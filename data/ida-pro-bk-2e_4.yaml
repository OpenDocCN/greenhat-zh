- en: Part IV. Extending IDA’s Capabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分. 扩展IDA的功能
- en: Chapter 15. IDA Scripting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章. IDA脚本
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: It is a simple fact that no application can meet every need of every user. It
    is just not possible to anticipate every potential use case that may arise. Application
    developers are faced with the choice of responding to an endless stream of feature
    requests or offering users a means to solve their own problems. IDA takes the
    latter approach by integrating scripting features that allow users to exercise
    a tremendous amount of programmatic control over IDA’s actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的事实，没有任何应用程序能够满足每个用户的每个需求。根本无法预测可能出现的每一个潜在用例。应用程序开发者面临着回应无休止的功能请求或为用户提供解决他们自己问题的手段的选择。IDA采取了后一种方法，通过集成脚本功能，允许用户对IDA的操作进行大量的程序性控制。
- en: Potential uses for scripts are infinite and can range from simple one-liners
    to full-blown programs that automate common tasks or perform complex analysis
    functions. From an automation standpoint, IDA scripts can be viewed as macros,^([[95](#ftn.CHP-15-FN-1)])
    while from an analysis point of view, IDA’s scripting languages serve as the query
    languages that provide programmatic access to the contents of an IDA database.
    IDA supports scripting using two different languages. IDA’s original, embedded
    scripting language is named *IDC*, perhaps because its syntax bears a close resemblance
    to C. Since the release of IDA 5.4,^([[96](#ftn.CHP-15-FN-2)]) integrated scripting
    with Python has also been supported through the integration of the IDAPython plug-in
    by Gergely Erdelyi.^([[97](#ftn.CHP-15-FN-3)]) For the remainder of this chapter
    we will cover the basics of writing and executing both IDC and Python scripts
    as well as some of the more useful functions available to script authors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的可能用途无限，可以从简单的单行命令到完整的程序，这些程序可以自动化常见任务或执行复杂分析功能。从自动化的角度来看，IDA脚本可以被视为宏，^([[95](#ftn.CHP-15-FN-1)])而从分析的角度来看，IDA的脚本语言作为查询语言，提供了对IDA数据库内容的程序性访问。IDA支持使用两种不同的语言进行脚本编写。IDA的原始、嵌入式脚本语言命名为*IDC*，可能是因为其语法与C语言非常相似。自IDA
    5.4版本发布以来，^([[96](#ftn.CHP-15-FN-2)))通过集成Gergely Erdelyi的IDAPython插件，也支持了与Python的集成脚本。在本章的剩余部分，我们将介绍编写和执行IDC和Python脚本的基本知识，以及一些对脚本作者更有用的函数。
- en: Basic Script Execution
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本脚本执行
- en: Before diving into the details of either scripting language, it is useful to
    understand the most common ways that scripts can be executed. Three menu options,
    File ▸ Script File, File ▸ IDC Command, and File ▸ Python Command^([[98](#ftn.CHP-15-FN-4)])
    are available to access IDA’s scripting engine. Selecting File ▸ Script File indicates
    that you wish to run a standalone script, at which point you are presented with
    a file-selection dialog that lets you choose the script to run. Each time you
    run a new script, the program is added to a list of recent scripts to provide
    easy access to edit or rerun the script. [Figure 15-1](ch15.html#the_recent_scripts_window
    "Figure 15-1. The Recent Scripts window") shows the Recent Scripts window accessible
    via the View ▸ Recent Scripts menu option.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解任何脚本语言之前，了解脚本最常见的执行方式是有用的。有三个菜单选项，文件▸脚本文件、文件▸IDC命令和文件▸Python命令^([[98](#ftn.CHP-15-FN-4)])，可用于访问IDA的脚本引擎。选择文件▸脚本文件表示您希望运行一个独立的脚本，此时您将看到一个文件选择对话框，允许您选择要运行的脚本。每次运行新的脚本时，程序都会添加到最近脚本列表中，以便轻松编辑或重新运行脚本。[图15-1](ch15.html#the_recent_scripts_window
    "图15-1. 最近脚本窗口")显示了通过视图▸最近脚本菜单选项可访问的最近脚本窗口。
- en: '![The Recent Scripts window](httpatomoreillycomsourcenostarchimages854265.png.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![最近脚本窗口](httpatomoreillycomsourcenostarchimages854265.png.jpg)'
- en: Figure 15-1. The Recent Scripts window
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-1. 最近脚本窗口
- en: Double-clicking a listed script causes the script to be executed. A pop-up,
    context-sensitive menu offers options to remove a script from the list or to open
    a script for editing using the editor specified under Options ▸ General on the
    Misc tab.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 双击列表中的脚本会导致脚本执行。一个弹出式、上下文相关的菜单提供了从列表中删除脚本或使用在“选项”▸“常规”选项卡下指定的编辑器打开脚本进行编辑的选项。
- en: As an alternative to executing a standalone script file, you may elect to open
    a script entry dialog using File ▸ IDC Command or File ▸ Python Command. [Figure 15-2](ch15.html#the_script_entry_dialog
    "Figure 15-2. The script entry dialog") shows the resulting script entry dialog
    (for an IDC script in this case), which is useful in situations where you wish
    to execute only a few statements but don’t want to go to the trouble of creating
    a standalone script file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为执行独立脚本文件的替代方案，你可以选择使用“文件”▸“IDC命令”或“文件”▸“Python命令”打开脚本输入对话框。[图15-2](ch15.html#the_script_entry_dialog
    "图15-2. 脚本输入对话框")显示了由此产生的脚本输入对话框（在这种情况下为IDC脚本），在只想执行几个语句而不想麻烦创建独立脚本文件的情况下非常有用。
- en: '![The script entry dialog](httpatomoreillycomsourcenostarchimages854268.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![脚本输入对话框](httpatomoreillycomsourcenostarchimages854268.png.jpg)'
- en: Figure 15-2. The script entry dialog
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-2. 脚本输入对话框
- en: Some restrictions apply to the types of statements that you can enter in the
    script dialog, but the dialog is very useful in cases where creating a full-blown
    script file is overkill.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对可以在脚本对话框中输入的语句类型有一些限制，但对话框在创建完整的脚本文件过于繁琐的情况下非常有用。
- en: The last way to easily execute script commands is to use IDA’s command line.
    The command line is available only in GUI versions of IDA, and its presence is
    controlled by the value of the `DISPLAY_COMMAND_LINE` option in *<IDADIR>/cfg/idagui.cfg*.
    The command line has been enabled by default since IDA 5.4\. [Figure 15-3](ch15.html#the_ida_command_line
    "Figure 15-3. The IDA command line") shows the command line as it appears in the
    lower-left corner of the IDA workspace, beneath the output window.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本命令的最后一种简单方法是使用IDA的命令行。命令行仅在IDA的GUI版本中可用，其存在由`DISPLAY_COMMAND_LINE`选项在`*<IDADIR>/cfg/idagui.cfg`中的值控制。自IDA
    5.4以来，命令行默认启用。[图15-3](ch15.html#the_ida_command_line "图15-3. IDA命令行")显示了命令行在IDA工作区左下角输出窗口下方的外观。
- en: '![The IDA command line](httpatomoreillycomsourcenostarchimages854271.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![IDA命令行](httpatomoreillycomsourcenostarchimages854271.png.jpg)'
- en: Figure 15-3. The IDA command line
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-3. IDA命令行
- en: The interpreter that will be used to execute the command line is labeled to
    the left of the command-line entry box. In [Figure 15-3](ch15.html#the_ida_command_line
    "Figure 15-3. The IDA command line"), the command line is configured to execute
    IDC statements. Clicking this label opens the pop-up menu shown in [Figure 15-3](ch15.html#the_ida_command_line
    "Figure 15-3. The IDA command line"), allowing either interpreter (IDC or Python)
    to be associated with the command line.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将用于执行命令行的解释器标签位于命令行输入框的左侧。在[图15-3](ch15.html#the_ida_command_line "图15-3. IDA命令行")中，命令行被配置为执行IDC语句。点击此标签将打开[图15-3](ch15.html#the_ida_command_line
    "图15-3. IDA命令行")中显示的弹出菜单，允许将IDC或Python解释器与命令行关联。
- en: Although the command line contains only a single line of text, you can enter
    multiple statements by separating each statement with a semicolon. As a convenience,
    the history of recent commands is accessible with the up arrow key. If you find
    yourself frequently needing to execute very short scripts, you will find the command
    line very useful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管命令行只包含一行文本，但你可以通过分号分隔每个语句来输入多个语句。为了方便，可以使用上箭头键访问最近命令的历史记录。如果你发现自己经常需要执行非常短的脚本，你会发现命令行非常有用。
- en: With a basic ability to execute scripts under our belts, it is time to focus
    on the specifics of IDA’s two available scripting languages, IDC and Python. We
    begin with a description of IDA’s native scripting language, IDC, and conclude
    with a discussion of IDA’s Python integration, which will rely heavily on the
    foundation built by the IDC sections that follow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了执行脚本的基本能力之后，现在是时候关注IDA提供的两种脚本语言的细节了，即IDC和Python。我们首先描述IDA的本地脚本语言IDC，然后讨论IDA的Python集成，这将严重依赖于以下IDC部分建立的基础。
- en: '* * *'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[95](#CHP-15-FN-1)]) Many applications offer facilities that allow users
    to record sequences of actions into a single complex action called a *macro*.
    Replaying or triggering a macro causes the entire sequence of recorded steps to
    be executed. Macros provided an easy means to automate a complex series of actions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[95](#CHP-15-FN-1)]) 许多应用程序提供允许用户将一系列操作记录到一个称为*宏*的单一复杂操作中的功能。重新播放或触发宏会导致记录的所有步骤序列被执行。宏提供了一种自动化复杂操作序列的简单方法。
- en: ^([[96](#CHP-15-FN-2)]) For a comprehensive list of features introduced with
    each new version of IDA, visit [http://www.hex-rays.com/idapro/idanew48.htm](http://www.hex-rays.com/idapro/idanew48.htm).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[96](#CHP-15-FN-2)]) 要获取每个新版本IDA引入的功能的完整列表，请访问 [http://www.hex-rays.com/idapro/idanew48.htm](http://www.hex-rays.com/idapro/idanew48.htm)。
- en: ^([[97](#CHP-15-FN-3)]) See [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[97](#CHP-15-FN-3)]) 请参阅 [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
- en: ^([[98](#CHP-15-FN-4)]) This option is only available if Python is properly
    installed. Refer to [Chapter 3](ch03.html "Chapter 3. IDA Pro Background") for
    details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[98](#CHP-15-FN-4)]) 此选项仅在Python正确安装的情况下可用。有关详细信息，请参阅[第3章](ch03.html "第3章。IDA
    Pro背景")。
- en: The IDC Language
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDC语言
- en: Unlike for some other aspects of IDA, a reasonable amount of help is available
    for the IDC language in IDA’s help system. Topics available at the top level of
    the help system include *IDC language*, which covers the basics of IDC syntax,
    and *Index of IDC functions*, which provides an exhaustive list of built-in functions
    available to IDC programmers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与IDA中其他一些方面不同，IDA的帮助系统中为IDC语言提供了一定程度的帮助。帮助系统顶层可用的主题包括*IDC语言*，它涵盖了IDC语法的基础知识，以及*IDC函数索引*，它提供了IDC程序员可用的内置函数的详尽列表。
- en: IDC is a scripting language that borrows most of its syntactic elements from
    C. Beginning with IDA 5.6, IDC actually takes on more of the flavor of C++ with
    the introduction of object-oriented features and exception handling. Because of
    its similarity to C and C++, we will describe IDC in terms of these languages
    and focus primarily on where IDC differs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: IDC是一种脚本语言，它从C语言中借用了大部分的语法元素。从IDA 5.6开始，随着面向对象功能和异常处理的引入，IDC实际上更多地具有了C++的风格。由于其与C和C++的相似性，我们将用这些语言来描述IDC，并主要关注IDC与这些语言的不同之处。
- en: IDC Variables
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC变量
- en: IDC is a loosely typed language, meaning that variables have no explicit type.
    The three primary datatypes used in IDC are integers (IDA documentation uses the
    type name *long*), strings, and floating point values, with the overwhelming majority
    of operations taking place on integers and strings. Strings are treated as a native
    datatype in IDC, and there is no need to keep track of the space required to store
    a string or whether a string is null terminated or not. Beginning with IDA 5.6,
    IDC incorporates a number of additional variable types, including objects, references,
    and function pointers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: IDC是一种弱类型语言，这意味着变量没有显式的类型。IDC中使用的三个主要数据类型是整数（IDA文档使用类型名*long*）、字符串和浮点值，绝大多数操作都是在整数和字符串上进行的。在IDC中，字符串被视为原生数据类型，无需跟踪存储字符串所需的空间或字符串是否以空字符终止。从IDA
    5.6开始，IDC包含了一些额外的变量类型，包括对象、引用和函数指针。
- en: 'All variables must be declared prior to their use. IDC supports local variables
    and, since IDA 5.4, global variables as well. The IDC keyword `auto` is used to
    introduce a local variable declaration, and local variable declarations may include
    initial values. The following examples show legal IDC local variable declarations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量在使用之前都必须声明。IDC支持局部变量，并且从IDA 5.4开始也支持全局变量。IDC关键字`auto`用于引入局部变量声明，局部变量声明可以包括初始值。以下示例显示了合法的IDC局部变量声明：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: IDC recognizes C-style multiline comments using `/* */` and C++–style line-terminating
    comments using `//`. Also, note that several variables may be declared in a single
    statement and that all statements in IDC are terminated using a semicolon (as
    in C). IDC does not support C-style arrays (slices are introduced in IDA 5.6),
    pointers (though references are supported beginning with IDA 5.6), or complex
    datatypes such as structs and unions. Classes are introduced in IDA 5.6.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: IDC识别使用`/* */`的C风格多行注释和使用`//`的C++风格行终止注释。此外，请注意，可以在单个语句中声明多个变量，并且IDC中的所有语句都使用分号（如C语言中一样）终止。IDC不支持C风格数组（切片是在IDA
    5.6中引入的），指针（尽管从IDA 5.6开始支持引用），或复杂数据类型，如结构和联合。类是在IDA 5.6中引入的。
- en: Global variable declarations are introduced using the `extern` keyword, and
    their declarations are legal both inside and outside of any function definition.
    It is not legal to provide an initial value when a global variable is declared.
    The following listing shows the declaration of two global variables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extern`关键字引入全局变量声明，并且它们的声明在函数定义内外都是合法的。在声明全局变量时提供初始值是不合法的。以下列表显示了两个全局变量的声明。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Global variables are allocated the first time they are encountered during an
    IDA session and persist as long as that session remains active, regardless of
    the number of databases that you may open and close.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量在 IDA 会话期间首次遇到时分配，并且只要该会话保持活跃，就会持续存在，无论你打开和关闭了多少数据库。
- en: IDC Expressions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC 表达式
- en: 'With a few exceptions, IDC supports virtually all of the arithmetic and logical
    operators available in C, including the ternary operator (`? :`). Compound assignment
    operators of the form `op=` (`+=`, `*=`, `>>=`, and the like) are not supported.
    The comma operator is supported beginning with IDA 5.6\. All integer operands
    are treated as signed values. This affects integer comparisons (which are always
    signed) and the right-shift operator (`>>`), which always performs an arithmetic
    shift with sign bit replication. If you require logical right shifts, you must
    implement them yourself by masking off the top bit of the result, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了少数例外，IDC 支持几乎所有在 C 中可用的算术和逻辑运算符，包括三元运算符 (`? :`)。不支持形式为 `op=` 的复合赋值运算符（例如 `+=`,
    `*=`, `>>=` 等）。逗号运算符从 IDA 5.6 开始支持。所有整数操作数都被视为有符号值。这影响了整数比较（总是有符号的）和右移运算符 (`>>`)，它总是执行带符号位复制的算术右移。如果你需要逻辑右移，你必须自己实现，如以下示例所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because strings are a native type in IDC, some operations on strings take on
    a different meaning than they might in C. The assignment of a string operand into
    a string variable results in a string copy operation; thus there is no need for
    string copying or duplicating functions such as C’s `strcpy` and `strdup`. Also,
    the addition of two string operands results in the concatenation of the two operands;
    thus “Hello” + “World” yields “HelloWorld”; there is no need for a concatenation
    function such as C’s `strcat`. Starting with IDA 5.6, IDC offers a slice operator
    for use with strings. Python programmers will be familiar with slices, which basically
    allow you to specify subsequences of array-like variables. Slices are specified
    using square brackets and a start (inclusive) and end (exclusive) index. At least
    one index is required. The following listing demonstrates the use of IDC slices.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串在 IDC 中是原生类型，因此字符串上的某些操作在 IDC 中的含义与在 C 中可能不同。将字符串操作数赋值给字符串变量会导致字符串复制操作；因此不需要字符串复制或复制函数，如
    C 的 `strcpy` 和 `strdup`。此外，两个字符串操作数的相加会导致两个操作数的连接；因此“Hello” + “World” 得到 “HelloWorld”；不需要连接函数，如
    C 的 `strcat`。从 IDA 5.6 开始，IDC 为字符串提供了切片运算符。Python 程序员将熟悉切片，它基本上允许你指定类似数组的变量的子序列。切片使用方括号和起始（包含）和结束（不包含）索引来指定。至少需要一个索引。以下列表展示了
    IDC 切片的使用。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that while there are no array datatypes available in IDC, the slice operator
    effectively allows you to treat IDC strings as if they were arrays.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 IDC 中没有数组数据类型，但切片运算符实际上允许你将 IDC 字符串视为数组来处理。
- en: IDC Statements
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC 语句
- en: 'As in C, all simple statements are terminated with a semicolon. The only C-style
    compound statement that IDC does not support is the `switch` statement. When using
    `for` loops, keep in mind that IDC does not support compound assignment operators,
    which may affect you if you wish to count by anything other than one, as shown
    here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 一样，所有简单语句都以分号结束。IDC 不支持的唯一 C 风格的复合语句是 `switch` 语句。在使用 `for` 循环时，请注意，IDC
    不支持复合赋值运算符，这可能影响你使用非一作为计数单位的愿望，如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With IDA 5.6, IDC introduces `try`/`catch` blocks and the associated `throw`
    statement, which are syntactically similar to C++ exceptions.^([[99](#ftn.CHP-15-FN-5)])
    IDA’s built-in help contains specifics on IDC’s exception-handling implementation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA 5.6 中，IDC 引入了 `try`/`catch` 块以及相关的 `throw` 语句，这些在语法上与 C++ 异常类似.^([[99](#ftn.CHP-15-FN-5)])
    IDA 的内置帮助文档包含了关于 IDC 异常处理实现的详细信息。
- en: 'For compound statements, IDC utilizes the same bracing (`{}`) syntax and semantics
    as C. Within a braced block, it is permissible to declare new variables as long
    as the variable declarations are the first statements within the block. However,
    IDC does not rigorously enforce the scope of the newly introduced variables, because
    such variables may be referenced beyond the block in which they were declared.
    Consider the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复合语句，IDC 使用与 C 相同的花括号 (`{}`) 语法和语义。在一个花括号块内，只要变量声明是该块内的第一条语句，就可以声明新的变量。然而，IDC
    并不严格限制新引入变量的作用域，因为这些变量可能在其声明块之外被引用。考虑以下示例：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output statements (the `Message` function is analogous to C’s `printf`)
    will inform us that `x = 10` and `y = 0`. Given that IDC does not strictly enforce
    the scope of `x`, it is not terribly surprising that we are allowed to print the
    value of `x`. What is somewhat surprising is that `y` is accessible at all, given
    that the block in which `y` is declared is never executed. This is simply a quirk
    of IDC. Note that while IDC may loosely enforce variable scoping within a function,
    variables declared within one function continue to remain inaccessible in any
    other function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出语句（`Message` 函数类似于 C 语言的 `printf` 函数）会告诉我们 `x = 10` 和 `y = 0`。鉴于 IDC 不严格强制执行
    `x` 的作用域，我们被允许打印 `x` 的值并不令人特别惊讶。但有一点令人有些惊讶的是，`y` 竟然可以访问，考虑到声明 `y` 的代码块从未被执行。这仅仅是
    IDC 的一个特性。请注意，尽管 IDC 可能会松散地强制函数内的变量作用域，但一个函数内声明的变量在其他任何函数中仍然无法访问。
- en: IDC Functions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC 函数
- en: 'IDC supports user-defined functions in standalone programs (*.idc* files) only.
    User-defined functions are not supported when using the IDC command dialog (see
    [USING THE IDC COMMAND DIALOG](ch15s02.html#using_the_idc_command_dialog "USING
    THE IDC COMMAND DIALOG") in [USING THE IDC COMMAND DIALOG](ch15s02.html#using_the_idc_command_dialog
    "USING THE IDC COMMAND DIALOG")). IDC’s syntax for declaring user-defined functions
    is where it differs most from C. The `static` keyword is used to introduce a user-defined
    function, and the function’s parameter list consists solely of a comma-separated
    list of parameter names. The following listing details the basic structure of
    a user-defined function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: IDC 仅支持在独立程序（*.idc* 文件）中定义用户自定义函数。当使用 IDC 命令对话框时（参见[使用 IDC 命令对话框](ch15s02.html#using_the_idc_command_dialog
    "使用 IDC 命令对话框")），不支持用户自定义函数。[使用 IDC 命令对话框](ch15s02.html#using_the_idc_command_dialog
    "使用 IDC 命令对话框")）。IDC 声明用户自定义函数的语法与 C 语言最不同。使用 `static` 关键字引入用户自定义函数，函数的参数列表仅由逗号分隔的参数名列表组成。以下列表详细说明了用户自定义函数的基本结构：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Prior to IDA 5.6, all function parameters are strictly call-by-value. Call-by-reference
    parameter passing was introduced with IDA 5.6\. Interestingly, whether a parameter
    is passed using call-by-value or call-by-reference is determined by the manner
    in which the function is called, not the manner in which the function is declared.
    The unary `&` operator is used in a function call (*not* the function declaration)
    to denote that an argument is being passed by reference. The following examples
    show invocations of the `my_func` function from the previous listing making use
    of both call-by-value and call-by-reference parameter passing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA 5.6 之前，所有函数参数都是严格按值传递的。在 IDA 5.6 中引入了按引用传递参数。有趣的是，参数是按值传递还是按引用传递，取决于函数的调用方式，而不是函数的声明方式。在函数调用中（*不是*函数声明）使用一元
    `&` 操作符来表示参数是按引用传递的。以下示例展示了从上一个列表中调用 `my_func` 函数，使用了按值传递和按引用传递参数。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Function declarations never indicate whether a function explicitly returns a
    value or what type of value is returned when a function does yield a result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明永远不会指示函数是否显式返回值，或者当函数产生结果时返回什么类型的值。
- en: USING THE IDC COMMAND DIALOG
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDC 命令对话框
- en: The IDC command dialog offers a simple interface for entering short sequences
    of IDC code. The command dialog is a great tool for rapidly entering and testing
    new scripts without the hassle of creating a standalone script file. The most
    important thing to keep in mind when using the command dialog is that you *must*
    not define any functions inside the dialog. In essence, IDA wraps your statements
    within a function and then calls that function in order to execute your statements.
    If you were to define a function within the dialog, the net effect would be a
    function defined within a function, and since nested function declarations are
    not allowed in IDC (or in C for that matter), a syntax error would result.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: IDC 命令对话框提供了一个简单的界面，用于输入短序列的 IDC 代码。命令对话框是一个快速输入和测试新脚本的好工具，无需创建独立的脚本文件。在使用命令对话框时，最重要的是要记住，*必须*不要在对话框内定义任何函数。本质上，IDA
    将你的语句包裹在一个函数中，然后调用该函数以执行你的语句。如果你在对话框内定义了一个函数，最终效果将是一个函数内定义的函数，由于 IDC（或实际上 C 语言）不允许嵌套函数声明，这将导致语法错误。
- en: When you wish to return a value from a function, use a `return` statement to
    return the desired value. It is permissible to return entirely different datatypes
    from different paths of execution within a function. In other words, a function
    may return a string in some cases, while in other cases the same function may
    return an integer. As in C, use of a `return` statement within a function is optional.
    However, unlike C, any function that does not explicitly return a value implicitly
    returns the value zero.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望从函数中返回一个值时，使用`return`语句来返回所需的值。在函数的不同执行路径中返回完全不同的数据类型是允许的。换句话说，一个函数在某些情况下可能返回一个字符串，而在其他情况下，同一个函数可能返回一个整数。与C语言一样，在函数中使用`return`语句是可选的。然而，与C语言不同，任何没有显式返回值的函数隐式返回的值是零。
- en: As a final note, beginning with IDA 5.6, functions take a step closer to becoming
    first-class objects in IDC. It is now possible to pass function references as
    arguments to other functions and return function references as the result of a
    function. The following listing demonstrates the use of function parameters and
    functions as return values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，从IDA 5.6版本开始，函数在IDC中更接近成为一等对象。现在可以将函数引用作为参数传递给其他函数，并将函数引用作为函数的结果返回。以下列表展示了函数参数和函数作为返回值的使用。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: IDC Objects
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC对象
- en: Another feature introduced in IDA 5.6 is the ability to define classes and,
    as a result, have variables that represent objects. In the discussion that follows,
    we assume that you have some familiarity with an object-oriented programming language
    such as C++ or Java.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 5.6版本引入的另一个功能是定义类的能力，从而拥有表示对象变量的变量。在接下来的讨论中，我们假设你对面向对象编程语言（如C++或Java）有一定的了解。
- en: IDA SCRIPTING EVOLVES
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: IDA脚本演变
- en: If you haven’t gotten the idea that a large number of changes to IDC were introduced
    with IDA 5.6, then you haven’t been paying attention. Following the integration
    of IDAPython in IDA 5.4, Hex-Rays looked to rejuvenate IDC, resulting in many
    of the features mentioned in this chapter being introduced in IDA 5.6\. Along
    the way, JavaScript was even contemplated as a potential addition to IDA’s scripting
    lineup.^([[100](#ftn.CHP-15-FN-6)]).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有意识到IDC在IDA 5.6版本中引入了大量的更改，那么你可能没有注意到。在IDA 5.4版本中集成IDAPython之后，Hex-Rays寻求复兴IDC，导致本章中提到的许多功能在IDA
    5.6版本中引入。在这个过程中，甚至考虑将JavaScript作为IDA脚本系列中可能的补充。（[100](#ftn.CHP-15-FN-6)）
- en: IDC defines a root class named `object` from which all classes ultimately derive,
    and single inheritance is supported when creating new classes. IDC does not make
    use of access specifiers such as `public` and `private`; all class members are
    effectively public. Class declarations contain only the definitions of the class’s
    member functions. In order to create data members within a class, you simply create
    an assignment statement that assigns a value to the data member. The following
    listing will help to clarify.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: IDC定义了一个名为`object`的根类，所有类最终都从这个类派生出来，创建新类时支持单继承。IDC不使用`public`和`private`等访问修饰符；所有类成员都是公开的。类声明只包含类的成员函数的定义。为了在类中创建数据成员，你只需创建一个将值赋给数据成员的赋值语句。以下列表将有助于阐明。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more information on IDC classes and their syntax, refer to the appropriate
    section within IDA’s built-in help file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于IDC类及其语法的更多信息，请参阅IDA内置帮助文件中的相应部分。
- en: IDC Programs
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC程序
- en: For any scripting applications that require more than a few IDC statements,
    you are likely to want to create a standalone IDC program file. Among other things,
    saving your scripts as programs gives you some measure of persistence and portability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要超过几个IDC语句的任何脚本应用程序，你可能会想创建一个独立的IDC程序文件。除了其他事情之外，将你的脚本保存为程序为你提供了一定程度的持久性和可移植性。
- en: 'IDC program files require you to make use of user-defined functions. At a minimum,
    you must define a function named `main` that takes no arguments. In most cases,
    you will also want to include the file *idc.idc* in order to pick up useful macro
    definitions that it contains. The following listing details the components of
    a minimal IDC program file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: IDC程序文件要求你使用用户定义的函数。至少，你必须定义一个名为`main`的函数，该函数不接受任何参数。在大多数情况下，你还会想包含文件`*idc.idc*`，以便获取其中包含的有用宏定义。以下列表详细说明了最小IDC程序文件的组件：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'IDC recognizes the following C-style preprocessor directives:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: IDC识别以下C风格预处理器指令：
- en: '**`#include`** <file>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**`#include`** `<file>`'
- en: Includes the named file in the current file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前文件中包含指定的文件。
- en: '**`#define`** <name> [optional value]'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**`#define`** <名称> [可选值]'
- en: Creates a macro named *name* and optionally assigns it the specified value.
    IDC predefines a number of macros that may be used to test various aspects of
    your script’s execution environment. These include *_NT_*, *_LINUX_*, *_MAC_*,
    *_GUI_*, and `_`*TXT_* among others. See the *Predefined symbols* section of the
    IDA help file for more information on these and other symbols.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *名称* 的宏，并可选择将其指定值分配给它。IDC预定义了多个宏，可用于测试脚本执行环境的各个方面。这些包括 *_NT_*, *_LINUX_*,
    *_MAC_*, *_GUI_*, 和 `_TXT_*` 等等。有关这些和其他符号的更多信息，请参阅IDA帮助文件的*预定义符号*部分。
- en: '**`#ifdef`** <name>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**`#ifdef`** <名称>'
- en: Tests for the existence of the named macro and optionally processes any statements
    that follow if the named macro exists.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否存在名为的宏，如果存在，则可选地处理任何后续语句。
- en: '**`#else`**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**`#else`**'
- en: Optionally used in conjunction with an `#ifdef` to provide an alternative set
    of statements to process in the event the named macro does not exist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可与`#ifdef`一起使用，在名为的宏不存在时提供一组备选语句进行处理。
- en: '**`#endif`**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**`#endif`**'
- en: This is a required terminator for an `#ifdef` or `#ifdef/#else` block.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`#ifdef`或`#ifdef/#else`块的必需终止符。
- en: '**`#undef`** <name>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**`#undef`** <名称>'
- en: Deletes the named macro.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 删除指定的宏。
- en: Error Handling in IDC
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC中的错误处理
- en: 'No one is ever going to praise IDC for its error-reporting capabilities. There
    are two types of errors that you can expect to encounter when running IDC scripts:
    parsing errors and runtime errors.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人会赞扬IDC的错误报告能力。在运行IDC脚本时，你可以期望遇到两种类型的错误：解析错误和运行时错误。
- en: '*Parsing errors* are those errors that prevent your program from ever being
    executed and include such things as syntax errors, references to undefined variables,
    and supplying an incorrect number of arguments to a function. During the parsing
    phase, IDC reports only the first parsing error that it encounters. In some cases,
    error messages correctly identify both the location and the type of an error (`hello_world.idc,20:
    Missing semicolon`), while in other cases, error messages offer no real assistance
    (`Syntax error near: <END>`). Only the first error encountered during parsing
    is reported. As a result, in a script with 15 syntax errors, it may take 15 attempts
    at running the script before you are informed of every error.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*解析错误*是那些阻止你的程序执行的错误，包括语法错误、对未定义变量的引用以及向函数提供错误数量的参数。在解析阶段，IDC只报告它遇到的第一个解析错误。在某些情况下，错误消息正确地标识了错误的位置和类型（`hello_world.idc,20:
    缺少分号`），而在其他情况下，错误消息没有提供真正的帮助（`语法错误附近：<END>`）。只报告解析过程中遇到的第一个错误。因此，在一个有15个语法错误的脚本中，可能需要运行15次脚本才能通知你每个错误。'
- en: '*Runtime errors* are generally encountered less frequently than parsing errors.
    When encountered, runtime errors cause a script to terminate immediately. One
    example of a runtime error results from an attempt to call an undefined function
    that for some reason is not detected when the script is initially parsed. Another
    problem arises with scripts that take an excessive amount of time to execute.
    Once a script is started, there is no easy way to terminate the script if it inadvertently
    ends up in an infinite loop or simply takes longer to execute than you are willing
    to wait. Once a script has executed for more than two to three seconds, IDA displays
    the dialog shown in [Figure 15-4](ch15s02.html#script_cancellation_dialog "Figure 15-4. Script
    cancellation dialog").'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时错误*通常比解析错误遇到的频率低。当遇到时，运行时错误会导致脚本立即终止。一个运行时错误的例子是尝试调用一个未定义的函数，这个函数在脚本最初解析时由于某种原因没有被检测到。另一个问题是脚本执行时间过长。一旦脚本开始执行，如果它意外地陷入无限循环或执行时间超过你愿意等待的时间，就没有简单的方法来终止脚本。一旦脚本执行超过两到三秒，IDA会显示[图15-4](ch15s02.html#script_cancellation_dialog
    "图15-4. 脚本取消对话框")中所示的对话框。'
- en: This dialog is the only means by which you can terminate a script that fails
    to terminate properly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框是终止无法正确终止的脚本的唯一方式。
- en: '![Script cancellation dialog](httpatomoreillycomsourcenostarchimages854274.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![脚本取消对话框](httpatomoreillycomsourcenostarchimages854274.png.jpg)'
- en: Figure 15-4. Script cancellation dialog
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-4. 脚本取消对话框
- en: Debugging is another of IDC’s weak points. Other than liberal use of output
    statements, there is no way to debug IDC scripts. With the introduction of exception
    handling (`try/catch`) in IDA 5.6, it does become possible to build more robust
    scripts that can terminate or continue as gracefully as you choose.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是 IDC 的另一个弱点。除了大量使用输出语句外，没有其他方法可以调试 IDC 脚本。随着 IDA 5.6 中异常处理（`try/catch`）的引入，现在可以构建更健壮的脚本，可以优雅地终止或继续，就像你选择的那样。
- en: Persistent Data Storage in IDC
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDC 中的持久数据存储
- en: Perhaps you are the curious type who, not trusting that we would provide sufficient
    coverage of IDA’s scripting capability, raced off to see what the IDA help system
    has to say on the subject. If so, welcome back, and if not, we appreciate you
    sticking with us this far. In any case, somewhere along the way you may have acquired
    knowledge that claims that IDC does in fact support arrays, in which case you
    must surely be questioning the quality of this book. We urge you to give us a
    chance to sort out this potential confusion.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你是那种好奇的类型，不相信我们会提供足够的 IDA 脚本功能覆盖，所以匆匆忙忙地去查看 IDA 帮助系统对这个主题有什么说法。如果是这样，欢迎回来，如果不是，我们感谢你一直坚持到现在。无论如何，在某个地方，你可能获得了关于
    IDC 实际支持数组的知识，在这种情况下，你肯定在质疑这本书的质量。我们敦促你给我们一个机会来澄清这种潜在的混淆。
- en: As mentioned previously, IDC does not support arrays in the traditional sense
    of declaring a large block of storage and then using a subscript notation to access
    individual items within that block. However, IDA’s documentation on scripting
    does mention something called *global persistent arrays*. IDC global arrays are
    better thought of as *persistent named objects*. The objects just happen to be
    sparse arrays.^([[101](#ftn.CHP-15-FN-7)]) Global arrays are stored within an
    IDA database and are persistent across script invocations and IDA sessions. Data
    is stored in global arrays by specifying an index and a data value to be stored
    at the specified index in the array. Each element in an array can simultaneously
    hold one integer value and one string value. IDC’s global arrays provide no means
    for storing floating point values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，IDC 不支持传统意义上的数组，即声明一个大块存储空间，然后使用下标符号来访问该块中的单个项目。然而，IDA 的脚本文档中提到了一种称为 *全局持久数组*
    的东西。IDC 的全局数组最好被视为 *持久命名对象*。这些对象恰好是稀疏数组。[^([101](#ftn.CHP-15-FN-7))] 全局数组存储在 IDA
    数据库中，并且跨脚本调用和 IDA 会话持久存在。数据通过指定索引和要存储在数组指定索引处的数据值来存储在全局数组中。数组中的每个元素可以同时存储一个整数值和一个字符串值。IDC
    的全局数组不提供存储浮点值的方法。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the overly curious, IDA’s internal mechanism for storing persistent arrays
    is called a netnode. While the array-manipulation functions described next provide
    an abstracted interface to netnodes, lower-level access to netnode data is available
    using the IDA SDK, which is discussed, along with netnodes, in [Chapter 16](ch16.html
    "Chapter 16. The IDA Software Development Kit").
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过于好奇的人来说，IDA 存储持久数组的内部机制被称为 netnode。虽然接下来描述的数组操作函数提供了一个对 netnode 的抽象接口，但可以使用
    IDA SDK 以较低级别访问 netnode 数据，SDK 与 netnode 一起在 [第 16 章](ch16.html "第 16 章。IDA 软件开发套件")
    中讨论。
- en: 'All interaction with global arrays occurs through the use of IDC functions
    dedicated to array manipulation. Descriptions of these functions follow:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与全局数组的交互都通过使用 IDC 专门用于数组操作的函数来完成。以下是对这些函数的描述：
- en: '**`long CreateArray(string name)`**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long CreateArray(string name)`**'
- en: This function creates a persistent object with the specified name. The return
    value is an integer handle required for all future access to the array. If the
    named object already exists, the return value is −1.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个具有指定名称的持久对象。返回值是用于所有未来数组访问所需的整数句柄。如果指定的对象已经存在，则返回值是 −1。
- en: '**`long GetArrayId(string name)`**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetArrayId(string name)`**'
- en: Once an array has been created, subsequent access to the array must be done
    through an integer handle, which can be obtained by looking up the array name.
    The return value for this function is an integer handle to be used for all future
    interaction with the array. If the named array does not exist, the return value
    is −1.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个数组，后续对数组的访问必须通过一个整数句柄来完成，这个句柄可以通过查找数组名称来获得。该函数的返回值是一个整数句柄，用于所有未来的数组交互。如果指定的数组不存在，则返回值是
    −1。
- en: '**`long SetArrayLong(long id, long idx, long value)`**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long SetArrayLong(long id, long idx, long value)`**'
- en: Stores an integer `value` into the array referred to by `id` at the position
    specified by `idx`. The return value is 1 on success or 0 on failure. The operation
    will fail if the array `id` is invalid.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数 `value` 存储到由 `id` 引用的数组中，位置由 `idx` 指定。成功时返回 1，失败时返回 0。如果数组 `id` 无效，则操作将失败。
- en: '**`long SetArrayString(long id, long idx, string str)`**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long SetArrayString(long id, long idx, string str)`**'
- en: Stores a string `value` into the array referred to by `id` at the position specified
    by `idx`. The return value is 1 on success or 0 on failure. The operation will
    fail if the array `id` is invalid.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串 `value` 存储到由 `id` 引用的数组中，位置由 `idx` 指定。成功时返回 1，失败时返回 0。如果数组 `id` 无效，则操作将失败。
- en: '**`string or long GetArrayElement(long tag, long id, long idx)`**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string or long GetArrayElement(long tag, long id, long idx)`**'
- en: While there are distinct functions for storing data into an array depending
    on the type of data to be stored, there is only one function for retrieving data
    from an array. This function retrieves either an integer or a string value from
    the specified index (`idx`) in the specified array (`id`). Whether an integer
    or a string is retrieved is determined by the value of the `tag` parameter, which
    must be one of the constants `AR_LONG` (to retrieve an integer) or `AR_STR` (to
    retrieve a string).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然根据要存储的数据类型有专门用于将数据存储到数组中的函数，但只有一个函数用于从数组中检索数据。此函数从指定的数组（`id`）中指定的索引（`idx`）检索整数或字符串值。检索整数或字符串由
    `tag` 参数的值决定，该值必须是常量 `AR_LONG`（用于检索整数）或 `AR_STR`（用于检索字符串）之一。
- en: '**`long DelArrayElement(long tag, long id, long idx)`**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long DelArrayElement(long tag, long id, long idx)`**'
- en: Deletes the contents of the specified array location from the specified array.
    The value of `tag` determines whether the integer value or string value associated
    with the specified index is deleted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从指定的数组中删除指定位置的数组内容。`tag` 的值决定是否删除与指定索引关联的整数值或字符串值。
- en: '**`void DeleteArray(long id)`**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void DeleteArray(long id)`**'
- en: Deletes the array referenced by `id` and all of its associated contents. Once
    an array has been created, it continues to exist, even after a script terminates,
    until a call is made to `DeleteArray` to remove the array from the database in
    which it was created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 删除由 `id` 引用的数组及其所有相关内容。一旦创建了一个数组，它将继续存在，即使在脚本终止后，直到调用 `DeleteArray` 从创建它的数据库中删除数组。
- en: '**`long RenameArray(long id, string newname)`**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long RenameArray(long id, string newname)`**'
- en: Renames the array referenced by `id` to `newname`. Returns 1 if successful or
    0 if the operation fails.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将由 `id` 引用的数组重命名为 `newname`。如果操作成功则返回 1，如果操作失败则返回 0。
- en: Possible uses for global arrays include approximating global variables, approximating
    complex datatypes, and providing persistent storage across script invocations.
    Global variables for a script are simulated by creating a global array when the
    script begins and storing global values in the array. These global values are
    shared either by passing the array handle to functions requiring access to the
    values or by requiring any function that requires access to perform a name lookup
    for the desired array.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 全局数组的可能用途包括近似全局变量、近似复杂数据类型以及在脚本调用之间提供持久存储。脚本的全局变量通过在脚本开始时创建全局数组并在数组中存储全局值来模拟。这些全局值通过将数组句柄传递给需要访问这些值的函数或要求任何需要访问的函数执行所需数组的名称查找来共享。
- en: Values stored in an IDC global array persist for the lifetime of the database
    in which the script was executed. You may test for the existence of an array by
    examining the return value of the `CreateArray` function. If the values stored
    in an array are applicable only to a specific invocation of a script, then the
    array should be deleted before the script terminates. Deleting the array ensures
    that no global values carry over from one execution of a script to a subsequent
    execution of the same script.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 IDC 全局数组中的值在脚本执行的生命周期内持续存在。您可以通过检查 `CreateArray` 函数的返回值来测试数组的存在。如果数组中存储的值仅适用于脚本的一次特定调用，则应在脚本终止之前删除该数组。删除数组确保没有全局值从一个脚本的执行延续到同一脚本的后续执行。
- en: '* * *'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[99](#CHP-15-FN-5)]) See [http://www.cplusplus.com/doc/tutorial/exceptions/](http://www.cplusplus.com/doc/tutorial/exceptions/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[99](#CHP-15-FN-5)]) 查看 [http://www.cplusplus.com/doc/tutorial/exceptions/](http://www.cplusplus.com/doc/tutorial/exceptions/).
- en: ^([[100](#CHP-15-FN-6)]) See [http://www.hexblog.com/?p=101](http://www.hexblog.com/?p=101)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[100](#CHP-15-FN-6)]) 查看 [http://www.hexblog.com/?p=101](http://www.hexblog.com/?p=101)
- en: ^([[101](#CHP-15-FN-7)]) Sparse arrays do not necessarily preallocate space
    for the entire array, nor are they limited to a particular maximum index. Instead,
    space for array elements is allocated on an as-needed basis when elements are
    added to the array.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[101](#CHP-15-FN-7)]) 稀疏数组不一定为整个数组预分配空间，也不受特定最大索引的限制。相反，当向数组添加元素时，将根据需要为数组元素分配空间。
- en: Associating IDC Scripts with Hotkeys
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 IDC 脚本与热键关联
- en: 'Occasionally you may develop a script so amazing in its utility that you must
    have access to it with a keystroke or two. When this happens, you will want to
    assign a hotkey sequence that you can use to quickly activate your script. Fortunately
    IDA provides a simple means to do this. Every time IDA is launched, the script
    contained in *<IDADIR>/idc/ida.idc* is executed. The default version of this script
    contains an empty `main` function and thus does nothing. To associate a hotkey
    with one of your scripts, you need to add two lines to *ida.idc*. The first line
    you must add is an `include` directive to include your script file in *ida.idc*.
    The second line you must add is a call, within `main`, to the `AddHotkey` function
    to associate a specific hotkey with your amazing IDC function. This might leave
    *ida.idc* looking like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能会开发出如此出色的脚本，以至于您必须通过几个按键来访问它。当这种情况发生时，您将希望分配一个热键序列，以便您可以快速激活您的脚本。幸运的是，IDA
    提供了一种简单的方法来实现这一点。每次启动 IDA 时，都会执行包含在 *<IDADIR>/idc/ida.idc* 中的脚本。此脚本的默认版本包含一个空的
    `main` 函数，因此不会执行任何操作。要将热键与您的脚本之一关联，您需要向 *ida.idc* 中添加两行。您必须添加的第一行是 `include` 指令，用于将您的脚本文件包含在
    *ida.idc* 中。您必须添加的第二行是在 `main` 中调用 `AddHotkey` 函数，以将特定的热键与您惊人的 IDC 函数关联。这可能会使
    *ida.idc* 看起来像这样：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the hotkey you are attempting to associate with your script has already been
    assigned to another IDA action (menu hotkey or plug-in activation sequence), `AddHotkey`
    silently fails with no way to detect the failure other than the fact that your
    function fails to execute when your hotkey sequence is activated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试关联到脚本的热键已经被分配给了另一个 IDA 动作（菜单热键或插件激活序列），则 `AddHotkey` 将静默失败，除了您在激活热键序列时函数无法执行的事实外，没有其他方式可以检测到失败。
- en: Two important points here are that the standard include directory for IDC scripts
    is *<IDADIR>/idc* and that you must not name your script function `main`. If you
    want IDA to find your script easily, you can copy it into *<IDADIR>/idc*. If you
    intend to leave your script file in another location, then you will need to specify
    the full path to your script in the `include` statement. While testing your script,
    it will be useful to run your script as a standalone program with a `main` function.
    Once you are ready to associate your script with a hotkey, however, you cannot
    use the name `main`, because it will conflict with the `main` function in *ida.idc*.
    You must rename your `main` function and use the new name in the call to `AddHotkey`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的点：IDC 脚本的标准包含目录是 *<IDADIR>/idc*，并且您不得将您的脚本函数命名为 `main`。如果您希望 IDA 能够轻松找到您的脚本，您可以将它复制到
    *<IDADIR>/idc* 中。如果您打算将您的脚本文件留在另一个位置，那么您需要在 `include` 语句中指定脚本的全路径。在测试您的脚本时，将脚本作为具有
    `main` 函数的独立程序运行将非常有用。然而，一旦您准备好将脚本与热键关联，您就不能使用 `main` 名称，因为它将与 *ida.idc* 中的 `main`
    函数冲突。您必须重命名您的 `main` 函数，并在调用 `AddHotkey` 时使用新名称。
- en: Useful IDC Functions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的 IDC 函数
- en: At this point, you have all the information required to write well-formed IDC
    scripts. What you are lacking is the ability to perform any useful interaction
    with IDA itself. IDC provides a long list of built-in functions that offer many
    different ways to access a database. All of the functions are documented to some
    degree in the IDA help system under the topic *Index of IDC functions*. In most
    cases, the documentation is nothing more than relevant lines copied from the main
    IDC include file, *idc.idc*. Becoming comfortable with the rather terse documentation
    is one of the more frustrating aspects of learning IDC. In general, there is no
    easy way to answer the question “How do I do *x* in IDC?” The most common way
    to figure out how to do something is to browse the list of IDC functions looking
    for one that, based on its name, appears to do what you need. This presumes, of
    course, that the functions are named according to their purpose, but their purpose
    may not always be obvious. For example, in many cases, functions that retrieve
    information from the database are named `Get`*`XXX`*; however; in many other cases,
    the `Get` prefix is not used. Functions that change the database may be named
    `Set`*`XXX`*, `Make`*`XXX`*, or something else entirely. In summary, if you want
    to use IDC, get used to browsing the list of functions and reading through their
    descriptions. If you find yourself at a complete loss, don’t be afraid to use
    the support forums at Hex-Rays.^([[102](#ftn.CHP-15-FN-8)])
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经拥有了编写良好格式IDC脚本所需的所有信息。你所缺乏的是与IDA本身进行任何有用交互的能力。IDC提供了一系列内置函数，提供了许多访问数据库的不同方式。所有这些函数都在IDA帮助系统中的“IDC函数索引”主题下进行了某种程度的文档说明。在大多数情况下，文档只是从主IDC包含文件`idc.idc`中复制的相关行。熟悉这种相当简略的文档是学习IDC时更加令人沮丧的方面之一。一般来说，没有简单的方法来回答“如何在IDC中做*x*？”这个问题。最常见的方法是浏览IDC函数列表，寻找一个根据其名称似乎能完成你所需要的功能。当然，这假设函数的命名是根据其目的来命名的，但它们的目的可能并不总是显而易见。例如，在许多情况下，从数据库检索信息的函数被命名为`Get`*`XXX`*；然而，在许多其他情况下，并不使用`Get`前缀。更改数据库的函数可能被命名为`Set`*`XXX`*、`Make`*`XXX`*或完全不同的名称。总之，如果你想使用IDC，就要习惯浏览函数列表并阅读它们的描述。如果你发现自己完全不知所措，不要害怕使用Hex-Rays的支持论坛。[^([[102](#ftn.CHP-15-FN-8)])]
- en: The intent of the remainder of this section is to point out some of the more
    useful (in our experience) IDC functions and group them into functional areas.
    Even if you intend to script in Python only, familiarity with the listed functions
    will be useful to you because IDAPython provides Python equivalents to each function
    listed here. We make no attempt to cover every IDC function, however, since they
    are already covered in the IDA help system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分的目的在于指出一些更有用（根据我们的经验）的IDC函数，并将它们分组到功能区域。即使你只打算用Python编写脚本，熟悉列出的函数也将对你有所帮助，因为IDAPython为这里列出的每个函数都提供了Python等效函数。然而，我们并不试图涵盖每个IDC函数，因为它们已经在IDA帮助系统中有所介绍。
- en: Functions for Reading and Modifying Data
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和修改数据的函数
- en: 'The following functions provide access to individual bytes, words, and double
    words in a database:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数提供对数据库中单个字节、字和双字的访问：
- en: '**`long Byte(long addr)`**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long Byte(long addr)`**'
- en: Reads a byte value from virtual address `addr`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从虚拟地址`addr`读取一个字节值。
- en: '**`long Word(long addr)`**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long Word(long addr)`**'
- en: Reads a word (2-byte) value from virtual address `addr`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从虚拟地址`addr`读取一个字（2字节）值。
- en: '**`long Dword(long addr)`**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long Dword(long addr)`**'
- en: Reads a double word (4-byte) value from virtual address `addr`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从虚拟地址`addr`读取一个双字（4字节）值。
- en: '**`void PatchByte(long addr, long val)`**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void PatchByte(long addr, long val)`**'
- en: Sets a byte value at virtual address `addr`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟地址`addr`设置一个字节值。
- en: '**`void PatchWord(long addr, long val)`**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void PatchWord(long addr, long val)`**'
- en: Sets a word value at virtual address `addr`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟地址`addr`设置一个字值。
- en: '**`void PatchDword(long addr, long val)`**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void PatchDword(long addr, long val)`**'
- en: Sets a double word value at virtual address `addr`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟地址`addr`设置一个双字值。
- en: '**`bool isLoaded(long addr)`**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool isLoaded(long addr)`**'
- en: Returns 1 if `addr` contains valid data, 0 otherwise.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`addr`包含有效数据，则返回1，否则返回0。
- en: Each of these functions takes the byte ordering (little-endian or big-endian)
    of the current processor module into account when reading and writing the database.
    The `Patch`*`XXX`* functions also trim the supplied value to an appropriate size
    by using only the proper number of low-order bytes according to the function called.
    For example, a call to `PatchByte(0x401010, 0x1234)` will patch location `0x401010`
    with the byte value `0x34` (the low-order byte of `0x1234`). If an invalid address
    is supplied while reading the database with `Byte`, `Word`, and `Dword`, the values
    `0xFF`, `0xFFFF`, and `0xFFFFFFFF` will be returned, respectively. Because there
    is no way to distinguish these error values from legitimate data stored in the
    database, you may wish to call `isLoaded` to determine whether an address in the
    database contains any data prior to attempting to read from that address.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在读取和写入数据库时都会考虑到当前处理器模块的字节序（小端或大端）。`Patch`*`XXX`* 函数还会通过仅使用调用函数的正确数量的低阶字节来修剪提供的值到适当的大小。例如，对
    `PatchByte(0x401010, 0x1234)` 的调用将使用 `0x34`（`0x1234` 的低阶字节）修补位置 `0x401010`。如果在用
    `Byte`、`Word` 和 `Dword` 读取数据库时提供了无效地址，将分别返回 `0xFF`、`0xFFFF` 和 `0xFFFFFFFF` 的值。由于无法区分这些错误值和数据库中存储的合法数据，您可能希望在尝试从该地址读取之前调用
    `isLoaded` 来确定数据库中的地址是否包含任何数据。
- en: Because of a quirk in refreshing IDA’s disassembly view, you may find that the
    results of a patch operation are not immediately visible. In such cases, scrolling
    away from the patched location and then scrolling back to the patched location
    generally forces the display to be updated properly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IDA 反汇编视图刷新的一个怪癖，您可能会发现修补操作的结果不会立即可见。在这种情况下，从修补位置滚动离开，然后滚动回修补位置通常可以强制正确更新显示。
- en: User Interaction Functions
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户交互函数
- en: 'In order to perform any user interaction at all, you will need to familiarize
    yourself with IDC input/output functions. The following list summarizes some of
    IDC’s more useful interface functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行任何用户交互，您需要熟悉 IDC 输入/输出函数。以下列表总结了 IDC 一些更有用的接口函数：
- en: '**`void Message(string format, ...)`**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void Message(string format, ...)`**'
- en: Prints a formatted message to the output window. This function is analogous
    to C’s `printf` function and accepts a `printf`-style format string.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将格式化的消息打印到输出窗口。此函数类似于 C 的 `printf` 函数，并接受 `printf` 风格的格式字符串。
- en: '**`void print(...)`**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void print(...)`**'
- en: Prints the string representation of each argument to the output window.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个参数的字符串表示打印到输出窗口。
- en: '**`void Warning(string format, ...)`**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void Warning(string format, ...)`**'
- en: Displays a formatted message in a dialog.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框中显示格式化的消息。
- en: '**`string AskStr(string default, string prompt)`**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string AskStr(string default, string prompt)`**'
- en: Displays an input dialog asking the user to enter a string value. Returns the
    user’s string or 0 if the dialog was canceled.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个输入对话框，提示用户输入字符串值。返回用户的字符串或0（如果对话框被取消）。
- en: '**`string AskFile(long doSave, string mask, string prompt)`**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string AskFile(long doSave, string mask, string prompt)`**'
- en: Displays a file-selection dialog to simplify the task of choosing a file. New
    files may be created for saving data (`doSave = 1`), or existing files may be
    chosen for reading data (`doSave = 0`). The displayed list of files may be filtered
    according to `mask` (such as `*.*` or `*.idc`). Returns the name of the selected
    file or 0 if the dialog was canceled.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文件选择对话框以简化选择文件的任务。可以创建新文件以保存数据（`doSave = 1`），或选择现有文件以读取数据（`doSave = 0`）。显示的文件列表可以根据
    `mask`（例如 `*.*` 或 `*.idc`）进行筛选。返回所选文件的名称或0（如果对话框被取消）。
- en: '**`long AskYN(long default, string prompt)`**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long AskYN(long default, string prompt)`**'
- en: Prompts the user with a yes or no question, highlighting a default answer (1
    = yes, 0 = no, −1 = cancel). Returns an integer representing the selected answer.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 提出一个是或否的问题，突出显示默认答案（1 = 是，0 = 否，-1 = 取消）。返回表示所选答案的整数。
- en: '**`long ScreenEA()`**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long ScreenEA()`**'
- en: Returns the virtual address of the current cursor location.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前光标位置的虚拟地址。
- en: '**`bool Jump(long addr)`**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool Jump(long addr)`**'
- en: Jumps the disassembly window to the specified address.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将反汇编窗口跳转到指定的地址。
- en: Because IDC lacks any debugging facilities, you may find yourself using the
    `Message` function as your primary debugging tool. Several other `Ask`*`XXX`*
    functions exist to handle more specialized input cases such as integer input.
    Please refer to the help system documentation for a complete list of available
    `Ask`*`XXX`* functions. The `ScreenEA` function is very useful for picking up
    the current cursor location when you wish to create a script that tailors its
    behavior based on the location of the cursor. Similarly, the `Jump` function is
    useful when you have a script that needs to call the user’s attention to a specific
    location within the disassembly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IDC缺少任何调试功能，您可能会发现自己将`Message`函数作为主要的调试工具。存在几个其他`Ask`*`XXX`*函数，用于处理更专业的输入情况，例如整数输入。请参阅帮助系统文档以获取可用`Ask`*`XXX`*函数的完整列表。`ScreenEA`函数在您希望创建基于光标位置的脚本时非常有用。同样，`Jump`函数在您需要脚本调用用户的注意力到反汇编中的特定位置时非常有用。
- en: String-Manipulation Functions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作函数
- en: 'Although simple string assignment and concatenation are taken care of with
    basic operators in IDC, more complex operations must be performed using available
    string-handling functions, some of which are detailed here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IDC中使用基本运算符可以处理简单的字符串赋值和连接，但更复杂的操作必须使用可用的字符串处理函数来完成，其中一些在此处详细介绍：
- en: '**`string form(string format, ...) // pre IDA 5.6`**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string form(string format, ...) // pre IDA 5.6`**'
- en: Returns a new string formatted according to the supplied format strings and
    values. This is the rough equivalent to C’s `sprintf` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个根据提供的格式字符串和值格式化的新字符串。这大致等同于C语言的`sprintf`函数。
- en: '**`string sprintf(string format, ...) // IDA 5.6+`**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string sprintf(string format, ...) // IDA 5.6+`**'
- en: With IDA 5.6, `sprintf` replaces `form` (see above).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA 5.6中，`sprintf`替换了`form`（见上文）。
- en: '**`long atol(string val)`**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long atol(string val)`**'
- en: Converts the decimal value `val` to its corresponding integer representation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制值`val`转换为相应的整数表示。
- en: '**`long xtol(string val)`**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long xtol(string val)`**'
- en: Converts the hexadecimal value `val` (which may optionally begin with `0x`)
    to its corresponding integer representation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将十六进制值`val`（可能以`0x`开头）转换为相应的整数表示。
- en: '**`string ltoa(long val, long radix)`**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string ltoa(long val, long radix)`**'
- en: Returns a string representation of `val` in the specified `radix` (2, 8, 10,
    or 16).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`val`在指定`radix`（2、8、10或16）中的字符串表示。
- en: '**`long ord(string ch)`**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long ord(string ch)`**'
- en: Returns the ASCII value of the one-character string `ch`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 返回单字符字符串`ch`的ASCII值。
- en: '**`long strlen(string str)`**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long strlen(string str)`**'
- en: Returns the length of the provided string.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 返回提供的字符串的长度。
- en: '**`long strstr(string str, string substr)`**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long strstr(string str, string substr)`**'
- en: Returns the index of `substr` within `str` or −1 if the substring is not found.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`substr`在`str`中的索引，如果子字符串未找到，则返回-1。
- en: '**`string substr(string str, long start, long end)`**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string substr(string str, long start, long end)`**'
- en: Returns the substring containing the characters from `start` through `end-1`
    of `str`. Using slices (IDA 5.6+) this function is equivalent to `str[start:end]`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含从`start`到`end-1`字符的子字符串。使用切片（IDA 5.6+），此函数等同于`str[start:end]`。
- en: Recall that there is no character datatype in IDC, nor is there any array syntax.
    Lacking slices, if you want to iterate through the individual characters within
    a string, you must take successive one-character substrings for each character
    in the string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，IDC中没有字符数据类型，也没有数组语法。由于缺少切片，如果您想遍历字符串中的单个字符，您必须对字符串中的每个字符取连续的一个字符子字符串。
- en: File Input/Output Functions
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输入/输出函数
- en: 'The output window may not always be the ideal place to send the output of your
    scripts. For scripts that generate a large amount of text or scripts that generate
    binary data, you may wish to output to disk files instead. We have already discussed
    using the `AskFile` function to ask a user for a filename. However, `AskFile`
    returns only a string containing the name of a file. IDC’s file-handling functions
    are detailed here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出窗口可能并非总是发送脚本输出（尤其是生成大量文本或二进制数据的脚本）的理想位置。对于希望将输出保存到磁盘文件的脚本，您可能希望将其输出到磁盘文件。我们已经讨论了使用`AskFile`函数请求用户输入文件名。然而，`AskFile`仅返回包含文件名的字符串。IDC的文件处理函数在此处详细介绍：
- en: '**`long fopen(string filename, string mode)`**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long fopen(string filename, string mode)`**'
- en: Returns an integer file handle (or 0 on error) for use with all IDC file I/O
    functions. The `mode` parameter is similar to the modes used in C’s `fopen` (`r`
    to read, `w` to write, and so on).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个整数文件句柄（或错误时返回 0），用于与所有 IDC 文件 I/O 函数一起使用。`mode` 参数类似于 C 的 `fopen` 中使用的模式（例如，`r`
    用于读取，`w` 用于写入等）。
- en: '**`void fclose(long handle)`**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void fclose(long handle)`**'
- en: Closes the file specified by the file handle from `fopen`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭由 `fopen` 指定的文件。
- en: '**`long filelength(long handle)`**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long filelength(long handle)`**'
- en: Returns the length of the indicated file or −1 on error.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定文件的长度或错误时返回 -1。
- en: '**`long fgetc(long handle)`**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long fgetc(long handle)`**'
- en: Reads a single byte from the given file. Returns −1 on error.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定文件中读取一个字节。错误时返回 -1。
- en: '**`long fputc(long val, long handle)`**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long fputc(long val, long handle)`**'
- en: Writes a single byte to the given file. Returns 0 on success or −1 on error.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个字节写入给定文件。成功时返回 0 或错误时返回 -1。
- en: '**`long fprintf(long handle, string format, ...)`**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long fprintf(long handle, string format, ...)`**'
- en: Writes a formatted string to the given file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将格式化的字符串写入给定文件。
- en: '**`long writestr(long handle, string str)`**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long writestr(long handle, string str)`**'
- en: Writes the specified string to the given file.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定的字符串写入给定文件。
- en: '**`string/long readstr(long handle)`**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string/long readstr(long handle)`**'
- en: Reads a string from the given file. This function reads all characters (including
    non-ASCII) up to and including the next line feed (ASCII 0xA) character. Returns
    the string on success or −1 on end of file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定文件中读取一个字符串。此函数读取所有字符（包括非 ASCII 字符）直到并包括下一个换行符（ASCII 0xA）字符。成功时返回字符串或错误时返回
    -1。
- en: '**`long writelong(long handle, long val, long bigendian)`**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long writelong(long handle, long val, long bigendian)`**'
- en: Writes a 4-byte integer to the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大端（`bigendian` = 1）或小端（`bigendian` = 0）字节顺序将一个 4 字节整数写入给定文件。
- en: '**`long readlong(long handle, long bigendian)`**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long readlong(long handle, long bigendian)`**'
- en: Reads a 4-byte integer from the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大端（`bigendian` = 1）或小端（`bigendian` = 0）字节顺序从给定文件中读取一个 4 字节整数。
- en: '**`long writeshort(long handle, long val, long bigendian)`**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long writeshort(long handle, long val, long bigendian)`**'
- en: Writes a 2-byte integer to the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大端（`bigendian` = 1）或小端（`bigendian` = 0）字节顺序将一个 2 字节整数写入给定文件。
- en: '**`long readshort(long handle, long bigendian)`**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long readshort(long handle, long bigendian)`**'
- en: Reads a 2-byte integer from the given file using big-endian (`bigendian` = 1)
    or little-endian (`bigendian` = 0) byte order.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大端（`bigendian` = 1）或小端（`bigendian` = 0）字节顺序从给定文件中读取一个 2 字节整数。
- en: '**`bool loadfile(long handle, long pos, long addr, long length)`**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool loadfile(long handle, long pos, long addr, long length)`**'
- en: Reads `length` number of bytes from position `pos` in the given file and writes
    those bytes into the database beginning at address `addr`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定文件的位置 `pos` 读取 `length` 个字节并将这些字节写入从地址 `addr` 开始的数据库。
- en: '**`bool savefile(long handle, long pos, long addr, long length)`**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool savefile(long handle, long pos, long addr, long length)`**'
- en: Writes `length` number of bytes beginning at database address `addr` to position
    `pos` in the given file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将从数据库地址 `addr` 开始的 `length` 个字节写入给定文件的位置 `pos`。
- en: Manipulating Database Names
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作数据库名称
- en: 'The need to manipulate named locations arises fairly often in scripts. The
    following IDC functions are available for working with named locations in an IDA
    database:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，经常需要操作命名位置。以下 IDC 函数可用于在 IDA 数据库中处理命名位置：
- en: '**`string Name(long addr)`**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string Name(long addr)`**'
- en: Returns the name associated with the given address or returns the empty string
    if the location has no name. This function does not return user-assigned names
    when the names are marked as local.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与给定地址关联的名称或如果位置没有名称则返回空字符串。此函数在名称标记为本地时不会返回用户指定的名称。
- en: '**`string NameEx(long from, long addr)`**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string NameEx(long from, long addr)`**'
- en: Returns the name associated with `addr`. Returns the empty string if the location
    has no name. This function returns user-defined local names if `from` is any address
    within a function that also contains `addr`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与 `addr` 关联的名称。如果 `from` 是包含 `addr` 的函数中的任何地址，则返回用户定义的本地名称。
- en: '**`bool MakeNameEx(long addr, string name, long flags)`**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool MakeNameEx(long addr, string name, long flags)`**'
- en: Assigns the given name to the given address. The name is created with attributes
    specified in the `flags` bitmask. These flags are described in the help file documentation
    for `MakeNameEx` and are used to specify attributes such as whether the name is
    local or public or whether it should be listed in the names window.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的名称分配给给定的地址。名称通过在`flags`位掩码中指定的属性创建。这些标志在`MakeNameEx`的帮助文件文档中描述，用于指定名称是否为本地或公共，或者是否应在名称窗口中列出。
- en: '**`long LocByName(string name)`**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long LocByName(string name)`**'
- en: Returns the address of the location with the given name. Returns BADADDR (−1)
    if no such name exists in the database.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 返回具有给定名称的位置地址。如果数据库中不存在此类名称，则返回BADADDR（-1）。
- en: '**`long LocByNameEx(long funcaddr, string localname)`**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long LocByNameEx(long funcaddr, string localname)`**'
- en: Searches for the given local name within the function containing `funcaddr`.
    Returns BADADDR (−1) if no such name exists in the given function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含`funcaddr`的函数内搜索给定的本地名称。如果给定函数中不存在此类名称，则返回BADADDR（-1）。
- en: Functions Dealing with Functions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理函数的函数
- en: Many scripts are designed to perform analysis of functions within a database.
    IDA assigns disassembled functions a number of attributes, such as the size of
    the function’s local variable area or the size of the function’s arguments on
    the runtime stack. The following IDC functions can be used to access information
    about functions within a database.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 许多脚本被设计用于在数据库中执行函数分析。IDA为反汇编函数分配了多个属性，例如函数局部变量区域的大小或函数在运行时栈上的参数大小。以下IDC函数可用于访问数据库中函数的信息。
- en: '**`long GetFunctionAttr(long addr, long attrib)`**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetFunctionAttr(long addr, long attrib)`**'
- en: Returns the requested attribute for the function containing the given address.
    Refer to the IDC help documentation for a list of attribute constants. As an example,
    to find the ending address of a function, use **`GetFunctionAttr(addr, FUNCATTR_END);`**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含给定地址的函数的请求属性。有关属性常量的列表，请参阅IDC帮助文档。例如，要查找函数的结束地址，请使用**`GetFunctionAttr(addr,
    FUNCATTR_END);`**。
- en: '**`string GetFunctionName(long addr)`**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string GetFunctionName(long addr)`**'
- en: Returns the name of the function that contains the given address or an empty
    string if the given address does not belong to a function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含给定地址的函数的名称，或者如果给定地址不属于函数，则返回空字符串。
- en: '**`long NextFunction(long addr)`**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long NextFunction(long addr)`**'
- en: Returns the starting address of the next function following the given address.
    Returns −1 if there are no more functions in the database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址之后下一个函数的起始地址。如果数据库中没有更多函数，则返回-1。
- en: '**`long PrevFunction(long addr)`**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long PrevFunction(long addr)`**'
- en: Returns the starting address of the nearest function that precedes the given
    address. Returns −1 if no function precedes the given address.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址之前最近函数的起始地址。如果给定地址之前没有函数，则返回-1。
- en: Use the `LocByName` function to find the starting address of a function given
    the function’s name.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LocByName`函数根据函数的名称查找函数的起始地址。
- en: Code Cross-Reference Functions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码交叉引用函数
- en: Cross-references were covered in [Chapter 9](ch09.html "Chapter 9. Cross-References
    and Graphing"). IDC offers functions for accessing cross-reference information
    associated with any instruction. Deciding which functions meet the needs of your
    scripts can be a bit confusing. It requires you to understand whether you are
    interested in following the flows leaving a given address or whether you are interested
    in iterating over all of the locations that refer to a given address. Functions
    for performing both of the preceding operations are described here. Several of
    these functions are designed to support iteration over a set of cross-references.
    Such functions support the notion of a sequence of cross-references and require
    a `current` cross-reference in order to return a `next` cross-reference. Examples
    of using cross-reference iterators are provided in [Enumerating Cross-References](ch15s05.html#enumerating_cross-references
    "Enumerating Cross-References") in [Enumerating Cross-References](ch15s05.html#enumerating_cross-references
    "Enumerating Cross-References").
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用在[第9章](ch09.html "第9章。交叉引用和绘图")中进行了介绍。IDC提供了访问与任何指令相关的交叉引用信息的函数。决定哪些函数满足你的脚本需求可能会有些困惑。这需要你理解你是否对跟踪给定地址离开的流程感兴趣，或者你是否对迭代所有引用给定地址的位置感兴趣。描述了执行上述两种操作的函数。其中一些函数旨在支持对一组交叉引用的迭代。这些函数支持交叉引用序列的概念，并需要一个`当前`交叉引用来返回一个`下一个`交叉引用。在[枚举交叉引用](ch15s05.html#enumerating_cross-references
    "枚举交叉引用")中提供了使用交叉引用迭代器的示例。
- en: '**`long Rfirst(long from)`**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long Rfirst(long from)`**'
- en: Returns the first location to which the given address transfers control. Returns
    BADADDR (−1) if the given address refers to no other address.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址传递控制权的第一个位置。如果给定地址不引用其他地址，则返回BADADDR（-1）。
- en: '**`long Rnext(long from, long current)`**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long Rnext(long from, long current)`**'
- en: Returns the next location to which the given address (`from`) transfers control,
    given that `current` has already been returned by a previous call to `Rfirst`
    or `Rnext`. Returns BADADDR if no more cross-references exist.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`current`已经被前一个调用`Rfirst`或`Rnext`返回的情况下，返回给定地址（`from`）传递控制权的下一个位置。如果没有更多交叉引用存在，则返回BADADDR。
- en: '**`long XrefType()`**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long XrefType()`**'
- en: Returns a constant indicating the type of the last cross-reference returned
    by a cross-reference lookup function such as `Rfirst`. For code cross-references,
    these constants are `fl_CN` (near call), `fl_CF` (far call), `fl_JN` (near jump),
    `fl_JF` (far jump), and `fl_F` (ordinary sequential flow).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个常量，指示由交叉引用查找函数（如`Rfirst`）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量是`fl_CN`（近调用）、`fl_CF`（远调用）、`fl_JN`（近跳转）、`fl_JF`（远跳转）和`fl_F`（普通顺序流程）。
- en: '**`long RfirstB(long to)`**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long RfirstB(long to)`**'
- en: Returns the first location that transfers control to the given address. Returns
    BADADDR (−1) if there are no references to the given address.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 返回将控制权传递给给定地址的第一个位置。如果没有引用给定地址，则返回BADADDR（-1）。
- en: '**`long RnextB(long to, long current)`**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long RnextB(long to, long current)`**'
- en: Returns the next location that transfers control to the given address (`to`),
    given that `current` has already been returned by a previous call to `RfirstB`
    or `RnextB`. Returns BADADDR if no more cross-references to the given location
    exist.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`current`已经被前一个调用`RfirstB`或`RnextB`返回的情况下，返回将控制权传递给给定地址的下一个位置。如果没有更多指向给定位置的交叉引用，则返回BADADDR。
- en: Each time a cross-reference function is called, an internal IDC state variable
    is set that indicates the type of the last cross-reference that was returned.
    If you need to know what type of cross-reference you have received, then you must
    call `XrefType` prior to calling another cross-reference lookup function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用交叉引用函数时，都会设置一个内部IDC状态变量，指示返回的最后一个交叉引用的类型。如果你需要知道你收到了哪种类型的交叉引用，那么你必须在使用另一个交叉引用查找函数之前调用`XrefType`。
- en: Data Cross-Reference Functions
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据交叉引用函数
- en: 'The functions for accessing data cross-reference information are very similar
    to the functions used to access code cross-reference information. These functions
    are described here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据交叉引用信息的函数与用于访问代码交叉引用信息的函数非常相似。这些函数在此进行描述：
- en: '**`long Dfirst(long from)`**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long Dfirst(long from)`**'
- en: Returns the first location to which the given address refers to a data value.
    Returns BADADDR (−1) if the given address refers to no other addresses.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址引用数据值的第一个位置。如果给定地址不引用其他地址，则返回BADADDR（-1）。
- en: '**`long Dnext(long from, long current)`**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long Dnext(long from, long current)`**'
- en: Returns the next location to which the given address (`from`) refers a data
    value, given that `current` has already been returned by a previous call to `Dfirst`
    or `Dnext`. Returns BADADDR if no more cross-references exist.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向给定地址（`from`）的数据值的下一个位置，前提是`current`已经被前一个对`Dfirst`或`Dnext`的调用返回。如果没有更多交叉引用存在，则返回BADADDR。
- en: '**`long XrefType()`**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long XrefType()`**'
- en: Returns a constant indicating the type of the last cross-reference returned
    by a cross-reference lookup function such as `Dfirst`. For data cross-references,
    these constants include `dr_O` (offset taken), `dr_W` (data write), and `dr_R`
    (data read).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个常数，指示由`Dfirst`等交叉引用查找函数返回的最后一个交叉引用的类型。对于数据交叉引用，这些常数包括`dr_O`（取偏移量）、`dr_W`（数据写入）和`dr_R`（数据读取）。
- en: '**`long DfirstB(long to)`**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long DfirstB(long to)`**'
- en: Returns the first location that refers to the given address as data. Returns
    BADADDR (−1) if there are no references to the given address.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向给定地址的数据的第一个位置。如果没有指向给定地址的引用，则返回BADADDR（-1）。
- en: '**`long DnextB(long to, long current)`**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long DnextB(long to, long current)`**'
- en: Returns the next location that refers to the given address (`to`) as data, given
    that `current` has already been returned by a previous call to `DfirstB` or `DnextB`.
    Returns BADADDR if no more cross-references to the given location exist.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向给定地址（`to`）的数据的下一个位置，前提是`current`已经被前一个对`DfirstB`或`DnextB`的调用返回。如果没有更多指向给定位置的交叉引用，则返回BADADDR。
- en: As with code cross-references, if you need to know what type of cross-reference
    you have received, then you must call `XrefType` prior to calling another cross-reference
    lookup function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码交叉引用一样，如果您需要知道您收到了哪种类型的交叉引用，那么在调用另一个交叉引用查找函数之前，您必须调用`XrefType`。
- en: Database Manipulation Functions
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库操作函数
- en: 'A number of functions exist for formatting the contents of a database. Here
    are descriptions of a few of these functions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多用于格式化数据库内容的函数。以下是这些函数的一些描述：
- en: '**`void MakeUnkn(long addr, long flags)`**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void MakeUnkn(long addr, long flags)`**'
- en: Undefines the item at the specified address. The flags (see the IDC documentation
    for `MakeUnkn`) dictate whether subsequent items will also be undefined and whether
    any names associated with undefined items will be deleted. Related function `MakeUnknown`
    allows you to undefine large blocks of data.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定地址取消定义项目。标志（参见`MakeUnkn`的IDC文档）决定了后续项目是否也会被取消定义，以及与取消定义的项目关联的任何名称是否会被删除。相关函数`MakeUnknown`允许您取消定义大量数据块。
- en: '**`long MakeCode(long addr)`**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long MakeCode(long addr)`**'
- en: Converts the bytes at the specified address into an instruction. Returns the
    length of the instruction or 0 if the operation fails.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定地址的字节转换为指令。如果操作失败，则返回指令的长度或0。
- en: '**`bool MakeByte(long addr)`**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool MakeByte(long addr)`**'
- en: Converts the item at the specified address into a data byte. `MakeWord` and
    `MakeDword` are also available.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定地址的项目转换为数据字节。`MakeWord`和`MakeDword`也是可用的。
- en: '**`bool MakeComm(long addr, string comment)`**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool MakeComm(long addr, string comment)`**'
- en: Adds a regular comment at the given address.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定地址添加常规注释。
- en: '**`bool MakeFunction(long begin, long end)`**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool MakeFunction(long begin, long end)`**'
- en: Converts the range of instructions from `begin` to `end` into a function. If
    `end` is specified as `BADADDR (-1)`, IDA attempts to automatically identify the
    end of the function by locating the function’s return instruction.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将从`begin`到`end`的指令范围转换为函数。如果将`end`指定为`BADADDR (-1)`，IDA将尝试通过定位函数的返回指令来自动识别函数的结束。
- en: '**`bool MakeStr(long begin, long end)`**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool MakeStr(long begin, long end)`**'
- en: Creates a string of the current string type (as returned by `GetStringType`),
    spanning the bytes from `begin` to `end - 1`. If `end` is specified as `BADADDR`,
    IDA attempts to automatically identify the end of the string.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个字符串，该字符串是当前字符串类型（由`GetStringType`返回），跨越从`begin`到`end - 1`的字节。如果将`end`指定为`BADADDR`，IDA将尝试通过自动识别字符串的结束。
- en: Many other `Make`*`XXX`* functions exist that offer behavior similar to the
    functions just described. Please refer to the IDC documentation for a full list
    of these functions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多其他`Make`*`XXX`*函数，它们提供与上述函数类似的行为。请参阅IDC文档以获取这些函数的完整列表。
- en: Database Search Functions
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库搜索函数
- en: The majority of IDA’s search capabilities are accessible in IDC in the form
    of various `Find`*`XXX`* functions, some of which are described here. The `flags`
    parameter used in the `Find`*`XXX`* functions is a bitmask that specifies the
    behavior of the find operation. Three of the more useful flags are `SEARCH_DOWN`,
    which causes the search to scan toward higher addresses; `SEARCH_NEXT`, which
    skips the current occurrence in order to search for the next occurrence; and `SEARCH_CASE`,
    which causes binary and text searches to be performed in a case-sensitive manner.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的大多数搜索功能都以各种`Find`*`XXX`*函数的形式在IDC中提供，其中一些在此处进行了描述。`Find`*`XXX`*函数中使用的`flags`参数是一个位掩码，用于指定查找操作的行为。其中三个更有用的标志是`SEARCH_DOWN`，它使搜索扫描向更高地址；`SEARCH_NEXT`，它跳过当前出现以搜索下一个出现；以及`SEARCH_CASE`，它使二进制和文本搜索以区分大小写的方式进行。
- en: '**`long FindCode(long addr, long flags)`**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long FindCode(long addr, long flags)`**'
- en: Searches for an instruction from the given address.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定地址搜索指令。
- en: '**`long FindData(long addr, long flags)`**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long FindData(long addr, long flags)`**'
- en: Searches for a data item from the given address.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定地址搜索数据项。
- en: '**`long FindBinary(long addr, long flags, string binary)`**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long FindBinary(long addr, long flags, string binary)`**'
- en: Searches for a sequence of bytes from the given address. The `binary` string
    specifies a sequence of hexadecimal byte values. If `SEARCH_CASE` is not specified
    and a byte value specifies an uppercase or lowercase ASCII letter, then the search
    will also match corresponding, complementary case values. For example, “41 42”
    will match “61 62” (and “61 42”) unless the `SEARCH_CASE` flag is set.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定地址搜索一系列字节。`binary`字符串指定一系列十六进制字节值。如果没有指定`SEARCH_CASE`，并且字节值指定大写或小写ASCII字母，则搜索也将匹配相应的互补大小写值。例如，“41
    42”将匹配“61 62”（以及“61 42”），除非设置了`SEARCH_CASE`标志。
- en: '**`long FindText(long addr, long flags, long row, long column, string text)`**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long FindText(long addr, long flags, long row, long column, string text)`**'
- en: Searches for a `text` string from the given `column` on the given line (`row`)
    at the given address. Note that the disassembly text at a given address may span
    several lines, hence the need to specify on which line the search should begin.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定地址的给定行（`row`）的给定列（`column`）开始搜索`text`字符串。请注意，给定地址的汇编文本可能跨越多行，因此需要指定搜索应从哪一行开始。
- en: Also note that `SEARCH_NEXT` does not define the direction of search, which
    may be either up or down according to the `SEARCH_DOWN` flag. In addition, when
    `SEARCH_NEXT` is not specified, it is perfectly reasonable for a `Find`*`XXX`*
    function to return the same address that was passed in as the `addr` argument
    when the item at `addr` satisfies the search.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`SEARCH_NEXT`不定义搜索方向，这可能向上或向下，具体取决于`SEARCH_DOWN`标志。此外，当未指定`SEARCH_NEXT`时，如果`addr`处的项目满足搜索条件，`Find`*`XXX`*函数返回与作为`addr`参数传入的相同地址是完全合理的。
- en: Disassembly Line Components
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编行组件
- en: 'From time to time it is useful to extract the text, or portions of the text,
    of individual lines in a disassembly listing. The following functions provide
    access to various components of a disassembly line:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有时从汇编列表中的单个行提取文本或文本的部分是有用的。以下函数提供了访问汇编行各种组件的权限：
- en: '**`string GetDisasm(long addr)`**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string GetDisasm(long addr)`**'
- en: Returns disassembly text for the given address. The returned text includes any
    comments but does not include address information.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址的汇编文本。返回的文本包括任何注释，但不包括地址信息。
- en: '**`string GetMnem(long addr)`**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string GetMnem(long addr)`**'
- en: Returns the mnemonic portion of the instruction at the given address.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址上指令的助记符部分。
- en: '**`string GetOpnd(long addr, long opnum)`**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string GetOpnd(long addr, long opnum)`**'
- en: Returns the text representation of the specified operand at the specified address.
    Operands are numbered from zero beginning with the leftmost operand.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定地址上指定操作数的文本表示。操作数从零开始编号，从最左边的操作数开始。
- en: '**`long GetOpType(long addr, long opnum)`**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetOpType(long addr, long opnum)`**'
- en: Returns an integer representing the type for the given operand at the given
    address. Refer to the IDC documentation for `GetOpType` for a complete list of
    operand type codes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表示给定地址上给定操作数类型的整数。有关`GetOpType`的完整操作数类型代码列表，请参阅IDC文档。
- en: '**`long GetOperandValue(long addr, long opnum)`**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**`long GetOperandValue(long addr, long opnum)`**'
- en: Returns the integer value associated with the given operand at the given address.
    The nature of the returned value depends on the type of the given operand as specified
    by `GetOpType`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址处与给定操作数关联的整数值。返回值的性质取决于由`GetOpType`指定的给定操作数的类型。
- en: '**`string CommentEx(long addr, long type)`**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**`string CommentEx(long addr, long type)`**'
- en: Returns the text of any comment present at the given address. If `type` is 0,
    the text of the regular comment is returned. If `type` is 1, the text of the repeatable
    comment is returned. If no comment is present at the given address, an empty string
    is returned.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定地址处存在的任何注释的文本。如果`type`为0，则返回常规注释的文本。如果`type`为1，则返回可重复注释的文本。如果给定地址处不存在注释，则返回空字符串。
- en: '* * *'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[102](#CHP-15-FN-8)]) The support forum is currently located at [http://www.hex-rays.com/forum/](http://www.hex-rays.com/forum/)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[102](#CHP-15-FN-8)]) 当前支持论坛位于 [http://www.hex-rays.com/forum/](http://www.hex-rays.com/forum/)
- en: IDC Scripting Examples
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDC 脚本示例
- en: At this point it is probably useful to see some examples of scripts that perform
    specific tasks. For the remainder of the chapter we present some fairly common
    situations in which a script can be used to answer a question about a database.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，查看一些执行特定任务的脚本示例可能是有用的。在本章的剩余部分，我们将展示一些相当常见的情况，在这些情况下，脚本可以用来回答有关数据库的问题。
- en: Enumerating Functions
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举函数
- en: Many scripts operate on individual functions. Examples include generating the
    call tree rooted at a specific function, generating the control flow graph of
    a function, or analyzing the stack frames of every function in a database. [Example 15-1](ch15s05.html#function_enumeration_script
    "Example 15-1. Function enumeration script") iterates through every function in
    a database and prints basic information about each function, including the start
    and end addresses of the function, the size of the function’s arguments, and the
    size of the function’s local variables. All output is sent to the output window.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 许多脚本操作单个函数。例如，生成以特定函数为根的调用树，生成函数的控制流图，或分析数据库中每个函数的栈帧。[示例 15-1](ch15s05.html#function_enumeration_script
    "示例 15-1. 函数枚举脚本") 遍历数据库中的每个函数，并打印每个函数的基本信息，包括函数的起始和结束地址、函数参数的大小以及函数局部变量的大小。所有输出都发送到输出窗口。
- en: Example 15-1. Function enumeration script
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-1. 函数枚举脚本
- en: '[PRE12]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This script uses some of IDC’s structure-manipulation functions to obtain a
    handle to each function’s stack frame (`GetFrame`), determine the size of the
    stack frame (`GetStrucSize`), and determine the offset of the saved return address
    within the frame (`GetMemberOffset`). The first argument to the function lies
    4 bytes beyond the saved return address. The size of the function’s argument area
    is computed as the space between the first argument and the end of the stack frame.
    Since IDA can’t generate stack frames for imported functions, this script tests
    whether the function’s stack frame contains a saved return address as a simple
    means of identifying calls to an imported function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用 IDC 的结构操作函数来获取每个函数的栈帧句柄（`GetFrame`），确定栈帧的大小（`GetStrucSize`），并确定栈帧中保存的返回地址的偏移量（`GetMemberOffset`）。函数的第一个参数位于保存的返回地址之后
    4 个字节处。函数的参数区域大小是通过第一个参数和栈帧末尾之间的空间计算得出的。由于 IDA 无法为导入的函数生成栈帧，此脚本通过检查函数的栈帧是否包含保存的返回地址作为识别导入函数调用的简单方法。
- en: Enumerating Instructions
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举指令
- en: 'Within a given function, you may want to enumerate every instruction. [Example 15-2](ch15s05.html#instruction_enumeration_script
    "Example 15-2. Instruction enumeration script") counts the number of instructions
    contained in the function identified by the current cursor position:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的函数内，你可能想要枚举每个指令。[示例 15-2](ch15s05.html#instruction_enumeration_script "示例
    15-2. 指令枚举脚本") 计算了由当前光标位置确定的函数中包含的指令数量：
- en: Example 15-2. Instruction enumeration script
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-2. 指令枚举脚本
- en: '[PRE13]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function begins ![](httpatomoreillycomsourcenostarchimages854061.png) by
    using `GetFunctionAttr` to determine the start address of the function containing
    the cursor address (`ScreenEA()`). If the beginning of a function is found, the
    next step ![](httpatomoreillycomsourcenostarchimages854063.png) is to determine
    the end address for the function, once again using the `GetFunctionAttr` function.
    Once the function has been bounded, a loop is executed to step through successive
    instructions in the function by using the search functionality of the `FindCode`
    function ![](httpatomoreillycomsourcenostarchimages854093.png). In this example,
    the `Warning` function is used to display results, since only a single line of
    output will be generated by the function and output displayed in a Warning dialog
    is much more obvious than output generated in the message window. Note that this
    example assumes that all of the instructions within the given function are contiguous.
    An alternative approach might replace the use of `FindCode` with logic to iterate
    over all of the code cross-references for each instruction within the function.
    Properly written, this second approach would handle noncontiguous, also known
    as “chunked,” functions.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的起始是通过使用 `GetFunctionAttr` 来确定包含光标地址（`ScreenEA()`）的函数的起始地址来开始的 ![函数起始](httpatomoreillycomsourcenostarchimages854061.png)。如果找到了函数的起始点，下一步
    ![确定函数结束地址](httpatomoreillycomsourcenostarchimages854063.png) 是确定函数的结束地址，再次使用
    `GetFunctionAttr` 函数。一旦函数被界定，就通过使用 `FindCode` 函数的搜索功能 ![遍历函数中的指令](httpatomoreillycomsourcenostarchimages854093.png)
    来执行一个循环，逐个遍历函数中的连续指令。在这个例子中，使用 `Warning` 函数来显示结果，因为函数将只生成一行输出，并且警告对话框中显示的输出比消息窗口中生成的输出更明显。请注意，此示例假设给定函数中的所有指令都是连续的。另一种方法可能用迭代函数中每个指令的所有代码交叉引用的逻辑来替换
    `FindCode` 的使用。正确编写的话，第二种方法将能够处理非连续的，也称为“分块”的函数。
- en: Enumerating Cross-References
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历交叉引用
- en: Iterating through cross-references can be confusing because of the number of
    functions available for accessing cross-reference data and the fact that code
    cross-references are bidirectional. In order to get the data you want, you need
    to make sure you are accessing the proper type of cross-reference for your situation.
    In our first cross-reference example, shown in [Example 15-3](ch15s05.html#enumerating_function_calls
    "Example 15-3. Enumerating function calls"), we derive the list of all function
    calls made within a function by iterating through each instruction in the function
    to determine if the instruction calls another function. One method of doing this
    might be to parse the results of `GetMnem` to look for `call` instructions. This
    would not be a very portable solution, because the instruction used to call a
    function varies among CPU types. Second, additional parsing would be required
    to determine exactly which function was being called. Cross-references avoid each
    of these difficulties because they are CPU-independent and directly inform us
    about the target of the cross-reference.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可用的访问交叉引用数据的函数数量以及代码交叉引用的双向性，遍历交叉引用可能会令人困惑。为了获取所需的数据，您需要确保您正在访问适合您情况的正确类型的交叉引用。在我们的第一个交叉引用示例中，如
    [示例 15-3](ch15s05.html#enumerating_function_calls "示例 15-3. 遍历函数调用") 所示，我们通过遍历函数中的每个指令来确定指令是否调用另一个函数，从而推导出函数内所有函数调用的列表。完成这一任务的一种方法可能是解析
    `GetMnem` 的结果以查找 `call` 指令。这不会是一个非常通用的解决方案，因为用于调用函数的指令在不同类型的 CPU 之间是不同的。其次，还需要进行额外的解析来确定被调用的确切函数。交叉引用避免了这些困难，因为它们与
    CPU 无关，并且直接告诉我们交叉引用的目标。
- en: Example 15-3. Enumerating function calls
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-3. 遍历函数调用
- en: '[PRE14]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we must iterate through each instruction in the function. For
    each instruction, we must then iterate through each cross-reference from the instruction.
    We are interested only in cross-references that call other functions, so we must
    test the return value of `XrefType` looking for `fl_CN` or `fl_CF`-type cross-references.
    Here again, this particular solution handles only functions whose instructions
    happen to be contiguous. Given that the script is already iterating over the cross-references
    from each instruction, it would not take many changes to produce a flow-driven
    analysis instead of the address-driven analysis seen here.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们必须遍历函数中的每个指令。对于每个指令，我们必须然后遍历从指令出发的每个交叉引用。我们只对调用其他函数的交叉引用感兴趣，因此我们必须测试`XrefType`的返回值，寻找`fl_CN`或`fl_CF`类型的交叉引用。在这里，这个特定的解决方案只处理指令连续的函数。鉴于脚本已经遍历了每个指令的交叉引用，要产生这里看到的地址驱动分析而不是流驱动分析，只需进行很少的修改。
- en: Another use for cross-references is to determine every location that references
    a particular location. For example, if we wanted to create a low-budget security
    analyzer, we might be interested in highlighting all calls to functions such as
    `strcpy` and `sprintf`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用交叉引用的用途是确定引用特定位置的每个位置。例如，如果我们想创建一个低成本的安全分析器，我们可能会对突出显示所有调用诸如`strcpy`和`sprintf`等函数的调用感兴趣。
- en: DANGEROUS FUNCTIONS
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**危险函数**'
- en: 'The C functions `strcpy` and `sprintf` are generally acknowledged as dangerous
    to use because they allow for unbounded copying into destination buffers. While
    each may be safely used by programmers who conduct proper checks on the size of
    source and destination buffers, such checks are all too often forgotten by programmers
    unaware of the dangers of these functions. The `strcpy` function, for example,
    is declared as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: C函数`strcpy`和`sprintf`通常被认为使用起来很危险，因为它们允许无限制地复制到目标缓冲区。虽然每个函数都可以安全地由对源和目标缓冲区大小进行适当检查的程序员使用，但这样的检查往往被不了解这些函数危险性的程序员所遗忘。例如，`strcpy`函数声明如下：
- en: '[PRE15]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `strcpy` function’s defined behavior is to copy all characters up to and
    including the first null termination character encountered in the source buffer
    to the given destination buffer (`dest`). The fundamental problem is that there
    is no way to determine, at runtime, the size of any array. In this instance, `strcpy`
    has no means to determine whether the capacity of the destination buffer is sufficient
    to hold all of the data to be copied from source. Such unchecked copy operations
    are a major cause of buffer overflow vulnerabilities.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcpy`函数的定义行为是将源缓冲区中遇到的所有字符（包括第一个空终止字符）复制到指定的目标缓冲区（`dest`）。基本问题是无法在运行时确定任何数组的大小。在这种情况下，`strcpy`没有确定目标缓冲区容量是否足以容纳从源复制的数据的手段。这种未经检查的复制操作是缓冲区溢出漏洞的主要原因。'
- en: 'In the example shown in [Example 15-4](ch15s05.html#enumerating_a_functionas_callers
    "Example 15-4. Enumerating a function’s callers"), we work in reverse to iterate
    across all of the cross-references *to* (as opposed to *from* in the preceding
    example) a particular symbol:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例15-4](ch15s05.html#enumerating_a_functionas_callers "示例15-4. 列出函数的调用者")中所示，我们反向操作以遍历所有指向特定符号的交叉引用（与上一个示例中的从特定符号出发相反）：
- en: Example 15-4. Enumerating a function’s callers
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 示例15-4. 列出函数的调用者
- en: '[PRE16]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the `LocByName` ![](httpatomoreillycomsourcenostarchimages854061.png)
    function is used to find the address of a given (by name) bad function. If the
    function’s address is found, a loop ![](httpatomoreillycomsourcenostarchimages854063.png)
    is executed in order to process all cross-references to the bad function. For
    each cross-reference, if the cross-reference type ![](httpatomoreillycomsourcenostarchimages854093.png)
    is determined to be a call-type ![](httpatomoreillycomsourcenostarchimages854095.png)
    cross-reference, the calling function’s name is determined ![](httpatomoreillycomsourcenostarchimages854099.png)
    and is displayed to the user ![](httpatomoreillycomsourcenostarchimages854101.png).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`LocByName`函数来查找给定（按名称）的坏函数的地址。如果找到了函数的地址，就会执行一个循环来处理所有指向坏函数的交叉引用。对于每个交叉引用，如果确定交叉引用类型是调用类型的交叉引用，就会确定调用函数的名称并将其显示给用户。
- en: It is important to note that some modifications may be required to perform a
    proper lookup of the name of an imported function. In ELF executables in particular,
    which combine a procedure linkage table (PLT) with a global offset table (GOT)
    to handle the details of linking to shared libraries, the names that IDA assigns
    to imported functions may be less than clear. For example, a PLT entry may appear
    to be named `_memcpy`, when in fact it is named `.memcpy` and IDA has replaced
    the dot with an underscore because IDA considers dots invalid characters within
    names. Further complicating matters is the fact that IDA may actually create a
    symbol named `memcpy` that resides in a section that IDA names `extern`. When
    attempting to enumerate cross-references to `memcpy`, we are interested in the
    PLT version of the symbol because this is the version that is called from other
    functions in the program and thus the version to which all cross-references would
    refer.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，可能需要对导入函数的名称进行一些修改才能正确查找。特别是在 ELF 可执行文件中，特别是将过程链接表（PLT）与全局偏移表（GOT）结合使用以处理链接到共享库的细节，IDA
    分配给导入函数的名称可能不够清晰。例如，PLT 条目可能看起来被命名为 `_memcpy`，但实际上它被命名为 `.memcpy`，而 IDA 将点替换为下划线，因为
    IDA 认为点在名称中是无效字符。更复杂的是，IDA 实际上可能创建一个名为 `memcpy` 的符号，它位于 IDA 命名的 `extern` 部分中。当尝试枚举
    `memcpy` 的交叉引用时，我们感兴趣的符号是 PLT 版本，因为这是程序中其他函数调用的版本，因此所有交叉引用都会引用这个版本。
- en: Enumerating Exported Functions
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举导出函数
- en: 'In [Chapter 13](ch13.html "Chapter 13. Extending IDA’s Knowledge") we discussed
    the use of `idsutils` to generate *.ids* files that describe the contents of shared
    libraries. Recall that the first step in generating a *.ids* file involves generating
    a *.idt* file, which is a text file containing descriptions of each exported function
    contained in the library. IDC contains functions for iterating through the functions
    that are exported by a shared library. The script shown in [Example 15-5](ch15s05.html#a_script_to_generate_.idt_files
    "Example 15-5. A script to generate .idt files") can be run to generate an *.idt*
    file after opening a shared library with IDA:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13 章](ch13.html "第 13 章。扩展 IDA 的知识") 中，我们讨论了使用 `idsutils` 生成 *.ids* 文件，这些文件描述了共享库的内容。回想一下，生成
    *.ids* 文件的第一个步骤是生成 *.idt* 文件，这是一个包含库中每个导出函数描述的文本文件。IDC 包含遍历由共享库导出的函数的函数。在 [示例
    15-5](ch15s05.html#a_script_to_generate_.idt_files "示例 15-5. 生成 .idt 文件") 中显示的脚本可以在使用
    IDA 打开共享库后运行以生成 *.idt* 文件：
- en: Example 15-5. A script to generate *.idt* files
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-5. 生成 *.idt* 文件的脚本
- en: '[PRE17]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output of the script is saved to a file chosen by the user. New functions
    introduced in this script include `GetEntryPointQty`, which returns the number
    of symbols exported by the library; `GetEntryOrdinal`, which returns an ordinal
    number (an index into the library’s export table); `GetEntryPoint`, which returns
    the address associated with an exported function that has been identified by ordinal
    number; and `GetInputFile`, which returns the name of the file that was loaded
    into IDA.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出保存到用户选择的文件中。此脚本中引入的新函数包括 `GetEntryPointQty`，它返回库导出的符号数量；`GetEntryOrdinal`，它返回一个序号（库导出表的索引）；`GetEntryPoint`，它返回通过序号识别的导出函数的地址；以及
    `GetInputFile`，它返回加载到 IDA 中的文件名。
- en: Finding and Labeling Function Arguments
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找和标记函数参数
- en: 'Versions of GCC later than 3.4 use `mov` statements rather than `push` statements
    in x86 binaries to place function arguments into the stack before calling a function.
    Occasionally this causes some analysis problems for IDA (newer versions of IDA
    handle this situation better), because the analysis engine relies on finding `push`
    statements to pinpoint locations at which arguments are pushed for a function
    call. The following listing shows an IDA disassembly when parameters are pushed
    onto the stack:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 3.4 之后的版本在 x86 二进制文件中使用 `mov` 指令而不是 `push` 指令将函数参数放入栈中，在调用函数之前。偶尔这会给 IDA
    的分析带来一些问题（IDA 的新版本处理这种情况更好），因为分析引擎依赖于找到 `push` 指令来定位函数调用中参数被推入的位置。以下列表显示了当参数被推入栈时的
    IDA 汇编：
- en: '[PRE18]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note the comments that IDA has placed in the right margin. Such commenting
    is possible only when IDA recognizes that parameters are being pushed and when
    IDA knows the signature of the function being called. When `mov` statements are
    used to place parameters onto the stack, the resulting disassembly is somewhat
    less informative, as shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 IDA 在右页边距放置的注释。这种注释只有在 IDA 识别出参数被推入栈中，并且 IDA 知道被调用函数的签名时才可能实现。当使用 `mov` 语句将参数放置到栈上时，生成的反汇编结果相对不那么具有信息量，如下所示：
- en: '[PRE19]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, IDA has failed to recognize that the three `mov` statements preceding
    the call are being used to set up the parameters for the function call. As a result,
    we get less assistance from IDA in the form of automatic comments in the disassembly.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，IDA 未识别出在调用之前的三个 `mov` 语句被用来设置函数调用的参数。因此，我们在反汇编中得到的自动注释形式的帮助较少。
- en: 'Here we have a situation where a script might be able to restore some of the
    information that we are accustomed to seeing in our disassemblies. [Example 15-6](ch15s05.html#automating_parameter_recognition
    "Example 15-6. Automating parameter recognition") is a first effort at automatically
    recognizing instructions that are setting up parameters for function calls:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，脚本可能能够恢复我们在反汇编中习惯看到的一些信息。[示例 15-6](ch15s05.html#automating_parameter_recognition
    "示例 15-6. 自动化参数识别") 是自动识别为函数调用设置参数的指令的初步尝试：
- en: Example 15-6. Automating parameter recognition
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-6. 自动化参数识别
- en: '[PRE20]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The script works only on EBP-based frames and relies on the fact that when
    parameters are moved into the stack prior to a function call, GCC generates memory
    references relative to `esp`. The script iterates through all instructions in
    a function; for each instruction that writes to a memory location using `esp`
    as a base register, the script determines the depth within the stack and adds
    a comment indicating which parameter is being moved. The `GetFunctionFlags` function
    offers access to various flags associated with a function, such as whether the
    function uses an EBP-based stack frame. Running the script in [Example 15-6](ch15s05.html#automating_parameter_recognition
    "Example 15-6. Automating parameter recognition") yields the annotated disassembly
    shown here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本仅在基于 EBP 的栈帧上工作，并依赖于在函数调用之前将参数移动到栈上时，GCC 会生成相对于 `esp` 的内存引用。脚本遍历函数中的所有指令；对于每个使用
    `esp` 作为基址寄存器的内存位置写入指令，脚本确定栈中的深度，并添加注释以指示正在移动哪个参数。`GetFunctionFlags` 函数提供了访问与函数相关联的各种标志的方法，例如函数是否使用基于
    EBP 的栈帧。在 [示例 15-6](ch15s05.html#automating_parameter_recognition "示例 15-6. 自动化参数识别")
    中运行脚本会产生如下所示的带注释的反汇编：
- en: '[PRE21]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The comments aren’t particularly informative. However, we can now tell at a
    glance that the three `mov` statements are used to place parameters onto the stack,
    which is a step in the right direction. By extending the script a bit further
    and exploring some more of IDC’s capabilities, we can come up with a script that
    provides almost as much information as IDA does when it properly recognizes parameters.
    The output of the final product is shown here:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 评论并不特别具有信息量。然而，现在我们可以一眼看出，三个 `mov` 语句被用来将参数放置到栈上，这是朝着正确方向迈出的一步。通过进一步扩展脚本并探索
    IDC 的更多功能，我们可以编写出一个脚本，它在正确识别参数时几乎能提供与 IDA 相当多的信息。最终产品的输出如下所示：
- en: '[PRE22]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The extended version of the script in [Example 15-6](ch15s05.html#automating_parameter_recognition
    "Example 15-6. Automating parameter recognition"), which is capable of incorporating
    data from function signatures into comments, is available on this book’s website.^([[103](#ftn.CHP-15-FN-9)])
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-6](ch15s05.html#automating_parameter_recognition "示例 15-6. 自动化参数识别")
    中的脚本扩展版本，它能够将函数签名中的数据纳入注释中，可在本书的网站上找到.^([[103](#ftn.CHP-15-FN-9)])'
- en: Emulating Assembly Language Behavior
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟汇编语言行为
- en: There are a number of reasons why you might need to write a script that emulates
    the behavior of a program you are analyzing. For example, the program you are
    studying may be self-modifying, as many malware programs are, or the program may
    contain some encoded data that gets decoded when it is needed at runtime. Without
    running the program and pulling the modified data out of the running process’s
    memory, how can you understand the behavior of the program? The answer may lie
    with an IDC script. If the decoding process is not terribly complex, you may be
    able to quickly write an IDC script that performs the same actions that are performed
    by the program when it runs. Using a script to decode data in this way eliminates
    the need to run a program when you don’t know what the program does or you don’t
    have access to a platform on which you can run the program. An example of the
    latter case might occur if you were examining a MIPS binary with your Windows
    version of IDA. Without any MIPS hardware, you would not be able to execute the
    MIPS binary and observe any data decoding it might perform. You could, however,
    write an IDC script to mimic the behavior of the binary and make the required
    changes within the IDA database, all with no need for a MIPS execution environment.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因你可能需要编写一个模拟你正在分析程序行为的脚本。例如，你正在研究的程序可能是自修改的，就像许多恶意软件程序一样，或者程序可能包含一些在运行时需要解码的编码数据。在不运行程序并从运行进程的内存中提取修改后的数据的情况下，你如何理解程序的行为？答案可能在于IDC脚本。如果解码过程并不特别复杂，你可能能够快速编写一个IDC脚本，执行程序运行时执行的动作。使用脚本以这种方式解码数据可以消除在不知道程序做什么或无法访问可以运行程序的平台时运行程序的需求。后者的情况可能发生在你使用Windows版本的IDA检查MIPS二进制文件时。没有任何MIPS硬件，你将无法执行MIPS二进制文件并观察它可能执行的数据解码。然而，你可以编写一个IDC脚本来模拟二进制文件的行为，并在IDA数据库中做出必要的更改，而无需MIPS执行环境。
- en: The following x86 code was extracted from a DEFCON^([[104](#ftn.CHP-15-FN-10)])
    Capture the Flag binary.^([[105](#ftn.CHP-15-FN-11)])
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下x86代码是从DEFCON^([[104](#ftn.CHP-15-FN-10)]) Capture the Flag二进制文件中提取的.^([[105](#ftn.CHP-15-FN-11)])
- en: '[PRE23]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code decodes a private key that has been embedded within the program binary.
    Using the IDC script shown in [Example 15-7](ch15s05.html#emulating_assembly_language_with_idc
    "Example 15-7. Emulating assembly language with IDC"), we can extract the private
    key without running the program:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码解码了嵌入在程序二进制文件中的私钥。使用[示例15-7](ch15s05.html#emulating_assembly_language_with_idc
    "示例15-7. 使用IDC模拟汇编语言")中显示的IDC脚本，我们可以提取私钥而无需运行程序：
- en: Example 15-7. Emulating assembly language with IDC
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 示例15-7. 使用IDC模拟汇编语言
- en: '[PRE24]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 15-7](ch15s05.html#emulating_assembly_language_with_idc "Example 15-7. Emulating
    assembly language with IDC") is a fairly literal translation of the preceding
    assembly language sequence generated according to the following rather mechanical
    rules.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例15-7](ch15s05.html#emulating_assembly_language_with_idc "示例15-7. 使用IDC模拟汇编语言")是按照以下相当机械的规则生成的先前汇编语言序列的相当直译。'
- en: For each stack variable and register used in the assembly code, declare an IDC
    variable.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在汇编代码中使用的每个堆变量和寄存器，声明一个IDC变量。
- en: For each assembly language statement, write an IDC statement that mimics its
    behavior.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个汇编语言语句，编写一个模拟其行为的IDC语句。
- en: Reading and writing stack variables is emulated by reading and writing the corresponding
    variable declared in your IDC script.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过读取和写入在IDC脚本中声明的相应变量来模拟读取和写入堆变量。
- en: Reading from a nonstack location is accomplished using the `Byte`, `Word`, or
    `Dword` function, depending on the amount of data being read (1, 2, or 4 bytes).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据读取的数据量（1、2或4字节）使用`Byte`、`Word`或`Dword`函数从非堆位置读取数据。
- en: Writing to a nonstack location is accomplished using the `PatchByte`, `PatchWord`,
    or `PatchDword` function, depending on the amount of data being written.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PatchByte`、`PatchWord`或`PatchDword`函数将数据写入非堆位置，具体取决于写入的数据量。
- en: In general, if the code appears to contain a loop for which the termination
    condition is not immediately obvious, it is easiest to begin with an infinite
    loop such as `while (1) {}` and then insert a `break` statement when you encounter
    statements that cause the loop to terminate.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，如果代码中包含一个终止条件不明显循环，最简单的方法是从一个无限循环`while (1) {}`开始，然后在遇到导致循环终止的语句时插入`break`语句。
- en: When the assembly code calls functions, things get complicated. In order to
    properly simulate the behavior of the assembly code, you must find a way to mimic
    the behavior of the function that has been called, including providing a return
    value that makes sense within the context of the code being simulated. This fact
    alone may preclude the use of IDC as a tool for emulating the behavior of an assembly
    language sequence.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当汇编代码调用函数时，事情会变得复杂。为了正确模拟汇编代码的行为，您必须找到一种方法来模拟被调用的函数的行为，包括提供在模拟的代码上下文中有意义的返回值。仅此一点就可能阻止使用
    IDC 作为模拟汇编语言序列行为的工具。
- en: 'The important thing to understand when developing scripts such as the previous
    one is that it is not absolutely necessary to fully understand how the code you
    are emulating behaves on a global scale. It is often sufficient to understand
    only one or two instructions at a time and generate correct IDC translations for
    those instructions. If each instruction has been correctly translated into IDC,
    then the script as a whole should properly mimic the complete functionality of
    the original assembly code. We can delay further study of the assembly language
    algorithm until after the IDC script has been completed, at which point we can
    use the IDC script to enhance our understanding of the underlying assembly. Once
    we spend some time considering how our example algorithm works, we might shorten
    the preceding IDC script to the following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发如前所述的脚本时，需要理解的重要一点是，您并不绝对有必要完全理解您正在模拟的代码在全局范围内是如何行为的。通常，一次只理解一条或两条指令并生成这些指令的正确
    IDC 翻译就足够了。如果每条指令都已正确翻译成 IDC，那么整个脚本应该能够正确地模拟原始汇编代码的完整功能。我们可以推迟对汇编语言算法的进一步研究，直到
    IDC 脚本完成之后，那时我们可以使用 IDC 脚本来增强我们对底层汇编的理解。一旦我们花时间考虑我们的示例算法是如何工作的，我们可能会将前面的 IDC 脚本缩短为以下内容：
- en: '[PRE25]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As an alternative, if we did not wish to modify the database in any way, we
    could replace the `PatchByte` function with a call to `Message` if we were dealing
    with ASCII data, or as an alternative we could write the data to a file if we
    were dealing with binary data.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，如果我们不想以任何方式修改数据库，如果我们处理的是 ASCII 数据，我们可以用 `Message` 函数调用替换 `PatchByte`
    函数，或者如果我们处理的是二进制数据，我们可以将数据写入文件。
- en: '* * *'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[103](#CHP-15-FN-9)]) See [http://www.idabook.com/ch15_examples](http://www.idabook.com/ch15_examples).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[103](#CHP-15-FN-9)]) 请参阅 [http://www.idabook.com/ch15_examples](http://www.idabook.com/ch15_examples)。
- en: ^([[104](#CHP-15-FN-10)]) See [http://www.defcon.org/](http://www.defcon.org/).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[104](#CHP-15-FN-10)]) 请参阅 [http://www.defcon.org/](http://www.defcon.org/)。
- en: ^([[105](#CHP-15-FN-11)]) Courtesy of Kenshoto, the organizers of CTF at DEFCON
    15\. Capture the Flag is an annual hacking competition held at DEFCON.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[105](#CHP-15-FN-11)]) 感谢 Kenshoto，DEFCON 15 的 CTF 组织者。Capture the Flag 是在
    DEFCON 举办的年度黑客竞赛。
- en: IDAPython
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDAPython
- en: IDAPython is a plug-in developed by Gergely Erdelyi that integrates a Python
    interpreter into IDA. Combined with supplied Python bindings, this plug-in allows
    you to write Python scripts with full access to all of the capabilities of the
    IDC scripting language. One clear advantage gained with IDAPython is access to
    Python’s native data-handling capabilities as well as the full range of Python
    modules. In addition, IDAPython exposes a significant portion of IDA’s SDK functionality,
    allowing for far more powerful scripting than is possible using IDC. IDAPython
    has developed quite a following in the IDA community. Ilfak’s blog^([[106](#ftn.CHP-15-FN-12)])
    contains numerous interesting examples of problem solving with Python scripts,
    while questions, answers, and many other useful IDAPython scripts are frequently
    posted in the forums at OpenRCE.org.^([[107](#ftn.CHP-15-FN-13)]) In addition,
    third-party tools such as BinNavi^([[108](#ftn.CHP-15-FN-14)]) from Zynamics rely
    on IDA and IDAPython in order to perform various subtasks required by the tools.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: IDAPython 是由 Gergely Erdelyi 开发的一个插件，它将 Python 解释器集成到 IDA 中。结合提供的 Python 绑定，此插件允许您编写具有对
    IDC 脚本语言所有功能完全访问权限的 Python 脚本。使用 IDAPython 获得的明显优势是访问 Python 的原生数据处理能力以及完整的 Python
    模块范围。此外，IDAPython 还公开了 IDA 的 SDK 功能的一部分，这使得使用 IDC 实现的脚本功能更加强大。IDAPython 在 IDA
    社区中已经积累了一定的追随者。Ilfak 的博客^([[106](#ftn.CHP-15-FN-12)]) 包含了许多使用 Python 脚本解决问题的有趣示例，而问题、答案以及许多其他有用的
    IDAPython 脚本经常在 OpenRCE.org 的论坛上发布.^([[107](#ftn.CHP-15-FN-13)]) 此外，来自 Zynamics
    的第三方工具，如 BinNavi^([[108](#ftn.CHP-15-FN-14)))，依赖 IDA 和 IDAPython 来执行工具所需的各项子任务。
- en: 'Since IDA 5.4, Hex-Rays has been including IDAPython as a standard plug-in.
    Source code for the plug-in is available for download on the IDA-Python project
    page,^([[109](#ftn.CHP-15-FN-15)]) and API documentation is available on the Hex-Rays
    website.^([[110](#ftn.CHP-15-FN-16)]) IDA enables the plug-in only when Python
    is found to be installed on the computer on which you are running IDA. The Windows
    version of IDA ships with and installs a compatible version of Python,^([[111](#ftn.CHP-15-FN-17)])
    while the Linux and OS X versions of IDA leave proper installation of Python up
    to you. On Linux, the current version of IDA (6.1) looks for Python 2.6\. IDAPython
    is compatible with Python 2.7, and IDA will work just fine if you create symlinks
    from the required Python 2.6 libraries to your existing Python 2.7 libraries.
    If you have Python 2.7, a command similar to the following will create the symlink
    that will make IDA happy:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 IDA 5.4 以来，Hex-Rays 一直将 IDAPython 作为标准插件提供。该插件的源代码可在 IDA-Python 项目页面上下载，[^([[109](#ftn.CHP-15-FN-15)])]
    API 文档可在 Hex-Rays 网站上找到。[^([[110](#ftn.CHP-15-FN-16)])] IDA 仅在检测到计算机上已安装 Python
    时才会启用插件。IDA 的 Windows 版本随附并安装了一个兼容的 Python 版本，[^([[111](#ftn.CHP-15-FN-17)])]
    而Linux 和 OS X 版本的 IDA 则将 Python 的正确安装留给你。在 Linux 上，当前版本的 IDA（6.1）寻找 Python 2.6。IDAPython
    与 Python 2.7 兼容，如果你从所需的 Python 2.6 库创建到现有 Python 2.7 库的符号链接，IDA 将运行良好。如果你有 Python
    2.7，以下类似的命令将创建使 IDA 满意的符号链接：
- en: '[PRE26]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: OS X users may find that the version of Python that ships with OS X is older
    than that required by IDA. If this is the case, a suitable Python installer should
    be downloaded from [www.python.org](http://www.python.org).^([[112](#ftn.CHP-15-FN-18)])
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: OS X 用户可能会发现随 OS X 一起提供的 Python 版本比 IDA 所需的版本要旧。如果是这种情况，应从 [www.python.org](http://www.python.org)
    下载合适的 Python 安装程序。[^([[112](#ftn.CHP-15-FN-18)])]
- en: Using IDAPython
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IDAPython
- en: IDAPython bridges Python code into IDA by making available three Python modules,
    each serving a specific purpose. Access to the core IDA API (as exposed via the
    SDK) is made available with the `idaapi` module. All of the functions present
    in IDC are made available in IDAPython’s `idc` module. The third module that ships
    with IDAPython is `idautils`, which provides a number of utility functions, many
    of which yield Python lists of various database-related objects such as functions
    or cross-references. Modules `idc` and `idautils` are automatically imported for
    all IDAPython scripts. If you need `idaapi`, on the other hand, you must import
    it yourself.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: IDAPython 通过提供三个 Python 模块将 Python 代码桥接到 IDA，每个模块都服务于特定的目的。通过 `idaapi` 模块可以访问核心
    IDA API（通过 SDK 暴露）。IDC 中所有的函数都在 IDAPython 的 `idc` 模块中提供。随 IDAPython 一起提供的第三个模块是
    `idautils`，它提供了一些实用函数，其中许多函数返回各种数据库相关对象的 Python 列表，如函数或交叉引用。`idc` 和 `idautils`
    模块会自动导入所有 IDAPython 脚本。另一方面，如果你需要 `idaapi`，你必须自己导入它。
- en: When using IDAPython, keep in mind that the plug-in embeds a single instance
    of the Python interpreter into IDA. This interpreter is not destroyed until you
    close IDA. As a result, you can view all of your scripts and statements as if
    they are running within a single Python shell session. For example, once you have
    imported the `idaapi` module for the first time in your IDA session, you need
    never import it again until you restart IDA. Similarly, initialized variables
    and function definitions retain their values until they are redefined or until
    you quit IDA.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 IDAPython 时，请注意该插件将单个 Python 解释器实例嵌入到 IDA 中。这个解释器在你关闭 IDA 之前不会被销毁。因此，你可以将所有的脚本和语句视为在单个
    Python 命令行会话中运行。例如，一旦你在 IDA 会话中第一次导入 `idaapi` 模块，你就不需要再次导入它，直到你重启 IDA。同样，初始化的变量和函数定义会保留它们的值，直到它们被重新定义或直到你退出
    IDA。
- en: There are a number of strategies for learning IDA’s Python API. If you already
    have some experience using IDC or programming with the IDA SDK, then you should
    feel right at home with the `idaapi` and `idc` modules. A quick review of the
    additional features in the `idautils` module should be all you really need to
    start making full use of IDAPython. If you have prior experience with IDC or the
    SDK, then you might dive into the Hex-Ray’s documentation for the Python API to
    develop a feel for the capabilities it offers. Remember that the `idc` module
    basically mirrors the IDC API and that you may find the list of IDC functions
    in IDA’s built-in help to be quite useful. Similarly, the descriptions of IDC
    functions presented earlier in this chapter are equally applicable to the corresponding
    functions in the `idc` module.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 IDA 的 Python API 有多种策略。如果你已经有一些使用 IDC 或使用 IDA SDK 编程的经验，那么你应该会感到非常熟悉 `idaapi`
    和 `idc` 模块。快速浏览 `idautils` 模块中的附加功能应该就足够你开始充分利用 IDAPython 了。如果你有使用 IDC 或 SDK 的先验经验，那么你可能需要深入研究
    Hex-Ray 的 Python API 文档，以了解它提供的功能。记住，`idc` 模块基本上反映了 IDC API，你可能会在 IDA 的内置帮助中找到
    IDC 函数列表非常有用。同样，本章前面介绍的 IDC 函数描述也适用于 `idc` 模块中的相应函数。
- en: '* * *'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[106](#CHP-15-FN-12)]) See [http://www.hexblog.com](http://www.hexblog.com).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[106](#CHP-15-FN-12)]) 查看 [http://www.hexblog.com](http://www.hexblog.com)。
- en: ^([[107](#CHP-15-FN-13)]) See [http://www.openrce.org/articles/](http://www.openrce.org/articles/).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[107](#CHP-15-FN-13)]) 查看 [http://www.openrce.org/articles/](http://www.openrce.org/articles/)
- en: ^([[108](#CHP-15-FN-14)]) See [http://www.zynamics.com/binnavi.html](http://www.zynamics.com/binnavi.html).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[108](#CHP-15-FN-14)]) 查看 [http://www.zynamics.com/binnavi.html](http://www.zynamics.com/binnavi.html)。
- en: ^([[109](#CHP-15-FN-15)]) See [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[109](#CHP-15-FN-15)]) 查看 [http://code.google.com/p/idapython/](http://code.google.com/p/idapython/)
- en: ^([[110](#CHP-15-FN-16)]) See [http://www.hex-rays.com/idapro/idapython_docs/index.html](http://www.hex-rays.com/idapro/idapython_docs/index.html).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[110](#CHP-15-FN-16)]) 查看 [http://www.hex-rays.com/idapro/idapython_docs/index.html](http://www.hex-rays.com/idapro/idapython_docs/index.html)。
- en: ^([[111](#CHP-15-FN-17)]) See [http://www.python.org/](http://www.python.org/).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[111](#CHP-15-FN-17)]) 查看 [http://www.python.org/](http://www.python.org/)。
- en: ^([[112](#CHP-15-FN-18)]) See [http://www.python.org/download/mac/](http://www.python.org/download/mac/)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[112](#CHP-15-FN-18)]) 查看 [http://www.python.org/download/mac/](http://www.python.org/download/mac/)
- en: IDAPython Scripting Examples
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDAPython 脚本示例
- en: By way of offering a compare and contrast between IDC and IDAPython, the following
    sections present the same example cases seen previously in the discussion of IDC.
    Wherever possible we endeavor to make maximum use of Python-specific features
    to demonstrate some of the efficiencies that can be gained by scripting in Python.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较和对比 IDC 和 IDAPython，以下章节展示了之前在 IDC 讨论中看到的相同示例案例。 wherever possible 我们努力最大限度地利用
    Python 特有的功能来展示通过 Python 脚本可以获得的效率。
- en: Enumerating Functions
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举函数
- en: One of the strengths of IDAPython is the way that it uses Python’s powerful
    datatypes to simplify access to collections of database objects. In [Example 15-8](ch15s07.html#function_enumeration_using_python
    "Example 15-8. Function enumeration using Python"), we reimplement the function
    enumeration script of [Example 15-1](ch15s05.html#function_enumeration_script
    "Example 15-1. Function enumeration script") in Python. Recall that the purpose
    of this script is to iterate over every function in a database and print basic
    information about each function, including the start and end addresses of the
    function, the size of the function’s arguments, and the size of the function’s
    local variable space. All output is sent to the output window.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: IDAPython 的一个优点是它使用 Python 强大的数据类型来简化对数据库对象集合的访问。在 [示例 15-8](ch15s07.html#function_enumeration_using_python
    "示例 15-8. 使用 Python 枚举函数") 中，我们使用 Python 重新实现了 [示例 15-1](ch15s05.html#function_enumeration_script
    "示例 15-1. 枚举函数脚本") 中的函数枚举脚本。回想一下，这个脚本的目的是在数据库中迭代每个函数并打印每个函数的基本信息，包括函数的起始和结束地址、函数参数的大小以及函数局部变量空间的大小。所有输出都发送到输出窗口。
- en: Example 15-8. Function enumeration using Python
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-8. 使用 Python 枚举函数
- en: '[PRE27]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For this particular script, the use of Python gains us little in the way of
    efficiency other than the use of the `Functions` ![](httpatomoreillycomsourcenostarchimages854061.png)
    list generator, which facilitates the `for` loop at ![](httpatomoreillycomsourcenostarchimages854063.png).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的脚本，使用 Python 除了使用 `Functions` ![http://atomoreilly.com/source/nostarch/images/854061.png]
    列表生成器外，在效率方面并没有给我们带来多少提升，这个生成器简化了 ![http://atomoreilly.com/source/nostarch/images/854063.png]
    的 `for` 循环。
- en: Enumerating Instructions
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举指令
- en: '[Example 15-9](ch15s07.html#instruction_enumeration_in_python "Example 15-9. Instruction
    enumeration in Python") demonstrates how the instruction-counting script of [Example 15-2](ch15s05.html#instruction_enumeration_script
    "Example 15-2. Instruction enumeration script") might be written in Python, taking
    advantage of the list generators available in the `idautils` module.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-9](ch15s07.html#instruction_enumeration_in_python "示例 15-9. Python 中的指令枚举")
    展示了如何使用 Python 编写 [示例 15-2](ch15s05.html#instruction_enumeration_script "示例 15-2.
    指令枚举脚本") 中的指令计数脚本，利用 `idautils` 模块中可用的列表生成器。'
- en: Example 15-9. Instruction enumeration in Python
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-9. Python 中的指令枚举
- en: '[PRE28]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Differences from the IDC version include the use of an SDK function ![](httpatomoreillycomsourcenostarchimages854061.png)
    (accessed via `idaapi`) to retrieve a reference to a function object (specifically
    a `func_t`) and the use of the `FuncItems` generator ![](httpatomoreillycomsourcenostarchimages854063.png)
    (from `idautils`) to provide easy iteration over all of the instructions within
    the function. Because we can’t use Python’s `len` function on a generator, we
    are still obligated to step through the generator list in order to count each
    instruction one at a time.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IDC 版本相比，包括使用 SDK 函数 ![http://atomoreilly.com/source/nostarch/images/854061.png]（通过
    `idaapi` 访问）来获取函数对象（特别是 `func_t`）的引用，以及使用 `FuncItems` ![http://atomoreilly.com/source/nostarch/images/854063.png]
    生成器（来自 `idautils`）来提供在函数内所有指令上的简单迭代。因为我们不能在生成器上使用 Python 的 `len` 函数，所以我们仍然必须逐个遍历生成器列表来计数每个指令。
- en: Enumerating Cross-References
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举交叉引用
- en: The `idautils` module contains several generator functions that build cross-reference
    lists in a somewhat more intuitive way than we saw in IDC. [Example 15-10](ch15s07.html#enumerating_function_calls_using_python
    "Example 15-10. Enumerating function calls using Python") rewrites the function
    call enumeration script that we saw previously in [Example 15-3](ch15s05.html#enumerating_function_calls
    "Example 15-3. Enumerating function calls").
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`idautils` 模块包含几个生成器函数，它们以比我们在 IDC 中看到的方式更直观的方式构建交叉引用列表。[示例 15-10](ch15s07.html#enumerating_function_calls_using_python
    "示例 15-10. 使用 Python 枚举函数调用") 重写了我们在 [示例 15-3](ch15s05.html#enumerating_function_calls
    "示例 15-3. 枚举函数调用") 中看到的函数调用枚举脚本。'
- en: Example 15-10. Enumerating function calls using Python
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-10. 使用 Python 枚举函数调用
- en: '[PRE29]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: New in this script is the use of the `XrefsFrom` generator ![](httpatomoreillycomsourcenostarchimages854061.png)
    (from `idautils`) to step through all cross-references from the current instruction.
    `XrefsFrom` returns a reference to an `xrefblk_t` object that contains detailed
    information about the current cross-reference.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中新引入的是使用 `XrefsFrom` ![http://atomoreilly.com/source/nostarch/images/854061.png]
    生成器（来自 `idautils`）来遍历当前指令的所有交叉引用。`XrefsFrom` 返回一个指向 `xrefblk_t` 对象的引用，该对象包含有关当前交叉引用的详细信息。
- en: Enumerating Exported Functions
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举导出函数
- en: '[Example 15-11](ch15s07.html#a_python_script_to_generate_idt_files "Example 15-11. A
    Python script to generate IDT files") is the Python version of the *.idt* generator
    script from [Example 15-5](ch15s05.html#a_script_to_generate_.idt_files "Example 15-5. A
    script to generate .idt files").'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-11](ch15s07.html#a_python_script_to_generate_idt_files "示例 15-11. 生成
    IDT 文件的 Python 脚本") 是 [示例 15-5](ch15s05.html#a_script_to_generate_.idt_files "示例
    15-5. 生成 .idt 文件") 中 *.idt* 生成器脚本的 Python 版本。'
- en: Example 15-11. A Python script to generate IDT files
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-11. 生成 IDT 文件的 Python 脚本
- en: '[PRE30]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The two scripts look remarkably similar because IDAPython has no generator function
    for entry-point lists, so we are left to use the same set of functions that were
    used in [Example 15-5](ch15s05.html#a_script_to_generate_.idt_files "Example 15-5. A
    script to generate .idt files"). One difference worth noting is that IDAPython
    deprecates IDC’s file-handling functions in favor of Python’s built-in file-handling
    functions.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 两个脚本看起来非常相似，因为 IDAPython 没有用于入口点列表的生成器函数，所以我们只能使用在 [示例 15-5](ch15s05.html#a_script_to_generate_.idt_files
    "示例 15-5. 生成 .idt 脚本") 中使用的相同函数集。值得注意的一个区别是，IDAPython 废弃了 IDC 的文件处理函数，转而使用 Python
    的内置文件处理函数。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Scripting provides a powerful means for extending IDA’s capabilities. Through
    the years, scripts have been used in a number of innovative ways to fill the needs
    of IDA users. Many useful scripts are available for download on the Hex-Rays website
    as well as the mirror site of the former IDA Palace.^([[113](#ftn.CHP-15-FN-19)])
    IDA scripts are perfect for small tasks and rapid development, but they are not
    ideally suited for all situations.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本提供了扩展 IDA 功能的强大手段。多年来，脚本以多种创新方式被用于满足 IDA 用户的需求。许多有用的脚本可以在 Hex-Rays 网站以及前 IDA
    Palace 的镜像网站上下载。^([[113](#ftn.CHP-15-FN-19)]) IDA 脚本非常适合小任务和快速开发，但它们并不完全适合所有情况。
- en: One of the principal limitations of the IDC language is its lack of support
    for complex datatypes and the lack of access to a more fully featured API such
    as the C standard library or the Windows API. At the expense of greater complexity,
    we can lift these limitations by moving away from scripted extensions and toward
    compiled extensions. As we will show in the next chapter, compiled extensions
    require the use of the IDA software development kit (SDK), which has a steeper
    learning curve than either IDC or IDAPython. However, the power available when
    developing extensions with the SDK is usually well worth the effort spent learning
    how to use it.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: IDC 语言的主要局限性之一是其对复杂数据类型的支持不足，以及无法访问更全面的功能 API，如 C 标准库或 Windows API。通过增加复杂性，我们可以通过转向编译扩展而不是脚本扩展来克服这些限制。正如我们将在下一章中展示的，编译扩展需要使用
    IDA 软件开发工具包 (SDK)，其学习曲线比 IDC 或 IDAPython 都要陡峭。然而，使用 SDK 开发扩展时所能获得的功能通常值得投入学习如何使用它的努力。
- en: '* * *'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[113](#CHP-15-FN-19)]) See [http://old.idapalace.net/](http://old.idapalace.net/).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[113](#CHP-15-FN-19)]) 查看 [http://old.idapalace.net/](http://old.idapalace.net/).
- en: Chapter 16. The IDA Software Development Kit
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 16 章。IDA 软件开发工具包
- en: Throughout the course of the book, we have used phrases like “IDA does this,”
    and “IDA does that.” While IDA certainly does an awful lot for us, the intelligence
    is more correctly attributed to the various modules upon which IDA relies. For
    example, it is the processor module that makes all of the decisions during the
    analysis phase, so one could argue that IDA is only as smart as the processor
    modules on which it relies. Of course, Hex-Rays puts tremendous effort into ensuring
    that its processor modules are as capable as possible, and for the casual user,
    IDA neatly hides its modular architecture beneath its user interface.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们使用了诸如“IDA 这样做”和“IDA 那样做”之类的短语。虽然 IDA 确实为我们做了很多，但更准确地说，这种智能应归因于 IDA
    所依赖的各种模块。例如，分析阶段的所有决策都是由处理器模块做出的，因此可以说，IDA 的智能程度取决于它所依赖的处理器模块。当然，Hex-Rays 在确保其处理器模块尽可能强大方面投入了巨大的努力，而对于普通用户来说，IDA
    将其模块化架构巧妙地隐藏在其用户界面之下。
- en: At some point you may find yourself needing more power than the IDC scripting
    language has to offer, whether for performance reasons or because you wish to
    do things that IDC simply was not designed to do. When that moment arrives, it
    is time to advance to using IDA’s *software development kit (SDK)* to build your
    own compiled modules for use with IDA.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，你可能发现自己需要比 IDC 脚本语言所能提供的更多功能，无论是出于性能原因，还是因为你希望做 IDC 简单设计所无法实现的事情。当这一刻到来时，是时候进阶到使用
    IDA 的 *软件开发工具包 (SDK)* 来构建你自己的编译模块以供 IDA 使用了。
- en: Note
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The IDC scripting engine is built on top of IDA’s SDK. All IDC functions are
    ultimately translated to calls to one or more SDK functions that perform the actual
    work. While it is true that if you can do something in IDC, you can do the same
    thing using the SDK, the reverse does not hold. The SDK offers far more power
    than is available using IDC alone, and many SDK actions have no IDC counterpart.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: IDC 脚本引擎建立在 IDA 的 SDK 之上。所有 IDC 函数最终都会被转换成对一个或多个执行实际工作的 SDK 函数的调用。虽然确实如果你能在
    IDC 中做到某事，你也可以使用 SDK 做到同样的事情，但反之则不然。SDK 提供的功能远比仅使用 IDC 可用得多，而且许多 SDK 动作在 IDC 中没有对应的操作。
- en: The SDK exposes IDA’s internal programming interfaces in the form of C++ libraries
    and the header files required to interface to those libraries. The SDK is required
    in order to create loader modules to handle new file formats, processor modules
    to disassemble new CPU instruction sets, and plug-in modules that might be viewed
    as more powerful, compiled alternatives to scripts.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: SDK以C++库的形式暴露了IDA的内部编程接口，以及与这些库接口所需的头文件。为了创建处理新文件格式的加载模块、处理新CPU指令集的处理模块，以及可能被视为比脚本更强大的编译替代品的插件模块，需要SDK。
- en: BELLS, WHISTLES, AND BULLETS TO THE FOOT
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 钟声、口哨声和脚跟子弹
- en: While working with C++, you will of course have access to a wide variety of
    C++ libraries, including your operating system’s native APIs. By utilizing such
    libraries, you may be tempted to incorporate a wide variety of sophisticated features
    into any modules that you build. However, you should be very careful what functionality
    you choose to incorporate in this way, as it may lead to instability in IDA. The
    most concrete example of this is the fact that IDA is a single-threaded application.
    No effort whatsoever is made to synchronize access to low-level database structures,
    nor does the SDK provide facilities for doing so. For IDA versions earlier than
    5.5, you should never create additional threads that may simultaneously access
    the database. For versions 5.5 and later, you may create additional threads, but
    any calls to SDK functions should be queued using the `exec_request_t and execute_sync`
    function described in *kernwin.hpp*. Also, you should understand that any blocking^([[114](#ftn.CHP-16-FN-1)])
    operations you perform will render IDA unresponsive until the operation completes.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用C++时，您当然可以访问各种C++库，包括您操作系统的本地API。通过利用这些库，您可能会倾向于将各种复杂的功能纳入您构建的任何模块中。然而，您在选择以这种方式纳入的功能时应该非常小心，因为这可能会导致IDA不稳定。最具体的例子是，IDA是一个单线程应用程序。没有任何努力去同步访问低级数据库结构，SDK也不提供这样做的方法。对于5.5版本之前的IDA版本，您绝对不应该创建可能同时访问数据库的额外线程。对于5.5版本及以后的版本，您可以创建额外的线程，但任何对SDK函数的调用都应该使用在*kernwin.hpp*中描述的`exec_request_t`和`execute_sync`函数进行排队。此外，您应该了解，您执行的任何阻塞操作都将使IDA在操作完成之前无响应。
- en: In this chapter we introduce some of the core capabilities of the SDK. You will
    find these capabilities useful whether you are creating plug-ins, loader modules,
    or processor modules. As each of these types of modules is covered individually
    in the following three chapters, the examples in this chapter are offered without
    attempting to supply a specific context in which they might be used.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了SDK的一些核心功能。无论您是在创建插件、加载模块还是处理模块，您都会发现这些功能非常有用。由于在接下来的三个章节中会分别详细介绍这些类型的模块，因此本章中的示例提供时并未试图提供它们可能被使用的特定上下文。
- en: SDK Introduction
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDK简介
- en: IDA’s SDK is distributed in much the same manner as the other IDA extras that
    we have discussed so far. The Zip file containing the SDK can be found on your
    original IDA CD, or authorized users can download the SDK from the Hex-Rays website.
    Each version of the SDK is named for the version of IDA with which it is compatible
    (for example, *idasdk61.zip* goes with IDA version 6.1). The SDK features the
    same minimalist documentation typically found in other IDA-related tools, which
    in the case of the SDK means a top-level *readme.txt* file and additional README
    files for plug-ins, processor modules, and loaders.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的SDK的分布方式与其他我们之前讨论过的IDA附加组件非常相似。包含SDK的Zip文件可以在您原始的IDA CD上找到，或者授权用户可以从Hex-Rays网站下载SDK。每个SDK版本都是以与之兼容的IDA版本命名的（例如，*idasdk61.zip*与IDA版本6.1相匹配）。SDK具有与其他IDA相关工具中常见的相同简约文档，对于SDK来说，这意味着一个顶级的*readme.txt*文件以及插件、处理模块和加载器的附加README文件。
- en: The SDK defines the published programming interface that modules may use to
    interact with IDA. Prior to SDK version 4.9, it was not uncommon for these interfaces
    to change enough that a module that successfully compiled under SDK 4.8 might
    no longer compile under a newer SDK, such as version 4.9, without the need for
    changes. With the introduction of version 4.9 of the SDK, Hex-Rays chose to standardize
    the existing API, which means that not only would modules require no changes to
    compile successfully with newer versions of the SDK, but modules would also be
    binary compatible with newer versions of IDA. This means that module users need
    no longer wait for module authors to update their source code or make available
    updated binary versions of their modules each time a new version of IDA is released.
    It does not mean that existing API interfaces are completely frozen; Hex-Rays
    continues to introduce new features with each new version of the SDK (that is,
    each new SDK is a superset of its predecessor). Modules that make use of these
    newer features are typically not compatible with older versions of IDA or the
    SDK. That said, there have been occasions where, for various reasons, functions
    have been renamed or marked as obsolete. The SDK offers macros to allow or disallow
    the use of deprecated functions, making it easy to note when a function has been
    deprecated.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 定义了模块可以用来与 IDA 交互的已发布编程接口。在 SDK 版本 4.9 之前，这些接口的变化足够大，以至于在 SDK 4.8 下成功编译的模块可能在新版本的
    SDK（如版本 4.9）下不再编译，而无需进行更改。随着 SDK 4.9 版本的引入，Hex-Rays 选择标准化现有的 API，这意味着模块不仅无需更改即可成功编译
    SDK 的新版本，而且模块与 IDA 的新版本也具有二进制兼容性。这意味着模块用户不再需要等待模块作者更新他们的源代码或提供模块的更新二进制版本，每次 IDA
    发布新版本时。但这并不意味着现有的 API 接口完全冻结；Hex-Rays 继续在每个 SDK 的新版本中引入新功能（即每个新 SDK 都是前一个 SDK
    的超集）。利用这些新功能的模块通常与 IDA 或 SDK 的旧版本不兼容。尽管如此，由于各种原因，有时函数会被重命名或标记为已弃用。SDK 提供宏来允许或禁止使用已弃用的函数，这使得记录函数何时被弃用变得容易。
- en: SDK Installation
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDK 安装
- en: Prior to version 5.4, the Zip file containing the SDK does not contain a top-level
    directory. Because the SDK shares several subdirectory names with IDA, it is highly
    recommended that you create a dedicated SDK directory, such as idasdk53, and extract
    the SDK contents into that directory. This will make it much easier to distinguish
    SDK components from IDA components. Beginning with version 5.4, the IDA SDK is
    packaged within a top-level SDK directory, such as idasdk61, so this step is no
    longer needed. There is no requirement to install the SDK in a specific location
    relative to *<IDADIR>*. Regardless of where you choose to install your SDK, we
    will refer to the SDK directory generically as *<SDKDIR>* for the remainder of
    the book.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 5.4 之前，包含 SDK 的 Zip 文件不包含顶级目录。由于 SDK 与 IDA 共享多个子目录名称，强烈建议您创建一个专门的 SDK 目录，例如
    idasdk53，并将 SDK 内容提取到该目录中。这将使区分 SDK 组件和 IDA 组件变得容易得多。从版本 5.4 开始，IDA SDK 被打包在一个顶级
    SDK 目录中，例如 idasdk61，因此此步骤不再需要。无需在相对于 *<IDADIR>* 的特定位置安装 SDK。无论您选择在何处安装 SDK，我们将在本书的其余部分将
    SDK 目录通称为 *<SDKDIR>*。
- en: SDK Layout
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDK 布局
- en: A basic understanding of the directory structure used within the SDK will be
    helpful, both in knowing where you might find documentation and in knowing where
    you can expect to find the modules that you build. A quick rundown of what you
    can expect to find in the SDK follows.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对 SDK 中使用的目录结构的了解将有所帮助，这不仅有助于了解您可能在何处找到文档，还有助于了解您可以在何处找到您构建的模块。以下是您在 SDK 中可以期望找到的内容的简要概述。
- en: '**bin directory**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**bin 目录**'
- en: This directory is where the example build scripts save their compiled modules
    following a successful build. Installing a module involves copying the module
    from the appropriate subdirectory within *bin* to the appropriate subdirectory
    in *<IDADIR>*. Module installation will be covered in more detail in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture"), [Chapter 18](ch18.html "Chapter 18. Binary
    Files and IDA Loader Modules"), and [Chapter 19](ch19.html "Chapter 19. IDA Processor
    Modules"). This directory also contains a postprocessing tool required for the
    creation of processor modules.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录是示例构建脚本在成功构建后保存其编译模块的地方。安装模块涉及将模块从 *bin* 目录中的适当子目录复制到 *<IDADIR>* 目录中的适当子目录。模块安装将在第
    17 章（[第 17 章。IDA 插件架构](ch17.html "Chapter 17. The IDA Plug-in Architecture")）、第
    18 章（[第 18 章。二进制文件和 IDA 加载模块](ch18.html "Chapter 18. Binary Files and IDA Loader
    Modules")）和第 19 章（[第 19 章。IDA 处理器模块](ch19.html "Chapter 19. IDA Processor Modules")）中更详细地介绍。此目录还包含创建处理器模块所需的后期处理工具。
- en: '**etc directory**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**etc 目录**'
- en: This directory contains source code for two utilities that are required to build
    some SDK modules. Compiled versions of these utilities are also included with
    the SDK.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含构建某些 SDK 模块所需的两个实用程序的源代码。这些实用程序的编译版本也包含在 SDK 中。
- en: '**include directory**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**include 目录**'
- en: This directory contains the header files that define the interface to the IDA
    API. In short, every API data structure that you are allowed to use and every
    API function that you are allowed to call are declared in one of the header files
    in this directory. The SDK’s top-level *readme.txt* file contains an overview
    of some of the more commonly used header files in this directory. The files in
    this directory constitute the bulk of the documentation (as in “read the source”)
    for the SDK.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含定义 IDA API 接口的头文件。简而言之，你被允许使用的每个 API 数据结构以及你被允许调用的每个 API 函数都声明在此目录中的一个头文件中。SDK
    的顶层 *readme.txt* 文件包含此目录中一些常用头文件的概述。此目录中的文件构成了 SDK 文档的大部分内容（即“阅读源代码”）。
- en: '**ldr directory**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**ldr 目录**'
- en: This directory contains the source code and build scripts for several example
    loader modules. The README file for loaders is nothing more than a rundown of
    the contents of this directory.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含几个示例加载模块的源代码和构建脚本。加载器的 README 文件不过是此目录内容的概述。
- en: '**lib directory**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**lib 目录**'
- en: This directory contains a number of subdirectories, which in turn contain the
    link libraries required to build various IDA modules. The subdirectories are named
    after the compiler with which they should be used. For example, `x86_win_vc_32`
    (6.1 and later) or `vc.w32` (6.0 and earlier) contains the library to use with
    Visual Studio and 32-bit IDA on Windows, while `x64_mac_gcc_64` (6.1 and later)
    or `gcc64.mac64` (6.0 and earlier) contains the library for use with 64-bit IDA
    on OSX platforms.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含多个子目录，这些子目录又包含构建各种 IDA 模块所需的链接库。子目录以应使用的编译器命名。例如，`x86_win_vc_32`（6.1 及以后版本）或
    `vc.w32`（6.0 及以前版本）包含用于 Windows 上 Visual Studio 和 32 位 IDA 的库，而 `x64_mac_gcc_64`（6.1
    及以后版本）或 `gcc64.mac64`（6.0 及以前版本）包含用于 OSX 平台上 64 位 IDA 的库。
- en: '**module directory**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**module 目录**'
- en: This directory contains the source code and build scripts for several example
    processor modules. The README file for processor modules is nothing more than
    a rundown of the contents of this directory.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含几个示例处理器模块的源代码和构建脚本。处理器模块的 README 文件不过是此目录内容的概述。
- en: '**plug-ins directory**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**插件目录**'
- en: This directory contains the source code and build scripts for several example
    plug-in modules. The README file for plug-ins provides a high-level overview of
    the plug-in architecture.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含几个示例插件模块的源代码和构建脚本。插件的 README 文件提供了插件架构的高级概述。
- en: '**top-level directory**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶层目录**'
- en: The top level of the SDK contains several make files used for building modules
    as well as the main *readme.txt* file for the SDK. Several additional *install_xxx.txt*
    files contain information regarding installation and configuration for various
    compilers (for example, *install_visual.txt* discusses Visual Studio configuration).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 的顶层包含用于构建模块的几个 make 文件以及 SDK 的主要 *readme.txt* 文件。几个额外的 *install_xxx.txt*
    文件包含有关各种编译器（例如，*install_visual.txt* 讨论了 Visual Studio 配置）的安装和配置信息。
- en: Keep in mind that documentation on using the SDK is sparse. For most developers,
    knowledge of the SDK has been derived through trial and error and extensive exploration
    of the contents of the SDK. You may have some luck posting questions to the *Research
    & Resources* forum on the Hex-Rays support forums, where other IDA users familiar
    with the SDK may answer them. An excellent third-party resource providing an introduction
    to the SDK and plug-in writing is Steve Micallef’s guide titled *IDA Plug-in Writing
    in C/C++*.^([[115](#ftn.CHP-16-FN-2)])
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，关于使用SDK的文档很少。对于大多数开发者来说，对SDK的了解是通过试错和广泛探索SDK内容得来的。你可以在Hex-Rays支持论坛的*Research
    & Resources*论坛上发帖提问，那里熟悉SDK的其他IDA用户可能会回答你的问题。一本优秀的第三方资源，介绍了SDK和插件编写，是Steve Micallef的指南，标题为*IDA
    Plug-in Writing in C/C++*。[^[[115](#ftn.CHP-16-FN-2])]
- en: Configuring a Build Environment
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置构建环境
- en: One of the more frustrating aspects of using the SDK is not related to programming
    at all. Instead, you may find that it is relatively easy to code up a solution
    to a problem only to find that it is virtually impossible to successfully build
    your module. This is true because it can be difficult to support a wide variety
    of compilers with a single code base, and coding a solution is complicated by
    the fact that library file formats recognized by Windows compilers are often incompatible
    with one another.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SDK的一个更令人沮丧的方面与编程无关。相反，你可能发现，编写一个解决问题的方案相对容易，但最终发现几乎不可能成功构建你的模块。这是因为支持单个代码库的广泛编译器可能很困难，而编写解决方案的复杂性又因Windows编译器识别的库文件格式通常不兼容而加剧。
- en: 'All of the examples included with the SDK were created to be built using Borland
    tools. From *install_make.txt* we have the following quote from Ilfak:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: SDK中包含的所有示例都是为使用Borland工具构建而创建的。从*install_make.txt*中，我们可以找到Ilfak的以下引言：
- en: WIN32 versions can be created only by Borland C++ CBuilder v4.0\. Probably the
    old BCC v5.2 will work too, but I haven’t checked it.
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有使用Borland C++ CBuilder v4.0才能创建WIN32版本。可能旧的BCC v5.2也能用，但我还没有验证过。
- en: That being said, other *install_xxx* files offer pointers on how to successfully
    build modules with other compilers. A few of the example modules contain files
    for building with Visual Studio (*<SDKDIR>/plugins/vcsample*, for example), while
    *install_visual.txt* offers a series of steps for properly configuring SDK projects
    using Visual C++ Express 2005.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，其他*install_xxx*文件提供了如何使用其他编译器成功构建模块的指导。一些示例模块包含用于Visual Studio构建的文件（例如，*<SDKDIR>/plugins/vcsample*），而*install_visual.txt*提供了使用Visual
    C++ Express 2005正确配置SDK项目的步骤。
- en: In order to build modules using Unix-style tools, either on a Unix-style system
    such as Linux or using an environment such as MinGW, the SDK provides a script
    named *idamake.pl* that converts the Borland-style make files into Unix-style
    make files prior to initiating the build process. This process is discussed in
    *install_linux.txt*.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Unix风格的工具构建模块，无论是在Unix风格的系统（如Linux）上还是在MinGW这样的环境中，SDK提供了一个名为*idamake.pl*的脚本，该脚本在启动构建过程之前将Borland风格的make文件转换为Unix风格的make文件。这个过程在*install_linux.txt*中有详细讨论。
- en: Note
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The command-line build scripts provided with the SDK expect an environment variable
    named IDA to point to *<SDKDIR>* . You can set this globally for all scripts by
    editing *<SDKDIR>/allmake.mak* and *<SDKDIR>/allmake.unx* to set this variable
    or by adding an IDA environment variable to your global environment.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: SDK提供的命令行构建脚本期望有一个名为IDA的环境变量指向*<SDKDIR>*。你可以通过编辑*<SDKDIR>/allmake.mak*和*<SDKDIR>/allmake.unx*来设置此变量，或者通过向你的全局环境添加IDA环境变量来设置它。
- en: Steve Micallef’s guide also provides excellent instructions for configuring
    build environments for building plug-ins with various compilers. Our personal
    preference when building SDK modules for Windows versions of IDA is to use the
    MinGW tools gcc and make. The examples presented in [Chapter 17](ch17.html "Chapter 17. The
    IDA Plug-in Architecture"), [Chapter 18](ch18.html "Chapter 18. Binary Files and
    IDA Loader Modules"), and [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules")
    include makefiles and Visual Studio project files that do not rely on any of the
    build scripts included with the SDK and that are easy to modify to suit the needs
    of your projects. Module-specific build configuration will also be discussed in
    each of these chapters.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Micallef的指南还提供了配置构建环境的优秀说明，用于使用各种编译器构建插件。我们个人在为IDA的Windows版本构建SDK模块时，更喜欢使用MinGW工具gcc和make。在第17章（[Chapter 17. The
    IDA Plug-in Architecture](ch17.html "Chapter 17. The IDA Plug-in Architecture")）、第18章（[Chapter 18. Binary
    Files and IDA Loader Modules](ch18.html "Chapter 18. Binary Files and IDA Loader
    Modules")）和第19章（[Chapter 19. IDA Processor Modules](ch19.html "Chapter 19. IDA
    Processor Modules")）中提供的示例包括不依赖于SDK中包含的任何构建脚本的makefiles和Visual Studio项目文件，并且易于修改以满足您项目的需求。每个章节也将讨论特定模块的构建配置。
- en: '* * *'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[114](#CHP-16-FN-1)]) A blocking operation is an action that causes a program
    to come to a halt while it awaits completion of the action.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[114](#CHP-16-FN-1)]) 阻塞操作是指导致程序停止执行，等待操作完成的动作。
- en: ^([[115](#CHP-16-FN-2)]) See [http://www.binarypool.com/idapluginwriting/](http://www.binarypool.com/idapluginwriting/).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[115](#CHP-16-FN-2)]) 查看 [http://www.binarypool.com/idapluginwriting/](http://www.binarypool.com/idapluginwriting/)。
- en: The IDA Application Programming Interface
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA应用程序编程接口
- en: IDA’s API is defined by the contents of the header files in *<SDKDIR>/include*.
    There is no single-source index of available functions (though Steve Micallef
    has collected a rather nice subset in his plug-in writing guide). Many prospective
    SDK programmers find this fact initially difficult to come to terms with. The
    reality is that there is never an easy-to-find answer to the question, “How do
    I do *x* using the SDK?” The two principal options for answering such questions
    are to post the questions to an IDA user’s forum or attempt to answer them yourself
    by searching through the API documentation. What documentation, you say? Why,
    the header files, of course. Granted, these are not the most searchable of documents,
    but they do contain the complete set of API features. In this case, `grep` (or
    a suitable replacement, preferably built into your programming editor) is your
    friend. The catch is knowing what to search for, which is not always obvious.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的API由*<SDKDIR>/include*中的头文件内容定义。没有单一源索引可用的函数（尽管Steve Micallef在他的插件编写指南中收集了一个相当不错的子集）。许多潜在的SDK程序员最初发现这个事实很难接受。现实是，对于“我如何使用SDK来做*x*？”这样的问题，永远没有容易找到的答案。回答此类问题的两种主要选项是将问题发布到IDA用户论坛，或者通过搜索API文档自行尝试回答。你说什么文档？当然，是头文件。诚然，这些文件不是最容易搜索的文档，但它们确实包含了完整的API功能集。在这种情况下，`grep`（或合适的替代品，最好是集成到您的编程编辑器中）是您的朋友。难点在于知道要搜索什么，这并不总是显而易见的。
- en: There are a few ways to try to narrow your searches through the API. The first
    way is to leverage your knowledge of the IDC scripting language and attempt to
    locate similar functionality within the SDK using keywords and possibly function
    names derived from IDC. However—and this is an extremely frustrating point—while
    the SDK may contain functions that perform tasks identical to those of IDC functions,
    the names of those functions are seldom identical. This results in programmers
    learning two sets of API calls, one for use with IDC and one for use with the
    SDK. In order to address this situation, [Appendix B](apb.html "Appendix B. IDC/SDK
    Cross-Reference") presents a complete list of IDC functions and the corresponding
    SDK 6.1 actions that are carried out to execute those functions.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以尝试缩小API搜索的范围。第一种方法是利用您对IDC脚本语言的知识，并尝试使用关键字和可能从IDC派生的函数名在SDK中定位类似的功能。然而——这是一个极其令人沮丧的点——虽然SDK可能包含执行与IDC函数相同任务的函数，但这些函数的名称很少相同。这导致程序员学习两套API调用，一套用于IDC，一套用于SDK。为了解决这个问题，[附录B](apb.html
    "Appendix B. IDC/SDK Cross-Reference")提供了一个IDC函数的完整列表以及执行这些函数的相应SDK 6.1操作。
- en: The second technique for narrowing down SDK-related searches is to become familiar
    with the content and, more important, the purpose of the various SDK header files.
    In general, related functions and associated data structures are grouped into
    headers files based on functional groups. For example, SDK functions that allow
    interaction with a user are grouped into *kernwin.hpp*. When a `grep`-style search
    fails to locate a capability that you require, some knowledge of which header
    file relates to that capability will narrow your search and hopefully limit the
    number of files that you need to dig deeper into.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小与SDK相关搜索的第二种技术是熟悉各种SDK头文件的内容及其目的。一般来说，相关函数和关联的数据结构根据功能组分组到头文件中。例如，允许与用户交互的SDK函数被分组到*kernwin.hpp*。当使用`grep`风格的搜索无法找到所需的特性时，了解哪个头文件与该特性相关将缩小搜索范围，并有望限制需要深入挖掘的文件数量。
- en: Header Files Overview
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件概述
- en: 'While the SDK’s *readme.txt* files provide a high-level overview of the most
    commonly used header files, this section highlights some other useful information
    for working with these files. First, the majority of the header files use the
    *.hpp* suffix, while a few use the *.h* suffix. This can easily lead to trivial
    errors when naming header files to be included in your files. Second, *ida.hpp*
    is the main header file for the SDK and should be included in all SDK-related
    projects. Third, the SDK utilizes preprocessor directives designed to preclude
    access to functions that Hex-Rays considers dangerous (such as `strcpy` and `sprintf`).
    For a complete list of these functions refer to the `USE_DANGEROUS_FUNCTIONS`
    macro prior to including *ida.hpp* in your own files. An example is shown here:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SDK的*readme.txt*文件提供了最常用头文件的高级概述，但本节突出了使用这些文件的一些其他有用信息。首先，大多数头文件使用*.hpp*后缀，而少数使用*.h*后缀。这很容易在命名要包含在文件中的头文件时导致微不足道的错误。其次，*ida.hpp*是SDK的主要头文件，应包含在所有与SDK相关的项目中。第三，SDK使用预处理指令来阻止对Hex-Rays认为危险的功能（如`strcpy`和`sprintf`）的访问。在将*ida.hpp*包含到自己的文件中之前，请参考`USE_DANGEROUS_FUNCTIONS`宏以获取这些功能的完整列表。以下是一个示例：
- en: '[PRE31]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Failure to define `USE_DANGEROUS_FUNCTIONS` will result in a build error to
    the effect that `dont_use_snprintf` is an undefined symbol (in the case of an
    attempt to use the `snprintf` function). In order to compensate for restricting
    access to these so-called dangerous functions, the SDK defines safer equivalents
    for each, generally in the form of a `qstr`*`XXXX`* function such as `qstrncpy`
    and `qsnprintf`. These safer versions are also declared in *pro.h*.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未定义`USE_DANGEROUS_FUNCTIONS`，将导致构建错误，显示`dont_use_snprintf`是一个未定义的符号（在尝试使用`snprintf`函数的情况下）。为了补偿限制对这些所谓的危险函数的访问，SDK为每个函数定义了更安全的等效函数，通常以`qstr`*`XXXX`*函数的形式，如`qstrncpy`和`qsnprintf`。这些更安全的版本也声明在*pro.h*中。
- en: Along similar lines, the SDK restricts access to many standard file input/output
    variables and functions such as `stdin`, `stdout`, `fopen`, `fwrite`, and `fprintf`.
    This restriction is due in part to limitations of the Borland compiler. Here again
    the SDK defines replacement functions in the form of `q`*`XXX`* counterparts such
    as `qfopen` and `qfprintf`. If you require access to the standard file functions,
    then you must define the `USE_STANDARD_FILE_FUNCTIONS` macro prior to including
    *fpro.h* (which is included from *kernwin.hpp*, which is, in turn, included from
    several other files).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，SDK限制了访问许多标准文件输入/输出变量和函数，如`stdin`、`stdout`、`fopen`、`fwrite`和`fprintf`。这种限制部分是由于Borland编译器的限制。在这里，SDK也定义了替换函数，形式为`q`*`XXX`*对应函数，如`qfopen`和`qfprintf`。如果您需要访问标准文件函数，则必须在包含*fpro.h*（它从*kernwin.hpp*包含，而*kernwin.hpp*又从几个其他文件包含）之前定义`USE_STANDARD_FILE_FUNCTIONS`宏。
- en: In most cases, each SDK header file contains a brief description of the file’s
    purpose and fairly extensive comments describing the data structures and functions
    that are declared in the file. Together these comments constitute IDA’s API documentation.
    Brief descriptions of some of the more commonly used SDK header files follow.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，每个SDK头文件都包含对文件目的的简要描述，以及相当详尽的注释，描述了在文件中声明的数据结构和函数。这些注释共同构成了IDA的API文档。以下是一些常用SDK头文件的简要描述。
- en: '**area.hpp**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**area.hpp**'
- en: This file defines the `area_t` struct, which represents a contiguous block of
    addresses within a database. This struct serves as the base class for several
    other classes that build on the concept of an address range. It is seldom necessary
    to include this file directly, as it is typically included in files defining subclasses
    of `area_t`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了`area_t`结构，它表示数据库中地址的连续块。此结构作为基于地址范围概念的几个其他类的基类。通常不需要直接包含此文件，因为它通常包含在定义`area_t`子类的文件中。
- en: '**auto.hpp**'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**auto.hpp**'
- en: This file declares functions used to work with IDA’s autoanalyzer. The autoanalyzer
    performs queued analysis tasks when IDA is not busy processing userinput events.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了用于与IDA的自动分析器交互的函数。自动分析器在IDA忙于处理用户输入事件时执行排队分析任务。
- en: '**bytes.hpp**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**bytes.hpp**'
- en: This file declares functions for working with individual database bytes. Functions
    declared in this file are used to read and write individual database bytes as
    well as manipulate the characteristics of those bytes. Miscellaneous functions
    also provide access to flags associated with instruction operands, while other
    functions allow manipulation of regular and repeatable comments.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了用于处理单个数据库字节的函数。在此文件中声明的函数用于读取和写入单个数据库字节以及操作这些字节的特征。一些杂项函数还提供对与指令操作数相关的标志的访问，而其他函数允许操作常规和可重复的注释。
- en: '**dbg.hpp**'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**dbg.hpp**'
- en: This file declares functions offering programmatic control of IDA’s debugger.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了提供对IDA调试器程序控制功能的函数。
- en: '**entry.hpp**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**entry.hpp**'
- en: This header declares functions for working with a file’s entry points. For shared
    libraries, each exported function or data value is considered an entry point.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 此头文件声明了用于处理文件入口点的函数。对于共享库，每个导出的函数或数据值都被视为入口点。
- en: '**expr.hpp**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr.hpp**'
- en: This file declares functions and data structures for working with IDC constructs.
    It is possible to modify existing IDC functions, add new IDC functions, or execute
    IDC statements from within modules.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了用于处理IDC构造的函数和数据结构。可以修改现有的IDC函数，添加新的IDC函数，或从模块内部执行IDC语句。
- en: '**fpro.h**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**fpro.h**'
- en: This file contains the alternative file I/O functions, such as `qfopen`, discussed
    previously.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含之前讨论过的替代文件I/O函数，如`qfopen`。
- en: '**frame.hpp**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**frame.hpp**'
- en: This header contains functions used to manipulate stack frames.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 此头文件包含用于操作堆栈帧的函数。
- en: '**funcs.hpp**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**funcs.hpp**'
- en: This header contains functions and data structures for working with disassembled
    functions as well as functions for working with FLIRT signatures.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此头文件包含用于处理反汇编函数以及用于处理FLIRT签名的函数和数据结构。
- en: '**gdl.hpp**'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**gdl.hpp**'
- en: This file declares support routines for generating graphs using either DOT or
    GDL.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了使用DOT或GDL生成图的辅助例程。
- en: '**ida.hpp**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**ida.hpp**'
- en: This is the main header file required for working with the SDK. This file contains
    the definition of the `idainfo` structure as well as the declaration of the global
    variable `inf`, which contains a number of fields containing information about
    the current database as well as fields initialized from configuration file settings.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用SDK所需的主要头文件。此文件包含`idainfo`结构的定义以及全局变量`inf`的声明，该变量包含有关当前数据库的信息的多个字段，以及从配置文件设置初始化的字段。
- en: '**idp.hpp**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**idp.hpp**'
- en: This file contains declarations of structures that form the foundation of processor
    modules. The global variable `ph`, which describes the current processor module,
    and the global variable `ash`, which describes the current assembler, are defined
    in this file.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含形成处理器模块基础的结构的声明。描述当前处理器模块的全局变量`ph`和描述当前汇编器的全局变量`ash`在此文件中定义。
- en: '**kernwin.hpp**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**kernwin.hpp**'
- en: This file declares functions for interacting with the user and the user interface.
    The SDK equivalents of IDC’s `Ask`*`XXX`* functions are declared here, as are
    functions used to set the display position and configure hotkey associations.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了与用户和用户界面交互的函数。这里声明了IDC的`Ask`*`XXX`*函数的SDK等效函数，以及用于设置显示位置和配置热键关联的函数。
- en: '**lines.hpp**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**lines.hpp**'
- en: This file declares functions for generating formatted, colorized disassembly
    lines.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了用于生成格式化、着色反汇编行的函数。
- en: '**loader.hpp**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**loader.hpp**'
- en: This file contains the declarations for the `loader_t` and `plugin_t` structures
    required for the creation of loader modules and plug-in modules, respectively,
    as well as functions useful during the file-loading phase and functions for activating
    plug-ins.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含用于创建加载模块和插件模块所需的 `loader_t` 和 `plugin_t` 结构的声明，以及在文件加载阶段有用的函数以及激活插件的函数。
- en: '**name.hpp**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**name.hpp**'
- en: This file declares functions for manipulating named locations (as opposed to
    names within structures or stack frames, which are covered in *stuct.hpp* and
    *funcs.hpp*, respectively).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了用于操作命名位置（与结构或堆栈帧中的名称相对，分别由 *stuct.hpp* 和 *funcs.hpp* 覆盖）的函数。
- en: '**netnode.hpp**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**netnode.hpp**'
- en: Netnodes are the lowest-level storage structure accessible via the API. The
    details of netnodes are typically hidden by the IDA user interface. This file
    contains the definition of the `netnode` class and functions for low-level manipulation
    of netnodes.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Netnodes是通过API可访问的最底层存储结构。Netnodes的详细信息通常被IDA用户界面隐藏。此文件包含 `netnode` 类的定义以及用于低级操作netnodes的函数。
- en: '**pro.h**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**pro.h**'
- en: This file includes the top-level typedefs and macros required in any SDK module.
    You do not need to explicitly include this file in your projects, as it is included
    from *ida.hpp*. Among other things, the `IDA_SDK_VERSION` macro is defined in
    this file. `IDA_SDK_VERSION` provides a means to determine with which version
    of the SDK a module is being built, and it can be tested to provide conditional
    compilation when using different versions of the SDK. Note that `IDA_SDK_VERSION`
    was introduced with SDK version 5.2\. Prior to SDK 5.2, there is no official way
    to determine which SDK is being used. An unofficial header file that defines `IDA_SDK_VERSION`
    for older versions of the SDK (*sdk_versions.h*) is available on this book’s website.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含任何SDK模块中所需的顶层typedefs和宏。您不需要在项目中显式包含此文件，因为它是从 *ida.hpp* 中包含的。此外，此文件中定义了
    `IDA_SDK_VERSION` 宏。`IDA_SDK_VERSION` 提供了一种确定模块正在使用哪个SDK版本的方法，并且可以在使用不同版本的SDK时进行测试，以提供条件编译。请注意，`IDA_SDK_VERSION`
    是从SDK版本5.2引入的。在SDK 5.2之前，没有官方的方法来确定正在使用哪个SDK。一个非官方的头文件（*sdk_versions.h*），它为旧版本的SDK定义了
    `IDA_SDK_VERSION`，可在本书的网站上找到。
- en: '**search.hpp**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**search.hpp**'
- en: This file declares functions for performing different types of searches on a
    database.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了在数据库上执行不同类型搜索的函数。
- en: '**segment.hpp**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**segment.hpp**'
- en: This file contains the declaration of the `segment_t` class, a subclass of `area_t`,
    which is used to describe individual sections (`.text`, `.data`, etc.) within
    a binary. Functions for working with segments are also declared here.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含 `segment_t` 类的声明，它是 `area_t` 的子类，用于描述二进制文件中的单个部分（如 `.text`、`.data` 等）。还在此声明了用于处理段面的函数。
- en: '**struct.hpp**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**struct.hpp**'
- en: This file contains the declaration of the `struc_t` class and functions for
    manipulating structures within a database.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含 `struc_t` 类的声明以及用于在数据库中操作结构的函数。
- en: '**typeinf.hpp**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**typeinf.hpp**'
- en: This file declares functions for working with IDA type libraries. Among other
    things, functions declared here offer access to function signatures, including
    function return types and parameter sequences.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了用于处理IDA类型库的函数。其中，此处声明的函数提供了对函数签名的访问，包括函数返回类型和参数序列。
- en: '**ua.hpp**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**ua.hpp**'
- en: This file declares the `op_t` and `insn_t` classes used extensively in processor
    modules. Also declared here are functions used for disassembling individual instructions
    and for generating the text for various portions of each disassembled line.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了在处理器模块中广泛使用的 `op_t` 和 `insn_t` 类。还在此声明了用于反汇编单个指令和为每行反汇编的不同部分生成文本的函数。
- en: '**xref.hpp**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**xref.hpp**'
- en: This file declares the datatypes and functions required for adding, deleting,
    and iterating code and data cross-references.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件声明了添加、删除和迭代代码和数据交叉引用所需的datatypes和函数。
- en: The preceding list describes approximately half of the header files that ship
    with the SDK. You are encouraged to familiarize yourself not only with the files
    in this list but also with all of the other header files as well, as you dig deeper
    into the SDK. Functions that make up the published API are marked as `ida_export`.
    Only functions designated as `ida_export` are exported in the link libraries that
    ship with the SDK. Don’t be misled by the use of `idaapi`, as it merely signifies
    that a function is to use the `stdcall` calling convention on Windows platforms
    only. You may occasionally run across interesting-looking functions that are not
    designated as `ida_export`; you cannot use these functions in your modules.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表描述了与 SDK 一起提供的头文件的大约一半。我们鼓励您不仅熟悉列表中的文件，还要熟悉 SDK 中所有其他头文件，因为您在深入研究 SDK 时，会用到这些文件。构成已发布
    API 的函数被标记为 `ida_export`。只有被指定为 `ida_export` 的函数才会被包含在 SDK 一起提供的链接库中。不要被 `idaapi`
    的使用所误导，因为它仅仅表示该函数在 Windows 平台上将使用 `stdcall` 调用约定。您可能会偶尔遇到一些看起来很有趣但未指定为 `ida_export`
    的函数；您不能在您的模块中使用这些函数。
- en: Netnodes
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Netnodes
- en: Much of IDA’s API is built around C++ classes that model various aspects of
    a disassembled binary. The `netnode` class, on the other hand, seems wrapped in
    mystery because it appears to have no direct relationship to constructs within
    binary files (sections, functions, instructions, etc.).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 的 API 的大部分都是围绕 C++ 类构建的，这些类模拟了解析二进制文件的各个方面。另一方面，`netnode` 类似乎被神秘地包裹着，因为它似乎与二进制文件中的结构（段、函数、指令等）没有直接关系。
- en: Netnodes are the lowest-level and most-general-purpose data storage mechanism
    accessible within an IDA database. As a module programmer, you will seldom be
    required to work directly with netnodes. Many of the higher-level data structures
    hide the fact that they ultimately rely on netnodes for persistent storage within
    a database. Some of the ways that netnodes are used within a database are detailed
    in the file *nalt.hpp*, in which we learn, for example, that information about
    the shared libraries and functions that a binary imports is stored in a netnode
    named `import_node` (yes, netnodes may have names). Netnodes are also the persistent
    storage mechanisms that facilitate IDC’s global arrays.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Netnodes 是在 IDA 数据库中可访问的最低级和最通用的数据存储机制。作为一个模块程序员，您很少需要直接与 netnodes 一起工作。许多高级数据结构隐藏了它们最终依赖于
    netnodes 在数据库中进行持久存储的事实。在文件 *nalt.hpp* 中详细介绍了 netnodes 在数据库中的使用方式，例如，我们了解到关于二进制导入的共享库和函数的信息存储在一个名为
    `import_node` 的 netnode 中（是的，netnodes 可以有名称）。Netnodes 也是 IDC 的全局数组所使用的持久存储机制。
- en: Netnodes are described in extensive detail in the file *netnode.hpp*. But from
    a high-level perspective, netnodes are storage structures used internally by IDA
    for a variety of purposes. However, their precise structure is kept hidden, even
    to SDK programmers. To provide an interface to these storage structures, the SDK
    defines a `netnode` class, which functions as an opaque wrapper around this internal
    storage structure. The `netnode` class contains a single data member called `netnodenumber`,
    which is an integer identifier used to access the internal representation of a
    netnode. Every netnode is uniquely identified by its `netnodenumber`. On 32-bit
    systems the `netnodenumber` is a 32-bit quantity, allowing for 2^(32) unique netnodes.
    On 64-bit systems, a `netnodenumber` is a 64-bit integer, which allows for 2^(64)
    unique netnodes. In most cases, the `netnodenumber` represents a virtual address
    within the database, which creates a natural mapping between each address within
    a database and any net-node that might be required to store information associated
    with that address. Comment text is an example of arbitrary information that may
    be associated with an address and thus stored within a netnode associated with
    that address.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *netnode.hpp* 中详细描述了 Netnodes。但从高层次的角度来看，netnodes 是 IDA 内部用于各种目的的存储结构。然而，它们的精确结构被隐藏起来，即使是
    SDK 程序员也无法得知。为了提供对这些存储结构的接口，SDK 定义了一个 `netnode` 类，它作为内部存储结构的不可见包装器。`netnode` 类包含一个名为
    `netnodenumber` 的单一数据成员，它是一个整数标识符，用于访问 netnode 的内部表示。每个 netnode 都通过其 `netnodenumber`
    唯一标识。在 32 位系统上，`netnodenumber` 是一个 32 位量，允许有 2^(32) 个唯一的 netnodes。在 64 位系统上，`netnodenumber`
    是一个 64 位整数，允许有 2^(64) 个唯一的 netnodes。在大多数情况下，`netnodenumber` 代表数据库中的一个虚拟地址，这就在数据库中的每个地址和可能需要存储与该地址相关信息的任何
    netnode 之间创建了一种自然映射。注释文本是可能与地址相关联的任意信息的一个例子，因此它被存储在与之相关的 netnode 中。
- en: The recommended way to manipulate netnodes is by invoking member functions of
    the `netnode` class using an instantiated `netnode` object. Reading through *netnode.hpp*,
    you will notice that a number of nonmember functions exist that seem to support
    netnode manipulation. Use of these functions is discouraged in favor of member
    functions. You will note, however, that most of the member functions in the `netnode`
    class are thin wrappers around one of the nonmember functions.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 操作网节点的推荐方法是调用`netnode`类的成员函数，使用实例化的`netnode`对象。阅读`netnode.hpp`，你会注意到存在一些非成员函数，似乎支持对网节点的操作。建议使用成员函数而不是这些函数。然而，你会注意到`netnode`类中的大多数成员函数都是围绕一个非成员函数的薄包装。
- en: Internally, netnodes can be used to store several different types of information.
    Each netnode may be associated with a name of up to 512 characters and a primary
    value of up to 1,024 bytes. Member functions of the `netnode` class are provided
    to retrieve (`name`) or modify (`rename`) a netnode’s name. Additional member
    functions allow you to treat a netnode’s primary value as an integer (`set_long`,
    `long_value`), a string (`set`, `valstr`), or an arbitrary binary blob^([[116](#ftn.CHP-16-FN-3)])
    (`set`, `valobj`). The function used inherently determines how the primary value
    is treated.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，网节点可以用来存储几种不同类型的信息。每个网节点可以关联一个最多512个字符的名称和一个最多1,024字节的主要值。`netnode`类的成员函数提供了检索（`name`）或修改（`rename`）网节点名称的功能。其他成员函数允许你将网节点的主要值视为整数（`set_long`,
    `long_value`）、字符串（`set`, `valstr`）或任意二进制blob^([[116](#ftn.CHP-16-FN-3)])（`set`,
    `valobj`）。使用的函数本身决定了如何处理主要值。
- en: Here is where things get a little complicated. In addition to a name and a primary
    value, every `netnode` is also capable of storing 256 sparse arrays in which the
    array elements can be arbitrarily sized with values up to a maximum of 1,024 bytes
    each. These arrays fall into three overlapping categories. The first category
    of arrays is indexed using 32-bit index values and can potentially hold in excess
    of 4 billion items. The second category of arrays is indexed using 8-bit index
    values and can thus hold up to 256 items. The last category of arrays is actually
    hash tables that use strings for keys. Regardless of which of the three categories
    is used, each element of the array will accept values up to 1,024 bytes in size.
    In short, a netnode can hold a tremendous amount of data—now we just need to learn
    how to make it all happen.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得有些复杂。除了名称和主要值之外，每个`netnode`还能够存储256个稀疏数组，其中数组元素可以任意大小，每个元素的最大值可达1,024字节。这些数组分为三个重叠的类别。第一个类别的数组使用32位索引值进行索引，可以潜在地存储超过40亿个条目。第二个类别的数组使用8位索引值进行索引，因此可以存储多达256个条目。最后一个类别的数组实际上是使用字符串作为键的哈希表。无论使用哪三个类别，数组的每个元素都将接受大小最多为1,024字节的值。简而言之，网节点可以存储大量的数据——现在我们只需要学习如何让它发生。
- en: If you are wondering where all of this information gets stored, you are not
    alone. All netnode content is stored within btree nodes in an IDA database. Btree
    nodes in turn are stored in an ID0 file, which in turn is archived into an IDB
    file when you close your database. Any netnode content that you create will not
    be visible in any of IDA’s display windows; the data is yours to manipulate as
    you please. This is why netnodes are an ideal place for persistent storage for
    any plug-ins and scripts that you may wish to use to store results from one invocation
    to the next.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道所有这些信息都存储在哪里，你并不孤单。所有网节点内容都存储在IDA数据库中的btree节点内。btree节点反过来又存储在ID0文件中，当你关闭数据库时，这些文件会被存档到IDB文件中。你创建的任何网节点内容都不会在IDA的任何显示窗口中可见；数据由你自己随意操作。这就是为什么网节点是存储任何插件和脚本的理想位置，这些插件和脚本可以用来存储从一次调用到下一次调用的结果。
- en: Creating Netnodes
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建网节点
- en: 'A potentially confusing point about netnodes is that declaring a `netnode`
    variable within one of your modules does not necessarily create an internal representation
    of that netnode within the database. A netnode is not created internally until
    one of the following events takes place:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网节点的一个可能令人困惑的点是在你的模块中声明`netnode`变量并不一定在数据库内部创建该网节点的内部表示。网节点只有在以下事件之一发生时才会内部创建：
- en: The netnode is assigned a name.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网节点被分配了一个名称。
- en: The netnode is assigned a primary value.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网节点被分配了一个主要值。
- en: A value is stored into one of the netnode’s internal arrays.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值被存储到网节点的内部数组之一。
- en: There are three constructors available for declaring netnodes within your modules.
    The prototypes for each, extracted from *netnode.hpp*, and examples of their use
    are shown in [Example 16-1](ch16s02.html#declaring_netnodes "Example 16-1. Declaring
    netnodes").
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的模块中声明 netnodes 有三个构造函数可用。每个的原型，从 *netnode.hpp* 中提取，以及它们的使用示例，显示在 [示例 16-1](ch16s02.html#declaring_netnodes
    "示例 16-1. 声明 netnodes") 中。
- en: Example 16-1. Declaring netnodes
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-1. 声明 netnodes
- en: '[PRE32]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, only one netnode (`n3`) is guaranteed to exist within the
    database after the code has executed. Netnodes `n1` and `n2` may exist if they
    had been previously created and populated with data. Whether it previously existed
    or not, `n1` is capable of receiving new data at this point. If `n2` did not exist,
    meaning that no netnode named `$ node 2` could be found in the database, then
    `n2` must be explicitly created (![](httpatomoreillycomsourcenostarchimages854095.png)
    or ![](httpatomoreillycomsourcenostarchimages854099.png)) before data can be stored
    into it. If we want to guarantee that we can store data into `n2`, we need to
    add the following safety check:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，只有一个 netnode (`n3`) 在代码执行后保证存在于数据库中。如果之前已创建并填充了数据，则 netnodes `n1` 和 `n2`
    可能存在。在此点，`n1` 能够接收新数据。如果 `n2` 不存在，意味着在数据库中找不到名为 `$ node 2` 的 netnode，那么在将数据存储到其中之前，必须显式创建
    `n2` (![](httpatomoreillycomsourcenostarchimages854095.png) 或 ![](httpatomoreillycomsourcenostarchimages854099.png))。如果我们想保证能够将数据存储到
    `n2` 中，我们需要添加以下安全检查：
- en: '[PRE33]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding example demonstrates the use of the `nodeidx_t` operator, which
    allows a netnode to be cast to a `nodeidx_t`. The `nodeidx_t` operator simply
    returns the `netnodenumber` data member of the associated netnode and allows `netnode`
    variables to be easily converted into integers.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例演示了使用 `nodeidx_t` 操作符，它允许将 netnode 转换为 `nodeidx_t`。`nodeidx_t` 操作符简单地返回相关
    netnode 的 `netnodenumber` 数据成员，并允许将 `netnode` 变量轻松转换为整数。
- en: An important point to understand about netnodes is that a netnode *must* have
    a valid `netnodenumber` before you can store data into the netnode. A `netnodenumber`
    may be explicitly assigned, as with `n1` via a constructor shown at ![](httpatomoreillycomsourcenostarchimages854063.png)
    in the previous example. Alternatively, a `netnodenumber` may be internally generated
    when a netnode is created using the `create` flag in a constructor (as with `n3`
    via a constructor shown in ![](httpatomoreillycomsourcenostarchimages854093.png))
    or via the `create` function (as with `n2`). Internally assigned `netnodenumbers`
    begin with `0xFF000000` and increment with each newly created netnode.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 netnodes，一个需要理解的重要点是，在您可以将数据存储到 netnode 中之前，netnode *必须* 有一个有效的 `netnodenumber`。`netnodenumber`
    可以显式分配，如 `n1` 通过在先前的示例中显示的构造函数 (![](httpatomoreillycomsourcenostarchimages854063.png))。或者，当使用构造函数中的
    `create` 标志创建 netnode 时，`netnodenumber` 可以内部生成（如 `n3` 通过在先前的示例中显示的构造函数 (![](httpatomoreillycomsourcenostarchimages854093.png))），或者通过
    `create` 函数（如 `n2`）。内部分配的 `netnodenumbers` 以 `0xFF000000` 开头，并随着每个新创建的 netnode
    而递增。
- en: 'We have thus far neglected netnode `n0` in our example. As things currently
    stand, `n0` has neither a number nor a name. We could create `n0` by name using
    the `create` function in a manner similar to `n2`. Or we could use the alternate
    form of `create` to create an unnamed netnode with a valid, internally generated
    `netnodenumber`, as shown here:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在示例中忽略了 netnode `n0`。就目前情况而言，`n0` 既没有编号也没有名称。我们可以通过使用与 `n2` 类似的 `create`
    函数按名称创建 `n0`。或者，我们可以使用 `create` 的另一种形式创建一个无名称的 netnode，它具有有效的、内部生成的 `netnodenumber`，如下所示：
- en: '[PRE34]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point it is possible to store data into `n0`, though we have no way
    to retrieve that data in the future unless we record the assigned `netnodenumber`
    somewhere or assign `n0` a name. This demonstrates the fact that netnodes are
    easy to access when they are associated with a virtual address (similar to `n1`
    in our example). For all other netnodes, assigning a name makes it possible to
    perform a named lookup for all future references to the netnode (as with `n2`
    and `n3` in our example).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，可以将数据存储到 `n0` 中，尽管我们没有方法在未来检索这些数据，除非我们将分配的 `netnodenumber` 记录在某个地方或给 `n0`
    赋予一个名称。这证明了这样一个事实：当 netnodes 与虚拟地址相关联时（类似于我们示例中的 `n1`），它们很容易访问。对于所有其他 netnodes，赋予一个名称使得能够执行对
    netnode 的命名查找（如我们示例中的 `n2` 和 `n3`）。
- en: Note that for our named netnodes, we have chosen to use names prefixed with
    “`$` ”, which is in keeping with the practice, recommended in *netnode.hpp*, for
    avoiding conflicts with names IDA uses internally.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于我们的命名netnode，我们选择使用以“`$`”为前缀的名称，这与在*netnode.hpp*中推荐的实践一致，以避免与IDA内部使用的名称冲突。
- en: Data Storage in Netnodes
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Netnode中的数据存储
- en: 'Now that you understand how to create a netnode that you can store data into,
    let’s return to the discussion of the internal array storage capability of net-nodes.
    To store a value into an array within a netnode, we need to specify five pieces
    of information: an index value, an index size (8 or 32 bits), a value to store,
    the number of bytes the value contains, and an array (one of 256 available for
    each category of array) in which to store the value. The index size parameter
    is specified implicitly by the function that we use to store or retrieve the data.
    The remaining values are passed into that function as parameters. The parameter
    that selects which of the 256 possible arrays a value is stored in is usually
    called a *tag*, and it is often specified (though it need not be) using a character.
    The netnode documentation distinguishes among a few special types of values termed
    *altvals*, *supvals*, and *hashvals*. By default, each of these values is typically
    associated with a specific array tag: `''A''` for altvals, `''S''` for supvals,
    and `''H''` for hashvals. A fourth type of value, called a *charval*, is not associated
    with any specific array tag.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何创建可以存储数据的netnode，让我们回到对netnode内部数组存储能力的讨论。要将值存储到netnode内的数组中，我们需要指定五条信息：一个索引值、一个索引大小（8位或32位）、要存储的值、值包含的字节数，以及要存储值的数组（每个数组类别有256个可供选择）。索引大小参数由我们用于存储或检索数据的函数隐式指定。其余值作为参数传递给该函数。选择将值存储在256个可能的数组中的参数通常称为*tag*，通常使用一个字符指定（尽管不必须）。netnode文档区分了几种特殊类型的值，称为*altvals*、*supvals*和*hashvals*。默认情况下，这些值通常与特定的数组标签相关联：`'A'`用于altvals，`'S'`用于supvals，`'H'`用于hashvals。第四种类型的值，称为*charval*，不与任何特定的数组标签相关联。
- en: It is important to understand that these value types are associated more with
    a specific way of storing data into a netnode than with a specific array within
    a netnode. It is possible to store any type of value in any array simply by specifying
    an alternate array tag when storing data. In all cases, it is up to you to remember
    what type of data you stored into a particular array location so that you can
    use retrieval methods appropriate to the type of the stored data.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这些值类型更多地与将数据存储到netnode的特定方式相关，而不是与netnode中的特定数组相关。通过指定存储数据时的备用数组标签，可以在任何数组中存储任何类型的值。在所有情况下，你必须记住你将哪种类型的数据存储到特定的数组位置，以便你可以使用适合存储数据类型的检索方法。
- en: '*Altvals* provide a simple interface for storing and retrieving integer data
    in netnodes. Altvals may be stored into any array within a netnode but default
    to the `''A''` array. Regardless of which array you wish to store integers into,
    using the altval-related functions greatly simplifies matters. The code in [Example 16-2](ch16s02.html#accessing_netnode_altvals
    "Example 16-2. Accessing netnode altvals") demonstrates data storage and retrieval
    using altvals.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '*Altvals*为在netnode中存储和检索整数数据提供了一个简单的接口。Altvals可以存储在netnode中的任何数组中，但默认为`''A''`数组。无论你希望将整数存储到哪个数组中，使用与altval相关的函数都可以大大简化问题。[示例16-2](ch16s02.html#accessing_netnode_altvals
    "示例16-2. 访问netnode altvals")中的代码演示了使用altvals进行数据存储和检索。'
- en: Example 16-2. Accessing netnode altvals
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-2. 访问netnode altvals
- en: '[PRE35]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, you see a pattern that will be repeated for other types of
    netnode values, namely, the use of an *`XXX`*`set` function (in this case, `altset`)
    to store a value into a netnode and an *`XXX`*`val` function (in this case, `altval`)
    to retrieve a value from a netnode. If we want to store integers into arrays using
    8-bit index values, we need to use slightly different functions, as shown in the
    next example.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你看到的是一个模式，这个模式将在其他类型的netnode值中重复出现，即使用一个*`XXX`*`set`函数（在这个例子中，`altset`）将值存储到netnode中，以及一个*`XXX`*`val`函数（在这个例子中，`altval`）从netnode中检索值。如果我们想使用8位索引值将整数存储到数组中，我们需要使用稍微不同的函数，如下一个例子所示。
- en: '[PRE36]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here you see that the general rule of thumb for the use of 8-bit index values
    is to use a function with an `_idx8` suffix. Also note that none of the `_idx8`
    functions provide default values for the array tag parameter.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用 8 位索引值的一般规则是使用带有 `_idx8` 后缀的函数。请注意，没有任何 `_idx8` 函数为数组标签参数提供默认值。
- en: '*Supvals* represent the most versatile means of storing and retrieving data
    in netnodes. Supvals represent data of arbitrary size, from 1 byte to a maximum
    of 1,024 bytes. When using 32-bit index values, the default array for storing
    and retrieving supvals is the `''S''` array. Again, however, supvals can be stored
    into any of the 256 available arrays by specifying an appropriate array tag value.
    Strings are a common form of arbitrary length data and as such are afforded special
    handling in supval manipulation functions. The code in [Example 16-3](ch16s02.html#storing_netnode_supvals
    "Example 16-3. Storing netnode supvals") provides examples of storing supvals
    into a netnode.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '*Supvals* 代表在 netnodes 中存储和检索数据最灵活的方式。Supvals 可以表示任意大小的数据，从 1 字节到最多 1,024 字节。当使用
    32 位索引值时，存储和检索 supvals 的默认数组是 `''S''` 数组。然而，再次强调，通过指定适当的数组标签值，supvals 可以存储到 256
    个可用数组中的任何一个。字符串是任意长度数据的常见形式，因此在 supval 操作函数中得到了特殊处理。[示例 16-3](ch16s02.html#storing_netnode_supvals
    "示例 16-3. 存储netnode supvals") 中的代码提供了将 supvals 存储到 netnode 中的示例。'
- en: Example 16-3. Storing netnode supvals
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-3. 存储 netnode supvals
- en: '[PRE37]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `supset` function requires an array index, a pointer to some data, the length
    of the data (in bytes), and an array tag that defaults to `'S'` if omitted. If
    the length parameter is omitted, it defaults to zero. When the length is specified
    as zero, `supset` assumes that the data being stored is a string, computes the
    length of the data as `strlen`(data) + 1, and stores a null termination character
    along with the string data.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`supset` 函数需要一个数组索引、指向某些数据的指针、数据的长度（以字节为单位），以及默认为 `''S''` 的数组标签（如果省略）。如果省略长度参数，它默认为零。当指定长度为零时，`supset`
    假设要存储的数据是字符串，计算数据的长度为 `strlen`(data) + 1，并存储一个空终止字符以及字符串数据。'
- en: Retrieving data from a supval takes a little care, as you may not know the amount
    of data contained within the supval before you attempt to retrieve it. When you
    retrieve data from a supval, bytes are copied out of the netnode into a user-supplied
    output buffer. How do you ensure that your output buffer is of sufficient size
    to receive the supval data? The first method is to retrieve all supval data into
    a buffer that is at least 1,024 bytes. The second method is to preset the size
    of your output buffers by querying the size of the supval. Two functions are available
    for retrieving supvals. The `supval` function is used to retrieve arbitrary data,
    while the `supstr` function is specialized for retrieving string data. Each of
    these functions expects a pointer to your output buffer along with the size of
    the buffer. The return value for `supval` is the number of bytes copied into the
    output buffer, while the return value for `supstr` is the length of the string
    copied to the output buffer not including the null terminator, even though the
    null terminator is copied to the buffer. Each of these functions recognizes the
    special case in which a `NULL` pointer is supplied in place of an output buffer
    pointer. In such cases, `supval` and `supstr` return the number of bytes of storage
    (including any null terminator) required to hold the supval data. [Example 16-4](ch16s02.html#retrieving_netnode_supvals
    "Example 16-4. Retrieving netnode supvals") demonstrates retrieval of supval data
    using the `supval` and `supstr` functions.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 从 supval 中检索数据需要一点小心，因为在尝试检索之前，你可能不知道 supval 中包含的数据量。当你从 supval 中检索数据时，字节会被从
    netnode 复制到用户提供的输出缓冲区。你如何确保你的输出缓冲区足够大，以接收 supval 数据？第一种方法是检索所有 supval 数据到一个至少
    1,024 字节的缓冲区。第二种方法是预先设置输出缓冲区的大小，通过查询 supval 的大小。有两个函数可用于检索 supvals。`supval` 函数用于检索任意数据，而
    `supstr` 函数专门用于检索字符串数据。这些函数都期望一个指向你的输出缓冲区的指针以及缓冲区的大小。`supval` 的返回值是复制到输出缓冲区的字节数，而
    `supstr` 的返回值是复制到输出缓冲区的字符串长度，不包括空终止符，尽管空终止符也被复制到缓冲区。这些函数都识别在输出缓冲区指针的位置提供一个 `NULL`
    指针的特殊情况。在这种情况下，`supval` 和 `supstr` 返回存储 supval 数据所需的字节数（包括任何空终止符）。[示例 16-4](ch16s02.html#retrieving_netnode_supvals
    "示例 16-4. 检索 netnode supvals") 展示了使用 `supval` 和 `supstr` 函数检索 supval 数据。
- en: Example 16-4. Retrieving netnode supvals
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-4. 检索 netnode supvals
- en: '[PRE38]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using supvals, it is possible to access any data stored in any array within
    a netnode. For example, supval functions can be used to store and retrieve altval
    data by limiting the supset and supval operations to the size of an altval. Reading
    through *netnode.hpp*, you will see that this is in fact the case by observing
    the inlined implementation of the `altset` function, as shown here:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用supvals，可以访问netnode中任何数组存储的数据。例如，可以通过限制supset和supval操作的大小到altval的大小，使用supval函数存储和检索altval数据。通过阅读*netnode.hpp*，你会看到这确实如此，通过观察`altset`函数的内联实现，如下所示：
- en: '[PRE39]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Hashvals* offer yet another interface to netnodes. Rather than being associated
    with integer indexes, hashvals are associated with key strings. Overloaded versions
    of the `hashset` function make it easy to associate integer data or array data
    with a hash key, while the `hashval`, `hashstr`, and `hashval_long` functions
    allow retrieval of hashvals when provided with the appropriate hash key. Tag values
    associated with the `hash`*`XXX`* functions actually choose one of 256 hash tables,
    with the default table being `''H''`. Alternate tables are selected by specifying
    a tag other than `''H''`.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hashvals*提供了另一种访问netnodes的接口。与整数索引关联不同，hashvals与键字符串关联。`hashset`函数的重载版本使得将整数数据或数组数据与哈希键关联变得容易，而`hashval`、`hashstr`和`hashval_long`函数允许在提供适当的哈希键时检索hashvals。与`hash`*`XXX`*函数关联的标签值实际上选择256个哈希表中的一个，默认表为`''H''`。通过指定不同于`''H''`的标签来选择备用表。'
- en: The last interface to netnodes that we will mention is the *charval* interface.
    The `charval` and `charset` functions offer a simple means to store single-byte
    data into a netnode array. There is no default array associated with charval storage
    and retrieval, so you must specify an array tag for every charval operation. Charvals
    are stored into the same arrays as altvals and supvals, and the charval functions
    are simply wrappers around 1-byte supvals.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要提到的最后一个与netnodes的接口是*charval*接口。`charval`和`charset`函数提供了一种简单的方法将单字节数据存储到netnode数组中。与charval存储和检索没有关联默认数组，因此你必须为每个charval操作指定一个数组标签。Charvals存储在与altvals和supvals相同的数组中，而charval函数只是1字节supvals的包装。
- en: Another capability provided by the `netnode` class is the ability to iterate
    over the contents of a netnode array (or hash table). Iteration is performed using
    *`XXX`*`1st`, *`XXX`*`nxt`, *`XXX`*`last`, and *`XXX`*`prev` functions that are
    available for altvals, supvals, hashvals, and charvals. The example in [Example 16-5](ch16s02.html#enumerating_netnode_altvals
    "Example 16-5. Enumerating netnode altvals") illustrates iteration across the
    default altvals array (`'A'`).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`netnode`类提供的另一个功能是能够迭代netnode数组（或哈希表）的内容。迭代是通过可用于altvals、supvals、hashvals和charvals的*`XXX`*`1st`、*`XXX`*`nxt`、*`XXX`*`last`和*`XXX`*`prev`函数来执行的。示例[示例16-5](ch16s02.html#enumerating_netnode_altvals
    "示例16-5. 枚举netnode altvals")说明了跨默认altvals数组(`''A''`)的迭代。'
- en: Iteration over supvals, charvals, and hashvals is performed in a very similar
    manner; however, you will find that the syntax varies depending on the type of
    values being accessed. For example, iteration over hashvals returns hashkeys rather
    than array indexes, which must then be used to retrieve hashvals.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 对supvals、charvals和hashvals的迭代以非常相似的方式进行；然而，你会发现语法取决于访问的值类型。例如，对hashvals的迭代返回hashkeys而不是数组索引，然后必须使用这些索引来检索hashvals。
- en: Example 16-5. Enumerating netnode altvals
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-5. 枚举netnode altvals
- en: '[PRE40]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: NETNODES AND IDC GLOBAL ARRAYS
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: NETNODES AND IDC GLOBAL ARRAYS
- en: You may recall from [Chapter 15](ch15.html "Chapter 15. IDA Scripting") that
    the IDC scripting language provides persistent global arrays. Netnodes provide
    the backing storage for IDC global arrays. When you supply a name to the IDC `CreateArray`
    function, the string `$ idc_array` is prepended to the name that you supply to
    form a netnode name. The `netnodenumber` of the newly created netnode is returned
    to you as the IDC array identifier. The IDC `SetArrayLong` function stores an
    integer into the altvals (`'A'`) array, while the `SetArrayString` function stores
    a string into the supvals (`'S'`) array. When you retrieve a value from an IDC
    array using the `GetArrayElement` function, the tags that you supply (`AR_LONG
    or AR_STR`) represent the tags to the altval and supval arrays used to store the
    corresponding integer or strings data.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得[第15章](ch15.html "第15章. IDA脚本")中提到的，IDC脚本语言提供了持久的全局数组。Netnodes为IDC全局数组提供支持存储。当你向IDC
    `CreateArray`函数提供一个名称时，字符串`$ idc_array`会被添加到你提供的名称之前，形成netnode名称。新创建的netnode的`netnodenumber`作为IDC数组标识符返回给你。IDC
    `SetArrayLong`函数将整数存储到altvals（`'A'`）数组中，而`SetArrayString`函数将字符串存储到supvals（`'S'`）数组中。当你使用`GetArrayElement`函数从IDC数组中检索值时，你提供的标签（`AR_LONG
    or AR_STR`）代表用于存储相应整数或字符串数据的altval和supval数组。
- en: '[Appendix B](apb.html "Appendix B. IDC/SDK Cross-Reference") offers additional
    insight into the use of netnodes within the implementations of IDC functions and
    exposes how netnodes are used to store various types of information (such as comments)
    within a database.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录B](apb.html "附录B. IDC/SDK交叉引用")提供了关于在IDC函数实现中使用netnodes的额外见解，并揭示了netnodes是如何在数据库中用于存储各种类型的信息（如注释）的。'
- en: Deleting Netnodes and Netnode Data
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除Netnodes和Netnode数据
- en: The `netnode` class also provides functions for deleting individual array elements,
    the entire contents of an array, or the entire contents of a netnode. Removing
    an entire netnode is fairly straightforward.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`netnode`类还提供了用于删除单个数组元素、整个数组内容或整个netnode内容的函数。删除整个netnode相对直接。'
- en: '[PRE41]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When deleting individual array elements, or entire array contents, you must
    take care to choose the proper deletion function because the names of the functions
    are very similar and choosing the wrong form may result in significant loss of
    data. Commented examples demonstrating deletion of altvals follow:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除单个数组元素或整个数组内容时，你必须小心选择正确的删除函数，因为函数的名称非常相似，选择错误的形式可能会导致数据的大量丢失。以下是一些注释示例，展示了如何删除altvals：
- en: '[PRE42]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note the similarity in the syntax to delete the entire contents of the default
    altval array ![](httpatomoreillycomsourcenostarchimages854061.png) and the syntax
    to delete a single element from the default altval array ![](httpatomoreillycomsourcenostarchimages854063.png).
    If for some reason you fail to specify an index when you want to delete a single
    element, you may end up deleting an entire array. Similar functions exist to delete
    supval, charval, and hashval data.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 注意删除默认altval数组全部内容的语法与删除默认altval数组单个元素的语法相似 ![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)
    和 ![httpatomoreillycomsourcenostarchimages854063.png](httpatomoreillycomsourcenostarchimages854063.png)。如果你在想要删除单个元素时未能指定索引，你可能会删除整个数组。类似的函数也存在于删除supval、charval和hashval数据。
- en: Useful SDK Datatypes
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的SDK数据类型
- en: IDA’s API defines a number of C++ classes designed to model components typically
    found in executable files. The SDK contains classes to describe functions, program
    sections, data structures, individual assembly language instructions, and individual
    operands within each instruction. Additional classes are defined to implement
    the tools that IDA uses to manage the disassembly process. Classes falling into
    this latter category define general database characteristics, loader module characteristics,
    processor module characteristics, and plug-in module characteristics, and they
    define the assembly syntax to be used for each disassembled instruction.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的API定义了多个C++类，旨在模拟可执行文件中通常找到的组件。SDK包含用于描述函数、程序部分、数据结构、单个汇编语言指令以及每个指令中的单个操作数的类。还定义了额外的类来实现IDA用于管理反汇编过程的工具。属于后一类的类定义了通用数据库特性、加载模块特性、处理器模块特性和插件模块特性，并定义了用于每个反汇编指令的汇编语法。
- en: Some of the more common general-purpose classes are described here. We defer
    discussion of classes that are more specific to plug-ins, loaders, and processor
    modules until the appropriate chapters covering those topics. Our goal here is
    to introduce classes, their purposes, and some important data members of each
    class. Useful functions for manipulating each class are described in [Commonly
    Used SDK Functions](ch16s02.html#commonly_used_sdk_functions "Commonly Used SDK
    Functions") in [Commonly Used SDK Functions](ch16s02.html#commonly_used_sdk_functions
    "Commonly Used SDK Functions").
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里描述了一些更常见的通用类。关于更特定于插件、加载器和处理器模块的类的讨论将推迟到涵盖这些主题的适当章节。我们的目标是介绍类、它们的目的以及每个类的一些重要数据成员。用于操作每个类的有用函数在[常用SDK函数](ch16s02.html#commonly_used_sdk_functions
    "常用SDK函数")中描述，见[常用SDK函数](ch16s02.html#commonly_used_sdk_functions "常用SDK函数")。
- en: '**`area_t`** **(area.hpp)**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**`area_t`** **(area.hpp)**'
- en: This struct describes a range of addresses and is the base class for several
    other classes. The struct contains two data members, `startEA` (inclusive) and
    `endEA` (exclusive), that define the boundaries of the address range. Member functions
    are defined that compute the size of the address range and that can perform comparisons
    between two areas.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构体描述了一个地址范围，是其他几个类的基类。该结构体包含两个数据成员，`startEA`（包含）和`endEA`（排除），它们定义了地址范围的边界。定义了成员函数来计算地址范围的大小，并且可以在两个区域之间执行比较。
- en: '**`func_t`** **(funcs.hpp)**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**`func_t`** **(funcs.hpp)**'
- en: This class inherits from `area_t`. Additional data fields are added to the class
    to record binary attributes of the function, such as whether the function uses
    a frame pointer or not, and attributes describing the function’s local variables
    and arguments. For optimization purposes, some compilers may split functions into
    several noncontiguous regions within a binary. IDA terms these regions *chunks*
    or *tails*. The `func_t` class is also used to describe tail chunks.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 此类从 `area_t` 继承。为记录函数的二进制属性（例如，函数是否使用帧指针）以及描述函数的局部变量和参数的属性添加了额外的数据字段。为了优化目的，一些编译器可能会将函数拆分为二进制内的几个非连续区域。IDA将这些区域称为*块*或*尾部*。`func_t`
    类也用于描述尾部块。
- en: '**`segment_t`** **(segment.hpp)**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**`segment_t`** **(segment.hpp)**'
- en: The `segment_t` class is another subclass of `area_t`. Additional data fields
    describe the name of the segment, the permissions in effect in the segment (readable,
    writeable, executable), the type of the segment (code, data, etc.), and the number
    of bits used in a segment address (16, 32, or 64).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`segment_t` 类是 `area_t` 的另一个子类。额外的数据字段描述了段名称、段内的权限（可读、可写、可执行）、段类型（代码、数据等），以及段地址中使用的位数（16、32或64）。'
- en: '**`idc_value_t`** **(expr.hpp)**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**`idc_value_t`** **(expr.hpp)**'
- en: This class describes the contents of an IDC value, which may contain at any
    time a string, an integer, or a floating-point value. The type is utilized extensively
    when interacting with IDC functions from within a compiled module.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 此类描述了IDC值的内容，该值在任何时候都可能包含一个字符串、一个整数或一个浮点数。在与编译模块内的IDC函数交互时，类型被广泛使用。
- en: '**`idainfo`** **(ida.hpp)**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**`idainfo`** **(ida.hpp)**'
- en: This struct is populated with characteristics describing the open database.
    A single global variable named `inf`, of type `idainfo`, is declared in *ida.hpp*.
    Fields within this struct describe the name of the processor module that is in
    use, the input file type (such as `f_PE` or `f_MACHO` via the `filetype_t` enum),
    the program entry point (`beginEA`), the minimum address within the binary (`minEA`),
    the maximum address in the binary (`maxEA`), the endianness of the current processor
    (`mf`), and a number of configuration settings parsed from *ida.cfg*.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构体填充了描述打开数据库的特征。在 *ida.hpp* 中声明了一个名为 `inf` 的全局变量，其类型为 `idainfo`。此结构体中的字段描述了正在使用的处理器模块的名称、输入文件类型（例如通过
    `filetype_t` 枚举的 `f_PE` 或 `f_MACHO`）、程序入口点（`beginEA`）、二进制中的最小地址（`minEA`）、二进制中的最大地址（`maxEA`）、当前处理器的字节序（`mf`），以及从
    *ida.cfg* 解析的配置设置数量。
- en: '**`struc_t`** **(struct.hpp)**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**`struc_t`** **(struct.hpp)**'
- en: This class describes the layout of structured data within a disassembly. It
    is used to describe structures within the Structures window as well as to describe
    the composition of function stack frames. A `struc_t` contains flags describing
    attributes of the structure (such as whether it is a structure or union or whether
    the structure is collapsed or expanded in the IDA display window), and it also
    contains an array of structure members.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类描述了反汇编中结构化数据的布局。它用于描述结构窗口中的结构以及描述函数栈帧的组成。一个`struc_t`包含描述结构属性（例如，它是否是结构或联合，或者结构在IDA显示窗口中是折叠还是展开）的标志，并且它还包含一个结构成员数组。
- en: '**`member_t`** **(struct.hpp)**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**`member_t`** **(struct.hpp)**'
- en: This class describes a single member of a structured datatype. Included data
    fields describe the byte offset at which the member begins and ends within its
    parent structure.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类描述了结构化数据类型中的一个单个成员。包含的数据字段描述了成员在其父结构中开始和结束的字节偏移量。
- en: '**`op_t`** **(ua.hpp)**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**`op_t`** **(ua.hpp)**'
- en: This class describes a single operand within a disassembled instruction. The
    class contains a zero-based field to store the number of the operand (`n`), an
    operand type field (`type`), and a number of other fields whose meaning varies
    depending on the operand type. The `type` field is set to one of the `optype_t`
    constants defined in *ua.hpp* and describes the operand type or addressing mode
    used for the operand.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类描述了反汇编指令中的一个操作数。该类包含一个基于零的字段来存储操作数的编号（`n`），一个操作数类型字段（`type`），以及一些其他字段，其含义取决于操作数类型。`type`字段被设置为在
    *ua.hpp* 中定义的 `optype_t` 常量之一，并描述了操作数类型或用于操作数的寻址模式。
- en: '**`insn_t`** **(ua.hpp)**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**`insn_t`** **(ua.hpp)**'
- en: This class contains information describing a single disassembled instruction.
    Fields within the class describe the instruction’s address within the disassembly
    (`ea`), the instruction’s type (`itype`), the instruction’s length in bytes (`size`),
    and an array of six possible operand values (`Operands`) of type `op_t` (IDA limits
    each instruction to a maximum of six operands). The `itype` field is set by the
    processor module. For standard IDA processor modules, the `itype` field is set
    to one of the enumerated constants defined in *allins.hpp*. When a third-party
    processor module is used, the list of potential `itype` values must be obtained
    from the module developer. Note that the `itype` field generally bears no relationship
    whatsoever to the binary opcode for the instruction.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含描述单个反汇编指令的信息。类内的字段描述了指令在反汇编中的地址（`ea`），指令的类型（`itype`），指令的字节长度（`size`），以及一个包含六个可能的操作数值（`Operands`）的数组，这些值是类型
    `op_t`（IDA将每个指令限制为最多六个操作数）。`itype`字段由处理器模块设置。对于标准的IDA处理器模块，`itype`字段被设置为在 *allins.hpp*
    中定义的枚举常量之一。当使用第三方处理器模块时，必须从模块开发者那里获取潜在的`itype`值列表。请注意，`itype`字段通常与指令的二进制操作码没有任何关系。
- en: The preceding list is by no means a definitive guide to all of the datatypes
    used within the SDK. This list is intended merely as an introduction to some of
    the more commonly used classes and some of the more commonly accessed fields within
    those classes.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表绝不是SDK中使用的所有数据类型的 definitive 指南。此列表仅作为介绍一些常用类以及这些类中一些常用字段的目的。
- en: Commonly Used SDK Functions
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用SDK函数
- en: While the SDK is programmed using C++ and defines a number of C++ classes, in
    many cases the SDK favors traditional C-style nonmember functions for manipulation
    of objects within a database. For most API datatypes, it is more common to find
    nonmember functions that require a pointer to an object than it is to find a member
    function to manipulate the object in the manner you desire.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SDK是用C++编写的并定义了许多C++类，但在许多情况下，SDK更倾向于使用传统的C风格的非成员函数来操作数据库中的对象。对于大多数API数据类型，更常见的是找到需要指向对象的指针的非成员函数，而不是找到可以按您希望的方式操作对象的成员函数。
- en: In the summaries that follow, we cover API functions that provide functionality
    similar to many of the IDC functions introduced in [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting"). It is unfortunate that functions that perform identical tasks are
    named one thing in IDC and something different within the API.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下摘要中，我们介绍了提供与第15章中介绍的许多IDC函数类似功能的API函数。不幸的是，执行相同任务的函数在IDC和API中命名不同。
- en: Basic Database Access
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本数据库访问
- en: The following functions, declared in *bytes.hpp*, provide access to individual
    bytes, words, and dwords within a database.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *bytes.hpp* 中声明的以下函数提供了对数据库中单个字节、字和双字的访问。
- en: '| **`uchar get_byte(ea_t addr)`** Reads current byte value from virtual address
    `addr`. |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| **`uchar get_byte(ea_t addr)`** 从虚拟地址 `addr` 读取当前字节值。|'
- en: '| **`ushort get_word(ea_t addr)`** Reads current word value from virtual address
    `addr`. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| **`ushort get_word(ea_t addr)`** 从虚拟地址 `addr` 读取当前字值。|'
- en: '| **`ulong get_long(ea_t addr)`** Reads current double word value from virtual
    address `addr`. |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| **`ulong get_long(ea_t addr)`** 从虚拟地址 `addr` 读取当前双字值。|'
- en: '| **`get_many_bytes(ea_t addr, void *buffer, ssize_t len)`** Copies `len` bytes
    from the `addr` into the supplied buffer. |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| **`get_many_bytes(ea_t addr, void *buffer, ssize_t len)`** 从 `addr` 复制 `len`
    个字节到提供的缓冲区。|'
- en: '| **`patch_byte(ea_t addr, ulong val)`** Sets a byte value at virtual address
    `addr`. |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| **`patch_byte(ea_t addr, ulong val)`** 在虚拟地址 `addr` 设置字节值。|'
- en: '| **`patch_word(long addr, ulonglong val)`** Sets a word value at virtual address
    `addr`. |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| **`patch_word(long addr, ulonglong val)`** 在虚拟地址 `addr` 设置字值。|'
- en: '| **`patch_long(long addr, ulonglong val)`** Sets a double word value at virtual
    address `addr`. |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| **`patch_long(long addr, ulonglong val)`** 在虚拟地址 `addr` 设置双字值。|'
- en: '| **`patch_many_bytes(ea_t addr, const void *buffer, size_t len)`** Patches
    the database beginning at `addr` with `len` bytes from the user-supplied `buffer`.
    |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| **`patch_many_bytes(ea_t addr, const void *buffer, size_t len)`** 使用用户提供的
    `buffer` 中的 `len` 个字节从 `addr` 开始修补数据库。|'
- en: '| **`ulong get_original_byte(ea_t addr)`** Reads the original byte value (prior
    to patching) from virtual address `addr`. |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| **`ulong get_original_byte(ea_t addr)`** 从虚拟地址 `addr` 读取原始字节值（补丁之前）。|'
- en: '| **`ulonglong get_original_word(ea_t addr)`** Reads the original word value
    from virtual address `addr`. |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| **`ulonglong get_original_word(ea_t addr)`** 从虚拟地址 `addr` 读取原始字值。|'
- en: '| **`ulonglong get_original_long(ea_t addr)`** Reads the original double word
    value from virtual address `addr`. |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| **`ulonglong get_original_long(ea_t addr)`** 从虚拟地址 `addr` 读取原始双字值。|'
- en: '| **`bool isLoaded(ea_t addr)`** Returns true if `addr` contains valid data,
    false otherwise. |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| **`bool isLoaded(ea_t addr)`** 如果 `addr` 包含有效数据则返回 true，否则返回 false。|'
- en: Additional functions exist for accessing alternative data sizes. Note that the
    `get_original_`*`XXX`* functions get the very first *original* value, which is
    not necessarily the value at an address prior to a patch. Consider the case when
    a byte value is patched twice; over time this byte has held three different values.
    After the second patch, both the current value and the original value are accessible,
    but there is no way to obtain the second value (which was set with the first patch).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 存在额外的函数用于访问不同的数据大小。请注意，`get_original_`*`XXX`* 函数获取第一个 *原始* 值，这个值不一定是补丁之前的地址处的值。考虑以下情况：字节值被补丁两次；随着时间的推移，这个字节已经持有三个不同的值。在第二次补丁之后，当前值和原始值都是可访问的，但无法获得第二个值（这是第一次补丁设置的）。
- en: User Interface Functions
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面函数
- en: 'Interaction with the IDA user interface is handled by a single *dispatcher*
    function named `callui`. Requests for various user interface services are made
    by passing a user interface request (one of the enumerated `ui_notification_t`
    constants) to `callui` along with any additional parameters required by the request.
    Parameters required for each request type are specified in *kernwin.hpp*. Fortunately,
    a number of convenience functions that hide many of the details of using `callui`
    directly are also defined in *kernwin.hpp*. Several common convenience functions
    are described here:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IDA 用户界面的交互由一个名为 `callui` 的单个 *分发器* 函数处理。通过将用户界面请求（枚举 `ui_notification_t`
    常量之一）和请求所需的任何附加参数传递给 `callui` 来请求各种用户界面服务。每个请求类型所需的参数在 *kernwin.hpp* 中指定。幸运的是，*kernwin.hpp*
    中还定义了多个便利函数，这些函数隐藏了直接使用 `callui` 的许多细节。以下描述了几个常见的便利函数：
- en: '| **`msg(char *format, ...)`** Prints a formatted message to the message window.
    This function is analogous to C’s `printf` function and accepts a `printf`-style
    format string. |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| **`msg(char *format, ...)`** 将格式化的消息打印到消息窗口。此函数类似于 C 的 `printf` 函数，并接受 `printf`
    风格的格式字符串。|'
- en: '| **`warning(char *format, ...)`** Displays a formatted message in a dialog.
    |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| **`warning(char *format, ...)`** 在对话框中显示格式化的消息。|'
- en: '| **`char *askstr(int hist, char *default, char *format, ...)`** Displays an
    input dialog asking the user to enter a string value. The `hist` parameter dictates
    how the drop-down history list in the dialog should be populated and should be
    set to one of the `HIST_`*`xxx`* constants defined in *kernwin.hpp*. The `format`
    string and any additional parameters are use to form a prompt string. |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| **`char *askstr(int hist, char *default, char *format, ...)`** 显示一个输入对话框，要求用户输入字符串值。`hist`
    参数指定对话框中下拉历史记录列表的填充方式，应设置为 *kernwin.hpp* 中定义的 `HIST_`*`xxx`* 常量之一。`format` 字符串和任何其他参数用于形成提示字符串。|'
- en: '| **`char *askfile_c(int dosave, char *default, char *prompt, ...)`** Displays
    a file save (`dosave` = 1) or file open (`dosave` = 0) dialog, initially displaying
    the directory and file mask specified by default (such as `C:\\windows\\*.exe`).
    Returns the name of the selected file or NULL if the dialog was canceled. |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| **`char *askfile_c(int dosave, char *default, char *prompt, ...)`** 显示一个文件保存（`dosave`
    = 1）或文件打开（`dosave` = 0）对话框，最初显示默认指定的目录和文件掩码（例如 `C:\\windows\\*.exe`）。返回所选文件的名称或
    NULL（如果对话框被取消）。|'
- en: '| **`askyn_c(int default, char *prompt, ...)`** Prompts the user with a yes
    or no question, highlighting a *default* answer (1 = yes, 0 = no,-1 = cancel).
    Returns an integer representing the selected answer. |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| **`askyn_c(int default, char *prompt, ...)`** 提示用户以是或否的问题，突出显示默认答案（1 = 是，0
    = 否，-1 = 取消）。返回表示所选答案的整数。|'
- en: '| **`AskUsingForm_c(const char *form, ...)`** The `form` parameter is an ASCII
    string specification of a dialog and its associated input elements. This function
    may be used to build customized user interface elements when none of the SDK’s
    other convenience functions meet your needs. The format of the `form` string is
    detailed in *kernwin.hpp*. |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| **`AskUsingForm_c(const char *form, ...)`** `form` 参数是一个对话框及其相关输入元素的 ASCII
    字符串规范。此函数可用于在 SDK 的其他便利函数都无法满足需求时构建自定义用户界面元素。`form` 字符串的格式在 *kernwin.hpp* 中有详细说明。|'
- en: '| **`get_screen_ea()`** Returns the virtual address of the current cursor location.
    |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| **`get_screen_ea()`** 返回当前光标位置的虚拟地址。|'
- en: '| **`jumpto(ea_t addr)`** Jumps the disassembly window to the specified address.
    |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| **`jumpto(ea_t addr)`** 将反汇编窗口跳转到指定的地址。|'
- en: Many more user interface capabilities are available using the API than are available
    with IDC scripting, including the ability to create customized single- and multicolumn
    list selection dialogs. Users interested in these capabilities should consult
    *kernwin.hpp* and the `choose` and `choose2` functions in particular.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 API 可以获得比 IDC 脚本更多的用户界面功能，包括创建自定义的单列和多列列表选择对话框的能力。对这些功能感兴趣的用户应查阅 *kernwin.hpp*
    以及 `choose` 和 `choose2` 函数。
- en: Manipulating Database Names
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库名称操作
- en: 'The following functions are available for working with named locations within
    a database:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数可用于在数据库中处理命名位置：
- en: '| **`get_name(ea_t from, ea_t addr, char *namebuf, size_t maxsize)`** Returns
    the name associated with `addr`. Returns the empty string if the location has
    no name. This function provides access to local names when `from` is any address
    in the function that contains `addr`. The name is copied into the provided output
    buffer. |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| **`get_name(ea_t from, ea_t addr, char *namebuf, size_t maxsize)`** 返回与 `addr`
    关联的名称。如果位置没有名称，则返回空字符串。当 `from` 是包含 `addr` 的函数中的任何地址时，此函数提供对局部名称的访问。名称被复制到提供的输出缓冲区中。|'
- en: '| **`set_name(ea_t addr, char *name, int flags)`** Assigns the given name to
    the given address. The name is created with attributes specified in the `flags`
    bitmask. Possible flag values are described in *name.hpp*. |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| **`set_name(ea_t addr, char *name, int flags)`** 将给定的名称分配给给定的地址。名称使用 `flags`
    位掩码中指定的属性创建。可能的标志值在 *name.hpp* 中描述。|'
- en: '| **`get_name_ea(ea_t funcaddr, char *localname)`** Searches for the given
    local name within the function containing `funcaddr`. Returns the address of the
    name or BADADDR (-1) if no such name exists in the given function. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| **`get_name_ea(ea_t funcaddr, char *localname)`** 在包含 `funcaddr` 的函数中搜索给定的局部名称。如果给定函数中不存在此类名称，则返回名称的地址或
    BADADDR（-1）。|'
- en: Function Manipulation
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数操作
- en: 'The API functions for accessing information about disassembled functions are
    declared in *funcs.hpp*. Functions for accessing stack frame information are declared
    in *frame.hpp*. Some of the more commonly used functions are described here:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 访问反汇编函数信息的 API 函数在 *funcs.hpp* 中声明。访问堆栈帧信息的函数在 *frame.hpp* 中声明。以下是一些常用函数的描述：
- en: '| **`func_t *get_func(ea_t addr)`** Returns a pointer to a `func_t` object
    that describes the function containing the indicated address. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| **`func_t *get_func(ea_t addr)`** 返回一个指向 `func_t` 对象的指针，该对象描述了包含指定地址的函数。|'
- en: '| **`size_t get_func_qty()`** Returns the number of functions present in the
    database. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| **`size_t get_func_qty()`** 返回数据库中函数的数量。|'
- en: '| **`func_t *getn_func(size_t n)`** Returns a pointer to a `func_t` object
    that represents the *n*th function in the database where *`n`* is between zero
    (inclusive) and `get_func_qty()` (exclusive). |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| **`func_t *getn_func(size_t n)`** 返回一个指向 `func_t` 对象的指针，该对象表示数据库中的第 *n* 个函数，其中
    *`n`* 在零（包含）和 `get_func_qty()`（不包含）之间。|'
- en: '| **`func_t *get_next_func(ea_t addr)`** Returns a pointer to a `func_t` object
    that describes the next function following the specified address. |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| **`func_t *get_next_func(ea_t addr)`** 返回一个指向 `func_t` 对象的指针，该对象描述了指定地址之后的下一个函数。|'
- en: '| **`get_func_name(ea_t addr, char *name, size_t namesize)`** Copies the name
    of the function containing the indicated address into the supplied name buffer.
    |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| **`get_func_name(ea_t addr, char *name, size_t namesize)`** 将包含指定地址的函数的名称复制到提供的名称缓冲区中。|'
- en: '| **`struc_t *get_frame(ea_t addr)`** Returns a pointer to a `struc_t` object
    that describes the stack frame for the function that contains the indicated address.
    |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| **`struc_t *get_frame(ea_t addr)`** 返回一个指向 `struc_t` 对象的指针，该对象描述了包含指定地址的函数的堆栈帧。|'
- en: Structure Manipulation
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构操作
- en: The `struc_t` class is used to access function stack frames as well as structured
    datatypes defined within type libraries. Some of the basic functions for interacting
    with structures and their associated members are described here. Many of these
    functions make use of a type ID (`tid_t`) datatype. The API includes functions
    for mapping a `struc_t` to an associated `tid_t` and vice versa. Note that both
    the `struc_t` and `member_t` classes contain a `tid_t` data member, so obtaining
    type ID information is simple if you already have a pointer to a valid `struc_t`
    or `member_t` object.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`struc_t` 类用于访问函数调用栈帧以及类型库中定义的结构化数据类型。这里描述了一些与结构和它们相关成员交互的基本函数。许多这些函数都使用了类型
    ID (`tid_t`) 数据类型。API 包含将 `struc_t` 映射到相关 `tid_t` 以及相反的函数。请注意，`struc_t` 和 `member_t`
    类都包含一个 `tid_t` 数据成员，因此如果你已经有了有效 `struc_t` 或 `member_t` 对象的指针，获取类型 ID 信息就很简单了。'
- en: '| **`tid_t get_struc_id(char *name)`** Looks up the type ID of a structure
    given its name. |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| **`tid_t get_struc_id(char *name)`** 根据结构名称查找类型 ID。|'
- en: '| **`struc_t *get_struc(tid_t id)`** Obtains a pointer to a `struc_t` representing
    the structure specified by the given type ID. |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| **`struc_t *get_struc(tid_t id)`** 获取一个指向 `struc_t` 的指针，该 `struc_t` 表示由给定类型
    ID 指定的结构。|'
- en: '| **`asize_t get_struc_size(struc_t *s)`** Returns the size of the given structure
    in bytes. |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| **`asize_t get_struc_size(struc_t *s)`** 返回给定结构的大小（以字节为单位）。|'
- en: '| **`member_t *get_member(struc_t *s, asize_t offset)`** Returns a pointer
    to a `member_t` object that describes the structure member that resides at the
    specified `offset` into the given structure. |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| **`member_t *get_member(struc_t *s, asize_t offset)`** 返回一个指向 `member_t`
    对象的指针，该对象描述了位于给定结构中指定 `offset` 的结构成员。|'
- en: '| **`member_t *get_member_by_name(struc_t *s, char *name)`** Returns a pointer
    to a `member_t` object that describes the structure member identified by the given
    `name`. |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| **`member_t *get_member_by_name(struc_t *s, char *name)`** 返回一个指向 `member_t`
    对象的指针，该对象描述了由给定 `name` 标识的结构成员。|'
- en: '| **`tid_t add_struc(uval_t index, char *name, bool is_union=false)`** Appends
    a new structure with the given `name` into the standard structures list. The structure
    is also added to the Structures window at the given `index`. If `index` is `BADADDR`,
    the structure is added as the last structure in the Structures window. |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| **`tid_t add_struc(uval_t index, char *name, bool is_union=false)`** 将具有给定
    `name` 的新结构追加到标准结构列表中。该结构也被添加到给定 `index` 的结构窗口中。如果 `index` 是 `BADADDR`，则该结构作为结构窗口中的最后一个结构添加。|'
- en: '| **`add_struc_member(struc_t *s, char *name, ea_t offset, flags_t flags, typeinfo_t
    *info, asize_t size)`** Adds a new member with the given `name` to the given structure.
    The member is either added at the indicated `offset` within the structure or appended
    to the end of the structure if `offset` is `BADADDR`. The `flags` parameter describes
    the datatype of the new member. Valid flags are defined using the `FF_`*`XXX`*
    constants described in *bytes.hpp*. The `info` parameter provides additional information
    for complex datatypes; it may be set to `NULL` for primitive datatypes. The `typeinfo_t`
    datatype is defined in *nalt.hpp*. The `size` parameter specifies the number of
    bytes occupied by the new member. |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| **`add_struc_member(struc_t *s, char *name, ea_t offset, flags_t flags, typeinfo_t
    *info, asize_t size)`** 向给定的结构中添加一个具有给定 `name` 的新成员。该成员要么在结构中指定的 `offset` 位置添加，要么如果
    `offset` 是 `BADADDR`，则添加到结构的末尾。`flags` 参数描述了新成员的数据类型。有效的标志是通过在 *bytes.hpp* 中描述的
    `FF_`*`XXX`* 常量定义的。`info` 参数为复杂数据类型提供附加信息；对于原始数据类型，它可能被设置为 `NULL`。`typeinfo_t`
    数据类型在 *nalt.hpp* 中定义。`size` 参数指定新成员占用的字节数。|'
- en: Segment Manipulation
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 段操作
- en: The `segment_t` class stores information related to the different segments within
    a database (such as `.text` and `.data`) as listed in the View ▸ Open Subviews
    ▸ Segments window. Recall that what IDA terms *segments* are often referred to
    as *sections* by various executable file formats such as PE and ELF. The following
    functions provide basic access to `segment_t` objects. Additional functions dealing
    with the `segment_t` class are declared in *segment.hpp*.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`segment_t` 类存储与数据库中不同段（如 `.text` 和 `.data`）相关的信息，如 View ▸ Open Subviews ▸
    Segments 窗口中列出。回想一下，IDA 所称的 *段* 通常被各种可执行文件格式（如 PE 和 ELF）称为 *节*。以下函数提供了对 `segment_t`
    对象的基本访问。处理 `segment_t` 类的附加函数在 *segment.hpp* 中声明。'
- en: '| **`segment_t *getseg(ea_t addr)`** Returns a pointer to the `segment_t` object
    that contains the given address. |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| **`segment_t *getseg(ea_t addr)`** 返回包含给定地址的 `segment_t` 对象的指针。|'
- en: '| **`segment_t *ida_export get_segm_by_name(char *name)`** Returns a pointer
    to the `segment_t` object with the given name. |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| **`segment_t *ida_export get_segm_by_name(char *name)`** 返回具有给定名称的 `segment_t`
    对象的指针。|'
- en: '| **`add_segm(ea_t para, ea_t start, ea_t end, char *name, char *sclass)`**
    Creates a new segment in the current database. The segment’s boundaries are specified
    with the `start` (inclusive) and `end` (exclusive) address parameters, while the
    segment’s name is specified by the `name` parameter. The segment’s class loosely
    describes the type of segment being created. Predefined classes include `CODE`
    and `DATA`. A complete list of predefined classes may be found in *segment.hpp*.
    The `para` parameter describes the base address of the section when segmented
    addresses (`seg:offset`) are being used, in which case `start` and `end` are interpreted
    as offsets rather than as virtual addresses. When segmented addresses are not
    being used, or all segments are based at 0, this parameter should be set to 0.
    |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| **`add_segm(ea_t para, ea_t start, ea_t end, char *name, char *sclass)`**
    在当前数据库中创建一个新的段。段的边界由 `start`（包含）和 `end`（排除）地址参数指定，而段名由 `name` 参数指定。段的类大致描述了正在创建的段类型。预定义的类包括
    `CODE` 和 `DATA`。预定义类的完整列表可以在 *segment.hpp* 中找到。`para` 参数描述了当使用分段地址（`seg:offset`）时，节的基地址；在这种情况下，`start`
    和 `end` 被解释为偏移量而不是虚拟地址。当不使用分段地址或所有段基于 0 时，此参数应设置为 0。|'
- en: '| **`add_segm_ex(segment_t *s, char *name, char *sclass, int flags)`** Alternate
    method for creating new segments. The fields of `s` should be set to reflect the
    address range of the segment. The segment is named and typed according to the
    `name` and `sclass` parameters. The `flags` parameter should be set to one of
    the `ADDSEG_`*`XXX`* values defined in *segment.hpp*. |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| **`add_segm_ex(segment_t *s, char *name, char *sclass, int flags)`** 创建新段的替代方法。`s`
    的字段应设置为反映段的地址范围。段根据 `name` 和 `sclass` 参数命名和分类。`flags` 参数应设置为在 *segment.hpp* 中定义的
    `ADDSEG_`*`XXX`* 值之一。|'
- en: '| **`int get_segm_qty()`** Returns the number of sections present within the
    database. |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| **`int get_segm_qty()`** 返回数据库中存在的段数。|'
- en: '| **`segment_t *getnseg(int n)`** Returns a pointer to a `segment_t` object
    populated with information about the *n*th program section in the database. |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| **`segment_t *getnseg(int n)`** 返回一个 `segment_t` 对象的指针，其中包含数据库中第 *n* 个程序节的信息。|'
- en: '| **`int set_segm_name(segment_t *s, char *name, ...)`** Changes the name of
    the given segment. The name is formed by treating `name` as a format string and
    incorporating any additional parameters as required by the format string. |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| **`int set_segm_name(segment_t *s, char *name, ...)`** 更改给定段的名称。名称是通过将 `name`
    作为格式字符串处理，并按照格式字符串的要求合并任何附加参数来形成的。 |'
- en: '| **`get_segm_name(ea_t addr, char *name, size_t namesize)`** Copies the name
    of the segment containing the given address into the user-supplied `name` buffer.
    Note the `name` may be filtered to replace characters that IDA considers invalid
    (characters not specified as `NameChars` in *ida.cfg*) with a dummy character
    (typically an underscore as specified by `SubstChar` in *ida.cfg*). |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| **`get_segm_name(ea_t addr, char *name, size_t namesize)`** 将包含给定地址的段名称复制到用户提供的
    `name` 缓冲区中。注意，`name` 可能会被过滤，以替换 IDA 认为无效的字符（在 *ida.cfg* 中未指定为 `NameChars` 的字符）为一个占位符字符（通常是一个下划线，如
    *ida.cfg* 中的 `SubstChar` 所指定）。 |'
- en: '| **`get_segm_name(segment_t *s, char *name, size_t namesize)`** Copies the
    potentially filtered name of the given segment into the user-supplied `name` buffer.
    |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| **`get_segm_name(segment_t *s, char *name, size_t namesize)`** 将给定段的可能已过滤的名称复制到用户提供的
    `name` 缓冲区中。 |'
- en: '| **`get_true_segm_name(segment_t *s, char *name, size_t namesize)`** Copies
    the exact name of the given segment into the user-supplied `name` buffer without
    filtering any characters. |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| **`get_true_segm_name(segment_t *s, char *name, size_t namesize)`** 将给定段的准确名称复制到用户提供的
    `name` 缓冲区中，而不过滤任何字符。 |'
- en: One of the `add_segm` functions must be used to actually create a segment. Simply
    declaring and initializing a `segment_t` object does not actually create a segment
    within the database. This is true with all of the wrapper classes such as `func_t`
    and `struc_t`. These classes merely provide a convenient means to access attributes
    of an underlying database entity. The appropriate functions to create, modify,
    or delete actual database objects must be utilized in order to make persistent
    changes to the database.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用 `add_segm` 中的一个函数来实际创建一个段。仅仅声明和初始化一个 `segment_t` 对象并不会在数据库中实际创建一个段。这对于所有包装类（如
    `func_t` 和 `struc_t`）都是正确的。这些类仅仅提供了一个方便的方式来访问底层数据库实体的属性。为了对数据库进行持久性更改，必须使用适当的函数来创建、修改或删除实际的数据库对象。
- en: Code Cross-References
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码交叉引用
- en: 'A number of functions and enumerated constants are defined in *xref.hpp* for
    use with code cross-references. Some of these are described here:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *xref.hpp* 中定义了多个函数和枚举常量，用于与代码交叉引用一起使用。其中一些在这里进行了描述：
- en: '| **`get_first_cref_from(ea_t from)`** Returns the first location to which
    the given address transfers control. Returns BADADDR (-1) if the given address
    refers to no other addresses. |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| **`get_first_cref_from(ea_t from)`** 返回给定地址转移控制权的第一个位置。如果给定地址不指向其他地址，则返回
    BADADDR (-1)。 |'
- en: '| **`get_next_cref_from(ea_t from, ea_t current)`** Returns the next location
    to which the given address (`from`) transfers control, given that `current` has
    already been returned by a previous call to `get_first_cref_from` or `get_next_cref_from`.
    Returns BADADDR if no more cross-references exist. |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| **`get_next_cref_from(ea_t from, ea_t current)`** 在给定地址 (`from`) 已经由先前的 `get_first_cref_from`
    或 `get_next_cref_from` 调用返回的情况下，返回给定地址的控制权转移到的下一个位置。如果没有更多的交叉引用存在，则返回 BADADDR。
    |'
- en: '| **`get_first_cref_to(ea_t to)`** Returns the first location that transfers
    control to the given address. Returns BADADDR (-1) if there are no references
    to the given address. |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| **`get_first_cref_to(ea_t to)`** 返回控制权转移到给定地址的第一个位置。如果没有对给定地址的引用，则返回 BADADDR
    (-1)。 |'
- en: '| **`get_next_cref_to(ea_t to, ea_t current)`** Returns the next location that
    transfers control to the given address (`to`), given that `current` has already
    been returned by a previous call to `get_first_cref_to` or `get_next_cref_to`.
    Returns BADADDR if no more cross-references to the given location exist. |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| **`get_next_cref_to(ea_t to, ea_t current)`** 在给定地址 (`to`) 已经由先前的 `get_first_cref_to`
    或 `get_next_cref_to` 调用返回的情况下，返回控制权转移到给定地址 (`to`) 的下一个位置。如果没有更多到给定位置的交叉引用存在，则返回
    BADADDR。 |'
- en: Data Cross-References
  id: totrans-672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据交叉引用
- en: 'The functions for accessing data cross-reference information (also declared
    in *xref.hpp*) are very similar to the functions used to access code cross-reference
    information. These functions are described here:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据交叉引用信息的函数（也在 *xref.hpp* 中声明）与用于访问代码交叉引用信息的函数非常相似。这些函数在这里进行了描述：
- en: '| **`get_first_dref_from(ea_t from)`** Returns the first location to which
    the given address refers to a data value. Returns BADADDR (-1) if the given address
    refers to no other addresses. |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| **`get_first_dref_from(ea_t from)`** 返回引用给定地址作为数据值的第一个位置。如果给定地址不引用其他地址，则返回
    BADADDR (-1)。 |'
- en: '| **`get_next_dref_from(ea_t from, ea_t current)`** Returns the next location
    to which the given address (`from`) refers a data value, given that `current`
    has already been returned by a previous call to `get_first_dref_from` or `get_next_dref_from`.
    Returns BADADDR if no more cross-references exist. |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| **`get_next_dref_from(ea_t from, ea_t current)`** 返回引用给定地址（`from`）作为数据值的下一个位置，前提是
    `current` 已经由之前的 `get_first_dref_from` 或 `get_next_dref_from` 调用返回。如果没有更多交叉引用，则返回
    BADADDR。 |'
- en: '| **`get_first_dref_to(ea_t to)`** Returns the first location that refers to
    the given address as data. Returns BADADDR (-1) if there are no references to
    the given address. |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| **`get_first_dref_to(ea_t to)`** 返回引用给定地址作为数据的第一个位置。如果没有引用给定地址，则返回 BADADDR
    (-1)。 |'
- en: '| **`get_next_dref_to(ea_t to, ea_t current)`** Returns the next location that
    refers to the given address (`to`) as data, given that `current` has already been
    returned by a previous call to `get_first_dref_to` or `get_next_dref_to`. Returns
    BADADDR if no more cross-references to the given location exist. |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| **`get_next_dref_to(ea_t to, ea_t current)`** 返回引用给定地址（`to`）作为数据的下一个位置，前提是
    `current` 已经由之前的 `get_first_dref_to` 或 `get_next_dref_to` 调用返回。如果没有更多给定位置的交叉引用，则返回
    BADADDR。 |'
- en: The SDK contains no equivalent to IDC’s `XrefType` function. A variable named
    `lastXR` is declared in *xref.hpp*; however, it is not exported. If you need to
    determine the exact type of a cross-reference, you must iterate cross-references
    using an `xrefblk_t` structure. The `xrefblk_t` is described in “Enumerating Cross-References
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 中没有与 IDC 的 `XrefType` 函数等效的功能。在 *xref.hpp* 中声明了一个名为 `lastXR` 的变量；然而，它没有被导出。如果您需要确定交叉引用的确切类型，您必须使用
    `xrefblk_t` 结构遍历交叉引用。`xrefblk_t` 在“枚举交叉引用”中描述。
- en: Iteration Techniques Using the IDA API
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IDA API 的遍历技术
- en: 'Using the IDA API, there are often several different ways to iterate over various
    database objects. In the following examples we demonstrate some common iteration
    techniques:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDA API，通常有几种不同的方式来遍历各种数据库对象。在以下示例中，我们展示了某些常见的遍历技术：
- en: Enumerating Functions
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举函数
- en: 'The first technique for iterating through the functions within a database mimics
    the manner in which we performed the same task using IDC:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数据库中函数的第一个技术模仿了我们使用 IDC 执行相同任务的方式：
- en: '[PRE43]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Alternatively, we can simply iterate through functions by index numbers, as
    shown in the next example:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以简单地通过索引号遍历函数，如下一个示例所示：
- en: '[PRE44]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we can work at a somewhat lower level and make use of a data structure
    called an `areacb_t`, also known as an *area control block*, defined in *area.hpp*.
    Area control blocks are used to maintain lists of related `area_t` objects. A
    global `areacb_t` named `funcs` is exported (in *funcs.hpp*) as part of the IDA
    API. Using the `areacb_t` class, the previous example can be rewritten as follows:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在一个较低的水平上工作，并使用一个名为 `areacb_t` 的数据结构，也称为 *区域控制块*，它在 *area.hpp* 中定义。区域控制块用于维护相关
    `area_t` 对象的列表。一个名为 `funcs` 的全局 `areacb_t` 被导出（在 *funcs.hpp* 中）作为 IDA API 的一部分。使用
    `areacb_t` 类，前面的示例可以重写如下：
- en: '[PRE45]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, the `get_next_area` member function ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) is used repeatedly to
    obtain the index values for each area in the `funcs` control block. A pointer
    to each related `func_t` area is obtained by supplying each index value to the
    `getn_area` member function ![](httpatomoreillycomsourcenostarchimages854093.png).
    Several global `areacb_t` variables are declared within the SDK, including the
    `segs` global, which is an area control block containing `segment_t` pointers
    for each section in the binary.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`get_next_area` 成员函数 ![](httpatomoreillycomsourcenostarchimages854061.png)
    和 ![](httpatomoreillycomsourcenostarchimages854063.png) 被反复使用以获取 `funcs` 控制块中每个区域的索引值。通过将每个索引值提供给
    `getn_area` 成员函数 ![](httpatomoreillycomsourcenostarchimages854093.png)，可以获得每个相关
    `func_t` 区域的指针。在 SDK 中声明了几个全局 `areacb_t` 变量，包括 `segs` 全局变量，它是一个包含二进制中每个部分 `segment_t`
    指针的区域控制块。
- en: Enumerating Structure Members
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举结构成员
- en: Within the SDK, stack frames are modeled using the capabilities of the `struc_t`
    class. The example in [Example 16-6](ch16s02.html#enumerating_stack_frame_members
    "Example 16-6. Enumerating stack frame members") utilizes structure member iteration
    as a means of printing the contents of a stack frame.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在SDK中，栈帧是通过`struc_t`类的功能来建模的。在[示例16-6](ch16s02.html#enumerating_stack_frame_members
    "示例16-6。枚举栈帧成员")中，利用结构成员迭代作为打印栈帧内容的一种手段。
- en: Example 16-6. Enumerating stack frame members
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-6. 枚举栈帧成员
- en: '[PRE46]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example summarizes a function’s stack frame using information from the
    function’s `func_t` object and the associated `struc_t` representing the function’s
    stack frame. The `frsize` and and `frregs` fields specify the size of the local
    variable portion of the stack frame and the number of bytes dedicated to saved
    registers, respectively. The saved return address can be found within the frame
    following the local variables and the saved registers. Within the frame itself,
    the `memqty` field specifies the number of defined members contained in the frame
    structure, which also corresponds to the size of the `members` array. A loop is
    used to retrieve the name of each member and determine whether the member is a
    local variable or an argument based on its starting offset (`soff`) within the
    frame structure.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用函数的`func_t`对象和表示函数栈帧的关联`struc_t`对象中的信息来总结函数的栈帧。`frsize`和`frregs`字段分别指定栈帧局部变量部分的大小和分配给保存寄存器的字节数。保存的返回地址可以在局部变量和保存的寄存器之后的帧中找到。在帧本身中，`memqty`字段指定帧结构中定义的成员数量，这也对应于`members`数组的大小。使用循环检索每个成员的名称，并根据其在帧结构中的起始偏移量（`soff`）确定该成员是局部变量还是参数。
- en: Enumerating Cross-References
  id: totrans-694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举交叉引用
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") we saw that it is possible
    to enumerate cross-references from IDC scripts. The same capabilities exist within
    the SDK, though in a some-what different form. As an example, let’s revisit the
    idea of listing all calls of a particular function (see [Example 15-4](ch15s05.html#enumerating_a_functionas_callers
    "Example 15-4. Enumerating a function’s callers") in [Enumerating Exported Functions](ch15s05.html#enumerating_exported_functions
    "Enumerating Exported Functions")). The following function almost works.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.html "第15章。IDA脚本")中，我们了解到从IDC脚本中枚举交叉引用是可能的。在SDK中，虽然形式略有不同，但同样具备这些功能。例如，让我们回顾一下列出特定函数所有调用的想法（参见[示例15-4](ch15s05.html#enumerating_a_functionas_callers
    "示例15-4。枚举函数的调用者")，在[枚举导出函数](ch15s05.html#enumerating_exported_functions "枚举导出函数")中）。以下函数几乎可以工作。
- en: '[PRE47]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The reason this function almost works is that there is no way to determine the
    type of cross-reference returned for each iteration of the loop (recall that there
    is no SDK equivalent for IDC’s `XrefType`). In this case we should verify that
    each cross-reference to the given function is in fact a call type (`fl_CN` or
    `fl_CF`) cross-reference.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数几乎可以工作的原因是无法确定循环每次迭代返回的交叉引用类型（回想一下，SDK中没有IDC的`XrefType`等效项）。在这种情况下，我们应该验证给定的每个函数的交叉引用实际上是一种调用类型（`fl_CN`或`fl_CF`）的交叉引用。
- en: When you need to determine the type of a cross-reference within the SDK, you
    must use an alternative form of cross-reference iteration facilitated by the `xrefblk_t`
    structure, which is described in *xref.hpp*. The basic layout of an `xrefblk_t`
    is shown in the following listing. (For full details, please see *xref.hpp*.)
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在SDK中确定交叉引用的类型时，您必须使用由`xrefblk_t`结构提供的替代形式的交叉引用迭代，该结构在*xref.hpp*中有所描述。`xrefblk_t`的基本布局如下所示。（有关完整详情，请参阅*xref.hpp*。）
- en: '[PRE48]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The member functions of `xrefblk_t` are used to initialize the structure ![](httpatomoreillycomsourcenostarchimages854061.png)
    and ![](httpatomoreillycomsourcenostarchimages854063.png) and perform the iteration
    ![](httpatomoreillycomsourcenostarchimages854093.png) and ![](httpatomoreillycomsourcenostarchimages854095.png),
    while the data members are used to access information about the last cross-reference
    that was retrieved. The `flags` value required by the `first_from` and `first_to`
    functions dictates which type of cross-references should be returned. Legal values
    for the `flags` parameter include the following (from *xref.hpp*):'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`xrefblk_t`的成员函数用于初始化结构！[](httpatomoreillycomsourcenostarchimages854061.png)和！[](httpatomoreillycomsourcenostarchimages854063.png)，并执行迭代！[](httpatomoreillycomsourcenostarchimages854093.png)和！[](httpatomoreillycomsourcenostarchimages854095.png)，而数据成员用于访问检索到的最后一个交叉引用的信息。`first_from`和`first_to`函数所需的`flags`值决定了应返回哪种类型的交叉引用。`flags`参数的有效值包括以下内容（来自*xref.hpp*）:'
- en: '[PRE49]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that no flag value restricts the returned references to code only. If you
    are interested in code cross-references, you must either compare the `xrefblk_t
    type` field to specific cross-reference types (such as `fl_JN`) or test the `iscode`
    field to determine if the last returned cross-reference was a code cross-reference.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有标志值限制返回的引用仅限于代码。如果您对代码交叉引用感兴趣，您必须将`xrefblk_t type`字段与特定的交叉引用类型（如`fl_JN`）进行比较，或者测试`iscode`字段以确定最后一个返回的交叉引用是否是代码交叉引用。
- en: The following modified version of the `list_callers` function demonstrates the
    use of an `xrefblk_t` iteration structure.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`list_callers`函数的修改版本展示了`xrefblk_t`迭代结构的用法。
- en: '[PRE50]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Through the use of an `xrefblk_t`, we now have the opportunity to examine ![](httpatomoreillycomsourcenostarchimages854061.png)
    the type of each cross-reference returned by the iterator and decide whether it
    is interesting to us or not. In this example we simply ignore any cross-reference
    that is not related to a function call. We did not use the `iscode` member of
    `xrefblk_t` because `iscode` is true for jump and ordinary flow cross-references
    in addition to call cross-references. Thus, `iscode` alone does not guarantee
    that the current cross-reference is related to a function call.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`xrefblk_t`，我们现在有机会检查由迭代器返回的每个交叉引用的类型，并决定它对我们是否有兴趣。在这个例子中，我们简单地忽略任何与函数调用无关的交叉引用。我们没有使用`xrefblk_t`的`iscode`成员，因为`iscode`对于跳转和普通流程交叉引用来说也是真的，而不仅仅是调用交叉引用。因此，仅凭`iscode`本身并不能保证当前交叉引用与函数调用相关。
- en: '* * *'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[116](#CHP-16-FN-3)]) *Binary large object*, or *blob*, is a term often used
    to refer to arbitray binary data of varying size.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[116](#CHP-16-FN-3)]) *二进制大对象*，或*blob*，是一个常用来指代不同大小的任意二进制数据的术语。
- en: Summary
  id: totrans-708
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The functions and data structures described in this chapter only scratch the
    surface of IDA’s API. For each of the functional categories described, many more
    API functions exist that perform more specialized tasks and that provide much
    finer control over various database elements than can be implemented using IDC.
    In the following chapters we will cover the details of building plug-in modules,
    loader modules, and processor modules, and we will continue to expand our presentation
    of the capabilities of the SDK.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的函数和数据结构只是触及了IDA API的表面。对于描述的每个功能类别，都存在许多执行更专业任务并提供比使用IDC更精细控制的API函数。在接下来的章节中，我们将介绍构建插件模块、加载模块和处理器模块的细节，并继续扩展我们对SDK功能的介绍。
- en: Chapter 17. The IDA Plug-in Architecture
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。IDA插件架构
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: Over the course of the next few chapters, we will cover the types of modules
    that can be constructed using the IDA SDK. We will also discuss new features (since
    IDA 5.7) that allow for the development of these same types of modules using one
    of IDA’s scripting languages. Whether you ever intend to create your own plug-ins
    or not, a basic understanding of plug-ins will greatly enhance your experience
    using IDA, since, arguably, the majority of third-party software developed for
    use with IDA is distributed in the form of plug-ins. In this chapter, we begin
    the exploration of IDA modules by discussing the purpose of IDA plug-ins, along
    with how to build, install, and configure them.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将介绍可以使用 IDA SDK 构建的各种模块类型。我们还将讨论自 IDA 5.7 以来引入的新功能，这些功能允许使用 IDA 的脚本语言之一来开发这些相同类型的模块。无论你是否打算创建自己的插件，对插件的基本理解都将极大地增强你在使用
    IDA 时的体验，因为可以说，为 IDA 开发的第三方软件的大部分都是以插件的形式分发的。在本章中，我们通过讨论 IDA 插件的目的以及如何构建、安装和配置它们，开始对
    IDA 模块进行探索。
- en: Plug-ins are probably best described as the compiled, albeit more powerful,
    equivalents of IDA scripts. Plug-ins are usually associated with a hotkey and/or
    a menu item and are typically accessible only after a database has been opened.
    Individual plug-ins may be general purpose in nature and useful across a wide
    variety of binary file types and processor architectures, or they may be very
    specialized, designed to be used only with a specific file format or processor
    type. In all cases, by virtue of being compiled modules, plug-ins have full access
    to the IDA API and can generally perform much more complex tasks than you could
    ever hope to accomplish using scripting alone.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 插件最好被描述为编译后的、尽管更强大的 IDA 脚本的等价物。插件通常与热键和/或菜单项相关联，并且通常只能在数据库打开后才能访问。单个插件可能是通用的，适用于广泛的二进制文件类型和处理器架构，或者它们可能是非常专业的，仅设计用于特定文件格式或处理器类型。在所有情况下，由于是编译模块，插件可以完全访问
    IDA API，并且通常可以执行比仅使用脚本所能完成的更复杂的任务。
- en: Writing a Plug-in
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写插件
- en: All IDA modules, including plug-ins, are implemented as shared library components
    appropriate to the platform on which the plug-in is expected to execute. Under
    IDA’s modular architecture, modules are not required to export any functions.
    Instead, each module type must export a variable of a specific class. In the case
    of plug-ins, this class is called a `plugin_t` and is defined in the SDK’s *loader.hpp*
    file.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 IDA 模块，包括插件，都作为适合插件预期执行的平台上的共享库组件实现。在 IDA 的模块化架构下，模块不需要导出任何函数。相反，每种模块类型必须导出一个特定类的变量。在插件的情况下，这个类被称为
    `plugin_t`，并在 SDK 的 *loader.hpp* 文件中定义。
- en: THE EVOLVING IDA API
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 不断演进的 IDA API
- en: Since SDK 4.9, Hex-Rays has attempted to minimize changes to existing API functions
    between releases of IDA. One result of this policy is that binary plug-ins from
    an older version of IDA can often be copied directly into newer IDA installations
    and continue to work properly. Nonetheless, IDA’s API has grown with each new
    release, introducing new functions and new options to take advantage of IDA’s
    everexpanding list of capabilities. As the SDK has evolved, Hex-Rays has opted
    to deprecate the occasional API function. When a function (or any other symbol)
    is deprecated, Hex-Rays moves it into a code block bounded by a test of the `NO_OBSOLETE_FUNCS`
    macro. If you wish to ensure that your plug-ins (or other modules) are not using
    any deprecated functions, you should define `NO_OBSOLETE_FUNCS` prior to including
    any SDK header files.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 自 SDK 4.9 以来，Hex-Rays 试图最小化 IDA 版本之间 API 函数的变化。这一政策的一个结果是，旧版本的 IDA 的二进制插件可以直接复制到新的
    IDA 安装中，并继续正常工作。尽管如此，IDA 的 API 随着每个新版本的发布而增长，引入了新的函数和新的选项，以利用 IDA 持续扩展的功能列表。随着
    SDK 的发展，Hex-Rays 选择弃用偶尔的 API 函数。当一个函数（或任何其他符号）被弃用时，Hex-Rays 会将其移动到一个由 `NO_OBSOLETE_FUNCS`
    宏的测试所包围的代码块中。如果你希望确保你的插件（或其他模块）没有使用任何弃用的函数，你应该在包含任何 SDK 头文件之前定义 `NO_OBSOLETE_FUNCS`。
- en: 'In order to understand how to create a plug-in, you must first understand the
    `plugin_t` class and its component data fields (the class has no member functions).
    The layout of the `plugin_t` class is shown here, with comments taken from *loader.hpp*:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何创建插件，你必须首先了解 `plugin_t` 类及其组件数据字段（该类没有成员函数）。`plugin_t` 类的布局在此处显示，注释来自
    *loader.hpp*：
- en: '[PRE51]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Every plug-in must export a `plugin_t` object named `PLUGIN`. Exporting your
    `PLUGIN` object is handled by *loader.hpp*, which leaves you responsible for declaring
    and initializing the actual object. Since successful plug-in creation relies on
    properly initializing this object, we describe the purpose of each member here.
    Note that even if you prefer to take advantage of IDA’s new scripted plug-in capabilities,
    you will still need to familiarize yourself with each of these fields because
    they are used in scripted plug-ins as well.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插件都必须导出一个名为`PLUGIN`的`plugin_t`对象。导出你的`PLUGIN`对象由*loader.hpp*处理，这让你负责声明和初始化实际的对象。由于成功创建插件依赖于正确初始化此对象，所以我们在这里描述了每个成员的目的。请注意，即使你更喜欢利用IDA的新脚本插件功能，你仍然需要熟悉这些字段，因为它们在脚本插件中也被使用。
- en: '**`version`**'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**`version`**'
- en: This member indicates the version number of the API that was used to build the
    plug-in. It is typically set to the constant `IDP_INTERFACE_VERSION`, which is
    declared in *idp.hpp*. The value of this constant has not changed since the API
    was standardized with SDK version 4.9\. The original intent of this field was
    to prevent plug-ins created with earlier versions of an SDK from being loaded
    into versions of IDA built with newer versions of the SDK.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员指示用于构建插件的API版本号。它通常设置为在*idp.hpp*中声明的常量`IDP_INTERFACE_VERSION`。自API与SDK版本4.9标准化以来，此常量的值没有变化。此字段的原始目的是防止使用较早版本的SDK创建的插件被加载到使用较新版本的SDK构建的IDA版本中。
- en: '**`flags`**'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**`flags`**'
- en: This field contains various flags indicating how IDA should treat the plug-in
    in various situations. The flags are set using a bitwise combination of the `PLUGIN_`*`XXX`*
    constants defined in *loader.hpp*. For many plug-ins, assigning zero to this field
    will be sufficient. Please refer to *loader.hpp* for the meanings of each flag
    bit.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含各种标志，指示IDA在不同情况下如何处理插件。这些标志是通过在*loader.hpp*中定义的`PLUGIN_`*`XXX`*常量的位组合来设置的。对于许多插件，将此字段设置为0将足够。请参阅*loader.hpp*了解每个标志位的含义。
- en: '**`init`**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**`init`**'
- en: This is the first of three function pointers contained in the `plugin_t` class.
    This particular member is a pointer to the plug-in’s initialization function.
    The function takes no parameters and returns an `int`. IDA calls this function
    to offer your plug-in a chance to be loaded. Initialization of plug-ins is discussed
    in [Plug-in Initialization](ch17.html#plug-in_initialization "Plug-in Initialization")
    in [Plug-in Initialization](ch17.html#plug-in_initialization "Plug-in Initialization").
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`plugin_t`类中包含的三个函数指针中的第一个。这个特定的成员是指向插件初始化函数的指针。该函数不接受任何参数，并返回一个`int`。IDA调用此函数以给插件一个被加载的机会。插件的初始化在[插件初始化](ch17.html#plug-in_initialization
    "插件初始化")中讨论。
- en: '**`term`**'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**`term`**'
- en: This member is another function pointer. IDA calls the associated function when
    your plug-in is unloaded. The function takes no arguments and returns no value.
    The purpose of this function is to perform any cleanup tasks (deallocating memory,
    closing handles, saving state, and so on) required by your plug-in before IDA
    unloads it. This field may be set to NULL if you have no actions to perform when
    your plug-in is unloaded.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员是一个另一个函数指针。当你的插件卸载时，IDA会调用相关的函数。该函数不接受任何参数，也不返回任何值。此函数的目的是在IDA卸载插件之前执行插件所需的任何清理任务（释放内存、关闭句柄、保存状态等）。
- en: '**`run`**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**`run`**'
- en: This member points to the function that should be called whenever a user activates
    (via a hotkey, menu item, or script invocation) your plug-in. This function is
    the heart of any plug-in, because it is here that the behaviors users associate
    with the plug-in are defined. This is the function that bears the most resemblance
    to scripted behaviors. The function receives a single integer parameter (discussed
    later under [Plug-in Execution](ch17.html#plug-in_execution "Plug-in Execution")
    in [Plug-in Execution](ch17.html#plug-in_execution "Plug-in Execution")) and returns
    nothing.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员指向当用户通过热键、菜单项或脚本调用激活（your plug-in）时应该被调用的函数。这个函数是任何插件的核心，因为用户与插件关联的行为定义在这里。这个函数与脚本行为最为相似。该函数接收一个整数参数（在[插件执行](ch17.html#plug-in_execution
    "插件执行")中讨论），并返回空值。
- en: '**`comment`**'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**`comment`**'
- en: This member is a pointer to a character string that serves as a comment for
    the plug-in. It is not used directly by IDA and can safely be set to NULL.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 该成员是一个指向字符字符串的指针，用作插件的注释。它不会被 IDA 直接使用，可以安全地设置为 NULL。
- en: '**`help`**'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**`help`**'
- en: This member is a pointer to a character string that serves as a multiline help
    string. It is not used directly by IDA and can safely be set to NULL.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 该成员是一个指向字符字符串的指针，用作多行帮助字符串。它不会被 IDA 直接使用，可以安全地设置为 NULL。
- en: '**`wanted_name`**'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**`wanted_name`**'
- en: This member is a pointer to a character string that holds the name of the plug-in.
    When a plug-in is loaded, this string is added to the Edit ▸ Plugins menu as a
    means of activating the plug-in. There is no requirement for the name to be unique
    among loaded plug-ins, though it is difficult to determine which of two identically
    named plug-ins will be activated when the name is selected from the menu.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 该成员是一个指向字符字符串的指针，包含插件的名称。当插件被加载时，这个字符串被添加到 Edit ▸ Plugins 菜单中，作为激活插件的一种方式。虽然不需要该名称在已加载的插件中是唯一的，但在从菜单中选择名称时，很难确定哪个具有相同名称的插件将被激活。
- en: '**`wanted_hotkey`**'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '**`wanted_hotkey`**'
- en: This member is a pointer to a character string that holds the name of the hotkey
    (such as `"Alt-F8"`) that IDA will attempt to associate with the plugin. Here
    again, there is no need for this value to be unique among loaded plug-ins; however;
    if the value is not unique, the hotkey will be associated with the last plug-in
    to request it. [Configuring Plug-ins](ch17s04.html "Configuring Plug-ins") in
    [Configuring Plug-ins](ch17s04.html "Configuring Plug-ins") discusses how users
    may override the `wanted_hotkey` value.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 该成员是一个指向字符字符串的指针，包含要尝试与插件关联的热键名称（例如 `"Alt-F8"`）。在这里，也没有必要要求这个值在已加载的插件中是唯一的；然而，如果该值不是唯一的，则热键将与最后请求它的插件关联。[配置插件](ch17s04.html
    "Configuring Plug-ins")中的[配置插件](ch17s04.html "Configuring Plug-ins")讨论了用户如何覆盖
    `wanted_hotkey` 值。
- en: 'An example of initializing a `plugin_t` object is shown here:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了初始化 `plugin_t` 对象的示例：
- en: '[PRE52]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The function pointers included in the `plugin_t` class allow IDA to locate required
    functions in your plug-in without requiring you to export those functions or to
    choose specific names for those functions.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugin_t` 类中包含的功能指针允许 IDA 在不要求您导出这些函数或为这些函数选择特定名称的情况下，在您的插件中定位所需的函数。'
- en: The Plug-in Life Cycle
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件生命周期
- en: 'A typical IDA session begins with the launch of the IDA application itself
    and proceeds through loading and analyzing a new binary file or existing database
    before settling down to wait for user interaction. During this process, there
    are three distinct points at which IDA offers plug-ins a chance to load:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 IDA 会话从启动 IDA 应用程序本身开始，然后通过加载和分析新的二进制文件或现有数据库，最后进入等待用户交互的状态。在这个过程中，IDA
    提供了三个不同的点，让插件有机会加载：
- en: A plug-in may load immediately upon IDA startup, regardless of whether a database
    is being loaded or not. Loading in this manner is controlled by the presence of
    the `PLUGIN_FIX` bit in `PLUGIN.flags`.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件可以在 IDA 启动时立即加载，无论是否正在加载数据库。以这种方式加载由 `PLUGIN.flags` 中的 `PLUGIN_FIX` 位是否存在控制。
- en: A plug-in may load immediately following a processor module and remain loaded
    until the processor module is unloaded. Tying a plug-in to a processor module
    is controlled by the `PLUGIN_PROC` bit in `PLUGIN.flags`.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件可以在处理器模块之后立即加载，并保持加载状态，直到处理器模块被卸载。将插件绑定到处理器模块由 `PLUGIN.flags` 中的 `PLUGIN_PROC`
    位控制。
- en: In the absence of the flag bits just mentioned, IDA offers plug-ins the opportunity
    to load each time a database is opened in IDA.
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有上述标志位的情况下，IDA 每次在 IDA 中打开数据库时都为插件提供加载的机会。
- en: IDA offers plug-ins the opportunity to load by calling `PLUGIN.init`. When called,
    the `init` function should determine whether the plug-in is designed to be loaded
    given the current state of IDA. The meaning of *current state* varies depending
    on which of the three preceding situations are applicable when the plug-in is
    being loaded. Examples of states that a plug-in may be interested in include the
    input file type (a plug-in may be designed specifically for use with PE files,
    for example) and the processor type (a plug-in may be designed exclusively for
    use with x86 binaries).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 通过调用 `PLUGIN.init` 为插件提供加载的机会。当被调用时，`init` 函数应确定插件是否设计为在 IDA 的当前状态下加载。*当前状态*
    的含义取决于在插件加载时适用的前三种情况中的哪一种。插件可能感兴趣的示例状态包括输入文件类型（例如，插件可能专门设计用于与 PE 文件一起使用）和处理器类型（插件可能仅设计用于与
    x86 二进制文件一起使用）。
- en: To indicate its desires to IDA, `PLUGIN.init` must return one of the following
    values defined in *loader.hpp*.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向 IDA 表达其愿望，`PLUGIN.init` 必须返回在 *loader.hpp* 中定义的以下值之一。
- en: '| **PLUGIN_SKIP** Returning this value signals that the plug-in should not
    be loaded. |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| **PLUGIN_SKIP** 返回此值表示插件不应被加载。|'
- en: '| **PLUGIN_OK** Returning this value instructs IDA to make the plug-in available
    for use with the current database. IDA loads the plug-in when the user activates
    the plug-in using a menu action or a hotkey. |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '| **PLUGIN_OK** 返回此值指示 IDA 使插件可用于与当前数据库一起使用。当用户通过菜单操作或热键激活插件时，IDA 会加载插件。|'
- en: '| **PLUGIN_KEEP** Returning this value instructs IDA to make the plug-in available
    for use with the current database and keep the plug-in loaded in memory. |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '| **PLUGIN_KEEP** 返回此值指示 IDA 使插件可用于与当前数据库一起使用，并保持插件在内存中加载。|'
- en: Once a plug-in has been loaded, it may be activated in one of two ways. The
    most frequent method of activating a plug-in is at the direction of the user in
    response to a menu selection or hotkey activation. Each time a plug-in is activated
    in this way, IDA passes control to the plug-in by calling `PLUGIN.run`. An alternate
    method for plug-in activation is for the plug-in to hook into IDA’s event-notification
    system. In such cases, a plug-in must express interest in one or more types of
    IDA events and register a callback function to be called by IDA when any event
    of interest occurs.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件被加载，可以通过两种方式之一激活它。激活插件最常见的方法是用户根据菜单选择或热键激活的指示。每次以这种方式激活插件时，IDA 都会通过调用 `PLUGIN.run`
    将控制权传递给插件。另一种激活插件的方法是插件挂钩到 IDA 的事件通知系统。在这种情况下，插件必须表达对一种或多种 IDA 事件感兴趣，并注册一个回调函数，以便
    IDA 在任何感兴趣的事件发生时调用。
- en: When it is time for a plug-in to be unloaded, IDA calls `PLUGIN.term` (assuming
    it is non-NULL). The circumstances under which a plug-in is unloaded vary according
    to the bits set in `PLUGIN.flags`. Plug-ins that specify no flag bits are loaded
    according to the value returned by `PLUGIN.init`. These types of plug-ins are
    unloaded when the database for which they were loaded is closed.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件需要卸载时，IDA 会调用 `PLUGIN.term`（假设它非 NULL）。插件卸载的情况根据 `PLUGIN.flags` 中设置的位而变化。未指定标志位的插件根据
    `PLUGIN.init` 返回的值加载。这些类型的插件在为它们加载的数据库关闭时卸载。
- en: When a plug-in specifies the `PLUGIN_UNL` flag bit, the plug-in is unloaded
    after each call to `PLUGIN.run`. Such plug-ins must be reloaded (resulting in
    a call to `PLUGIN.init`) for each subsequent activation. Plug-ins that specify
    the `PLUGIN_PROC` flag bit are unloaded when the processor module for which they
    were loaded is unloaded. Processor modules are unloaded whenever a database is
    closed. Finally, plug-ins that specify the `PLUGIN_FIX` flag bit are unloaded
    only when IDA itself terminates.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件指定 `PLUGIN_UNL` 标志位时，插件在每次调用 `PLUGIN.run` 之后卸载。此类插件必须在每次后续激活时重新加载（导致调用 `PLUGIN.init`）。指定
    `PLUGIN_PROC` 标志位的插件在为它们加载的处理器模块卸载时卸载。处理器模块在数据库关闭时卸载。最后，指定 `PLUGIN_FIX` 标志位的插件仅在
    IDA 本身终止时卸载。
- en: Plug-in Initialization
  id: totrans-755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件初始化
- en: Plug-ins are initialized in two phases. Static initialization of plug-ins takes
    place at compile time, while dynamic initialization takes place at load time via
    actions performed within `PLUGIN.init`. As discussed earlier, the `PLUGIN.flags`
    field, which is initialized at compile time, dictates several behaviors of a plug-in.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的初始化分为两个阶段。插件的静态初始化发生在编译时，而动态初始化是通过在 `PLUGIN.init` 中执行的操作在加载时发生的。如前所述，`PLUGIN.flags`
    字段在编译时初始化，决定了插件的一些行为。
- en: When IDA is launched, the `PLUGIN.flags` field of every plug-in in *<IDADIR>/plugins*
    is examined. At this point, IDA calls `PLUGIN.init` for each plug-in that specifies
    the `PLUGIN_FIX` flag. `PLUGIN_FIX` plug-ins are loaded before any other IDA module
    and therefore have the opportunity to be notified of any event that IDA is capable
    of generating, including notifications generated by loader modules and processor
    modules. The `PLUGIN.init` function for such plug-ins should generally return
    either `PLUGIN_OK` or `PLUGIN_KEEP`, because it makes little sense to request
    it to be loaded at startup only to return `PLUGIN_SKIP` in `PLUGIN.init`.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 当IDA启动时，会检查*<IDADIR>/plugins*目录中每个插件的`PLUGIN.flags`字段。在此阶段，IDA会为指定了`PLUGIN_FIX`标志的每个插件调用`PLUGIN.init`。`PLUGIN_FIX`插件在IDA的任何其他模块之前加载，因此有机会通知IDA能够生成的事件，包括由加载模块和处理器模块生成的通知。此类插件的`PLUGIN.init`函数通常应返回`PLUGIN_OK`或`PLUGIN_KEEP`，因为在启动时请求加载它，然后在`PLUGIN.init`中返回`PLUGIN_SKIP`几乎没有意义。
- en: However, if your plug-in is designed to perform a one-time initialization task
    at IDA startup, you may consider performing that task in the plug-in’s `init`
    function and returning `PLUGIN_SKIP` to indicate that the plug-in is no longer
    needed.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的插件设计用于在IDA启动时执行一次性的初始化任务，你可以考虑在该插件的`init`函数中执行该任务，并通过返回`PLUGIN_SKIP`来表示插件不再需要。
- en: 'Each time a processor module is loaded, IDA samples the `PLUGIN_PROC` flag
    in every available plug-in and calls `PLUGIN.init` for each plug-in in which `PLUGIN_PROC`
    is set. The `PLUGIN_PROC` flag allows plug-ins to be created that respond to notifications
    generated by processor modules and thereby supplement the behavior of those modules.
    The `PLUGIN.init` function for such modules has access to the global `processor_t`
    object, `ph`, which may be examined and used to determine whether the plug-in
    should be skipped or retained. For example, a plug-in designed specifically for
    use with the MIPS processor module should probably return `PLUGIN_SKIP` if the
    x86 processor module is being loaded, as shown here:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 每次加载处理器模块时，IDA都会检查每个可用插件的`PLUGIN_PROC`标志，并为其中`PLUGIN_PROC`被设置的每个插件调用`PLUGIN.init`。`PLUGIN_PROC`标志允许创建响应处理器模块生成通知的插件，从而补充这些模块的行为。此类模块的`PLUGIN.init`函数可以访问全局的`processor_t`对象`ph`，可以检查和使用它来确定插件是否应该被跳过或保留。例如，专门为与MIPS处理器模块一起使用而设计的插件，如果正在加载x86处理器模块，则可能应该返回`PLUGIN_SKIP`，如下所示：
- en: '[PRE53]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, each time a database is loaded or created, the `PLUGIN.init` function
    for each plug-in that has not already been loaded is called to determine whether
    the plug-in should be loaded or not. At this point each plug-in may use any number
    of criteria to determine whether IDA should retain it or not. Examples of specialized
    plug-ins include those that offer behavior specific to certain file types (ELF,
    PE, Mach-O, etc.), processor types, or compiler types.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每次加载或创建数据库时，都会调用尚未加载的每个插件的`PLUGIN.init`函数，以确定是否应该加载该插件。在此阶段，每个插件都可以使用任何数量的标准来决定IDA是否应该保留它。专用插件的例子包括那些针对特定文件类型（ELF、PE、Mach-O等）、处理器类型或编译器类型提供特定行为的插件。
- en: Regardless of the reason, when a plug-in decides to return `PLUGIN_OK` (or `PLUGIN_KEEP`),
    the `PLUGIN.init` function should also take care of any one-time initialization
    actions necessary to ensure that the plug-in is capable of performing properly
    when it is eventually activated. Any resources that are requested by `PLUGIN.init`
    should be released in `PLUGIN.term`. A major difference between `PLUGIN_OK` and
    `PLUGIN_KEEP` is that `PLUGIN_KEEP` prevents a plug-in from being repeatedly loaded
    and unloaded and thus reduces the need to allocate, deallocate, and reallocate
    resources as might be required when a plug-in specifies `PLUGIN_OK`. As a general
    rule of thumb, `PLUGIN.init` should return `PLUGIN_KEEP` when future invocations
    of the plug-in may depend on states accumulated during previous invocations of
    the plug-in. A workaround for this is for plug-ins to store any state information
    in the open IDA database using a persistent storage mechanism such as netnodes.
    Using such a technique, subsequent invocations of the plug-in can locate and utilize
    data stored by earlier invocations of the plug-in. This method has the advantage
    of providing persistent storage not only across invocations of the plug-in but
    also across IDA sessions.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 无论出于何种原因，当插件决定返回 `PLUGIN_OK`（或 `PLUGIN_KEEP`），`PLUGIN.init` 函数也应负责执行任何一次性的初始化动作，以确保插件在最终激活时能够正常工作。`PLUGIN.init`
    所请求的资源应在 `PLUGIN.term` 中释放。`PLUGIN_OK` 和 `PLUGIN_KEEP` 之间的主要区别在于，`PLUGIN_KEEP`
    防止插件被反复加载和卸载，从而减少了在插件指定 `PLUGIN_OK` 时可能需要的分配、释放和重新分配资源的需要。一般来说，当插件未来的调用可能依赖于插件之前调用期间积累的状态时，`PLUGIN.init`
    应返回 `PLUGIN_KEEP`。为此，插件可以通过使用持久化存储机制（如 netnodes）将任何状态信息存储在开放的 IDA 数据库中。使用这种技术，后续的插件调用可以定位并利用早期调用存储的数据。这种方法的优势在于，不仅可以在插件调用之间提供持久化存储，还可以在
    IDA 会话之间提供持久化存储。
- en: For plug-ins in which each invocation is completely independent of any previous
    invocations, it is often suitable for `PLUGIN.init` to return `PLUGIN_OK`, which
    has the advantage of reducing IDA’s memory footprint by keeping fewer modules
    loaded in memory at any given time.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个调用完全独立于任何先前调用的插件，通常适合 `PLUGIN.init` 返回 `PLUGIN_OK`，这具有减少 IDA 内存占用（在任何给定时间保持较少的模块加载到内存中）的优点。
- en: Event Notification
  id: totrans-764
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件通知
- en: While plug-ins are quite frequently activated directly by a user via a menu
    selection (Edit ▸ Plugins) or through the use of a hotkey, IDA’s event-notification
    capabilities offer an alternative means of activating plug-ins.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然插件通常通过用户通过菜单选择（编辑 ▸ 插件）或使用热键直接激活，但 IDA 的事件通知能力提供了激活插件的一种替代方法。
- en: 'When you want your plug-ins to be notified of specific events that take place
    within IDA, you must register a callback function to express interest in specific
    event types. The `hook_to_notification_point` function is used to inform IDA (1)
    that you are interested in a particular class of events and (2) that IDA should
    call the function that you indicate each time an event in the indicated class
    occurs. An example of using `hook_to_notification_point` to register interest
    in database events is shown here:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想让你的插件通知 IDA 内部发生的特定事件时，你必须注册一个回调函数来表示对特定事件类型的兴趣。`hook_to_notification_point`
    函数用于通知 IDA（1）你对特定类别的事件感兴趣，并且（2）每次发生指示类别的事件时，IDA 应该调用你指定的函数。这里展示了使用 `hook_to_notification_point`
    注册对数据库事件兴趣的示例：
- en: '[PRE54]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Four broad categories of notification exist: processor notifications (`idp_notify`
    in *idp.hpp*, `HT_IDP`), user interface notifications (`ui_notification_t` in
    *kernwin.hpp*, `HT_UI`), debugger events (`dbg_notification_t` in *dbg.hpp*, `HT_DBG`),
    and database events (`idp_event_t` in *idp.hpp*, `HT_IDB`). Within each event
    category are a number of individual notification codes that represent specific
    events for which you will receive notifications. Examples of database (`HT_IDB`)
    notifications include `idb_event::byte_patched`, to indicate that a database byte
    has been patched, and `idb_event::cmt_changed`, to indicate that a regular or
    repeatable comment has been changed. Each time an event occurs, IDA invokes each
    registered callback function, passing the specific event-notification code and
    any additional parameters specific to the notification code. Parameters supplied
    for each notification code are detailed in the SDK header files that define each
    notification code.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 存在四种广泛的通知类别：处理器通知（`idp_notify`在`*idp.hpp*`中，`HT_IDP`）、用户界面通知（`ui_notification_t`在`*kernwin.hpp*`中，`HT_UI`）、调试器事件（`dbg_notification_t`在`*dbg.hpp*`中，`HT_DBG`）和数据库事件（`idp_event_t`在`*idp.hpp*`中，`HT_IDB`）。在每个事件类别中都有一些单独的通知代码，代表您将接收通知的特定事件。数据库（`HT_IDB`）通知的例子包括`idb_event::byte_patched`，表示数据库字节已被修补，以及`idb_event::cmt_changed`，表示常规或可重复的注释已被更改。每次事件发生时，IDA都会调用每个已注册的回调函数，传递特定的事件-通知代码以及任何针对通知代码的特定参数。每个通知代码提供的参数在定义每个通知代码的SDK头文件中有详细说明。
- en: 'Continuing the preceding example, we might define a callback function to handle
    database events as follows:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 继续先前的例子，我们可能定义一个回调函数来处理数据库事件，如下所示：
- en: '[PRE55]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This particular example recognizes only the `byte_patched` notification message,
    for which it prints the address of the patched byte, the new value of the byte,
    and the original value of the byte. Notification callback functions make use of
    the C++ variable arguments list, `va_list`, to provide access to a variable number
    of arguments, depending on which notification code is being sent to the function.
    The number and type of arguments provided for each notification code are specified
    in the header files in which each notification code is defined. The `byte_patched`
    notification code is defined in *loader.hpp* to receive one argument of type `ea_t`
    in its `va_list`. The C++ `va_arg` macro should be used to retrieve successive
    arguments from a `va_list`. The address of the patched byte is retrieved from
    the `va_list` at ![](httpatomoreillycomsourcenostarchimages854061.png) in the
    preceding example.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子只识别`byte_patched`通知消息，对于这个消息，它会打印出被修补字节的地址、字节的新的值以及字节的原始值。通知回调函数使用C++变量参数列表`va_list`来提供对可变数量参数的访问，具体取决于向函数发送哪个通知代码。每个通知代码提供的参数数量和类型在定义每个通知代码的头文件中指定。`byte_patched`通知代码在`*loader.hpp*`中定义，以接收其`va_list`中的一个`ea_t`类型的参数。应该使用C++的`va_arg`宏从`va_list`中检索连续的参数。在先前的例子中，从`va_list`中检索修补字节的地址在![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)。
- en: 'An example of unhooking from database notification events is shown here:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了从数据库通知事件取消连接的例子：
- en: '[PRE56]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: All well-behaved plug-ins should unhook any notifications whenever the plug-in
    is unloaded. This is one of the intended purposes of the `PLUGIN.term` function.
    Failure to unhook all of your active notifications will almost certainly result
    in crashing IDA shortly after your plug-in is unloaded.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表现良好的插件都应该在插件卸载时取消所有通知。这是`PLUGIN.term`函数的一个预期用途。未能取消所有活动通知几乎肯定会导致在插件卸载后不久IDA崩溃。
- en: Plug-in Execution
  id: totrans-775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件执行
- en: Thus far we have discussed several instances in which IDA calls functions belonging
    to a plug-in. Plug-in loading and unloading operations result in calls to `PLUGIN.init`
    and `PLUGIN.term`, respectively. User plug-in activation via the Edit ▸ Plugins
    menu or the plug-in’s associated hotkey results in a call to `PLUGIN.run`. Finally,
    callback functions registered by a plug-in may be called in response to various
    events that take place within IDA.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了IDA调用插件函数的几个实例。插件加载和卸载操作分别导致调用`PLUGIN.init`和`PLUGIN.term`。通过编辑▸插件菜单或插件的关联热键激活用户插件会导致调用`PLUGIN.run`。最后，插件注册的回调函数可能会在IDA内部发生的各种事件响应中被调用。
- en: Regardless of how a plug-in comes to be executed, it is important to understand
    a few essential facts. Plug-in functions are invoked from IDA’s main event-processing
    loop. While a plug-in is executing, IDA cannot process events, including queued
    analysis tasks or updates to the user interface. Therefore it is important that
    your plug-in perform its task as expeditiously as possible and return control
    to IDA. Otherwise IDA will be completely unresponsive, and there will be no way
    to regain control. In other words, once your plug-in is executing, there is no
    simple way to break out of it. You must either wait for your plug-in to complete
    or kill your IDA process. In the latter case, you are likely to have an open database
    on your hands that may or may not be corrupt and may or may not be repairable
    by IDA. The SDK offers three functions that you may use to work around this issue.
    The `show_wait_box` function may be called to display a dialog that displays the
    message *Please wait*. . . along with a Cancel button. You may periodically test
    whether the user pressed the Cancel button by calling the `wasBreak` function.
    The advantage to this approach is that when `wasBreak` is called, IDA will take
    the opportunity to update its user interface, and it allows your plug-in the opportunity
    to decide whether it should stop the processing that it is doing. In any case,
    you must call `hide_wait_box` to remove the Wait dialog from the display.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 无论插件是如何被执行的，理解一些基本事实是很重要的。插件功能是从 IDA 的主事件处理循环中调用的。当插件正在执行时，IDA 无法处理事件，包括队列中的分析任务或用户界面的更新。因此，你的插件应尽可能快速地完成任务并返回控制权给
    IDA。否则，IDA 将完全无响应，将无法恢复控制。换句话说，一旦你的插件开始执行，就没有简单的方法从中退出。你必须等待插件完成或终止你的 IDA 进程。在后一种情况下，你可能会遇到一个可能损坏或可能无法由
    IDA 修复的开放数据库。SDK 提供了三个函数，你可以使用这些函数来解决这个问题。可以通过调用 `show_wait_box` 函数来显示一个对话框，该对话框显示消息“请等待...”以及一个取消按钮。你可以通过调用
    `wasBreak` 函数定期测试用户是否按下了取消按钮。这种方法的优点是，当调用 `wasBreak` 时，IDA 将利用这个机会更新其用户界面，并允许你的插件有机会决定是否应该停止正在进行的处理。无论如何，你必须调用
    `hide_wait_box` 来从显示中移除等待对话框。
- en: Do not attempt to get creative in your plug-ins by having your `PLUGIN.run`
    function create a new thread to handle the processing within your plug-in. IDA
    is not thread safe. There are no locking mechanisms in place to synchronize access
    to the many global variables used by IDA, nor are there any locking mechanisms
    to ensure the atomicity of database transactions. In other words, if you did create
    a new thread, and you used SDK functions to modify the database from within that
    thread, you could corrupt the database, because IDA might be in the middle of
    its own modification to the database that conflicts with your attempted changes.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图在插件中变得有创意，让 `PLUGIN.run` 函数创建一个新的线程来处理插件内的处理。IDA 不是线程安全的。IDA 中没有锁定机制来同步对
    IDA 使用的许多全局变量的访问，也没有锁定机制来确保数据库事务的原子性。换句话说，如果你创建了一个新的线程，并使用 SDK 函数在该线程中修改数据库，你可能会损坏数据库，因为
    IDA 可能正在对其进行自己的数据库修改，这与你的尝试更改相冲突。
- en: 'Keeping these limitations in mind, for most plug-ins, the bulk of the work
    performed by the plug-in will be implemented within `PLUGIN.run`. Building on
    our previously initialized `PLUGIN` object, a minimal (and boring) implementation
    for `PLUGIN.run` might look like the following:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些限制，对于大多数插件，插件执行的大部分工作将在 `PLUGIN.run` 中实现。基于我们之前初始化的 `PLUGIN` 对象，`PLUGIN.run`
    的一个最小（且无聊）的实现可能如下所示：
- en: '[PRE57]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Every plug-in has the C++ and IDA APIs at its disposal. Additional capabilities
    are available by linking your plug-in with appropriate platform-specific libraries.
    For example, the complete Windows API is available for plug-ins developed to run
    with Windows versions of IDA. To do something more interesting than printing a
    message to the output window, you need to understand how to accomplish your desired
    task using available functions from the IDA SDK. Taking the code from [Example 16-6](ch16s02.html#enumerating_stack_frame_members
    "Example 16-6. Enumerating stack frame members"), for example, we might develop
    the following function:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插件都可以使用 C++ 和 IDA API。通过将插件与适当的平台特定库链接，可以获得额外的功能。例如，完整的 Windows API 对 IDA
    的 Windows 版本开发的插件可用。若想做一些比向输出窗口打印消息更有趣的事情，您需要了解如何使用 IDA SDK 中的可用函数来完成您期望的任务。以
    [示例 16-6](ch16s02.html#enumerating_stack_frame_members "示例 16-6. 列举栈帧成员") 中的代码为例，我们可能会开发以下函数：
- en: '[PRE58]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Using this function, we now have the core of a plug-in that dumps stack frame
    information for the currently selected function each time the plug-in is activated.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，我们现在有了插件的核心，该插件在每次插件激活时都会转储当前选定函数的栈帧信息。
- en: Building Your Plug-ins
  id: totrans-784
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的插件
- en: On Windows, plug-ins are valid DLL files (that happen to use a *.plw* or .*p64*
    extension), while on Linux and Mac, a plug-in is a valid shared object file (that
    uses a *.plx/.plx64* or *.pmc/.pmc64* extension, respectively). Building plug-ins
    can be a tricky matter, because you must get all of the build settings correct
    or the build process is almost certain to fail. The SDK contains a number of sample
    plug-ins, each containing its own makefile. The makefiles were all created with
    Borland’s build tools for Windows in mind. This poses some challenges when you
    wish to build with a different tool chain or on a different platform. The *install_xxx.txt*
    files included with the SDK discuss the use of *<SDKDIR>/bin/idamake.pl* to build
    plug-ins using GNU make and gcc. The purpose of *idamake.pl* is to generate a
    GNU make-style makefile from the Borland-style makefiles and then invoke GNU make
    to build the plug-in.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，插件是有效的 DLL 文件（偶然使用 *.plw* 或 .*p64* 扩展名），而在 Linux 和 Mac 上，插件是一个有效的共享对象文件（分别使用
    *.plx/.plx64* 或 *.pmc/.pmc64* 扩展名）。构建插件可能是一个棘手的问题，因为您必须确保所有构建设置都正确，否则构建过程几乎肯定会失败。SDK
    包含了多个示例插件，每个插件都包含自己的 makefile。这些 makefile 都是为了与 Windows 上的 Borland 构建工具兼容而创建的。当您希望使用不同的工具链或在不同的平台上构建时，这会带来一些挑战。SDK
    中包含的 *install_xxx.txt* 文件讨论了使用 *<SDKDIR>/bin/idamake.pl* 来使用 GNU make 和 gcc 构建插件。*idamake.pl*
    的目的是从 Borland 风格的 makefile 生成 GNU make 风格的 makefile，然后调用 GNU make 来构建插件。
- en: 'Our preference for building plug-ins is to use simplified makefiles with the
    GNU tools (via MinGW on Windows). The simplified makefile in [Example 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins
    "Example 17-1. A sample makefile for IDA plug-ins") can easily be adapted to your
    own plug-in projects:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建插件时倾向于使用简化版的 makefile，配合 GNU 工具（通过 Windows 上的 MinGW）。[示例 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins
    "示例 17-1. 为 IDA 插件的一个示例 makefile") 中的简化 makefile 可以轻松地适配到您自己的插件项目中：
- en: Example 17-1. A sample makefile for IDA plug-ins
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-1. 为 IDA 插件的一个示例 makefile
- en: '[PRE59]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding makefile uses the `uname` command to determine the platform on
    which it is running and configures some build flags accordingly. Additional source
    files can be added to the plug-in project by appending the names of the associated
    object files to the `$OBJS` variable and to the end of the makefile. If your plug-in
    requires additional libraries, you should specify the library names in `$EXTRALIBS`.
    The `$IDA_SDK` variable is used to specify the location of the *<SDKDIR>*, and
    `$IDA_SDK` may be specified as an absolute or a relative path. In this example,
    `$IDA_SDK` is specified as a relative path, indicating that *<SDKDIR>* lies two
    directories above the plug-in’s directory. This is in keeping with locating plug-in
    projects within *<SDKDIR>/plugins* (*<SDKDIR>/plugins/**idabook_plugin* in this
    case). If you choose to locate your plug-in’s project directory in some other
    location relative to *<SDKDIR>*, you must ensure that `$IDA_SDK` properly refers
    to *<SDKDIR>*. Finally, the preceding example is configured to store successfully
    compiled plug-ins in *<SDKDIR>/bin/plugins*. It is important to understand that
    successfully compiling a plug-in does not necessarily install the plug-in. We
    cover plug-in installation in the next section.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 makefile 使用 `uname` 命令来确定其运行的平台，并根据此配置一些构建标志。可以通过将相关目标文件的名称追加到 `$OBJS` 变量和
    makefile 的末尾来向插件项目添加额外的源文件。如果你的插件需要额外的库，你应该在 `$EXTRALIBS` 中指定库的名称。`$IDA_SDK` 变量用于指定
    *<SDKDIR>* 的位置，`$IDA_SDK` 可以指定为绝对路径或相对路径。在这个例子中，`$IDA_SDK` 被指定为相对路径，表示 *<SDKDIR>*
    位于插件目录的上两层。这与将插件项目定位在 *<SDKDIR>/plugins* 内（在这种情况下是 *<SDKDIR>/plugins/**idabook_plugin*）相一致。如果你选择将插件的项目目录定位在相对于
    *<SDKDIR>的其他位置，你必须确保 `$IDA_SDK` 正确地引用了 *<SDKDIR>*。最后，上述示例被配置为将成功编译的插件存储在 *<SDKDIR>/bin/plugins*
    中。重要的是要理解，成功编译插件并不一定意味着插件被安装。我们将在下一节中介绍插件的安装。
- en: 'The use of Microsoft’s Visual C++ Express to build IDA modules is discussed
    in *install_visual.txt*. To create a project from scratch using Visual Studio
    2008, perform the following steps:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *install_visual.txt* 中讨论了使用 Microsoft 的 Visual C++ Express 构建 IDA 模块。要使用 Visual
    Studio 2008 从头创建一个项目，请执行以下步骤：
- en: Select **File** ▸ **New** ▸ **Project** to open the New Project dialog shown
    in [Figure 17-1](ch17s02.html#visual_studio_new_project-creation_dialo "Figure 17-1. Visual
    Studio new project-creation dialog").
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件** ▸ **新建** ▸ **项目** 以打开显示在 [图 17-1](ch17s02.html#visual_studio_new_project-creation_dialo
    "图 17-1. Visual Studio 新建项目对话框") 中的新建项目对话框。
- en: '![Visual Studio new project-creation dialog](httpatomoreillycomsourcenostarchimages854277.png.jpg)'
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Visual Studio 新建项目对话框](httpatomoreillycomsourcenostarchimages854277.png.jpg)'
- en: Figure 17-1. Visual Studio new project-creation dialog
  id: totrans-793
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 17-1. Visual Studio 新建项目对话框
- en: Specify the project type as **Visual C++/Win32**, choose the **Win32 Project**
    template, and provide the name and location for your project. We typically create
    new plug-in projects within the *<SDKDIR>/plugins* directory in order to keep
    all of our plug-ins grouped together. When you click **OK**, the Win32 Application
    Wizard appears. Click **Next** to get to the Application Settings step and then
    set the Application type to **DLL** and the Additional options to **Empty project**
    before clicking **Finish**, as shown in [Figure 17-2](ch17s02.html#visual_studio_win32_application_wizard
    "Figure 17-2. Visual Studio Win32 Application Wizard").
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目类型指定为 **Visual C++/Win32**，选择 **Win32 项目** 模板，并为你的项目提供名称和位置。我们通常在 *<SDKDIR>/plugins*
    目录内创建新的插件项目，以便将所有插件分组在一起。当你点击 **OK** 时，Win32 应用程序向导会出现。点击 **Next** 进入应用程序设置步骤，然后将应用程序类型设置为
    **DLL**，在点击 **Finish** 之前将附加选项设置为 **空项目**，如图 [图 17-2](ch17s02.html#visual_studio_win32_application_wizard
    "图 17-2. Visual Studio Win32 应用程序向导") 所示。
- en: '![Visual Studio Win32 Application Wizard](httpatomoreillycomsourcenostarchimages854280.png.jpg)'
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Visual Studio Win32 应用程序向导](httpatomoreillycomsourcenostarchimages854280.png.jpg)'
- en: Figure 17-2. Visual Studio Win32 Application Wizard
  id: totrans-796
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 17-2. Visual Studio Win32 应用程序向导
- en: Once the basic framework of the project has been created, you must configure
    a few additional settings. Project properties in Visual Studio 2008 are accessed
    via Project ▸ Properties, which brings up the dialog shown in [Figure 17-3](ch17s02.html#visual_studio_project_properties_dialog
    "Figure 17-3. Visual Studio project properties dialog"). C/C++ configuration options
    only become available once a source file has been added to the project, either
    by adding and editing a new file or adding an existing file.
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了项目的基本框架，您必须配置一些额外的设置。在Visual Studio 2008中，通过项目 ▸ 属性访问项目属性，这将显示[图17-3](ch17s02.html#visual_studio_project_properties_dialog
    "图17-3. Visual Studio项目属性对话框")中所示的对话框。只有在将源文件添加到项目后，C/C++配置选项才可用，无论是通过添加和编辑新文件还是添加现有文件。
- en: '![Visual Studio project properties dialog](httpatomoreillycomsourcenostarchimages854283.png.jpg)'
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Visual Studio项目属性对话框](httpatomoreillycomsourcenostarchimages854283.png.jpg)'
- en: Figure 17-3. Visual Studio project properties dialog
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图17-3. Visual Studio项目属性对话框
- en: The settings that require modification are spread throughout the Configuration
    Properties section at the left side of the dialog. [Figure 17-3](ch17s02.html#visual_studio_project_properties_dialog
    "Figure 17-3. Visual Studio project properties dialog") is representative of the
    manner in which properties are set throughout a project. For each property category
    selected in the left-hand portion of the dialog, a list of configurable properties
    is displayed in the right-hand portion of the dialog. Note that property categories
    are organized in a hierarchical fashion. Properties are edited using file-selection
    controls, single-line edit controls, multiline edit controls, or drop-down-list-selection
    controls. [Table 17-1](ch17s02.html#visual_studio_plug-in_configuration_valu "Table 17-1. Visual
    Studio Plug-in Configuration Values (32-bit)") details the properties that must
    be edited to create a plug-in project.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修改的设置分散在对话框左侧的配置属性部分。 [图17-3](ch17s02.html#visual_studio_project_properties_dialog
    "图17-3. Visual Studio项目属性对话框")展示了在整个项目中设置属性的方式。在对话框左侧选择每个属性类别后，对话框右侧将显示可配置属性的列表。请注意，属性类别以分层方式组织。属性使用文件选择控件、单行编辑控件、多行编辑控件或下拉列表选择控件进行编辑。[表17-1](ch17s02.html#visual_studio_plug-in_configuration_valu
    "表17-1. Visual Studio插件配置值（32位）")详细说明了必须编辑以创建插件项目的属性。
- en: Note that Visual Studio allows you to specify separate configuration options
    for Debug and Release versions of the project (see top left of [Figure 17-3](ch17s02.html#visual_studio_project_properties_dialog
    "Figure 17-3. Visual Studio project properties dialog")). If you intend to build
    separate Debug and Release versions of your plug-in, make certain that you have
    modified the properties in both configurations. Alternatively, you may save some
    time by selecting All Configurations from the Configurations drop-down list (at
    the top left of the Properties dialog), in which case your property changes will
    be applied to all build configurations.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Visual Studio允许您为项目的调试和发布版本指定不同的配置选项（见[图17-3](ch17s02.html#visual_studio_project_properties_dialog
    "图17-3. Visual Studio项目属性对话框")左上角）。如果您打算为您的插件构建单独的调试和发布版本，请确保您已修改了两种配置中的属性。或者，您可以通过从配置下拉列表（位于属性对话框的左上角）中选择“所有配置”来节省一些时间，在这种情况下，您的属性更改将应用于所有构建配置。
- en: Table 17-1. Visual Studio Plug-in Configuration Values (32-bit)
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-1. Visual Studio插件配置值（32位）
- en: '| Configuration Property Category | Specific Property | Property Value |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| 配置属性类别 | 特定属性 | 属性值 |'
- en: '| --- | --- | --- |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| General | Output Directory | As desired, often *<SDKDIR>\bin\plugins* |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '| 一般 | 输出目录 | 如需，通常为 *<SDKDIR>\bin\plugins* |'
- en: '| C/C++▸General | Additional Include Directories | Add *<SDKDIR>\include* |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '| C/C++▸一般 | 额外包含目录 | 添加 *<SDKDIR>\include* |'
- en: '| C/C++▸Preprocessor | Preprocessor Definitions | Append “;__NT__;__IDP__”
    |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '| C/C++▸预处理器 | 预处理器定义 | 追加 “;__NT__;__IDP__” |'
- en: '| C/C++▸Code Generation | Runtime Library | Multithreaded (Release)^([[a](#ftn.CHP-17-TFN-1)])
    Multithreaded Debug (Debug) (Not the DLL versions)^([[b](#ftn.CHP-17-TFN-2)])
    |'
  id: totrans-808
  prefs: []
  type: TYPE_TB
  zh: '| C/C++▸代码生成 | 运行库 | 多线程（发布）^([[a](#ftn.CHP-17-TFN-1)]) 多线程调试（调试）（不是DLL版本）^([[b](#ftn.CHP-17-TFN-2)])
    |'
- en: '| Linker▸General | Output File | Change extension to *.plw* |'
  id: totrans-809
  prefs: []
  type: TYPE_TB
  zh: '| 链接▸一般 | 输出文件 | 更改扩展名为 *.plw* |'
- en: '| Linker▸General | Additional Library Directories | Add *<SDKDIR>\lib\x86_win_vc_32*^([[c](#ftn.CHP-17-TFN-3)])
    |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '| 链接▸一般 | 额外库目录 | 添加 *<SDKDIR>\lib\x86_win_vc_32*^([[c](#ftn.CHP-17-TFN-3)])
    |'
- en: '| Linker▸Input | Additional Dependencies | Add *ida.lib* (from *\lib\86_win_vc_32*)
    |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '| 链接器▸输入 | 额外依赖项 | 添加 *ida.lib*（来自 *\lib\86_win_vc_32*） |'
- en: '| Linker▸Command Line | Additional options | Add */EXPORT:PLUGIN* |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '| 链接器▸命令行 | 额外选项 | 添加 */EXPORT:PLUGIN* |'
- en: '|'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ^([[a](#CHP-17-TFN-1)]) Multithreaded in this case refers to the C++ runtime
    library itself. IDA just happens to be a single-threaded application that makes
    use of this library. A single-threaded version of the C++ runtime library does
    not exist.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[a](#CHP-17-TFN-1)]) 在此情况下，多线程指的是C++运行时库本身。IDA恰好是一个使用此库的单线程应用程序。C++运行时库没有单线程版本。
- en: ^([[b](#CHP-17-TFN-2)]) Choosing the DLL versions of the C++ library requires
    that *MSVCR80.DLL* be present on the system on which the plug-in will ultimately
    run. In order to remove this restriction, choose the non-DLL version of the C++
    runtime libraries, which produces a statically linked plug-in that is more portable.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[b](#CHP-17-TFN-2)]) 选择C++库的DLL版本需要确保在插件最终运行的系统上存在 *MSVCR80.DLL*。为了消除此限制，请选择非DLL版本的C++运行时库，这将生成一个更易于移植的静态链接插件。
- en: ^([[c](#CHP-17-TFN-3)]) Prior to SDK version 6.1, add library directory *<SDKDIR>\lib\vc.w32*.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[c](#CHP-17-TFN-3)]) 在SDK版本6.1之前，添加库目录 *<SDKDIR>\lib\vc.w32*。
- en: '|'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Installing Plug-ins
  id: totrans-818
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装插件
- en: In comparison to the build process, plug-in installation is very simple. Installing
    a plug-in is accomplished by copying the compiled plug-in module to *<IDADIR>/plugins*.
    Note that Windows systems do not allow an executable file that is in use to be
    overwritten. So to install a plug-in on a Windows system, you must ensure that
    any previous version of the plug-in has been unloaded from IDA. Depending on the
    plug-in loading options, a plug-in may be unloaded when a database is closed.
    However, plug-ins that have the `PLUGIN_FIX` flag set may require IDA to be shut
    down entirely before the new plug-in can be copied to *<IDADIR>/plugins*.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建过程相比，插件安装非常简单。安装插件是通过将编译好的插件模块复制到 *<IDADIR>/plugins* 目录来完成的。请注意，Windows系统不允许覆盖正在使用的可执行文件。因此，要在Windows系统上安装插件，您必须确保任何之前的插件版本已经从IDA中卸载。根据插件加载选项，插件可能在关闭数据库时卸载。然而，设置了
    `PLUGIN_FIX` 标志的插件可能需要在将新插件复制到 *<IDADIR>/plugins* 之前完全关闭IDA。
- en: On Linux and OS X systems, executable files can be overwritten while they are
    in use, so you do not need to ensure that a plug-in is unloaded before installing
    a new version of it. However, the new version of the plug-in will not be loaded
    into IDA until the next time IDA offers plug-ins a chance to load.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和OS X系统上，可执行文件在使用时可以被覆盖，因此您不需要在安装新版本之前确保插件已卸载。然而，新版本的插件将不会在下次IDA提供插件加载机会之前被加载到IDA中。
- en: Some IDA plug-ins are distributed in binary form only, while others are distributed
    in both source and binary format. Installing such plug-ins usually involves finding
    the proper version of the compiled plug-in for your version of IDA and copying
    that plug-in to *<IDADIR>/plugins*. Make sure that you read the documentation
    (if any!) that accompanies any plug-in that you wish to install, because some
    plug-ins require the installation of additional components in order to function
    properly.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IDA插件仅以二进制形式分发，而其他插件则以源代码和二进制格式分发。安装此类插件通常涉及找到适合您IDA版本的编译好的插件版本，并将其复制到 *<IDADIR>/plugins*
    目录。请确保您阅读了任何您希望安装的插件的文档（如果有！），因为某些插件需要安装额外的组件才能正常工作。
- en: Configuring Plug-ins
  id: totrans-822
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置插件
- en: 'IDA provides a limited ability to configure plug-ins via settings in *<IDADIR>/plugins/plugins.cfg*.
    Settings in *plugins.cfg* can be used to specify the following information about
    a plug-in:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: IDA通过 *<IDADIR>/plugins/plugins.cfg* 中的设置提供有限的插件配置能力。*plugins.cfg* 中的设置可以用来指定有关插件以下信息：
- en: An alternate menu description for the plug-in. This value overrides the plug-in’s
    `wanted_name` data member.
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件的备用菜单描述。此值覆盖了插件的 `wanted_name` 数据成员。
- en: A nonstandard location or file extension for the plug-in. By default IDA searches
    for plug-ins in *<IDADIR>/plugins* and expects plug-ins to have a default, platform-specific
    file extension.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件的非标准位置或文件扩展名。默认情况下，IDA在 *<IDADIR>/plugins* 中搜索插件，并期望插件具有默认的平台特定文件扩展名。
- en: An alternate or additional hotkey used to activate the plug-in. This value overrides
    the plug-in’s `wanted_hotkey` data member.
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于激活插件的备用或附加快捷键。此值覆盖了插件的 `wanted_hotkey` 数据成员。
- en: An integer value to be passed to the plug-in’s `PLUGIN.run` function each time
    the plug-in is activated.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次插件被激活时，要传递给插件`PLUGIN.run`函数的整数值。
- en: An optional `DEBUG` flag for use with debugger plug-ins. Debugger plug-ins are
    discussed in [Chapter 24](ch24.html "Chapter 24. The IDA Debugger").
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于调试器插件的可选`DEBUG`标志。调试器插件将在[第 24 章](ch24.html "第 24 章。IDA 调试器")中讨论。
- en: 'The syntax of a valid plug-in configuration line is described in *plugins.cfg*.
    A few examples of plug-in configuration lines are shown here:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 有效插件配置行的语法在`plugins.cfg`中描述。这里展示了几个插件配置行的示例：
- en: '[PRE60]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `wanted_name` and `wanted_hotkey` data members for a plug-in are chosen
    by the plug-in’s author and compiled into the plug-in. It is entirely possible
    that two plug-ins developed by different authors may have identical names or identical
    hotkey associations. Within *plugin.cfg*, the `plugin_name` field specifies the
    text (which overrides `PLUGIN.wanted_name`) to be added to the Edit ▸ Plugins
    menu. It is possible to assign several names—and therefore several menu items—to
    a single plug-in. Underscore characters in the `plugin_name` field are replaced
    with space characters before the name is added to the Edit ▸ Plugins menu.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的`wanted_name`和`wanted_hotkey`数据成员由插件作者选择并编译到插件中。完全有可能两个由不同作者开发的插件具有相同名称或相同的快捷键关联。在`plugin.cfg`中，`plugin_name`字段指定要添加到“编辑
    ▸ 插件”菜单中的文本（该文本覆盖`PLUGIN.wanted_name`）。可以为单个插件分配多个名称——因此可以分配多个菜单项。在将名称添加到“编辑 ▸
    插件”菜单之前，`plugin_name`字段中的下划线字符被替换为空格字符。
- en: The `plugin_file` field specifies the name of the compiled plug-in module file
    to which the current configuration line applies. If a full path is specified,
    IDA loads the plug-in from the specified path. If no path is specified, IDA looks
    for the plug-in in *<IDADIR>/plugins*. If no file extension is specified, then
    IDA assumes a default plug-in extension for the current platform. If a file extension
    is specified, IDA searches for an exact match to the plug-in filename.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugin_file`字段指定应用于当前配置行的编译插件模块文件的名称。如果指定了完整路径，IDA 将从指定路径加载插件。如果没有指定路径，IDA
    将在`<IDADIR>/plugins`中查找插件。如果没有指定文件扩展名，则 IDA 假设当前平台的默认插件扩展名。如果指定了文件扩展名，IDA 将搜索与插件文件名完全匹配的文件。 '
- en: The `hotkey` field specifies the hotkey that should be used to activate the
    plug-in. This field overrides the value of `PLUGIN.wanted_hotkey` and can be used
    to resolve conflicting hotkey assignments when two plug-ins have been built that
    use the same hotkey for activation. Alternatively, assigning more than one hotkey
    to a plug-in offers the ability to activate a plug-in in more than one way. In
    such cases, it is useful to specify unique integer arguments for `PLUGIN.run`
    depending on which hotkey was used to activate a plug-in. When you pass different
    integer values to `PLUGIN.run`, IDA makes it possible for a plug-in to determine
    exactly how it was activated. This capability is useful when a plug-in implements
    more than one behavior and each behavior is selected based on how the plug-in
    is activated. In the preceding configuration example, IDA passes the integer value
    2 to `idabook_plugin`’s `PLUGIN.run` function whenever the plug-in is activated
    via the alt-F3 hotkey sequence.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`hotkey`字段指定用于激活插件的快捷键。此字段覆盖`PLUGIN.wanted_hotkey`的值，并可用于解决两个已构建的插件使用相同快捷键进行激活时的冲突快捷键分配。或者，将多个快捷键分配给插件可以提供以多种方式激活插件的能力。在这种情况下，根据使用了哪个快捷键来激活插件，为`PLUGIN.run`指定唯一的整数参数是有用的。当你向`PLUGIN.run`传递不同的整数值时，IDA
    使插件能够确定它确切是如何被激活的。当插件实现多个行为且每个行为都是根据插件是如何被激活的来选择时，这种能力非常有用。在前面的配置示例中，每次插件通过 alt-F3
    快捷键序列被激活时，IDA 都会将整数值 2 传递给`idabook_plugin`的`PLUGIN.run`函数。'
- en: Extending IDC
  id: totrans-834
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 IDC
- en: So far we have presented plug-ins designed primarily to manipulate or extract
    information from a database. In this section, we present an example of extending
    the capabilities of the IDC scripting language.^([[117](#ftn.CHP-17-FN-1)]) As
    mentioned in [Chapter 16](ch16.html "Chapter 16. The IDA Software Development
    Kit"), IDC is implemented on top of the IDA API, so it should come as no surprise
    that the API can be used to enhance IDC when the need arises.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已介绍了主要设计用于操作或从数据库中提取信息的插件。在本节中，我们将展示如何扩展 IDC 脚本语言的功能。（[[117](#ftn.CHP-17-FN-1)])
    如[第 16 章](ch16.html "第 16 章。IDA 软件开发套件")所述，IDC 是在 IDA API 之上实现的，因此当需要时使用 API 来增强
    IDC 并不令人惊讶。
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") and [Chapter 16](ch16.html
    "Chapter 16. The IDA Software Development Kit"), you learned that IDC global arrays
    are actually a somewhat restricted abstraction of netnodes. Recall that in IDC
    you create global arrays by supplying a name and receiving an array ID in return.
    Internally your name gets prefixed with the string “$ idc_array ”, and the array
    ID that you receive is actually a netnode index value. How could we go about extending
    IDC in order to enable access to any netnode in an IDA database? We can already
    access any netnode whose index we happen to know by using the index as the array
    ID in IDC, so what we need is the ability to access any netnode whose name we
    happen to know. IDC currently prevents us from doing this because it prepends
    “$ idc_array ” to every netnode name we supply. Enter the SDK and the `set_idc_func_ex`
    function.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 15 章](ch15.html "第 15 章。IDA 脚本") 和 [第 16 章](ch16.html "第 16 章。IDA 软件开发工具包")
    中，你了解到 IDC 全局数组实际上是 netnodes 的一种有限抽象。回想一下，在 IDC 中，你通过提供一个名称并返回一个数组 ID 来创建全局数组。内部你的名称会被前缀字符串
    “$ idc_array ”，而你收到的数组 ID 实际上是一个 netnode 索引值。我们如何扩展 IDC 以便能够访问 IDA 数据库中的任何 netnode
    呢？我们可以通过使用索引作为 IDC 中的数组 ID 来访问任何我们恰好知道索引的 netnode，所以我们需要的能力是能够访问任何我们恰好知道名称的 netnode。IDC
    目前阻止我们这样做，因为它将 “$ idc_array ” 前缀添加到我们提供的每个 netnode 名称中。现在引入 SDK 和 `set_idc_func_ex`
    函数。
- en: 'Defined in *expr.hpp*, `set_idc_func_ex` may be used to create a new IDC function
    and map its behavior to C++ implementation. The prototype for `set_idc_func_ex`
    is shown here:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *expr.hpp* 中定义的 `set_idc_func_ex` 可以用来创建一个新的 IDC 函数并将其行为映射到 C++ 实现中。`set_idc_func_ex`
    的原型如下所示：
- en: '[PRE61]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that we have introduced the `idc_func_t` datatype here in order to simplify
    the code somewhat. This datatype is not defined within the SDK. The arguments
    to `set_idc_func_ex` specify the name of the new IDC function that we are introducing
    (`idc_name`), a pointer to the C++ function that implements our new IDC behavior
    (`idc_impl`), a null-terminated array of characters that specify the argument
    types and sequence for the new IDC function (`args`), and flags (`extfunc_flags`)
    indicating whether an open database is required or whether the function never
    returns.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里引入了 `idc_func_t` 数据类型，以简化代码。此数据类型在 SDK 中没有定义。`set_idc_func_ex` 的参数指定了我们要引入的新
    IDC 函数的名称（`idc_name`），实现我们新 IDC 行为的 C++ 函数的指针（`idc_impl`），一个以 null 结尾的字符数组，指定新
    IDC 函数的参数类型和顺序（`args`），以及标志（`extfunc_flags`），指示是否需要打开数据库或函数是否永不返回。
- en: 'The following function, used as the initialization function for a plug-in,
    completes the process by creating the new IDC function we are designing:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用作插件初始化函数，通过创建我们正在设计的新的 IDC 函数来完成整个过程：
- en: '[PRE62]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This function creates the new IDC function `CreateNetnode` and maps it to our
    implementation function `idc_create_netnode` ![](httpatomoreillycomsourcenostarchimages854061.png).
    The arguments to the new IDC function are specified as being a single parameter
    of type string (`VT_STR2`) ![](httpatomoreillycomsourcenostarchimages854063.png).
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建新的 IDC 函数 `CreateNetnode` 并将其映射到我们的实现函数 `idc_create_netnode` ![图片链接](httpatomoreillycomsourcenostarchimages854061.png)。新
    IDC 函数的参数指定为单个字符串类型（`VT_STR2`）![图片链接](httpatomoreillycomsourcenostarchimages854063.png）。
- en: 'The function that actually implements the behavior of `CreateNetnode` is shown
    here:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `CreateNetnode` 行为的实际函数如下所示：
- en: '[PRE63]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The two arguments to this function represent the input argument array (`argv`)
    containing all of the parameters to `CreateNetnode` (there should be only one
    in this case) and an output parameter (`res`) used to receive the result of the
    IDC function we are implementing. The SDK datatype `idc_value_t` represents a
    single IDC value. Fields within this datatype indicate the current type of data
    represented by the value and the current contents of the value. The function begins
    by specifying that `CreateNetnode` returns a long (`VT_LONG`) value ![](httpatomoreillycomsourcenostarchimages854061.png).
    Since IDC variables are untyped, we must indicate internally what type of value
    the variable is holding at any given moment. Next, the function verifies that
    the caller of `CreateNetnode` has supplied an argument of type string (`VT_STR2`)
    ![](httpatomoreillycomsourcenostarchimages854063.png). If a valid argument has
    been supplied, a netnode is created with the supplied name ![](httpatomoreillycomsourcenostarchimages854093.png).
    The resulting netnode index number is returned to the caller as the result of
    the `CreateNetnode` function ![](httpatomoreillycomsourcenostarchimages854095.png).
    In this example, the result type is an integer value, so the result is stored
    into the `res->num` field. Had the result type been a string, we would have needed
    to call `res->set_string` to set the string value of the result. If the user fails
    to supply a string argument, the function fails and returns the invalid netnode
    index `−1` ![](httpatomoreillycomsourcenostarchimages854099.png).
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的两个参数代表输入参数数组（`argv`），包含 `CreateNetnode` 的所有参数（在这种情况下应该只有一个）和一个输出参数（`res`），用于接收我们实现的
    IDC 函数的结果。SDK 数据类型 `idc_value_t` 代表一个 IDC 值。此数据类型内的字段表示值当前表示的数据类型和值的当前内容。函数开始时指定
    `CreateNetnode` 返回一个长整型（`VT_LONG`）值![图片](httpatomoreillycomsourcenostarchimages854061.png)。由于
    IDC 变量是无类型的，我们必须内部指示变量在任何给定时刻所持有的值类型。接下来，函数验证 `CreateNetnode` 的调用者是否提供了一个字符串类型的参数（`VT_STR2`）![图片](httpatomoreillycomsourcenostarchimages854063.png）。如果已提供有效参数，则使用提供的名称创建一个
    netnode![图片](httpatomoreillycomsourcenostarchimages854093.png)。返回的 netnode 索引号作为
    `CreateNetnode` 函数的结果返回给调用者![图片](httpatomoreillycomsourcenostarchimages854095.png)。在这个例子中，结果类型是一个整数值，因此结果被存储到
    `res->num` 字段中。如果结果类型是字符串，我们就需要调用 `res->set_string` 来设置结果字符串值。如果用户未能提供字符串参数，函数将失败并返回无效的
    netnode 索引 `-1`![图片](httpatomoreillycomsourcenostarchimages854099.png)。
- en: 'We complete the plug-in with the following functions and `PLUGIN` structure:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下函数和 `PLUGIN` 结构完成插件：
- en: '[PRE64]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The trick to this plug-in is that it loads on IDA startup (`PLUGIN_FIX`) and
    remains hidden from the user because it is not added to the Edit ▸ Plugins menu
    (`PLUGIN_HIDE`) ![](httpatomoreillycomsourcenostarchimages854061.png). The plug-in
    is kept in memory for all databases, and all of the initialization takes place
    in the plug-in’s `init` function. As a result, the plug-in has nothing to do in
    its `run` method.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件的技巧在于它在 IDA 启动时加载（`PLUGIN_FIX`），并且对用户隐藏，因为它没有被添加到 Edit ▸ Plugins 菜单中（`PLUGIN_HIDE`）![图片](httpatomoreillycomsourcenostarchimages854061.png)。插件被保存在内存中，用于所有数据库，所有初始化都在插件的
    `init` 函数中完成。因此，插件在它的 `run` 方法中没有任何操作。
- en: 'Once this plug-in is installed, an IDC programmer may access any named netnode
    in an IDA database using the netnode’s name, as in the following example:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这个插件，IDC 程序员可以使用 netnode 的名称访问 IDA 数据库中的任何命名 netnode，如下例所示：
- en: '[PRE65]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: More information for using the SDK to interact with IDC is contained in the
    *expr.hpp* header file.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SDK 与 IDC 交互的更多信息包含在 *expr.hpp* 头文件中。
- en: '* * *'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[117](#CHP-17-FN-1)]) Note that there is currently no way to programmatically
    extend the IDAPython API from within a compiled plug-in.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[117](#CHP-17-FN-1)]) 注意，目前尚无方法可以从编译后的插件中程序化地扩展 IDAPython API。
- en: Plug-in User Interface Options
  id: totrans-854
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件用户界面选项
- en: This book makes no pretense at being a user interface development guide. However,
    there are many occasions in which a plug-in will need to interact with an IDA
    user to request or display information. In addition to the API’s `ask`*`XXX`*
    functions mentioned in [Chapter 16](ch16.html "Chapter 16. The IDA Software Development
    Kit"), a few more complex functions are available for user interaction via the
    IDA API. For more adventurous plug-in authors, it is worth remembering that plug-ins
    developed for GUI versions of IDA also have full access to the user interface
    functions that are available in various GUI libraries (Qt or Windows Native).
    Through the use of these functions it is possible to use virtually any type of
    graphical interface element within your plug-ins.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不假装是一本用户界面开发指南。然而，在许多情况下，插件需要与 IDA 用户交互以请求或显示信息。除了在第 16 章（[Chapter 16](ch16.html
    "Chapter 16. The IDA Software Development Kit")）中提到的 API 的 `ask`*`XXX`* 函数之外，IDA
    API 还提供了一些更复杂的函数用于用户交互。对于更有冒险精神的插件开发者来说，值得记住的是，为 IDA 的 GUI 版本开发的插件也完全有权访问各种 GUI
    库（Qt 或 Windows Native）中可用的用户界面函数。通过使用这些函数，你几乎可以在插件中使用任何类型的图形界面元素。
- en: Beyond the SDK’s `ask`*`XXX`* interface functions, things get a little more
    challenging when using the SDK to build user interface elements. One of the reasons
    for this is that the SDK attempts to provide a generic programming interface to
    accomplish the fairly complex task of displaying a GUI element to a user and accepting
    the user’s input.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 SDK 构建用户界面元素时，除了 SDK 的 `ask`*`XXX`* 接口函数之外，事情会变得稍微有些挑战性。其中一个原因是 SDK 试图提供一个通用的编程接口来完成向用户显示
    GUI 元素并接受用户输入的相对复杂的任务。
- en: Using the SDK’s Chooser Dialogs
  id: totrans-857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SDK 的选择对话框
- en: The first two functions that we will discuss are called `choose` and `choose2`.
    Each of these functions, along with various constants used to control its behavior,
    is declared in *kernwin.hpp*. The purpose of each function is to display a list
    of data elements to the user and ask the user to select one or more items from
    the list. The `choose` functions are capable of displaying virtually any type
    of data by virtue of the fact that they require you to specify formatting functions
    that are called to generate each line of text displayed in the chooser window.
    The two functions differ in that `choose` displays a single-column list, while
    `choose2` is capable of displaying a multicolumn list. In the following examples
    we demonstrate the simplest forms of these functions, which rely on many default
    parameters. If you want to explore the full range of capabilities of `choose`
    and `choose2`, please consult *kernwin.hpp*.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的前两个函数被称为 `choose` 和 `choose2`。这些函数以及用于控制其行为的各种常量都在 *kernwin.hpp* 中声明。每个函数的目的是向用户显示一系列数据元素，并要求用户从列表中选择一个或多个项目。`choose`
    函数能够通过要求你指定用于生成选择窗口中显示的每一行文本的格式化函数，几乎显示任何类型的数据。这两个函数的不同之处在于 `choose` 显示单列列表，而
    `choose2` 能够显示多列列表。在以下示例中，我们展示了这些函数最简单的形式，这些形式依赖于许多默认参数。如果你想要探索 `choose` 和 `choose2`
    的全部功能，请查阅 *kernwin.hpp*。
- en: 'For displaying a single column of information to a user, the simplest form
    of the `choose` function boils down to the following, once default parameters
    are omitted:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向用户显示单列信息，`choose` 函数的最简单形式在省略默认参数后如下：
- en: '[PRE66]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, the `obj` parameter is a pointer to the block of data to be displayed,
    and `width` is the desired column width to be used in the chooser window. The
    `sizer` parameter is a pointer to a function that is capable of parsing the data
    pointed to by `obj` and returning the number of lines required to display that
    data. The `getline` parameter is a pointer to a function that can generate the
    character string representation of a single item selected from `obj`. Note that
    the `obj` pointer can point to any type of data as long as the `sizer` function
    can parse the data to determine the number of lines required to display the data
    and as long as the `getline` function can locate a specific data item using an
    integer index and generate a character string representation of that data item.
    The `title` parameter specifies the title string used in the generated chooser
    dialog. The `choose` function returns the index number (1..*n*) of the user-selected
    item or zero if the dialog was canceled by the user. The code in [Example 17-2](ch17s06.html#example_use_of_the_choose_function
    "Example 17-2. Example use of the choose function"), while not terribly exciting,
    is extracted from a plug-in that demonstrates the use of the `choose` function.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`obj` 参数是指向要显示的数据块的指针，而 `width` 是在选取窗口中使用的期望列宽。`sizer` 参数是指向一个函数的指针，该函数能够解析
    `obj` 指向的数据，并返回显示该数据所需的行数。`getline` 参数是指向一个函数的指针，该函数可以生成从 `obj` 中选择的单个项目的字符字符串表示。请注意，只要
    `sizer` 函数能够解析数据以确定显示数据所需的行数，并且只要 `getline` 函数可以使用整数索引定位特定数据项并生成该数据项的字符字符串表示，`obj`
    指针可以指向任何类型的数据。`title` 参数指定用于生成的选取对话框的标题字符串。`choose` 函数返回用户选择的项的索引号（1..*n*），如果对话框被用户取消，则返回零。[示例
    17-2](ch17s06.html#example_use_of_the_choose_function "示例 17-2. `choose` 函数的示例用法")
    中的代码虽然并不十分令人兴奋，但它是从一个演示 `choose` 函数使用的插件中提取出来的。
- en: Example 17-2. Example use of the `choose` function
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-2. `choose` 函数的示例用法
- en: '[PRE67]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Activating the plug-in from [Example 17-2](ch17s06.html#example_use_of_the_choose_function
    "Example 17-2. Example use of the choose function") results in the chooser dialog
    shown in [Figure 17-4](ch17s06.html#example_of_the_chooser_dialog "Figure 17-4. Example
    of the chooser dialog").
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [示例 17-2](ch17s06.html#example_use_of_the_choose_function "示例 17-2. `choose`
    函数的示例用法") 激活插件会导致出现 [图 17-4](ch17s06.html#example_of_the_chooser_dialog "图 17-4.
    选取对话框的示例") 中所示的选取对话框。
- en: '![Example of the chooser dialog](httpatomoreillycomsourcenostarchimages854286.png.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![选取对话框的示例](httpatomoreillycomsourcenostarchimages854286.png.jpg)'
- en: Figure 17-4. Example of the chooser dialog
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-4. 选取对话框的示例
- en: 'The `choose2` function offers a multicolumn variation of the chooser dialog.
    Again, we look at the simplest version of the function, accepting all possible
    default arguments, which boils down to the following:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '`choose2` 函数提供了一个多列版本的选取对话框。同样，我们来看这个函数最简单的版本，接受所有可能的默认参数，这归结为以下内容：'
- en: '[PRE68]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We can observe a few differences between `choose2` and the `choose` function
    we saw earlier. First, the `ncol` parameter specifies the number of columns to
    be displayed, while the `widths` parameter is an array of integers that specify
    the width of each column. The format of the `getline` function changes somewhat
    in `choose2`. Since the `choose2` dialog can contain several columns, the `get-line`
    function must provide data for each column within a single line. The example code
    in [Example 17-3](ch17s06.html#example_use_of_the_choose2_function "Example 17-3. Example
    use of the choose2 function") shows the use of `choose2` in a demonstration plug-in.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到 `choose2` 函数与我们之前看到的 `choose` 函数之间的一些差异。首先，`ncol` 参数指定要显示的列数，而 `widths`
    参数是一个整数数组，指定每列的宽度。在 `choose2` 中，`getline` 函数的格式有所变化。由于 `choose2` 对话框可以包含多个列，因此
    `get-line` 函数必须在单行内为每个列提供数据。[示例 17-3](ch17s06.html#example_use_of_the_choose2_function
    "示例 17-3. `choose2` 函数的示例用法") 中的示例代码展示了在演示插件中使用 `choose2`。
- en: Example 17-3. Example use of the `choose2` function
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-3. `choose2` 函数的示例用法
- en: '[PRE69]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The multicolumn chooser dialog generated using the code from [Example 17-3](ch17s06.html#example_use_of_the_choose2_function
    "Example 17-3. Example use of the choose2 function") is shown in [Figure 17-5](ch17s06.html#example_of_the_choose2_dialog
    "Figure 17-5. Example of the choose2 dialog").
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [示例 17-3](ch17s06.html#example_use_of_the_choose2_function "示例 17-3. `choose2`
    函数的示例用法") 中的代码生成的多列选取对话框如图 [图 17-5](ch17s06.html#example_of_the_choose2_dialog
    "图 17-5. `choose2` 对话框的示例") 所示。
- en: '![Example of the choose2 dialog](httpatomoreillycomsourcenostarchimages854289.png.jpg)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![`choose2` 对话框示例](httpatomoreillycomsourcenostarchimages854289.png.jpg)'
- en: Figure 17-5. Example of the `choose2` dialog
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-5. `choose2` 对话框示例
- en: Far more complex uses of both the `choose` and the `choose2` functions are possible.
    Each function is capable of creating either modal ^([[118](#ftn.CHP-17-FN-2)])
    or nonmodal dialogs, and each function can generate dialogs that allow for selection
    of multiple items. Also, each function accepts several additional parameters that
    allow you to be notified when various events take place within the dialog. When
    these functions are used to create nonmodal dialogs, the result is a new tabbed
    window displayed alongside the tabs of other IDA display windows, such as the
    Imports window. In fact, IDA’s Imports window is implemented using the `choose2`
    interface. For more information on the capabilities of `choose` and `choose2`,
    please refer to *kernwin.hpp*.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`choose` 和 `choose2` 函数的更多复杂用法是可能的。每个函数都能够创建模态或非模态对话框，并且每个函数都可以生成允许选择多个项目的对话框。此外，每个函数还接受几个额外的参数，允许您在对话框中发生各种事件时得到通知。当这些函数用于创建非模态对话框时，结果是在其他
    IDA 显示窗口的标签旁边显示一个新标签页窗口，例如导入窗口。实际上，IDA 的导入窗口是使用 `choose2` 接口实现的。有关 `choose` 和
    `choose2` 的功能更多信息，请参阅 *kernwin.hpp*。'
- en: Creating Customized Forms with the SDK
  id: totrans-876
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SDK 创建自定义表单
- en: 'For creating more complex user interface elements, the SDK provides the `AskUsingForm_c`
    function. The prototype for this function is shown here:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更复杂的用户界面元素，SDK 提供了 `AskUsingForm_c` 函数。此函数的原型在此处显示：
- en: '[PRE70]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The function seems simple enough, yet it is among the more complex user interface
    functions available in the SDK. This complexity is due to the nature of the `form`
    argument, which is used to specify the layout of various user interface elements
    within the custom dialog. `AskUsingForm_c` is similar to `printf` in that the
    `form` argument is essentially a format string that describes the layout of various
    input elements. Where `printf` format strings utilize output format specifiers
    that are replaced with formatted data, `AskUsingForm_c` format strings are composed
    of both output specifiers and form field specifiers that are replaced with instances
    of input elements when the form is displayed. `AskUsingForm_c` recognizes a completely
    different set of output field specifiers than `printf`. These specifiers are detailed
    in *kernwin.hpp* along with complete documentation on the use of `AskUsingForm_c`.
    The basic format of a form field specifier is shown here:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 函数看起来足够简单，但在 SDK 中提供的用户界面函数中，它属于较为复杂的函数之一。这种复杂性是由于 `form` 参数的性质，该参数用于指定自定义对话框中各种用户界面元素的布局。`AskUsingForm_c`
    函数与 `printf` 类似，因为 `form` 参数本质上是一个格式字符串，它描述了各种输入元素的布局。`printf` 格式字符串使用输出格式说明符，这些说明符被格式化的数据替换，而
    `AskUsingForm_c` 格式字符串由输出说明符和表单字段说明符组成，当表单显示时，这些说明符被输入元素的实例替换。`AskUsingForm_c`
    识别与 `printf` 完全不同的输出字段说明符。这些说明符在 *kernwin.hpp* 中详细说明，并提供了关于使用 `AskUsingForm_c`
    的完整文档。表单字段指定符的基本格式在此处显示：
- en: '[PRE71]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The individual components of a form field specifier are described in the following
    list:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段指定符的各个组成部分在以下列表中描述：
- en: '| **`#hint text#`** This element is optional. If present, the hint text, excluding
    the# characters, is displayed as a tool tip when the mouse hovers over the associated
    input field. |'
  id: totrans-882
  prefs: []
  type: TYPE_TB
  zh: '| **`#提示文本#`** 此元素是可选的。如果存在，则提示文本（不包括 # 字符）在鼠标悬停在关联输入字段上时作为工具提示显示。|'
- en: '| **`label`** Static text displayed as a label to the left of the associated
    input field. In the case of button fields, this is the button text. |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
  zh: '| **`label`** 静态文本，作为关联输入字段左侧的标签显示。在按钮字段的情况下，这是按钮文本。|'
- en: '| **`type`** A single character indicates the type of form field being specified.
    Form field types are described following this list. |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
  zh: '| **`type`** 单个字符表示所指定的表单字段的类型。表单字段类型在以下列表中描述。|'
- en: '| **`width`** The maximum number of input characters accepted by the associated
    input field. In the case of button fields, this field specifies an integer button
    identification code used to distinguish one button from another. |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '| **`width`** 关联输入字段可接受的输入字符的最大数量。在按钮字段的情况下，该字段指定一个整数按钮标识码，用于区分不同的按钮。|'
- en: '| **`swidth`** The display width of the input field. |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
  zh: '| **`swidth`** 输入字段的显示宽度。|'
- en: '| **`@hlp[]`** This field is described in *kernwin.hpp* as “the number of help
    screen from the *IDA.HLP* file.” Since the content of this file is dictated by
    Hex-Rays, it seems unlikely that this field will be of use in the majority of
    cases. Substitute a colon for this field in order to ignore it. |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '| **`@hlp[]`** 此字段在*kernwin.hpp*中被描述为“从*IDA.HLP*文件中的帮助屏幕数量。”由于此文件的内容由Hex-Rays决定，因此此字段在大多数情况下似乎不太可能有用。为了忽略此字段，可以用冒号替换它。|'
- en: 'The characters used for the `type` field specify what type of input field will
    be generated when the dialog is realized at runtime. Each type of form field requires
    an associated parameter in the variable arguments portion of the `AskUsingForm_c`
    parameter list. Form field type specifiers and their associated parameter type
    are shown here (as taken from *kernwin.hpp*):'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 用于`type`字段的字符指定在运行时实现对话框时将生成哪种类型的输入字段。每种表单字段都需要在`AskUsingForm_c`参数列表的变量参数部分中有一个关联的参数。表单字段类型说明符及其关联的参数类型如下（从*kernwin.hpp*中摘取）：
- en: '[PRE72]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: All numeric fields interpret the user-supplied input as an IDC expression that
    is parsed and evaluated when the user clicks the dialog’s OK button. All fields
    require a pointer argument that is used for both input and output. When the form
    is first generated, initial values for all form fields are taken by dereferencing
    the associated pointers. Upon return, the user-supplied form field values are
    written into the associated memory locations. The pointer argument associated
    with a button (`B`) field is the address of a function that will be called if
    the associated button is pressed. The `formcb_t` function is defined as follows.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数字字段将用户提供的输入解释为IDC表达式，该表达式在用户点击对话框的OK按钮时解析和评估。所有字段都需要一个指针参数，用于输入和输出。当表单首次生成时，所有表单字段的初始值通过关联指针的解引用来获取。返回时，用户提供的表单字段值将写入相关的内存位置。与按钮（`B`）字段关联的指针是如果按下相关按钮将被调用的函数的地址。`formcb_t`函数定义如下。
- en: '[PRE73]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `code` argument to the button callback represents the code (width) value
    associated with the button that was clicked. By using a switch statement to test
    this code, you can use a single function to process many different buttons.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮回调的`code`参数表示与被点击按钮关联的代码（宽度）值。通过使用switch语句测试此代码，你可以使用单个函数来处理许多不同的按钮。
- en: 'The syntax for specifying radio button and checkbox controls differs slightly
    from the format of other types of form fields. These fields utilize the following
    format:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 指定单选按钮和复选框控件的语言与其它类型表单字段的格式略有不同。这些字段使用以下格式：
- en: '[PRE74]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Radio buttons and checkboxes may be grouped by listing their specifiers in order
    and denoting the end of the list using the following special format (note the
    extra `>` at the end).
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮和复选框可以通过按顺序列出它们的说明符并使用以下特殊格式表示列表的结束来分组（注意末尾的额外`>`）。
- en: '[PRE75]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A radio button (or checkbox) group will be boxed to highlight the group. You
    can give the box a title by utilizing a special format when specifying the first
    element in the group, as shown here:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮（或复选框）组将被框起来以突出显示该组。你可以通过在指定组中的第一个元素时使用特殊格式来给框一个标题，如下所示：
- en: '[PRE76]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you want to have a box title but do not want to use any hints, the hints
    may be omitted, leaving the following format specifier:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要有一个框标题但不想使用任何提示，可以省略提示，留下以下格式说明符：
- en: '[PRE77]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: At this point let’s look at an example of a dialog constructed using `AskUsingForm_c`.
    [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog "Figure 17-6. Sample
    AskUsingForm_c dialog") shows a dialog that we will refer to throughout this discussion.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，让我们看看使用`AskUsingForm_c`构建的对话框的示例。[图17-6](ch17s06.html#sample_askusingform_underscore_c_dialog
    "图17-6. 样本AskUsingForm_c对话框")显示了我们将在此讨论中引用的对话框。
- en: '![Sample AskUsingForm_c dialog](httpatomoreillycomsourcenostarchimages854292.png.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![样本AskUsingForm_c对话框](httpatomoreillycomsourcenostarchimages854292.png.jpg)'
- en: Figure 17-6. Sample `AskUsingForm_c` dialog
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-6. 样本`AskUsingForm_c`对话框
- en: 'Format strings used to create `AskUsingForm_c` dialogs are made up of individual
    lines that specify each aspect of the desired dialog. In addition to form field
    specifiers, the format string may contain static text that is displayed, verbatim,
    in the resulting dialog. Finally, the format string may contain a dialog title
    (which must be followed by two carriage returns) and one or more behavior directives
    (such as `STARTITEM`, which specifies the index of the form field that is initially
    active when the dialog is first displayed). The format string used to create the
    dialog in [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog "Figure 17-6. Sample
    AskUsingForm_c dialog") is shown here:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建`AskUsingForm_c`对话框的格式字符串由指定所需对话框每个方面的单独行组成。除了表单字段指定符外，格式字符串还可以包含在结果对话框中按原样显示的静态文本。最后，格式字符串可以包含对话框标题（必须后跟两个回车换行符）和一个或多个行为指令（例如`STARTITEM`，它指定当对话框首次显示时最初激活的表单字段索引）。用于创建[图17-6](ch17s06.html#sample_askusingform_underscore_c_dialog
    "图17-6. 样本AskUsingForm_c对话框")中对话框的格式字符串如下所示：
- en: '[PRE78]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'By formatting the dialog specification as we have, one element per line, we
    are attempting to make it easier to map each field specifier to its corresponding
    field in [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog "Figure 17-6. Sample
    AskUsingForm_c dialog"). You may notice that in [Figure 17-6](ch17s06.html#sample_askusingform_underscore_c_dialog
    "Figure 17-6. Sample AskUsingForm_c dialog"), all of the text and numeric input
    fields appear as drop-down list controls. In an effort to save you time, IDA populates
    each list with recently entered values whose type matches the type of the associated
    input field. The following plug-in code may be used to display the example dialog
    and process any results:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将对话框规范格式化为我们这样的形式，每行一个元素，我们试图使将每个字段指定符映射到[图17-6](ch17s06.html#sample_askusingform_underscore_c_dialog
    "图17-6. 样本AskUsingForm_c对话框")中相应的字段变得更加容易。你可能注意到，在[图17-6](ch17s06.html#sample_askusingform_underscore_c_dialog
    "图17-6. 样本AskUsingForm_c对话框")中，所有的文本和数字输入字段都显示为下拉列表控件。为了节省你的时间，IDA会为每个列表填充与相关输入字段类型匹配的最近输入的值。以下插件代码可以用来显示示例对话框并处理任何结果：
- en: '[PRE79]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that when processing radio button and checkbox results, the first button
    in each group is considered button zero.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在处理单选按钮和复选框的结果时，每组中的第一个按钮被认为是按钮零。
- en: The `AskUsingForm_c` function provides a considerable amount of power for designing
    user interface elements for your plug-ins. The example here touches on many of
    the capabilities of this function, but many more are detailed in *kernwin.hpp*.
    Please refer to this file for more information on the `AskUsingForm_c` function
    and its capabilities.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '`AskUsingForm_c`函数为设计插件的用户界面元素提供了相当多的功能。这里的示例涉及了该函数的许多功能，但更多细节可以在*kernwin.hpp*中找到。请参考此文件以获取有关`AskUsingForm_c`函数及其功能的更多信息。'
- en: Windows-Only User Interface–Generation Techniques
  id: totrans-910
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅限Windows的用户界面生成技术
- en: Many developers have wrestled with the problem of creating user interfaces for
    their plug-ins. Plug-ins targeting the Windows-only GUI version of IDA (*idag.exe*)
    have the entire Windows graphical API at their disposal. The author of the mIDA^([[119](#ftn.CHP-17-FN-3)])
    plug-in from Tenable Security developed an alternate approach for creating the
    MDI^([[120](#ftn.CHP-17-FN-4)]) client windows used in the mIDA plug-in. A lengthy
    thread^([[121](#ftn.CHP-17-FN-5)]) on the challenges faced by the mIDA developers
    can be found in the IDA support forums. The thread also contains example code
    that demonstrates their solution to the problem.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员都曾为创建他们插件的用户界面而挣扎。针对仅限Windows的IDA GUI版本(*idag.exe*)的插件可以利用整个Windows图形API。Tenable
    Security的mIDA^([[119](#ftn.CHP-17-FN-3)])插件的开发者开发了一种创建MDI^([[120](#ftn.CHP-17-FN-4)])客户端窗口的替代方法。在IDA支持论坛中可以找到一个关于mIDA开发者面临的挑战的长篇帖子^([[121](#ftn.CHP-17-FN-5)))。该帖子还包含示例代码，展示了他们解决问题的方法。
- en: 'The ida-x86emu^([[122](#ftn.CHP-17-FN-6)]) plug-in takes a slightly different
    approach in its user interface. This plug-in relies on the fact that a handle
    to IDA’s main window can be obtained using the following SDK code:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: ida-x86emu^([[122](#ftn.CHP-17-FN-6)])插件在用户界面方面采取了略有不同的方法。此插件依赖于可以使用以下SDK代码获取IDA主窗口句柄的事实：
- en: '[PRE80]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Using the main IDA window as a parent, ida-x86emu currently makes no attempt
    to integrate into the IDA workspace. All of the plug-in’s dialog interfaces are
    generated using a Windows resource editor, and all user interactions are handled
    using direct calls to Windows API functions. The use of a graphical dialog editor
    in conjunction with direct calls to native Windows API functions provides the
    most powerful user interface–generation capability at the expense of added complexity
    and the additional knowledge required to process Windows messages and work with
    lower-level interface functions.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 以 IDA 主窗口作为父窗口，ida-x86emu 目前不尝试集成到 IDA 工作区中。所有插件的对话框界面都是使用 Windows 资源编辑器生成的，所有用户交互都是通过直接调用
    Windows API 函数来处理的。结合图形对话框编辑器和直接调用原生 Windows API 函数提供了最强大的用户界面生成能力，但代价是增加了复杂性，并且需要额外的知识来处理
    Windows 消息和与低级界面函数协同工作。
- en: User Interface Generation with Qt
  id: totrans-915
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Qt 生成用户界面
- en: The Qt user interface introduced in IDA 6.0 offers plug-in developers the chance
    to create plug-ins with complex user interfaces capable of being used on all IDA
    platforms. Hex-Rays’ Daniel Pistelli^([[123](#ftn.CHP-17-FN-7)]) discusses some
    of the requirements for using Qt in your plug-ins in a blog post on the Hex-Rays
    blog. See ^([[124](#ftn.CHP-17-FN-8)]) In this section we will reiterate some
    of the important points that Daniel makes as well as point out some additional
    useful information.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 6.0 中引入的 Qt 用户界面为插件开发者提供了创建具有复杂用户界面、可在所有 IDA 平台上使用的插件的机会。Hex-Rays 的 Daniel
    Pistelli^([[123](#ftn.CHP-17-FN-7)]) 在 Hex-Rays 博客上的一篇博客文章中讨论了在插件中使用 Qt 的一些要求。见
    ^([[124](#ftn.CHP-17-FN-8)]) 在本节中，我们将重申 Daniel 提出的某些重要观点，并指出一些额外的有用信息。
- en: 'If you wish to make use of any Qt functionality in your plug-ins, you must
    begin by properly configuring a Qt development environment. IDA 6.1 ships with
    its own versions of the Qt 4.7.2 libraries.^([[125](#ftn.CHP-17-FN-9)]) When Hex-Rays
    builds its Qt libraries, it wraps the libraries in a C++ namespace named `QT`.
    To configure your development environment, obtain the appropriate Qt sources from
    Nokia. The Windows version of *idaq* is built with Visual Studio 2008,^([[126](#ftn.CHP-17-FN-10)])
    and the Linux and OS X versions use g++. The appropriate sources for Windows may
    be found here:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在插件中使用任何 Qt 功能，你必须首先正确配置一个 Qt 开发环境。IDA 6.1 随带其自己的 Qt 4.7.2 库版本.^([[125](#ftn.CHP-17-FN-9)])
    当 Hex-Rays 构建其 Qt 库时，它会将库包裹在一个名为 `QT` 的 C++ 命名空间中。为了配置你的开发环境，从诺基亚获取适当的 Qt 源代码。Windows
    版本的 *idaq* 使用 Visual Studio 2008 构建，^([[126](#ftn.CHP-17-FN-10)]) 而Linux 和 OS
    X 版本使用 g++。Windows 适当的源代码可以在这里找到：
- en: '[PRE81]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Sources for Linux and OS X can be found here:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 OS X 的源代码可以在这里找到：
- en: '[PRE82]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'See Daniel’s blog post for specific commands to configure your sources. The
    key to proper configuration is the following command-line parameter:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Daniel 的博客文章，了解配置源代码的具体命令。正确配置的关键是以下命令行参数：
- en: '[PRE83]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This parameter causes the Qt sources to be wrapped in the `QT` name-space. In
    order to build any Qt-related plug-ins on Windows, you will need link libraries
    (*.lib* files) for each Qt library that you utilize in your plug-in. While IDA
    ships with a number of dynamic link libraries for Qt (see *<IDADIR>* for a complete
    list), the SDK ships with a very limited number of Qt link libraries for Windows
    (notably QtCore4 and QtGui), which may be found in *<SDKDIR>/lib/x86_win_qt*.
    If you need additional link libraries, you will need to link against the libraries
    that you build yourself from the Qt sources. On Linux and OS X, you can link directly
    with the Qt libraries that ship with IDA. On Linux, these can be found in *<IDADIR>*;
    on OS X these can be found in *<IDADIR>/idaq.app/Contents/Frameworks*. Note that
    linking against Qt libraries that don’t ship with IDA will make your plug-in somewhat
    less portable, unless you also distribute those libraries along with your plug-in.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数会导致 Qt 源代码被包裹在 `QT` 命名空间中。为了在 Windows 上构建任何与 Qt 相关的插件，你需要为你在插件中使用的每个 Qt 库链接库
    (*.lib 文件)。虽然 IDA 随带了一些 Qt 的动态链接库（见 *<IDADIR>* 以获取完整列表），但 SDK 随带了一些非常有限的 Windows
    Qt 链接库（特别是 QtCore4 和 QtGui），这些库可以在 *<SDKDIR>/lib/x86_win_qt* 中找到。如果你需要额外的链接库，你需要链接到你从
    Qt 源代码构建的库。在 Linux 和 OS X 上，你可以直接链接到随 IDA 一起提供的 Qt 库。在 Linux 上，这些库可以在 *<IDADIR>*
    中找到；在 OS X 上，这些库可以在 *<IDADIR>/idaq.app/Contents/Frameworks* 中找到。请注意，链接到不随 IDA
    一起提供的 Qt 库会使你的插件的可移植性降低，除非你还将这些库与你的插件一起分发。
- en: 'When configuring your Qt plug-in projects, make sure that your `qmake` project
    file contains the following configuration directive:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置你的 Qt 插件项目时，确保你的 `qmake` 项目文件包含以下配置指令：
- en: '[PRE84]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'IDA defines a number of functions for safer string handling within the SDK.
    These include functions such as `qstrlen` and `qsnprintf`, which have long been
    part of the SDK. With the move to a Qt-based GUI, this leads to problems because
    Qt also defines several functions named the same as those provided by IDA. The
    IDA functions reside in the global namespace, while the Qt functions reside in
    the `QT` namespace. The IDA versions of such functions can be called by explicitly
    referencing the global namespace as shown here:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 在 SDK 中定义了多个用于更安全字符串处理的函数。这些包括 `qstrlen` 和 `qsnprintf` 等函数，这些函数长期以来一直是 SDK
    的一部分。随着转向基于 Qt 的 GUI，这导致了一些问题，因为 Qt 也定义了几个与 IDA 提供的函数同名。IDA 函数位于全局命名空间中，而 Qt 函数位于
    `QT` 命名空间中。可以通过显式引用全局命名空间（如下所示）来调用此类函数的 IDA 版本：
- en: '[PRE85]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Should you need a parent widget for any widgets that you are creating in your
    plug-in, the following statement will obtain a pointer to *idaq*’s top-level application
    window:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在插件中创建任何小部件需要父级小部件，以下语句将获取`idaq`顶级应用程序窗口的指针：
- en: '[PRE86]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This invokes a static method within Qt’s `QApplication` class that returns the
    widget pointer for the sole `QApplication` object in any Qt application.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 Qt 的 `QApplication` 类中的一个静态方法，该方法返回任何 Qt 应用程序中唯一的 `QApplication` 对象的窗口指针。
- en: For more information on configuring your plug-ins to use Qt, refer to Daniel’s
    blog post. Additionally, the qwindow plug-in sample that ships with IDA’s SDK
    provides an example of a plug-in that makes use of Qt. Specifically it contains
    example code that creates an empty widget (using `create_tform`), uses callbacks
    to receive notification that the form is being made visible, obtains a QWidget
    pointer to the newly created form, and finally populates the form with a Qt button
    object. The collabREate and ida-x86emu plug-ins to be discussed in [Chapter 23](ch23.html
    "Chapter 23. Real-World IDA Plug-ins") also make use of Qt GUI elements to allow
    these plug-ins to be used on all IDA capable platforms.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置你的插件以使用 Qt 的更多信息，请参阅丹尼尔的文章。此外，IDA SDK 中的 qwindow 插件示例提供了一个使用 Qt 的插件的例子。具体来说，它包含示例代码，创建一个空的小部件（使用
    `create_tform`），使用回调来接收表单正在变得可见的通知，获取指向新创建表单的 QWidget 指针，并最终用 Qt 按钮对象填充表单。在 [第
    23 章](ch23.html "第 23 章。现实世界的 IDA 插件") 中讨论的 collabREate 和 ida-x86emu 插件也使用 Qt
    GUI 元素，以便这些插件可以在所有 IDA 兼容平台上使用。
- en: '* * *'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[118](#CHP-17-FN-2)]) A *modal dialog* must be closed before the user is
    allowed to continue interacting with the dialog’s parent application. File open
    and save dialogs are common examples of modal dialogs. Modal dialogs are typically
    used when an application requires information from a user before the application
    can continue execution. On the other hand, nonmodal or modeless dialogs allow
    the user to continue interacting with the parent application while the dialog
    remains open.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[118](#CHP-17-FN-2)]) 在用户被允许继续与对话框的父应用程序交互之前，必须关闭 *模态对话框*。文件打开和保存对话框是模态对话框的常见例子。模态对话框通常在应用程序需要在继续执行之前从用户那里获取信息时使用。另一方面，非模态或无模式对话框允许用户在对话框保持打开状态的同时继续与父应用程序交互。
- en: ^([[119](#CHP-17-FN-3)]) See [http://cgi.tenablesecurity.com/tenable/mida.php](http://cgi.tenablesecurity.com/tenable/mida.php).
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[119](#CHP-17-FN-3)]) 查看 [http://cgi.tenablesecurity.com/tenable/mida.php](http://cgi.tenablesecurity.com/tenable/mida.php)。
- en: ^([[120](#CHP-17-FN-4)]) The Windows *Multiple Document Interface (MDI)* allows
    multiple child (client) windows to be contained within a single container window.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[120](#CHP-17-FN-4)]) Windows 的 *多文档界面 (MDI)* 允许多个子（客户端）窗口包含在一个容器窗口中。
- en: ^([[121](#CHP-17-FN-5)]) See [http://www.hex-rays.com/forum/viewtopic.php?f=8&t=1660&p=6752](http://www.hex-rays.com/forum/viewtopic.php?f=8&t=1660&p=6752)
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[121](#CHP-17-FN-5)]) 查看 [http://www.hex-rays.com/forum/viewtopic.php?f=8&t=1660&p=6752](http://www.hex-rays.com/forum/viewtopic.php?f=8&t=1660&p=6752)
- en: ^([[122](#CHP-17-FN-6)]) See [http://www.idabook.com/ida-x86emu](http://www.idabook.com/ida-x86emu)
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[122](#CHP-17-FN-6)]) 查看 [http://www.idabook.com/ida-x86emu](http://www.idabook.com/ida-x86emu)
- en: ^([[123](#CHP-17-FN-7)]) Daniel led the Hex-Rays effort to migrate IDA’s GUI
    to Qt.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[123](#CHP-17-FN-7)]) 丹尼尔领导了 Hex-Rays 将 IDA 的 GUI 迁移到 Qt 的努力。
- en: ^([[124](#CHP-17-FN-8)]) [http://www.hexblog.com/?p=250](http://www.hexblog.com/?p=250)
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[124](#CHP-17-FN-8)]) [http://www.hexblog.com/?p=250](http://www.hexblog.com/?p=250)
- en: ^([[125](#CHP-17-FN-9)]) IDA 6.0 utilized Qt 4.6.3.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[125](#CHP-17-FN-9)]) IDA 6.0 使用了 Qt 4.6.3。
- en: ^([[126](#CHP-17-FN-10)]) As a consequence, if you are building a Qt-related
    plug-in on Windows, you must use Visual Studio to build your plug-in.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[126](#CHP-17-FN-10)]) 因此，如果你在Windows上构建与Qt相关的插件，你必须使用Visual Studio来构建你的插件。
- en: Scripted Plug-ins
  id: totrans-942
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本插件
- en: IDA 5.6 introduced support for scripted loader modules. In IDA 5.7, support
    was added for scripted plug-ins ^([[127](#ftn.CHP-17-FN-11)]) and processor modules.
    While this does not necessarily allow for the development of more powerful plug-ins,
    it does somewhat lower the barrier to entry for potential plug-in developers and
    allows for a somewhat faster development cycle because the complex build process
    is eliminated.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 5.6引入了对脚本加载模块的支持。在IDA 5.7中，增加了对脚本插件^([[127](#ftn.CHP-17-FN-11)])和处理器模块的支持。虽然这并不一定允许开发更强大的插件，但它确实在一定程度上降低了潜在插件开发者的入门门槛，并允许开发周期更快，因为复杂的构建过程被消除了。
- en: Although scripted plug-ins can be created using either IDC or Python, Python
    is probably the most appropriate choice given that it exposes so much of IDA’s
    SDK. Given this fact, there is no reason why Python plug-ins can’t be just as
    powerful as compiled C++ plug-ins.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用IDC或Python创建脚本插件，但鉴于Python暴露了IDA SDK的大部分内容，Python可能是最合适的选择。鉴于这一事实，没有理由认为Python插件不能像编译的C++插件一样强大。
- en: Creating a Python plug-in is a straightforward process. The primary requirement
    is to define a function named `PLUGIN_ENTRY` that returns an instance of `plugin_t`
    (defined in module `idaapi`). The `plugin_t` class contains members that mirror
    the members of the SDK’s C++ `plugin_t` class. [Example 17-4](ch17s07.html#a_minimal_python_plug-in
    "Example 17-4. A minimal Python plug-in") shows a simple Python plug-in that defines
    a class named `idabook_plugin_t`, which inherits from `plugin_t`; initializes
    all required members; and defines `init`, `term`, and `run` functions that implement
    the plug-in behavior.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Python插件是一个简单的过程。主要要求是定义一个名为`PLUGIN_ENTRY`的函数，该函数返回`plugin_t`（在模块`idaapi`中定义）的一个实例。`plugin_t`类包含成员，这些成员反映了SDK的C++
    `plugin_t`类的成员。[示例 17-4](ch17s07.html#a_minimal_python_plug-in "示例 17-4. 一个最小的Python插件")显示了一个简单的Python插件，该插件定义了一个名为`idabook_plugin_t`的类，该类继承自`plugin_t`；初始化所有必需的成员；并定义了`init`、`term`和`run`函数，这些函数实现了插件的行为。
- en: Example 17-4. A minimal Python plug-in
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-4. 一个最小的Python插件
- en: '[PRE87]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Installation of the plug-in script is accomplished by copying the script to
    *<IDADIR>/plugins*.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 插件脚本的安装是通过将脚本复制到*<IDADIR>/plugins*来完成的。
- en: The same plug-in written in IDC appears in [Example 17-5](ch17s07.html#a_minimal_idc_plug-in
    "Example 17-5. A minimal IDC plug-in"). Since IDC does not define a plug-in–related
    base class, our obligation is to create a class that defines all the elements
    expected of a plug-in, ensuring that we name each element properly.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 用IDC编写的相同插件出现在[示例 17-5](ch17s07.html#a_minimal_idc_plug-in "示例 17-5. 一个最小的IDC插件")中。由于IDC没有定义与插件相关的基类，我们的义务是创建一个定义了插件所需所有元素的类，确保我们正确命名每个元素。
- en: Example 17-5. A minimal IDC plug-in
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-5. 一个最小的IDC插件
- en: '[PRE88]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As with the Python example, the `PLUGIN_ENTRY` function serves to create and
    return an instance of our plug-in class. Installation, once again, involves copying
    the *.idc* file to *<IDADIR>/plugins*.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例一样，`PLUGIN_ENTRY`函数用于创建并返回我们的插件类的一个实例。安装过程再次涉及将*.idc*文件复制到*<IDADIR>/plugins*。
- en: '* * *'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[127](#CHP-17-FN-11)]) See [http://www.hexblog.com/?p=120](http://www.hexblog.com/?p=120)
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[127](#CHP-17-FN-11)]) 查看 [http://www.hexblog.com/?p=120](http://www.hexblog.com/?p=120)
- en: Summary
  id: totrans-955
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'IDA plug-ins are the logical next step when scripting fails to meet your needs
    for extending IDA’s capabilities, though with the advent of scripted plug-ins,
    you may find yourself resisting the urge to dive into the SDK. Additionally, unless
    you are faced with the challenge of reverse engineering a file format that is
    unknown to IDA or a machine language for which IDA has no processor module, plug-ins
    may be the only type of IDA extension that you ever feel the need to explore.
    Nonetheless, in the next two chapters, we continue to explore the capabilities
    offered by IDA’s SDK by looking at the other types of modules that can be constructed
    for use with IDA: loaders and processor modules.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本无法满足扩展IDA功能的需求时，IDA插件是逻辑上的下一步。尽管脚本插件的出现可能会让你抵制深入研究SDK的冲动。此外，除非你面临逆向工程IDA未知的文件格式或IDA没有处理器模块的机器语言的挑战，否则插件可能是你唯一需要探索的IDA扩展类型。尽管如此，在接下来的两个章节中，我们继续通过查看可用于IDA的其他类型的模块来探索IDA
    SDK提供的功能：加载器和处理器模块。
- en: Chapter 18. Binary Files and IDA Loader Modules
  id: totrans-957
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 18 章. 二进制文件和 IDA 加载模块
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-958
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: One day word will get out that you have become the resident IDA geek. You may
    relish the fact that you have hit the big time, or you may bemoan the fact that
    from that day forward, people will be interrupting you with questions about what
    some file does. Eventually, either as a result of one such question or simply
    because you enjoy using IDA to open virtually every file you can find, you may
    be confronted with the dialog shown in [Figure 18-1](ch18.html#loading_a_binary_file
    "Figure 18-1. Loading a binary file").
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 有朝一日，人们会知道你已经成为了驻场的 IDA 极客。你可能喜欢自己已经达到了顶峰，或者你可能哀叹从那天起，人们会打断你询问某个文件的功能。最终，无论是由于这样的一个问题，还是因为你喜欢使用
    IDA 打开你找到的几乎所有文件，你可能会遇到[图 18-1](ch18.html#loading_a_binary_file "图 18-1. 加载二进制文件")中显示的对话框。
- en: This is IDA’s standard file-loading dialog with a minor problem (from the user’s
    perspective). The short list of recognized file types contains only one entry,
    Binary file, indicating that none of IDA’s installed loader modules recognize
    the format of the file you want to load. Hopefully you will at least know what
    machine language you are dealing with (you do at least know where the file came
    from, right?) and can make an intelligent choice for the processor type, because
    that is about all you can do in such cases.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 IDA 的标准文件加载对话框，但存在一个小问题（从用户的角度来看）。识别的文件类型列表很短，只有一个条目，即二进制文件，这表明 IDA 的所有已安装加载模块都无法识别您要加载的文件格式。希望您至少知道您正在处理哪种机器语言（您至少知道文件是从哪里来的，对吧？）并且可以智能地选择处理器类型，因为在这种情况下您能做的也就只有这些了。
- en: '![Loading a binary file](httpatomoreillycomsourcenostarchimages854295.png.jpg)'
  id: totrans-961
  prefs: []
  type: TYPE_IMG
  zh: '![加载二进制文件](httpatomoreillycomsourcenostarchimages854295.png.jpg)'
- en: Figure 18-1. Loading a binary file
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-1. 加载二进制文件
- en: In this chapter we will discuss IDA’s capabilities for helping you make sense
    of unrecognized file types, beginning with manual analysis of binary file formats
    and then using that as motivation for the development of your own IDA loader modules.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 IDA 帮助您理解未知文件类型的能力，从手动分析二进制文件格式开始，然后以此作为开发您自己的 IDA 加载模块的动机。
- en: Unknown File Analysis
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未知文件分析
- en: An infinite number of file formats exist for storing executable code. IDA ships
    with loader modules to recognize many of the more common file formats, but there
    is no way that IDA can accommodate the ever-increasing number of formats in existence.
    Binary images may contain executable files formatted for use with specific operating
    systems, ROM images extracted from embedded systems, firmware images extracted
    from flash updates, or simply raw blocks of machine language, perhaps extracted
    from network packet captures. The format of these images may be dictated by the
    operating system (executable files), the target processor and system architecture
    (ROM images), or nothing at all (exploit shellcode embedded in application layer
    data).
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 存储可执行代码的文件格式有无限多种。IDA 随带了许多常见文件格式的加载模块以供识别，但 IDA 无法适应存在的格式数量不断增加。二进制映像可能包含为特定操作系统格式化的可执行文件、从嵌入式系统提取的
    ROM 映像、从闪存更新中提取的固件映像，或者仅仅是原始的机器语言块，这些可能是从网络数据包捕获中提取的。这些映像的格式可能由操作系统（可执行文件）、目标处理器和系统架构（ROM
    映像）或根本没有任何东西（嵌入在应用层数据中的漏洞 shellcode）决定。
- en: Assuming that a processor module is available to disassemble the code contained
    in the unknown binary, it will be your job to properly arrange the file image
    within an IDA database before informing IDA which portions of the binary represent
    code and which portions of the binary represent data. For most processor types,
    the result of loading a file using the binary format is simply a list of the contents
    of the file piled into a single segment beginning at address zero, as shown in
    [Example 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin "Example 18-1. Initial
    lines of a PE file loaded in binary mode").
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个处理器模块可以反汇编未知二进制文件中的代码，那么你的任务是在通知 IDA 哪些二进制部分代表代码，哪些部分代表数据之前，正确地安排文件映像在
    IDA 数据库中的位置。对于大多数处理器类型，使用二进制格式加载文件的结果只是将文件内容堆叠在以地址零开始的单个段中，如[示例 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin
    "示例 18-1. 以二进制模式加载的 PE 文件的前几行")所示。
- en: Example 18-1. Initial lines of a PE file loaded in binary mode
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-1. 以二进制模式加载的 PE 文件的前几行
- en: '[PRE89]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In some cases, depending on the sophistication of the selected processor module,
    some disassembly may take place. This may be the case when a selected processor
    is an embedded microcontroller that can make specific assumptions about the memory
    layout of ROM images. For those interested in such applications, Andy Whittaker
    has created an excellent walk-through^([[128](#ftn.CHP-18-FN-1)]) of reverse engineering
    a binary image for a Siemens C166 microcontroller application.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据所选处理器模块的复杂程度，可能会进行一些反汇编操作。这种情况可能发生在所选处理器是一个可以针对ROM映像的内存布局做出特定假设的嵌入式微控制器时。对于那些对这类应用感兴趣的人来说，安迪·惠特克（Andy
    Whittaker）已经创建了一个出色的教程^([[128](#ftn.CHP-18-FN-1)]），介绍了如何对西门子C166微控制器应用的反汇编二进制映像进行逆向工程。
- en: When faced with binary files, you will almost certainly need to arm yourself
    with as many resources related to the file as you can get your hands on. Such
    resources might include CPU references, operating system references, system design
    documentation, and any memory layout information obtained through debugging or
    hardware-assisted (such as via logic analyzers) analysis.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 面对二进制文件时，你几乎肯定需要装备尽可能多的与文件相关的资源。这些资源可能包括CPU参考、操作系统参考、系统设计文档，以及通过调试或硬件辅助（如通过逻辑分析仪）分析获得的任何内存布局信息。
- en: In the following section, for the sake of example we assume that IDA does not
    recognize the Windows PE file format. PE is a well-known file format that many
    readers may be familiar with. More important, documents detailing the structure
    of PE files are widely available, which makes dissecting an arbitrary PE file
    a relatively simple task.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，为了举例说明，我们假设IDA不识别Windows PE文件格式。PE是一个广为人知的文件格式，许多读者可能熟悉。更重要的是，详细说明PE文件结构的文档广泛可用，这使得分析任意PE文件相对简单。
- en: '* * *'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[128](#CHP-18-FN-1)]) See [http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx](http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx).
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[128](#CHP-18-FN-1)]) 请参阅 [http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx](http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx)。
- en: Manually Loading a Windows PE File
  id: totrans-974
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动加载Windows PE文件
- en: When you can find documentation on the format utilized by a particular file,
    your life will be significantly easier as you attempt to map the file into an
    IDA database. [Example 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin
    "Example 18-1. Initial lines of a PE file loaded in binary mode") shows the first
    few lines of a PE file loaded into IDA as a binary file. With no help from IDA,
    we turn to the PE specification,^([[129](#ftn.CHP-18-FN-2)]) which states that
    a valid PE file will begin with a valid MS-DOS header structure. A valid MS-DOS
    header structure in turn begins with the 2-byte signature `4Dh 5Ah` (`MZ`), which
    we see in the first two lines of [Example 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin
    "Example 18-1. Initial lines of a PE file loaded in binary mode").
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 当你能找到特定文件使用的格式文档时，在尝试将文件映射到IDA数据库的过程中，你的生活将会大大简化。[示例 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin
    "示例 18-1. 以二进制模式加载到IDA中的PE文件的前几行")显示了作为二进制文件加载到IDA中的PE文件的前几行。在没有IDA的帮助下，我们转向PE规范，^([[129](#ftn.CHP-18-FN-2)])它指出，一个有效的PE文件将以一个有效的MS-DOS头部结构开始。一个有效的MS-DOS头部结构反过来又以2字节的签名`4Dh
    5Ah`（`MZ`）开始，这在[示例 18-1](ch18.html#initial_lines_of_a_pe_file_loaded_in_bin "示例 18-1. 以二进制模式加载到IDA中的PE文件的前几行")的第一两行中可以看到。
- en: 'At this point an understanding of the layout of an MS-DOS header is required.
    The PE specification would tell us that the 4-byte value located at offset `0x3C`
    in the file indicates the offset to the next header we need to find—the PE header.
    Two strategies for breaking down the fields of the MS-DOS header are (1) to define
    appropriately sized data values for each field in the MS-DOS header or (2) to
    use IDA’s structure-creation facilities to define and apply an `IMAGE_DOS_HEADER`
    structure in accordance with the PE file specification.^([[130](#ftn.CHP-18-FN-3)])
    Using the latter approach would yield the following modified display:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，需要理解MS-DOS头部的布局。PE规范会告诉我们，文件中偏移量为`0x3C`的4字节值指示了下一个我们需要找到的头部的偏移量——PE头部。分解MS-DOS头部字段有两种策略：（1）为MS-DOS头部中的每个字段定义适当大小的数据值；（2）使用IDA的结构创建功能，根据PE文件规范定义并应用一个`IMAGE_DOS_HEADER`结构.^([[130](#ftn.CHP-18-FN-3)])采用后一种方法会产生以下修改后的显示：
- en: '[PRE90]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `e_lfanew` field ![](httpatomoreillycomsourcenostarchimages854061.png)
    has a value of `80h`, indicating that a PE header should be found at offset `80h`
    (128 bytes) into the database. Examining the bytes at offset `80h` should reveal
    the magic number for a PE header, `50h 45h` (`PE`), and allow us to build (based
    on our reading of the PE specification) and apply an `IMAGE_NT_HEADERS` structure
    at offset `80h` into the database. A portion of the resulting IDA listing might
    look like the following:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '`e_lfanew` 字段 ![](httpatomoreillycomsourcenostarchimages854061.png) 的值为 `80h`，表示在数据库中偏移
    `80h`（128 字节）处应该找到 PE 头。检查偏移 `80h` 处的字节应该会揭示 PE 头的魔数 `50h 45h` (`PE`)，并允许我们在数据库的偏移
    `80h` 处构建（基于我们对 PE 规范的阅读）并应用 `IMAGE_NT_HEADERS` 结构。IDAS 列表的一部分可能看起来如下所示：'
- en: '[PRE91]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The preceding listings and discussion bear many similarities to the exploration
    of MS-DOS and PE header structures conducted in [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures"). In this case, however, the file has been loaded into IDA
    without the benefit of the PE loader, and rather than being a curiosity as they
    were in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures"), the
    header structures are essential to a successful understanding of the remainder
    of the database.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表和讨论与第 8 章中进行的 MS-DOS 和 PE 头结构探索有许多相似之处。[第 8 章](ch08.html "第 8 章。数据类型和数据结构")。然而，在这种情况下，文件是在没有
    PE 加载器的好处下被加载到 IDA 中的，而且与第 8 章中的情况不同，头结构对于成功理解数据库的其余部分是至关重要的。
- en: At this point, we have revealed a number of interesting pieces of information
    that will help us to further refine our database layout. First, the `Machine`
    ![](httpatomoreillycomsourcenostarchimages854063.png) field in a PE header indicates
    the target CPU type for which the file was built. In this example the value `14Ch`
    indicates that the file is for use with x86 processor types. Had the machine type
    been something else, such as `1C0h` (ARM), we would actually need to close the
    database and restart our analysis, making certain that we select the correct processor
    type in the initial loading dialog. Once a database has been loaded, it is not
    possible to change the processor type in use with that database.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经揭示了一些有趣的信息，这将帮助我们进一步细化数据库布局。首先，PE 头中的 `Machine` 字段 ![](httpatomoreillycomsourcenostarchimages854063.png)
    指示了为哪个目标 CPU 类型构建的文件。在这个例子中，值 `14Ch` 指示该文件适用于 x86 处理器类型。如果机器类型是其他类型，例如 `1C0h`（ARM），我们实际上需要关闭数据库并重新启动分析，确保我们在初始加载对话框中选择了正确的处理器类型。一旦加载了数据库，就无法更改该数据库使用的处理器类型。
- en: The `ImageBase` ![](httpatomoreillycomsourcenostarchimages854093.png) field
    indicates the base virtual address for the loaded file image. Using this information,
    we can finally begin to incorporate some virtual address information into the
    database. Using the Edit ▸ Segments ▸ Rebase Program menu option, we can specify
    a new base address for the first segment of the program, as shown in [Figure 18-2](ch18s02.html#specifying_a_new_base_address_for_a_prog
    "Figure 18-2. Specifying a new base address for a program").
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageBase` 字段 ![](httpatomoreillycomsourcenostarchimages854093.png) 指示加载的文件映像的基虚拟地址。使用这些信息，我们最终可以开始将一些虚拟地址信息纳入数据库。使用“编辑”▸“段”▸“重定位程序”菜单选项，我们可以为程序的第一段指定一个新的基址，如图
    18-2 所示。'
- en: '![Specifying a new base address for a program](httpatomoreillycomsourcenostarchimages854298.png.jpg)'
  id: totrans-983
  prefs: []
  type: TYPE_IMG
  zh: '![为程序指定新的基址](httpatomoreillycomsourcenostarchimages854298.png.jpg)'
- en: Figure 18-2. Specifying a new base address for a program
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-2. 为程序指定新的基址
- en: In the current example, only one segment exists, because IDA creates only one
    segment to hold the entire file when a file is loaded in binary mode. The two
    checkbox options shown in the dialog determine how IDA handles relocation entries
    when segments are moved and whether IDA should move every segment present in the
    database, respectively. For a file loaded in binary mode, IDA will not be aware
    of any relocation information. Similarly, with only one segment present in the
    program, the entire image will be rebased by default.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中，只有一个段存在，因为当以二进制模式加载文件时，IDA 只创建一个段来保存整个文件。对话框中显示的两个复选框选项确定 IDA 在段移动时如何处理重定位条目，以及
    IDA 是否应该移动数据库中出现的每个段。对于以二进制模式加载的文件，IDA 不会意识到任何重定位信息。同样，由于程序中只有一个段，整个映像将默认重定位。
- en: The `AddressOfEntryPoint` ![](httpatomoreillycomsourcenostarchimages854095.png)
    field specifies the relative virtual address (RVA) of the program entry point.
    An RVA is a relative offset from the program’s base virtual address, while the
    program entry point represents the address of the first instruction within the
    program that will be executed. In this case an entry point RVA of `1000h` indicates
    that the program will begin execution at virtual address `401000h` (`400000h +
    1000h`). This is an important piece of information, because it is our first indication
    of where we should begin looking for code within the database. Before we can do
    that, however, we need to properly map the remainder of the database to appropriate
    virtual addresses.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddressOfEntryPoint` ![AddressOfEntryPoint](http://atomoreilly.com/source/nostarch/images/854095.png)
    字段指定程序入口点的相对虚拟地址（RVA）。RVA是从程序的基本虚拟地址的相对偏移量，而程序入口点代表程序中将要执行的第一条指令的地址。在这种情况下，入口点RVA为
    `1000h` 指示程序将在虚拟地址 `401000h` (`400000h + 1000h`) 开始执行。这是一条重要信息，因为这是我们第一次得知在数据库中寻找代码应该从哪里开始。然而，在我们能够做到这一点之前，我们需要正确地将数据库的其余部分映射到适当的虚拟地址。'
- en: The PE format makes use of sections to describe the mapping of file content
    to memory ranges. By parsing the section headers for each section in the file,
    we can complete the basic virtual memory layout of the database. The `NumberOfSections`
    ![](httpatomoreillycomsourcenostarchimages854099.png) field indicates the number
    of sections contained in a PE file; in this case there are four. Referring once
    again to the PE specification, we would learn that an array of section header
    structures immediately follows the `IMAGE_NT_HEADERS` structure. Individual elements
    in the array are `IMAGE_SECTION_HEADER` structures, which we could define in IDA’s
    Structures window and apply (four times in this case) to the bytes following the
    `IMAGE_NT_HEADERS` structure.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: PE格式使用段来描述文件内容到内存范围的映射。通过解析文件中每个段的段头，我们可以完成数据库的基本虚拟内存布局。`NumberOfSections` ![NumberOfSections](http://atomoreilly.com/source/nostarch/images/854099.png)
    字段指示PE文件中包含的段数；在这种情况下有四个。再次参考PE规范，我们会了解到一个段头结构数组紧随 `IMAGE_NT_HEADERS` 结构之后。数组中的单个元素是
    `IMAGE_SECTION_HEADER` 结构，我们可以在IDA的结构窗口中定义它，并将其（在这种情况下四次）应用于 `IMAGE_NT_HEADERS`
    结构之后的字节。
- en: Before we discuss segment creation, two additional fields worth pointing out
    are `FileAlignment` ![](httpatomoreillycomsourcenostarchimages854101.png) and
    `SectionAlignment` ![](httpatomoreillycomsourcenostarchimages854103.png). These
    fields indicate how the data for each section is aligned^([[131](#ftn.CHP-18-FN-4)])
    within the file and how that same data will be aligned when mapped into memory,
    respectively. In our example, each section is aligned to a `200h` byte offset
    within the file; however, when loaded into memory, those same sections will be
    aligned on addresses that are multiples of `1000h`. The smaller `FileAlignment`
    value offers a means of saving space when an executable image is stored in a file,
    while the larger `SectionAlignment` value typically corresponds to the operating
    system’s virtual memory page size. Understanding how sections are aligned can
    help us avoid errors when we manually create sections within our database.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论段创建之前，有两个额外的字段值得指出，即 `FileAlignment` ![FileAlignment](http://atomoreilly.com/source/nostarch/images/854101.png)
    和 `SectionAlignment` ![SectionAlignment](http://atomoreilly.com/source/nostarch/images/854103.png)。这些字段分别指示每个段的文件内数据如何对齐以及当映射到内存中时相同数据将如何对齐。在我们的例子中，每个段在文件中都对齐到
    `200h` 字节偏移量；然而，当加载到内存中时，这些相同的段将在地址上是 `1000h` 的倍数处对齐。较小的 `FileAlignment` 值在将可执行映像存储在文件中时提供了一种节省空间的方法，而较大的
    `SectionAlignment` 值通常对应于操作系统的虚拟内存页面大小。了解段如何对齐可以帮助我们在数据库中手动创建段时避免错误。
- en: 'After structuring each of the section headers, we finally have enough information
    to begin creating additional segments within the database. Applying an `IMAGE_SECTION_HEADER`
    template to the bytes immediately following the `IMAGE_NT_HEADERS` structure yields
    the first section header and results in the following data displayed in our example
    database:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构化每个段头之后，我们最终拥有了足够的信息来开始在数据库中创建额外的段。将 `IMAGE_SECTION_HEADER` 模板应用于紧随 `IMAGE_NT_HEADERS`
    结构之后的字节，得到第一个段头，并在我们的示例数据库中显示以下数据：
- en: '[PRE92]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `Name` ![](httpatomoreillycomsourcenostarchimages854061.png) field informs
    us that this header describes the `.text` section. All of the remaining fields
    are potentially useful in formatting the database, but we will focus on the three
    that describe the layout of the section. The `PointerToRawData` ![](httpatomoreillycomsourcenostarchimages854063.png)
    field (`400h`) indicates the file offset at which the content of the section can
    be found. Note that this value is a multiple of the file alignment value, `200h`.
    Sections within a PE file are arranged in increasing file offset (and virtual
    address) order. Since this section begins at file offset `400h`, we can conclude
    that the first `400h` bytes of the file contain file header data. Therefore, even
    though they do not, strictly speaking, constitute a section, we can highlight
    the fact that they are logically related by grouping them into a section in the
    database.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name` ![](httpatomoreillycomsourcenostarchimages854061.png) 字段告诉我们这个头文件描述的是
    `.text` 段。所有剩余的字段在格式化数据库时可能都很有用，但我们将重点关注描述段布局的三个字段。`PointerToRawData` ![](httpatomoreillycomsourcenostarchimages854063.png)
    字段（`400h`）指示可以在文件偏移量 `400h` 处找到该段的内容。请注意，此值是文件对齐值 `200h` 的倍数。PE文件中的段按递增的文件偏移量（和虚拟地址）顺序排列。由于此段从文件偏移量
    `400h` 开始，我们可以得出结论，文件的前 `400h` 字节包含文件头数据。因此，即使它们严格来说不构成一个段，我们也可以通过将它们分组到数据库中的段来强调它们在逻辑上的相关性。'
- en: The Edit ▸ Segments ▸ Create Segment command is used to manually create segments
    in a database. [Figure 18-3](ch18s02.html#the_segment-creation_dialog "Figure 18-3. The
    segment-creation dialog") shows the segment-creation dialog.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Edit ▸ Segments ▸ Create Segment 命令可以在数据库中手动创建段。[图18-3](ch18s02.html#the_segment-creation_dialog
    "图18-3. 段创建对话框")显示了段创建对话框。
- en: '![The segment-creation dialog](httpatomoreillycomsourcenostarchimages854301.png.jpg)'
  id: totrans-993
  prefs: []
  type: TYPE_IMG
  zh: '![段创建对话框](httpatomoreillycomsourcenostarchimages854301.png.jpg)'
- en: Figure 18-3. The segment-creation dialog
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-3. 段创建对话框
- en: When creating a segment, you may specify any name you wish. Here we choose .`headers`,
    because it is unlikely to be used as an actual section name in the file and it
    adequately describes the section’s content. You may manually enter the section’s
    start (inclusive) and end (exclusive) addresses, or they will be filled in automatically
    if you have highlighted the range of addresses that make up the section prior
    to opening the dialog. The section base value is described in the SDK’s *segment.hpp*
    file. In a nutshell, for x86 binaries, IDA computes the virtual address of a byte
    by shifting the segment base left four bits and adding the offset to the byte
    (`virtual = (base << 4) + offset`). A base value of zero should be used when segmentation
    is not used. The segment class can be used to describe the content of the segment.
    Several predefined class names such as `CODE`, `DATA`, and `BSS` are recognized.
    Predefined segment classes are also described in *segment.hpp*.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个段时，你可以指定任何你希望的名字。在这里，我们选择 `.headers`，因为它不太可能被用作文件的实际段名，并且它充分描述了该段的内容。你可以手动输入段的起始（包含）和结束（不包含）地址，或者如果你在打开对话框之前已经突出显示了组成段的地址范围，它们将被自动填充。段的基值在SDK的
    *segment.hpp* 文件中描述。简而言之，对于x86二进制文件，IDA通过将段基左移四位并将偏移量加到字节上来计算字节的虚拟地址（`virtual
    = (base << 4) + offset`）。当不使用分段时，应使用零作为基值。段类可以用来描述段的内容。一些预定义的类名，如`CODE`、`DATA`和`BSS`被识别。预定义的段类也在
    *segment.hpp* 文件中描述。
- en: An unfortunate side effect of creating a new segment is that any data that had
    been defined within the bounds of the segment (such as the headers that we previously
    formatted) will be undefined. After reapplying all of the header structures discussed
    previously, we return to the header for the `.text` section to note that the `VirtualAddress`
    ![](httpatomoreillycomsourcenostarchimages854093.png) field (`1000h`) is an RVA
    that specifies the memory address at which the section content should be loaded
    and the `SizeOfRawData` ![](httpatomoreillycomsourcenostarchimages854095.png)
    field (`600h`) indicates how many bytes of data are present in the file. In other
    words, this particular section header tells us that the `.text` section is created
    by mapping the `600h` bytes from file offsets `400h-9FFh` to virtual addresses
    `401000h-4015FFh`.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新段的一个不幸副作用是，任何在段内定义的数据（例如我们之前格式化的标题）都将变为未定义。在重新应用之前讨论的所有标题结构之后，我们回到`.text`部分的标题，注意到`VirtualAddress`
    ![](httpatomoreillycomsourcenostarchimages854093.png)字段（`1000h`）是一个RVA，它指定了应将部分内容加载到的内存地址，而`SizeOfRawData`
    ![](httpatomoreillycomsourcenostarchimages854095.png)字段（`600h`）表示文件中包含多少字节的数据。换句话说，这个特定的部分标题告诉我们`.text`部分是通过将文件偏移量`400h-9FFh`中的`600h`字节映射到虚拟地址`401000h-4015FFh`来创建的。
- en: 'Because our example file was loaded in binary mode, all of the bytes of the
    `.text` section are present in the database; we simply need to shift them into
    their proper locations. Following creation of the `.headers` section, we might
    have a display similar to the following at the end of the `.headers` section:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的示例文件是以二进制模式加载的，所以`.text`部分的全部字节都存在于数据库中；我们只需将它们移到正确的位置。在创建`.headers`部分之后，我们可能在`.headers`部分的末尾看到类似以下的内容：
- en: '[PRE93]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When the `.headers` section was created, IDA split the original `seg000` to
    form the `.headers` section as we specified and a new `seg001` to hold the remaining
    bytes from `seg000`. The content for the `.text` section is resident in the database
    as the first `600h` bytes of `seg001`. We simply need to move the section to the
    proper location and size the `.text` section correctly.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`.headers`部分时，IDA将原始`seg000`分割成我们指定的`.headers`部分和一个新的`seg001`来存储`seg000`中剩余的字节。`.text`部分的内容作为`seg001`的前`600h`字节存储在数据库中。我们只需将部分移动到正确的位置并正确设置`.text`部分的大小。
- en: The first step in creating the `.text` section involves moving `seg001` to virtual
    address `401000h`. Using the Edit ▸ Segments ▸ Move Current Segment command, we
    specify a new start address for `seg001`, as shown in [Figure 18-4](ch18s02.html#moving_a_segment
    "Figure 18-4. Moving a segment").
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`.text`部分的第一个步骤是将`seg001`移动到虚拟地址`401000h`。使用Edit ▸ Segments ▸ Move Current
    Segment命令，我们指定`seg001`的新起始地址，如图[图18-4](ch18s02.html#moving_a_segment "图18-4. 移动一个段")所示。
- en: '![Moving a segment](httpatomoreillycomsourcenostarchimages854304.png.jpg)'
  id: totrans-1001
  prefs: []
  type: TYPE_IMG
  zh: '![移动一个段](httpatomoreillycomsourcenostarchimages854304.png.jpg)'
- en: Figure 18-4. Moving a segment
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-4. 移动一个段
- en: The next step is to carve the `.text` section from the first `600h` bytes of
    the newly moved `seg001` using Edit ▸ Segments ▸ Create Segment. [Figure 18-5](ch18s02.html#manual_creation_of_the_.text_section
    "Figure 18-5. Manual creation of the .text section") shows the parameters, derived
    from the section header values, used to create the new section.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从新移动的`seg001`的第一个`600h`字节中切割出`.text`部分，使用Edit ▸ Segments ▸ Create Segment。![图18-5](ch18s02.html#manual_creation_of_the_.text_section
    "图18-5. 手动创建.text部分")显示了用于创建新部分的参数，这些参数是从部分标题值中派生出来的。
- en: Keep in mind that the end address is exclusive. Creation of the `.text` section
    splits `seg001` into the new `.text` section and all remaining bytes of the original
    file into a new section named `seg002`, which immediately follows the `.text`
    section.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，结束地址是排他的。`.text`部分的创建将`seg001`分割成新的`.text`部分和原始文件中剩余的所有字节，这些字节将组成一个新的名为`seg002`的部分，它紧随`.text`部分之后。
- en: '![Manual creation of the .text section](httpatomoreillycomsourcenostarchimages854307.png.jpg)'
  id: totrans-1005
  prefs: []
  type: TYPE_IMG
  zh: '![手动创建.text部分](httpatomoreillycomsourcenostarchimages854307.png.jpg)'
- en: Figure 18-5. Manual creation of the `.text` section
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-5. 手动创建.text部分
- en: 'Returning to the section headers, we now look at the second section, which
    appears as follows once it has been structured as an `IMAGE_SECTION_HEADER`:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到部分标题，我们现在来看第二个部分，一旦它被结构化为`IMAGE_SECTION_HEADER`，它将如下所示：
- en: '[PRE94]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Using the same data fields we examined for the `.text` section, we note that
    this section is named `.rdata`, occupies `200h` bytes in the file beginning at
    file offset `0A00h`, and maps to RVA `2000h` (virtual address `402000h`). It is
    important to note at this point that since we moved the `.text` segment, we can
    no longer easily map the `PointerToRawData` field to an offset within the database.
    Instead, we rely on the fact that the content for the `.rdata` section immediately
    follows the content for the `.text` section. In other words, the `.rdata` section
    currently resides in the first `200h` bytes of `seg002`. An alternative approach
    would be to create the sections in reverse order, beginning with the last section
    defined in the headers and working our way backwards until we finally create the
    `.text` section. This approach leaves sections positioned at their proper file
    offsets until they are moved to their corresponding virtual addresses.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前检查`.text`章节时使用的相同数据字段，我们注意到这个章节被命名为`.rdata`，在文件中从偏移量`0A00h`开始占用`200h`字节，并映射到RVA
    `2000h`（虚拟地址`402000h`）。在此点需要注意的是，由于我们移动了`.text`段，我们不能再轻易地将`PointerToRawData`字段映射到数据库中的偏移量。相反，我们依赖于`.rdata`章节的内容紧接在`.text`章节内容之后的事实。换句话说，`.rdata`章节目前位于`seg002`的第一个`200h`字节中。另一种方法是将章节按相反的顺序创建，从标题中定义的最后一个章节开始，逐步向后工作，直到我们最终创建`.text`章节。这种方法使得章节在移动到相应的虚拟地址之前位于它们正确的文件偏移量处。
- en: The creation of the `.rdata` section proceeds in a manner similar to the creation
    of the `.text` section. In the first step, `seg002` is moved to `402000h`, and
    in the second step, the actual `.rdata` section is created to span the address
    range `402000h-402200h`.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '`.rdata`章节的创建方式与`.text`章节的创建方式类似。第一步，将`seg002`移动到`402000h`，第二步，创建实际的`.rdata`章节以跨越地址范围`402000h-402200h`。'
- en: 'The next section defined in this particular binary is called the `.bss` section.
    A `.bss` section is typically generated by compilers as a place to group all statically
    allocated variables (such as globals) that need to be initialized to zero when
    the program starts. Static variables with nonzero initial values are typically
    allocated in a `.data` (nonconstant) or `.rdata` (constant) section. The advantage
    of a `.bss` section is that it typically requires zero space in the disk image,
    with space being allocated for the section when the memory image of the executable
    is created by the operating system loader. In this example, the `.bss` section
    is specified as follows:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的二进制文件中定义的下一个章节被称为`.bss`章节。`.bss`章节通常由编译器生成，作为一个位置来分组所有在程序开始时需要初始化为零的静态分配变量（例如全局变量）。具有非零初始值的静态变量通常分配在`.data`（非常量）或`.rdata`（常量）章节中。`.bss`章节的优势在于它通常在磁盘映像中不需要空间，当操作系统加载器创建可执行文件的内存映像时，为该章节分配空间。在这个例子中，`.bss`章节的指定如下：
- en: '[PRE95]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Here the section header indicates that the size of the section within the file,
    `SizeOfRawData` ![](httpatomoreillycomsourcenostarchimages854061.png), is zero,
    while the `VirtualSize` ![](httpatomoreillycomsourcenostarchimages854063.png)
    of the section is `0x40` (`64`) bytes. In order to create this section in IDA,
    it is first necessary to create a gap (because we have no file content to populate
    the section) in the address space beginning at address `0x403000` and then define
    the `.bss` section to consume this gap. The easiest way to create this gap is
    to move the remaining sections of the binary into their proper places. When this
    task is complete, we might end up with a Segments window listing similar to the
    following:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，章节标题表明文件内章节的大小，`SizeOfRawData` ![图片链接](http://atomoreilly.com/source/nostarch/images/854061.png)，为零，而该章节的`VirtualSize`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/854063.png)为`0x40`（64）字节。为了在IDA中创建此章节，首先需要在地址空间中从地址`0x403000`开始创建一个间隙（因为我们没有文件内容来填充章节），然后定义`.bss`章节以消耗这个间隙。创建这个间隙的最简单方法是将二进制文件的剩余部分移动到它们适当的位置。当这项任务完成时，我们可能会得到一个类似以下内容的段窗口列表：
- en: '[PRE96]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The right-hand portion of the listing has been truncated for the sake of brevity.
    You may notice that the segment end addresses are not adjacent to their subsequent
    segment start addresses. This is a result of creating the segments using their
    file sizes rather than taking into account their virtual sizes and any required
    section alignment. In order to have our segments reflect the true layout of the
    executable image, we could edit each end address to consume any gaps between segments.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，列表的右侧已被截断。你可能注意到段结束地址与其后续段的起始地址不相邻。这是由于使用文件大小而不是考虑它们的虚拟大小和任何所需的段对齐来创建段的结果。为了使我们的段反映可执行图像的真实布局，我们可以编辑每个结束地址以消耗段之间的任何间隙。
- en: 'The question marks in the segments list represent unknown values for the permission
    bits on each section. For PE files, these values are specified via bits in the
    `Characteristics` field of each section header. There is no way to specify permissions
    for manually created sections other than by programmatically using a script or
    a plug-in. The following IDC statement sets the execute permission on the `.text`
    section in the previous listing:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 段列表中的问号代表每个部分的权限位上的未知值。对于PE文件，这些值是通过每个部分头文件中的“特征”字段中的位来指定的。除了通过编程使用脚本或插件外，没有其他方法可以指定手动创建部分的权限。以下IDC语句设置了上一个列表中`.text`部分的执行权限：
- en: '[PRE97]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Unfortunately, IDC does not define symbolic constants for each of the allowable
    permissions. Unix users may find it easy to remember that the section permission
    bits happen to correspond to the permission bits used in Unix file systems; thus
    read is 4, write is 2, and execute is 1\. You may combine the values using a bitwise
    `OR` to set more than one permission in a single operation.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，IDC并没有为每个允许的权限定义符号常量。Unix用户可能会发现记住各个部分的权限位与Unix文件系统中使用的权限位相对应是很容易的；因此，读取是4，写入是2，执行是1。你可以使用位运算符`OR`组合这些值，在单个操作中设置多个权限。
- en: 'The last step that we will cover in the manual loading process is to finally
    get the x86 processor module to do some work for us. Once the binary has been
    properly mapped into various IDA sections, we can return to the program entry
    point that we found in the headers (RVA `1000h`, or virtual address `401000h`)
    and ask IDA to convert the bytes at that location to code. If we wish to have
    IDA list the address as an entry point in the Exports window, we must programmatically
    designate it as such. Here is a Python one-liner to do this:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在手册加载过程中讨论的最后一步是最终让x86处理器模块为我们做一些工作。一旦二进制文件已经被正确地映射到各种IDA部分，我们就可以回到我们在头文件中找到的程序入口点（RVA
    `1000h`，或虚拟地址`401000h`），并要求IDA将该位置的字节转换为代码。如果我们希望IDA在“导出”窗口中将该地址列为入口点，我们必须通过编程将其指定为入口点。以下是一个用于此目的的Python单行代码：
- en: '[PRE98]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Called in this manner, IDA will name the entry point `'start'`, add it as an
    exported symbol, and create code at the specified address, initiating a recursive
    descent to disassemble as much related code as possible. Please refer to IDA’s
    built-in help for more information on the `AddEntryPoint` function.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式调用，IDA将入口点命名为`'start'`，将其添加为导出符号，并在指定的地址创建代码，从而启动递归下降以反汇编尽可能多的相关代码。请参阅IDA的内置帮助以获取有关`AddEntryPoint`函数的更多信息。
- en: When a file is loaded in binary mode, IDA performs no automatic analysis of
    the file content. Among other things, no attempt is made to identify the compiler
    used to create the binary, no attempt is made to determine what libraries and
    functions the binary imports, and no type library or signature information is
    automatically loaded into the database. In all likelihood, we will need to do
    a substantial amount of work to produce a disassembly comparable to those we have
    seen IDA generate automatically. In fact, we have not even touched on other aspects
    of the PE headers and how we might incorporate such additional information into
    our manual loading process.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 当以二进制模式加载文件时，IDA不会对文件内容进行任何自动分析。在其他方面，没有尝试识别用于创建二进制的编译器，没有尝试确定二进制文件导入的库和函数，也没有自动将类型库或签名信息加载到数据库中。我们很可能需要做大量工作才能生成与IDA自动生成的反汇编代码相当的结果。实际上，我们甚至还没有触及PE头部的其他方面以及我们如何将此类附加信息纳入我们的手动加载过程。
- en: In rounding out our discussion of manual loading, consider that you would need
    to repeat each of the steps covered in this section every time you open a binary
    with the same format, one unknown to IDA. Along the way, you might choose to automate
    some of your actions by writing IDC scripts that perform some of the header parsing
    and segment creation for you. This is exactly the motivation behind and the purpose
    for IDA loader modules, which are covered in the next section.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对手动加载的讨论时，请考虑每次打开具有相同格式、IDA未知格式的二进制文件时，您都需要重复本节中涵盖的每个步骤。在这个过程中，您可能会选择通过编写执行一些标题解析和段创建的IDC脚本来自动化一些操作。这正是IDA加载模块背后的动机和目的，这些内容将在下一节中介绍。
- en: '* * *'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[129](#CHP-18-FN-2)]) See [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)
    (EULA acceptance required).
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[129](#CHP-18-FN-2)]) 请参阅[http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)（需要接受EULA）。
- en: ^([[130](#CHP-18-FN-3)]) Refer to [Using Standard Structures](ch08s05.html "Using
    Standard Structures") in [Using Standard Structures](ch08s05.html "Using Standard
    Structures") for a discussion on adding these structure types in IDA.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[130](#CHP-18-FN-3)]) 请参阅[使用标准结构](ch08s05.html "使用标准结构")中的[使用标准结构](ch08s05.html
    "使用标准结构")，以讨论在IDA中添加这些结构类型。
- en: ^([[131](#CHP-18-FN-4)]) Alignment describes the starting address or offset
    of a block of data. The address or offset must be an even multiple of the alignment
    value. For example, when data is aligned to a `200h-` (`512-`) byte boundary,
    it must begin at an address (or offset) that is evenly divisible by `200h`.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[131](#CHP-18-FN-4)]) 对齐描述了数据块的开始地址或偏移量。地址或偏移量必须是对齐值的偶数倍。例如，当数据对齐到`200h-`（`512-`）字节边界时，它必须从可以整除`200h`的地址（或偏移量）开始。
- en: IDA Loader Modules
  id: totrans-1028
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA加载模块
- en: IDA relies on loader modules to perform the grunt work of creating the initial
    layout of new databases. Loaders are utilized when a user chooses to open a new
    file, and the loader’s job is to read the input file into the newly created database,
    create sections according to the structure of the input file, and generally organize
    the layout of the database prior to passing control to the processor module, whose
    job it is to perform any disassembly-related tasks. Once a database has been created,
    IDA may invoke special functions in the original loader in order to handle the
    movement of database segments and in order to produce an EXE file (File ▸ Produce
    File ▸ Create EXE File).
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: IDA依赖于加载模块来执行创建新数据库初始布局的繁重工作。当用户选择打开新文件时，会使用加载模块，其任务是读取输入文件到新创建的数据库中，根据输入文件的结构创建部分，并在将控制权传递给处理器模块之前，通常组织数据库的布局。处理器模块的任务是执行任何与反汇编相关的任务。一旦创建了一个数据库，IDA可能会调用原始加载模块中的特殊函数，以处理数据库段移动并生成EXE文件（文件
    ▸ 生成文件 ▸ 创建EXE文件）。
- en: The loading process begins when a user chooses to open a new file (loaders are
    not used to load existing databases). Like plug-ins, loaders may be built as shared
    library components using the IDA SDK. Loaders were the first of IDA’s extension
    modules capable of being implemented using scripts (introduced in IDA 5.6).
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 加载过程开始于用户选择打开新文件时（加载模块不用于加载现有数据库）。像插件一样，加载模块可以使用IDA SDK构建为共享库组件。加载模块是IDA的第一个可以使用脚本实现的扩展模块（在IDA
    5.6中引入）。
- en: Once a new binary has been selected, IDA loads, in a dynamic library sense,
    each loader module in the *<IDADIR>/loaders* directory and asks each module to
    examine the binary. All loaders that recognize the format of the new file are
    listed in the file-loading dialog, and it is up to the user to decide which loader
    should be used to load the file.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新二进制文件后，IDA以动态库的形式加载*<IDADIR>/loaders*目录中的每个加载模块，并要求每个模块检查二进制文件。所有识别新文件格式的加载模块都会列在文件加载对话框中，用户需要决定使用哪个加载模块来加载文件。
- en: Writing an IDA Loader Using the SDK
  id: totrans-1032
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SDK编写IDA加载模块
- en: IDA’s principle interface to any loader module takes place via a global `loader_t`
    object that each loader must declare and export. The `loader_t` struct is analogous
    to the `plugin_t` class used in plug-in modules. The following listing shows the
    layout of the `loader_t` struct as defined in *loader.hpp*.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: IDA与任何加载模块的主要接口是通过每个加载模块必须声明和导出的全局`loader_t`对象。`loader_t`结构类似于插件模块中使用的`plugin_t`类。以下列表显示了在*loader.hpp*中定义的`loader_t`结构的布局。
- en: '[PRE99]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As with the `plugin_t` class, the behavior of a `loader_t` object is defined
    by the functions (created by the loader’s author) to which its members point.
    Every loader must export a `loader_t` object named `LDSC` (*loader description*).
    Exporting your `LDSC` object is handled by *loader.hpp*, which leaves you responsible
    only for declaring and initializing the actual object. Note that several of the
    functions accept an input parameter of type `linput_t` (*loader input type*).
    An `linput_t` is an internal SDK class that provides a compiler-independent wrapper
    around the C standard `FILE` type. Functions implementing standard input operations
    for `linput_t` are declared in *diskio.hpp*.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 与`plugin_t`类一样，`loader_t`对象的行为由指向其成员的函数（由加载器的作者创建）定义。每个加载器都必须导出一个名为`LDSC`（*加载器描述*）的`loader_t`对象。导出`LDSC`对象由`loader.hpp`处理，您只需负责声明和初始化实际对象。请注意，一些函数接受类型为`linput_t`（*加载器输入类型*）的输入参数。`linput_t`是一个内部SDK类，它为C标准的`FILE`类型提供了一个编译器无关的包装。实现`linput_t`标准输入操作的函数在`diskio.hpp`中声明。
- en: 'Since successful loader creation relies on properly initializing the `LDSC`
    object, the purpose of each member is described here:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成功创建加载器依赖于正确初始化`LDSC`对象，因此每个成员的用途在此描述：
- en: '**`version`**'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '**`version`**'
- en: This member serves the same purpose as the `version` member of the `plugin_t`
    class. Please refer to its description in [Chapter 17](ch17.html "Chapter 17. The
    IDA Plug-in Architecture").
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员与`plugin_t`类的`version`成员具有相同的作用。请参阅[第17章](ch17.html "第17章。IDA插件架构")中的描述。
- en: '**`flags`**'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '**`flags`**'
- en: The only flag recognized for loaders is `LDRF_RELOAD`, defined in *loader.hpp*.
    For many loaders assigning zero to this field will be sufficient.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器唯一识别的标志是`LDRF_RELOAD`，它在`loader.hpp`中定义。对于许多加载器，将此字段设置为0将足够。
- en: '**`accept_file`**'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '**`accept_file`**'
- en: The purpose of this function is to provide basic recognition of a newly selected
    input file. This function should utilize the provided `linput_t` object to read
    enough information from a file to determine whether the loader can parse the given
    file. If the file is recognized, the loader should copy the file format name into
    the `fileformatname` output buffer. The function should return 0 if the file format
    is not recognized or nonzero if the format is recognized. `OR`ing the return value
    with the `ACCEPT_FIRST` flag requests that IDA list this loader first in the load-file
    dialog. When several loaders indicate `ACCEPT_FIRST`, the last loader queried
    will be listed first.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的目的是提供对新选定的输入文件的基本识别。此函数应使用提供的`linput_t`对象从文件中读取足够的信息以确定加载器是否可以解析给定的文件。如果文件被识别，加载器应将文件格式名称复制到`fileformatname`输出缓冲区。如果文件格式不被识别，则函数应返回0；如果格式被识别，则返回非零值。将返回值与`ACCEPT_FIRST`标志进行`OR`操作将请求IDA在加载文件对话框中将此加载器列为首选。当多个加载器指示`ACCEPT_FIRST`时，最后查询的加载器将被列为首选。
- en: '**`load_file`**'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '**`load_file`**'
- en: This member is another function pointer. IDA calls the associated function if
    the user chooses your loader to load the newly selected file. The function receives
    an `linput_t` object that should be used to read the selected file. The `neflags`
    parameter contains a bitwise `OR` of various `NEF_`*`XXX`* flags defined in *loader.hpp*.
    Several of these flags reflect the state of various checkbox settings from the
    load-file dialog. The `load_file` function is responsible for any required parsing
    of the input file content and loading and mapping some or all of the file content
    into the newly created database. If an unrecoverable error condition is recognized,
    `load_file` should call `loader_failure` to terminate the loading process.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员是另一个函数指针。如果用户选择您的加载器来加载新选定的文件，IDA将调用关联的函数。该函数接收一个`linput_t`对象，该对象应用于读取选定的文件。`neflags`参数包含在`loader.hpp`中定义的`NEF_`*`XXX`*标志的位或。这些标志中的几个反映了加载文件对话框中各种复选框设置的状态。`load_file`函数负责对输入文件内容进行任何必要的解析，并将某些或全部文件内容加载和映射到新创建的数据库中。如果识别到不可恢复的错误条件，`load_file`应调用`loader_failure`以终止加载过程。
- en: '**`save_file`**'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '**`save_file`**'
- en: This member optionally points to a function capable of producing an executable
    file in response to the File ▸ Produce File ▸ Create EXE File command. Strictly
    speaking, the use of EXE here is a bit of a misnomer, because your `save_file`
    implementation could choose to generate any type of file that you wish. Since
    the loader is responsible for mapping a file into a database, it may also have
    the capability to map the database back into a file. In practice, the loader may
    not have loaded enough information from the original input file to be able to
    generate a valid output file based on database content alone. For example, the
    PE file loader supplied with IDA cannot regenerate an EXE file from a database
    file. If your loader is not capable of generating an output file, then you should
    set the `save_file` member to NULL.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员可选地指向一个函数，该函数能够响应文件▸生成文件▸创建EXE文件命令生成可执行文件。严格来说，这里的EXE使用有点名不副实，因为你的`save_file`实现可以选择生成你想要的任何类型的文件。由于加载器负责将文件映射到数据库中，它也可能具有将数据库映射回文件的能力。在实践中，加载器可能没有从原始输入文件中加载足够的信息，无法仅根据数据库内容生成有效的输出文件。例如，与IDA一起提供的PE文件加载器无法从数据库文件重新生成EXE文件。如果你的加载器无法生成输出文件，那么你应该将`save_file`成员设置为NULL。
- en: '**`move_segm`**'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '**`move_segm`**'
- en: This member is a pointer to a function that is called when a user attempts to
    move a segment within a database that was loaded with this loader. Since the loader
    may be aware of relocation information contained in the original binary, this
    function may be able to take relocation information into account as the segment
    is moved. This function is optional, and the pointer should be set to NULL if
    the function is not required (for example, when there are no relocated or fixed-up
    addresses in this file format).
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员是指向一个函数的指针，当用户尝试使用此加载器加载的数据库中的段移动时，将调用该函数。由于加载器可能了解原始二进制中包含的重定位信息，因此该函数在移动段时可能能够考虑重定位信息。此函数是可选的，如果不需要该函数（例如，在此文件格式中没有重定位或修复的地址），则应将指针设置为NULL。
- en: '**`init_loader_options`**'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '**`init_loader_options`**'
- en: This member is a pointer to a function whose purpose is to set user-specified
    options via the wizard base-loading process available via File ▸ New. This function
    is useful only in the Windows native GUI version of IDA (idag) because this is
    the only version of IDA that offers these wizards. This function is called once
    a user has chosen a loader, prior to calling `load_file`. If the loader requires
    no configuration prior to the call to `load_file`, this member pointer may be
    set safely to NULL.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 此成员是指向一个函数的指针，该函数的目的是通过文件▸新建中可用的向导基础加载过程设置用户指定的选项。此函数仅在Windows原生GUI版本的IDA（idag）中很有用，因为这是唯一提供这些向导的IDA版本。在用户选择加载器并在调用`load_file`之前，将调用此函数。如果加载器在调用`load_file`之前不需要配置，则可以将此成员指针安全地设置为NULL。
- en: The `init_loader_options` function deserves additional explanation. It is important
    to understand that if File ▸ Open is used to open a file, this function will never
    be called. In more sophisticated loaders, such as IDA’s PE loader, this function
    is used to initialize XML-based wizards that step the user through the loading
    process. The XML templates for several wizards are stored in *<IDADIR>/cfg*; however,
    other than the existing templates, no documentation exists for creating your own
    wizard templates.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_loader_options`函数值得进一步解释。重要的是要理解，如果使用文件▸打开来打开文件，此函数将不会被调用。在更复杂的加载器中，例如IDA的PE加载器，此函数用于初始化基于XML的向导，引导用户完成加载过程。几个向导的XML模板存储在`<IDADIR>/cfg`中；然而，除了现有的模板外，没有关于创建自己的向导模板的文档。'
- en: In the remainder of this chapter, we will develop two example loaders in order
    to review some commonly used loader operations.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将开发两个示例加载器，以回顾一些常用的加载器操作。
- en: The Simpleton Loader
  id: totrans-1053
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单加载器
- en: 'In order to demonstrate the basic operation of an IDA loader, we introduce
    the completely fictitious *simpleton* file format as defined by the following
    C struct (all values are little-endian):'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示IDA加载器的基本操作，我们引入了一个完全虚构的*简单*文件格式，该格式由以下C结构定义（所有值都是小端序）：
- en: '[PRE100]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The file format is very straightforward: a magic number file identifier and
    two integers describing the structure of the file, followed by all of the code
    contained in the file. Execution of the file begins with the first byte in the
    `code` block.'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式非常简单：一个魔数文件标识符和两个描述文件结构的整数，然后是文件中包含的所有代码。文件的执行从`code`块中的第一个字节开始。
- en: 'A hexdump of a small simpleton file might look like this:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小型简单文件的反转十六进制可能看起来像这样：
- en: '[PRE101]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Several sample loaders are included with the SDK and may be found in the *<SDKDIR>/ldr*
    directory. We elect to build our loaders in individual subdirectories alongside
    the example loaders. In this case we are working in *<SDKDIR>/ldr/simpleton*.
    Our loader begins with the following setup:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 中包含了一些示例加载器，可以在 *<SDKDIR>/ldr* 目录中找到。我们选择在示例加载器旁边的单独子目录中构建我们的加载器。在这种情况下，我们在
    *<SDKDIR>/ldr/simpleton* 中工作。我们的加载器从以下设置开始：
- en: '[PRE102]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The *idaldr.h* header file is a convenience file, included with the SDK (*<SDKDIR>/ldr/idaldr.h*),
    which includes several other header files and defines several macros, all of which
    are commonly used in loader modules.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '`idaldr.h` 头文件是一个便利文件，包含在 SDK 中（*<SDKDIR>/ldr/idaldr.h*），它包含几个其他头文件并定义了几个宏，所有这些在加载器模块中都是常用的。'
- en: 'The next order of business is to declare the required `LDSC` object, which
    points to the various functions that implement our loader’s behavior:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要做的事情是声明所需的 `LDSC` 对象，它指向实现我们加载器行为的各种函数：
- en: '[PRE103]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The functions used in this loader are described in the order in which they
    might be invoked, beginning with the `accept_simpleton_loader` function shown
    here:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在此加载器中使用的函数按它们可能被调用的顺序描述，首先是下面所示的 `accept_simpleton_loader` 函数：
- en: '[PRE104]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The entire purpose of this function is to determine whether the file being opened
    appears to be a simpleton file. The `n` parameter is a counter that indicates
    the number of times that our `accept_file` function has been called during the
    current loading process. The intent of this parameter is to allow a loader to
    recognize multiple related file formats. IDA will invoke your `accept_file` function
    with increasing values of `n` until your function returns 0\. For each unique
    format that your loader recognizes, you should fill in the `fileformatname` array
    and return nonzero. In this case, we elect to ignore anything other than the first
    call (when `n` is zero) by immediately returning 0\. The `lread4bytes` function,
    defined in *diskio.hpp*, is used to read the 4-byte magic number, and it returns
    0 if the read completed successfully. A useful feature of `lread4bytes` is its
    ability to read bytes in either big-endian or little-endian format, depending
    on the value of its Boolean third parameter (`false` reads little-endian; `true`
    reads big-endian). This feature can help reduce the number of calls to byte-swapping
    functions required during the loading process. If the required magic number is
    located, the final step in `accept_simpleton_file` is to copy the name of the
    file format into the `fileformatname` output parameter prior to returning 1 to
    indicate that the file format was recognized.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的整个目的是确定正在打开的文件是否看起来像是一个简单文件。`n` 参数是一个计数器，指示在当前加载过程中我们的 `accept_file` 函数被调用的次数。此参数的目的是允许加载器识别多个相关文件格式。IDA
    将使用递增的 `n` 值调用你的 `accept_file` 函数，直到你的函数返回 0。对于你的加载器识别的每个唯一格式，你应该填写 `fileformatname`
    数组并返回非零值。在这种情况下，我们选择忽略除了第一次调用（当 `n` 为零时）之外的所有内容，通过立即返回 0。定义在 *diskio.hpp* 中的 `lread4bytes`
    函数用于读取 4 字节魔数，如果读取成功则返回 0。`lread4bytes` 的一个有用特性是它能够根据其布尔第三个参数的值（`false` 读取小端；`true`
    读取大端）以大端或小端格式读取字节。这个特性可以帮助减少在加载过程中所需的字节交换函数的调用次数。如果在 `accept_simpleton_file` 中找到了所需的魔数，那么此函数的最终步骤是在返回
    1 以指示已识别文件格式之前，将文件格式的名称复制到 `fileformatname` 输出参数中。
- en: 'For the simpleton loader, no special processing is required if a user chooses
    to load a simpleton file using File ▸ New rather than File ▸ Open, so no `init_loader_options`
    function is required. Therefore, the next function called in the loading sequence
    will be `load_simpleton_file`, which is shown here:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单加载器，如果用户选择使用 File ▸ New 而不是 File ▸ Open 来加载简单文件，则不需要进行特殊处理，因此不需要 `init_loader_options`
    函数。因此，加载序列中下一个调用的函数将是 `load_simpleton_file`，如下所示：
- en: '[PRE105]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The bulk of the loading process takes place in a loader’s `load_file` function.
    Our simple loader performs the following tasks:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 加载过程的大部分工作发生在加载器的 `load_file` 函数中。我们的简单加载器执行以下任务：
- en: Read the simpleton header from the file using `lread` from *diskio.hpp*. The
    `lread` function is very similar to the POSIX `read` function.
  id: totrans-1070
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自 *diskio.hpp* 的 `lread` 函数从文件中读取简单文件头。
- en: Load the code section from the file into the proper address space within the
    database using `file2base` from *loader.hpp*.
  id: totrans-1071
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自 *loader.hpp* 的 `file2base` 将文件中的代码部分加载到数据库中的适当地址空间。
- en: Create a new database segment containing the newly loaded bytes using `add_segm`
    from *segment.hpp*.
  id: totrans-1072
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自 *segment.hpp* 的 `add_segm` 创建包含新加载字节的新的数据库段。
- en: Specify 32-bit addressing on our new code segment by calling `getseg` and `set_segm_addressing`
    from *segment.hpp*.
  id: totrans-1073
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用来自 *segment.hpp* 的 `getseg` 和 `set_segm_addressing` 在我们的新代码段上指定32位寻址。
- en: Generate a database header comment using `create_filename_cmt` from *loader.hpp*.
  id: totrans-1074
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自 *loader.hpp* 的 `create_filename_cmt` 生成数据库头注释。
- en: Add a program entry point using `add_entry`, from *entry.hpp*, to provide the
    processor module with a starting point for the disassembly process.
  id: totrans-1075
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自 *entry.hpp* 的 `add_entry` 添加程序入口点，为处理器模块提供反汇编过程的起点。
- en: 'The `file2base` function is a workhorse function for loaders. Its prototype
    appears here:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '`file2base` 函数是加载器的一个工作马函数。其原型如下：'
- en: '[PRE106]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This function reads bytes from the provided `linput_t` beginning at the file
    position specified by `pos`. The bytes are loaded into the database beginning
    at address `ea1`, up to but not including `ea2`. The total number of bytes read
    is calculated as `ea2-ea1`. The `patchable` parameter indicates whether IDA should
    maintain an internal mapping of file offsets to their corresponding locations
    in the database. To maintain such a mapping, this parameter should be set to `FILEREG_PATCHABLE`,
    which allows for the generation of IDA DIF files, as discussed in [Chapter 14](ch14.html
    "Chapter 14. Patching Binaries and Other IDA Limitations").
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从提供的 `linput_t` 读取字节，从由 `pos` 指定的文件位置开始。字节从地址 `ea1` 开始加载到数据库中，直到但不包括 `ea2`。读取的字节总数计算为
    `ea2-ea1`。`patchable` 参数指示 IDA 是否应维护文件偏移量与其在数据库中对应位置的内部分配。为了维护此类分配，此参数应设置为 `FILEREG_PATCHABLE`，这允许生成
    IDA DIF 文件，如第14章所述。
- en: 'The `add_entry` function is another important function in the loading process.
    The disassembly process can begin only with addresses known to contain instructions.
    For a recursive descent disassembler, such addresses are generally obtained by
    parsing a file for entry points (such as exported functions). The prototype for
    `add_entry` appears here:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_entry` 函数是加载过程中另一个重要的函数。反汇编过程只能从已知包含指令的地址开始。对于递归下降反汇编器，这些地址通常是通过解析文件以获取入口点（例如导出函数）来获得的。`add_entry`
    函数的原型如下：'
- en: '[PRE107]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `ord` parameter is useful for exported functions that may be exported by
    ordinal number in addition to function name. If the entry point has no associated
    ordinal number, `ord` should be set to the same value as the `ea` parameter. The
    `ea` parameter specifies the effective address of the entry point, while the `name`
    parameter specifies the name associated with the entry point. The symbolic name
    `_start` is often applied to a program’s initial execution address. The boolean
    `makecode` parameter specifies whether the specified address is to be treated
    as code (true) or not (false). Exported data items, such as `LDSC` within a loader
    module, are examples of noncode entry points.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '`ord` 参数对于可能通过序号而不是函数名导出的导出函数很有用。如果入口点没有关联的序号，则 `ord` 应设置为与 `ea` 参数相同的值。`ea`
    参数指定入口点的有效地址，而 `name` 参数指定与入口点关联的名称。符号名称 `_start` 通常应用于程序的初始执行地址。布尔参数 `makecode`
    指定指定的地址是否要被视为代码（true）或不是（false）。导出数据项，如加载模块中的 `LDSC`，是非代码入口点的示例。'
- en: 'The final function that we have implemented in the simpleton loader, `save_simpleton_file`,
    is used to create a simpleton file from the database contents. Our implementation
    is shown here:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在简单加载器中实现的最后一个函数 `save_simpleton_file` 用于从数据库内容创建简单文件。我们的实现如下：
- en: '[PRE108]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: A `loader_t`’s `save_file` function receives a `FILE` stream pointer, `fp`,
    to which the function should write its output. The `fileformatname` parameter
    is the same name filled in by the loader’s `accept_file` function. As mentioned
    earlier, the `save_file` function is called in response to IDA’s File ▸ Produce
    File ▸ Create EXE File command. In response to this command, IDA initially calls
    `save_file` with `fp` set to NULL. When called in this manner, `save_file` is
    being queried as to whether it can produce an output file of the type specified
    by `fileformatname`, in which case `save_file` should return 0 if it cannot create
    the specified file type or 1 if it can create the specified file. For example,
    the loader may be able to create a valid output file only if specific information
    is present within the database.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader_t` 的 `save_file` 函数接收一个 `FILE` 流指针 `fp`，该函数应该将输出写入此指针。`fileformatname`
    参数是加载器的 `accept_file` 函数填写的相同名称。如前所述，`save_file` 函数是在响应 IDA 的文件 ▸ 生成文件 ▸ 创建 EXE
    文件命令时被调用的。响应此命令时，IDA 首先使用 `fp` 设置为 NULL 调用 `save_file`。以这种方式调用时，`save_file` 正在被查询是否可以生成由
    `fileformatname` 指定的输出文件类型，在这种情况下，如果无法创建指定的文件类型，`save_file` 应返回 0；如果可以创建指定的文件，则返回
    1。例如，加载器可能只有在数据库中存在特定信息时才能创建有效的输出文件。'
- en: When called with a valid (non-NULL) `FILE` pointer, `save_file` should write
    a valid output file representation to the provided `FILE` stream. In such cases,
    IDA creates the `FILE` stream after presenting the user with a File Save dialog.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用有效的（非 NULL）`FILE` 指针调用时，`save_file` 应将有效的输出文件表示写入提供的 `FILE` 流。在这种情况下，IDA
    在向用户展示文件保存对话框后创建 `FILE` 流。
- en: IDA AND FILE POINTERS
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 和 FILE 指针
- en: 'If you develop modules for Windows versions of IDA, a very important aspect
    of the behavior of an IDA `FILE` stream is noted in *fpro.h* and results from
    the fact that IDA’s core DLL, *ida_wll.dll*, is built using Borland tools. In
    short, Borland `FILE` pointers may not be shared between program modules, and
    any attempt to do so is likely to result in an access violation, potentially crashing
    IDA. To work around this problem, IDA offers a complete set of wrapper functions
    in the form of `qfxxx` (such as qfprintf declared in *fpro.h*) alternatives to
    the standard C-style `FILE` manipulation routines (such as `fprintf`). A word
    of caution when using these functions, however, is that the `qfxxx` functions
    do not always utilize the same parameters as their C-style counterparts (`qfwrite`
    and `fwrite`, for example). If you wish to use the C-style `FILE` manipulation
    functions, you must remember the following rules:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为 IDA 的 Windows 版本开发模块，IDA `FILE` 流的行为的一个重要方面在 `fpro.h` 中被指出，并源于 IDA 的核心
    DLL，`ida_wll.dll`，是使用 Borland 工具构建的。简而言之，Borland `FILE` 指针可能不能在程序模块之间共享，并且尝试这样做很可能会导致访问违规，甚至可能使
    IDA 崩溃。为了解决这个问题，IDA 提供了一组完整的包装函数，形式为 `qfxxx`（例如在 `fpro.h` 中声明的 `qfprintf`），作为标准
    C 风格 `FILE` 操作例程（例如 `fprintf`）的替代。然而，在使用这些函数时，必须小心，因为 `qfxxx` 函数并不总是使用与它们的 C 风格对应函数相同的参数（例如，`qfwrite`
    和 `fwrite`）。如果你希望使用 C 风格的 `FILE` 操作函数，你必须记住以下规则：
- en: You must define the `USE_STANDARD_FILE_FUNCTIONS` macro prior to including *fpro.h*
    in your module.
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将 `fpro.h` 包含到你的模块中之前，你必须定义 `USE_STANDARD_FILE_FUNCTIONS` 宏。
- en: You must not mix IDA-provided `FILE` pointers with the C library `FILE` functions.
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你绝对不能将 IDA 提供的 `FILE` 指针与 C 库的 `FILE` 函数混合使用。
- en: You must not mix `FILE` pointers obtained from the C library functions with
    IDA’s `qfxxx` functions.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将来自 C 库函数的 `FILE` 指针与 IDA 的 `qfxxx` 函数混合使用。
- en: Returning to the `save_simpleton_file` function, the only truly interesting
    function used in implementing our `save_file` capability is the `base2file` function,
    which is the output counterpart to the `file2base` function used in `load_simpleton_file`.
    The `base2file` function simply writes a range of database values to a specified
    position within a supplied `FILE` stream.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `save_simpleton_file` 函数，在实现我们的 `save_file` 功能时使用的唯一真正有趣的函数是 `base2file`
    函数，它是 `load_simpleton_file` 中使用的 `file2base` 函数的输出对应函数。`base2file` 函数简单地将一系列数据库值写入提供的
    `FILE` 流的指定位置。
- en: While the simpleton file format borders on useless, it does serve one purpose,
    namely that it has allowed us to demonstrate the core functionality of IDA loader
    modules. The source code for the simpleton loader may be found on the book’s website.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的文件格式几乎无用，但它确实有一个用途，即它使我们能够展示 IDA 加载模块的核心功能。简单加载器的源代码可以在本书的网站上找到。
- en: Building an IDA Loader Module
  id: totrans-1093
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 IDA 加载模块
- en: The process for building and installing an IDA loader module is virtually identical
    to the process for building an IDA plug-in module as discussed in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture"), with only a few minor differences.
    First, the file extensions used for loaders are *.ldw/.l64* on Windows, *.llx/.llx64*
    on Linux platforms, and *.lmc/.lmc64* on OS X. Second, this is a matter of personal
    preference, but when we build loaders, we store the newly created loader binaries
    into *<SDKDIR>/bin/loaders*. Third, loader modules are installed by copying the
    compiled loader binary to *<IDADIR>/loaders*. The plug-in makefile presented in
    [Example 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins "Example 17-1. A
    sample makefile for IDA plug-ins") is easily adapted to build the simpleton loader
    by changing the `PLUGIN_EXT` variable to a `LOADER_EXT` variable that reflects
    the proper loader file extensions for each IDA platform, changing all references
    to `idabook_plugin` to `simpleton`, and changing the `OUTDIR` variable to point
    to `$(IDA)/bin/loaders`.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和安装IDA加载器模块的过程几乎与第17章中讨论的构建IDA插件模块的过程相同，只有一些细微的差异。首先，用于加载器的文件扩展名在Windows上是
    *.ldw/.l64*，在Linux平台上是 *.llx/.llx64*，在OS X上是 *.lmc/.lmc64*。其次，这是一个个人偏好的问题，但当我们构建加载器时，我们将新创建的加载器二进制文件存储在
    *<SDKDIR>/bin/loaders* 中。第三，通过将编译好的加载器二进制文件复制到 *<IDADIR>/loaders* 来安装加载器模块。在 [示例17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins
    "示例17-1. 为IDA插件提供的示例makefile") 中提供的插件makefile可以很容易地修改为构建simpleton加载器，只需将 `PLUGIN_EXT`
    变量更改为 `LOADER_EXT` 变量，以反映每个IDA平台适当的加载器文件扩展名，将所有对 `idabook_plugin` 的引用更改为 `simpleton`，并将
    `OUTDIR` 变量更改为指向 `$(IDA)/bin/loaders`。
- en: A pcap Loader for IDA
  id: totrans-1095
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA的pcap加载器
- en: Granted, the majority of network packets do not contain code that can be disassembled.
    However, if the packets happen to contain evidence of an exploit, the packets
    may contain binary code that might require disassembly for proper analysis. In
    order to demonstrate that IDA loaders can be used for many purposes, we now describe
    the construction of a loader capable of loading a pcap^([[132](#ftn.CHP-18-FN-5)])
    format packet-capture file into an IDA database. While this may be somewhat over
    the top, along the way we will demonstrate several more capabilities of IDA’s
    SDK. No attempt is made here to match the capabilities of tools such as Wireshark^([[133](#ftn.CHP-18-FN-6)])
    in any way.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数网络数据包不包含可反汇编的代码。然而，如果数据包恰好包含漏洞利用的证据，数据包可能包含可能需要反汇编以进行适当分析的二进制代码。为了证明IDA加载器可用于许多用途，我们现在描述了一个能够将pcap^([[132](#ftn.CHP-18-FN-5)])格式数据包捕获文件加载到IDA数据库中的加载器构建过程。虽然这可能有些过分，但在过程中，我们将展示IDA
    SDK的更多功能。这里没有尝试以任何方式匹配Wireshark^([[133](#ftn.CHP-18-FN-6)])等工具的功能。
- en: 'The development process for such a loader requires some research into the pcap
    file format, which reveals that a pcap file is structured with the following rough
    syntax:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的加载器开发过程需要对pcap文件格式进行一些研究，这揭示了pcap文件是以以下粗略语法构建的：
- en: '[PRE109]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: A `pcap_file_header` contains a 32-bit magic number field, as well as other
    fields describing the content of the file, including the type of packets contained
    in the file. For the sake of simplification, we assume here that we are dealing
    only with `DLT_EN10MB` (10Mb Ethernet packets). In developing the pcap loader,
    one of our goals is to identify as much header data as possible in order to help
    users focus on packet content, particularly at the application layer. Our approach
    for accomplishing this goal is (1) to separate the file header from the packet
    data by creating a separate segment for each and (2) to identify as many header
    structures as possible with the packets segment so that the user does not need
    to manually parse the file content. The discussion that follows focuses only on
    the `load_file` component of the pcap loader, because the `accept_file` function
    is a simple adaptation of the `accept_simpleton_file` function changed to recognize
    the pcap magic number.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcap_file_header` 包含一个32位魔数字段，以及其他描述文件内容的字段，包括文件中包含的数据包类型。为了简化，我们假设这里只处理 `DLT_EN10MB`（10Mb以太网数据包）。在开发pcap加载器时，我们的目标之一是尽可能多地识别头部数据，以便帮助用户专注于数据包内容，尤其是在应用层。我们实现这一目标的方法是（1）通过为每个文件头部和包数据创建单独的段来分离文件头部和包数据，（2）尽可能多地识别与包段相关的头部结构，以便用户不需要手动解析文件内容。以下讨论仅关注pcap加载器的
    `load_file` 组件，因为 `accept_file` 函数是对 `accept_simpleton_file` 函数的简单修改，改为识别pcap魔数。'
- en: In order to highlight header structures, we will need to have some commonly
    used structures defined in the IDA Structures window during the loading phase.
    This allows the loader to automatically format groups of bytes as structures when
    the datatype for those bytes is known. Pcap header structures and various networking-related
    structures describing Ethernet, IP, TCP, and UDP headers are defined in IDA’s
    GNU C++ Unix type library; however, in versions of IDA prior to 5.3, the definition
    for the IP header struct (`iphdr`) is incorrect. The first step that `load_pcap_file`
    takes is to call a helper function we have written named `add_types` to take care
    of importing structures into the new database. We examine two possible versions
    of `add_types`, one that makes use of the types declared in IDA’s GNU C++ Unix
    type library and another version in which `add_types` takes care of all required
    structure declarations by itself.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出显示头结构，在加载阶段我们需要在 IDA 结构窗口中定义一些常用结构。这允许加载器在已知这些字节的类型时自动将字节组格式化为结构。Pcap 头结构以及描述以太网、IP、TCP
    和 UDP 头的各种网络相关结构定义在 IDA 的 GNU C++ Unix 类型库中；然而，在 IDA 5.3 之前的版本中，IP 头结构（`iphdr`）的定义是不正确的。`load_pcap_file`
    执行的第一个步骤是调用我们编写的辅助函数 `add_types`，以处理将结构导入新数据库。我们检查了 `add_types` 的两种可能版本，一个版本利用了
    IDA 的 GNU C++ Unix 类型库中声明的类型，另一个版本中 `add_types` 自行处理所有必需的结构声明。
- en: 'The first version loads the GNU C++ Unix type library and then pulls type identifiers
    from the newly loaded type library. This version of `add_types` is shown here:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一版本的 `add_types` 首先加载 GNU C++ Unix 类型库，然后从新加载的类型库中提取类型标识符。这里展示了 `add_types`
    的这个版本：
- en: '[PRE110]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `add_til` functions defined in *typinf.hpp* are used to load an existing
    type library file into a database. The `add_til` function was deprecated in favor
    of `add_til2` with the introduction of IDA version 5.1\. These functions are the
    SDK equivalent of loading a *.til* file using the Types window discussed in [Chapter 8](ch08.html
    "Chapter 8. Datatypes and Data Structures"). Once a type library has been loaded,
    the `til2idb` function may be utilized to import individual types into the current
    database. This is the programmatic equivalent of adding a standard structure to
    the Structures window, which was also described in [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures"). The `til2idb` function returns a type identifier that is
    required whenever we want to convert a range of bytes into a specific structured
    datatype. We have chosen to save these type identifiers into global variables
    (each of type `tid_t`) in order to provide faster access to types later in the
    loading process.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *typinf.hpp* 中定义的 `add_til` 函数用于将现有的类型库文件加载到数据库中。随着 IDA 版本 5.1 的引入，`add_til`
    函数已被弃用，转而使用 `add_til2`。这些函数是 SDK 中使用类型窗口（在[第 8 章](ch08.html "第 8 章。数据类型和数据结构")中讨论）加载
    *.til* 文件的等效函数。一旦类型库被加载，就可以使用 `til2idb` 函数将单个类型导入当前数据库。这是在加载过程中向结构窗口添加标准结构的程序等效操作，这也在[第
    8 章](ch08.html "第 8 章。数据类型和数据结构")中有所描述。`til2idb` 函数返回一个类型标识符，在我们要将一系列字节转换为特定结构化数据类型时是必需的。我们选择将这些类型标识符保存到全局变量（每个都是
    `tid_t` 类型）中，以便在加载过程中后续更快地访问类型。
- en: Two drawbacks to this first version of `add_types` are the fact that we need
    to import an entire type library just to gain access to six datatypes and, as
    mentioned previously, the built-in IDA definition of a structure may be incorrect,
    which would lead to problems when we attempt to apply these structures later in
    the loading process.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `add_types` 第一版本的缺点是我们需要导入整个类型库才能访问六个数据类型，并且如前所述，内置的 IDA 结构定义可能是不正确的，这会导致我们在加载过程中尝试应用这些结构时出现问题。
- en: 'The second version of `add_types` demonstrates the process of building a type
    library on the fly by parsing actual C-style structure declarations. This version
    is shown here:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_types` 的第二版本展示了通过解析实际的 C 风格结构声明动态构建类型库的过程。这里展示了这个版本：'
- en: '[PRE111]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In this case, a temporary, empty type library is created using the `new_til`
    function. The new type library is populated by parsing a string (`pcap_types`)
    that contains valid C structure definitions for the types required by the loader.
    The first few lines of the `pcap_types` string are shown here:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 `new_til` 函数创建了一个临时、空白的类型库。新的类型库通过解析包含加载器所需类型的有效 C 结构定义的字符串（`pcap_types`）来填充。`pcap_types`
    字符串的前几行如下所示：
- en: '[PRE112]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The declaration of `pcap_types` continues and includes structure definitions
    for all of the structures required by the pcap loader. In order to simplify the
    parsing process, we elected to change all data declarations used within the structure
    definitions to make use of standard C datatypes.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcap_types`的声明继续进行，包括pcap加载器所需的所有结构体的定义。为了简化解析过程，我们选择将结构定义中使用的所有数据声明更改为使用标准C数据类型。'
- en: The `HTI_PAK1` constant is defined in *typeinf.hpp* and is one of many `HTI_`*`XXX`*
    values that may be used to control the behavior of the internal C parser. In this
    case, structure packing on a 1-byte boundary is being requested. Following modification,
    a type library is expected to be sorted using `sort_til`, at which point it is
    ready to use. The `import_type` function pulls the requested structure type from
    the specified type library into the database in a manner similar to `til2idb`.
    In this version, again we save the returned type identifier into global variables
    for use later in the loading process. The function completes by deleting the temporary
    type library using the `free_til` function to release the memory consumed by the
    type library. In this version of `add_types`, unlike the first version, we have
    complete control over the datatypes that we choose to import into the database,
    and we have no need to import entire libraries of structures that we have no intention
    of using.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTI_PAK1`常量在`typeinf.hpp`中定义，是许多`HTI_`*`XXX`*值之一，这些值可以用来控制内部C解析器的行为。在这种情况下，请求在1字节边界上进行结构打包。修改后，预期将使用`sort_til`对类型库进行排序，此时它就准备好使用了。`import_type`函数以类似于`til2idb`的方式，从指定的类型库中将请求的结构类型拉入数据库。在这个版本中，我们再次将返回的类型标识符保存到全局变量中，以便在加载过程中稍后使用。该函数通过使用`free_til`函数删除临时类型库来完成，以释放类型库消耗的内存。在这个版本的`add_types`中，与第一个版本不同，我们对要导入数据库的数据类型有完全的控制权，我们不需要导入整个结构库，因为我们没有打算使用这些结构。'
- en: As an aside, it is also possible to save the temporary type library file to
    disk using the `store_til` function (which should be preceded by a call to `compact_til`).
    With so few types to construct, this has little benefit in this case, because
    it is just as easy to build the structures each time the loader is executed as
    it is to build and distribute a special-purpose type library that must be properly
    installed and in the end does not save a significant amount of time.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为补充，使用`store_til`函数（应该在调用`compact_til`之前）也可以将临时类型库文件保存到磁盘上。由于要构建的类型很少，在这种情况下这几乎没有好处，因为每次加载器执行时构建结构体和构建并分发一个特殊用途的类型库一样容易，而这个特殊用途的类型库必须正确安装，最终并没有节省多少时间。
- en: 'Turning our attention to the `load_pcap_file` function, we see the call to
    `add_types` to initialize the datatypes, as discussed previously; the creation
    of a file comment; followed by loading the pcap file header into the database,
    creating a section around the header bytes, and transforming the header bytes
    into a `pcap_file_header` structure:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转向`load_pcap_file`函数，我们可以看到对`add_types`的调用，用于初始化数据类型，正如之前所讨论的；接着创建文件注释；然后是将pcap文件头加载到数据库中，围绕头部字节创建一个部分，并将头部字节转换成`pcap_file_header`结构：
- en: '[PRE113]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Once again, we see the use of `file2base` to load content from the newly opened
    disk file into the database. Once the pcap file header content has been loaded,
    it gets its own section in the database, and the `pcap_file_header` structure
    is applied to all of the header bytes using the `doStruct` function, declared
    in *bytes.hpp*, which is the SDK equivalent of using Edit ▸ Struct Var to convert
    a contiguous block of bytes into a structure. The `doStruct` function expects
    an address, a size, and a type identifier, and it converts size bytes at the given
    address into the given type.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看到使用`file2base`将新打开的磁盘文件中的内容加载到数据库中。一旦pcap文件头内容被加载，它将在数据库中拥有自己的部分，并且使用在`bytes.hpp`中声明的`doStruct`函数将`pcap_file_header`结构应用于所有头部字节，该函数是SDK中使用Edit
    ▸ Struct Var将连续的字节块转换为结构的等价物。`doStruct`函数期望一个地址、一个大小和一个类型标识符，并将给定地址的size字节转换为指定的类型。
- en: 'The `load_pcap_file` function continues by reading all of the packet content
    and creating a single `.packets` section around the packet content, as shown here:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_pcap_file`函数继续读取所有数据包内容，并在数据包内容周围创建一个单独的`.packets`部分，如下所示：'
- en: '[PRE114]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In the preceding code, the `mem2base` function is new and utilized to transfer
    content that has already been loaded into memory into the database.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`mem2base`函数是新的，用于将已加载到内存中的内容传输到数据库。
- en: 'The `load_pcap_file` function concludes by applying structure templates wherever
    possible throughout the database. We must apply structure templates after creating
    the segment; otherwise the act of creating the segment will remove all applied
    structure templates, negating all of our hard work. The third and final portion
    of the function is shown here:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_pcap_file`函数通过在数据库中尽可能应用结构模板来结束。我们必须在创建段之后应用结构模板；否则，创建段的行为将移除所有应用的结构模板，从而抵消了我们所有的努力。函数的第三和最后一部分如下所示：'
- en: '[PRE115]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The preceding code simply steps through the database, one packet at a time,
    and examines a few fields within each packet header in order to determine both
    the type of structure to be applied and the location of the start of that structure.
    The following output represents the first few lines of a pcap file that has been
    loaded into a database using the pcap loader:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码简单地遍历数据库，一次一个数据包，检查每个数据包头中的几个字段，以确定要应用的结构类型及其起始位置。以下输出表示使用pcap加载器加载到数据库中的pcap文件的前几行：
- en: '[PRE116]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Applying structure templates in this manner, we can expand and collapse any
    header to show or hide its individual member fields. As displayed, it is fairly
    easy to observe that the byte at address `0000005E` is the first byte of an HTTP
    response packet.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式应用结构模板，我们可以展开和折叠任何头文件以显示或隐藏其单个成员字段。如图所示，观察地址`0000005E`的字节是HTTP响应数据包的第一个字节。
- en: Having a basic loading capability for pcap files lays the groundwork for developing
    plug-ins that perform more sophisticated tasks, such as TCP stream reassembly
    and various other forms of data extraction. Additional work could go into formatting
    various networking-related structures in a more user-friendly manner, such as
    displaying readable versions of an IP address and hosting byte-ordered displays
    for other fields within each header. Such improvements are left as challenges
    to the reader.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 具备对pcap文件的基本加载能力为开发执行更复杂任务的插件奠定了基础，例如TCP流重组和各种其他形式的数据提取。可以进一步工作，以更用户友好的方式格式化各种网络相关结构，例如显示IP地址的可读版本，以及在每个头文件内为其他字段提供字节序显示。这样的改进留给了读者作为挑战。
- en: '* * *'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[132](#CHP-18-FN-5)]) See [http://www.tcpdump.org/](http://www.tcpdump.org/).
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[132](#CHP-18-FN-5)]) 查看 [http://www.tcpdump.org/](http://www.tcpdump.org/).
- en: ^([[133](#CHP-18-FN-6)]) See [http://www.wireshark.org/](http://www.wireshark.org/).
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[133](#CHP-18-FN-6)]) 查看 [http://www.wireshark.org/](http://www.wireshark.org/).
- en: Alternative Loader Strategies
  id: totrans-1127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代加载策略
- en: 'If you spend some time browsing the example loaders included with the SDK,
    you will find several different styles of loaders. One loader worth pointing out
    is the Java loader (*<SDKDIR>/ldr/javaldr*). For some file formats, the coupling
    between the loader and the processor module is very loose. Once the loader makes
    note of entry points into the code, the processor module needs no additional information
    in order to properly disassemble the code. Some processor modules may require
    substantially more information about the original input file and may be required
    to perform much of the same parsing that was previously completed by the loader.
    In order to avoid such duplication of effort, a loader and a processor may be
    paired in a much more tightly coupled manner. In fact, the approach taken in the
    Java loader is essentially to push all loading tasks (those that would usually
    take place in the loader’s `load_file` function) into the processor module using
    code similar to the following:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花些时间浏览SDK中包含的示例加载器，你会发现几种不同的加载器样式。其中一个值得指出的是Java加载器（`<SDKDIR>/ldr/javaldr*`）。对于某些文件格式，加载器与处理模块之间的耦合非常松散。一旦加载器记录了代码的入口点，处理模块就不需要额外的信息来正确地反汇编代码。某些处理模块可能需要大量关于原始输入文件的信息，并且可能需要执行之前由加载器完成的大部分相同的解析。为了避免这种努力的重叠，加载器和处理模块可以以更紧密耦合的方式配对。实际上，Java加载器采取的方法基本上是将所有加载任务（那些通常在加载器的`load_file`函数中进行的任务）通过类似以下代码的方式推送到处理模块：
- en: '[PRE117]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In the Java loader, the only work that takes place is to verify that the processor
    type is set to the Java processor, at which point the loader sends a `ph.loader`
    (defined in *idp.hpp*) notification message to the processor module to inform
    the processor that the loading phase has been initiated. Upon receipt of the notification,
    the Java processor takes over the responsibility for loading, and in the process
    it derives a significant amount of internal state information that will be reused
    when the processor is directed to perform its disassembly tasks.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 加载器中，唯一的工作是验证处理器类型是否设置为 Java 处理器，此时加载器向处理器模块发送一个 `ph.loader`（在 *idp.hpp*
    中定义）通知消息，告知处理器加载阶段已经开始。接收到通知后，Java 处理器接管加载任务，并在过程中推导出大量内部状态信息，这些信息将在处理器被指示执行反汇编任务时被重用。
- en: Whether this strategy makes sense for you depends entirely on if you are developing
    both a loader and an associated processor module and if you feel that the processor
    would benefit from access to the information traditionally derived within the
    loader (segmentation, file header fields, debugging information, and so on).
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略是否适合您完全取决于您是否正在开发加载器和相关的处理器模块，以及您是否认为处理器将从访问在加载器中传统上获取的信息（如分段、文件头字段、调试信息等）中受益。
- en: Another means to pass state information from the loader to the processor module
    involves the use of database netnodes. During the loading phase, the loader may
    choose to populate specific netnodes with information that can later be retrieved
    by the processor module during the disassembly phase. Note that frequently accessing
    the database to retrieve information stored in this manner may be somewhat slower
    than utilizing available C++ datatypes.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 从加载器向处理器模块传递状态信息的另一种方法涉及使用数据库 netnodes。在加载阶段，加载器可以选择用信息填充特定的 netnodes，这些信息可以在反汇编阶段由处理器模块检索。请注意，频繁访问数据库以检索以这种方式存储的信息可能比使用可用的
    C++ 数据类型要慢一些。
- en: Writing a Scripted Loader
  id: totrans-1133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写脚本式加载器
- en: In IDA 5.6 Hex-Rays introduced the capability to implement loaders using Python
    or IDC scripts. In the Hex Blog posting announcing this new capability,^([[134](#ftn.CHP-18-FN-7)])
    Elias Bachaalany of Hex-Rays describes a loader, implemented in Python, used to
    load a particular type of malicious *.pdf* file containing shellcode. The nature
    of malicious *.pdf* files is such that the loader does not generalize across all
    *.pdf* files, but the loader is an excellent example of how to load unsupported
    file formats in IDA.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA 5.6 中，Hex-Rays 引入了使用 Python 或 IDC 脚本实现加载器的功能。在宣布这一新功能的 Hex Blog 帖子中，^([[134](#ftn.CHP-18-FN-7)])
    Hex-Rays 的 Elias Bachaalany 描述了一个使用 Python 实现的加载器，用于加载特定类型的恶意 *.pdf* 文件，该文件包含
    shellcode。恶意 *.pdf* 文件的性质使得加载器不能泛化到所有 *.pdf* 文件，但这个加载器是 IDA 中如何加载不受支持的文件格式的优秀示例。
- en: 'Scripted loaders may be implemented in either IDC or Python and require at
    least two functions, `accept_file` and `load_file`, which perform functions similar
    to those previously described for SDK-based loaders. An IDC-based loader for the
    Simpleton file format is shown here:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本式加载器可以采用 IDC 或 Python 实现，并且至少需要两个函数，`accept_file` 和 `load_file`，这些函数的功能与之前描述的基于
    SDK 的加载器类似。这里展示了 Simpleton 文件格式的基于 IDC 的加载器示例：
- en: '[PRE118]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Other than the use of IDC functions in place of SDK functions, the similarities
    between the IDC version of the simpleton loader and the C++ version presented
    earlier should be fairly obvious. Loader scripts are installed by copying them
    to *<IDADIR>/loaders*.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 IDC 函数代替 SDK 函数之外，simpleton 加载器的 IDC 版本和之前展示的 C++ 版本之间的相似性应该是相当明显的。加载器脚本通过将它们复制到
    *<IDADIR>/loaders* 来安装。
- en: Python may also be used to develop loaders and allows for more robust development
    because it offers much greater access to IDA’s underlying SDK. Implemented in
    Python, the simpleton loader might look something like this.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以用来开发加载器，并且由于它提供了对 IDA 内部 SDK 的更广泛访问，因此可以支持更健壮的开发。在 Python 中实现的 simpleton
    加载器可能看起来像这样。
- en: '[PRE119]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: One of the greatest strengths of scripting loaders (and plug-ins for that matter)
    is that they allow for rapid prototyping of modules that might eventually be implemented
    using the SDK.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本式加载器（以及插件）的一个最大的优点是，它们允许快速原型化那些最终可能使用 SDK 实现的模块。
- en: '* * *'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[134](#CHP-18-FN-7)]) See [http://www.hexblog.com/?p=110](http://www.hexblog.com/?p=110).
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[134](#CHP-18-FN-7)]) 查看 [http://www.hexblog.com/?p=110](http://www.hexblog.com/?p=110)。
- en: Summary
  id: totrans-1143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Once you have developed an understanding of how loaders fit into IDA’s modular
    architecture, you should find that loader modules are no more difficult to create
    than plug-in modules. Loaders clearly have their own particular subset of the
    SDK that they rely heavily on, the majority of which resides in *loader.hpp*,
    *segment.hpp*, *entry.hpp*, and *diskio.hpp*. Finally, since loaders execute before
    the processor module has a chance to analyze the newly loaded code, loaders should
    never bother themselves with any disassembly tasks, such as dealing with functions
    or disassembled instructions.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了加载器如何融入IDA的模块化架构，你应该会发现创建加载器模块并不比创建插件模块更困难。加载器显然有它们自己的特定子集的SDK，它们严重依赖于这些SDK，其中大部分位于`loader.hpp`、`segment.hpp`、`entry.hpp`和`diskio.hpp`中。最后，由于加载器在处理器模块有机会分析新加载的代码之前就执行了，因此加载器不应该去处理任何反汇编任务，例如处理函数或反汇编指令。
- en: In the next chapter, we round out our discussion of IDA modules with an introduction
    to processor modules, the components most responsible for the overall formatting
    of a disassembled binary.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍处理器模块来完善我们对IDA模块的讨论，处理器模块是负责反汇编二进制文件整体格式的组件。
- en: Chapter 19. IDA Processor Modules
  id: totrans-1146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章。IDA处理器模块
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-1147
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: The last type of IDA modules that can be built with the SDK are processor modules,
    which are by far the most complex of IDA’s module types. Processor modules are
    responsible for all of the disassembly operations that take place within IDA.
    Beyond the obvious conversion of machine language opcodes into their assembly
    language equivalents, processor modules are also responsible for tasks such as
    creating functions, generating cross-references, and tracking the behavior of
    the stack pointer. As it has done with plug-ins and loaders, Hex-Rays has made
    it possible (beginning with IDA 5.7) to author processor modules using one of
    IDA’s scripting languages.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用SDK构建的IDA模块中最后一种类型是处理器模块，这无疑是IDA模块类型中最复杂的。处理器模块负责IDA内部发生的所有反汇编操作。除了将机器语言操作码转换为它们的汇编语言等效操作码之外，处理器模块还负责创建函数、生成交叉引用和跟踪栈指针的行为。正如Hex-Rays在插件和加载器方面所做的那样，它使得（从IDA
    5.7版本开始）能够使用IDA的一种脚本语言来编写处理器模块成为可能。
- en: The obvious case that would require development of a processor module is reverse
    engineering a binary for which no processor module exists. Among other things,
    such a binary might represent firmware images for embedded microcontrollers or
    executable images pulled from handheld devices. A less-obvious use for a processor
    module might be to disassemble the instructions of a custom virtual machine embedded
    within an obfuscated executable. In such cases, an existing IDA processor module
    such as the `pc` module for x86 would help you understand only the virtual machine
    itself; it would offer no help at all in disassembling the virtual machine’s underlying
    byte code. Rolf Rolles demonstrated just such an application of a processor module
    in a paper posted to [OpenRCE.org](http://openrce.org).^([[135](#ftn.CHP-19-FN-1)])
    In [Appendix B](apb.html "Appendix B. IDC/SDK Cross-Reference") of his paper,
    Rolf also shares his thoughts on creating IDA processor modules; this is one of
    the few documents available on the subject.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 需要开发处理器模块的明显情况是，为不存在处理器模块的二进制文件进行逆向工程。这类二进制文件可能代表嵌入式微控制器的固件映像或从手持设备中提取的可执行映像。处理器模块的一个不那么明显用途可能是反汇编嵌入在混淆可执行文件中的自定义虚拟机的指令。在这种情况下，现有的IDA处理器模块，如x86的`pc`模块，可以帮助你理解虚拟机本身；但它对反汇编虚拟机底层的字节码没有任何帮助。Rolf
    Rolles在[OpenRCE.org](http://openrce.org)上发布的一篇论文中展示了处理器模块的这样一个应用。在他的论文附录B[附录B。IDC/SDK交叉引用](apb.html
    "附录B。IDC/SDK交叉引用")中，Rolf还分享了他对创建IDA处理器模块的看法；这是关于这个主题的少数几个文档之一。
- en: In the world of IDA modules, there are an infinite number of conceivable uses
    for plug-ins, and after scripts, plug-ins are by far the most commonly available
    third-party add-ons for IDA. The need for custom loader modules is far smaller
    than the need for plug-ins. This is not unexpected, as the number of binary file
    formats (and hence the need for loaders) tends to be much smaller than the number
    of conceivable uses for plug-ins. A natural consequence is that outside of modules
    donated to and distributed with IDA, there tend to be relatively few third-party
    loader modules published. Smaller still is the need for processor modules, as
    the number of instruction sets requiring decoding is smaller than the number of
    file formats that make use of those instruction sets. Here again, this leads to
    an almost complete lack of third-party processor modules other than the few distributed
    with IDA and its SDK. Judging by the subjects of posts to the Hex-Rays forums,
    it is clear that people are working on processor modules; these modules are simply
    not being released to the public.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA模块的世界里，插件有着无限多的潜在用途，并且在脚本之后，插件是IDA最常见的外部第三方插件。对于自定义加载模块的需求远小于插件的需求。这一点并不意外，因为二进制文件格式的数量（以及加载器的需求）通常远小于插件的潜在用途数量。一个自然的后果是，除了捐赠给IDA并随IDA一起分发的模块之外，公开发布的第三方加载模块相对较少。对于处理器模块的需求则更小，因为需要解码的指令集数量小于使用这些指令集的文件格式数量。同样，这也导致了除了与IDA及其SDK一起分发的少数几个之外，几乎没有第三方处理器模块。从Hex-Rays论坛帖子的话题来看，很明显人们正在开发处理器模块；这些模块只是没有向公众发布。
- en: In this chapter, we hope to shed additional light on the topic of creating IDA
    processor modules and help to demystify (at least somewhat) the last of IDA’s
    modular components. As a running example, we will develop a processor module to
    disassemble Python byte code. Since the components of a processor module can be
    lengthy, it will not be possible to include complete listings of every piece of
    the module. The complete source code for the Python processor module is available
    on the book’s companion website. It is important to understand that without the
    benefit of a Python loader module, it will not be possible to perform fully automated
    disassembly of compiled *.pyc* files. Lacking such a loader, you will need to
    load *.pyc* files in binary mode, select the Python processor module, identify
    a likely starting point for a function, and then convert the displayed bytes to
    Python instructions using Edit ▸ Code.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们希望对创建IDA处理器模块的主题进行进一步的探讨，并帮助揭开（至少在一定程度上）IDA模块组件的最后面纱。作为一个运行示例，我们将开发一个用于反汇编Python字节码的处理器模块。由于处理器模块的组件可能很长，因此不可能包含模块每个部分的完整列表。Python处理器模块的完整源代码可在本书的配套网站上找到。重要的是要理解，如果没有Python加载模块的好处，将无法完全自动地反汇编编译的*.pyc*文件。缺少这样的加载器，您需要以二进制模式加载*.pyc*文件，选择Python处理器模块，确定函数的可能起始点，然后使用“编辑”▸“代码”将显示的字节转换为Python指令。
- en: Python Byte Code
  id: totrans-1152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python字节码
- en: Python^([[136](#ftn.CHP-19-FN-2)]) is an object-oriented, interpreted programming
    language. Python is often used for scripting tasks in a manner similar to Perl.
    Python source files are commonly saved with a *.py* extension. Whenever a Python
    script is executed, the Python interpreter compiles the source code to an internal
    representation known as *Python byte code*.^([[137](#ftn.CHP-19-FN-3)]) This byte
    code is ultimately interpreted by a virtual machine. This entire process is somewhat
    analogous to the manner in which Java source is compiled to Java byte code, which
    is ultimately executed by a Java virtual machine. The primary difference is that
    Java users must explicitly compile their Java source into Java byte code, while
    Python source code is implicitly converted to byte code every time a user elects
    to execute a Python script.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: Python^([[136](#ftn.CHP-19-FN-2)])是一种面向对象的解释型编程语言。Python通常以类似于Perl的方式用于脚本任务。Python源文件通常以*.py*扩展名保存。每当执行Python脚本时，Python解释器将源代码编译成内部表示，称为*Python字节码*。^([[137](#ftn.CHP-19-FN-3)])这种字节码最终由虚拟机解释。整个过程在某种程度上类似于Java源代码编译成Java字节码，最终由Java虚拟机执行。主要区别在于，Java用户必须显式地将Java源代码编译成Java字节码，而Python源代码在用户选择执行Python脚本时隐式地转换为字节码。
- en: In order to avoid repeated translations from Python source to Python byte code,
    the Python interpreter may save the byte code representation of a Python source
    file in a *.pyc* file that may be loaded directly on subsequent execution, eliminating
    the time spent in translating the Python source. Users typically do not explicitly
    create *.pyc* files. Instead, the Python interpreter automatically creates *.pyc*
    files for any Python source module that is imported by another Python source module.
    The theory is that modules tend to get reused frequently, and you can save time
    if the byte code form of the module is readily available. Python byte code (*.pyc*)
    files are the rough equivalent of Java *.class* files.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免从 Python 源代码到 Python 字节码的重复翻译，Python 解释器可能会将 Python 源文件的字节码表示保存在一个 *.pyc*
    文件中，该文件可以直接在后续执行中加载，从而消除翻译 Python 源代码所花费的时间。用户通常不会明确创建 *.pyc* 文件。相反，Python 解释器会自动为任何被另一个
    Python 源模块导入的 Python 源模块创建 *.pyc* 文件。理论上是这样的，模块往往会被频繁重用，如果模块的字节码形式可以轻松获得，那么可以节省时间。Python
    字节码 (*.pyc*) 文件大致等同于 Java *.class* 文件。
- en: Given that the Python interpreter does not require source code when a corresponding
    byte code file is available, it may be possible to distribute some portions of
    a Python project as byte code rather than as source. In such cases, it might be
    useful to reverse engineer the byte code files in order to understand what they
    do, just as we might do with any other binary software distribution. This is the
    intended purpose of our example Python processor module—to provide a tool that
    can assist in reverse engineering Python byte code.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 解释器在存在相应的字节码文件时不需要源代码，因此可能可以将 Python 项目的某些部分作为字节码而不是源代码进行分发。在这种情况下，逆向工程字节码文件以了解其功能可能是有用的，就像我们可能对任何其他二进制软件分发做的那样。这正是我们示例
    Python 处理器模块的预期用途——提供一个可以帮助逆向工程 Python 字节码的工具。
- en: '* * *'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[135](#CHP-19-FN-1)]) See “Defeating HyperUnpackMe2 With an IDA Processor
    Module” at [http://www.openrce.org/articles/full_view/28](http://www.openrce.org/articles/full_view/28)
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[135](#CHP-19-FN-1)]) 请参阅 [http://www.openrce.org/articles/full_view/28](http://www.openrce.org/articles/full_view/28)
    中的“使用 IDA 处理器模块击败 HyperUnpackMe2”
- en: ^([[136](#CHP-19-FN-2)]) See [http://www.python.org/](http://www.python.org/)
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[136](#CHP-19-FN-2)]) 请参阅 [http://www.python.org/](http://www.python.org/)
- en: ^([[137](#CHP-19-FN-3)]) See [http://docs.python.org/library/dis.html#bytecodes](http://docs.python.org/library/dis.html#bytecodes)
    for a complete list of Python byte code instructions and their meanings. Also
    see *opcode.h* in the Python source distribution for a mapping of byte code mnemonics
    to their equivalent opcodes.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[137](#CHP-19-FN-3)]) 请参阅 [http://docs.python.org/library/dis.html#bytecodes](http://docs.python.org/library/dis.html#bytecodes)
    以获取 Python 字节码指令及其含义的完整列表。还可以在 Python 源代码分发中的 *opcode.h* 中找到字节码助记符与其等效操作码的映射。
- en: The Python Interpreter
  id: totrans-1160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 解释器
- en: A little background on the Python interpreter may be useful as we develop the
    Python processor module. The Python interpreter implements a stack-based virtual
    machine that is capable of executing Python byte code. By *stack-based*, we mean
    that the virtual machine has no registers other than an instruction pointer and
    a stack pointer. The majority of Python byte code instructions manipulate the
    stack in some way by reading, writing, or examining stack content. The `BINARY_ADD`
    byte code instruction, for example, removes two items from the interpreter’s stack,
    adds those two items together, and places the single result value back on the
    top of the interpreter’s stack.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发 Python 处理器模块时，对 Python 解释器的一些背景知识可能是有用的。Python 解释器实现了一个基于栈的虚拟机，能够执行 Python
    字节码。当我们说“基于栈”时，我们的意思是虚拟机除了指令指针和栈指针之外没有其他寄存器。Python 字节码指令中的大多数通过读取、写入或检查栈内容以某种方式操作栈。例如，`BINARY_ADD`
    字节码指令从解释器的栈中移除两个项目，将这两个项目相加，并将单个结果值放回解释器栈的顶部。
- en: In terms of instruction set layout, Python bytes codes are relatively simple
    to understand. All Python instructions consist of a single-byte opcode and either
    zero or two operand bytes. The processor example presented in this chapter does
    not require that you have any prior knowledge of Python byte code. In the few
    instances where specific knowledge is required, we will take the time to explain
    the byte code sufficiently. The primary goal of this chapter is to provide a basic
    understanding of IDA processor modules and some of the considerations that go
    into creating them. Python byte code is merely used as a means to facilitate this
    goal.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令集布局方面，Python字节码相对容易理解。所有Python指令都由一个单字节操作码和零个或两个操作数字节组成。本章中提供的处理器示例不需要你对Python字节码有任何先前的了解。在需要特定知识的一些情况下，我们会花时间充分解释字节码。本章的主要目标是提供一个对IDA处理器模块的基本理解以及创建它们时需要考虑的一些因素。Python字节码仅作为实现这一目标的手段。
- en: Writing a Processor Module Using the SDK
  id: totrans-1163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SDK编写处理器模块
- en: It wouldn’t be proper to begin a discussion of creating a processor module without
    including the standard disclaimer that documentation concerning processor modules
    is scarce. Other than reading through SDK include files and the source of processor
    modules included with the SDK, you will find that the SDK’s *readme.txt* file
    is the only other file that sheds any light on how to create a processor module,
    with a few notes under the heading “Description of processor modules.”
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 在不包含关于处理器模块的标准免责声明的情况下开始讨论创建处理器模块是不恰当的。除了阅读SDK包含的包含文件和SDK中包含的处理器模块的源代码外，你会发现SDK的`readme.txt`文件是唯一其他可以提供有关如何创建处理器模块信息的文件，其中在“处理器模块描述”标题下有一些注释。
- en: It is worth clarifying that while the README file references specific filenames
    within a processor module as if those filenames are set in stone, in fact they
    are not. They do, however, tend to be the filenames that are used in the included
    SDK examples, and they are also the filenames referenced in the build scripts
    included with those examples. Feel free to create your processor modules using
    any filenames you like, as long as you update your build scripts accordingly.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 值得明确的是，虽然README文件引用了处理器模块中的特定文件名，好像这些文件名是固定不变的，但实际上并非如此。然而，它们往往是在包含的SDK示例中使用的文件名，并且它们也是那些示例中包含的构建脚本中引用的文件名。请随意使用你喜欢的任何文件名来创建你的处理器模块，只要相应地更新你的构建脚本即可。
- en: 'The general intent of referring to specific processor files is to convey the
    idea that a processor module consists of three logical components: an *analyzer*,
    an *instruction emulator*, and an *output generator*. We will cover the purpose
    of each of these functional components as we work our way through the creation
    of our Python processor module.'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 指向特定处理器文件的一般意图是传达一个想法，即处理器模块由三个逻辑组件组成：一个*分析器*、一个*指令模拟器*和一个*输出生成器*。随着我们创建Python处理器模块的过程，我们将介绍每个功能组件的作用。
- en: Several example processors can be found in *<SDKDIR>/module*. One of the simpler
    processors to read through (if there is such a thing) is the z8 processor. Other
    processor modules vary in complexity based on their instruction sets and whether
    they take on any of the loading responsibilities. If you are thinking about writing
    your own processor module, one approach for getting started (recommended by Ilfak
    in the README file) is to copy an existing processor module and modify it to suit
    your needs. In such cases, you will want to find the processor module that most
    closely resembles the logical structure (not necessarily the processor architecture)
    that you envision for your module.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<SDKDIR>/module`中可以找到几个示例处理器。其中，阅读起来相对简单的一个处理器（如果存在的话）是z8处理器。其他处理器模块的复杂度因指令集的不同以及是否承担任何加载责任而有所不同。如果你正在考虑编写自己的处理器模块，一个入门的方法（在README文件中由Ilfak推荐）是复制一个现有的处理器模块，并修改它以满足你的需求。在这种情况下，你将希望找到与你的模块预想的逻辑结构（不一定是处理器架构）最相似的处理器模块。
- en: The processor_t Struct
  id: totrans-1168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`processor_t`结构'
- en: As with plug-ins and loaders, processor modules export exactly one thing. For
    processors, that one thing is a `processor_t` struct that must be named `LPH`.
    This struct is exported automatically if you include *<SDKDIR>/module/idaidp.hpp*,
    which in turn includes many other SDK header files commonly required by processor
    modules. One of the reasons why writing a processor module is so challenging is
    that the `processor_t` struct contains 56 fields that must be initialized, and
    26 of those fields are function pointers, while 1 of the fields is a pointer to
    an array of one or more struct pointers that each point to a different type of
    struct (`asm_t`) that contains 59 fields requiring initialization. Easy enough,
    right? One of the principle inconveniences in building processor modules revolves
    around initializing all of the required static data, a proccess that can be error
    prone because of the large number of fields within each data structure. This is
    one of the reasons why Ilfak recommends using an existing processor as the basis
    for any new processors you develop.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 与插件和加载器一样，处理器模块只导出一件事情。对于处理器来说，这一件事就是一个名为`LPH`的`processor_t`结构体。如果您包含`*<SDKDIR>/module/idaidp.hpp*`，这个结构体会自动导出，它反过来又包含了处理器模块通常需要的许多其他SDK头文件。编写处理器模块之所以如此具有挑战性，其中一个原因就是`processor_t`结构体包含56个字段需要初始化，其中26个字段是函数指针，而1个字段是指向一个或多个结构指针数组的指针，每个指针指向一个不同的类型结构（`asm_t`），该结构包含59个字段需要初始化。听起来很简单，对吧？构建处理器模块的一个主要不便之处在于初始化所有必需的静态数据，这个过程可能会因为每个数据结构中的字段数量众多而容易出错。这也是为什么Ilfak建议使用现有的处理器作为您开发任何新处理器的基础的原因之一。
- en: Because of the complexity of these data structures, we will not attempt to enumerate
    every possible field and its uses. Instead, we will highlight the major fields
    and refer you to *idp.hpp* for further details on these and other fields within
    each structure. The order in which we cover various `processor_t` fields bears
    no resemblance to the order in which those fields are declared within `processor_t`.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些数据结构的复杂性，我们不会尝试列举每个可能的字段及其用途。相反，我们将突出显示主要字段，并请您参考`*idp.hpp*`以获取有关这些和其他结构中字段的更多详细信息。我们覆盖各种`processor_t`字段的顺序与这些字段在`processor_t`中声明的顺序没有任何相似之处。
- en: Basic Initialization of the LPH Structure
  id: totrans-1171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LPH结构的基本初始化
- en: Before diving into the behavioral aspects of your processor module, there are
    some static data requirements that you should take care of. As you build a disassembly
    module, you need to create a list of every assembly language mnemonic that you
    intend to recognize for your target processor. This list is created in the form
    of an array of `instruc_t` (defined in *idp.hpp*) structures and is commonly placed
    in a file named *ins.cpp*. As shown here, `instruc_t` is a simple structure whose
    purpose is twofold. First, it provides a table lookup for instruction mnemonics.
    Second, it describes some basic characteristics of each instruction.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨处理器模块的行为方面之前，有一些静态数据需求需要您注意处理。当您构建一个反汇编模块时，您需要创建一个列表，列出您打算为您的目标处理器识别的所有汇编语言助记符。这个列表以`instruc_t`（在`*idp.hpp*`中定义）结构体的数组形式创建，通常放置在一个名为`*ins.cpp*`的文件中。正如这里所示，`instruc_t`是一个简单的结构体，其目的是双重的。首先，它提供了一个用于指令助记符的表格查找。其次，它描述了每个指令的一些基本特性。
- en: '[PRE120]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `feature` field is used to indicate behaviors such as whether the instruction
    reads or writes any of its operands and how execution continues once the instruction
    is executed (default, jump, call). The `CF` in `CF_`*`xxx`* stands for *canonical
    feature*. The `feature` field basically drives the concepts of control flow and
    cross-references. A few of the more interesting canonical feature flags are described
    here:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature`字段用于指示行为，例如指令是否读取或写入其任何操作数，以及指令执行后执行如何继续（默认、跳转、调用）。`CF_`*`xxx`*中的`CF`代表*规范特性*。`feature`字段基本上驱动了控制流和交叉引用的概念。这里描述了一些更有趣的规范特性标志：'
- en: '| **`CF_STOP`** The instruction does not pass control to the following instruction.
    Examples might include absolute jumps or function-return instructions. |'
  id: totrans-1175
  prefs: []
  type: TYPE_TB
  zh: '| **`CF_STOP`** 指令不会将控制权传递给后续指令。示例可能包括绝对跳转或函数返回指令。|'
- en: '| **`CF_CHGn`** The instruction modifies operand `n`, where `n` is in the range
    1..6. |'
  id: totrans-1176
  prefs: []
  type: TYPE_TB
  zh: '| **`CF_CHGn`** 指令修改操作数`n`，其中`n`的范围是1..6。|'
- en: '| **`CF_USEn`** The instruction uses operand `n`, where `n` is in the range
    1..6, and *uses* means “reads” or “refers to” (but does not modify; see `CF_CHGn`)
    a memory location. |'
  id: totrans-1177
  prefs: []
  type: TYPE_TB
  zh: '| **`CF_USEn`** 指令使用操作数 `n`，其中 `n` 在 1..6 的范围内，并且 *使用* 意味着“读取”或“引用”（但不修改；参见
    `CF_CHGn`）一个内存位置。|'
- en: '| **`CF_CALL`** The instruction calls a function. |'
  id: totrans-1178
  prefs: []
  type: TYPE_TB
  zh: '| **`CF_CALL`** 指令调用一个函数。|'
- en: 'Instructions need not be listed in any particular order. In particular, there
    is no need to order instructions according to their associated binary opcodes,
    nor is there any requirement to have a one-to-one correspondence between the instructions
    in this array and valid binary opcodes. The first and last few lines of our example
    instruction array are shown here:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 指令无需按任何特定顺序列出。特别是，没有必要根据它们关联的二元操作码对指令进行排序，也没有要求此数组中的指令与有效的二元操作码之间有一对一对应关系。我们示例指令数组的开头和结尾几行如下所示：
- en: '[PRE121]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In our example, because Python byte code is so simple, we will be maintaining
    a one-to-one correspondence between instructions and byte codes. Note that in
    order to do so, some instruction records must act as filler when an opcode is
    not defined, such as opcode 6 ![](httpatomoreillycomsourcenostarchimages854061.png)
    in this case.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，由于 Python 字节码非常简单，我们将保持指令和字节码之间的一对一对应关系。请注意，为了做到这一点，某些指令记录必须充当填充，当操作码未定义时，例如本例中的操作码
    6 ![httpatomoreillycomsourcenostarchimages854061.png](httpatomoreillycomsourcenostarchimages854061.png)。
- en: 'An associated set of enumerated constants is typically defined in *ins.hpp*
    to provide a mapping from integers to instructions, as shown here:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在 *ins.hpp* 中定义一组枚举常量，以提供从整数到指令的映射，如下所示：
- en: '[PRE122]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Here we have elected to explicitly assign a value to each enum, both for clarity’s
    sake and because there are gaps in our sequence because we have elected to use
    the actual Python opcodes as our instruction indexes. An additional constant has
    also been added (`PYTHON_LAST`) to provide easy reference to the end of the list.
    With a list of instructions and associated integer mapping in hand, we have sufficient
    information to initialize three fields of `LPH` (our global `processor_t`). These
    three fields are described here:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择明确为每个枚举分配一个值，既是为了清晰起见，也因为我们的序列中存在间隙，因为我们选择使用实际的 Python 操作码作为我们的指令索引。还添加了一个额外的常量
    (`PYTHON_LAST`)，以便于引用列表的末尾。有了指令列表及其关联的整数映射，我们就有了足够的信息来初始化 `LPH`（我们的全局 `processor_t`）的三个字段。这三个字段在此处描述：
- en: '[PRE123]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We must initialize these fields with `STOP_CODE`, `PYTHON_LAST`, and `Instructions`,
    respectively. Together these fields enable a processor module to quickly look
    up the mnemonic for any instruction in the disassembly.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须分别用 `STOP_CODE`、`PYTHON_LAST` 和 `Instructions` 初始化这些字段。这些字段共同使处理器模块能够快速查找反汇编中任何指令的助记符。
- en: 'For most processor modules, we also need to define a set of register names
    and an associated set of enumerated constants for referring to them. If we were
    writing an x86 processor module, we might begin with something like the following,
    where for the sake of brevity we restrict ourselves to the basic x86 register
    set:'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数处理器模块，我们还需要定义一组寄存器名称及其关联的枚举常量集，以便引用它们。如果我们正在编写 x86 处理器模块，我们可能从以下内容开始，为了简洁起见，我们限制自己只使用基本的
    x86 寄存器集：
- en: '[PRE124]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The `RegNames` array is often declared in a file named *reg.cpp*. This file
    is also where the sample processor modules declare `LPH`, which enables `RegNames`
    to be declared statically. The associated register enumeration would be declared
    in a header file, usually named after the processor (perhaps *x86.hpp* in this
    case), as follows:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegNames` 数组通常在名为 *reg.cpp* 的文件中声明。此文件也是示例处理器模块声明 `LPH` 的地方，这使得 `RegNames`
    可以静态声明。相关的寄存器枚举将在头文件中声明，通常以处理器命名（例如，在这种情况下可能是 *x86.hpp*），如下所示：'
- en: '[PRE125]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Make certain that you maintain the proper correspondence between the register
    name array and its associated set of constants. Together the register name array
    and the enumerated register constants allow a processor module to quickly look
    up register names when formatting instruction operands. These two data declarations
    are used to initialize additional fields in `LPH`:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在寄存器名称数组和其关联的常量集之间保持适当的对应关系。寄存器名称数组和枚举寄存器常量一起允许处理器模块在格式化指令操作数时快速查找寄存器名称。这两个数据声明用于初始化
    `LPH` 中的额外字段：
- en: '[PRE126]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: These two fields are often initialized with `qnumber(RegNames)` and `RegNames`,
    respectively, where `qnumber` is a macro, defined in *pro.h*, that computes the
    number of elements in a statically allocated array.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字段通常分别用`qnumber(RegNames)`和`RegNames`初始化，其中`qnumber`是一个宏，定义在`*pro.h*`中，用于计算静态分配数组中的元素数量。
- en: 'An IDA processor module is always required to specify information about segment
    registers regardless of whether the actual processor uses segment registers or
    not. Since the x86 utilizes segment registers, the preceding example is fairly
    straightforward to configure. Segment registers are configured in the following
    fields within a `processor_t`:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实际的处理器是否使用段寄存器，IDA处理器模块总是需要指定关于段寄存器的信息。由于x86使用段寄存器，前面的示例配置起来相当直接。段寄存器在`processor_t`的以下字段中进行配置：
- en: '[PRE127]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'To initialize our hypothetical x86 processor module, the previous five fields
    would be initialized, in order, as follows:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化我们的假设x86处理器模块，前五个字段将按顺序初始化如下：
- en: '[PRE128]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Note the comments, ![](httpatomoreillycomsourcenostarchimages854061.png) and
    ![](httpatomoreillycomsourcenostarchimages854063.png), regarding segment registers.
    IDA always wants information about segment registers, even if your processor does
    not use them. Returning to our Python example, we don’t have nearly as much work
    to do in setting up register mappings, since the Python interpreter is a stack-based
    architecture and there are no registers, but we do need to deal with the segment
    register issue. The typical approach for doing so is to make up names and enumerated
    values to represent a minimal set of segment registers (code and data). Basically,
    we are faking the existence of segment registers for no other reason than because
    IDA expects them. However, even though IDA expects them, we are by no means obligated
    to use them, so we simply ignore them in our processor module. For our Python
    processor, we do the following:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于段寄存器的注释，![](httpatomoreillycomsourcenostarchimages854061.png) 和 ![](httpatomoreillycomsourcenostarchimages854063.png)，它们涉及到段寄存器。IDA总是希望获取关于段寄存器的信息，即使你的处理器并不使用它们。回到我们的Python示例，在设置寄存器映射时，我们不需要做太多工作，因为Python解释器是一种基于栈的架构，没有寄存器，但我们确实需要处理段寄存器的问题。通常的做法是为最小的一组段寄存器（代码和数据）创建名称和枚举值。基本上，我们只是在伪造段寄存器的存在，原因仅仅是因为IDA期望它们。然而，尽管IDA期望它们，我们并没有义务使用它们，所以我们只是在我们的处理器模块中忽略它们。对于我们的Python处理器，我们做以下操作：
- en: '[PRE129]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'With these declarations in place, we can return to initialize the appropriate
    fields within `LPH` using the following sequence of values:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些声明就绪后，我们可以使用以下值序列返回并初始化`LPH`结构中的适当字段：
- en: '[PRE130]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Before moving on to the implementation of any behavior in the Python processor,
    we take some time to knock off some remaining low-hanging fruit where initialization
    of the `LPH` structure is concerned. The first five fields of a `processor_t`
    are described here:'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实现Python处理器的任何行为之前，我们花了一些时间来处理一些关于`LPH`结构初始化的剩余低垂果实。这里描述了`processor_t`的前五个字段：
- en: '[PRE131]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `version` field should look familiar, as it is also required in plug-in
    and loader modules. For custom processor modules, the `id` field should be a self-assigned
    value greater than 0x8000\. The `flag` field describes various characteristics
    of the processor module as a combination of `PR_`*`xxx`* flags defined in *idp.hpp*.
    For the Python processor, we choose to specify only `PR_RNAMESOK`, which allows
    register names to be used as location names (which is okay since we have no registers),
    and `PRN_DEC`, which sets the default number display format to decimal. The remaining
    two fields, `cnbits` and `dnbits`, are each set to 8.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`字段应该很熟悉，因为它也要求在插件和加载模块中使用。对于自定义处理器模块，`id`字段应该是一个大于0x8000的自定义值。`flag`字段描述了处理器模块的各种特性，作为在`*idp.hpp*`中定义的`PR_`*`xxx`*标志的组合。对于Python处理器，我们选择指定仅`PR_RNAMESOK`，这允许将寄存器名称用作位置名称（由于我们没有寄存器，这是可以接受的），以及`PRN_DEC`，它将默认数字显示格式设置为十进制。剩余的两个字段`cnbits`和`dnbits`分别设置为8。'
- en: The Analyzer
  id: totrans-1205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析器
- en: 'At this point we have filled in enough of the `LPH` structure that we can begin
    thinking about the first portion of a processor module that will execute—the analyzer.
    In the example processor modules, the analyzer is typically implemented by a function
    named `ana` (you may name it anything you like) in a file named *ana.cpp*. The
    prototype for this function is very simple, as shown here:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经填充了足够的`LPH`结构，可以开始考虑处理器模块的第一个部分，即执行器——分析器。在示例处理器模块中，分析器通常通过一个名为`ana`（你可以取任何你喜欢的名字）的函数在名为*ana.cpp*的文件中实现。这个函数的原型非常简单，如下所示：
- en: '[PRE132]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You must initialize the `u_ana` member of the `LPH` object with a pointer to
    your analyzer function. The analyzer’s job is to analyze a single instruction,
    populate the global variable `cmd` with information about the instruction, and
    return the length of the instruction. The analyzer should not make any changes
    to the database.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用指向你的分析器函数的指针初始化`LPH`对象的`u_ana`成员。分析器的任务是分析一条指令，将有关指令的信息填充到全局变量`cmd`中，并返回指令的长度。分析器不应对数据库进行任何更改。
- en: 'The `cmd` variable is a global instance of an `insn_t` object. The `insn_t`
    class, defined in *ua.hpp*, is used to describe a single instruction in the database.
    Its declaration is shown here:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd`变量是一个`insn_t`对象的全局实例。`insn_t`类在*ua.hpp*中定义，用于描述数据库中的单条指令。其声明如下所示：'
- en: '[PRE133]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Prior to calling your analyzer function, the IDA kernel (the core of IDA) fills
    in the first three fields of the `cmd` object with the segmented and linear address
    of the instruction. After that, it is the analyzer’s job to fill in the rest.
    The essential fields for the analyzer to fill in are `itype` ![](httpatomoreillycomsourcenostarchimages854061.png),
    `size` ![](httpatomoreillycomsourcenostarchimages854063.png), and `Operands` ![](httpatomoreillycomsourcenostarchimages854093.png).
    The `itype` field must be set to one of the enumerated instruction type values
    discussed previously. The `size` field must be set to the total size of the instruction
    (in bytes) and should be used as the return value of the instruction. If the instruction
    cannot be parsed, the analyzer should return a size of zero. Finally, an instruction
    may have up to six operands, and the analyzer should fill in information about
    each operand used by the instruction.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用你的分析器函数之前，IDA内核（IDA的核心）将`cmd`对象的前三个字段填充为指令的分段和线性地址。之后，填充其余部分就是分析器的任务。分析器需要填充的基本字段是`itype`
    ![httpatomoreillycomsourcenostarchimages854061.png]，`size` ![httpatomoreillycomsourcenostarchimages854063.png]，和`Operands`
    ![httpatomoreillycomsourcenostarchimages854093.png]。`itype`字段必须设置为之前讨论过的枚举指令类型值之一。`size`字段必须设置为指令的总大小（以字节为单位），并应作为指令的返回值使用。如果指令无法解析，分析器应返回大小为零。最后，一条指令可能有最多六个操作数，分析器应填写指令使用的每个操作数的信息。
- en: 'The analyzer function is often implemented using a switch statement. The first
    step in the analyzer is typically to request one or more (depending on the processor)
    bytes from the instruction stream and use those bytes as the switch test variable.
    The SDK offers special functions for use in the analyzer for the purpose of retrieving
    bytes from the instruction stream. These functions are shown here:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器函数通常使用switch语句实现。分析器的第一步通常是请求一个或多个（取决于处理器）字节从指令流中，并使用这些字节作为switch测试变量。SDK为分析器提供了特殊函数，用于从指令流中检索字节。这些函数如下所示：
- en: '[PRE134]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The `current instruction location` is initially the same value contained in
    *cmd.ip*. Each call to one of the `ua_next_`*`xxx`* functions has the side effect
    of incrementing `cmd.size` according to the number of bytes requested by the `ua_next_`*`xxx`*
    function being called (1, 2, 4, or 8). The retrieved bytes must be decoded enough
    to assign the appropriate instruction type enumerated value into the `itype` field,
    determine the number and type of any operands required by the instruction, and
    then determine the overall length of the instruction. As the decoding process
    progresses, additional instruction bytes may be required until a complete instruction
    has been retrieved from the instruction stream. As long as you utilize the `ua_next_`*`xxx`*
    function, `cmd.size` will be updated automatically for you, eliminating the need
    to keep track of the number of bytes you have requested for a given instruction.
    From a high-level perspective, the analyzer somewhat mimics the instruction fetch
    and instruction decode phases employed in real CPUs. Mirroring real life, instruction
    decoding tends to be easier for processors with fixed instruction sizes, as is
    often the case with RISC-style architectures, while instruction decoding tends
    to be more complicated for processors that use variable-length instructions, such
    as the x86.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '`当前指令位置`最初与*cmd.ip*中包含的值相同。对`ua_next_`*`xxx`*函数之一的每次调用都会产生副作用，根据被调用的`ua_next_`*`xxx`*函数请求的字节数（1、2、4或8）增加`cmd.size`。检索到的字节必须解码足够，以便将适当的指令类型枚举值分配到`itype`字段，确定指令所需的操作数数量和类型，然后确定指令的总长度。随着解码过程的进行，可能需要额外的指令字节，直到从指令流中检索到完整的指令。只要您使用`ua_next_`*`xxx`*函数，`cmd.size`将自动为您更新，从而消除跟踪给定指令请求的字节数的需要。从高层次的角度来看，分析器在某种程度上模仿了真实CPU中使用的指令获取和指令解码阶段。与现实生活相呼应，对于具有固定指令大小的处理器，指令解码通常更容易，如RISC风格的架构通常那样，而对于使用可变长度指令的处理器，如x86，指令解码通常更复杂。'
- en: 'Using the retrieved bytes, the analyzer must initialize one element in the
    `cmd.Operands` array for each operand used by the instruction. Instruction operands
    are represented using instances of the `op_t` class, which is defined in *ua.hpp*
    and summarized here:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用检索到的字节，分析器必须为指令使用的每个操作数在`cmd.Operands`数组中初始化一个元素。指令操作数使用`op_t`类的实例表示，该类在*ua.hpp*中定义，并在下面进行总结：
- en: '[PRE135]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Configuring an operand begins with setting the operand’s `type` field to one
    of the enumerated `optype_t` constants defined in *ua.hpp*. An operand’s `type`
    describes the source or destination of the operand data. In other words, the `type`
    field roughly describes the addressing mode employed to access the operand. Examples
    of operand types include `o_reg`, which means that the operand is the content
    of a register; `o_mem`, which means the operand is a memory address known at compile
    time; and `o_imm`, which means that the operand is immediate data contained within
    the instruction.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 配置操作数从将操作数的`type`字段设置为*ua.hpp*中定义的枚举`optype_t`常量之一开始。操作数的`type`描述了操作数数据的源或目的地。换句话说，`type`字段大致描述了用于访问操作数的寻址模式。操作数类型的示例包括`o_reg`，表示操作数是寄存器的内容；`o_mem`，表示操作数是编译时已知的内存地址；以及`o_imm`，表示操作数是包含在指令中的立即数据。
- en: The `dtype` field specifies the size of the operand data. This field should
    be set to one of the `dt_`*`xxx`* values specified in *ua.hpp*. Example values
    include `dt_byte` for 8-bit data, `dt_word` for 16-bit data, and `dt_dword` for
    32-bit data.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype`字段指定操作数数据的大小。此字段应设置为*ua.hpp*中指定的`dt_`*`xxx`*值之一。示例值包括`dt_byte`用于8位数据，`dt_word`用于16位数据，以及`dt_dword`用于32位数据。'
- en: 'The following x86 instructions demonstrate the correspondence of some of the
    primary operand datatypes to commonly used operands:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下x86指令演示了一些主要操作数数据类型与常用操作数的对应关系：
- en: '[PRE136]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The manner in which the various unions within an `op_t` are used is dictated
    by the value of the `type` field. For example, when an operand is type `o_imm`,
    the immediate data value should be stored into the `value` field, and when the
    operand type is `o_reg`, the register number (from the enumerated set of register
    constants) should be stored into the `reg` field. Complete details on where to
    store each piece of an instruction are contained in *ua.hpp*.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`op_t`结构体内部，各种联合的使用方式由`type`字段的值决定。例如，当操作数类型为`o_imm`时，立即数据值应存储到`value`字段中，而当操作数类型为`o_reg`时，应将寄存器号（来自寄存器常数的枚举集合）存储到`reg`字段中。关于如何存储指令中每一部分的详细信息包含在`ua.hpp`中。
- en: Note that none of the fields within an `op_t` describe whether the operand is
    being used as a source or a destination for data. In fact, it is not the analyzer’s
    job to determine such things. The canonical flags specified in the instruction
    names array are used in a later stage in the processor to determine exactly how
    an operand is being used.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`op_t`结构体内的任何字段都不描述操作数是作为数据源还是目标使用。实际上，这不是分析器的职责。在指令名称数组中指定的规范标志在处理器的一个后续阶段被用来确定操作数的确切使用方式。
- en: Several of the fields within both the `insn_t` class and the `op_t` class are
    described as *processor dependent*, which means that you may use those fields
    for any purpose you wish. Such fields are often used for storing information that
    does not fit neatly into one of the other fields within these classes. The processor-dependent
    fields are also a convenient mechanism for passing information along to later
    stages of the processor so that those stages do not need to replicate the work
    of the analyzer.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`insn_t`类和`op_t`类内部，有几个字段被描述为*处理器相关*，这意味着你可以根据需要使用这些字段。这些字段通常用于存储不适合放入这些类中其他字段的信息。处理器相关的字段也是将信息传递到处理器后续阶段的便捷机制，这样那些阶段就不需要重复分析器的工作。
- en: 'With all of the ground rules for an analyzer covered, we can take a stab at
    crafting a minimal analyzer for Python byte code. Python byte code is very straightforward.
    Python opcodes are 1 byte long. Opcodes less than 90 have no operands, while opcodes
    greater than or equal to 90 each have a 2-byte operand. Our basic analyzer is
    shown here:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了分析器的所有基本规则之后，我们可以尝试为Python字节码编写一个最小化的分析器。Python字节码非常直接。Python操作码是1字节长。小于90的操作码没有操作数，而大于或等于90的操作码每个都有2字节的操作数。我们的基本分析器如下所示：
- en: '[PRE137]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'For the Python processor module, we have elected to create an additional array
    of flags, one per instruction, used to supplement (and in some cases replicate)
    the canonical features of each instruction. The `HAS_JREL`, `HAS_JABS`, and `HAS_CALL`
    flags were defined for use in our `flags` array. We use these flags to indicate
    whether an instruction operand represents a relative jump offset, an absolute
    jump target, or the description of a function call stack, respectively. Explaining
    every detail of the analysis phase is difficult without descending into the operation
    of the Python interpreter, so we summarize the analyzer here and through comments
    in the preceding code, remembering that the analyzer’s job is to dissect a single
    instruction:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python处理器模块，我们选择创建一个额外的标志数组，每个指令一个标志，用于补充（在某些情况下复制）每个指令的规范特性。`HAS_JREL`、`HAS_JABS`和`HAS_CALL`标志被定义用于我们的`flags`数组。我们使用这些标志来指示指令操作数是否代表相对跳转偏移、绝对跳转目标或函数调用栈的描述。如果不深入Python解释器的操作，解释分析阶段的每个细节都很困难，所以我们在这里总结分析器，并通过前述代码中的注释来记住，分析器的任务是解析单个指令：
- en: The analyzer gets the next instruction byte from the instruction stream and
    determines whether the byte is a valid Python opcode.
  id: totrans-1227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析器从指令流中获取下一个指令字节，并确定该字节是否是有效的Python操作码。
- en: If the instruction has no operands, `cmd.Operand[0]` (`cmd.Op1`) is initialized
    to `o_void`.
  id: totrans-1228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指令没有操作数，`cmd.Operand[0]`（`cmd.Op1`）被初始化为`o_void`。
- en: If the command has an operand, `cmd.Operand[0]` is initialized to reflect the
    type of the operand. Several processor-specific fields are used to carry information
    forward to later stages in the processor module.
  id: totrans-1229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果命令有操作数，`cmd.Operand[0]`会被初始化以反映操作数的类型。一些处理器特定的字段被用来将信息传递到处理器模块的后续阶段。
- en: The length of the instruction is returned to the caller.
  id: totrans-1230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指令的长度被返回给调用者。
- en: 'More sophisticated instruction sets are almost certain to require more complex
    analyzer stages. Overall, however, any analyzer’s behavior may be generalized
    as follows:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的指令集几乎肯定需要更复杂的分析阶段。然而，任何分析器的行为可以概括如下：
- en: Read enough bytes from the instruction stream to determine whether the instruction
    is valid and to map the instruction to one of the enumerated instruction type
    constants, which is then saved in `cmd.itype`. This operation is often performed
    using a large switch statement to categorize instruction opcodes.
  id: totrans-1232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从指令流中读取足够的字节以确定指令是否有效，并将指令映射到枚举的指令类型常量之一，然后将其保存到`cmd.itype`中。此操作通常通过一个大的switch语句来分类指令操作码。
- en: Read any additional bytes required to properly determine the number of operands
    required by the instruction, the addressing modes in use by those operands, and
    the individual components of each operand (registers and immediate data). This
    data is used to populate elements of the `cmd.Operands` array. This operation
    may be factored into a separate operand-decoding function.
  id: totrans-1233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取任何额外的字节，以正确确定指令所需的操作数数量、这些操作数使用的寻址模式以及每个操作数的各个组成部分（寄存器和立即数据）。这些数据用于填充`cmd.Operands`数组中的元素。此操作可以分解为一个单独的操作数解码函数。
- en: Return the total length of the instruction and its operands.
  id: totrans-1234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回指令及其操作数的总长度。
- en: Strictly speaking, once an instruction has been dissected, IDA has enough information
    to generate an assembly language representation of that instruction. In order
    to generate cross-references, facilitate the recursive descent process, and monitor
    the behavior of the program stack pointer, IDA must obtain additional details
    about the behavior of each instruction. This is the job of the emulator stage
    of an IDA processor module.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，一旦指令被分解，IDA就有足够的信息来生成该指令的汇编语言表示。为了生成交叉引用、方便递归下降过程以及监控程序栈指针的行为，IDA必须获取关于每个指令行为的额外细节。这是IDA处理器模块的模拟阶段的工作。
- en: The Emulator
  id: totrans-1236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器
- en: 'Whereas the analyzer stage is concerned with the structure of a single instruction,
    the emulator stage is concerned with the behavior of a single instruction. In
    IDA example processor modules, the emulator is typically implemented by a function
    named `emu` (you may name it anything you like) in a file named *emu.cpp*. Like
    the `ana` function, the prototype for this function is very simple, as shown here:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 而分析阶段关注的是单个指令的结构，模拟阶段关注的是单个指令的行为。在IDA示例处理器模块中，模拟器通常通过一个名为`emu`（你可以取任何你喜欢的名字）的函数在名为`emu.cpp`的文件中实现。与`ana`函数一样，此函数的原型非常简单，如下所示：
- en: '[PRE138]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: According to *idp.hpp*, the `emu` function is supposed to return the length
    of the instruction that was emulated; however, the majority of sample emulators
    seem to return the value 1.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`idp.hpp`，`emu`函数应该返回被模拟指令的长度；然而，大多数示例模拟器似乎返回值1。
- en: You must initialize the `u_emu` member of the `LPH` object with a pointer to
    your emulator function. By the time `emu` is called, `cmd` has been initialized
    by the analyzer. The emulator’s primary purpose is to create code and data cross-references
    based on the behavior of the instruction described by `cmd`. The emulator is also
    the place to keep track of any changes to the stack pointer and create local variables
    based on observed access to a function’s stack frame. Unlike the analyzer, the
    emulator may change the database.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用指向你的模拟器函数的指针初始化`LPH`对象的`u_emu`成员。在调用`emu`之前，`cmd`已经被分析器初始化。模拟器的主要目的是根据`cmd`描述的指令行为创建代码和数据交叉引用。模拟器也是跟踪栈指针变化并基于观察到的对函数栈帧的访问创建局部变量的地方。与分析器不同，模拟器可以更改数据库。
- en: 'Determining whether an instruction results in the creation of any cross-references
    is typically done by examining the instruction’s canonical features in conjunction
    with the `type` field of the instruction’s operands. A very basic emulator function
    for an instruction set whose instructions may take up to two operands, which is
    representative of many of the SDK examples, is shown here:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查指令的规范特征以及指令操作数的`type`字段来确定指令是否导致创建任何交叉引用，通常是通过检查指令的规范特征以及指令操作数的`type`字段来完成的。以下是一个具有最多两个操作数的指令集的非常基本的模拟器函数示例，这代表了许多SDK示例：
- en: '[PRE139]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: For each instruction operand, the preceding function examines the instruction’s
    canonical features to determine whether a cross-reference of any kind should be
    generated. In this example, a function named `TouchArg` examines a single operand
    to determine what type of cross-reference should be generated and handles the
    details of generating the correct cross-reference. When generating cross-references
    from your emulator, you should use the cross-reference-creation functions declared
    in *ua.hpp* rather than in *xref.hpp*. The following rough guidelines may be used
    in determining what type of cross-references to generate.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个指令操作数，前一个函数会检查指令的规范特征以确定是否应生成任何类型的交叉引用。在这个例子中，一个名为 `TouchArg` 的函数检查单个操作数以确定应生成哪种类型的交叉引用，并处理生成正确交叉引用的细节。当从仿真器生成交叉引用时，应使用在
    *ua.hpp* 中声明的交叉引用创建函数，而不是在 *xref.hpp* 中。以下粗略指南可用于确定要生成哪种类型的交叉引用。
- en: If the operand type is `o_imm`, the operation is a read (`isRead` is true),
    and the operand value is a pointer, create an offset reference. Determine whether
    an operand is a pointer by calling the `isOff` function, for example, `isOff(uFlag,
    op.n)`. Add an offset cross-reference using `ua_add_off_drefs`, for example, `ua_add_off_drefs(op,
    dr_O);`.
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作数类型是 `o_imm`，操作是读取（`isRead` 为真），并且操作数值是一个指针，则创建一个偏移量引用。通过调用 `isOff` 函数（例如，`isOff(uFlag,
    op.n)`）来确定操作数是否为指针。使用 `ua_add_off_drefs`（例如，`ua_add_off_drefs(op, dr_O);`）添加偏移量交叉引用。
- en: 'If the operand type is `o_displ` and the operand value is a pointer, create
    an offset cross-reference with a read or write cross-reference type as appropriate,
    for example, `ua_add_off_drefs(op, isRead ? dr_R : dr_W);`.'
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果操作数类型是 `o_displ` 并且操作数值是一个指针，则创建一个适当的读取或写入交叉引用类型的偏移量交叉引用，例如，`ua_add_off_drefs(op,
    isRead ? dr_R : dr_W);`。'
- en: 'If the operand type is `o_mem`, add a data cross-reference with a read or write
    cross-reference type as appropriate using `ua_add_dref`, for example, `ua_add_dref(op.offb,
    op.addr, isRead ? dr_R : dr_W);`.'
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果操作数类型是 `o_mem`，则使用 `ua_add_dref`（例如，`ua_add_dref(op.offb, op.addr, isRead
    ? dr_R : dr_W);`）添加适当的数据交叉引用，类型为读取或写入交叉引用。'
- en: 'If the operand type is `o_near`, add a code cross-reference with a jump or
    call cross-reference type as appropriate using `ua_add_cref`, for example, `ua_add_cref(op.offb,
    op.addr, feature & CF_CALL ? fl_CN : fl_JN);`.'
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果操作数类型是 `o_near`，则使用 `ua_add_cref`（例如，`ua_add_cref(op.offb, op.addr, feature
    & CF_CALL ? fl_CN : fl_JN);`）添加适当的代码交叉引用，类型为跳转或调用交叉引用。'
- en: 'The emulator is also responsible for reporting on the behavior of the stack
    pointer register. The emulator should use the `add_auto_stkpnt2` function to inform
    IDA that an instruction changed the value of the stack pointer. The prototype
    for `add_auto_stkpnt2` is shown here:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真器还负责报告栈指针寄存器的行为。仿真器应使用 `add_auto_stkpnt2` 函数通知 IDA 指令已更改栈指针的值。`add_auto_stkpnt2`
    的原型如下所示：
- en: '[PRE140]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `pfn` pointer should point to the function that contains the address being
    emulated. If `pfn` is NULL, it will be automatically determined by IDA. The `ea`
    parameter should specify the end address (typically `cmd.ea + cmd.size`) for the
    instruction that changes the stack pointer. The `delta` parameter is used to specify
    the number of bytes by which the stack pointer grows or shrinks. Use negative
    deltas when the stack is growing (such as after a `push` instruction) and positive
    deltas when the stack is shrinking (such as after a `pop` instruction). A simple
    4-byte adjustment to the stack pointer in conjunction with a `push` operation
    might be emulated as follows:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '`pfn` 指针应指向包含被仿真地址的函数。如果 `pfn` 为 NULL，IDA 将自动确定。`ea` 参数应指定改变栈指针的指令的结束地址（通常是
    `cmd.ea + cmd.size`）。`delta` 参数用于指定栈指针增长或缩小的字节数。当栈增长（例如在 `push` 指令之后）时使用负 delta，当栈缩小（例如在
    `pop` 指令之后）时使用正 delta。对栈指针进行简单的 4 字节调整并结合 `push` 操作可能仿真如下：'
- en: '[PRE141]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In order to maintain an accurate record of stack pointer behavior, the emulator
    should be able to recognize and emulate all instructions that change the stack
    pointer, not just the simple `push` and `pop` cases. A more complex example of
    tracking the stack pointer occurs when a function allocates its local variables
    by subtracting a constant value from the stack pointer. This case is illustrated
    here:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持栈指针行为的准确记录，仿真器应能够识别和仿真所有改变栈指针的指令，而不仅仅是简单的 `push` 和 `pop` 情况。跟踪栈指针的更复杂示例发生在函数通过从栈指针减去一个常数值来分配其局部变量时。此情况如下所示：
- en: '[PRE142]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Because CPU architectures vary significantly from one CPU to another, it is
    not possible for IDA (or any other program for that matter) to account for every
    possible way that an operand may be formed or every way that an instruction may
    reference other instructions or data. As a result, there is no precise cookbook
    recipe for building your emulator module. Reading through existing processor module
    source code along with a lot of trial and error may be required before your emulator
    does everything you want it to do.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CPU架构在各个CPU之间差异很大，IDA（或任何其他程序）都无法考虑操作数可能形成的所有可能方式或指令可能引用其他指令或数据的所有方式。因此，没有精确的烹饪配方来构建你的模拟器模块。在模拟器能够完成你想要的所有功能之前，你可能需要阅读现有的处理器模块源代码，并进行大量的尝试和错误。
- en: 'The emulator for our example Python processor is shown here:'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了我们示例Python处理器的模拟器：
- en: '[PRE143]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Again, owing to the architecture of the Python interpreter, we are severely
    limited in the types of cross-references that we can generate. In Python byte
    code, there is no concept of a memory address for data items, and the absolute
    address of each instruction can be determined only by parsing metainformation
    contained in the compiled Python (*.pyc*) file. Data items are either stored in
    tables and referenced by index values or they are stored on the program stack,
    where they cannot be directly referenced. Here again, while we can directly read
    data item index values from instruction operands, we cannot know the structure
    of the tables that hold the data unless we have parsed additional metainformation
    contained in the *.pyc* file. In our processor, we can compute only the target
    of relative jump instructions and the address of the next instruction because
    they are located relative to the current instruction address. The fact that our
    processor can provide a better disassembly only if it has a more detailed understanding
    of the file structure is a limitation that we discuss in [Processor Module Architecture](ch19s06.html
    "Processor Module Architecture") in [Processor Module Architecture](ch19s06.html
    "Processor Module Architecture").
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于Python解释器的架构，我们在生成交叉引用的类型上受到严重限制。在Python字节码中，没有数据项的内存地址的概念，每个指令的绝对地址只能通过解析编译的Python
    (*.pyc*) 文件中包含的元信息来确定。数据项要么存储在表中并通过索引值引用，要么存储在程序栈上，它们不能被直接引用。在这里，虽然我们可以直接从指令操作数中读取数据项索引值，但我们除非解析了包含在*.pyc*文件中的附加元信息，否则无法知道包含数据的表的结构。在我们的处理器中，我们只能计算相对跳转指令的目标和下一条指令的地址，因为它们位于当前指令地址的相对位置。我们的处理器只有在它对文件结构有更详细的理解时才能提供更好的反汇编，这是一个我们在[处理器模块架构](ch19s06.html
    "处理器模块架构")中讨论的限制，见[处理器模块架构](ch19s06.html "处理器模块架构")。
- en: For similar reasons, we have elected not to track the stack pointer’s behavior
    in our Python processor. This is primarily because IDA treats stack pointer changes
    as relevant only when those changes are made within the confines of a function
    and we have no means at present for recognizing function boundaries within Python
    code. If we were to implement stack-pointer tracking, it would be wise to remember
    that, as a stack-based architecture, virtually every Python instruction modifies
    the stack in some way. In this case, to simplify the process of determining how
    much the stack pointer is changed by each instruction, it might be easier to define
    an array of values, one per Python instruction, that contains the amount by which
    each instruction modifies the stack. These amounts would then be used in calls
    to `add_auto_stkpnt2` each time an instruction is emulated.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类似的原因，我们选择不在我们的Python处理器中跟踪栈指针的行为。这主要是因为IDA将栈指针的变化视为仅在函数内部进行时才相关，而我们目前没有在Python代码中识别函数边界的手段。如果我们实施栈指针跟踪，明智的做法是记住，作为一个基于栈的架构，几乎每条Python指令都会以某种方式修改栈。在这种情况下，为了简化确定每条指令修改栈指针多少的过程，可能更容易定义一个包含每个Python指令修改栈的数量的数组，每个指令一个值。这些数量将在每次模拟指令时调用`add_auto_stkpnt2`时使用。
- en: Once the emulator has added all of the cross-references that it can and made
    any other modifications to the database that it deems necessary, you are ready
    to start generating output. In the following section, we discuss the role of the
    outputter in generating IDA’s disassembly display.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模拟器添加了它能添加的所有交叉引用，并对数据库进行了它认为必要的任何其他修改，你就可以开始生成输出。在下一节中，我们将讨论输出器在生成IDA反汇编显示中的作用。
- en: The Outputter
  id: totrans-1260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出器
- en: 'The purpose of the outputter is to output a single disassembled instruction,
    as specified by the `cmd` global variable, to the IDA display. In IDA processor
    modules, the outputter is typically implemented by a function named `out` (you
    may name it anything you like) in a file named *out.cpp*. Like the `ana` and `emu`
    functions, the prototype for this function is very simple, as shown here:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 输出器的作用是将由 `cmd` 全局变量指定的单个反汇编指令输出到 IDA 显示。在 IDA 处理器模块中，输出器通常通过一个名为 `out`（您可以将其命名为任何您喜欢的名称）的函数在名为
    *out.cpp* 的文件中实现。像 `ana` 和 `emu` 函数一样，此函数的原型非常简单，如下所示：
- en: '[PRE144]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: You must initialize the `u_out` member of the `LPH` object with a pointer to
    your output function. By the time `out` is called, `cmd` has been initialized
    by the analyzer. Your output function should not make any changes to the database.
    You are also required to create a helper function whose sole purpose is to format
    and output a single instruction operand. This function is typically named `outop`
    and is pointed to by the `u_outop` member of `LPH`. Your `out` function should
    not call `outop` directly. Instead, you should call `out_one_operand` each time
    you need to print an operand portion of your disassembly lines. Data output operations
    are handled by a separate function typically named *`cpu`*`_data` and specified
    by the `d_out` member field of the `LPH` object. In our Python processor, this
    function is named `python_data`.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用指向您的输出函数的指针初始化 `LPH` 对象的 `u_out` 成员。在 `out` 被调用之前，`cmd` 已由分析器初始化。您的输出函数不应更改数据库。您还必须创建一个辅助函数，其唯一目的是格式化和输出单个指令操作数。此函数通常命名为
    `outop`，并由 `LPH` 的 `u_outop` 成员指向。您的 `out` 函数不应直接调用 `outop`。相反，每次您需要打印反汇编行的操作数部分时，您应调用
    `out_one_operand`。数据输出操作由一个单独的函数处理，该函数通常命名为 *`cpu`*`_data`，并由 `LPH` 对象的 `d_out`
    成员字段指定。在我们的 Python 处理器中，此函数名为 `python_data`。
- en: 'Output lines in a disassembly listing are composed of several components, such
    as a prefix, a name label, a mnemonic, operands, and possibly a comment. The IDA
    kernel retains responsibility for rendering some of these components (such as
    prefixes, comments, and cross-references), while others are the responsibility
    of the processor’s outputter. Several useful functions for generating pieces of
    an output line are declared in *ua.hpp* under the following heading:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编列表中的输出行由多个组件组成，例如前缀、名称标签、助记符、操作数以及可能的注释。IDA 内核保留渲染这些组件（如前缀、注释和交叉引用）的责任，而其他组件则是处理器输出器的责任。在
    *ua.hpp* 中声明了以下标题下的几个用于生成输出行片段的有用函数：
- en: '[PRE145]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Colorizing portions of each output line is possible through the use of functions
    that insert special color tags into your output buffers. Additional functions
    for generating output lines may be found in *lines.hpp*.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用插入特殊颜色标签到输出缓冲区的函数，可以给每行输出着色。可以在 *lines.hpp* 中找到用于生成输出行的附加函数。
- en: 'Rather than use a console-style output model in which you write content directly
    to the IDA display, IDA utilizes a buffer-based output scheme in which you must
    write a single line of display text into a character buffer and then ask IDA to
    display your buffer. The basic process for generating an output line follows:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接写入 IDA 显示的基于控制台风格的输出模型不同，IDA 使用基于缓冲区的输出方案，您必须将单行显示文本写入字符缓冲区，然后请求 IDA 显示您的缓冲区。生成输出行的基本过程如下：
- en: Call `init_output_buffer(char *buf, size_t bufsize)` (declared in *ua.hpp*)
    to initialize your output buffer.
  id: totrans-1268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `init_output_buffer(char *buf, size_t bufsize)`（在 *ua.hpp* 中声明）以初始化您的输出缓冲区。
- en: Utilize the buffer output functions in *ua.hpp* to generate a single line of
    content by adding to the initialized buffer. Most of these functions automatically
    write to the destination buffer specified in the previous step, so there is often
    no need to explicitly pass a buffer into these functions. These functions are
    typically named `out_`*`xxx`* or `Out`*`Xxx`*.
  id: totrans-1269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *ua.hpp* 中的缓冲区输出函数，通过向初始化的缓冲区添加内容来生成单行内容。这些函数中的大多数会自动将内容写入之前步骤中指定的目标缓冲区，因此通常不需要显式将这些函数传递一个缓冲区。这些函数通常命名为
    `out_`*`xxx`* 或 `Out`*`Xxx`*。
- en: Call `term_output_buffer()` to finalize your output buffer, making it ready
    to send to the IDA kernel for display.
  id: totrans-1270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `term_output_buffer()` 来最终化您的输出缓冲区，使其准备好发送到 IDA 内核进行显示。
- en: Send the output buffer to the kernel using either `MakeLine` or `printf_line`
    (both declared in *lines.hpp*).
  id: totrans-1271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MakeLine` 或 `printf_line`（两者均在 *lines.hpp* 中声明）将输出缓冲区发送到内核。
- en: Note that `init_output_buffer`, `term_output_buffer`, and `MakeLine` are usually
    called only within your `out` function. Your `outop` function typically makes
    use of the current output buffer as initialized by `out` and usually has no need
    to initialize its own output buffers.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`init_output_buffer`、`term_output_buffer` 和 `MakeLine` 通常仅在您的 `out` 函数内部调用。您的
    `outop` 函数通常利用由 `out` 初始化的当前输出缓冲区，并且通常不需要初始化自己的输出缓冲区。
- en: 'Strictly speaking, you can skip all of the buffer manipulation described in
    the first four steps of the preceding list and go straight to calling `MakeLine`
    as long as you don’t mind taking complete control of the buffer-generation process
    and passing up the convenience functions offered in *ua.hpp*. In addition to assuming
    a default destination for generated output (as specified via `init_out_buffer`),
    many of the convenience functions automatically work with the current contents
    of the `cmd` variable. Some of the more useful convenience functions from *ua.hpp*
    are described here:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，您可以直接跳过前面列表中的前四个步骤中描述的所有缓冲区操作，直接调用 `MakeLine`，只要您不介意完全控制缓冲区生成过程并放弃 *ua.hpp*
    中提供的便利函数。除了假设生成的输出有默认目的地（通过 `init_out_buffer` 指定）外，许多便利函数会自动与 `cmd` 变量的当前内容一起工作。以下是一些
    *ua.hpp* 中更有用的便利函数的描述：
- en: '**`OutMnem(int width, char *suffix)`**'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '**`OutMnem(int width, char *suffix)`**'
- en: 'Outputs the mnemonic that corresponds to `cmd.itype` in a field of at least
    `width` characters, appending the specified suffix. At least one space is printed
    after the mnemonic. The default width is 8, and the default suffix is NULL. An
    example of the use of the suffix value might be for operand size modifiers, as
    in the following x86 mnemonics: `movsb`, `movsw`, `movsd`.'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 在至少 `width` 个字符的区域内输出与 `cmd.itype` 对应的助记符，并追加指定的后缀。助记符后至少打印一个空格。默认宽度为 8，默认后缀为
    NULL。后缀值的使用示例可能包括操作数大小修饰符，如下面的 x86 助记符所示：`movsb`、`movsw`、`movsd`。
- en: '**`out_one_operand(int n)`**'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '**`out_one_operand(int n)`**'
- en: Invokes your processor’s `outop` function to print `cmd.Operands[n]`.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 调用处理器中的 `outop` 函数以打印 `cmd.Operands[n]`。
- en: '**`out_snprintf(const char *format, ...)`**'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '**`out_snprintf(const char *format, ...)`**'
- en: Appends formatted text to the current output buffer.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 将格式化文本追加到当前输出缓冲区。
- en: '**`OutValue(op_t &op, int outflags)`**'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '**`OutValue(op_t &op, int outflags)`**'
- en: Outputs constant fields of an operand. This function outputs `op.value` or `op.addr`,
    depending on the value of `outflags`. See *ua.hpp* for the meaning of `outflags`,
    which defaults to 0\. This function is meant to be called from within `outop`.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 输出操作数的常量字段。此函数输出 `op.value` 或 `op.addr`，具体取决于 `outflags` 的值。有关 `outflags` 的含义，请参阅
    *ua.hpp*，默认值为 0。此函数旨在在 `outop` 内部调用。
- en: '**`out_symbol(char c)`**'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '**`out_symbol(char c)`**'
- en: Outputs the given character using the current color for punctuation (`COLOR_SYMBOL`
    as defined in *lines.hpp*). This function is primarily used for outputting the
    syntactic elements within operands (thus called from `outop`), such as commas
    and brackets.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前颜色（`COLOR_SYMBOL`，如 *lines.hpp* 中定义）输出给定的字符。此函数主要用于输出操作数内的语法元素（因此从 `outop`
    调用），例如逗号和括号。
- en: '**`out_line(char *str, color_t color)`**'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '**`out_line(char *str, color_t color)`**'
- en: Appends the given string, in the given `color`, to the current output buffer.
    Colors are defined in *lines.hpp*. Note that this function does not output a line
    at all. A better name for this function might be `out_str`.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定字符串，在给定 `color` 中，追加到当前输出缓冲区。颜色在 *lines.hpp* 中定义。请注意，此函数根本不会输出一行。此函数可能更好的名称是
    `out_str`。
- en: '**`OutLine(char *str)`**'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '**`OutLine(char *str)`**'
- en: Same as `out_line` but without the use of color.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `out_line` 相同，但不使用颜色。
- en: '**`out_register(char *str)`**'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '**`out_register(char *str)`**'
- en: Outputs the given string using the current color for registers (`COLOR_REG`).
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前颜色（`COLOR_REG`）输出给定的字符串。
- en: '**`out_tagon(color_t tag)`**'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '**`out_tagon(color_t tag)`**'
- en: Inserts a *turn color on* tag into the output buffer. Subsequent output to the
    buffer will be displayed in the given color until a *turn color off* tag is encountered.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出缓冲区中插入一个 *开启颜色* 标签。直到遇到 *关闭颜色* 标签，后续输出到缓冲区的文本将显示为指定的颜色。
- en: '**`out_tagoff(color_t tag)`**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '**`out_tagoff(color_t tag)`**'
- en: Inserts a *turn color off* tag into the output buffer.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出缓冲区中插入一个 *关闭颜色* 标签。
- en: Please refer to *ua.hpp* for additional output functions that may be of use
    in building your outputter.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *ua.hpp* 了解可能对构建输出器有用的其他输出函数。
- en: 'One output capability that is missing from *ua.hpp* is the ability to easily
    output a register name. During the analysis phase, register numbers are stored
    into an operand’s `reg` or `phrase` field, depending on the addressing mode used
    for that operand. Since many operands make use of registers, it would be nice
    to have a function that quickly outputs a register string given a register number.
    The following function provides a minimal capability to do so:'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '*ua.hpp*中缺少的一个输出功能是轻松输出寄存器名称。在分析阶段，寄存器号存储在操作数的`reg`或`phrase`字段中，具体取决于该操作数使用的寻址模式。由于许多操作数使用寄存器，因此有一个函数可以快速输出寄存器字符串，给定寄存器号，将会很方便。以下函数提供了执行此操作的最小功能：'
- en: '[PRE146]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'IDA calls your `out` function only as needed, when an address comes into view
    in one of the IDA displays or when portions of a line are reformatted. Each time
    `out` is called, it is expected to output as many lines as are necessary to represent
    the instruction described in the `cmd` global variable. In order to do this, `out`
    will generally make one or more calls to `MakeLine` (or `printf_line`). In most
    cases one line (and hence one call to `MakeLine`) will be sufficient. When more
    than one line is required to describe an instruction, you should never add carriage
    returns to your output buffers in an attempt to generate several lines at once.
    Instead, you should make multiple calls to `MakeLine` to output each individual
    line. The prototype for `MakeLine` is shown here:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: IDA仅在需要时调用你的`out`函数，当地址在IDA显示中的一个视图中出现或当一行的一部分被重新格式化时。每次调用`out`时，都期望输出尽可能多的行来表示`cmd`全局变量中描述的指令。为了做到这一点，`out`通常会对`MakeLine`（或`printf_line`）进行一次或多次调用。在大多数情况下，一行（因此是对`MakeLine`的一次调用）就足够了。当需要多行来描述一个指令时，你不应该在输出缓冲区中添加换行符以尝试一次性生成多行。相反，你应该对`MakeLine`进行多次调用以输出每一行。`MakeLine`的原型如下所示：
- en: '[PRE147]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: An `indent` value of −1 requests default indentation, which is the current value
    of `inf.indent` as specified in the Disassembly section of the Options ▸ General
    dialog. The `indent` parameter has additional meaning when an instruction (or
    data) spans several lines in the disassembly. In a multiline instruction, an indent
    of −1 designates a line as the most important line for that instruction. Please
    refer to the comments for the `printf_line` function in *lines.hpp* for more information
    on using `indent` in this manner.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`indent`值为-1请求默认缩进，这是在“选项 ▸ 通用”对话框的“反汇编”部分中指定的`inf.indent`的当前值。当指令（或数据）在反汇编中跨越多行时，`indent`参数具有额外的意义。在多行指令中，缩进为-1表示该行是该指令最重要的行。请参阅*lines.hpp*中`printf_line`函数的注释，以获取有关以这种方式使用`indent`的更多信息。
- en: Up to this point, we have avoided discussion of comments. Like names and cross-references,
    comments are handled by the IDA kernel. However, you are afforded some control
    over which line of a multiline instruction the comment is displayed on. The display
    of comments is controlled to some extent by a global variable named `gl_comm`,
    which is declared in *lines.hpp*. The most important thing to understand about
    `gl_comm` is that comments cannot be displayed at all unless `gl_comm` is set
    to 1\. If `gl_comm` is 0, then a comment will not be displayed at the end of the
    output you have generated, even if the user has entered one and comments are enabled
    in the Options ▸ General settings. The trouble is, `gl_comm` defaults to 0, so
    you need to make sure that you set it to 1 at some point if you ever expect users
    to see comments while using your processor module. When your `out` function generates
    multiple lines, you need to control `gl_comm` if you want any user-entered comments
    to be displayed on anything other than your first line of output.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们避免了对注释的讨论。像名称和交叉引用一样，注释由IDA内核处理。然而，你可以控制多行指令的哪一行显示注释。注释的显示在一定程度上由一个名为`gl_comm`的全局变量控制，该变量在*lines.hpp*中声明。关于`gl_comm`最重要的理解是，除非`gl_comm`设置为1，否则无法显示注释。如果`gl_comm`为0，那么即使在“选项
    ▸ 通用”设置中启用了注释，用户输入的注释也不会显示在你生成的输出末尾。问题是，`gl_comm`默认为0，所以如果你希望用户在使用你的处理器模块时看到注释，你需要确保在某个时刻将其设置为1。当你的`out`函数生成多行时，如果你想显示除第一行输出之外的用户输入的任何注释，你需要控制`gl_comm`。
- en: 'With the highlights of building an outputter under our belts, here is the `out`
    function for our example Python processor:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握构建输出器的高潮之后，以下是我们的示例Python处理器的`out`函数：
- en: '[PRE148]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The function works its way through the components of a disassembled line in
    a very simple fashion. If Python instructions could take two operands, we might
    use `out_symbol` to output a comma and then call `out_one_operand` a second time
    to output the second operand. In most cases, your `outop` function will be somewhat
    more complex than your `out` function, as the structure of an operand is generally
    more complex than the high-level structure of an instruction. A typical approach
    for implementing the `outop` function is to use a switch statement to test the
    value of the operand’s `type` field and format the operand accordingly.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数以非常简单的方式遍历反汇编行的组件。如果Python指令可以接受两个操作数，我们可能会使用`out_symbol`输出一个逗号，然后再次调用`out_one_operand`以输出第二个操作数。在大多数情况下，您的`outop`函数将比您的`out`函数更复杂，因为操作数的结构通常比指令的高级结构更复杂。实现`outop`函数的典型方法是用switch语句测试操作数`type`字段的值，并相应地格式化操作数。
- en: 'In our Python example, we are forced to use a very simple `outop` function,
    because in most cases we lack the information required to translate the integer
    operands into anything more intelligible. Our implementation is shown here, with
    special handling for comparisons and relative jumps only:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python示例中，我们被迫使用一个非常简单的`outop`函数，因为在大多数情况下，我们缺乏将整数操作数转换为更易理解内容所需的信息。我们的实现如下所示，仅对比较和相对跳转进行特殊处理：
- en: '[PRE149]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'In addition to disassembled instructions, a disassembly listing usually contains
    bytes that should be represented as data. In the output stage, data display is
    handled by the `d_out` member of the `LPH` object. The kernel calls the `d_out`
    function to display any bytes that are not part of an instruction, whether the
    datatype of those bytes is unknown or whether the bytes have been formatted as
    data by the user or the emulator. The prototype for `d_out` is shown here:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反汇编指令外，反汇编列表通常还包含应表示为数据的字节。在输出阶段，数据显示由`LPH`对象的`d_out`成员处理。内核调用`d_out`函数来显示任何不属于指令的字节，无论这些字节的数据类型是否未知，或者这些字节是否已被用户或仿真器格式化为数据。`d_out`的原型如下所示：
- en: '[PRE150]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The `d_out` function should examine the flags associated with the address specified
    by the `ea` parameter and generate an appropriate representation of the data in
    the style of the assembly language being generated. This function must be specified
    for all processor modules. A bare-bones implementation is offered by the SDK in
    the form of the `intel_data` function, but it is unlikely to meet your specific
    needs. In our Python example, we actually have very little need to format static
    data because we don’t have the means to locate it. For the sake of example, we
    make use of the function shown here:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '`d_out`函数应检查由`ea`参数指定的地址关联的标志，并生成与正在生成的汇编语言风格适当的数据表示。此函数必须为所有处理器模块指定。SDK以`intel_data`函数的形式提供了一个基本的实现，但它可能无法满足您的特定需求。在我们的Python示例中，我们实际上对格式化静态数据的需求非常小，因为我们没有定位它的手段。为了举例，我们使用了下面所示的函数：'
- en: '[PRE151]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Functions for accessing and testing the flags associated with any address in
    the database are available in *bytes.hpp*. In this example, the flags are tested
    to determine whether the address represents word or dword data, and appropriate
    output is generated using the appropriate data declaration keyword from the current
    assembler module. The global variable `ash` is an instance of an `asm_t` struct
    that describes characteristics of the assembler syntax that is being utilized
    in the disassembly. We would need significantly more logic in order to generate
    more complex data displays, such as arrays.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bytes.hpp`中提供了访问和测试与数据库中任何地址关联的标志的函数。在这个例子中，标志被测试以确定地址是否表示word或dword数据，并使用当前汇编模块中适当的数据声明关键字生成适当的输出。全局变量`ash`是`asm_t`结构的实例，它描述了正在使用的反汇编汇编语法的特征。为了生成更复杂的数据显示，例如数组，我们需要更多的逻辑。
- en: Processor Notifications
  id: totrans-1311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理器通知
- en: In [Chapter 17](ch17.html "Chapter 17. The IDA Plug-in Architecture"), we discussed
    the ability of plug-ins to hook various notification messages using the `hook_to_notification_point`
    function. By hooking notifications, plug-ins could be informed of various actions
    taking place within the database. The concept of notification messages exists
    for processor modules as well, but processor notifications are implemented in
    a slightly different manner than plug-in notifications.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](ch17.html "第17章。IDA插件架构")中，我们讨论了插件使用`hook_to_notification_point`函数挂钩各种通知消息的能力。通过挂钩通知，插件可以了解数据库内发生的各种操作。通知消息的概念也存在于处理器模块中，但处理器通知的实现方式与插件通知略有不同。
- en: 'All processor modules should set a pointer to a notification function in the
    `LPH` object’s `notify` field. The prototype for `notify` is shown here:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 所有处理器模块应在`LPH`对象的`notify`字段中设置一个指向通知函数的指针。`notify`函数的原型如下所示：
- en: '[PRE152]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `notify` function is a variable-arguments function that receives a notification
    code and a variable list of arguments specific to that notification code. The
    complete list of available processor notification codes may be found in *idp.hpp*.
    Notification messages exist for simple actions such as loading (`init`) and unloading
    (`term`) the processor to more complex notifications that code or data is being
    created, functions are being added or deleted, or segments are being added or
    deleted. The list of parameters supplied with each notification code is also specified
    in *idp.hpp*. Before looking at an example of a `notify` function, it is worth
    noting the following comments found only in some of the SDK’s sample processor
    modules:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify`函数是一个可变参数函数，它接收一个通知代码和与该通知代码相关的变量参数列表。可用的处理器通知代码的完整列表可以在`*idp.hpp*`中找到。通知消息存在于简单的操作，如加载（`init`）和卸载（`term`）处理器，以及更复杂的操作，如创建代码或数据、添加或删除函数或段。每个通知代码提供的参数列表也在`*idp.hpp*`中指定。在查看`notify`函数的示例之前，值得注意以下仅在SDK的一些示例处理器模块中找到的注释：'
- en: '[PRE153]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'In order to ensure that all modules that have hooked processor notifications
    are properly notified, the `invoke_callbacks` function should be called. This
    causes the kernel to propagate the given notification message to all registered
    callbacks. The `notify` function used in our Python processor is shown here:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有已挂钩处理器通知的模块都能得到适当的通知，应调用`invoke_callbacks`函数。这将导致内核将给定的通知消息传播到所有已注册的回调函数。我们Python处理器中使用的`notify`函数如下所示：
- en: '[PRE154]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'This `notify` function handles only two notification codes: `init` and `make_data`.
    The `init` notification is handled in order to explicitly force the kernel to
    treat data as little-endian. The `inf.mf` (most first) flag indicates the endianness
    value in use by the kernel (0 for little and 1 for big). The `make_data` notification
    is sent whenever an attempt is made to convert bytes to data. In our case, the
    `d_out` function is capable of dealing with only byte, word, and dword data, so
    the function tests the size of the data being created and disallows anything larger
    than 4 bytes.'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 此`notify`函数仅处理两个通知代码：`init`和`make_data`。处理`init`通知是为了明确强制内核将数据视为小端。`inf.mf`（最前位）标志表示内核使用的小端值（0表示小端，1表示大端）。每当尝试将字节转换为数据时，都会发送`make_data`通知。在我们的案例中，`d_out`函数只能处理字节、字和双字数据，因此该函数会检查正在创建的数据的大小，并禁止大于4字节的数据。
- en: Other processor_t Members
  id: totrans-1320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他`processor_t`成员
- en: 'In order to wind up the discussion on creating processor modules, we need to
    at least touch on several additional fields in the `LPH` object. As mentioned
    previously, there are a tremendous number of function pointers within this structure.
    If you read through the definition of the `processor_t` struct in *idp.hpp*, it
    is clear in some cases that you can safely set some function pointers to NULL,
    and the kernel will not call them. It seems reasonable to assume that you are
    required to provide implementations for all of the other functions required by
    `processor_t`. As a general rule of thumb, you can often get away with an empty
    stub function when you are at a loss as to what you should do. In our Python processor,
    where it was not clear that NULL was a valid value, we initialized function pointers
    as follows (refer to *idp.hpp* for the behavior of each function):'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束关于创建处理器模块的讨论，我们至少需要涉及到 `LPH` 对象中的几个附加字段。如前所述，该结构中有大量的函数指针。如果你阅读了 *idp.hpp*
    中 `processor_t` 结构的定义，在某些情况下可以清楚地看到你可以安全地将一些函数指针设置为 NULL，内核将不会调用它们。合理地假设你需要为 `processor_t`
    所需的所有其他函数提供实现。一般来说，当你不知道该做什么时，通常可以使用一个空的存根函数。在我们的 Python 处理器中，由于不清楚 NULL 是否是一个有效的值，我们按照以下方式初始化了函数指针（有关每个函数的行为，请参阅
    *idp.hpp*）：
- en: '| **`header`** Points to empty function in example. |'
  id: totrans-1322
  prefs: []
  type: TYPE_TB
  zh: '| **`header`** 在示例中指向空函数。|'
- en: '| **`footer`** Points to empty function in example. |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
  zh: '| **`footer`** 在示例中指向空函数。|'
- en: '| **`segstart`** Points to empty function in example. |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
  zh: '| **`segstart`** 在示例中指向空函数。|'
- en: '| **`segend`** Points to empty function in example. |'
  id: totrans-1325
  prefs: []
  type: TYPE_TB
  zh: '| **`segend`** 在示例中指向空函数。|'
- en: '| **`is_far_jump`** Is set to NULL in example. |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
  zh: '| **`is_far_jump`** 在示例中设置为 NULL。|'
- en: '| **`translate`** Is set to NULL in example. |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
  zh: '| **`translate`** 在示例中设置为 NULL。|'
- en: '| **`realcvt`** Points to `ieee_realcvt` from *ieee.h*. |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
  zh: '| **`realcvt`** 指向 *ieee.h* 中的 `ieee_realcvt`。|'
- en: '| **`is_switch`** Is set to NULL in example. |'
  id: totrans-1329
  prefs: []
  type: TYPE_TB
  zh: '| **`is_switch`** 在示例中设置为 NULL。|'
- en: '| **`extract_address`** Points to a function that returns (BADADDR−1) in example.
    |'
  id: totrans-1330
  prefs: []
  type: TYPE_TB
  zh: '| **`extract_address`** 在示例中指向返回 (BADADDR−1) 的函数。|'
- en: '| **`is_sp_based`** Is set to NULL in example. |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
  zh: '| **`is_sp_based`** 在示例中设置为 NULL。|'
- en: '| **`create_func_frame`** Is set to NULL in example. |'
  id: totrans-1332
  prefs: []
  type: TYPE_TB
  zh: '| **`create_func_frame`** 在示例中设置为 NULL。|'
- en: '| **`get_frame_retsize`** Is set to NULL in example. |'
  id: totrans-1333
  prefs: []
  type: TYPE_TB
  zh: '| **`get_frame_retsize`** 在示例中设置为 NULL。|'
- en: '| **`u_outspec`** Is set to NULL in example. |'
  id: totrans-1334
  prefs: []
  type: TYPE_TB
  zh: '| **`u_outspec`** 在示例中设置为 NULL。|'
- en: '| **`set_idp_options`** Is set to NULL in example. |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
  zh: '| **`set_idp_options`** 在示例中设置为 NULL。|'
- en: 'In addition to these function pointers, the following three data members are
    worth mentioning:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些函数指针之外，以下三个数据成员也值得提及：
- en: '| **`shnames`** A NULL-terminated array of character pointers that point to
    short names (fewer than nine characters) associated with the processor (such as
    *python*). Terminate this array with a NULL pointer. |'
  id: totrans-1337
  prefs: []
  type: TYPE_TB
  zh: '| **`shnames`** 是一个以 NULL 结尾的字符指针数组，这些指针指向与处理器（如 *python*）关联的短名称（少于九个字符）。使用
    NULL 指针终止此数组。|'
- en: '| **`lnames`** A NULL-terminated array of character pointers that point to
    long names associated with the processor (such as *Python 2.4 byte code*). This
    array should contain the same number of elements as the `shnames` array. |'
  id: totrans-1338
  prefs: []
  type: TYPE_TB
  zh: '| **`lnames`** 是一个以 NULL 结尾的字符指针数组，这些指针指向与处理器（如 *Python 2.4 字节码*）关联的长名称。此数组应包含与
    `shnames` 数组相同数量的元素。|'
- en: '| **`asms`** NULL-terminated array of pointers to target assembler (`asm_t`)
    structs. |'
  id: totrans-1339
  prefs: []
  type: TYPE_TB
  zh: '| **`asms`** 是指向目标汇编器 (`asm_t`) 结构的指针的 NULL 结尾数组。|'
- en: The `shnames` and `lnames` arrays specify the names of all processor types that
    can be handled by the current processor module. Users may select alternate processors
    on the Analysis tab of the Options ▸ General dialog, as shown in [Figure 19-1](ch19s03.html#selecting_alternate_processors_and_assem
    "Figure 19-1. Selecting alternate processors and assemblers").
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '`shnames` 和 `lnames` 数组指定了当前处理器模块可以处理的所有处理器类型的名称。用户可以在选项 ▸ 通用对话框的分析选项卡上选择替代处理器，如图
    19-1 所示。'
- en: Processor modules that support multiple processors should process the `processor_t.newprc`
    notification in order to be informed of processor changes.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多个处理器的处理器模块应该处理 `processor_t.newprc` 通知，以便了解处理器变化。
- en: '![Selecting alternate processors and assemblers](httpatomoreillycomsourcenostarchimages854310.png.jpg)'
  id: totrans-1342
  prefs: []
  type: TYPE_IMG
  zh: '![选择替代处理器和汇编器](httpatomoreillycomsourcenostarchimages854310.png.jpg)'
- en: Figure 19-1. Selecting alternate processors and assemblers
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19-1. 选择替代处理器和汇编器
- en: The `asm_t` structure is used to describe some of the syntactic elements of
    an assembly language, such as the format of hexadecimal numbers, strings, and
    character delimiters, as well as various keywords commonly used in assembly languages.
    The intent of the `asms` field is to allow several different styles of assembly
    language to be generated by a single processor module. Processor modules that
    support multiple assemblers should process the `processor_t.newasm` notification
    in order to be notified of processor changes.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm_t`结构用于描述汇编语言的一些语法元素，例如十六进制数的格式、字符串和字符分隔符，以及汇编语言中常用的各种关键字。`asms`字段的目的是允许单个处理器模块生成多种不同的汇编语言风格。支持多个汇编器的处理器模块应该处理`processor_t.newasm`通知，以便通知处理器更改。'
- en: 'Ultimately, the completed version of our simple Python processor is capable
    of generating code such as the following:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们简单的Python处理器版本能够生成如下代码：
- en: '[PRE155]'
  id: totrans-1346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: While it is possible to generate Python disassemblies that reveal far more information
    than this, they require far greater knowledge of the *.pyc* file format than was
    assumed for this example. A somewhat more fully featured Python processor module
    is available on the book’s website.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以生成比这更多的Python反汇编信息，但它们需要比本例中假设的更深入的知识来理解*.pyc*文件格式。一个功能更全面的Python处理器模块可在本书的网站上找到。
- en: Building Processor Modules
  id: totrans-1348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建处理器模块
- en: 'The process for building and installing an IDA processor module is very similar
    to the process for building plug-ins and loaders, with one major difference that,
    if not followed, can result in the inability of IDA to utilize your processor.
    Some minor differences in the build process include these:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和安装IDA处理器模块的过程与构建插件和加载器的过程非常相似，但有一个主要区别，如果不遵循，可能会导致IDA无法使用您的处理器。构建过程中的某些细微差异包括这些：
- en: File extensions for processors are *.w32/.w64* on Windows, *.ilx/ilx64* on Linux,
    and *`.imc/.imc64`* on OS X platforms.
  id: totrans-1350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理器的文件扩展名在Windows上是*.w32/.w64*，在Linux上是*.ilx/ilx64*，在OS X平台上是`.imc/.imc64`。
- en: The build scripts for the SDK’s example processors (as well as our own) store
    newly created processor binaries into *<SDKDIR>/bin/procs*.
  id: totrans-1351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDK示例处理器（以及我们自己的）的构建脚本将新创建的处理器二进制文件存储到`*<SDKDIR>/bin/procs*`。
- en: Processor modules are installed by copying the compiled processor binary to
    *<IDADIR>/procs*.
  id: totrans-1352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理器模块通过将编译后的处理器二进制文件复制到`*<IDADIR>/procs*`目录来安装。
- en: Windows processor modules are required to use a customized MS-DOS stub^([[138](#ftn.CHP-19-FN-4)])
    supplied with the SDK.
  id: totrans-1353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows处理器模块需要使用SDK提供的定制MS-DOS引导程序^([[138](#ftn.CHP-19-FN-4)))。
- en: Windows-based processor modules require a custom postprocessing step not required
    by plug-ins and loaders. The purpose of this step is to insert a processor description
    string into a specific location in the compiled processor binary. The description
    string is displayed in the processor drop-down list portion of IDA’s load-file
    dialog.
  id: totrans-1354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于Windows的处理器模块需要执行一个插件和加载器不需要的定制后处理步骤。此步骤的目的是将处理器描述字符串插入到编译后的处理器二进制文件中的特定位置。该描述字符串将在IDA的加载文件对话框的处理器下拉列表部分显示。
- en: When you build a Windows-based processor module, you are expected to utilize
    a custom MS-DOS stub supplied with the SDK (*<SDKDIR>/module/stub*). In order
    to use a custom MS-DOS stub, you must instruct your linker to use your stub rather
    than the default stub it would otherwise include. When using Windows-specific
    compilers, it is occasionally possible to specify alternate stubs through the
    use of module definition (*.def* ) files. Borland build tools (used by Hex-Rays)
    support the specification of alternate stubs using *.def* files. The SDK includes
    *<SDKDIR>/module/idp.def* for your use if you happen to be using Borland tools.
    The GNU and Microsoft linkers both support *.def* files (albeit with a slightly
    different syntax); however, neither supports the specification of alternate MS-DOS
    stubs, which clearly poses a problem if you are using one of these compilers.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建基于Windows的处理器模块时，您需要使用SDK提供的定制MS-DOS引导程序(*<SDKDIR>/module/stub*)。为了使用定制的MS-DOS引导程序，您必须指导您的链接器使用您的引导程序而不是它默认包含的引导程序。当使用特定于Windows的编译器时，有时可以通过使用模块定义
    (*.def*) 文件来指定替代引导程序。Borland构建工具（Hex-Rays使用）支持使用*.def*文件来指定替代引导程序。SDK包括供您使用的`*<SDKDIR>/module/idp.def*`，如果您恰好在使用Borland工具。GNU和Microsoft链接器都支持*.def*文件（尽管语法略有不同）；然而，它们都不支持指定替代MS-DOS引导程序，如果您使用这些编译器之一，这显然会引发问题。
- en: 'Assuming for a moment that you do manage to build your processor module with
    the SDK-supplied custom MS-DOS stub, you must still insert the processor description
    comment into the processor binary. This is the purpose of the *<SDKDIR>/bin/mkidp.exe*
    utility. You may add a description to a processor using the following syntax to
    invoke `mkidp`:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你确实能够使用 SDK 提供的定制 MS-DOS stub 构建处理器模块，你仍然必须将处理器描述注释插入到处理器二进制文件中。这就是 *`<SDKDIR>/bin/mkidp.exe`*
    工具的目的。你可以使用以下语法向 `mkidp` 添加描述：
- en: '[PRE156]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Here, *`module`* is the path to your processor module, while *`description`*
    is a textual description of your module in the following form:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*`module`* 是你的处理器模块的路径，而 *`description`* 是你的模块的文本描述，其形式如下：
- en: '[PRE157]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'To add a description to our Python processor module, we might use the following
    command line:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的 Python 处理器模块添加描述，我们可能使用以下命令行：
- en: '[PRE158]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The `mkidp` utility attempts to insert the supplied description into the named
    module at an offset of 128 bytes into the file, in space that lies between the
    MS-DOS stub and the PE header, assuming such space exists. If there is not enough
    space because the PE header is too close to the end of the MS-DOS stub, you will
    receive the following error message:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkidp` 工具尝试将提供的描述插入到名为模块的文件中，偏移量为 128 字节，位于 MS-DOS stub 和 PE 头部之间的空间中，假设存在这样的空间。如果由于
    PE 头部太靠近 MS-DOS stub 的末尾而导致空间不足，你将收到以下错误信息：'
- en: '[PRE159]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Things become more dependent on your tools at this point, because processors
    built with the Microsoft linker will have enough space available to insert a description,
    while processors built using the GNU linker will not.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，事情变得更加依赖于你的工具，因为使用 Microsoft 链接器构建的处理器将有足够的空间来插入描述，而使用 GNU 链接器构建的处理器则不会有。
- en: In order to clear up the confusion in our minds and allow us to use either Microsoft
    or GNU tools, we developed a utility that we call `fix_proc`, which is available
    in the [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules") section of
    the book’s website. The `fix_proc` utility uses the same command-line syntax as
    `mkidp`, but it provides additional behavior that allows it to insert a processor
    description into processor modules built with most compilers. When `fix_proc`
    is executed, it replaces a processor’s existing MS-DOS stub with the stub supplied
    with the SDK (thus eliminating the need to use *.def* files in the build process).
    At the same time, `fix_proc` performs the necessary actions to relocate the processor’s
    PE headers to create sufficient space to hold the processor-description string,
    before ultimately inserting the description string into the proper location within
    the processor binary. We use `fix_proc` as a replacement for `mkidp` in performing
    the required postprocessing steps on processor modules.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除我们心中的困惑，并允许我们使用 Microsoft 或 GNU 工具，我们开发了一个名为 `fix_proc` 的实用程序，该实用程序可在书籍网站的
    [第 19 章](ch19.html "第 19 章。IDA 处理器模块") 部分找到。`fix_proc` 实用程序使用与 `mkidp` 相同的命令行语法，但它提供了额外的行为，允许它将处理器描述插入到大多数编译器构建的处理器模块中。当
    `fix_proc` 执行时，它会用 SDK 提供的 stub 替换处理器现有的 MS-DOS stub（从而消除了在构建过程中使用 *.def* 文件的需求）。同时，`fix_proc`
    执行必要的操作，将处理器的 PE 头部重新定位，以创建足够的空间来存放处理器描述字符串，最终将描述字符串插入到处理器二进制文件中的正确位置。我们使用 `fix_proc`
    作为 `mkidp` 的替代品，在处理器模块上执行所需的后期处理步骤。
- en: Note
  id: totrans-1366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Strictly speaking, use of the SDK’s MS-DOS stub for processor modules is not
    required. IDA is happy with a processor module as long as it finds a description
    string 128 bytes into the processor module. In `fix_proc`, we replace the existing
    MS-DOS stub with the SDK stub simply to avoid any possible conflicts over the
    space dedicated to the description string.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，对于处理器模块，使用 SDK 的 MS-DOS stub 不是必需的。只要 IDA 在处理器模块中找到 128 字节处的描述字符串，它就会对处理器模块感到满意。在
    `fix_proc` 函数中，我们简单地用 SDK stub 替换现有的 MS-DOS stub，以避免在描述字符串专用空间上可能出现的任何冲突。
- en: '[Table 19-1](ch19s04.html#postprocessing_ida_processor_modules "Table 19-1. Postprocessing
    IDA Processor Modules (by Compiler)") describes the features of processors based
    on the tools used to build them.'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 19-1](ch19s04.html#postprocessing_ida_processor_modules "表 19-1. 后处理 IDA
    处理器模块（按编译器）") 描述了基于构建它们的工具的处理器功能。'
- en: Only processors that have valid descriptions will be listed in the file-loading
    dialog. In other words, without a valid description field, it is not possible
    to select a processor module.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 只有具有有效描述的处理器才会列在文件加载对话框中。换句话说，如果没有有效的描述字段，就无法选择处理器模块。
- en: Table 19-1. Postprocessing IDA Processor Modules (by Compiler)
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19-1. 通过编译器后处理的 IDA 处理器模块 (按编译器分类)
- en: '|   | Initial Build |   | After mkidp |   | After fix_proc |   |'
  id: totrans-1371
  prefs: []
  type: TYPE_TB
  zh: '|   | 初始构建 |   | 在mkidp之后 |   | 在fix_proc之后 |   |'
- en: '| Tool | Uses .def? | Has stub? | Has stub? | Has Description? | Has stub?
    | Has Description? |'
  id: totrans-1372
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 使用 .def? | 有占位符? | 有占位符? | 有描述? | 有占位符? | 有描述? |'
- en: '| Borland | Yes | Yes | Yes | Yes | Yes | Yes |'
  id: totrans-1373
  prefs: []
  type: TYPE_TB
  zh: '| Borland | 是 | 是 | 是 | 是 | 是 | 是 |'
- en: '| Microsoft | No | No | No | Yes | Yes | Yes |'
  id: totrans-1374
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft | 否 | 否 | 否 | 是 | 是 | 是 |'
- en: '| GNU | No | No | No | No | Yes | Yes |'
  id: totrans-1375
  prefs: []
  type: TYPE_TB
  zh: '| GNU | 否 | 否 | 否 | 否 | 是 | 是 |'
- en: All of these differences in the build process require a few more modifications
    to the makefile presented in [Example 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins
    "Example 17-1. A sample makefile for IDA plug-ins") than were required to build
    loader modules. [Example 19-1](ch19s04.html#a_makefile_for_the_python_processor_modu
    "Example 19-1. A makefile for the Python processor module") shows a makefile modified
    to build our example Python processor.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构建过程中的所有差异都需要对[示例 17-1](ch17s02.html#a_sample_makefile_for_ida_plug-ins "示例
    17-1. 为 IDA 插件提供的示例 makefile")中展示的 makefile 进行一些额外的修改，而构建加载模块所需的修改较少。[示例 19-1](ch19s04.html#a_makefile_for_the_python_processor_modu
    "示例 19-1. Python 处理器模块的 makefile") 展示了一个修改后的 makefile，用于构建我们的示例 Python 处理器。
- en: Example 19-1. A makefile for the Python processor module
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-1. Python 处理器模块的 makefile
- en: '[PRE160]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In addition to the minor changes to account for different suffixes and default
    file locations for processors, the primary differences are the definition of a
    description string ![](httpatomoreillycomsourcenostarchimages854061.png), the
    specification of a utility to insert description strings ![](httpatomoreillycomsourcenostarchimages854063.png),
    and the addition of a build step to insert the description string in Windows processor
    modules ![](httpatomoreillycomsourcenostarchimages854093.png).
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对处理器不同后缀和默认文件位置进行的一些小修改外，主要差异包括定义一个描述字符串 ![更多](httpatomoreillycomsourcenostarchimages854061.png)，指定一个用于插入描述字符串的工具
    ![更多](httpatomoreillycomsourcenostarchimages854063.png)，以及在 Windows 处理器模块中添加一个构建步骤以插入描述字符串
    ![更多](httpatomoreillycomsourcenostarchimages854093.png)。
- en: '* * *'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[138](#CHP-19-FN-4)]) An MS-DOS header stub includes an MS-DOS file header
    as well as code to warn users that a Windows program cannot be executed in MS-DOS
    mode.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[138](#CHP-19-FN-4)]) MS-DOS 头部占位符包括 MS-DOS 文件头部以及警告用户在 MS-DOS 模式下无法执行 Windows
    程序的代码。
- en: Customizing Existing Processors
  id: totrans-1382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制现有处理器
- en: 'Perhaps you are considering developing a processor module, but you notice that
    an existing processor module does almost everything that you need. If you have
    the source code for the processor module, then you might easily modify it to suit
    your needs. On the other hand, if you don’t have the source code, you might feel
    that you are out of luck. Fortunately, IDA offers a mechanism for customizing
    existing processors through the use of plug-ins. By hooking the appropriate processor
    notifications, a plug-in module can intercept calls to one or more of an existing
    processor’s analyzer, emulator, and outputter stages. Potential applications for
    customizing a processor include the following:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你正在考虑开发一个处理器模块，但注意到现有的处理器模块几乎可以做你需要的一切。如果你有处理器模块的源代码，那么你可能很容易修改它以满足你的需求。另一方面，如果你没有源代码，你可能觉得你运气不好。幸运的是，IDA
    通过使用插件提供了一种定制现有处理器的机制。通过钩住适当的处理器通知，插件模块可以拦截对现有处理器分析器、模拟器和输出器阶段的调用。定制处理器的潜在应用包括以下内容：
- en: Extending the capabilities of an existing processor to recognize additional
    instructions
  id: totrans-1384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展现有处理器的功能以识别额外的指令
- en: Correcting broken behavior in an existing processor module (though it is probably
    faster just to let Ilfak know you found a bug)
  id: totrans-1385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复现有处理器模块中的损坏行为（尽管直接告诉 Ilfak 你发现了一个错误可能更快）
- en: Customizing the output of an existing processor module to suit your particular
    needs
  id: totrans-1386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制现有处理器模块的输出以满足特定需求
- en: 'The following notification codes, declared in `processor_t` and discussed in
    *idp.hpp*, may be hooked by plug-ins that want to intercept calls to various stages
    of a processor:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下通知代码，在 `processor_t` 中声明并在 *idp.hpp* 中讨论，可以被想要拦截处理器各个阶段调用的插件钩住：
- en: '| **`custom_ana`** Behaves as `u_ana`; however, any new instructions must use
    a `cmd.itype` value of 0x8000 or higher. |'
  id: totrans-1388
  prefs: []
  type: TYPE_TB
  zh: '| **`custom_ana`** 行为类似于 `u_ana`；然而，任何新的指令都必须使用 `cmd.itype` 值为 0x8000 或更高。
    |'
- en: '| **`custom_emu`** Provides emulation for custom instruction types. You may
    call `(*ph.u_emu)()` if you wish to invoke the processor’s existing emulator.
    |'
  id: totrans-1389
  prefs: []
  type: TYPE_TB
  zh: '| **`custom_emu`** 为自定义指令类型提供仿真。如果您想调用处理器现有的仿真器，可以调用 `(*ph.u_emu)()`。|'
- en: '| **`custom_out`** Generates output for custom instructions or provides custom
    output for existing instructions. You may call `(*ph.u_out)()` if you wish to
    invoke the processor’s `out` function. |'
  id: totrans-1390
  prefs: []
  type: TYPE_TB
  zh: '| **`custom_out`** 生成自定义指令的输出或为现有指令提供自定义输出。如果您想调用处理器的 `out` 函数，可以调用 `(*ph.u_out)()`。|'
- en: '| **`custom_outop`** Outputs a single custom operand. You may call `(*ph.u_outop)(op)`
    if you wish to invoke the processor’s existing `outop` function. |'
  id: totrans-1391
  prefs: []
  type: TYPE_TB
  zh: '| **`custom_outop`** 输出一个单独的自定义操作数。如果您想调用处理器现有的 `outop` 函数，可以调用 `(*ph.u_outop)(op)`。|'
- en: '| **`custom_mnem`** Generates the mnemonic for a custom instruction. |'
  id: totrans-1392
  prefs: []
  type: TYPE_TB
  zh: '| **`custom_mnem`** 生成自定义指令的助记符。|'
- en: 'The following code excerpts are from a plug-in that modifies the output of
    the x86 processor module to replace the `leave` instruction with a `cya` instruction
    and to swap the display order for instructions that have two operands (similar
    to the AT&T-style syntax):'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自一个插件，该插件修改了 x86 处理器模块的输出，将 `leave` 指令替换为 `cya` 指令，并交换具有两个操作数的指令的显示顺序（类似于
    AT&T 风格的语法）：
- en: '[PRE161]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The plug-in’s `init` function verifies that the current processor is the x86
    processor ![](httpatomoreillycomsourcenostarchimages854061.png) and then hooks
    processor notifications ![](httpatomoreillycomsourcenostarchimages854063.png).
    In the callback `hook` function, the plug-in processes the `custom_out` notification
    to recognize the `leave` instruction ![](httpatomoreillycomsourcenostarchimages854093.png)
    and generates an alternative output line ![](httpatomoreillycomsourcenostarchimages854095.png).
    For two operand instructions, the `hook` function temporarily saves the operands
    associated with the current command, before swapping them within the command just
    prior to invoking the x86 processor’s `u_out` function ![](httpatomoreillycomsourcenostarchimages854099.png)
    to handle all of the details of printing the line. Upon return, the command’s
    operands are swapped back to their original order. Finally, the plug-in’s flags
    ![](httpatomoreillycomsourcenostarchimages854101.png) specify that the plug-in
    should be loaded when a processor is loaded, should not be listed on the Edit
    ▸ Plugins menu, and modifies the database. The following output shows the effects
    of the customizations performed by the plug-in:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的 `init` 函数验证当前处理器是 x86 处理器 ![图片链接](httpatomoreillycomsourcenostarchimages854061.png)
    然后挂钩处理器通知 ![图片链接](httpatomoreillycomsourcenostarchimages854063.png)。在回调 `hook`
    函数中，插件处理 `custom_out` 通知以识别 `leave` 指令 ![图片链接](httpatomoreillycomsourcenostarchimages854093.png)
    并生成替代输出行 ![图片链接](httpatomoreillycomsourcenostarchimages854095.png)。对于具有两个操作数的指令，`hook`
    函数在调用 x86 处理器的 `u_out` 函数之前，临时保存与当前命令关联的操作数，在命令内部交换它们 ![图片链接](httpatomoreillycomsourcenostarchimages854099.png)
    以处理打印行的所有细节。返回后，命令的操作数将恢复到原始顺序。最后，插件的标志 ![图片链接](httpatomoreillycomsourcenostarchimages854101.png)
    指定插件应在加载处理器时加载，不应在“编辑 ▸ 插件”菜单中列出，并修改数据库。以下输出显示了插件执行的定制效果：
- en: '[PRE162]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: You can observe the plug-in’s effects by noting that constants appear as the
    first operand in four instructions ![](httpatomoreillycomsourcenostarchimages854103.png)
    and that the `cya` instruction is used in place of the `leave` instruction ![](httpatomoreillycomsourcenostarchimages854133.png).
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过注意常数在四条指令中作为第一个操作数出现 ![图片链接](httpatomoreillycomsourcenostarchimages854103.png)
    以及 `cya` 指令被用作 `leave` 指令的替代 ![图片链接](httpatomoreillycomsourcenostarchimages854133.png)
    来观察插件的效果。
- en: In [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis"), we will look
    at using a custom processor plug-in to aid in the analysis of certain types of
    obfuscated binaries.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 21 章](ch21.html "第 21 章。混淆代码分析") 中，我们将探讨使用自定义处理器插件来帮助分析某些类型的混淆二进制文件。
- en: Processor Module Architecture
  id: totrans-1399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器模块架构
- en: As you set about designing processor modules, one of the things you will need
    to consider is whether the processor will be closely coupled with a specific loader
    or can be decoupled from all loaders. For example, consider the x86 processor
    module. This module makes no assumptions about the type of file that is being
    disassembled. Therefore, it is easily incorporated and used in conjunction with
    a wide variety of loaders such as the PE, ELF, and Mach-O loaders.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始设计处理器模块时，你需要考虑的一件事是处理器是否会紧密耦合到特定的加载器，或者是否可以从所有加载器中解耦。例如，考虑 x86 处理器模块。此模块对正在反汇编的文件类型没有任何假设。因此，它很容易被集成并与其他加载器一起使用，例如
    PE、ELF 和 Mach-O 加载器。
- en: In a similar manner, loaders show versatility when they are capable of handling
    a file format independently of the processor used with the file. For example,
    the PE loader works equally well whether it contains x86 code or ARM code; the
    ELF loader works equally well whether it contains x86, MIPS, or SPARC code; and
    the Mach-O loader works fine whether it contains PPC or x86 code.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，当加载器能够独立于与文件一起使用的处理器处理文件格式时，它们表现出多功能性。例如，PE 加载器在包含 x86 代码或 ARM 代码时都能正常工作；ELF
    加载器在包含 x86、MIPS 或 SPARC 代码时都能正常工作；Mach-O 加载器在包含 PPC 或 x86 代码时也能正常工作。
- en: Real-world CPUs lend themselves to the creation of processor modules that do
    not rely on a specific input file format. Virtual machine languages, on the other
    hand, pose a much larger challenge. Whereas a wide variety of loaders (such as
    ELF, a.out, and PE) may be used to load code for execution on native hardware,
    a virtual machine typically acts as both a loader and a CPU. The net result is
    that, for virtual machines, both the file format and the underlying byte code
    are intimately related. One cannot exist without the other. We bumped up against
    this limitation several times in the development of the Python processor module.
    In many cases, it simply was not possible to generate more readable output without
    a deeper understanding of the structure of the file being disassembled.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，CPU 适合创建不依赖于特定输入文件格式的处理器模块。另一方面，虚拟机语言则提出了更大的挑战。虽然可以使用各种加载器（如 ELF、a.out
    和 PE）来在原生硬件上加载代码执行，但虚拟机通常既充当加载器又充当 CPU。结果是，对于虚拟机来说，文件格式和底层字节码密切相关。一个不能没有另一个存在。我们在开发
    Python 处理器模块的过程中多次遇到了这种限制。在许多情况下，如果没有对正在反汇编的文件结构的深入了解，根本无法生成更易于阅读的输出。
- en: In order for the Python processor to have access to the additional information
    that it requires, we could build a Python loader that configures the database
    in a manner very specific to the Python processor so that the Python processor
    knows exactly where to find the information it needs. In this scenario, a significant
    amount of loader state data would need to pass from the loader to the processor.
    One approach is to store such data in database netnodes, where that data could
    later be retrieved by the processor module.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Python 处理器能够访问它所需的其他信息，我们可以构建一个 Python 加载器，以非常具体的方式配置数据库，以便 Python 处理器确切地知道信息所在的位置。在这种情况下，大量的加载器状态数据需要从加载器传递到处理器。一种方法是将此类数据存储在数据库
    netnodes 中，这样处理器模块稍后可以检索这些数据。
- en: An alternative approach is to build a loader that does nothing other than recognize
    *.pyc* files and then tells the processor module that it should handle all of
    the other loading tasks, in which case the processor will surely know how to locate
    all of the information needed for disassembling the *.pyc* file.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是构建一个仅识别 *.pyc* 文件的加载器，然后告诉处理器模块它应该处理所有其他加载任务，在这种情况下，处理器肯定知道如何定位所有用于反汇编
    *.pyc* 文件所需的信息。
- en: 'IDA facilitates the construction of tightly coupled loaders and processor modules
    by allowing a loader to defer all loading operations to an associated processor
    module. This is how the SDK’s included Java loader and Java processor are constructed.
    In order for a loader to defer loading to the processor module, the loader should
    first accept a file by returning a file type of `f_LOADER` (defined in *ida.hpp*).
    If the loader is selected by the user, the loader’s `load_file` function should
    ensure that the proper processor type has been specified by calling `set_processor_type`
    (*idp.hpp*) if necessary before sending a loader-notification message to the processor.
    To build a tightly coupled Python loader/processor combination, we might build
    a loader with the following `load_file` function:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: IDA通过允许加载器将所有加载操作推迟到相关的处理器模块来实现，从而简化了紧密耦合的加载器和处理器模块的构建。为了使加载器能够将加载推迟到处理器模块，加载器首先应该通过返回文件类型为`f_LOADER`（在`ida.hpp`中定义）来接受一个文件。如果加载器被用户选中，加载器的`load_file`函数应该在向处理器发送加载通知消息之前，如果需要，通过调用`set_processor_type`（在`idp.hpp`中定义）来确保已经指定了正确的处理器类型。为了构建一个紧密耦合的Python加载器/处理器组合，我们可能会构建一个具有以下`load_file`函数的加载器：
- en: '[PRE163]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: When the processor module receives the `loader` notification, it takes responsibility
    for mapping the input file into the database and making sure that it has access
    to any information that will be required in any of the `ana`, `emu`, and `out`
    stages. A Python loader and processor combination that operates in this manner
    is available on the book’s companion website.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理器模块接收到`loader`通知时，它负责将输入文件映射到数据库中，并确保它能够访问在`ana`、`emu`和`out`阶段所需的任何信息。在本书的配套网站上有一个以这种方式运行的Python加载器和处理器组合。
- en: Scripting a Processor Module
  id: totrans-1408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写处理器模块脚本
- en: Introduced in IDA 5.7, the capability to create processor modules using one
    of IDA’s scripting languages somewhat simplifies the creation of processor modules.
    If nothing else, it completely eliminates the build phase of module creation.
    Elias Bachaalany of Hex-Rays introduced scripted processor modules in a post on
    Hex Blog^([[139](#ftn.CHP-19-FN-5)]) and IDA’s EFI bytecode processor module is
    implemented as a Python script (see *<IDADIR>/procs/ebc.py*). Note that while
    the Hex Blog post serves as useful background, the actual API used for scripting
    processor modules seems to have evolved. The best place for you to start development
    of your own processor module script is with the template module that ships with
    the SDK (see *<SDKDIR>/module/script/proctemplate.py*). Among other things, this
    template enumerates all of the fields required in a Python processor module.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA 5.7中引入的，使用IDA的一种脚本语言创建处理器模块的能力，在某种程度上简化了处理器模块的创建。至少，它完全消除了模块创建的构建阶段。Hex-Rays的Elias
    Bachaalany在Hex Blog^([[139](#ftn.CHP-19-FN-5)])上发表了一篇关于脚本处理器模块的文章，IDA的EFI字节码处理器模块是用Python脚本实现的（见`<IDADIR>/procs/ebc.py`）。请注意，尽管Hex
    Blog文章提供了有用的背景信息，但用于脚本处理器模块的实际API似乎已经发生了演变。你开始自己处理器模块脚本开发的最佳地方是SDK中附带的自定义模块模板（见`<SDKDIR>/module/script/proctemplate.py`）。这个模板列出了Python处理器模块中所需的所有字段。
- en: Scripted processor modules make use of nearly all elements discussed previously.
    Understanding these elements will ease your transition to scripted modules. Additionally,
    the three Python processor modules that currently ship with IDA (as of IDA 6.1)
    serve as excellent examples from which to begin your own module development. The
    structure of these two modules is a bit easier to understand than the C++ examples
    that ship with the SDK, which span several files and require you to correctly
    configure a build environment.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本处理器模块使用了之前讨论的几乎所有元素。理解这些元素将有助于你过渡到脚本模块。此外，目前随IDA（截至IDA 6.1）一起提供的三个Python处理器模块是开始你自己的模块开发的优秀示例。这两个模块的结构比SDK中提供的C++示例更容易理解，后者跨越多个文件，并要求你正确配置构建环境。
- en: 'From a very high level, two things are required to implement a processor module
    in Python:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个非常高的层面来看，实现Python处理器模块需要两个东西：
- en: Define a subclass `idaapi.processor_t`, providing implementations for all required
    processor module functions such as `emu`, `ana`, `out`, and `outop`.
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`idaapi.processor_t`的子类，提供所有必需的处理器模块函数的实现，例如`emu`、`ana`、`out`和`outop`。
- en: Define a `PROCESSOR_ENTRY` function (not a member of your subclass) that returns
    an instance of your processor class.
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`PROCESSOR_ENTRY`函数（不是你的子类的成员）它返回你的处理器类的实例。
- en: 'The following listing begins to outline some of the required elements:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表开始概述一些必需的元素：
- en: '[PRE164]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: A valid Python processor module contains far more fields and functions than
    shown above, essentially mirroring the fields required in any processor module
    implemented in C++. Once your script is complete, installation of your module
    is accomplished by copying your script to *<IDADIR>/procs*.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的Python处理器模块包含比上面显示的更多字段和函数，本质上反映了任何用C++实现的处理器模块所需的字段。一旦你的脚本完成，通过将你的脚本复制到*<IDADIR>/procs*，就可以完成你的模块的安装。
- en: '* * *'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[139](#CHP-19-FN-5)]) See [http://www.hexblog.com/?p=116](http://www.hexblog.com/?p=116).
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[139](#CHP-19-FN-5)]) 查看 [http://www.hexblog.com/?p=116](http://www.hexblog.com/?p=116)。
- en: Summary
  id: totrans-1419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As the most complex of IDA’s modular extensions, processor modules take time
    to learn and even more time to create, although the use of scripting can ease
    this pain to some extent. However, if you are in a niche reverse engineering market,
    or you simply like to be on the leading edge of the reverse engineering community,
    you will almost certainly find yourself with the need to develop a processor module
    at some point. We cannot emphasize enough the role that patience and trial and
    error play in any processor-development situation. The hard work more than pays
    off when you are able to reuse your processor module with each new binary you
    collect.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 作为IDA模块扩展中最复杂的部分，处理器模块的学习需要时间，创建则需要更多时间，尽管使用脚本可以在一定程度上减轻这种痛苦。然而，如果你在一个细分的市场中进行逆向工程，或者你只是喜欢站在逆向工程社区的尖端，你几乎肯定会在某个时候需要开发一个处理器模块。我们无法过分强调耐心和试错在处理器开发中的角色。当你能够将你的处理器模块与每个新收集的二进制文件一起重用时，这种辛勤的工作将得到充分的回报。
- en: With the end of this chapter, we conclude our discussion of IDA’s extensibility
    features. Over the course of the next several chapters, we will discuss many of
    the ways IDA is used in real-world scenarios and look at how users have leveraged
    IDA extensions to perform a variety of interesting analysis tasks.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们结束了对IDA扩展功能的讨论。在接下来的几章中，我们将讨论IDA在现实场景中的多种应用方式，并查看用户如何利用IDA扩展执行各种有趣的分析任务。
