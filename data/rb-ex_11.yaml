- en: Chapter 11. CGI and the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。CGI 和网页
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: Ruby has gotten a lot of attention as a language particularly well suited for
    web programming, especially in the context of the Rails development framework.
    Some people even go so far as to categorize Ruby as a web language, suggesting
    that it is not a full-fledged general-purpose programming language. I hope that
    the previous chapters have played at least a modest role in convincing readers
    that this assertion is false.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 作为一种特别适合网页编程的语言受到了很多关注，尤其是在 Rails 开发框架的背景下。有些人甚至将 Ruby 归类为一种网页语言，暗示它不是一个完整的通用编程语言。我希望前几章至少在某种程度上说服了读者这一说法是错误的。
- en: That said, Ruby is very useful for web work, and it does have some characteristics
    that make it better suited for web programming than (for example) video game programming.
    Ruby operates at a very high level of abstraction, giving programmers a large
    toolset to work with, and it executes code at a slower speed than some other languages.
    These characteristics make Ruby well suited for web work, since development speed
    is often critical, but program execution speed is often less critical than in
    other types of programs, such as real-time action video games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Ruby 对于网页开发非常有用，它确实有一些特性使其比（例如）视频游戏编程更适合网页编程。Ruby 在一个非常高的抽象级别上运行，为程序员提供了一个庞大的工具集来使用，并且它执行代码的速度比某些其他语言要慢。这些特性使
    Ruby 非常适合网页开发，因为开发速度通常至关重要，但程序执行速度通常不如其他类型的程序，如实时动作视频游戏重要。
- en: The Rails development framework has been instrumental in bringing Ruby to the
    attention of an ever-larger audience. Some say it’s Ruby’s “killer app,” analogous
    to Perl’s CPAN or the GNU project’s gcc. This is a general Ruby book, not a Rails
    book, but Rails is important enough that it gets its own chapter. (Since we’ll
    be using RubyGems, Ruby’s package-management system, to install Rails, this book
    also has a chapter devoted to RubyGems.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 开发框架在将 Ruby 推向越来越广泛的受众方面发挥了重要作用。有人说它是 Ruby 的“杀手级应用”，类似于 Perl 的 CPAN 或
    GNU 项目的 gcc。这是一本关于 Ruby 的通用书籍，而不是 Rails 的书籍，但 Rails 的重要性足以让它拥有自己的章节。（由于我们将使用 RubyGems，Ruby
    的包管理系统，来安装 Rails，因此本书还包括一个关于 RubyGems 的章节。）
- en: You’ll have to wait two chapters for Rails. Aside from knowing how to install
    it with RubyGems, by then you should also know something about web programs in
    general—that’s what this chapter is for. If you’re a web app veteran, feel free
    to skip this chapter, although you may find some of the specific scripts novel
    and interesting, even if you already know how they work.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要等待两章才能了解 Rails。除了知道如何使用 RubyGems 安装它之外，到那时你也应该对一般性的网页程序有所了解——这就是本章的目的。如果你是网页应用程序的老手，你可以自由地跳过这一章，尽管你可能发现其中的一些特定脚本新颖有趣，即使你已经知道它们是如何工作的。
- en: Common Gateway Interface
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用网关接口
- en: The most common approach to web programming is the Common Gateway Interface
    (CGI). *CGI* is not a programming language; it’s a set of rules for programs to
    follow when they run on the Web, regardless of the particular language in which
    each program might be written. CGI enables friendly cooperation among multiple
    files that could even be written in distinct programming languages but all exist
    together within a larger web application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网页编程最常见的方法是通用网关接口（CGI）。*CGI* 并不是一种编程语言；它是一套规则，程序在网页上运行时需要遵循这些规则，无论每个程序可能用哪种特定的语言编写。CGI
    允许多个文件之间友好地协作，即使这些文件是用不同的编程语言编写的，但它们都存在于一个更大的网络应用程序中。
- en: Using more than one language for a single web application is fairly common.
    I mentioned that Ruby’s high level of abstraction makes it suitable for web programming.
    However, sometimes you might really want to use a library someone has already
    written in another language—like Python, for instance—in a web program. If you
    use CGI, you could write part of your web application in Python in order to use
    that library. You might also have a section of your web application that is highly
    speed critical, so you could write that part in C for execution speed, and the
    rest in Ruby for development speed. This is exactly the reason that Paul Graham
    and his colleagues chose to use a combination of Lisp and C for their company
    Viaweb, which eventually became Yahoo! Stores. They were able to do so because
    the CGI specification holds across multiple languages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个网络应用程序中使用多种语言相当常见。我提到Ruby的高度抽象性使其适合于网络编程。然而，有时你可能真的想在网络程序中使用别人用另一种语言（比如Python）编写的库。如果你使用CGI，你可以在Python中编写你的网络应用程序的一部分，以便使用那个库。你也可能有一个对速度要求很高的网络应用程序部分，因此你可以用C编写这部分以提高执行速度，其余部分用Ruby编写以提高开发速度。这正是保罗·格雷厄姆和他的同事选择在他们的公司Viaweb中使用Lisp和C的组合的原因，Viaweb最终成为了Yahoo!
    Stores。他们之所以能够这样做，是因为CGI规范适用于多种语言。
- en: Preparation and Installation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备和安装
- en: Before we get going with Ruby and CGI, we’ve got to do a little work to get
    our webserver ready. For the purposes of this chapter, I’ll be focusing on getting
    CGI working for the Apache webserver running on a Unix-like environment. Apache
    is the most popular webserver, and Unix-like operating systems are the most common
    (and most stable) server operating systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Ruby和CGI之前，我们需要做一些工作来使我们的Web服务器准备就绪。为了本章的目的，我将专注于在类Unix环境中为Apache Web服务器设置CGI。Apache是最受欢迎的Web服务器，类Unix操作系统是最常见（也是最稳定）的服务器操作系统。
- en: 'You can get a copy of the Apache webserver at [http://httpd.apache.org](http://httpd.apache.org),
    or you can use a package manager to install it. (Mac OS X comes with Apache pre-installed.)
    I used `apt-get` on my Ubuntu system, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://httpd.apache.org](http://httpd.apache.org)获取Apache Web服务器的副本，或者你可以使用包管理器来安装它。（Mac
    OS X预装了Apache。）我在Ubuntu系统上使用了`apt-get`，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I answered `Y`. You can see that I chose the `apache2` version of the Apache
    webserver. After installing Apache, you’ll also want to install packages for `mod_ruby`,
    which allows Ruby programs to be run within the webserver. I’ll explain the benefits
    of this when we get to the script that shows `mod_ruby` being used. You can install
    `mod_ruby` by typing `apt-get install libapache2-mod-ruby liberuby` on a Debian-based
    system. Now that the installation is done, let’s start with our first simple CGI
    script.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我回答了`Y`。你可以看到我选择了Apache Web服务器的`apache2`版本。安装Apache后，你还会想安装`mod_ruby`的包，它允许Ruby程序在Web服务器中运行。当我展示使用`mod_ruby`的脚本时，我会解释它的好处。你可以在基于Debian的系统上通过输入`apt-get
    install libapache2-mod-ruby liberuby`来安装`mod_ruby`。现在安装完成，让我们开始我们的第一个简单的CGI脚本。
- en: '#41 A Simple CGI Script (simple_cgi.rb)'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#41 一个简单的CGI脚本 (simple_cgi.rb)'
- en: This script is fairly quick and dirty, but it shows the basics of how to use
    Ruby for CGI and introduces Ruby’s aptly named `cgi` library. You’ll need to put
    this script in your system’s cgi-bin directory. It’s `/usr/lib/cgi-bin/` on my
    system, although your system’s location may be different. You can then browse
    to http://localhost/cgi-bin/simple_cgi.rb, because your webserver will provide
    access to the contents of your cgi-bin directory via http://localhost/cgi-bin/.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本相当简单，但展示了如何使用Ruby进行CGI的基本方法，并介绍了Ruby的名为`cgi`的库。你需要将这个脚本放在你的系统cgi-bin目录下。在我的系统上，它是`/usr/lib/cgi-bin/`，但你的系统位置可能不同。然后你可以浏览到http://localhost/cgi-bin/simple_cgi.rb，因为你的Web服务器将通过http://localhost/cgi-bin/提供对cgi-bin目录内容的访问。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You’ll also need to give `simple_cgi.rb 755` permissions, meaning that its
    owner can do anything with it and everyone else can read and execute it, but not
    write (change) it. For more information, see *`man chmod`**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还需要给`simple_cgi.rb`设置`755`权限，这意味着它的所有者可以做任何事情，而其他人可以读取和执行它，但不能写入（更改）它。更多信息，请参阅*`man
    chmod`**。'
- en: Before we even get started with the script, you should also browse to http://localhost/.
    If you see either a page telling you that Apache is installed correctly or a listing
    of files in a directory, your webserver is probably working. If you don’t see
    either of these things, consult the Apache documentation (available at http://httpd.apache.org/docs)
    to diagnose the problem. If your webserver is working, you can proceed to the
    script.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始脚本之前，你也应该浏览到http://localhost/。如果你看到的是告诉你Apache安装正确的页面，或者是一个目录中的文件列表，那么你的web服务器可能正在工作。如果你没有看到这两者中的任何一个，请查阅Apache文档（可在http://httpd.apache.org/docs获取）以诊断问题。如果你的web服务器正在工作，你可以继续到脚本。
- en: The Code
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How It Works
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The first thing we do in the script is `require` the `cgi` library at ❶. Then
    we define a class called `Simple_CGI` at ❷ and the Constants `EMPTY_STRING` and
    `TITLE` at ❸. Next, within the `display` method (at ❹), we create an instance
    of `CGI` called `cgi`, defining it in terms of `html4`, which is one of the versions
    of HTML that `CGI` is aware of. We’ll use `cgi` to create an HTML document that
    `simple_cgi.rb` will output.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本中做的第一件事是在❶处`require` `cgi`库。然后我们在❷处定义一个名为`Simple_CGI`的类，并在❸处定义常量`EMPTY_STRING`和`TITLE`。接下来，在`display`方法（在❹处），我们创建了一个名为`cgi`的`CGI`实例，用`html4`来定义它，这是`CGI`所了解的HTML版本之一。我们将使用`cgi`来创建一个`simple_cgi.rb`将要输出的HTML文档。
- en: Instances of `CGI` have several methods that take blocks, whose names are the
    same as the tags they will create. Every HTML document needs an `<html>` tag,
    so we include that at ❺. For reasons I’ll explain shortly, I want to store the
    contents of the `<html>` tag in a temporary local variable called `output`. We
    can go through the HTML document we want to create, opening new tags with the
    appropriate method of `cgi` (like `head, title, h1`, etc.). Hierarchical nesting
    is accomplished using blocks, as you can see, and tags that are at the same level
    (*siblings*) are concatenated with the `+` method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGI`的实例有几个接受块的方法，这些方法的名称与它们将要创建的标签相同。每个HTML文档都需要一个`<html>`标签，所以我们包括它（在❺处）。出于我将要解释的原因，我想将`<html>`标签的内容存储在一个名为`output`的临时局部变量中。我们可以遍历我们想要创建的HTML文档，使用`cgi`的适当方法打开新的标签（如`head,
    title, h1`等）。正如你所看到的，使用块实现了分层嵌套，同一级别的标签（*兄弟标签*）使用`+`方法连接。'
- en: You’ll notice that within `cgi.body`, which creates the `<body>` tag within
    our resulting output, I have used a method at ❻ called `show_def_list` (defined
    at ❿). This is mainly to avoid multiple levels of block nesting for the methods
    of `cgi`, but it also performs other tasks. Let’s examine it at ❿. It outputs
    a definition list as you’d expect using `cgi.dl` with a block. To do so, it pulls
    both `terms` and their `definitions` from a Hash called `items`, wrapping them
    in `<dt>` and `<dd>` tags, respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在`cgi.body`中，它创建了我们输出结果中的`<body>`标签，我在❻处使用了一个名为`show_def_list`的方法（定义在❿处）。这主要是为了避免`cgi`方法的嵌套层级过多，但它也执行其他任务。让我们在❿处检查它。它输出一个定义列表，正如你所期望的那样，使用`cgi.dl`与一个块。为此，它从名为`items`的哈希中提取`terms`和它们的`definitions`，分别用`<dt>`和`<dd>`标签包裹。
- en: The `items` Hash is defined by the output of `get_items_hash` (❽) merged with
    `cgi.params`. The `cgi.params` Hash represents the query string, so if you browse
    to http://localhost/cgi-bin/simple_cgi.rb?key1=value1&key2=value2, `cgi.params`
    would be `{ ‘key1’ => ‘value1’, ‘key2’, ‘value2’ }`. The `get_items_hash` method
    returns a Hash representing some values that I thought might be worth demonstrating,
    such as the script name, the server, and so on. In general, the script simply
    reads from the machine’s environment, using values of the `ENV` Hash. At ❾, the
    value for `‘server’` in the Hash is slightly more complex than the others. It
    tries to read from `ENV` like the others, falling back to a system execution of
    the `hostname` command, and finally falling back to the `EMPTY_STRING`, if necessary.
    This resulting Hash is then returned implicitly, because it’s the last evaluated
    expression in the method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`哈希是由`get_items_hash`（❽）的输出与`cgi.params`合并而成的。`cgi.params`哈希代表查询字符串，所以如果你浏览到http://localhost/cgi-bin/simple_cgi.rb?key1=value1&key2=value2，`cgi.params`将会是`{‘key1’
    => ‘value1’, ‘key2’ => ‘value2’}`。`get_items_hash`方法返回一个哈希，代表一些我认为可能值得展示的值，例如脚本名称、服务器等。一般来说，脚本只是从机器的环境变量中读取，使用`ENV`哈希的值。在❾处，哈希中`‘server’`的值比其他值稍微复杂一些。它尝试像其他值一样从`ENV`中读取，如果需要，回退到系统执行的`hostname`命令，最后回退到`EMPTY_STRING`。然后这个哈希作为方法中的最后一个评估表达式隐式返回。'
- en: Back at ❼, we call `cgi.out`, giving it a block with a slight massaging of the
    `output` variable using `gsub`. I’ll be the first to admit that this is a little
    unusual. Normally, you call `cgi.out` with a block that includes `cgi.html` and
    all the other methods I used to fill the `output` variable. Why did I do it this
    way? There are two related reasons.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❽ 处，我们调用 `cgi.out`，给它一个包含对 `output` 变量进行轻微调整的块，使用 `gsub`。我首先承认这有点不寻常。通常，您会使用包含
    `cgi.html` 和我用来填充 `output` 变量的所有其他方法的块来调用 `cgi.out`。我为什么这样做呢？有两个相关的原因。
- en: 'The first reason is that `cgi.out` is not purely functional: It doesn’t return
    a value to be printed using `puts`. Instead, it does the outputting by itself.
    The second reason is that `cgi`’s methods don’t introduce line breaks between
    tags. This is good for speed optimization, in that each new character, even just
    a line break, is slightly more content to transfer. However, it doesn’t make the
    resulting HTML source very readable. I like readable HTML source, so I use `gsub`
    at ❼ to introduce line breaks between adjacent tags. If you don’t mind your HTML
    all strung together in a single line, by all means, put your `cgi.html` and similar
    calls within the block for `cgi.out`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是 `cgi.out` 并非纯粹的功能性：它不会返回一个使用 `puts` 打印的值。相反，它自己进行输出。第二个原因是 `cgi` 的方法在标签之间不会引入换行符。这对于速度优化是有好处的，因为每个新字符，即使是换行符，都会稍微增加传输的内容。然而，这并不使生成的
    HTML 源代码非常易于阅读。我喜欢可读的 HTML 源代码，所以我在 ❽ 处使用 `gsub` 在相邻标签之间引入换行符。如果您不介意您的 HTML 都连成一行，那么当然，将您的
    `cgi.html` 和类似的调用放在 `cgi.out` 的块中。
- en: 'Everything we have discussed so far has been within the `display` method. We
    call it on the last line of the script, directly on an anonymous new instance
    of `Simple_CGI`. There’s no real need to instantiate it into a variable, like
    so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所讨论的一切都是在 `display` 方法中。我们在脚本的最后一行直接调用它，在一个匿名的 `Simple_CGI` 新实例上。实际上没有必要将它实例化为一个变量，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, if you’re more comfortable doing that, there’s also no reason not to.
    Let’s see how it works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您更习惯这样做，也没有理由不这样做。让我们看看它是如何工作的。
- en: The Results
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: On your system, browse to http://localhost/cgi-bin/simple_cgi.rb and see what
    you get. It should be something more or less like [Figure 11-1](ch11s03.html#the_output_of_ltliteralgtsimple_cgirbltl
    "Figure 11-1. The output of simple_cgi.rb").
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上，浏览到 http://localhost/cgi-bin/simple_cgi.rb 并查看您得到的结果。它应该大致类似于 [图11-1](ch11s03.html#the_output_of_ltliteralgtsimple_cgirbltl
    "图11-1. simple_cgi.rb 的输出")。
- en: Note that the software value will probably differ, unless you’re also using
    a fairly stock Ubuntu system, and the time will obviously differ a great deal.
    You can see that the tab shows the page title, which is *A simple CGI script*
    (the same as the large bold header). Values that should not differ are the script
    and server, unless you’ve intentionally changed the filename from `simple_cgi.rb`
    to something else or browsed to a hostname other than `localhost`. Astute readers
    will also see that I had another tab open to the Apache website.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，软件值可能会不同，除非您也在使用相当标准的 Ubuntu 系统，时间显然会有很大差异。您可以看到，标签显示的是页面标题，即 *一个简单的 CGI
    脚本*（与大的粗体标题相同）。除非您故意将文件名从 `simple_cgi.rb` 改为其他名称或浏览到除 `localhost` 之外的主机名，否则不应有差异的值是脚本和服务器。敏锐的读者也会看到我还有一个打开的
    Apache 网站标签页。
- en: '![The output of simple_cgi.rb](httpatomoreillycomsourcenostarchimages686188.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![simple_cgi.rb 的输出](httpatomoreillycomsourcenostarchimages686188.png.jpg)'
- en: Figure 11-1. The output of `simple_cgi.rb`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1. `simple_cgi.rb` 的输出
- en: Now let’s try changing the query string a bit, with http://localhost/cgi-bin/simple_cgi.rb?lang=Ruby.
    I won’t bother showing a new screenshot, but you should now see five entries in
    the definition list instead of four. The new one is the key `lang`, which has
    a value of `Ruby`. This appears because `cgi.params` is a part of the items Hash
    within `show_def_list` at ❿, and when we use the query string `lang=Ruby, cgi.params`
    is `{ ‘lang’ => ‘Ruby’ }`, which is then one of the pairs in `items`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试稍微改变一下查询字符串，使用 http://localhost/cgi-bin/simple_cgi.rb?lang=Ruby。我不会麻烦展示新的截图，但你现在应该会看到定义列表中有五个条目而不是四个。新的一条是键
    `lang`，其值为 `Ruby`。这是由于 `cgi.params` 是 `show_def_list` 中的项目 Hash 的一部分，当我们使用查询字符串
    `lang=Ruby` 时，`cgi.params` 变为 `{ ‘lang’ => ‘Ruby’ }`，然后它就是 `items` 中的其中一个对。
- en: Now let’s try giving an explicit value within the query string to one of the
    keys that already appears in items, with the URL http://localhost/cgi-bin/simple_cgi.rb?lang=Ruby&server=some_other_server_name.
    You should still see the key `lang` with a value `Ruby`, but in addition, the
    value for `server` is no longer `localhost`, but is instead `some_other_server_name`.
    The reason this happens is that `cgi.params` is the argument to `merge`, and it
    overrides any conflicting pair already in the Hash on which `merge` is called.
    Therefore, anything in `cgi.params` takes precedence.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试在查询字符串中为已经出现在项目中的某个键提供一个显式值，使用URL http://localhost/cgi-bin/simple_cgi.rb?lang=Ruby&server=some_other_server_name。你应该仍然看到键`lang`的值为`Ruby`，但除此之外，`server`的值不再是`localhost`，而是`some_other_server_name`。这种情况发生的原因是`cgi.params`是`merge`的参数，它覆盖了在调用`merge`的哈希中已经存在的任何冲突的键值对。因此，`cgi.params`中的任何内容都优先。
- en: Hacking the Script
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: This is just a simple script showing the basics of CGI. You could modify and
    extend it in countless ways. One suggestion would be to incorporate part of `currency_converter2.rb`.
    For example, you could display the time, just as this script already does, and
    take arguments for the currencies to convert from and to as well as the amount
    of money to convert. Many people also use CGI to execute system calls on a machine
    and display the results, showing the processes running on the machine, how much
    disk space is used, and other information of interest to system administrators.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的脚本，展示了CGI的基础知识。你可以以无数种方式对其进行修改和扩展。一个建议是将其与`currency_converter2.rb`的一部分结合使用。例如，你可以显示时间，就像这个脚本已经做的那样，并接受要转换的货币以及转换的金额作为参数。许多人也使用CGI在机器上执行系统调用并显示结果，展示机器上正在运行的过程、磁盘空间使用情况以及其他对系统管理员感兴趣的信息。
- en: '#42 Mod Ruby (mod_ruby_demo.rhtml and mod_ruby_demo.conf)'
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#42 Mod Ruby (mod_ruby_demo.rhtml 和 mod_ruby_demo.conf)'
- en: CGI is great for many applications. However, sometimes you may want to have
    files that are mainly HTML, with only subsections that need to be executed by
    your programming language, Ruby or otherwise. Wouldn’t it be great if you had
    an HTML tag that meant *Start Ruby code now*, after which you could add some Ruby
    code, and then use another tag that meant *Done with Ruby code, go back to plain
    old HTML*?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CGI对于许多应用来说都很棒。然而，有时你可能希望有一些主要是HTML的文件，只有部分子部分需要由你的编程语言，比如Ruby，来执行。如果有一个HTML标签意味着“现在开始Ruby代码”，之后你可以添加一些Ruby代码，然后使用另一个标签表示“Ruby代码完成，回到普通的HTML”，那岂不是很好？
- en: There is such a system, for many languages. It’s the default behavior for the
    PHP language, and similar systems are available for Perl and Python, among others.
    One of the systems that does this for Ruby is `eRuby`, which will be embedded
    directly within the webserver via the `mod_ruby` software.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多语言来说，都存在这样的系统。这是PHP语言的默认行为，Perl和Python等其他语言也有类似的系统。为Ruby实现这一功能的系统之一是`eRuby`，它将通过`mod_ruby`软件直接嵌入到Web服务器中。
- en: One of the problems with CGI is speed. When someone makes a web request that
    needs dynamic CGI execution, that request spawns a new Ruby interpreter;^([[32](#ftn.CHP-11-FNOTE-1)])
    that interpreter then evaluates the CGI program, returns its value to the webserver
    process, and closes down. For the next CGI request, the whole process start all
    over again. All of this takes time. What `mod_ruby` and similar systems do is
    have a Ruby interpreter always running in the background, ready to evaluate scripts
    and return their results to the webserver, but without the overhead of spawning
    and shutting down a distinct `ruby` process for each script. This makes the webserver
    start up a bit slower, because it needs to do more, but it saves a lot of machine
    overhead after just a few requests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CGI的一个问题是速度。当有人发起一个需要动态CGI执行的Web请求时，该请求会启动一个新的Ruby解释器；^([[32](#ftn.CHP-11-FNOTE-1)])然后该解释器评估CGI程序，将其值返回给Web服务器进程，并关闭。对于下一个CGI请求，整个过程从头开始。所有这些都需要时间。`mod_ruby`和类似系统所做的就是在后台始终运行一个Ruby解释器，随时准备评估脚本并将结果返回给Web服务器，但无需为每个脚本启动和关闭一个独立的`ruby`进程。这使得Web服务器启动稍微慢一些，因为它需要做更多的事情，但只需几个请求之后，它就能节省大量的机器开销。
- en: In the code, you’ll see `<%` and `%>`, the opening and closing tags that mean
    *Interpret my contents in Ruby, not as HTML*. But first we need to set up Apache
    so that it knows how to handle `mod_ruby`. We’ve already installed the `mod_ruby`
    packages, but we need a configuration file. That’s `mod_ruby_demo.conf` below.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，您会看到 `<%` 和 `%>`，这是表示 *将我的内容解释为 Ruby，而不是 HTML* 的开始和结束标签。但首先我们需要设置 Apache，使其知道如何处理
    `mod_ruby`。我们已经安装了 `mod_ruby` 软件包，但我们需要一个配置文件。那就是下面的 `mod_ruby_demo.conf`。
- en: The Code
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: mod_ruby_demo.conf
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mod_ruby_demo.conf
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file isn’t Ruby code—it uses Apache’s configuration file format. Put this
    file in `/etc/apache2/mods-available/`, with a symlink in `/etc/apache2/mod-enabled/`.^([[33](#ftn.CHP-11-FNOTE-2)])
    If you’re using Apache version 1.X (such as 1.3, which is still popular), you’ll
    add the contents of this file within your `/etc/apache/httpd.conf` file. As I
    noted for the `cgi-bin` directory, these specific file and directory locations
    are accurate for my system, but yours might be different.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件不是 Ruby 代码——它使用 Apache 的配置文件格式。将此文件放在 `/etc/apache2/mods-available/` 中，并在
    `/etc/apache2/mod-enabled/` 中创建一个符号链接^([[33](#ftn.CHP-11-FNOTE-2)])。如果您使用的是 Apache
    版本 1.X（例如 1.3，它仍然很受欢迎），您将在 `/etc/apache/httpd.conf` 文件中添加此文件的內容。正如我之前提到的 `cgi-bin`
    目录，这些特定的文件和目录位置适用于我的系统，但您的可能不同。
- en: mod_ruby_demo.rhtml
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mod_ruby_demo.rhtml
- en: This file should be more recognizable as a weird hybrid of HTML and Ruby code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件应该更像是 HTML 和 Ruby 代码的奇怪混合体。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Put this file somewhere browsable via the Web. I’ll assume it’s in http://localhost/mod_ruby/,
    making it accessible as http://localhost/mod_ruby/mod_ruby_demo.rhtml.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件放置在可通过网络浏览的位置。我将假设它在 http://localhost/mod_ruby/，使其可通过 http://localhost/mod_ruby/mod_ruby_demo.rhtml
    访问。
- en: How It Works
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Hopefully, `mod_ruby_demo.conf` will be completely opaque. I’m kidding, of course,
    but it’s not critical at this point if you don’t understand everything about this
    file. It’s great to know about Apache configuration files, and you can certainly
    learn a great deal from the Apache website ([http://www.apache.org](http://www.apache.org))
    or the various Apache-related books out there, but what’s important for our purposes
    are points ❶ and ❷. At ❶, we declare that files having the .rcss extension are
    to be interpreted as Ruby files. At ❷, we make the same declaration about files
    having the .rhtml extension.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 希望地，`mod_ruby_demo.conf` 将是完全透明的。当然，我在开玩笑，但在这个阶段，如果您不理解这个文件的所有内容，并不是关键。了解 Apache
    配置文件是很好的，您当然可以从 Apache 网站或各种 Apache 相关的书籍中学到很多，但对我们来说重要的是 ❶ 和 ❷。在 ❶，我们声明具有 .rcss
    扩展名的文件应被解释为 Ruby 文件。在 ❷，我们对具有 .rhtml 扩展名的文件做了同样的声明。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Why these extensions? It’s a fairly common practice to define filename extensions
    for dynamically interpreted files with the normal extension and an additional
    preceding letter representing the programming language used. For example*, .rhtml
    *is used for Ruby files that generate HTML output*, .rcss *is used for Ruby files
    that generate CSS stylesheets, and so on. You may also sometimes see .phtml files
    that integrate Perl or PHP, or even .mhtml files that use the software Mason,
    written in Perl*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么使用这些扩展名？为动态解释的文件定义文件扩展名，通常使用正常的扩展名，并在前面加上代表所用编程语言的额外字母，这是一种相当常见的做法。例如*，.rhtml
    用于生成 HTML 输出的 Ruby 文件，.rcss 用于生成 CSS 样式表的 Ruby 文件，等等。您有时也可能看到 .phtml 文件，它集成了 Perl
    或 PHP，甚至 .mhtml 文件，它使用的是用 Perl 编写的软件 Mason*。'
- en: 'That’s it for `mod_ruby_demo.conf`. In `mod_ruby_demo.rhtml`, we have some
    additional points of interest. It should look like standard HTML until ❸. At that
    point, we see this line: `<q><% print “Hello, world!” %></q>`. The `<%` and `%>`
    are the *Interpret my contents as* Ruby tags I mentioned earlier, so anything
    within those tags will be interpreted as Ruby code. In this case, we’re asking
    Ruby to print `‘Hello, world!’`, which it does, incorporating the printed output
    within the eventual HTML.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod_ruby_demo.conf` 的内容到此为止。在 `mod_ruby_demo.rhtml` 中，我们有一些额外的关注点。它应该看起来像标准的
    HTML，直到 ❸。在那个点上，我们看到这一行：`<q><% print “Hello, world!” %></q>`。`<%` 和 `%>` 是我之前提到的
    *将我的内容解释为* Ruby 标签，所以那些标签内的任何内容都将被解释为 Ruby 代码。在这种情况下，我们要求 Ruby 打印 `‘Hello, world!’`，它确实这样做了，将打印的输出包含在最终的
    HTML 中。'
- en: You’ll probably expect that we often want to print output that will be incorporated
    into the HTML. It would be tedious to keep using `print` statements, so there’s
    a shortcut, which you can see at ❹. If you use an initial code tag of `<%=`, Ruby
    assumes that you want the evaluated expression to be printed. At ❹, we incorporate
    the value of `ENV[‘SERVER_NAME’]` within an `<em>` tag. Just to show that what
    falls between `<%=` and `%>` can be any expression, at ❺, we concatenate two Strings,
    only caring about the result.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预期我们经常想要打印出将被整合到HTML中的输出。不断地使用`print`语句会很繁琐，所以有一个快捷方式，你可以在❹处看到。如果你使用一个初始的代码标签`<%=`,
    Ruby就会假设你想要打印出评估后的表达式。在❹处，我们在一个`<em>`标签内整合了`ENV[‘SERVER_NAME’]`的值。为了展示在`<%=`和`%>`之间的内容可以是任何表达式，在❺处，我们连接了两个字符串，只关心结果。
- en: The printed output doesn’t have to be a simple literal expression, either. At
    ❻, I show the value of a method call, which in this case results in the current
    local time. Finally, at ❼, we define a completely new method within our .rhtml
    file called `function_within_mod_ruby`, which is then available anytime afterward
    for use, as you can see in the code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的输出也不一定是简单的字面表达式。在❻处，我展示了方法调用的值，在这种情况下结果是当前本地时间。最后，在❼处，我们在.rhtml文件中定义了一个全新的方法，名为`function_within_mod_ruby`，之后任何时候都可以使用，如代码所示。
- en: The Results
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: When I call this script via my own webserver, I get the results shown in [Figure 11-2](ch11s04.html#the_output_from_ltliteralgtmod_rubyltlit
    "Figure 11-2. The output from mod_ruby").
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我通过自己的web服务器调用这个脚本时，我得到了[图11-2](ch11s04.html#the_output_from_ltliteralgtmod_rubyltlit
    "图11-2. mod_ruby的输出")中显示的结果。
- en: '![The output from mod_ruby](httpatomoreillycomsourcenostarchimages686172.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![mod_ruby的输出](httpatomoreillycomsourcenostarchimages686172.png.jpg)'
- en: Figure 11-2. The output from `mod_ruby`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2. `mod_ruby`的输出
- en: The time will obviously be different in your result, but that should be the
    only difference, unless you specifically browse to your machine by a name other
    than `localhost`, or you placed `mod_ruby_demo.rhtml` under a different directory
    or gave it a different name.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果中的时间显然会有所不同，但那应该是唯一的区别，除非你通过除`localhost`之外的名字浏览你的机器，或者你将`mod_ruby_demo.rhtml`放在不同的目录下或给它不同的名字。
- en: Hacking the Script
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: This script is a modification playground. You can put any Ruby expressions you
    want within those `<%` or `<%=` tags. Try using `require`, either with files that
    you know are part of the standard library (like `cgi`) or your own files. This
    technique lets you define all your real “things” as classes in .rb library files,
    reserving your .rhtml files for display.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是一个修改的游乐场。你可以在那些`<%`或`<%=`标签内放置任何你想要的Ruby表达式。尝试使用`require`，无论是你知道是标准库的一部分的文件（如`cgi`）还是你自己的文件。这种技术让你可以将所有真正的“东西”定义为类，放在.rb库文件中，而将.rhtml文件保留用于显示。
- en: '* * *'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[32](#CHP-11-FNOTE-1)]) Or an interpreter for whichever language the CGI
    program uses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#CHP-11-FNOTE-1)]) 或者是CGI程序使用的语言的解释器。
- en: ^([[33](#CHP-11-FNOTE-2)]) You can create a symlink with the command `ln -s`
    in a Unix shell.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[33](#CHP-11-FNOTE-2)]) 你可以在Unix shell中使用`ln -s`命令创建一个符号链接。
- en: '#43 CSS Stylesheets, Part I (stylesheet.rcss)'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#43 CSS样式表，第一部分 (stylesheet.rcss)'
- en: Having .rhtml files is great—they allow you to dynamically generate whatever
    visible HTML you want. But you can use `mod_ruby` for more than that. A major
    portion of any well-designed modern website will be its stylesheets. One of the
    frustrations that web designers have to deal with is incomplete or incompatible
    CSS support among the various browsers. There are lots of potential solutions
    for those frustrations, which you can find at sites like [http://www.richinstyle.com](http://www.richinstyle.com)
    or [http://alistapart.com](http://alistapart.com). One obvious solution for programmers
    is to determine exactly which browser someone is using (via `ENV[‘USER_AGENT’]`)
    and serve that user a stylesheet customized for his or her specific browser.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有.rhtml文件是很好的——它们允许你动态生成你想要的任何可见HTML。但你可以使用`mod_ruby`做更多的事情。任何设计良好的现代网站的大部分内容将是其样式表。网页设计师必须处理的一个挫折是各种浏览器之间不完整或不兼容的CSS支持。对于这些挫折有很多潜在的解决方案，你可以在像[http://www.richinstyle.com](http://www.richinstyle.com)或[http://alistapart.com](http://alistapart.com)这样的网站上找到。对于程序员来说，一个明显的解决方案是确定某人正在使用哪种浏览器（通过`ENV[‘USER_AGENT’]`），并为该用户提供一个针对其特定浏览器的定制样式表。
- en: That’s a great solution, put into practice countless times all over the Web.
    There is another solution, however. Why not make the stylesheet itself a dynamic
    .rcss file? With this approach, the stylesheet becomes polymorphic, to use a term
    from object-oriented programming. Every browser would refer to the same stylesheet
    by name and would then receive specific content that works just right for that
    browser. Here’s an example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的解决方案，在网络上被无数次地付诸实践。然而，还有一个解决方案。为什么不将样式表本身做成一个动态的 .rcss 文件呢？采用这种方法，样式表就变成了多态的，这是从面向对象编程中借用的一个术语。每个浏览器都会通过名称引用相同的样式表，然后接收针对该浏览器恰好合适的内容。以下是一个例子。
- en: The Code
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How It Works
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Much like `mod_ruby_demo.rhtml`, this is mainly a file with some other format
    (in this case a CSS stylesheet) that happens to have a little Ruby interspersed
    within it. We define a new function called `alpha_width` at ❶ that determines
    the value of a local variable called `width`, finally returning it within a bit
    of text that follows CSS formatting at ❷. Note that this function takes advantage
    of the fact that even `if` statements in Ruby return a value, in this case, assigning
    that value into `width`. We do something similar with `beta_width` at ❸, which
    returns its own CSS-formatted output at ❹. Finally, we define `margin_left` at
    ❺, which returns CSS at ❻.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `mod_ruby_demo.rhtml` 类似，这主要是一个具有其他格式（在这种情况下是一个 CSS 样式表）的文件，它恰好包含一些 Ruby 代码。我们在
    ❶ 处定义了一个名为 `alpha_width` 的新函数，该函数确定一个名为 `width` 的局部变量的值，最终在遵循 CSS 格式的文本中返回它 ❷。请注意，这个函数利用了
    Ruby 中的 `if` 语句也会返回值的这一事实，在这种情况下，将那个值赋给 `width`。我们在 ❸ 处对 `beta_width` 做了类似的事情，它返回自己的
    CSS 格式化输出 ❹。最后，我们在 ❺ 处定义了 `margin_left`，它返回 ❻ 的 CSS。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Why those particular functions? I found that the CSS support variations that
    frustrated me the most were the differences involving margins and padding and
    left margins for list items, so those are the functions I made. People who know
    more about CSS than I do have probably found more elegant solutions, but sometimes
    a pretty good solution now is better than a perfect solution when it’s too late.
    The point of this script is also to demonstrate that the polymorphic stylesheet
    technique* can *be done, but this isn’t precisely* how *it should be done. If
    you care a great deal about CSS, you can use this technique to accomplish much
    bigger things*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么是那些特定的函数？我发现最让我沮丧的 CSS 支持差异涉及边距和填充以及列表项的左边距，所以我就做了这些函数。比我更了解 CSS 的人可能已经找到了更优雅的解决方案，但有时，当为时已晚时，一个相当不错的解决方案比一个完美的解决方案更好。这个脚本的目的也是为了证明多态样式表技术*是可以做到的，但这并不是*它应该被做到的方式。如果你非常关心
    CSS，你可以使用这种技术来完成更大的事情*。'
- en: Then we use the output of `margin_left` within a CSS declaration for a list
    element at ❼. The stylesheet also defines two IDs called `#navAlpha` and `#navBeta`,
    which are just identifiers for column divs. Within `#navAlpha` at ❽, we use the
    output of `alpha_width` for the width of `#navAlpha`, and at ❾, we do something
    analogous for `#navBeta`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在列表元素的 CSS 声明中使用 `margin_left` 的输出 ❼。样式表还定义了两个 ID，即 `#navAlpha` 和 `#navBeta`，它们只是列
    div 的标识符。在 `#navAlpha` ❽ 中，我们使用 `alpha_width` 的输出作为 `#navAlpha` 的宽度，在 ❾ 中，我们对
    `#navBeta` 做了类似的事情。
- en: The Results
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here’s the output of `stylesheet.rcss` when I browse to it using Mozilla Firefox
    on an Ubuntu system:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 Ubuntu 系统上的 Mozilla Firefox 浏览 `stylesheet.rcss` 时的输出：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You’ll notice that the appropriate values are interpolated within the `li` and
    `width` CSS declarations. Your results may differ, since the whole point of this
    file is to provide different output for different browsers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，适当的值被插值在 `li` 和 `width` CSS 声明之间。由于这个文件的全部目的就是为不同的浏览器提供不同的输出，所以你的结果可能会有所不同。
- en: Hacking the Script
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑客脚本
- en: There are many hacking options for this script. One is our next script, `stylesheet2.rcss`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，有很多黑客选项。其中一个是我们下一个脚本，`stylesheet2.rcss`。
- en: '#44 CSS Stylesheets, Part II (stylesheet2.rcss)'
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#44 CSS 样式表，第二部分（stylesheet2.rcss）'
- en: In many ways, this script is just a glorified hack of `stylesheet.rcss`. I separated
    it mainly to allow for comparison. The major difference between the two files
    is that `stylesheet2.rcss` generalizes the `width` values into a single function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这个脚本只是 `stylesheet.rcss` 的一个美化版黑客。我主要将其分离出来，以便进行比较。这两个文件之间的主要区别在于 `stylesheet2.rcss`
    将 `width` 值概括为一个单一函数。
- en: The Code
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How It Works
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'At ❶, we define the general `width` function, which you’ll see now takes two
    arguments: the user agent as before, but also the `type` of column we’re generating
    `width` for. We then have separate Hashes for `small` (❷), `large` (❸), and `palm`
    (❹). Palm devices always use their own Hash, while other browsers use either the
    `small` or `large` Hash, depending on the specific user agent. Then at ❺, we determine
    the `width`.^([[34](#ftn.CHP-11-FNOTE-3)]) The `type` is simply the key for whichever
    Hash has already been decided on. Everything else is identical to `stylesheet.rcss`,
    except that calls to either `alpha_width` or `beta_width` are now calls to `width`,
    as described already.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，我们定义了通用的 `width` 函数，您现在会看到它现在接受两个参数：与之前一样，用户代理，但还包括我们正在为它生成 `width` 的列的
    `type`。然后我们有针对 `small`（❷）、`large`（❸）和 `palm`（❹）的单独的 Hash。Palm 设备始终使用它们自己的 Hash，而其他浏览器则根据特定的用户代理使用
    `small` 或 `large` Hash。然后在 ❺ 处，我们确定 `width`。^([[34](#ftn.CHP-11-FNOTE-3)]) `type`
    只是已经决定的 Hash 的键。其他一切都是与 `stylesheet.rcss` 相同的，除了现在对 `alpha_width` 或 `beta_width`
    的调用现在是 `width` 的调用，如之前所述。
- en: The Results
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: As before, here’s the output with my setup.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是我的设置下的输出。
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This output is basically the same as that for `stylesheet.rcss`, except for
    the preliminary comments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出基本上与 `stylesheet.rcss` 的输出相同，只是没有初步注释。
- en: Hacking the Script
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: As I already noted, someone with a better grasp of CSS could really customize
    this script to do some marvelous things. There are undoubtedly better ways to
    accomplish what this script does, but its point was to show the technique in broad
    strokes. I hope you found it useful.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，如果对 CSS 有更深入理解的人，可以真正定制这个脚本，使其做一些奇妙的事情。毫无疑问，完成这个脚本所做事情的方法有很多种，但它的目的是以粗略的方式展示技术。希望您觉得它有用。
- en: '* * *'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[34](#CHP-11-FNOTE-3)]) Don’t be confused by the fact that there is both
    a function called `width` and a local variable inside it also called `width`.
    Anything outside the function can’t get at the variable, and the function knows
    to check whether or not there’s a variable by that name before automatically making
    a recursive call to itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#CHP-11-FNOTE-3)]) 不要因为存在一个名为 `width` 的函数和一个内部也称为 `width` 的局部变量而感到困惑。函数外部无法访问变量，函数知道在自动递归调用自身之前检查是否存在名为该名称的变量。
- en: Chapter Recap
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: What was new in this chapter?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有哪些新内容？
- en: Using Ruby for CGI scripts
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ruby 进行 CGI 脚本
- en: The `cgi` library
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cgi` 库'
- en: '`cgi.params`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cgi.params`'
- en: '`mod_ruby`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod_ruby`'
- en: .rhtml and .rcss files
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .rhtml 和 .rcss 文件
- en: Apache configuration files
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache 配置文件
- en: This chapter scratches the surface of CGI programming, with Ruby or other languages.
    Its purpose was to get you comfortable with using Ruby to interact with a webserver
    and browser. Most web-based coding in Ruby makes use of the Rails framework, which
    we’ll get to soon. But first, we’ll be installing Rails with the RubyGems system,
    so that is the subject of our next chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅对使用 Ruby 或其他语言进行的 CGI 编程进行了初步探讨。其目的是让您熟悉使用 Ruby 与 web 服务器和浏览器交互。大多数基于 Ruby
    的网络编码都使用了 Rails 框架，我们很快就会涉及到。但首先，我们将使用 RubyGems 系统安装 Rails，这就是我们下一章的主题。
