- en: '![](../images/43-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/43-1.jpg)'
- en: '[USING RUN-TIME ACCESS](toc.html#chapter3)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用运行时访问](toc.html#chapter3)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/as.jpg)'
- en: 'This chapter gives you a practical introduction to developing Linux appliances
    with the RTA library. Consider this your “Hello, world!” example. In this chapter,
    we’ll discuss the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了使用 RTA 库开发 Linux 设备的实用介绍。请将此视为您的“Hello, world!”示例。在本章中，我们将讨论以下内容：
- en: • RTA appliance architecture
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: • RTA 设备架构
- en: • RTA daemon architecture
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: • RTA 守护进程架构
- en: • Telling RTA about your columns and tables
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • 告诉 RTA 关于您的列和表的信息
- en: • Building your first RTA program
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 构建您的第一个 RTA 程序
- en: • A little SQL
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 一点 SQL
- en: • An introduction to RTA’s built-in tables
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • RTA 内置表的简介
- en: • The RTA table editor
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • RTA 表编辑器
- en: '[**RTA Appliance Architecture**](toc.html#chapter3.1)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RTA 设备架构**](toc.html#chapter3.1)'
- en: You may recall from the last chapter that there were several reasons to put
    a well-defined protocol between the UI programs and the daemon. A protocol offers
    reduced complexity in both the UI and the daemon, gives access to the daemon while
    it is running, lets you work on and test the UIs and daemon independently, and
    helps improve security. The important requirements for the protocol are that the
    protocol’s data model matches your view of the data, that you don’t have to define
    or write the protocol yourself, and that the protocol will be available for most
    UI programming languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得上一章中，在 UI 程序和守护进程之间放置一个定义良好的协议有多个原因。协议在 UI 和守护进程中都提供了简化的复杂性，在守护进程运行时提供对守护进程的访问，允许您独立地工作并测试
    UI 和守护进程，并有助于提高安全性。协议的重要要求是协议的数据模型与您对数据的看法相匹配，您不必自己定义或编写协议，并且协议将对大多数 UI 编程语言可用。
- en: The data model we use in this book is that of a database. Because we view our
    arrays of structures as tables of data, the UI programs (or *clients*) see the
    data in the daemon as data in a database. While the UI programs think they are
    dealing with a PostgreSQL database, they are, in fact, talking to the daemon.
    This arrangement results in an appliance architecture similar to that shown in
    Figure 3-1, in which a framebuffer UI uses the PostgreSQL C language binding in
    libpq.so; the web UI uses the PostgreSQL PHP binding in pgsql.so; and the test
    and debug UI uses the command line program psql.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中使用的数据模型是数据库。因为我们把我们的结构数组看作是数据表，所以 UI 程序（或 *客户端*）将守护进程中的数据视为数据库中的数据。虽然
    UI 程序认为它们正在处理 PostgreSQL 数据库，但实际上它们是在与守护进程通信。这种安排导致了一种类似于图 3-1 所示的设备架构，其中帧缓冲区
    UI 使用 libpq.so 中的 PostgreSQL C 语言绑定；Web UI 使用 pgsql.so 中的 PostgreSQL PHP 绑定；测试和调试
    UI 使用命令行程序 psql。
- en: '![](../images/44-1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/44-1.jpg)'
- en: '*Figure 3-1: A sample appliance using RTA*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：使用 RTA 的示例设备*'
- en: After connecting to the daemon over a Unix or TCP socket, the UIs shown in Figure
    3-1 can display the configuration, status, and statistics available in the daemon.
    The librtadb.so library presents the daemon’s data as if it were coming from a
    PostgreSQL database. This figure shows the PostgreSQL client-side binding that
    we use in this book, but many more language bindings are available including Java,
    Python, Tcl, Perl, and Microsoft C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 Unix 或 TCP 套接字连接到守护进程后，如图 3-1 所示的 UI 可以显示守护进程中可用的配置、状态和统计信息。librtadb.so
    库将守护进程的数据呈现为来自 PostgreSQL 数据库。此图显示了本书中使用的 PostgreSQL 客户端绑定，但还有许多其他语言绑定可用，包括 Java、Python、Tcl、Perl
    和 Microsoft C++。
- en: Figure 3-1 offers a global view of the appliance. Now let’s look at how RTA
    works inside the daemon.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1 提供了该设备的全局视图。现在让我们看看 RTA 在守护进程内部是如何工作的。
- en: '[**RTA Daemon Architecture**](toc.html#chapter3.2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RTA 守护进程架构**](toc.html#chapter3.2)'
- en: Adding RTA to your daemon is fairly straightforward, since it usually involves
    using only two routines from the library. The first routine, rta_add_table(),
    makes one of your daemon’s tables visible to the clients. The second routine,
    dbcommand(), handles the protocol and SQL commands from the clients. Figure 3-2
    illustrates a daemon offering RTA access to two UI-visible tables.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将 RTA 添加到您的守护进程相对简单，因为它通常只需要使用库中的两个例程。第一个例程，rta_add_table()，使您的守护进程中的一个表对客户端可见。第二个例程，dbcommand()，处理来自客户端的协议和
    SQL 命令。图 3-2 阐述了一个提供 RTA 访问两个 UI 可见表的守护进程。
- en: '![](../images/45-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/45-1.jpg)'
- en: '*Figure 3-2: A daemon using RTA*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：使用 RTA 的守护进程*'
- en: The dbcommand() routine does not communicate directly with the client. Your
    program must create a listening TCP or Unix socket and must be able to accept
    and manage connections from the UI or other clients. Once a connection is established,
    all data from the connection should be passed to RTA with a call to dbcommand().
    The dbcommand() routine parses the SQL command in the request from the client;
    if the request is valid, it executes the SQL command and returns a buffer with
    any data to be sent back to the client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: dbcommand()例程不直接与客户端通信。您的程序必须创建一个监听TCP或Unix套接字，并且必须能够接受和管理来自UI或其他客户端的连接。一旦建立连接，应通过调用dbcommand()将连接的所有数据传递给RTA。dbcommand()例程解析来自客户端请求中的SQL命令；如果请求有效，它将执行SQL命令并返回一个包含要发送回客户端的任何数据的缓冲区。
- en: RTA would be of limited usefulness if all it could do was read and write values
    in your tables. Its real power lies in its ability to call a routine when ever
    a UI reads or writes a value into one of your tables. These read and write *callbacks*
    are similar to traditional database triggers. Callbacks are tied to the column
    definition and are specified separately for reads and writes. (We describe callbacks
    in the more detail in the next section.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果RTA只能读取和写入您表中的值，那么它的实用性将非常有限。它的真正力量在于它能够在UI读取或写入您表中的值时调用例程。这些读取和写入*回调*类似于传统的数据库触发器。回调与列定义相关联，并且分别针对读取和写入进行指定。（我们将在下一节中更详细地描述回调。）
- en: '[**Telling RTA About Your Columns and Tables**](toc.html#chapter3.3)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[**向RTA告知您的列和表**](toc.html#chapter3.3)'
- en: A table is an array or linked list of data structures. Each member of your data
    structure is considered to be a column in a table, and each instance of the data
    structure is considered to be a row. From this point on, when you see the term
    *column*, think *member of my data structure*. In order to make a table visible
    to clients, you need to describe the table in a way that RTA can understand. This
    means describing the table as a whole and then describing each column in the table.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表是数据结构数组和链表的集合。您的数据结构中的每个成员被视为表中的一列，每个数据结构的实例被视为一行。从现在开始，当您看到术语*列*时，请考虑*我的数据结构中的成员*。为了使表对客户端可见，您需要以RTA可以理解的方式描述表。这意味着描述整个表，然后描述表中的每一列。
- en: A TBLDEF structure describes the table as a whole; it contains a pointer to
    an array of column definitions with a COLDEF structure to define each column in
    your data table. At first you may find the process of creating COLDEFs and TBLDEFs
    painstaking and tedious, but once you have a little experience, you’ll find it
    simple and mechanical.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TBLDEF结构描述了整个表；它包含一个指向由COLDEF结构组成的数组的指针，以定义数据表中的每一列。最初您可能会发现创建COLDEFs和TBLDEFs的过程既繁琐又乏味，但一旦您有一些经验，您会发现它既简单又机械。
- en: '[***Columns***](toc.html#chapter3.4)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[***列***](toc.html#chapter3.4)'
- en: One big advantage of RTA is that you don’t need to marshal the data into and
    out of the protocol. RTA uses your data as it already exists in your program.
    Of course, you have to describe your data so that RTA can access it intelligently.
    A table is made up of columns, and we need to describe each column in the table.
    This is the purpose of RTA’s COLDEF data structure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: RTA的一个大优点是您不需要将数据在协议中序列化和反序列化。RTA使用您程序中已经存在的数据。当然，您必须描述您的数据，以便RTA能够智能地访问它。表由列组成，我们需要描述表中的每一列。这就是RTA的COLDEF数据结构的目的。
- en: You can also have members in your data structure that are not defined by a COLDEF.
    Such hidden columns might include information that you do not want to be visible
    to the UIs, or binary data that would have no meaning if it was displayed to the
    user.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据结构中也可以有不是由COLDEF定义的成员。这些隐藏的列可能包括您不希望对UI可见的信息，或者如果显示给用户将没有意义的二进制数据。
- en: A COLDEF contains nine pieces of information about each of your structure’s
    members.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: COLDEF包含关于您结构成员的九条信息。
- en: '![](../images/46-1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/46-1.jpg)'
- en: '**table**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表**'
- en: The table field specifies the name of the table as seen from the UI programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表字段指定了从UI程序中看到的表名。
- en: '**name**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**'
- en: The name field specifies the name of the column. Use this name when selecting
    or updating this column.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 名称字段指定了列的名称。在选择或更新此列时使用此名称。
- en: '**type**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**'
- en: 'The type of the column is used for syntax checking and for SQL SELECT output
    formatting. The currently defined types include:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列的类型用于语法检查和SQL SELECT输出格式化。当前定义的类型包括：
- en: '![](../images/46-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/46-2.jpg)'
- en: '**length**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**length**'
- en: RTA uses the native compiler data types in order to match the data types you
    use in your structures. The length member is ignored for integers, longs, floats,
    and their associated pointer types, but it has meaning for strings and pointers
    to strings, both of which should report the number of bytes in the string (including
    the terminating null).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: RTA使用本地编译器数据类型以匹配您在结构中使用的数据类型。对于整数、长整型、浮点型和它们相关的指针类型，长度成员被忽略，但对于字符串和字符串指针，它具有意义，两者都应报告字符串中的字节数（包括终止的空字符）。
- en: '**offset**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**offset**'
- en: The offset is the number of bytes from the start of the data structure to the
    structure member being described. For example, a table using a data structure
    with an int, a 20-character string, and a long would have the offset to the long
    set to 24 (assuming it was a 4-byte int).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量是从数据结构开始到正在描述的结构成员的字节数。例如，使用具有int、20个字符的字符串和长整型的数据结构的表会将长整型的偏移量设置为24（假设int是4字节）。
- en: Computing the offset of a structure member is painstaking and error prone. The
    gcc compiler suite provides the offsetof() macro to automatically compute the
    offset of the structure member.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结构成员的偏移量是费时且容易出错的。gcc编译器套件提供了offsetof()宏来自动计算结构成员的偏移量。
- en: '**flags**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**flags**'
- en: 'A column has two binary attributes that are specified by the flags member.
    The first attribute specifies whether the column can be overwritten or if it is
    read-only. Statistics are often marked as read-only. An error is generated if
    a column marked as read-only is the subject in an UPDATE statement. The #define
    for this attribute is RTA_READONLY.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列有两个由标志成员指定的二进制属性。第一个属性指定列是否可以被覆盖或是否为只读。统计信息通常被标记为只读。如果标记为只读的列是UPDATE语句的主题，则生成错误。此属性的#define是RTA_READONLY。
- en: 'The second attribute specifies whether or not values written to this column
    should be saved in a configuration file associated with the table. Values that
    should persist from one invocation of the program to the next should be marked
    with the #define RTA_DISKSAVE attribute.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性指定是否将写入此列的值保存到与表关联的配置文件中。应该从一次程序调用持续到下一次调用的值应使用#define RTA_DISKSAVE属性标记。
- en: The flags field is the bitwise OR of RTA_DISKSAVE and RTA_READONLY.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 标志字段是RTA_DISKSAVE和RTA_READONLY的按位或。
- en: '**readcb()**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**readcb()**'
- en: If defined, the *read callback* routine, readcb(), is called every time the
    column’s value is used. This is handy for values that take lots of CPU cycles
    to compute but that are used infrequently. A read callback is invoked each time
    the column is referenced—if your SQL statement uses the column name twice, the
    read callback is called twice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了，每次列的值被使用时都会调用*读取回调*例程readcb()。这对于计算量大但使用频率不高的值来说很方便。每次引用列时都会调用读取回调——如果你的SQL语句使用了列名两次，则读取回调会被调用两次。
- en: 'The read callback is passed five parameters: the table name, the column name,
    the text of the SQL request, a pointer to the row affected, and the zero-indexed
    row number. A function prototype for a read callback is shown below.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 读取回调传递五个参数：表名、列名、SQL请求的文本、受影响的行指针以及零索引的行号。以下是一个读取回调的函数原型。
- en: int readcb(char *tbl, char *col, char *sql, void *pr, int rowid);
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: int readcb(char *tbl, char *col, char *sql, void *pr, int rowid);
- en: A read callback returns zero on success and an error code if an error occurred
    in the callback. (See Appendix A for a list of the error codes and more details
    on callbacks.) Check the return value in your clients in order to enhance reliability
    and security.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 读取回调在成功时返回零，如果回调中发生错误则返回错误代码。（有关错误代码的列表和回调的更多详细信息，请参阅附录A。）请检查客户端的返回值以增强可靠性和安全性。
- en: '**writecb()**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**writecb()**'
- en: '*Write callbacks* can be the real engine driving your application. If defined,
    the write callback, writecb(), is called after all columns in an UPDATE have been
    changed. Consider the following SQL command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*写回调*可以是驱动您应用程序的真正引擎。如果定义了，则在UPDATE中的所有列都已更改后调用写回调writecb()。考虑以下SQL命令：'
- en: UPDATE ifcfg SET addr="192.168.1.1", mask = "255.255.255.0";
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ifcfg SET addr="192.168.1.1", mask = "255.255.255.0";
- en: If there is a write callback on addr, it will be called after both addr and
    mask have been updated. RTA does the write callback after all the fields have
    updated in order to help maintain consistency.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在addr上有写回调，它将在addr和mask都已更新后调用。RTA在所有字段都已更新后执行写回调，以帮助保持一致性。
- en: 'Write callbacks are passed six parameters: the table name, the column name,
    the text of the UPDATE statement, a pointer to the row affected, the zero-indexed
    row number, and a pointer to a copy of the row before any changes were made. (This
    last parameter is useful when you want to know both the old and new values for
    the row.) The copy of the old row is in dynamically allocated memory, which is
    freed after the write callback returns. A function prototype for a write callback
    is shown below.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 写回调传递六个参数：表名、列名、UPDATE语句的文本、受影响的行的指针、零索引的行号以及一个指向在更改之前所做的行的副本的指针。（此参数在您想同时知道行的旧值和新值时非常有用。）旧行的副本在动态分配的内存中，在写回调返回后释放。以下是一个写回调函数的原型。
- en: int writecb(char *tbl, char *col, char *sql, void *pr, int rowid, void *poldrow);
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: int writecb(char *tbl, char *col, char *sql, void *pr, int rowid, void *poldrow);
- en: The write callback returns zero on success and nonzero on failure. On failure,
    the row is restored to its initial value and an SQL error, TRIGGERED ACTION EXCEPTION,
    is returned to the client. Write callbacks allow you to enforce consistency and
    can provide security checks for your system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 写回调在成功时返回零，在失败时返回非零值。在失败的情况下，行将恢复到其初始值，并向客户端返回一个SQL错误，触发动作异常。写回调允许您强制执行一致性，并可以为您的系统提供安全检查。
- en: '**help**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**帮助**'
- en: Your help text for the column should include a description of how the column
    is used, any limits or constraints on the column, and the side effects caused
    by any read or write callbacks. (Give yourself and your fellow developers meaningful
    help text for your columns to make it easier to maintain and troubleshoot your
    code.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您的列帮助文本应包括对列如何使用的描述，列的任何限制或约束，以及由任何读取或写回调引起的副作用。（为您的列提供有意义的帮助文本，以便更容易维护和调试您的代码。）
- en: '[***Tables***](toc.html#chapter3.5)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[***表格***](toc.html#chapter3.5)'
- en: You tell RTA about each of your tables with a call to the RTA routine rta_add_table().
    The single parameter to rta_add_table() is a pointer to a TBLDEF structure that
    describes the table.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过调用RTA例程rta_add_table()来告诉RTA关于您的每个表。rta_add_table()的单个参数是描述表的TBLDEF结构的指针。
- en: The TBLDEF structure uses 10 pieces of information to describe your table. The
    most critical of these are the name of the table, the start address of the array
    of structures, the width of each structure (that is, the width of each row), the
    number of rows, and a pointer to an array of COLDEF structures that describe the
    columns in the table. Most of the fields in the TBLDEF structure should be self-explanatory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TBLDEF结构使用10条信息来描述您的表。其中最重要的是表名、结构数组的起始地址、每个结构的宽度（即每行的宽度）、行数以及指向描述表中列的COLDEF结构数组的指针。TBLDEF结构中的大多数字段应该是自解释的。
- en: '![](../images/48-1.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/48-1.jpg)'
- en: '![](../images/49-1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/49-1.jpg)'
- en: '**savefile**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**保存文件**'
- en: The need to save configuration data from one boot of the appliance to the next
    is so common that the authors of RTA included the ability to automatically save
    table data in a file when the data is updated. There is one file per table, and
    the name of the file is specified in the TBLDEF structure as the savefile string.
    You can mark the columns to save by adding the RTA_DISKSAVE flag to the column
    definition.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个启动到下一个启动保存配置数据的需求如此普遍，以至于RTA的作者包括了在数据更新时自动将表数据保存到文件中的功能。每个表有一个文件，文件名在TBLDEF结构中作为保存文件字符串指定。您可以通过向列定义中添加RTA_DISKSAVE标志来标记要保存的列。
- en: The save file contains a list of UPDATE statements, one for each row in the
    table. The save file is read from the disk and applied to the table when you initialize
    the table with the rta_add_table() call. The combination of RTA_DISKSAVE on a
    column and a savefile for the table eliminates the need to parse XML or INI files
    to get initial or saved configuration values. Of course, you can use XML or INI
    if you prefer to—just set the savefile pointer to a null.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件包含一个UPDATE语句列表，每个表中的一行一个。当您使用rta_add_table()调用初始化表时，从磁盘读取保存文件并将其应用于表。在列上使用RTA_DISKSAVE和表的保存文件组合消除了解析XML或INI文件以获取初始或保存配置值的需求。当然，如果您更喜欢使用XML或INI，只需将保存文件指针设置为null。
- en: '**iterator**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**'
- en: An *iterator* is a subroutine in your code that steps through a linked list
    or other arrangement of the rows in your table. The iterator lets you treat a
    linked list, a B-tree, or just about any other scheme for organizing data as if
    the data was in a table.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器* 是你代码中的一个子程序，它遍历你表中行的链表或其他排列。迭代器让你可以将链表、B 树或几乎任何其他组织数据的方式视为数据在表中。'
- en: 'The iterator function is called with three parameters: a pointer to the current
    row, the void pointer it_info from the TBLDEF, and the zero-indexed row number.
    The function returns a pointer to the next row. When RTA asks for the first row,
    the current row pointer is NULL, and the desired row index is zero. The function
    should return a NULL when RTA asks for the row after the last row in the list.
    If an iterator is defined, the address and nrows members in the TBLDEF are ignored.
    Here is its function prototype.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代函数使用三个参数调用：当前行的指针，来自 TBLDEF 的 void 指针 it_info，以及零索引的行号。函数返回下一行的指针。当 RTA 请求第一行时，当前行指针是
    NULL，所需的行索引为零。当 RTA 请求列表中最后一行之后的行时，函数应返回 NULL。如果定义了迭代器，TBLDEF 中的地址和 nrows 成员将被忽略。以下是它的函数原型。
- en: void iterator(void *cur_row, void *it_info, int rowid);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: void iterator(void *cur_row, void *it_info, int rowid);
- en: 'There is one caveat when using iterator functions: Loading a save file may
    fail if you have not already allocated all the links in the linked list. (Remember,
    the save file is a list of UPDATE statements and expects the rows to already exist.)
    Fortunately, there is a simple way around this problem. Always keep one unused
    row available, and when that row is written by an UPDATE statement, have a write
    callback allocate another row so that you can stay one step ahead of the UPDATEs.
    The logmuxd program presented in Chapter 7 uses this technique.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用迭代函数时有一个注意事项：如果你还没有为链表中的所有链接分配内存，加载保存文件可能会失败。（记住，保存文件是一系列 UPDATE 语句，并期望行已经存在。）幸运的是，有一个简单的方法可以解决这个问题。始终保留一个未使用的行，当该行被
    UPDATE 语句写入时，让写回调分配另一行，这样你就可以领先一步处理 UPDATEs。第 7 章中介绍的 logmuxd 程序就使用了这种技术。
- en: '[**Building Your First RTA Program**](toc.html#chapter3.6)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[**构建您的第一个 RTA 程序**](toc.html#chapter3.6)'
- en: 'Now we’ll look at how to use RTA to expose a table inside a running program.
    The five basic steps for doing so are:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看如何使用 RTA 来在运行程序中暴露一个表。为此，需要遵循以下五个基本步骤：
- en: Defining the problem.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义问题。
- en: Reviewing the code.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查代码。
- en: Installing RTA.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 RTA。
- en: Building and linking.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和链接。
- en: Testing.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试。
- en: '[***Defining the Problem***](toc.html#chapter3.7)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[***定义问题***](toc.html#chapter3.7)'
- en: We want to expose the UI program to an array of structures that contain a user-editable
    string and two integers. One of the integers, *zalarm*, is set by the user. The
    other, *zcount*, is incremented on each transition of zalarm from one to zero
    or from zero to one. We print a message to the console each time a transition
    occurs. The string, *zname*, is considered a configuration value and is saved
    in a disk file whenever it is updated. Since zcount is a statistic, we mark it
    as read-only. This sample problem is a precursor to the actual Laddie appliance
    application presented in Chapter 5\. The code presented below is also available
    in the file myapp.c on this book’s companion CD.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将 UI 程序暴露给包含一个用户可编辑的字符串和两个整数的结构数组。其中一个整数，*zalarm*，由用户设置。另一个，*zcount*，在 zalarm
    从一变为零或从零变为一时递增。每当发生转换时，我们都会向控制台打印一条消息。字符串，*zname*，被视为配置值，并在更新时保存在磁盘文件中。由于 zcount
    是一个统计值，我们将其标记为只读。这个示例问题是在第 5 章中实际 Laddie 设备应用程序之前的一个先导。下面展示的代码也包含在本书的配套 CD 上的
    myapp.c 文件中。
- en: '[***Reviewing the Code***](toc.html#chapter3.8)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[***检查代码***](toc.html#chapter3.8)'
- en: This code walk-through should give you an idea of what to expect in RTA-enabled
    programs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码示例应该能给你一个关于在 RTA 启用程序中可以期待什么的想法。
- en: '**Includes, Defines, and Memory Allocation**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含、定义和内存分配**'
- en: 'First, we’ll look at the code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看代码：
- en: '![](../images/50-1.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/50-1.jpg)'
- en: '![](../images/51-1.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/51-1.jpg)'
- en: The transitions of zalarm are detected in a write callback. Here, ![](../images/1.jpg)
    is the forward reference for it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: zalarm 的转换是在写回调中检测到的。这里，![](../images/1.jpg) 是它的前向引用。
- en: We need to allocate buffers for the text of the SQL command from the client
    and for the response returned to the client. At ![](../images/2.jpg) we are using
    500 and 5,000 bytes, respectively. These values are chosen to hold the largest
    possible SQL statement we expect to use and the largest possible result we expect
    to get back.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为客户端的SQL命令文本和返回给客户端的响应分配缓冲区。在![](../images/2.jpg)中，我们分别使用了500和5,000字节。这些值被选择以容纳我们预期使用的最大SQL语句和预期返回的最大结果。
- en: The structure definition at ![](../images/3.jpg) is the heart of the application’s
    data. Each instance of this data structure looks like a row in a database to the
    various UIs and clients.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在![](../images/3.jpg)的结构定义是应用程序数据的核心。这个数据结构的一个实例对各种UI和客户端来说就像数据库中的一行。
- en: We see at ![](../images/4.jpg) that our table has five rows in it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在![](../images/4.jpg)看到我们的表格中有五行。
- en: '**Column Definitions**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**列定义**'
- en: Here is the array of COLDEFs that define the columns in our table. The information
    in the COLDEFs is derived from the data structure we want to make visible and
    from our problem statement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是定义我们表格中列的COLDEF数组。COLDEF中的信息来源于我们想要使其可见的数据结构以及我们的问题陈述。
- en: '![](../images/51-2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/51-2.jpg)'
- en: Note ![](../images/1.jpg) the definition of the zedgedetect write callback in
    the COLDEF above. We do the transition detection of zalarm in this callback.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意![](../images/1.jpg)中COLDEF上zedgedetect写回调的定义。我们在该回调中执行zalarm的转换检测。
- en: '![](../images/52-1.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/52-1.jpg)'
- en: '**Table Defin it ion**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格定义**'
- en: In the TBLDEF we give the name of the table, its start address, the size of
    each row, the number of rows, a pointer to the table of COLDEFs for this table,
    and the number of columns in the table. The save file, /tmp/zsave.sql, will be
    used to save the RTA_DISKSAVE columns, which, in this case, is only the name column.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在TBLDEF中，我们给出了表格的名称、起始地址、每行的大小、行数、指向此表格的COLDEF表的指针以及表格中的列数。保存文件/tmp/zsave.sql将用于保存RTA_DISKSAVE列，在这种情况下，只有名称列。
- en: '![](../images/52-2.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/52-2.jpg)'
- en: '**main() Routine**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**main() 例程**'
- en: This is pretty standard code. We allocate our socket structures and other local
    variables, then we initialize the table values and use rta_add_table() to tell
    RTA about our table.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当标准的代码。我们分配我们的套接字结构和其它局部变量，然后初始化表格值并使用rta_add_table()告诉RTA关于我们的表格。
- en: '![](../images/52-3.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/52-3.jpg)'
- en: '![](../images/53-1.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/53-1.jpg)'
- en: '**Setting Up a Listening Socket**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置监听套接字**'
- en: Remember that each UI program treats our application as if it were a PostgreSQL
    database, and we have to accept either Unix or TCP connections from these clients.
    Therefore, as the final piece of initialization, we set up the socket to listen
    for incoming client connections. Our program is listening on TCP port 8888, so
    we need to tell our PostgreSQL clients to use this port.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个UI程序都将我们的应用程序视为一个PostgreSQL数据库，我们必须接受来自这些客户端的Unix或TCP连接。因此，作为初始化的最后一步，我们设置了套接字以监听传入的客户端连接。我们的程序正在监听TCP端口8888，因此我们需要告诉我们的PostgreSQL客户端使用此端口。
- en: '**NOTE**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The following code has some serious shortcomings (i.e., blocking I/O, ignoring
    error conditions, and making optimistic assumptions about socket I/O). Our goal,
    however, is to make the code understandable by keeping it as short as possible.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下代码存在一些严重的缺陷（例如，阻塞I/O、忽略错误条件以及乐观地假设套接字I/O）。然而，我们的目标是通过尽可能缩短代码来使代码易于理解。*'
- en: '![](../images/53-2.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/53-2.jpg)'
- en: '![](../images/54-1.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/54-1.jpg)'
- en: The ![](../images/1.jpg) read() call above uses blocking I/O. In a real application
    we would want to accept the connection and use a select() or poll() to multiplex
    for us. However, in this example we are trying keep the line count low.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的![](../images/1.jpg) read()调用使用了阻塞I/O。在实际应用中，我们希望接受连接并使用select()或poll()为我们进行多路复用。然而，在这个例子中，我们试图保持行数低。
- en: '**dbcommand() Call**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**dbcommand() 调用**'
- en: The following call is where the real work of RTA occurs. We pass the SQL command
    read from the client into the RTA library which parses it, verifies it, executes
    it, and fills outbuf with the result. We switch on the result of the dbcommand()
    call to see if we should send the result back to the client or close the connections.
    Under normal circumstances, the PostgreSQL client will do an orderly close and
    the dbcommand() call will return RTA_CLOSE.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调用是RTA真正工作的地方。我们将从客户端读取的SQL命令传递给RTA库，该库解析它、验证它、执行它，并将结果填充到buf中。我们根据dbcommand()调用的结果切换，以确定是否应将结果发送回客户端或关闭连接。在正常情况下，PostgreSQL客户端将进行有序关闭，dbcommand()调用将返回RTA_CLOSE。
- en: '![](../images/54-2.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/54-2.jpg)'
- en: '**Write Callback**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**写回调**'
- en: Here is the subroutine that is called after a UI/client program has set the
    zalarm column. A typical SQL command for this update would be UPDATE ztable SET
    zalarm = 0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是UI/客户端程序设置zalarm列之后调用的子例程。对此更新的一个典型SQL命令可能是UPDATE ztable SET zalarm = 0。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When first learning to use callbacks, you might want to add a print statement
    to the callback to display the table, column, input SQL, and row number.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*当刚开始学习使用回调时，您可能想在回调中添加一个打印语句来显示表、列、输入SQL和行号。*'
- en: '![](../images/54-3.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/54-3.jpg)'
- en: '![](../images/55-1.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/55-1.jpg)'
- en: A transition is detected by comparing the old value of zalarm with the new value.
    Both old and new values of the row are passed into the routine as parameters.
    We always return success in this example.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较zalarm的旧值和新值来检测过渡。将行的旧值和新值都作为参数传递给例程。在这个例子中，我们总是返回成功。
- en: return(0); /* always succeeds */ }
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: return(0); /* 总是成功 */ }
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a reminder, if the write callback returns a nonzero value, the row affected
    is restored to its old value and the client program receives an error result from
    the SQL command that it sent.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*提醒一下，如果写回调返回非零值，受影响的行将恢复到其旧值，客户端程序将接收到它发送的SQL命令的错误结果。*'
- en: '[***Installing RTA***](toc.html#chapter3.9)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[***安装RTA***](toc.html#chapter3.9)'
- en: You can find a copy of the RTA package on this book’s companion CD and on the
    RTA project website ([http://librta.org](http://librta.org)). Check the website
    for the latest version. The SQL parser in RTA is written using yacc and lex, so
    your development system will need to have both installed if you build RTA from
    its source code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的配套CD和RTA项目网站上找到RTA包的副本（[http://librta.org](http://librta.org)）。请检查网站以获取最新版本。RTA中的SQL解析器使用yacc和lex编写，因此如果您从源代码构建RTA，您的开发系统将需要安装这两个工具。
- en: The default installation of RTA puts the .a and .so libraries into the /usr/local/lib
    directory. If you do not want to use /usr/local/lib, you can edit the makefile
    before performing the install.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: RTA的默认安装将.a和.so库放入/usr/local/lib目录。如果您不想使用/usr/local/lib，您可以在安装之前编辑makefile。
- en: Once you have downloaded the RTA package, extract the files and build the library.
    The sample code below shows you how.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下载RTA包后，提取文件并构建库。下面的示例代码展示了如何操作。
- en: '![](../images/55-2.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/55-2.jpg)'
- en: '[***Building and Linking***](toc.html#chapter3.10)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[***构建和链接***](toc.html#chapter3.10)'
- en: 'Now create a test directory under rta-X.Y.Z and copy myapp.c to it. Next, build
    the application with this command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在rta-X.Y.Z下创建一个测试目录，并将myapp.c复制到其中。接下来，使用以下命令构建应用程序：
- en: gcc myapp.c -o myapp -L/usr/local/lib -lrtadb
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gcc myapp.c -o myapp -L/usr/local/lib -lrtadb
- en: 'To compile and run the application, we tell the system where to find the RTA
    libraries at runtime. You can edit /etc/ld.so.conf and run ldconf ig or export
    the LD_LIBRARY_PATH environment variable. If the compile succeeded, you should
    be able to run the application with these commands:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行应用程序，我们需要告诉系统在运行时在哪里找到RTA库。您可以通过编辑/etc/ld.so.conf并运行ldconfig或导出LD_LIBRARY_PATH环境变量来实现。如果编译成功，您应该可以使用以下命令运行应用程序：
- en: export LD_LIBRARY_PATH=/usr/local/lib
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: export LD_LIBRARY_PATH=/usr/local/lib
- en: ./myapp
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./myapp
- en: That’s it! Your sample application should be up and running and ready to respond
    to PostgreSQL requests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！您的示例应用程序应该已经启动并运行，准备好响应PostgreSQL请求。
- en: '[***Testing***](toc.html#chapter3.11)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[***测试***](toc.html#chapter3.11)'
- en: In this section we assume you have installed PostgreSQL from your Linux distribution
    or from the version included on this book’s companion CD, and that the psql command
    is somewhere on your path. If all has gone well, you should now have an application
    running which pretends to be a PostgreSQL database server. Instead of a database,
    however, our sample application is offering up its internal table for use by various
    PostgreSQL clients. The client we will be using first is the command line tool,
    psql.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们假设您已从Linux发行版或本书配套CD中安装了PostgreSQL，并且psql命令已存在于您的路径上。如果一切顺利，您现在应该有一个运行中的应用程序，它假装是一个PostgreSQL数据库服务器。然而，我们的示例应用程序提供其内部表供各种PostgreSQL客户端使用。我们将首先使用的客户端是命令行工具，psql。
- en: Assuming everything is in order, open another terminal window and start psql,
    specifying the host and port of the database server as follows. (Remember that
    we told our application to listen on port 8888.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切正常，打开另一个终端窗口并启动psql，指定数据库服务器的主机和端口如下。（请记住，我们告诉应用程序在端口8888上监听。）
- en: psql -h localhost -p 8888
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: psql -h localhost -p 8888
- en: 'PostgreSQL should respond with something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL应该响应如下：
- en: '![](../images/56-1.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/56-1.jpg)'
- en: '![](../images/57-1.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/57-1.jpg)'
- en: If your SQL command did not display the above table, you need to debug the RTA
    installation. The most common problem is a version mismatch in the PostgreSQL
    protocol between the client and RTA. The psql client may give a warning, but it
    is fairly forgiving of using a newer client with an older server. This may be
    the case if you are using the very latest psql client.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的SQL命令没有显示上述表，您需要调试RTA安装。最常见的问题是客户端和RTA之间PostgreSQL协议版本不匹配。psql客户端可能会给出警告，但它对使用较新客户端与较旧服务器相当宽容。如果您使用的是最新的psql客户端，这种情况可能发生。
- en: Check the RTA website to see if your version of RTA is compatible with your
    version of PostgreSQL. If there is a mismatch, update either RTA or PostgreSQL.
    This book’s companion CD contains versions of the RTA and PostgreSQL libraries
    that are known to be compatible. You can also do a netstat -natp to verify that
    the application is really listening on port 8888.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 检查RTA网站，看看您的RTA版本是否与您的PostgreSQL版本兼容。如果存在不匹配，请更新RTA或PostgreSQL。本书的配套CD包含已知与RTA和PostgreSQL库兼容的版本。您还可以使用netstat
    -natp来验证应用程序是否真的在端口8888上监听。
- en: Before dropping into the tutorial on SQL, let’s try a couple of commands just
    to see how the application responds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入SQL教程之前，让我们尝试几个命令，看看应用程序如何响应。
- en: UPDATE ztable SET zalarm = 1;
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zalarm = 1;
- en: UPDATE 5
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE 5
- en: '#'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: This should cause a *transition* message to be printed on the console where
    you started myapp. (Note that psql responds with the number of rows changed, and
    because we did not specify which row to change, all five rows were updated.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在您启动myapp时所在的控制台上打印出一个*转换*消息。（请注意，psql会响应已更改的行数，因为我们没有指定更改哪一行，所以所有五行都被更新了。）
- en: Now issue the same command a second time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次执行相同的命令。
- en: UPDATE ztable SET zalarm = 1;
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zalarm = 1;
- en: UPDATE 5
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE 5
- en: '#'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: There should be no message printed to the console, since this time there was
    no transition.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不应该在控制台上打印任何消息，因为没有发生转换。
- en: Setting zalarm back to zero should cause a transition, and the count of transitions
    should now be 2.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将zalarm设置回零应导致一个转换，并且转换的计数现在应该是2。
- en: '![](../images/58-1.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/58-1.jpg)'
- en: When you first started ./myapp, the saved table configuration file, /tmp/zsave.sql,
    did not exist. Create it by doing an update on a column that is marked as RTA_DISKSAVE.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次启动./myapp时，保存的表配置文件/tmp/zsave.sql不存在。通过在一个标记为RTA_DISKSAVE的列上执行更新来创建它。
- en: UPDATE ztable SET zname = "row name";
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "row name";
- en: UPDATE 5
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE 5
- en: '#'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: 'You can verify the above by doing a cat on /tmp/zsave.sql. You should see the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在/tmp/zsave.sql上执行cat来验证上述内容。您应该看到以下内容：
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 0
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 0
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 1
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 1
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 2
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 2
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 3
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 3
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 4
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 4
- en: To conclude this section on RTA, let’s generate some errors and look at the
    corresponding error messages.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本节关于RTA的内容，让我们生成一些错误并查看相应的错误消息。
- en: UPDATE ztable SET zcount = 0;
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zcount = 0;
- en: 'ERROR: Can not update read-only column ''zcount'''
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：无法更新只读列 'zcount'
- en: UPDATE ztable SET zname = "abcdefghijklmnopqrstuvwxyz";
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "abcdefghijklmnopqrstuvwxyz";
- en: 'ERROR: String too long for ''zname'''
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：'zname' 字符串太长
- en: '#'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: '[**A Little SQL**](toc.html#chapter3.12)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[**一点SQL**](toc.html#chapter3.12)'
- en: 'Structured Query Language is a standard way to manipulate data in a database.
    RTA uses only two SQL commands: SELECT, to get data from a table, and UPDATE,
    to write data to a table. The RTA syntax for SELECT and UPDATE is a limited subset
    of the standard SQL syntax, with one minor extension.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化查询语言（Structured Query Language，简称SQL）是操作数据库数据的一种标准方式。RTA仅使用两个SQL命令：SELECT，用于从表中获取数据，和UPDATE，用于向表中写入数据。RTA的SELECT和UPDATE语法是标准SQL语法的子集，有一个小的扩展。
- en: '[***SELECT***](toc.html#chapter3.13)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[***SELECT***](toc.html#chapter3.13)'
- en: 'The SELECT statement reads values out of a table. The syntax for the RTA SELECT
    statement is:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT语句从表中读取值。RTA SELECT语句的语法是：
- en: SELECT column_list FROM table [where_clause] [limit_clause]
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT column_list FROM table [where_clause] [limit_clause]
- en: The column_list is a comma-separated list of column names or a single asterisk
    (*) to retrieve all columns. The variable table is the name of the table you wish
    to examine. The where_clause specifies which rows to return, and the limit_clause
    tells how many rows to return. Here are some simple examples.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: column_list是一个以逗号分隔的列名列表或单个星号(*)以检索所有列。变量table是您要检查的表名。where_clause指定要返回的行，limit_clause告诉返回多少行。以下是一些简单的例子。
- en: SELECT * FROM ztable
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM ztable
- en: select * from ztable
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: select * from ztable
- en: SELECT zcount, zname FROM ztable
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT zcount, zname FROM ztable
- en: You can specify the columns in any order, and you can ask for the same column
    more than once.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以任何顺序指定列，并且可以多次请求相同的列。
- en: '**NOTE**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The SQL parser recognizes the SQL reserved words in both upper- and lowercase
    letters. We use uppercase in our examples to make the reserved words more visible.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL解析器识别SQL保留字的大小写形式。在我们的示例中，我们使用大写字母来使保留字更加明显。*'
- en: Also, SQL does not require a semicolon at the end of the line, but the psql
    command line tool does.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SQL不需要在行尾使用分号，但psql命令行工具需要。
- en: '[***UPDATE***](toc.html#chapter3.14)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[***UPDATE***](toc.html#chapter3.14)'
- en: 'The UPDATE statement writes values into a table. The syntax for the RTA UPDATE
    statement is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE语句将值写入表中。RTA UPDATE语句的语法是：
- en: UPDATE table SET update_list [where_clause] [limit_clause]
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE table SET update_list [where_clause] [limit_clause]
- en: 'The update_list is a comma-separated list of value assignments in the following
    format:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: update_list是一个以逗号分隔的值赋值列表，格式如下：
- en: column_name = value[, column_name = value...]
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: column_name = value[, column_name = value...]
- en: In the example above, value is a literal value. Let’s look at some more examples.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，value是一个字面值。让我们看看一些更多的例子。
- en: UPDATE ztable SET zalarm = 44
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zalarm = 44
- en: UPDATE ztable SET zalarm = 0, zname = Terminator
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zalarm = 0, zname = Terminator
- en: UPDATE ztable SET zalarm = *1,* zname = "Mr. Terminator"
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zalarm = *1,* zname = "Mr. Terminator"
- en: Strings with spaces must be enclosed in either single or double quotes. One
    kind of quote can be enclosed in the other kind of quote.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 包含空格的字符串必须用单引号或双引号括起来。一种引号可以嵌套在另一种引号中。
- en: UPDATE ztable SET zname = "Baker's Pride"
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Baker's Pride"
- en: UPDATE ztable SET zname = 'Just say "no"'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = 'Just say "no"'
- en: '[***WHERE***](toc.html#chapter3.15)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[***WHERE***](toc.html#chapter3.15)'
- en: 'A WHERE clause specifies which rows to select or update, based on the data
    in the rows. WHERE might be the single biggest reason to use SQL. The form of
    the WHERE clause is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE子句指定要选择或更新的行，基于行中的数据。WHERE可能是使用SQL的最大原因之一。WHERE子句的形式是：
- en: col_name rel_op value [AND col_name rel_op value ...]
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: col_name rel_op value [AND col_name rel_op value ...]
- en: 'The supported comparison operators are equality, inequality, greater than,
    less than, greater than or equal to, and less than or equal to. Only logical AND
    is available to link column comparisons, and value must refer to a literal value.
    For example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的比较运算符包括等于、不等于、大于、小于、大于等于和小于等于。仅逻辑AND可用于连接列比较，并且值必须引用一个字面值。例如：
- en: SELECT * FROM ztable WHERE zalarm != 0
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM ztable WHERE zalarm != 0
- en: UPDATE ztable SET zalarm = 1 WHERE zname = "Front Door"
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zalarm = 1 WHERE zname = "Front Door"
- en: '[***LIMIT***](toc.html#chapter3.16)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[***LIMIT***](toc.html#chapter3.16)'
- en: 'The LIMIT clause can limit the number of rows selected to limit rows, and can
    specify that the first OFFSET rows be ignored. The form of the LIMIT clause is:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: LIMIT子句可以限制选择的行数，并可以指定忽略第一个OFFSET行。LIMIT子句的形式是：
- en: '[LIMIT limit [OFFSET offset]]'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[LIMIT limit [OFFSET offset]]'
- en: 'Normal SQL does not support the idea of “give me only the third row,” but this
    functionality is important if you’re trying to manage an embedded application.
    The LIMIT and OFFSET clauses let you specify exactly how many rows should be returned
    and how many candidate rows to ignore before starting the read or write. If there
    is a WHERE clause, the offset and limit apply only to the rows that match the
    WHERE conditions. For example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的SQL不支持“只给我第三行”的想法，但如果你试图管理嵌入式应用程序，这个功能很重要。LIMIT和OFFSET子句允许你指定应该返回多少行，以及开始读取或写入之前应该忽略多少候选行。如果有WHERE子句，偏移量和限制只适用于匹配WHERE条件的行。例如：
- en: UPDATE ztable SET zname = "Front Door" LIMIT 2
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Front Door" LIMIT 2
- en: UPDATE ztable SET zname = "Back Door" LIMIT 3 OFFSET 2
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Back Door" LIMIT 3 OFFSET 2
- en: UPDATE ztable SET zalarm = 1 LIMIT 2 OFFSET 1
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zalarm = 1 LIMIT 2 OFFSET 1
- en: SELECT zname FROM ztable LIMIT 4
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT zname FROM ztable LIMIT 4
- en: UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2
- en: SELECT * FROM ztable WHERE zalarm = 1 LIMIT 1
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM ztable WHERE zalarm = 1 LIMIT 1
- en: '**NOTE**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A great way to step through a table one row at a time is to set LIMIT to 1
    and increment OFFSET from 0 up to one less than the number of rows.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*一种逐行遍历表的好方法是设置LIMIT为1，并将OFFSET从0递增到行数减1。*'
- en: You may remember that we said that we stored RTA_DISKSAVE columns in the save
    file given in the table definition, and that we wanted to store the configuration
    as SQL commands so that we could run it through the SQL parser. You can see a
    good example of the LIMIT clause and of save files by looking at /tmp/zsave.sql.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们说过，我们将RTA_DISKSAVE列存储在表定义中给出的保存文件中，并且我们希望将配置存储为SQL命令，以便我们可以通过SQL解析器运行它。你可以通过查看/tmp/zsave.sql来看到一个关于LIMIT子句和保存文件的优秀示例。
- en: cat /tmp/zsave.sql
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cat /tmp/zsave.sql
- en: UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 0
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 0
- en: UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 1
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 1
- en: UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2
- en: UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 3
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 3
- en: UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 4
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 4
- en: Real SQL purists reading this are probably pounding the table with their shoe
    and shouting, “Where’s ORDER_BY and INSERT and DELETE . . . and . . . and . .
    . ?” They are not there. Remember, RTA is *not* a database—it is an interface.
    We only need SELECT and UPDATE.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的SQL纯粹主义者阅读这篇文档可能会用鞋底猛击桌子，并喊道，“ORDER_BY和INSERT和DELETE在哪里……和……和……？”它们都不在那里。记住，RTA不是数据库——它是一个接口。我们只需要SELECT和UPDATE。
- en: '[**Introduction to RTA’s Built-in Tables**](toc.html#chapter3.17)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RTA内置表的介绍**](toc.html#chapter3.17)'
- en: The RTA library has several built-in tables. Appendix A has the full details,
    so we will introduce them here. The first table has only one row.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: RTA库有几个内置表。附录A有完整细节，所以我们将在这里介绍它们。第一个表只有一行。
- en: '[***rta_dbg***](toc.html#chapter3.18)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_dbg***](toc.html#chapter3.18)'
- en: 'The rta_dbg table lets you control how and what is logged. You can turn on
    tracing of all SQL by setting trace to 1, and you can direct log messages to neither,
    syslog, stderr, or both by setting target to 0, 1, 2, or 3, respectively. You
    can also specify the priority, facility, and ident values for syslog(). From psql
    we get:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: rta_dbg表允许你控制如何以及记录什么。你可以通过将trace设置为1来开启所有SQL的跟踪，并且你可以通过将target设置为0、1、2或3来分别将日志消息定向到既不是、syslog、stderr或两者。你还可以为syslog()指定优先级、设施和ident值。从psql中我们得到：
- en: '![](../images/61-1.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/61-1.jpg)'
- en: '[***rta_stat***](toc.html#chapter3.19)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_stat***](toc.html#chapter3.19)'
- en: The rta_stat table holds statistics related to the calls into RTA. It contains
    counts of the different types of errors, how many connections have been opened
    into RTA, and the number of SELECTs and UPDATEs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: rta_stat表包含与RTA调用相关的统计信息。它包含不同类型错误的计数、已打开到RTA中的连接数以及SELECT和UPDATE的数量。
- en: '![](../images/61-2.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/61-2.jpg)'
- en: '[***rta_tables***](toc.html#chapter3.20)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_tables***](toc.html#chapter3.20)'
- en: The rta _tables metatable is a collection of table definition structures. In
    order to add a table into RTA, you had to fill in a data structure with a description
    of your table. The collection of table definition structures is itself a table
    in RTA. This is one of the RTA metatables.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: rta _tables元表是一个表定义结构的集合。为了将一个表添加到RTA中，你必须填写一个包含你的表描述的数据结构。表定义结构的集合本身在RTA中也是一个表。这是RTA的元表之一。
- en: '![](../images/62-1.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/62-1.jpg)'
- en: The two RTA metatables have zero in the address field because they are actually
    an array of pointers, so they use an iterator function. All of the columns in
    the metatables are marked read-only, since all of the values are set from the
    rta_add_table() call.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 两个RTA元表在地址字段中为零，因为它们实际上是一个指针数组，所以它们使用迭代函数。元表中的所有列都被标记为只读，因为所有值都是从rta_add_table()调用中设置的。
- en: '[***rta_columns***](toc.html#chapter3.21)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_columns***](toc.html#chapter3.21)'
- en: The rta_columns metatable is a collection of column definitions. All of the
    column definitions from all of the tables are collected into the rta_columns table.
    (The table actually holds pointers to the COLDEF structures.) We can see what
    columns are in a table using the metatables and a WHERE clause.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: rta_columns元表是一组列定义。所有表的列定义都收集到rta_columns表中。（该表实际上持有指向COLDEF结构的指针。）我们可以使用元表和WHERE子句来查看表中的列。
- en: '![](../images/62-2.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/62-2.jpg)'
- en: What do you suppose we would get if we combined the RTA metatables with PHP?
    Read on.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为如果我们结合RTA元表和PHP会得到什么？请继续阅读。
- en: '[**The RTA Table Editor**](toc.html#chapter3.22)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RTA表编辑器**](toc.html#chapter3.22)'
- en: The RTA package has a web/PHP-based utility called a *table editor* that reads
    the RTA metatables and lets you view and edit any table in the system. Figure
    3-3 shows the screen that lets you choose which table to view or edit. The screenshots
    in Figures 3-3, 3-4, and 3-5 were taken from our development system while we were
    working on the myapp.c application. You can see a similar screen by booting this
    book’s companion CD and using the browser on another PC to view [http://192.168.1.11/rta/rta_tables.php?port=8885](http://192.168.1.11/rta/rta_tables.php?port=8885).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: RTA包有一个基于web/PHP的实用工具，称为*表编辑器*，它读取RTA元表，并允许您查看和编辑系统中的任何表。图3-3显示了允许您选择要查看或编辑的表的屏幕。图3-3、3-4和3-5中的截图是在我们处理myapp.c应用程序时从我们的开发系统中拍摄的。您可以通过启动本书的配套CD并使用另一台PC上的浏览器来查看[http://192.168.1.11/rta/rta_tables.php?port=8885](http://192.168.1.11/rta/rta_tables.php?port=8885)来看到类似的屏幕。
- en: '![](../images/63-1.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/63-1.jpg)'
- en: '*Figure 3-3: The RTA Table Editor*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3：RTA表编辑器*'
- en: Selecting a table from the top screen opens a web page with the contents of
    the selected table. Figure 3-4 shows a display of the example program’s ztable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部屏幕中选择一个表会打开一个包含所选表内容的网页。图3-4显示了示例程序的ztable显示。
- en: '![](../images/63-2.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/63-2.jpg)'
- en: '*Figure 3-4: A sample table display*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4：一个示例表显示*'
- en: You can select a row to edit from the table display. Figure 3-5 shows the view
    after selecting row number 3.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从表显示中选择要编辑的行。图3-5显示了选择行号3后的视图。
- en: '![](../images/64-1.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/64-1.jpg)'
- en: '*Figure 3-5: A sample row edit screen*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-5：一个示例行编辑屏幕*'
- en: The RTA table editor has one HTML file and four PHP files that can be put on
    any PHP-enabled webserver. In fact, the webserver does not even need to run on
    the same machine as the application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: RTA表编辑器有一个HTML文件和四个PHP文件，可以放在任何支持PHP的web服务器上。实际上，web服务器甚至不需要在运行应用程序的同一台机器上运行。
- en: 'The HTML file contains a list of the RTA port numbers in use. You will have
    a different port number for each RTA-enabled application that you run. On our
    development machine, we have an HTML table with port numbers and RTA application
    names that looks like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件包含正在使用的RTA端口号列表。您为每个运行的RTA启用应用程序都有一个不同的端口号。在我们的开发机器上，我们有一个包含端口号和RTA应用程序名称的HTML表格，看起来像这样：
- en: '![](../images/64-2.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/64-2.jpg)'
- en: '[**Summary**](toc.html#chapter3.23)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[**总结**](toc.html#chapter3.23)'
- en: This chapter has presented the details of how to build your application using
    RTA so that several different types of UI programs can manage it. You’ve seen
    that you need to tell RTA about the data structures you want to make visible by
    describing them with TBLDEFs and COLDEFs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用RTA构建应用程序的细节，以便几种不同类型的UI程序可以管理它。您已经看到，您需要通过使用TBLDEFs和COLDEFs来描述它们，告诉RTA您想要使其可见的数据结构。
- en: While all this may seem a little overwhelming at first, stick with it. After
    just a little practice, you’ll find that writing TBLDEFs and COLDEFs is straightforward
    and mostly mechanical. The extra effort to add RTA to your daemon is more than
    compensated by having run-time access to configuration, status, and statistics.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一切一开始可能看起来有些令人不知所措，但请坚持下去。经过一点练习，您会发现编写TBLDEFs和COLDEFs非常直接，主要是机械的。将RTA添加到您的守护进程中的额外努力，通过运行时访问配置、状态和统计信息得到了充分的补偿。
- en: '![](../images/66-1.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/66-1.jpg)'
