- en: Chapter 7. Avoiding Detection
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章：避免检测
- en: 'When you are performing a penetration test, nothing is more embarrassing than
    being caught by antivirus software. This is one of those little details that can
    be overlooked quite easily: If you don’t make plans to evade detection by antivirus
    software, watch out, because your target will quickly be alerted that something
    fishy is going on. In this chapter, we’ll cover situations in which antivirus
    software might be an issue and discuss possible solutions.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行渗透测试时，没有什么比被防病毒软件抓住更尴尬的了。这是那些容易被忽视的小细节之一：如果你没有计划规避防病毒软件的检测，小心，因为你的目标会很快意识到有些不对劲。在本章中，我们将讨论防病毒软件可能成为问题的情况，并讨论可能的解决方案。
- en: 'Most antivirus software uses *signatures* to identify aspects of malicious
    code that are present in a sampling of malicious software. These signatures are
    loaded into antivirus engines and then used to scan disk storage and running processes
    for matches. When a match is found, the antivirus software takes certain steps
    to respond to the situation: Most quarantine the binary or kill the running process.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数防病毒软件使用 *签名* 来识别恶意软件样本中存在的恶意代码方面。这些签名被加载到防病毒引擎中，然后用于扫描磁盘存储和运行进程以查找匹配项。当找到匹配项时，防病毒软件会采取某些步骤来应对这种情况：大多数会将二进制文件隔离或终止正在运行的进程。
- en: As you might imagine, this model has scaling issues. For one, the amount of
    malicious code in the wild means that an antivirus product loaded with signatures
    can check files only so quickly for matching signatures. Also, the signatures
    must be specific enough to trigger only when they encounter truly malicious programs,
    not legitimate software. This model is relatively easy to implement, yet it provides
    limited success in practice.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这个模型存在扩展性问题。一方面，野外的恶意代码数量意味着带有签名的防病毒产品只能如此快速地检查文件以匹配签名。此外，签名必须足够具体，以便仅在它们遇到真正恶意程序时触发，而不是合法软件。这种模型相对容易实现，但在实践中提供的成功有限。
- en: That being said, a lot of money is being made by antivirus publishers, and many
    smart and talented people work in the industry. If you plan to use a payload that
    is not custom built, you can expect that antivirus software will detect it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，防病毒出版商正在赚取大量金钱，许多聪明而有才华的人在这个行业中工作。如果你计划使用非定制的有效载荷，你可以预期防病毒软件会检测到它。
- en: To evade antivirus, we can create unique payloads to run on an antivirus software–protected
    system that will not match any of the available signatures. In addition, when
    we’re performing direct exploits on a system, Metasploit payloads are designed
    to run in memory and never to write data to the hard disk. When we send a payload
    as part of an exploit, most antivirus programs will not detect that it has been
    run on the target.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了规避防病毒软件，我们可以创建独特的有效载荷，在受防病毒软件保护的系统上运行，而不会匹配任何可用的签名。此外，当我们对系统进行直接利用时，Metasploit有效载荷被设计为在内存中运行，而不会将数据写入硬盘。当我们将有效载荷作为利用的一部分发送时，大多数防病毒程序都不会检测到它在目标上已运行。
- en: Rather than focus on specific commands in this chapter, we’ll focus on the underlying
    concepts. Consider the sorts of characteristics that might trigger antivirus software,
    and try to use the techniques presented here to change sections of code so that
    they no longer match the antivirus signatures. Don’t be afraid to experiment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是关注本章中的特定命令，我们将关注底层概念。考虑可能触发防病毒软件的特性，并尝试使用这里介绍的技术更改代码部分，以便它们不再匹配防病毒签名。不要害怕实验。
- en: Creating Stand-Alone Binaries with MSFpayload
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MSFpayload创建独立二进制文件
- en: Before we perform an antivirus evasion, let’s look at how to create stand-alone
    Metasploit binary payloads with *msfpayload*. For starters, we’ll create a simple
    reverse shell that connects back to the attacker and spawns a command shell. We’ll
    use `msfpayload` and `windows/shell_reverse_tcp`. But first, let’s look at the
    available options for the `shell_reverse_tcp` payload using the `O` flag at ![](../images/00002.gif).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行防病毒规避之前，让我们看看如何使用 *msfpayload* 创建独立的Metasploit二进制有效载荷。首先，我们将创建一个简单的反向shell，它连接回攻击者并启动一个命令行shell。我们将使用
    `msfpayload` 和 `windows/shell_reverse_tcp`。但首先，让我们使用 `O` 标志查看 `shell_reverse_tcp`
    有效载荷的可用选项，如图 ![](../images/00002.gif) 所示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let’s run `msfpayload` again and provide the options needed to create this
    payload in the Windows Portable Executable (PE) format. To do so, we provide the
    `X` option as shown at ![](../images/00002.gif) as our output format:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行 `msfpayload` 并提供创建此有效载荷所需的选项，以在 Windows 可移植可执行文件 (PE) 格式下创建它。为此，我们提供
    `X` 选项，如图 ![](../images/00002.gif) 所示，作为我们的输出格式：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have a working executable, so we can start a listener with the *multi/handler*
    module in *msfconsole*. *multi/handler* allows Metasploit to listen for reverse
    connections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可工作的可执行文件，因此我们可以使用 *msfconsole* 中的 *multi/handler* 模块启动监听器。*multi/handler*
    允许 Metasploit 监听反向连接。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first use the *multi/handler* module at ![](../images/00002.gif) and get
    a quick display of the options at ![](../images/00004.gif). Then, we set our payload
    to be a Windows reverse shell at ![](../images/00005.gif) so that it matches the
    behavior of the executable we created earlier, tell it the IP at ![](../images/00006.gif)
    and the port to listen on at ![](../images/00007.gif), and we’re ready to go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 *multi/handler* 模块在 ![](../images/00002.gif) 并快速显示选项在 ![](../images/00004.gif)。然后，我们将有效载荷设置为
    Windows 反向 shell 在 ![](../images/00005.gif)，以便它与之前创建的可执行文件的行为相匹配，告诉它 IP 地址在 ![](../images/00006.gif)
    和监听端口在 ![](../images/00007.gif)，然后我们就可以开始了。
- en: Evading Antivirus Detection
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免杀毒软件检测
- en: We’ll use the popular AVG Anti-Virus product in the following examples. Because
    it can take some time and multiple tries to circumvent certain antivirus engines,
    before we try to deploy a payload, we check the antivirus solution to make sure
    the payload gets past it before we deploy it on the target.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用流行的 AVG 杀毒软件产品。由于绕过某些杀毒引擎可能需要一些时间和多次尝试，在我们尝试部署有效载荷之前，我们检查杀毒解决方案以确保有效载荷能够通过它，然后再将其部署到目标上。
- en: In this case, when we test our payload with AVG, we see that it’s detected,
    as shown in [Figure 7-1](part0011.html#avg_detected_our_payload).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们用 AVG 测试我们的有效载荷时，我们看到它被检测到了，如图 [图 7-1](part0011.html#avg_detected_our_payload)
    所示。
- en: '![AVG detected our payload.](../images/00031.jpeg)Figure 7-1. AVG detected
    our payload.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![AVG 检测到我们的有效载荷。](../images/00031.jpeg)图 7-1. AVG 检测到我们的有效载荷。'
- en: Encoding with MSFencode
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 MSFencode 进行编码
- en: One of the best ways to avoid being stopped by antivirus software is to encode
    our payload with *msfencode*. *Msfencode* is a useful tool that alters the code
    in an executable so that it looks different to antivirus software but will still
    run the same way. Much as the binary attachment in email is encoded in Base64,
    *msfencode* encodes the original executable in a new binary. Then, when the executable
    is run, *msfencode* decodes the original code into memory and executes it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 避免被杀毒软件阻止的最好方法之一是使用 *msfencode* 对我们的有效载荷进行编码。*Msfencode* 是一个有用的工具，它改变了可执行文件中的代码，使其对杀毒软件看起来不同，但仍然以相同的方式运行。就像电子邮件中的二进制附件被编码为
    Base64 一样，*msfencode* 将原始可执行文件编码为新的二进制文件。然后，当可执行文件运行时，*msfencode* 将原始代码解码到内存中并执行它。
- en: You can use `msfencode -h` to see a list of *msfencode* usage options. Of the
    *msfencode* options, the encoder formats are among the most important. For a list
    of encoder formats, we use `msfencode -l`, as shown next. Notice that different
    encoders are used for different platforms, because, for example, a Power PC (PPC)
    encoder will not operate correctly on an x86 platform because of differences in
    the two architectures.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `msfencode -h` 来查看 *msfencode* 的使用选项列表。在 *msfencode* 的选项中，编码器格式是最重要的。为了列出编码器格式，我们使用
    `msfencode -l`，如下所示。请注意，不同的编码器用于不同的平台，因为例如，Power PC (PPC) 编码器在 x86 平台上无法正确运行，因为两种架构之间存在差异。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we’ll run a simple encoding of an MSF payload by importing raw output from
    *msfpayload* into *msfencode* to see how the result affects our antivirus detection:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将运行一个简单的 MSF 有效载荷编码，通过将 *msfpayload* 的原始输出导入到 *msfencode* 中，以查看结果如何影响我们的杀毒软件检测：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We add the `R` flag at ![](../images/00002.gif) to the `msfpayload` command
    line to specify raw output, because we will pipe its output directly into *msfencode*.
    We specify the `x86/shikata_ga_nai` encoder at ![](../images/00004.gif) and tell
    *msfencode* to send the executable output `-t exe` ![](../images/00005.gif) to
    */var/www/payload2.exe*. Finally, we run a quick check at ![](../images/00006.gif)
    to ensure that the resulting file is in fact a Windows executable. The response
    tells us that it is. Unfortunately, after the *payload2.exe* file is copied over
    to the Windows system, AVG detects our encoded payload yet again, as shown in
    [Figure 7-2](part0011.html#avg_detected_our_encoded_payload).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`msfpayload`命令行中添加了`R`标志，如![图](../images/00002.gif)所示，以指定原始输出，因为我们将会将其输出直接管道输入到*msfencode*。我们在![图](../images/00004.gif)处指定了`x86/shikata_ga_nai`编码器，并告诉*msfencode*将可执行输出`-t
    exe`![图](../images/00005.gif)发送到`/var/www/payload2.exe`。最后，我们在![图](../images/00006.gif)处进行快速检查，以确保生成的文件实际上是一个Windows可执行文件。响应告诉我们确实是。不幸的是，在将*payload2.exe*文件复制到Windows系统后，AVG再次检测到我们的编码有效载荷，如图[图7-2](part0011.html#avg_detected_our_encoded_payload)所示。
- en: '![AVG detected our encoded payload.](../images/00032.jpeg)Figure 7-2. AVG detected
    our encoded payload.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![AVG检测到我们的编码有效载荷](../images/00032.jpeg)图7-2. AVG检测到我们的编码有效载荷。'
- en: Multi-encoding
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多编码
- en: When we’re performing antivirus detection without modifying the static binary
    itself, it’s always a cat-and-mouse game, because antivirus signatures are frequently
    updated to detect new and changed payloads. Within the Framework, we can get better
    results through *multi-encoding*, which allows the payload to be encoded several
    times to throw off antivirus programs that check for signatures.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在不修改静态二进制文件本身的情况下执行防病毒检测时，总是一场猫捉老鼠的游戏，因为防病毒签名通常会更新以检测新的和更改后的有效载荷。在框架中，我们可以通过*多编码*获得更好的结果，这允许有效载荷被编码多次，以迷惑检查签名的防病毒程序。
- en: 'In the preceding example, the `shikata_ga_nai` encoding is *polymorphic*, meaning
    that the payload will change each time the script is run. Of course, the payload
    that an antivirus product will flag is a mystery: Every time you generate a payload,
    the same antivirus program can flag it once and miss it another time.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`shikata_ga_nai`编码是**多态的**，这意味着每次运行脚本时有效载荷都会改变。当然，防病毒产品会标记的有效载荷是一个谜：每次生成有效载荷时，相同的防病毒程序可能会标记它一次，而另一次则错过。
- en: 'It is recommended that you test your script using an evaluation version of
    a product to see if it bypasses the antivirus software prior to using it in a
    penetration test. Here’s an example of using multiple encoding passes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您在使用渗透测试之前，使用产品的评估版测试您的脚本，以查看它是否绕过了防病毒软件。以下是一个使用多次编码的示例：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we use five counts at ![](../images/00002.gif) of `shikata_ga_nai`, feeding
    the code in raw format at ![](../images/00004.gif) into two counts of `alpha_upper`
    encoding at ![](../images/00005.gif), which is then fed to another five counts
    of `shikata_ga_nai` ![](../images/00006.gif),followed by five counts of `countdown`
    encoding at ![](../images/00007.gif), before finally directing the output into
    the desired executable. We are using a total of 17 encoding loops in an attempt
    to circumvent the antivirus software. And, as you can see in [Figure 7-3](part0011.html#avg_has_not_detected_the_multi-encoded_p),
    we have successfully slipped our payload past the antivirus engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在![图](../images/00002.gif)处使用五次`shikata_ga_nai`，将原始格式的代码在![图](../images/00004.gif)处输入到两次`alpha_upper`编码在![图](../images/00005.gif)处，然后将其输入到另一个五次的`shikata_ga_nai`![图](../images/00006.gif)处，接着是五次的`countdown`编码在![图](../images/00007.gif)处，最后将输出导向所需的可执行文件。我们总共使用了17次编码循环，试图绕过防病毒软件。正如您在[图7-3](part0011.html#avg_has_not_detected_the_multi-encoded_p)中可以看到的，我们已经成功地将我们的有效载荷绕过了防病毒引擎。
- en: '![AVG has not detected the multi-encoded payload.](../images/00033.jpeg)Figure 7-3. AVG
    has not detected the multi-encoded payload.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![AVG未检测到多编码有效载荷](../images/00033.jpeg)图7-3. AVG未检测到多编码有效载荷。'
- en: Custom Executable Templates
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义可执行模板
- en: Typically, when `msfencode` is run, the payload is embedded into the default
    executable template at *data/templates/template.exe*. Although this template is
    changed on occasion, antivirus vendors still look for it when building signatures.
    However, *msfencode* now supports the use of any Windows executable in place of
    the default executable template via the `-x` option. In the following example,
    we encode our payload again using the Process Explorer from Microsoft’s Sysinternals
    Suite as a custom-executable template.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当运行`msfencode`时，有效载荷会被嵌入到默认的可执行文件模板`*data/templates/template.exe*`中。尽管这个模板偶尔会更改，但防病毒供应商在构建签名时仍然会寻找它。然而，`msfencode`现在支持通过`-x`选项使用任何Windows可执行文件作为默认可执行文件模板。在下面的示例中，我们再次使用微软Sysinternals
    Suite中的Process Explorer作为自定义可执行文件模板来编码我们的有效载荷。
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, at ![](../images/00002.gif) we download Process Explorer from
    Microsoft then unzip it at ![](../images/00004.gif). Then at ![](../images/00005.gif)
    we use the `-x` switch to specify the downloaded Process Explorer binary for use
    as our custom template. After encoding completes, we start up the multi-handler
    through *msfcli* to listen for the incoming connection, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在![图片1](../images/00002.gif)中，我们下载了微软的Process Explorer，然后在![图片2](../images/00004.gif)处解压它。然后在![图片3](../images/00005.gif)处，我们使用`-x`开关指定下载的Process
    Explorer二进制文件作为我们的自定义模板。编码完成后，我们通过`msfcli`启动多处理器以监听传入的连接，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And voilà: We have successfully opened a shell without being detected by antivirus
    software.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功打开了一个shell，而不会被防病毒软件检测到。
- en: '![The backdoored executable is not detected by AVG.](../images/00034.jpeg)Figure 7-4. The
    backdoored executable is not detected by AVG.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![被后门化的可执行文件未被AVG检测到。](../images/00034.jpeg)图7-4. 被后门化的可执行文件未被AVG检测到。'
- en: Launching a Payload Stealthily
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 悄悄地启动有效载荷
- en: 'For the most part, when a targeted user launches a backdoored executable such
    as the one we just generated, nothing will appear to happen, and that can raise
    suspicions. To improve your chances of not tipping off a target, you can launch
    a payload while simultaneously continuing normal execution of the launched application,
    as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，当目标用户启动我们刚刚生成的后门化可执行文件时，似乎没有任何事情发生，这可能会引起怀疑。为了提高你不引起目标注意的机会，你可以在同时继续启动应用程序的正常执行时启动有效载荷，如下所示：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this listing, we download the PuTTY Windows SSH client at ![](../images/00002.gif)
    and then access PuTTY using the `-k` flag at ![](../images/00004.gif). The `-k`
    flag configures the payload to launch in a separate thread from the main executable
    so the application will behave normally while the payload is being executed. Now,
    as shown in [Figure 7-5](part0011.html#avg_declares_the_payload_safe_and_the_co),
    when this executable is processed with AVG, it comes back clean and should execute
    while still presenting us with a shell! (This option may not work with all executables,
    so be sure to test yours before deployment.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们在![图片1](../images/00002.gif)处下载了PuTTY Windows SSH客户端，然后在![图片2](../images/00004.gif)处使用`-k`标志访问PuTTY。`-k`标志配置有效载荷在主可执行文件之外的新线程中启动，这样在有效载荷执行时应用程序将表现得正常。现在，如[图7-5](part0011.html#avg_declares_the_payload_safe_and_the_co)所示，当这个可执行文件通过AVG处理时，它会干净地返回，并且应该执行，同时仍然为我们提供一个shell！（这个选项可能不适用于所有可执行文件，所以在部署之前务必测试你的。）
- en: When choosing to embed a payload in an executable, you should consider using
    GUI-based applications if you’re not specifying the `-k` flag. If you embed a
    payload into a console-based application, when the payload is run, it will display
    a console window that won’t close until you’re finished using the payload. If
    you choose a GUI-based application and do not specify the `-k` flag, when the
    payload is executed, the target will not see a console window. Paying attention
    to these little details can help you remain stealthy during an engagement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择在可执行文件中嵌入有效载荷时，如果你没有指定`-k`标志，你应该考虑使用基于GUI的应用程序。如果你将有效载荷嵌入到基于控制台的应用程序中，当有效载荷运行时，它将显示一个控制台窗口，直到你完成对有效载荷的使用，这个窗口才不会关闭。如果你选择基于GUI的应用程序并且没有指定`-k`标志，当有效载荷执行时，目标将不会看到控制台窗口。注意这些小细节可以帮助你在行动中保持隐蔽。
- en: '![AVG declares the payload safe and the computer secure.](../images/00035.jpeg)Figure 7-5. AVG
    declares the payload safe and the computer secure.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![AVG声明有效载荷安全且计算机安全。](../images/00035.jpeg)图7-5. AVG声明有效载荷安全且计算机安全。'
- en: Packers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Packers
- en: '*Packers* are tools that compress an executable and combine it with decompression
    code. When this new executable is run, the decompression code re-creates the original
    executable from the compressed code before executing it. This usually happens
    transparently so the compressed executable can be used in exactly the same way
    as the original. The result of the packing process is a smaller executable that
    retains all the functionality of the original.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*打包程序*是压缩可执行文件并将其与解压缩代码结合的工具。当这个新的可执行文件运行时，解压缩代码会在执行之前从压缩代码中重新创建原始的可执行文件。这通常是无缝发生的，因此压缩的可执行文件可以像原始文件一样使用。打包过程的结果是一个更小的可执行文件，它保留了原始文件的所有功能。'
- en: As with *msfencode*, packers change the structure of an executable. However,
    unlike the *msfencode* encoding process, which often increases the size of an
    executable, a carefully chosen packer will use various algorithms to both compress
    and encrypt an executable. Next, we use the popular *UPX* packer with Back|Track
    to compress and encode our *payload3.exe* payload in attempt to evade antivirus
    software detection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与*msfencode*一样，打包程序会改变可执行文件的结构。然而，与通常会增加可执行文件大小的*msfencode*编码过程不同，一个精心选择的打包程序将使用各种算法来压缩和加密可执行文件。接下来，我们使用流行的*UPX*打包程序与Back|Track一起压缩和编码我们的*payload3.exe*有效载荷，以尝试规避防病毒软件的检测。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At ![](../images/00002.gif) we install *UPX*, and then at ![](../images/00004.gif)
    we run *UPX* with no arguments to view its command line options. Then at ![](../images/00005.gif)
    we use the `−5` option to compress and pack our executable. You can see at ![](../images/00006.gif)
    that *UPX* compresses our payload 59.46 percent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在![../images/00002.gif](../images/00002.gif)处我们安装*UPX*，然后在![../images/00004.gif](../images/00004.gif)处我们不带参数运行*UPX*以查看其命令行选项。然后在![../images/00005.gif](../images/00005.gif)处我们使用`−5`选项来压缩和打包我们的可执行文件。您可以在![../images/00006.gif](../images/00006.gif)处看到*UPX*将我们的有效载荷压缩了59.46%。
- en: In our tests, only 9 of 42 antivirus vendors detected the *UPX*-packed binaries.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，只有9家防病毒供应商中的42家检测到了*UPX*打包的二进制文件。
- en: '* * *'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The PolyPack project ([http://jon.oberheide.org/files/woot09-polypack.pdf](http://jon.oberheide.org/files/woot09-polypack.pdf))
    shows the results of packing known malicious binaries with various packers and
    the effectiveness of antivirus detection before and after the packing process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PolyPack项目([http://jon.oberheide.org/files/woot09-polypack.pdf](http://jon.oberheide.org/files/woot09-polypack.pdf))展示了使用各种打包程序打包已知恶意二进制文件的结果，以及打包前后防病毒检测的效果。
- en: '* * *'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Msf Venom
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Msf Venom
- en: In this chapter we cover only the *msfpayload* and *msfencode* utilities, but
    there is an additional tool called *msfvenom* that combines the functionalities
    of *msfpayload* and *msfencode* in a simpler-to-use interface. *Msfvenom* is not
    covered in detail in this book (see [Appendix B](part0023.html#cheat_sheet)),
    but it should be very easy to use after you become familiar with *msfpayload*
    and *msfencode*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只介绍了*msfpayload*和*msfencode*工具，但还有一个名为*msfvenom*的工具，它将*msfpayload*和*msfencode*的功能结合在一个更易于使用的界面中。*Msfvenom*在本书中没有详细介绍（见[附录B](part0023.html#cheat_sheet)），但在熟悉*msfpayload*和*msfencode*之后，使用它应该非常简单。
- en: '* * *'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A Final Note on Antivirus Software Evasion
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于防病毒软件规避的最后一则笔记
- en: The world of antivirus software moves very quickly, even by Internet standards.
    As of this writing, the methods and processes documented in this chapter work
    successfully; however, experience has shown that even a few months can bring major
    changes in how antivirus evasion is accomplished. Although the Metasploit team
    is constantly tweaking its payloads and attempts to stay one step ahead of detection
    algorithms, don’t be surprised if by the time you work through these examples,
    some work and some do not. When you’re attempting antivirus evasion, consider
    using multiple packers or encoders, as mentioned, or write your own. Antivirus
    evasion, like all penetration testing skills, needs to be practiced and requires
    dedicated research to help you ensure success in your engagements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 防病毒软件的世界变化非常快，即使是按照互联网标准。截至本文撰写时，本章中记录的方法和过程都成功有效；然而，经验表明，即使几个月的时间也可能带来防病毒规避方式的重大变化。尽管Metasploit团队不断调整其有效载荷并试图领先于检测算法一步，但在您完成这些示例时，有些可能有效，有些可能无效，这并不奇怪。当您尝试防病毒规避时，请考虑使用多个打包程序或编码器，如前所述，或者编写自己的。防病毒规避，就像所有渗透测试技能一样，需要练习并需要专门的研究，以帮助您确保在您的任务中取得成功。
