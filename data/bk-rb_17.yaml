- en: Chapter 17. Threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 17 章。线程
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: There may be times when your programs need to perform more than one action at
    a time. For example, maybe you want to do some disk operations and simultaneously
    display some feedback to the user. Or you might want to copy or upload some files
    “in the background” while still allowing the user to carry on with some other
    task “in the foreground.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你的程序可能需要同时执行多个操作。例如，你可能想进行一些磁盘操作，同时向用户显示一些反馈。或者你可能想在用户继续在“前台”执行其他任务的同时，在“后台”复制或上传一些文件。
- en: In Ruby, if you want to do more than one task at a time, you can run each task
    in its own *thread*. A thread is like a program within a program. It runs some
    particular piece of code independently of any other threads.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，如果你想同时执行多个任务，你可以为每个任务运行一个自己的 *线程*。线程就像程序中的程序。它独立于其他线程运行一些特定的代码。
- en: However, as you will see shortly, multiple threads may need to find ways of
    cooperating with each other so that, for example, they can share the same data
    and they don’t hog all the processing time available, thereby preventing other
    threads from running. When reading this chapter, you need to be aware that the
    behavior of threads in Ruby 1.9 and newer is substantially different from threads
    in 1.8 and older. I’ll explain why that is shortly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你很快就会看到的，多个线程可能需要找到相互合作的方法，以便例如，它们可以共享相同的数据，并且不会占用所有可用的处理时间，从而防止其他线程运行。在阅读本章时，你需要意识到
    Ruby 1.9 及更高版本中线程的行为与 1.8 及更早版本中的线程有显著不同。我将在稍后解释原因。
- en: Creating Threads
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线程
- en: Threads can be created like any other object, using the `new` method. When you
    do this, you must pass to the thread a block containing the code you want the
    thread to run.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以像创建任何其他对象一样创建，使用 `new` 方法。当你这样做时，你必须向线程传递一个包含你想要线程运行的代码的块。
- en: 'What follows is my first attempt at creating two threads, one of which should
    print four strings while the other prints ten numbers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我尝试创建两个线程的第一次尝试，其中一个应该打印四个字符串，而另一个应该打印十个数字：
- en: '*threads1.rb*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*threads1.rb*'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In all probability, when you run this, you may see nothing or, anyway, very
    little. It may display some strings and some numbers but not all of them and not
    in any easily predictable order. In the sample code in the archive, I’ve added
    a report of the time taken for the program to execute, which shows that the darn
    thing finishes before it has time to get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，当你运行这个程序时，你什么也看不到，或者至少非常少。它可能显示一些字符串和一些数字，但不是所有的，也不是任何容易预测的顺序。在存档中的示例代码中，我添加了程序执行时间的报告，这表明这个讨厌的东西在开始之前就结束了！
- en: Running Threads
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行线程
- en: 'Here is a simple fix to the thread-running problem. Right at the end of the
    code, add this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决线程运行问题的简单方法。在代码的末尾，添加以下内容：
- en: '*threads2.rb*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*threads2.rb*'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This inserts a five-second delay. Now when you run the code again, you should
    see all the strings and all the numbers, albeit a bit jumbled up, like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将插入五秒的延迟。现在当你再次运行代码时，你应该能看到所有的字符串和所有的数字，尽管有点混乱，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is, in fact, exactly what you want since it shows that time is now being
    divided between the two threads. That’s why the words and numbers are jumbled,
    sometimes with even the carriage returns printed by the `puts` statements being
    mixed up, with either no carriage return or two at once being displayed. This
    happens because the threads are madly competing with one another for the available
    time—first one thread executes and displays a word, then the next thread executes
    and displays a number, then execution returns to the first thread, and so on,
    until the first thread ends (when all four words have been displayed), at which
    point the second thread can run without interruption.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这正是你想要的，因为它表明时间现在正在两个线程之间分配。这就是为什么单词和数字会混乱，有时甚至会把 `puts` 语句打印的回车符也混在一起，要么没有回车符，要么一次显示两个。这是因为线程正在疯狂地竞争可用的资源——首先一个线程执行并显示一个单词，然后下一个线程执行并显示一个数字，然后执行回到第一个线程，以此类推，直到第一个线程结束（当所有四个单词都显示完毕），此时第二个线程可以无干扰地运行。
- en: Now compare this with the first version of the program. In that program, I created
    two threads, but just as Ruby was getting itself ready to run the code inside
    each thread—*bam!*—it arrived at the end of the program and shut everything down,
    including my two threads. So, in effect, the threads were killed off before they
    had time to do anything of any interest.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这个与程序的第一版进行比较。在那个程序中，我创建了两个线程，但当Ruby正在准备运行每个线程内部的代码时——*砰!*——它到达了程序的末尾并关闭了一切，包括我的两个线程。所以，实际上，线程在有时间做任何有趣的事情之前就被杀死了。
- en: But when I add a call to `sleep( 5 )` to insert a five-second delay, Ruby has
    plenty of time to run the threads before the program exits. There is just one
    problem with this technique—and it’s a *big* problem. Adding unnecessary delays
    to your programs in order to let threads run defeats the object of the exercise.
    The timer display now shows that the program takes all of five whole seconds to
    run, which is about 4.99 seconds or so longer than is strictly necessary! You’ll
    be learning more civilized ways of handling threads shortly. First, however, I
    need to say a few words about an important difference between threads in Ruby
    1.8 and threads in Ruby 1.9.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我添加一个调用`sleep( 5 )`的语句来插入五秒延迟时，Ruby有足够的时间在程序退出之前运行线程。这个技术只有一个问题——这是一个*大*问题。为了让线程运行而向程序中添加不必要的延迟，这违背了练习的目的。现在计时器显示程序运行了整整五秒钟，这比严格必要的多出大约4.99秒！你很快就会学习到更文明地处理线程的方法。然而，首先我需要说几句关于Ruby
    1.8和Ruby 1.9中线程之间一个重要区别的话。
- en: Going Native
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生化
- en: In all versions of Ruby up to and including Ruby 1.8.*x*, there was no access
    to “native” threads (that is, threads handled by the operating system). In effect,
    Ruby 1.8 threads exist inside the closed world of a Ruby program, with multiple
    threads each being allocated time, using a procedure called *time-slicing*, within
    a single process. Ruby 1.9 (and newer) uses a new interpreter, YARV (Yet Another
    Ruby Virtual-machine). This allows Ruby 1.9 to make use of native threads, albeit
    with some limitations that I’ll explain shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby的所有版本中，包括1.8.*x*，都没有访问“原生”线程（即由操作系统处理的线程）。实际上，Ruby 1.8的线程存在于Ruby程序的封闭世界中，每个线程都分配了时间，在单个进程中使用称为*时间切片*的程序。Ruby
    1.9（及更高版本）使用一个新的解释器，YARV（另一种Ruby虚拟机）。这使得Ruby 1.9能够使用原生线程，尽管有一些限制，我稍后会解释。
- en: 'In principle, native threads allow more efficient execution (using *preemptive
    multitasking*) whereby the operating system takes care of the execution of threads
    on one or more processors. Even though Ruby 1.9 uses native threads, it does not
    perform preemptive multitasking. For reasons of compatibility with existing Ruby
    programs, Ruby 1.9 native threads work in a similar fashion to Ruby 1.8 non-native
    (or *green*) threads. In other words, although Ruby 1.9 may in fact run a native
    thread, it is the Ruby virtual machine, rather than the operating system, that
    schedules the execution of threads. This means Ruby threads sacrifice efficiency;
    however, they do at least benefit from portability: Threads written on one operating
    system will also run on a different operating system.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，原生线程允许更高效的执行（使用*抢占式多任务处理*），其中操作系统负责在一个或多个处理器上执行线程。尽管Ruby 1.9使用原生线程，但它并不执行抢占式多任务处理。出于与现有Ruby程序兼容性的原因，Ruby
    1.9的原生线程以类似Ruby 1.8非原生（或*绿色*）线程的方式工作。换句话说，尽管Ruby 1.9实际上可能运行原生线程，但线程的执行调度是由Ruby虚拟机而不是操作系统来完成的。这意味着Ruby线程牺牲了效率；然而，它们至少受益于可移植性：在一个操作系统上编写的线程也可以在不同的操作系统上运行。
- en: The Main Thread
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主线程
- en: 'Even if you don’t explicitly create any threads, there is always at least one
    thread executing—the main thread in which your Ruby program is running. You can
    verify this by entering the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有明确创建任何线程，也始终至少有一个线程正在执行——那就是运行你的Ruby程序的主线程。你可以通过输入以下内容来验证这一点：
- en: '*thread_main.rb*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*thread_main.rb*'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will display something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示类似以下的内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, Thread is the thread’s class, `0x28955c8` (or some other number) is its
    hexadecimal object identifier, and `run` is the thread’s current status.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Thread是线程的类，`0x28955c8`（或另一个数字）是其十六进制对象标识符，而`run`是线程的当前状态。
- en: Thread Status
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程状态
- en: 'Each thread has a status that may be one of the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有一个状态，可能是以下之一：
- en: '| `run` | When the thread is executing |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `run` | 当线程正在执行时 |'
- en: '| `sleep` | When the thread is sleeping or waiting on I/O |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `sleep` | 当线程正在睡眠或等待I/O时 |'
- en: '| `aborting` | When the thread is aborting |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `aborting` | 当线程正在中止时 |'
- en: '| `false` | When the thread terminated normally |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `false` | 当线程正常终止时 |'
- en: '| `nil` | When the thread terminated with an exception |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `nil` | 当线程因异常而终止时 |'
- en: You can obtain the status of a thread using the `status` method. The status
    is also shown when you inspect a thread, in which case either a `nil` or a `false`
    status is shown as `dead`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `status` 方法获取线程的状态。当检查线程时，状态也会显示，此时要么显示为 `nil` 或 `false` 的状态，表示“dead”。
- en: '*thread_status.rb*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*thread_status.rb*'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the status shown may differ according to the version of Ruby being
    used and also when the program is run at different times. This is because actions
    on threads may not occur instantly, and the timing of a change in status may vary
    with each execution. For example, sometimes you may see the status of a killed
    thread shown as “aborting” and at other times as “dead.” The thread aborts before
    it dies, and its change in status may happen in milliseconds. Here is an example
    taken from the Ruby class library documentation. The documented status of each
    thread is shown in the comments:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，显示的状态可能会根据所使用的 Ruby 版本以及程序运行的时间不同而有所差异。这是因为线程上的操作可能不会立即发生，状态变化的时间可能会随着每次执行而变化。例如，有时你可能看到已终止线程的状态显示为“aborting”，而有时则显示为“dead”。线程在死亡之前会中止，其状态的变化可能发生在毫秒级别。以下是从
    Ruby 类库文档中摘取的一个示例。每个线程的文档状态在注释中显示：
- en: '*thread_status2.rb*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*thread_status2.rb*'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But when I run this code with Ruby 1.9, the status varies greatly, and it does
    not always match the status shown in the documented example shown earlier. At
    one moment, this is what I see:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我用 Ruby 1.9 运行这段代码时，状态变化很大，并不总是与前面文档示例中显示的状态相匹配。有时候，我看到的是：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But when I run it again, this is what I see:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我再次运行它时，我看到的是：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now look at this program:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个程序：
- en: '*thread_status3.rb*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*thread_status3.rb*'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once again the output varies each time it is run. I often see the following,
    which shows that even after I have “killed” the thread, it may still be “aborting”
    when I test its status:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行时，输出每次都不同。我经常看到以下内容，这表明即使我已经“杀死”了线程，在测试其状态时它可能仍然处于“aborting”状态：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now I force a time delay by calling `sleep` for one second:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我通过调用 `sleep` 方法强制引入一秒的时间延迟：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This time the thread has time to be terminated, and this is displayed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这次线程有足够的时间被终止，显示如下：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These timing issues are more likely to arise in Ruby 1.9 than in older versions.
    You need to be aware of them and, if necessary, check a thread’s status repeatedly
    in order to verify that it is in the state expected at any given moment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些时间问题在 Ruby 1.9 中比在旧版本中更可能出现。你需要意识到这些问题，并在必要时反复检查线程的状态，以验证它在任何给定时刻是否处于预期的状态。
- en: Ensuring That a Thread Executes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保线程执行
- en: 'Let’s return to the problem I had in the previous programs. Recall that I created
    two threads, but the program finished before either of them had a chance to run
    fully. I fixed this by inserting a fixed-length delay using the `sleep` method.
    Deliberately introducing gratuitous delays into your programs is not something
    you would want to do as a general rule. Fortunately, Ruby has a more civilized
    way of ensuring that a thread has time to execute. The `join` method forces the
    calling thread (for example, the *main* thread) to suspend its own execution (so
    it doesn’t just terminate the program) until the thread that calls `join` has
    completed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前程序中遇到的问题。回想一下，我创建了两个线程，但程序在它们有机会完全运行之前就结束了。我通过使用 `sleep` 方法插入固定长度的延迟来解决这个问题。故意在程序中引入无谓的延迟并不是你想要的一般做法。幸运的是，Ruby
    有一种更文明的方式来确保线程有足够的时间执行。`join` 方法强制调用线程（例如，*主* 线程）暂停其自己的执行（这样它就不会只是终止程序），直到调用 `join`
    的线程完成：
- en: '*join.rb*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*join.rb*'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At first sight, this looks like progress since both threads get the time they
    need to execute and you haven’t had to introduce any unnecessary delays. However,
    when you take a look at the output, you will see that the threads run in sequence—*the
    second thread starts to run after the first thread has finished*. This is why
    the output shows first all the words, displayed in the first Thread, and then
    all the numbers, displayed in the second Thread. But what you really want to do
    is get the two threads to run simultaneously, with Ruby switching from one to
    the next to give each thread a slice of the available processing time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎是进步，因为两个线程都得到了它们执行所需的时间，你也没有引入任何不必要的延迟。然而，当你查看输出时，你会发现线程是按顺序运行的——*第二个线程在第一个线程完成后才开始运行*。这就是为什么输出首先显示所有单词，它们在第一个线程中显示，然后是所有数字，在第二个线程中显示。但你所真正想要的是让两个线程同时运行，Ruby
    在它们之间切换，给每个线程分配一段可用的处理时间。
- en: 'The next program, *threads3.rb*, shows one way of achieving this. It creates
    two threads, as before; however, this time it assigns each thread to a variable,
    namely, `wordsThread` and `numbersThread`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个程序，*threads3.rb*，展示了实现这一目标的一种方法。它创建了两个线程，就像之前一样；然而，这次它将每个线程分配给一个变量，即，`wordsThread`
    和 `numbersThread`：
- en: '*threads3.rb*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*threads3.rb*'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now it puts these threads into an array and calls the `each` method to pass
    them into a block where they are received by the block variable, `t`, which simply
    calls the `join` method on each thread:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它将这些线程放入一个数组中，并调用 `each` 方法将它们传递到一个块中，在该块中它们通过块变量 `t` 被接收，该变量简单地调用每个线程的 `join`
    方法：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you will see from the output, the two threads now run “in parallel,” so their
    output is jumbled up, but there is no artificial delay, and the total execution
    time is negligible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将从输出中看到的，现在两个线程“并行”运行，所以它们的输出是混乱的，但没有人工延迟，总执行时间可以忽略不计。
- en: Thread Priorities
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程优先级
- en: So far, I’ve given Ruby total freedom in slicing up the time between threads
    in any way it wants. But sometimes one thread is more important than the others.
    For example, if you are writing a file-copying program with one thread to do the
    actual copying and another thread to display the progress bar, it would make sense
    to give the file-copying thread most of the time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经给了 Ruby 在线程之间分配时间的完全自由。但有时一个线程比其他线程更重要。例如，如果你正在编写一个文件复制程序，一个线程用于实际复制，另一个线程用于显示进度条，那么给文件复制线程分配大部分时间是有意义的。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There may be times when the currently executing thread specifically wants to
    give execution time to other threads. This is done by calling the `Thread.pass`
    method. However, this may not produce quite the results you expect. The `pass`
    method is discussed in more detail in [Digging Deeper](ch17s10.html#digging_deeper-id16
    "Digging Deeper") in [Digging Deeper](ch17s10.html#digging_deeper-id16 "Digging
    Deeper").
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当前正在执行的线程可能特别想要将执行时间让给其他线程。这是通过调用 `Thread.pass` 方法来实现的。然而，这可能不会产生你期望的结果。`pass`
    方法在 [深入挖掘](ch17s10.html#digging_deeper-id16 "深入挖掘") 的 [深入挖掘](ch17s10.html#digging_deeper-id16
    "深入挖掘") 中有更详细的讨论。
- en: 'Ruby lets you assign integer values to indicate the priority of each thread.
    In theory, threads with higher priorities are allocated more execution time than
    threads with lower priorities. In practice, things aren’t that simple since other
    factors (such as the order in which threads are run) may affect the amount of
    time given to each thread. Moreover, in very short programs, the effects of varying
    the priorities may be impossible to determine. The little words-and-numbers thread
    example you’ve used up to now is far too short to show any clear differences.
    So, let’s take a look at a slightly more labor-intensive program—one that runs
    three threads, each of which calls a method fifty times in order to compute the
    factorial of 50\. For our purposes, it’s not important to understand how the code
    calculates factorials. Bear in mind, though, that it uses the shorthand (ternary
    operator) *if..else* notation (*`< Test Condition >`* `?` *`<if true do this>
    : <else do this>`*) explained in [Chapter 6](ch06.html "Chapter 6. Conditional
    Statements"):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ruby 允许你分配整数值来表示每个线程的优先级。从理论上讲，优先级较高的线程比优先级较低的线程分配更多的执行时间。但在实践中，事情并不那么简单，因为其他因素（例如线程运行的顺序）可能会影响分配给每个线程的时间。此外，在非常短的程序中，改变优先级的效果可能无法确定。你之前使用的简短的字词和数字线程示例远远不足以展示任何明显的差异。因此，让我们看看一个稍微复杂一些的程序——一个运行三个线程的程序，每个线程调用一个方法五十次来计算50的阶乘。对我们来说，理解代码如何计算阶乘并不重要。然而，请记住，它使用了在[第6章](ch06.html
    "第6章。条件语句")中解释的缩写（三元运算符）*if..else*表示法（*`< Test Condition >`* `?` *`<if true do
    this> : <else do this>`*）：'
- en: '*threads4.rb*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*threads4.rb*'
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can now set specific priorities for each thread:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以为每个线程设置特定的优先级：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, the priorities are the same for each thread, so, in principle,
    no thread will be given the biggest slice of the action, and the results from
    all three threads should appear in the usual jumble. This is indeed the case in
    Ruby 1.8, but be aware that thread priorities may not always produce the expected
    results in some versions of Ruby 1.9.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个线程的优先级相同，因此，从原则上讲，没有线程会被分配到最大的执行份额，所有三个线程的结果应该以通常的混乱方式出现。这确实是 Ruby
    1.8 的情况，但请注意，在某些版本的 Ruby 1.9 中，线程优先级可能不会产生预期的结果。
- en: Thread Priority Problems in Ruby 1.9
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 的线程优先级问题
- en: 'In Ruby 1.9, thread priorities do not always work as documented. Here is an
    example taken from the Ruby class library documentation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.9 中，线程优先级并不总是按文档所述工作。以下是一个从 Ruby 类库文档中摘取的例子：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*priority_test.rb*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*priority_test.rb*'
- en: In principle, `count1` is incremented on a higher-priority thread (`b`) than
    `count2` (on thread `a`), and it should, therefore, always result in a higher
    value number as indicated in the comments in this example. In practice (at least
    when running this program using Ruby 1.9.2 on Windows), `count1` is sometimes
    higher and sometimes lower than `count2`. This behavior has been reported and
    documented, and its status as either a “bug” or a “feature” is open to debate.
    I personally regard it as undesirable and still hope that it will be remedied.
    However, you must be sure to verify the effect of thread priorities before using
    them in your own programs. Most of the discussion of thread priorities in this
    chapter assumes you are using a version of Ruby in which priorities work as documented.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，`count1` 在优先级较高的线程（`b`）上递增，而 `count2`（在线程 `a` 上）则较低，因此，它应该总是产生一个比注释中所示更高的数值。但在实践中（至少当使用
    Ruby 1.9.2 在 Windows 上运行此程序时），`count1` 有时比 `count2` 高，有时比 `count2` 低。这种行为已被报告并记录，其作为“错误”或“特性”的状态尚有争议。我个人认为这是不希望的，并仍然希望它能得到修复。然而，在使用自己的程序之前，你必须确保验证线程优先级的效果。本章大部分关于线程优先级的讨论假设你使用的是文档中所述优先级正常工作的
    Ruby 版本。
- en: 'Now, in *threads4.rb* try changing the priority of `t3`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 *threads4.rb* 中尝试更改 `t3` 的优先级：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time when you run the code, `t3` will (at least in Ruby 1.8) grab most
    of the time and execute (mostly) before the other threads. The other threads may
    get a look in at the outset because they are created with equal priorities and
    the priority is changed only after they have started running. When `t3` has finished,
    `t1` and `t2` should share the time more or less equally.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当你运行代码时，`t3`（至少在 Ruby 1.8 中）将占用大部分时间，并在其他线程之前执行（主要是）。其他线程可能在开始时有机会，因为它们是以相同的优先级创建的，并且优先级是在它们开始运行之后改变的。当
    `t3` 完成，`t1` 和 `t2` 应该大致平均分配时间。
- en: 'So, let’s suppose you want `t1` and `t2` to run first, sharing time more or
    less equally and running `t3` only after those two threads have finished. Here’s
    my first attempt; you may want to try it yourself:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，假设你想要`t1`和`t2`先运行，时间分配大致相等，只有在那些两个线程完成之后才运行`t3`。这是我的第一次尝试；你可能想亲自试试：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Hmm, the end result is not what I wanted! It seems that the threads are run
    in sequence with no time-slicing at all! Okay, just for the heck of it, let’s
    try some negative numbers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，最终结果并不是我想要的！看起来线程是按顺序运行的，完全没有时间片分片！好吧，只是为了好玩，让我们尝试一些负数：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hurrah! That’s more like it. This time (at least in Ruby 1.8), `t1` and `t2`
    run concurrently though you may also see `t3` executing briefly before the thread
    priorities are set; then `t3` runs. So, why do negative values work but positive
    values don’t?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！这次好多了。这次（至少在Ruby 1.8中），`t1`和`t2`是并发运行的，尽管你可能会看到在设置线程优先级之前`t3`短暂执行；然后`t3`开始运行。那么，为什么负值有效而正值无效呢？
- en: There is nothing special about negative values *per se*. However, you need to
    bear in mind that every process has at least one thread running—the *main* thread—and
    this too has a priority. Its priority happens to be 0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 负值本身并没有什么特殊之处。然而，你需要记住，每个进程至少有一个正在运行的线程——*主线程*，它也有一个优先级。它的优先级恰好是0。
- en: The Main Thread Priority
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主线程优先级
- en: 'You can easily verify the priority of the main thread:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地验证主线程的优先级：
- en: '*main_thread.rb*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*main_thread.rb*'
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, in the previous program (*threads4.rb*), if you set the priority of `t1`
    to 2, it will “outrank” the main thread itself and will then be given all the
    execution time it needs until the next thread, `t2`, comes along, and so on. By
    setting the priorities lower than that of the main thread, you can force the three
    threads to compete only with themselves since the main thread will always outrank
    them. If you prefer working with positive numbers, you can specifically set the
    priority of the main thread to a higher value than all other threads:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在之前的程序（*threads4.rb*）中，如果你将`t1`的优先级设置为2，它将“超越”主线程本身，然后将被分配所有需要的执行时间，直到下一个线程`t2`到来，依此类推。通过将优先级设置为主线程以下，你可以迫使三个线程只与自己竞争，因为主线程总是会超越它们。如果你更喜欢使用正数，你可以将主线程的优先级特别设置为比其他所有线程都高的值：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ruby 1.9 may not respect all values assigned in this way. For example, when
    I display that the priority of a thread to 100 has been assigned, Ruby 1.9 shows
    3, whereas Ruby 1.8 shows 100.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9可能不会尊重以这种方式分配的所有值。例如，当我显示将线程的优先级设置为100时，Ruby 1.9显示3，而Ruby 1.8显示100。
- en: 'If you want `t2` and `t3` to have the same priority and `t1` to have a lower
    one, you need to set the priorities for those three threads plus the main thread:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要`t2`和`t3`具有相同的优先级，而`t1`具有较低的优先级，你需要为这三个线程以及主线程设置优先级：
- en: '*threads5.rb*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*threads5.rb*'
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once again, this assumes you are using a version of Ruby (such as Ruby 1.8)
    in which thread priorities are respected. If you look closely at the output, you
    may spot one tiny but undesirable side effect. It is possible (not *certain*,
    but *possible*) that you will see some output from the `t1` thread right at the
    outset, just before `t2` and `t3` kick in and assert their priorities. This is
    the same problem noted earlier: Each of the threads tries to start running as
    soon as it is created, and `t1` may get its own slice of the action before the
    priorities of the other threads are “upgraded.” To prevent this, you can specifically
    suspend the thread at the time of creation using `Thread.stop` like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这假设你使用的是尊重线程优先级的Ruby版本（例如Ruby 1.8）。如果你仔细查看输出，你可能会注意到一个微小但不受欢迎的副作用。有可能（不是*确定*，而是*可能*）你会看到`t1`线程的一些输出，就在`t2`和`t3`启动并声明它们的优先级之前。这是之前提到的问题：每个线程都试图在创建后立即开始运行，而`t1`可能会在其他线程的优先级“升级”之前获得自己的动作份额。为了防止这种情况，你可以在创建时使用`Thread.stop`特别挂起线程，如下所示：
- en: '*stop_run.rb*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*stop_run.rb*'
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, when you want to start the thread running (in this case, after setting
    the thread priorities), you call its `run` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你想要启动线程运行（在这种情况下，在设置线程优先级之后），你调用它的`run`方法：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the use of some Thread methods may cause *deadlocks* in Ruby 1.9\.
    A deadlock occurs when two or more threads are waiting for one another to release
    a resource. To avoid deadlocks, you may prefer to use mutexes, as I’ll explain
    next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，某些Thread方法的使用可能会导致Ruby 1.9中的*死锁*。死锁发生在两个或多个线程都在等待对方释放资源时。为了避免死锁，你可能更喜欢使用互斥锁，正如我接下来要解释的。
- en: Mutexes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: 'There may be occasions when multiple threads each need to access some kind
    of global resource. This has the potential of producing erroneous results because
    the current state of the global resource may be modified by one thread and this
    modified value may be unpredictable when it is used by some other thread. For
    a simple example, look at this code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，多个线程可能需要访问某种全局资源。这可能导致错误的结果，因为全局资源的当前状态可能被一个线程修改，而这个修改后的值在由其他线程使用时可能是不可预测的。为了一个简单的例子，看看这段代码：
- en: '*no_mutex.rb*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*no_mutex.rb*'
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: My intention here is to create and run three threads, each of which increments
    the global variable, `$i`, 1 million times. I do this by enumerating from 1 to
    3 and creating an array using the `collect` method (the `map` method is synonymous
    with `collect` so could also be used) from the results returned by the block.
    This array of threads, `somethreads`, subsequently passes each thread, `t`, into
    a block to be executed using `join`, as explained earlier. Each thread calls the
    `addNum` method to increment the value of `$i`. The expected result of `$i` at
    the end of this would (naturally) be 3 million. But, in fact, when I run this,
    the end value of `$i` is 1,068,786 (though you may see a different result).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意图是创建并运行三个线程，每个线程将全局变量 `$i` 增加 100 万次。我通过从 1 到 3 进行枚举，并使用 `collect` 方法（`map`
    方法与 `collect` 同义，因此也可以使用）从块返回的结果创建一个数组来实现这一点。这个线程数组 `somethreads` 随后通过 `join`
    将每个线程 `t` 传递给一个要执行的块，如前所述。每个线程调用 `addNum` 方法来增加 `$i` 的值。在这次操作结束时，`$i` 的预期结果自然是
    300 万。但实际上，当我运行这个程序时，`$i` 的最终值是 1,068,786（尽管你可能看到不同的结果）。
- en: The explanation of this is that the three threads are, in effect, competing
    for access to the global variable, `$i`. This means, at certain times, thread
    `a` may get the current value of `$i` (let’s suppose it happens to be 100), and
    simultaneously thread `b` gets the current value of `$i` (still 100). Now, `a`
    increments the value it just got (`$i` becomes 101), and `b` increments the value
    *it* just got, which was 100 (so `$i` becomes 101 once again). In other words,
    when multiple threads simultaneously access a shared resource, some of them may
    be working with out-of-date values, that is, values that do not take into account
    any modifications that have been made by other threads. Over time, errors resulting
    from these operations accumulate until you end up with results that differ substantially
    from those you might have anticipated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解释是，三个线程实际上是在竞争访问全局变量 `$i`。这意味着在某些时候，线程 `a` 可能会获取 `$i` 的当前值（假设它恰好是 100），同时线程
    `b` 也会获取 `$i` 的当前值（仍然是 100）。现在，`a` 增加了它刚刚获取的值（`$i` 变为 101），而 `b` 增加了它刚刚获取的值，这个值是
    100（所以 `$i` 再次变为 101）。换句话说，当多个线程同时访问一个共享资源时，其中一些可能在使用过时的值，也就是说，这些值没有考虑到其他线程所做的任何修改。随着时间的推移，这些操作产生的错误会累积，最终导致的结果与预期的结果大相径庭。
- en: 'To deal with this problem, you need to ensure that when one thread has access
    to a global resource, it blocks the access of other threads. This is another way
    of saying that the access to global resources granted to multiple threads should
    be “mutually exclusive.” You can implement this using Ruby’s Mutex class, which
    uses a semaphore to indicate whether a resource is currently being accessed and
    provides the `synchronize` method to prevent access to resources inside a block.
    Note that you must, in principle, `require ''thread''` to use the Mutex class,
    but in some versions of Ruby this is provided automatically. Here is my rewritten
    code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要确保当一个线程访问全局资源时，它会阻止其他线程的访问。这另一种说法是，多个线程对全局资源的访问应该是“互斥的”。你可以使用 Ruby
    的 Mutex 类来实现这一点，它使用一个信号量来指示资源是否正在被访问，并提供 `synchronize` 方法来防止在块内部访问资源。请注意，原则上，你必须
    `require 'thread'` 来使用 Mutex 类，但在 Ruby 的某些版本中，这可能是自动提供的。以下是我的重写代码：
- en: '*mutex.rb*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*mutex.rb*'
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time, the end result of `$i` is 3,000,000.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`$i` 的最终结果是 3,000,000。
- en: Finally, for a slightly more useful example of using threads, take a look at
    *file_find2.rb*. This sample program uses Ruby’s `Find` class to traverse directories
    on disk. For a nonthreaded example, see *file_find.rb*. Compare this with the
    *file_info3.rb* program in [Sorting by Size](ch13s07.html "Sorting by Size"),
    which uses the `Dir` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了更实用地展示线程的使用示例，请查看 *file_find2.rb*。这个示例程序使用 Ruby 的 `Find` 类遍历磁盘上的目录。对于非线程示例，请参阅
    *file_find.rb*。将其与 [Sorting by Size](ch13s07.html "Sorting by Size") 中的 *file_info3.rb*
    程序进行比较，该程序使用 `Dir` 类。
- en: 'This program sets two threads running. The first, `t1`, calls the `processFiles`
    method to find and display file information (you will need to edit the call to
    `processFiles` to pass to it a directory name on your system). The second thread,
    `t2`, simply prints out a message, and this thread runs while `t1` is “alive”
    (that is, running or sleeping):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序启动了两个线程。第一个线程 `t1` 调用 `processFiles` 方法来查找并显示文件信息（你需要编辑 `processFiles` 的调用，以便传递系统上的目录名）。第二个线程
    `t2` 简单地打印一条消息，并且当 `t1` “存活”（即正在运行或睡眠）时，这个线程在运行：
- en: '*file_find2.rb*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*file_find2.rb*'
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In a real application, you could adapt this technique to provide user feedback
    of some kind while some intensive process (such as directory walking) is taking
    place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你可以将这种技术适应以在某个密集型过程（如目录遍历）进行时提供某种用户反馈。
- en: Fibers
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fibers
- en: Ruby 1.9 introduces a new class called a Fiber, which is a bit like a thread
    and a bit like a block. Fibers are intended for the implementation of “lightweight
    concurrency.” This broadly means they operate like blocks (see [Chapter 10](ch10.html
    "Chapter 10. Blocks, Procs, and Lambdas")) whose execution can be paused and restarted
    just as you can with threads. Unlike threads, however, the execution of fibers
    is not scheduled by the Ruby virtual machine; it has to be controlled explicitly
    by the programmer. Another difference between threads and fibers is that threads
    run automatically when they are created; fibers do not. To start a fiber, you
    must call its `resume` method. To yield control to code outside the fiber, you
    must call the `yield` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 引入了一个名为 Fiber 的新类，它有点像线程，又有点像块。Fiber 的目的是实现“轻量级并发”。这广泛意味着它们像块一样操作（参见第
    10 章[Blocks, Procs, and Lambdas](ch10.html "第 10 章。块、Proc 和 Lambda")），其执行可以被暂停和重新启动，就像线程一样。然而，与线程不同的是，Fiber
    的执行不是由 Ruby 虚拟机调度；它必须由程序员显式控制。线程和 Fiber 之间的另一个区别是，线程在创建时自动运行；而 Fiber 不自动运行。要启动一个
    Fiber，你必须调用它的 `resume` 方法。要向 Fiber 外部的代码让出控制权，你必须调用 `yield` 方法。
- en: 'Let’s look at some simple examples:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些简单的示例：
- en: '*fiber_test.rb*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*fiber_test.rb*'
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here I create a new fiber, `f`, but don’t immediately start it running. First
    I display “a”, `puts( "a" )`, and then I start the fiber, `f.resume`. The fiber
    starts executing and displays the “In fiber” message. But then it calls `yield`
    with the “yielding” string. This suspends the execution of the fiber and allows
    the code outside the fiber to continue. The code that called `f.resume` now puts
    the string that’s been yielded, so “yielding” is displayed. Another call to `f.resume`
    restarts the fiber where you left off, so “Still in fiber” is displayed, and so
    on. With each call to `yield`, execution returns to code outside the fiber. And,
    when that code calls `f.resume`, the remaining code in the fiber is executed.
    Once there is no more code left to be executed, the fiber terminates. When an
    inactive (or *dead*) fiber is called by `f.resume`, a FiberError occurs. This
    is the output from the program shown earlier:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了一个新的 Fiber，`f`，但并没有立即启动它运行。首先我显示“a”，`puts( "a" )`，然后我启动 Fiber，`f.resume`。Fiber
    开始执行并显示“在 Fiber 中”的消息。然后它调用 `yield` 并传递“yielding”字符串。这暂停了 Fiber 的执行，并允许 Fiber
    外部的代码继续。调用 `f.resume` 的代码现在会打印出被 `yield` 的字符串，因此“yielding”被显示。再次调用 `f.resume`
    会从上次停止的地方重新启动 Fiber，因此显示“仍在 Fiber 中”，依此类推。每次调用 `yield`，执行都会返回到 Fiber 外部的代码。当该代码调用
    `f.resume` 时，Fiber 中剩余的代码会被执行。一旦没有更多的代码要执行，Fiber 就会终止。当通过 `f.resume` 调用一个非活动（或
    *已死亡*）的 Fiber 时，会引发 FiberError。这是前面程序输出的内容：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can avoid “dead fiber” errors by testing the state of a fiber using the
    `alive?` method. This returns true if the fiber is active and returns false if
    inactive. You must `require ''fiber''` in order to use this method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `alive?` 方法测试 Fiber 的状态来避免“已死亡 Fiber”错误。如果 Fiber 是活动的，它返回 true；如果是不活动的，它返回
    false。你必须 `require 'fiber'` 才能使用此方法：
- en: '*fiber_alive.rb*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*fiber_alive.rb*'
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `resume` method accepts an arbitrary number of parameters. On the first
    call to `resume`, they are passed as block arguments. Otherwise, they become the
    return value of the call to `yield`. The following example is taken from the documentation
    in the Ruby class library:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`resume` 方法接受任意数量的参数。在第一次调用 `resume` 时，它们作为块参数传递。否则，它们成为 `yield` 调用的返回值。以下示例取自
    Ruby 类库中的文档：'
- en: '*fiber_test2.rb*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*fiber_test2.rb*'
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s a simple example illustrating the use of two fibers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单示例，说明了两个 Fiber 的使用：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This starts the first fiber, `f`, which runs until the call to `yield`. Then
    it starts the second fiber, `f2`, which runs until it too calls `yield`. Then
    the main program displays the string “world,” and finally `f2` and `f` are resumed.
    This is the output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这启动了第一条纤维，`f`，它一直运行到调用`yield`。然后它启动第二条纤维，`f2`，它也一直运行到它也调用`yield`。然后主程序显示字符串“world”，最后`f2`和`f`被恢复。这是输出：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Digging Deeper
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Here you will learn how to pass execution from one thread to another. You will
    discover some things that the Ruby documentation doesn’t tell you and some oddities
    about different versions of Ruby.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习如何将执行权从一个线程传递到另一个线程。你将发现一些Ruby文档没有告诉你的内容，以及Ruby不同版本的一些奇怪之处。
- en: Passing Execution to Other Threads
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行权传递给其他线程
- en: Sometimes you might specifically want a certain thread to yield execution to
    any other threads that happen to be running. For example, if you have multiple
    threads doing steadily updated graphics operations or displaying various bits
    of “as it happens” statistical information, you may want to ensure that once one
    thread has drawn X number of pixels or displayed Y number of statistics, the other
    threads are guaranteed to get their chances to do something.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望特定的线程将执行权让给任何正在运行的线程。例如，如果你有多个线程正在执行稳定的图形操作或显示各种“实时”统计信息，你可能想确保一旦一个线程绘制了X数量的像素或显示了Y数量的统计信息，其他线程将保证有机会做些事情。
- en: 'In theory, the `Thread.pass` method takes care of this. Ruby’s source code
    documentation states that `Thread.pass` “invokes the thread scheduler to pass
    execution to another thread.” This is the example provided by the Ruby documentation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`Thread.pass`方法负责处理这个问题。Ruby的源代码文档指出`Thread.pass`“调用线程调度器将执行传递给另一个线程。”这是Ruby文档提供的示例：
- en: '*pass0.rb*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*pass0.rb*'
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: According to the documentation, this code, when run, produces the output `axbycz`.
    And, sure enough, it does. In theory, then, this seems to show that by calling
    `Thread.pass` after each call to `print`, these threads pass execution to another
    thread, which is why the output from the two threads alternates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，这段代码在运行时会产生输出`axbycz`。确实如此，它确实产生了这样的输出。因此，理论上，这似乎表明通过在每次调用`print`之后调用`Thread.pass`，这些线程将执行权传递给另一个线程，这就是为什么两个线程的输出交替出现。
- en: 'Being of a suspicious turn of mind, I wondered what the effect would be with
    the calls to `Thread.pass` removed. Would the first thread hog all the time, yielding
    to the second thread only when it has finished? The best way to find out is to
    try it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我有一种怀疑的心态，我想知道移除对`Thread.pass`的调用会有什么效果。第一个线程是否会一直占用所有时间，直到完成才将控制权交给第二个线程？找出答案的最佳方式是尝试一下：
- en: '*pass1.rb*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*pass1.rb*'
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If my theory is correct (that thread `a` will hog all the time until it’s finished),
    this would be the expected output: `abcdef`. In fact (to my surprise!), the output
    actually produced was `axbycz`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的理论是正确的（即线程`a`将一直占用所有时间直到完成），这将是最预期的输出：`abcdef`。事实上（令我惊讶的是！），实际产生的输出实际上是`axbycz`。
- en: In other words, the result was the *same* with or without all those calls to
    `Thread.pass`. So what, if anything, is `Thread.pass` doing? And is the documentation
    wrong when it claims that the `pass` method invokes the thread scheduler to pass
    execution to another thread?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，无论是否有所有那些对`Thread.pass`的调用，结果都是相同的。那么，如果有什么的话，`Thread.pass`在做什么？当它声称`pass`方法调用线程调度器将执行传递给另一个线程时，文档是错误的吗？
- en: 'For a brief and cynical moment I confess that I toyed with the possibility
    that the documentation was simply incorrect and that `Thread.pass` didn’t do anything
    at all. A look into Ruby’s C-language source code soon dispelled my doubts; `Thread.pass`
    certainly does something, but its behavior is not quite as predictable as the
    Ruby documentation seems to suggest. Before explaining why this is, let’s try
    an example of my own:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个短暂而愤世嫉俗的时刻，我承认我考虑了这样的可能性，即文档可能是错误的，`Thread.pass`根本不做任何事情。查看Ruby的C语言源代码很快消除了我的疑虑；`Thread.pass`确实做了些什么，但它的行为并不像Ruby文档似乎暗示的那样可预测。在解释原因之前，让我们尝试一个我自己的例子：
- en: '*pass2.rb*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*pass2.rb*'
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At first sight, this may look very similar to the previous example. It sets
    two threads running, but instead of printing out something repeatedly, these threads
    repeatedly add a character to a string—“a” being added by the `a` thread and “b”
    by the `b` thread. After each operation, `Thread.pass` passes execution to the
    other thread. At the end, the entire string is displayed. When run with Ruby 1.8,
    it comes as no surprise that the string contains an alternating sequence of “a”
    and “b” characters: `abababababababababab`. However, in Ruby 1.9, the characters
    do not alternate, and this is what I see: `aaaaaaaaaabbbbbbbbbb`. In my view,
    the `pass` method is not to be trusted with Ruby 1.9, and the remaining discussion
    applies to Ruby 1.8 only.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这似乎与上一个例子非常相似。它启动了两个线程，但与反复打印内容不同，这些线程反复向一个字符串中添加字符——“a”由 `a` 线程添加，“b”由 `b`
    线程添加。每次操作后，`Thread.pass` 将执行权传递给另一个线程。最后，整个字符串被显示出来。当使用 Ruby 1.8 运行时，字符串包含交替的“a”和“b”字符序列并不令人惊讶：`abababababababababab`。然而，在
    Ruby 1.9 中，字符不会交替，这是我看到的结果：`aaaaaaaaaabbbbbbbbbb`。在我看来，`pass` 方法在 Ruby 1.9 中并不可靠，接下来的讨论仅适用于
    Ruby 1.8。
- en: 'Now, remember that in the previous program, I obtained the same alternating
    output even when I removed the calls to `Thread.pass`. Based on that experience,
    I guess I should expect similar results if I delete `Thread.pass` in this program.
    Let’s try it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住在之前的程序中，即使我移除了 `Thread.pass` 的调用，我也获得了相同的交替输出。基于那个经验，我猜如果我在这个程序中删除 `Thread.pass`，我应该期待类似的结果。让我们试试：
- en: '*pass3.rb*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*pass3.rb*'
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This time, this is the output: `aaaaaaaaaabbbbbbbbbb`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，这是输出结果：`aaaaaaaaaabbbbbbbbbb`。
- en: In other words, this program shows the kind of differing behavior that I had
    originally anticipated in the first program (the one I copied out of Ruby’s embedded
    documentation), which is to say that when the two threads are left to run under
    their own steam, the first thread, `a`, grabs all the time for itself and only
    when it’s finished does the second thread, `b`, get a look in. But by explicitly
    adding calls to `Thread.pass` in Ruby 1.8, you can force each thread to pass execution
    to any other threads.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个程序展示了我在第一个程序（我从 Ruby 的嵌入式文档中复制出来的那个程序）中最初预期的不同行为，也就是说，当两个线程被留给自己运行时，第一个线程
    `a` 会独占所有时间，只有当它完成时，第二个线程 `b` 才有机会。但是，通过在 Ruby 1.8 中显式添加 `Thread.pass` 的调用，你可以强制每个线程将执行权传递给其他线程。
- en: So, how can you explain this difference in behavior? In essence, *pass0.rb*
    and *pass3.rb* are doing the same things—running two threads and displaying strings
    from each. The only real difference is that, in *pass3.rb*, the strings are concatenated
    inside the threads rather than printed. This might not seem like a big deal, but
    it turns out that printing a string takes a bit more time than concatenating one.
    In effect, then, a call to `print` introduces a time delay. And as you found out
    earlier (when I deliberately introduced a delay using `sleep`), time delays have
    profound effects on threads.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何解释这种行为差异呢？本质上，*pass0.rb* 和 *pass3.rb* 做的是相同的事情——运行两个线程并显示每个线程的字符串。唯一的真正区别在于，在
    *pass3.rb* 中，字符串是在线程内部连接的，而不是打印。这看起来可能不是什么大问题，但结果证明，打印一个字符串比连接一个字符串要花费更多的时间。因此，调用
    `print` 会引入时间延迟。正如你之前发现的（当我故意使用 `sleep` 引入延迟时），时间延迟对线程有深远的影响。
- en: 'If you still aren’t convinced, try my rewritten version of *pass0.rb*, which
    I have creatively named *pass0_new.rb*. This simply replaces the prints with concatenations.
    Now if you comment and uncomment the calls to `Thread.pass`, you will indeed,
    in Ruby 1.8, see differing results:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不相信，尝试我重写的 *pass0.rb* 版本，我创造性地将其命名为 *pass0_new.rb*。这仅仅是将打印替换为连接。现在，如果你注释和取消注释
    `Thread.pass` 的调用，你确实会在 Ruby 1.8 中看到不同的结果：
- en: '*pass0_new.rb*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*pass0_new.rb*'
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With `Thread.pass`, Ruby 1.8 displays the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Thread.pass`，Ruby 1.8 会显示以下内容：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Without `Thread.pass`, Ruby 1.8 displays the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `Thread.pass`，Ruby 1.8 会显示以下内容：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In Ruby 1.9, the presence or absence of `Thread.pass` has no obvious effect.
    And, with or without it, this is displayed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.9 中，`Thread.pass` 的存在与否没有明显的影响。无论是否有它，都会显示以下内容：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Incidentally, my tests were conducted on a PC running Windows. It is quite possible
    that different results will be seen on other operating systems. This is because
    the implementation of the Ruby scheduler, which controls the amount of time allocated
    to threads, is different on Windows and other operating systems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的是，我的测试是在运行 Windows 的 PC 上进行的。在其他操作系统上可能会看到不同的结果。这是因为 Ruby 调度器的实现不同，它控制着分配给线程的时间量，在
    Windows 和其他操作系统上有所不同。
- en: 'As a final example, you may want to take a look at the *pass4.rb* program,
    which is intended for Ruby 1.8 only. This creates two threads and immediately
    suspends them (`Thread.stop`). In the body of each thread the thread’s information,
    including its `object_id` is appended to an array, `arr`, and then `Thread.pass`
    is called. Finally, the two threads are run and joined, and the array, `arr`,
    is displayed. Try experimenting by uncommenting `Thread.pass` to verify its effect
    (pay close attention to the execution order of the threads as indicated by their
    `object_id` identifiers):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，你可能想看看 *pass4.rb* 程序，这个程序仅适用于 Ruby 1.8。它创建了两个线程并立即挂起它们（`Thread.stop`）。在每一个线程的主体中，线程的信息，包括其
    `object_id`，被追加到一个数组 `arr` 中，然后调用 `Thread.pass`。最后，运行并合并这两个线程，并显示数组 `arr`。尝试取消注释
    `Thread.pass` 来进行实验，以验证其效果（请密切注意线程的执行顺序，如它们的 `object_id` 标识符所示）：
- en: '*pass4.rb*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*pass4.rb*'
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
