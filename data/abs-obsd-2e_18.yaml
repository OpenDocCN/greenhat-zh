- en: Chapter 18. Kernel Configuration
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 18 章。内核配置
- en: '*Kernel, not colonel!*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*内核，不是上校！*'
- en: '*This is blowfish, not chicken.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是 Blowfish，不是鸡*。'
- en: '*Less grease, more function.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*少油多汁*。'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Depending on your systems
    administration experience and background, the kernel is a subject of great mystery
    and speculation. It might be something you reconfigure when the whim strikes you,
    or something you know to leave alone.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1616079.png) 根据你的系统管理经验和背景，内核是一个充满神秘和猜测的主题。它可能是你心血来潮时重新配置的东西，或者是你知道不要去动的东西。'
- en: Most commercial operating systems provide only a few basic hooks for configuring
    the kernel. Many open source operating systems tell you to rebuild the kernel
    from source code whenever you change anything.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数商业操作系统只为配置内核提供了一些基本钩子。许多开源操作系统会告诉你，每次更改任何内容时都要从源代码重新构建内核。
- en: OpenBSD falls somewhere in the middle.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 处于中间位置。
- en: The standard OpenBSD kernel is intended to be perfectly usable without modifications,
    but you have the tools to perform any tweaks or adjustments necessary for your
    environment. Additionally, you have the complete source code and kernel-building
    tools in case you decide to perform wholesale kernel surgery.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 OpenBSD 内核旨在无需修改即可完美使用，但你拥有进行任何调整或调整所需的环境工具。此外，如果你决定进行大规模内核手术，你还有完整的源代码和内核构建工具。
- en: OpenBSD lets you adjust kernel behavior even as the system is running, via `sysctl(8)`.
    Some hardware or protocols require special OpenBSD kernel tweaks to run in specific
    environments. This chapter will cover both kinds of changes, but first, let’s
    talk about the kernel in general.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 允许你在系统运行时调整内核行为，通过 `sysctl(8)` 实现。某些硬件或协议需要特殊的 OpenBSD 内核调整才能在特定环境中运行。本章将涵盖这两种类型的更改，但首先，让我们来谈谈内核的一般情况。
- en: What Is the Kernel?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是内核？
- en: “The file */bsd* is OpenBSD’s kernel. Next question?”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “文件 */bsd* 是 OpenBSD 的内核。下一个问题？”
- en: That’s technically correct, but not exactly useful. A more general description
    is that “The kernel is the interface that links applications and the hardware.”
    That’s not a complete definition, but it’s good enough.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术上是对的，但并不十分有用。一个更通用的描述是，“内核是连接应用程序和硬件的接口。”这不是一个完整的定义，但已经足够了。
- en: The kernel allows programs to write data to disk drives and to the network,
    and it gives instructions to the CPU and shuffles bits into memory. When you open
    a web page, the browser application asks the kernel to fetch the data it displays.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 内核允许程序将数据写入磁盘驱动器和网络，并向 CPU 发出指令，将位移动到内存中。当你打开一个网页时，浏览器应用程序会请求内核获取显示的数据。
- en: Some kernel responsibilities exceed this definition. For example, the kernel
    handles network connectivity, including forwarding packets from one interface
    to another if needed. The packet-filtering rules run in the kernel (although the
    rules are managed by applications). The kernel handles disk redundancy. And the
    kernel also handles all sorts of things that don’t impact applications but are
    integral to a functioning system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内核责任超出了这个定义。例如，内核处理网络连接，包括在需要时从一个接口转发数据包到另一个接口。数据包过滤规则在内核中运行（尽管规则由应用程序管理）。内核处理磁盘冗余。内核还处理所有不影响应用程序但对系统运行至关重要的各种事情。
- en: A simplified view is to think of the kernel as the program that handles all
    the low-level functions, which is close enough to give you an idea of what the
    kernel does.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，可以把内核看作是处理所有底层功能的程序，这已经足够让你了解内核的作用。
- en: Along with *kernel*, you’ll also hear the term *userland*. Userland is everything
    in the system that isn’t the kernel. Your shells, libraries, and applications
    are all part of userland.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 *kernel*，你还会听到 *userland* 这个术语。Userland 是系统中不属于内核的所有内容。你的 shell、库和应用程序都是
    userland 的一部分。
- en: Kernel Messages
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核消息
- en: The kernel issues messages to userland. These include hardware attaching and
    detaching alerts, warnings from device drivers, and system boot messages. If you’re
    logged on to the system console in text mode, you might notice these messages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内核向用户空间发出消息。这些包括硬件连接和断开警报、设备驱动程序的警告以及系统启动消息。如果你以文本模式登录到系统控制台，你可能会注意到这些消息。
- en: To review kernel messages, you can watch the console, check the system logs
    (as discussed in [Chapter 15](ch15.html "Chapter 15. System Maintenance")), or
    use `dmesg(8)`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看内核消息，你可以查看控制台、检查系统日志（如第 15 章所述[Chapter 15](ch15.html "Chapter 15. System
    Maintenance")），或使用 `dmesg(8)`。
- en: OpenBSD has a system message buffer, where it sends messages from the kernel.
    These messages are usually copied to the system logger, but they’re also accessible
    via `dmesg`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD有一个系统信息缓冲区，其中它将消息从内核发送出去。这些消息通常被复制到系统日志中，但也可以通过`dmesg`访问。
- en: The system message buffer is circular. As it fills up, the oldest messages are
    deleted to make room for new ones. Run `dmesg` to view it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 系统信息缓冲区是环形的。随着它的填满，最旧的信息被删除以腾出空间给新的信息。运行`dmesg`来查看它。
- en: Startup Messages
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动信息
- en: One common question is “What hardware did your kernel find?” If the kernel handles
    all the device drivers and other hardware support, the list of devices found should
    include all the supported hardware in the system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是“你的内核找到了哪些硬件？”如果内核处理所有的设备驱动程序和其他硬件支持，那么找到的设备列表应该包括系统中所有受支持的硬件。
- en: While the system message buffer is circular, OpenBSD copies the boot-time system
    messages into */var/run/dmesg.boot*. Here are the boot messages from one of my
    test systems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然系统信息缓冲区是环形的，但OpenBSD会将启动时的系统消息复制到`/var/run/dmesg.boot`。以下是我测试系统中的一个启动消息。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line lists the version of OpenBSD, the kernel name and version, the
    date the kernel was built, as well as the machine and directory where the kernel
    was built and who built it. This machine runs an official OpenBSD i386 snapshot,
    built by Theo de Raadt.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行列出了OpenBSD的版本、内核名称和版本、内核构建的日期，以及内核构建的机器和目录以及构建者。这台机器运行的是官方OpenBSD i386快照，由Theo
    de Raadt构建。
- en: We then see some specifics on the processor. Those familiar with AMD will note
    that this is a 64-bit amd64 processor. I chose to run the 32-bit i386 version
    of OpenBSD, because that’s the installation disk I had handy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来看到一些关于处理器的具体信息。熟悉AMD的读者会注意到这是一个64位的amd64处理器。我选择运行32位的i386版本的OpenBSD，因为这是我手头上的安装盘。
- en: This system came with 256MB of RAM, but 1MB is lost due to hardware-level weirdness.
    OpenBSD sees 255MB, and 240MB are available to programs other than the kernel
    at this moment. The kernel might use some of that memory later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统配备了256MB的RAM，但由于硬件级别的奇怪问题，有1MB丢失。OpenBSD看到255MB，此时有240MB可供除内核之外的其他程序使用。内核可能会稍后使用一些那部分内存。
- en: Device Attachments
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备附加
- en: The kernel then explores the hardware. When it finds hardware that matches a
    device driver, it attaches the device driver to the hardware.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内核随后探索硬件。当它找到与设备驱动程序匹配的硬件时，它会将设备驱动程序附加到硬件上。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: OpenBSD found the main system bus, `mainbus0`, which is a bit odd because it’s
    not actually a piece of hardware. The kernel creates this logical device as a
    point for all other devices to attach to. It’s not the only logical device driver,
    but it’s present on every machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD找到了主系统总线`mainbus0`，这有点奇怪，因为它实际上不是一块硬件。内核创建这个逻辑设备作为所有其他设备附加的点。它不是唯一的逻辑设备驱动程序，但它在每台机器上都是存在的。
- en: The `bios0` device, for the hardware BIOS, isn’t terribly interesting either.
    You know the hardware has some kind of BIOS. We covered configuring your system
    BIOS back in [Chapter 3](ch03.html "Chapter 3. Installation Walk-Through"), and
    you haven’t needed to look at it since. Similarly, the `acpi0` device represents
    the Advanced Configuration and Power Interface (ACPI). If it needed any configuration,
    you took care of that after unpacking the system from the shipping box.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`bios0`设备，对于硬件BIOS来说，也没有什么特别有趣的地方。你知道硬件有一些BIOS。我们之前在[第3章](ch03.html "第3章。安装指南")中介绍了如何配置系统BIOS，并且自从那时起你就不需要查看它了。同样，`acpi0`设备代表高级配置和电源接口（ACPI）。如果它需要任何配置，你会在从运输箱中解包系统后进行处理。'
- en: Connections and Numbering
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接和编号
- en: Now we get into real hardware.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入真正的硬件。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first PCI bus, device `pci0`, is attached to `mainbus0` in the slot bus
    0\. The kernel then finds a device it identifies as `pchb0`, and attaches it to
    the PCI bus as device 0\. Don’t know what `pchb0` is? Use `man pchb` to identify
    this as a PCI host bridge. `dmesg` gives you the part number.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一PCI总线，设备`pci0`，连接到插槽总线0的`mainbus0`。内核随后找到一个它识别为`pchb0`的设备，并将其作为设备0附加到PCI总线上。不知道`pchb0`是什么？使用`man
    pchb`来识别它作为一个PCI主机桥。`dmesg`会给你部件号。
- en: Next is the device `ppb0` (a PCI/PCI bridge, per `ppb(4)`), attached to PCI
    bus 0 as device 1\. This is followed by another PCI bus, `pci1`, attached to the
    `ppb` device. Each instance of a device is assigned a number, starting with zero.
    Our tenth PCI bus would be device `pci9`. (There’s no technical requirement for
    sequential numbering, but the kernel follows this rule unless you tell it otherwise.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是设备 `ppb0`（一个 PCI/PCI 桥，根据 `ppb(4)`），作为设备 1 连接到 PCI 总线 0。这后面跟着另一个 PCI 总线
    `pci1`，它连接到 `ppb` 设备。每个设备的实例都分配一个数字，从零开始。我们的第十个 PCI 总线将是设备 `pci9`。（没有技术要求按顺序编号，但内核除非您告知它否则会遵循此规则。）
- en: If you dig through *dmesg.boot*, you’ll see that every device is plugged into
    another device somewhere. For example, here’s my keyboard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入查看 *dmesg.boot*，你会看到每个设备都连接到另一个设备。例如，这是我的键盘。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The keyboard `wskbd0` is attached to device `pckbd0`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘 `wskbd0` 已连接到设备 `pckbd0`。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Device `pckbd0` is attached to device `pckbc0`, which, in turn, is plugged into
    the `isa0` device, which is the ISA bus.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设备 `pckbd0` 连接到设备 `pckbc0`，而 `pckbc0` 又连接到 `isa0` 设备，这是 ISA 总线。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The ISA bus is connected to the Intel PIIX4 ISA bridge.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ISA 总线连接到 Intel PIIX4 ISA 桥。
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And this bridge is then hooked to PCI bus 0.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个桥接器连接到 PCI 总线 0。
- en: OpenBSD finds devices from the root outward, which means that everything is
    listed in the reverse order from what you’ve just seen. You get a list of which
    devices are attached to a device, and then the devices attached to those devices.
    You can backtrack starting with the end device, but that’s kind of annoying.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 从根向外查找设备，这意味着列表中的顺序与您刚才看到的顺序相反。您会得到一个列表，显示哪些设备连接到某个设备，然后是连接到这些设备的设备。您可以从终端设备开始回溯，但这有点麻烦。
- en: Using dmassage to View Installed Devices
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 dmassage 查看已安装设备
- en: 'I find the `dmassage` package most useful for identifying exactly what’s attached
    to what devices, although that’s not its only function. Install `dmassage` like
    any other package, and then run it with `-t` to display installed devices as a
    tree, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 `dmassage` 软件包在确定哪些设备连接到哪些设备方面非常有用，尽管这并非它的唯一功能。像其他任何软件包一样安装 `dmassage`，然后使用
    `-t` 选项运行它以显示以树状结构显示的已安装设备，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While this information may not be immediately useful, `dmassage` illustrates
    how devices are interconnected on your system, which may become important later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些信息可能不是立即有用的，但 `dmassage` 展示了系统上设备是如何相互连接的，这可能在以后变得很重要。
- en: Viewing and Adjusting Sysctls
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看和调整 Sysctls
- en: As noted in earlier chapters, the OpenBSD kernel includes a variety of parameters
    known as *system controls*, or *sysctls*. Some sysctls are static and can be viewed
    but not changed. The root account can change others, either at runtime or at boot.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，OpenBSD 内核包括各种称为 *系统控制* 或 *sysctls* 的参数。一些 sysctls 是静态的，可以查看但不能更改。root
    账户可以更改其他一些，无论是在运行时还是在启动时。
- en: Sysctls allow an application to retrieve information from the kernel. They also
    let a sysadmin change system behavior without reconfiguring applications, recompiling
    the kernel, or rebooting. You can view sysctl values and adjust those that can
    be changed with `sysctl(8)`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Sysctls 允许应用程序从内核检索信息。它们还允许系统管理员在不重新配置应用程序、重新编译内核或重启的情况下更改系统行为。您可以使用 `sysctl(8)`
    查看sysctl值并调整可更改的值。
- en: That said, just because you *can* change sysctls doesn’t mean you *should* change
    them. The OpenBSD developers set the sysctls to default values that work well
    for most environments. You might need to change one or two for your system, but
    if you find yourself changing sysctls all over the place, you’re probably sending
    yourself down the sysadmin rabbit hole.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，尽管您 *可以* 更改 sysctls，但这并不意味着您 *应该* 更改它们。OpenBSD 开发者将 sysctls 设置为适用于大多数环境的默认值。您可能需要更改一个或两个以适应您的系统，但如果您发现自己到处都在更改
    sysctls，那么您可能正在进入系统管理员的兔子洞。
- en: Sysctl MIBs
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sysctl MIBs
- en: 'The kernel presents sysctls in a MIB tree. As you learned in [Chapter 16](ch16.html
    "Chapter 16. Network Servers"), MIB trees organize information into hierarchical
    categories. The top-level categories include `kern` (kernel), `vm` (virtual memory),
    `net` (networking), `hw` (hardware), `machdep` (machine-dependent values), and
    so on. Each of these categories has additional subcategories. For example, `net`
    has the categories `inet` (IPv4) and `inet6` (IPv6). The `inet6` MIBs have subcategories
    `ip6` (general IPv6 characteristics) and `icmp6` (ICMP for IPv6). When you reach
    the end of categories, you’ll find individual MIBs like these:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 内核以MIB树的形式呈现sysctl。正如您在[第16章](ch16.html "第16章。网络服务器")中学到的，MIB树将信息组织成层次类别。顶级类别包括`kern`（内核）、`vm`（虚拟内存）、`net`（网络）、`hw`（硬件）、`machdep`（机器相关值）等等。这些类别中的每一个都有额外的子类别。例如，`net`有`inet`（IPv4）和`inet6`（IPv6）类别。`inet6`
    MIB有`ip6`（通用IPv6特性）和`icmp6`（IPv6的ICMP）子类别。当您到达类别的末尾时，您会找到这些单独的MIB：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This MIB configures forwarding IPv6 packets between interfaces, turning the
    host into the router. How do I know? I’ve read it in the documentation, and it’s
    a commented example in */etc/sysctl.conf*. OpenBSD doesn’t maintain a central
    list of sysctl values, but the man pages refer to any related sysctls.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个MIB配置了在接口之间转发IPv6数据包，将主机变成路由器。我如何知道？我在文档中读过，它是在`/etc/sysctl.conf`中的注释示例。OpenBSD不维护sysctl值的中央列表，但手册页引用了任何相关的sysctl。
- en: If you want to explore sysctls, get a list from your system, as described next.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索sysctl，请根据以下描述从您的系统获取列表。
- en: Viewing Sysctls
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看Sysctl
- en: Use `sysctl(8)` to view the sysctls available on a system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sysctl(8)`来查看系统上可用的sysctl。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This particular system has more than 400 sysctls. Interpreting the `kern.ostype`
    and `kern.osrelease` sysctls is fairly straightforward, but why would an OpenBSD
    system have a sysctl to report the operating system?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的系统有超过400个sysctl。解释`kern.ostype`和`kern.osrelease` sysctl相对直接，但为什么OpenBSD系统会有一个sysctl来报告操作系统呢？
- en: 'The `sysctl(3)` interface appears in all BSD-derived operating systems and
    even in Linux, so checking the `kern.ostype` sysctl, or checking for its existence,
    is a good way for third-party software to identify the operating system. `kern.osrevision`
    is just the year and month this particular snapshot was built. `kern.version`
    is the kernel compilation information displayed at boot. That’s not hard, is it?
    Let’s look at the next few sysctls:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysctl(3)`接口出现在所有基于BSD的操作系统上，甚至在Linux上，所以检查`kern.ostype` sysctl或检查其存在性是第三方软件识别操作系统的好方法。`kern.osrevision`只是这个特定快照构建的年份和月份。`kern.version`是启动时显示的内核编译信息。这难道不难吗？让我们看看接下来的几个sysctl：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Figuring out what these do is a little harder than interpreting the previous
    sysctl names. An experienced sysadmin could make really good guesses about these,
    but guessing isn’t system administration. Always research sysctls before changing
    them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些sysctl的作用比解释之前的sysctl名称要难一些。经验丰富的系统管理员可以对这些做出很好的猜测，但猜测并不是系统管理。在更改它们之前，总是要研究sysctl。
- en: When you know the name of a sysctl and you want to view its current value, give
    the sysctl name as an argument to `sysctl`. For example, to view the current securelevel
    (discussed in [Chapter 10](ch10.html "Chapter 10. Securing Your System")), check
    the `kern.securelevel` sysctl.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当您知道sysctl的名称并想查看其当前值时，请将sysctl名称作为`sysctl`的参数。例如，要查看当前的securelevel（在第10章[Securing
    Your System]中讨论），请检查`kern.securelevel` sysctl。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The current value of `kern.securelevel` is 1.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`kern.securelevel`的当前值是1。'
- en: You can view subsets of the sysctl tree by giving just the part of the tree
    you’re interested in. For example, to view only the sysctls related to ICMP, check
    the `sysctl net.inet.icmp` subcategory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过只提供您感兴趣的树的一部分来查看sysctl树的子集。例如，要查看仅与ICMP相关的sysctl，请检查`sysctl net.inet.icmp`子类别。
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: OpenBSD has six sysctls for IPv4 ICMP networking. You can view any portion of
    the sysctl tree this way, going as deep or as shallow as you like.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD有六个与IPv4 ICMP网络相关的sysctl。您可以通过这种方式查看sysctl树的任何部分，深入或浅出都可以。
- en: Changing Sysctl Values
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改Sysctl值
- en: Some sysctls are read-only. For example, the `hw.ncpufound` sysctl shows how
    many processors the system has.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些sysctl是只读的。例如，`hw.ncpufound` sysctl显示了系统有多少个处理器。
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This system has one processor. You cannot change the number of hardware processors
    through software (duh).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统有一个处理器。您不能通过软件更改硬件处理器的数量（duh）。
- en: On the other hand, a system decides whether or not to forward packets in software.
    OpenBSD performs packet forwarding entirely in the kernel, like embedded firewalls
    and routers. The sysctl `net.inet.ip.forwarding` controls this feature. If this
    is set to `0`, packets are not forwarded. If it’s set to 1, the system routes
    packets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，系统在软件中决定是否转发数据包。OpenBSD完全在内核中执行数据包转发，就像嵌入式防火墙和路由器一样。sysctl `net.inet.ip.forwarding`控制此功能。如果设置为`0`，则不转发数据包。如果设置为1，则系统路由数据包。
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To change this, use the equal sign to assign a new value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改此设置，请使用等号分配新值。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you need to stop forwarding packets, set this sysctl to `0`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要停止转发数据包，请将此sysctl设置为`0`。
- en: Changes take effect immediately. Remember that only root can change sysctl values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 变更立即生效。请记住，只有root可以更改sysctl值。
- en: Types of Sysctl Values
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sysctl值的类型
- en: Most sysctls have a numerical value, but the interpretation of that number depends
    on the sysctl. A few sysctls are words, and some generate tables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数sysctl具有数值，但该数值的解释取决于sysctl。一些sysctl是单词，一些会生成表格。
- en: Numerical Sysctls
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数值Sysctl
- en: Some sysctls are Boolean—either on or off. For example, IP forwarding is either
    on or off. You can’t have 50 percent packet forwarding on a properly functioning
    system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些sysctl是布尔值——要么开启要么关闭。例如，IP转发要么开启要么关闭。在正常工作的系统中，您不能有50%的数据包转发。
- en: Other numerical sysctls have a range of valid numbers. For example the `kern.securelevel`
    sysctl can range from `-1` to `2`, as discussed in [Chapter 10](ch10.html "Chapter 10. Securing
    Your System"). While you could assign a value outside this range, it wouldn’t
    have any effect beyond the closest valid value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数值sysctl有一个有效的数值范围。例如，`kern.securelevel` sysctl的范围可以从`-1`到`2`，如第10章[第10章。保护您的系统](ch10.html
    "第10章。保护您的系统")中讨论的那样。虽然您可以为范围之外分配值，但它不会对最接近的有效值之外产生任何影响。
- en: Some sysctls have numerical values that map directly to some kernel value. For
    example, the `kern.maxproc` sysctl gives the maximum number of processes that
    the system can run. You can adjust this value as needed to support your applications.
    While there’s no maximum value, increasing `kern.maxproc` increases the memory
    used by various in-kernel tables. By the same token, there’s no minimum size,
    but if you reduce this setting too far, the system won’t run correctly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些sysctl具有直接映射到某些内核值的数值。例如，`kern.maxproc` sysctl提供了系统可以运行的最大进程数。您可以根据需要调整此值以支持您的应用程序。虽然没有最大值，但增加`kern.maxproc`会增加各种内核表中使用的内存。同样，没有最小值，但如果您将此设置降低太多，系统将无法正常运行。
- en: Word Sysctls
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单词Sysctl
- en: A few sysctls are words, such as the `kern.ostype` sysctl examined earlier.
    Most of these sysctls cannot be changed with `sysctl`, but some can be changed
    with other programs. For example, the sysctl `kern.hostname` gives the system’s
    hostname. You cannot change `kern.hostname` with `sysctl`, but you can change
    it with `hostname(8)`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些sysctl是单词，例如前面检查过的`kern.ostype` sysctl。大多数这些sysctl不能使用`sysctl`更改，但一些可以使用其他程序更改。例如，sysctl
    `kern.hostname`提供了系统的主机名。您不能使用`sysctl`更改`kern.hostname`，但可以使用`hostname(8)`更改它。
- en: Table Sysctls
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表格Sysctl
- en: In addition to words and numbers, some sysctls generate output in the form of
    tables. These sysctls are not intended for direct human consumption, but are meant
    for processing by dedicated userland programs. For example, `netstat(1)` reads
    table sysctls to create its output.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单词和数字之外，一些sysctl会以表格的形式生成输出。这些sysctl不是供直接人类消费的，而是供专用用户空间程序处理的。例如，`netstat(1)`读取表格sysctl以创建其输出。
- en: To view all sysctls, including tables, pass the `-A` option to `sysctl`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有sysctl，包括表格，请将`-A`选项传递给`sysctl`。
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Many table sysctls still won’t print (they will generate warnings that you should
    use program such-and-such to view that data), but you’ll get a few tables amid
    the regular output.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 许多表格sysctl仍然不会打印（它们将生成警告，说明您应该使用某个程序来查看该数据），但您将在常规输出中看到一些表格。
- en: And by the way, tabular sysctls are read-only.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，表格sysctl是只读的。
- en: Setting Sysctls at Boot
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在引导时设置Sysctl
- en: Sysctl changes are not permanent; they revert when you reboot. To make sysctl
    changes permanent, set them in */etc/sysctl.conf*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Sysctl的更改不是永久的；重启后会恢复。要使sysctl更改永久生效，请在*/etc/sysctl.conf*中设置它们。
- en: Changes specified in *sysctl.conf* take place early in the booting process,
    before any server software starts. For example, if you need to customize the network
    stack, those changes should take place before the system opens any network connections.
    List the sysctls you need to change, an equal sign, and the desired value in *sysctl.conf*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*sysctl.conf*中指定的更改在引导过程中早期发生，在任何服务器软件启动之前。例如，如果你需要自定义网络堆栈，这些更改应该在系统打开任何网络连接之前发生。在*sysctl.conf*中列出你需要更改的sysctl，一个等号，以及所需值。
- en: The default *sysctl.conf* contains commonly changed sysctls (those that the
    OpenBSD team expects you might reasonably want to change). Each is commented out
    with a pound sign (`#`) and set to the most common nondefault setting. If you
    want to change the sysctl, uncomment the entry.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的*sysctl.conf*包含常见的更改sysctl（OpenBSD团队预计你可能合理想要更改的）。每个都使用井号（`#`）注释，并设置为最常用的非默认设置。如果你想更改sysctl，取消注释条目。
- en: The following are some commonly changed entries from *sysctl.conf*. (You might
    have different entries in your system, depending on your OpenBSD version.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从*sysctl.conf*中的一些常见更改条目。（根据你的OpenBSD版本，你的系统可能有不同的条目。）
- en: '**`net.inet.ip.forwarding`**'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`net.inet.ip.forwarding`**'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This controls forwarding of IPv4 packets between interfaces. When set to `1`,
    the system forwards packets received on any interface according to the internal
    routing table. When set to `0` (the default), packets are not forwarded.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这控制接口之间的IPv4数据包转发。当设置为`1`时，系统根据内部路由表转发接收到的任何接口上的数据包。当设置为`0`（默认值）时，不转发数据包。
- en: '**`net.inet.icmp.rediraccept`**'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`net.inet.icmp.rediraccept`**'
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This determines whether the host will accept ICMP redirects. Routers send ICMP
    redirects to direct hosts to use different local gateways for more specific routes.
    While the router can forward the packets for the clients, using redirects reduces
    network load. Accepting ICMP redirects means the host could be redirected to an
    invalid gateway, however, so they can be a security issue. Set this to `1` to
    accept ICMP redirects. The default of `0` ignores ICMP redirects.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这决定了主机是否会接受ICMP重定向。路由器发送ICMP重定向以指导主机使用不同的本地网关来访问更具体的路由。虽然路由器可以转发客户端的包，但使用重定向可以减少网络负载。然而，接受ICMP重定向意味着主机可能会被重定向到一个无效的网关，因此可能成为安全问题。将此设置为`1`以接受ICMP重定向。默认的`0`会忽略ICMP重定向。
- en: '**`net.inet6.ip6.forwarding`**'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`net.inet6.ip6.forwarding`**'
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This controls the forwarding of IPv6 packets, much like `net.inet.ip.forwarding`
    does for IPv4 packets. You can control IPv4 and IPv6 forwarding separately. Set
    this to `1` to forward IPv6 packets.
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这控制IPv6数据包的转发，就像`net.inet.ip.forwarding`对IPv4数据包做的那样。你可以分别控制IPv4和IPv6的转发。将此设置为`1`以转发IPv6数据包。
- en: '**`net.inet6.icmp6.rediraccept`**'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`net.inet6.icmp6.rediraccept`**'
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By default, OpenBSD ICMPv6 ignores redirects, just as it ignores IPv4 ICMP redirects.
    Set this to `1` to accept ICMPv6 redirects.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，OpenBSD ICMPv6忽略重定向，就像它忽略IPv4 ICMP重定向一样。将此设置为`1`以接受ICMPv6重定向。
- en: '**`net.inet6.ip6.accept_rtadv`**'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`net.inet6.ip6.accept_rtadv`**'
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: IPv6 autoconfiguration listens for router advertisements, much as IPv4 autoconfiguration
    listens for configurations from DHCP servers. To autoconfigure IPv6, a host must
    accept router advertisements. Set this to `0` to disable accepting router advertisements.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPv6自动配置监听路由器通告，就像IPv4自动配置监听DHCP服务器的配置一样。为了自动配置IPv6，主机必须接受路由器通告。将此设置为`0`以禁用接受路由器通告。
- en: '**`net.inet.tcp.always_keepalive`**'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`net.inet.tcp.always_keepalive`**'
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The TCP keep-alive feature sends packets over otherwise idle connections so
    that intermediate devices will recognize that a connection is still in use. Proper
    firewalls recognize live but idle TCP connections even without keep-alives. If
    you have a broken firewall or NAT device, TCP keep-alives can help hold a connection
    alive. Set this to `1` to enable keep-alives.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TCP保持活动功能会在其他情况下空闲的连接上发送数据包，以便中间设备能够识别出连接仍在使用中。适当的防火墙即使在没有保持活动的情况下也能识别出活跃但空闲的TCP连接。如果你有一个损坏的防火墙或NAT设备，TCP保持活动可以帮助保持连接活跃。将此设置为`1`以启用保持活动。
- en: '**`net.inet.tcp.ecn`**'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`net.inet.tcp.ecn`**'
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By default, OpenBSD’s TCP stack does not use Explicit Congestion Notification
    (ECN). Set this to `1` to enable ECN.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，OpenBSD的TCP堆栈不使用显式拥塞通知（ECN）。将此设置为`1`以启用ECN。
- en: '**`ddb.panic`**'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`ddb.panic`**'
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OpenBSD uses the `ddb(4)` kernel debugger. If you want the system to drop into
    the debugger in the unlikely event of a kernel panic, leave this at `1`. If you
    want the system to reboot as soon as possible, set this to `0`.
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OpenBSD使用`ddb(4)`内核调试器。如果您希望在内核恐慌的极不可能事件中让系统进入调试器，请保持此值为`1`。如果您希望系统尽快重新启动，请将其设置为`0`。
- en: '**`ddb.console`**'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`ddb.console`**'
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When set to `1`, this enables entering the `ddb(4)` debugger from the console
    when someone presses CTRL-ALT-ESC. This option is primarily of interest to developers.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当设置为`1`时，此选项启用在某人按CTRL-ALT-ESC时从控制台进入`ddb(4)`调试器。此选项主要对开发者感兴趣。
- en: '**`vm.swapencrypt.enable`**'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`vm.swapencrypt.enable`**'
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By default, OpenBSD encrypts all data written to swap. To disable encrypting
    swap, set this to `0`. There’s really no reason to disable swap encryption, because
    encrypting swap space induces minimal system load.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，OpenBSD会对写入交换区的所有数据进行加密。要禁用交换区加密，请将此设置为`0`。实际上没有理由禁用交换区加密，因为加密交换空间只会引起最小的系统负载。
- en: '**`machdep.allowaperture`**'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`machdep.allowaperture`**'
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This controls userland program access to the memory that userland really shouldn’t
    be able to access. The X Windows System needs access to this memory to display
    a graphical console. ([Chapter 17](ch17.html "Chapter 17. Desktop OpenBSD") covers
    this sysctl and X.)
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这控制用户空间程序对用户空间实际上不应能访问的内存的访问。X窗口系统需要访问此内存来显示图形控制台。（[第17章](ch17.html "第17章。桌面OpenBSD"）涵盖了此sysctl和X。）
- en: '**`machdep.kbdreset`**'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`machdep.kbdreset`**'
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On amd64 and i386 systems, setting this to `1` allows you to press CTRL-ALT-DEL
    on the console to do a clean shutdown and reboot. When set to `0` (the default),
    pressing CTRL-ALT-DEL has no effect.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在amd64和i386系统上，将此设置为`1`允许您在控制台上按CTRL-ALT-DEL进行干净的重启和重新启动。当设置为`0`（默认值）时，按CTRL-ALT-DEL没有任何效果。
- en: As a rule, if you don’t understand the thing that a sysctl affects, don’t change
    it. You won’t learn about RFC 3390 by playing with a sysctl related to it; you’ll
    learn about RFC 3390 by actually *reading* RFC 3390 and spending quality time
    with a packet sniffer watching traffic with RFC 3390 disabled and enabled.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果您不了解sysctl影响的那个东西，就不要更改它。您不会通过玩与RFC 3390相关的sysctl来了解RFC 3390；您将通过实际*阅读*RFC
    3390，并花时间与数据包嗅探器一起观察禁用和启用RFC 3390时的流量来了解RFC 3390。
- en: And if you want to change a sysctl that’s not listed here, think twice. If the
    OpenBSD guys wanted you to change it, they would list it in *sysctl.conf*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更改此处未列出的sysctl，请三思。如果OpenBSD的开发者希望您更改它，他们会在*sysctl.conf*中列出它。
- en: Altering the Kernel with config(8)
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用config(8)修改内核
- en: While `sysctl` lets you tweak the kernel, it won’t let you change values that
    are hard-coded into the kernel binary. Some of these values are used to initialize
    kernel data structures, and they can’t be changed once the kernel is running.
    Others relate to device drivers. Once the kernel has finished probing devices,
    it won’t go back and reprobe just because you change where a device driver checks
    for its hardware. To change hard-coded values like these, you must edit the existing
    kernel file and reboot, allowing the system to set things as you like from initialization.
    That’s where `config(8)` comes in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`sysctl`允许您调整内核，但它不会让您更改内核二进制文件中硬编码的值。其中一些值用于初始化内核数据结构，一旦内核运行，它们就不能更改。其他一些与设备驱动程序相关。一旦内核完成设备探测，它不会因为您更改了设备驱动程序检查其硬件的位置而回过头来重新探测。要更改这些硬编码的值，您必须编辑现有的内核文件并重新启动，让系统从初始化开始按照您的喜好设置一切。这就是`config(8)`的作用所在。
- en: The `config` command has two completely separate functions. The first creates
    a kernel compilation directory from a text configuration file, as discussed in
    [Chapter 19](ch19.html "Chapter 19. Building Custom Kernels"). The function we’re
    most interested in now is editing an existing kernel binary, which lets you tweak
    a kernel to better suit your needs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`命令有两个完全不同的功能。第一个是从文本配置文件创建内核编译目录，如第19章所述。我们现在最感兴趣的功能是编辑现有的内核二进制文件，这允许您调整内核以更好地满足您的需求。'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The modern OpenBSD kernel is largely dynamic. If you call for additional virtual
    interfaces, the kernel creates them. If you need to change the amount of memory
    for the buffer cache, use a sysctl. Editing the kernel is rarely necessary.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的OpenBSD内核在很大程度上是动态的。如果您请求额外的虚拟接口，内核会创建它们。如果您需要更改缓冲区缓存内存的数量，请使用sysctl。编辑内核很少是必要的。
- en: Making a Backup of the Default Kernel
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备份默认内核
- en: Before making any changes to a working kernel, no matter how minor, back up
    the original kernel! If your minor changes make your machine unbootable, you want
    to be able to easily fall back to a working kernel.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在对正在工作的内核进行任何更改之前，无论多么微小，都要备份原始内核！如果你的微小更改使你的机器无法启动，你希望能够轻松地回退到可工作的内核。
- en: The kernel is just a file, */bsd*. To back it up, copy it to another file. I
    recommend naming your backup of the default kernel */bsd.GENERIC*, for reasons
    that will become apparent in [Chapter 19](ch19.html "Chapter 19. Building Custom
    Kernels").
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 内核只是一个文件，*/bsd*。要备份它，将其复制到另一个文件。我建议将默认内核的备份命名为*/bsd.GENERIC*，原因将在[第19章](ch19.html
    "第19章。构建自定义内核")中变得明显。
- en: Always keep a known-good kernel on your system. A bad kernel can prevent a computer
    from booting, and if you don’t have a reliable kernel that’s easily bootable,
    you will need to boot from installation media. (Boot your backup kernel using
    the instructions in [Chapter 5](ch05.html "Chapter 5. The Boot Process").) And
    remember that subtle kernel bugs can take weeks or months to show up, so plan
    to keep your backup kernel forever.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总是保持一个已知良好的内核在你的系统上。一个坏的内核可能会阻止计算机启动，如果你没有可靠且易于启动的内核，你将需要从安装介质启动。（使用[第5章](ch05.html
    "第5章。启动过程")中的说明启动备份内核。）记住，微小的内核错误可能需要几周或几个月才能显现，所以计划永远保留你的备份内核。
- en: Device Drivers and the Kernel
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备驱动程序和内核
- en: Much of the hard-coded information in the kernel relates to device drivers,
    especially drivers for ancient ISA cards.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中大部分硬编码的信息都与设备驱动程序有关，特别是古老ISA卡的驱动程序。
- en: Some of you may remember manually configuring the interrupt request (IRQ) and
    memory port addresses on a network or SCSI card. The kernel uses the IRQ to identify
    cards. Essentially, it consults an internal list of IRQs and port numbers, compares
    it to what it finds on the hardware probe, and assigns the drivers appropriately.
    “This card answers at IRQ 10 and memory port 0x300? It must be a NE2000-compatible
    network card. I will assign that driver to it.” The process is more complicated
    than this, of course, but this probe is a vital part of the process. If you want
    OpenBSD to recognize such a card, and the card is set to an IRQ and memory port
    other than what OpenBSD expects, you must tell the kernel the IRQ and memory port
    the card is using.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能还记得手动配置网络或SCSI卡上的中断请求（IRQ）和内存端口地址。内核使用IRQ来识别卡。本质上，它咨询一个内部的中断请求和端口号码列表，将其与硬件探测中找到的内容进行比较，并相应地分配驱动程序。“这张卡在IRQ
    10和内存端口0x300处响应？它必须是一张NE2000兼容的网络卡。我将分配那个驱动程序给它。”当然，这个过程比这更复杂，但这个探测是过程的一个关键部分。如果你想让OpenBSD识别这样的卡，并且卡设置了一个与OpenBSD期望不同的IRQ和内存端口，你必须告诉内核卡使用的IRQ和内存端口。
- en: Realistically, the best way to deal with ISA cards is to feed them to the recycling
    plant. Running OpenBSD on a 25-year-old VAX is interesting and educational. Running
    OpenBSD on 15-year-old Sparc hardware is realistic for very specific applications,
    and can also be educational and interesting. Running OpenBSD on 10-year-old consumer-grade
    i386 hardware is either a waste of time or an exercise in masochism—probably both.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，处理ISA卡的最佳方式是将它们送到回收站。在25年的VAX上运行OpenBSD很有趣，也很有教育意义。在15年的Sparc硬件上运行OpenBSD对于非常特定的应用来说是现实的，也可以很有教育意义和趣味性。在10年的消费级i386硬件上运行OpenBSD要么是浪费时间，要么是自我折磨——可能两者都是。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modern PCI-descended hardware includes hooks for the kernel to identify the
    hardware and assign the proper device driver. You shouldn’t need to edit the kernel
    to support hardware.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现代基于PCI的硬件包括内核识别硬件并分配正确设备驱动程序的钩子。你不应该需要编辑内核来支持硬件。
- en: Enabling Drivers
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用驱动程序
- en: Rather than changing driver IRQs, more realistically, you might need to enable
    a device driver that’s disabled by default or disable a device that’s on by default.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是更改驱动程序中断请求（IRQs），更现实的做法可能是需要启用默认禁用的设备驱动程序，或者禁用默认启用的设备。
- en: The kernel includes some device drivers that are disabled because they react
    badly with certain hardware, such as the IPMI driver. The `ipmi(4)` driver is
    known to be buggy, and as I write this, it is badly broken in some use cases.
    It’s included in the default kernel, but disabled by default.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 内核包括一些由于与某些硬件反应不良而禁用的设备驱动程序，例如IPMI驱动程序。`ipmi(4)`驱动程序已知存在错误，在我写这篇文章的时候，在某些用例中它已经严重损坏。它包含在默认内核中，但默认情况下是禁用的。
- en: You can choose to enable `ipmi(4)`. If it works for you, great. If it doesn’t,
    feel free to submit bug reports, preferably with patches, or at least proper `dmesg`
    output and crash dumps.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择启用 `ipmi(4)`。如果它对你有用，那很好。如果没有，请随意提交错误报告，最好是带有补丁，或者至少是正确的 `dmesg` 输出和崩溃转储。
- en: Editing the Kernel with config
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用配置编辑内核
- en: When using `config` as a kernel editor, use the command-line options `-e` and
    `-o`. The `-e` flag tells `config` you’re editing a kernel binary. The `-o` flag
    lets you specify a new file for the edited version of the kernel.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `config` 作为内核编辑器时，使用命令行选项 `-e` 和 `-o`。`-e` 标志告诉 `config` 你正在编辑一个内核二进制文件。`-o`
    标志允许你指定内核编辑版本的新的文件。
- en: 'Give the original kernel file path as an argument. For example, here’s how
    to edit */bsd* and write the result to the file */bsd.test*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始内核文件路径作为参数。例如，以下是编辑 */bsd* 并将结果写入文件 */bsd.test* 的方法：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You could use the `-f` flag instead of `-o` and a filename. The `-f` flag tells
    `config` to edit the kernel file in place, not to create a new file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-f` 标志代替 `-o` 和一个文件名。`-f` 标志告诉 `config` 在原地编辑内核文件，而不是创建一个新文件。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re editing */bsd* and you specified the `-f` option, your changes are
    written directly to */bsd*. I recommend *not* doing this. (Unless, of course,
    you’re absolutely certain you know what you’re doing. You get to keep all the
    parts.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编辑 */bsd* 并指定了 `-f` 选项，你的更改将直接写入 */bsd*。我建议**不要**这样做。（除非，当然，你绝对确定你在做什么。你可以保留所有部分。）
- en: 'Running `config` will open the kernel editor, which should look much like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `config` 将打开内核编辑器，它看起来应该像这样：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, you need to use kernel editor commands to make changes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你需要使用内核编辑器命令来做出更改。
- en: Using the help and list Commands
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用帮助和列表命令
- en: Start with the two editor commands `help` and `list`. The `help` command shows
    all the commands available within `config` and comes in particularly handy at
    stupid-o’clock AM to remind you of the necessary syntax.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个编辑器命令 `help` 和 `list` 开始。`help` 命令显示 `config` 中所有可用的命令，并在凌晨愚蠢时刻特别有用，提醒你必要的语法。
- en: The `list` command displays a complete list of all the devices the kernel supports,
    one screen at a time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 命令每次显示内核支持的所有设备的完整列表。'
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On an OpenBSD 5.2 system, the default kernel has 538 entries, most for hardware
    that isn’t on any particular system but that OpenBSD supports out of the box.
    Let’s take a closer look at the devices shown.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 5.2 系统上，默认内核有 538 个条目，大多数是为不在任何特定系统上的硬件，但 OpenBSD 默认支持的。让我们更仔细地看看显示的设备。
- en: Line 0 says that this kernel supports the `video` device. The kernel will look
    for a video device attached to the `uvideo` device. The `uvideo(4)` man page tells
    us that `uvideo` is USB video, mainly for webcams and the like, and `video(4)`
    says that the `video` driver is a device-independent video driver. The `flags`
    statement gives settings to feed to this device driver. (This kernel supports
    webcams.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第 0 行说明这个内核支持 `video` 设备。内核将寻找连接到 `uvideo` 设备的视频设备。`uvideo(4)` 手册页告诉我们 `uvideo`
    是 USB 视频，主要用于摄像头等设备，而 `video(4)` 说明 `video` 驱动程序是一个设备无关的视频驱动程序。`flags` 语句提供了要传递给此设备驱动程序的设置。（此内核支持摄像头。）
- en: Line 1 says that this kernel supports an `audio` device, and it can be attached
    to any of a long list of device drivers. The online manual says that `uaudio`,
    `sb0`, `gus0`, and so on are sound cards. We get sound with our video? Truly we
    live in an age of wonders.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 行说明这个内核支持 `audio` 设备，并且它可以连接到一系列设备驱动程序中的任何一个。在线手册说明 `uaudio`、`sb0`、`gus0`
    等是声卡。我们用视频获得声音？确实，我们生活在一个充满奇迹的时代。
- en: Entries for older ISA gear are more complex.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧 ISA 设备的条目更复杂。
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This entry for supporting the old-fashioned NE2000 ISA network card includes
    an IRQ, DRQ, memory port, and a few other settings that I’ve (thankfully) forgotten
    about. The kernel will check ISA bus number 0 at the stated port and IRQ, in the
    hope of finding such a device.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目支持老式的 NE2000 ISA 网络卡，包括一个中断请求（IRQ）、直接内存访问请求（DRQ）、内存端口以及一些我（幸运地）已经忘记的其他设置。内核将在指定的端口和中断请求处检查
    ISA 总线编号 0，希望找到这样的设备。
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a *pseudo-device*—a software creation that acts much like an actual
    device but has no underlying hardware. The `pflog(4)` pseudo-device is where the
    packet filter dumps its logs. This kernel creates one instance of the `pflog`
    device at boot, but thanks to OpenBSD’s cloneable interfaces, the kernel can create
    more `pflog` interfaces as needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**伪设备**——一个软件创建，其行为与实际设备非常相似，但没有底层硬件。`pflog(4)`伪设备是数据包过滤器记录日志的地方。这个内核在启动时创建了一个`pflog`设备的实例，但多亏了OpenBSD的可克隆接口，内核可以根据需要创建更多的`pflog`接口。
- en: Finally, notice that several lines declare themselves “free.” You can copy an
    existing device and add it to the kernel. For example, if you wanted a kernel
    that supported 10 NE2000 cards, and needed 10 instances of the device driver in
    the kernel, you could copy and add the devices here. The kernel will autoconfigure
    any number of device driver instances for modern hardware; it will find 10 PCI
    Express network cards and give them their own instances of the device without
    any prodding from you.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，有几行声明自己是“空闲的”。你可以复制一个现有的设备并将其添加到内核中。例如，如果你需要一个支持10个NE2000卡片的内核，并且需要在内核中添加10个设备驱动程序的实例，你可以在这些位置复制并添加设备。内核将为现代硬件自动配置任意数量的设备驱动程序实例；它将找到10个PCI
    Express网络卡并为它们各自分配设备实例，而无需你任何干预。
- en: Finding and Enabling Devices
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找和启用设备
- en: One of the disadvantages to the `list` command is that it shows everything in
    the kernel. You can’t interrupt it; you must scroll through to the end. It’s also
    difficult to search through several hundred devices by eye. If you know the device
    you want, use `find` to search for it. Here, we’ll use `ipmi` as an example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`命令的一个缺点是它会显示内核中的所有内容。你不能中断它；你必须滚动到末尾。通过肉眼搜索几百个设备也很困难。如果你知道你想要的设备，使用`find`来搜索它。这里，我们将使用`ipmi`作为例子。'
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The IPMI device is device number 493, and it is attached to the device `mainbus0`.
    But note the word `disable` in the device entry. The `ipmi` device is disabled.
    Let’s turn it on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: IPMI设备是设备编号493，它连接到设备`mainbus0`。但请注意设备条目中的单词`disable`。`ipmi`设备已被禁用。让我们将其打开。
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The kernel now has an active IPMI driver. Yippee!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 内核现在有一个活动的IPMI驱动程序。太好了！
- en: Changing Kernel Constants
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改内核常量
- en: In addition to the device drivers, the kernel has a few hard-coded values for
    internal data structures. If you run `help` in the kernel editor, you’ll see these
    values as options.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设备驱动程序之外，内核还有一些硬编码的内部数据结构值。如果你在内核编辑器中运行`help`，你会看到这些值作为选项。
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see there are only two values: `BUFCACHEPERCENT` and `NKMEMPAGES`.
    Unless you have a compelling reason to touch these values, leave them alone.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里只有两个值：`BUFCACHEPERCENT`和`NKMEMPAGES`。除非你有充分的理由去修改这些值，否则请保持它们不变。
- en: '`NKMEMPAGES` is the number of pages of memory dedicated to the kernel.If your
    machine starts panicking with error messages of `out of space in kmem_map`, you
    can increase this value. If the system boots successfully, however, you’re better
    off setting the `vm.nkmempages` sysctl rather than editing the kernel.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`NKMEMPAGES`是分配给内核的内存页数。如果你的机器开始因为`kmem_map`中的空间不足而恐慌并显示错误信息，你可以增加这个值。然而，如果系统成功启动，你最好设置`vm.nkmempages`
    sysctl而不是编辑内核。'
- en: '`BUFCACHEPERCENT` is the percentage of physical memory dedicated to the buffer
    cache. In some fairly rare circumstances, increasing the size of the buffer cache
    can improve filesystem performance. You could set the sysctl `kern.bufcachepercent`
    instead of editing this kernel value, however.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`BUFCACHEPERCENT`是分配给缓冲区缓存的物理内存的百分比。在某些相当罕见的情况下，增加缓冲区缓存的大小可以提高文件系统性能。然而，你可以设置sysctl
    `kern.bufcachepercent`而不是编辑这个内核值。'
- en: To view a current value, enter its name.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前值，输入其名称。
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To change the value, enter its name and the desired value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改值，输入其名称和所需值。
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, don’t muck with these numbers arbitrarily. The OpenBSD developers set
    them to the default values for very good reasons.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，不要随意更改这些数字。OpenBSD开发者出于非常好的原因将它们设置为默认值。
- en: Completing Configuration
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成配置
- en: Once you’ve made all of your changes, enter **`quit`** to save your changes
    and write them to a kernel file. The `exit` command discards all changes and leaves
    the editor, making it easy to start over. Do not mix `quit` and `exit` unless
    you like being annoyed and confused.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了所有的更改，输入**`quit`**来保存你的更改并将它们写入内核文件。`exit`命令会丢弃所有更改并离开编辑器，这使得重新开始变得容易。除非你喜欢被打扰和困惑，否则不要混合使用`quit`和`exit`。
- en: Installing Your Edited Kernel
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装你的编辑后的内核
- en: Your edited kernel is just a file. Verify that you have a backup of your working
    kernel, copy your new kernel to */bsd*, and reboot.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您编辑的内核只是一个文件。请确认您已经备份了您的工作内核，然后将新内核复制到 */bsd* 目录下，并重新启动。
- en: Boot-Time Kernel Configuration
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动时内核配置
- en: The `config` kernel editor is great when you know what you’re doing, but many
    of us aren’t that lucky or educated. When I’m trying to figure out how to fix
    a problem, I’ll frequently make a change, reboot to test the change, and see if
    things work.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您知道自己在做什么时，`config` 内核编辑器很棒，但许多人并不那么幸运或受过教育。当我试图找出如何修复问题时，我经常会进行更改，重新启动以测试更改，并查看是否正常工作。
- en: OpenBSD lets you edit the kernel at boot time. You can try one boot with a kernel
    change, see if it works, and write your changes to the kernel. At the boot loader
    prompt, run **`boot -c`**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 允许您在启动时编辑内核。您可以尝试使用更改后的内核启动一次，看看是否正常工作，并将您的更改写入内核。在引导加载程序提示符下，运行 **`boot
    -c`**。
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You’ll get a couple lines of boot output, and then the kernel editor prompt.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到几行引导输出，然后是内核编辑器的提示符。
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This works just like the `config` kernel configuration editor. Make any changes
    you want here, exactly as you would with `config`. When you `quit` the editor,
    the kernel should boot with the changes you’ve chosen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `config` 内核配置编辑器的工作方式相同。在这里进行任何您想要的更改，就像使用 `config` 一样。当您退出编辑器时，内核应该会使用您选择的更改启动。
- en: The nice thing about boot-time edits is that they’re not permanent unless you
    later declare them so. If your changes don’t result in the desired behavior, reboot
    and try again. If your changes do solve your issue, however, you can write them
    to a kernel file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时编辑的优点是，除非您后来声明它们是永久的，否则它们不是永久的。如果您的更改没有产生预期的行为，请重新启动并再次尝试。然而，如果您的更改解决了问题，您可以将它们写入内核文件。
- en: The kernel remembers the changes you made in it. You can “replay” those changes
    in `config` by using the `-u` flag. Run `config` as if you were editing the kernel,
    but add the `-u` flag to replicate your boot-time changes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 内核会记住您对其所做的更改。您可以通过使用 `-u` 标志在 `config` 中“重放”这些更改。运行 `config` 时，就像编辑内核一样，但需要添加
    `-u` 标志以复制您的启动时更改。
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you get your command prompt, enter **`quit`** to save your changes to your
    new kernel file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当您获得命令提示符时，输入 **`quit`** 以保存您的更改到新的内核文件。
- en: Between `sysctl` and `config`, you should be able to make any OpenBSD-supported
    changes to the kernel. In the next chapter, we’ll cover how to make wildly unsupported
    kernel changes by rebuilding the kernel from source.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sysctl` 和 `config` 之间，您应该能够对内核进行任何 OpenBSD 支持的更改。在下一章中，我们将介绍如何通过从源代码重新构建内核来做出广泛不受支持的内核更改。
