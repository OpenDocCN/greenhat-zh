- en: Chapter 8. Thinking Like a Programmer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 像程序员一样思考
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
- en: It’s time for us to bring together everything we’ve experienced over the previous
    chapters to complete the journey from fledgling coder to problem-solving programmer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将前几章中我们所经历的一切整合起来，完成从新手程序员到问题解决程序员的转变之旅。
- en: 'In previous chapters, we’ve solved problems in a variety of areas. I believe
    these areas are the most beneficial for the developing programmer to master, but
    of course there are always more things to learn, and many problems will require
    skills not covered in this book. So in this chapter, we’re going to come full
    circle to general problem-solving concepts, taking the knowledge we’ve gained
    in our journey to develop a *master plan* for attacking any programming problem.
    Although we might call this a general plan, in one way it’s actually a very specific
    plan: It will be *your* plan, and no one else’s. We’ll also look at the many ways
    you can add to your knowledge and skills as a programmer.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们在各个领域解决了问题。我相信这些领域对正在发展的程序员来说最有益，但当然还有更多东西要学习，而且许多问题将需要本书未涵盖的技能。因此，在本章中，我们将回到一般问题解决概念，结合我们在旅程中获得的知识，制定一个攻击任何编程问题的**宏伟蓝图**。虽然我们可能称之为一个一般计划，但在某种程度上，它实际上是一个非常具体的计划：它将是**您的**计划，而不是别人的。我们还将探讨您作为程序员可以增加知识和技能的许多方式。
- en: Creating Your Own Master Plan
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定您的个人宏伟蓝图
- en: Way back in the first chapter, we learned the first rule of problem solving
    was that you should always have a plan. A more precise formulation would be to
    say you should always follow *your* plan. You should construct a master plan that
    maximizes your strengths and minimizes your weaknesses and then apply this master
    plan to each problem you must solve.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 充分发挥您的优势和劣势
- en: Over many years of teaching, I’ve seen students of all different abilities.
    By that I don’t simply mean that some programmers have more ability than others,
    although of course this is true. Even among programmers with the same level of
    ability, there is great diversity. I’ve lost track of how often I’ve been surprised
    by a formerly struggling student who quickly masters a particular skill or a talented
    student who displays a weakness in a new area. Just as no two fingerprints are
    the same, no two brains are the same, and lessons that are easy for one person
    are difficult for another.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在多年的教学过程中，我见过各种能力水平的学生。我说的不仅仅是有些程序员的能力比其他人强，虽然这当然是真的。即使在能力水平相同的情况下，程序员之间也存在很大的差异。我记不清有多少次被一个曾经努力的学生迅速掌握一项特定技能或一个有才华的学生在新领域表现出弱点而感到惊讶。正如没有两个人的指纹是完全相同的，也没有两个人的大脑是完全相同的，对某个人来说容易的课程对另一个人来说可能就很难。
- en: Suppose you’re a football coach, planning your offense for the next game. Because
    of an injury, you’re not sure which of two quarterbacks will be able to start.
    Both quarterbacks are highly capable professionals, but like any individuals in
    any endeavor, they have their strengths and weaknesses. The game plan that creates
    the best opportunity for victory with one quarterback might be terrible for the
    other.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是一名足球教练，正在为下一场比赛制定进攻策略。由于受伤，您不确定哪位四分卫能够首发。这两位四分卫都是能力出众的专业球员，但就像任何领域的个人一样，他们都有自己的优势和劣势。为一位四分卫制定的比赛策略可能对另一位来说却是个糟糕的选择。
- en: In creating your master plan, you are the coach and your skill set is your quarterback.
    To maximize your chances for success, you need a plan that recognizes both your
    strengths and your weaknesses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在制定您的宏伟蓝图时，您是教练，您的技能组合就是您的四分卫。为了最大限度地提高成功的机会，您需要一个既能认识到您的优势也能认识到您的劣势的计划。
- en: Playing to Your Strengths and Weaknesses
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在第一章中，我们了解到解决问题的第一规则是您应该始终有一个计划。一个更精确的表述可能是说您应该始终遵循**您的**计划。您应该构建一个能够最大限度地发挥您的优势并最小化您的劣势的宏伟蓝图，然后将这个宏伟蓝图应用于您必须解决的每个问题。
- en: The key step in making your own master plan, then, is identifying your strengths
    and weaknesses. This is not difficult, but it requires effort and a fair degree
    of honest self-appraisal. In order to benefit from your mistakes, you must not
    only correct them in programs in which they appear, but you must also note them,
    at least mentally, or better yet, in a document. In this way, you can identify
    patterns of behavior that you would have otherwise missed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，制定自己的主计划的关键步骤是识别你的优势和弱点。这并不困难，但需要努力和相当程度的诚实自我评估。为了从你的错误中受益，你不仅必须在出现错误的程序中纠正它们，而且你必须在心理上或最好是在文档中记录它们。这样，你可以识别出你否则可能会错过的行为模式。
- en: 'I’m going to describe weaknesses in two different categories: coding and design.
    *Coding weaknesses* are areas where you tend to repeat mistakes when you’re actually
    writing the code. For example, many programmers frequently write loops that iterate
    one time too many or one time too few. This is known as a *fencepost error*, from
    an old puzzle about how many fenceposts are needed to build a 50-foot fence with
    10-foot-long rails between posts. The immediate response from most people is five,
    but if you think about it carefully, the answer is six, as shown in [Figure 8-1](ch08.html#the_fencepost_puzzle
    "Figure 8-1. The fencepost puzzle").'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我将描述两种不同类别的弱点：编码和设计。*编码弱点*是在你实际编写代码时容易重复犯错的领域。例如，许多程序员经常编写迭代次数过多或过少的循环。这被称为*栅栏桩错误*，源自一个古老的难题，即需要多少根栅栏桩才能用10英尺长的横梁建造一个50英尺的栅栏。大多数人的直接反应是五根，但如果你仔细思考，答案是六根，如图[图8-1](ch08.html#the_fencepost_puzzle
    "图8-1. 栅栏桩难题")所示。
- en: Most coding weaknesses are situations in which the programmer creates semantic
    errors by coding too quickly or without enough preparation. *Design weaknesses*,
    in contrast, are problems you commonly have in the problem-solving or design stage.
    For example, you might discover you have trouble getting started or trouble integrating
    previously written subprograms into a complete solution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编码弱点是程序员在编码过快或准备不足时创建的语义错误的情况。相比之下，*设计弱点*是在问题解决或设计阶段常见的问题。例如，你可能会发现你很难开始或者很难将之前编写的子程序集成到完整的解决方案中。
- en: '![The fencepost puzzle](httpatomoreillycomsourcenostarchimages1273271.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![栅栏桩难题](httpatomoreillycomsourcenostarchimages1273271.png)'
- en: Figure 8-1. The fencepost puzzle
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1. 栅栏桩难题
- en: Although there is some overlap between these two categories, the two types of
    weaknesses tend to create different sorts of problems and must be defended against
    in different ways.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个类别之间有一些重叠，但两种类型的弱点往往会引起不同类型的问题，并且必须以不同的方式来防御。
- en: Planning Against Coding Weaknesses
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对编码弱点的规划
- en: Perhaps the most frustrating activity in programming is spending hours tracking
    down a semantic error that turns out to be a simple thing to fix once identified.
    Because no one is perfect, there’s no way to completely eliminate these situations,
    but a good programmer will do all he or she can to avoid making the same mistakes
    over and over again.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，最令人沮丧的活动之一可能是花费数小时追踪一个语义错误，一旦确定，其实很容易修复。因为没有人是完美的，所以无法完全消除这些情况，但一个好的程序员会尽其所能避免一次又一次地犯同样的错误。
- en: 'I knew a programmer who had tired of making what is perhaps the most common
    semantic error in C++ programming: the substitution of the assignment operator
    (`=`) for the equality operator (`==`). Because conditional expressions in C++
    are integer, not strictly Boolean, a statement such as the following is syntactically
    legal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我认识一个程序员，他已经厌倦了犯可能是C++编程中最常见的语义错误：将赋值运算符（`=`）替换为相等运算符（`==`）。因为C++中的条件表达式是整数，而不是严格的布尔值，所以以下这样的语句在语法上是合法的：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this case, the integer value 1 is assigned to `number`, and then the value
    1 is used as the result of the conditional statement, which C++ evaluates as `true`.
    What the programmer meant to do, of course, was:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，整数值1被分配给`number`，然后值1被用作条件语句的结果，C++将其评估为`true`。当然，程序员本意是想做的是：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Frustrated at making this type of mistake over and over, the programmer taught
    himself to always write equality tests the other way, with the numerical literal
    on the left side, such as:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反复犯这种错误感到沮丧，程序员自学了总是以另一种方式编写相等测试，即左侧使用数值字面量，例如：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By doing this, if the programmer slips up and substitutes the equality operator,
    the expression `1 = number` would no longer be legal C++ syntax, and would produce
    a syntax error that would be caught at compile time. The original error is legal
    syntax, so it’s only a semantic error, which would be caught at compile time or
    not caught at all. Since I had made this mistake many times myself (and driven
    myself crazy trying to track the bug down), I employed this method, putting the
    numerical literal on the left side of the equality operator. In doing so, I discovered
    something curious. Because this ran counter to my usual style, putting the literal
    on the left forced me to pause momentarily when writing conditional statements.
    I would think, “I need to remember to put the literal on the left so that I’ll
    catch myself if I use the assignment operator.” As you might expect, by having
    that thought run through my head, I never actually used the assignment operator
    but always correctly used the equality operator. Now, I no longer put the literal
    on the left side of the equality operator, but I still pause and let those thoughts
    run through my head, which keeps me from using the wrong operator.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，如果程序员不小心使用了相等运算符，表达式`1 = number`就不再是合法的C++语法，并且会在编译时产生语法错误。原始错误是合法的语法，所以它只是一个语义错误，可能会在编译时被捕获，也可能根本不会被捕获。由于我自己也犯过这样的错误（并且试图追踪这个错误让自己疯狂），我采用了这种方法，将数值字面量放在相等运算符的左边。在这个过程中，我发现了一些有趣的事情。因为这与我的常规风格相反，将字面量放在左边迫使我写条件语句时暂时停下来。我会想，“我需要记住把字面量放在左边，这样我就能在用到赋值运算符时提醒自己。”正如你所预期的，通过让这个想法在我的脑海中运行，我实际上从未使用过赋值运算符，而总是正确地使用了相等运算符。现在，我不再把字面量放在相等运算符的左边，但我仍然会停下来，让这些想法在我的脑海中运行，这使我避免了使用错误的运算符。
- en: 'The lesson here is that being aware of your coding-level weaknesses is often
    all that is necessary to avoid them. That’s the good news. The bad news is that
    you still have to put in the work to be aware of your coding weaknesses in the
    first place. The key technique is asking yourself why you made a particular mistake,
    rather than just fixing the mistake and moving on. This will allow you to identify
    the general principle you failed to follow. For example, suppose you had written
    the following function to compute the average of the positive numbers in an array
    of integers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，意识到自己的编码弱点通常就足以避免它们。这是好消息。坏消息是，你仍然需要付出努力来首先意识到自己的编码弱点。关键技巧是问自己为什么犯了一个特定的错误，而不仅仅是修复错误然后继续前进。这将帮助你识别你未能遵循的一般原则。例如，假设你编写了以下函数来计算整数数组中正数的平均值：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At a glance, this function looks fine, but upon closer inspection, it has a
    problem. If there are no positive numbers in the array, then the value of `positiveCount`
    will be zero when the loop ends, and this will result in a division by zero at
    the end of the function ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Because this is floating-point division, the program may not actually crash but
    rather produce odd behavior, depending on how the value of this function is used
    in the overall program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个函数看起来没问题，但仔细检查后会发现一个问题。如果数组中没有正数，那么循环结束时`positiveCount`的值将为零，这将在函数结束时导致除以零的错误
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)。因为这是浮点数除法，程序可能实际上不会崩溃，而是产生奇怪的行为，这取决于这个函数在整个程序中的使用方式。
- en: 'If you were quickly trying to get your code running and you discovered this
    problem, you might add some code to handle the case where `positiveCount` is zero
    and move on. But if you want to grow as a programmer, you should ask yourself
    what mistake you made. The specific problem, of course, is that you didn’t account
    for the possibility of dividing by zero. If that’s as deep as the analysis goes,
    though, it won’t help you very much in the future. Sure, you might catch another
    situation where a divisor might turn out to be zero, but that is not a very common
    situation. Instead, we should ask what general principle has been violated. The
    answer: that we should always look for special cases that can blow up our code.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你急于让代码运行，并发现了这个问题，你可能会添加一些代码来处理`positiveCount`为零的情况，然后继续。但如果你想作为一个程序员成长，你应该问问自己你犯了什么错误。具体问题当然是，你没有考虑到除以零的可能性。但如果分析就到这里，那么在将来它对你帮助不大。当然，你可能会遇到另一个除数可能为零的情况，但这并不常见。相反，我们应该问一下违反了哪个一般原则。答案是：我们应该总是寻找可能使我们的代码崩溃的特殊情况。
- en: By considering this general principle, we’ll be more likely to see patterns
    in our mistakes and therefore more likely to catch those mistakes in the future.
    Asking ourselves, “Any chance of dividing by zero here?” is not nearly as useful
    as asking ourselves, “What are the special cases for this data?” By asking the
    broader question, we’ll be reminded to check not just for division by zero but
    also for empty data sets, data outside the expected range, and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑这个一般原则，我们更有可能看到我们错误中的模式，因此更有可能在将来捕捉到这些错误。问自己“这里有可能除以零吗？”并不像问自己“这个数据有哪些特殊情况？”那么有用。通过问更广泛的问题，我们会提醒自己不仅要检查除以零，还要检查空数据集、超出预期范围的数据等等。
- en: Planning Against Design Weaknesses
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对设计弱点的规划
- en: 'Design weaknesses require a different approach to circumvent. The first step,
    though, is the same: You identify the weaknesses. A lot of people have trouble
    with this step because they don’t like to turn such a critical eye on themselves.
    We’re conditioned to conceal personal failings. It’s like when a job interviewer
    asks you what your biggest weakness is, and you are expected to answer with some
    nonsense about how you care too much about the quality of your work instead of
    providing an *actual* weakness. But just as Superman has his Kryptonite, even
    the best programmers have real weaknesses.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上的弱点需要不同的方法来规避。但第一步是相同的：你识别出弱点。很多人在这个步骤上遇到困难，因为他们不喜欢对自己如此苛刻。我们习惯于隐藏个人的失败。就像当面试官问你最大的弱点是什么时，你被期望给出一些关于你过于关心工作质量的废话，而不是提供一个**实际**的弱点。但就像超人有他的氪石一样，即使是最好的程序员也有真正的弱点。
- en: Here’s a sample (and certainly not exhaustive) list of programmer weaknesses.
    See whether you recognize yourself in any of these descriptions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份（当然不是详尽的）程序员弱点的样本列表。看看你是否在这些描述中找到了自己。
- en: '**Convoluted designs**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计复杂**'
- en: The programmer with this weakness creates programs that have too many parts
    or too many steps. While the programs work, they don’t inspire confidence—like
    worn clothing that looks as if it would fall apart at the first tug of a thread—and
    they are clearly inefficient.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这种弱点的程序员创建的程序部分太多或步骤太多。虽然程序可以工作，但它们不会让人有信心——就像看起来一扯就会破的破旧衣服——而且它们显然效率低下。
- en: '**Can’t get started**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**无法开始**'
- en: This programmer has a high degree of inertia. Whether from a lack of confidence
    in problem solving or plain procrastination, this programmer takes too long to
    make any initial progress on a problem.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序员有很大的惰性。无论是由于对解决问题的信心不足还是简单的拖延，这个程序员在问题上的初始进展总是花费太长时间。
- en: '**Fails to test**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**未能测试**'
- en: This programmer doesn’t like to formally test the code. Often the code will
    work for general cases, but not for special cases. In other situations, the code
    will work fine but won’t “scale up” for larger problem sets that the programmer
    hasn’t tested.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序员不喜欢正式测试代码。通常代码对一般情况有效，但对特殊情况无效。在其他情况下，代码可能运行良好，但不会“扩展”到程序员未测试的更大的问题集。
- en: '**Overconfident**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**过度自信**'
- en: Confidence is a great thing—this book is intended to increase the confidence
    of its readers—but too much confidence can sometimes be as much a problem as too
    little. Overconfidence manifests itself in various ways. The overconfident programmer
    might attempt a more complicated solution than necessary or allow too little time
    to finish a project, resulting in a rushed, bug-ridden program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 信心是一件好事——这本书的目的是增加读者的信心——但过度的自信有时可能和缺乏自信一样成问题。过度自信会以各种方式表现出来。过度自信的程序员可能会尝试比必要的更复杂的解决方案，或者给项目留的时间太少，结果导致一个匆忙、充满错误的程序。
- en: '**Weak area**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**薄弱环节**'
- en: This category is a bit of a catchall. Some programmers work smoothly enough
    until they hit certain concepts. Consider the topics discussed in previous chapters
    of this book. Most programmers, even after completing the exercises, will be more
    confident in some of the areas we’ve covered than others. For example, perhaps
    the programmer gets lost with pointer programs, or recursion turns the programmer’s
    head inside out. Maybe the programmer has trouble designing elaborate classes.
    It’s not that the programmer can’t muddle through and solve the problem, but it’s
    rough work, like driving through mud.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别有点像是一个大杂烩。一些程序员在遇到某些概念之前工作得很顺利。考虑一下本书前面章节中讨论的主题。大多数程序员，即使完成了练习，也会在某些我们覆盖的领域比其他领域更有信心。例如，程序员可能在指针程序中迷失方向，或者递归让程序员的头脑变得混乱。也许程序员在设计复杂的类时遇到困难。并不是程序员不能勉强解决问题，但这是一项艰难的工作，就像在泥地里开车一样。
- en: There are different ways you can confront your large-scale weaknesses, but once
    you recognize them, it’s easy to plan around them. If you’re the kind of programmer
    who often skips testing, for example, make testing an explicit part of your plan
    for writing each module, and don’t move onto the next module until you put a check
    in that box. Or consider a design paradigm called *test-driven development*, in
    which the testing code is written first, and then the code is written to fill
    those tests. If you have trouble getting started, use the principles of dividing
    or reducing problems, and start writing code as soon as you can, with the understanding
    that you may have to rewrite that code later. If your designs are often too complicated,
    add an explicit refactoring step to your master plan. The point is, no matter
    what weaknesses you have as a programmer, if you recognize them, you can plan
    around them. Then your weaknesses are no longer weaknesses—just obstacles in the
    road that you will steer around on the way to successful project completion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以面对你的大规模薄弱环节，但一旦你认识到它们，规划起来就容易多了。例如，如果你是那种经常跳过测试的程序员，那么请将测试明确纳入你编写每个模块的计划中，并且不要在检查那个框之前进入下一个模块。或者考虑一种称为*测试驱动开发*的设计范式，在这种范式中，测试代码首先编写，然后编写代码来填充那些测试。如果你有困难开始，使用分解或简化问题的原则，并尽快开始编写代码，理解你可能需要稍后重写那段代码。如果你的设计通常过于复杂，在你的总体规划中添加一个明确的重构步骤。重点是，无论你作为程序员有什么弱点，如果你认识到它们，你就可以规划绕过它们。那么，你的弱点就不再是弱点——只是你在通往成功项目完成道路上的障碍，你可以绕过它们。
- en: Planning for Your Strengths
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划您的优势
- en: Planning for your weaknesses is largely about avoiding mistakes. Good planning,
    though, isn’t just about avoiding mistakes. It’s about working toward the best
    possible result given your current abilities and whatever restraints you may be
    operating under. This means you must also incorporate your strengths into your
    master plan.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 规划您的薄弱环节主要是为了避免错误。然而，良好的规划并不仅仅是避免错误。它是在你当前的能力和可能面临的任何限制下，朝着最佳可能结果努力。这意味着你必须在你的总体规划中融入你的优势。
- en: 'You might think that this section isn’t for you, or at least not yet. After
    all, if you are reading this book, then you are still becoming a programmer. You
    might wonder whether you even have any strengths at this stage of your development.
    I’m here to tell you that you do, even if you haven’t recognized them yet. Here’s
    a list of common programmer strengths, by no means exhaustive, with descriptions
    of each and hints to help you recognize whether the term applies to you:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这一部分不是为你准备的，或者至少还不是。毕竟，如果你在读这本书，那么你还在成为程序员的路上。你可能想知道在目前的发展阶段你是否真的有任何优势。我在这里告诉你，你确实有，即使你还没有意识到。以下是一份常见的程序员优势列表，绝非详尽无遗，每个优势都有描述以及帮助你识别这些优势是否适用于你的提示：
- en: '**Eye for detail**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注重细节**'
- en: This type of programmer can anticipate special cases, see potential performance
    issues before they arise, and never lets the big picture cloud over the important
    details that must be handled for the program to be a complete and correct solution.
    Programmers with this strength tend to test their plans on paper before coding,
    code slowly, and test frequently.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的程序员可以预见特殊情况，在问题出现之前就能看到潜在的性能问题，并且永远不会让大局模糊了必须处理的重要细节，这对于程序成为一个完整且正确的解决方案至关重要。具有这种优势的程序员倾向于在编码前在纸上测试他们的计划，缓慢编码，并频繁测试。
- en: '**Fast learner**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速学习者**'
- en: A fast learner picks up new skills quickly, whether that’s learning a new technique
    in an already-known language or working with a new application framework. This
    type of programmer enjoys the challenge of learning new things and may choose
    projects based on this preference.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 快速学习者能够迅速掌握新技能，无论是学习已知语言中的新技术还是使用新的应用程序框架。这种类型的程序员喜欢学习新事物的挑战，并可能根据这种偏好选择项目。
- en: '**Fast coder**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速编码者**'
- en: The fast coder doesn’t need to spend a lot of time with a reference book to
    hammer out a function. Once it’s time to start typing, the code flows off the
    ends of the fast coder’s fingers without much effort and with few syntactical
    errors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 快速编码者不需要花很多时间在参考书上就能敲出一个函数。一旦开始输入，代码就会从快速编码者的指尖流淌出来，几乎不需要努力，且语法错误很少。
- en: '**Never gives up**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**永不放弃**'
- en: For some programmers, a pesky bug is a personal affront that can’t be ignored.
    It’s like the program has slapped the programmer across the mouth with a leather
    glove, and it’s up to the programmer to respond. This type of programmer always
    seems to stay levelheaded, determined but never very frustrated, and confident
    that with enough effort, victory is assured.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些程序员来说，一个讨厌的bug就像是对他们个人的侮辱，不能被忽视。这就像程序用皮手套打在程序员的嘴上，程序员必须做出回应。这种类型的程序员似乎总是保持冷静，坚定但从不非常沮丧，并确信只要付出足够的努力，胜利就一定属于自己。
- en: '**Super problem-solver**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**超级问题解决者**'
- en: Presumably you were not a super problem-solver when you bought this book, but
    now that you’ve gotten some guidance, perhaps it’s all starting to come easily.
    The programmer with this trait is starting to envision potential solutions to
    a problem even as he or she is reading it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你在购买这本书时并不是一个超级问题解决者，但现在你已经得到了一些指导，也许一切开始变得容易起来。具有这种特性的程序员在阅读问题时已经开始构想可能的解决方案。
- en: '**Tinkerer**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手实践者**'
- en: To this sort of programmer, a working program is like a wonderful toy box. The
    tinkerer has never lost the thrill of making the computer do his or her bidding
    and loves to keep finding something else for the computer to do. Maybe the tinkering
    means adding more and more functionality to a working program—a symptom known
    as *creeping featurism*. Maybe the program can be refactored for improved performance.
    Maybe the program can just be made prettier for the programmer or the user.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种程序员来说，一个能工作的程序就像一个美妙的玩具箱。动手实践者从未失去让计算机按照自己的意愿工作的兴奋感，喜欢不断为计算机找到新的任务。也许这种动手实践意味着给一个能工作的程序添加越来越多的功能——这是一种被称为*渐进式特性主义*的症状。也许程序可以被重构以提高性能。也许程序只是为了程序员或用户而变得更漂亮。
- en: Few programmers will exhibit more than a couple of these strengths—in fact,
    some of them tend to cancel each other out. But every programmer has strengths.
    If you don’t recognize yourself in any of these, it just means you have yet to
    learn enough about yourself or your strength is something that doesn’t fit into
    one of my categories.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有程序员会展现出超过两种这些优势——实际上，其中一些优势可能会相互抵消。但每个程序员都有自己的优势。如果你在上述任何一项中找不到自己的影子，那只是意味着你还没有足够了解自己，或者你的优势不属于我的任何一个类别。
- en: Once you’ve identified your strengths, you need to factor them into your master
    plan. Suppose you’re a fast coder. Obviously this will help get any project across
    the finish line, but how can you leverage this strength in a systematic way? In
    formal software engineering, there is an approach called *rapid prototyping*,
    in which a program is initially written without extensive planning and then improved
    through successive iterations until the results meet the problem requirements.
    If you’re a fast coder, you might try adopting this method, coding as soon as
    you have a basic idea and letting your rough prototype guide the design and development
    of the final program code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了你的优势，你需要将它们纳入你的总体规划中。假设你是一个编程速度快的人。显然这有助于让任何项目顺利完成，但你如何以系统化的方式利用这个优势呢？在正式的软件工程中，有一种称为“快速原型设计”的方法，其中程序最初在没有广泛规划的情况下编写，然后通过连续迭代进行改进，直到结果满足问题要求。如果你是一个编程速度快的人，你可能尝试采用这种方法，一旦有基本想法就立即编码，让你的粗糙原型指导最终程序代码的设计和开发。
- en: If you’re a rapid learner, maybe you should start every project by hunting for
    new resources or techniques to solve the current problem. If you’re not a rapid
    learner, but you are the sort of programmer who doesn’t easily get frustrated,
    maybe you should start the project with the areas you think will be the most difficult
    to give yourself the most time to tackle them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个快速学习者，也许你应该从寻找新的资源或技术来解决当前问题开始每一个项目。如果你不是一个快速学习者，但你是那种不容易沮丧的程序员，也许你应该从你认为最困难的领域开始项目，给自己更多的时间去解决它们。
- en: So whatever strengths you have, make sure you are taking advantage of them in
    your programming. Design your master plan so that you spend as much time as possible
    doing what you do best. Not only will you produce the best results this way, but
    you’ll also have the most fun, too.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以无论你有什么优势，确保你在编程中充分利用它们。设计你的总体规划，以便尽可能多地做你最擅长的事情。这样不仅会产生最好的结果，而且你也会玩得最开心。
- en: Putting the Master Plan Together
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定总体规划
- en: Let’s look at constructing a sample master plan. The ingredients include all
    the problem-solving techniques we have developed, plus our analysis of our strengths
    and weaknesses. For this example, I’ll use my own strengths and weaknesses.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构建一个示例总体规划。配料包括我们开发的所有解决问题的技巧，以及我们对优势和劣势的分析。在这个例子中，我将使用我自己的优势和劣势。
- en: In terms of problem-solving techniques, I use all of the techniques I share
    in this book, but I’m especially fond of the “reduce the problem” technique because
    using that technique allows me to feel that I’m always making concrete progress
    toward my goal. If I’m currently unable to figure out a way to write code that
    meets the full specification, I just throw out part of the specification until
    I gain momentum.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决问题的技巧方面，我使用这本书中分享的所有技巧，但我特别偏爱“简化问题”的技巧，因为使用这个技巧让我感觉我总是在朝着目标取得具体进展。如果我现在无法想出一种编写满足完整规范代码的方法，我就会先抛出一部分规范，直到我获得动力。
- en: My biggest coding weakness is excessive eagerness. I love to program because
    I love to see computers following my instructions. Sometimes this leads me to
    think, “Let’s give this thing a rip and see what happens,” when I should still
    be analyzing the correctness of what I just wrote. The danger here isn’t that
    the program will fail—it’s that the program will either appear to succeed but
    not cover all the special cases, or succeed but not be the best possible solution
    I could write.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我最大的编程弱点是过于急切。我喜欢编程，因为我喜欢看到计算机按照我的指令运行。有时这会让我想，“让我们试试看这个，看看会发生什么，”而此时我应该还在分析我刚刚写下的代码的正确性。这里的危险不在于程序会失败——而在于程序可能会看似成功但未涵盖所有特殊情况，或者成功但不是我能写出的最佳解决方案。
- en: I love elegant program designs that are easy to expand and reuse. Often when
    I code larger projects, I spend a lot of time developing alternative designs.
    On the whole, this is a good trait, but sometimes this results in me spending
    too much time in the design phase, not leaving enough time to actually implement
    the selected design. Also, this can sometimes result in a solution that is over-designed.
    That is, sometimes the solution is more elegant, expandable, and robust than it
    really needs to be. Because every project is limited in time and money, the best
    solution must balance the desire for high software quality with the need to conserve
    resources.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢优雅的程序设计，这种设计易于扩展和重用。通常当我编写较大的项目时，我会花费大量时间开发替代设计方案。总体来说，这是一个好的特性，但有时这会导致我在设计阶段花费过多时间，没有留出足够的时间来实际实施所选的设计。此外，有时这可能会导致过度设计的解决方案。也就是说，有时解决方案比实际需要的更加优雅、可扩展和健壮。因为每个项目在时间和金钱上都是有限的，所以最佳解决方案必须在追求高软件质量与节约资源的需求之间取得平衡。
- en: My best programming strength, I think, is that I pick up new concepts well,
    and I love to learn. While some programmers like using the same skills over and
    over, I love a project where I can learn something new, and I’m always exhilarated
    by that challenge.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我最好的编程优势是，我能够很好地掌握新概念，并且我喜欢学习。当一些程序员喜欢反复使用相同的技能时，我喜欢那些可以让我学到新东西的项目，而且我总是被这样的挑战所激励。
- en: With all that in mind, here is my master plan for a new project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，以下是我对新项目的总体规划。
- en: To fight my primary design weakness, I will strictly limit my time spent in
    the design phase or, alternatively, limit the number of distinct designs I will
    consider before moving on. This might sound like a dangerous idea to some readers.
    Shouldn’t we spend as much time as we can in the design phase before jumping into
    coding? Don’t most projects fail because not enough time was spent on the front
    end, leading to a cascade of compromises on the back end? These concerns are valid,
    but remember that I’m not creating a general guidebook for software development.
    I’m creating my own personal master plan for tackling programming problems. My
    weakness is over-designing, not under-designing, so a rule limiting design time
    makes sense for me. For another programmer, such a rule could be disastrous, and
    some programmers may need a rule to force them to spend more time on design.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服我的主要设计弱点，我将严格限制我在设计阶段花费的时间，或者，在继续前进之前，限制我要考虑的不同设计的数量。这可能会让一些读者觉得这是一个危险的想法。我们不应该在设计阶段投入尽可能多的时间，然后再开始编码吗？大多数项目不都是因为前端投入的时间不足而导致后端出现一系列妥协吗？这些担忧是合理的，但请记住，我并不是在编写一个软件开发的一般指南。我正在创建我自己的个人总体规划，以应对编程问题。我的弱点是过度设计，而不是设计不足，因此限制设计时间对我来说是有意义的。对于另一位程序员来说，这样的规则可能是灾难性的，有些程序员可能需要一个规则来迫使他们花更多的时间在设计上。
- en: After I complete my initial analysis, I’m going to consider whether the project
    presents opportunities to learn new techniques, libraries, and so forth. If it
    does, I’m going to write a small test-bed program to try out these new skills
    before attempting to incorporate them into my developing solution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成初步分析之后，我将考虑项目是否提供了学习新技术、库等的机会。如果确实如此，我将在尝试将其纳入我的开发解决方案之前，编写一个小型测试程序来尝试这些新技能。
- en: 'To fight excessive eagerness, I could incorporate a miniature code-review step
    when I finish coding each module. However, that will require an exercise of willpower
    on my part—when I complete each module, I’m going to want to go ahead and try
    it out. Simply hoping that I can talk myself out of it each time is like leaving
    an open bag of potato chips next to a hungry man and being surprised when the
    bag is emptied. It’s better to subvert weaknesses with a plan that doesn’t require
    the programmer to fight his or her instincts. So what if I create two versions
    of the project: a crusty, anything-goes version and a polished version for delivery?
    If I allow myself to play with the first version at will but prevent myself from
    incorporating code into the polished version until it’s been fully vetted, I’m
    much more likely to overcome my weakness.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗过度的急切心情，我可以在完成每个模块的编码后加入一个微型的代码审查步骤。然而，这需要我自己的意志力——当我完成每个模块时，我肯定会想要尝试它。仅仅希望每次都能说服自己放弃，就像在饥饿的人旁边放一袋薯片，然后惊讶地看着袋子被清空。更好的办法是制定一个计划，让程序员不必与其本能作斗争。那么，如果我创建两个版本的项目：一个粗糙的、无拘无束的版本和一个经过打磨的交付版本呢？如果我允许自己随意玩弄第一个版本，但直到它被彻底审查后才允许将其代码合并到打磨版本中，我更有可能克服我的弱点。
- en: Tackling Any Problem
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决任何问题
- en: 'Once we have a master plan, we’re ready for anything. That’s what this book
    is ultimately all about: starting with a problem, any problem, and finding a way
    through to the solution. In all the previous chapters, the problem descriptions
    pushed us in a particular initial direction, but in the real world, most problems
    don’t come with a requirement to use an array or recursion or to encapsulate some
    part of the program’s functionality into a class. Instead, the programmer makes
    those decisions as part of the problem-solving process.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了总计划，我们就准备好应对任何情况。这正是这本书的最终目的：从一个问题开始，任何问题，找到一条通往解决方案的道路。在前面的所有章节中，问题描述推动我们朝着特定的初始方向前进，但在现实世界中，大多数问题并不要求使用数组或递归，或者将程序功能的一部分封装到类中。相反，程序员在解决问题的过程中做出这些决定。
- en: At first, fewer requirements might seem to make problems easier. After all,
    a design requirement is a constraint, and don’t constraints make problems harder?
    While this is true, it’s also true that all problems have constraints—it’s just
    that in some cases they are more explicitly spelled out than in others. For example,
    not being told whether a particular problem requires a dynamically allocated structure
    doesn’t mean that the decision has no effect. The broad constraints of the problem—whether
    for performance, modifiability, speed of development, or something else—may be
    more difficult, or perhaps impossible, to meet if we make the wrong design choices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，更少的约束可能看起来会使问题更容易解决。毕竟，设计要求是一种约束，而约束不是会使问题更难吗？虽然这是真的，但所有问题都有约束——只是有些情况下，它们比其他情况下更明确地表述出来。例如，没有被告知特定问题是否需要动态分配的结构并不意味着这个决定没有影响。如果我们的设计选择错误，问题的广泛约束——无论是性能、可修改性、开发速度还是其他什么——可能更难满足，或者可能根本无法满足。
- en: Imagine a group of friends has asked you to select a movie for everyone to watch.
    If one friend definitely wants a comedy, another doesn’t like older films, and
    another lists five films she’s just seen and doesn’t want to see again, these
    constraints will make the selection difficult. However, if no one has any suggestions
    beyond “just pick something good,” your work is even harder, and you’re highly
    likely to pick something that at least one member of the group won’t like at all.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一群朋友请你为他们挑选一部电影观看。如果其中一个朋友肯定想看喜剧，另一个不喜欢老电影，还有一个列出她刚刚看过的五部电影，不想再看，这些限制会使选择变得困难。然而，如果没有人有任何建议，只是“随便挑个好的”，你的工作会更难，你很可能挑选出至少一个成员根本不喜欢的电影。
- en: Therefore larger, broadly defined, weakly constrained problems are the most
    difficult of all. However, they are susceptible to the same problem-solving techniques
    we’ve used throughout this book; they just take more time to solve. With your
    knowledge of these techniques and your master plan in hand, you will be able to
    solve any problem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更大、定义较宽泛、约束较弱的难题是最难解决的。然而，它们同样容易受到我们在本书中使用的相同问题解决技术的攻击；只是需要更多的时间来解决。有了这些技术的知识和手中的总计划，你将能够解决任何问题。
- en: To demonstrate what I’m talking about, I’m going to walk you through the first
    steps of a program that plays hangman, the classic children’s game, but with a
    twist.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我所说的内容，我将带你了解一个玩猜字谜程序的初步步骤，这是一个经典的儿童游戏，但有一个转折点。
- en: Before we get to the problem description, let’s review the basic rules of the
    game. The first player selects a word and tells a second player how many letters
    are in the word. The second player then guesses a letter. If the letter is in
    the word, the first player shows where the letter appears in the word; if the
    letter appears more than once, all appearances are indicated. If the letter is
    not in the word, the first player adds a piece to a stick-figure drawing of a
    man being hanged. If the second player guesses all the letters in the word, the
    second player wins, but if the first player completes the drawing, the first player
    wins. Different rules exist for how many pieces make up the drawing of the hanged
    man, so more generally we can say that the players agree ahead of time how many
    “misses” will win the game for the first player.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达问题描述之前，让我们回顾一下游戏的基本规则。第一个玩家选择一个单词，并告诉第二个玩家单词中有多少个字母。然后第二个玩家猜测一个字母。如果这个字母在单词中，第一个玩家会显示这个字母在单词中的位置；如果这个字母出现多次，所有出现的位置都会被指出。如果这个字母不在单词中，第一个玩家会在一个被绞死的人的stick-figure画上添加一个部件。如果第二个玩家猜对了单词中的所有字母，第二个玩家获胜，但如果第一个玩家完成了画，第一个玩家获胜。关于组成被绞死的人的部件数量有不同的规则，所以更普遍地说，玩家们事先同意第一个玩家获胜需要多少“失误”。
- en: Now that we’ve covered the basic rules, let’s look at the specific problem,
    including the challenging twist.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基本规则，让我们来看一个具体的问题，包括具有挑战性的转折点。
- en: 'Problem: Cheating at Hangman'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：猜字谜作弊
- en: Write a program that will be Player 1 in a text-based version of hangman (that
    is, you don’t actually have to draw a hanged man—just keep track of the number
    of incorrect guesses). Player 2 will set the difficulty of the game by specifying
    the length of the word to guess as well as the number of incorrect guesses that
    will lose the game.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序将是猜字谜（hangman）文本版本的玩家1（也就是说，你实际上不需要画一个被绞死的人——只需记录错误的猜测次数即可）。玩家2将通过指定猜测单词的长度以及导致游戏失败的错误猜测次数来设置游戏的难度。
- en: The twist is that the program will cheat. Rather than actually picking a word
    at the beginning of the game, the program may avoid picking a word, so long as
    when Player 2 loses, the program can display a word that matches all the information
    given to Player 2\. The correctly guessed letters must appear in their correct
    positions, and none of the incorrectly guessed letters can appear in the word
    at all. When the game ends, Player 1 (the program) will tell Player 2 the word
    that was chosen. Therefore, Player 2 can never prove that the game is cheating;
    it’s just that the likelihood of Player 2 winning is small.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 转折点是程序将作弊。而不是在游戏开始时实际选择一个单词，只要玩家2失败，程序就可以显示一个与玩家2给出的所有信息匹配的单词。正确猜测的字母必须出现在正确的位置，而且任何错误的猜测字母都不能出现在单词中。当游戏结束时，玩家1（程序）将告诉玩家2所选择的单词。因此，玩家2永远无法证明游戏在作弊；这只是玩家2获胜的可能性很小。
- en: This is not a monster-sized problem by real-world standards, but it’s large
    enough to demonstrate the issues we face when dealing with a programming problem
    that specifies results but no methodology. Based on the problem description, you
    could fire up your development environment and begin to write code in one of dozens
    of different places. That, of course, would be a mistake because we always want
    to program with a plan, so I need to apply my master plan to this specific situation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个按照现实世界标准的大问题，但它足够大，可以展示我们在处理指定结果但没有指定方法论的编程问题时面临的问题。根据问题描述，你可以在开发环境中启动并开始编写代码，可以在数十个不同的地方开始。当然，这将是错误的，因为我们总是希望有计划地编程，所以我需要将我的总体规划应用于这个具体的情况。
- en: The first part of my master plan is limiting the amount of time I spend in the
    design phase. In order to make that a reality, I need to think carefully about
    the design before I work on the production code. However, I believe that some
    experimentation will be necessary in this case for me to work out a solution to
    the problem. My master plan also allows me to create two projects, a rough-and-ready
    prototype and a final, polished solution. So I’m going to allow myself to begin
    coding for the prototype at any time, prior to any real design work, but not allow
    any coding in the final solution until I believe my design is set. That won’t
    guarantee I’ll be entirely satisfied with the design in the second project, but
    it offers the best opportunity for that to be so.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我的大计划的第一部分是限制我在设计阶段花费的时间。为了使这成为现实，我需要在编写生产代码之前仔细思考设计。然而，我相信在这种情况下进行一些实验对于我找到问题的解决方案是必要的。我的大计划还允许我创建两个项目，一个粗糙的原型和最终的、完善的解决方案。因此，我将允许自己在任何实际设计工作之前开始为原型编码，但在我相信设计已经确定之前，不允许对最终解决方案进行任何编码。这不能保证我对第二个项目的整个设计完全满意，但它提供了最好的机会。
- en: Now it’s time to start picking this problem apart. In previous chapters, we
    would sometimes list all of the subtasks needed to complete a problem, so I’d
    like to make an inventory of the subtasks. At this point, though, this would be
    difficult because I don’t know what the program will actually do to accomplish
    the cheating. I need to investigate this area further.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始分析这个问题了。在之前的章节中，我们有时会列出完成问题所需的子任务，所以我想要列出这些子任务。然而，目前这很困难，因为我不知道程序实际上会如何实现作弊。我需要进一步调查这个领域。
- en: Finding a Way to Cheat
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到作弊的方法
- en: Cheating at hangman is specific enough that I don’t expect to find any help
    in the normal sources of components; there is no *NefariousStrategy* pattern.
    At this point, I have a vague idea how the cheating could be accomplished. I’m
    thinking that I’ll choose an initial puzzle word and hang on to that as long as
    Player 2 chooses letters that aren’t actually in that word. Once Player 2 hits
    upon a letter that’s actually in the word, though, I’ll switch to another word
    if it’s possible to find one that has none of the letters selected thus far. In
    other words, I’ll deny a match to Player 2 as long as possible. That’s the idea,
    but I need more than an idea—I need something I can implement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在猜字谜游戏中作弊是足够具体的，我不期望在组件的正常来源中找到任何帮助；没有*邪恶策略*模式。在这个阶段，我对如何作弊有一个模糊的想法。我想我会选择一个初始谜题单词，只要玩家2选择的字母实际上不在那个单词中，我就保留那个单词。然而，一旦玩家2猜中了一个实际上在单词中的字母，如果可能找到一个不包含迄今为止所选字母的单词，我就会切换到另一个单词。换句话说，我会尽可能长时间地拒绝玩家2匹配。这是我的想法，但我需要的不仅仅是想法——我需要我能实现的东西。
- en: In order to firm up my ideas, I’m going to work through an example on paper,
    taking on the role of Player 1, working from a word list. To keep things simple,
    I’m going to assume that Player 2 has requested a three-letter word and that the
    complete list of three-letter words that I know are shown in the first column
    of [Table 8-1](ch08.html#sample_word_list "Table 8-1. Sample Word List"). I’ll
    assume that my first choice “puzzle word” is the first word on the list, *bat*.
    If Player 2 guesses any letter besides *b*, *a*, or *t*, I’ll say “no,” and we’ll
    be one step closer to completing the gallows. If Player 2 guesses a letter in
    the word, then I’ll pick another word, one that doesn’t contain that letter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我的想法更加明确，我将在纸上通过一个例子来工作，扮演玩家1的角色，从一个单词列表开始。为了简化问题，我将假设玩家2请求了一个三字母单词，并且我知道的所有三字母单词的完整列表显示在[表8-1](ch08.html#sample_word_list
    "表8-1. 样本单词列表")的第一列。我将假设我的第一个选择的“谜题单词”是列表上的第一个单词，*bat*。如果玩家2猜的字母不是*b*、*a*或*t*，我会说“不”，然后我们就会更接近完成绞刑架。如果玩家2猜中了一个单词中的字母，那么我会选择另一个单词，一个不包含那个字母的单词。
- en: Looking at my list, though, I’m not so sure this strategy is the best. In some
    situations, it probably makes sense. Suppose Player 2 guesses *b*. No other word
    in the list contains *b*, so I can switch the puzzle word to any of them. This
    also means that I’ve minimized the damage; I’ve eliminated only one possible word
    from my list. But what happens if Player 2 guesses *a*? If I just say “no,” I
    eliminate all words containing an *a*, which leaves just the three words in the
    second column of [Table 8-1](ch08.html#sample_word_list "Table 8-1. Sample Word
    List") for me to choose from. If I decided instead to admit the presence of letter
    *a* in the puzzle word, I would have five words left I could choose from, as shown
    in the third column. Note, though, that this extended selection exists only because
    all five of the words have the *a* in the same position. Once I declare a guess
    correct, I have to show exactly where the letter appears in the word. I’ll feel
    a lot better about my chances for the rest of the game if I have more word choices
    remaining to react to future guesses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我查看我的列表时，我不太确定这种策略是否是最好的。在某些情况下，这可能是有意义的。假设玩家2猜测*b*。列表中没有任何其他单词包含*b*，所以我可以将谜题单词切换到其中任何一个。这也意味着我已经最小化了损害；我只从我的列表中消除了一个可能的单词。但是，如果玩家2猜测*a*会发生什么？如果我只是说“没有”，我将消除包含*a*的所有单词，这只会留下[表8-1](ch08.html#sample_word_list
    "表8-1. 样本单词列表")第二列中的三个单词供我选择。如果相反，我决定承认谜题单词中存在字母*a*，我将剩下五个单词可供选择，如第三列所示。但请注意，这种扩展的选择仅因为所有五个单词的*a*都在相同的位置。一旦我宣布一个猜测是正确的，我就必须准确地显示字母在单词中的位置。如果我在游戏中剩余的时间里还有更多的单词选择来应对未来的猜测，我会感到更加安心。
- en: Table 8-1. Sample Word List
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1. 样本单词列表
- en: '| All Words | Words Without *a* | Words with *a* |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| All Words | Words Without *a* | Words with *a* |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| bat | dot | bat |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| bat | dot | bat |'
- en: '| car | pit | car |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| car | pit | car |'
- en: '| dot | top | eat |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| dot | top | eat |'
- en: '| eat |   | saw |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| eat | saw |'
- en: '| pit |   | tap |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| pit |   | tap |'
- en: '| saw |   |   |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| saw |   |   |'
- en: '| tap |   |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| tap |   |   |'
- en: '| top |   |   |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| top |   |   |'
- en: Also, even if I managed to avoid revealing letters early in the game, I have
    to expect that Player 2 will eventually make a correct guess. Player 2 could start
    with all of the vowels, for example. Therefore, at some point I will have to decide
    what to do when a letter is revealed, and from my experiment with the sample list,
    it looks like I will have to find the location (or locations) where the letter
    appears most often. From this observation, I realized that I have been thinking
    about cheating in the wrong way. I should never actually pick a puzzle word, even
    temporarily, but just keep track of all the possible words I could choose if I
    have to.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使我设法在游戏早期避免了揭示字母，我也必须预计玩家2最终会做出正确的猜测。例如，玩家2可能一开始就猜测所有元音字母。因此，在某个时候，我必须决定在字母被揭示时该做什么，并且根据我对样本列表的实验，看起来我必须找到字母出现最频繁的位置（或位置）。从这个观察中，我意识到我一直在错误地思考作弊。我实际上永远不应该选择一个谜题单词，即使只是暂时，而只是跟踪如果我必须选择时所有可能的单词。
- en: 'With this idea in mind, I can now define cheating in a different way: Keep
    as many words as possible in the list of candidate puzzle words. For each guess
    that Player 2 makes, the program has a decision to make. Do we claim that the
    guess was a miss or a match? If it was a match, in which positions does the guessed
    letter appear? I’ll have my program keep an ever-dwindling list of candidate puzzle
    words and, after each guess, make the decision that will leave the greatest number
    of words in that list.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个想法，我现在可以以不同的方式定义作弊：尽可能多地保留候选谜题单词列表中的单词。对于玩家2的每一次猜测，程序都需要做出一个决定。我们声称这个猜测是未命中还是匹配？如果是匹配，猜测的字母出现在哪些位置？我的程序将保持一个不断减少的候选谜题单词列表，并在每次猜测后做出决定，以保留列表中尽可能多的单词。
- en: Required Operations for Cheating at Hangman
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 悖我猜单词游戏所需的操作
- en: Now I understand the problem well enough to create my list of subtasks. In a
    problem of this size, there’s a good chance that a list made at this early stage
    will leave some operations out. This is okay, because my master plan anticipates
    that I will not create a perfect design the first time around.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经足够了解这个问题，可以创建我的子任务列表。在这样一个规模的问题中，在早期阶段制作的列表可能会遗漏一些操作。这是可以接受的，因为我的主要计划预计我不会第一次就创建一个完美的设计。
- en: '**Store and maintain a list of words**.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储并维护一个单词列表**。'
- en: This program must have a list of valid English words. The program will therefore
    have to read a list of words from a file and store them internally in some format.
    This list will be reduced, or extracted from, during the game as the program cheats.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序必须有一个有效的英语单词列表。因此，程序将不得不从文件中读取单词列表，并以某种格式将它们存储在内部。在游戏过程中，随着程序的作弊，这个列表将被缩减或提取。
- en: '**Create a sublist of words of a given length**.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建给定长度的单词子列表**。'
- en: Given my intention to maintain a list of candidate puzzle words, I have to start
    the game with a list of words of the length specified by Player 2.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的意图是维护候选谜底单词列表，我必须以玩家2指定的长度单词列表开始游戏。
- en: '**Track letters chosen**.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪所选字母**。'
- en: The program will need to remember which letters have been guessed, how many
    of those were incorrect, and for any that were deemed correct, where they appear
    in the puzzle word.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要记住哪些字母已被猜出，其中有多少是不正确的，以及对于被认为正确的字母，它们在谜底单词中的位置。
- en: '**Count words in which a letter does not appear**.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算不包含字母的单词数量**。'
- en: In order to facilitate cheating, I’ll need to know how many words in the list
    do not contain the most recently guessed letter. Remember that the program will
    decide whether the most recently guessed letter appears in the puzzle word with
    the goal of leaving the maximum number of words in the candidate word list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于作弊，我需要知道列表中有多少单词不包含最近猜出的字母。请记住，程序将决定最近猜出的字母是否出现在谜底单词中，目的是在候选单词列表中留下尽可能多的单词。
- en: '**Determine the largest number of words based on letter and position**.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**根据字母和位置确定单词数量最多的情况**。'
- en: This looks like the trickiest operation. Let’s suppose Player 2 has just guessed
    the letter *d* and the current game has a puzzle-word length of three. Perhaps
    the current candidate word list as a whole contains 10 words that include *d*,
    but that’s not what’s important because the program will have to state where the
    letter occurs in the puzzle word. Let’s call the positioning of letters in a word
    a pattern. So *d??* is a three-letter pattern that specifies the first letter
    is a *d* and the other two letters are anything other than a *d*. Consider [Table 8-2](ch08.html#three-letter_words
    "Table 8-2. Three-Letter Words"). Suppose that the list in the first column contains
    every three-letter word containing *d* known to the program. The other columns
    break this list down by pattern. The most frequently occurring pattern is *??d*,
    with 17 words. This number, 17, would be compared with the number of words in
    the candidate list that do not contain a *d* to determine whether to call the
    guess a match or a miss.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是最棘手的操作。假设玩家2刚刚猜出字母*d*，当前游戏谜底单词长度为三个。也许当前的候选单词列表总共包含10个包含*d*的单词，但这并不重要，因为程序必须声明字母在谜底单词中的位置。让我们称单词中字母的位置为模式。所以*d??*是一个三字母模式，指定第一个字母是*d*，而其他两个字母可以是任何不是*d*的字母。考虑[表8-2](ch08.html#three-letter_words
    "表8-2. 三字母单词")。假设第一列中的列表包含程序所知的每个包含*d*的三字母单词。其他列根据模式分解这个列表。最频繁出现的模式是*??d*，有17个单词。这个数字，17，将与候选列表中不包含*d*的单词数量进行比较，以确定猜测是匹配还是失误。
- en: '**Create a sublist of words matching a pattern**.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建匹配特定模式的单词子列表**。'
- en: When the program declares that a Player 2 guess is a match, it will create a
    new candidate word list with only those words that match the letter pattern chosen.
    In the previous example, if we declared *d* a match, the third column in [Table 8-2](ch08.html#three-letter_words
    "Table 8-2. Three-Letter Words") would become the new candidate word list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序宣布玩家2的猜测是匹配时，它将创建一个新的候选单词列表，其中只包含与所选字母模式匹配的单词。在先前的例子中，如果我们宣布*d*为匹配，[表8-2](ch08.html#three-letter_words
    "表8-2. 三字母单词")的第三列将变成新的候选单词列表。
- en: '**Keep playing until the game is over**.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**继续玩游戏直到游戏结束**。'
- en: After all the other operations are in place, I need to write the code that glues
    everything together and actually play the game. The program should repeatedly
    request a guess from Player 2 (the user), determine whether the candidate word
    list would be longer by rejecting or accepting that guess, reduce the word list
    accordingly, and then display the resulting puzzle word, with any correctly guessed
    letters revealed, along with a review of all previously guessed letters. This
    process would continue until the game was over, having been won by one player
    or the other—the conditions for which I also need to figure out.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他操作就绪之后，我需要编写将一切粘合在一起并实际玩游戏的代码。程序应该反复请求玩家2（用户）猜测，确定通过接受或拒绝该猜测来决定候选单词列表是否会变长，相应地减少单词列表，并显示结果谜题单词，包括任何正确猜测的字母，以及所有先前猜测的字母的回顾。这个过程将继续，直到游戏结束，由一方玩家获胜——我还需要弄清楚这些条件。
- en: Table 8-2. Three-Letter Words
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-2. 三字母单词
- en: '| All Words | ?dd | ??d | d?? | d?d |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 所有单词 | ?dd | ??d | d?? | d?d |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| add | add | aid | day | did |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| add | add | aid | day | did |'
- en: '| aid | odd | and | die |   |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| aid | odd | and | die |   |'
- en: '| and |   | bad | doe |   |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| and |   | bad | doe |   |'
- en: '| bad |   | bed | dog |   |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| bad |   | bed | dog |   |'
- en: '| bed |   | bid | dry |   |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| bed |   | bid | dry |   |'
- en: '| bid |   | end | due |   |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| bid |   | end | due |   |'
- en: '| day |   | fed |   |   |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| day |   | fed |   |   |'
- en: '| did |   | had |   |   |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| did |   | had |   |   |'
- en: '| die |   | hid |   |   |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| die |   | hid |   |   |'
- en: '| doe |   | kid |   |   |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| doe |   | kid |   |   |'
- en: '| dog |   | led |   |   |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| dog |   | led |   |   |'
- en: '| dry |   | mad |   |   |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| dry |   | mad |   |   |'
- en: '| due |   | mod |   |   |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| due |   | mod |   |   |'
- en: '| end |   | old |   |   |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| end |   | old |   |   |'
- en: '| fed |   | red |   |   |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| fed |   | red |   |   |'
- en: '| had |   | rid |   |   |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| had |   | rid |   |   |'
- en: '| hid |   | sad |   |   |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| hid |   | sad |   |   |'
- en: '| kid |   |   |   |   |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| kid |   |   |   |   |'
- en: '| led |   |   |   |   |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| led |   |   |   |   |'
- en: '| mad |   |   |   |   |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| mad |   |   |   |   |'
- en: '| mod |   |   |   |   |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| mod |   |   |   |   |'
- en: '| odd |   |   |   |   |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| odd |   |   |   |   |'
- en: '| old |   |   |   |   |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| old |   |   |   |   |'
- en: '| red |   |   |   |   |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| red |   |   |   |   |'
- en: '| rid |   |   |   |   |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| rid |   |   |   |   |'
- en: '| sad |   |   |   |   |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| sad |   |   |   |   |'
- en: Initial Design
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始设计
- en: Although it may appear that the previous list of required operations merely
    lists raw facts, design decisions are being made. Consider the operation “Create
    a sublist of words matching a pattern.” That operation is going to appear in my
    solution, or at least this initial version of it, but strictly speaking, it’s
    not a *required* operation at all. Neither is “Create a sublist of words of a
    given length.” Rather than maintaining a list of candidate puzzle words that keeps
    getting smaller, I could keep the original master list of words throughout the
    game. This would complicate most of the other operations, though. The operation
    to “Count words in which a letter does not appear” could not merely iterate through
    the candidate puzzle-word list and count all words without the specified letter.
    Because it would be searching through the master list, it would also have to check
    the length of each word and whether the word matches the letters revealed so far
    in the puzzle word. I think the path I have chosen is easier overall, but I have
    to be aware that even these early choices are affecting the final design.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来之前的操作列表只是列出了一些原始事实，但设计决策正在被做出。考虑操作“创建一个匹配模式的单词子列表。”这个操作将出现在我的解决方案中，至少是这个初始版本，但严格来说，这根本不是一个*必需*的操作。同样，“创建给定长度的单词子列表”也不是。与其维护一个不断缩小的候选谜题单词列表，我可以在整个游戏中保持原始的单词主列表。但这将使大多数其他操作变得复杂。对于“计算不包含指定字母的单词数量”的操作，不能仅仅遍历候选谜题单词列表并计算所有不包含指定字母的单词。因为它将搜索主列表，所以它还必须检查每个单词的长度以及单词是否与谜题单词中到目前为止揭示的字母匹配。我认为我选择的路径总体上更容易，但我必须意识到，即使是这些早期的选择也在影响着最终的设计。
- en: Beyond the initial breakdown of the problem into subtasks, though, I have other
    decisions to make.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在将问题分解为子任务之后，我还有其他决定要做。
- en: '**How to store the lists of words**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何存储单词列表**'
- en: The key data structure of the program will be the list of words, which the program
    will reduce throughout the game. In choosing a structure, I make the following
    observations. First, I don’t believe I will require random access to the words
    in the list but instead will always be processing the list as a whole, from front
    to back. Second, I don’t know the size of the initial list I require. Third, I’m
    going to be reducing the list frequently. Fourth and finally, the methods of the
    standard `string` class will probably come in handy in this program. Putting all
    of these observations together, I decide that my initial choice for this structure
    will be the standard template `list` class, with an item type of `string`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的关键数据结构将是单词列表，程序将在整个游戏中减少这个列表。在选择结构时，我观察到以下几点。首先，我相信我不需要随机访问列表中的单词，而是一直从前往后整体处理列表。第二，我不知道我需要的初始列表的大小。第三，我将会频繁地减少列表。第四，也是最后一点，标准`string`类的方法在这个程序中可能会很有用。将这些观察结果综合起来，我决定我的初始选择将是标准的模板`list`类，项目类型为`string`。
- en: '**How to track letters guessed**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何跟踪猜测的字母**'
- en: The chosen letters are conceptually a set—that is, a letter has either been
    chosen or it hasn’t, and no letter can be chosen more than once. Thus, it’s really
    a question of whether a particular letter of the alphabet is a member of the “chosen”
    set. I’m therefore going to represent chosen letters as an array of `bool` of
    size 26\. If the array is named `guessedLetters`, then `guessedLetters[0]` is
    true if *a* has been guessed during the game so far and false otherwise; `guessedLetters[1]`
    is for *b*, and so on. I’ll use the range conversion techniques we’ve been employing
    throughout this book to convert between a lowercase alphabet letter and its corresponding
    position in the array. If `letter` is a char representing a lowercase letter,
    then `guessedLetters[letter - 'a']` is the corresponding location.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 被选中的字母在概念上是一个集合——也就是说，一个字母要么被选中，要么没有被选中，一个字母不能被选中超过一次。因此，这实际上是一个特定字母是否是“选中”集合的成员的问题。因此，我将选中的字母表示为一个大小为26的`bool`数组。如果数组命名为`guessedLetters`，那么`guessedLetters[0]`在游戏到目前为止被猜中时为true，否则为false；`guessedLetters[1]`用于*b*，以此类推。我将使用我们在整本书中一直在使用的范围转换技术，在大小写字母及其在数组中的对应位置之间进行转换。如果`letter`是一个表示小写字母的char，那么`guessedLetters[letter
    - 'a']`就是相应的位置。
- en: '**How to store patterns**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何存储模式**'
- en: One of the operations I’ll be coding, “Create a sublist of words matching a
    pattern,” is going to use the pattern of a letter’s positions in a word. This
    pattern will be produced by another operation, “Determine the largest number of
    words based on letter and position.” So what format will I use for that data?
    The pattern is a series of numbers representing the positions in which a particular
    letter appears. There are a lot of ways I could store these numbers, but I’m going
    to keep things simple and use another `list`, this one with an item type of `int`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要编写的操作之一，“创建匹配模式的单词子列表”，将使用单词中字母的位置模式。这个模式将由另一个操作产生，“根据字母和位置确定最大单词数”。那么我将使用什么格式来存储这些数据？模式是一系列代表特定字母出现位置的数字。我有许多方法可以存储这些数字，但我将保持简单，使用另一个`list`，这个`list`的项目类型为`int`。
- en: '**Am I writing a class?**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**我是在写一个类吗？**'
- en: Because I am coding this program in C++, I can use object-oriented programming
    or not, at my discretion. My first thought is that many of the operations in my
    list could naturally coalesce into a class, called `wordList` perhaps, with methods
    to remove words based on specified criteria (that is, length and pattern). However,
    because I’m trying to avoid making design decisions now that I’ll have to revoke
    later, I’m going to make my first, rough-and-ready program entirely procedural.
    Once I’ve worked out all of the tricky aspects of the program and actually written
    code for all of the operations in my list, I’ll be in a great position to determine
    the applicability of object-oriented programming for the final version.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我在用C++编写这个程序，我可以根据我的意愿使用面向对象编程，也可以不使用。我的第一个想法是，我列表中的许多操作可以自然地合并成一个类，比如叫做`wordList`，它有根据指定标准（即长度和模式）删除单词的方法。然而，因为我正在尝试避免做出我现在会后悔的设计决策，所以我将我的第一个、粗略而实用的程序完全做成过程式的。一旦我解决了程序的所有棘手方面，并且实际上为列表中的所有操作编写了代码，我将处于一个很好的位置来决定面向对象编程对于最终版本的可适用性。
- en: Initial Coding
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始编码
- en: 'Now the fun begins. I fire up my development environment and get to work. This
    program is going to use a number of classes from the standard library, so for
    clarity, let me set all of those up first:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有趣的部分开始了。我启动了我的开发环境并开始工作。这个程序将使用标准库中的许多类，为了清晰起见，让我先设置好所有这些类：
- en: '[PRE4]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now I’m ready to start coding the operations on my list. To some extent, I could
    code the operations in any order, but I’m going to start with a function to read
    a plain text file of words into my chosen `list<string>` structure. At this point,
    I realize I need to find an existing master file of words—I don’t want to type
    it up myself. Luckily, Googling *word list* reveals a number of sites that have
    lists of English words in plain-text format, one word per line of the file. I’m
    already familiar with reading text files in C++, but if I weren’t, I would write
    a small test program just to play around with that skill first and then integrate
    that ability into the cheating hangman program, a practice I discuss later in
    this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经准备好开始编写我列表中的操作代码了。在某种程度上，我可以按任何顺序编写这些操作，但我打算从一个函数开始，该函数将读取一个包含单词的纯文本文件到我所选择的`list<string>`结构中。在这个时候，我意识到我需要找到一个现有的单词主文件——我不想自己输入。幸运的是，搜索“单词列表”揭示了许多网站，它们提供了以纯文本格式排列的英语单词列表，每个单词占文件的一行。我已经熟悉了在C++中读取文本文件，但如果我不熟悉，我会编写一个小型测试程序，先练习这项技能，然后再将其集成到作弊的猜字游戏程序中，这种练习我在本章后面会讨论。
- en: 'With the file in hand, I can write the function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到文件后，我可以编写这个函数：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function is straightforward, so I’ll make just a few brief comments. If
    you’ve never seen one before, an `ifstream` object ![](httpatomoreillycomsourcenostarchimages1273182.png)
    is an input stream that works just like `cin`, except that it reads from a file
    instead of standard input. If the constructor is unable to open the file (usually
    this means the file wasn’t found), the object will be `NULL`, something I explicitly
    check for ![](httpatomoreillycomsourcenostarchimages1273191.png). If the file
    exists, it’s processed in a loop ![](httpatomoreillycomsourcenostarchimages1273193.png)
    that reads each line of the file into a character array, converts the array to
    a `string` object, and adds it to a `list`. The file of English words I ended
    up using included words with apostrophes, which aren’t legal for our game, so
    I explicitly exclude them ![](httpatomoreillycomsourcenostarchimages1273195.png).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单，所以我只会做几个简要的注释。如果你以前从未见过，一个`ifstream`对象 ![ifstream](http://atomoreilly.com/source/no_starch_images/1273182.png)
    是一个输入流，它的工作方式就像`cin`一样，只不过它从文件而不是标准输入读取。如果构造函数无法打开文件（通常这意味着文件未找到），对象将是`NULL`，我会明确检查这一点
    ![ifstream](http://atomoreilly.com/source/no_starch_images/1273191.png)。如果文件存在，它将在循环
    ![ifstream](http://atomoreilly.com/source/no_starch_images/1273193.png) 中被处理，循环读取文件的每一行到一个字符数组中，将数组转换为`string`对象，并将其添加到`list`中。我最终使用的英语单词文件包含了带有撇号的单词，这些单词在我们的游戏中是不合法的，所以我明确排除了它们
    ![ifstream](http://atomoreilly.com/source/no_starch_images/1273195.png)。
- en: 'Next, I write a function to display all the words in my `list<string>`. This
    isn’t on my required list of operations, and I wouldn’t use it in the game (that
    would only help Player 2, whom I’m trying to cheat, after all), but it’s a good
    way to test whether my `readWordFile` function is working correctly:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我编写了一个函数来显示我`list<string>`中的所有单词。这不在我的必需操作列表中，我也不会在游戏中使用它（毕竟，这只会帮助玩家2，而我正试图欺骗他），但这是一个测试我的`readWordFile`函数是否正确工作的好方法：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is essentially the same list traversal code introduced in the previous
    chapter. Note that I have declared the parameter as a `const` reference ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Because the list may be quite large at the beginning, having a reference parameter
    reduces the overhead of the function call, while a value parameter would have
    to copy the entire list. Declaring that reference parameter a `const` signals
    that the function won’t change the list, which aids the readability of the code.
    A `const` list requires a `const` iterator ![](httpatomoreillycomsourcenostarchimages1273191.png).
    The `cout` stream can’t output a string object, so this method produces the equivalent
    null-terminated `char` array using `c_str()`![](httpatomoreillycomsourcenostarchimages1273193.png).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是上一章中介绍的基本列表遍历代码。请注意，我已经将参数声明为`const`引用 ![图片](httpatomoreillycomsourcenostarchimages1273182.png)。因为列表在开始时可能相当大，所以将引用参数声明为`const`可以减少函数调用的开销，而值参数将不得不复制整个列表。将这个引用参数声明为`const`表示函数不会更改列表，这有助于代码的可读性。一个`const`列表需要一个`const`迭代器
    ![图片](httpatomoreillycomsourcenostarchimages1273191.png)。`cout`流不能输出字符串对象，所以这个方法使用`c_str()`生成等效的空终止`char`数组
    ![图片](httpatomoreillycomsourcenostarchimages1273193.png)。
- en: 'I use this same basic structure to write a function that counts the words in
    the list that do not contain a specified letter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这个相同的基本结构来编写一个函数，该函数计算列表中不包含指定字母的单词数量：
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, this is the same basic traversal loop. Inside, I call the `find`
    method of the `string` class ![](httpatomoreillycomsourcenostarchimages1273182.png),
    which returns the position of its `char` parameter in the `string` object, returning
    the special value `npos` when the character isn’t found.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个相同的基本遍历循环。在内部，我调用了`string`类的`find`方法 ![图片](httpatomoreillycomsourcenostarchimages1273182.png)，它返回其`char`参数在`string`对象中的位置，当字符未找到时返回特殊值`npos`。
- en: 'I use this same basic structure to write the function that removes all the
    words from my word list that don’t match the specified length:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这个相同的基本结构来编写一个函数，该函数会移除我的单词列表中所有与指定长度不匹配的单词：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function is a good example of how every program you write is an opportunity
    to deepen your understanding of how programs work. This function was straightforward
    for me to write because I understood what was happening “under the hood” from
    previous programs that I had written. This function employs the basic traversal
    code of the previous functions, but the code gets interesting inside the loop.
    The `erase()` method removes an item, specified by an `iterator`, from a `list`
    object. But from our experience implementing the iterator pattern for a linked
    list in [Chapter 7](ch07.html "Chapter 7. Solving Problems with Code Reuse"),
    I know that the `iterator` is almost certainly a pointer. From our experience
    with pointers back in [Chapter 4](ch04.html "Chapter 4. Solving Problems with
    Pointers and Dynamic Memory"), I know that a pointer is useless, and often dangerous,
    when it’s a dangling reference to something that’s been deleted. Therefore, I
    know I need to assign a valid value to `iter` after this operation. Fortunately,
    the designers of `erase()` have anticipated this problem and have the method return
    a new `iterator` that points to the item immediately following the one we just
    erased, so I can assign that value back to `iter` ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Also note that I explicitly advance `iter` ![](httpatomoreillycomsourcenostarchimages1273191.png)
    only when I have not deleted the current string from the list, because the assignment
    of the `erase()` return value effectively advances the `iterator`, and I don’t
    want to skip any items.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是每个你编写的程序都是加深你对程序工作方式理解的机会的一个很好的例子。这个函数对我来说写起来很简单，因为我已经从之前编写的程序中理解了“幕后”发生了什么。这个函数使用了之前函数的基本遍历代码，但代码在循环内部变得有趣。`erase()`方法从一个`list`对象中移除由`iterator`指定的项。但根据我们在[第7章](ch07.html
    "第7章. 通过代码重用解决问题")中实现链表迭代器模式的经验，我知道`iterator`几乎肯定是一个指针。根据我们在[第4章](ch04.html "第4章.
    通过指针和动态内存解决问题")中的指针经验，我知道当它是一个指向已删除对象的悬挂引用时，指针是无用的，并且通常是危险的。因此，我知道我需要在这次操作后给`iter`赋一个有效值。幸运的是，`erase()`的设计者已经预料到这个问题，并有一个方法返回一个指向我们刚刚删除的项之后的项的新`iterator`，所以我可以将这个值赋回`iter`
    ![图片](httpatomoreillycomsourcenostarchimages1273182.png)。此外，请注意，我只在未从列表中删除当前字符串时显式前进`iter`
    ![图片](httpatomoreillycomsourcenostarchimages1273191.png)，因为`erase()`返回值的赋值实际上会前进`iterator`，我不想跳过任何项。
- en: 'Now for the tough part: finding the most common pattern of a specified letter
    in the remaining word list. This is another opportunity to use the divide-the-problem
    technique. I know one of the subtasks of this operation is determining whether
    a particular word matches a particular pattern. Remember that a pattern is a `list<int>`,
    with each `int` representing a position where the letter appears in the word,
    and that for a word to match a pattern, not only must the letter appear in the
    specified positions in the word, but the letter must *not* appear anywhere else
    in the word. With that thought in mind, I’m going to test a string for a match
    by traversing it; for each position in the string, if the specified letter appears,
    I’ll make sure that position is in the pattern, and if some other letter appears,
    I’ll make sure that position is not in the pattern.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是困难的部分：在剩余的单词列表中找到指定字母的最常见模式。这是使用分解问题技术的一个机会。我知道这个操作的子任务之一是确定一个特定的单词是否与特定的模式匹配。记住，一个模式是一个`list<int>`，其中每个`int`代表字母在单词中出现的位置，并且为了使单词与模式匹配，不仅字母必须出现在单词中指定的位置，而且字母**不能**出现在单词的任何其他位置。有了这个想法，我将通过遍历字符串来测试字符串是否匹配；对于字符串中的每个位置，如果指定的字母出现，我将确保该位置在模式中，如果出现其他字母，我将确保该位置不在模式中。
- en: 'To make things even simpler, I’ll first write a separate function to check
    whether a particular position number appears in a pattern:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加简单，我首先将编写一个单独的函数来检查特定的位置数字是否出现在模式中：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code is pretty simple to write based on the previous functions. I simply
    traverse the `list`, searching for `number`. Either I find it and return `true`
    or I get to the end of the list and return `false`. Now I can implement the general
    pattern-matching test:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前的函数，这段代码相当简单编写。我只是遍历`list`，寻找`number`。要么我找到它并返回`true`，要么我到达列表的末尾并返回`false`。现在我可以实现通用的模式匹配测试：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this function follows the plan outlined earlier. For each character
    in the string, if it matches `letter`, the code checks that the current position
    is in the pattern. If the character doesn’t match `letter`, the code checks that
    the position is not in the pattern. If a single position doesn’t match the pattern,
    the word is rejected; otherwise, the end of the word is reached, and the word
    is accepted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数遵循了之前概述的计划。对于字符串中的每个字符，如果它与`letter`匹配，代码将检查当前位置是否在模式中。如果字符不匹配`letter`，代码将检查该位置是否不在模式中。如果单个位置不匹配模式，则单词将被拒绝；否则，单词的末尾将被达到，单词将被接受。
- en: 'At this point, it occurs to me that finding the most frequent pattern will
    be easier if every word in the list contains the specified letter. So I write
    a quick function to chop out the words without the letter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我突然想到，如果列表中的每个单词都包含指定的字母，那么找到最频繁出现的模式将会更容易。因此，我快速编写了一个函数来删除不包含该字母的单词：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code is just a combination of the ideas used in the previous functions.
    Now that I think about it, I’m going to need the opposite function as well, one
    that chops out all the words that *have* the specified letter. I’ll use this to
    reduce the candidate word list when the program calls the latest guess a miss:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是之前函数中用到的想法的组合。现在我想起来，我还需要一个相反的函数，一个可以删除所有包含指定字母的单词的函数。当程序在调用最新的猜测失败时，我将使用这个函数来减少候选单词列表。
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now I’m ready to find the most frequent pattern in the word list for the given
    letter. I considered a number of approaches and picked the one that I thought
    I could most easily implement. First, I’ll use a call to the function above to
    remove all the words without the specified letter. Then, I’ll take the first word
    in the list, determine its pattern, and count how many other words in the list
    have the same pattern. All of these words will be erased from the list as I count
    them. Then the process will repeat again with whatever word is now at the head
    of the list and so on until the list is empty. The result looks like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我准备找到给定字母在单词列表中最频繁出现的模式。我考虑了多种方法，并选择了我认为最容易实现的方法。首先，我将调用上面的函数来删除所有不包含指定字母的单词。然后，我将取列表中的第一个单词，确定其模式，并计算列表中有多少其他单词具有相同的模式。在计数时，所有这些单词都将从列表中删除。然后，这个过程将再次使用现在列表头部的单词重复进行，等等，直到列表为空。结果看起来像这样：
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `list` arrives as a value parameter ![](httpatomoreillycomsourcenostarchimages1273182.png)
    because this function is going to whittle the list down to nothing during processing,
    and I don’t want to affect the parameter passed by the calling code. Note that
    `maxPattern` ![](httpatomoreillycomsourcenostarchimages1273191.png) and `maxPatternCount`
    ![](httpatomoreillycomsourcenostarchimages1273193.png) are outgoing parameters
    only; these will be used to send the most regularly occurring pattern and its
    number of occurrences back to the calling code. I remove all of the words without
    `letter` ![](httpatomoreillycomsourcenostarchimages1273195.png). Then I enter
    the main loop of the function, which continues as long as the list isn’t empty
    ![](httpatomoreillycomsourcenostarchimages1273197.png). The code inside the loop
    has three main sections. First, a `for` loop constructs the pattern for the first
    word in the list ![](httpatomoreillycomsourcenostarchimages1273203.png). Then,
    a `while` loop counts how many words in the list match that pattern ![](httpatomoreillycomsourcenostarchimages1273203.png).
    Finally, we see whether this count is greater than the highest count seen so far,
    employing the “King of the Hill” strategy first seen back in [Chapter 3](ch03.html
    "Chapter 3. Solving Problems with Arrays") ![](httpatomoreillycomsourcenostarchimages1273223.png).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`作为值参数传入![图片链接](http://atomoreilly.com/source/no_starch_images/1273182.png)，因为这个函数在处理过程中会将列表缩减为空，我不想影响调用代码传递的参数。注意，`maxPattern`![图片链接](http://atomoreilly.com/source/no_starch_images/1273191.png)和`maxPatternCount`![图片链接](http://atomoreilly.com/source/no_starch_images/1273193.png)仅作为输出参数；这些将被用来将最常出现的模式和它的出现次数发送回调用代码。我移除了所有没有`letter`![图片链接](http://atomoreilly.com/source/no_starch_images/1273195.png)的单词。然后我进入函数的主循环，只要列表不为空![图片链接](http://atomoreilly.com/source/no_starch_images/1273197.png)，循环就会继续。循环内的代码有三个主要部分。首先，一个`for`循环构建列表中第一个单词的模式![图片链接](http://atomoreilly.com/source/no_starch_images/1273203.png)。然后，一个`while`循环计算列表中有多少单词与该模式匹配![图片链接](http://atomoreilly.com/source/no_starch_images/1273203.png)。最后，我们看到这个计数是否大于迄今为止看到的最高的计数，采用“山丘之王”策略，这是在[第3章](ch03.html
    "第3章. 使用数组解决问题")![图片链接](http://atomoreilly.com/source/no_starch_images/1273223.png)中首次出现的。'
- en: 'The last utility function I should need will display all of the letters guessed
    so far. Remember that I am storing these as an array of 26 `bool` values:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要最后一个实用函数来显示迄今为止猜测的所有字母。记住，我将它们存储为一个包含26个`bool`值的数组：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that I am adding the base value of one range, in this case, the character
    `a`, to a value from another range ![](httpatomoreillycomsourcenostarchimages1273182.png),
    a technique we first employed back in [Chapter 2](ch02.html "Chapter 2. Pure Puzzles").
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在一个范围的基值（在这种情况下是字符`a`）和一个来自另一个范围的值![图片链接](http://atomoreilly.com/source/no_starch_images/1273182.png)上添加了基值，这是一种我们在[第2章](ch02.html
    "第2章. 纯拼图")中首次使用的技巧。
- en: Now I have all the key subtasks completed, and I’m ready to try solving the
    whole problem, but I have a lot of functions here that haven’t been fully tested,
    and I would like to get them tested as soon as possible. So, rather than tackle
    the rest of the problem in one step, I’m going to reduce the problem. I’ll do
    this by making some of the variables, such as the size of the puzzle word, into
    constants.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经完成了所有的关键子任务，我准备尝试解决整个问题，但我这里有很多函数还没有经过完全测试，我希望它们能尽快得到测试。所以，与其一步解决剩余的问题，我打算简化这个问题。我会通过将一些变量，比如拼图单词的大小，变成常量来实现这一点。
- en: Because I’m going to be throwing this version away, I’m comfortable with putting
    the entire game-playing logic into the `main` function. Because the result is
    lengthy, though, I’m going to present the code in stages.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我会丢弃这个版本，所以我愿意把整个游戏逻辑放入`main`函数中。尽管如此，由于结果很长，我打算分阶段展示代码。
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This first section of code sets up the constants and variables we’ll need to
    play the game. Most of this code is self-explanatory. The word list is created
    from a file ![](httpatomoreillycomsourcenostarchimages1273182.png) and then pared
    down to the specified word length, in this case, the constant value 8 ![](httpatomoreillycomsourcenostarchimages1273195.png).
    The variable `misses` ![](httpatomoreillycomsourcenostarchimages1273191.png) stores
    the number of wrong guesses by Player 2, while `discoveredLetterCount` ![](httpatomoreillycomsourcenostarchimages1273193.png)
    tracks the number of positions revealed in the word (so if *d* appears twice,
    guessing *d* increases this value by two). The `revealedWord` variable stores
    the puzzle word as currently known to Player 2, with asterisks for letters that
    have not yet been guessed ![](httpatomoreillycomsourcenostarchimages1273197.png).
    The `guessedLetters` array of `bool` ![](httpatomoreillycomsourcenostarchimages1273199.png)
    tracks the specific letters guessed so far; a loop sets all the values to `false`.
    Finally, `nextLetter` ![](httpatomoreillycomsourcenostarchimages1273203.png) stores
    the current guess of Player 2\. I output the initial `revealedWord`, and then
    I’m ready for the main game loop.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一部分设置了我们玩游戏所需的常量和变量。大部分代码都是自解释的。单词列表是从文件 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)
    中创建的，然后根据指定的单词长度进行了缩减，在这个例子中是常量值8 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273195.png)。变量`misses`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273191.png) 存储玩家2的错误猜测次数，而`discoveredLetterCount`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273193.png) 跟踪单词中已揭示的位置数（如果*d*出现两次，猜测*d*会使此值增加两）。`revealedWord`变量存储玩家2目前所知的谜题单词，未猜测的字母用星号表示
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273197.png)。`guessedLetters`数组中的`bool`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273199.png) 跟踪到目前为止猜测的特定字母；一个循环将所有值设置为`false`。最后，`nextLetter`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273203.png) 存储玩家2的当前猜测。我输出了初始的`revealedWord`，然后我就准备好进入主游戏循环了。
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are two conditions that can end the game. Either Player 2 discovers all
    of the characters in the word, so that `discoveredLetterCount` reaches `wordLength`,
    or Player 2’s bad guesses complete the hangman, in which case `misses` will equal
    `maxMisses`. So the loop continues as long as neither condition has occurred ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Inside the loop, after the next guess is read from the user, the corresponding
    position in `guessedLetters` is updated ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Then the cheating begins. The program determines how many candidates would be
    left in the word list if the guess were declared a miss using `countWordsWithoutLetter`
    ![](httpatomoreillycomsourcenostarchimages1273193.png), and it determines the
    maximum that could be left if the guess were declared a hit using `mostFreqPatternByLetter`
    ![](httpatomoreillycomsourcenostarchimages1273195.png). If the former is larger,
    the words with the guessed letter are culled and `misses` is incremented ![](httpatomoreillycomsourcenostarchimages1273197.png).
    If the latter is larger, we’ll take the pattern given by `mostFreqPatternByLetter`
    and update `revealedWord`, while also removing all words from the list that don’t
    match the pattern ![](httpatomoreillycomsourcenostarchimages1273199.png).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束有两种条件。要么玩家2发现了单词中的所有字符，使得`discoveredLetterCount`达到`wordLength`，要么玩家2的错误猜测完成了吊死人的游戏，在这种情况下`misses`将等于`maxMisses`。因此，只要这两个条件中的任何一个没有发生，循环就会继续
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)。在循环内部，在从用户那里读取下一个猜测之后，`guessedLetters`中的相应位置会被更新
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273191.png)。然后就开始作弊了。程序会确定如果猜测被宣布为失误，单词列表中会剩下多少候选词，使用`countWordsWithoutLetter`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273193.png)，并且确定如果猜测被宣布为命中，最多会剩下多少，使用`mostFreqPatternByLetter`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273195.png)。如果前者更大，就会淘汰包含猜测字母的单词，并将`misses`增加
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273197.png)。如果后者更大，我们会采用`mostFreqPatternByLetter`给出的模式，并更新`revealedWord`，同时从列表中移除所有不匹配该模式的单词
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273199.png)。
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The remainder of the code is what I call a *loop postmortem*, where the post-loop
    action is determined by the condition that “killed” the loop. Here, either our
    program successfully cheated its way to a victory or Player 2, against all odds,
    forced the program to reveal the entire word. Note that when the program wins,
    at least one word must remain in the list, so I just display the first word ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and claim that was the one I was thinking of all along. A more devious program
    might randomly select one of the remaining words to reduce the chance of the opponent
    detecting the cheating.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分是我所说的“循环后事分析”，其中循环后的动作由“杀死”循环的条件决定。在这里，要么我们的程序成功地欺骗了胜利，要么玩家2在所有不利的情况下迫使程序揭示整个单词。请注意，当程序获胜时，列表中至少必须保留一个单词，所以我只显示第一个单词
    ![更多](http://atomoreilly.com/source/no_starch_images/1273182.png) 并声称这是我一直在想的。一个更狡猾的程序可能会随机选择剩余单词中的一个，以减少对手发现作弊的机会。
- en: Analysis of Initial Results
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始结果分析
- en: I’ve put all this code together and tested it, and it works, but clearly there
    are a lot of improvements to be made. Beyond any design considerations, the program
    is missing a lot of functionality. It doesn’t allow the user to specify the size
    of the puzzle word or the number of allowable wrong guesses. It doesn’t check
    to see whether the guessed letter has been guessed before. For that matter, it
    doesn’t even check that the input character is a lowercase letter. It’s missing
    a lot of interface pleasantries, like telling the user how many more misses are
    available. I think it would also be nice if the program could offer to play again,
    rather than making the user re-run the program.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经把这些代码组合起来并测试了，它确实工作，但显然还有很多改进的空间。除了任何设计考虑之外，程序缺少很多功能。它不允许用户指定谜题单词的大小或允许的错误猜测次数。它不检查猜测的字母是否已经被猜测过。就这一点而言，它甚至不检查输入字符是否是小写字母。它缺少很多界面上的礼貌，比如告诉用户还有多少次未命中。我认为如果程序能提供再次玩的机会，而不是让用户重新运行程序，那也会很好。
- en: As for the design, when I begin to think about the finished version of the program,
    I’m going to seriously consider an object-oriented design. A `wordlist` class
    now seems like a natural choice. The main function looks too large to me. I like
    a modular, easy-to-maintain design, and that should result in a main function
    that is short and merely directs traffic among the subprograms that do the real
    work. So my main function needs to be broken up into several functions. Some of
    my initial design choices might need rethinking. For example, in hindsight, storing
    patterns as `list<int>` looks cumbersome. Perhaps I could try an array of `bool`,
    in a manner analogous to `guessedLetters`?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设计，当我开始思考程序的最终版本时，我会认真考虑面向对象的设计。现在看起来`wordlist`类似乎是一个自然的选择。在我看来，主函数看起来太大。我喜欢模块化、易于维护的设计，这应该会导致一个短小且仅指导子程序之间交通的主函数。因此，我的主函数需要分解成几个函数。我的一些初始设计选择可能需要重新思考。例如，事后看来，将模式存储为`list<int>`看起来很繁琐。也许我可以尝试一个`bool`数组，类似于`guessedLetters`？
- en: Or perhaps I should look for another structure entirely. Now is also the time
    for me to step back to see whether there are any opportunities to learn new techniques
    in solving this problem. I’m wondering whether there are specialized data structures
    that I have not yet considered that could be helpful. Even if I end up sticking
    with my original choices, I could learn a lot from the investigation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许我应该寻找另一种完全不同的结构。现在也是我退后一步看看是否有机会学习解决这个问题的新的技术的时候了。我在想是否有我尚未考虑的专门的数据结构可能是有帮助的。即使我最终坚持我的原始选择，我也可以从调查中学习很多。
- en: Though all of these decisions are still looming, I feel like I’m well on my
    way with this project. Having a working program that meets the essential requirements
    of the problem is a great place to be. I can easily experiment with the different
    design ideas in this rough version, with the confidence that comes from knowing
    I already have a solution, and I’m only looking for a better solution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些决定仍然悬而未决，但我感觉我在这个项目上已经取得了很大的进展。拥有一个满足问题基本要求的可工作程序是一个很好的起点。我可以轻松地在这个粗糙版本中尝试不同的设计想法，因为我已经知道我有一个解决方案，我只是在寻找更好的解决方案。
- en: CREATE A RESTORE POINT
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个恢复点
- en: The Microsoft Windows operating system creates what it calls a *restore point*
    before installing or modifying system components. The restore point contains backup
    copies of key files, such as the registry. If an installation or update results
    in a serious problem, it can effectively be “rolled back,” or undone by copying
    back the files from the restore point.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Windows操作系统在安装或修改系统组件之前会创建它所说的*恢复点*。恢复点包含关键文件的备份副本，例如注册表。如果安装或更新导致严重问题，可以通过从恢复点复制文件来有效地“回滚”或撤销。
- en: I highly recommend taking the same approach with your own source code. When
    you have a working program that you expect to later modify, make a copy of the
    entire project, and modify only the copy. It’s quick to do and can save you considerable
    time later if your modifications go awry. Programmers can easily fall into the
    trap of thinking, “I accomplished this once; therefore, I can do it again.” That’s
    usually true, but there’s a big difference between knowing that you can do something
    again and being able to bring up the old source code for instant reference.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你对自己的源代码采取同样的方法。当你有一个你预期以后要修改的工作程序时，复制整个项目，只修改副本。这样做很快，如果你的修改出了问题，可以节省你大量的时间。程序员很容易陷入这样的陷阱，认为：“我完成过这个；因此，我可以再次完成它。”这通常是正确的，但知道你可以再次做某事和能够立即引用旧源代码之间有很大的区别。
- en: You can also use *version control software*, which automates the copying and
    storage of project files. Version control software performs more than the “restore
    point” function; it also may allow multiple programmers to work independently
    on the same files, for example. While such tools are beyond the scope of this
    book, they’re something you should investigate as you develop as a programmer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用*版本控制软件*，它自动复制和存储项目文件。版本控制软件的功能不仅限于“恢复点”功能；它还可能允许多个程序员独立地在同一文件上工作，例如。虽然这些工具超出了本书的范围，但作为程序员的发展过程中，你应该调查这些工具。
- en: The Art of Problem Solving
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题解决的艺术
- en: Did you recognize all the problem-solving techniques I employed in my solution
    so far? I had a plan for solving the problem. As always, this is the most crucial
    of all problem-solving techniques. I decided to start with what I knew for the
    first version of my solution, employing a couple of data structures with which
    I was very familiar, arrays and the `list` class. I reduced the functionality
    to make it easier to write my rough-and-ready version and to allow me to test
    my code earlier than I could otherwise. I divided the problem into operations
    and made each operation a different function, allowing me to work on pieces of
    the program separately. When I was unsure how to cheat, I experimented, allowing
    me to restate “cheating” as “maximizing the size of the candidate word list,”
    which was a concrete concept for me to code. In the particulars of coding the
    operations, I employed techniques analogous to those used throughout this book.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否认识到了我在迄今为止的解决方案中使用的所有问题解决技巧？我有一个解决问题的计划。一如既往，这是所有问题解决技巧中最关键的。我决定从我的解决方案的第一版开始，使用我非常熟悉的一些数据结构，即数组和`list`类。我将功能简化，以便更容易编写我的草稿版本，并允许我比其他情况下更早地测试我的代码。我将问题分解为操作，并将每个操作变成一个不同的函数，这样我可以单独处理程序的各个部分。当我不确定如何作弊时，我会进行实验，这样我可以将“作弊”重新定义为“最大化候选单词列表的大小”，这对我来说是一个具体的编码概念。在具体编码操作时，我使用了本书中使用的类似技术。
- en: I also successfully avoided getting frustrated, although I suppose you’ll have
    to take my word for that.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我也成功地避免了感到沮丧，尽管我想你可能得相信我的话。
- en: Before we move on, let me be clear that I have demonstrated the steps *I* took
    to get to this stage in the process of solving this problem. These are not necessarily
    the same steps you would take to solve this problem. The code shown above is not
    the best solution to the problem and is not necessarily better than what you would
    come up with. What I hope it demonstrates is that any problem, no matter the size,
    can be solved using variations of the same basic techniques used throughout this
    book. If you were tackling a problem twice as large as this one, or 10 times as
    large, it might test your patience, but you could solve it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我明确一点，我已经展示了我在解决这个问题的过程中所采取的步骤**我**达到这个阶段。这些步骤不一定是你解决这个问题的步骤。上面显示的代码并不是解决问题的最佳方案，也不一定比你想到的方案更好。我希望它展示的是，任何问题，无论大小，都可以使用本书中贯穿始终的基本技术的变体来解决。如果你面临的是一个比这个大两倍或十倍的问题，这可能会考验你的耐心，但你仍然可以解决它。
- en: Learning New Programming Skills
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习新的编程技能
- en: There’s one more topic to discuss. In mastering the problem-solving techniques
    of this book, you are taking the key step down the road of life as a programmer.
    However, as with most professions, this is a road without a destination, for you
    must always be striving to better yourself as a programmer. As with everything
    else in programming, you should have a plan for how you will learn new skills
    and techniques, rather than just trusting that you will pick up new things here
    and there along the way.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个话题需要讨论。在掌握本书的问题解决技巧的过程中，你正在走上程序员生涯的关键一步。然而，与大多数职业一样，这是一条没有终点的路，因为你必须始终努力成为一个更好的程序员。与编程中的其他一切一样，你应该有一个计划，说明你将如何学习新的技能和技术，而不仅仅是相信你会在路上点点滴滴地学到新东西。
- en: In this section, we’ll discuss some of the areas in which you may want to acquire
    new skills and some systematic approaches for each. The common thread running
    through all of the areas is that you must put what you want to learn into practice.
    That’s why each chapter in this book ends with exercises—and you have been working
    through those exercises, right? To read about new ideas in programming is a vital
    first step in actually learning them, but it is only the first step. To reach
    the point where you can confidently employ a new technique in the solution for
    a real-world problem, you should first try out the technique in a smaller, synthetic
    problem. Remember that one of our basic problem-solving techniques is to break
    complex problems down, by either dividing the problem or temporarily reducing
    the problem so that each state we’re dealing with has just one nontrivial element.
    You don’t want to try to solve a nontrivial problem at the same time that you’re
    learning the skill that will be central to your solution because then your attention
    will be divided between two difficult problems.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论你可能想要掌握的新技能的一些领域，以及每个领域的系统方法。贯穿所有这些领域的共同线索是，你必须将你想要学习的内容付诸实践。这就是为什么本书的每一章都以练习结束——你一直在做这些练习，对吧？阅读有关编程的新思想是真正学习它们的必要第一步，但仅仅是一步。为了达到能够自信地在一个现实世界问题的解决方案中应用新技术的水平，你应该首先在一个较小的、合成的练习中尝试这个技术。记住，我们基本的问题解决技术之一是将复杂问题分解，通过分割问题或暂时减少问题，使得我们处理的每个状态只有一个非平凡元素。你不想在学习将是你解决方案核心的技能的同时尝试解决一个非平凡问题，因为那样你的注意力将分散在两个困难的问题上。
- en: New Languages
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的语言
- en: I think C++ is a great programming language for production code, and I explained
    in the first chapter why I think it’s also a great language to learn with. That
    said, no programming language is superior in all situations; therefore, good programmers
    must learn several.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为C++是一种非常适合生产代码的编程语言，我在第一章中解释了为什么我认为它也是一种非常适合学习的语言。话虽如此，没有一种编程语言在所有情况下都是优越的；因此，优秀的程序员必须学习几种。
- en: Take the Time to Learn
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投资时间学习
- en: 'Whenever possible, you should give yourself time to study a new language before
    attempting to write production code with one. If you attempt to solve a nontrivial
    problem in the language you have never used before, you are quickly going to run
    counter to an important problem-solving rule: Avoid frustration. Set yourself
    the task of learning a language, and complete the task before you assign yourself
    any “real” programs in that language.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，你应该在尝试用一种新语言编写生产代码之前给自己留出时间来学习这种新语言。如果你尝试解决一个你从未使用过的语言中的非平凡问题，你很快就会违反一个重要的解决问题的规则：避免挫败感。给自己设定一个学习一种语言的任务，并在你给自己分配任何“真实”程序之前完成这个任务。
- en: Of course, in the real world, sometimes we are not completely in control of
    when we are assigned projects. At any moment, someone could request that we write
    a program in a particular language, and that request could be accompanied by a
    deadline that would prevent us from leisurely studying the language before tackling
    the actual problem. The best defense against encountering this situation is to
    begin studying other programming languages *before* you are absolutely required
    to know them. Investigate languages that interest you or that are used for areas
    in which you expect to program during your career. This is another situation in
    which an activity that seems like a poor use of time in the short term will pay
    large dividends in the long term. Even if it turns out that you don’t require
    the language you have studied in the near future, studying another language can
    improve your skills with the other languages you already know because it forces
    you to think in new and different ways, breaking you out of old habits and giving
    you fresh perspectives on your skills and techniques. Think of it as the programming
    equivalent of cross-training.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实世界中，有时我们并不完全控制我们被分配项目的时间。在任何时候，都可能有人要求我们用特定的语言编写程序，并且这个请求可能伴随着一个截止日期，这将阻止我们在解决实际问题之前悠闲地学习这种语言。最好的防御措施是在你绝对需要知道它们之前就开始学习其他编程语言。调查那些引起你兴趣的语言或那些你预期在职业生涯中编程的领域的语言。这是另一种情况，在短期内看似浪费时间的行为，在长期内会带来巨大的回报。即使最终你不需要你近期学习过的语言，学习另一种语言也可以提高你对其他已知语言的技能，因为它迫使你以新的和不同的方式思考，帮助你摆脱旧习惯，并从新的角度看待你的技能和技术。把它看作是编程的交叉训练。
- en: Start with What You Know
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从你所知开始
- en: When you begin learning a new programming language, by definition you know nothing
    about it. If it’s not your first programming language, though, you do know a lot
    about programming. So a good first step in learning a new language is to understand
    how code that you already know how to write in another language can be written
    in the new language.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始学习一种新的编程语言时，按照定义，你对它一无所知。如果你不是第一次学习编程语言，那么你对编程的了解就很多了。因此，学习新语言的一个好步骤是理解你已经在另一种语言中知道如何编写的代码如何在新的语言中编写。
- en: As stated before, you want to learn this by doing, not just by reading. Take
    programs you have written in other languages, and rewrite them in the new language.
    Systematically investigate individual language elements, such as control statements,
    classes, other data structures, and so on. The goal is to transfer as much of
    your previous knowledge as possible to the new language.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你想要通过实践来学习，而不仅仅是通过阅读。将你在其他语言中编写的程序重写在新语言中。系统地调查单个语言元素，例如控制语句、类、其他数据结构等。目标是尽可能地将你之前的知识转移到新语言中。
- en: Investigate What’s Different
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调查不同之处
- en: The next step is to study what is different about the new language. While two
    high-level programming languages may have extensive similarities, *something*
    must be different with the new language, or there would be no reason to choose
    this language over any other. Again, learn by doing. Just reading, for example,
    that a language’s multiple-selection statement allows ranges (instead of the individual
    values of a C++ `switch` statement) isn’t as helpful to your development as actually
    writing code that meaningfully employs the capability.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是研究新语言的不同之处。虽然两种高级编程语言可能有很多相似之处，但新语言中**肯定**有一些不同之处，否则就没有理由选择这种语言而不是其他语言。再次强调，通过实践来学习。例如，仅仅阅读一个语言的多个选择语句允许范围（而不是C++
    `switch`语句的单独值）并不如实际编写代码来有意义地使用这种能力对你有所帮助。
- en: 'This step is obviously important for languages that are noticeably dissimilar
    but is equally important for languages that have a common ancestor, such as C++,
    C#, and Java, which are all object-oriented descendents of C. Syntax similarities
    can trick you into believing you know more about the new language than you really
    do. Consider the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步对于明显不同的语言来说显然很重要，但对于有共同祖先的语言来说同样重要，例如C++、C#和Java，它们都是C的面向对象的后代。语法相似性可能会让你误以为你对新语言了解得比你实际了解的要多。考虑以下代码：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If these lines were presented to you as C++ code, you would understand that
    the first line constructed an object, `numberList`, of a class, `integerListClass`,
    and the second line invoked an `addInteger` method on that object. If that class
    actually exists and has a method of that name that takes an `int` parameter, this
    code makes perfect sense. Now suppose I told you this code had been written in
    Java, not C++. Syntactically, there is nothing illegal about these two lines.
    However, in Java, a mere variable declaration of a class object does not actually
    construct the object because object variables are actually references—that is,
    they behave in a manner analogous to pointers. To perform the equivalent steps
    in Java, the correct code would be:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些行被展示给你作为C++代码，你会理解第一行创建了一个名为`numberList`的对象，属于`integerListClass`类，而第二行在对象上调用了一个`addInteger`方法。如果这个类实际上存在并且有一个同名的方法接受`int`参数，那么这段代码是完美的。现在假设我告诉你这段代码是用Java而不是C++编写的。从语法上讲，这两行没有非法之处。然而，在Java中，仅仅声明一个类对象并不实际构造对象，因为对象变量实际上是引用——也就是说，它们的行为类似于指针。要在Java中执行等效步骤，正确的代码将是：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You would likely catch on to this particular difference between Java and C++
    quickly, but many other differences could be quite subtle. If you don’t take the
    time to discover them, they can make debugging very difficult in the new language.
    As you scan your code, your internal programming language interpreter will be
    feeding you incorrect information about what you are reading.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会很快注意到Java和C++之间的这个特定差异，但许多其他差异可能相当微妙。如果你不花时间去发现它们，它们会在新语言中使调试变得非常困难。当你扫描代码时，你的内部编程语言解释器会给你提供关于你所阅读内容的错误信息。
- en: Study Well-Written Code
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 研究编写良好的代码
- en: I’ve made a point throughout this book that you shouldn’t try to learn programming
    by taking someone else’s code and modifying it. There are times, however, when
    the study of someone else’s code is vital. While you can build up your skills
    in a new language by writing a series of original programs, to reach a level of
    mastery, you will want to seek out code written by a programmer skilled in that
    language.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中一直强调，你不应该通过修改别人的代码来学习编程。然而，有时候研究别人的代码是至关重要的。虽然你可以通过编写一系列原创程序来提高你在新语言中的技能，但要达到精通的水平，你将需要寻找由精通该语言的程序员编写的代码。
- en: You’re not looking to “crib” this code; you’re not going to borrow this code
    to solve a specific problem. Instead, you’re looking at existing code to discover
    the “best practices” in that language. Look at an expert programmer’s code and
    ask yourself not just *what* the programmer is doing but *why* the programmer
    is doing it. If the code is accompanied by the programmer’s explanations, all
    the better. Differentiate between style choices and benefits to performance. By
    completing this step, you will avoid a common pitfall. Too often, programmers
    will learn just enough in a new language to survive, and the result is weak code
    that doesn’t use all of the features of the language. If you are a C++ programmer
    required to write code in Java, for example, you don’t want to settle for writing
    code in pidgin C++; instead, you want to learn to write actual Java code the way
    a Java programmer would.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是在寻找“抄袭”这段代码；你不是要借用这段代码来解决特定问题。相反，你是在查看现有代码，以发现该语言的“最佳实践”。看看专家程序员的代码，并问问自己，程序员不仅在做**什么**，而且在做**为什么**。如果代码附有程序员的解释，那就更好了。区分风格选择和性能优势。通过完成这一步，你将避免一个常见的陷阱。程序员往往只学会足够的新语言知识来生存，结果是代码薄弱，没有使用语言的所有功能。例如，如果你是一个需要用Java编写代码的C++程序员，你不想满足于用pidgin
    C++编写代码；相反，你想要学会像Java程序员一样编写实际的Java代码。
- en: As with everything else, put what you learn into practice. Take the original
    code and modify it to do something new. Put the code out of sight and try to reproduce
    it. The goal is to become comfortable enough with the code that you could answer
    questions about it from another programmer.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他所有事情一样，将你学到的知识付诸实践。将原始代码修改成做些新的事情。将代码放在一边，尝试重新生成它。目标是让你对代码足够熟悉，以至于你可以回答其他程序员关于它的问题。
- en: It’s important to emphasize that this step comes after the others. Before we
    reach the stage of studying someone else’s code in a new language, we have already
    learned the syntax and grammar of the new language and applied the problem-solving
    skills we learned in another language to the new language. If we try to shorten
    the process by starting the study of the new language with the study of long program
    samples and the modification of those samples, there’s a real risk that that’s
    all we’ll ever be able to do.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，这一步骤是在其他步骤之后进行的。在我们达到在新的语言中研究他人代码的阶段之前，我们已经在新的语言中学习了语法和语法，并将我们在另一种语言中学到的解决问题的技能应用到新的语言中。如果我们试图通过从研究长程序样本和修改这些样本开始学习新的语言来缩短这个过程，那么我们真的有风险只能做到这一点。
- en: New Skills for a Language You Already Know
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知语言的新技能
- en: Just because you reach the point where you can say that you “know” a language,
    doesn’t mean you know everything about that language. Even once you have mastered
    the syntax of the language, there will always be new ways to combine existing
    language features to solve problems. Most of these new ways will fall under one
    of the “component” headings of the previous chapter, in which we discussed how
    to build component knowledge. The important factor is effort. Once you get good
    at solving problems in certain ways, it’s easy to rely on what you already know
    and cease growing as a programmer. At that point, you’re like a baseball pitcher
    who throws a mean fastball but doesn’t know how to throw anything else. Some pitchers
    have had successful professional careers with only one pitch, but the pitcher
    who wants to go from being a reliever to a starter needs more.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 只因为你达到了可以说你“知道”一门语言的程度，并不意味着你了解这门语言的所有内容。即使你已经掌握了这门语言的语法，也总会有新的方法来组合现有的语言特性以解决问题。这些新方法中的大多数都将属于前一章中提到的“组件”标题下的某个类别，我们在其中讨论了如何构建组件知识。重要的因素是努力。一旦你擅长以某种方式解决问题，就很容易依赖你已经知道的知识，停止作为程序员的成长。到了那个阶段，你就像一个只会投掷强力快球的棒球投手，却不知道如何投掷其他类型的球。有些投手只凭借一个球就能在职业生涯中取得成功，但那些想要从替补投手转变为首发投手的投手则需要更多。
- en: To be the best programmer you can be, you need to seek new knowledge and new
    techniques and put them into practice. Look for challenges and overcome them.
    Investigate the work of expert programmers of your chosen languages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为最好的程序员，你需要寻求新的知识和新的技术，并将它们付诸实践。寻找挑战并克服它们。研究你选择的语言的专家程序员的成果。
- en: Remember that necessity is the mother of invention. Seek out problems that cannot
    satisfactorily be solved with your current skill set. Sometimes you can modify
    problems you have already solved to provide new challenges. For example, you may
    have written a program that works fine when the data set is small, but what happens
    when you allow the data to grow to gargantuan proportions? Or what if you have
    written a program that stores its data on the local hard drive, but you wanted
    the data to be stored remotely? What if you need multiple executions of the program
    that could access and update the remote data concurrently? By starting with a
    working program and adding new functionality, you can focus on just the new aspects
    of the programming.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，需求是发明之母。寻找那些无法用你当前技能集满意解决的问题。有时你可以修改你已经解决的问题，以提供新的挑战。例如，你可能已经编写了一个当数据集较小时运行良好的程序，但当你允许数据增长到巨无霸规模时会发生什么？或者如果你已经编写了一个将数据存储在本地硬盘上的程序，但你希望数据被远程存储呢？或者当你需要程序的多重执行，这些执行可以同时访问和更新远程数据时会发生什么？通过从工作程序开始并添加新功能，你可以专注于编程的新方面。
- en: New Libraries
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的库
- en: Modern programming languages are inseparable from their core libraries. When
    you learn C++, you’ll inevitably learn something about the standard template libraries,
    for example, and when you study Java, you will learn about standard Java classes.
    Beyond the libraries bundled with the language, though, you’ll need to study third-party
    libraries. Sometimes these are general application frameworks, such as Microsoft’s
    .NET framework, that can be used with several different high-level languages.
    In other cases, the library is specific to a particular area, like OpenGL for
    graphics, or is part of a third-party proprietary software package.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程语言与它们的内核库密不可分。当你学习C++时，你不可避免地会了解一些关于标准模板库的知识，例如，当你学习Java时，你会了解标准Java类。然而，除了语言捆绑的库之外，你还需要学习第三方库。有时这些是通用应用程序框架，如微软的.NET框架，它可以与几种不同的高级语言一起使用。在其他情况下，库是特定于某个特定领域的，如OpenGL用于图形，或者它是第三方专有软件包的一部分。
- en: As with learning a new language, you should not try to learn a new library during
    a major project that requires that library. Instead, learn the main components
    of the library separately in a test project of zero importance before employing
    them in a real project. Assign yourself a progression of increasingly difficult
    problems to solve. Remember that the goal is not necessarily to complete any of
    those problems, only to learn from the process, so you don’t need to polish the
    solutions or even complete them once you have successfully employed that part
    of the library in your program. These programs can then serve as references for
    later work. When you find yourself stuck because you’re unable to remember how
    to, let’s say, superimpose a 2D display over a 3D scene in OpenGL, there’s nothing
    better than being able to open up an old program that was created just to demonstrates
    that very technique and is written in your own style because it was written by
    you.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就像学习一门新语言一样，你不应该在需要该库的重大项目中学习一个新的库。相反，在将它们用于实际项目之前，你应该在一个零重要性的测试项目中单独学习库的主要组件。为自己设定一个越来越困难的解决问题的进度。记住，目标不一定是要完成任何这些问题，而是要从过程中学习，因此你不需要完善解决方案，甚至在你成功将库的这部分应用于你的程序后，也不需要完成它们。这些程序可以作为以后工作的参考。当你发现自己因为无法记住如何，比如说，在OpenGL中将2D显示叠加到3D场景中而陷入困境时，没有什么比打开一个专门为了演示那种技术而创建的旧程序更好了，因为这个程序是用你自己的风格编写的，因为它是由你编写的。
- en: Also, as with learning a new language, once you are comfortable with the basics
    of a library, you should review the code written by experts in the use of that
    library. Most large libraries have idiosyncrasies and caveats that aren’t exposed
    by the official documentation and that, outside of long experience, can only be
    discovered from other programmers. In truth, to make much headway with some libraries
    requires the initial use of a framework provided by another programmer. The important
    thing is not to rely on others’ code any more than you have to and to quickly
    get to the stage where you re-create the code you were originally shown. You might
    be surprised how much you learn from the process of re-creating someone else’s
    existing code. You may see a call to a library function in the original code and
    understand that the arguments passed in this call produce a certain result. When
    you set that code aside, though, and try to reproduce that effect on your own,
    you’ll be forced to investigate the function’s documentation, all the particular
    values the arguments could take, and why they have to be what they are to get
    the desired effect.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像学习一门新语言一样，一旦你熟悉了一个库的基本用法，你应该回顾一下那些在该库使用方面有经验的专家所编写的代码。大多数大型库都有一些官方文档没有暴露的特性和注意事项，这些只有在长期经验中才能从其他程序员那里发现。实际上，要深入理解某些库，可能需要使用其他程序员提供的框架。重要的是不要过度依赖他人的代码，而应尽快达到重新创建最初展示给你的代码的阶段。你可能会惊讶于从重新创建他人现有代码的过程中学到了多少东西。你可能会在原始代码中看到对库函数的调用，并理解这个调用中传递的参数产生了某种结果。然而，当你把这段代码放一边，并试图在自己的程序中重现那种效果时，你将不得不调查该函数的文档、所有可能的参数值以及为什么它们必须是这样的才能得到期望的效果。
- en: Take a Class
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上课
- en: As a longtime educator, I feel I have to conclude this section by talking about
    classes—not in the object-oriented programming sense, but in the sense of a course
    at a school. Whatever area of programming you want to learn about, you’ll find
    someone offering to teach you, whether in a traditional classroom or in some online
    environment. However, a class is a catalyst for learning, not the learning itself,
    especially in an area like programming. No matter how knowledgeable or enthusiastic
    a programming instructor is, when you actually learn new programming abilities,
    it will happen as you’re sitting in front of your computer, not as you’re sitting
    in a lecture hall. As I reiterate throughout this book, you have to put programming
    ideas into practice, and you have to make them your own to truly learn them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名长期的教育工作者，我觉得我必须通过谈论课程来结束这一部分——不是在面向对象编程的意义上，而是在学校课程的意义上。无论你想学习编程的哪个领域，你都会找到有人愿意教你，无论是在传统的教室里还是在某种在线环境中。然而，课程是学习的催化剂，而不是学习本身，尤其是在编程这样的领域。无论编程讲师多么博学或热情，当你真正学习新的编程技能时，这将在你坐在电脑前发生，而不是你坐在讲堂里。正如我在整本书中反复强调的那样，你必须将编程思想付诸实践，你必须使它们成为你自己的，才能真正学会它们。
- en: This isn’t to suggest that classes have no value—because they often have tremendous
    value. Some concepts in programming are inherently difficult or confusing, and
    if you have access to an instructor with a talent for explaining difficult concepts,
    that may save you loads of time and frustration. Also, classes provide an evaluation
    of your learning. If you are again fortunate with your instructor, you may learn
    much from the evaluation of your code, which would streamline the learning process.
    Finally, the successful completion of a class provides some evidence to current
    or future employers that you understand the subjects taught (if you are unfortunate
    and have a poor instructor, you can at least take solace in that).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说课程没有价值——因为它们通常具有巨大的价值。编程中的一些概念本质上是难以理解或令人困惑的，如果你有机会接触到擅长解释复杂概念的讲师，这可能为你节省大量时间和挫折。此外，课程提供了对你学习的评估。如果你有幸遇到一位优秀的讲师，你可能可以从对你的代码的评估中学到很多东西，这将简化学习过程。最后，课程的顺利完成为当前或未来的雇主提供了一些证据，表明你理解所教授的主题（如果你不幸遇到一位糟糕的讲师，你至少可以从中得到安慰）。
- en: Just remember that your programming education is your responsibility, even when
    you take a class. A course will provide a framework for acquiring a grade and
    credit at the end of the term, but that framework doesn’t limit you in your learning.
    Think of your time in the class as a great opportunity to learn as much about
    the subject as possible, beyond any objectives listed in the course syllabus.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，你的编程教育是你的责任，即使你参加了一门课程。课程会提供一个框架，让你在学期结束时获得成绩和学分，但这个框架并不限制你的学习。把你在课堂上的时间看作是一个极好的机会，尽可能多地了解这门学科，而不仅仅是课程大纲中列出的任何目标。
- en: Conclusion
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: I fondly remember my first programming experience. I wrote a short, text-based
    simulation of a pinball machine, and no, that doesn’t make any sense to me either,
    but it must have at the time. I didn’t own a computer then—who did in 1976?—but
    at my father’s office was a teletype terminal, essentially an enormous dot-matrix
    printer with a click-clack keyboard, that communicated with the mainframe at the
    local university via acoustic modem. (You picked up the phone to dial by hand,
    and when you heard electronic screaming, you dropped the handset into a special
    cradle connected to the terminal.) As primitive and pointless as my pinball simulation
    was, the moment the program worked and the computer was acting under my instructions,
    I was hooked.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我深情地回忆起我的第一次编程经历。我编写了一个简短的基于文本的弹球机模拟，不，这对我来说也没有什么意义，但当时肯定有。那时我并没有电脑——1976年谁有呢？——但在我的父亲的办公室里有一台电传打字机终端，本质上是一个巨大的点阵打印机，带有咔哒咔哒的键盘，通过声学调制解调器与当地大学的计算机主机通信。（你用手拨打电话，当你听到电子尖叫时，你就把听筒放入连接到终端的特殊托架上。）尽管我的弹球机模拟既原始又无意义，但当程序运行起来，计算机按照我的指令行动时，我就上瘾了。
- en: The feeling I had that day—that a computer was like an infinite pile of Legos,
    Erector Sets, and Lincoln Logs, all for me to build anything I could imagine—is
    what drives my love of programming. When my development environment announces
    a clean build and my fingers reach for the keystroke that will begin execution
    of my program, I’m always excited, in anticipation of success or failure, and
    anxious to see the results of my efforts, whether I am writing a simple test project
    or putting the finishing touches on a large solution, or whether I am creating
    beautiful graphics or just constructing the front end of a database application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 那天我有的感觉——一台计算机就像一个无限的乐高积木堆、Erector Sets和林肯积木，所有这些都可以用来构建我能想象到的一切——这就是推动我对编程热爱的原因。当我的开发环境宣布构建成功，我的手指触摸到按键开始执行我的程序时，我总是既兴奋又焦虑，期待着成功或失败的结果，渴望看到我的努力成果，无论是编写一个简单的测试项目，还是在大型解决方案上完成最后的润色，或者我是在创建美丽的图形，还是在构建数据库应用程序的前端。
- en: I hope you have similar feelings when you program. Even if you are still struggling
    with some of the areas covered in this book, I hope you now understand that as
    long as programming excites you so much that you always want to stick with it,
    there is no problem you can’t solve. All that is required is the willingness to
    put in the effort and to go about the process the right way. Time takes care of
    the rest.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在编程时也有类似的感受。即使你还在这本书涵盖的一些领域挣扎，我也希望你现在明白，只要编程让你如此兴奋，你总是想坚持下去，就没有你解决不了的问题。所需要的只是愿意付出努力，并且以正确的方式处理这个过程。时间会解决剩下的问题。
- en: 'Are you thinking like a programmer yet? If you’ve solved the exercises at the
    ends of these chapters, then you should be thinking like a programmer and be confident
    in your problem-solving ability. If you haven’t solved many of the exercises,
    then I have a suggestion for you, and I’ll bet you can guess what it is: Solve
    more exercises. If you’ve skipped some in previous chapters, don’t start with
    the exercises in this chapter—go back to where you left off, and work your way
    forward from there. If you don’t want to do more exercises because you don’t enjoy
    programming, then I can’t help you.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否已经像程序员一样思考了？如果你已经解决了这些章节末尾的练习题，那么你应该像程序员一样思考，并且对自己的问题解决能力有信心。如果你没有解决很多练习题，那么我有一个建议给你，我敢打赌你能猜到是什么：解决更多的练习题。如果你在之前的章节中跳过了一些练习，不要从这一章的练习开始——回到你停止的地方，从那里继续前进。如果你不想做更多的练习，因为你不喜欢编程，那么我帮不上忙。
- en: Once you are thinking like a programmer, be proud of your skills. If someone
    calls you a coder rather than a programmer, say that a well-trained bird could
    be taught to peck out code—you don’t just write code, you use code to solve problems.
    When you’re sitting across an interview table from a future employer or client,
    you’ll know that whatever the job requires, you can figure it out.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始像程序员一样思考，就为你的技能感到自豪。如果有人称你为码农而不是程序员，可以说一个受过良好训练的鸟儿可以被训练出来敲代码——你不仅仅是写代码，你使用代码来解决问题。当你坐在面试桌对面，面对未来的雇主或客户时，你会知道无论工作需要什么，你都能找到解决办法。
- en: Exercises
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: You had to know that there would be one last set of exercises. These are, of
    course, tougher and more open-ended than any from previous chapters.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定知道会有最后一组练习。当然，这些练习比之前章节中的任何练习都更具挑战性和开放性。
- en: Write a complete implementation for the cheating hangman problem that’s better
    than mine.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为作弊猜字游戏问题编写一个比我的更好的完整实现。
- en: Expand your hangman program so that the user can choose to be Player 1\. The
    user still selects the number of letters in the word and the number of missed
    guesses, but the program does the guessing.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展你的猜字游戏程序，让用户可以选择成为玩家1。用户仍然可以选择单词中的字母数量和未猜中的猜测次数，但程序负责猜测。
- en: Rewrite your hangman program in another language, one that you currently know
    little or nothing about.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的猜字游戏程序用另一种你目前几乎一无所知或知之甚少的语言重写。
- en: Make your hangman game graphical, actually displaying the gallows and the hangman
    as he is being constructed. You’re trying to think like a programmer, not like
    an artist, so don’t worry about the quality of the art. You must make an actual
    graphical program, though. Don’t draw the hangman using ASCII text—that’s too
    easy. You might want to investigate 2D graphics libraries for C++ or choose a
    different platform that’s more graphically oriented to begin with, like Flash.
    Having a graphical hangman might require constraining the number of wrong guesses,
    but there may be a way to offer at least a range of choices for this number.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使你的“猜字谜”游戏具有图形化，实际上显示绞刑架和正在被建造的绞刑犯。你试图像程序员一样思考，而不是像艺术家一样，所以不要担心艺术的质量。你必须制作一个真正的图形程序。不要用ASCII文本绘制绞刑犯——那太简单了。你可能想调查C++的2D图形库，或者选择一个一开始就更具图形导向的平台，比如Flash。拥有一个图形化的“猜字谜”可能需要限制错误猜测的数量，但可能有一种方法可以至少提供这个数字的选择范围。
- en: 'Design your own exercise: Employ the skills you learned in the hangman problem
    to solve something completely different that involves manipulating a list of words,
    such as another game that uses words—like Scrabble, a spellchecker, or whatever
    else you can think of.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你自己的练习：运用你在“猜字谜”问题中学到的技能来解决一些完全不同的问题，这些问题涉及到操作单词列表，例如另一个使用单词的游戏——比如拼字游戏、拼写检查器，或者你想得到的任何其他东西。
- en: 'Design your own exercise: Search for a C++ programming problem of such size
    or difficulty that you are sure you would have once considered it impossible for
    you to solve with your skills, and solve it.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你自己的练习：寻找一个C++编程问题，其规模或难度如此之大，以至于你确信你曾经认为凭借你的技能解决它是不可行的，然后解决它。
- en: 'Design your own exercise: Find a library or API that interests you but that
    you have yet to use in a program. Then investigate that library or API and use
    it in a useful program. If you’re interested in general programming, consider
    the Microsoft .NET library or an open-source database library. If you like low-level
    graphics, consider OpenGL or DirectX. If you’d like to try making games, consider
    an open-source game engine like Ogre. Think about the kinds of programs you’d
    like to write, find a library that fits, and go at it.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你自己的练习：寻找一个你感兴趣但尚未在程序中使用过的库或API。然后调查那个库或API，并在一个有用的程序中使用它。如果你对通用编程感兴趣，可以考虑Microsoft
    .NET库或开源数据库库。如果你喜欢底层图形，可以考虑OpenGL或DirectX。如果你想尝试制作游戏，可以考虑像Ogre这样的开源游戏引擎。考虑你想编写的程序类型，找到一个合适的库，然后着手去做。
- en: 'Design your own exercise: Write a useful program for a new platform (one that’s
    new to you)—for example, mobile or web programming.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你自己的练习：为一个新的平台（对你来说是新的）编写一个有用的程序——例如，移动或网页编程。
