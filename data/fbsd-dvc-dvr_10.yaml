- en: Chapter 10. Managing and Using Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. 管理和使用资源
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: In [Chapter 7](ch07.html "Chapter 7. Newbus and Resource Allocation") we discussed
    how to allocate IRQs, I/O ports, and I/O memory. [Chapter 8](ch08.html "Chapter 8. Interrupt
    Handling") focused on using IRQs for interrupt handling. This chapter details
    how to use I/O ports for port-mapped I/O (PMIO) and I/O memory for memory-mapped
    I/O (MMIO). Before I describe PMIO and MMIO, some background on I/O ports and
    I/O memory is needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章. Newbus 和资源分配") 中，我们讨论了如何分配中断请求、I/O 端口和 I/O 内存。[第
    8 章](ch08.html "第 8 章. 中断处理") 专注于使用中断请求进行中断处理。本章详细介绍了如何使用 I/O 端口进行端口映射 I/O（PMIO）和
    I/O 内存进行内存映射 I/O（MMIO）。在描述 PMIO 和 MMIO 之前，需要了解一些关于 I/O 端口和 I/O 内存的基础知识。
- en: I/O Ports and I/O Memory
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O 端口和 I/O 内存
- en: Every peripheral device is controlled by reading from and writing to its registers
    (Corbet et al., 2005), which are mapped to either I/O ports or I/O memory. The
    use of I/O ports or I/O memory is device and architecture dependent. For example,
    on the *i386*, most ISA devices will map their registers to I/O ports; however,
    PCI devices tend to map their registers to I/O memory. As you may have guessed,
    reading and writing to a device’s registers, which are mapped to either I/O ports
    or I/O memory, is called PMIO or MMIO.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个外围设备都通过读取和写入其寄存器来控制（Corbet 等人，2005 年），这些寄存器映射到 I/O 端口或 I/O 内存。I/O 端口或 I/O
    内存的使用取决于设备和架构。例如，在 *i386* 上，大多数 ISA 设备将它们的寄存器映射到 I/O 端口；然而，PCI 设备倾向于将它们的寄存器映射到
    I/O 内存。正如你可能已经猜到的，读取和写入映射到 I/O 端口或 I/O 内存中的设备寄存器被称为 PMIO 或 MMIO。
- en: Reading from I/O Ports and I/O Memory
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 I/O 端口和 I/O 内存读取
- en: 'After a driver has called `bus_alloc_resource` to allocate the range of I/O
    ports or I/O memory it needs, it can read from those I/O regions using one of
    the following functions:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序在调用 `bus_alloc_resource` 分配所需的 I/O 端口或 I/O 内存范围之后，可以使用以下函数之一从这些 I/O 区域读取：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `bus_read_N` functions (where `N` is `1`, `2`, `4`, or `8`) read *`N`* bytes
    from an `offset` in `r` (where `r` is the return value from a successful `bus_alloc_resource`
    call that allocated an I/O region).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_read_N` 函数（其中 `N` 为 `1`、`2`、`4` 或 `8`）从 `r` 中的 `offset` 位置读取 *`N`* 字节（其中
    `r` 是成功调用 `bus_alloc_resource` 分配 I/O 区域的返回值）。'
- en: The `bus_read_multi_`*`N`* functions read *`N`* bytes from an `offset` in `r`,
    `count` times, and store the reads into `datap`. In short, `bus_read_multi_`*`N`*
    reads from the same location multiple times.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_read_multi_`*`N`* 函数从 `r` 中的 `offset` 位置读取 *`N`* 字节，共读取 `count` 次，并将读取的数据存储到
    `datap` 中。简而言之，`bus_read_multi_`*`N`* 从同一位置多次读取。'
- en: The `bus_read_region_`*`N`* functions read `count` *`N`*-byte values starting
    from an `offset` in `r`, and store the reads into `datap`. In other words, `bus_read_region_`*`N`*
    reads consecutive *`N`*-byte values from an I/O region (that is, an array).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_read_region_`*`N`* 函数从 `r` 中的 `offset` 位置开始读取 `count` *`N`*-字节值，并将读取的数据存储到
    `datap` 中。换句话说，`bus_read_region_`*`N`* 从 I/O 区域（即数组）中读取连续的 *`N`*-字节值。'
- en: Writing to I/O Ports and I/O Memory
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 I/O 端口和 I/O 内存写入
- en: 'A driver writes to an I/O region using one of the following functions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序使用以下函数之一将数据写入 I/O 区域：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `bus_write_`*`N`* functions (where *`N`* is `1`, `2`, `4`, or `8`) write
    an *`N`*-byte `value` to an `offset` in `r` (where `r` is the return value from
    a `bus_alloc_resource` call that allocated an I/O region).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_write_`*`N`* 函数（其中 *`N`* 为 `1`、`2`、`4` 或 `8`）将 *`N`*-字节 `value` 写入 `r`
    中的 `offset` 位置（其中 `r` 是 `bus_alloc_resource` 调用分配的 I/O 区域的返回值）。'
- en: The `bus_write_multi_`*`N`* functions take `count` *`N`*-byte values from `datap`
    and write them to an `offset` in `r`. In short, `bus_write_multi_`*`N`* writes
    multiple values to the same location.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_write_multi_`*`N`* 函数从 `datap` 中读取 `count` *`N`*-字节值，并将它们写入 `r` 中的 `offset`
    位置。简而言之，`bus_write_multi_`*`N`* 将多个值写入同一位置。'
- en: The `bus_write_region_`*`N`* functions take `count` *`N`*-byte values from `datap`
    and write them to a region in `r`, starting at `offset`. Each successive value
    is written at an offset of *`N`* bytes after the previous value. In short, `bus_write_region_`*`N`*
    writes consecutive *`N`*-byte values to an I/O region (that is, an array).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_write_region_`*`N`* 函数从 `datap` 中读取 `count` *`N`*-字节值，并将它们写入 `r` 中的某个区域，起始位置为
    `offset`。每个后续值都写入前一个值之后 *`N`* 字节的位置。简而言之，`bus_write_region_`*`N`* 将连续的 *`N`*-字节值写入
    I/O 区域（即数组）。'
- en: The `bus_set_multi_`*`N`* functions write an *`N`*-byte `value` to an `offset`
    in `r`, `count` times. That is, `bus_set_multi_`*`N`* writes the same value to
    the same location multiple times.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_set_multi_`*`N`* 函数将一个 *`N`*-字节的 `value` 写入 `r` 中的 `offset`，重复 `count`
    次。也就是说，`bus_set_multi_`*`N`* 将相同的值多次写入相同的位置。'
- en: The `bus_set_region_`*`N`* functions write an *`N`*-byte `value`, `count` times,
    throughout a region in `r`, starting at `offset`. In other words, `bus_set_region_`*`N`*
    writes the same value consecutively to an I/O region (that is, an array).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_set_region_`*`N`* 函数将一个 *`N`*-字节的 `value`，重复 `count` 次，写入 `r` 中的某个区域，从
    `offset` 开始。换句话说，`bus_set_region_`*`N`* 将相同的值连续写入一个 I/O 区域（即数组）。'
- en: Stream Operations
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流操作
- en: 'All of the preceding functions handle converting to and from host byte order
    and bus byte order. In some cases, however, you may need to avoid this conversion.
    Fortunately, FreeBSD provides the following functions for such an occasion:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前面函数都处理主机字节序和总线字节序之间的转换。然而，在某些情况下，您可能需要避免这种转换。幸运的是，FreeBSD 提供了以下函数来满足这种场合：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These functions are identical to their nonstream counterparts, except that they
    don’t perform any byte order conversions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与其非流版本相同，只是它们不执行任何字节序转换。
- en: Memory Barriers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存屏障
- en: 'Sequences of read and write instructions can often be executed more quickly
    if run in an order that’s different from the program text (Corbet et al., 2005).
    As a result, modern processors customarily reorder read and write instructions.
    However, this optimization can foul up drivers performing PMIO and MMIO. To prevent
    instruction reordering, memory barriers are employed. *Memory barriers* ensure
    that all instructions before the barrier conclude before any instruction after
    the barrier. For PMIO and MMIO operations, the `bus_barrier` function provides
    this ability:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按照与程序文本不同的顺序执行读取和写入指令序列，通常可以更快地执行（Corbet et al., 2005）。因此，现代处理器通常重新排序读取和写入指令。然而，这种优化可能会破坏执行
    PMIO 和 MMIO 的驱动程序。为了防止指令重排序，使用了内存屏障。*内存屏障* 确保在屏障之前的所有指令都完成之前，屏障之后的任何指令都不会执行。对于
    PMIO 和 MMIO 操作，`bus_barrier` 函数提供了这种能力：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `bus_barrier` function inserts a memory barrier that enforces the ordering
    of read or write operations on a region in `r`, which is described by the `offset`
    and `length` arguments. The `flags` argument specifies the type of operation to
    be ordered. Valid values for this argument are shown in [Table 10-1](ch10s02.html#bus_underscore_barrier_symbolic_constant
    "Table 10-1. bus_barrier Symbolic Constants").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_barrier` 函数在 `r` 的某个区域中插入一个内存屏障，该区域由 `offset` 和 `length` 参数描述，强制对读取或写入操作进行排序。`flags`
    参数指定要排序的操作类型。此参数的有效值在 [表 10-1](ch10s02.html#bus_underscore_barrier_symbolic_constant
    "表 10-1. bus_barrier 符号常量") 中显示。'
- en: Table 10-1. bus_barrier Symbolic Constants
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1. bus_barrier 符号常量
- en: '| Constant | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BUS_SPACE_BARRIER_READ` | Synchronizes read operations |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `BUS_SPACE_BARRIER_READ` | 同步读取操作 |'
- en: '| `BUS_SPACE_BARRIER_WRITE` | Synchronizes write operations |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `BUS_SPACE_BARRIER_WRITE` | 同步写入操作 |'
- en: 'Note that these flags can be ORed to enforce ordering on both read and write
    operations. An exemplary use of `bus_barrier` looks something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些标志可以按位或（ORed）来强制在读取和写入操作上执行排序。`bus_barrier` 的一个典型用法如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the calls to `bus_barrier` guarantee that the writes and reads conclude
    in the order written.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对 `bus_barrier` 的调用保证了写入和读取的顺序与写入的顺序一致。
- en: Tying Everything Together
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 综合一切
- en: '[Example 10-1](ch10s03.html#led.c "Example 10-1. led.c") is a simple driver
    for an i-Opener’s LEDs (based on code written by Warner Losh). An i-Opener includes
    two LEDs that are controlled by bits 0 and 1 of the register located at 0x404c.
    Hopefully, this example will clarify any misunderstandings you may have about
    PMIO (and MMIO).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-1](ch10s03.html#led.c "示例 10-1. led.c") 是一个简单的 i-Opener LED 驱动程序（基于
    Warner Losh 编写的代码）。i-Opener 包含两个 LED，由位于 0x404c 的寄存器的位 0 和 1 控制。希望这个示例能澄清您可能对
    PMIO（以及 MMIO）存在的任何误解。'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take a quick look at this code and try to discern some of its structure. If
    you don’t understand all of it, don’t worry; an explanation follows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览一下这段代码，并尝试了解其结构。如果您不理解其中的所有内容，请不要担心；解释将在后面提供。
- en: Example 10-1. led.c
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-1. led.c
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before I describe the functions defined in [Example 10-1](ch10s03.html#led.c
    "Example 10-1. led.c"), note that the constant ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `LED_IO_ADDR` is defined as `0x404c` and that the constant ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `LED_NUM` is defined as `2`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我描述 [示例 10-1](ch10s03.html#led.c "示例 10-1. led.c") 中定义的函数之前，请注意常量 ![LED_IO_ADDR](httpatomoreillycomsourcenostarchimages1137499.png)
    被定义为 `0x404c`，而常量 ![LED_NUM](httpatomoreillycomsourcenostarchimages1137501.png)
    被定义为 `2`。
- en: The following sections describe the functions defined in [Example 10-1](ch10s03.html#led.c
    "Example 10-1. led.c") in the order they would roughly execute.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节按它们大致执行的顺序描述了在 [示例 10-1](ch10s03.html#led.c "示例 10-1. led.c") 中定义的函数。
- en: led_identify Function
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_identify 函数
- en: 'The `led_identify` function is the `device_identify` implementation for this
    driver. This function is required because the ISA bus cannot identify its children
    unaided. Here is the function definition for `led_identify` (again):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_identify` 函数是本驱动程序的 `device_identify` 实现。这个函数是必需的，因为 ISA 总线无法在没有辅助的情况下识别其子设备。以下是
    `led_identify` 函数的定义（再次）：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) determines
    if the ISA bus has identified a child device named ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `"led"`. If it has not, then `"led"` is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    appended to the ISA bus’s catalog of identified children. Afterward, ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `bus_set_resource` is called to specify that I/O port access for `"led"` starts
    at `LED_IO_ADDR`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先确定 ISA 总线是否已识别名为 ![led](httpatomoreillycomsourcenostarchimages1137501.png)
    的子设备。如果没有，则将 `"led"` 添加到 ISA 总线的已识别子设备目录中。之后，调用 ![bus_set_resource](httpatomoreillycomsourcenostarchimages1137505.png)
    指定 `"led"` 的 I/O 端口访问从 `LED_IO_ADDR` 开始。
- en: led_probe Function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_probe 函数
- en: 'The `led_probe` function is the `device_probe` implementation for this driver.
    Here is its function definition (again):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_probe` 函数是本驱动程序的 `device_probe` 实现。以下是它的函数定义（再次）：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) checks
    if `"led"` can acquire I/O port access. Afterward, the verbose description of
    `"led"` is ![](httpatomoreillycomsourcenostarchimages1137501.png) set and the
    success code ![](httpatomoreillycomsourcenostarchimages1137503.png) `BUS_PROBE_SPECIFIC`
    is returned.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先检查 `"led"` 是否可以获取 I/O 端口访问权限。之后，设置 `"led"` 的详细描述 ![详细描述](httpatomoreillycomsourcenostarchimages1137501.png)
    并返回成功代码 ![BUS_PROBE_SPECIFIC](httpatomoreillycomsourcenostarchimages1137503.png)。
- en: led_attach Function
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_attach 函数
- en: 'The `led_attach` function is the `device_attach` implementation for this driver.
    Here is its function definition (again):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_attach` 函数是本驱动程序的 `device_attach` 实现。以下是它的函数定义（再次）：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    acquiring an I/O port. If unsuccessful, the error code ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `ENXIO` is returned. Then the member variables ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `sc_open_mask` and ![](httpatomoreillycomsourcenostarchimages1137505.png) `sc_read_mask`
    are zeroed; in the `d_foo` functions, these variables will be protected by ![](httpatomoreillycomsourcenostarchimages1137507.png)
    `sc_mutex`. Finally, `led_attach` creates a ![](httpatomoreillycomsourcenostarchimages1137509.png)
    ![](httpatomoreillycomsourcenostarchimages1137511.png) character device node for
    each LED.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先尝试获取一个 I/O 端口。如果失败，则返回错误代码 ![ENXIO](httpatomoreillycomsourcenostarchimages1137501.png)。然后，成员变量
    ![sc_open_mask](httpatomoreillycomsourcenostarchimages1137503.png) 和 ![sc_read_mask](httpatomoreillycomsourcenostarchimages1137505.png)
    被置零；在 `d_foo` 函数中，这些变量将由 ![sc_mutex](httpatomoreillycomsourcenostarchimages1137507.png)
    保护。最后，`led_attach` 为每个 LED 创建一个 ![字符设备节点](httpatomoreillycomsourcenostarchimages1137509.png)
    ![字符设备节点](httpatomoreillycomsourcenostarchimages1137511.png)。
- en: led_detach Function
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_detach 函数
- en: 'The `led_detach` function is the `device_detach` implementation for this driver.
    Here is its function definition (again):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_detach` 函数是本驱动程序的 `device_detach` 实现。以下是它的函数定义（再次）：'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    ![](httpatomoreillycomsourcenostarchimages1137501.png) destroying its device nodes.
    Once this is done, it ![](httpatomoreillycomsourcenostarchimages1137503.png) destroys
    its mutex and ![](httpatomoreillycomsourcenostarchimages1137505.png) releases
    its I/O port.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先销毁其设备节点。一旦完成，它销毁其互斥锁并释放其I/O端口。
- en: led_open Function
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_open 函数
- en: 'The `led_open` function is defined in `led_cdevsw` (that is, the character
    device switch table) as the `d_open` operation. Here is its function definition
    (again):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_open` 函数定义在 `led_cdevsw`（即字符设备切换表）中，作为 `d_open` 操作。以下是它的函数定义（再次）：'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) stores
    in `led` the unit number of the device node being opened. If `led` is ![](httpatomoreillycomsourcenostarchimages1137501.png)
    greater than or equal to `LED_NUM`, then `ENXIO` is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    returned. Next, the value of `sc_open_mask` is ![](httpatomoreillycomsourcenostarchimages1137505.png)
    examined. If its `led` bit does not equal `0`, which indicates that another process
    has opened the device, then `EBUSY` is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    returned. Otherwise, `sc_open_mask` and `sc_read_mask` are ![](httpatomoreillycomsourcenostarchimages1137509.png)
    ![](httpatomoreillycomsourcenostarchimages1137511.png) set to include `1 << led`.
    That is, their `led` bit will be changed to `1`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先将打开的设备节点的单元号存储在 `led` 中。如果 `led` 大于或等于 `LED_NUM`，则返回 `ENXIO`。接下来，检查 `sc_open_mask`
    的值。如果其 `led` 位不等于 `0`，这表示另一个进程已打开该设备，则返回 `EBUSY`。否则，将 `sc_open_mask` 和 `sc_read_mask`
    设置为包含 `1 << led`。也就是说，它们的 `led` 位将被更改为 `1`。
- en: led_close Function
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_close 函数
- en: 'The `led_close` function is defined in `led_cdevsw` as the `d_close` operation.
    Here is its function definition (again):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_close` 函数定义在 `led_cdevsw` 中，作为 `d_close` 操作。以下是它的函数定义（再次）：'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, this function simply ![](httpatomoreillycomsourcenostarchimages1137499.png)
    clears `sc_open_mask`’s `led` bit (which allows another process to open this device).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此函数只是简单地清除 `sc_open_mask` 的 `led` 位（这允许另一个进程打开此设备）。
- en: led_read Function
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_read 函数
- en: 'The `led_read` function is defined in `led_cdevsw` as the `d_read` operation.
    This function returns one character indicating whether the LED is on (`1`) or
    off (`0`). Here is its function definition (again):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_read` 函数定义在 `led_cdevsw` 中，作为 `d_read` 操作。此函数返回一个字符，指示LED是开启（`1`）还是关闭（`0`）。以下是它的函数定义（再次）：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) checks
    that `sc_read_mask`’s `led` bit is set; otherwise, it ![](httpatomoreillycomsourcenostarchimages1137501.png)
    exits. Next, 1 byte from the LED’s control register is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    read into `ch`. Then `ch`’s `led` bit is ![](httpatomoreillycomsourcenostarchimages1137505.png)
    isolated and its value is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    returned to user space.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先检查 `sc_read_mask` 的 `led` 位是否已设置；否则，它退出。接下来，从LED的控制寄存器中读取1个字节到 `ch`。然后，将
    `ch` 的 `led` 位隔离，并将其值返回到用户空间。
- en: led_write Function
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: led_write 函数
- en: 'The `led_write` function is defined in `led_cdevsw` as the `d_write` operation.
    This function takes in one character to turn on (`1`) or off (`0`) the LED. Here
    is its function definition (again):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`led_write` 函数定义在 `led_cdevsw` 中，作为 `d_write` 操作。此函数接收一个字符来打开（`1`）或关闭（`0`）LED。以下是它的函数定义（再次）：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) copies
    one character from user space to `ch`. Next, 1 byte from the LED’s control register
    is ![](httpatomoreillycomsourcenostarchimages1137501.png) read into `old`. Then,
    based on the ![](httpatomoreillycomsourcenostarchimages1137503.png) value from
    user space, `old`’s `led` bit is turned ![](httpatomoreillycomsourcenostarchimages1137505.png)
    on or ![](httpatomoreillycomsourcenostarchimages1137507.png) off. Afterward, `old`
    is ![](httpatomoreillycomsourcenostarchimages1137509.png) written back to the
    LED’s control register.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先从用户空间复制一个字符到`ch`。接下来，从LED的控制寄存器中读取1个字节到`old`。然后，根据用户空间中的值，将`old`的`led`位打开或关闭。之后，将`old`写回LED的控制寄存器。
- en: Conclusion
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter described all of the functions provided by FreeBSD for performing
    PMIO and MMIO (that is, for accessing a device’s registers). The next chapter
    discusses using PMIO and MMIO with PCI devices, which are more involved than what’s
    been shown here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了FreeBSD提供的所有用于执行PMIO和MMIO（即访问设备寄存器）的函数。下一章将讨论使用PMIO和MMIO与PCI设备，这比这里展示的要复杂得多。
