- en: Chapter 21. Packet Filtering
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 21 章。数据包过滤
- en: '*The name’s Pond, James Pond.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*名字是 Pond，詹姆斯·庞德。*'
- en: '*My x86 loaded,*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我的 x86 已加载，*'
- en: '*licensed to filter.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权过滤。*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Packet filtering and
    traffic manipulation are among the most basic tools in network security. OpenBSD
    includes a very powerful in-kernel packet filter, `pf(4)`, or PF. This tool not
    only performs standard filtering, but it can also inspect, reassemble, redirect,
    and otherwise abuse packets in several ways; translate addresses in several different
    directions simultaneously; authenticate users; and manage bandwidth. Along with
    PF, OpenBSD includes programs that let you turn your system into a load balancer,
    transparent proxy, or any number of other network devices.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1616079.png) 数据包过滤和流量操作是网络安全中最基本的工具之一。OpenBSD
    包含一个非常强大的内核级数据包过滤器 `pf(4)` 或 PF。这个工具不仅执行标准过滤，还可以以多种方式检查、重新组装、重定向以及其他方式滥用数据包；同时以多个不同方向转换地址；验证用户；并管理带宽。与
    PF 一起，OpenBSD 包含允许您将系统转换为负载均衡器、透明代理或其他网络设备的程序。'
- en: PF is one of the high points of OpenBSD and deserves its own book. That book
    is *The Book of PF*, *2nd edition*, by Peter Hansteen (No Starch Press, 2010),
    which goes into detail on many different PF use cases. This chapter covers the
    basics of PF so that you can protect a small network or an individual server.
    If you want to protect a web farm and transparently relay traffic to only the
    active servers with sufficient free capacity to handle the load, get Peter’s book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PF 是 OpenBSD 的亮点之一，值得拥有一本自己的书。这本书是 Peter Hansteen（No Starch Press，2010）所著的 *《PF
    权威指南》*，*第 2 版*，详细介绍了许多不同的 PF 应用场景。本章涵盖了 PF 的基础知识，以便您能够保护一个小型网络或单个服务器。如果您想保护一个
    Web 农场，并且只将流量透明地转发到具有足够空闲容量来处理负载的活跃服务器，请获取 Peter 的书。
- en: That said, not even Peter’s book covers PF in its entirety. OpenBSD lets you
    fold, spindle, and mutilate TCP/IP far beyond anything any reasonable person could
    ever expect to support in the real world. For complete details on PF, read the
    `pf(4)`, `pfctl(8)`, and `pf.conf(5)` man pages, and the OpenBSD PF FAQ at *[http://www.OpenBSD.org/faq/pf/](http://www.OpenBSD.org/faq/pf/)*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，即使是 Peter 的书也没有涵盖 PF 的全部内容。OpenBSD 允许您对 TCP/IP 进行折叠、拉伸和扭曲，远远超出了任何合理的人在任何实际环境中可能期望支持的范畴。有关
    PF 的完整详细信息，请阅读 `pf(4)`、`pfctl(8)`、`pf.conf(5)` 手册页，以及 OpenBSD PF FAQ 在 *[http://www.OpenBSD.org/faq/pf/](http://www.OpenBSD.org/faq/pf/)*。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PF is still undergoing active development. While the configuration syntax doesn’t
    change as often as it used to, check `pf.conf(5)` for the latest information on
    your version of OpenBSD.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: PF 仍在积极开发中。虽然配置语法不像以前那样频繁变化，但请检查 `pf.conf(5)` 以获取关于您版本 OpenBSD 的最新信息。
- en: Firewalls
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防火墙
- en: The word *firewall* has been tortured beyond recognition over the past 20 or
    so years, until it has ceased to mean much of anything in particular. In general,
    a firewall sits between a private and public network, and controls the traffic
    between the two.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去 20 年左右的时间里，*防火墙* 这个词已经被折磨得无法辨认，以至于它不再具有特定的含义。一般来说，防火墙位于私有网络和公共网络之间，并控制两者之间的流量。
- en: You can buy a firewall for your cable modem for under $100, and you can purchase
    an enterprise firewall cluster for $1 million. What’s the difference? They’re
    all firewalls, much as rats and cats and elephants are all mammals, but some are
    welcome in your home and most are not.^([[45](#ftn.id337427)]) Which you permit,
    of course, is your personal preference. And firewalls are much the same.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用不到 100 美元的价格购买一个用于电缆调制解调器的防火墙，也可以用 100 万美元购买一个企业级防火墙集群。区别在哪里？它们都是防火墙，就像老鼠、猫和象都是哺乳动物一样，但有些是受欢迎的，而大多数则不然.^([[45](#ftn.id337427)])
    当然，您允许的当然是您个人的偏好。而且防火墙也大致如此。
- en: Some firewalls filter application-level traffic. Some only filter based on protocol
    or ports. Some firewalls inspect protocol flags and ensure traffic sanity. Others
    just pass packets. And some firewalls just translate network addresses and claim
    that provides security. Worse, the price tag bears no relationship to the feature
    set.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些防火墙过滤应用层流量。一些仅基于协议或端口进行过滤。一些防火墙检查协议标志并确保流量合理性。其他只是传递数据包。还有一些防火墙只是转换网络地址，并声称这提供了安全性。更糟糕的是，价格标签与功能集没有任何关系。
- en: At their most basic, all firewalls filter packets and can perform network address
    translation (NAT). OpenBSD can perform those tasks as well or better than most
    commercial firewalls. If you want application proxies, however, they don’t come
    with the core OpenBSD system (with the exception of FTP and TFTP proxies, which
    are necessary for those protocols to function with NAT). Several popular application
    proxies run quite well on OpenBSD, but they are not part of OpenBSD. For example,
    I’ve used Squid (*/usr/ports/www/squid*) and several related packages to build
    a web proxy and filter on OpenBSD that is comparable to anything the big companies
    offer, and an assortment of other proxies to manage just about everything else.
    If you are interested in firewalls, I highly recommend that you assemble your
    own highly featured firewall from available components at least once, for the
    sake of education if nothing else.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的情况下，所有防火墙都会过滤数据包并可以执行网络地址转换（NAT）。OpenBSD可以像大多数商业防火墙一样，甚至更好地进行这些任务。但是，如果你想要应用程序代理，它们并不包含在核心OpenBSD系统中（除了FTP和TFTP代理，这些代理对于这些协议与NAT一起工作是必要的）。几个流行的应用程序代理在OpenBSD上运行得相当好，但它们不是OpenBSD的一部分。例如，我使用Squid（*/usr/ports/www/squid*）和几个相关软件包在OpenBSD上构建了一个与大型公司提供的任何东西相媲美的Web代理和过滤器，以及一系列其他代理来管理几乎所有其他事情。如果你对防火墙感兴趣，我强烈建议你至少一次从可用的组件中组装一个功能强大的防火墙，以教育为目的，如果其他什么也不做的话。
- en: A firewall is what you make it. You can send all your traffic through a simple
    OpenBSD packet filter and honestly declare that you have a firewall, or you can
    set up application proxies, authentication, and so on, and still say you have
    a firewall. A plain packet filter is a firewall just as much as one of those umpteen-integrated-application-proxy,
    six-figure-price-tag devices. Remember this the next time someone says he has
    a firewall.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙是你自己定义的。你可以将所有流量通过简单的OpenBSD数据包过滤器发送，并诚实地宣称你有一个防火墙，或者你可以设置应用程序代理、身份验证等，仍然可以说你有一个防火墙。一个简单的数据包过滤器就像那些集成应用程序代理、价格昂贵的设备一样，是一个防火墙。下次有人说他有一个防火墙时，请记住这一点。
- en: Realistically, a firewall is not a security device. It is a point of policy
    enforcement.^([[46](#ftn.id337464)]) The firewall doesn’t secure anything; it
    prevents access to certain services. But blocking access doesn’t secure inherently
    insecure services—it just means you can’t access them. If your firewall permits
    access to a service, the firewall doesn’t add any security to that service.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，防火墙不是一个安全设备。它是一个政策执行点。[46](#ftn.id337464) 防火墙不会保护任何东西；它阻止对某些服务的访问。但是阻止访问并不
    inherently secure inherently insecure services—it just means you can’t access
    them. 如果你的防火墙允许访问某个服务，防火墙不会为该服务增加任何安全性。
- en: In order to build an effective firewall, you must understand TCP/IP. If [Chapter 11](ch11.html
    "Chapter 11. Overview of TCP/IP") was a revelation to you, get a copy of *The
    TCP/IP Guide* (No Starch Press, 2005). Read it. Mark it up. Highlight it. And
    read it again.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个有效的防火墙，你必须理解TCP/IP。如果[第11章](ch11.html "第11章。TCP/IP概述")对你来说是一个启示，请获取一份*The
    TCP/IP Guide*（No Starch Press，2005）的副本。阅读它。标记它。突出显示它。然后再读一遍。
- en: Many of the examples in this chapter assume that you are building a firewall.
    This means that your host has two or more network interfaces (including VLAN interfaces)
    and that you want to protect the network on one side from the network on the other
    side. While this is a popular application for OpenBSD, everything covered here
    works just as well on individual hosts. I filter packets on lone web servers,
    on desktops, and on any host sitting naked on the Internet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多示例都假设你在构建防火墙。这意味着你的主机有两个或更多网络接口（包括VLAN接口），并且你想要保护一侧的网络不受另一侧网络的影响。虽然这是OpenBSD的一个流行应用，但这里涵盖的所有内容在单个主机上同样适用。我在孤立的Web服务器、桌面和任何裸露在互联网上的主机上过滤数据包。
- en: Enabling and Configuring PF
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置PF
- en: 'OpenBSD enables PF by default at system boot with these *rc.conf* variables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD在系统启动时默认启用PF，使用以下*rc.conf*变量：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To disable PF at boot, set `pf` to `NO` in *rc.conf.local*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动时禁用PF，请在*rc.conf.local*中将`pf`设置为`NO`。
- en: The default configuration file for PF is */etc/pf.conf*. There’s nothing special
    about this file—it’s just a standard location. The `pf(4)` kernel interface doesn’t
    read the file directly; the PF control program `pfctl(8)` reads the file and sends
    the configuration to the kernel.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PF的默认配置文件是*/etc/pf.conf*。这个文件并没有什么特殊之处——它只是一个标准位置。`pf(4)`内核接口不会直接读取该文件；PF控制程序`pfctl(8)`读取文件并将配置发送到内核。
- en: The default PF configuration (hard-coded in */etc/rc*) blocks all network traffic
    except for ICMP and SSH. During boot, PF replaces those defaults with rules from
    */etc/pf.conf*. If an error in *pf.conf* renders the file unparsable when the
    system boots, PF can’t load those rules; instead, it retains the default configuration.
    You’ll be able to connect to your machine to correct your rules, but that’s about
    it. (And, as anyone who administers remote firewalls can tell you, this ability
    can save you a lot of driving and phone calls.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的PF配置（硬编码在*/etc/rc*中）阻止了除ICMP和SSH之外的所有网络流量。在引导过程中，PF用*/etc/pf.conf*中的规则替换这些默认规则。如果*pf.conf*中的错误在系统引导时使文件不可解析，PF无法加载这些规则；相反，它保留默认配置。您将能够连接到您的机器以纠正您的规则，但这就足够了。（而且，正如任何管理远程防火墙的人都可以告诉您的那样，这种能力可以为您节省大量的驾驶和电话费。）
- en: Running PF by default, even with a permissive ruleset, cleans up incoming traffic
    before the rest of the kernel has to deal with it. PF reassembles packets before
    handing them to the kernel, and obviously bogus traffic, such as packets too short
    to be legitimate, is discarded.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认运行PF，即使有宽容的规则集，也会在内核的其他部分处理之前清理传入的流量。PF在将数据包交给内核之前重新组装数据包，并且显然是虚假的流量，如太短而无法成为合法的数据包，将被丢弃。
- en: If you want to forward packets between interfaces (that is, act like a “firewall”),
    tell the kernel to forward packets with the `net.inet.ip.forwarding` and `net.inet6.ip6.forwarding`
    sysctls. (See */etc/sysctl.conf* for commented-out examples.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在接口之间转发数据包（即，充当“防火墙”），请告诉内核使用`net.inet.ip.forwarding`和`net.inet6.ip6.forwarding`
    sysctls转发数据包。（有关已注释示例，请参阅*/etc/sysctl.conf*。）
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remove the pound signs and reboot, or use `sysctl(8)` to enable and disable
    packet forwarding on the fly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 移除井号并重新启动，或者使用`sysctl(8)`在运行时启用和禁用数据包转发。
- en: Packet-Filtering Basics
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据包过滤基础
- en: 'Packet filtering is comparing packets to a list of rules and accepting, rejecting,
    or altering them as those rules dictate. As a network administrator, you get to
    decide which packets are naughty and which are nice. When you filter packets for
    a single host, you can legitimately call that host *hardened*. (The word *hardened*
    means almost exactly what *firewall* means: nothing.) When you send all packets
    on your network through a single host that filters packets, you have a basic firewall.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包过滤是将数据包与规则列表进行比较，并根据这些规则接受、拒绝或修改它们。作为网络管理员，您有权决定哪些数据包是“坏”的，哪些是“好”的。当您为单个主机过滤数据包时，您可以合法地称该主机为“加固的”。（“加固”一词几乎与“防火墙”一词的意思完全相同：什么都没有。）当您将您的网络上的所有数据包通过一个过滤数据包的主机发送时，您就有一个基本的防火墙。
- en: A basic packet filter might allow you to filter based on only the TCP or UDP
    protocol number. Some don’t even allow you to filter by ICMP type or cannot cope
    with protocols other than those enumerated in the GUI. PF, however, can cope with
    almost anything you throw at it. If you need a machine to communicate with another
    over IP protocol 184, PF will support you. Many commercial firewalls won’t let
    you pass such traffic, or claim that they do but throw a tantrum if you actually
    try it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的数据包过滤器可能只允许您根据TCP或UDP协议号进行过滤。有些甚至不允许您根据ICMP类型进行过滤，或者无法处理GUI中未列出的协议。然而，PF可以处理您向其投掷的几乎所有内容。如果您需要一台机器通过IP协议184与其他机器通信，PF将支持您。许多商业防火墙不会允许您通过此类流量，或者声称可以，但如果你实际尝试，它们会大发雷霆。
- en: Packet-Filtering Concepts
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据包过滤概念
- en: '[Chapter 11](ch11.html "Chapter 11. Overview of TCP/IP") described how TCP
    connections can be in a variety of states. A TCP connection that is just starting
    goes through a three-way handshake process. A client requests a connection by
    sending a synchronization request, or SYN, packet to the server. The server responds
    by sending the client an acknowledgment of the SYN, as well as its own SYN request,
    or a SYN+ACK packet. The client responds with its own ACK.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html "第11章。TCP/IP概述")描述了TCP连接可以处于各种状态。一个刚开始的TCP连接会经历一个三次握手过程。客户端通过向服务器发送一个同步请求，或SYN，数据包来请求连接。服务器通过向客户端发送SYN的确认以及它自己的SYN请求，或SYN+ACK数据包来响应。客户端随后发送自己的ACK。'
- en: Every part of this three-way handshake must complete for any actual data to
    transfer between the two machines. Your packet-filtering rules must permit each
    part of the three-way handshake and the subsequent data transmission. PF automatically
    recognizes these three-way handshakes and tracks them through *stateful inspection*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个三次握手过程的每一部分都必须完成，才能在两台机器之间传输实际数据。您的数据包过滤规则必须允许三次握手和随后的数据传输的每一部分。PF通过*状态检查*自动识别这些三次握手并跟踪它们。
- en: Stateful Inspection
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态检测
- en: PF maintains a list of permitted connections that have completed connection
    setup, which is called a *state table*. When a client sends out a SYN packet,
    PF records that packet in a table and waits for a corresponding SYN+ACK packet.
    If a SYN+ACK packet arrives at PF, but PF has no record of a corresponding SYN
    request, the SYN+ACK packet is rejected.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PF 维护一个已完成的连接设置允许连接的列表，这被称为 *状态表*。当客户端发送一个 SYN 数据包时，PF 将该数据包记录在表中，并等待相应的 SYN+ACK
    数据包。如果 PF 收到 SYN+ACK 数据包，但没有记录相应的 SYN 请求，则拒绝该 SYN+ACK 数据包。
- en: PF has a series of built-in timeouts that dictate how long idle connections
    remain in the state table, how long to wait for each stage of the three-way handshake,
    and so on. The state table is self-maintaining, and I’ve never had to adjust any
    of these timeouts. (On occasion, I have needed to increase the maximum size of
    the state table.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PF 有一系列内置的超时时间，这些时间决定了空闲连接在状态表中保持多长时间，等待三次握手每个阶段的时长，等等。状态表是自我维护的，我从未需要调整这些超时时间。（偶尔，我需要增加状态表的最大大小。）
- en: UDP is technically stateless, but some applications expect a certain amount
    of state. When your system transmits a UDP packet, the application might well
    expect a UDP packet or 10 in response, or no packets, depending on the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 在技术上是无状态的，但某些应用程序期望一定量的状态。当你的系统传输一个 UDP 数据包时，应用程序可能会期望一个 UDP 数据包或 10 个响应，或者没有数据包，这取决于应用程序。
- en: DNS queries are a common example of UDP packets flowing back and forth, and
    while UDP has no state, DNS certainly does. (ICMP behaves similarly.) You can
    have PF either expect this back-and-forth or not, by adding these flows to the
    state table as your protocol dictates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 查询是 UDP 数据包往返流动的常见例子，虽然 UDP 没有状态，但 DNS 确实有。 (ICMP 的行为类似。)你可以根据你的协议，通过将这些流添加到状态表中来让
    PF 期望或不需要这种往返。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PF can also operate without stateful inspection, allowing traffic to and from
    hosts and ports based on individual packet characteristics. *Stateless filtering*
    is slower than stateful inspection, harder to correctly configure, and generally
    considered less secure and less useful than stateful inspection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PF 也可以在不进行状态检测的情况下运行，允许根据单个数据包特征从主机和端口传输流量。*无状态过滤* 比状态检测慢，更难正确配置，通常被认为比状态检测不安全且不那么有用。
- en: Packet Reassembly
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据包重组
- en: Packets can be mangled during transit, usually by *fragmentation*. Part of a
    packet filter’s job is to sensibly *reassemble* those packets. PF can reassemble
    and rationalize packets in a variety of ways. (Old versions of PF called this
    *scrubbing*.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包在传输过程中可能会被破坏，通常是通过 *分片*。数据包过滤器的部分工作就是合理地 *重组* 这些数据包。PF 可以以多种方式重组和合理化数据包。（旧版本的
    PF 将此称为 *清洗*。）
- en: Default Accept vs. Default Deny
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认接受与默认拒绝
- en: 'One of the essential concepts in packet filtering is the question of default
    accept versus default deny:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包过滤中的一个基本概念是默认接受与默认拒绝的问题：
- en: A *default accept* stance means that you allow any type of connection except
    what you specifically deny. The default PF rules are an example of a default accept
    stance.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认接受* 立场意味着你允许任何类型的连接，除了你明确拒绝的连接。默认的 PF 规则是默认接受立场的例子。'
- en: A *default deny* stance means that you allow only explicitly permitted connections.
    All other connections are refused.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认拒绝* 立场意味着你只允许明确允许的连接。所有其他连接都被拒绝。'
- en: Once you have chosen your default, you can adjust your rules to hide or reveal
    network services as needed. In today’s world, I recommend default deny on all
    systems, because this stance protects new services as they are added to a system.
    In most environments where I’ve seen a default accept stance used in the past
    decade, it’s because the system administrators did not understand the network
    protocol they were using. This is particularly common in VoIP installations (yes,
    you *can* packet filter VoIP servers!)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了默认设置，你可以调整你的规则，根据需要隐藏或显示网络服务。在当今世界，我建议在所有系统上使用默认拒绝，因为这种立场在将新服务添加到系统时保护了这些服务。在过去十年中，我看到的大多数使用默认接受立场的环境，是因为系统管理员没有理解他们所使用的网络协议。这在
    VoIP 安装中尤其常见（是的，你可以对 VoIP 服务器进行数据包过滤！）
- en: In addition to packet filtering and reassembly, PF offers several other important
    features, including NAT, connection redirection, and bandwidth management, to
    name a few. We’ll consider each separately. All are configured in *pf.conf* and
    managed with `pfctl(8)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据包过滤和重组之外，PF还提供了一些其他重要功能，包括NAT、连接重定向和带宽管理，仅举几例。我们将分别考虑。所有这些都在`*pf.conf*`中配置，并通过`pfctl(8)`进行管理。
- en: “My Network Can Do No Wrong”
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “我的网络不会出错”
- en: Many network administrators who build a firewall carefully filter and restrict
    incoming traffic, but only apply minimal restrictions on outgoing traffic. While
    control of incoming traffic is among the most in-your-face issues of network management,
    control of outgoing traffic is also important.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 许多构建防火墙的网络管理员会仔细过滤和限制入站流量，但只在出站流量上施加最小限制。虽然对入站流量的控制是网络管理中最直接的问题之一，但出站流量的控制也同样重要。
- en: Even if you trust your users, malware can convert a skilled engineer’s workstation
    into a garbage-spewing pest. Do not assume that your network can do no wrong.
    It can be malicious, and one day it will be, but careful traffic control can minimize
    the damage you inflict on your neighbors, clients, customers, and reputation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你信任你的用户，恶意软件也可以将一名熟练工程师的工作站变成垃圾邮件喷发虫。不要假设你的网络不会出错。它可以是有害的，而且总有一天会变成这样，但仔细的流量控制可以最小化你对邻居、客户、客户和声誉造成的损害。
- en: Is there any reason for your staff desktops to connect to any random remote
    mail server? If not, block it, and even if a workstation is infected with a spambot,
    the rest of the world won’t blacklist you. Is there any reason for your users
    to connect to remote DNS servers, or should they use your company’s? Block outbound
    DNS, and prevent your users from becoming unwitting amplifiers of denial-of-service
    attacks. I strongly recommend a default deny stance for outbound as well as inbound
    traffic, and explicitly allowing desirable traffic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你的员工桌面是否有理由连接到任何随机的远程邮件服务器？如果没有，就阻止它，即使工作站感染了垃圾邮件机器人，世界上的其他人也不会将你列入黑名单。用户是否有理由连接到远程DNS服务器，或者他们应该使用公司的DNS服务器？阻止出站DNS，防止用户成为拒绝服务攻击的无意识放大器。我强烈建议对出站和入站流量都采取默认拒绝立场，并明确允许期望的流量。
- en: Some networks might be exceptions, of course. If every system on your network
    runs OpenBSD, you’re pretty safe from routine malware, but already we see malware
    targeting televisions, Blu-ray, streaming media players, and other appliances
    with network connectivity. Protect yourself now.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些网络可能是个例外。如果你的网络上的每个系统都运行OpenBSD，你将相当安全，免受常规恶意软件的侵害，但我们已经看到恶意软件针对电视、蓝光播放器、流媒体播放器和其他具有网络连接的设备。现在就保护自己。
- en: Anytime that you catch yourself thinking that your network can do no wrong,
    stop and remind yourself that you are not as smart as the combination of every
    malware author in the world.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你发现自己认为你的网络不会出错，请停下来提醒自己，你并不像世界上每个恶意软件作者的组合那样聪明。
- en: What Packet Filtering Doesn’t Do
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据包过滤无法做到的事情
- en: Packet filtering controls network connections based entirely on TCP/IP protocols
    and related characteristics, such as port numbers. If you want to block all traffic
    from certain IP addresses, packet filtering is your friend. If you want to allow
    only connections to a particular TCP/IP port, packet filtering will work for you.
    If you want to allow entrance only to packets with the ECN flag set, but no other
    flags, PF will support you (even though that’s a pretty daft thing to do).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包过滤根据TCP/IP协议和相关特性（如端口号）完全控制网络连接。如果你想阻止来自某些IP地址的所有流量，数据包过滤是你的朋友。如果你想只允许连接到特定的TCP/IP端口，数据包过滤将为你工作。如果你想只允许设置ECN标志的包进入，但没有其他标志，PF将支持你（尽管这听起来相当愚蠢）。
- en: You can filter protocols that operate at a logical protocol layer such as IPsec,
    SKIP, VINES, and so on, but only on the network protocol. If it’s a different
    protocol layer, PF can’t help.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以过滤在逻辑协议层运行的协议，如IPsec、SKIP、VINES等，但仅限于网络协议。如果是在不同的协议层，PF就无能为力了。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PF can even filter by MAC address. There’s special support for this specific
    media layer protocol via tags added on `bridge(4)` interfaces, as documented in
    `ifconfig(4)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PF甚至可以根据MAC地址进行过滤。通过在`bridge(4)`接口上添加的标签，对这种特定的媒体层协议提供了特殊支持，如`ifconfig(4)`文档所述。
- en: Similarly, PF doesn’t know anything about applications or application protocols.
    If you allow TCP/IP connections to port 25 on a server within your network, you
    might think that you’re allowing connections to the mail server on that host.
    Actually, you’re allowing connections to whatever daemon happens to be running
    on port 25 on that host! PF doesn’t recognize an SMTP data stream; it sees only
    that the connection goes to port 25\. (I have a system that offers SSH on many
    ports commonly assigned to other services, just so I can saunter past whatever
    naïve packet filter I happen to be stuck behind.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，PF 对应用程序或应用程序协议一无所知。如果您允许您的网络内服务器的 TCP/IP 连接到端口 25，您可能会认为您正在允许连接到该主机上的邮件服务器。实际上，您正在允许连接到该主机上运行在端口
    25 上的任何守护进程！PF 不识别 SMTP 数据流；它只看到连接到端口 25。 (我有一个系统在许多通常分配给其他服务的端口上提供 SSH，这样我就可以轻松绕过任何我可能陷入的简单数据包过滤器。)
- en: PF Components
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PF 组件
- en: Before we dive into PF, let’s look at the basic components of packet filtering
    on OpenBSD. In addition to the `pf(4)` kernel module, we’ll look at the packet
    filter control program and the configuration file */etc/pf.conf*. Knowledge of
    interface groups also helps.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 PF 之前，让我们看看 OpenBSD 上数据包过滤的基本组件。除了 `pf(4)` 内核模块外，我们还将查看数据包过滤器控制程序和配置文件
    */etc/pf.conf*。了解接口组也有帮助。
- en: Packet Filter Control and Configuration
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据包过滤器控制和配置
- en: Use the packet filter control program `pfctl(8)` to manage, configure, and extract
    information from PF. You can see the current packet filter rules and settings,
    connections being processed, the state of the TCP/IP transactions, debugging information,
    and all kinds of other details. You can also parse rules files and install them
    in the actual packet filter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据包过滤器控制程序 `pfctl(8)` 来管理、配置和从 PF 中提取信息。您可以看到当前的包过滤规则和设置、正在处理连接、TCP/IP 事务的状态、调试信息以及各种其他细节。您还可以解析规则文件并将它们安装到实际的数据包过滤器中。
- en: You’ll see many different options for `pfctl`, addressing every aspect of packet-filter
    management. Many of these are rather lengthy, but you need to type only as much
    of the word arguments to make a command unique. For example, instead of typing
    `pfctl -s rules`, you can get away with `pfctl -sr` because no other argument
    to `pfctl -s` begins with an `r`. That said, I give all examples in their full
    form, as it’s impossible to guarantee that OpenBSD won’t add some other argument
    that begins with `r` in the future.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到许多针对 `pfctl` 的不同选项，涵盖了数据包过滤管理的各个方面。其中许多选项相当长，但您只需输入足够多的单词参数来使命令独特。例如，您不必输入
    `pfctl -s rules`，只需输入 `pfctl -sr` 就可以，因为没有其他 `pfctl -s` 的参数以 `r` 开头。话虽如此，我给出所有示例的完整形式，因为无法保证
    OpenBSD 不会在未来添加以 `r` 开头的其他参数。
- en: I focus on using `pfctl` for viewing PF output, but OpenBSD also includes PF
    views in `systat(1)`. For a dynamic display of PF activity, somewhat like `top(1)`
    for the network, look at `systat`. Run `systat` by giving the name of the view
    as an argument, such as `systat pf`. And, as always, any time you want more detail
    from `pfctl`, add one or two `-v` arguments for verbose mode.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我专注于使用 `pfctl` 来查看 PF 输出，但 OpenBSD 还在 `systat(1)` 中包含了 PF 视图。对于 PF 活动的动态显示，类似于网络中的
    `top(1)`，请查看 `systat`。通过提供视图名称作为参数来运行 `systat`，例如 `systat pf`。并且，一如既往，如果您想从 `pfctl`
    获取更多详细信息，请添加一个或两个 `-v` 参数以启用详细模式。
- en: You configure PF in */etc/pf.conf*. The *pf.conf* file contains statements and
    rules, whose format varies with the features they configure. You’ll be very good
    friends with this file before we’re through.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 */etc/pf.conf* 中配置 PF。*pf.conf* 文件包含语句和规则，其格式根据它们配置的功能而变化。在我们完成之前，您将非常熟悉这个文件。
- en: Interface Groups
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口组
- en: 'OpenBSD lets you put interfaces in named groups, which you can refer to in
    PF rules. This abstracts away the actual physical interface, and lets you build
    policy-based rulesets. Take a look at this interface:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 允许您将接口放入命名组中，您可以在 PF 规则中引用这些组。这抽象了实际的物理接口，并允许您构建基于策略的规则集。看看这个接口：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This interface is in the `egress` group. An interface is assigned to the `egress`
    group if a default route is reached over it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口位于 `egress` 组中。如果一个默认路由通过该接口到达，则该接口将被分配到 `egress` 组。
- en: To move this interface to a new group, `dmz`, remove it from the `egress` group
    and add it to the `dmz` group. An interface group is created when you assign the
    first interface to it, and one interface can be in any number of groups.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此接口移动到新的组 `dmz`，请将其从 `egress` 组中删除并添加到 `dmz` 组中。当您将第一个接口分配给它时，将创建一个接口组，一个接口可以属于任意数量的组。
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can now write rules that reference interface groups instead of specific
    interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以编写引用接口组而不是特定接口的规则。
- en: PF Configuration
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PF 配置
- en: Let’s dismantle the default *pf.conf* from an OpenBSD system and identify some
    parts. Many of the default entries are commented out, but identifying them will
    help you understand how the components fit together.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拆解一个 OpenBSD 系统中的默认 *pf.conf* 文件，并识别一些部分。许多默认条目已被注释掉，但识别它们将有助于你理解组件是如何组合在一起的。
- en: 'It begins with an *option*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它从一个 *选项* 开始：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Options turn features on and off, or set general rules on how other features
    behave. The `skip` option disables PF on a per-interface basis.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 选项可以打开或关闭功能，或设置其他功能的行为的一般规则。`skip` 选项根据接口禁用 PF。
- en: 'Next comes the `anchor` setting:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `anchor` 设置：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An *anchor* is a set of dynamic sub-rules for packet filtering. If a packet
    hits an anchor as it’s processed through the filter rules, it’s dropped into this
    sub-ruleset for further processing. `pfctl` can change the rules running in the
    kernel, and an anchor is a way of saying, “Add new rules here.”
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *锚点* 是一组用于数据包过滤的动态子规则。如果一个数据包在通过过滤规则处理时击中锚点，它将被丢弃到这个子规则集中进行进一步处理。`pfctl`
    可以更改内核中运行的规则，而锚点是一种说“在这里添加新规则”的方式。
- en: Anchors are generally used for letting outside software add rules to the firewall.
    For example, FTP is a complicated protocol that requires all sorts of firewall
    rules. OpenBSD includes an FTP proxy that dynamically adds the necessary rules
    for permitted FTP connections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点通常用于允许外部软件向防火墙添加规则。例如，FTP 是一种复杂的协议，需要各种防火墙规则。OpenBSD 包含一个 FTP 代理，它可以动态地添加允许的
    FTP 连接所需的所有规则。
- en: 'Then come two *packet-filtering* rules:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是两个 *数据包过滤* 规则：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first is a rule to support FTP traffic, in combination with the FTP anchor.
    We’ll look at anchors and FTP handling in more detail in the next chapter. The
    other is a much simpler packet-filtering rule, which permits all traffic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是支持 FTP 流量的规则，与 FTP 锚点结合使用。我们将在下一章中更详细地探讨锚点和 FTP 处理。另一个是一个更简单的数据包过滤规则，允许所有流量。
- en: 'Up next are two *tables*, which are lists of IP addresses:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是两个 *表格*，它们是 IP 地址的列表：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: External programs can dynamically alter tables, and you can add addresses to
    tables directly within *pf.conf* or in an external file. These two tables are
    used by the antispam software `spamd(8)`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 外部程序可以动态地更改表格，你可以在 *pf.conf* 或外部文件中直接向表格添加地址。这两个表格由反垃圾邮件软件 `spamd(8)` 使用。
- en: 'After the tables is another packet-filtering rule:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表格之后是另一个数据包过滤规则：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This rule is interesting in that it refers to an interface group. Traffic is
    permitted in, as long as it arrives on an interface in the `egress` group.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则很有趣，因为它指的是一个接口组。只要流量到达 `egress` 组中的接口，就允许进入。
- en: 'And the final rule is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条规则如下：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This packet-filtering rule stops traffic. If a packet arrives on any interface
    except the loopback interface, and the packet is a TCP protocol going to port
    6000 through 6010 inclusive, it is blocked.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这条数据包过滤规则阻止流量。如果一个数据包到达除了环回接口之外的任何接口，并且该数据包是 TCP 协议，目标端口为 6000 到 6010（包括 6010），则会被阻止。
- en: This is the sort of thing you’ll see in *pf.conf*. Let’s dive into some specifics
    of filtering rules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 *pf.conf* 中你会看到的东西。让我们深入了解过滤规则的具体细节。
- en: Filtering Rules
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤规则
- en: Filtering rules are the heart of PF. You can use PF without doing any of the
    fancy redirection, address translation, load balancing, or redundancy, but packet
    filtering is the bedrock on which most of these features are based. To start with,
    however, basic packet filtering is defined as access control for network packets
    by source, destination, protocol, and protocol characteristics.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤规则是 PF 的核心。你可以不进行任何花哨的重定向、地址转换、负载均衡或冗余操作来使用 PF，但数据包过滤是大多数这些功能的基础。然而，首先，基本的包过滤被定义为通过源、目的、协议和协议特性对网络数据包进行访问控制。
- en: 'PF processes filtering rules in order. The last rule that matches a packet
    is acted on. A typical packet-filtering rule looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: PF 按顺序处理过滤规则。最后匹配到数据包的规则将被执行。一个典型的数据包过滤规则看起来像这样：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first word of the filter rule is a keyword that describes the results of
    this rule **1**. PF will either `pass` or `block` packets that match a rule. (There’s
    also `match`, which we’ll look at in the next chapter.) The rest of the line is
    a description of matching packets. If the packet matches the description, the
    rule is applied.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤规则的第一词是一个关键字，描述了该规则的结果**1**。PF将根据规则“通过”或“阻塞”匹配的数据包。 （还有“匹配”，我们将在下一章中探讨。）该行的其余部分是对匹配数据包的描述。如果数据包与描述匹配，则应用该规则。
- en: The second statement is the direction the packet is going. Packets are either
    going in or out. In this rule, the packet is going `in` **2**—it is entering the
    system. Not only do we define a direction, but we also define an interface group.
    Packets must be entering this system on an interface in the `egress` group to
    match this rule **3**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句是数据包的方向。数据包要么进入要么出去。在这个规则中，数据包是进入的**2**——它正在进入系统。我们不仅定义了方向，还定义了一个接口组。数据包必须通过`egress`组中的接口进入此系统才能匹配此规则**3**。
- en: We then have several statements that define traffic characteristics. (This rule
    is almost like a regular expression for TCP/IP.) This rule applies to TCP connections
    **4**, coming from any IP address **5**, if the connection is made to the IP address
    192.0.2.12 **6** on port 80 **7**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有几个定义流量特征的语句。（这个规则几乎就像TCP/IP的正则表达式。）此规则适用于来自任何IP地址**5**的TCP连接**4**，如果连接是到IP地址192.0.2.12**6**的端口80**7**。
- en: If a packet matches all of these characteristics, it can pass. If any of these
    characteristics isn’t matched, the packet does not match this rule, and PF continues
    processing the rules, looking for a matching one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据包与所有这些特征匹配，它就可以通过。如果这些特征中的任何一个不匹配，数据包就不符合这个规则，PF会继续处理规则，寻找匹配项。
- en: TCP and UDP rules implicitly check connection state. A TCP packet that matches
    this rule needs to be a SYN packet, the start of a standard TCP/IP connection.
    PF uses the state table to manage follow-up packets in the same connection (see
    [Filtering Rules and the State Table](ch21.html#filtering_rules_and_the_state_table
    "Filtering Rules and the State Table")).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP规则隐式检查连接状态。匹配此规则的数据包需要是一个SYN数据包，即标准TCP/IP连接的开始。PF使用状态表来管理同一连接中的后续数据包（参见[过滤规则和状态表](ch21.html#filtering_rules_and_the_state_table
    "过滤规则和状态表")）。
- en: Default Permit or Default Deny
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认允许或默认拒绝
- en: 'I touched earlier on the idea of default accept versus default deny. Set this
    stance at the beginning of your packet-filtering rules with one of the following
    two statements:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到了默认接受与默认拒绝的概念。在您的数据包过滤规则开始时设置这种立场，可以使用以下两个语句之一：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The default *pf.conf* has a default pass stance, but it’s for people who haven’t
    yet configured a firewall. I recommend starting your filter rules with a lone
    `block` statement, and then adding rules to explicitly permit desirable traffic.
    Remember that the last matching rule wins.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的*pf.conf*具有默认通过立场，但它是为尚未配置防火墙的人准备的。我建议从单独的`block`语句开始您的过滤规则，然后添加规则以明确允许期望的流量。请记住，最后一个匹配的规则获胜。
- en: Packet Pattern Matching
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据包模式匹配
- en: One of the most intensive parts of PF is the syntax used to describe packets.
    Most filter rules describe packets by protocol, port, direction, and other characteristics.
    PF compares each arriving packet to the state table, and if the packet isn’t part
    of the state table, it compares the packet to the filter rules. If the rule matches
    the packet description, the packet is passed or blocked as desired.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PF最密集的部分之一是用于描述数据包的语法。大多数过滤规则通过协议、端口、方向和其他特征来描述数据包。PF将每个到达的数据包与状态表进行比较，如果数据包不是状态表的一部分，它将数据包与过滤规则进行比较。如果规则与数据包描述匹配，则按需通过或阻塞数据包。
- en: Once you define whether you’re in a default accept or default deny stance, the
    filter rules describe exceptions to your default. So if you block packets by default,
    most of your filter rules will be `pass` statements that describe particular desirable
    connections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了您是在默认接受还是默认拒绝立场，过滤规则就描述了默认规则的例外。因此，如果您默认阻止数据包，您的大多数过滤规则将是描述特定期望连接的“通过”语句。
- en: Direction
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方向
- en: The keywords `in` and `out` describe the direction the packets are going. In
    many commercial firewalls, the word `in` means traffic entering the protected
    network, and `out` refers to traffic leaving the protected network. OpenBSD does
    not magically know which side of the network is protected and which is not. As
    far as PF knows, it’s managing traffic between two interfaces. The keyword `in`
    means traffic flowing into the machine from the network, and `out` means traffic
    leaving the machine and entering the network.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`in`和`out`描述了数据包的传输方向。在许多商业防火墙中，`in`一词表示进入受保护网络的流量，而`out`指的是离开受保护网络的流量。OpenBSD不会神奇地知道网络的哪一侧是受保护的，哪一侧不是。在PF看来，它正在管理两个接口之间的流量。关键字`in`表示从网络流入机器的流量，而`out`表示离开机器并进入网络的流量。
- en: When you see `in` or `out` in a PF rule, do not think about your network as
    a whole. Instead, imagine that you’re very small and sitting on your CPU, grilling
    steaks over the heat sink and watching packets enter and leave the computer. You
    cannot see what lies beyond the case, just the packets as they come and go. Packets
    coming in are approaching you, and packets going out are receding.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在PF规则中看到`in`或`out`时，不要将整个网络视为一个整体。相反，想象你自己非常小，坐在CPU上，在散热器上烤牛排，并观察数据包进入和离开计算机。你无法看到箱体之外的情况，只能看到来去的数据包。进入的数据包正在接近你，而出去的数据包正在远离你。
- en: Interface Matching
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口匹配
- en: The `on` keyword describes an interface or interface group to which this rule
    applies. You must specify an interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`on`关键字描述了此规则适用的接口或接口组。您必须指定一个接口。'
- en: 'If you want a rule to match every interface on the system, use the interface
    name `all`. This example stops all traffic entering the machine on the interface
    `fxp0`, but allows all traffic leaving the system on the interface group `egress`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让规则匹配系统上的每个接口，请使用接口名称`all`。此示例阻止所有进入机器的接口`fxp0`上的流量，但允许所有通过接口组`egress`离开系统的流量：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This ruleset implies that interface `fxp0` is special for some reason, so it’s
    not treated like the rest of the `egress` group.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则集意味着接口`fxp0`由于某种原因而特殊，因此它不像`egress`组中的其他接口那样被处理。
- en: Address Families
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 地址族
- en: 'Rules can apply to specific address families, either `inet` for IPv4 or `inet6`
    for IPv6\. Here’s how to prohibit IPv4 but permit IPv6:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 规则可以应用于特定的地址族，即`inet`用于IPv4或`inet6`用于IPv6。以下是禁止IPv4但允许IPv6的方法：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Presumably, you have later rules that more tightly restrict IPv6.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有更严格限制IPv6的后续规则。
- en: Network Protocol
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络协议
- en: PF can recognize almost any network protocol by number or name. The `proto`
    keyword tells PF to match a protocol. Network protocols can be given by name from
    */etc/protocols*, protocol number, or even a list (see [Using Lists](ch21.html#using_lists
    "Using Lists")).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PF可以通过数字或名称识别几乎任何网络协议。`proto`关键字告诉PF匹配一个协议。网络协议可以通过名称从`/etc/protocols`、协议号或甚至列表（见[使用列表](ch21.html#using_lists
    "使用列表")）提供。
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can use this to pass protocols other than IP and IPv6\. Here’s how to allow
    the protocols necessary for IPsec:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此方法来通过除IP和IPv6之外的其他协议。以下是允许IPsec所需协议的方法：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This functionality somewhat overlaps the `inet` and `inet6` statements. If you
    prefer, you could explicitly allow IP, ICMP, TCP, UDP, and all the various IPv6
    protocols.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能与`inet`和`inet6`语句有些重叠。如果您愿意，您可以明确允许IP、ICMP、TCP、UDP以及所有各种IPv6协议。
- en: Source and Destination Address
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 源地址和目标地址
- en: Almost every filter rule specifies a source and/or destination address.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个过滤规则都指定了源地址和/或目标地址。
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: IP addresses can appear either as individual addresses or as an address with
    a netmask (as shown in the preceding example). The keyword `any` means any IP
    address. The keyword `all` is shorthand for “from any to any.”
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址可以以单个地址或带有子网掩码的地址（如前例所示）的形式出现。关键字`any`表示任何IP地址。关键字`all`是“从任何到任何”的简称。
- en: You can also use hostnames instead of IP addresses. `pfctl` will check the IP
    address of the host when loading the rules, and insert the actual IP address into
    the rules.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用主机名而不是IP地址。`pfctl`在加载规则时会检查主机的IP地址，并将实际IP地址插入到规则中。
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the IP address of the host changes, PF won’t notice until you reload the
    rules with `pfctl`. If the hostname cannot be found, the rules won’t parse, and
    `pfctl` will not be able to load them. I recommend not using hostnames in filter
    rules, much as I recommend not wearing medieval plate armor while swimming, but
    it is an available option.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机的IP地址发生变化，PF不会注意到，直到你使用`pfctl`重新加载规则。如果找不到主机名，规则将无法解析，`pfctl`将无法加载它们。我建议不要在过滤规则中使用主机名，就像我建议在游泳时不要穿中世纪的板甲一样，但它是一个可用的选项。
- en: To say “anything but this address,” use the exclamation point as a negation
    character.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示“除了这个地址之外的所有内容”，请使用感叹号作为否定字符。
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This says “block everything except the addresses 192.0.2.0/24.” That’s not the
    same as saying “pass 192.0.2.0/24,” but it can help simplify your rules.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示“除了地址192.0.2.0/24之外，所有内容都被阻止。”这与说“允许192.0.2.0/24”不同，但它可以帮助简化你的规则。
- en: You can also use lists, macros, and tables as IP addresses. Lists and macros
    are discussed later in this chapter, and tables are covered in the next chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用列表、宏和表格作为IP地址。列表和宏将在本章后面讨论，表格将在下一章介绍。
- en: Source and Destination Variants
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 源和目标变体
- en: You can use the name of an interface or interface group instead of an IP address.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用接口或接口组的名称而不是IP地址。
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This lets traffic leave via the `egress` interface group, from any IP address
    on any interface in that group, to any IP address.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许流量通过出口接口组离开，从该组中任何接口的任何IP地址到任何IP地址。
- en: If you put the interface name or group in parentheses, PF updates its rules
    whenever the IP address on the interface changes. This is useful for dial-up connections,
    or if you add and remove IP addresses from an interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将接口名称或组放入括号中，PF会在接口上的IP地址更改时更新其规则。这对于拨号连接或当你从接口添加和删除IP地址时非常有用。
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can specify a network that is directly attached to an interface or an interface
    group by following the name with `:network`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在名称后跟`:network`来指定直接连接到接口或接口组的网络。
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Suppose the `egress` group has only one interface, and that interface has an
    IP address of 192.0.2.88/25\. This rule would translate to the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设出口组只有一个接口，并且该接口的IP地址为192.0.2.88/25。这条规则将转换为以下内容：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This rule means that any host on the local network to an `egress` interface
    can communicate anywhere. When you add another interface to the `egress` group,
    the rules automatically update to accommodate the new interface’s network.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则意味着任何连接到出口接口的主机都可以在任何地方进行通信。当你向出口组添加另一个接口时，规则会自动更新以适应新接口的网络。
- en: To filter on broadcast traffic for an interface or group, use the `:broadcast`
    modifier.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤接口或组的广播流量，请使用`:broadcast`修饰符。
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, suppose that the `egress` group has only one interface, and that interface
    has an IP address of 192.0.2.88/25\. This rule would translate to the following,
    blocking broadcast traffic on the local subnet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设出口组只有一个接口，并且该接口的IP地址为192.0.2.88/25。这条规则将转换为以下内容，在本地子网上阻止广播流量：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Use the `:peer` modifier to indicate the IP address of the far side of a point-to-point
    link, such as a dial-up connection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:peer`修饰符来指示点对点链路（如拨号连接）另一端的IP地址。
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we completely trust our dial-up provider.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们完全信任我们的拨号服务提供商。
- en: Interface Main Address
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口主地址
- en: To use only the first IP address on an interface, add the `:0` modifier with
    an interface or group name.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅使用接口上的第一个IP地址，请使用接口或组名称添加`:0`修饰符。
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `egress` interface group might have 98 IP addresses scattered across three
    interfaces, but only one address on each interface is the first address. This
    host can communicate out through the `egress` interface group, but only from primary
    IP addresses. The aliased IP addresses cannot initiate outbound connections.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 出口接口组可能有98个IP地址分布在三个接口上，但每个接口上只有一个地址是第一个地址。此主机可以通过出口接口组进行通信，但只能从主IP地址进行通信。别名IP地址不能发起出站连接。
- en: The problem with the `:0` modifier is that the kernel has a very weak idea of
    what is the “first” address on an interface. The kernel has a list of addresses
    associated with an interface. The address at the top of this list is the “first”
    or “main” address at the moment, but this address can change. If this might cause
    problems, specify an IP address in your rule rather than rely on `:0`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`:0` 修饰符的问题在于内核对接口上“第一个”地址的概念非常模糊。内核有一个与接口关联的地址列表。列表顶部的地址是当前“第一个”或“主要”地址，但这个地址可能会改变。如果这可能会引起问题，请在你的规则中指定
    IP 地址，而不是依赖 `:0`。'
- en: You can attach `:0` to any of the other interface modifiers, that is, to IP
    addresses other than the first from the rule. OpenBSD can’t tell if IP addresses
    on remote machines are aliases or actual IP addresses, but you can prohibit traffic
    to or from aliases on the local machine.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `:0` 附在任何其他接口修饰符上，即除了规则中的第一个地址之外的 IP 地址。OpenBSD 无法判断远程机器上的 IP 地址是别名还是实际
    IP 地址，但你可以在本地机器上禁止对或来自别名的流量。
- en: Note that the first address on an interface is either an IPv4 address *or* an
    IPv6 address. If you want to allow the first address of each protocol, specify
    the address family in the rule.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，接口上的第一个地址要么是 IPv4 地址 *要么* 是 IPv6 地址。如果你想允许每个协议的第一个地址，请在规则中指定地址族。
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Otherwise, PF will use only the first address it sees, regardless of address
    family.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，PF 将仅使用它看到的第一个地址，无论地址族如何。
- en: Source and Destination Port
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 源和目的端口
- en: Filter rules can describe TCP and UDP ports.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤规则可以描述 TCP 和 UDP 端口。
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example permits access to TCP port 80 on the server 192.0.2.12\. Presumably,
    this is a web server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例允许访问服务器 192.0.2.12 上的 TCP 端口 80。这可能是 Web 服务器。
- en: 'You could use a service name from */etc/services* instead of a port number,
    or even use a list (as described later in this chapter). You can also use ranges,
    as shown in [Table 21-1](ch21.html#port_ranges "Table 21-1. Table 21-1: Port Ranges").'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用来自 */etc/services* 的服务名称而不是端口号，或者甚至使用列表（如本章后面所述）。你还可以使用范围，如[表 21-1](ch21.html#port_ranges
    "表 21-1. 表 21-1：端口范围")所示。
- en: 'Table 21-1. Table 21-1: Port Ranges'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-1. 表 21-1：端口范围
- en: '| Symbol | Meaning |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `!=` | Not equal |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `<` | Less than |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `>` | Greater than |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `<=` | Less than or equal to |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于等于 |'
- en: '| `>=` | Greater than or equal to |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于等于 |'
- en: '| `><` | Range |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `><` | 范围 |'
- en: '| `<>` | Inverse range |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `<>` | 反向范围 |'
- en: For example, to specify all ports over 1024, you could use the greater-than
    operator (`>`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要指定所有大于 1024 的端口，你可以使用大于运算符（`>`）。
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To specify all ports between 1000 and 2000, excluding both 1000 and 2000, use
    the range operator (`><`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定 1000 和 2000 之间的所有端口，不包括 1000 和 2000，请使用范围运算符（`><`）。
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To include ports 1000 and 2000 in your range, use the inclusive range operator
    (`:`). (Note that you cannot have space on either side of the colon.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要将端口 1000 和 2000 包含在你的范围内，使用包含范围运算符（`:`）。(注意，冒号两侧不能有空格。)
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To pass traffic on all ports less than 1000 and greater than 2000, use the inverse
    range operator (`<>`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递所有小于 1000 且大于 2000 的端口的流量，请使用反向范围运算符（`<>`）。
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ranges let you express large numbers of ports in very few rules.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 范围允许你在非常少的规则中表达大量的端口。
- en: A Complete Ruleset
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整规则集
- en: The following is a complete ruleset for a desktop machine, using many of the
    features described previously. We’ll look at some more complicated rulesets later,
    but this illustrates many basic principles of PF rules.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个桌面机的完整规则集，使用了之前描述的许多功能。我们将在后面查看一些更复杂的规则集，但这个例子说明了 PF 规则的许多基本原理。
- en: Interface group `egress` is attached to the public network, and interface group
    `inside` is connected to my private network.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接口组 `egress` 连接到公共网络，而接口组 `inside` 连接到我的私有网络。
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first rule disables packet filtering on the loopback interface **1**, and
    the second defines a default deny stance **2**. The second and third rules permit
    all connections from IP addresses directly connected to the external **3** and
    internal interfaces **4**. If I install a web server on my desktop, I want to
    be able to view it from any machine on the network I control. Then I permit inbound
    SSH connections from anywhere in the world to the primary IP address on any `egress`
    interface **5**. Finally, I permit all outbound traffic, so my desktop can freely
    access the outside world **6**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则禁用了回环接口 **1** 的数据包过滤，第二条定义了一个默认拒绝立场 **2**。第二条和第三条规则允许来自直接连接到外部 **3** 和内部接口
    **4** 的 IP 地址的所有连接。如果我在我的桌面上安装一个 Web 服务器，我希望能够从网络中任何我控制的机器上查看它。然后我允许来自世界任何地方的任何
    `egress` 接口的 IP 地址的 SSH 连接进入。最后，我允许所有出站流量，这样我的桌面就可以自由访问外部世界 **6**。
- en: I’ve said before that PF rules are processed in order, and these rules illustrate
    that. I establish a default, blocking all traffic, and then use individual rules
    to carve out exceptions to that global block.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，PF 规则按顺序处理，这些规则说明了这一点。我设置了一个默认规则，阻止所有流量，然后使用单个规则来排除全局阻止的例外。
- en: Activating Rules
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活规则
- en: For your PF rules to take effect, you must load them into the kernel using `pfctl
    -f`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的 PF 规则生效，你必须使用 `pfctl -f` 将它们加载到内核中。
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, `pfctl` reads and parses the rules file. If the file parses correctly,
    `pfctl` expands any variables in the file, performs any necessary DNS lookups
    to transform hostnames into IP addresses, and feeds the complete rules into the
    kernel. The kernel reads the new rules, and then swaps between the old and new
    rules in one operation. At no time are the packet-filtering rules missing, scrambled,
    or a hybrid of the two rulesets. Also note that `pfctl -f` won’t enable PF if
    it’s disabled.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`pfctl` 读取并解析规则文件。如果文件解析正确，`pfctl` 将扩展文件中的任何变量，执行任何必要的 DNS 查询以将主机名转换为 IP
    地址，并将完整的规则馈送到内核。内核读取新的规则，然后在一次操作中在旧规则和新规则之间切换。在任何时候，数据包过滤规则都不会缺失、混乱或两个规则集的混合体。另外请注意，`pfctl
    -f` 不会在禁用的情况下启用 PF。
- en: Personally, I like to know that my edited packet-filter configuration parses
    before the scheduled change time. It’s embarrassing to announce to your team that
    “the new firewall configuration will be active at noon” and spend the whole time
    tracking down a misplaced comma or a parenthesis where you should have put in
    a curly brace. To test your syntax without installing the rules, use the `-n`
    flag with `-f`. Add `-v` for verbose mode, to see how `pfctl` expands your macros,
    groups, and so on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我喜欢知道我的编辑过的数据包过滤配置在预定更改时间之前已经解析。当宣布给团队“新的防火墙配置将在中午生效”并花了一整天的时间追踪一个放错位置的逗号或括号，你应该放花括号时，这会让人感到尴尬。为了在不安装规则的情况下测试你的语法，请使用
    `-n` 标志与 `-f` 一起使用。添加 `-v` 以启用详细模式，以查看 `pfctl` 如何扩展你的宏、组等。
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The rules might still have errors, but only errors of comprehension rather than
    syntax.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 规则可能仍然有错误，但只是理解上的错误，而不是语法错误。
- en: Loading new rules doesn’t remove any existing open connections or state entries.
    If my old ruleset allowed outbound SSH connections, and I remove that permission
    from the newly installed rules, existing SSH connections remain open. I can either
    specifically kill those connections with `pfctl -k` or flush the state table.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 加载新规则不会删除任何现有的开放连接或状态条目。如果我的旧规则集允许出站 SSH 连接，而我从新安装的规则中移除了该权限，现有的 SSH 连接仍然保持开放。我可以使用
    `pfctl -k` 特意终止这些连接，或者刷新状态表。
- en: Viewing Active Rules
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看活动规则
- en: 'To see how these rules are interpreted inside PF, view the currently installed
    ruleset with `pfctl -s rules`. Here are the rules generated by the configuration
    in [A Complete Ruleset](ch21.html#a_complete_ruleset "A Complete Ruleset"):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些规则在 PF 内部的解释，请使用 `pfctl -s rules` 查看当前安装的规则集。以下是 [一个完整的规则集](ch21.html#a_complete_ruleset
    "一个完整的规则集") 中配置生成的规则：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first rule establishes a default deny stance **1**. I then specifically
    allow connections from hosts on the networks local to interfaces in the `egress`
    group, for both IPv6 **2** and IPv4 **3**. This desktop also accepts connections
    from my private network **4**.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则建立了一个默认拒绝立场 **1**。然后我特别允许来自 `egress` 组中接口的本地网络的连接，无论是 IPv6 **2** 还是 IPv4
    **3**。这个桌面还接受来自我的私有网络的连接 **4**。
- en: The private network permits connections only from IPv4 addresses because the
    interface in the private group has only an IPv4 address. (I really should add
    an IPv6 address, but it hasn’t caused me any trouble, so I’ll probably forget
    all about it once again.) Then there’s a rule permitting inbound SSH traffic **5**,
    followed by a final rule to pass all outbound traffic **6**.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 私有网络只允许来自IPv4地址的连接，因为私有组中的接口只有一个IPv4地址。（我真的很应该添加一个IPv6地址，但它没有给我带来任何麻烦，所以我又可能再次忘记它。）然后有一个规则允许传入的SSH流量**5**，接着是一个最终规则允许所有传出流量**6**。
- en: If I change any IP address on my desktop, my firewall rules update to accommodate
    them. That’s a really nice feature of interface groups. If I moved my desktop
    regularly, I would put the interface group names in parentheses so PF would watch
    for IP address changes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在我的桌面电脑上更改任何IP地址，防火墙规则会自动更新以适应这些更改。这是接口组的一个非常实用的功能。如果我的桌面电脑经常移动，我会把接口组名称放在括号里，这样PF就会监视IP地址的更改。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing you’ll probably notice is that the pass rules end with `flags S/SA`.
    This means that out of the SYN and ACK flags, matching packets can have only the
    SYN flag set, indicating that these are requests to establish a connection. You
    can filter on TCP flags, but doing so requires in-depth understanding of TCP,
    and most people should never do it. To see how SYN and SYN+ACK packets affect
    connections, you need to understand the state table.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，通过规则以`flags S/SA`结束。这意味着在SYN和ACK标志中，匹配的包只能设置SYN标志，表示这些是建立连接的请求。你可以根据TCP标志进行过滤，但这需要深入理解TCP，大多数人应该永远不要这样做。要了解SYN和SYN+ACK包如何影响连接，你需要理解状态表。
- en: To see how often a packet triggers each rule, add `-v` to the `pfctl` command.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个规则被触发多少次，请在`pfctl`命令中添加`-v`。
- en: To see how the rules impact traffic in a constantly updating display, run `systat
    rules`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看规则如何影响不断更新的显示中的流量，请运行`systat rules`。
- en: Filtering Rules and the State Table
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤规则和状态表
- en: 'OpenBSD tracks approved connections in the state table. Packets that are part
    of an approved connection are allowed to pass. Consider this rule from an earlier
    example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD在状态表中跟踪已批准的连接。属于已批准连接的包允许通过。考虑以下早期示例中的规则：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If a packet matches this rule, and it has the TCP/IP flags that indicate this
    is the start of a TCP connection, PF permits the connection. PF also makes an
    entry in the state table. If a packet arrives that matches the state table, PF
    passes the packet without consulting the rules.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包匹配此规则，并且它具有指示这是TCP连接开始的TCP/IP标志，PF允许该连接。PF还在状态表中创建一个条目。如果一个包与状态表匹配，PF将直接传递该包，而无需查阅规则。
- en: TCP States
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP状态
- en: First, we’ll look at a state table entry for a TCP connection. To view the state
    table, enter **`pfctl -s states`**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看TCP连接的状态表条目。要查看状态表，请输入**`pfctl -s states`**。
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This state table entry represents one specific connection that the packet filter
    approved. This state applies to all interfaces **1**. If a state applies to only
    one interface, you’ll see the interface name here.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态表条目代表一个包过滤器批准的特定连接。这个状态适用于所有接口**1**。如果一个状态只适用于一个接口，你将在这里看到接口名称。
- en: This TCP connection **2** was bound for 192.0.2.12 port 80 **3**, and came from
    the host 198.51.100.227 port 55635 **4**. When the first SYN packet arrived from
    198.51.100.227 port 55635, PF added this entry to the state table. When 192.0.2.12
    sent a SYN+ACK packet back to 198.51.100.227 port 55635, PF consulted the state
    table. This was clearly a match to the permitted SYN packet, so PF permitted that
    packet, even though no explicit rule in *pf.conf* permitted that connection. Data
    exchange between these two hosts and these two ports proceeded.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个TCP连接**2**目标是192.0.2.12端口80**3**，来自主机198.51.100.227端口55635**4**。当第一个来自198.51.100.227端口55635的SYN包到达时，PF将此条目添加到状态表中。当192.0.2.12向198.51.100.227端口55635发送SYN+ACK包时，PF查阅了状态表。这显然是一个与允许的SYN包匹配的匹配项，所以PF允许了该包，尽管在*pf.conf*中没有明确的规则允许该连接。这两个主机和这两个端口之间的数据交换继续进行。
- en: PF knows what an actual TCP/IP data exchange looks like. There’s a three-way
    handshake in the beginning, and a similar dance when the connection is finished
    and PF tracks the state of the connection. This particular connection is established
    on both sides **5**, meaning that the initial setup negotiation succeeded, and
    data can flow back and forth freely.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: PF知道实际的TCP/IP数据交换看起来是什么样子。开始时有一个三次握手，当连接完成且PF跟踪连接状态时，有一个类似的舞蹈。这个特定的连接在双方**5**上建立，这意味着初始设置协商成功，数据可以自由地来回流动。
- en: 'If your server is busy enough, and you keep refreshing the state table view,
    you’ll catch connections in other states. Here’s the same connection as the data
    exchange ends and is being torn down:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的服务器足够繁忙，并且您不断刷新状态表视图，您将捕捉到其他状态下的连接。以下是数据交换结束并被拆除时的相同连接：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One possible problem with viewing the state table is that `pfctl` displays a
    snapshot. By the time your eyes scroll down the screen, the table has changed.
    Personally, I find that’s the only way I can cope with the information. If you
    need to view states in a constantly updating display, in near real time, run `systat
    states`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 查看状态表可能存在的一个问题是`pfctl`显示的是快照。当您的眼睛滚动到屏幕底部时，表格已经改变。我个人认为这是唯一能够处理信息的方式。如果您需要在一个不断更新的显示中查看状态，在几乎实时的情况下，请运行`systat
    states`。
- en: The state table is very specific. A state table entry permitting 198.51.100.227
    port 55635 to 192.0.2.12 port 80 does not permit traffic between other hosts and
    ports. PF knows how traffic should flow, and it won’t allow traffic that isn’t
    obviously part of an existing TCP/IP exchange. If a packet arrives from 198.51.100.227
    that looks like it’s part of this data exchange, except that it comes from port
    55634 instead of 55635, the state table entry won’t match. Similarly, if PF knows
    that the connection is in a `FIN_WAIT_2` state, or almost finished, a subsequent
    data packet with an ACK flag set won’t match and will be discarded. This is because
    a SYN request from the same host, from the same port, should not arrive—the client
    should know that the port is busy closing the previous connection. A new connection
    should come from a different port on the client and create a new state table entry.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 状态表非常具体。允许198.51.100.227端口55635到192.0.2.12端口80的状态表条目不允许其他主机和端口之间的流量。PF知道流量应该如何流动，并且不会允许显然不属于现有TCP/IP交换的流量。如果一个来自198.51.100.227的数据包看起来像是这个数据交换的一部分，除了它来自端口55634而不是55635之外，状态表条目不会匹配。同样，如果PF知道连接处于`FIN_WAIT_2`状态，或者几乎完成，那么设置ACK标志的后续数据包不会匹配并将被丢弃。这是因为来自同一主机、同一端口的SYN请求不应该到达——客户端应该知道端口正在关闭之前的连接。新的连接应该来自客户端的不同端口并创建新的状态表条目。
- en: Without stateful inspection, you would need to write firewall rules that not
    only permitted incoming traffic, but also permitted the responses. Your firewall
    rules would need to permit outbound connections to thousands of high-numbered
    ports, instead of just the single ports attached to desirable connections. Filtering
    based on TCP flags would be nearly impossible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 没有状态检查，您需要编写的防火墙规则不仅允许传入流量，还允许响应。您的防火墙规则需要允许对数千个高编号端口的出站连接，而不仅仅是与所需连接相关联的单个端口。基于TCP标志的过滤几乎是不可能的。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a consultant in the 1990s, I made a couple of rent payments dismantling such
    rules that had been shoehorned into stateless packet filters because they just
    aren’t realistic without stateful inspection. Plus, carefully tracking data exchanges
    not only simplifies rules, but also prevents a whole slew of TCP/IP-based attacks.
    You don’t hear much about these attacks anymore, thanks to stateful inspection.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为20世纪90年代的一名顾问，我拆除了几条被强行塞入无状态包过滤器的规则，因为这些规则在没有状态检查的情况下并不现实。此外，仔细跟踪数据交换不仅简化了规则，还防止了一系列基于TCP/IP的攻击。由于状态检查，您现在很少听到这些攻击。
- en: UDP States
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDP状态
- en: The state entries for UDP connections are similar to those for TCP connections.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: UDP连接的状态条目与TCP连接的状态条目相似。
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a DNS query, bound for 192.0.2.12 port 53 from 198.51.100.227 port 38469\.
    The client sent a single packet, and the destination replied with multiple packets.
    While stateful inspection cannot identify the state of this connection by flags,
    it can track the source and destination addresses and ports. You would need to
    write only a single rule permitting access to 192.0.2.12 port 53, and stateful
    inspection would permit the matching reply packets.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个DNS查询，目标为192.0.2.12端口53，来自198.51.100.227端口38469。客户端发送了一个数据包，目标以多个数据包回复。虽然状态检查不能通过标志识别此连接的状态，但它可以跟踪源地址和目标地址以及端口。你只需要写一条规则允许访问192.0.2.12端口53，状态检查将允许匹配的回复数据包。
- en: ICMP States
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ICMP状态
- en: ICMP falls somewhere in between TCP and UDP. PF is aware of ICMP types and knows
    legitimate responses to ICMP packets, and by using stateful inspection, you get
    all of these benefits automatically. Much as you could write rules that permit
    specific TCP flags, you can write rules that permit certain ICMP types and codes.
    Most of us cannot manage that, and those of us who can know better. (ICMP errors
    referring to an existing TCP or UDP state are matched to the state, and don’t
    need to be allowed separately.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP位于TCP和UDP之间。PF了解ICMP类型，并知道对ICMP数据包的合法响应，通过使用状态检查，你可以自动获得所有这些好处。就像你可以编写允许特定TCP标志的规则一样，你也可以编写允许特定ICMP类型和代码的规则。我们大多数人无法做到这一点，而那些能够做到的人知道得更多。（指向现有TCP或UDP状态的ICMP错误将与该状态匹配，不需要单独允许。）
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenBSD’s stateful inspection actually tracks more detail than source and destination
    addresses and ports. Add `-v` to the `pfctl` command to see more information,
    including timing, the number of packets passed as a result of the state, and more.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD的状态检查实际上跟踪的细节比源地址、目标地址和端口更多。将`-v`添加到`pfctl`命令中，以查看更多信息，包括时间、由于状态而通过的数据包数量等。
- en: Packet Filtering with Lists and Macros
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列表和宏进行数据包过滤
- en: PF includes many ways to have one rule reference several similar items, or symbolically
    represent something with a variable. The basic ways are lists and macros.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: PF提供了许多方法，让一条规则引用多个相似的项目，或者用变量符号表示某物。基本的方法是列表和宏。
- en: Using Lists
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'A *list* is a way to represent several similar items in one rule. You might
    want to use a list if, for example, you want a particular group of TCP ports open
    on a certain group of hosts, and your rule entries would be repetitions of one
    rule with minor changes. Opening ports 80 and 443 to one host requires two rules:
    one for each port. If you have 30 web servers, you would need 60 rules. This is
    a pain to maintain and error-prone, but lists let you express these common elements
    more easily.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是在一条规则中表示多个相似项目的一种方式。如果你想要在特定的一组主机上打开特定的TCP端口组，并且你的规则条目是重复一条规则并做些小修改，那么你可能想使用列表。例如，打开80和443端口到一台主机需要两条规则：一条对应每个端口。如果你有30台Web服务器，你需要60条规则。这很麻烦，容易出错，但列表让你更容易表达这些常见的元素。'
- en: A list is represented in curly braces within a rule. To make the rule more readable,
    you can put a comma between items.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在规则中用花括号表示。为了使规则更易读，你可以在项目之间放置逗号。
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This one *pf.conf* statement creates two rules, opening both TCP ports 80 and
    443 to the target host.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这一条`pf.conf`语句创建了两个规则，同时打开目标主机的TCP端口80和443。
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You could also use a list to have this rule cover multiple web servers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用列表让这条规则覆盖多个Web服务器。
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This expands to four rules: one for each combination of server and port.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将扩展为四条规则：每条规则对应服务器和端口的组合。
- en: Remember that each entry in the list creates its own rules. The list entries
    do not combine to create a single rule.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，列表中的每个条目都会创建自己的规则。列表条目不会组合成一条规则。
- en: Using Macros
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用宏
- en: A macro is a variable that you create and define for use within PF rules. Macros
    keep *pf.conf* more readable, maintainable, and manageable.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是你创建并定义用于PF规则中的变量。宏使`pf.conf`更易读、可维护和管理。
- en: Macro names must begin with a letter, but can include letters, numbers, and
    underscores. You cannot give a macro a name that’s used elsewhere in PF, like
    `pass`, `block`, or `proto`. Frequent uses of macros include interface names,
    network addresses, and ports.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 宏名称必须以字母开头，但可以包含字母、数字和下划线。你不能给宏起一个在PF中其他地方使用的名字，比如`pass`、`block`或`proto`。宏的常见用途包括接口名称、网络地址和端口。
- en: 'Earlier, we saw a list that included the popular web ports 80 and 443\. You
    could make these a macro, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了一个包括流行的Web端口80和443的列表。你可以将这些作为宏，如下所示：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our sample rule would then become this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的示例规则将变成这样：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When combined with braces, macros can simplify your *pf.conf* file. Consider
    the following *pf.conf* snippet:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当与花括号结合使用时，宏可以简化你的`pf.conf`文件。考虑以下`pf.conf`片段：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This expands to eight rules, but requires only three easy-to-understand configuration
    statements. When you add a new web server, add its IP address to the list in the
    `webservers` macro. What’s more, you might use the `webservers` macro in dozens
    of places throughout your rules. Changing the IP address list once is much easier
    and more likely to be correct than doing so in each rule.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这会扩展为八条规则，但只需要三个易于理解的配置语句。当你添加一个新的Web服务器时，将它的IP地址添加到`webservers`宏中的列表中。更重要的是，你可能会在规则中的数十个地方使用`webservers`宏。更改IP地址列表一次比在每个规则中更改要容易得多，也更可能正确。
- en: While you probably use interface groups to represent IP addresses local to your
    machine, you might have other IP addresses that you need to represent. Macros
    are great for this, too.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能使用接口组来表示你机器本地的IP地址，但你可能还有其他需要表示的IP地址。宏在这方面也非常有用。
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Or if you have multiple disparate blocks, you could use a list inside the macro.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你有多个不同的块，你可以在宏内部使用列表。
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You don’t see macros or lists when viewing the running PF rules with `pfctl`;
    instead, you see the rules that they expand to.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pfctl`查看正在运行的PF规则时，你不会看到宏或列表；相反，你看到的是它们扩展到的规则。
- en: 'A Common Error: List Exclusions and Negations'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见错误：列表排除和否定
- en: 'Lists can be counterintuitive, and it’s easy to write lists that negate other
    rules. For example, this seems like it should work:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可能难以理解，很容易编写出否定其他规则的列表。例如，这似乎应该工作：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The idea here is that our clients have the IP addresses 192.0.2.0/24\. We want
    to permit all of those addresses except for the small chunk in the middle, 192.0.2.128/29\.
    That seems reasonable, right? But much like excluding commands from `sudo(8)`,
    this breaks. Remember that each entry in a list expands into another rule. This
    creates two rules.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是我们的客户端拥有192.0.2.0/24的IP地址。我们希望允许所有这些地址，除了中间的小块，即192.0.2.128/29。这似乎是合理的，对吧？但就像排除`sudo(8)`中的命令一样，这也会出问题。记住，列表中的每个条目都会扩展为另一条规则。这会创建两条规则。
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first rule passes in everything from the 192.0.2.0/24 subnet. That’s what
    we wanted. The second rule, however, passes in *everything* that’s not in the
    subnet 192.0.2.128/29, also known as “everyone in the world”—not what we were
    hoping to achieve.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则适用于从192.0.2.0/24子网开始的全部内容。这正是我们想要的。然而，第二条规则却适用于不在192.0.2.128/29子网中的所有内容，也称为“世界上所有人”——这并不是我们希望实现的目标。
- en: Similarly, negating an entire list expands to negating each individual item
    in the list. If you need to do this sort of exclusion, use a table, as described
    in the next chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，否定整个列表会扩展为否定列表中的每个单独项目。如果你需要执行这种排除操作，请使用下一章中描述的表格。
- en: Sanitizing Traffic
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 净化流量
- en: All sorts of weird traffic arrives at Internet hosts. Some of that traffic is
    broken garbage. Other parts tell you that someone else is running broken garbage.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网主机到达的各种奇怪流量。其中一些流量是损坏的垃圾。其他部分告诉你，其他人正在运行损坏的垃圾。
- en: PF tries to sanitize and normalize traffic before otherwise processing it. The
    normalizations include discarding illegal packets, packet reassembly, and packet
    modification.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: PF试图在处理之前对流量进行净化和标准化。这些标准化包括丢弃非法数据包、数据包重组和数据包修改。
- en: Illegal Packets
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非法数据包
- en: Some of the random stuff that arrives at a host is garbage. If a packet is shorter
    than the IP header, it can’t be a real IP packet, and if a TCP packet is too short
    to include a full TCP header, it can’t be a real packet.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一些随机到达主机的数据是垃圾。如果一个数据包的长度短于IP头部，那么它就不能是一个真正的IP数据包；如果一个TCP数据包太短，无法包含完整的TCP头部，那么它也不能是一个真正的数据包。
- en: If the packet length doesn’t match the length given in the header, it’s somehow
    corrupt. PF has no way to figure out where these packets came from, or if they’re
    maliciously damaged or just corrupted in transit. Since the kernel can’t do anything
    with them, PF automatically drops them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据包长度与头部中给出的长度不匹配，那么数据包就可能在某些方面损坏。PF无法确定这些数据包的来源，或者它们是否被恶意损坏，或者只是在传输过程中损坏。由于内核无法对这些数据包进行处理，PF会自动丢弃它们。
- en: Packet Reassembly
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据包重组
- en: Before the packet filter can decide how to handle a packet, the packet should
    be free of ambiguities and random weirdness. Reassembly cleans up these ambiguities,
    and the default reassembly settings are suitable for most environments. You get
    reassembly when you enable PF.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在包过滤器决定如何处理一个包之前，该包应该是没有歧义和随机奇怪性的。重新组装清理了这些歧义，默认的重新组装设置适用于大多数环境。当你启用PF时，你会得到重新组装。
- en: Packet Modification
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包修改
- en: Sometimes you need to modify packets. These days, PF handles everything for
    most environments. If you need to modify packets, such as clearing the “do not
    fragment” bit on fragmented UDP packets, see the `scrub` keyword in `pf.conf(5)`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要修改包。如今，PF为大多数环境处理一切。如果你需要修改包，例如清除分片UDP包上的“不要分段”位，请参阅`pf.conf(5)`中的`scrub`关键字。
- en: Blocking Spoofed Packets
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻止伪造的包
- en: Another classic IP attack is sending packets that appear to come from the private
    network to a firewall, in an attempt to evade the packet filter. Most firewalls
    today block this type of attack, so attackers rarely bother, but you should still
    protect against spoofed attacks. Just because everyone else has had their measles
    shot doesn’t mean you should go without one.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种经典的IP攻击是发送看起来来自私有网络到防火墙的包，试图绕过包过滤器。如今，大多数防火墙都阻止这种攻击，攻击者很少为此烦恼，但你仍然应该保护免受伪造攻击。仅仅因为其他人已经接种了麻疹疫苗并不意味着你应该不接种。
- en: For an antispoofing rule, use `antispoof for` and an interface name.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反伪造规则，使用`antispoof for`和一个接口名称。
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When fed into the packet filter, the rules would look something like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入到包过滤器时，规则看起来可能像这样：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first rule drops any traffic that arrives from an address local to interface
    `fxp0` on any interface other than `fxp0`. Packets from an address local to interface
    `fxp0` should always arrive on your system via `fxp0`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则丢弃了来自除`fxp0`以外的任何接口上`fxp0`本地地址的任何流量。来自`fxp0`本地地址的包应该始终通过`fxp0`到达你的系统。
- en: The second rule drops any traffic that comes from the address of interface `fxp0`.
    Packets with that source address should never arrive from the outside world. If
    the system needs to communicate with itself, it uses interface `lo0`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则丢弃了来自`fxp0`接口地址的任何流量。具有该源地址的包永远不会从外部世界到达。如果系统需要与自身通信，它使用接口`lo0`。
- en: You could use interface groups instead of interface names, but I don’t recommend
    doing so. If you have multiple `egress` interfaces, using antispoofing rules on
    the egress group won’t block outside packets that arrive at the wrong egress interface.
    Take the time to enumerate your interfaces in your antispoofing rules.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用接口组而不是接口名称，但我不建议这样做。如果你有多个`egress`接口，在出口组上使用反伪造规则不会阻止到达错误出口接口的外部包。花时间在你的反伪造规则中列举你的接口。
- en: Instead of listing a single interface, you can also use a list or a macro.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以列出单个接口，还可以使用列表或宏。
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Antispoofing rules can mess with packets passed over the loopback interface.
    I recommend skipping filtering on `lo0`, although PF includes special built-in
    protection for 127.0.0.0/8 addresses.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 反伪造规则可能会干扰通过环回接口传递的包。我建议跳过对`lo0`的过滤，尽管PF为127.0.0.0/8地址提供了特殊的内置保护。
- en: Now that you have basic packet filtering, let’s consider some of PF’s core settings.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了基本的包过滤，让我们来考虑一些PF的核心设置。
- en: PF Options
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PF选项
- en: 'Options are basic settings that affect core PF functions. Options answer questions
    like these:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是影响核心PF功能的基本设置。选项回答了像这样的问题：
- en: Do we reassemble fragments into packets?
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否将碎片重新组装成包？
- en: How many entries should the state table support?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态表应该支持多少条记录？
- en: Is logging on?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否开启了日志记录？
- en: All options start with the `set` keyword. Because options affect how all other
    parts of PF operate, I recommend placing them at the very top of *pf.conf*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选项都以`set`关键字开头。因为选项会影响PF其他所有部分的操作，我建议将它们放在`pf.conf`的顶部。
- en: Here, we’ll look at some of the more commonly used options.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将查看一些更常用的选项。
- en: The set block-policy Option
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置阻塞策略选项
- en: Will your firewall silently drop forbidden packets, or respond to the client
    with “sorry, not allowed?” The block policy determines which approach it takes.
    By default, PF drops blocked packets, but you can override the global block policy
    on individual filter rules.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你的防火墙会静默地丢弃禁止的包，还是会向客户端响应“对不起，不允许？”阻塞策略决定了它采取哪种方法。默认情况下，PF会丢弃被阻塞的包，但你可以在单个过滤规则上覆盖全局阻塞策略。
- en: 'Strictly speaking, when PF drops packets, it should return an error to the
    client, so that legitimate clients can immediately recognize that they cannot
    connect. Using `set block-policy return` tells PF to return these polite errors:
    an RST for TCP connections and an ICMP unreachable message for other types of
    connections.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，当PF丢弃数据包时，它应该向客户端返回一个错误，以便合法客户端可以立即意识到他们无法连接。使用`set block-policy return`告诉PF返回这些礼貌的错误：TCP连接的RST和一个ICMP不可达消息用于其他类型的连接。
- en: Unfortunately, politeness has largely been overwhelmed by the modern Internet.
    PF’s default, `set block-policy drop`, tells PF to not return any kind of error
    on blocked packets. Client applications such as web browsers, vulnerability scanners,
    worms, and other malware must wait for the network protocol to time out before
    realizing that they cannot connect.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，礼貌在现代社会互联网中被很大程度上忽视了。PF的默认设置`set block-policy drop`告诉PF不要在阻塞的数据包上返回任何类型的错误。客户端应用程序，如网页浏览器、漏洞扫描器、蠕虫和其他恶意软件必须等待网络协议超时才能意识到他们无法连接。
- en: I recommend dropping blocked packets silently.^([[47](#ftn.id467314)])
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议静默丢弃被阻塞的数据包.^([[47](#ftn.id467314)])
- en: The set limit Option
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置限制选项
- en: PF includes limits on the size of various internal tables used to track fragments,
    states, address tables, and other memory-consuming items. I have needed to adjust
    these limits on very rare occasions. The existing limits are chosen because they
    are sufficient for most users in most environments.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: PF包括限制用于跟踪片段、状态、地址表和其他内存消耗项的各种内部表的大小。我非常罕见地需要调整这些限制。现有的限制被选择是因为它们对于大多数环境中的大多数用户来说是足够的。
- en: View the existing limits with `pfctl`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pfctl`查看现有的限制。
- en: '[PRE54]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let’s take a look at what each limit represents.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个限制代表什么。
- en: frags Limit
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: frags限制
- en: When PF receives a fragmented packet, it holds onto that fragment and waits
    for other fragments of that packet to arrive. Once it has all the pieces, it reassembles
    the fragment and processes it. The `frags` limit controls the number of packet
    fragments awaiting reassembly at one time. (You shouldn’t need to change this.)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当PF收到一个分段数据包时，它会保留这个片段并等待该数据包的其他片段到达。一旦它收集到所有片段，它就会重新组装这个片段并处理它。`frags`限制控制了一次性等待重新组装的包片段的数量。（你不应该需要更改这个设置。）
- en: To see the total number of fragments PF has processed, and how many arrive per
    second, use `pfctl -s info` and look at the Counters section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看PF处理的总片段数以及每秒到达的片段数，使用`pfctl -s info`并查看计数器部分。
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This host has been sitting on the naked Internet for three months in an Internet
    colocation site, and has received only 368 fragments. I do not need to increase
    PF’s memory for fragments, and I certainly don’t want to reduce the limit in case
    I receive a sudden barrage of fragments.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主机已经在互联网数据中心裸露放置了三个月，只收到了368个片段。我不需要增加PF的片段内存，当然也不希望降低限制，以防突然收到大量片段。
- en: If you suspect that fragments are flowing in, run `systat pf` for constantly
    updating counters of PF statistics.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑有片段流入，运行`systat pf`以持续更新PF统计计数器。
- en: The src-nodes Limit
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: src-nodes限制
- en: 'PF can track a number of states per source address. You might want to limit
    each client to, say, 10 connections to a specific server. This connection limit
    includes connections being set up and those still waiting to finish. Here’s an
    example of this sort of rule:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: PF可以跟踪每个源地址的状态数量。你可能想限制每个客户端对特定服务器的连接数，比如10个连接。这个连接限制包括正在建立和仍在等待完成的连接。以下是一个此类规则的示例：
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: PF’s load balancer features use `src-nodes` to help track which clients are
    attached to which servers, through the `sticky-address` and `source-track` options.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: PF的负载均衡器功能使用`src-nodes`通过`sticky-address`和`source-track`选项帮助跟踪哪些客户端连接到哪些服务器。
- en: If you use these features, and think you might be out of source nodes, check
    usage with `pfctl -s Sources`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这些功能，并且认为你可能会超出源节点，使用`pfctl -s Sources`来检查使用情况。
- en: The states Limit
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: states限制
- en: The `states` limit controls how many entries can be in the stateful inspection
    list. The default of 10,000 is adequate for most environments.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`states`限制控制了状态检查列表中可以有多少条目。默认的10,000对于大多数环境来说是足够的。'
- en: You can view the current usage with `pfctl -s info`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pfctl -s info`查看当前的使用情况。
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I have needed to change the state table more than once. Each time, it was because
    of a strangely written application that required clients to make dozens of connections
    to a single TCP/IP port. I’m certain that the application developers had their
    reasons for doing so (possible reasons do include ignorance and malice). Multiplied
    by thousands of simultaneous users, that became a lot of states. As I wasn’t in
    a position to tell the developers to write their application like normal people,
    I had to adjust the state table.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要多次更改状态表。每次都是因为一个编写奇特的程序，要求客户端对单个TCP/IP端口进行数十次连接。我确信应用程序开发者有他们这样做的原因（可能的原因包括无知和恶意）。乘以数千个同时在线用户，这就变成了很多状态。由于我无法告诉开发者像普通人一样编写应用程序，我不得不调整状态表。
- en: If you suspect that the state table is having trouble, use `systat pf` and/or
    `systat states` to view state activity in real time.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑状态表存在问题，请使用`systat pf`和/或`systat states`来实时查看状态活动。
- en: The tables and table-entries Limits
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表和表条目限制
- en: The `tables` and `table-entries` limits control how many tables PF can create,
    and how many entries can go into a single table. I have never had to adjust these,
    and I would suggest that if your filter rules need more than 1000 tables, you
    should probably reconsider how you’ve designed it. A table might need to hold
    more than 100,000 addresses, but that’s very much the exception these days.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`tables`和`table-entries`限制控制PF可以创建多少个表，以及单个表中可以有多少条目。我从未需要调整这些，我建议如果你的过滤规则需要超过1000个表，你也许应该重新考虑你的设计。一个表可能需要存储超过10万个地址，但这种情况在当今非常少见。'
- en: Setting Limits
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置限制
- en: 'To change a limit, use `set limit`, the name of the limit, and the new value.
    Here’s how to double the size of the default state table:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改限制，请使用`set limit`，限制的名称和新的值。以下是如何将默认状态表大小加倍的方法：
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Again, don’t change these defaults lightly. Increase them only if existing limits
    cause a specific problem. And don’t decrease them, or you won’t be prepared for
    problems and spikes.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不要轻易更改这些默认设置。只有在现有限制导致特定问题时才增加它们。而且不要降低它们，否则你将无法为问题和高峰期做好准备。
- en: The set optimization Option
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置优化选项
- en: PF includes a variety of timeouts, which default to values reasonable for the
    modern Internet. Some environments, such as satellite uplinks, do require slightly
    different timeouts.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: PF包含各种超时设置，默认值适用于现代互联网。某些环境，如卫星上行链路，可能需要稍微不同的超时值。
- en: 'You can adjust PF’s timeouts with `set optimization`. (The name is a leftover
    from the early days of PF, but has stuck around.) This has four values:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`set optimization`来调整PF的超时时间。（这个名字是PF早期时代的遗留物，但一直沿用至今。）这有四个值：
- en: '**`normal`**'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`normal`**'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `normal` optimization is the default. If you don’t specify an optimization,
    the standard timeouts are used.
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`normal`优化是默认设置。如果你没有指定优化，则使用标准超时时间。'
- en: '**`conservative`**'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`conservative`**'
- en: ''
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `conservative` optimization is for environments where you want to be absolutely
    sure you don’t time out connections. (State table entries will stick around longer.)
    This setting uses more memory and processor time—possibly much more on a busy
    network. I use it to ease the minds of managers of industrial networks who are
    less concerned about buying more hardware and more concerned about the possibility
    of a meeting caused by some executive’s idle connection timing out.
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`conservative`优化适用于你绝对不希望超时连接的环境。（状态表条目将保留更长时间。）此设置使用更多的内存和处理器时间——在繁忙的网络中可能更多。我使用它来安抚那些不太关心购买更多硬件，而更关心由于某些高管空闲连接超时而可能引起的会议的工业网络管理员。'
- en: '**`high-latency`**'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`high-latency`**'
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you connect over a satellite uplink or carrier pigeon, use the `high-latency`
    optimization.
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你通过卫星上行链路或信鸽连接，请使用`high-latency`优化。
- en: '**`aggressive`**'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`aggressive`**'
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you have a busy firewall, with many connections coming and going, you might
    try the `aggressive` optimization. This times out idle connections more quickly,
    reducing memory and processor use. Many people report that `aggressive` timeouts
    work perfectly well in their environments, but if low timeouts cause trouble for
    you, turn them off.
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你有一个繁忙的防火墙，有很多连接进出，你可能尝试使用`aggressive`优化。这会更快地超时空闲连接，减少内存和处理器使用。许多人报告说，在他们的环境中`aggressive`超时工作得非常好，但如果低超时时间给你带来麻烦，请将其关闭。
- en: Configure any of these by using `set optimization` and the optimization name.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`set optimization`和优化名称来配置这些设置。
- en: '[PRE59]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The set skip Option
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置跳过选项
- en: You can tell PF to not manage an interface. By default, it watches all interfaces,
    but some interfaces don’t really require filtering. Your loopback interface, `lo0`,
    passes traffic only from the local machine to itself. Packet filtering on `lo0`
    is an interesting educational exercise, but not terribly useful in production.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以告诉PF不要管理一个接口。默认情况下，它会监视所有接口，但有些接口实际上并不需要过滤。你的回环接口`lo0`只从本地机器传递流量到自身。在`lo0`上进行数据包过滤是一个有趣的教育练习，但在生产环境中并不十分有用。
- en: '[PRE60]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can also specify multiple interfaces to skip.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定多个要跳过的接口。
- en: '[PRE61]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It’s fairly common to skip filtering on the physical interfaces beneath a trunk
    in favor of filtering on the trunk itself.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在主干下的物理接口上跳过过滤，而选择在主干本身上进行过滤，这种情况相当常见。
- en: This will get you started with packet filtering. If you have a single server
    with simple functions, you can protect it quite nicely using the techniques covered
    in this chapter. But PF can do a lot more than what we’ve talked about here, such
    as control bandwidth and have applications dynamically change rules. In the next
    chapter, we’ll touch on a few of PF’s more advanced functions.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助你开始学习数据包过滤。如果你有一个功能简单的单一服务器，你可以使用本章中介绍的技术相当好地保护它。但PF的功能远不止我们在这里讨论的，比如控制带宽和让应用程序动态更改规则。在下一章中，我们将触及PF的一些更高级功能。
- en: '* * *'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[45](#id337427)]) Sorry, cats and elephants, find your own place to live.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[45](#id337427)]) 对不起，猫和象，你们要找到自己的居住地。
- en: ^([[46](#id337464)]) Blatantly stolen from Henning Brauer. Thankfully, he’s
    so sick of this book by now, he won’t notice.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[46](#id337464)]) 明显地借鉴自Henning Brauer。幸运的是，他现在对这个书已经厌倦了，不会注意到这一点。
- en: ^([[47](#id467314)]) Mind you, if PF included an option to insult the client
    when a packet is dropped, somewhat like sudo, I would need to change my recommendation.
    But that’s a fault in the underlying network protocol, not PF.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#id467314)]) 请注意，如果PF在数据包被丢弃时提供了一个侮辱客户的功能，类似于sudo，我可能需要改变我的推荐。但这不是PF的问题，而是底层网络协议的缺陷。
