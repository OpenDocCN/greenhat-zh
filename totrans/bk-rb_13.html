<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Files and IO"><div class="titlepage"><div><div><h1 class="title"><a id="files_and_io"/>Chapter 13. Files and IO</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id15"/><div class="mediaobject"><a id="I_mediaobject13_d1e15613"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>Ruby provides classes dedicated to handling input and output (IO). Chief among these is a class called, unsurprisingly, IO. The IO class lets you open and close IO <span class="emphasis"><em>streams</em></span> (sequences of bytes) and read and write data to and from them.<a id="IDX-CHP-13-0001" class="indexterm"/><a id="IDX-CHP-13-0002" class="indexterm"/></p><p>For example, assuming you have a file called <span class="emphasis"><em>textfile.txt</em></span>, containing some lines of text, this is how you might open the file and display each line on the screen:</p><p><span class="emphasis"><em>io_test.rb</em></span></p><a id="I_programlisting13_d1e15639"/><pre class="programlisting">IO.foreach("testfile.txt") {|line| print( line ) }</pre><p>Here <code class="literal">foreach</code> is a class method of IO, so you don’t need to create a new IO object to use it; instead, you just specify the filename as an argument. The <code class="literal">foreach</code> method takes a block into which each line that is read from the file is passed as an argument. You don’t have to open the file for reading and close it when you’ve finished (as you might expect from your experience with other languages) because Ruby’s <code class="literal">IO.foreach</code> method does this for you.<a id="IDX-CHP-13-0003" class="indexterm"/><a id="IDX-CHP-13-0004" class="indexterm"/></p><p>IO has a number of other useful methods. For example, you could use the <code class="literal">readlines</code> method to read the file contents into an array for further processing. Here is a simple example that once again prints the lines to screen:<a id="IDX-CHP-13-0005" class="indexterm"/><a id="IDX-CHP-13-0006" class="indexterm"/><a id="IDX-CHP-13-0007" class="indexterm"/><a id="IDX-CHP-13-0008" class="indexterm"/><a id="IDX-CHP-13-0009" class="indexterm"/></p><a id="I_programlisting13_d1e15688"/><pre class="programlisting">lines = IO.readlines("testfile.txt")
lines.each{|line| print( line )}</pre><p>The File class is a subclass of IO, and the previous examples could be rewritten using the File class:</p><p><span class="emphasis"><em>file_test.rb</em></span></p><a id="I_programlisting13_d1e15696"/><pre class="programlisting">File.foreach("testfile.txt") {|line| print( line ) }

lines = File.readlines("testfile.txt")
lines.each{|line| print( line )}</pre><div class="sect1" title="Opening and Closing Files"><div class="titlepage"><div><div><h1 class="title"><a id="opening_and_closing_files"/>Opening and Closing Files</h1></div></div></div><p>Although some standard methods open and close files automatically, often when processing the contents of a file, you will need to open and close the file explicitly. You can open a file using either the <code class="literal">new</code> or <code class="literal">open</code> method. You must pass two arguments to one of those methods—the filename and the file “mode”—and it returns a new File object. The File modes may be either integers that are defined by operating system-specific constants or strings. The mode generally indicates whether the file is be opened for reading (<code class="literal">"r"</code>), writing (<code class="literal">"w"</code>), or reading and writing (<code class="literal">"rw"</code>). <a class="xref" href="ch13.html#file_mode_strings" title="Table 13-1. File Mode Strings">Table 13-1</a> shows the list of available string modes.<a id="IDX-CHP-13-0010" class="indexterm"/></p><div class="table"><a id="file_mode_strings"/><p class="title">Table 13-1. File Mode Strings</p><div class="table-contents"><table summary="File Mode Strings" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Mode</p></th><th style="text-align: left" valign="bottom"><p>Meaning</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">"r"</code></p></td><td style="text-align: left" valign="top"><p>Read-only, starts at beginning of file (default mode)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"r+"</code></p></td><td style="text-align: left" valign="top"><p>Read-write, starts at beginning of file</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"w"</code></p></td><td style="text-align: left" valign="top"><p>Write-only, truncates existing file to zero length or creates a new file for writing</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"w+"</code></p></td><td style="text-align: left" valign="top"><p>Read-write, truncates existing file to zero length or creates a new file for reading and writing</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"a"</code></p></td><td style="text-align: left" valign="top"><p>Write-only, starts at end of file if file exists; otherwise, creates a new file for writing</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"a+"</code></p></td><td style="text-align: left" valign="top"><p>Read-write, starts at end of file if file exists; otherwise, creates a new file for reading and writing</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"b"</code></p></td><td style="text-align: left" valign="top"><p>(DOS/Windows only) Binary file mode (may appear with any of the key letters listed earlier)</p></td></tr></tbody></table></div></div><p>Let’s look at an actual example of opening, processing, and closing files. In <span class="emphasis"><em>open_close.rb</em></span>, I first open a file, <span class="emphasis"><em>myfile.txt</em></span>, for writing (<code class="literal">"w"</code>). When a file is opened for writing, a new file will be created if it doesn’t already exist. I use <code class="literal">puts()</code> to write six strings to the file, one string on each of six lines. Finally, I close the file:<a id="IDX-CHP-13-0011" class="indexterm"/><a id="IDX-CHP-13-0012" class="indexterm"/><a id="IDX-CHP-13-0013" class="indexterm"/><a id="IDX-CHP-13-0014" class="indexterm"/><a id="IDX-CHP-13-0015" class="indexterm"/></p><a id="I_programlisting13_d1e15835"/><pre class="programlisting">f = File.new("myfile.txt", "w")
f.puts( "I", "wandered", "lonely", "as", "a", "cloud" )
f.close</pre><p>Closing a file not only releases the <span class="emphasis"><em>file handle</em></span> (the pointer to the file data) but also “flushes” any data from memory to ensure that it is all saved into the file on disk.</p><p>Having written text into a file, let’s see how to open that file and read the data back in. This time I’ll read in the data one character at a time up to the end of the file (<code class="literal">eof</code>). As I do so, I’ll keep a count of the characters that have been read. I’ll also keep a count of the lines, which will be incremented whenever I read in a linefeed character (given by ASCII code 10). For the sake of clarity, I’ll add a string to the end of each line that’s been read, displaying its line number. I’ll display the characters plus my line-end strings on the screen, and when everything has been read from the file, I’ll close it and display the statistics that I’ve calculated. Here is the complete code:<a id="IDX-CHP-13-0016" class="indexterm"/><a id="IDX-CHP-13-0017" class="indexterm"/></p><p><span class="emphasis"><em>open_close.rb</em></span></p><a id="I_programlisting13_d1e15860"/><pre class="programlisting">f = File.new("myfile.txt", "w")
f.puts( "I", "wandered", "lonely", "as", "a", "cloud" )
f.close                          # Try commenting this out!

charcount = 0
linecount = 0
f = File.new("myfile.txt", "r")
while !( f.eof ) do              # while not at end of file...
    c = f.getc()                 # get a single character
    if ( c.ord == 10 ) then      # test ASCII code (Ruby 1.9)
        linecount += 1
        puts( " &lt;End Of Line #{linecount}&gt;" )
    else
        putc( c )                # put the char to screen
        charcount += 1
    end
end
if f.eof then
    puts( "&lt;End Of File&gt;" )
end
f.close
puts("This file contains #{linecount} lines and #{charcount} characters." )</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>This code is written for Ruby 1.9 and won’t run in Ruby 1.8. See the following section for more details.<a id="IDX-CHP-13-0018" class="indexterm"/><a id="IDX-CHP-13-0019" class="indexterm"/><a id="IDX-CHP-13-0020" class="indexterm"/><a id="IDX-CHP-13-0021" class="indexterm"/></p></div><p>When manipulating files in this way, it is the programmer’s responsibility to ensure that the file is closed after data is written to or read from it. Failing to close a file may result in unpredictable side effects. For example, try commenting out the first <code class="literal">f.close</code> (on the third line in the previous code) to see for yourself! You’ll find that when the program subsequently tries to read back the contents of the file, no data is found, and a count of zero lines and characters is returned!</p></div></div>
<div class="sect1" title="Characters and Compatibility"><div class="titlepage"><div><div><h1 class="title"><a id="characters_and_compatibility"/>Characters and Compatibility</h1></div></div></div><p>The <span class="emphasis"><em>open_close.rb</em></span> program is written for Ruby 1.9 and cannot be run in Ruby 1.8. This is because when a single character is returned by Ruby 1.8, it is treated as an integer ASCII value, whereas in Ruby 1.9 it is treated as a one-character string. So, when <code class="literal">getc()</code> returns the character, <code class="literal">c</code>, Ruby 1.8 is able to test its ASCII value ( <code class="literal">c == 10</code> ), whereas Ruby 1.9 must either test it as a string ( <code class="literal">c == "\n"</code> ) or convert the character to an integer using the <code class="literal">ord</code> method: <code class="literal">( c.ord == 10 )</code>. The <code class="literal">ord</code> method does not exist in Ruby 1.8.<a id="IDX-CHP-13-0022" class="indexterm"/></p><p>As a general principle, if you want to write programs that work in different versions of Ruby, you may code around incompatibility issues by testing the value of the <code class="literal">RUBY_VERSION</code> constant. This constant returns a string giving a version number such as 1.9.2. You could simply convert the string to a floating-point number using the <code class="literal">to_f</code> method and then take different actions if the value is greater than 1.8:<a id="IDX-CHP-13-0023" class="indexterm"/></p><a id="I_programlisting13_d1e15932"/><pre class="programlisting">if (RUBY_VERSION.to_f &gt; 1.8) then
    c = c.ord
end</pre><p>Alternatively, you could analyze the string to determine the minor and major version numbers. Here, for example, is a very simple method that indexes into the <code class="literal">RUBY_VERSION</code> string to obtain the first character as the major version ( 1 or 2) and the second character as the minor version (for example, 8 or 9). It returns <code class="literal">true</code> if the Ruby version is 1.9 or higher and false otherwise:</p><p><span class="emphasis"><em>open_close2.rb</em></span></p><a id="I_programlisting13_d1e15945"/><pre class="programlisting">def isNewRuby
    newR = false # is this &gt; Ruby version 1.8?
    majorNum = RUBY_VERSION[0,1]
    minorNum = RUBY_VERSION[2,1]
    if ( majorNum == "2" ) || (minorNum  == "9" ) then
        newR = true
    else
        newR == false
    end
    return newR
end</pre><p>You can use this test in your code to deal with compatibility issues. Here the <code class="literal">ord</code> method is applied to the character, <code class="literal">c</code>, only if the Ruby version is 1.9 or greater:<a id="IDX-CHP-13-0024" class="indexterm"/><a id="IDX-CHP-13-0025" class="indexterm"/></p><a id="I_programlisting13_d1e15963"/><pre class="programlisting">if (isNewRuby) then
    c = c.ord
end</pre></div>
<div class="sect1" title="Files and Directories"><div class="titlepage"><div><div><h1 class="title"><a id="files_and_directories"/>Files and Directories</h1></div></div></div><p>You can also use the File class to manipulate files and directories on disk. Before attempting to perform some operation on a file, you must naturally make sure that the file exists. It might, after all, have been renamed or deleted after the program started—or the user may have incorrectly entered a file or directory name.<a id="IDX-CHP-13-0026" class="indexterm"/></p><p>You can verify the existence of a file using the <code class="literal">File.exist?</code> method. This is one of several testing methods that are provided to the File class by the <code class="literal">FileTest</code> module. As far as the <code class="literal">File.exist?</code> method is concerned, a directory counts as a file, so you could use the following code to test for the presence of a <span class="emphasis"><em>C:\</em></span> drive (note that you must use double file separator <code class="literal">"\\"</code> characters in strings, because a single <code class="literal">"\"</code> will be treated as an escape character):<a id="IDX-CHP-13-0027" class="indexterm"/></p><p><span class="emphasis"><em>file_ops.rb</em></span></p><a id="I_programlisting13_d1e16004"/><pre class="programlisting">if File.exist?( "C:\\" ) then
    puts( "Yup, you have a C:\\ directory" )
else
    puts( "Eeek! Can't find the C:\\ drive!" )
end</pre><p>If you want to distinguish between a directory and a data file, use the <code class="literal">directory?</code> method:</p><a id="I_programlisting13_d1e16011"/><pre class="programlisting">def dirOrFile( aName )
    if File.directory?( aName ) then
        puts( "#{aName} is a directory" )
    else
        puts( "#{aName} is a file" )
    end
end</pre></div>
<div class="sect1" title="Copying Files"><div class="titlepage"><div><div><h1 class="title"><a id="copying_files"/>Copying Files</h1></div></div></div><p>Let’s put the File class to some practical use by writing a simple file backup program. When you run <span class="emphasis"><em>copy_files.rb</em></span>, you will be asked to choose a directory to copy from (the source directory) and another directory to copy to (the target directory). Assuming both directories exist, the program will then copy all the files from the source directory to the target directory. If the target directory does not exist, it will ask you whether you would like to create it, in which case you should enter <span class="emphasis"><em>Y</em></span> to accept. I’ve supplied a source directory for you; just enter the name <span class="emphasis"><em>srcdir</em></span> when prompted. When asked for a target directory, enter <span class="emphasis"><em>targetdir</em></span> in order to create a subdirectory of that name beneath the current directory.<a id="IDX-CHP-13-0028" class="indexterm"/><a id="IDX-CHP-13-0029" class="indexterm"/></p><p>The program initializes the variable <code class="literal">sourcedir</code> with the path of the source directory, and it initializes <code class="literal">targetdir</code> with the name of the target directory. This is the code that does the file copying:</p><p><span class="emphasis"><em>copy_files.rb</em></span></p><a id="I_programlisting13_d1e16047"/><pre class="programlisting">Dir.foreach( sourcedir ){
    |f|
    filepath = "#{sourcedir}\\#{f}"
       if !(File.directory?(filepath) ) then
          if File.exist?("#{targetdir}\\#{f}") then
              puts("#{f} already exists in target directory" )
          else
              FileUtils.cp( filepath, targetdir )
              puts("Copying... #{filepath}" )
        end
    end
}</pre><p>Here I’ve used the <code class="literal">foreach</code> method of the Dir class, which passes into a block the filename, <code class="literal">f</code>, of each file in the specified directory. I’ll have more to say about the Dir class shortly. The code constructs a qualified path to the file, <code class="literal">filepath</code>, by appending the filename to the directory name given by the <code class="literal">sourcedir</code> variable. I only want to copy data files but not directories, so I test that <code class="literal">filepath</code> is a file and not a directory:</p><a id="I_programlisting13_d1e16066"/><pre class="programlisting">if !(File.directory?(filepath) )</pre><p>I don’t want this program to copy over files that already exist, so it first checks to see whether a file with the name <code class="literal">f</code> already exists in the target directory, <code class="literal">targetdir</code>:</p><a id="I_programlisting13_d1e16076"/><pre class="programlisting">if File.exist?("#{targetdir}\\#{f}")</pre><p>Finally, assuming all the specified conditions are met, the source file, <code class="literal">filepath</code>, is copied to <code class="literal">targetdir</code>:</p><a id="I_programlisting13_d1e16086"/><pre class="programlisting">FileUtils.cp( filepath, targetdir )</pre><p>Here <code class="literal">cp</code> is a file-copy method found in the <code class="literal">FileUtils</code> module. This module also contains a number of other useful file-handling routines such as <code class="literal">mv(source, target)</code> to move a file from <code class="literal">source</code> to <code class="literal">target</code>, <code class="literal">rm( files )</code> to delete one or more files listed in the <code class="literal">files</code> parameter, and <code class="literal">mkdir</code> to create a directory as I have done when creating <code class="literal">targetdir</code> in the current program:<a id="IDX-CHP-13-0030" class="indexterm"/><a id="IDX-CHP-13-0031" class="indexterm"/><a id="IDX-CHP-13-0032" class="indexterm"/></p><a id="I_programlisting13_d1e16128"/><pre class="programlisting">FileUtils.mkdir( targetdir )</pre></div>
<div class="sect1" title="Directory Inquiries"><div class="titlepage"><div><div><h1 class="title"><a id="directory_inquiries"/>Directory Inquiries</h1></div></div></div><p>My backup program deals with just one directory level at a time, which is why it tests to see that a file, <code class="literal">f</code>, is not a directory before attempting to copy it. There are many times, however, when you may want to traverse the subdirectories. For an example of this, let’s write a program that calculates the sizes of all the subdirectories beneath a specified root directory. This might be useful if, for example, you wanted to locate the biggest files and directories in order to free up disk space by archiving or deleting them.<a id="IDX-CHP-13-0033" class="indexterm"/><a id="IDX-CHP-13-0034" class="indexterm"/><a id="IDX-CHP-13-0035" class="indexterm"/><a id="IDX-CHP-13-0036" class="indexterm"/><a id="IDX-CHP-13-0037" class="indexterm"/></p><p>Navigating through subdirectories creates an interesting programming problem. When you begin searching for the presence of subdirectories, you have no idea whether you will find one, none, or many. Moreover, any subdirectory you find may contain yet another level of subdirectories, each of which may contain other subdirectories and so on through many possible levels.</p></div>
<div class="sect1" title="A Discursion into Recursion"><div class="titlepage"><div><div><h1 class="title"><a id="a_discursion_into_recursion"/>A Discursion into Recursion</h1></div></div></div><p>This program needs to be able to navigate down the entire subdirectory tree to any number of levels. To be able to do this, you have to use <span class="emphasis"><em>recursion</em></span>. Put simply, a recursive method is one that calls itself. If you aren’t familiar with recursive programming, see <a class="xref" href="ch13s07.html#digging_deeper-id12" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch13s07.html#digging_deeper-id12" title="Digging Deeper">Digging Deeper</a>.</p><p>In the program <span class="emphasis"><em>file_info.rb</em></span>, the <code class="literal">processfiles</code> method is recursive:</p><p><span class="emphasis"><em>file_info.rb</em></span></p><a id="I_programlisting13_d1e16184"/><pre class="programlisting">def processfiles( aDir )
    totalbytes = 0
    Dir.foreach( aDir ){
    |f|
    mypath = "#{aDir}\\#{f}"
    s = ""
    if File.directory?(mypath) then
        if f != '.' and f != '..' then
        bytes_in_dir = processfiles(mypath)     # &lt;==== recurse!
        puts( "&lt;DIR&gt; ---&gt;
            #{mypath} contains [#{bytes_in_dir/1024}] KB" )
    end
    else
       filesize = File.size(mypath)
       totalbytes += filesize
       puts ( "#{mypath} : #{filesize/1024}K" )
    end
    }
    $dirsize += totalbytes
    return totalbytes
end</pre><p>You will see that when the method is first called, toward the bottom of the source code, it is passed the name of a directory in the variable <code class="literal">dirname</code>:</p><a id="I_programlisting13_d1e16191"/><pre class="programlisting">processfiles( dirname )</pre><p>I’ve already assigned the parent of the current directory, given by two dots:</p><a id="I_programlisting13_d1e16195"/><pre class="programlisting">dirname = ".."</pre><p>If you are running this program in its original location (that is, the location to which it is extracted from this book’s source code archive), this will reference the directory containing the subdirectories of all the sample code files. Alternatively, you could assign the name of some directory on your hard disk to the variable, <code class="literal">dirname</code>. If you do this, don’t specify a directory containing huge numbers of files and directories (on Windows, <span class="emphasis"><em>C:\Program Files</em></span> would not be a good choice, and <span class="emphasis"><em>C:\</em></span> would be even worse!) because the program would then take quite some time to execute.</p><p>Let’s take a closer look at the code in the <code class="literal">processfiles</code> method. Once again, I use <code class="literal">Dir.foreach</code> to find all the files in the current directory and pass each file, <code class="literal">f</code>, one at a time, to be handled by the code in a block between curly brackets. If <code class="literal">f</code> is a directory and is not the current one (<code class="literal">'.'</code>) or its parent directory (<code class="literal">'..'</code>), then I pass the full path of the directory back to the <code class="literal">processfiles</code> method:<a id="IDX-CHP-13-0038" class="indexterm"/></p><a id="I_programlisting13_d1e16236"/><pre class="programlisting">if File.directory?(mypath) then
    if f != '.' and f != '..' then
       bytes_in_dir = processfiles(mypath)</pre><p>If <code class="literal">f</code> is not a directory but just an ordinary data file, I find its size in bytes with <code class="literal">File.size</code> and assign this to the variable <code class="literal">filesize</code>:</p><a id="I_programlisting13_d1e16249"/><pre class="programlisting">filesize = File.size(mypath)</pre><p>As each successive file, <code class="literal">f</code>, is processed by the block of code, its size is calculated, and this value is added to the variable <code class="literal">totalbytes</code>:</p><a id="I_programlisting13_d1e16259"/><pre class="programlisting">totalbytes += filesize</pre><p>Once every file in the current directory has been passed into the block, <code class="literal">totalbytes</code> will be equal to the total size of all the files in the directory.<a id="IDX-CHP-13-0039" class="indexterm"/></p><p>However, I need to calculate the bytes in all the subdirectories too. Because the method is recursive, this is done automatically. Remember that when the code between curly brackets in the <code class="literal">processfiles</code> method determines that the current file, <code class="literal">f</code>, is a directory, it passes this directory name back to <span class="emphasis"><em>itself</em></span>—the <code class="literal">processfiles</code> method.</p><p>Let’s imagine that you first call <code class="literal">processfiles</code> with the <span class="emphasis"><em>C:\test</em></span> directory. At some point, the variable <code class="literal">f</code> is assigned the name of one of its subdirectories, say, <span class="emphasis"><em>C:\test\dir_a</em></span>. Now this subdirectory is passed back to <code class="literal">processfiles</code>. No further directories are found in <span class="emphasis"><em>C:\test\dir_a</em></span>, so <code class="literal">processfiles</code> simply calculates the sizes of all the files in this subdirectory. When it finishes calculating these files, the <code class="literal">processfiles</code> method comes to an end and returns the number of bytes in the current directory, <code class="literal">totalbytes</code>, to whichever bit of code called the method in the first place:<a id="IDX-CHP-13-0040" class="indexterm"/></p><a id="I_programlisting13_d1e16320"/><pre class="programlisting">return totalbytes</pre><p>In this case, it was this bit of code inside the <code class="literal">processfiles</code> method that recursively called the <code class="literal">processfiles</code> method:</p><a id="I_programlisting13_d1e16330"/><pre class="programlisting">bytes_in_dir = processfiles(mypath)</pre><p>So, when <code class="literal">processfiles</code> finishes processing the files in the subdirectory, <span class="emphasis"><em>C:\test\dir_a</em></span>, it returns the total size of all the files found there, and this is assigned to the <code class="literal">bytes_in_dir</code> variable. The <code class="literal">processfiles</code> method now carries on where it left off (that is, it continues from the point at which it called itself to deal with the subdirectory) by processing the files in the original directory, <span class="emphasis"><em>C:\test</em></span>.</p><p>No matter how many levels of subdirectories this method encounters, the fact that it calls itself whenever it finds a directory ensures that it automatically travels down every directory pathway it finds, calculating the total bytes in each.</p><p>One final thing to note is that the values assigned to variables declared inside the <code class="literal">processfiles</code> method will change back to their “previous” values as each level of recursion completes. So, the <code class="literal">totalbytes</code> variable will first contain the size of <span class="emphasis"><em>C:\test\test_a\test_b</em></span>, then of <span class="emphasis"><em>C:\test\test_a</em></span>, and finally of <span class="emphasis"><em>C:\test</em></span>. To keep a running total of the combined sizes of all the directories, you need to assign values to a variable declared <span class="emphasis"><em>outside</em></span> the method. Here I use the global variable <code class="literal">$dirsize</code> for this purpose, adding to it the value of <code class="literal">totalbytes</code> calculated for each subdirectory processed:</p><a id="I_programlisting13_d1e16379"/><pre class="programlisting">$dirsize += totalbytes</pre><p>Incidentally, although a byte may be a convenient unit of measurement for very small files, it is generally better to describe larger files in kilobyte sizes and very large files or directories in megabytes. To change bytes to kilobytes or to change kilobytes to megabytes, you need to divide by 1,024. To change bytes to megabytes, divide by 1,048,576. The last line of code in my program does these calculations and displays the results in a formatted string using Ruby’s <code class="literal">printf</code> method:<a id="IDX-CHP-13-0041" class="indexterm"/></p><a id="I_programlisting13_d1e16391"/><pre class="programlisting">printf( "Size of this directory and subdirectories is
    #{$dirsize} bytes,
    #{$dirsize/1024}K, %0.02fMB",
    "#{$dirsize/1048576.0}" )</pre><p>Notice that I have embedded the formatting placeholder <code class="literal">"%0.02fMB"</code> in the first string, and I have added a second string following a comma: <code class="literal">"#{$dirsize/1048576.0}"</code>. The second string calculates the directory size in megabytes, and this value is then substituted for the placeholder in the first string. The placeholder’s formatting option <code class="literal">"%0.02f"</code> ensures that the megabyte value is shown as a floating-point number, <code class="literal">"f"</code>, with two decimal places, <code class="literal">"0.02"</code>.<a id="IDX-CHP-13-0042" class="indexterm"/></p></div>
<div class="sect1" title="Sorting by Size"><div class="titlepage"><div><div><h1 class="title"><a id="sorting_by_size"/>Sorting by Size</h1></div></div></div><p>Currently this program prints the file and directory names and their sizes in alphabetical order. But I am more interested in their <span class="emphasis"><em>relative</em></span> sizes. It would, therefore, be more useful if the files were sorted by size rather than by name.</p><p>To be able to sort the files, you need some way of storing a complete list of all file sizes. One obvious way of doing this would be to add the file sizes to an array. In <span class="emphasis"><em>file_info2.rb</em></span>, I create an empty array, <code class="literal">$files</code>, and each time a file is processed, I append its size to the array:</p><p><span class="emphasis"><em>file_info2.rb</em></span></p><a id="I_programlisting13_d1e16437"/><pre class="programlisting">$files &lt;&lt; fsize</pre><p>I can then sort the file sizes to display low to high values or (by sorting and then reversing the array) to display from high to low values:</p><a id="I_programlisting13_d1e16441"/><pre class="programlisting">$files.sort                   # sort low to high
$files.sort.reverse           # sort high to low</pre><p>The only trouble with this is that I now end up with an array of file sizes without the associated filenames. A better solution would be to use a Hash instead of an Array. I’ve done this in <span class="emphasis"><em>file_info3.rb</em></span>. First, I create two empty Hashes:</p><p><span class="emphasis"><em>file_info3.rb</em></span></p><a id="I_programlisting13_d1e16451"/><pre class="programlisting">$dirs = {}
$files = {}</pre><p>Now, when the <code class="literal">processfiles</code> method encounters a directory, it adds a new entry to the <code class="literal">$dirs</code> Hash using the full directory path, <code class="literal">mypath</code>, as the key and using the directory size, <code class="literal">dsize</code>, as the value:</p><a id="I_programlisting13_d1e16468"/><pre class="programlisting">$dirs[mypath] = dsize</pre><p>Key-value pairs are similarly added to the <code class="literal">$files</code> hash. When the entire structure of subdirectories and files has been processed by recursive calls to the <code class="literal">processfiles</code> method, the <code class="literal">$dirs</code> hash variable will contain key-value pairs of directory names and sizes, and the <code class="literal">$files</code> hash will contain key-value pairs of file names and sizes.</p><p>All that remains now is for these hashes to be sorted and displayed. The standard <code class="literal">sort</code> method for a Hash sorts the keys, not the values. I want to sort the values (sizes), not the keys (names). To do this, I have defined a custom sort method (refer to <a class="xref" href="ch04.html" title="Chapter 4. Arrays and Hashes">Chapter 4</a> and <a class="xref" href="ch05.html" title="Chapter 5. Loops and Iterators">Chapter 5</a> for guidance on defining custom comparisons using <code class="literal">&lt;=&gt;</code>):<a id="IDX-CHP-13-0043" class="indexterm"/><a id="IDX-CHP-13-0044" class="indexterm"/><a id="IDX-CHP-13-0045" class="indexterm"/><a id="IDX-CHP-13-0046" class="indexterm"/></p><a id="I_programlisting13_d1e16511"/><pre class="programlisting">$files.sort{|a,b| a[1]&lt;=&gt;b[1]}</pre><p>Here the <code class="literal">sort</code> method converts the <code class="literal">$files</code> Hash into nested arrays of <code class="literal">[key,value]</code> pairs and passes two of these, <code class="literal">a</code> and <code class="literal">b</code>, into the block between curly brackets. The second item (at index <code class="literal">[1]</code>) of each <code class="literal">[key,value]</code> pair provides the value. The sorting itself is done on the value using Ruby’s <code class="literal">&lt;=&gt;</code> comparison method. The end result is that this program now displays first a list of files in ascending order (by size) and then a similarly sorted list of directories. This is an example of its output:</p><a id="I_programlisting13_d1e16540"/><pre class="programlisting">..\ch19\blog\app\models\post.rb : 36 bytes
..\ch19\say_hello.html.erb : 41 bytes
..\ch13\testfile.txt : 57 bytes
..\ch01\2helloname.rb : 67 bytes
..\ch9\div_by_zero.rb : 71 bytes
..\ch12\test.rb : 79 bytes
..\ch4\dir_array.rb : 81 bytes
..\ch3\for_to.rb : 89 bytes</pre><div class="sidebar"><a id="digging_deeper-id12"/><p class="title">Digging Deeper</p><p>Recursion is an important programming technique that can, however, be quite difficult to understand. Here I will explain recursion one step at a time.<a id="IDX-CHP-13-0047" class="indexterm"/><a id="IDX-CHP-13-0048" class="indexterm"/></p><p><span class="bolditalic">Recursion Made Simple</span></p><p>If you’ve never used recursion before, the recursive “directory-walking” methods in this chapter may need a little explanation. To clarify how recursion works, let’s look at a much simpler example. Load the <span class="emphasis"><em>recursion.rb</em></span> program:</p><p><span class="emphasis"><em>recursion.rb</em></span></p><a id="I_programlisting13_d1e16566"/><pre class="programlisting">$outercount = 0

def addup( aNum )
    aNum += 1
    $outercount +=1
    puts( "aNum is #{aNum}, $outercount is #{$outercount}" )
    if $outercount &lt; 3 then
        addup( aNum )         #&lt;= recursive call to addup method
    end
    puts("At END: aNum is #{aNum},outercount is #{$outercount}")
end

addup( 0 )                    #&lt;= This is where it all begins</pre><p>This contains the recursive method, <code class="literal">addup</code>, whose sole purpose in life is to count from 1 to 3. The <code class="literal">addup</code> method receives an integer value as an incoming argument, <code class="literal">aNum</code>.</p><a id="I_programlisting13_d1e16579"/><pre class="programlisting">addup( aNum )</pre><p>There is also global variable, <code class="literal">$outercount</code>, which lives “outside” the <code class="literal">addup</code> method. Whenever the <code class="literal">addup</code> method executes, 1 is added to <code class="literal">aNum</code>, and 1 is also added to <code class="literal">$outercount</code>. Then, just so long as <code class="literal">$outercount</code> is less than 3, the code inside the <code class="literal">addup</code> method calls the same method (<code class="literal">addup</code>) all over again, passing to it the new value of <code class="literal">aNum</code>:</p><a id="I_programlisting13_d1e16611"/><pre class="programlisting">if $outercount &lt; 3 then
    addup( aNum )
end</pre><p>Let’s follow what happens. The process is started off by calling <code class="literal">addup</code> with the value 0:</p><a id="I_programlisting13_d1e16619"/><pre class="programlisting">addup( 0 )</pre><p>The <code class="literal">addup</code> method adds 1 to both <code class="literal">aNum</code> and <code class="literal">$outercount</code>, so both variables now have the value 1. The test (<code class="literal">$outercount &lt; 3</code>) evaluates to true, so <code class="literal">aNum</code> is passed as an argument to <code class="literal">addup</code>. Once again, 1 is added to both variables, so <code class="literal">aNum</code> is now 2, and <code class="literal">$outercount</code> is also 2. Now <code class="literal">aNum</code> is once more passed to <code class="literal">addup</code>. Yet again 1 is added to both variables, giving each the value 3. This time, however, the test condition fails since <code class="literal">$outercount</code> is no longer less than 3. So, the code that calls <code class="literal">addup</code> is skipped, and you arrive at the last line in the method:</p><a id="I_programlisting13_d1e16661"/><pre class="programlisting">puts( "At END: aNum is #{aNum}, outercount is #{$outercount}" )</pre><p>This prints out the values of <code class="literal">aNum</code> and <code class="literal">$outercount</code>, which, as you expect, are both 3. Having arrived at the end of this method, the “flow of control” moves back to the line of code immediately following the code that originally called the method. Here, the line of code that called the <code class="literal">addup</code> method happens to be inside the method itself. Here it is:</p><a id="I_programlisting13_d1e16674"/><pre class="programlisting">addup( aNum )</pre><p>And the first executable line that follows this is (once again) the final line of the method that prints out the values of the two variables:</p><a id="I_programlisting13_d1e16678"/><pre class="programlisting">puts( "At END: aNum is #{aNum}, outercount is #{$outercount}" )</pre><p>So, you have gone back to an earlier “point of execution”—the point at which you recursively called the <code class="literal">addup</code> method. At that time, the value of <code class="literal">aNum</code> was 2, and that is its value <span class="emphasis"><em>now</em></span>. If this seems confusing, just try to think what would have happened if <code class="literal">aNum</code> had been 2 and then you called some other, unrelated method. On returning from that other method, <code class="literal">aNum</code> would, of course, still have had the value 2. That’s all that’s happened here. The only difference is that this method happened to call <span class="emphasis"><em>itself</em></span> rather than some other method.</p><p>Once again, the method exits, and control returns to the next executable line following the code that called the method, and <code class="literal">aNum</code>’s value has taken another step back into its own history—it now has the value 1. The <code class="literal">$outercount</code> variable, however, lives <span class="emphasis"><em>outside</em></span> the method and is unaffected by recursion, so it is still 3.</p><p>If you have access to a visual debugger, this entire process will become much clearer: You can place a breakpoint on line 9 (<code class="literal">if $outercount &lt; 3 then</code>), add <code class="literal">aNum</code> and <code class="literal">$outercount</code> to the Watch window, and repeatedly step into the code after you hit the breakpoint.<a id="IDX-CHP-13-0049" class="indexterm"/></p><div class="informalfigure"><a id="image_no_caption-id16"/><div class="mediaobject"><a id="I_mediaobject13_d1e16727"/><img src="httpatomoreillycomsourcenostarchimages860162.png" alt="image with no caption"/></div></div><p>This screenshot shows the recursion program being debugged visually in the IDE Ruby In Steel. I can step through the source code, use the call stack to keep track of the current “level” of recursion (how many times the addup method has been called), and use the Watch window to monitor the current values of the variables.<a id="IDX-CHP-13-0050" class="indexterm"/></p></div></div></body></html>