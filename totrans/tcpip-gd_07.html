<html><head></head><body><div class="part" title="Part&#xA0;II-4.&#xA0;INTERNET PROTOCOL VERSION 6 (IPV6)"><div class="titlepage"><div><div><h1 class="title"><a id="internet_protocol_version_6_ipv6"/>Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)</h1></div></div></div><div class="partintro" id="id3228304" title="INTERNET PROTOCOL VERSION 6 (IPV6)"><div/><p><a class="xref" href="ch24.html" title="Chapter 24. IPV6 OVERVIEW, CHANGES, AND TRANSITION">Chapter 24</a></p><p><a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a></p><p><a class="xref" href="ch26.html" title="Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 26</a></p><p><a class="xref" href="ch27.html" title="Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING">Chapter 27</a></p><p>Since 1981, TCP/IP has been built on version 4 of the Internet Protocol (IPv4), discussed at length in the preceding part. IPv4 was created when the giant, worldwide Internet we take for granted today was just a small, experimental network. Considering how much the Internet has grown and changed over the course of two decades, IPv4 has done its job admirably. At the same time, it has been apparent for many years that certain limitations in this venerable protocol would hold back the future growth of the Internet if they were not addressed.</p><p>Due to the key role that IP plays, changing it is no simple feat. It means a substantial modification to the way that nearly everything in TCP/IP operates. However, even though we find change difficult, most of us know that it is necessary. For the past several years, development of a new version of IP has been under way, officially called <span class="emphasis"><em>Internet Protocol version 6 (IPv6)</em></span> and also sometimes referred to as <span class="emphasis"><em>IP Next Generation</em></span> or <span class="emphasis"><em>IPng</em></span>. IPv6 is poised to take over for IPv4, and it will be the basis for the Internet of the future.</p><p>In this part, I provide a detailed description of IPv6. Since IPv6 is still IP, just like IPv4, it performs the same functions: addressing, encapsulation, fragmentation and reassembly, and datagram delivery and routing. For this reason, this discussion of IPv6 is patterned after the discussion of IPv4. There are four chapters: The first covers IPv6 concepts and issues; the second discusses IPv6 addressing; the third discusses IPv6 encapsulation and formatting; and the fourth discusses IPv6 datagram fragmentation, reassembly, and routing.</p><p>Since IPv6 represents the evolution of IP, many of its concepts of operation are built on those introduced in IPv4. To avoid unnecessary duplication in this part, I've assumed you are familiar with the operation of IPv4, especially addressing and how datagrams are packaged and delivered. If you have not read <a class="xref" href="pt06.html" title="Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)">Part II-3</a>, reviewing it first would be wise, because the description of IPv6 focuses on how it differs from the current IP version.</p><p>You may also wish to refer to the <a class="xref" href="pt09.html" title="Part II-6. IP SUPPORT PROTOCOLS">Part II-6</a>, which covers the Internet Control Message Protocol (ICMP), part of which is ICMP version 6—ICMP for IPv6, and the IPv6 Neighbor Discovery (ND) protocol, since these are companions to IPv6.</p></div></div>
<div class="chapter" title="Chapter&#xA0;24.&#xA0;IPV6 OVERVIEW, CHANGES, AND TRANSITION"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_overview_changes_and_transition"/>Chapter 24. IPV6 OVERVIEW, CHANGES, AND TRANSITION</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e24540"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>Internet Protocol version 6 (IPv6) is destined to be the future of IP, and due to IP's critical importance, it will form the basis for the future of TCP/IP and the Internet as well. In fact, it's been under development since the middle of the last decade, and a real IPv6 internetwork has been used for testing for a number of years as well. Despite this, many people don't know much about IPv6, other than the fact that it's a newer version of IP. Some have never even heard of it at all! I'm going to rectify that, of course—but before I delve into the important changes made in IPv6 addressing, packaging, fragmentation, and other functions, let's start with a bird's-eye view of IPv6.</p><p>In this chapter, I provide a brief higher-level overview of IPv6, including a look at how it differs from IP version 4 (IPv4) in general terms. I begin with a brief overview of IPv6 and why it was created. I list the major changes made in IPv6 and the new additions to the protocol. I also explain some of the difficulties associated with transitioning the enormous global Internet from IPv4 to IPv6.</p><div class="sect1" title="IPv6 Motivation and Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_motivation_and_overview"/>IPv6 Motivation and Overview</h1></div></div></div><p>"If it ain't broke, don't fix it." This is one of my favorite pieces of folk wisdom. I generally like to stick with what works, as do most people. And IPv4 works pretty darned well. It's been around for decades now and has survived the growth of the Internet from a small research network into a globe-spanning powerhouse. So, like a trusty older car that you've operated successfully for years, why should you replace it if it still gets the job done?</p><p>Like that older car, you could continue to use IPv4 for the foreseeable future. The question is: at what cost? An older car can be kept in good working order if you are willing to devote the time and money it takes to maintain and service it. However, it will still be limited in some of its capabilities. Its reliability may be suspect. It won't have the latest features. With the exception of those who like to work on cars as a hobby, it eventually stops making sense to keep fixing up an older vehicle.</p><p>In some ways, this isn't that great of an analogy. Our highways aren't all that much different than they were in the 1970s, and most other issues related to driving a car haven't changed all that much in the past 25 years either. The choice of updating a vehicle or not is based on practical considerations more than necessity.</p><p>In contrast, look at what has happened to the computer and networking worlds in the last 25 years! Today's handheld PCs can do more than the most powerful servers could back then. Networking technologies are 100 or even 1,000 times as fast. The number of people connecting to the global Internet has increased by an even larger factor. And the ways that computers communicate have, in many cases, changed dramatically.</p><p>IPv4 could be considered in some ways like an older car that has been meticulously maintained and repaired over time. It gets the job done, but its age is starting to show. The main problem with IPv4 is its relatively small address space, a legacy of the decision to use only 32 bits for the IP address. Under the original classful addressing allocation scheme, we would have probably already run out of IPv4 addresses by now. Moving to classless addressing has helped postpone this, as have technologies like IP Network Address Translation (NAT), which allows privately addressed hosts to access the Internet.</p><p>In the end, however, these represent patch jobs and imperfect repairs applied to keep the aging IPv4 automobile on the road. The core problem, the 32-bit address space that is too small for the current and future size of the Internet, can be solved only by moving to a larger address space. This was the primary motivating factor in creating the next version of IP, <a class="indexterm" id="idx-CHP-24-0840"/><span class="emphasis"><em>IPv6</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="note-86"/>Note</h3><p><span class="emphasis"><em>The reason why the successor to IPv4 is version 6 and not version 5 is because version number 5 was used to refer to an experimental protocol called the Internet Stream Protocol, which was never widely deployed. See <a class="xref" href="ch15.html" title="Chapter 15. INTERNET PROTOCOL VERSIONS, CONCEPTS, AND OVERVIEW">Chapter 15</a> for a full discussion of IP history and versions</em></span>.</p></div><div class="sect2" title="IPv6 Standards"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_standards"/>IPv6 Standards</h2></div></div></div><p><a class="indexterm" id="idx-CHP-24-0841"/>IPv6 represents the first major change to IP since IPv4 was formalized in 1981. For many years, its core operation was defined in a series of RFCs published in 1998: RFCs 2460 through 2467. The most notable of these are the main IPv6 standard, RFC 2460, "Internet Protocol, Version 6 (IPv6) Specification," and documents describing the two helper protocols for IPv6: RFC 2461, which describes the IPv6 Neighbor Discovery Protocol (ND), and RFC 2463, which describes Internet Control Message Protocol version 6 (ICMPv6) for IPv6.</p><p>In addition to these, two documents were also written in 1998. They discuss more about IP addressing: RFC 2373, "IP Version 6 Addressing Architecture," and RFC 2374, "An IPv6 Aggregatable Global Unicast Address Format." Due to changes in how IPv6 addressing was to be implemented, these were updated in 2003 by RFC 3513, "Internet Protocol Version 6 (IPv6) Addressing Architecture," and RFC 3587, "IPv6 Global Unicast Address Format."</p><p>Many other RFCs define more specifics of how IPv6 works, and many also describe IPv6-compatible versions of other TCP/IP protocols like the Domain Name System (DNS; see <a class="xref" href="ch52.html" title="Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS">Chapter 52</a>) and Dynamic Host Control Protocol (DHCP; see <a class="xref" href="ch61.html" title="Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS">Chapter 61</a>). IPv6 is still very much a work in progress, with new standards being proposed and adopted on a regular basis.</p><p>Because IPv6 is the version of IP that's designed for the next generation of the Internet, it is also sometimes called <span class="emphasis"><em>IP Next Generation</em></span> or <span class="emphasis"><em>IPng</em></span>. Personally, I don't care for this name; it reminds me too much of <span class="emphasis"><em>Star Trek: The Next Generation</em></span>. Regardless of its name, IPv6 or IPng was designed to take TCP/IP and the Internet "where none have gone before." (Sorry, I <span class="emphasis"><em>had</em></span> to!)</p></div><div class="sect2" title="Design Goals of IPv6"><div class="titlepage"><div><div><h2 class="title"><a id="design_goals_of_ipv6"/>Design Goals of IPv6</h2></div></div></div><p><a class="indexterm" id="idx-CHP-24-0842"/>The problem of addressing was the main motivation for creating IPv6. Unfortunately, this has caused many people to think that the address space expansion is the <span class="emphasis"><em>only</em></span> change made in IP, which is definitely not the case. Since making a change to IP is such a big deal, it's something done rarely. It made sense to correct not just the addressing issue, but also to update the protocol in a number of other respects in order to ensure its viability. In fact, even the addressing changes in IPv6 go far beyond just adding more bits to IP address fields.</p><p>Some of the most important goals in designing IPv6 include the following:</p><p><span class="strong"><strong>Larger Address Space</strong></span> IPv6 needed to provide more addresses for the growing Internet.</p><p><span class="strong"><strong>Better Management of Address Space</strong></span> Developers wanted IPv6 to include not only more addresses, but also a more capable way of dividing the address space and using the bits in each address.</p><p><span class="strong"><strong>Elimination of Addressing Kludges</strong></span> Technologies like NAT are effectively kludges that make up for the lack of address space in IPv4. IPv6 eliminates the need for NAT and similar work-arounds, allowing every TCP/IP device to have a public address.</p><p><span class="strong"><strong>Easier TCP/IP Administration</strong></span> The designers of IPv6 hoped to resolve some of the current labor-intensive requirements of IPv4, such as the need to configure IP addresses. Even though tools like DHCP eliminate the need to manually configure many hosts, it only partially solves the problem.</p><p><span class="strong"><strong>Modern Design for Routing</strong></span> In contrast to IPv4, which was designed before anyone had an idea what the modern Internet would be like, IPv6 was created specifically for efficient routing in the current Internet, and with the flexibility for the future.</p><p><span class="strong"><strong>Better Support for Multicasting</strong></span> Multicasting was an option in IPv4 from the start, but support for it has been slow in coming.</p><p><span class="strong"><strong>Better Support for Security</strong></span> IPv4 was designed at a time when security wasn't much of an issue because there were a relatively small number of networks on the Internet, and those networks' administrators often knew each other. Today, security on the public Internet is a big issue, and the future success of the Internet requires that security concerns be resolved.</p><p><span class="strong"><strong>Better Support for Mobility</strong></span> When IPv4 was created, there really was no concept of mobile IP devices. The problems associated with computers that move between networks led to the need for Mobile IP. IPv6 builds on Mobile IP and provides mobility support within IP itself.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-124"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The new version of the IP is <span class="emphasis"><em>Internet Protocol version 6 (IPv6)</em></span>. It was created to correct some of the significant problems of IPv4, especially the looming deficiency of the IPv4 address space, to improve the operation of the protocol as a whole, and to take TCP/IP into the future.</p></div><p>At the same time that IPv6 was intended to address these and many other issues with traditional IP, its changes are nevertheless <span class="emphasis"><em>evolutionary</em></span>, not <span class="emphasis"><em>revolutionary</em></span>. During the many discussions in the Internet Engineering Task Force (IETF) in the 1990s, there were some who said that while we were updating IP, perhaps we should make a complete, radical change to a new type of internetworking protocol completely. The end decision was not to do this, but to define a more capable version of the IP that we've been using all along.</p><p>The reason for this is simple: IP, like our trusted older car, <span class="emphasis"><em>works</em></span>. IPv6 represents an update that strives to add to the best characteristics of IPv4, rather than making everyone start over from scratch with something new and unproven. This design ensures that whatever pain may result from the change from IPv4 to IPv6 can be managed, and hopefully, minimized.</p></div></div></div>
<div class="sect1" title="Major Changes and Additions in IPv6"><div class="titlepage"><div><div><h1 class="title"><a id="major_changes_and_additions_in_ipv6"/>Major Changes and Additions in IPv6</h1></div></div></div><p><a class="indexterm" id="idx-CHP-24-0843"/>In the preceding overview, I explained that the primary motivation for creating a new version of IP was to fix the problems with addressing under IPv4. But as you also saw, numerous other design goals existed for the new protocol as well. Once the decision was made to take the significant step of creating a new version of a protocol as important as IP, it made sense to use the opportunity to make as many improvements as possible.</p><p>Of course, there is still the problem of the pain of change to worry about, so each potential change or addition in IPv6 needed to have benefits that would outweigh its costs. The resulting design does a good job of providing useful advantages while maintaining most of the core of the original IP. The following are some of the most important changes between IPv4 and IPv6, and they demonstrate some of the ways that the IPv6 team met the design goals for the new protocol:</p><p><span class="strong"><strong>Larger Address Space</strong></span> IPv6 addresses are 128 bits long instead of 32 bits. This expands the address space from around 4 billion addresses to, well, an astronomical number (over 300 trillion trillion trillion addresses).</p><p><span class="strong"><strong>Hierarchical Address Space</strong></span> One reason why the IPv6 address size was expanded so much was to allow it to be hierarchically divided to provide a large number of many classes of addresses.</p><p><span class="strong"><strong>Hierarchical Assignment of Unicast Addresses</strong></span> A special global unicast address format was created to allow addresses to be easily allocated across the entire Internet. It allows for multiple levels of network and subnetwork hierarchies at both the Internet service provider (ISP) and the organizational level. It also permits the generation of IP addresses based on underlying hardware interface device IDs such as Ethernet MAC addresses.</p><p><span class="strong"><strong>Better Support for Nonunicast Addressing</strong></span> Support for multicasting is improved, and support for a new type of addressing, <span class="emphasis"><em>anycast</em></span> addressing, has been added. This new kind of addressing basically says, "Deliver this message to the easiest-to-reach member of this group," and potentially enables new types of messaging functionality.</p><p><span class="strong"><strong>Autoconfiguration and Renumbering</strong></span> A provision is included to allow easier autoconfiguration of hosts and renumbering of the IP addresses in networks and subnetworks as needed. A technique also exists for renumbering router addresses.</p><p><span class="strong"><strong>New Datagram Format</strong></span> The IP datagram format has been redefined and given new capabilities. The main header of each IP datagram has been streamlined, and support has been added for the ability to easily extend the header for datagrams that require more control information.</p><p><span class="strong"><strong>Support for Quality of Service (QoS)</strong></span> IPv6 datagrams include QoS features that allow for better support for multimedia and other applications that require QoS.</p><p><span class="strong"><strong>Security Support</strong></span> Security support is designed into IPv6 using the authentication and encryption extension headers and other features.</p><p><span class="strong"><strong>Updated Fragmentation and Reassembly Procedures</strong></span> The way that the fragmentation and reassembly of datagrams works has been changed in IPv6. The improved routing efficiency better reflects the realities of today's networks.</p><p><span class="strong"><strong>Modernized Routing Support</strong></span> IPv6 is designed to support modern routing systems and allow for expansion as the Internet grows.</p><p><span class="strong"><strong>Transition Capabilities</strong></span> Since it was recognized from the start that going from IPv4 to IPv6 is a big move, support for the IPv4/IPv6 transition has been provided in numerous areas. This includes a plan for interoperating IPv4 and IPv6 networks, for mapping between IPv4 and IPv6 addresses, and other transition support.</p><p><span class="strong"><strong>Changes to Other Protocols</strong></span> With the introduction of IPv6, several other TCP/IP protocols that deal intimately with IP have also had to be updated. One of these is ICMP, the most important support protocol for IPv4, which has been revised through the creation of ICMPv6 for IPv6. An addition to TCP/IP is the ND protocol, which performs several functions for IPv6 that were done by the Address Resolution Protocol (ARP) and ICMP in version 4.</p><p>The following chapters on IPv6 provide much more detail on these changes and additions to IP. You'll notice that the majority of these are related to addressing, because that is where the greatest number of important changes were made in IPv6. Of course, routing and addressing are closely related, and the changes to addressing have had a big impact on routing as well.</p></div>
<div class="sect1" title="Transition from IPv4 to IPv6"><div class="titlepage"><div><div><h1 class="title"><a id="transition_from_ipv4_to_ipv6"/>Transition from IPv4 to IPv6</h1></div></div></div><p><a class="indexterm" id="idx-CHP-24-0844"/>IP is the foundation of the TCP/IP protocol suite and the Internet, and thus it's somewhat comparable to the foundation of a house in terms of its structural importance. Given this, changing IP is somewhat analogous to making a substantial modification to the foundation of your house. Since IP is used to connect together many devices, it is like changing not just your house, but every house in the world!</p><p>How do you change the foundation of a house? Very carefully. The same caution is required with the implementation of IPv6. While most people think IPv6 is something new, the reality is that the planning and development of IPv6 has been underway for nearly a full decade, and if we were starting from scratch, the protocol would have been ready for action years ago. However, there is a truly enormous installed base of IPv4 hardware and software. This means the folks who develop TCP/IP could not just flip a switch and have everyone move over to using IPv6. Instead, a <span class="emphasis"><em>transition</em></span> from IPv4 to IPv6 had to be planned.</p><p>The transition is already under way, though most people don't know about it. As I said, development of IPv6 itself is pretty much complete, though work continues on refining the protocol and also on the development of IPv6-compatible versions of other protocols. The implementation of IPv6 began with the creation of development networks to test IPv6's operation. These were connected together to form an experimental IPv6 internetwork called the <a class="indexterm" id="idx-CHP-24-0845"/><span class="emphasis"><em>6BONE</em></span> (which is a contraction of the phrase <span class="emphasis"><em>IPv6 backbone</em></span>). This internetwork has been in operation for several years.</p><div class="sect2" title="IPv4 to IPv6 Transition: Differences of Opinion"><div class="titlepage"><div><div><h2 class="title"><a id="ipv4_to_ipv6_transition_differences_of_o"/>IPv4 to IPv6 Transition: Differences of Opinion</h2></div></div></div><p>Experimental networks are well and good, but the big issue is transitioning the Internet to IPv6, and here, opinion diverges rather quickly. In one camp are the corporations, organizations, and individuals. All of these groups are quite eager to transition to IPv6 quickly in order to gain the many benefits it promises in the areas of addressing, routing, and security. Others are taking a much more cautious approach, noting that the dire predictions in the mid-1990s of IPv4's imminent doom have not come to pass, and arguing that we should take our time to make sure IPv6 is going to work on a large scale.</p><p>These two groups will continue to play tug-of-war for the next few years, but it seems that the tide is now turning toward those who want to speed up the now-years-long transition. The move toward adoption of IPv6 as a <span class="emphasis"><em>production</em></span> protocol is being spearheaded by a number of groups and organizations. IPv6 has a lot of support in areas outside the United States, many of which are running short of IPv4 addresses due to small allocations relative to their size. One such area is Asia, a region with billions of people, rapidly growing Internet use, and a shortage of IPv4 addresses.</p><p>Within the United States, which has the lion's share of IPv4 addresses (because the Internet was developed here), there seems to be a bit less enthusiasm for rapid IPv6 deployment. Even here, however, IPv6 got a major shot in the arm in July 2003 when the United States <a class="indexterm" id="idx-CHP-24-0846"/>Department of Defense (DoD) announced that starting in October of that year, it would purchase only networking products that included compatibility with IPv6. The <a class="indexterm" id="idx-CHP-24-0847"/>DoD (which was responsible for the development of the Internet in the first place) hopes to be fully transitioned to IPv6 by 2008. This will likely have a big impact on the plans of other governmental and private organizations in the United States.</p><p>The creators of IPv6 knew from the start that transition was going to be an important issue with the new protocol. IPv6 is not compatible with IPv4 because the addressing system and datagram format are different. Yet the IPv6 designers knew that since the transition would take many years, it was necessary that they provide a way for IPv4 and IPv6 hosts to interoperate. Consider that in any transition there are always stragglers. Like the old Windows 3.11 PC in the corner that you still need to use once in a while, some devices will remain on IPv4, even when most of the Internet is IPv6, because they were never upgraded.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-125"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Due to the many differences between IPv4 and IPv6, and the fundamental importance of IP to TCP/IP, an orderly transition has been planned from IPv4 to IPv6 over a period of many years.</p></div></div><div class="sect2" title="IPv4 to IPv6 Transition Methods"><div class="titlepage"><div><div><h2 class="title"><a id="ipv4_to_ipv6_transition_methods"/>IPv4 to IPv6 Transition Methods</h2></div></div></div><p>The IETF has been working on specific provisions to allow a smooth transition from IPv4 to IPv6, and hardware and software interoperability solutions to let newer IPv6 devices access IPv4 hosts. A technique was included in IPv6 to allow administrators to embed IPv4 addresses within IPv6 addresses. Special methods are defined to handle interoperability, including the following:</p><p><span class="strong"><strong>Dual-Stack Devices</strong></span> Routers and some other devices may be programmed with both IPv4 and IPv6 implementations to allow them to communicate with both types of hosts.</p><p><span class="strong"><strong>IPv4/IPv6 Translation</strong></span> Dual-stack devices may be designed to accept requests from IPv6 hosts, convert them to IPv4 datagrams, send the datagrams to the IPv4 destination, and then process the return datagrams similarly.</p><p><span class="strong"><strong>IPv4 Tunneling of IPv6</strong></span> IPv6 devices that don't have a path between them consisting entirely of IPv6-capable routers may be able to communicate by encapsulating IPv6 datagrams within IPv4. In essence, they would be using IPv6 on top of IPv4; that is, two network layers. The encapsulated IPv4 datagrams would travel across conventional IPv4 routers.</p><p>Bear in mind that these solutions generally address only backward compatibility to allow IPv6 devices to talk to IPv4 hardware. Forward compatibility between IPv4 and IPv6 is not possible because IPv4 hosts cannot communicate with IPv6 hosts; they lack the knowledge of how IPv6 works. It is possible that certain special adaptations might be created to allow IPv4 hosts to access IPv6 hosts. But eventually, all IPv4 devices of any importance will want to migrate to IPv6.</p><p>The IETF has done such a good job in the past with introducing new technologies, and so much effort has been put into the IPv6 transition, that I am quite confident that the transition to IPv6 will come off with few, if any, problems. One good thing about the transition is that IPv4 is, at the present time, still getting the job done, so there is no big hurry to make the move to IPv6. While technologies such as CIDR and NAT are like Band-Aids on IPv4, they have been very successful ones in extending the useful life of the aging protocol.</p></div></div>
<div class="chapter" title="Chapter&#xA0;25.&#xA0;IPV6 ADDRESSING"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_addressing"/>Chapter 25. IPV6 ADDRESSING</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e24817"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>The primary motivation for creating Internet Protocol version 6 (IPv6) was to rectify the <a class="indexterm" id="idx-CHP-25-0848"/>addressing problems in version 4 (IPv4). Along with acquiring more addresses, the IPv6 designers desired a way of interpreting, assigning, and using addresses in a way that was more consonant with modern internetworking. So, it's no surprise that many of the changes in IPv6 are associated with IP addressing. The IPv6 addressing scheme is similar in concept to IPv4 addressing, but has been completely overhauled to create an addressing system that's capable of supporting continued Internet expansion and new applications for the foreseeable future.</p><p>This chapter describes the concepts and methods associated with addressing under IPv6. I begin with a look at some addressing generalities in IPv6, including the addressing model, address types' size, and address space. I discuss the unique and sometimes confusing representations and notations used for IPv6 addresses and prefixes. Then I look at how addresses are arranged and allocated into types, beginning with an overall look at address space composition and then at the global unicast address format. I describe the new methods used for mapping IP addresses to underlying physical network addresses. I then describe special IPv6 addressing issues, including reserved and private addresses, IPv4 address embedding, anycast and multicast addresses, and autoconfiguration and renumbering of addresses.</p><p>Addressing under IPv6 is outlined in the main IPv6 RFC, RFC 2460, "Internet Protocol, Version 6 (IPv6) Specification." However, most of the details of IPv6 addressing are contained in two other standards: RFC 3513, "Internet Protocol Version 6 (IPv6) Addressing Architecture," and RFC 3587, "IPv6 Global Unicast Address Format." These replaced the 1998 standards RFC 2373, "IP Version 6 Addressing Architecture," and RFC 2374, "An IPv6 Aggregatable Global Unicast Address Format."</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-126"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>As with the other IPv6 chapters in this book, my look at addressing is based somewhat on a contrast to how addressing is done in IPv4. I strongly recommend a thorough understanding of IPv4 addressing, including classless addressing using Classless Inter-Domain Routing (CIDR), as presented in Chapters <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a> through <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a>, before proceeding here. As with the IPv4 addressing sections, familiarity with how binary numbers work, and conversion between binary and decimal numbers is also a good idea. <a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a>, which provides some background on data representation and the mathematics of computing, may be of assistance in that respect</em></span>.</p></div><div class="sect1" title="IPv6 Addressing Overview: Addressing Model, Address Types, and Address Size"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_addressing_overview_addressing_mode"/>IPv6 Addressing Overview: Addressing Model, Address Types, and Address Size</h1></div></div></div><p><a class="indexterm" id="idx-CHP-25-0849"/>As you saw in the previous chapter, IPv6 represents a significant update to IP, but its modifications and additions are made without changing the core nature of how IP works. Addressing is the place where most of the differences between IPv4 and IPv6 are seen, but the changes are mostly in how addresses are implemented and used. The overall model used for IP addressing in IPv6 is pretty much the same as it was in IPv4; some aspects have not changed at all, while others have changed only slightly.</p><div class="sect2" title="IPv6 Addressing Model Characteristics"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_addressing_model_characteristics"/>IPv6 Addressing Model Characteristics</h2></div></div></div><p>Here are some of the general characteristics of the IPv6 addressing model that are basically the same as in IPv4:</p><p><span class="strong"><strong>Core Functions of Addressing</strong></span> The two main functions of addressing are still network interface identification and routing. Routing is facilitated through the structure of addresses on the internetwork.</p><p><span class="strong"><strong>Network Layer Addressing</strong></span> IPv6 addresses are still the ones associated with the network layer in TCP/IP networks and are distinct from data link layer (also sometimes called <span class="emphasis"><em>physical</em></span>) addresses.</p><p><span class="strong"><strong>Number of IP Addresses per Device</strong></span> Addresses are still assigned to network interfaces, so a regular host like a PC will usually have one (unicast) address, and routers will have more than one for each of the physical networks to which it connects.</p><p><span class="strong"><strong>Address Interpretation and Prefix Representation</strong></span> <a class="indexterm" id="idx-CHP-25-0850"/>IPv6 addresses are like classless IPv4 addresses in that they are interpreted as having a network identifier part and a host identifier part (a network ID and a host ID), but that the delineation is not encoded into the address itself. A prefix-length number, using CIDR-like notation, is used to indicate the length of the network ID (prefix length).</p><p><span class="strong"><strong>Private and Public Addresses</strong></span> Both <a class="indexterm" id="idx-CHP-25-0851"/>types of addresses exist in IPv6, though they are defined and used somewhat differently.</p></div><div class="sect2" title="IPv6 Supported Address Types"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_supported_address_types"/>IPv6 Supported Address Types</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0852"/>One important change in the addressing model of IPv6 is the <span class="emphasis"><em>address types</em></span> supported. IPv4 supported three address types: <a class="indexterm" id="idx-CHP-25-0853"/>unicast, multicast, and <a class="indexterm" id="idx-CHP-25-0854"/>broadcast. Of these, the vast majority of actual traffic was unicast. IP multicast support was not widely deployed until many years after the Internet was established and it continues to be hampered by various issues. Use of broadcast in IP had to be severely restricted for performance reasons (we don't want any device to be able to broadcast across the entire Internet!).</p><p>IPv6 also supports three address types, but with the following changes:</p><p><span class="strong"><strong>Unicast Addresses</strong></span> These are standard unicast addresses as in IPv4, one per host interface.</p><p><span class="strong"><strong>Multicast Addresses</strong></span> These are addresses that represent various groups of IP devices. A message sent to a multicast address goes to all devices in the group. IPv6 includes much better multicast features and many more multicast addresses than IPv4. Since multicast under IPv4 was hampered in large part due to lack of support of the feature by many hardware devices, support for multicasting is a required, not optional, part of IPv6.</p><p><span class="strong"><strong>Anycast Addresses</strong></span> Anycast addressing is used when a message must be sent to any member of a group, but does not need to be sent to all of them. Usually the member of the group that is easiest to reach will be sent the message. One common example of how anycast addressing could be used is in load sharing among a group of routers in an organization.</p><p>Broadcast addressing as a distinct addressing method is gone in IPv6. Broadcast functionality is implemented using multicast addressing to groups of devices. A multicast group to which all nodes belong can be used for broadcasting in a network, for example.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-127"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IPv6 has unicast and multicast addresses like IPv4. There is, however, no distinct concept of a broadcast address in IPv6. A new type of address, <span class="emphasis"><em>the anycast</em></span> address, has been added to allow a message to be sent to any one member of a group of devices.</p></div><p>An important implication of the creation of anycast addressing is removal of the strict uniqueness requirement for IP addresses. Anycast is accomplished by assigning the same IP address to more than one device. The devices must also be specifically told that they are sharing an anycast address, but the addresses themselves are structurally the same as unicast addresses.</p><p>The bulk of the remainder of this chapter focuses on unicast addressing, since it is by far the most important type. Multicast and anycast addressing are given special attention in a separate section later in this chapter.</p></div><div class="sect2" title="IPv6 Address Size and Address Space"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_address_size_and_address_space"/>IPv6 Address Size and Address Space</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0855"/><a class="indexterm" id="idx-CHP-25-0856"/><a class="indexterm" id="idx-CHP-25-0857"/>Of all the changes introduced in <a class="indexterm" id="idx-CHP-25-0858"/>IPv6, easily the most celebrated is the increase in the size of IP addresses, which resulted in a corresponding massive increase in the size of the address space as well. It's not surprising that these sizes were increased compared to IPv4—everyone has known for years that the IPv4 address space was too small to support the future of the Internet. What's remarkable is the level of increase and the implications for how Internet addresses are used.</p><p>In IPv4, IP addresses are 32 bits long; these are usually grouped into 4 octets of 8 bits each. The theoretical IPv4 address space is 2<sup>32</sup>, or 4,294,967,296 addresses. To increase this address space, we simply increase the size of addresses; each extra bit we give to the address size doubles the address space. Based on this, some folks expected the IPv6 address size to increase from 32 to 48 bits, or perhaps 64 bits. Either of these numbers would have given a rather large number of addresses.</p><p>However, IPv6 addressing doesn't use either of these figures. Instead, the IP address size jumps all the way to 128 bits, or 16 8-bit octets/bytes. The size of the IPv6 address space is, quite literally, astronomical. Like the numbers that describe the number of stars in a galaxy or the distance to the furthest pulsars, the number of addresses that can be supported in IPv6 is mind-boggling. See <a class="xref" href="ch25.html#a_poor_representation_of_relative_ipv4_a" title="Figure 25-1. A (poor) representation of relative IPv4 and IPv6 address space sizes I wanted to make a cool graphic to show the relative sizes of the IPv4 and IPv6 address spaces. You know, where I would show the IPv6 address space as a big box and the IPv4 address space as a tiny one. The problem is that the IPv6 address space is so much larger than the IPv4 space that there is no way to show it to scale! To make this diagram to scale, imagine the IPv4 address space is the 1.6-inch square above. In that case, the IPv6 address space would be represented by a square the size of the solar system!">Figure 25-1</a> for an idea of what I mean by <span class="emphasis"><em>astronomical</em></span>.</p><p>Since IPv6 addresses are 128 bits long, the theoretical address space, if all addresses were used, is 2<sup>128</sup> addresses. This number, when expanded out, is 340,282,366,920,938,463,463,374,607,431,768,211,456, which is normally expressed in scientific notation as about 3.4*10<sup>38</sup> addresses. Whoa! That's about 340 trillion, <span class="emphasis"><em>trillion</em></span>, <span class="emphasis"><em>trillion</em></span> addresses. As I said, it's pretty hard to grasp just how large this number is. Consider these comparisons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It's enough addresses for many trillions of addresses to be assigned to every human being on the planet.</p></li><li class="listitem"><p>The Earth is about 4.5 billion years old. If you had been assigning IPv6 addresses at a rate of 1 billion per second since the Earth was formed, you would have by now used up less than one trillionth of the address space.</p></li><li class="listitem"><p>The Earth's surface area is about 510 trillion square meters. If a typical computer has a footprint of about one-tenth of a square meter, you would have to stack computers 10 billion high—blanketing the entire surface of the Earth—to use up that same trillionth of the address space.</p></li></ul></div><p>OK, I think you get the idea. It's clear that one goal of the decision to go to 128-bit addresses is to make sure that we will never run out of address space again, and it seems quite likely that this will be the case.</p><div class="figure"><a id="a_poor_representation_of_relative_ipv4_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e25017"/><img alt="A (poor) representation of relative IPv4 and IPv6 address space sizes I wanted to make a cool graphic to show the relative sizes of the IPv4 and IPv6 address spaces. You know, where I would show the IPv6 address space as a big box and the IPv4 address space as a tiny one. The problem is that the IPv6 address space is so much larger than the IPv4 space that there is no way to show it to scale! To make this diagram to scale, imagine the IPv4 address space is the 1.6-inch square above. In that case, the IPv6 address space would be represented by a square the size of the solar system!" src="httpatomoreillycomsourcenostarchimages287869.png.jpg"/></div></div><p class="title">Figure 25-1. A (poor) representation of relative IPv4 and IPv6 address space sizes I wanted to make a cool graphic to show the relative sizes of the IPv4 and IPv6 address spaces. You know, where I would show the IPv6 address space as a big box and the IPv4 address space as a tiny one. The problem is that the IPv6 address space is so much larger than the IPv4 space that there is no way to show it to scale! To make this diagram to scale, imagine the IPv4 address space is the 1.6-inch square above. In that case, the IPv6 address space would be represented by a square the size of the solar system!</p></div><p>There are drawbacks to having such a huge address space, too. Consider that even with a 64-bit address, we would have a very large address space; 2<sup>64</sup> equals 18,446,744,073,709,551,616, or about 18 million trillion. These are still probably more addresses than the Internet will ever need. However, by going to 128 bits instead, this has made dealing with IP addresses unruly (as you'll see in the next section). This has also increased overhead, since every datagram header or other place where IP addresses are referenced must use 16 bytes for each address instead of the 4 bytes that were needed in IPv4, or the 8 bytes that might have been required with a 64-bit address.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-128"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The IPv6 address space is really, <span class="emphasis"><em>really</em></span> big!</p></div><p>So why the overkill of going to 128 bits? The main reason is <span class="emphasis"><em>flexibility</em></span>. Even though you can have a couple zillion addresses if we allocate them one at a time, this makes assignment difficult. The developers got rid of class-oriented addressing in IPv4 because it wasted address space. The reality, though, is that being able to waste address space is a useful luxury.</p><p>Having 128 bits allows us to divide the address space and assign various purposes to different bit ranges, while still not having to worry about running out of space. Later in this chapter, in the section describing the IPv6 global unicast address format, you'll see one way that those 128 bits are put to good use: They allow you to create a hierarchy of networks while still saving 64 bits for host IDs. This hierarchy has its own advantages.</p></div></div></div>
<div class="sect1" title="IPv6 Address and Address Notation and Prefix Representation"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_address_and_address_notation_and_pr"/>IPv6 Address and Address Notation and Prefix Representation</h1></div></div></div><p>Increasing the size of IP addresses from 32 bits to 128 bits expands the address space to a gargantuan size, thereby ensuring that we will never again run out of IP addresses, and thereby allowing flexibility in how they are assigned and used. Unfortunately, there are some drawbacks to this method, and one of them is that 128-bit numbers are very large. The size makes them awkward and difficult to use.</p><p>Computers work in <a class="indexterm" id="idx-CHP-25-0859"/>binary, and they have no problem dealing with long strings of ones and zeros, but humans find them confusing. Even the 32-bit addresses of IPv4 are cumbersome for us to deal with, which is why we use dotted decimal notation for them unless we need to work in binary (as with subnetting). However, <a class="indexterm" id="idx-CHP-25-0860"/>IPv6 addresses are so much larger than IPv4 addresses that it becomes problematic to use dotted decimal notation. To use this notation, we would split the 128 bits into 16 octets and represent each with a decimal number from 0 to 255. However, we would end up not with 4 of these numbers, but <span class="emphasis"><em>16</em></span>. A typical IPv6 address in this notation would appear as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>128.91.45.157.220.40.0.0.0.0.252.87.212.200.31.255</td></tr></table><p>The binary and dotted decimal <a class="indexterm" id="idx-CHP-25-0861"/>representations of this address are shown near the top of <a class="xref" href="ch25s02.html#binary_decimal_and_hexadecimal_represent" title="Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses The top two rows show binary and dotted decimal representations of an IPv6 address; neither is commonly used (other than by computers themselves!). The top row of the lower table shows the full hexadecimal representation, while the next two rows illustrate zero suppression and compression. The last row shows mixed notation, with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255). This is most commonly used for embedded IPv4 addresses.">Figure 25-2</a>. In either case, the word <span class="emphasis"><em>elegant</em></span> doesn't exactly spring to mind.</p><div class="figure"><a id="binary_decimal_and_hexadecimal_represent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e25086"/><img alt="Binary, decimal, and hexadecimal representations of IPv6 addresses The top two rows show binary and dotted decimal representations of an IPv6 address; neither is commonly used (other than by computers themselves!). The top row of the lower table shows the full hexadecimal representation, while the next two rows illustrate zero suppression and compression. The last row shows mixed notation, with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255). This is most commonly used for embedded IPv4 addresses." src="httpatomoreillycomsourcenostarchimages287871.png.jpg"/></div></div><p class="title">Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses The top two rows show binary and dotted decimal representations of an IPv6 address; neither is commonly used (other than by computers themselves!). The top row of the lower table shows the full hexadecimal representation, while the next two rows illustrate zero suppression and compression. The last row shows mixed notation, with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255). This is most commonly used for embedded IPv4 addresses.</p></div><div class="sect2" title="IPv6 Address Hexadecimal Notation"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_address_hexadecimal_notation"/>IPv6 Address Hexadecimal Notation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0862"/>To make addresses shorter, the decision was made in IPv6 to change the primary method of expressing addresses to use hexadecimal instead of decimal. The advantage of this is that it requires fewer characters to represent an address, and converting from hexadecimal to binary and back again is much easier than converting from binary to decimal or vice versa. The disadvantage is that many people find hexadecimal difficult to comprehend and work with, especially because the notion of 16 values in each digit is a bit strange.</p><p>The hexadecimal notation used for IPv6 addresses is similar to the same method used for IEEE 802 MAC addresses, and for technologies like Ethernet. With these MAC addresses, 48 bits are represented by 6 octets, each octet being a hexadecimal number from 0 to FF, separated by a dash or colon, like this:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>0A-A7-94-07-CB-D0</td></tr></table><p>Since IPv6 addresses are larger, they are instead grouped into eight 16-bit <span class="emphasis"><em>words</em></span>, separated by colons, to create what is sometimes called <a class="indexterm" id="idx-CHP-25-0863"/><span class="emphasis"><em>colon hexadecimal notation</em></span>, as shown in <a class="xref" href="ch25s02.html#binary_decimal_and_hexadecimal_represent" title="Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses The top two rows show binary and dotted decimal representations of an IPv6 address; neither is commonly used (other than by computers themselves!). The top row of the lower table shows the full hexadecimal representation, while the next two rows illustrate zero suppression and compression. The last row shows mixed notation, with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255). This is most commonly used for embedded IPv4 addresses.">Figure 25-2</a>. So, the IPv6 address given in the previous example would be expressed as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>805B:2D9D:DC28:0000:0000:FC57:D4C8:1FFF</td></tr></table><p>To keep the address size down, leading zeros can be suppressed in the notation so you can immediately reduce this to the following:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>805B:2D9D:DC28:0:0:FC57:D4C8:1FFF</td></tr></table><p>Well, it's definitely shorter than dotted decimal, but still pretty long. When you are dealing with numbers this big, there's only so much you can do. This is part of why the use of Domain Name System (DNS) names for hosts becomes much more important under IPv6 than it is in IPv4: Who could remember a hex address that long?</p></div><div class="sect2" title="Zero Compression in IPv6 Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="zero_compression_in_ipv6_addresses"/>Zero Compression in IPv6 Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0864"/>Fortunately, there is a shortcut that can be applied to shorten some addresses even further. This technique is sometimes called <a class="indexterm" id="idx-CHP-25-0865"/><span class="emphasis"><em>zero compression</em></span>. The method allows a single string of contiguous zeros in an IPv6 address to be replaced by double colons. So, for example, the previous address could be expressed as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>805B:2D9D:DC28::FC57:D4C8:1FFF</td></tr></table><p>You know how many zeros are replaced by the two colons (::) because you can see how many fully expressed (uncompressed) hexadecimal words are in the address. In this case, there are six, so the :: represents two zero words. To prevent ambiguity, the double colons can appear only once in any IP address, because if it appeared more than once, you could not tell how many zeros were replaced in each instance. So, if the example address were 805B:2D9D:DC28:0:0:FC57:0:0, you could replace either the first pair of zeros or the second, but not both.</p><p>Zero compression doesn't make the example much shorter, but due to how IPv6 addresses are structured, long strings of zeros are common. For example, consider this address:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>FF00:4501:0:0:0:0:0:32</td></tr></table><p>With compression, this could be shortened as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>FF00:4501::32</td></tr></table><p>The technique works even better on special addresses. The full IPv6 loopback address is written as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>0:0:0:0:0:0:0:1</td></tr></table><p>With compression, the loopback address looks like this:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>::1</td></tr></table><p>For even more fun, consider the especially odd IPv6 unspecified address, as shown here:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>0:0:0:0:0:0:0:0</td></tr></table><p>Apply zero compression to an address that is all zeros, and what do you get?</p><table border="0" class="simplelist" summary="Simple list"><tr><td>::</td></tr></table><p>No numbers at all! Of course, thinking of :: as an address <span class="emphasis"><em>does</em></span> take some getting used to.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-129"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> For brevity, IPv6 addresses are represented using eight sets of four hexadecimal digits, a form called <span class="emphasis"><em>colon hexadecimal notation</em></span>. Additional techniques, called <span class="emphasis"><em>zero suppression</em></span> and <span class="emphasis"><em>zero compression</em></span>, are used to reduce the size of displayed addresses further by removing unnecessary zeros from the presentation of the address.</p></div></div><div class="sect2" title="IPv6 Mixed Notation"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_mixed_notation"/>IPv6 Mixed Notation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0866"/>There is also an alternative notation used in some cases, especially for expressing IPv6 addresses that embed IPv4 addresses (discussed later in this chapter). For these, it is useful to show the IPv4 portion of the address in the older dotted decimal notation, since that's what you use for IPv4. Since embedding uses the last 32 bits for the IPv4 address, the notation has the first 96 bits in colon hexadecimal notation and the last 32 bits in dotted decimal. So, to take the earlier example again, in <a class="indexterm" id="idx-CHP-25-0867"/><span class="emphasis"><em>mixed notation</em></span> it would be shown as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>805B:2D9D:DC28::FC57:<span class="strong"><strong>212.200.31.255</strong></span></td></tr></table><p>This isn't really a great example of mixed notation, because embedding usually involves long strings of zeros followed by the IPv4 address. Thus, zero compression comes in very handy here. Instead of seeing something like this:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>0:0:0:0:0:0:212.200.31.255</td></tr></table><p>You will typically see this:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>::212.200.31.255</td></tr></table><p>At first glance, this appears to be an IPv4 address. You must keep a close eye on those colons in IPv6!</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-130"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A special mixed notation is defined for IPv6 addresses whose last 32 bits contain an embedded IPv4 address. In this notation, the first 96 bits are displayed in regular colon hexadecimal notation, and the last 32 bits are displayed in IPv4-style dotted decimal.</p></div></div><div class="sect2" title="IPv6 Address Prefix Length Representation"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_address_prefix_length_representatio"/>IPv6 Address Prefix Length Representation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0868"/>Like IPv4 classless addresses, IPv6 addresses are fundamentally divided into a number of network ID bits followed by a number of host ID bits. The network identifier is called the <span class="emphasis"><em>prefix</em></span>, and the number of bits used is the <span class="emphasis"><em>prefix length</em></span>. This prefix is represented by adding a slash after the address and then putting the prefix length after the slash. This is the same method used for classless IPv4 addressing with CIDR. For example, if the first 48 bits of the sample address were the network ID (prefix), then we would express this as 805B:2D9D:DC28::FC57:D4C8:1FFF/48.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-131"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In IPv6, the size of an address's prefix is indicated by the prefix length that follows the address, separated with a slash, just as it is done in IPv4 classless addressing.</p></div><p>As in IPv4, specifiers for whole networks will typically end in long strings of zeros. These can be replaced by double colons (::) using zero compression. For example, the 48-bit network ID for the previous example is 805B:2D9D:DC28:0:0:0:0:0/48, or 805B:2D9D:DC28::/48. You <span class="emphasis"><em>must</em></span> include the "::" if replacing the trailing zeros.</p></div></div>
<div class="sect1" title="IPv6 Address Space Allocation"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_address_space_allocation"/>IPv6 Address Space Allocation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-25-0869"/>After dealing for so many years with the very small IPv4 address space, the enormous number of addresses in IPv6 must have made the Internet Engineering Task Force (IETF) engineers feel like kids in a candy shop. They were good kids, however, and didn't run wild, grabbing all the candy they could find and gobbling it up. They very carefully considered how to divide the address space for various uses. Of course, when you have this much candy, sharing becomes pretty easy.</p><p>As was the case with IPv4, the two primary concerns in deciding how to divide the IPv6 address space were address assignment and routing. The designers of IPv6 wanted to structure the address space to make <a class="indexterm" id="idx-CHP-25-0870"/>allocation of addresses to Internet service providers (ISPs), organizations, and individuals as easy as possible.</p><p>At first, perhaps ironically, this led the creators of IPv6 back full circle to the use of specific bit sequences to identify different types of addresses, just like the old classful addressing scheme. The address type was indicated by a set of bits at the start of the address, called the format prefix (FP). The format prefix was conceptually identical to the one to four bits used in IPv4 classful addressing to denote address classes, but was variable in length, ranging from three to ten bits. Format prefixes were described in RFC 2373.</p><p>In the years following the publication of RFC 2373, the gurus who run the Internet had a change of heart regarding how address blocks should be considered. They still wanted to divide the IPv6 address space into variably sized blocks for different purposes. However, they realized that many people were starting to consider the use of format prefixes to be equivalent to the old class-oriented IPv4 system. Their main concern was that implementers might program into IPv6 hardware logic to make routing decisions based only on the first few bits of the address. This was specifically <span class="emphasis"><em>not</em></span> how IPv6 is supposed to work; for one thing, the <a class="indexterm" id="idx-CHP-25-0871"/>allocations are subject to change.</p><p>Thus, one of the modifications made in RFC 3513 was to change the language regarding IPv6 address allocations, and specifically, to remove the term <a class="indexterm" id="idx-CHP-25-0872"/><span class="emphasis"><em>format prefix</em></span> from the standard. The allocation of different parts of the address space is still done based on particular patterns of the first three to ten bits of the address to allow certain categories to have more addresses than others. The elimination of the specific term denoting this is intended to convey that these bits should not be given special attention.</p><p><a class="xref" href="ch25s03.html#ipv_address_space_allocations" title="Table 25-1. IPv6 Address Space Allocations">Table 25-1</a> shows the allocations of the IPv6 address space and what fraction of the total address space each represents.</p><div class="table"><a id="ipv_address_space_allocations"/><p class="title">Table 25-1. IPv6 Address Space Allocations</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Address Space Allocations"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Leading Bits</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Fraction of Total IPv6 Address Space</p></th><th style="border-bottom: 0.5pt solid ; "><p>Allocation</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0000 0000</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/256</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned (Includes special addresses such as the unspecified and loopback addresses)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0000 0001</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/256</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0000 001</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/128</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved for NSAP address allocation</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0000 01</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/64</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0000 1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/32</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0001</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>001</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Global unicast addresses</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>010</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>011</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>100</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>101</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1111 0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/32</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1111 10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/64</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1111 110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/128</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1111 1110 0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/512</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unassigned</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1111 1110 10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/1024</p></td><td style="border-bottom: 0.5pt solid ; "><p>Link-local unicast addresses</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1111 1110 11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/1024</p></td><td style="border-bottom: 0.5pt solid ; "><p>Site-local unicast addresses</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1111 1111</p></td><td style="border-right: 0.5pt solid ; "><p>1/256</p></td><td style=""><p>Multicast addresses</p></td></tr></tbody></table></div></div><p>This is more complicated than the IPv4 classful scheme because there are so many more categories and they range greatly in size, even if most of them are currently unassigned.</p><p>An easier way to make sense of this table is to consider the division of the IPv6 address space into <span class="emphasis"><em>eighths</em></span>. Of these eight groups, one (001) has been reserved for unicast addresses; a second (000) has been used to carve out smaller reserved blocks, and a third (111) has been used for sub-blocks for local and multicast addresses. Five are completely unassigned.</p><p>You can see that the IPv6 designers have taken great care to allocate only the portion of these "eighths" of the address space that they felt was needed for each type of address. For example, only a small portion of the part of the address space beginning 111 was used, with most of it left aside. In total, only 71/512ths of the address space is assigned right now, or about 14 percent. The other 86 percent is unassigned and kept aside for future use. (Bear in mind that even 1/1024th of the IPv6 address space is gargantuan—it represents trillions of trillions of addresses.)</p><p>Later sections in this chapter provide more information on several of these address blocks. Note that the 0000 0000 reserved block is used for several special address types, including the loopback address, the unspecified address, and IPv4 address embedding. The 1111 1111 format prefix identifies multicast addresses; this string is FF in hexadecimal, so any address beginning with FF is a multicast address in IPv6.</p></div>
<div class="sect1" title="IPv6 Global Unicast Address Format"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_global_unicast_address_format"/>IPv6 Global Unicast Address Format</h1></div></div></div><p><a class="indexterm" id="idx-CHP-25-0873"/>It is anticipated that unicast addressing will be used for the vast majority of Internet traffic under IPv6, as is the case for IPv4. It is for this reason that the largest of the assigned blocks of the IPv6 address space is dedicated to unicast addressing. A full one-eighth slice of the enormous IPv6 address "pie" is assigned to unicast addresses, which are indicated by a 001 in the first three bits of the address. The question is: How do we use the remaining 125 bits in the spacious IP addresses?</p><div class="sect2" title="Rationale for a Structured Unicast Address Block"><div class="titlepage"><div><div><h2 class="title"><a id="rationale_for_a_structured_unicast_addre"/>Rationale for a Structured Unicast Address Block</h2></div></div></div><p>When IPv4 was first created, the Internet was rather small, and the model for allocating address blocks was based on a central coordinator: the Internet Assigned Numbers Authority (IANA). Everyone who wanted address blocks would go straight to the central authority. As the Internet grew, this model became impractical. Today, IPv4's classless addressing scheme allows variable-length network IDs and hierarchical assignment of address blocks. Big ISPs get large blocks from the central authority, and then subdivide them and allocate them to their customers, and so on. This is managed by today's ISPs, but there is nothing in the address space that helps manage the allocation process. In turn, each organization has the ability to further subdivide its address allocation to suit its internal requirements.</p><p>The designers of IPv6 had the benefit of this experience and realized there would be tremendous advantages to designing the unicast address structure to reflect the overall topology of the Internet. These include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Easier allocation of address blocks at various levels of the Internet topological hierarchy.</p></li><li class="listitem"><p>IP network addresses that automatically reflect the hierarchy by which routers move information across the Internet, thereby allowing routes to be easily aggregated for more efficient routing.</p></li><li class="listitem"><p>Flexibility for organizations like ISPs to subdivide their address blocks for customers.</p></li><li class="listitem"><p>Flexibility for end-user organizations to subdivide their address blocks to match internal networks, much as subnetting did in IPv4.</p></li><li class="listitem"><p>Greater meaning to IP addresses. Instead of just being a string of 128 bits with no structure, it would become possible to look at an address and know certain things about it.</p></li></ul></div></div><div class="sect2" title="Generic Division of the Unicast Address Space"><div class="titlepage"><div><div><h2 class="title"><a id="generic_division_of_the_unicast_address_"/>Generic Division of the Unicast Address Space</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0874"/>The most generic way of dividing up the 128 bits of the unicast address space is into three sections, as shown in <a class="xref" href="ch25s04.html#generic_ipv_global_unicast_address_forma" title="Table 25-2. Generic IPv6 Global Unicast Address Format">Table 25-2</a>.</p><div class="table"><a id="generic_ipv_global_unicast_address_forma"/><p class="title">Table 25-2. Generic IPv6 Global Unicast Address Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Generic IPv6 Global Unicast Address Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bits)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prefix</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>n</em></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Global Routing Prefix: The network ID or prefix of the address, used for routing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnet ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>m</em></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Subnet Identifier: A number that identifies a subnet within the site.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Interface ID</p></td><td style="border-right: 0.5pt solid ; "><p>128-<span class="emphasis"><em>n-m</em></span></p></td><td style=""><p>Interface Identifier: The unique identifier for a particular interface (host or other device). It is unique within the specific prefix and subnet.</p></td></tr></tbody></table></div></div><p>The <span class="emphasis"><em>global routing prefix</em></span> and <span class="emphasis"><em>subnet identifier</em></span> represent the two basic levels at which addresses need to be hierarchically constructed: that is, global and site-specific. The routing prefix consists of a number of bits that can be further subdivided according to the needs of Internet registries and ISPs. This subdivision reflects the topography of the Internet as a whole. The subnet ID gives a number of bits to site administrators for creating an internal network structure suiting each administrator's needs.</p></div><div class="sect2" title="IPv6 Implementation of the Unicast Address Space"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_implementation_of_the_unicast_addre"/>IPv6 Implementation of the Unicast Address Space</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0875"/>In theory, any size for <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>m</em></span> (see <a class="xref" href="ch25s04.html#generic_ipv_global_unicast_address_forma" title="Table 25-2. Generic IPv6 Global Unicast Address Format">Table 25-2</a>) could be used. The implementation chosen for IPv6, however, assigns 48 bits to the routing prefix and 16 bits to the subnet identifier. This means 64 bits are available for interface identifiers, which are constructed based on the IEEE EUI-64 format, as described in the next section. Thus, the overall IPv6 unicast address format is constructed as shown in <a class="xref" href="ch25s04.html#ipv_global_unicast_address_format" title="Table 25-3. IPv6 Global Unicast Address Format">Table 25-3</a> and illustrated in <a class="xref" href="ch25s04.html#ipv6_global_unicast_address_format-id001" title="Figure 25-3. IPv6 global unicast address format">Figure 25-3</a>.</p><div class="table"><a id="ipv_global_unicast_address_format"/><p class="title">Table 25-3. IPv6 Global Unicast Address Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Global Unicast Address Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bits)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prefix</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>48</p></td><td style="border-bottom: 0.5pt solid ; "><p>Global Routing Prefix: The network ID or prefix of the address that's used for routing. The first three bits are 001 to indicate a unicast address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnet ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Subnet Identifier: A number that identifies a subnet within the site.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Interface ID</p></td><td style="border-right: 0.5pt solid ; "><p>64</p></td><td style=""><p><a class="indexterm" id="idx-CHP-25-0876"/>Interface ID: The unique identifier for a particular interface (host or other device). It is unique within the specific prefix and subnet.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ipv6_global_unicast_address_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e25721"/><img alt="IPv6 global unicast address format" src="httpatomoreillycomsourcenostarchimages287873.png.jpg"/></div></div><p class="title">Figure 25-3. IPv6 global unicast address format</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-132"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The part of the IPv6 address space set aside for unicast addresses is structured into an address format that uses the first 48 bits for the <span class="emphasis"><em>routing prefix</em></span> (like a network ID), the next 16 bits for a <span class="emphasis"><em>subnet ID</em></span>, and the final 64 bits for an <span class="emphasis"><em>interface ID</em></span> (like a host ID).</p></div><p>Due to this structure, most end sites (regular companies and organizations, as opposed to ISPs) will be assigned IPv6 networks with a 48-bit prefix. In common parlance, these network identifiers have now come to be called <span class="emphasis"><em>48s</em></span> or <span class="emphasis"><em>/48s</em></span>.</p><p>The 16 bits of subnet ID allow each site considerable flexibility in creating subnets that reflect the site's network structure. Here are some example uses of the 16 bits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A smaller organization can just set all the bits in the subnet ID to zero and have a flat internal structure.</p></li><li class="listitem"><p>A medium-sized organization could use all the bits in the subnet ID to perform the equivalent of straight subnetting under IPv4, thereby assigning a different subnet ID to each subnet. There are 16 bits here, and this allows a whopping 65,536 subnets!</p></li><li class="listitem"><p>A larger organization can use the bits to create a multiple-level hierarchy of subnets, exactly like IPv4's Variable Length Subnet Masking (VLSM). For example, the company could use two bits to create four subnets. It could then take the next three bits to create eight sub-subnets in some or all of the four subnets. There would still be 11 more bits to create sub-sub-subnets, and so forth.</p></li></ul></div></div><div class="sect2" title="Original Division of the Global Routing Prefix: Aggregators"><div class="titlepage"><div><div><h2 class="title"><a id="original_division_of_the_global_routing_"/>Original Division of the Global Routing Prefix: Aggregators</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0877"/>The global routing prefix is similarly divided into a hierarchy, but one that has been designed for the use of the entire Internet, like CIDR. There are 45 bits available here (48 bits minus the first three that are fixed at 001). That is a lot. When the unicast address structure was first detailed in RFC 2374, that document described a specific division of the 45 bits based on a two-level hierarchical topology of Internet registries and providers. These organizations were described as follows:</p><p><span class="strong"><strong>Top-Level Aggregators (TLAs)</strong></span> These refer to the largest Internet organizations, which were to be assigned large blocks of IPv6 addresses from registration authorities.</p><p><span class="strong"><strong>Next-Level Aggregators (NLAs)</strong></span> These organizations would get blocks of addresses from TLAs and divide them for end-user organizations (sites).</p><p><a class="indexterm" id="idx-CHP-25-0878"/>The 45 bits were split between these two uses, with a few bits reserved in the middle to allow expansion of either field if needed. Thus, the RFC 2374 structure for the 45 bits appeared as listed in <a class="xref" href="ch25s04.html#historical_ipv_unicast_routing_prefix_st" title="Table 25-4. Historical IPv6 Unicast Routing Prefix Structure">Table 25-4</a>.</p><div class="table"><a id="historical_ipv_unicast_routing_prefix_st"/><p class="title">Table 25-4. Historical IPv6 Unicast Routing Prefix Structure</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Historical IPv6 Unicast Routing Prefix Structure"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bits)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TLA ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-bottom: 0.5pt solid ; "><p>Top-Level Aggregation (TLA) Identifier: A globally unique identifier for the top-level aggregator. There are 13 bits, so there were a maximum of 8,192 TLAs allowed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RES</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved: These 8 bits were reserved for future use and set to zero. By leaving these 8 bits between the TLA ID and NLA ID unused, they could later be used to expand either the TLA ID or NLA ID fields as needed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>NLA ID</p></td><td style="border-right: 0.5pt solid ; "><p>24</p></td><td style=""><p>Next-Level Aggregation (NLA) Identifier: Each TLA was given this 24-bit field to generate blocks of addresses for allocation to its customers. The NLA ID is unique for each TLA ID. The use of the 24 bits was left up to the TLA organization.</p></td></tr></tbody></table></div></div><p>You'll notice my use of the past tense in the description of the TLA/NLA <a class="indexterm" id="idx-CHP-25-0879"/>structure, and that table heading is a pretty big giveaway, too. In August 2003, RFC 3587 was published, which in a nutshell says, "Uh, never mind about all that TLA/NLA stuff." The decision was made that having this structure hardwired into an Internet standard was inflexible, and it made more sense to let the regional Internet registries (APNIC, ARIN, LACNIC, and RIPE) decide for themselves how to use the 45 bits.</p><div class="note" title="Note"><h3 class="title"><a id="note-87"/>Note</h3><p><span class="emphasis"><em>The obsoleting of the TLA/NLA structure occurred after many years of people getting used to it, so for some time to come, you will still routinely see those terms mentioned in IPv6 descriptions. (This is why I included discussion of them here.)</em></span></p></div></div><div class="sect2" title="A Sample Division of the Global Routing Prefix into Levels"><div class="titlepage"><div><div><h2 class="title"><a id="a_sample_division_of_the_global_routing_"/>A Sample Division of the Global Routing Prefix into Levels</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0880"/><a class="indexterm" id="idx-CHP-25-0881"/>There is no single structure for determining how the 48-bit routing prefix is divided in the global unicast hierarchy. As one example, it might be possible to divide it into three levels, as shown in <a class="xref" href="ch25s04.html#example_ipv_unicast_routing_prefix_struc" title="Table 25-5. Example IPv6 Unicast Routing Prefix Structure">Table 25-5</a> and illustrated in <a class="xref" href="ch25s04.html#example_of_ipv6_unicast_routing_prefix_s" title="Figure 25-4. Example of IPv6 unicast routing prefix structure The top row shows the global IPv6 unicast address format. The second shows one way to divide the global routing prefix into three levels using 10, 12, and 23 bits, respectively. The third row shows how the first 10 bits are used to create 210, or 1,024, different level 1 blocks. The next row illustrates that for each of these 13-bit prefixes, you could have 212, or 4,096, level 2 blocks. Then, within each 25-bit level 2 ID, you have 23 bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or /48 would be assigned to an individual organization.">Figure 25-4</a>.</p><div class="table"><a id="example_ipv_unicast_routing_prefix_struc"/><p class="title">Table 25-5. Example IPv6 Unicast Routing Prefix Structure</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Example IPv6 Unicast Routing Prefix Structure"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bits)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(Unicast Indicator)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>Each unicast address starts with 001; there is no official name for this (it used to be called the <span class="emphasis"><em>format prefix</em></span>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Level1 ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-bottom: 0.5pt solid ; "><p>Level 1 Identifier: The identifier of the highest level in the hierarchy. This would be used for assigning the largest blocks of addresses in the global hierarchy to the biggest Internet organizations. The number of level 1 organizations would be 210, or 1,024.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Level2 ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-bottom: 0.5pt solid ; "><p>Level 2 Identifier: Each block assigned to a level 1 organization would use 12 bits to create 4,096 address blocks to divide among the lower-level organizations it serves.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Level3 ID</p></td><td style="border-right: 0.5pt solid ; "><p>23</p></td><td style=""><p>Level 3 Identifier: Each level 2 organization has 23 bits to use to divide its level 2 address block. Thus, it could create over 8 million individual /48 address blocks to assign to end-user sites. Alternatively, the 23 bits could be divided further into still lower levels to reflect the structure of the level 2 organization's customers.</p></td></tr></tbody></table></div></div><div class="figure"><a id="example_of_ipv6_unicast_routing_prefix_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e25936"/><img alt="Example of IPv6 unicast routing prefix structure The top row shows the global IPv6 unicast address format. The second shows one way to divide the global routing prefix into three levels using 10, 12, and 23 bits, respectively. The third row shows how the first 10 bits are used to create 210, or 1,024, different level 1 blocks. The next row illustrates that for each of these 13-bit prefixes, you could have 212, or 4,096, level 2 blocks. Then, within each 25-bit level 2 ID, you have 23 bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or /48 would be assigned to an individual organization." src="httpatomoreillycomsourcenostarchimages287875.png.jpg"/></div></div><p class="title">Figure 25-4. Example of IPv6 unicast routing prefix structure The top row shows the global IPv6 unicast address format. The second shows one way to divide the global routing prefix into three levels using 10, 12, and 23 bits, respectively. The third row shows how the first 10 bits are used to create 210, or 1,024, different level 1 blocks. The next row illustrates that for each of these 13-bit prefixes, you could have 212, or 4,096, level 2 blocks. Then, within each 25-bit level 2 ID, you have 23 bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or /48 would be assigned to an individual organization.</p></div><p><a class="indexterm" id="idx-CHP-25-0882"/><a class="indexterm" id="idx-CHP-25-0883"/>This is just one possible theoretical way that the bits in a /48 network address could be assigned. As you can see, with so many bits, there is a lot of flexibility. In the previous scheme, you can have over four million level 2 organizations, each of which can assign eight million /48 addresses. And each of those is equivalent in size to an IPv4 Class B address (over 65,000 hosts)!</p><p>The removal of RFC 2374's fixed structure for the global <a class="indexterm" id="idx-CHP-25-0884"/>routing prefix is consistent with the IPv6 development team's efforts to emphasize that bit fields and structures are used only for allocating addresses and not for routing purposes. The addresses themselves, once created, are not interpreted by hardware on an internetwork based on this format. To routers, the only structure that matters is the division between the network ID and host ID, given by the prefix length that trails the IP address, and this division can occur at any bit boundary. These hardware devices just see 128 bits of an IP address and use it without any knowledge of hierarchical address divisions or levels.</p><p>Incidentally, the key to obtaining the allocation benefits of the aggregatable unicast address format is the abundance of bits available to us under IPv6. The ability to have these hierarchical levels while still allowing 64 bits for the interface identifier is one of the main reasons why IPv6 designers went all the way from 32 bits to 128 bits for address size. By creating this structure, we maintain flexibility, while avoiding the potential chaos of trying to allocate many different network sizes within the 128 bits.</p><p>Note that anycast addresses are structured in the same way as unicast addresses, so they are allocated according to this same model. (Multicast addresses are not.)</p></div></div>
<div class="sect1" title="IPv6 Interface Identifiers and Physical Address Mapping"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_interface_identifiers_and_physical_"/>IPv6 Interface Identifiers and Physical Address Mapping</h1></div></div></div><p><a class="indexterm" id="idx-CHP-25-0885"/><a class="indexterm" id="idx-CHP-25-0886"/>
In IPv4, IP addresses have no relationship to the addresses used for underlying data link layer network technologies. A host that connects to a TCP/IP network using an Ethernet network interface card (NIC) has an Ethernet MAC address and an IP address, but the two numbers are distinct and unrelated in any way. IP addresses are assigned manually by administrators without any regard for the underlying physical address.</p><p>With the overhaul of addressing in IPv6, an opportunity presented itself to create a better way of mapping IP unicast addresses and physical network addresses. Implementing this superior mapping technique was one of the reasons why IPv6 addresses were made so large. With 128 total bits, even with a full 45 bits reserved for the network prefix and 16 bits for the site subnet, we are still left with 64 bits to use for the <span class="emphasis"><em>interface identifier (interface ID)</em></span>, which is analogous to the host ID under IPv4.</p><p>Having so many bits at our disposal gives us great flexibility. Instead of using arbitrary, made-up identifiers for hosts, we can base the interface ID on the underlying data link layer hardware address, as long as that address is no greater than 64 bits in length. Since virtually all devices use layer 2 addresses of 64 bits or fewer, there is no problem in using those addresses for the interface ID in IP addresses. This provides an immediate benefit: It makes networks easier to administer, since we don't need to record two arbitrary numbers for each host. The IP address can be derived from the MAC address and the network ID. It also means that we can tell the IP address from the MAC address and vice versa.</p><p>The actual mapping from data link layer addresses to IP interface IDs depends on the particular technology. It is essential that all devices on the same network use the same mapping technique, of course. By far, the most common type of layer 2 addresses in networking are <a class="indexterm" id="idx-CHP-25-0887"/>IEEE 802 MAC addresses, which are used by Ethernet and other IEEE 802 Project networking technologies. These addresses have 48 bits, arranged into two blocks of 24. The upper 24 bits are arranged into a block called the <span class="emphasis"><em>organizationally unique identifier (OUI)</em></span>, with different values assigned to individual organizations. The lower 24 bits are then used for an identifier for each specific device.</p><p>The IEEE has also defined a format called the <span class="emphasis"><em>64-bit extended unique identifier</em></span>, which is abbreviated <a class="indexterm" id="idx-CHP-25-0888"/><span class="emphasis"><em>EUI-64</em></span>. It is similar to the 48-bit MAC format, except that while the OUI remains at 24 bits, the device identifier becomes 40 bits instead of 24. This gives each manufacturer 65,536 times as many device addresses within its OUI.</p><p>A form of this format, called <a class="indexterm" id="idx-CHP-25-0889"/><span class="emphasis"><em>modified EUI-64</em></span>, has been adopted for IPv6 interface IDs. To get the <a class="indexterm" id="idx-CHP-25-0890"/>modified EUI-64 interface ID for a device, you simply take the EUI-64 address and change the seventh bit from the left (the universal/local, or U/L, bit) from a 0 to a 1.</p><p>Of course, most devices still use the older 48-bit MAC address format. These can be converted to EUI-64 and then modified to EUI-64 form for creating an IPv6 interface ID. The process is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Take the 24-bit OUI portion, the leftmost 24 bits of the Ethernet address, and put them into the leftmost 24 bits of the interface ID. Take the 24-bit local portion (the rightmost 24 bits of the Ethernet address) and put it into the rightmost 24 bits of the interface ID.</p></li><li class="listitem"><p>In the remaining 16 bits in the middle of the interface ID, put the value 11111111 11111110, FFFE in hexadecimal.</p></li><li class="listitem"><p>The address is now in EUI-64 form. Change the universal/local bit (bit 7 from the left, shown in bold in <a class="xref" href="ch25s06.html#converting_ieee_802_mac_addresses_to_ipv" title="Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers">Figure 25-5</a>) from a 0 to a 1. This gives the modified EUI-64 interface ID.</p></li></ol></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-133"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The last 64 bits of IPv6 unicast addresses are used for interface IDs, which are created in a <a class="indexterm" id="idx-CHP-25-0891"/>special format called <span class="emphasis"><em>modified EUI-64</em></span>. A simple process can be used to determine the interface ID from the 48-bit MAC address of a device like an Ethernet network interface card. This can then be combined with a network prefix (routing prefix and subnet ID) to determine a corresponding IPv6 address for the device.</p></div><p>Let's take as an example the Ethernet address of 39-A7-94-07-CB-D0. Here are the steps for conversion (illustrated in <a class="xref" href="ch25s06.html#converting_ieee_802_mac_addresses_to_ipv" title="Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers">Figure 25-5</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Take 39-A7-94, the first 24 bits of the identifier, and put it into the first (leftmost) 24 bits of the address. The local portion of 07-CB-D0 becomes the last 24 bits of the identifier.</p></li><li class="listitem"><p>The middle 16 bits are given the value FF-FE.</p></li><li class="listitem"><p>Change the seventh bit from 0 to 1, which changes the first octet from 39 to 3B.</p></li></ol></div><p>The identifier thus becomes 3B-A7-94-FF-FE-07-CB-D0, or in IPv6 colon hexadecimal notation, 3BA7:94FF:FE07:CBD0. The first 64 bits of the device's address are supplied using the global unicast address format.</p><p>The only drawback of this technique is that if the physical hardware changes, so does the IPv6 address.</p></div>
<div class="sect1" title="IPv6 Special Addresses: Reserved, Private, Unspecified, and Loopback"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_special_addresses_reserved_private_"/>IPv6 Special Addresses: Reserved, Private, Unspecified, and Loopback</h1></div></div></div><p>Just as certain IPv4 address ranges are designated for reserved, private, and other unusual addresses, a small part of the monstrous IPv6 address space has been set aside for special addresses. The purpose of these addresses and address blocks is to provide addresses for special requirements and private use in IPv6 networks. Since even relatively small pieces of IPv6 are still enormous, setting aside 0.1 percent of the address space for a particular use still generally yields more addresses than anyone will ever need.</p><div class="figure"><a id="converting_ieee_802_mac_addresses_to_ipv"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e26082"/><img alt="Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers" src="httpatomoreillycomsourcenostarchimages287877.png.jpg"/></div></div><p class="title">Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers</p></div><div class="sect2" title="Special Address Types"><div class="titlepage"><div><div><h2 class="title"><a id="special_address_types"/>Special Address Types</h2></div></div></div><p>There are four basic types of special <a class="indexterm" id="idx-CHP-25-0892"/>IPv6 addresses:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-25-0893"/>Reserved Addresses</strong></span> A portion of the address space is set aside as reserved for various uses by the IETF, both present and future. Unlike IPv4, which has many small reserved blocks in various locations in the address space, the reserved block in IPv6 is at the "top" of the address space, beginning with 0000 0000 (or 00 for the first hexadecimal octet). This represents 1/256th of the total address space. Some of the special addresses you'll see shortly come from this block. IPv4 address embedding is also done within this reserved address area.</p><div class="note" title="Note"><h3 class="title"><a id="note-88"/>Note</h3><p><span class="emphasis"><em>Reserved addresses are not the same as unassigned addresses. The latter term just refers to blocks whose use has not yet been determined</em></span>.</p></div><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-25-0894"/>Private/Unregistered/Nonroutable Addresses</strong></span> A block of addresses is set aside for private addresses, just as in IPv4, except that like everything in IPv6 the private address block in IPv6 is much larger. These private addresses are local only to a particular link or site and, therefore, are never routed outside a particular company's network. Private addresses are indicated by the address having "1111 1110 1" for the first nine bits. Thus, private addresses have a first octet value of FE in hexadecimal, with the next hexadecimal digit being from 8 to F. These addresses are further divided into two types based on their scope: site-local and link-local, as discussed shortly.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-25-0895"/>Loopback Address</strong></span> Like IPv4, a provision has been made for a special loopback address for testing; datagrams sent to this address "loop back" to the sending device. However, in <a class="indexterm" id="idx-CHP-25-0896"/>IPv6, there is just one address for this function, not a whole block (which was never needed in the first place). The loopback address is 0:0:0:0:0:0:0:1, which is normally expressed using zero compression as ::1.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-25-0897"/>Unspecified Address</strong></span> In IPv4, an IP address of all zeros has a special meaning: It refers to the host itself and is used when a device doesn't know its own address. In <a class="indexterm" id="idx-CHP-25-0898"/>IPv6, this concept has been formalized, and the all-zeros address (0:0:0:0:0:0:0:0) is named the <a class="indexterm" id="idx-CHP-25-0899"/><span class="emphasis"><em>unspecified address</em></span>. It is typically used in the source field of a datagram sent by a device seeking to have its IP address configured. Zero compression can be applied to this address; since it is all zeros, the address becomes just ::. (I consider this confusing, myself. I think something like 0::0 is a lot clearer and short enough.)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-134"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In IPv6, a special <span class="emphasis"><em>loopback address</em></span>, 0:0:0:0:0:0:0:1 (::1 in compressed form) is set aside for testing purposes. The <span class="emphasis"><em>unspecified address</em></span>, 0:0:0:0:0:0:0:0 (:: in compressed form) is used to indicate an unknown address. A block of <span class="emphasis"><em>private</em></span> or <span class="emphasis"><em>local</em></span> addresses is defined. This block is the set of all addresses beginning with 1111 1110 1 as the first nine bits.</p></div></div><div class="sect2" title="IPv6 Private Addresses Type Scopes"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_private_addresses_type_scopes"/>IPv6 Private Addresses Type Scopes</h2></div></div></div><p>Now let's take a closer look at private addresses. In IPv6, these are called <span class="emphasis"><em>local-use</em></span> addresses, with the name conveying clearly what they are for. They are also sometimes called <span class="emphasis"><em>link-layer</em></span> addresses. You'll recall that IPv4 private addresses were commonly used when public addresses could not be obtained for all devices, sometimes in combination with technologies like Network Address Translation (NAT). In IPv6, trickery like NAT isn't required. Instead, local-use addresses are intended for communication that is inherently designed to be sent to local devices only. For example, neighbor discovery functions using the IPv6 Neighbor Discovery (ND) protocol employ local-use addresses.</p><p>The <span class="emphasis"><em>scope</em></span> of local addresses is obviously a local network, not the global scope of public Internet addresses. Local addresses in IPv6 are further divided into two types, reflecting a division of local scope:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-25-0900"/>Site-Local Addresses</strong></span> These addresses have the scope of an entire site or organization. They allow addressing within an organization without having to use a public prefix. Routers will forward datagrams using <a class="indexterm" id="idx-CHP-25-0901"/>site-local addresses within the site, but not addresses outside it to the public Internet. Site-local addresses are differentiated from <a class="indexterm" id="idx-CHP-25-0902"/>link-local addresses by having a tenth bit of 1 following the nine starting address bits that are common to all private IPv6 addresses. Thus, they begin with 1111 1110 11. In hexadecimal, site-local addresses begin with FE, and then C to F for the third digit. So, these addresses start with FEC, FED, FEE, or FEF.</p><p><span class="strong"><strong>Link-Local Addresses</strong></span> These addresses have a smaller scope than site-local addresses; they refer only to a particular physical link (physical network). Routers will not forward datagrams using link-local addresses at all—not even within the organization. These addresses are only for local communication on a particular physical network segment. They can be used for address configuration or for ND functions such as address resolution and ND. Link-local addresses are differentiated from site-local addresses by having a tenth bit of 0 following the nine initial address bits common to all private IPv6 addresses: 1111 1110 1. Thus, site-local addresses begin with FE, and then 8 to B for the third hexadecimal digit. So, these addresses start with FE8, FE9, FEA, or FEB.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-135"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IPv6 site-local addresses allow data to be sent only to the devices within a site or organization. They begin with FEC, FED, FEE, or FEF in hexadecimal. IPv6 link-loca laddresses are used only on a particular local link (physical network), typically for special purposes such as address resolution or Neighbor Discovery (ND). They start with FE8, FE9, FEA, or FEB.</p></div><p>Note that site-local IPv6 addresses are the equivalent of IPv4 private addresses, since they are routed throughout the organization. The concept of link-local scope is new to IPv6.</p></div></div>
<div class="sect1" title="IPv6/IPv4 Address Embedding"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6ipv4_address_embedding"/>IPv6/IPv4 Address Embedding</h1></div></div></div><p><a class="indexterm" id="idx-CHP-25-0903"/><a class="indexterm" id="idx-CHP-25-0904"/>Due to the importance of IP and the significance of the changes made in IPv6, deployment of the newer version of the protocol will not occur all at once. A <span class="emphasis"><em>transition</em></span> from IPv4 to IPv6 will be required. This transition requires careful planning. It is anticipated that the migration from IPv4 to IPv6 will take many years, as I mentioned earlier.</p><p>IPv6 is backward-compatible with IPv4 provided that you use special techniques. For example, to enable communication between islands of IPv6 devices connected by IPv4 networks, you may need to employ tunneling. To support IPv4/IPv6 compatibility, a scheme was developed to allow IPv4 addresses to be <span class="emphasis"><em>embedded</em></span> within the IPv6 address structure. This method takes regular IPv4 addresses and puts them in a special IPv6 format, so that they are recognized as being IPv4 addresses by certain IPv6 devices.</p><p>Since the IPv6 address space is so much bigger than the one in IPv4, <a class="indexterm" id="idx-CHP-25-0905"/>embedding the latter within the former is easy—it's like tucking a compact sedan into the hold of a cargo ship! The embedding address space is part of the reserved address block whose addresses begin with eight 0 bits, but it's only a relatively small part. Two different embedding formats are used to indicate the capabilities of the device that's using the embedded address:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-25-0906"/>IPv4-Compatible IPv6 Addresses</strong></span> These are special addresses assigned to IPv6-capable devices, such as <span class="emphasis"><em>dual-stack</em></span> devices that use both IPv4 and IPv6. They have all zeros for the middle 16 bits; thus, they start off with a string of 96 zeros, followed by the IPv4 address. An example of such an address would be 0:0:0:0:0:0:101.45.75.219 in mixed notation, or more succinctly, ::101.45.75.219. <a class="xref" href="ch25s07.html#ipv4-compatible_embedded_ipv6_address_re" title="Figure 25-6. IPv4-compatible embedded IPv6 address representation">Figure 25-6</a> illustrates IPv4-compatible IPv6 representation.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-25-0907"/>IPv4-Mapped IPv6 Addresses</strong></span> These are regular IPv4 addresses that have been mapped into the IPv6 address space. They are used for devices that are IPv4-capable only. They have a set of 16 ones after the initial string of 80 zeros and then the IPv4 address. So if an IPv4 device has the address 222.1.41.90, such as the one shown in <a class="xref" href="ch25s07.html#ipv4-mapped_embedded_ipv6_address_repres" title="Figure 25-7. IPv4-mapped embedded IPv6 address representation">Figure 25-7</a>, it would be represented as 0:0:0:0:0:FFFF:222.1.41.90, or ::FFFF:222.1.41.90.</p><div class="figure"><a id="ipv4-compatible_embedded_ipv6_address_re"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e26276"/><img alt="IPv4-compatible embedded IPv6 address representation" src="httpatomoreillycomsourcenostarchimages287879.png.jpg"/></div></div><p class="title">Figure 25-6. IPv4-compatible embedded IPv6 address representation</p></div><p><a class="indexterm" id="idx-CHP-25-0908"/>The difference between these two is subtle but important. Both have zeros for the first 80 bits of the address and put the embedded IPv4 address into the last 32 bits of the IPv6 address format. They differ in the value of the 16 remaining bits in between (bits 81 to 96, counting from the left). IPv4-compatible IPv6 addresses are used only for devices that are actually IPv6-aware; the IPv4-compatible address is in addition to its conventional IPv6 address. In contrast, if the FFFF is seen for the 16 bits after the initial 80, this designates a conventional IPv4 devices whose IPv4 address has been mapped into the IPv6 format. It is not an IPv6-capable device.</p><div class="figure"><a id="ipv4-mapped_embedded_ipv6_address_repres"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e26291"/><img alt="IPv4-mapped embedded IPv6 address representation" src="httpatomoreillycomsourcenostarchimages287881.png.jpg"/></div></div><p class="title">Figure 25-7. IPv4-mapped embedded IPv6 address representation</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-136"/>Tip</h3><p><a class="indexterm" id="idx-CHP-25-0909"/><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>IPv4 address embedding</em></span> is used to create a relationship between an IPv4 address and an IPv6 address to help you transition from IPv4 to IPv6. One type, the <span class="emphasis"><em>IPv4-compatible IPv6 address</em></span>, is used for devices that are compatible with both IPv4 and IPv6; it begins with 96 zero bits. The other, the <span class="emphasis"><em>IPv4-mapped address</em></span>, is used for mapping IPv4 devices that are not compatible with IPv6 into the IPv6 address space; it begins with 80 zeros followed by 16 ones.</p></div></div>
<div class="sect1" title="IPv6 Multicast and Anycast Addressing"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_multicast_and_anycast_addressing"/>IPv6 Multicast and Anycast Addressing</h1></div></div></div><p>One of the most significant modifications in the general addressing model in IPv6 was a change to the basic types of <a class="indexterm" id="idx-CHP-25-0910"/>addresses and how they were used. Unicast <a class="indexterm" id="idx-CHP-25-0911"/>addresses are still the choice for the vast majority of communications as in IPv4, but the "bulk" addressing methods are different in IPv6. Broadcast as a specific addressing type has been eliminated. Instead, support for multicast addressing has been expanded and made a required part of the protocol, and a new type of addressing called <span class="emphasis"><em>anycast</em></span> has been implemented.</p><div class="sect2" title="IPv6 Multicast Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_multicast_addresses"/>IPv6 Multicast Addresses</h2></div></div></div><p>Let's start by looking at multicast under IPv6. Multicasting is used to allow a single device to send a datagram to a group of recipients. IPv4 supported multicast addressing using the Class D address block in the classful addressing scheme (see <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a>). Under IPv6, multicast addresses are allocated from the multicast block. This is 1/256th of the address space, and it consists of all addresses that begin with 1111 1111. Thus, any address starting with FF in colon hexadecimal notation is an IPv6 multicast address.</p><p>The remaining 120 bits of address space are enough to allow the definition of, well, a gazillion or three multicast addresses. (OK, it's officially about 1.3 trillion trillion trillion addresses.) The allocation of unicast addresses was organized by using a special format to divide these many bits, and the same thing was done for multicast addresses. The format for multicast addresses is explained in <a class="xref" href="ch25s08.html#ipv_multicast_address_format" title="Table 25-6. IPv6 Multicast Address Format">Table 25-6</a> and illustrated in <a class="xref" href="ch25s08.html#ipv6_multicast_address_format" title="Figure 25-8. IPv6 multicast address format">Figure 25-8</a>.</p><div class="figure"><a id="ipv6_multicast_address_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e26355"/><img alt="IPv6 multicast address format" src="httpatomoreillycomsourcenostarchimages287883.png.jpg"/></div></div><p class="title">Figure 25-8. IPv6 multicast address format</p></div><div class="table"><a id="ipv_multicast_address_format"/><p class="title">Table 25-6. IPv6 Multicast Address Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Multicast Address Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bits)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(Indicator)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>The first eight bits are always 1111 1111, which indicates a multicast address. This used to be called the <span class="emphasis"><em>format prefix</em></span> before the term was dropped (as explained in the section about IPv6 address space allocation earlier in this chapter). The field now has no name.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Four bits are reserved for flags that can be used to indicate the nature of certain multicast addresses. Currently, the first three of these are unused and set to zero. The fourth is the T (Transient) flag. If left as zero, this marks the multicast address as a permanently assigned, well-known multicast address, as you will see shortly. If set to one, this means this is a <span class="emphasis"><em>transient</em></span> multicast address, meaning that it is not permanently assigned.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Scope ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>These four bits are used to define the scope of the multicast address; 16 different values from 0 to 15 are possible. This field allows creation of multicast addresses that are global to the entire Internet, or restricted to smaller spheres of influence such as a specific organization, site, or link. The currently defined values (in decimal) are as follows:</p>
<p>0 = Reserved</p>
<p>1 = Node-Local Scope 2 = Link-Local Scope</p>
<p>5 = Site-Local Scope</p>
<p>8 = Organization-Local Scope</p>
<p>14 = Global Scope</p>
<p>15 = Reserved</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Group ID</p></td><td style="border-right: 0.5pt solid ; "><p>112</p></td><td style=""><p>Defines a particular group within each scope level.</p></td></tr></tbody></table></div></div><div class="sect3" title="Multicast Scopes"><div class="titlepage"><div><div><h3 class="title"><a id="multicast_scopes"/>Multicast Scopes</h3></div></div></div><p>The notion of explicitly scoping multicast <a class="indexterm" id="idx-CHP-25-0912"/>addresses is important. Globally scoped multicast addresses must be unique across the entire Internet, but locally scoped addresses are unique only within the organization. This provides tremendous flexibility, as every type of multicast address actually comes in several versions: one that multicasts only within a node, one that multicasts on the local link (local network), one that multicasts on the local site, and so on. The scope also allows routers to immediately determine how broadly they should propagate multicast datagrams in order to improve efficiency and eliminate problems with traffic being sent outside the are a for which it is intended. <a class="xref" href="ch25s08.html#ipv6_multicast_scope_this_diagram_shows_" title="Figure 25-9. IPv6 multicast scope This diagram shows how the notion of scope allows IPv6 multicasts to be limited to specific spheres of influence. The tightest scope is node-local scope, with a scope ID value of 1. As the scope ID value increases, the scope expands to cover the local network, site, organization, and finally, entire Internet.">Figure 25-9</a> illustrates the notion of multicast scope graphically.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-137"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Multicast addresses are used to send data to a number of devices on an internetwork simultaneously. In IPv6, each multicast address can be specified for a variety of different <a class="indexterm" id="idx-CHP-25-0913"/>scopes, thereby allowing a transmission to be targeted to either a wide or a narrow audience of recipient devices.</p></div><div class="figure"><a id="ipv6_multicast_scope_this_diagram_shows_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e26471"/><img alt="IPv6 multicast scope This diagram shows how the notion of scope allows IPv6 multicasts to be limited to specific spheres of influence. The tightest scope is node-local scope, with a scope ID value of 1. As the scope ID value increases, the scope expands to cover the local network, site, organization, and finally, entire Internet." src="httpatomoreillycomsourcenostarchimages287885.png.jpg"/></div></div><p class="title">Figure 25-9. IPv6 multicast scope This diagram shows how the notion of scope allows IPv6 multicasts to be limited to specific spheres of influence. The tightest scope is node-local scope, with a scope ID value of 1. As the scope ID value increases, the scope expands to cover the local network, site, organization, and finally, entire Internet.</p></div></div><div class="sect3" title="Well-Known Multicast Addresses"><div class="titlepage"><div><div><h3 class="title"><a id="well-known_multicast_addresses-id001"/>Well-Known Multicast Addresses</h3></div></div></div><p>The Transient flag allows for the explicit determination of which multicast <a class="indexterm" id="idx-CHP-25-0914"/>addresses are available for normal use compared to which ones are set aside as well known. Several well-known multicast addresses are defined by setting aside certain group IDs that are used for a number of different scope ID values. <a class="xref" href="ch25s08.html#important_ipv_well-known_multicast_addre" title="Table 25-7. Important IPv6 Well-Known Multicast Addresses">Table 25-7</a> shows these values; the <span class="emphasis"><em>x</em></span> in the multicast address pattern is the hexadecimal digit corresponding to the four-bit scope ID field.</p><p>The all-nodes and all-routers multicast addresses enable the equivalent function of what broadcast used to perform in IPv4. Again, the concept of scope is important in a multicast of this type, because we don't want to try to send a message to all nodes on the global Internet, for example. So when the all-routers address is used with a scope value of 2, it means "all routers on the local link." If it is used with a value of 5, it means "all routers in this site."</p></div><div class="sect3" title="Solicited-Node Multicast Addresses"><div class="titlepage"><div><div><h3 class="title"><a id="solicited-node_multicast_addresses"/>Solicited-Node Multicast Addresses</h3></div></div></div><p><a class="indexterm" id="idx-CHP-25-0915"/>In addition to the regular multicast addresses, each unicast address has a special multicast address called its <a class="indexterm" id="idx-CHP-25-0916"/><span class="emphasis"><em>solicited-node address</em></span>. This address is created through a special mapping from the device's unicast address. Solicited-node addresses are used by the <a class="indexterm" id="idx-CHP-25-0917"/>IPv6 ND protocol (see <a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a>) to provide more efficient address resolution than the Address Resolution Protocol (ARP; see <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>) technique used in IPv4.</p><div class="table"><a id="important_ipv_well-known_multicast_addre"/><p class="title">Table 25-7. Important IPv6 Well-Known Multicast Addresses</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Important IPv6 Well-Known Multicast Addresses"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Multicast Address Pattern</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Valid Scope Values (Decimal)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Designation</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>FF0x:0:0:0:0:0:0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 to 15</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-bottom: 0.5pt solid ; "><p>All multicast addresses where the 112-bit group ID is zero are reserved.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>FF0x:0:0:0:0:0:1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1, 2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>All Nodes</p></td><td style="border-bottom: 0.5pt solid ; "><p>When the group ID is equal to exactly 1, this is a multicast to all nodes. Both node-local (FF01:0:0:0:0:0:1) and link-local (FF02:0:0:0:0:0:1) all-nodes multicast addresses are possible.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>FF0x:0:0:0:0:0:2</p></td><td style="border-right: 0.5pt solid ; "><p>1, 2, 5</p></td><td style="border-right: 0.5pt solid ; "><p>All Routers</p></td><td style=""><p>When the group ID is equal to exactly 2, this designates all routers within a specific scope as the recipients. Valid scope values are node-local, link-local, and site-local.</p></td></tr></tbody></table></div></div><p>All <a class="indexterm" id="idx-CHP-25-0918"/>solicited-node addresses have their T flag set to zero and a scope ID of 2, so they start with FF02. The 112-bit group ID is broken down as follows (see <a class="xref" href="ch25s08.html#ipv6_solicited-node_address_calculation_" title="Figure 25-10. IPv6 solicited-node address calculation The solicited-node multicast address is calculated from a unicast address by taking the last 24 bits of the address and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows the example address from Figure 25-2 converted to its solicited-node address, FF02::1:FFC8:1FFF.">Figure 25-10</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Eighty bits consisting of 79 zeros followed by a single one. This means that the next five hexadecimal values are 0000:0000:0000:0000:0001 in colon hexadecimal notation, or more succinctly, 0:0:0:0:1.</p></li><li class="listitem"><p>Eight ones: FF.</p></li><li class="listitem"><p>Twenty-four bits taken from the bottom 24 bits of its unicast address.</p></li></ul></div><p>So, these addresses start with FF02:0:0:0:0:1:FF, followed by the bottom 24 bits of the unicast address. Thus, the node with IP address 805B:2D9D:DC28:0:0:FC57:D4C8:1FFF would have a solicited-node address of FF02:0:0:0:0:1:FFC8:1FFF (or FF02::1:FFC8:1FFF).</p><div class="figure"><a id="ipv6_solicited-node_address_calculation_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e26610"/><img alt="IPv6 solicited-node address calculation The solicited-node multicast address is calculated from a unicast address by taking the last 24 bits of the address and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows the example address from converted to its solicited-node address, FF02::1:FFC8:1FFF." src="httpatomoreillycomsourcenostarchimages287887.png.jpg"/></div></div><p class="title">Figure 25-10. IPv6 solicited-node address calculation The solicited-node multicast address is calculated from a unicast address by taking the last 24 bits of the address and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows the example address from <a class="xref" href="ch25s02.html#binary_decimal_and_hexadecimal_represent" title="Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses The top two rows show binary and dotted decimal representations of an IPv6 address; neither is commonly used (other than by computers themselves!). The top row of the lower table shows the full hexadecimal representation, while the next two rows illustrate zero suppression and compression. The last row shows mixed notation, with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255). This is most commonly used for embedded IPv4 addresses.">Figure 25-2</a> converted to its solicited-node address, FF02::1:FFC8:1FFF.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-138"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each unicast address has an equivalent <span class="emphasis"><em>solicited-node multicast address</em></span> that is created from the unicast address and used when other devices need to reach it on the local network.</p></div></div></div><div class="sect2" title="IPv6 Anycast Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_anycast_addresses"/>IPv6 Anycast Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0919"/>Anycast addresses are a unique type of address that is new to IP in IPv6. The IPv6 implementation is based on the material in RFC 1546, "Host Anycasting Service." Anycast addresses can be considered a conceptual cross between unicast and multicast addressing. Where unicast says, "Send this to one address," and multicast says, "Send this to every member of this group," anycast says, "Send this to any one member of this group." Naturally, in choosing which member to send to, we would, for efficiency, normally send to the closest one—that is, the closest in routing terms. So, we can normally also consider <span class="emphasis"><em>anycast</em></span> to mean, "Send this to the closest member of this group."</p><p>The idea behind anycast is to enable functionality that was previously difficult to implement in TCP/IP. Anycast was specifically intended to provide flexibility in situations where we need a service that is provided by a number of different servers or routers but don't really care which one provides it. In routing, anycast allows datagrams to be sent to whichever router in a group of equivalent routers is closest, and to allow load sharing among routers and dynamic flexibility if certain routers go out of service. Datagrams sent to the anycast address will automatically be delivered to the device that is easiest to reach.</p><p>Perhaps surprisingly, there is no special anycast-addressing scheme. Anycast addresses are the same as unicast addresses. An anycast address is created automatically when a unicast address is assigned to more than one interface.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-139"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Anycast addresses are new in IPv6 and can be used to set up a group of devices, any one of which can respond to a request sent to a single IP address.</p></div><p>Like multicast, anycast creates more work for routers, because it is more complicated than unicast addressing. In particular, the further apart the devices that share the anycast address are, the more complexity. Anycasting across the global Internet would be potentially difficult to implement, and IPv6 anycasting was designed for devices that are proximate to each other, generally within the same network. Also, at present, due to the Internet community's relative inexperience with anycast, only routers, not individual hosts, use anycast addresses.</p></div></div>
<div class="sect1" title="IPv6 Autoconfiguration and Renumbering"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_autoconfiguration_and_renumbering"/>IPv6 Autoconfiguration and Renumbering</h1></div></div></div><p>One of the most interesting and potentially valuable addressing features implemented in IPv6 is a facility that allows devices on an IPv6 network to actually configure themselves independently. In IPv4, hosts were originally configured manually. Later, host configuration protocols like the Dynamic Host Configuration Protocol (DHCP; see <a class="xref" href="ch61.html" title="Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS">Chapter 61</a>) enabled servers to allocate IP addresses to hosts that joined the network. IPv6 takes this a step further by defining a method for some devices to automatically configure their IP address and other parameters without the need for a server. It also defines a method whereby the IP addresses on a network can be renumbered (changed en masse). These are the sorts of features that make TCP/IP network administrators drool.</p><p>The <a class="indexterm" id="idx-CHP-25-0920"/>IPv6 <a class="indexterm" id="idx-CHP-25-0921"/>autoconfiguration and renumbering feature is defined in RFC 2462, "IPv6 Stateless Address Autoconfiguration." The word <span class="emphasis"><em>stateless</em></span> contrasts this method to the server-based method using something like DHCPv6, which is called <span class="emphasis"><em>stateful</em></span>. (This word, like <span class="emphasis"><em>classful</em></span>, makes me cringe.) This method is called stateless because it begins with no information (or <span class="emphasis"><em>state</em></span>) at all for the host to work with. It has no need for a DHCP server.</p><div class="sect2" title="IPv6 Stateless Autoconfiguration"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_stateless_autoconfiguration"/>IPv6 Stateless Autoconfiguration</h2></div></div></div><p><a class="indexterm" id="idx-CHP-25-0922"/><a class="indexterm" id="idx-CHP-25-0923"/>Stateless autoconfiguration exploits several other new features in IPv6, including link-local addresses, multicasting, the ND protocol, and the ability to generate the interface ID of an address from the underlying data link layer address. The general idea is to have a device generate a temporary address until it can determine the characteristics of the network it is on, and then create a permanent address it can use based on that information. In the case of multihomed devices, autoconfiguration is performed for each interface separately.</p><p>The following is a summary of the steps a device takes when using stateless autoconfiguration:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Link-Local Address Generation</strong></span> The device generates a link-local address. You'll recall that this is one of the two types of local-use IPv6 addresses. Link-local addresses have 1111 1110 10 for the first 10 bits. The generated address uses those 10 bits, followed by 54 zeros and then the 64-bit interface ID. Typically, this will be derived from the data link layer (MAC) address as explained in the "IPv6 Interface Identifiers and Physical Address Mapping" section earlier in this chapter, or it may be a "token" generated in some other manner.</p></li><li class="listitem"><p><span class="strong"><strong>Link-Local Address Uniqueness Test</strong></span> The node tests to ensure that the address it generated isn't already in use on the local network. (This is very unlikely to be an issue if the link-local address came from a MAC address; it is more likely that the address is already in use if it was based on a generated token.) It sends a Neighbor Solicitation message using the ND protocol. In response, it listens for a Neighbor Advertisement, which indicates that another device is already using its link-local address. If so, either a new address must be generated or autoconfiguration fails, and another method must be employed.</p></li><li class="listitem"><p><span class="strong"><strong>Link-Local Address Assignment</strong></span> Assuming the uniqueness test passes, the device assigns the link-local address to its IP interface. This address can be used for communication on the local network, but not on the wider Internet (since link-local addresses are not routed).</p></li><li class="listitem"><p><span class="strong"><strong>Router Contact</strong></span> The node next attempts to contact a local router for more information on continuing the configuration. This is done either by listening for Router Advertisement messages sent periodically by routers or by sending a specific Router Solicitation message to ask a router for information on what to do next. This process is described in the section on the IPv6 ND protocol, in <a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a>.</p></li><li class="listitem"><p><span class="strong"><strong>Router Direction</strong></span> The router provides direction to the node about how to proceed with the autoconfiguration. It may tell the node that on this network stateful autoconfiguration is in use, and it may give it the address of a DHCP server to use. Alternatively, it will tell the host how to determine its global Internet address.</p></li><li class="listitem"><p><span class="strong"><strong>Global Address Configuration</strong></span> Assuming that stateless autoconfiguration is in use on the network, the host will configure itself with its globally unique Internet address. This address is generally formed from a network prefix provided to the host by the router. The prefix is combined with the device's identifier, as generated in step 1.</p></li></ol></div><p>Clearly, this method has numerous advantages over both manual and server-based configuration. It is particularly helpful in supporting the mobility of IP devices, because they can move to new networks and get a valid address without any knowledge of local servers or network prefixes. At the same time, it still allows for the management of IP addresses using the (IPv6-compatible) version of DHCP, if that is desired. Routers on the local network will typically tell hosts which type of autoconfiguration is supported using special flags in Internet Control Message Protocol version 6 (ICMPv6) Router Advertisement messages (see <a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a>).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-140"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IPv6 includes an interesting feature called <span class="emphasis"><em>stateless address autoconfiguration</em></span>, which allows a host to actually determine its own IPv6 address from its layer 2 address by following a special procedure.</p></div></div><div class="sect2" title="IPv6 Device Renumbering"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_device_renumbering"/>IPv6 Device Renumbering</h2></div></div></div><p>The renumbering of devices is a method related to autoconfiguration. Like host configuration, it can be implemented using protocols like DHCP through the use of IP address leases that expire after a period of time. Under IPv6, networks can be renumbered by having routers specify an expiration interval for network prefixes when autoconfiguration is done. Later, they can send a new prefix to tell devices to regenerate their IP addresses. Devices can actually maintain the old deprecated address for a while, and then move over to the new address.</p><p>RFC 2894 defined a similar technique for renumbering router addresses. It uses special ICMPv6 messages and is described in <a class="xref" href="ch35.html" title="Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 35</a>.</p></div></div>
<div class="chapter" title="Chapter&#xA0;26.&#xA0;IPV6 DATAGRAM ENCAPSULATION AND FORMATTING"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_datagram_encapsulation_and_formatti"/>Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e26755"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Delivery of data over Internet Protocol version 6 (IPv6) internetworks is accomplished by encapsulating higher-layer data into IPv6 datagrams. These serve the same general purpose for IPv6 as IPv4 datagrams do in the older version of the protocol. However, they have been redesigned as part of the overall changes represented by IPv6. IPv6 datagrams have a flexible structure, and their format better matches the needs of current IP networks.</p><p>In this chapter, I take a look at the format used for IPv6 datagrams. I begin with an overview of the general structure of IPv6 datagrams, describe the major changes, and show how main and extension headers are arranged in the datagram. I then describe the format of the main header, and define and describe the various extension header types. I conclude with a brief explanation of IPv6 options and how they are implemented.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-141"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>This chapter assumes basic understanding of IPv6 addressing concepts (see the previous chapter) and general familiarity with the IPv4 datagram format (described in <a class="xref" href="ch21.html" title="Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 21</a>)</em></span>.</p></div><div class="sect1" title="IPv6 Datagram Overview and General Structure"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_datagram_overview_and_general_struc"/>IPv6 Datagram Overview and General Structure</h1></div></div></div><p>The method by which IPv6 encapsulates data received from higher-layer protocols for transmission across the internetwork is basically the same as the one used by IPv4. The data received from the transport or higher layers is made the payload of an IPv6 datagram, which has one or more headers that control the delivery of the message. These headers provide information to routers in order to enable them to move the datagram across the network. They also provide information to hosts so they can tell which <a class="indexterm" id="idx-CHP-26-0924"/>datagrams they are intended to receive.</p><p>While the basic use of datagrams hasn't changed since IPv4, many modifications were made to their <a class="indexterm" id="idx-CHP-26-0925"/>structure and format when IPv6 was created. This was done partly out of necessity: IPv6 addresses are different from IPv4 addresses, and IP addresses go in the datagram header. The increase in the size of IP addresses from 32 bits to 128 bits adds a whopping extra 192 bits, or 24 bytes, of information to the header. This led to an effort to remove fields that weren't strictly necessary in order to compensate for the necessary increase in size. However, changes were also made to IPv6 datagrams to add features to them and to make them better suit the needs of modern internetworking.</p><p>The following is a list of the most significant overall changes to datagrams in IPv6:</p><p><span class="strong"><strong>Multiple-Header Structure</strong></span> Rather than a single header that contains all fields for the datagram (possibly including options), the IPv6 datagram supports a main header and then extension headers for additional information when needed.</p><p><span class="strong"><strong>Streamlined Header Format</strong></span> Several fields have been removed from the main header to reduce its size and increase efficiency. Only the fields that are truly required for pretty much <span class="emphasis"><em>all</em></span> datagrams remain in the main header; others are put into extension headers and used as needed. Some were removed because they were no longer needed, such as the Internet Header Length field. The IPv6 header is of fixed length. I'll examine this more thoroughly in a moment.</p><p><span class="strong"><strong>Renamed Fields</strong></span> Some fields have been renamed to better reflect their actual use in modern networks.</p><p><span class="strong"><strong>Greater Flexibility</strong></span> The extension headers allow for a great deal of extra information that will accompany datagrams when needed. Options are also supported in IPv6.</p><p><span class="strong"><strong>Elimination of Checksum Calculation</strong></span> In IPv6, a checksum is no longer computed on the header. This saves both the calculation time spent by every device that packages IP datagrams (hosts and routers) and the space the checksum field took up in the IPv4 header.</p><p><span class="strong"><strong>Improved Quality of Service Support</strong></span> A new field, the Flow Label, is defined to help support the prioritization of traffic.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-142"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IPv6 <a class="indexterm" id="idx-CHP-26-0926"/>datagrams use a general structure that begins with a mandatory main header that's 40 bytes in length, followed by optional extension headers, and then a variable-length Data area. This structure was created to allow the main header to be streamlined, while allowing devices to add extra information to <a class="indexterm" id="idx-CHP-26-0927"/>datagrams when needed.</p></div><p>As I mentioned previously, IPv6 datagrams now include a main header format (which has no official name in the standards; it's just "the header") and zero or more extension headers. The overall structure of an IPv6 datagram is shown in <a class="xref" href="ch26.html#ipv_general_datagram_structure" title="Table 26-1. IPv6 General Datagram Structure">Table 26-1</a> and illustrated in <a class="xref" href="ch26.html#ipv6_general_datagram_structure" title="Figure 26-1. IPv6 general datagram structure">Figure 26-1</a>.</p><div class="table"><a id="ipv_general_datagram_structure"/><p class="title">Table 26-1. IPv6 General Datagram Structure</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 General Datagram Structure"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Component</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Number of Components per Datagram</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Main Header</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>40</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains the source and destination addresses, and important information that's required for every datagram.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extension Headers</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 or more</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Each contains one type of extra information that supports various features, including fragmentation, source routing, security, and options.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Data</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The payload from the upper layer that will be transmitted in the datagram.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ipv6_general_datagram_structure"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e26904"/><img alt="IPv6 general datagram structure" src="httpatomoreillycomsourcenostarchimages287889.png"/></div></div><p class="title">Figure 26-1. IPv6 general datagram structure</p></div><p>Note that as with IPv4, large payloads may be fragmented prior to encapsulation in order to ensure that the total size of the datagram doesn't exceed the maximum size permitted on an underlying network. However, the details of fragmentation in IPv6 are different than in IPv4, as explained in <a class="xref" href="ch27.html" title="Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING">Chapter 27</a>.</p></div></div>
<div class="sect1" title="IPv6 Datagram Main Header Format"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_datagram_main_header_format"/>IPv6 Datagram Main Header Format</h1></div></div></div><p>IPv6 datagrams use a structure that includes a regular header and, optionally, one or more extension headers. This regular header is like the header of IPv4 datagrams, though it has a different format, as you will see shortly. The standards don't give this header a name; it is just "<span class="emphasis"><em>the</em></span> IPv6 header." To differentiate it from IPv6 extension headers, I call it the <span class="emphasis"><em>main header</em></span>.</p><p><a class="indexterm" id="idx-CHP-26-0928"/>The IPv6 main header is required for every datagram. It contains addressing and control information that are used to manage the processing and routing of the datagram. The <a class="indexterm" id="idx-CHP-26-0929"/>main header format of IPv6 datagrams is described in <a class="xref" href="ch26s02.html#ipv_main_header_format" title="Table 26-2. IPv6 Main Header Format">Table 26-2</a> and illustrated in <a class="xref" href="ch26s02.html#ipv6_main_header_format" title="Figure 26-2. IPv6 main header format">Figure 26-2</a>.</p><div class="table"><a id="ipv_main_header_format"/><p class="title">Table 26-2. IPv6 Main Header Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Main Header Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2 (4 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>This identifies the version of IP that's used to generate the datagram. This field is used the same way as in IPv4, except that it carries the value 6 (0110 binary).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Traffic Class</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>This field replaces the Type of Service (TOS) field in the IPv4 header. It is used not in the original way that the TOS field was defined (with Precedence, D, T, and R bits), but rather, using the new Differentiated Services (DS) method defined in RFC 2474. That RFC actually specifies quality-of-service (QoS) techniques for both IPv4 and IPv6; see the IPv4 format description (<a class="xref" href="ch21.html" title="Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 21</a>) for a bit more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flow Label</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2 1/2 (20 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>This large field was created to provide additional support for real-time datagram delivery and QoS features. The concept of a flow is defined in RFC 2460 as a sequence of datagrams sent from a source device to one or more destination devices. A unique flow label is used to identify all the datagrams in a particular flow, so that routers between the source and destination all handle them the same way. This helps to ensure uniformity in how the datagrams in the flow are delivered. For example, if a video stream is being sent across an IP internetwork, the datagrams containing the stream could be identified with a flow label to ensure that they are delivered with minimal latency. Not all devices and routers may support flow label handling, and the use of the field by a source device is entirely optional. Also, the field is still somewhat experimental and may be refined over time.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Payload Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>This field replaces the Total Length field from the IPv4 header, but it is used differently. Rather than measuring the length of the whole datagram, it contains only the number of bytes of the payload. However, if extension headers are included, their length is counted here as well. In simpler terms, this field measures the length of the datagram less the 40 bytes of the main header itself.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next Header</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>This field replaces the Protocol field and has two uses. When a datagram has extension headers, this field specifies the identity of the first extension header, which is the next header in the datagram. When a datagram has just this "main" header and no extension headers, it serves the same purpose as the old IPv4 Protocol field and has the same values, though new numbers are used for the IPv6 versions of common protocols. In this case the "next header" is the header of the upper layer message the IPv6 datagram is carrying. I'll discuss this in more detail a bit later in this chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hop Limit</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>This replaces the Time to Live (TTL) field in the IPv4 header; its name better reflects the way that TTL is used in modern networks (because TTL is really used to count hops, not time).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Source Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 128-bit IP address of the originator of the datagram. As with IPv4, this is always the device that originally sent the datagram.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Destination Address</p></td><td style="border-right: 0.5pt solid ; "><p>16</p></td><td style=""><p>The 128-bit IP address of the intended recipient of the datagram: unicast, anycast, or multicast. Again, even though devices such as routers may be the intermediate targets of the datagram, this <a class="indexterm" id="idx-CHP-26-0930"/>field is always for the ultimate destination.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ipv6_main_header_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27051"/><img alt="IPv6 main header format" src="httpatomoreillycomsourcenostarchimages287891.png"/></div></div><p class="title">Figure 26-2. IPv6 main header format</p></div><div class="sect2" title="IPv6 Next Header Field"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_next_header_field"/>IPv6 Next Header Field</h2></div></div></div><p><a class="indexterm" id="idx-CHP-26-0931"/><a class="indexterm" id="idx-CHP-26-0932"/>The Next Header field is one of the most important additions to the IPv6 datagram format. When an IPv6 datagram uses extension headers, this field contains an identifier for the first extension header, which, in turn, uses its own Next Header field to point to the next header, and so on. The last extension header then references the encapsulated higher-layer protocol. Because the higher-layer protocol's header appears at the start of the IPv6 Data field, it is like the "next header" to the device receiving the datagram. For some folks, this is a bit tough to see conceptually; you can find more detail on how the field works (including a useful illustration, <a class="xref" href="ch26s03.html#ipv6_extension_header_linking_using_the_" title="Figure 26-3. IPv6 extension header linking using the Next Header field The Next Header field allows a device to more easily process the headers in a received IPv6 datagram. When a datagram has no extension headers, the &quot;next header&quot; is actually the header at the start of the IP Data field, which, in this case, is a TCP header with a value of 6. This is the same way the Protocol field is used in IPv4. When extension headers do appear, the Next Header value of each header contains a number indicating the type of the following header in the datagram, so they logically chain together the headers.">Figure 26-3</a>) in the "IPv6 Header Chaining Using the Next Header Field" section later in this chapter.</p><p>Some of the most common values for the Next Header field in IPv6 are shown in <a class="xref" href="ch26s02.html#common_ipv_next_header_values" title="Table 26-3. Common IPv6 Next Header Values">Table 26-3</a>.</p><div class="table"><a id="common_ipv_next_header_values"/><p class="title">Table 26-3. Common IPv6 Next Header Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common IPv6 Next Header Values"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value (Hexadecimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value (Decimal)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Protocol/Extension Header</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>00</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>Hop-By-Hop Options Extension Header
(Note that this value was "Reserved" in IPv4)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>01</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Internet Control Message Protocol version 4 (ICMPv4)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>02</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Internet Group Management Protocol version 4 (IGMPv4)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>04</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>IP-in-IP Encapsulation</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>06</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>Transmission Control Protocol (TCP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>08</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Exterior Gateway Protocol (EGP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-bottom: 0.5pt solid ; "><p>User Datagram Protocol (UDP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>29</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>41</p></td><td style="border-bottom: 0.5pt solid ; "><p>IPv6</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>43</p></td><td style="border-bottom: 0.5pt solid ; "><p>Routing Extension Header</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2C</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>44</p></td><td style="border-bottom: 0.5pt solid ; "><p>Fragmentation Extension Header</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2E</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>46</p></td><td style="border-bottom: 0.5pt solid ; "><p>Resource Reservation Protocol (RSVP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>50</p></td><td style="border-bottom: 0.5pt solid ; "><p>Encrypted Security Payload (ESP) Extension Header</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>33</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>51</p></td><td style="border-bottom: 0.5pt solid ; "><p>Authentication Header (AH) Extension Header</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3A</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>58</p></td><td style="border-bottom: 0.5pt solid ; "><p>ICMPv6</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>59</p></td><td style="border-bottom: 0.5pt solid ; "><p>No <a class="indexterm" id="idx-CHP-26-0933"/>Next Header</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>3C</p></td><td style="border-right: 0.5pt solid ; "><p>60</p></td><td style=""><p>Destination Options Extension Header</p></td></tr></tbody></table></div></div><p>The total length of the main IPv6 header format is 40 bytes. This is double the size of the IPv4 header without options, largely because of the extra 24 bytes needed for the monstrous IPv6 addresses. There are only 8 bytes of nonaddress header fields in the IPv6 main header, compared to 12 in the IPv4 header.</p></div><div class="sect2" title="Key Changes to the Main Header Between IPv4 and IPv6"><div class="titlepage"><div><div><h2 class="title"><a id="key_changes_to_the_main_header_between_i"/>Key Changes to the Main Header Between IPv4 and IPv6</h2></div></div></div><p>To summarize, the IPv6 main header compares to the IPv4 header as follows:</p><p><span class="strong"><strong>Unchanged Fields</strong></span> Three fields are used the same way, and they retain the same name (though they have different content and/or size): Version, Source Address, and Destination Address.</p><p><span class="strong"><strong>Renamed Fields</strong></span> Two fields are used the same way, but they are renamed: Traffic Class and Hop Limit.</p><p><span class="strong"><strong>Modified Fields</strong></span> Two fields are used in a way similar way to their IPv4 predecessors, but they are slightly different in meaning and also renamed: Payload Length and Next Header.</p><p><span class="strong"><strong>Added Field</strong></span> There is one new field: Flow Label.</p><p><span class="strong"><strong>Removed Fields</strong></span> To cut down on header length and unnecessary work, five IPv4 header fields are removed from the IPv6 header:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>Internet Header Length</em></span> field is no longer needed, because the main IPv6 header is fixed in length at 40 bytes.</p></li><li class="listitem"><p>The <span class="emphasis"><em>Identification, Flags</em></span>, and <span class="emphasis"><em>Fragment Offset</em></span> fields are used for fragmentation, which is done less in IPv6 than IPv4, so these fields are now found only when needed in the Fragmentation extension header.</p></li><li class="listitem"><p>The <span class="emphasis"><em>Header Checksum</em></span> field is no longer needed, because the decision was made to eliminate header checksum calculations in IPv6. It was viewed as redundant with higher-layer error-checking and data link layer CRC calculations. This saves processing time for routers and 2 bytes in the datagram header.</p></li></ul></div><p>In addition, while options were formerly considered part of the main header in IPv4, they are separate in IPv6.</p></div></div>
<div class="sect1" title="IPv6 Datagram Extension Headers"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_datagram_extension_headers"/>IPv6 Datagram Extension Headers</h1></div></div></div><p><a class="indexterm" id="idx-CHP-26-0934"/>After the mandatory main header in an IPv6 datagram, one or more <a class="indexterm" id="idx-CHP-26-0935"/>extension headers may appear before the encapsulated payload. These headers were created in an attempt to provide both flexibility and efficiency in the creation of IPv6 datagrams. All the fields that are needed for only special purposes are put into extension headers and placed in the datagram when needed. This allows the size of the main datagram header to be made small and streamlined, containing only those fields that really must be present all the time.</p><p>There is often confusion regarding the role of extension headers, especially when compared to datagram options. The IPv4 datagram had only one header, but it included a provision for options, and IPv6 also has options, so why bother with extension headers?</p><p>It would have been possible to do everything using options. However, it was deemed a better design to employ extension headers for certain sets of information that are needed for common functions such as fragmenting. Options are indeed still supported in IPv6; they are used to supply even more flexibility by providing variable-length fields that can be used for any purpose. They are themselves defined using extension headers, as you will see shortly.</p><p>When extension headers are included in an IPv6 datagram, they appear one after the other following the main header. Each extension header type has its own internal structure of fields.</p><div class="sect2" title="IPv6 Header Chaining Using the Next Header Field"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_header_chaining_using_the_next_head"/>IPv6 Header Chaining Using the Next Header Field</h2></div></div></div><p><a class="indexterm" id="idx-CHP-26-0936"/>The only field common to all extension header types is the Next Header field, which actually appears at the end of one header type, the ESP header. The 8-bit Next Header field is used to logically link all the headers in an IPv6 datagram, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The Next Header field in the main header contains a reference number for the first extension header type.</p></li><li class="listitem"><p>The Next Header field in the first extension header contains the number of the second extension header type, if there is a second one. If there's a third, the second header's Next Header points to it, and so on.</p></li><li class="listitem"><p>The Next Header field of the last extension header contains the protocol number of the encapsulated higher-layer protocol. In essence, this field points to the "next header" within the payload itself.</p></li></ul></div><p>For example, suppose a datagram that encapsulates TCP has a Hop-By-Hop Options extension header and a Fragment extension header. Then, the Next Header fields of these headers would contain the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The main header would have a Next Header value of 0, indicating the Hop-By-Hop Options header.</p></li><li class="listitem"><p>The Hop-By-Hop Options header would have a Next Header value of 44 (decimal), which is the value for the Fragment extension header.</p></li><li class="listitem"><p>The Fragment header would have a Next Header value of 6.</p></li></ul></div><p>This is illustrated in <a class="xref" href="ch26s03.html#ipv6_extension_header_linking_using_the_" title="Figure 26-3. IPv6 extension header linking using the Next Header field The Next Header field allows a device to more easily process the headers in a received IPv6 datagram. When a datagram has no extension headers, the &quot;next header&quot; is actually the header at the start of the IP Data field, which, in this case, is a TCP header with a value of 6. This is the same way the Protocol field is used in IPv4. When extension headers do appear, the Next Header value of each header contains a number indicating the type of the following header in the datagram, so they logically chain together the headers.">Figure 26-3</a>.</p><div class="figure"><a id="ipv6_extension_header_linking_using_the_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27375"/><img alt="IPv6 extension header linking using the Next Header field The Next Header field allows a device to more easily process the headers in a received IPv6 datagram. When a datagram has no extension headers, the &quot;next header&quot; is actually the header at the start of the IP Data field, which, in this case, is a TCP header with a value of 6. This is the same way the Protocol field is used in IPv4. When extension headers do appear, the Next Header value of each header contains a number indicating the type of the following header in the datagram, so they logically chain together the headers." src="httpatomoreillycomsourcenostarchimages287893.png.jpg"/></div></div><p class="title">Figure 26-3. IPv6 extension header linking using the Next Header field The Next Header field allows a device to more easily process the headers in a received IPv6 datagram. When a datagram has no extension headers, the "next header" is actually the header at the start of the IP Data field, which, in this case, is a TCP header with a value of 6. This is the same way the Protocol field is used in IPv4. When extension headers do appear, the Next Header value of each header contains a number indicating the type of the following header in the datagram, so they logically chain together the headers.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-143"/>Tip</h3><p><a class="indexterm" id="idx-CHP-26-0937"/><span class="strong"><strong>KEY CONCEPT</strong></span> The IPv6 Next Header field is used to chain together the headers in an IPv6 datagram. The Next Header field in the main header contains the number of the first extension header; its Next Header contains the number of the second, and so forth. The last header in the datagram contains the number of the encapsulated protocol that begins the Data field.</p></div></div><div class="sect2" title="Summary of IPv6 Extension Headers"><div class="titlepage"><div><div><h2 class="title"><a id="summary_of_ipv6_extension_headers"/>Summary of IPv6 Extension Headers</h2></div></div></div><p><a class="xref" href="ch26s03.html#ipv_extension_headers" title="Table 26-4. IPv6 Extension Headers">Table 26-4</a> lists the different extension headers, showing each one's Next Header value, length, defining RFC, and a brief description of how it is used.</p><div class="table"><a id="ipv_extension_headers"/><p class="title">Table 26-4. IPv6 Extension Headers</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Extension Headers"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next Header Value (Decimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extension Header Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length (Bytes)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining RFC</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hop-By-Hop Options</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Defines an arbitrary set of options that are intended to be examined by all devices on the path from the source to destination device(s). This is one of two extension headers used to define variable-format options.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2460</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>43</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Routing</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Defines a method for allowing a source device to specify the route for a datagram. This header type actually allows the definition of multiple routing types. The IPv6 standard defines the Type 0 Routing extension header, which is equivalent to the "loose" source routing option in IPv4. It's used in a similar way. See the "IPv6 Routing Extension Header" section in this chapter for the format of this extension header.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2460</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>44</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Fragment</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>When a datagram contains only a fragment of the original message, contains the Fragment Offset, Identification, and More Fragment fields that were removed from the main header. See the "IPv6 Fragment Extension Header" section in this chapter for the format of this extension header, and the topic on fragmentation and reassembly (<a class="xref" href="ch27.html" title="Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING">Chapter 27</a>) for details on how the fields are used.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2460</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>50</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Encapsulating Security Payload (ESP)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Carries encrypted data for secure communications. This header is described in detail in <a class="xref" href="ch29.html" title="Chapter 29. IP SECURITY (IPSEC) PROTOCOLS">Chapter 29</a>, which covers IPsec.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2406</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>51</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Authentication Header (AH)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Contains information used to verify the authenticity of encrypted data. This header is described in detail in <a class="xref" href="ch29.html" title="Chapter 29. IP SECURITY (IPSEC) PROTOCOLS">Chapter 29</a>.</p></td><td style="border-bottom: 0.5pt solid ; "><p>2402</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>60</p></td><td style="border-right: 0.5pt solid ; "><p>Destination Options</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; "><p>Defines an arbitrary set of options that are intended to be examined only by the destination(s) of the datagram. This is one of two extension headers used to define variable-format options.</p></td><td style=""><p>2460</p></td></tr></tbody></table></div></div><p>Note that the Next Header value of the IPv6 main header is 41; that of an IPv4 header is 4 (its protocol number). There is also a "dummy" extension header called <a class="indexterm" id="idx-CHP-26-0938"/>No Next Header that has a value of 59. This is a placeholder that, when found in the Next Header field, indicates that there is nothing after that extension header.</p><p>As mentioned in <a class="xref" href="ch26s03.html#ipv_extension_headers" title="Table 26-4. IPv6 Extension Headers">Table 26-4</a>, the formats for several of the headers are provided in other areas of this book. I will describe two of them here, however: the Routing extension header and the Fragment extension header.</p></div><div class="sect2" title="IPv6 Routing Extension Header"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_routing_extension_header"/>IPv6 Routing Extension Header</h2></div></div></div><p>The <a class="indexterm" id="idx-CHP-26-0939"/>Routing extension header is used to perform source <a class="indexterm" id="idx-CHP-26-0940"/>routing in IPv6. It is described in <a class="xref" href="ch26s03.html#ipv_routing_extension_header_format" title="Table 26-5. IPv6 Routing Extension Header Format">Table 26-5</a> and illustrated in <a class="xref" href="ch26s03.html#ipv6_routing_extension_header_format" title="Figure 26-4. IPv6 Routing extension header format">Figure 26-4</a>.</p><div class="table"><a id="ipv_routing_extension_header_format"/><p class="title">Table 26-5. IPv6 Routing Extension Header Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Routing Extension Header Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next Header</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains the protocol number of the next header after the <a class="indexterm" id="idx-CHP-26-0941"/>Routing header. Used to link headers together, as described earlier in this chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hdr Ext Len</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>For Header Extension Length, specifies the length of the Routing header in 8-byte units, not including the first 8 bytes of the header. For a Routing Type field of 0, this value is thus two times the number addresses embedded in the header.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Routing Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows multiple routing types to be defined; at present, the only value used is 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Segments Left</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the number of explicitly named nodes remaining in the route until the destination.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Address1…AddressN</p></td><td style="border-right: 0.5pt solid ; "><p>Variable (Multiple of 16)</p></td><td style=""><p>A set of IPv6 addresses that specify the route to be used.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ipv6_routing_extension_header_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27644"/><img alt="IPv6 Routing extension header format" src="httpatomoreillycomsourcenostarchimages287895.png"/></div></div><p class="title">Figure 26-4. IPv6 Routing extension header format</p></div></div><div class="sect2" title="IPv6 Fragment Extension Header"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_fragment_extension_header"/>IPv6 Fragment Extension Header</h2></div></div></div><p><a class="indexterm" id="idx-CHP-26-0942"/>The <a class="indexterm" id="idx-CHP-26-0943"/>Fragment extension header is included in <a class="indexterm" id="idx-CHP-26-0944"/>fragmented datagrams to provide the information that's necessary to allow the <a class="indexterm" id="idx-CHP-26-0945"/>fragments to be reassembled. It is described in <a class="xref" href="ch26s03.html#ipv_fragment_extension_header_format" title="Table 26-6. IPv6 Fragment Extension Header Format">Table 26-6</a> and illustrated in <a class="xref" href="ch26s03.html#ipv6_fragment_extension_header_format" title="Figure 26-5. IPv6 Fragment extension header format">Figure 26-5</a>.</p><div class="table"><a id="ipv_fragment_extension_header_format"/><p class="title">Table 26-6. IPv6 Fragment Extension Header Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Fragment Extension Header Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next Header</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains the protocol number of the next header after the Fragment header. Used to link headers together, as described earlier in this chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Fragment Offset</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13/8 (13 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the offset, or position, in the overall message where the data in this fragment goes. It is specified in units of 8 bytes (64 bits) and used in a manner very similar to the field of the same name in the IPv4 header.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Res</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/4 (2 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used; set to zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M Flag</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>For More Fragments Flag, same as the flag of the same name in the IPv4 header. When set to 0, indicates the last fragment in a message; when set to 1, indicates that more fragments are yet to come in the fragmented message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Identification</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>Same as the field of the same name in the IPv4 header, but expanded to 32 bits. It contains a specific value that is common to each of the fragments belonging to a particular message. This ensures that pieces from different fragmented messages are not mixed together.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ipv6_fragment_extension_header_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27765"/><img alt="IPv6 Fragment extension header format" src="httpatomoreillycomsourcenostarchimages287897.png.jpg"/></div></div><p class="title">Figure 26-5. IPv6 Fragment extension header format</p></div></div><div class="sect2" title="IPv6 Extension Header Order"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_extension_header_order"/>IPv6 Extension Header Order</h2></div></div></div><p><a class="indexterm" id="idx-CHP-26-0946"/>Each extension header appears only once in any datagram (with one exception, as you'll see shortly). Also, only the final recipients of the datagram examine extension headers, not intermediate devices (again with one exception, which you will see momentarily).</p><p>RFC 2460 specifies that when multiple headers appear, they should be in the following order, after the main header and before the higher-layer encapsulated header in the IPv6 datagram payload:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Hop-By-Hop <a class="indexterm" id="idx-CHP-26-0947"/>Options</p></li><li class="listitem"><p>Destination Options (for options to be processed by the destination as well as devices specified in a Routing header)</p></li><li class="listitem"><p>Routing</p></li><li class="listitem"><p>Fragmentation</p></li><li class="listitem"><p>Authentication Header</p></li><li class="listitem"><p>Encapsulating Security Payload</p></li><li class="listitem"><p>Destination Options (for options processed only by the final destination)</p></li></ol></div><p>Now let's look at those exceptions. The only header that can appear twice is Destination Options. Normally, it appears as the last header. However, the datagram may also have a Destination Options header that contains options that must be examined by a list of devices specified in a source route, in addition to the destination. In this case, the Destination Options header for these options is placed before the Routing header. A second such header containing options for only the final destination may also appear.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-144"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each extension header may appear only once in an IPv6 datagram, and each one must appear in a fixed order. The exception is the Destination Options header, which may appear twice: near the start of the datagram for options to be processed by devices en route to the destination and at the end of the extension headers for options intended for only the final destination.</p></div><p>The only header normally examined by all intermediate devices is the Hop-By-Hop Options extension header. It is used specifically to convey management information to all routers in a route. The Hop-By-Hop Options extension header must appear as the first extension header if present. Since it is the only one that every router must read (and this represents a performance drain on routers), it is given top billing to make it easier and faster to find and process.</p><p>Finally, note that all extension headers must be a multiple of eight bytes in length for alignment purposes. Also, remember that the Next Header value for a particular extension header appears in the Next Header field of the preceding header, not the header itself.</p></div></div>
<div class="sect1" title="IPv6 Datagram Options"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_datagram_options"/>IPv6 Datagram Options</h1></div></div></div><p>In IPv4, all extra information required for various purposes is placed into the datagram in the form of options that appear in the IPv4 header. In IPv6, the new concept of extension headers is introduced, as you just saw. These headers take the place of many of the predefined IPv4 options. However, the concept of options is still maintained in IPv6 for a slightly different purpose.</p><p><a class="indexterm" id="idx-CHP-26-0948"/>Options allow the IPv6 datagram to be supplemented with arbitrary sets of information that aren't defined in the regular extension headers. They provide maximum flexibility, thereby allowing the basic IPv6 protocol to be extended in ways the designers never anticipated, with the goal of reducing the chance of the protocol becoming obsolete in the future.</p><p>I said that IPv6 <a class="indexterm" id="idx-CHP-26-0949"/>options supplement extension headers; in fact, they are actually implemented as extension headers. There are two different ones used to encode options. These two headers differ only in terms of how devices will process the options they contain; otherwise, they are formatted the same and used in the same way.</p><p>The two extension header types are as follows:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-26-0950"/>Destination Options</strong></span> Contains options that are intended only for the ultimate destination of the datagram (and perhaps a set of routers in a Routing header, if present).</p><p><span class="strong"><strong>Hop-By-Hop Options</strong></span> Contains options that carry information for every device (router) between the source and destination.</p><p>Each of these header types has a one-byte Next Header field, and a one-byte Header Extension Length field that indicates the header's overall length. The rest of the header has one or more option fields.</p><p><a class="xref" href="ch26s04.html#ipv6_hop-by-hop_options_and_destination_" title="Figure 26-6. IPv6 Hop-By-Hop Options and Destination Options header formats Each of these extension headers begins with two fixed fields, Next Header and Header Extension Length. The rest of the header consists of a sequence of variable-length options. Each option has a structure that consists of a type/length/value triplet, shown in Table 26-7.">Figure 26-6</a> illustrates the overall format of these two headers. The format of each option is similar to that of IPv4 options, as shown in Tables <a class="xref" href="ch26s04.html#ipv_option_format-id001" title="Table 26-7. IPv6 Option Format">Table 26-7</a> and <a class="xref" href="ch26s04.html#ipv_option_type_subfields" title="Table 26-8. IPv6 Option Type Subfields">Table 26-8</a>.</p><div class="figure"><a id="ipv6_hop-by-hop_options_and_destination_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27870"/><img alt="IPv6 Hop-By-Hop Options and Destination Options header formats Each of these extension headers begins with two fixed fields, Next Header and Header Extension Length. The rest of the header consists of a sequence of variable-length options. Each option has a structure that consists of a type/length/value triplet, shown in ." src="httpatomoreillycomsourcenostarchimages287899.png.jpg"/></div></div><p class="title">Figure 26-6. IPv6 Hop-By-Hop Options and Destination Options header formats Each of these extension headers begins with two fixed fields, Next Header and Header Extension Length. The rest of the header consists of a sequence of variable-length options. Each option has a structure that consists of a type/length/value triplet, shown in <a class="xref" href="ch26s04.html#ipv_option_format-id001" title="Table 26-7. IPv6 Option Format">Table 26-7</a>.</p></div><div class="table"><a id="ipv_option_format-id001"/><p class="title">Table 26-7. IPv6 Option Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Option Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>This field indicates the type of option. The bits are interpreted according to the sub-subfield" structure, described in <a class="xref" href="ch26s04.html#ipv_option_type_subfields" title="Table 26-8. IPv6 Option Type Subfields">Table 26-8</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opt Data Len</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the length of the Option Data subfield. Note that this is a change in semantics from IPv4, where the Length field indicated the size of the entire option; in IPv6 the length of the Option Type and Option Data Length fields are not included.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Option Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The data to be sent as part of the option, which is specific to the option type. Also sometimes referred to as the Option Value.</p></td></tr></tbody></table></div></div><div class="table"><a id="ipv_option_type_subfields"/><p class="title">Table 26-8. IPv6 Option Type Subfields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv6 Option Type Subfields"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sub-Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unrecognized Option Action</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2/8 (2 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>The first two bits specify what action should be taken if the device processing the option doesn't recognize the Option Type. The four values are as follows:</p>
<p>00: Skip option; process rest of header.</p>
<p>0: Discard datagram; do nothing else.</p>
<p>10: Discard datagram and send an ICMP Parameter Problem message with code 2 back to the datagram source.</p>
<p>11: Discard datagram and send the ICMP message as for value 10, only if destination was not a multicast address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Change Allowed Flag</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 1 if the Option Data can change while the datagram is en route, or left at 0 if it cannot.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Remainder of Option Type</p></td><td style="border-right: 0.5pt solid ; "><p>5/8 (5 bits)</p></td><td style=""><p>Five remaining bits that allow the specification of 32 different combinations for each combination of the three preceding bits.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-89"/>Note</h3><p><span class="emphasis"><em>The Option Type subfield is a bit strange in terms of how it is interpreted. Even though it has a substructure with three sub-subfields (as shown in <a class="xref" href="ch26s04.html#ipv_option_type_subfields" title="Table 26-8. IPv6 Option Type Subfields">Table 26-8</a>, that structure is informal—the eight bits of this field are taken as a single entity. Despite the special meaning of the three highest-order bits, the entire field is called the Option Type, not just the last five bits, and the whole is used as a single value from 0 to 255. In fact, the sub-subfield names aren't even specified in the standard; I made them up</em></span>.</p></div><p>Since each option has a subfield for type, length, and value (data), the options are sometimes said to be TLV-encoded. If there are multiple options, they are placed one after each other in the header. At the end of all the options, in a Hop-By-Hop Options or Destination Options extension header, a device may place padding to ensure that the header is a multiple of eight bytes in length.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-145"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Two IPv6 extension header types, Hop-By-Hop Options and Destination Options, are used to carry arbitrary optional information in IPv6 datagrams. Each consists of a set of variable-length options that are defined using three subfields that indicate the option's type, length, and value.</p></div></div>
<div class="chapter" title="Chapter&#xA0;27.&#xA0;IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_datagram_size_fragmentation_reassem"/>Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e28007"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Internet Protocol version 6 (IPv6) changes many of the operating details of IP, but most of the basics are the same. In particular, devices still need to deliver datagrams over an internetwork that may use different underlying network technologies. This means that we must be concerned here, as we were in IPv4, with the mechanics of datagram sizing, handling fragmentation and reassembly, and dealing with issues related to routing.</p><p>In this chapter, I complete the discussion of IPv6 by examining these matters, with an eye toward contrasting how they work in IPv6. This includes a look at IPv6 datagram sizing, changes to the maximum transmission unit (MTU), and fragmentation and reassembly. I also briefly discuss areas where IPv6 routing is performed in the same way as in IPv4, as well as where routing has changed.</p><div class="sect1" title="Overview of IPv6 Datagram Sizing and Fragmentation"><div class="titlepage"><div><div><h1 class="title"><a id="overview_of_ipv6_datagram_sizing_and_fra"/>Overview of IPv6 Datagram Sizing and Fragmentation</h1></div></div></div><p>The job of IP is to convey messages across an internetwork of connected networks. When datagrams are sent between hosts on distant networks, they are carried along their journey by routers, one hop at a time, over many physical network links. On each step of this journey, the datagram is encoded in a data link layer frame for transmission.</p><p>In order for a datagram to be successfully carried along a route, its size must be small enough to fit within the lower-layer frame at each step of the way. The term <a class="indexterm" id="idx-CHP-27-0951"/><span class="emphasis"><em>maximum transmission unit (MTU)</em></span> describes the size limit for any given physical network. If a datagram is too large for the <a class="indexterm" id="idx-CHP-27-0952"/>MTU of a network, it must be broken into pieces—a process called <span class="emphasis"><em>fragmentation</em></span>—and then the pieces are <span class="emphasis"><em>reassembled</em></span> at the destination device. This has been a requirement since IPv4, and I explain the concepts and issues related to datagram size, MTUs, fragmentation, and reassembly in detail in the associated IPv4 discussion, in <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a>.</p><p>All of these issues apply to sending datagrams in <a class="indexterm" id="idx-CHP-27-0953"/>IPv6 as much as they did in IPv4. However, as in other areas of the protocol, some important details of how fragmentation and reassembly are done have changed. These changes were made to improve the efficiency of the routing process and to reflect the realities of current networking technologies: Most can handle average IP datagrams without needing fragmentation.</p><p>The most important differences between IPv4 and IPv6 with respect to datagram size, MTU, and fragmentation and reassembly are as follows:</p><p><span class="strong"><strong>Increased Default MTU</strong></span> In IPv4, the minimum MTU that routers and physical links were required to handle was 576 bytes. In IPv6, all links must handle a datagram size of at least 1280 bytes. This more than doubling in size improves efficiency by increasing the ratio of maximum payload to header length and reduces the frequency with which fragmentation is required.</p><p><span class="strong"><strong>Elimination of en Route Fragmentation</strong></span> In IPv4, datagrams may be fragmented by either the source device or by routers during delivery. In IPv6, only the source node can fragment; routers do not. The source must fragment to the size of the smallest MTU on the route before transmission. This has both advantages and disadvantages, as you will see. Reassembly is still done only by the destination, as in IPv4.</p><p><span class="strong"><strong>MTU Size Error Feedback</strong></span> Since routers cannot fragment datagrams, they must drop them if they are forced to try to send a too-large datagram over a physical link. Using the Internet Control Message Protocol version 6 (ICMPv6; see <a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>), a feedback process has been defined that allows routers to tell source devices that they are using datagrams that are too large for the route.</p><p><span class="strong"><strong>Path MTU Discovery</strong></span> Since source devices must decide on the correct size of fragments, it is helpful if they have a mechanism for determining what this should be. This capability is provided through a special technique called <span class="emphasis"><em>Path MTU Discovery</em></span>, which was originally defined for IPv4 but has been refined for IPv6.</p><p><span class="strong"><strong>Movement of Fragmentation Header Fields</strong></span> To reflect the decreased importance of fragmentation in IPv4, the permanent fields related to the process that were in the IPv4 header have been farmed out to a Fragment extension header and are included only when needed.</p></div></div>
<div class="sect1" title="Implications of IPv6's Source-Only Fragmentation Rule"><div class="titlepage"><div><div><h1 class="title"><a id="implications_of_ipv6s_source-only_fragme"/>Implications of IPv6's Source-Only Fragmentation Rule</h1></div></div></div><p>I find the changes in the fragmentation and reassembly process interesting. While many other changes in IPv6 represent a shift in responsibility for functions from host devices to routers, this one is the opposite. In IPv4, a source node can send a datagram of any size that its local link can handle, and let the routers take care of fragmenting it as needed. This seems like a sensible model; nodes communicate on a large, virtual network, and the details of splitting messages as needed for physical links are handled invisibly.</p><p>The problem with this is that it represents a performance drag on routing. It is much faster for a router to forward a datagram intact than to spend time fragmenting it. In some cases, fragmentation would need to occur multiple times during the transmission of a datagram, and remember that this must happen for every datagram on a route. It is a lot more efficient for the source to just send datagrams that are the right size in the first place.</p><p>Of course, there's a problem here: How does the source know what size to use? The source has no understanding of the physical networks used by the route datagrams will take to a destination; in fact, it doesn't even know what the routes are! Thus, it has no idea of what MTU would be best. It has two choices:</p><p><span class="strong"><strong>Use the Default MTU</strong></span> The first option is simply to use the default MTU of 1280 bytes, which all physical networks must be able to handle. This is a good choice, especially for short communications or for sending small amounts of data.</p><p><span class="strong"><strong>Use Path MTU Discovery</strong></span> The alternative is to make use of the Path MTU Discovery feature, as described later in the chapter. This feature, defined in RFC 1981, defines a method whereby a node sends messages over a route to determine what the overall minimum MTU for the path is. It's a technique that's very similar to the way it is done in IPv4, as discussed in <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a>.</p><p>Since routers can't fragment in IPv6, if a datagram is sent by a source that is too large for a router, it must drop the datagram. It will then send back to the source feedback about this occurrence, in the form of an <a class="indexterm" id="idx-CHP-27-0954"/>ICMPv6 Packet Too Big message. This tells the source that its datagram was dropped and that it must fragment (or reduce the size of its fragments).</p><p>This feedback mechanism is also used in discovering path MTUs. The source node sends a datagram that has the MTU of its local physical link, since that represents an upper bound on the MTU of the path. If this goes through without any errors, it knows it can use that value for future datagrams to that destination. If it gets back any Packet Too Big messages, it tries again using a smaller datagram size. The advantage of this over the 1280 default is that it may allow a large communication to proceed with a higher MTU, which improves performance.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-146"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In IPv6, fragmentation is performed only by the device that's sending a datagram, not by routers. If a router encounters a datagram too large to send over a physical network with a small MTU, the router sends an ICMPv6 <span class="emphasis"><em>Packet Too Big</em></span> message back to the source of the datagram. This can be used as part of a process called <span class="emphasis"><em>Path MTU Discovery</em></span> to determine the minimum MTU of an entire route.</p></div><p>One drawback of the decision to only fragment at the source is that it introduces the potential for problems if there is more than one route between devices or if routes change. In IPv4, <a class="indexterm" id="idx-CHP-27-0955"/>fragmentation is dynamic and automatic; it happens on its own and adjusts as routes change. Path MTU Discovery is a good feature, but it is static. It requires that hosts keep track of MTUs for different routes and update them regularly. <a class="indexterm" id="idx-CHP-27-0956"/>IPv6 does this by redoing Path MTU Discovery if a node receives a Packet Too Big message on a route for which it has previously performed Path MTU Discovery. However, this takes time.</p></div>
<div class="sect1" title="The IPv6 Fragmentation Process"><div class="titlepage"><div><div><h1 class="title"><a id="the_ipv6_fragmentation_process"/>The IPv6 Fragmentation Process</h1></div></div></div><p>The actual mechanics of fragmentation in IPv6 are similar to those in IPv4, with the added complication that extension headers must be handled carefully. For purposes of fragmentation, IPv6 datagrams are broken into the following two pieces:</p><p><span class="strong"><strong>Unfragmentable Part</strong></span> This includes the main header of the original datagram, as well as any extension headers that need to be present in each fragment. This means the main header, and any of the following headers, if present: Hop-By-Hop Options, Destination Options (for those options to be processed by devices along a route), and Routing.</p><p><span class="strong"><strong>Fragmentable Part</strong></span> This includes the data portion of the datagram, along with the other extension headers, if present—Authentication Header, Encapsulating Security Payload, and/or Destination Options (for options to be processed only by the final destination).</p><p>The Unfragmentable Part must be present in each fragment, while the Fragmentable Part is split up among the fragments. So to fragment a datagram, a device creates a set of fragment datagrams, each of which contains the following, in order:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Unfragmentable Part</strong></span> The full Unfragmentable Part of the original datagram, with its Payload Length changed to the length of the fragment datagram.</p></li><li class="listitem"><p><span class="strong"><strong>Fragment Header</strong></span> A Fragment header with the Fragment Offset, Identification, and M flags set in the same way they are used in IPv4.</p></li><li class="listitem"><p><span class="strong"><strong>Fragment</strong></span> A fragment of the Fragmentable Part of the original datagram. Note that each fragment must have a length that is a multiple of 8 bytes, because the value in the Fragment Offset field is specified in multiples of 8 bytes.</p></li></ol></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-147"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Fragmentation is done in IPv6 in a manner similar to that of IPv4, except that extension headers must be handled specially. Certain extension headers are considered <span class="emphasis"><em>unfragmentable</em></span> and appear in each fragment; others are fragmented along with the data.</p></div><p>Let's use an example to illustrate how IPv6 fragmentation works. Suppose you have an IPv6 datagram exactly 320 bytes wide, consisting of a 40-byte IP header, four 30-byte extension headers, and 160 bytes of data. Two of the extension headers are unfragmentable, while two are fragmentable. (In practice you would never need to fragment such a small datagram, but I am trying to keep the numbers simple.) Suppose you need to send this over a link with an MTU of only 230 bytes. You would actually require three fragments, not the two you might expect, because of the need to put the two 30-byte unfragmentable extension headers in each fragment, and the requirement that each fragment be a length that is a multiple of 8. Here is how the fragments would be structured (see <a class="xref" href="ch27s03.html#ipv6_datagram_fragmentation_in_this_illu" title="Figure 27-1. IPv6 datagram fragmentation In this illustration, a 320-byte IPv6 datagram, containing four 30-byte extension headers, is broken into three fragments. The sizes of the fields are shown to scale. The Unfragmentable Part, shown in lighter shading on the left, begins each fragment, followed by the Fragment header. Then, portions of the Fragmentable Part are placed into each fragment in sequence. The Authentication and Destination Options extension headers are part of the Fragmentable Part, so that they appear as part of the first fragment.">Figure 27-1</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>First Fragment</strong></span> The first fragment would consist of the 100-byte Unfragmentable Part, followed by a 30-byte Fragment header and the first 96 bytes of the Fragmentable Part of the original datagram. This would contain the two fragmentable extension headers and the first 36 bytes of data. This leaves 124 bytes of data to send.</p></li><li class="listitem"><p><span class="strong"><strong>Second Fragment</strong></span> This would also contain the 100-byte Unfragmentable Part, followed by a Fragment header, and 96 bytes of data (bytes 36 to 131). This would leave 28 bytes of data remaining.</p></li><li class="listitem"><p><span class="strong"><strong>Third Fragment</strong></span> The last fragment would contain the 100-byte Unfragmentable Part, a Fragment header, and the final 28 bytes of data.</p></li></ol></div><div class="figure"><a id="ipv6_datagram_fragmentation_in_this_illu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e28191"/><img alt="IPv6 datagram fragmentation In this illustration, a 320-byte IPv6 datagram, containing four 30-byte extension headers, is broken into three fragments. The sizes of the fields are shown to scale. The Unfragmentable Part, shown in lighter shading on the left, begins each fragment, followed by the Fragment header. Then, portions of the Fragmentable Part are placed into each fragment in sequence. The Authentication and Destination Options extension headers are part of the Fragmentable Part, so that they appear as part of the first fragment." src="httpatomoreillycomsourcenostarchimages287901.png.jpg"/></div></div><p class="title">Figure 27-1. IPv6 datagram fragmentation In this illustration, a 320-byte IPv6 datagram, containing four 30-byte extension headers, is broken into three fragments. The sizes of the fields are shown to scale. The Unfragmentable Part, shown in lighter shading on the left, begins each fragment, followed by the Fragment header. Then, portions of the Fragmentable Part are placed into each fragment in sequence. The Authentication and Destination Options extension headers are part of the Fragmentable Part, so that they appear as part of the first fragment.</p></div><p><a class="indexterm" id="idx-CHP-27-0957"/><a class="indexterm" id="idx-CHP-27-0958"/>The M (More Fragments) flag would be set to 1 in the first two fragments and 0 in the third, and the Fragment Offset values would be set appropriately. See <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a>, which covers IPv4 fragmentation, for more on how these fields are used.</p><p>The receiving device reassembles by taking the Unfragmentable Part from the first fragment and then assembling the Fragment data from each fragment in sequence.</p></div>
<div class="sect1" title="IPv6 Datagram Delivery and Routing"><div class="titlepage"><div><div><h1 class="title"><a id="ipv6_datagram_delivery_and_routing"/>IPv6 Datagram Delivery and Routing</h1></div></div></div><p><a class="indexterm" id="idx-CHP-27-0959"/><a class="indexterm" id="idx-CHP-27-0960"/><a class="indexterm" id="idx-CHP-27-0961"/> IP functions such as addressing, datagram encapsulation, and, if necessary, fragmentation and reassembly, all lead up to the ultimate objective of the protocol: the actual delivery of datagrams from a source device to one or more destination devices. Most of the concepts related to how datagram delivery is accomplished in <a class="indexterm" id="idx-CHP-27-0962"/>IPv6 are the same as in IPv4:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Datagrams are delivered directly when the source and destination nodes are on the same network. When they are on different networks, delivery is indirect, using routing to the destination's network, and then direct to the destination.</p></li><li class="listitem"><p>Routers look at IP addresses and determine which portion is the network identifier (network ID) and which is the host identifier (host ID). <a class="indexterm" id="idx-CHP-27-0963"/>IPv6 does this in the same basic way as in classless IPv4, despite the fact that IPv6 unicast addresses are assigned using a special hierarchical format.</p></li><li class="listitem"><p>Routing is still done on a next-hop basis, with sources generally not knowing how datagrams get from point A to point B.</p></li><li class="listitem"><p>Routing is performed by devices called <span class="emphasis"><em>routers</em></span>, which maintain tables of routes that tell them where to forward datagrams to reach different destination networks.</p></li><li class="listitem"><p>Routing protocols are used to allow routers to exchange information about routes and networks.</p></li></ul></div><p>Most of the changes in routing in IPv6 are directly related to changes in other areas of the protocol, as discussed in the previous chapters. Some of the main issues of note related to routing and routers in IPv6 include the following:</p><p><span class="strong"><strong>Hierarchical Routing and Aggregation</strong></span> One of the goals of the structure used for organizing unicast addresses was to improve routing. The unicast addressing format is designed to provide a better match between addresses and Internet topology and to facilitate route aggregation. Classless addressing using CIDR in IPv4 was an improvement but lacked any formal mechanism for creating a scalable hierarchy.</p><p><span class="strong"><strong>Scoped Local Addresses</strong></span> Local-use addresses, including site-local and link-local addresses, are defined in IPv6, and routers must be able to recognize them. They must route them or <span class="emphasis"><em>not</em></span> route them when appropriate. Multicast addresses also have various levels of scope.</p><p><span class="strong"><strong>Multicast and Anycast Routing</strong></span> Multicast is standard in IPv6, not optional as in IPv4, so routers must support it. Anycast addressing is a new type of addressing in IPv6.</p><p><span class="strong"><strong>More Support Functions</strong></span> Capabilities must be added to routers to support new features in IPv6. For example, routers play a key role in implementing autoconfiguration without the help of a server and Path MTU Discovery in the new IPv6 fragmentation scheme.</p><p><span class="strong"><strong>New Routing Protocols</strong></span> Routing protocols such as RIP must be updated to support IPv6.</p><p><span class="strong"><strong>Transition Issues</strong></span> Last, but certainly not least, routers play a major role in supporting the transition from IPv4 to IPv6. They will be responsible for connecting together IPv6 "islands" and performing translation to allow IPv4 and IPv6 devices to communicate with each other during the multiyear migration to the new protocol.</p></div></body></html>