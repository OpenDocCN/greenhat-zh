<html><head></head><body><div class="part" title="Part&#xA0;II-3.&#xA0;INTERNET PROTOCOL VERSION 4 (IP/IPV4)"><div class="titlepage"><div><div><h1 class="title"><a id="internet_protocol_version_4_ipipv4"/>Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)</h1></div></div></div><div class="partintro" id="id3208803" title="INTERNET PROTOCOL VERSION 4 (IP/IPV4)"><div/><p><a class="xref" href="ch15.html" title="Chapter 15. INTERNET PROTOCOL VERSIONS, CONCEPTS, AND OVERVIEW">Chapter 15</a></p><p><a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a></p><p><a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a></p><p><a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a></p><p><a class="xref" href="ch19.html" title="Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE">Chapter 19</a></p><p><a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a></p><p><a class="xref" href="ch21.html" title="Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 21</a></p><p><a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a></p><p><a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a></p><p>The idea of singling out any one protocol as being more important than the others in a network is kind of pointless, if you think about it. The protocols and technologies work as a team to accomplish the goal of communication across the network. As with any team, no single member can get the job done alone, no matter how good it is. Still, if we were to try to pick a "most valuable player" in the world of networking, a good case could be made that we have it in the TCP/IP <span class="emphasis"><em>Internet Protocol (IP)</em></span>.</p><p>Even though it gets second billing in the name of the TCP/IP protocol suite, IP is the workhorse of TCP/IP. It implements key network layer functions including addressing, datagram handling, and routing, and it is the foundation on which other TCP/IP protocols are built. Even the ones lower in the TCP/IP architecture, such as the Address Resolution Protocol (ARP) and the Point-to-Point Protocol (PPP), are easier to understand when you know how IP works.</p><p>This part includes nine chapters that provide considerable coverage of IP. The first chapter gives an overview of IP as a whole, including a discussion of its versions, while the rest of the chapters focus on the details of operation of the most popular current version of the protocol, <span class="emphasis"><em>IP version 4 (IPv4)</em></span>.</p><p>The second through sixth chapters discuss in great detail the concepts and practice behind IP addressing. The second chapter provides an overview of IPv4 addressing concepts and issues. The third discusses the original, class-based (<span class="emphasis"><em>classful</em></span>) IP addressing scheme and how the different classes work. The fourth and fifth chapters are devoted to IP subnets and subnet addressing. They discuss subnetting concepts and include an illustration of practical step-by-step subnetting. The sixth chapter describes the new classless addressing system, also sometimes called <span class="emphasis"><em>supernetting</em></span>.</p><p>The seventh through ninth chapters discuss important practical issues related to how IPv4 datagrams are created and handled. You'll find a full description of the IPv4 message format and options in the seventh chapter; explanations of IP datagram sizing, fragmentation, and reassembly in the eighth chapter; and coverage of routing and multicasting in the ninth chapter.</p><p>As the title of this part implies, the coverage here is limited to IPv4. (For simplicity, in this part, I use the simpler designation <span class="emphasis"><em>IP</em></span> rather than <span class="emphasis"><em>IPv4</em></span>, except where the version number is required for clarity.) IP version 6 (IPv6) is covered in its separate section (<a class="xref" href="pt07.html" title="Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)">Part II-4</a>), as are the IP-related protocols. That said, some of the principles here will also apply to IPv6, as well as IP Network Address Translation (NAT), IPsec, and Mobile IP (<a class="xref" href="pt07.html" title="Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)">Part II-4</a>) in a limited manner.</p></div></div>
<div class="chapter" title="Chapter&#xA0;15.&#xA0;INTERNET PROTOCOL VERSIONS, CONCEPTS, AND OVERVIEW"><div class="titlepage"><div><div><h1 class="title"><a id="internet_protocol_versions_concepts_and_"/>Chapter 15. INTERNET PROTOCOL VERSIONS, CONCEPTS, AND OVERVIEW</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e15490"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>The Internet Protocol (IP) is a very important protocol in internetworking. It would be no exaggeration to say that you can't really comprehend modern networking without a good understanding of IP. Unfortunately, IP can be somewhat difficult to understand. A large amount of complexity has become associated with it over the years, and this has allowed it to meet the many demands placed on it.</p><p>Before diving into the details of how IP works, we'll look at the basic concepts underlying IP. In this chapter, I explain how IP operates in basic terms and the most important aspects of how it does its job. We'll look at its main functions, its history, and how it has spawned the development of several IP-related protocols.</p><div class="sect1" title="IP Overview and Key Operational Characteristics"><div class="titlepage"><div><div><h1 class="title"><a id="ip_overview_and_key_operational_characte"/>IP Overview and Key Operational Characteristics</h1></div></div></div><p><a class="indexterm" id="idx-CHP-15-0636"/>IP is the core of the TCP/IP protocol suite and the main protocol at the network layer. The network layer is primarily concerned with the delivery of data between devices that may be on different networks, which are interconnected in an arbitrary manner. In other words, an <span class="emphasis"><em>internetwork</em></span>. IP is the mechanism by which this data is sent on TCP/IP networks (with help from other protocols at the network layer, too, of course).</p><p>Let's look at the TCP/IP layer model and consider what IP does from an architectural standpoint. As the layer 3 protocol, it provides a service to layer 4 in the TCP/IP stack, represented mainly by the Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) (see <a class="xref" href="pt11.html" title="Part II-8. TCP/IP TRANSPORT LAYER PROTOCOLS">Part II-8</a>). IP takes data that has been packaged by either TCP or UDP, manipulates it as necessary, and sends it out (see <a class="xref" href="ch15.html#the_main_function_of_ip_internetwork_dat" title="Figure 15-1. The main function of IP: internetwork datagram delivery IP's overall responsibility is to deliver data between devices on unconnected networks. This figure shows how IP delivers datagrams from one device to another over an internetwork; in this case, a distant client and server communicate with each other by passing IP datagrams over a series of interconnected networks.">Figure 15-1</a>).</p><p>This service is sometimes called <span class="emphasis"><em>internetwork datagram delivery</em></span>. There are many details that explain exactly how this service is accomplished, but in a nutshell, IP sends data from point A to point B over an internetwork of connected networks.<a class="indexterm" id="idx-CHP-15-0637"/></p><div class="figure"><a id="the_main_function_of_ip_internetwork_dat"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e15526"/><img alt="The main function of IP: internetwork datagram delivery IP's overall responsibility is to deliver data between devices on unconnected networks. This figure shows how IP delivers datagrams from one device to another over an internetwork; in this case, a distant client and server communicate with each other by passing IP datagrams over a series of interconnected networks." src="httpatomoreillycomsourcenostarchimages287789.png.jpg"/></div></div><p class="title">Figure 15-1. The main function of IP: internetwork datagram delivery IP's overall responsibility is to deliver data between devices on unconnected networks. This figure shows how IP delivers datagrams from one device to another over an internetwork; in this case, a distant client and server communicate with each other by passing IP datagrams over a series of interconnected networks.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-79"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> While the <span class="emphasis"><em>Internet Protocol</em></span> has many functions and characteristics, it can be boiled down to one primary purpose: the delivery of datagrams across an internetwork of connected networks.<a class="indexterm" id="idx-CHP-15-0638"/></p></div><p>Of course, there are many ways in which IP could have been implemented in order to accomplish this task. To understand how the designers of TCP/IP made IP work, let's take a look at the key characteristics used to describe IP and the general manner in which it operates:</p><p><span class="strong"><strong>Universally Addressed</strong></span> In order to send data from point A to point B, it is necessary to ensure that devices know how to identify which device is point B. IP defines the addressing mechanism for the network and uses these addresses for delivery purposes.</p><p><span class="strong"><strong>Underlying Protocol-Independent</strong></span> IP is designed to allow the transmission of data across any type of underlying network that is designed to work with a TCP/IP stack. It includes provisions that allow it to adapt to the requirements of various lower-level protocols such as Ethernet or IEEE 802.11. IP can also run on the special data link protocols, Serial Line Interface Protocol (SLIP) and Point-to-Point Protocol (PPP), that were created for it (see <a class="xref" href="pt04.html" title="Part II-1. TCP/IP NETWORK INTERFACE LAYER PROTOCOLS">Part II-1</a>). An important example is IP's ability to fragment large blocks of data into smaller ones in order to match the size limitations of physical networks, and then have the recipient reassemble the pieces again as needed.</p><p><span class="strong"><strong>Connectionless Delivery</strong></span> IP is a <span class="emphasis"><em>connectionless protocol</em></span>. This means that when point A wants to send data to point B, it doesn't first set up a connection to point B and then send the data—it just makes the datagram and sends it. (See the section in <a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a> on connection-oriented and connectionless protocols for more information on this.)</p><p><span class="strong"><strong>Unreliable Delivery</strong></span> IP is said to be an unreliable protocol. That doesn't mean that one day your IP software will decide to go fishing rather than run your network. It does mean that when datagrams are sent from Device A to Device B, Device A just sends each one and then moves on to the next. IP doesn't keep track of the ones it sent. It does not provide reliability or service-quality capabilities, such as error protection for the data it sends (though it does on the IP header), flow control, or retransmission of lost datagrams. For this reason, IP is sometimes called a <span class="emphasis"><em>best-effort</em></span> protocol. It does what it can to get data to where it needs to go, but makes no guarantees that the data will actually get there.<a class="indexterm" id="idx-CHP-15-0639"/></p><p><span class="strong"><strong>Unacknowledged Delivery</strong></span> Corresponding with its unreliable nature, IP doesn't use acknowledgements. When Device B gets a datagram from Device A, it doesn't send back a "thank you note" to tell Device A that the datagram was received. It leaves Device A in the dark, so to speak.</p><p>These last three characteristics might be enough to make you cringe, thinking that giving your data to IP would be somewhat like trusting a new car to your 16-year-old son. If you are going to build an entire network around this protocol, why design it so that it works without connections, doesn't guarantee that the data will get there, and has no means of acknowledging receipt of data?</p><p>The reason is simple: Establishing connections, guaranteeing delivery, error checking, and similar insurance-type <a class="indexterm" id="idx-CHP-15-0640"/>functions have a cost in <span class="emphasis"><em>performance</em></span>. It takes time, computer resources, and network bandwidth to perform these tasks, and they aren't always necessary for every application. Now, consider that IP carries pretty much <span class="emphasis"><em>all</em></span> user traffic on a TCP/IP network. To build this complexity into IP would burden all traffic with this overhead, whether or not it was needed.</p><p>The solution taken by the designers of TCP/IP was to exploit the power of layering. If service-quality features such as connections, error checking, or guaranteed delivery are required by an application, they are provided at the transport layer (or possibly, the application layer). On the other hand, applications that don't need these features can avoid using them. This is the major distinction between the two TCP/IP transport layer protocols: TCP and UDP. TCP is full featured but a bit slower than UDP; UDP is spartan in its capabilities, but faster than TCP. This system is really the best of both worlds, and it works.</p></div></div>
<div class="sect1" title="IP Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ip_functions"/>IP Functions</h1></div></div></div><p>The exact number of IP functions depends on where you draw the line between certain activities. For explanatory purposes, however, I view IP as having four basic functions (or more accurately, function sets):</p><p><span class="strong"><strong>Addressing</strong></span> Before it can deliver datagrams, IP must know where to deliver them. For this reason, IP includes a mechanism for host addressing. Furthermore, since IP operates over internetworks, its system is designed to allow for the unique addressing of devices across arbitrarily large networks. It also contains a structure to facilitate the routing of datagrams to distant networks, if that is required. Since most of the other TCP/IP protocols use IP, an understanding the IP addressing scheme is of vital importance to comprehending much of what goes on in TCP/IP. It is explored fully in Chapters <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a> through <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>.</p><p><span class="strong"><strong>Data Encapsulation and Formatting/Packaging</strong></span> As the TCP/IP network layer protocol, IP accepts data from the transport layer protocols UDP and TCP. It then encapsulates this data into an IP datagram using a special format prior to transmission.</p><p><span class="strong"><strong>Fragmentation and Reassembly</strong></span> IP datagrams are passed down to the data link layer for transmission on the local network. However, the maximum frame size of each physical and data link network using IP may be different. For this reason, IP includes the ability to <span class="emphasis"><em>fragment</em></span> IP datagrams into pieces, so that they can each be carried on the local network. The receiving device uses the <span class="emphasis"><em>reassembly</em></span> function to re-create the whole IP datagram. Some people view fragmentation and reassembly as distinct functions, though clearly they are complementary, and I view them as being part of the same job.</p><p><span class="strong"><strong>Routing and Indirect Delivery</strong></span> When an IP datagram must be sent to a destination on the same local network, you can do this easily with the network's underlying local area network (LAN), wireless LAN (WLAN), or wide area network (WAN) protocol, using what is sometimes called <span class="emphasis"><em>direct delivery</em></span>. However, in many (if not most cases) the final destination is on a distant network that isn't directly attached to the source. In this situation, the datagram must be delivered indirectly. This is accomplished by routing the datagram through intermediate devices (<span class="emphasis"><em>routers</em></span>). <a class="indexterm" id="idx-CHP-15-0641"/>IP accomplishes this in concert with support from the other protocols including the Internet Control Message Protocol (ICMP) and the TCP/IP gateway/routing protocols such as the Routing Information Protocol (RIP) and the Border Gateway Protocol (BGP).<a class="indexterm" id="idx-CHP-15-0642"/></p></div>
<div class="sect1" title="IP History, Standards, Versions, and Closely Related Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ip_history_standards_versions_and_closel"/>IP History, Standards, Versions, and Closely Related Protocols</h1></div></div></div><p>Since IP is really the architectural foundation for the entire TCP/IP protocol suite, you might have expected that it was created first, and that the other protocols were built upon it. That's usually how you build a structure, after all! The history of IP, however, is a bit more complex. The functions it <span class="emphasis"><em>performs</em></span> were defined at the birth of the protocol, but IP itself didn't exist for the first few years that the protocol suite was being defined.<a class="indexterm" id="idx-CHP-15-0643"/><a class="indexterm" id="idx-CHP-15-0644"/><a class="indexterm" id="idx-CHP-15-0645"/></p><p>I explore the early days of TCP/IP in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>, which provides an overview of the suite as a whole. What is notable about the development of IP is that its functions were originally part of TCP. As a formal protocol, IP was born when an early version of TCP developed in the 1970s for predecessors of the modern Internet was split into TCP at layer 4 and IP at layer 3. The key milestone in the development of IP was the publication of RFC 791, "Internet Protocol," in September 1981. This standard, a revision of the similar RFC 760 of the previous year, defined the core functionality and characteristics of the version of IP that has been in widespread use for the last two decades.</p><div class="sect2" title="IP Versions and Version Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ip_versions_and_version_numbers"/>IP Versions and Version Numbers</h2></div></div></div><p>The IP defined in RFC 791 was the first widely used version of IP. Interestingly, however, it is not version 1 of IP but version 4! This would of course imply that there were earlier versions of the protocol at one point. Interestingly, however, there really weren't. IP was created when its functions were split out from an early version of TCP that combined both TCP and IP functions. TCP evolved through three earlier versions and was split into TCP and IP for version 4. That version number was applied to both TCP and IP for consistency.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-80"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Version 4 of the <span class="emphasis"><em>Internet Protocol</em></span> (IP) is actually the first version that was widely deployed and is currently the one in widespread use.</p></div><p>So, when you use IP today, you are using IP version 4, which is frequently abbreviated IPv4. Unless otherwise qualified, it's safe to assume that <span class="emphasis"><em>IP</em></span> means IP version 4—at least for the next few years. (This version number is carried in the appropriate field of all IP datagrams, as described in the topic discussing the IP datagram format in <a class="xref" href="ch21.html" title="Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 21</a>.)</p><p>Given that it was originally designed for an internetwork a tiny fraction of the size of our current Internet, IPv4 has proven itself remarkably capable. Various additions and changes have been made over time to how IP is used, especially with respect to addressing, but the core protocol is basically what it was in the early 1980s. There's good reason for this. Changing something as fundamental as IP requires a great deal of development effort and also introduces complexities during transition.</p><p>IPv4 has served us well, but people understood that, for various reasons, a new version of IP would eventually be required. Due to the difficulties associated with making such an important change, development of this new version of IP has actually been under way since the mid-1990s. This new version of IP is formally called <span class="emphasis"><em>Internet Protocol version 6 (IPv6)</em></span> and also sometimes referred to as <span class="emphasis"><em>IP Next Generation</em></span> or <span class="emphasis"><em>IPng</em></span>. I discuss the reasons why IPv6 was developed and how it differs from IPv4 in considerable detail in <a class="xref" href="pt07.html" title="Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)">Part II-4</a> of this book.</p><p>A natural question at this point is, "What happened to version 5 of IP?" The answer is that it doesn't exist. While this may seem confusing, version 5 was in fact intentionally skipped in order to <span class="emphasis"><em>avoid</em></span> confusion, or at least to rectify it. The problem with version 5 relates to an experimental TCP/IP protocol called the <span class="emphasis"><em>Internet Stream Protocol, version 2</em></span>, originally defined in RFC 1190. This protocol was originally seen by some as being a peer of IP at the Internet layer in the TCP/IP architecture, and in its standard version, these packets were assigned IP version 5 to differentiate them from normal IP packets (version 4). This protocol apparently never went anywhere, but to be absolutely sure that there would be no confusion, version 5 was skipped over in favor of version 6.</p></div><div class="sect2" title="IP-Related Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="ip-related_protocols"/>IP-Related Protocols</h2></div></div></div><p>In addition to the old and new versions of IP, there are several protocols that are <span class="emphasis"><em>IP-related</em></span>. These are protocols that add to or expand on the capabilities of IP functions for special circumstances, but they are not part of IP proper. These are as follows:</p><p><span class="strong"><strong>IP Network Address Translation (IP NAT or NAT)</strong></span> This protocol provides IP address translation capabilities that allow private networks to be interfaced to public networks in a flexible manner. It allows public IP addresses to be shared and improves security by making it more difficult for hosts on the public network to gain unauthorized access to hosts. It is commonly called <span class="emphasis"><em>NAT</em></span>. This protocol is discussed in <a class="xref" href="ch28.html" title="Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL">Chapter 28</a>.</p><p><span class="strong"><strong>IP Security (IPsec)</strong></span> IPsec defines a set of subprotocols that provide a mechanism for the secure transfer of data using IP. It is rapidly growing in popularity as a security protocol that enables virtual private networks. This protocol is discussed in <a class="xref" href="ch29.html" title="Chapter 29. IP SECURITY (IPSEC) PROTOCOLS">Chapter 29</a>.</p><p><span class="strong"><strong>Mobile IP</strong></span> This is a protocol that addresses some of the difficulties associated with using IP on computers that frequently move from one network to another. It provides a mechanism that allows data to be automatically routed to a mobile host (such as a notebook computer), without requiring a constant reconfiguration of the device's IP address. This protocol is discussed in <a class="xref" href="ch30.html" title="Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)">Chapter 30</a>.</p></div></div>
<div class="chapter" title="Chapter&#xA0;16.&#xA0;IPV4 ADDRESSING CONCEPTS AND ISSUES"><div class="titlepage"><div><div><h1 class="title"><a id="ipv4_addressing_concepts_and_issues"/>Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e15746"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>The primary job of the Internet Protocol (IP) is delivering messages between devices, and like any good delivery service, it can't do its job too well if it doesn't know where the recipients are located. Obviously then, one of the most important functions of IP is <span class="emphasis"><em>addressing</em></span>. IP addressing is used not only to uniquely identify IP addresses, but also to facilitate the routing of IP datagrams over internetworks. IP addresses are used and referred to extensively in TCP/IP networking.</p><p>Even though the original IP addressing scheme was relatively simple, it has become complex over time as changes have been made to it to allow it to deal with various addressing requirements. The more advanced styles of IP addressing, such as subnetting and classless addressing, are the ones used most in modern networks. However, they can be a bit confusing to understand. To help make sense of them, we must start at the beginning with a discussion of the fundamentals of IP addressing.</p><p>In this chapter, I begin a larger exploration of <a class="indexterm" id="idx-CHP-16-0646"/>IP addressing by explaining the key concepts and issues behind it. I begin with an overview of IP addressing and a discussion of what it is all about. I describe the size of IP addresses, the concept of its address space, and the notation usually used for IP addresses. I provide basic information on the structure of an IP address and how it is divided into a network identifier and host identifier. I then describe the different types of IP addresses and the additional information, such as a subnet mask and default gateway, that often accompanies an IP address on larger networks. I provide a brief description of how multiple addresses are sometimes assigned to single devices and why. I conclude with a description of the process by which public IP addresses are registered and managed, and the organizations that do this work for the global Internet.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-81"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>If you are not familiar with at least the basics of how binary numbers work, and also with how to convert between binary and decimal numbers, I recommend reading <a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a>, which provides some background on data representation and the mathematics of computing, before you proceed here</em></span>.</p></div><div class="sect1" title="IP Addressing Overview and Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="ip_addressing_overview_and_fundamentals"/>IP Addressing Overview and Fundamentals</h1></div></div></div><p>IP addressing is important because it facilitates the primary function of the IP: the delivery of datagrams across an internetwork. When you examine this in more detail, it becomes apparent that the IP address actually has two different functions, as follows:</p><p><span class="strong"><strong>Network Interface Identification</strong></span> Like a street address, the IP address provides unique identification of the interface between a device and the network. This is required to ensure that the datagram is delivered to the correct recipients.</p><p><span class="strong"><strong>Routing</strong></span> When the source and destination of an IP datagram are not on the same network, the datagram must be delivered indirectly using intermediate systems. This is a process called <span class="emphasis"><em>routing</em></span>. The IP address is an essential part of the system used to route datagrams.</p><p>You may have noticed a couple of things about this short list. One is that I said the IP address identifies the <span class="emphasis"><em>network interface</em></span>, not that it identifies the <span class="emphasis"><em>device</em></span> itself. This distinction is important because it underscores the concept that IP is oriented around connections to a large, virtual network at layer 3, which can span multiple physical networks. Some devices, such as routers, will have more than one network connection, necessary to take datagrams from one network and route them onto another. This means they will also have more than one IP address—one per connection.</p><p>You might also find it curious that I said that the IP address facilitates routing. How can it do that? The answer is that the addressing system is designed with a structure that can be interpreted to allow routers to determine what to do with a datagram based on the values in the address. Numbers related to the IP address, such as the subnet mask when subnetting is used, support this function.</p><p>Let's look at some of the more important issues and characteristics associated with IP addresses in general terms.</p><div class="sect2" title="Number of IP Addresses Per Device"><div class="titlepage"><div><div><h2 class="title"><a id="number_of_ip_addresses_per_device"/>Number of IP Addresses Per Device</h2></div></div></div><p>Any device that has data sent to it at the network layer will have at least one IP address: one per network interface. This means that normal hosts such as computers and network-capable printers usually get one IP address, while routers get more than one IP address. Some special hosts may have more than one IP address if they are multihomed—connected to more than one network.</p><p>Lower-level network interconnection devices—such as repeaters, bridges, and switches—don't require an IP address because they pass traffic based on layer 2 (data link layer) addresses. Network segments connected by bridges and switches form a single broadcast domain, and any devices on them can send data to each other directly without routing. To IP, these devices are essentially invisible; they are no more significant than the wires that connect devices together (with a couple of exceptions). Such devices may, however, optionally have an IP address for management purposes. In this regard, they are acting like a regular host on the network.</p><p><a class="xref" href="ch16.html#ip_interfaces_for_common_network_devices" title="Figure 16-1. IP interfaces for common network devices Regular hosts have one interface; routers usually have more than one; and switches have none (because they operate at layer 2).">Figure 16-1</a> shows the IP interfaces of a few common LAN devices as small circles. Each regular host has one interface, while the router that serves this LAN has three, since it connects to three different networks. Note that the LAN switch has no IP interfaces; it connects the hosts and router at layer 2. (Also see <a class="xref" href="ch16s06.html#multihomed_devices_on_an_ip_internetwork" title="Figure 16-5. Multihomed devices on an IP internetwork This internetwork consists of two LANs, A (above) and B (below). LAN A has a multihomed workstation, shown with two IP network interface &quot;circles.&quot; The two LANs are connected together through a multihomed, shared server that has been configured to route traffic between them. Note that this server also handles all traffic passing between LAN B and the Internet (since the Internet connection is in LAN A only).">Figure 16-5</a>, which shows the IP interfaces of devices in a more complex configuration.)</p><div class="figure"><a id="ip_interfaces_for_common_network_devices"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15816"/><img alt="IP interfaces for common network devices Regular hosts have one interface; routers usually have more than one; and switches have none (because they operate at layer 2)." src="httpatomoreillycomsourcenostarchimages287791.png.jpg"/></div></div><p class="title">Figure 16-1. IP interfaces for common network devices Regular hosts have one interface; routers usually have more than one; and switches have none (because they operate at layer 2).</p></div></div><div class="sect2" title="Address Uniqueness and Network Specificity"><div class="titlepage"><div><div><h2 class="title"><a id="address_uniqueness_and_network_specifici"/>Address Uniqueness and Network Specificity</h2></div></div></div><p>Each IP address on a single internetwork must be unique. (This seems rather obvious, although there are exceptions in IPv6, in the form of special anycast addresses, as discussed in <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a>.)</p><p>Since IP <a class="indexterm" id="idx-CHP-16-0647"/>addresses represent network interfaces and are used for routing, the IP address is specific to the network to which it is connected. If the device moves to a new network, the IP address will usually have to change as well. For the full reason why, see the discussion of basic IP address structure later in this chapter. This issue was a primary motivation for the creation of Mobile IP (covered in <a class="xref" href="ch30.html" title="Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)">Chapter 30</a>).</p></div><div class="sect2" title="Contrasting IP Addresses and Data Link Layer Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="contrasting_ip_addresses_and_data_link_l"/>Contrasting IP Addresses and Data Link Layer Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0648"/>IP addresses are used for network-layer data delivery across an internetwork. This makes IP addresses quite different from the data link layer address of a device, such as its Ethernet MAC address. (In TCP/IP parlance, these are sometimes called <span class="emphasis"><em>physical addresses</em></span> or <a class="indexterm" id="idx-CHP-16-0649"/><span class="emphasis"><em>hardware addresses</em></span>.)</p><p>At the network layer, a single datagram may be sent from Device A to Device B. However, the actual delivery of the datagram may require that it passes through a dozen or more physical devices if Device A and Device B are not on the same network.</p><p>It is also necessary to provide a function that maps between IP and data link layer addresses. In TCP/IP, this is the job of the Address Resolution Protocol (ARP; see <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>).</p><p>In a physical network such as an Ethernet, the MAC address is all the information needed to send data between devices. In contrast, an IP address represents only the final delivery point of the datagram. The route taken depends on the characteristics of the network paths between the source and destination devices. It is even possible that there may not be a route between any two devices, which means two devices cannot exchange data, even if they know each other's addresses!</p></div><div class="sect2" title="Private and Public IP Network Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="private_and_public_ip_network_addresses"/>Private and Public IP Network Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0650"/> There are two distinct ways that a network can be set up with IP addresses. On a <span class="emphasis"><em>private network</em></span>, a single organization controls the assignment of the addresses for all devices; they have pretty much absolute control to do what they wish in selecting numbers, as long as each address is unique.</p><p>In contrast, on a <span class="emphasis"><em>public network</em></span>, a mechanism is required to ensure that organizations don't use overlapping addresses and that they enable efficient routing of data between organizations. The best-known example of this is the Internet, where public IP registration and management facilities have been created to address this issue. There are also advanced techniques now, such as IP Network Address Translation (NAT), which allow a network using private addresses to be interfaced to a public TCP/IP network.</p></div><div class="sect2" title="IP Address Configuration and Addressing Types"><div class="titlepage"><div><div><h2 class="title"><a id="ip_address_configuration_and_addressing_"/>IP Address Configuration and Addressing Types</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0651"/>IP addresses can be set up as either a static or dynamic configuration. In a <span class="emphasis"><em>static configuration</em></span> setup, each device is manually configured with an IP address that doesn't change. This is fine for small networks but quickly becomes an administrative nightmare in larger networks, when changes are required. The alternative, <span class="emphasis"><em>dynamic configuration</em></span>, allows <a class="indexterm" id="idx-CHP-16-0652"/>IP addresses to be assigned to devices and changed under software control. The two host configuration protocols, BOOTP and DHCP, were created to fill this latter function (see <a class="xref" href="pt14.html" title="Part III-3. HOST CONFIGURATION AND TCP/IP HOST CONFIGURATION PROTOCOLS">Part III-3</a>).</p><p>Additionally, provision is included in the <a class="indexterm" id="idx-CHP-16-0653"/>IP addressing scheme for all three basic types of addressing: unicast, multicast, and broadcast.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-82"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IP addresses serve the dual function of device identification and routing. Each network interface requires one IP address, which is network specific. IP addresses can be either statically or dynamically allocated, and come in unicast, multicast, and broadcast forms.</p></div></div></div></div>
<div class="sect1" title="IP Address Size, Address Space, and Notation"><div class="titlepage"><div><div><h1 class="title"><a id="ip_address_size_address_space_and_notati"/>IP Address Size, Address Space, and Notation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-16-0654"/><a class="indexterm" id="idx-CHP-16-0655"/>Now that you have looked at the general issues and characteristics associated with IP addresses, it's time to get past the introductions and dig into the "meat" of the IP address discussion. Let's start by looking at the physical construction and size of the IP address and how it is referred to and used.</p><div class="sect2" title="IP Address Size and Binary Notation"><div class="titlepage"><div><div><h2 class="title"><a id="ip_address_size_and_binary_notation"/>IP Address Size and Binary Notation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0656"/>At its simplest, the IP address is just a 32-bit binary number: a set of 32 ones or zeros. At their lowest levels, computers always work in binary, and this also applies to networking hardware and software. While different meanings are ascribed to different bits in the address, the address itself is just a 32-digit binary number.</p><p>People don't work too well with binary numbers, because they are long and complicated, and the use of only two digits makes them hard to differentiate. (Quick, which of these is larger: 11100011010100101001100110110001 or 11100011010100101001101110110001?) For this reason, when you use IP addresses, you don't work with them in binary except when absolutely necessary.</p><p>The first thing that people would naturally do with a long string of bits is to split it into four eight-bit octets (or bytes, even though the two aren't technically the same; see <a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a>), to make it more manageable. So 11100011010100101001101110110001 would become 11100011 - 01010010 - 10011101 - 10110001. Then you could convert each of those octets into a more manageable two-digit hexadecimal number to yield the following: E3 - 52 - 9D - B1. This is, in fact, the notation used for IEEE 802 MAC addresses, except that they are 48 bits long, so they have six two-digit hex numbers, and they are usually separated by colons, not dashes, as I used here.</p><p>(Incidentally, the second binary number is the larger one.)</p></div><div class="sect2" title="IP Address Dotted Decimal Notation"><div class="titlepage"><div><div><h2 class="title"><a id="ip_address_dotted_decimal_notation"/>IP Address Dotted Decimal Notation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0657"/>Most people still find hexadecimal a bit difficult to work with. So, IP addresses are normally expressed with each octet of eight bits converted to a decimal number and the octets separated by a period (a <span class="emphasis"><em>dot</em></span>). Thus, the previous example would become 227.82.157.177, as shown in <a class="xref" href="ch16s02.html#ip_address_binary_hexadecimal_and_dotted" title="Figure 16-2. IP address binary, hexadecimal, and dotted decimal representations The binary, hexadecimal, and decimal representations of an IP address are all equivalent.">Figure 16-2</a>. This is usually called <span class="emphasis"><em>dotted decimal notation</em></span> for rather obvious reasons. Each of the octets in an IP address can take on the values from 0 to 255, so the lowest value is theoretically 0.0.0.0 and the highest is 255.255.255.255.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-83"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IP addresses are 32-bit binary numbers, which can be expressed in binary, hexadecimal, or decimal form. Most commonly, they are expressed by dividing the 32 bits into four bytes and converting each to decimal, then separating these numbers with dots to create dotted decimal notation.</p></div><div class="figure"><a id="ip_address_binary_hexadecimal_and_dotted"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15992"/><img alt="IP address binary, hexadecimal, and dotted decimal representations The binary, hexadecimal, and decimal representations of an IP address are all equivalent." src="httpatomoreillycomsourcenostarchimages287793.png.jpg"/></div></div><p class="title">Figure 16-2. IP address binary, hexadecimal, and dotted decimal representations The binary, hexadecimal, and decimal representations of an IP address are all equivalent.</p></div><p>Dotted decimal notation provides a convenient way to work with <a class="indexterm" id="idx-CHP-16-0658"/>IP addresses when communicating among people. Never forget that to the computers, the IP address is always a 32-bit <a class="indexterm" id="idx-CHP-16-0659"/>binary number; you'll understand the importance of this when you look at how the IP address is logically divided into components in the next topic, and when you examine techniques that manipulate IP addresses, such as subnetting.</p></div><div class="sect2" title="IP Address Space"><div class="titlepage"><div><div><h2 class="title"><a id="ip_address_space"/>IP Address Space</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0660"/>Since the IP address is 32 bits wide, this provides a theoretical <span class="emphasis"><em>address space</em></span> of 2<sup>32</sup>, or 4,294,967,296 addresses. This seems like quite a lot of addresses, and in some ways, it is. However, as you will see, due to how IP addresses are structured and allocated, not every one of those addresses can actually be used.</p><p>One of the unfortunate legacies of the fact that IP was originally created on a rather small internetwork is that decisions were made that wasted much of the address space. For example, all IP addresses starting with 127 in the first octet are reserved for the loopback function. Just this one decision makes 1/256th of the total number, or 16,277,216 addresses, no longer available. There are also other ways that the IP address space was not conserved. This caused difficulty as the Internet grew in size. (You'll see more about this in <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a>, which covers classful addressing.)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-84"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since IP addresses are 32 bits long, the total address space of IPv4 is 2<sup>32</sup> or 4,294,967,296 addresses. However, not all of these addresses can be used, for a variety of reasons.</p></div><p>This IP address space dictates the limit on the number of addressable interfaces in <span class="emphasis"><em>each</em></span> IP internetwork. So, if you have a private network, you can, in theory, have four-billion-plus addresses. However, in a public network such as the Internet, alldevices must share the available address space. Techniques such as Classless Inter-Domain Routing (CIDR), or supernetting, and NAT were designed in part to utilize the existing Internet IP address space more efficiently. IPv6 expands the IP address size from 32 bits all the way up to 128, which increases the address space to a ridiculously large number and makes the entire matter of address space size moot.</p></div></div>
<div class="sect1" title="IP Basic Address Structure and Main Components"><div class="titlepage"><div><div><h1 class="title"><a id="ip_basic_address_structure_and_main_comp"/>IP Basic Address Structure and Main Components</h1></div></div></div><p><a class="indexterm" id="idx-CHP-16-0661"/>As I mentioned in the IP addressing overview, one of the ways that IP addresses are used is to facilitate the routing of datagrams in an IP internetwork. This is made possible because of the way that IP addresses are structured and how that structure is interpreted by network routers.</p><div class="sect2" title="Network ID and Host ID"><div class="titlepage"><div><div><h2 class="title"><a id="network_id_and_host_id"/>Network ID and Host ID</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0662"/>As you just saw, each IPv4 address is 32 bits long. When you refer to the IP address, you use a dotted decimal notation, while the computer converts this into binary. However, even though these sets of 32 bits are considered a single entity, they have an internal structure containing two components:</p><p><span class="strong"><strong>Network Identifier (Network ID)</strong></span> A certain number of bits, starting from the leftmost bit, is used to identify the network where the host or other network interface is located. This is also sometimes called the <span class="emphasis"><em>network prefix</em></span> or even just the <span class="emphasis"><em>prefix</em></span>.</p><p><span class="strong"><strong>Host Identifier (Host ID)</strong></span> The remainder of the bits is used to identify the host on the network.</p><div class="note" title="Note"><h3 class="title"><a id="note-62"/>Note</h3><p><span class="emphasis"><em>By convention, IP devices are often called hosts for simplicity, as I do throughout this book. Even though each host usually has a single IP address, you should remember that IP addresses are strictly associated with network layer network interfaces, not physical devices, and a device may therefore have more than one IP address (especially a router or multihomed host)</em></span>.</p></div><p>As you can see in <a class="xref" href="ch16s03.html#basic_ip_address_division_network_id_and" title="Figure 16-3. Basic IP address division: network ID and host ID This diagram shows one of the many ways to divide an IP address into a network ID and host ID.">Figure 16-3</a>, this really is a fairly simple concept. The fundamental division of the bits of an IP address is into a network ID and host ID. In this illustration, the network ID is 8 bits long, and the host ID is 24 bits in length. This is similar to the structure used for phone numbers in North America. The telephone number (401) 555-7777 is a ten-digit number that's usually referred to as a single phone number. However, it has a structure. In particular, it has an area code (401) and a local number (555-7777).</p><p>The fact that the network ID is contained in the IP address is what partially facilitates the routing of IP datagrams when the address is known. Routers look at the network portion of the IP address to first determine if the destination IP address is on the same network as the host IP address. Then routing decisions are made based on information the routers keep about where various networks are located. Again, this is conceptually similar to how the area code is used by the equivalent of routers in the phone network to switch telephone calls. The host portion of the address is used by devices on the local portion of the network.</p><div class="figure"><a id="basic_ip_address_division_network_id_and"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e16090"/><img alt="Basic IP address division: network ID and host ID This diagram shows one of the many ways to divide an IP address into a network ID and host ID." src="httpatomoreillycomsourcenostarchimages287795.png.jpg"/></div></div><p class="title">Figure 16-3. Basic IP address division: network ID and host ID This diagram shows one of the many ways to divide an IP address into a network ID and host ID.</p></div></div><div class="sect2" title="Location of the Division Between Network ID and Host ID"><div class="titlepage"><div><div><h2 class="title"><a id="location_of_the_division_between_network"/>Location of the Division Between Network ID and Host ID</h2></div></div></div><p>One difference between IP addresses and phone numbers is that the dividing point between the bits used to identify the network and those that identify the host isn't fixed. It depends on the nature of the address, the type of addressing being used, and other factors.</p><p>Take the previous example of 227.82.157.177 (see <a class="xref" href="ch16s02.html#ip_address_binary_hexadecimal_and_dotted" title="Figure 16-2. IP address binary, hexadecimal, and dotted decimal representations The binary, hexadecimal, and decimal representations of an IP address are all equivalent.">Figure 16-2</a>). It is possible to divide this into a network ID of 227.82 and a host ID of 157.177. Alternatively, the network ID might be 227 and the host ID might be 82.157.177 within that network.</p><p>To express the network and host IDs as 32-bit addresses, you add zeros to replace the missing pieces. With a network ID of 227 and a host ID of 82.157.177, the address of the network becomes 227.0.0.0 and the address of the host 0.82.157.177. (In practice, network addresses of this sort are routinely seen with the added zeros; network IDs are not seen as often in 32-bit form this way.)</p><p>Lest you think from these examples that the <a class="indexterm" id="idx-CHP-16-0663"/>division must always be between whole octets of the address, you should know that it's also possible to divide it in the middle of an octet. For example, you could split the IP address 227.82.157.177 so that there were 20 bits for the network ID and 12 bits for the host ID. The process is the same, but determining the dotted decimal ID values is more tricky because here, the 157 is split into two binary numbers. The results are 227.82.144.0 for the network ID and 0.0.0.13.177 for the host ID, as shown in <a class="xref" href="ch16s03.html#mid-octet_ip_address_division_ip_address" title="Figure 16-4. Mid-octet IP address division IP addresses need not be divided between network ID and host ID on octet boundaries. The division here is into a 20-bit network ID and a 12-bit host ID.">Figure 16-4</a>.</p><p>Since IP addresses are normally expressed as four dotted-decimal numbers, educational resources often show the division between the network ID and host ID occurring on an octet boundary. However, it's essential to remember that the dividing point often appears in the middle of one of these eight-bit numbers. In <a class="xref" href="ch16s03.html#mid-octet_ip_address_division_ip_address" title="Figure 16-4. Mid-octet IP address division IP addresses need not be divided between network ID and host ID on octet boundaries. The division here is into a 20-bit network ID and a 12-bit host ID.">Figure 16-4</a>, the network ID is 20 bits long, and the host ID 12 bits long. This results in the third number of the original IP address, 157, being split into 144 and 13.</p><p>The place where the line is drawn between the network ID and the host ID must be known in order for devices such as routers to know how to interpret the address. This information is conveyed either implicitly or explicitly, depending on the type of IP addressing in use, as I discuss next.</p><div class="figure"><a id="mid-octet_ip_address_division_ip_address"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e16127"/><img alt="Mid-octet IP address division IP addresses need not be divided between network ID and host ID on octet boundaries. The division here is into a 20-bit network ID and a 12-bit host ID." src="httpatomoreillycomsourcenostarchimages287797.png.jpg"/></div></div><p class="title">Figure 16-4. Mid-octet IP address division IP addresses need not be divided between network ID and host ID on octet boundaries. The division here is into a 20-bit network ID and a 12-bit host ID.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-85"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The basic structure of an IP address consists of two components: the network ID and host ID. The dividing point of the 32-bit address is not fixed, but depends on a number of factors and can occur in a variety of places, including in the middle of a dotted-decimal octet.</p></div><p>Since the IP address can be split into network ID and host ID components, it is also possible to use either one or the other by itself, depending on context. These addresses are assigned special meanings. For example, if the network ID is used with all ones as the host ID, this indicates a broadcast to the entire network. Similarly, if the host ID is used by itself with all zeros for the network ID, this implies an IP address sent to the host of that ID on the local network, whatever that might be. This is explained in much more detail in <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a>.</p><p>It is the inclusion of the network ID in the IP address of each host on the network that causes the IP addresses to be network-specific. If you move a device from one network to a different one, the network ID must change to that of the new network. Therefore, the IP address must change as well. This is an unfortunate drawback that shows up most commonly when dealing with mobile devices; see <a class="xref" href="ch30.html" title="Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)">Chapter 30</a>.</p></div></div>
<div class="sect1" title="IP Addressing Categories and IP Address Adjuncts"><div class="titlepage"><div><div><h1 class="title"><a id="ip_addressing_categories_and_ip_address_"/>IP Addressing Categories and IP Address Adjuncts</h1></div></div></div><p><a class="indexterm" id="idx-CHP-16-0664"/>We just explored how the 32 bits in an IP address are fundamentally divided into the network ID and host ID. The network ID is used for routing purposes, and the host ID uniquely identifies each network interface on the network. In order for devices to know how to use IP addresses on the network, they must be able to tell which bits are used for each ID. However, the dividing line is not predefined. It depends on the type of addressing used in the network.</p><p>Understanding how these IDs are determined leads us into a larger discussion of the three main categories of IP addressing schemes: classful, subnetted, and classless. Each of these uses a slightly different system of indicating where in the IP address the host ID is found.</p><div class="sect2" title="Conventional (Classful) Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="conventional_classful_addressing"/>Conventional (Classful) Addressing</h2></div></div></div><p>The original IP addressing scheme is set up so that the dividing line occurs only in one of a few locations: on octet boundaries. Three main classes of addresses—A, B, and C—are differentiated based on how many octets are used for the network ID and how many for the host ID. For example, Class C addresses devote 24 bits to the network ID and 8 bits to the host ID. This type of addressing is now often referred to by the made-up word <span class="emphasis"><em>classful</em></span> to differentiate it from the newer classless scheme.</p><p>This most basic addressing type uses the simplest method to divide the network and host IDs: The class, and therefore the dividing point, are encoded into the first few bits of each address. Routers can tell from these bits which octets belong to which identifier.</p></div><div class="sect2" title="Subnetted Classful Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="subnetted_classful_addressing"/>Subnetted Classful Addressing</h2></div></div></div><p>In the subnet addressing system, the two-tier network and host division of the IP address is made into a three-tier system by taking some number of bits from a Class A, B, or C host ID and using them for a <span class="emphasis"><em>subnet identifier (subnet ID)</em></span>. The network ID is unchanged. The subnet ID is used for routing within the different subnetworks that constitute a complete network, thereby providing extra flexibility for administrators. For example, consider a Class C address that normally uses the first 24 bits for the network ID and remaining 8 bits for the host ID. The host ID can be split into, say, 3 bits for a subnet ID and 5 bits for the host ID.</p><p>This system is based on the original classful scheme, so the dividing line between the network ID and full host ID is based on the first few bits of the address as before. The dividing line between the subnet ID and the "subhost" ID is indicated by a 32-bit number called a <span class="emphasis"><em>subnet mask</em></span>. In the previous example, the subnet mask would be 27 ones followed by 5 zeros—the zeros indicate what part of the address is the host. In dotted decimal notation, this would be 255.255.255.224.</p></div><div class="sect2" title="Classless Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="classless_addressing"/>Classless Addressing</h2></div></div></div><p>In the classless system, the classes of the original IP addressing scheme are tossed out the window. The division between the network ID and host ID can occur at an arbitrary point, not just on octet boundaries, as in the classful scheme.</p><p>The dividing point is indicated by putting the number of bits used for the network ID, called the <span class="emphasis"><em>prefix length</em></span>, after the address. (Recall that the network ID bits are also sometimes called the <span class="emphasis"><em>network prefix</em></span>, so the network ID size is the prefix length.) For example, if 227.82.157.177 is part of a network where the first 27 bits are used for the network ID, that network would be specified as 227.82.157.160/27. The /27 is conceptually the same as the 255.255.255.224 subnet mask, since it has 27 one bits followed by 5 zeros.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-86"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> An essential factor in determining how an IP address is interpreted is the addressing scheme in which it is used. The three methods, arranged in increasing order of age, complexity, and flexibility, are classful addressing, subnetted classful addressing, and classless addressing.</p></div><p>This introduction to the concepts of classful, subnetted, and classless addressing was designed to show you how they impact the way the IP address is interpreted. I have greatly summarized important concepts here. All three methods are explained in their own chapters in full detail.</p></div><div class="sect2" title="Subnet Mask and Default Gateway"><div class="titlepage"><div><div><h2 class="title"><a id="subnet_mask_and_default_gateway"/>Subnet Mask and Default Gateway</h2></div></div></div><p><a class="indexterm" id="idx-CHP-16-0665"/>In the original classful scheme, the division between network ID and host ID is implied. However, if either subnetting or classless addressing is used, then the <span class="emphasis"><em>subnet mask</em></span> (or <span class="emphasis"><em>slash number</em></span>, which is equivalent) is required to fully qualify the address. These numbers are considered adjuncts to the IP address and usually mentioned with the address itself, because without them, it is not possible to know where the network ID ends and the host ID begins.</p><p>One other number that is often specified along with the IP address for a device is the <a class="indexterm" id="idx-CHP-16-0666"/><span class="emphasis"><em>default gateway</em></span> identifier. In simplest terms, this is the IP address of the router that provides default routing functions for a particular device. When a device on an IP network wants to send a datagram to a device it can't see on its local IP network, it sends it to the default gateway, which takes care of routing functions. Without this, each IP device would also need to have knowledge of routing functions and routes, which would be inefficient. See <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a>, which discusses IP routing concepts, and <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a> through 41, which cover TCP/IP routing protocols, for more information.</p></div></div>
<div class="sect1" title="Number of IP Addresses and Multihoming"><div class="titlepage"><div><div><h1 class="title"><a id="number_of_ip_addresses_and_multihoming"/>Number of IP Addresses and Multihoming</h1></div></div></div><p><a class="indexterm" id="idx-CHP-16-0667"/><a class="indexterm" id="idx-CHP-16-0668"/>
Each network interface on an IP internetwork has a separate IP address. In a classic network, each regular computer, usually called a <span class="emphasis"><em>host</em></span>, attaches to the network in exactly only one place, so it will have only one IP address. This is what most of us are familiar with when using an IP network (and is also why most people use the term <span class="emphasis"><em>host</em></span> when they really mean <span class="emphasis"><em>network interface</em></span>).</p><p>If a device has more than one interface to the internetwork, it will have more than one IP address. The most obvious case where this occurs is with routers, which connect together different networks and thus must have an IP address for the interface on each one. It is also possible for hosts to have more than one IP address, however. Such a device is sometimes said to be <span class="emphasis"><em>multihomed</em></span>.</p><p>There are two ways that a host can be multihomed:</p><p><span class="strong"><strong>Two or More Interfaces to the Same Network</strong></span> Devices such as servers or high-powered workstations may be equipped with two physical interfaces to the same network for performance and reliability reasons. They will have two IP addresses on the same network with the same network ID.</p><p><span class="strong"><strong>Interfaces to Two or More Different Networks</strong></span> Devices may have multiple interfaces to different networks. The <a class="indexterm" id="idx-CHP-16-0669"/>IP addresses will typically have different network IDs in them.</p><p><a class="xref" href="ch16s06.html#multihomed_devices_on_an_ip_internetwork" title="Figure 16-5. Multihomed devices on an IP internetwork This internetwork consists of two LANs, A (above) and B (below). LAN A has a multihomed workstation, shown with two IP network interface &quot;circles.&quot; The two LANs are connected together through a multihomed, shared server that has been configured to route traffic between them. Note that this server also handles all traffic passing between LAN B and the Internet (since the Internet connection is in LAN A only).">Figure 16-5</a> shows examples of both types of multihomed device. Of course, these could be combined, with a host having two connections to one network and a third to another network. There are also some other special cases, such as a host with a single network connection having multiple IP address aliases.</p><div class="note" title="Note"><h3 class="title"><a id="note-63"/>Note</h3><p><span class="emphasis"><em>When subnetting is used, the same distinction can be made between multihoming to the same subnet or a different subnet</em></span>.</p></div><p>Now, let's consider the second case. If a host has interfaces to two or more different networks, could it pass IP datagrams between them? Yes, if it had the right <a class="indexterm" id="idx-CHP-16-0670"/>software running on it. And wouldn't that make the host a router, of sorts? In fact, that is exactly the case. A multihomed host with interfaces to two networks can use software to function as a router. This is sometimes called <a class="indexterm" id="idx-CHP-16-0671"/><span class="emphasis"><em>software routing</em></span>.</p><p>Using a host as a router has certain advantages and disadvantages compared to a hardware router. A server that is multihomed can perform routing functions and also, well, act as a server. A dedicated hardware router is designed for the job of routing and usually will be more efficient than a software program running on a host.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-87"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A host with more than one IP network interface is said to be multihomed. A multihomed device can have multiple connections to the same network, to different networks, or both. A host connected to two networks can be configured to function as a router.</p></div><p>Multihoming was once considered a fairly esoteric application, but has become more common in recent years. This is also true of multihoming on different networks for software routing use. In fact, you may be doing this in your home without realizing it.</p><p>Suppose you have two PCs networked together and a single phone line to connect to the Internet. One computer dials up to your Internet service provider (ISP) and runs software such as Microsoft's <a class="indexterm" id="idx-CHP-16-0672"/>Internet Connection Sharing (<a class="indexterm" id="idx-CHP-16-0673"/>ICS) to let the other computer access the Internet. Millions of people do this every day—they have a multihomed system (the one connecting to the Internet and the other PC) with ICS acting in the role of a software router (though there are some technical differences between ICS and a true router, of course).</p></div>
<div class="sect1" title="IP Address Management and Assignment Methods and Authorities"><div class="titlepage"><div><div><h1 class="title"><a id="ip_address_management_and_assignment_met"/>IP Address Management and Assignment Methods and Authorities</h1></div></div></div><p><a class="indexterm" id="idx-CHP-16-0674"/>What would happen if you told someone that you lived at 34 Elm Street, and when he turned onto your road, he found four different houses with the number 34 on them? He probably would find your place eventually but wouldn't be too pleased. Neither would you or your mail carrier! And all of you folks are much smarter than computers. Like street addresses, IP addresses must be unique for them to be useful.</p><div class="figure"><a id="multihomed_devices_on_an_ip_internetwork"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e16338"/><img alt="Multihomed devices on an IP internetwork This internetwork consists of two LANs, A (above) and B (below). LAN A has a multihomed workstation, shown with two IP network interface &quot;circles.&quot; The two LANs are connected together through a multihomed, shared server that has been configured to route traffic between them. Note that this server also handles all traffic passing between LAN B and the Internet (since the Internet connection is in LAN A only)." src="httpatomoreillycomsourcenostarchimages287799.png.jpg"/></div></div><p class="title">Figure 16-5. Multihomed devices on an IP internetwork This internetwork consists of two LANs, A (above) and B (below). LAN A has a multihomed workstation, shown with two IP network interface "circles." The two LANs are connected together through a multihomed, shared server that has been configured to route traffic between them. Note that this server also handles all traffic passing between LAN B and the Internet (since the Internet connection is in LAN A only).</p></div><p>Since IP datagrams are sent only within the confines of the IP internetwork, they must be unique within each internetwork. If you are a company with your own private internetwork, this isn't really a big problem. Whoever is in charge of maintaining the internetwork keeps a list of what numbers have been used where and makes sure that no two <a class="indexterm" id="idx-CHP-16-0675"/>devices are given the same address. However, what happens in a public network with many different organizations? Here, it is essential that the IP address space be managed across the organizations to ensure that they use different addresses. It's not feasible to have each organization coordinate its activities with each other one. Therefore, some sort of centralized <span class="emphasis"><em>management authority</em></span> is required.</p><p>At the same time that you need someone to ensure that there are no conflicts in address assignment, you don't want users of the network to have to go to this central authority every time they need to make a change to their network. It makes more sense to have the authority assign numbers in blocks or chunks to organizations  based on the number of devices they want to connect to the network. The organizations can manage those blocks as they see fit, and the authority's job is made easier because it deals in blocks instead of billions of individual addresses and machines.</p><p>The Internet, as the big IP internetwork, requires this coordination task to be performed for millions of organizations worldwide. The job of managing IP address assignment on the Internet was originally carried out by a single organization: the <span class="emphasis"><em>Internet Assigned Number Authority (IANA)</em></span>. IANA was responsible for allocating IP addresses, along with other important centralized coordination functions such as managing universal parameters used for TCP/IP protocols. In the late 1990s, a new organization called the <span class="emphasis"><em>Internet Corporation for Assigned Names and Numbers (ICANN)</em></span> was created. ICANN now oversees the IP address assignment task of IANA, as well as managing other tasks such as Domain Name System (DNS) name registration (see <a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a>).</p><p>IP addresses were originally allocated directly to organizations. The original IP addressing scheme was based on classes, and so IANA would assign addresses in Class A, B, and C blocks. Today, addressing is classless, using CIDR's hierarchical addressing scheme. IANA doesn't assign addresses directly, but rather delegates them to regional Internet registries (RIRs). These are APNIC, ARIN, LACNIC, and RIPE NCC. Each RIR can, in turn, delegate blocks of addresses to lower-level registries such as national Internet registries (NIRs) and local Internet registries (LIRs).</p><p>Eventually, blocks of addresses are obtained by ISPs for distribution to end-user organizations. Some of the ISP's customers are end-user organizations, but others are (smaller) ISPs themselves. They can, in turn, use or delegate the addresses in their blocks. This can continue for several stages in a hierarchical fashion. This arrangement helps ensure that IP addresses are assigned and used in the most efficient manner possible. See <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>, which discusses CIDR, for more information on how this works.</p><p>IANA, ICANN, and the RIRs are responsible for more than just IP address allocation, though I have concentrated on IP addresses here for obvious reasons. For more general information on IANA, ICANN, APNIC, ARIN, LACNIC, and RIPE NCC, try a can of alphabet soup—or <a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a>, which provides an overview of the Internet registration authorities.</p></div>
<div class="chapter" title="Chapter&#xA0;17.&#xA0;CLASSFUL (CONVENTIONAL) ADDRESSING"><div class="titlepage"><div><div><h1 class="title"><a id="classful_conventional_addressing"/>Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e16379"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>The original addressing method for IP addresses divided the IP address space into five chunks of different sizes called <span class="emphasis"><em>classes</em></span>, and assigned blocks of addresses to organizations from these classes based on the size and requirements of the organization. In this classful addressing scheme, each class is reserved for a particular purpose, with the main address classes differentiated based on how many octets are used for the network identifier (network ID) and how many are used for the host identifier (host ID).</p><p>In this chapter, I describe classful IP addressing. I begin with an overview of the concept and general description of the different classes. I discuss the network and host IDs and address ranges associated with the different classes. I discuss the capacities of each of the commonly used classes, meaning how many networks belong to each and how many hosts each network can contain. I discuss the special meanings assigned to certain IP address patterns and the special ranges reserved for private IP addressing, loopback functions, and multicasting. I conclude with a discussion of the problems with this type of addressing, which led to it being abandoned in favor of subnetting, and eventually, classless assignment of the <a class="indexterm" id="idx-CHP-17-0676"/>IP address space.</p><div class="note" title="Note"><h3 class="title"><a id="note-64"/>Note</h3><p><span class="emphasis"><em>The classful addressing scheme has been replaced by the classless addressing system described in <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>. However, I think it is still important to understand how this original system operates, as it forms the basis for the more sophisticated addressing mechanisms.</em></span></p></div><div class="sect1" title="IP Classful Addressing Overview and Address Classes"><div class="titlepage"><div><div><h1 class="title"><a id="ip_classful_addressing_overview_and_addr"/>IP Classful Addressing Overview and Address Classes</h1></div></div></div><p>The developers of the Internet Protocol (IP) recognized that organizations come in different sizes and would therefore need varying numbers of <a class="indexterm" id="idx-CHP-17-0677"/>IP addresses on the Internet. They devised a system to divide the IP address space into <span class="emphasis"><em>classes</em></span>, each of which contained a portion of the total addresses and was dedicated to specific uses. Some classes would be devoted to large networks on the Internet, while others would be reserved for smaller organizations or special purposes.<a class="indexterm" id="idx-CHP-17-0678"/></p><p>This original system had no name; it was simply "the" IP addressing system. Today it is called the <span class="emphasis"><em>classful addressing scheme</em></span> to differentiate it from the newer classless scheme.</p><div class="sect2" title="IP Address Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ip_address_classes"/>IP Address Classes</h2></div></div></div><p>There are five classes in the classful system, which are assigned the letters A through E. <a class="xref" href="ch17.html#ip_address_classes_and_class_characteris" title="Table 17-1. IP Address Classes and Class Characteristics and Uses">Table 17-1</a> provides some general information about the classes, their intended uses, and their characteristics.<a class="indexterm" id="idx-CHP-17-0679"/></p><div class="table"><a id="ip_address_classes_and_class_characteris"/><p class="title">Table 17-1. IP Address Classes and Class Characteristics and Uses</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IP Address Classes and Class Characteristics and Uses"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Address Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Fraction of Total IP Address Space</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Number of Network ID Bits</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Number of Host ID Bits</p></th><th style="border-bottom: 0.5pt solid ; "><p>Intended Use</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class A</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>24</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unicast addressing for very large organizations with hundreds of thousands or millions of hosts to connect to the Internet</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class B</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unicast addressing for medium to large organizations with many hundreds to thousands of hosts to connect to the Internet</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class C</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unicast addressing for smaller organizations with no more than about 250 hosts to connect to the Internet</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class D</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>n/a</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>n/a</p></td><td style="border-bottom: 0.5pt solid ; "><p>IP multicasting</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Class E</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>1/16</p></td><td style="border-right: 0.5pt solid ; "><p>n/a</p></td><td style="border-right: 0.5pt solid ; "><p>n/a</p></td><td style=""><p>Reserved for experimental use</p></td></tr></tbody></table></div></div><p>Looking at this table (and <a class="xref" href="ch17.html#division_of_ipv4_address_space_into_clas" title="Figure 17-1. Division of IPv4 address space into classes">Figure 17-1</a>), you can see that Classes A, B, and C take up most of the total address space (seven-eighths of it). These are the classes used for <span class="emphasis"><em>unicast</em></span> IP addressing and messages sent to a single network interface. (The blocks also include associated broadcast addresses for these networks.) This is what I usually consider normal IP addressing.<a class="indexterm" id="idx-CHP-17-0680"/></p><div class="figure"><a id="division_of_ipv4_address_space_into_clas"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e16557"/><img alt="Division of IPv4 address space into classes" src="httpatomoreillycomsourcenostarchimages287801.png.jpg"/></div></div><p class="title">Figure 17-1. Division of IPv4 address space into classes</p></div><p>You can think of Classes A, B, and C as the papa bear, mama bear, and baby bear of traditional <a class="indexterm" id="idx-CHP-17-0681"/>IP addressing. They allow the Internet to provide addressing for a small number of very large networks, a moderate number of medium-sized organizations, and a large number of smaller companies. This approximately reflects the distribution of organization sizes in the real world, though the large gulf in the maximum number of hosts allowed for each address class leads to inflexibility, as I will discuss later in the chapter.</p><p>As you can see, the classes differ in where they draw the line between the network ID and the host ID portions of the addresses they contain. However, in each case, the division is made on octet boundaries. In classful addressing, the division does not occur within an octet.</p><p>Classes D and E are special—to the point where many people don't even realize they exist. Class D is used for IP multicasting, while Class E is reserved for experimental use (by designers of the Internet). I discuss IP multicast addressing later in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-88"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The classful IP addressing scheme divides the IP address space into five classes, A through E, of differing sizes. Classes A, B, and C are the most important ones, designated for conventional unicast addresses and taking up seven-eighths of the address space. Class D is reserved for IP multicasting, and Class E is reserved for experimental use.</p></div></div><div class="sect2" title="Rationale for Classful Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="rationale_for_classful_addressing"/>Rationale for Classful Addressing</h2></div></div></div><p>While the drawbacks of the classful system are often discussed today (as you'll see later in this chapter), it's important to keep in context what the size of the Internet was when this system was developed. The Internet was tiny then, and the 32-bit address space seemed enormous by comparison to even the number of machinesits creators envisioned years into the future. It's only fair to also remember the following advantages of the <a class="indexterm" id="idx-CHP-17-0682"/>classful system developed over 25 years ago:<a class="indexterm" id="idx-CHP-17-0683"/></p><p><span class="strong"><strong>Simplicity and Clarity</strong></span> There are only a few classes to choose from, and it's very simple to understand how the addresses are split up. The distinction between classes is clear and obvious. The divisions between network ID and host ID in Classes A, B, and C are on octet boundaries, making it easy to tell what the network ID is of any address.</p><p><span class="strong"><strong>Reasonable Flexibility</strong></span> Three levels of granularity match the sizes of large, medium-sized, and small organizations reasonably well. The original system provided enough capacity to handle the anticipated growth rate of the Internet at the time.</p><p><span class="strong"><strong>Routing Ease</strong></span> As you will see shortly, the class of the address is encoded right into the address to make it easy for routers to know what part of any address is the network ID and what part is the host ID. There was no need for adjunct information such as a subnet mask.</p><p><span class="strong"><strong>Reserved Addresses</strong></span> Certain addresses are reserved for special purposes. This includes not just Classes D and E, but also special reserved address ranges for private addressing.</p><p>Of course, it turned out that some of the decisions in the original <a class="indexterm" id="idx-CHP-17-0684"/>IP addressing scheme were regrettable—but that's the benefit of hindsight. I'm sure we would all like to have back the 268-odd million addresses that were set aside for Class E. While it may seem wasteful now to have reserved a full one-sixteenth of the address space for experimental use, remember that the current size of the Internet was never anticipated even 10 years ago, never mind 25. Furthermore, it's good practice to reserve some portion of any scarce resource for future use.</p></div></div></div>
<div class="sect1" title="IP Classful Addressing Network and Host Identification and Address Ranges"><div class="titlepage"><div><div><h1 class="title"><a id="ip_classful_addressing_network_and_host_"/>IP Classful Addressing Network and Host Identification and Address Ranges</h1></div></div></div><p>The classful IP addressing scheme divides the total IP address space into five classes, A through E. One of the benefits of the relatively simple classful scheme is that information about the classes is encoded directly into the IP address. This means you can determine in advance which address ranges belong to each class. It also means the opposite is possible: You can identify which class is associated with any address by examining just a few bits of the address. This latter benefit was one of the main motivators for the initial creation of the classful system.<a class="indexterm" id="idx-CHP-17-0685"/></p><div class="sect2" title="Classful Addressing Class Determination Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="classful_addressing_class_determination_"/>Classful Addressing Class Determination Algorithm</h2></div></div></div><p>When TCP/IP was first created, computer technology was still in its infancy. Routers needed to be able to quickly make decisions about how to move IP datagrams around. The IP address space was split into classes in such a way that, by looking at only the first few bits of any IP address, the router could easily tell how to choose between the network and host ID, and thus what to do with the datagram.<a class="indexterm" id="idx-CHP-17-0686"/></p><p>The number of bits the router needs to look at may be as few as one or as many as four, depending on what it finds when it starts looking. The algorithm used to determine the class corresponds to the system used to divide the address space, as illustrated in <a class="xref" href="ch17s02.html#class_determination_algorithm_for_classf" title="Figure 17-2. Class determination algorithm for classful IP addresses The simplicity of the classful IP addressing can be seen in the very uncomplicated algorithm used to determine the class of an address.">Figure 17-2</a>.</p><div class="figure"><a id="class_determination_algorithm_for_classf"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e16640"/><img alt="Class determination algorithm for classful IP addresses The simplicity of the classful IP addressing can be seen in the very uncomplicated algorithm used to determine the class of an address." src="httpatomoreillycomsourcenostarchimages287803.png.jpg"/></div></div><p class="title">Figure 17-2. Class determination algorithm for classful IP addresses The simplicity of the classful IP addressing can be seen in the very uncomplicated algorithm used to determine the class of an address.</p></div><p>Here are the four very basic steps in the algorithm:<a class="indexterm" id="idx-CHP-17-0687"/><a class="indexterm" id="idx-CHP-17-0688"/><a class="indexterm" id="idx-CHP-17-0689"/><a class="indexterm" id="idx-CHP-17-0690"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the first bit is a 0, it's a Class A address, and you're done. (Half the address space has a 0 for the first bit, so this is why Class A takes up half the address space.) If it's a 1, continue to step 2.</p></li><li class="listitem"><p>If the second bit is a 0, it's a Class B address, and you're done. (Half of the remaining non–Class A addresses, or one quarter of the total.) If it's a 1, continue to step 3.</p></li><li class="listitem"><p>If the third bit is a 0, it's a Class C address, and you're done. (Half again of what's left, or one-eighth of the total.) If it's a 1, continue to step 4.</p></li><li class="listitem"><p>If the fourth bit is a 0, it's a Class D address. (Half the remainder, or one-sixteenth of the address space.) If it's a 1, it's a Class E address. (The other half, one-sixteenth.)</p></li></ol></div><p>And that's pretty much it.</p></div><div class="sect2" title="Determining Address Class from the First Octet Bit Pattern"><div class="titlepage"><div><div><h2 class="title"><a id="determining_address_class_from_the_first"/>Determining Address Class from the First Octet Bit Pattern</h2></div></div></div><p>As humans, of course, we generally work with addresses in dotted decimal notation and not in binary, but it's pretty easy to see the ranges that correspond to the classes. For example, consider Class B. The first two bits of the first octet are 10. The remaining bits can be any combination of ones and zeros. This is normally represented as 10xx xxxx (shown as two groups of four for readability). Thus, the binary for the first octet can range from <span class="strong"><strong>10</strong></span>00 0000 to <span class="strong"><strong>10</strong></span>11 1111 (128 to 191 in decimal). So in the classful scheme, any IP address whose first octet is between 128 and 191 inclusive is a Class B address.<a class="indexterm" id="idx-CHP-17-0691"/></p><p><a class="xref" href="ch17s02.html#ip_address_class_bit_patterns_first-octe" title="Table 17-2. IP Address Class Bit Patterns, First-Octet Ranges, and Address Ranges">Table 17-2</a> shows the <a class="indexterm" id="idx-CHP-17-0692"/>bit patterns for each of the five classes and the way that the first octet ranges can be calculated. The first column shows the format of the first octet of the IP address; the <span class="emphasis"><em>x</em></span>s can be either a zero or a one. Next are the lowest and highest value columns for each class in binary (the fixed few bits are in bold print so you can see that they do not change while the others do), followed by the corresponding range for the first octet, in decimal.</p><div class="table"><a id="ip_address_class_bit_patterns_first-octe"/><p class="title">Table 17-2. IP Address Class Bit Patterns, First-Octet Ranges, and Address Ranges</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IP Address Class Bit Patterns, First-Octet Ranges, and Address Ranges"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Address Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>First Octet of IP Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lowest Value of First Octet (Binary)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Highest Value of First Octet (Binary)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Range of First Octet Values (Decimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octets in Network ID/Host ID</p></th><th style="border-bottom: 0.5pt solid ; "><p>Theoretical IP Address Range</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class A</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>0</strong></span>xxx xxxx</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>0</strong></span>000 0001</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>0</strong></span>111 1110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1 to 126</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1 / 3</p></td><td style="border-bottom: 0.5pt solid ; "><p>1.0.0.0 to 126.255.255.255</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class B</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>10</strong></span>xx xxxx</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>10</strong></span>00 0000</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>10</strong></span>11 1111</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128 to 191</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2 / 2</p></td><td style="border-bottom: 0.5pt solid ; "><p>128.0.0.0 to 191.255.255.255</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class C</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>110</strong></span>x xxxx</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>110</strong></span>0 0000</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>110</strong></span>1 1111</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192 to 223</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3 / 1</p></td><td style="border-bottom: 0.5pt solid ; "><p>192.0.0.0 to 223.255.255.255</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class D</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>1110</strong></span> xxxx</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>1110</strong></span> 0000</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>1110</strong></span> 1111</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>224 to 239</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>224.0.0.0 to 239.255.255.255</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Class E</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>1111</strong></span> xxxx</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>1111</strong></span> 0000</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>1111</strong></span> 1111</p></td><td style="border-right: 0.5pt solid ; "><p>240 to 255</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style=""><p>240.0.0.0 to 255.255.255.255</p></td></tr></tbody></table></div></div><p>This table also shows the <span class="emphasis"><em>theoretical</em></span> lowest and highest IP address ranges for each of the classes. This means that they are the result of taking the full span of binary numbers possible in each class. In reality, some of the values are not available for normal use. For example, even though the range 192.0.0.0 to 192.0.0.255 is technically in Class C, it is reserved and not actually used by hosts on the Internet.</p><p>Also, certain IP addresses cannot be used because they have special meaning. For example, 255.255.255.255 is a reserved broadcast address. In a similar vein, note that the range for Class A is from 1 to 126 and not 0 to 127 as you might have expected. This is because Class A networks 0 and 127 are reserved; 127 is the network that contains the IP loopback address. These special and reserved addresses are discussed later in this chapter.</p><p>Recall that Classes A, B, and C differ in where the dividing line is between the network ID and the host ID: 1 for network and 3 for host for Class A, 2 for each for Class B, and 3 for network and 1 for host for Class C. Based on this division, in <a class="xref" href="ch17s02.html#ip_address_class_bit_patterns_first-octe" title="Table 17-2. IP Address Class Bit Patterns, First-Octet Ranges, and Address Ranges">Table 17-2</a>, I have highlighted the network ID portion of the IP address ranges for each of Classes A, B, and C. The plain text corresponds to the range of host IDs for each allowable network ID. <a class="xref" href="ch17s02.html#ip_address_class_bit_assignments_and_net" title="Figure 17-3. IP address class bit assignments and network/host ID sizes This illustration shows how the 32 bits of IP address are assigned for each of the five IP address classes. Classes A, B, and C are the normal classes used for regular unicast addresses; each has a different dividing point between the network ID and host ID. Classes D and E are special and are not divided in this manner.">Figure 17-3</a> shows graphically how bits are used in each of the five classes.</p><div class="figure"><a id="ip_address_class_bit_assignments_and_net"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e16900"/><img alt="IP address class bit assignments and network/host ID sizes This illustration shows how the 32 bits of IP address are assigned for each of the five IP address classes. Classes A, B, and C are the normal classes used for regular unicast addresses; each has a different dividing point between the network ID and host ID. Classes D and E are special and are not divided in this manner." src="httpatomoreillycomsourcenostarchimages287805.png.jpg"/></div></div><p class="title">Figure 17-3. IP address class bit assignments and network/host ID sizes This illustration shows how the 32 bits of IP address are assigned for each of the five IP address classes. Classes A, B, and C are the normal classes used for regular unicast addresses; each has a different dividing point between the network ID and host ID. Classes D and E are special and are not divided in this manner.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-89"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the classful IP addressing scheme, the class of an IP address is identified by looking at the first one, two, three, or four bits of the address. This can be done both by humans working with these addresses and routers making routing decisions. The use of these bit patterns means that IP addresses in different classes fall into particular address ranges that allow an address's class to be determined by looking at the first byte of its dotted decimal address.<a class="indexterm" id="idx-CHP-17-0693"/></p></div><p>For example, consider Class C. The lowest IP address is <span class="strong"><strong>192.0.0</strong></span>.0, and the highest is <span class="strong"><strong>223.255.255</strong></span>.255. The first three octets are the network ID and can range from <span class="strong"><strong>192.0.0</strong></span> to <span class="strong"><strong>223.255.255</strong></span>. For each network ID in that range, the host ID can range from 0 to 255.</p><div class="note" title="Note"><h3 class="title"><a id="note-65"/>Note</h3><p><span class="emphasis"><em>It is common to see resources refer to the network ID of a classful address as including only the significant bits; that is, only the ones that are not common to all networks of that class. For example, you may see a Class B network ID shown in a diagram as having 14 bits, with the 10 that starts all such networks shown separately, as if it were not part of the network ID. Remember that the network ID does include those bits as well; it is 8 full bits for Class A, 16 for Class B, and 24 for Class C. In the case of Class D addresses, all 32 bits are part of the address, but only the lower 28 bits are part of the multicast group address; see the topic on multicast addressing later in this chapter for more</em></span>.</p></div></div></div>
<div class="sect1" title="IP Address Class A, B, and C Network and Host Capacities"><div class="titlepage"><div><div><h1 class="title"><a id="ip_address_class_a_b_and_c_network_and_h"/>IP Address Class A, B, and C Network and Host Capacities</h1></div></div></div><p>So far, I have introduced the concepts of IP address classes and showed how the classes relate to ranges of IP addresses. Of the five classes, D and E are dedicated to special purposes, so I will leave those alone for now. Classes A, B, and C are the ones actually assigned for normal (unicast) addressing purposes on IP internetworks, and therefore they are the primary focus of our continued attention.</p><p>As you've seen, the classes differ in the number of bits (and octets) used for the network ID compared to the host ID. The number of different networks possible in each class is a function of the number of bits assigned to the network ID, and likewise, the number of hosts possible in each network depends on the number of bits provided for the host ID. You must also take into account the fact that one, two, or three of the bits in the IP address are used to indicate the class itself, so it is effectively excluded from use in determining the number of networks (though again, it is still part of the network ID).</p><p>Based on this information, you can calculate the number of networks in each class, and for each class, the number of host IDs per network. <a class="xref" href="ch17s03.html#ip_address_class_network_and_host_capaci" title="Table 17-3. IP Address Class Network and Host Capacities">Table 17-3</a> shows the calculations.</p><div class="table"><a id="ip_address_class_network_and_host_capaci"/><p class="title">Table 17-3. IP Address Class Network and Host Capacities</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IP Address Class Network and Host Capacities"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Address Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Total # of Bits for Network ID/Host ID</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>First Octet of IP Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Network ID Bits Used To Identify Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Usable # of Network ID Bits</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Number of Possible Network IDs</p></th><th style="border-bottom: 0.5pt solid ; "><p># of Host IDs Per Network ID</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class A</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8/24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xxx xxxx</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8-1 = 7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>7</sup>-2 = 126</p></td><td style="border-bottom: 0.5pt solid ; "><p>2<sup>24</sup>-2 = 16,277,214</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Class B</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16/16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10xx xxxx</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16-2 = 14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>14</sup> = 16,384</p></td><td style="border-bottom: 0.5pt solid ; "><p>2<sup>16</sup>-2 = 65,534</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Class C</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>24/8</p></td><td style="border-right: 0.5pt solid ; "><p>110x xxxx</p></td><td style="border-right: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; "><p>24-3 = 21</p></td><td style="border-right: 0.5pt solid ; "><p>2<sup>21</sup> = 2,097,152</p></td><td style=""><p>2<sup>8</sup>-2 = 254</p></td></tr></tbody></table></div></div><p>Let's walk through one line of this table so you can see how it works using Class B as an example. The basic division is into 16 bits for network ID and 16 bits for host ID. However, the first 2 bits of all Class B addresses must be 10, so that leaves only 14 bits to uniquely identify the network ID. This gives us a total of 2<sup>14</sup> or 16,384 Class B network IDs. For each of these, you have 2<sup>16</sup> host IDs, less two, for a total of 65,534.<a class="indexterm" id="idx-CHP-17-0694"/></p><p>Why less two? For each network ID, two host IDs cannot be used: the host ID with all zeros and the ID with all ones. These are addresses with special meanings, as described in the next section. Also notice that two is subtracted from the number of network IDs for Class A. This is because two of the Class A network IDs (0 and 127) are reserved.</p><p>Several other address ranges are set aside in all three of the classes shown here. They are listed in the "IP Reserved, Private, and Loopback Addresses" section later in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-90"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the classful IP addressing scheme, a Class A network contains addresses for about 16 million network interfaces; a Class B network contains about 65,000; and a Class C network contains 254.</p></div><p>As you can see, there is quite a disparity in the number of hosts available for each network in each of these classes. What happens if an organization needs 1,000 <a class="indexterm" id="idx-CHP-17-0695"/>IP addresses? It must use either four Class Cs or one Class B (and in so doing, waste over 90 percent of the possible addresses in the Class B network). Bear in mind that there are only about 16,000 Class B network IDs available worldwide, and you begin to understand one of the big problems with classful addressing.</p></div>
<div class="sect1" title="IP Addresses with Special Meanings"><div class="titlepage"><div><div><h1 class="title"><a id="ip_addresses_with_special_meanings"/>IP Addresses with Special Meanings</h1></div></div></div><p>Some IP addresses do not refer directly to specific hardware devices; instead, they are used to refer indirectly to one or more devices. To draw an analogy with language, most IP addresses refer to proper nouns, like "John" or "the red table in the corner." However, some are used more the way you use pronouns such as "this one" or "that group over there." I call these IP addresses with <span class="emphasis"><em>special meanings</em></span>.</p><p>These special addresses are constructed by replacing the normal network ID or host ID (or both) in an IP address with one of two special patterns:</p><p><span class="strong"><strong>All Zeros</strong></span> When the network ID or host ID bits are replaced by a set of all zeros, the special meaning is the equivalent of the pronoun <span class="emphasis"><em>this</em></span>, referring to whatever was replaced. It can also be interpreted as <span class="emphasis"><em>the default</em></span> or the <span class="emphasis"><em>current</em></span>. For example, if you replace the network ID with all zeros but leave the host ID alone, the resulting address means "the device with the host ID given, on <span class="emphasis"><em>this network</em></span>,"or "the device with the host ID specified, on <span class="emphasis"><em>the default network</em></span> or <span class="emphasis"><em>the current network</em></span>."</p><p><span class="strong"><strong>All Ones</strong></span> When the network ID or host ID bits are replaced by a set of all ones, this has the special meaning of <span class="emphasis"><em>all</em></span>, meaning that the IP address refers to all hosts on the network. This is generally used as a broadcast address for sending a message to everyone.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-91"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> When the network ID or host ID of an IP address is replaced by a pattern of all ones or all zeros, the result is an address with a special meaning. Examples of such addresses include "all hosts" broadcast addresses and addresses that refer to a specific host or a whole network.</p></div><p>There are many special addresses. A small number apply to the entire TCP/IP network, while others exist for each network or host ID. Since two special patterns can be applied to the network ID, host ID, or both, there are six potential combinations, each of which has its own meaning. Of these, five are used.</p><p><a class="xref" href="ch17s04.html#ip_address_patterns_with_special_meaning" title="Table 17-4. IP Address Patterns with Special Meanings">Table 17-4</a> describes each of these special meanings and includes examples from Class A, B, and C. Note how an IP address in each of the common classes can be modified to have special meaning forms. (The first row shows the examples in their normal form, for reference.)</p><div class="table"><a id="ip_address_patterns_with_special_meaning"/><p class="title">Table 17-4. IP Address Patterns with Special Meanings</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IP Address Patterns with Special Meanings"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Network ID</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Host ID</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class A Example</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class B Example</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class C Example</p></th><th style="border-bottom: 0.5pt solid ; "><p>Special Meaning and Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Network ID</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Host ID</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>77.91.215.5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>154.3.99.6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>227.82.157.160</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Normal Meaning</strong></span>: Refers to a specific device.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Network ID</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>All Zeros</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>77.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>154.3.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>227.82.157.0</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>The Specified Network</strong></span>: This notation, <a class="indexterm" id="idx-CHP-17-0696"/>with a 0 at the end of the address, refers to an entire network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>All Zeros</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Host ID</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.91.215.5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.0.99.6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.0.0.160</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Specified Host on This Network</strong></span>: This addresses a host on the current or default network when the network ID is not known or when it doesn't need to be explicitly stated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>All Zeros</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>All Zeros</strong></span></p></td><td colspan="3" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.0.0.0</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Me</strong></span>: Used by a device to refer to itself when it doesn't know its own IP address. (Alternatively, "this host," or "the current/default host.") The most common use is when a device attempts to determine its address using a host-configuration protocol like DHCP. May also be used to indicate that any address of a multihomed host may be used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Network ID</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>All Ones</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>77.255.255.255</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>154.3.255.255</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>227.82.157.255</p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>All Hosts on the Specified Network</strong></span>: Used for broadcasting to all hosts on the local network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>All Ones</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>All Ones</strong></span></p></td><td colspan="3" style="border-right: 0.5pt solid ; "><p>255.255.255.255</p></td><td style=""><p><span class="strong"><strong>All Hosts on the Network</strong></span>: Specifies a global broadcast to all hosts on the directly connected network. Note that there is no address that would imply sending to all hosts everywhere on the global Internet, since this would be very inefficient and costly.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-66"/>Note</h3><p><span class="emphasis"><em>The missing combination from <a class="xref" href="ch17s04.html#ip_address_patterns_with_special_meaning" title="Table 17-4. IP Address Patterns with Special Meanings">Table 17-4</a> is that of the network ID being all ones and the host ID normal. Semantically, this would refer to "all hosts of a specific ID on all networks," which doesn't really mean anything useful in practice, so it's not used. Note also that, in theory, a special address where the network ID is all zeros and the host ID is all ones would have the same meaning as the all-ones limited broadcast address. The latter is used instead, however, because it is more general, not requiring knowledge of where the division is between the network ID and the host ID</em></span>.</p></div><p>Since the all-zeros and all-ones patterns are reserved for these special meanings, they cannot be used for regular <a class="indexterm" id="idx-CHP-17-0697"/>IP addresses. This is why, when you looked at the number of hosts per network in each of the classes, you had to subtract two from the theoretical maximum: one for the all-zeros case and one for the all-ones case.<a class="indexterm" id="idx-CHP-17-0698"/></p><p>Similarly, the network ID cannot be all zeros either. However, this doesn't require specific exclusion because the entire block of addresses with 0 in the first octet (0.x.x.x) is one of the reserved sets of <a class="indexterm" id="idx-CHP-17-0699"/>IP addresses. These reserved addresses, described in the next section, further restrict the use of certain addresses in the IP address space for regular uses.</p></div>
<div class="sect1" title="IP Reserved, Private, and Loopback Addresses"><div class="titlepage"><div><div><h1 class="title"><a id="ip_reserved_private_and_loopback_address"/>IP Reserved, Private, and Loopback Addresses</h1></div></div></div><p>In addition to the unusable numbers with special meanings just discussed, several other sets of IP addresses have special uses, and are therefore not available for normal address assignment. These generally fall into three categories: reserved, private, and loopback addresses.</p><div class="sect2" title="Reserved Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="reserved_addresses"/>Reserved Addresses</h2></div></div></div><p>Several blocks of addresses were designated as reserved with no specific indication given as to what they were reserved for. Perhaps they were set aside for future experimentation or for internal use in managing the Internet. (In general, it's a good idea to set aside some portion of any <a class="indexterm" id="idx-CHP-17-0700"/>limited resource for unanticipated needs.)</p><p>A couple of these blocks appear in each of the three main classes (A, B, and C), at the beginning and end of each class. (All of Class D and E are also reserved, since they aren't used for regular addressing.)</p></div><div class="sect2" title="Private, Unregistered, Nonroutable Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="private_unregistered_nonroutable_address"/>Private, Unregistered, Nonroutable Addresses</h2></div></div></div><p>You'll recall that in the IP address overview in <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a>, I contrasted private and public IP addresses. Every IP address on an IP network must be unique. In the case of a public IP network, addresses are allocated by a central authority to ensure that there is no overlap. In contrast, on a private network, you can use whatever addresses you want.</p><p>Then why not just pick any random block of Class A, B, or C addresses for your private network and use that? You could, and some people did. For example, if you weren't connected to the Internet you could use, say, the Class A network 18.x.x.x that is reserved on the Internet to the <a class="indexterm" id="idx-CHP-17-0701"/>Massachusetts Institute of Technology (MIT). Since you aren't connected to MIT, you would think that wouldn't matter.</p><p>However, as the Internet grew, those disconnected private networks needed to connect to the public Internet after all, and then they had a conflict. If they used the 18.x.x.x addresses, they would have to renumber all their devices to avoid getting a big bunch of computer geeks really angry. (There were, in fact, cases where companies that had used IP address space belonging to other companies accidentally connected those machines to the Internet, causing a small amount of ruckus in the process.)</p><p>RFC 1918 (superseding RFC 1597) provided the solution. It defines a set of unroutable, special address blocks just for private addresses. These addresses simply don't exist on the public Internet. For this reason, they are not registered like other public addresses; they are sometimes called <span class="emphasis"><em>unregistered</em></span>. Anyone can use them, but they cannot connect to the Internet because routers are not programmed to forward traffic with these address ranges outside of local organizations. RFC 1918 was published to encourage the use of these private blocks in order to cut down on the number of devices on the public Internet that didn't really need to be publicly accessible. This was in response to the need to conserve the public address space.</p><div class="note" title="Note"><h3 class="title"><a id="note-67"/>Note</h3><p><span class="emphasis"><em>In order to connect a network using private addressing to the public Internet, it is necessary to employ additional hardware and software. A gateway machine can be used as an interface between the public and private networks. Technologies such as Network Address Translation (NAT; see <a class="xref" href="ch28.html" title="Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL">Chapter 28</a>) are often used in conjunction with private IP addresses to allow these hosts to communicate on the public IP network</em></span>.<a class="indexterm" id="idx-CHP-17-0702"/></p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-92"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Private address blocks were created to allow private IP Internets to be created using addresses that were guaranteed not to conflict with public IP addresses. They are commonly used in internetworks that aren't connected to the global Internet; devices using them can also access the global Internet by using NAT.</p></div></div><div class="sect2" title="Loopback Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="loopback_addresses"/>Loopback Addresses</h2></div></div></div><p>Normally, when a TCP/IP application wants to send information, that information travels down the protocol layers to IP, where it is encapsulated in an IP datagram. That datagram then passes down to the data link layer of the device's physical network for transmission to the next hop, on the way to the IP destination.<a class="indexterm" id="idx-CHP-17-0703"/></p><p>However, one special range of addresses, 127.0.0.0 to 127.255.255.255, is set aside for <span class="emphasis"><em>loopback</em></span> functionality. IP datagrams sent by a host to a 127.x.x.x loopback address are not passed down to the data link layer for transmission; instead, they loop back to the source device at the IP level. In essence, this short-circuits the normal protocol stack; data is sent by a device's layer 3 IP implementation and then immediately received by it.</p><p>This loopback range is used for testing the TCP/IP protocol implementation on a host. Since the lower layers are short-circuited, sending to a loopback address allows you to isolate and test the higher layers (IP and above) without interference from the lower layers. <a class="indexterm" id="idx-CHP-17-0704"/>127.0.0.1 is the address most commonly used for testing purposes.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-93"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Portions of the IP address space are set aside for reserved, private, and loopback addresses.</p></div></div><div class="sect2" title="Reserved, Private, and Loopback Addressing Blocks"><div class="titlepage"><div><div><h2 class="title"><a id="reserved_private_and_loopback_addressing"/>Reserved, Private, and Loopback Addressing Blocks</h2></div></div></div><p><a class="xref" href="ch17s05.html#reserved_private_and_loopback_ip_address" title="Table 17-5. Reserved, Private, and Loopback IP Addresses">Table 17-5</a> shows all of the special blocks set aside from the normal <a class="indexterm" id="idx-CHP-17-0705"/>IP address space in numerical order, with a brief explanation of how each is used. It lists both the classful and the classless notation representing each of these blocks because the Internet now uses classless addressing, and because some of the private blocks don't correspond to single Class A, B, or C networks.</p><p>Note especially the private address block from 192.168.0.0 to 192.168.255.255. This is the size of a Class B network, but it isn't Class B in the classful scheme, because the first octet of 192 puts it in the Class C part of the address space. It is actually 256 contiguous Class C networks.</p><p>You may also notice the special Class B (/16) block 169.254.x.x. This is <a class="indexterm" id="idx-CHP-17-0706"/>reserved for <span class="emphasis"><em>Automatic Private IP Addressing (APIPA)</em></span>, discussed in <a class="xref" href="ch64.html" title="Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT">Chapter 64</a>. Systems that are configured to use this feature will automatically assign systems addresses from this block to enable them to communicate even if no server can be found for proper IP address assignment using the Dynamic Host Control Protocol (DHCP).</p><div class="table"><a id="reserved_private_and_loopback_ip_address"/><p class="title">Table 17-5. Reserved, Private, and Loopback IP Addresses</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Reserved, Private, and Loopback IP Addresses"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Range Start Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Range End Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Classful Address Equivalent</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Classless Address Equivalent</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>0.0.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>0.255.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class A network 0.x.x.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>10.0.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>10.255.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class A network 10.x.x.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Class A private address block</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>127.0.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>127.255.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class A network 127.x.x.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>127/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Loopback address block</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>128.0.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>128.0.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class B network 128.0.x.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128.0/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>169.254.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>169.254.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class B network 169.254.x.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>169.254/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Class B private address block reserved for automatic private address allocation (see <a class="xref" href="ch64.html" title="Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT">Chapter 64</a> for details)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>172.16.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>172.31.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16 contiguous Class B networks from 172.16.x.x through 172.31.x.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>172.16/12</p></td><td style="border-bottom: 0.5pt solid ; "><p>Class B private address blocks</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>191.255.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>191.255.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class B network 191.255.x.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>191.255/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>192.0.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>192.0.0.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class C network 192.0.0.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.0.0/24</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>192.168.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>192.168.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>256 contiguous Class C networks from 192.168.0.x through 192.168.255.x</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.168/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Class C private address blocks</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>223.255.255.0</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>223.255.255.255</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>Class C network 223.255.255.x</p></td><td style="border-right: 0.5pt solid ; "><p>223.255.255/24</p></td><td style=""><p>Reserved</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="IP Multicast Addressing"><div class="titlepage"><div><div><h1 class="title"><a id="ip_multicast_addressing"/>IP Multicast Addressing</h1></div></div></div><p>The vast majority of traffic on IP internetworks is <span class="emphasis"><em>unicast</em></span>, which is one source device sending to one destination device. IP also supports <span class="emphasis"><em> multicasting</em></span>, which is a source device sending to a group of devices. Multicasting is not used a great deal on the present-day Internet, mainly due to a lack of widespread hardware support, though it is useful in certain circumstances, especially as a more efficient alternative to broadcasting.<a class="indexterm" id="idx-CHP-17-0707"/></p><p>The classful IP addressing scheme sets aside one-sixteenth of the address space for <a class="indexterm" id="idx-CHP-17-0708"/>multicast addresses as Class D. Multicast addresses are identified by the pattern 1110 in the first four bits, which corresponds to a first octet of 224 to 239. Thus, the full range of multicast addresses is from 224.0.0.0 to 239.255.255.255.</p><p>Since multicast addresses represent a group of IP devices (sometimes called a <span class="emphasis"><em>host group</em></span>), they can be used only as the destination of a datagram, never the source.</p><div class="sect2" title="Multicast Address Types and Ranges"><div class="titlepage"><div><div><h2 class="title"><a id="multicast_address_types_and_ranges"/>Multicast Address Types and Ranges</h2></div></div></div><p>The other 28 bits in the IP address define the <span class="emphasis"><em>multicast group address</em></span>. The size of the Class D multicast address space is therefore 2<sup>28</sup>, or 268,435,456 multicast <a class="indexterm" id="idx-CHP-17-0709"/>groups. No substructure defines the use of these 28 bits, and there is no specific concept of a network ID and host ID as in Class A, B, and C. However, certain portions of the address space are set aside for specific uses. <a class="xref" href="ch17s06.html#ip_multicast_address_ranges_and_uses" title="Table 17-6. IP Multicast Address Ranges and Uses">Table 17-6</a> and <a class="xref" href="ch17s06.html#ip_multicast_address_ranges_and_uses_all" title="Figure 17-4. IP Multicast address ranges and uses All multicast addresses begin with 1110. The well-known group has zeros for the first 20 bits of the multicast group address, with 8 bits available to define 255 special multicast addresses. Multicast addresses starting with 1110 1111 are locally scoped; all other addresses are globally scoped (this includes addresses starting with 1110 0000 other than the 255 well-known addresses).">Figure 17-4</a> show the general allocation of the Class D address space.<a class="indexterm" id="idx-CHP-17-0710"/><a class="indexterm" id="idx-CHP-17-0711"/></p><div class="table"><a id="ip_multicast_address_ranges_and_uses"/><p class="title">Table 17-6. IP Multicast Address Ranges and Uses</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IP Multicast Address Ranges and Uses"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Range Start Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Range End Address</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.255</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved for special well-known multicast addresses</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.1.0</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>238.255.255.255</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Globally scoped (Internetwide) multicast addresses.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>239.0.0.0</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>239.255.255.255</strong></span></p></td><td style=""><p>Administratively scoped (local) multicast addresses</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-68"/>Note</h3><p><span class="emphasis"><em>As with the other IP address classes, the entire 32 bits of the address is always used. It is only the least significant 28 bits that are interesting, because the upper four bits never change</em></span>.</p></div><div class="figure"><a id="ip_multicast_address_ranges_and_uses_all"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e17790"/><img alt="IP Multicast address ranges and uses All multicast addresses begin with 1110. The well-known group has zeros for the first 20 bits of the multicast group address, with 8 bits available to define 255 special multicast addresses. Multicast addresses starting with 1110 1111 are locally scoped; all other addresses are globally scoped (this includes addresses starting with 1110 0000 other than the 255 well-known addresses)." src="httpatomoreillycomsourcenostarchimages287807.png.jpg"/></div></div><p class="title">Figure 17-4. IP Multicast address ranges and uses All multicast addresses begin with 1110. The well-known group has zeros for the first 20 bits of the multicast group address, with 8 bits available to define 255 special multicast addresses. Multicast addresses starting with 1110 1111 are locally scoped; all other addresses are globally scoped (this includes addresses starting with 1110 0000 other than the 255 well-known addresses).</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-94"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>The concept of multicast address scope was more completely defined in IPv6, and I discuss it in more detail in the in the discussion of IPv6 multicast addresses in <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a></em></span>.</p></div><p>The bulk of the address space is in the middle multicast range. These are normal multicast addresses, like the Class A, B, and C unicast addresses, and they can be assigned to various groups.</p><p>The last address range is for <span class="emphasis"><em>administratively scoped</em></span> multicast groups. This is a fancy term for multicast groups used within a private organization. This block, representing one-sixteenth of the total multicast address space, is comparable to the private addresses you saw earlier in this chapter. It is further subdivided into site-local multicast addresses, organization-local addresses, and so forth.<a class="indexterm" id="idx-CHP-17-0712"/></p></div><div class="sect2" title="Well-Known Multicast Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="well-known_multicast_addresses"/>Well-Known Multicast Addresses</h2></div></div></div><p>The first block of 256 addresses is used to define special, <a class="indexterm" id="idx-CHP-17-0713"/>well-known multicast address blocks (<a class="xref" href="ch17s06.html#well-known_ip_multicast_addresses" title="Table 17-7. Well-Known IP Multicast Addresses">Table 17-7</a> has a selective listing). These do not represent arbitrary groups of devices and cannot be assigned in that manner. Instead, they have a special meaning that allows a source to send a message to a predefined group.<a class="indexterm" id="idx-CHP-17-0714"/></p><div class="table"><a id="well-known_ip_multicast_addresses"/><p class="title">Table 17-7. Well-Known IP Multicast Addresses</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Well-Known IP Multicast Addresses"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Range Start Address</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.0</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved; not used</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>All devices on the subnet</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.2</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>All routers on the subnet</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.3</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.4</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>All routers using DVMRP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.5</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>All routers using OSPF</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.6</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Designated routers using OSPF</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.9</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Designated routers using RIP-2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.11</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Mobile agents (for Mobile IP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>224.0.0.12</strong></span></p></td><td style=""><p>DHCP server/relay agent</p></td></tr></tbody></table></div></div><p>Delivery of IP multicast traffic is more complex than unicast traffic due to the existence of multiple recipients. Instead of the normal resolution method through the Address Resolution Protocol (ARP) used for unicast datagrams, the IP multicast group and a hardware multicast group are mapped.<a class="indexterm" id="idx-CHP-17-0715"/></p></div></div>
<div class="sect1" title="Problems with Classful IP Addressing"><div class="titlepage"><div><div><h1 class="title"><a id="problems_with_classful_ip_addressing"/>Problems with Classful IP Addressing</h1></div></div></div><p>The classful addressing system was the first major attempt to define a method for universal addressing of a large IP internetwork. There was a reasonable rationale for the system, as I mentioned in the overview of the classful scheme, and given that it was developed decades ago for a network that was limited in size, it did the job remarkably well for a long time.</p><p>No one ever expected the Internet to mushroom to anything close to its current size. As the Internet grew, the classful IP addressing mechanism showed some problems.</p><p>The three main problems with classful addressing are as follows:</p><p><span class="strong"><strong>Lack of Internal Address Flexibility</strong></span> Big organizations are assigned large, monolithic blocks of addresses that aren't a good match for the structure of their underlying internal networks.</p><p><span class="strong"><strong>Inefficient Use of Address Space</strong></span> The existence of only three block sizes (Classes A, B, and C) leads to a waste of limited IP address space.</p><p><span class="strong"><strong>Proliferation of Router Table Entries</strong></span> As the Internet grows, more and more entries are required for routers to route IP datagrams. This causes performance problems for routers. Attempting to reduce inefficient address space allocation leads to even more router table entries.</p><p>The first issue results primarily from the fact that in the classful system, big companies are assigned a rather large (Class B) or truly enormous (Class A) block of addresses. They are considered by the Internet routers to be a single network, with one network ID. Now imagine that you are running a medium-to-large-sized company with 5,000 computers, and you are assigned a Class B address for your network. Do you really have 5,000 computers all hooked into a single network? I sure as heck hope you don't! Yet you would be forced to try to fit all of these into a single IP network in the original classful method. There was no way to create an internal hierarchy of addresses.</p><p>The second and third issues both stem from the fact that the <a class="indexterm" id="idx-CHP-17-0716"/>granularity in the classful system is simply too low to be practical in a large internetwork; there are simply too few choices in the sizes of available networks. Three sizes seem fine in principle, but the gaps between the sizes are enormous, and the sizes don't match up well with the distribution of organizations in the real world. Consider the difference in size between Class C and Class B networks—a jump from 254 hosts all the way up to over 65,000! There are many, many companies that need more than 254 IP address but a lot fewer than 65,000. And what about Class A? How many companies need 16 <span class="emphasis"><em>million</em></span> IP addresses, even the truly large ones? Probably none, if you think about it, yet that's half the IP address space right there.</p><p>What class of network should the company with 5,000 computers use? As <a class="xref" href="ch17s07.html#the_main_problem_with_classful_addressin" title="Figure 17-5. The main problem with classful addressing In this scale diagram, each square represents 50 available addresses. Since a Class C address has only 254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000 hosts is caught in the middle. It can only choose to either waste 90 percent of a Class B address or use 20 different Class C networks.">Figure 17-5</a> shows, the classful scheme offers no good match for this company's needs. If it were assigned a Class B, over 90 percent of the IP addresses would be wasted.</p><p>The alternative to wasting all these IP addresses would be to give this fictitious company a bunch of Class C addresses instead of one Class B; but they would need 20 of them. While this would use the address space more efficiently, it leads to the third issue: Every router on the Internet then has to replace the single Class B router table entry with 20 Class C router entries. Multiply this by a few thousand medium-sized companies, and you can see that this method would add dramatically to the size of router tables. The larger these tables, the more time it takes for routers to make routing decisions.</p><div class="figure"><a id="the_main_problem_with_classful_addressin"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e17980"/><img alt="The main problem with classful addressing In this scale diagram, each square represents 50 available addresses. Since a Class C address has only 254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000 hosts is caught in the middle. It can only choose to either waste 90 percent of a Class B address or use 20 different Class C networks." src="httpatomoreillycomsourcenostarchimages287809.png.jpg"/></div></div><p class="title">Figure 17-5. The main problem with classful addressing In this scale diagram, each square represents 50 available addresses. Since a Class C address has only 254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000 hosts is caught in the middle. It can only choose to either waste 90 percent of a Class B address or use 20 different Class C networks.</p></div><p>The problems with classful addressing have been solved by three enhancements, as you'll see in later chapters. The first, which primarily addresses the first issue, was the development of subnetting. The second was the move to classless addressing and routing, which replaces the classful system with a new method with higher granularity. This tackles the second and third issues by letting addresses be assigned based on real organizational needs, without requiring numerous routing table entries for each organization. The third improvement is the new IP version 6 (IPv6), which finally does away with the cramped 32-bit IP address space in favor of a gargantuan 128-bit one.</p><p>Other support technologies, such as NAT, have helped to extend the life of IPv4 by allowing multiple devices to share public addresses. This alone has added years to the life of the IPv4 addressing system.</p></div>
<div class="chapter" title="Chapter&#xA0;18.&#xA0;IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnet_addressing_subnetting_concepts"/>Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e17994"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> In the previous chapter, we looked at the original classful IP addressing scheme, which conceptually divides a large internetwork into a simple two-level hierarchy that includes many <span class="emphasis"><em>networks</em></span> of different sizes, each of which contains a number of <span class="emphasis"><em>hosts</em></span>. The system works well for smaller organizations that may connect all their machines in a single network. However, it lacks flexibility for large organizations that often have many subnetworks, or <span class="emphasis"><em>subnets</em></span>. To better meet the administrative and technical requirements of larger organizations, the classful IP addressing system was enhanced through a technique known as <span class="emphasis"><em>subnet addressing</em></span>, or more simply, <a class="indexterm" id="idx-CHP-18-0717"/><span class="emphasis"><em>subnetting</em></span>.</p><p>In this chapter, I describe the concepts and general techniques associated with IP subnet addressing. I begin with an overview of subnetting, including a discussion of the motivation for the system and its advantages. I discuss how the traditional two-level method for dividing IP addresses becomes three-level for subnetting. I talk about subnet masks and how they are used in calculations for addressing and routing. I discuss the default subnet masks used to represent the classful Class A, B, and C networks in a subnetting environment and then how custom subnet masks are used for these classes. I then discuss subnet identifiers and general concepts behind determining subnet and host addresses in a subnet environment. I provide summary tables for <a class="indexterm" id="idx-CHP-18-0718"/>subnetting Class A, B, and C networks. I conclude with a brief discussion of <span class="emphasis"><em>Variable Length Subnet Masking (VLSM)</em></span>, an enhancement of conventional subnetting that improves its flexibility further.</p><div class="note" title="Note"><h3 class="title"><a id="note-69"/>Note</h3><p><span class="emphasis"><em>I provide a great deal of coverage of subnetting, because understanding it is an important part of learning about how IP addresses work, and hence, how TCP/IP functions. However, the technique is today considered mostly</em></span> historical <span class="emphasis"><em>because it is based on classful addressing. The concept of a subnet and subnet mask has certainly not disappeared, but the idea of being assigned a Class A, B, or C Internet address block and then explicitly subnetting it is no longer relevant</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-95"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>This is the first of two chapters dedicated to IP address subnetting. <a class="xref" href="ch19.html" title="Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE">Chapter 19</a> describes the step-by-step process for subnetting using examples. If you find that after reading this concepts section that you don't quite understand subnetting, try reading the example-based section, and you may find that it helps make it all click. On the other hand, if you are already somewhat familiar with subnetting, you may find that you can skip this concepts section and just go through the step-by-step examples. You will find much more in that chapter in the way of gory details of subnet mask, subnet address, and host address calculations. Putting the practical details there allows this section to concentrate on concepts without getting too bogged down in numbers</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-96"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>Understanding subnetting requires familiarity with binary numbers and how they are manipulated. This includes the concept of using boolean operators such as</em></span> AND <span class="emphasis"><em>to "mask" binary digits. If reading that last sentence made you go "huh?" I strongly recommend reviewing the background section on computing mathematics (<a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a>) before you proceed</em></span>.</p></div><div class="sect1" title="IP Subnet Addressing Overview, Motivation, and Advantages"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnet_addressing_overview_motivation"/>IP Subnet Addressing Overview, Motivation, and Advantages</h1></div></div></div><p>As I discussed in the previous chapter, IP addressing was originally designed around the assumption of a strict two-level hierarchy for internetworks: the first level was the network, and the second level the host. Each organization was usually represented by a single network identifier (network ID) that indicated a Class A, B, or C block dedicated to them. Within that network, the organization needed to put all of the devices it wanted to connect to the public IP network.</p><p>It did not take long after this scheme was developed for serious inadequacies in it to be noticed, especially by larger organizations. In order to address this problem, RFC 950 [1985] defined a new addressing procedure called <span class="emphasis"><em>subnet addressing</em></span> or <span class="emphasis"><em>subnetting</em></span>.</p><p>Subnet addressing adds an additional hierarchical level to the way IP addresses are interpreted: Instead of having just hosts, the network has <span class="emphasis"><em>subnets</em></span> and hosts. Each subnet is a subnetwork, and functions much the way a full network does in conventional classful addressing. A three-level hierarchy is thus created: networks, which contain subnets, each of which then has a number of hosts. Thus, an organization can organize hosts into subnets that reflect the way internal networks are structured. In essence, subnet addressing allows each organization to have its own internetwork within the Internet. This change brought numerous advantages over the old system, such as the following:</p><p><span class="strong"><strong>Better Match to Physical Network Structure</strong></span> Hosts can be grouped into subnets that reflect the way they are actually structured in the organization's physical network.</p><p><span class="strong"><strong>Flexibility</strong></span> The number of subnets and number of hosts per subnet can be customized for each organization. Each can decide on its own subnet structure and change it as required.</p><p><span class="strong"><strong>Invisibility to Public Internet</strong></span> Subnetting was implemented so that the internal division of a network into subnets is visible only within the organization. To the rest of the Internet, the organization is still just one big, flat network. This also means that any changes made to the internal structure are not visible outside the organization.</p><p><span class="strong"><strong>No Need to Request New IP Addresses</strong></span> Organizations don't need to constantly requisition more IP addresses, as they would in the workaround of using multiple small Class C blocks.</p><p><span class="strong"><strong>No Routing Table Entry Proliferation</strong></span> Since the subnet structure exists only within the organization, routers outside that organization know nothing about it. The organization still maintains a single (or perhaps a few) routing table entries for all of its devices. Only routers inside the organization need to worry about routing between subnets.</p><p>The change to subnetting affects both addressing and routing in IP networks. Addressing changes because, instead of having just a network ID and host ID, you now also have a <span class="emphasis"><em>subnet ID</em></span> to be concerned with. The size of the subnet ID can vary for each network, so an additional piece of information is needed to supplement the IP address to indicate what part of the address is the subnet ID and what part is the host ID. This is a 32-bit number commonly called a <span class="emphasis"><em>subnet mask</em></span>. The mask is used both for calculating subnet and host addresses, and by routers for determining how to move IP datagrams around a subnetted network.</p><p>Routing changes because of the additional level of hierarchy. In regular classful addressing, when a router receives an IP datagram, it only needs to decide if the destination is on the same network or a different network. Under subnetting, it must also look at the subnet ID of the destination and make one of three choices: same subnet, different subnet on the same network, or different network. Changes are also required to routing protocols, such as the Routing Information Protocol (RIP; see <a class="xref" href="ch38.html" title="Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)">Chapter 38</a>), to deal with subnets and subnet masks.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-97"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Subnet addressing adds an additional hierarchical level to how IP addresses are interpreted by dividing an organization's IP network into subnets. This allows each organization to structure its address space to match its internal physical networks, rather than being forced to treat them a flat block. This solves a number of problems with the original classful addressing scheme, but requires changes to how addressing and routing work, as well as modifications to several TCP/IP protocols.</p></div><p>It's funny, but the main drawbacks to subnetting, compared with the older addressing scheme, have more to do with understanding how subnetting works than with the technology itself. More effort is required to deal with addressing and routing in a subnet environment, and administrators must learn how to subdivide their network into subnets and properly assign addresses. This can be a bit confusing to someone who is new to subnetting. However, the technology today is quite well established, so even this is not much of a problem.</p></div></div>
<div class="sect1" title="IP Subnetting: Three-Level Hierarchical IP Subnet Addressing"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_three-level_hierarchical_i"/>IP Subnetting: Three-Level Hierarchical IP Subnet Addressing</h1></div></div></div><p><a class="indexterm" id="idx-CHP-18-0719"/>As I mentioned earlier, subnetting adds an additional level to the hierarchy of structures used in IP addressing. To support this, IP addresses must be broken into three elements instead of two. This is done by leaving the network ID alone and dividing the host ID into a subnet ID and host ID. These subnet ID bits are used to identify each subnet within the network. Hosts are assigned to the subnets in whatever manner makes the most sense for that network.</p><p>Interestingly, the earlier analogy to telephone numbers still holds in the world of subnetting and shows how subnetting changes the way IP addresses are interpreted. For example, a phone number like (401) 555-7777 has an area code (401) and a local number (555-7777). The local number, however, can itself be broken down into two parts: the exchange (555) and the local extension (7777). This means phone numbers really are comprised of three hierarchical components, just as IP addresses are in subnetting.</p><p>Of course, the number of bits in an IP address is fixed at 32. This means that in splitting the host ID into subnet ID and host ID, you reduce the size of the host ID portion of the address. In essence, you are stealing bits from the host ID to use for the subnet ID. Class A networks have 24 bits to split between the subnet ID and host ID; Class B networks have 16; and Class C networks have only 8.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-98"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A classful network is subnetted by dividing its host ID portion, leaving some of the bits for the host ID while allocating others to a new subnet ID. These bits are then used to identify individual subnets within the network, into which hosts are assigned.</p></div><p>Now remember that when we looked at the sizes of each of the main classes in the previous chapter, we saw that, for each class, the number of networks and the number of hosts per network are a function of how many bits we use for each. The same applies to the splitting of the host ID. Since we are dealing with binary numbers, the number of subnets is two to the power of the size of the subnet ID field. Similarly, the number of hosts per subnet is two to the power of the size of the host ID field (less two for excluded special cases).</p><p>Let's take a brief example to see how this works. Imagine that you start with Class B network 154.71.0.0, with 16 bits for the network ID (154.71) and 16 are for the host ID. In regular classful addressing, there are no subnets and 65,534 hosts total. To subnet this network, you can decide to split those 16 bits however you feel best suits the needs of the network: 1 bit for the subnet ID and 15 for the host ID, or 2 and 14, 3 and 13, and so on. Most any combination will work, as long as the total is 16; I've used 5 and 11 in the example shown in <a class="xref" href="ch18s02.html#subnetting_class_b_network_we_begin_with" title="Figure 18-1. Subnetting Class B network We begin with the Class B network 154.71.0.0, which has 16 bits in its host ID block. We then subnet this network by dividing the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated to the subnet ID, leaving 11 bits for the host ID.">Figure 18-1</a>. The more bits you steal from the host ID for the subnet ID, the more subnets you can have, but the fewer hosts you can have for each subnet.</p><div class="figure"><a id="subnetting_class_b_network_we_begin_with"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e18151"/><img alt="Subnetting Class B network We begin with the Class B network 154.71.0.0, which has 16 bits in its host ID block. We then subnet this network by dividing the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated to the subnet ID, leaving 11 bits for the host ID." src="httpatomoreillycomsourcenostarchimages287811.png.jpg"/></div></div><p class="title">Figure 18-1. Subnetting Class B network We begin with the Class B network 154.71.0.0, which has 16 bits in its host ID block. We then subnet this network by dividing the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated to the subnet ID, leaving 11 bits for the host ID.</p></div><p>Choosing how to split the host ID into subnet and host bits is one of the most important design considerations in setting up a subnetted IP network. The number of subnets is generally determined based on the number of physical subnetworks in the overall organizational network, and the number of hosts per subnetwork must not exceed the maximum allowed for the particular subnetting choice you make. Choosing how to divide the original host ID bits into subnet ID bits and host ID bits is sometimes called <span class="emphasis"><em>custom subnetting</em></span> and is described in more detail later in this chapter.</p></div>
<div class="sect1" title="IP Subnet Masks, Notation, and Subnet Calculations"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnet_masks_notation_and_subnet_calc"/>IP Subnet Masks, Notation, and Subnet Calculations</h1></div></div></div><p><a class="indexterm" id="idx-CHP-18-0720"/>Subnetting divides an organization's network into a two-level structure of subnets and hosts that is entirely internal and hidden from all other organizations on the Internet. One of the many advantages of this is that each organization gets to make its own choice about how to divide the classful host ID into subnet ID and host ID.</p><p>In a nonsubnetted classful environment, routers use the first octet of the IP address to determine what the class of the address is, and from this they know which bits are the network ID and which are the host ID. When you use subnetting, these routers also need to know how that host ID is divided into subnet ID and host ID. However, this division can be arbitrary for each network. Furthermore, there is no way to tell how many bits belong to each simply by looking at the IP address.</p><p>In a subnetting environment, the additional information about which bits are for the subnet ID and which are for the host ID must be communicated to devices that interpret IP addresses. This information is given in the form of a 32-bit binary number called a <span class="emphasis"><em>subnet mask</em></span>. The term <span class="emphasis"><em>mask</em></span> comes from the binary mathematics concept called <a class="indexterm" id="idx-CHP-18-0721"/><span class="emphasis"><em>bit masking</em></span>. This is a technique where a special pattern of ones and zeros can be used in combination with boolean functions such as AND and OR to select or clear certain bits in a number. (I explain bit masking in the background section on binary numbers and mathematics, in <a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a>.)</p><div class="sect2" title="Function of the Subnet Mask"><div class="titlepage"><div><div><h2 class="title"><a id="function_of_the_subnet_mask"/>Function of the Subnet Mask</h2></div></div></div><p>There's something about subnet <a class="indexterm" id="idx-CHP-18-0722"/>masks that seems to set people's hair on end, especially if they aren't that familiar with binary numbers. However, the idea behind them is quite straightforward. The mask is a 32-bit number, just as the IP address is a 32-bit number. Each of the 32 bits in the <a class="indexterm" id="idx-CHP-18-0723"/>subnet mask corresponds to the bit in the IP address in the same location in the number. The bits of the mask in any given subnetted network are chosen so that the bits used for either the network ID or subnet ID are ones, while the bits used for the host ID are zeros.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-99"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>subnet mask</em></span> is a 32-bit binary number that accompanies an IP address. It is created so that it has a one bit for each corresponding bit of the IP address that is part of its network ID or subnet ID, and a zero for each bit of the IP address's host ID. The mask thus tells TCP/IP devices which bits in that IP address belong to the network ID and subnet ID, and which are part of the host ID.</p></div><p>Why bother doing this with a 32-bit binary number? The answer is the magic of boolean logic. You use the subnet mask by applying the boolean AND function between it and the IP address. For each of the 32 "bit pairs" in the IP address and subnet mask, you employ the AND function, the output of which is one only if both bits are one. What this means in practical terms is the following, for each of the 32 bits:</p><p><span class="strong"><strong>Subnet Bit Is a One</strong></span> In this case, you are ANDing either a zero or one in the IP address with a one. If the IP address bit is a zero, the result of the AND will be zero; if it is a one, the AND will be one. In other words, <span class="emphasis"><em>where the subnet bit is a one, the IP address is preserved unchanged</em></span>.</p><p><span class="strong"><strong>Subnet Bit Is a Zero</strong></span> Here, you are ANDing with a zero, so the result is always zero, regardless of what the IP address is. Thus, <span class="emphasis"><em>when the subnet bit is a zero, the IP address bit is always cleared to zero</em></span>.</p><p>Thus, when you use the subnet mask on an IP address, the bits in the network ID and subnet ID are left intact, while the host ID bits are removed. Like a mask that blocks part of your face but lets other parts show, the subnet mask blocks some of the address bits (the host bits) and leaves others alone (the network and subnet bits). A router that performs this function is left with the address of the subnet. Since it knows from the class of the network what part is the network ID, it also knows what subnet the address is on.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-100"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> To use a subnet mask, a device performs a boolean AND operation between each bit of the subnet mask and each corresponding bit of an IP address. The resulting 32-bit number contains only the network ID and subnet ID of the address, with the host ID cleared to zero.</p></div></div><div class="sect2" title="Subnet Mask Notation"><div class="titlepage"><div><div><h2 class="title"><a id="subnet_mask_notation"/>Subnet Mask Notation</h2></div></div></div><p>Like IP addresses, subnet <a class="indexterm" id="idx-CHP-18-0724"/>masks are always used as a 32-bit binary number by computers. And like IP addresses, using them as 32-bit binary numbers is difficult for humans. Therefore, they are usually converted to dotted decimal notation for convenience, just as IP addresses are.</p><p>For example, suppose you <a class="indexterm" id="idx-CHP-18-0725"/>decide to subnet the Class B network 154.71.0.0 using 5 bits for the subnet ID and 11 bits for the host ID (see <a class="xref" href="ch18s03.html#determining_the_subnet_mask_of_a_subnett" title="Figure 18-2. Determining the subnet mask of a subnetted network The Class B network from Figure 18-1 is shown at the top, with 5 bits assigned to the subnet ID and 11 bits left for the host ID. To create the subnet mask, you fill in a 32-bit number with 1 for each network ID and subnet ID bit, and 0 for each host ID bit. You can then convert this to dotted decimal.">Figure 18-2</a>). In this case, the subnet mask will have 16 ones for the network portion (since this is Class B) followed by 5 ones for the subnet ID, and 11 zeros for the host ID. That's 11111111 11111111 <span class="strong"><strong>11111</strong></span>000 00000000 in binary, with the bits corresponding to the subnet ID highlighted. In dotted decimal, the subnet mask would be 255.255.248.0.</p><div class="figure"><a id="determining_the_subnet_mask_of_a_subnett"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e18274"/><img alt="Determining the subnet mask of a subnetted network The Class B network from is shown at the top, with 5 bits assigned to the subnet ID and 11 bits left for the host ID. To create the subnet mask, you fill in a 32-bit number with 1 for each network ID and subnet ID bit, and 0 for each host ID bit. You can then convert this to dotted decimal." src="httpatomoreillycomsourcenostarchimages287813.png.jpg"/></div></div><p class="title">Figure 18-2. Determining the subnet mask of a subnetted network The Class B network from <a class="xref" href="ch18s02.html#subnetting_class_b_network_we_begin_with" title="Figure 18-1. Subnetting Class B network We begin with the Class B network 154.71.0.0, which has 16 bits in its host ID block. We then subnet this network by dividing the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated to the subnet ID, leaving 11 bits for the host ID.">Figure 18-1</a> is shown at the top, with 5 bits assigned to the subnet ID and 11 bits left for the host ID. To create the subnet mask, you fill in a 32-bit number with 1 for each network ID and subnet ID bit, and 0 for each host ID bit. You can then convert this to dotted decimal.</p></div></div><div class="sect2" title="Applying the Subnet Mask: An Example"><div class="titlepage"><div><div><h2 class="title"><a id="applying_the_subnet_mask_an_example"/>Applying the Subnet Mask: An Example</h2></div></div></div><p>Now, let's see how the subnet mask might be used. Suppose you have a host on this network with an IP of 154.71.150.42 and a router needs to figure out which subnet this address is on. To do so, it performs the masking operation shown in <a class="xref" href="ch18s03.html#determining_the_subnet_id_of_an_ip_addre" title="Table 18-1. Determining the Subnet ID of an IP Address Through Subnet Masking">Table 18-1</a> and <a class="xref" href="ch18s03.html#determining_the_subnet_id_of_an_ip-id001" title="Figure 18-3. Determining the subnet ID of an IP address through subnet masking Subnet masking involves performing a boolean AND between each corresponding bit in the subnet mask and the IP address. The subnet mask can be likened to a physical mask; each 1 in it lets the corresponding bit of the IP address show through, while each 0 blocks the corresponding IP address bit. In this way the host ID bits of the address are stripped so the device can determine the subnet to which the address belongs.">Figure 18-3</a>.</p><div class="table"><a id="determining_the_subnet_id_of_an_ip_addre"/><p class="title">Table 18-1. Determining the Subnet ID of an IP Address Through Subnet Masking</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Determining the Subnet ID of an IP Address Through Subnet Masking"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Component</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet 1</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet 2</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet 3</p></th><th style="border-bottom: 0.5pt solid ; "><p>Octet 4</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>IP Address</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10011010 (154)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>01000111 (71)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10010110 (150)</p></td><td style="border-bottom: 0.5pt solid ; "><p>00101010 (42)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Subnet Mask</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111 (255)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111 (255)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>11111</strong></span>000 (248)</p></td><td style="border-bottom: 0.5pt solid ; "><p>00000000 (0)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Result of AND Masking</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>10011010 (154)</p></td><td style="border-right: 0.5pt solid ; "><p>01000111(71)</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>10010</strong></span>000 (144)</p></td><td style=""><p>00000000 (0)</p></td></tr></tbody></table></div></div><div class="figure"><a id="determining_the_subnet_id_of_an_ip-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e18373"/><img alt="Determining the subnet ID of an IP address through subnet masking Subnet masking involves performing a boolean AND between each corresponding bit in the subnet mask and the IP address. The subnet mask can be likened to a physical mask; each 1 in it lets the corresponding bit of the IP address show through, while each 0 blocks the corresponding IP address bit. In this way the host ID bits of the address are stripped so the device can determine the subnet to which the address belongs." src="httpatomoreillycomsourcenostarchimages287815.png.jpg"/></div></div><p class="title">Figure 18-3. Determining the subnet ID of an IP address through subnet masking Subnet masking involves performing a boolean AND between each corresponding bit in the subnet mask and the IP address. The subnet mask can be likened to a physical mask; each 1 in it lets the corresponding bit of the IP address show through, while each 0 blocks the corresponding IP address bit. In this way the host ID bits of the address are stripped so the device can determine the subnet to which the address belongs.</p></div><p>This result, 154.71.144.0, is the IP address of the subnet to which 154.71.150.42 belongs. There is no need to explicitly differentiate the network <a class="indexterm" id="idx-CHP-18-0726"/>ID bits from the subnet ID bits, because you are still using classful addresses. Any router can see that since the first two bits of the address are 10, this is a Class B address. So the network ID is 16 bits, and this means the subnet ID must be bits 17 to 21, counting from the left. Here, the subnet is the portion highlighted earlier: 10010, or subnet 18. (I'll explain this better in the "IP Custom Subnet Masks" section later in this chapter.)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-101"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The subnet mask is often expressed in dotted decimal notation for convenience, but is used by computers as a binary number and usually must be expressed in binary to understand how the mask works and the number of subnet ID bits it represents.</p></div></div><div class="sect2" title="Rationale for Subnet Mask Notation"><div class="titlepage"><div><div><h2 class="title"><a id="rationale_for_subnet_mask_notation"/>Rationale for Subnet Mask Notation</h2></div></div></div><p>In practical terms, the subnet mask actually conveys only a single piece of information: the line between the subnet ID and host ID. Then why bother with a big 32-bit binary number in that case, instead of just specifying the bit number where the division occurs? Instead of carrying the subnet mask of 255.255.248.0 around, why not just divide the IP address after bit 21? Even if devices want to perform a masking operation, couldn't they just create the mask as needed?</p><p>That's a very good question. There are two historical reasons: efficiency considerations and support for <a class="indexterm" id="idx-CHP-18-0727"/>noncontiguous masks. The subnet mask expression is efficient because it allows routers to perform a quick masking operation to determine the subnet address. (This is not really an issue today given the speed of today's machines.)</p><p>When splitting the bits in the host ID for subnet ID and host ID, RFC 950 specifies that they may be split in more than one place. In the previous example, you could, instead of splitting the 16 bits into 5 bits for subnet ID and 11 for host ID, have done it as 2 bits for the subnet ID, then 4 bits for the host ID, then 3 more bits for the subnet ID, and finally 7 more bits for host ID. This would be represented by the subnet mask pattern 11000011 10000000 for those 16 bits (following the 16 ones for the network ID). Of course, subnetting this way makes assigning addresses <span class="emphasis"><em>extremely</em></span> confusing. For this reason, while technically legal, noncontiguous subnet masking is not recommended and not done in practice.</p><p>Given that noncontiguous masks are not used, and today's computers are faster, the alternative method of expressing masks with just a single number is now often used. Instead of writing "<a class="indexterm" id="idx-CHP-18-0728"/>IP address of 154.71.150.42 with subnet mask of 255.255.248.0," you can simply write "154.71.150.42<span class="strong"><strong>/21</strong></span>." This is sometimes called <a class="indexterm" id="idx-CHP-18-0729"/><span class="emphasis"><em>slash notation</em></span> or <a class="indexterm" id="idx-CHP-18-0730"/><span class="emphasis"><em>Classless Inter-Domain Routing</em></span> <span class="emphasis"><em>(CIDR) notation</em></span>. While this is more commonly used in Variable Length Subnet Masking (VLSM) environments and is the standard for specifying <a class="indexterm" id="idx-CHP-18-0731"/>classless addresses under the CIDR addressing scheme (see <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>), it is also sometimes seen in regular subnetting discussions.</p><div class="note" title="Note"><h3 class="title"><a id="note-70"/>Note</h3><p><span class="emphasis"><em>Since these weird masks were never really used, some resources say that the subnet mask always had to be contiguous, but this is not true—originally, it was legal but advised against. Later, this practice became so out of favor that many hardware devices would not support it. Today, now that classless addressing and CIDR are standard, noncontiguous masks are simply illegal</em></span><a class="indexterm" id="idx-CHP-18-0732"/>.</p></div></div></div>
<div class="sect1" title="IP Default Subnet Masks for Address Classes A, B, and C"><div class="titlepage"><div><div><h1 class="title"><a id="ip_default_subnet_masks_for_address_clas"/>IP Default Subnet Masks for Address Classes A, B, and C</h1></div></div></div><p><a class="indexterm" id="idx-CHP-18-0733"/>In order to better understand how subnets divide a Class A, B, or C network, let's look at how the Class A, B, and C networks are represented in a subnetted environment. This might seem unnecessary if you aren't planning to create subnets, but the fact is, once subnetting became popular, most operating systems, networking hardware, and software assumed that subnetting would be used. Even if you decide not to subnet, you may need to express your unsubnetted network using a subnet mask.</p><p>In essence, a nonsubnetted Class A, B, or C network can be considered the default for the more general, custom-subnetted network. You can think of a nonsubnetted network as being the case where you choose to divide the host ID so that exactly zero bits are used for the subnet ID, and all the bits are used for the host ID. This default case is the basis for the more practical subnetting you will examine shortly.</p><p>As is always the case, the subnet mask for a default, unsubnetted Class A, B, or C network has ones for each bit that is used for the network ID or subnet ID and zeros for the host ID bits. Of course, I just said you aren't subnetting, so there <span class="emphasis"><em>are</em></span> no subnet ID bits! Thus, the subnet mask for this default case has ones for the network ID portion and zeros for the host ID portion. This is called the <span class="emphasis"><em>default subnet mask</em></span> for each of the IP address classes.</p><p>Since Class A, B, and C divide the network ID from the host ID on octet boundaries, the subnet mask will always have all ones or all zeros in an octet. Therefore, the default subnet masks will always have 255s or 0s when expressed in decimal notation. <a class="xref" href="ch18s04.html#default_subnet_masks_for_class_a_class_b" title="Table 18-2. Default Subnet Masks for Class A, Class B, and Class C Networks">Table 18-2</a> summarizes the default subnet masks for each of the classes. They are also shown graphically in <a class="xref" href="ch18s04.html#default_subnet_masks_for_class_a_c-id001" title="Figure 18-4. Default subnet masks for Class A, Class B, and Class C networks">Figure 18-4</a>.</p><div class="table"><a id="default_subnet_masks_for_class_a_class_b"/><p class="title">Table 18-2. Default Subnet Masks for Class A, Class B, and Class C Networks</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Default Subnet Masks for Class A, Class B, and Class C Networks"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Address Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Total # of Bits for Network ID/Host ID</p></th><th colspan="4" style="border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-18-0734"/>Default Subnet Mask</p></th></tr><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>First Octet</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Second Octet</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Third Octet</p></th><th style="border-bottom: 0.5pt solid ; "><p>Fourth Octet</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class A</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>8/24</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111 (255)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>00000000 (0)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>00000000 (0)</p></td><td style="border-bottom: 0.5pt solid ; "><p>00000000 (0)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>16/16</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111 (255)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111 (255)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>00000000 (0)</p></td><td style="border-bottom: 0.5pt solid ; "><p>00000000 (0)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Class C</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>24/8</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>11111111 (255)</p></td><td style="border-right: 0.5pt solid ; "><p>11111111 (255)</p></td><td style="border-right: 0.5pt solid ; "><p>11111111 (255)</p></td><td style=""><p>00000000 (0)</p></td></tr></tbody></table></div></div><div class="figure"><a id="default_subnet_masks_for_class_a_c-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e18589"/><img alt="Default subnet masks for Class A, Class B, and Class C networks" src="httpatomoreillycomsourcenostarchimages287817.png.jpg"/></div></div><p class="title">Figure 18-4. Default subnet masks for Class A, Class B, and Class C networks</p></div><p><a class="indexterm" id="idx-CHP-18-0735"/>Thus, the three default subnet masks are 255.0.0.0 for Class A, 255.255.0.0 for Class B, and 255.255.255.0 for Class C.</p><p>While all default subnet masks use only 255 and 0, not all subnet masks with 255 and 0 are defaults. There are a small number of custom subnets that divide on octet boundaries as well. These are as follows:</p><p><span class="strong"><strong>255.255.0.0</strong></span> This is the default mask for Class B, but can also be the custom subnet mask for dividing a Class A network using 8 bits for the subnet ID (leaving 16 bits for the host ID).</p><p><span class="strong"><strong>255.255.255.0</strong></span> This is the default subnet mask for Class C, but can be a custom Class A with 16 bits for the subnet ID <span class="emphasis"><em>or</em></span> a Class B with 8 bits for the subnet ID.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-102"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each of the three IP unicast and broadcast address classes, A, B, and C, has a <span class="emphasis"><em>default subnet mask</em></span> defined that has a one for each bit of the class's network ID, a zero for each bit of its host ID, and no subnet ID bits. The three default subnet masks are 255.0.0.0 for Class A, 255.255.0.0 for Class B, and 255.255.255.0 for Class C.</p></div></div>
<div class="sect1" title="IP Custom Subnet Masks"><div class="titlepage"><div><div><h1 class="title"><a id="ip_custom_subnet_masks"/>IP Custom Subnet Masks</h1></div></div></div><p>A default subnet mask doesn't really represent subnetting because you are assigning zero bits to the subnet ID. To do real subnetting, you must dedicate at least one of the bits of the presubnetted host ID to the subnet ID.</p><p>Since you can choose the dividing point between subnet ID and host ID to suit the network, this is sometimes called <a class="indexterm" id="idx-CHP-18-0736"/><span class="emphasis"><em>customized subnetting</em></span>. The subnet mask that you use when creating a customized subnet is, in turn, called a <span class="emphasis"><em>custom subnet mask</em></span>. The custom subnet mask is used by network hardware to determine how you have decided to divide the subnet ID from the host ID in the network.</p><div class="sect2" title="Deciding How Many Subnet Bits to Use"><div class="titlepage"><div><div><h2 class="title"><a id="deciding_how_many_subnet_bits_to_use"/>Deciding How Many Subnet Bits to Use</h2></div></div></div><p>The key decision in customized subnetting is how many bits to take from the host ID portion of the <a class="indexterm" id="idx-CHP-18-0737"/>IP address to put into the subnet ID. You'll recall that the number of subnets possible on the network is two to the power of the number of bits you use to express the subnet ID, and the number of hosts possible per subnet is two to the power of the number of bits left in the host ID (less two, as I explain later in this section).</p><p>Thus, the decision of how many bits to use for each of the subnet ID and host ID represents a fundamental trade-off in subnet addressing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Each bit taken from the host ID for the subnet ID doubles the number of subnets that are possible in the network.</p></li><li class="listitem"><p>Each bit taken from the host ID for the subnet ID (approximately) halves the number of hosts that are possible within each subnet on the network.</p></li></ul></div><p>For example, say you start with a Class B network with the network address 154.71.0.0. Since this is Class B, 16 bits are for the network ID (154.71) and 16 are for the host ID. In the default case, there are no subnets and 65,534 hosts total. To subnet this network, you can use the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>One bit for the subnet ID and 15 bits for the host ID. If you do this, then the total number of subnets is 2<sup>1</sup>, or 2. The first subnet is 0, and the second is 1. The number of hosts available for each subnet is 2<sup>15</sup>–2, or 32,766.</p></li><li class="listitem"><p>Two bits for the subnet ID and 14 for the host ID. In this case, you double the number of subnets. You now have 2<sup>2</sup>, or 4 subnets: 00, 01, 10, and 11 (subnets 0, 1, 2, and 3). But the number of hosts is now only 2<sup>14</sup>–2, or 16,382.</p></li><li class="listitem"><p>Any combination of bits that add up to 16 as long as they allow you at least two hosts per subnet: 4 and 12, 5 and 11, and so on.</p></li></ul></div><p>The way you decide to divide the classful host ID into subnet ID and host ID bits is the key design decision in subnetting. You make your choice based on the number of subnets in the network, and also on the maximum number of hosts that need to be assigned to each subnet in the network. For example, if you have 10 total subnets for your Class B network, you need 4 bits to represent this, because 2<sup>4</sup> is 16 while 2<sup>3</sup> is only 8. This leaves 12 bits for the host ID, for a maximum of 4,094 hosts per subnet.</p><p>However, suppose instead that you have 20 subnets. If so, 4 bits for subnet ID won't suffice; you need 5 bits (2<sup>5</sup>=32). This means that you now have only 11 bits for the host ID, for a maximum of 2,046 hosts per subnet. (Step 2 of the practical subnetting example in <a class="xref" href="ch19.html" title="Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE">Chapter 19</a> discusses these decisions in more detail.)</p><p>Now if you have 20 subnets and also need a maximum of 3,000 hosts per subnet, you have a problem. You need 5 bits to express 20 different subnets, but you need 12 bits to express the number 3,000 for the host ID. That's 17 bits—too many. What's the solution? You might be able to shuffle your physical networks so that you only have 16. If not, you need a second Class B network.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-103"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The fundamental trade-off in subnetting is that each addition of a bit to the subnet ID (and thus, subtraction of that bit from the host ID) doubles the number of subnets, and approximately halves the number of hosts in each subnet. Each subtraction of a bit from the subnet ID (and addition of that bit to the host ID) does the opposite.</p></div></div><div class="sect2" title="Determining the Custom Subnet Mask"><div class="titlepage"><div><div><h2 class="title"><a id="determining_the_custom_subnet_mask"/>Determining the Custom Subnet Mask</h2></div></div></div><p>Once you determine how many bits to devote to the subnet and host IDs, you can determine the subnet mask. You begin with the default subnet mask in binary for the appropriate class of the network. You start with the leftmost zero in that mask and change as many bits to one as you have dedicated to the subnet ID, at which point you can express the subnet mask in dotted decimal form. <a class="xref" href="ch18s05.html#custom_subnet_masks_for_class_c_networks" title="Figure 18-5. Custom subnet masks for Class C networks Since there are host ID bits in a Class C network address, there are six different ways that the network can be subnetted. Each corresponds to a different custom subnet mask, which is created by changing the allocated subnet ID bits from zero to one.">Figure 18-5</a> shows how the custom subnet mask can be determined for each of the subnetting options of a Class C network in both binary and decimal.</p><p>Consider the Class C network 200.13.94.0 in <a class="xref" href="ch18s05.html#custom_subnet_masks_for_class_c_networks" title="Figure 18-5. Custom subnet masks for Class C networks Since there are host ID bits in a Class C network address, there are six different ways that the network can be subnetted. Each corresponds to a different custom subnet mask, which is created by changing the allocated subnet ID bits from zero to one.">Figure 18-5</a>. There are eight bits in the original host ID, which gives you six different subnetting options (you can't use seven or eight bits for the subnet ID, for reasons I will discuss shortly). Suppose you use three of these for the subnet ID, leaving five for the host ID. To determine the custom subnet mask, you start with the Class C default subnet mask:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11111111 11111111 11111111 00000000</td></tr><tr><td>You then change the first three zeros to ones, to get the custom subnet mask:</td></tr><tr><td>11111111 11111111 11111111 <span class="strong"><strong>111</strong></span>00000</td></tr><tr><td>In dotted decimal format, this is 255.255.255.224.</td></tr></table><div class="note" title="Note"><h3 class="title"><a id="note-71"/>Note</h3><p><span class="emphasis"><em>Once you've made the choice of how to subnet, you determine the custom subnet mask by starting with the default subnet mask for the network and changing each subnet ID bit from a zero to a one</em></span>.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-72"/>Note</h3><p><span class="emphasis"><em>In regular subnetting, the choice of how many bits to use for the subnet ID is fixed for the entire network. You can't have subnets of different sizes—they must all be the same. Thus, the number of hosts in the largest subnet will dictate how many bits you need for the host ID. This means that in the previous case, if you had a strange configuration where 19 subnets had only 100 hosts each but the 20th had 3,000, you would have a problem. If this were the case, you could solve the problem easily by dividing that one oversized subnet into two or more smaller ones. An enhancement to subnetting called Variable Length Subnet Masking (VLSM) was created in large part to remove this restriction. VLSM is described later in the chapter</em></span>.</p></div><div class="figure"><a id="custom_subnet_masks_for_class_c_networks"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e18747"/><img alt="Custom subnet masks for Class C networks Since there are host ID bits in a Class C network address, there are six different ways that the network can be subnetted. Each corresponds to a different custom subnet mask, which is created by changing the allocated subnet ID bits from zero to one." src="httpatomoreillycomsourcenostarchimages287819.png.jpg"/></div></div><p class="title">Figure 18-5. Custom subnet masks for Class C networks Since there are host ID bits in a Class C network address, there are six different ways that the network can be subnetted. Each corresponds to a different custom subnet mask, which is created by changing the allocated subnet ID bits from zero to one.</p></div></div><div class="sect2" title="Subtracting Two from the Number of Hosts per Subnet and (Possibly) Subnets per Network"><div class="titlepage"><div><div><h2 class="title"><a id="subtracting_two_from_the_number_of_hosts"/>Subtracting Two from the Number of Hosts per Subnet and (Possibly) Subnets per Network</h2></div></div></div><p>You've seen how you must subtract two from the number of hosts allowed in each network in regular classful addressing. This is necessary because two host IDs in each subnet have special meanings: the all-zeros host ID (for "this network") and the all-ones host ID (for broadcasts to all hosts on the network). These restrictions apply to each subnet under subnetting, too, which is why you must continue to subtract two from the number of hosts per subnet. (This is also why dividing the eight host ID bits of a Class C network into seven bits for subnet ID and one bit for host ID is meaningless: It leaves 2<a class="indexterm" id="idx-CHP-18-0738"/><sup>1</sup>–2 = 0 hosts per subnet, which is not particularly useful.)</p><p>A similar issue occurs with the subnet ID as well. When subnetting was originally defined in RFC 950, the standard specifically excluded the use of the all-zeros and all-ones subnets. This was due to concern that routers might become confused by these cases. A later standard, RFC 1812, "Requirements for IP Version 4 Routers," removed this restriction in 1995. Thus, modern hardware now has no problem with the all-zeros or all-ones subnets, but some very old hardware may still balk at it.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-104"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The number of hosts allowed in each subnet is the binary power of the number of host ID bits remaining after subnetting, less two. The reduction by two occurs because the all-zeros and all-ones host IDs within each subnet are reserved for two special meaning addresses: to refer to the subnetwork itself and to refer to its local broadcast address. In some implementations, the number of subnets is also reduced by two because the all-zeros and all-ones subnet IDs were originally not allowed to be used.</p></div><p>For this reason, you will sometimes see discussions of subnetting that exclude these cases. When that is done, you lose two potential subnets: the all-zeros and all-ones subnets. If you do this, then choosing one bit for subnet ID is no longer valid, as it yields 2<sup>1</sup>–2=0 subnets. You must choose two bits if you need two subnets.</p><div class="note" title="Note"><h3 class="title"><a id="note-73"/>Note</h3><p><span class="emphasis"><em>In this book, I assume you are dealing with modern hardware and do not exclude the all-zeros and all-ones subnets, but I do try to make explicit note of this fact wherever relevant. Summary tables later in this chapter show the trade-off in subnetting each of Classes A, B, and C, and the subnet mask for each of the choices</em></span>.</p></div></div></div>
<div class="sect1" title="IP Subnet Identifiers, Subnet Addresses, and Host Addresses"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnet_identifiers_subnet_addresses_a"/>IP Subnet Identifiers, Subnet Addresses, and Host Addresses</h1></div></div></div><p><a class="indexterm" id="idx-CHP-18-0739"/>The main advantage that conventional classful addressing without subnets offers over subnets is simplicity. For example, even though there can be problems with managing thousands of devices in a single Class B network, it is simple to assign addresses within the network: They are all lumped together, so any combination of bits can be used within the host ID (except for all-zeros and all-ones).</p><p>When you subnet, however, you create a two-level structure within the classful host ID: subnet ID and host ID. This means you must choose IP addresses for devices more carefully. In theory, you are selecting subnets to correspond to the physical networks within the organization, so you want to assign IP addresses in a way that is consistent with the physical network structure.</p><div class="sect2" title="Subnet Identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="subnet_identifiers"/>Subnet Identifiers</h2></div></div></div><p>Once you decide how many subnets you will have, you need to identify the subnets and determine their addresses. You begin with the <span class="emphasis"><em>subnet identifier</em></span>, the <span class="emphasis"><em>subnet ID</em></span> of any subnets on our network. Subnets are numbered starting with zero and increasing up to one less than the maximum number of subnets, which is a function of how many bits are in the subnet ID. (If the all-zero and all-ones subnet IDs are excluded, as specified in RFC 950, then the first subnet ID is one.)</p><p>Of course, you may not need all of the subnets that can be defined. For example, if you have 20 subnets, you need five bits for the subnet identifier, which allows a theoretical maximum of 32 subnets. You would use only subnets 0 to 19; 20 through 31 would be reserved for future use. These subnets could be expressed either in decimal form (0, 1, 2 … up to 19) or in binary (00000, 00001, 00010, and so on, up to 10011).</p></div><div class="sect2" title="Subnet Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="subnet_addresses"/>Subnet Addresses</h2></div></div></div><p>For each subnet, you can also determine the <span class="emphasis"><em>subnet address</em></span>. To do this, you start with the IP address for the overall network, which has all zeros in the classful host ID field (8 bits, 16 bits, or 24 bits). You then insert the subnet ID for a particular subnet into the designated subnet bits.</p><p>For example, to subnet the Class B network 154.71.0.0 shown in <a class="xref" href="ch18s03.html#determining_the_subnet_mask_of_a_subnett" title="Figure 18-2. Determining the subnet mask of a subnetted network The Class B network from Figure 18-1 is shown at the top, with 5 bits assigned to the subnet ID and 11 bits left for the host ID. To create the subnet mask, you fill in a 32-bit number with 1 for each network ID and subnet ID bit, and 0 for each host ID bit. You can then convert this to dotted decimal.">Figure 18-2</a>, in which you use five subnet ID bits, you start with the following network IP address, with the subnet ID bits highlighted:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>10011010 01000111 <span class="strong"><strong>00000</strong></span>000 00000000</td></tr></table><p>To find the address of say, subnet 11, you substitute 01011 for these bits, leaving the host ID bits zero, as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>10011010 01000111 <span class="strong"><strong>01011</strong></span>000 00000000</td></tr></table><p>You can then convert this from binary form to dotted decimal, resulting in a subnet address of 154.71.<span class="strong"><strong>88</strong></span>.0.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-105"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The subnet <span class="emphasis"><em>identifier</em></span> of a subnet is just its subnet ID. The subnet address of a subnet is determined by substituting its subnet ID into the subnet bits of the overall network address.</p></div><p>When you look at subnet addressing, especially when you substitute subnet IDs in sequence, a pattern becomes immediately visible. The first subnet address is always the address of the overall network, because the subnet ID is all zeros. Then you find the second subnet address in decimal form by adding a specific multiple of two to one of the octets. The third address is then found by adding this same number to the second address, and so on.</p><p>In fact, the decimal value of each subnet address can be expressed as a formula, based on the class of the original network and the number of bits being used for the subnet ID. For example, consider a Class B network with the overall address of x.y.0.0 (it doesn't matter what x and y are for these purposes). Now say you are using two bits for the subnet ID. You have four subnet <a class="indexterm" id="idx-CHP-18-0740"/>addresses here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The address of subnet 0 will be the same as the network address: x.y.0.0.</p></li><li class="listitem"><p>The address of subnet 1 will be found by substituting 01 for the first two bits of the third octet. This yields an address of x.y.01000000.0000000, or x.y.64.0 in straight decimal.</p></li><li class="listitem"><p>Subnet 2's address is found by substituting 10 for the subnet ID bits, so it is x.y.10000000.0000000, or x.y.128.0 in straight decimal.</p></li><li class="listitem"><p>Subnet 3's address will be x.y.192.0.</p></li></ul></div><p>So, the formula in this case for subnet <span class="emphasis"><em>N</em></span> is x.y.<span class="emphasis"><em>N</em></span><sup>*</sup>64.0. If you use five bits for a subnet, the formula is x.y.<span class="emphasis"><em>N</em></span><sup>*</sup>8.0. As you saw earlier, the subnet address for subnet 11 in network 154.71.0.0 is 154.71.<span class="strong"><strong>88</strong></span>.0. I have shown the formulas for all of the combinations of subnet ID and host ID size in the subnetting summary tables (Tables <a class="xref" href="ch18s07.html#subnetting_summary_table_for_class_a_net" title="Table 18-3. Subnetting Summary Table for Class A Networks">Table 18-3</a>, <a class="xref" href="ch18s07.html#subnetting_summary_table_for_class_b_net" title="Table 18-4. Subnetting Summary Table for Class B Networks">Table 18-4</a>, and <a class="xref" href="ch18s07.html#subnetting_summary_table_for_class_c_net" title="Table 18-5. Subnetting Summary Table for Class C Networks">Table 18-5</a>). These formulas can be a real time-saver once you become more familiar with subnetting.</p></div><div class="sect2" title="Host Addresses Within Each Subnet"><div class="titlepage"><div><div><h2 class="title"><a id="host_addresses_within_each_subnet"/>Host Addresses Within Each Subnet</h2></div></div></div><p>Once you know the subnet address for a particular subnet, you assign IP addresses by plugging in values into the remaining host ID bits. You skip the all-zeros value, so the first host in the subnet has all zeros for the host ID except for a one in the rightmost bit position. Then the next host has all zeros except for "10" at the end (2 in decimal). You can do this all the way up to one less than the all-ones value. Again, you then convert each IP address from binary to decimal.</p><div class="note" title="Note"><h3 class="title"><a id="note-74"/>Note</h3><p><span class="emphasis"><em>You can find exactly these details in <a class="xref" href="ch19.html" title="Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE">Chapter 19</a>'s coverage of practical subnetting</em></span>.</p></div></div></div>
<div class="sect1" title="IP Subnetting Summary Tables for Class A, Class B, and Class C Networks"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_summary_tables_for_class_a"/>IP Subnetting Summary Tables for Class A, Class B, and Class C Networks</h1></div></div></div><p><a class="indexterm" id="idx-CHP-18-0741"/>Since there are only a few options for how to subnet Class A, Class B, and Class C networks, I list the options for each class in summary Tables <a class="xref" href="ch18s07.html#subnetting_summary_table_for_class_a_net" title="Table 18-3. Subnetting Summary Table for Class A Networks">Table 18-3</a> through <a class="xref" href="ch18s07.html#subnetting_summary_table_for_class_c_net" title="Table 18-5. Subnetting Summary Table for Class C Networks">Table 18-5</a>. These tables can help you quickly decide how many bits to use for subnet ID and host ID, and then what the subnet mask is for their selection. They also summarize nicely what I've discussed so far in this chapter.</p><p>Each row of each table shows one possible subnetting option for that class, including the number of bits for each of the subnet ID and host ID, and the number of subnets and hosts based on the number of bits. I then show the subnet mask in binary and decimal form, as well as in CIDR notation (covered in <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>). Finally, I include the formula for calculating the addresses for each subnet under each of the options.</p><p>A few additional explanatory notes are in order regarding these tables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The values for the number of subnets per network assume that the all-zeros and all-ones subnets are allowed. If not, you must subtract two from those figures. This also means that the option using only one bit for the subnet ID becomes invalid, and the subnet address formulas no longer work as shown.</p></li><li class="listitem"><p>The number of hosts per subnet excludes the all-zeros and all-ones cases, so it is two to the power of the number of host ID bits, less two.</p></li><li class="listitem"><p>The first row of each table shows the default case where the number of subnet bits is zero, and thus the subnet mask is the default subnet mask for the class.</p></li><li class="listitem"><p>In the subnet mask for all options but the default, I have highlighted the portion of the subnet mask corresponding to the subnet ID, for clarity. This has been done for each individual bit of the binary mask, and for each octet in the dotted decimal representation of the mask where part of the subnet ID is found.</p></li><li class="listitem"><p>In looking at these tables, you will see that not all of the divisions make a great deal of sense in the real world, though you might be surprised. For example, at first glance, it seems silly to think that you might want to assign 14 bits of a Class B host ID to the subnet ID and leave 2 bits for the host ID—what sort of real network has 16,384 subnets with two hosts on each? Yet, some larger Internet service companies may indeed require thousands of tiny subnets when setting up connections between routers or between their core network and their customers.</p></li><li class="listitem"><p>The subnet address formulas in the last column of each table show the address for subnet <span class="emphasis"><em>N</em></span> (numbering from zero up to one less than the maximum number of subnets). See the end of step 4 in the step-by-step subnetting discussion (<a class="xref" href="ch19.html" title="Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE">Chapter 19</a>) for a full explanation of how these formulas work.</p></li></ul></div><div class="table"><a id="subnetting_summary_table_for_class_a_net"/><p class="title">Table 18-3. Subnetting Summary Table for Class A Networks</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Subnetting Summary Table for Class A Networks"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Subnet ID Bits</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Host ID Bits</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Subnets per Network</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Hosts per Subnet</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnet Mask (Binary/Dotted Decimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnet Mask (Slash/ CIDR Notation)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Subnet Address #N Formula (N=0, 1, # of Subnets -1)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>0 (Default)</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>24</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16,277,214</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.00000000.00000000.00000000255.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>1</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>23</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8,388,606</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>1</strong></span>0000000.00000000.00000000255.<span class="strong"><strong>128</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/9</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N*128.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>2</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>22</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4,194,302</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11</strong></span>000000.00000000.00000000255.<span class="strong"><strong>192</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/10</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N*64.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>3</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>21</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,097,150</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>111</strong></span>00000.00000000.00000000255.<span class="strong"><strong>224</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/11</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N*32.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>4</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>20</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,048,574</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>1111</strong></span>0000.00000000.00000000255.<span class="strong"><strong>240</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/12</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N*16.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>5</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>19</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>524,286</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111</strong></span>000.00000000.00000000255.<span class="strong"><strong>248</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/13</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N*8.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>6</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>18</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>262,142</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>111111</strong></span>00.00000000.00000000255.<span class="strong"><strong>252</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/14</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N*4.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>7</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>17</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>131,070</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>1111111</strong></span>0.00000000.00000000255.<span class="strong"><strong>254</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/15</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N*2.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>8</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>16</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>256</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>65,534</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.00000000.00000000255.<span class="strong"><strong>255</strong></span>.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N.0.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>9</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>15</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>512</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32,766</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.10000000.00000000255.<span class="strong"><strong>255.128</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/17</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/2.(N%2)*128.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>10</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>14</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,024</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16,382</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.11000000.00000000255.<span class="strong"><strong>255.192</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/18</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/4.(N%4)*64.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>11</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>13</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,048</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8,190</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.11100000.00000000255.<span class="strong"><strong>255.224</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/19</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/8.(N%8)*32.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>12</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>12</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4,096</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4,094</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>1111</strong></span>0000.00000000255.<span class="strong"><strong>255.240</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/20</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/16.(N%16)*16.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>13</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>11</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8,192</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,046</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111</strong></span>000.00000000255.<span class="strong"><strong>255.248</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/21</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/32.(N%32)*8.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>14</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>10</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16,384</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,022</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>111111</strong></span>00.00000000255.<span class="strong"><strong>255.252</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/22</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/64.(N%64)*4.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>15</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>9</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32,768</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>510</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>1111111</strong></span>0.00000000255.<span class="strong"><strong>255.254</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/23</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/128.(N%128)*2.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>16</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>8</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>65,536</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>254</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111111</strong></span>.00000000255.<span class="strong"><strong>255.255</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/24</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/256.N%256.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>17</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>7</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>131,072</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>126</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>1</strong></span>0000000255.<span class="strong"><strong>255.255.128</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/25</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/512.(N/2)%256.(N%2)*128</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>18</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>6</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>262,144</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>62</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11</strong></span>000000255.<span class="strong"><strong>255.255.192</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/26</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/1024.(N/4)%256.(N%4)*64</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>19</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>5</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>524,288</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>111</strong></span>00000255.<span class="strong"><strong>255.255.224</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/27</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/2048.(N/8)%256.(N%8)*32</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>20</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>4</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,048,576</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>1111</strong></span>0000255.<span class="strong"><strong>255.255.240</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/28</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/4096.(N/16)%256.(N%16)*16</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>21</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>3</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,097,152</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111</strong></span>000255.<span class="strong"><strong>255.255.248</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/29</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.N/8192.(N/32)%256.(N%32)*8</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>22</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>2</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>4,194,304</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>111111</strong></span>00255.<span class="strong"><strong>255.255.252</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>/30</p></td><td style=""><p>x.N/16384.(N/64)%256.(N%64)*4</p></td></tr></tbody></table></div></div><div class="table"><a id="subnetting_summary_table_for_class_b_net"/><p class="title">Table 18-4. Subnetting Summary Table for Class B Networks</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Subnetting Summary Table for Class B Networks"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Subnet ID Bit</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Host ID Bits</p></th><th style="border-bottom: 0.5pt solid ; "><p># of Subnets per Network</p></th><th style="border-bottom: 0.5pt solid ; "><p># of Hosts per Subnet</p></th><th style="border-bottom: 0.5pt solid ; "><p>Subnet Mask (Binary/Dotted Decimal)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Subnet Mask (Slash/ CIDR Notation)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Subnet Address #N Formula (N=0, 1, # of Subnets -1)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 (Default)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>65,534</p></td><td style="border-bottom: 0.5pt solid ; "><p>11111111.11111111.00000000.00000000255.255.0.0</p></td><td style="border-bottom: 0.5pt solid ; "><p>/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>-</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32,766</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.10000000.00000000255.255.<span class="strong"><strong>128</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/17</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N*128.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16,382</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11</strong></span>000000.00000000255.255.<span class="strong"><strong>192</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/18</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N*64.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8,190</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>111</strong></span>00000.00000000255.255.<span class="strong"><strong>224</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/19</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N*32.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4,094</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>1111</strong></span>0000.00000000255.255.<span class="strong"><strong>240</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/20</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N*16.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,046</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111</strong></span>000.00000000255.255.<span class="strong"><strong>248</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/21</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N*8.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,022</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>111111</strong></span>00.00000000255.255.<span class="strong"><strong>252</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/22</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N*4.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>510</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>1111111</strong></span>0.00000000255.255.<span class="strong"><strong>254</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/23</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N*2.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>256</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>254</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111111</strong></span>.00000000255.255.<span class="strong"><strong>255</strong></span>.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/24</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N.0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>512</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>126</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>1</strong></span>0000000255.255.<span class="strong"><strong>255.128</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/25</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N/2.(N%2)*128</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,024</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>62</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>11</strong></span>000000255.255.<span class="strong"><strong>255.192</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/26</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N/4.(N%4)*64</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,048</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111111</strong></span>.<span class="strong"><strong>111</strong></span>00000255.255.<span class="strong"><strong>255.224</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/27</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.x.N/8.(N%8)*32</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4,096</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111111.1111</strong></span>0000255.255.<span class="strong"><strong>255.240</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/28</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N/16.(N%16)*16</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8,192</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111111.11111</strong></span>000255.255.<span class="strong"><strong>255.248</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/29</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.N/32.(N%32)*8</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>16,384</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>11111111.11111111.<span class="strong"><strong>11111111.111111</strong></span>00255.255.<span class="strong"><strong>255.252</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>/30</p></td><td style=""><p>x.y.N/64.(N%64)*4</p></td></tr></tbody></table></div></div><div class="table"><a id="subnetting_summary_table_for_class_c_net"/><p class="title">Table 18-5. Subnetting Summary Table for Class C Networks</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Subnetting Summary Table for Class C Networks"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Subnet ID Bit</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Host ID Bits</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Subnets per Network</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Hosts per Subnet</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnet Mask (Binary/Dotted Decimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnet Mask (Slash/ CIDR Notation)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Subnet Address #N Formula (N=0, 1, # of Subnets-1)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 (Default)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>254</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.11111111.00000000255.255.255.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/24</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>126</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.11111111.<span class="strong"><strong>1</strong></span>0000000255.255.255.<span class="strong"><strong>128</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/25</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.z.N*128</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>62</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111
.11111111.<span class="strong"><strong>11</strong></span>000000255.255.255.<span class="strong"><strong>192</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/26</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.z.N*64</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.11111111.<span class="strong"><strong>111</strong></span>00000255.255.255.<span class="strong"><strong>224</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/27</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.z.N*32</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.11111111.<span class="strong"><strong>11110</strong></span>000255.255.255.<span class="strong"><strong>240</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/28</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.z.N*16</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111111.11111111.11111111.<span class="strong"><strong>11111</strong></span>000255.255.255.<span class="strong"><strong>248</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/29</p></td><td style="border-bottom: 0.5pt solid ; "><p>x.y.z.N*8</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>64</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>11111111.11111111.11111111.<span class="strong"><strong>111111</strong></span>00255.255.255.<span class="strong"><strong>252</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>/30</p></td><td style=""><p>x.y.z.N*4</p></td></tr></tbody></table></div></div></div>
<div class="sect1" title="IP Variable Length Subnet Masking (VLSM)"><div class="titlepage"><div><div><h1 class="title"><a id="ip_variable_length_subnet_masking_vlsm"/>IP Variable Length Subnet Masking (VLSM)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-18-0742"/>The main weakness with conventional subnetting is that the subnet ID represents only <span class="emphasis"><em>one</em></span> additional hierarchical level in how IP addresses are interpreted and used for routing.</p><p>It may seem greedy to look at subnetting and say, "What, only <span class="emphasis"><em>one</em></span> additional level?" However, in large networks, the need to divide the entire network into only one level of subnetworks doesn't represent the best use of the IP address block.</p><p>Furthermore, you have already seen that since the subnet ID is the same length throughout the network, you can have problems if you have subnetworks with very different numbers of hosts on them. The subnet ID must be chosen based on whichever subnet has the greatest number of hosts, even if most of subnets have far fewer. This is inefficient even in small networks, and can result in the need to use extra addressing blocks while wasting many of the addresses in each block.</p><p>For example, consider a relatively small company with a Class C network, 201.45.222.0/24. The administrators have six subnetworks in their network. The first four subnets (S1, S2, S3, and S4) are relatively small, containing only 10 hosts each. However, one of them (S5) is for their production floor and has 50 hosts, and the last (S6) is their development and engineering group, which has 100 hosts. The total number of hosts needed is thus 196.</p><p>Without subnetting, the company has enough hosts in the Class C network to handle them all. However, when they try to subnet, they have a big problem. In order to have six subnets, they need to use three bits for the subnet ID. This leaves only five bits for the host ID, which means every subnet has the identical capacity of 30 hosts, as shown in <a class="xref" href="ch18s08.html#class_c_24_network_split_into_eight_conv" title="Figure 18-6. Class C (/24) network split into eight conventional subnets With traditional subnetting, all subnets must be the same size, which creates problems when there are some subnets that are much larger than others. Contrast this with Figure 18-7.">Figure 18-6</a>. This is enough for the smaller subnets but not enough for the larger ones. The only solution with conventional subnetting, other than shuffling the physical subnets, is to get another Class C block for the two big subnets and use the original for the four small ones. But this is expensive and means wasting hundreds of IP addresses!</p><div class="figure"><a id="class_c_24_network_split_into_eight_conv"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20420"/><img alt="Class C (/24) network split into eight conventional subnets With traditional subnetting, all subnets must be the same size, which creates problems when there are some subnets that are much larger than others. Contrast this with ." src="httpatomoreillycomsourcenostarchimages287821.png.jpg"/></div></div><p class="title">Figure 18-6. Class C (/24) network split into eight conventional subnets With traditional subnetting, all subnets must be the same size, which creates problems when there are some subnets that are much larger than others. Contrast this with <a class="xref" href="ch18s08.html#class_c_24_network_split_using_vlsm_usin" title="Figure 18-7. Class C (/24) network split using VLSM Using VLSM, an organization can divide its IP network multiple times to create subnets that match the size requirements of its physical networks much better. Contrast this with Figure 18-6.">Figure 18-7</a>.</p></div><div class="sect2" title="The Solution: Variable Length Subnet Masking"><div class="titlepage"><div><div><h2 class="title"><a id="the_solution_variable_length_subnet_mask"/>The Solution: Variable Length Subnet Masking</h2></div></div></div><p><a class="indexterm" id="idx-CHP-18-0743"/>The solution is an enhancement to the basic subnet addressing scheme called <span class="emphasis"><em>Variable Length Subnet Masking (VLSM)</em></span>. The idea is that you subnet the network and then subnet the subnets just the way you originally subnetted the network. In fact, you can do this multiple times, creating subnets of subnets of subnets, as many times as you need (subject to how many bits you have in the host ID of your address block).</p><p>It is possible to choose to apply this multiple-level splitting to only some of the subnets, thereby allowing you to selectively cut the IP address pie so that some of the slices are bigger than others. This means that the company in the previous example could create six subnets to match the needs of its networks, as shown in <a class="xref" href="ch18s08.html#class_c_24_network_split_using_vlsm_usin" title="Figure 18-7. Class C (/24) network split using VLSM Using VLSM, an organization can divide its IP network multiple times to create subnets that match the size requirements of its physical networks much better. Contrast this with Figure 18-6.">Figure 18-7</a>.</p><div class="figure"><a id="class_c_24_network_split_using_vlsm_usin"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20449"/><img alt="Class C (/24) network split using VLSM Using VLSM, an organization can divide its IP network multiple times to create subnets that match the size requirements of its physical networks much better. Contrast this with ." src="httpatomoreillycomsourcenostarchimages287823.png.jpg"/></div></div><p class="title">Figure 18-7. Class C (/24) network split using VLSM Using VLSM, an organization can divide its IP network multiple times to create subnets that match the size requirements of its physical networks much better. Contrast this with <a class="xref" href="ch18s08.html#class_c_24_network_split_into_eight_conv" title="Figure 18-6. Class C (/24) network split into eight conventional subnets With traditional subnetting, all subnets must be the same size, which creates problems when there are some subnets that are much larger than others. Contrast this with Figure 18-7.">Figure 18-6</a>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-106"/>Tip</h3><p><a class="indexterm" id="idx-CHP-18-0744"/><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Variable Length Subnet Masking (VLSM)</em></span> is a technique for which subnetting is performed multiple times in iteration to allow a network to be divided into a hierarchy of subnetworks that vary in size. This allows an organization to better match the size of its subnets to the requirements of its networks.</p></div></div><div class="sect2" title="Multiple-Level Subnetting Using VLSM"><div class="titlepage"><div><div><h2 class="title"><a id="multiple-level_subnetting_using_vlsm"/>Multiple-Level Subnetting Using VLSM</h2></div></div></div><p>VLSM subnetting is done the same way as regular subnetting; it just involves extra levels of subnetting hierarchy. To implement it, you first subnet the network into large subnets and then further break down one or more of the subnets as required. You add bits to the subnet mask for each of the sub-subnets and sub-sub-subnets to reflect their smaller size.</p><p>In VLSM, the slash notation of classless addressing is commonly used instead of binary subnet masks (it works very much like CIDR), so that's what I will use.</p><div class="note" title="Note"><h3 class="title"><a id="note-75"/>Note</h3><p><span class="emphasis"><em>If you're feeling a bit uncomfortable with how subnetting works, consider reading the chapter on practical subnetting (<a class="xref" href="ch19.html" title="Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE">Chapter 19</a>) before proceeding with the VLSM example that follows</em></span>.</p></div><p>For example, consider the class C network, 201.45.222.0/24. You do three subnettings as follows (see <a class="xref" href="ch18s08.html#vlsm_example_this_diagram_illustrates_th" title="Figure 18-8. VLSM example This diagram illustrates the example described in the text, of a Class C (/24) network divided using three hierarchical levels. It is first divided into two subnets; one subnet is divided into two sub-subnets; and one sub-subnet is divided into four sub-sub-subnets. The resulting six subnets, shown with thick black borders, have a maximum capacity of 126, 62, 14, 14, 14, and 14 hosts.">Figure 18-8</a> for an illustration of the process).</p><div class="figure"><a id="vlsm_example_this_diagram_illustrates_th"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e20490"/><img alt="VLSM example This diagram illustrates the example described in the text, of a Class C (/24) network divided using three hierarchical levels. It is first divided into two subnets; one subnet is divided into two sub-subnets; and one sub-subnet is divided into four sub-sub-subnets. The resulting six subnets, shown with thick black borders, have a maximum capacity of 126, 62, 14, 14, 14, and 14 hosts." src="httpatomoreillycomsourcenostarchimages287825.png.jpg"/></div></div><p class="title">Figure 18-8. VLSM example This diagram illustrates the example described in the text, of a Class C (/24) network divided using three hierarchical levels. It is first divided into two subnets; one subnet is divided into two sub-subnets; and one sub-subnet is divided into four sub-sub-subnets. The resulting six subnets, shown with thick black borders, have a maximum capacity of 126, 62, 14, 14, 14, and 14 hosts.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You first do an initial subnetting by using one bit for the subnet ID, leaving you seven bits for the host ID and two subnets: 201.45.222.0/25 and 201.45.222.128/25. Each of these can have a maximum of 126 hosts. You set aside the first of these for subnet S6 and its 100 hosts.</p></li><li class="listitem"><p>You take the second subnet, 201.45.222.128/25, and subnet it further into two sub-subnets by taking one bit from the seven bits left in the host ID. This gives you the sub-subnets 201.45.222.128/26 and 201.45.222.192/26, each of which can have 62 hosts. You set aside the first of these for subnet S5 and its 50 hosts.</p></li><li class="listitem"><p>You take the second sub-subnet, 201.45.222.192/26, and subnet it further into four sub-sub-subnets. You take two bits from the six that are left in the host ID, which gives you four sub-sub-subnets that each can have a maximum of 14 hosts. These are used for S1, S2, S3, and S4.</p></li></ul></div><p>Although I've chosen these numbers so that they work out perfectly, you should get the picture. VLSM greatly improves both the flexibility and the efficiency of subnetting.</p><div class="note" title="Note"><h3 class="title"><a id="note-76"/>Note</h3><p><span class="emphasis"><em>In order to use VLSM, routers that support VLSM-capable routing protocols must be employed. VLSM also requires more care in how routing tables are constructed to ensure that there is no ambiguity in how to interpret an address in the network</em></span><a class="indexterm" id="idx-CHP-18-0745"/>.</p></div><p>As I mentioned earlier, VLSM is similar in concept to the way CIDR is performed. The difference between VLSM and CIDR is primarily one of focus. VLSM deals with subnets of a single network in a private organization. CIDR takes the concept you just saw in VLSM to the Internet as a whole by changing how organizational networks are allocated, replacing the single-level classful hierarchy with a multiple-layer hierarchy.</p></div></div>
<div class="chapter" title="Chapter&#xA0;19.&#xA0;IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_practical_subnet_design_an"/>Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e20526"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>When educators ask students what they consider to be the most confusing aspect in learning about networking, many say that it is IP address subnetting. While subnetting isn't all that difficult in concept, it can be a bit mind-boggling, in part due to the manipulations of binary numbers required. Many people understand the ideas behind subnetting but find it hard to follow the actual steps required to subnet a network.</p><p>For this reason, even though I explained the concepts behind subnetting in detail in the previous chapter, I felt it would be valuable to have another that provides a step-by-step look at how to perform custom subnetting. This chapter divides subnetting into five relatively straightforward stages that cover determining requirements; deciding how many bits to use for the subnet ID and host ID; and then determining important numbers such as the subnet mask, subnet addresses, and host addresses.</p><p>My focus here is on showing the practical "how" of subnetting. The topics work through two <a class="indexterm" id="idx-CHP-19-0746"/>examples using a Class B and a Class C sample network to show you how subnetting is done, and I am explicit in showing how everything is calculated. This means the section is a bit number heavy. Also, I try not to duplicate conceptual issues covered in the previous section, though a certain amount of overlap does occur. Overall, if you are not familiar with how subnetting works at all, you will want to read the previous chapter first. I do refer to topics in that chapter where appropriate, especially the summary tables. Incidentally, I only cover conventional subnetting here, not Variable Length Subnet Masking (VLSM).</p><p>This section may serve as a useful refresher or summary of subnetting <a class="indexterm" id="idx-CHP-19-0747"/>for someone who is already familiar with the basics but just wants to review the steps performed in subnetting. Again, bear in mind that subnetting is based on the older, classful IP addressing scheme, and today's Internet is classless, using Classless Inter-Domain Routing (CIDR; see <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>).</p><div class="note" title="Note"><h3 class="title"><a id="note-77"/>Note</h3><p><span class="emphasis"><em>If in reading this chapter, you find yourself wanting to do binary-to-decimal conversions or binary math, remember that most versions of Windows (and many other operating systems) have a calculator program that incorporates scientific functions</em></span>.</p></div><div class="sect1" title="IP Subnetting Step 1: Analyzing Requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_step_1_analyzing_requireme"/>IP Subnetting Step 1: Analyzing Requirements</h1></div></div></div><p>When you are building or upgrading a network as a whole, the first step isn't buying hardware, or figuring out protocols, or even design. It's <span class="emphasis"><em>requirements analysis</em></span>, the process of determining what it is the network needs to do. Without this foundation, you risk implementing a network that may perfectly match your design, but not meet the needs of your organization. The same rule applies to subnetting as well. Before you look at the gory details of host addresses and subnet masks, you must decide how to subnet the network. To do that, you must understand the requirements of the network.</p><p>Analyzing the requirements of the network for subnetting isn't difficult, because there are only a few issues that you need to consider. Since requirements analysis is usually done by asking questions, here's a list of the most important questions in analyzing subnetting requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>What class is the IP address block?</p></li><li class="listitem"><p>How many physical subnets are on the network today? (A <span class="emphasis"><em>physical subnet</em></span> generally refers to a broadcast domain on a LAN—a set of hosts on a physical network bounded by routers.)</p></li><li class="listitem"><p>Do you anticipate adding any more physical networks in the near future, and if so, how many?</p></li><li class="listitem"><p>How many hosts do you have in the largest of the subnets today?</p></li><li class="listitem"><p>How many hosts do you anticipate having in the largest subnet in the near future?</p></li></ul></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-107"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> To successfully subnet a network, you must begin by learning what the requirements of the network will be. The most important parameters to determine are the number of subnets required and the maximum number of hosts needed per subnet. Numbers should not be based on just present needs, but also take into account requirements anticipated in the near future.</p></div><p>The first question is important because everything in subnetting is based around dividing up a Class A, Class B, or Class C network, so you need to know which one you are dealing with. If you are in the process of designing a network from scratch and don't have a Class A, B, or C block yet, then you will determine which one you need based on the approximate size of the organization.</p><p>After that, you need to determine two key numbers: how many physical subnets you have and the maximum number of hosts per subnet. You need to know these not only for the present network, but for the <span class="emphasis"><em>near future</em></span> as well. The current values for these two numbers represent how the network needs to be designed today. However, designing only for the present is not a good idea.</p><p>Suppose you have exactly four subnetworks in the network now. In theory, you could use only two bits for the subnet ID, since 2<sup>2</sup> equals 4. However, if the company were growing rapidly, this would be a poor choice. When you needed to add a fifth subnet, you would have a problem!</p><p>Similarly, consider the growth in the number of hosts in a subnet. If the current largest subnet has 60 hosts, you don't want six bits for the host ID, because that limits you to 62 hosts. You can divide large subnets into smaller ones, but this may just mean unnecessary additional work.</p><p>So what is the "near future?" The term is necessarily vague, because it depends on how far into the future the organization wants to look. On the one hand, planning for several years' growth can make sense, if you have enough IP addresses to do it. On the other, you don't want to plan too far out, since changes in the short term may cause you to completely redesign your network anyway.</p></div></div>
<div class="sect1" title="IP Subnetting Step 2: Partitioning Network Address Host Bits"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_step_2_partitioning_networ"/>IP Subnetting Step 2: Partitioning Network Address Host Bits</h1></div></div></div><p>After you complete the brief requirements analysis, you should know the two critical parameters that you must have in order to subnet the network: the number of subnets required for the network and the maximum number of hosts per subnetwork. In using these figures to design the subnetted network, you will be faced with the key design decision in subnetting: how to divide the 8, 16, or 24 bits in the classful host ID into the subnet ID and host ID.</p><p>Put another way, you need to decide how many bits to steal from the host ID to use for the subnet ID. As I explained in the section on custom subnet masks in the previous chapter, the fundamental trade-off in choosing this number is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Each bit taken from the host ID for the subnet ID doubles the number of subnets that are possible in the network.</p></li><li class="listitem"><p>Each bit taken from the host ID for the subnet ID (approximately) halves the number of hosts that are possible within each subnet on the network.</p></li></ul></div><p>There are six possible ways this decision can be made for a Class C network, as illustrated in <a class="xref" href="ch19s02.html#subnetting_design_trade-off_for_class_c_" title="Figure 19-1. Subnetting design trade-off for Class C networks This drawing shows the options for subnetting a Class C network. As you increase the number of bits for the host ID, you increase the number of subnets, but decrease the size of each.">Figure 19-1</a>.</p><div class="figure"><a id="subnetting_design_trade-off_for_class_c_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e20630"/><img alt="Subnetting design trade-off for Class C networks This drawing shows the options for subnetting a Class C network. As you increase the number of bits for the host ID, you increase the number of subnets, but decrease the size of each." src="httpatomoreillycomsourcenostarchimages287827.png.jpg"/></div></div><p class="title">Figure 19-1. Subnetting design trade-off for Class C networks This drawing shows the options for subnetting a Class C network. As you increase the number of bits for the host ID, you increase the number of subnets, but decrease the size of each.</p></div><p>The relationship between the bits and the number of subnets and hosts is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The number of subnets allowed in the network is two to the power of the number of subnet ID bits.</p></li><li class="listitem"><p>The number of hosts allowed per subnet is two to the power of the number of host ID bits, less two.</p></li></ul></div><p>You subtract two from the number of hosts in each subnet to exclude the special meaning cases where the host ID is all zeros or all ones. As I explained in the previous chapter, this exclusion was originally also applied to the subnet ID, but is no longer in newer systems.</p><p>To choose how many bits to use for the subnet, you could use trial and error. By this, I mean you could try to first calculate the number of subnets and hosts when you use one bit for the subnet ID and leave the rest for the host ID. You could then try with two bits for the subnet ID, and then try with three, and so on. This would be silly, however; it's time-consuming and makes it hard for you to choose the best option. There's an easier method: You can use the subnetting summary tables, presented in the previous chapter. They let you look at all the options, and you can usually see immediately the best one for you.</p><div class="sect2" title="Class C Subnetting Design Example"><div class="titlepage"><div><div><h2 class="title"><a id="class_c_subnetting_design_example"/>Class C Subnetting Design Example</h2></div></div></div><p><a class="indexterm" id="idx-CHP-19-0748"/>Let's take an example. Suppose you have a Class C network, base address 211.77.20.0, with a total of seven subnets. The maximum number of hosts per subnet is 25. Looking at the subnetting summary table for Class C (<a class="xref" href="ch18s07.html#subnetting_summary_table_for_class_c_net" title="Table 18-5. Subnetting Summary Table for Class C Networks">Table 18-5</a> in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>), the answer is instantly clear: You need three bits for the subnet ID. Why? This allows you eight subnets and 30 hosts per subnet. If you try to choose two bits, you can't define enough subnets (only four). As <a class="xref" href="ch19s02.html#example_of_class_c_subnetting_in_this_pa" title="Figure 19-2. Example of Class C subnetting In this particular example, where seven subnets are needed and 25 hosts are needed for the largest subnet, there is only one choice of subnet ID size that meets the requirements. It's an easy decision!">Figure 19-2</a> shows, if you choose four bits for the subnet ID, then you can have only 14 hosts per subnet.</p><div class="figure"><a id="example_of_class_c_subnetting_in_this_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e20669"/><img alt="Example of Class C subnetting In this particular example, where seven subnets are needed and 25 hosts are needed for the largest subnet, there is only one choice of subnet ID size that meets the requirements. It's an easy decision!" src="httpatomoreillycomsourcenostarchimages287829.png.jpg"/></div></div><p class="title">Figure 19-2. Example of Class C subnetting In this particular example, where seven subnets are needed and 25 hosts are needed for the largest subnet, there is only one choice of subnet ID size that meets the requirements. It's an easy decision!</p></div></div><div class="sect2" title="Class B Subnetting Design Example"><div class="titlepage"><div><div><h2 class="title"><a id="class_b_subnetting_design_example"/>Class B Subnetting Design Example</h2></div></div></div><p>In some cases, especially with larger networks, you may have multiple choices. Consider, as a more interesting <a class="indexterm" id="idx-CHP-19-0749"/>example, the larger Class B network 166.113.0.0, where you have a total of 15 subnets and the largest has 450 hosts. Examining the subnet summary table for Class B (<a class="xref" href="ch18s07.html#subnetting_summary_table_for_class_b_net" title="Table 18-4. Subnetting Summary Table for Class B Networks">Table 18-4</a> in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>) suggests four acceptable options, as shown in <a class="xref" href="ch19s02.html#example_of_class_b_subnetting_this_class" title="Figure 19-3. Example of Class B subnetting This Class B network needs at least 15 subnets and must allow up to 450 hosts per subnet. Three subnet ID bits are too few, and eight bits means only 254 hosts per subnet, which is insufficient. This leaves four acceptable options, so you must choose wisely.">Figure 19-3</a>.</p><p>In all four of these options, the number of subnets is equal to 15 or greater, and the number of hosts per subnet is over 450. So which option should you choose? Usually, you want to pick something in the middle. If you use four bits for the subnet ID, this gives you a maximum of only 16 subnets, which limits growth in the number of subnets, since you already have 15. The same applies to the choice of seven bits for the subnet ID, since you already have 450 hosts in one subnet now, and that limits you to 510. Thus, you probably want either five or six bits here. If you expect more growth in the number of hosts in the largest subnet, you should choose five bits; if you expect more growth in the number of subnets, you should choose six bits. If you're unsure, it's probably best to assume more growth in the number of hosts per subnet, so here you would choose five bits.</p><p>The converse problem may also occur: You may be in a position where there don't appear to be any options—no rows in the summary table match. For example, if the Class C example had 35 hosts in the largest subnet instead of 25, you would be out of luck, because there is no combination of subnet ID and host ID size that works. The same is true in the Class B example if you had 4,500 hosts in that big subnet instead of 450. In this situation, you would need to divide the large subnet into a smaller one, use more than one IP address block, or upgrade to a larger block.</p><div class="figure"><a id="example_of_class_b_subnetting_this_class"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e20701"/><img alt="Example of Class B subnetting This Class B network needs at least 15 subnets and must allow up to 450 hosts per subnet. Three subnet ID bits are too few, and eight bits means only 254 hosts per subnet, which is insufficient. This leaves four acceptable options, so you must choose wisely." src="httpatomoreillycomsourcenostarchimages287831.png.jpg"/></div></div><p class="title">Figure 19-3. Example of Class B subnetting This Class B network needs at least 15 subnets and must allow up to 450 hosts per subnet. Three subnet ID bits are too few, and eight bits means only 254 hosts per subnet, which is insufficient. This leaves four acceptable options, so you must choose wisely.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-108"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> If there is more than one combination of subnet ID and host ID sizes that will meet requirements, try to choose a middle-of-the-road option that best anticipates future growth requirements. If no combination meets the requirements, the requirements have to change!</p></div></div></div>
<div class="sect1" title="IP Subnetting Step 3: Determining the Custom Subnet Mask"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_step_3_determining_the_cus"/>IP Subnetting Step 3: Determining the Custom Subnet Mask</h1></div></div></div><p>Once you have decided how many bits to use for the subnet ID and how many to leave for the host ID, you can determine the custom subnet mask for the network. Now, don't go running for cover on me. A lot of people's eyes glaze over at mention of the subnet mask, but it's really quite simple to figure out once you have done the homework in making the design decision you did in step 2. In fact, there are two ways of doing this; one is less work than the other, but they're both quite easy. I was going to call them the hard way and the easy way, but instead, I'll call them easy and easier.</p><div class="sect2" title="Calculating the Custom Subnet Mask"><div class="titlepage"><div><div><h2 class="title"><a id="calculating_the_custom_subnet_mask"/>Calculating the Custom Subnet Mask</h2></div></div></div><p>Let's start with the easy method, in which you calculate the subnet mask in binary form from the information you already have about the network, and then convert the mask to decimal. To refresh your memory and guide the process, remember this: The subnet mask is a 32-bit binary number where a one represents each bit that is part of the network ID or subnet ID, and a zero represents each bit of the host ID.</p><div class="sect3" title="Class C Custom Subnet Mask Calculation Example"><div class="titlepage"><div><div><h3 class="title"><a id="class_c_custom_subnet_mask_calculation_e"/>Class C Custom Subnet Mask Calculation Example</h3></div></div></div><p>Refer back to the Class C example in the previous section (<a class="xref" href="ch19s02.html#example_of_class_c_subnetting_in_this_pa" title="Figure 19-2. Example of Class C subnetting In this particular example, where seven subnets are needed and 25 hosts are needed for the largest subnet, there is only one choice of subnet ID size that meets the requirements. It's an easy decision!">Figure 19-2</a>). Say you decided to use three bits for the subnet ID, leaving five bits for the host ID. Here are the steps you will follow to determine the custom subnet mask for this network (illustrated in <a class="xref" href="ch19s03.html#determining_the_custom_subnet_mask_for_a" title="Figure 19-4. Determining the custom subnet mask for a Class C network">Figure 19-4</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Determine Default Subnet Mask</strong></span> Each of Classes A, B, and C has a default subnet mask, which is the subnet mask for the network prior to subnetting. It has a one for each network ID bit and a zero for each host ID bit. For Class C, the subnet mask is 255.255.255.0. In binary, this is:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11111111 11111111 11111111 00000000</td></tr></table></li><li class="listitem"><p><span class="strong"><strong>Change Leftmost Zeros to Ones for Subnet Bits</strong></span> You have decided to use three bits for the subnet ID. The subnet mask must have a one for each of the network ID or subnet ID bits. The network ID bits are already one from the default subnet mask, so, you change the three <span class="emphasis"><em>leftmost</em></span> zero bits in the default subnet mask from a 0 to 1, as shown in bold here. This results in the following custom subnet mask for the network:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11111111 11111111 11111111 <span class="strong"><strong>111</strong></span>00000</td></tr></table></li><li class="listitem"><p><span class="strong"><strong>Convert Subnet Mask to Dotted Decimal Notation</strong></span> You take each of the octets in the subnet mask and convert it to decimal. The result is the custom subnet mask in the form you usually see it: 255.255.255.224.</p></li><li class="listitem"><p><span class="strong"><strong>Express Subnet Mask in <a class="indexterm" id="idx-CHP-19-0750"/>Slash Notation</strong></span> Alternatively, you can express the subnet mask in <span class="emphasis"><em>slash notation</em></span>. This is just a slash followed by the number of ones in the subnet mask. 255.255.255.224 is equivalent to /27.</p></li></ol></div></div><div class="sect3" title="Class B Custom Subnet Mask Calculation Example"><div class="titlepage"><div><div><h3 class="title"><a id="class_b_custom_subnet_mask_calculation_e"/>Class B Custom Subnet Mask Calculation Example</h3></div></div></div><p>Now let's do the same example with the Class B network (166.113.0.0) with five bits for the subnet ID (with a bit less narration this time; see <a class="xref" href="ch19s03.html#determining_the_custom_subnet_mask-id001" title="Figure 19-5. Determining the custom subnet mask for a Class B network">Figure 19-5</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Determine Default Subnet Mask</strong></span> For Class B, the subnet mask is 255.255.0.0. In binary, this is:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11111111 11111111 00000000 00000000</td></tr></table></li><li class="listitem"><p><span class="strong"><strong>Change Leftmost Zeros to Ones for Subnet Bits</strong></span> If you use five bits for the subnet ID, you change the five leftmost zero bits from a 0 to 1, as shown in bold, to give you the binary custom subnet mask, as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11111111 11111111 <span class="strong"><strong>11111</strong></span>000 00000000</td></tr></table><div class="figure"><a id="determining_the_custom_subnet_mask_for_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e20800"/><img alt="Determining the custom subnet mask for a Class C network" src="httpatomoreillycomsourcenostarchimages287833.png.jpg"/></div></div><p class="title">Figure 19-4. Determining the custom subnet mask for a Class C network</p></div></li><li class="listitem"><p><span class="strong"><strong>Convert Subnet Mask to Dotted Decimal Notation</strong></span> You take each of the octets in the subnet mask and convert it to decimal to give you a custom subnet mask of 255.255.<span class="strong"><strong>248</strong></span>.0.</p></li><li class="listitem"><p><span class="strong"><strong>Express Subnet Mask in Slash Notation</strong></span> You can express the subnet mask 255.255.248.0 as /21, since it is 21 ones followed by 11 zeros. In other words, its prefix length is 21.</p></li></ol></div><div class="figure"><a id="determining_the_custom_subnet_mask-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e20821"/><img alt="Determining the custom subnet mask for a Class B network" src="httpatomoreillycomsourcenostarchimages287835.png.jpg"/></div></div><p class="title">Figure 19-5. Determining the custom subnet mask for a Class B network</p></div></div></div><div class="sect2" title="Determining the Custom Subnet Mask Using Subnetting Tables"><div class="titlepage"><div><div><h2 class="title"><a id="determining_the_custom_subnet_mask_using"/>Determining the Custom Subnet Mask Using Subnetting Tables</h2></div></div></div><p>Now, what could be easier than that? Well, you could simply refer to the subnetting summary tables, presented in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>. Find the table for the appropriate class, and then find the row that you selected in the previous step that matches the number of subnet ID bits you want to use. You can see the matching subnet mask right there.</p><p>(Hey, it's good to know how to do it yourself! You may not always have tables to refer to!)</p></div></div>
<div class="sect1" title="IP Subnetting Step 4: Determining Subnet Identifiers and Subnet Addresses"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_step_4_determining_subnet_"/>IP Subnetting Step 4: Determining Subnet Identifiers and Subnet Addresses</h1></div></div></div><p>The network ID assigned to the network applies to the entire network. This includes all subnets and all hosts in all subnets. Each subnet, however, needs to be identified with a unique <span class="emphasis"><em>subnet identifier</em></span>, or <span class="emphasis"><em>subnet ID</em></span>, so it can be differentiated from the other subnets in the network. This is the purpose of the subnet ID bits that you took from the host ID bits in subnetting. After you have identified each subnet, you need to determine the address of each subnet, so you can use this in assigning hosts specific IP addresses.</p><p>This is another step in subnetting that is not really hard to understand or do. The key to understanding how to determine subnet IDs and subnet addresses is to always work in binary form, and then convert to decimal later. You will also look at a shortcut for determining addresses in decimal directly, which is faster but less conceptually simple.</p><div class="note" title="Note"><h3 class="title"><a id="note-78"/>Note</h3><p><span class="emphasis"><em>I assume in this description that you will be using the all-zeros and all-ones subnet numbers. In the original RFC 950 subnetting system, those two subnets are not used, which changes most of the following calculations. See <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a> for an explanation</em></span>.</p></div><p>You number the subnets starting with 0, and then 1, 2, 3, and so on, up to the highest subnet ID that you need. You determine the subnet IDs and addresses as follows:</p><p><span class="strong"><strong>Subnet ID</strong></span> This is just the subnet number, and it can be expressed in either binary or decimal form.</p><p><span class="strong"><strong>Subnet Address</strong></span> This is the address formed by taking the address of the network as a whole and substituting the (binary) subnet ID for the subnet ID bits. You need to do this in binary, but only for the octets where there are subnet ID bits; the ones where there are only network ID bits or only host ID bits are left alone.</p><p>Seem complicated? Let's go back to the examples, and you'll see that it really isn't.</p><div class="sect2" title="Class C Subnet ID and Address Determination Example"><div class="titlepage"><div><div><h2 class="title"><a id="class_c_subnet_id_and_address_determinat"/>Class C Subnet ID and Address Determination Example</h2></div></div></div><p>You'll recall the Class C example network, 211.77.20.0. The network address in binary is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 00000000</td></tr></table><p>You are subnetting using three bits for the subnet ID, leaving five bits for the host ID. Now let's see the network address with the subnet bits in bold:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>000</strong></span>00000</td></tr></table><p>These are the bits that you substitute with the subnet ID for each subnet. Notice that since the first three octets contain network ID bits, and the network ID is the same for every subnet, they never change. You don't even really need to look at them in binary form, though for clarity, you will do so here.</p><p>Here's how you determine the subnet IDs and addresses, again, starting with 0 (see <a class="xref" href="ch19s04.html#determining_subnet_addresses_for_a_class" title="Figure 19-6. Determining subnet addresses for a Class C network This diagram shows each of the eight possible subnets created when you use three bits for the subnet ID in a Class C network. The binary subnet ID is simply substituted for the subnet bits, and the resulting 32-bit number is converted to dotted decimal form.">Figure 19-6</a>):</p><p><span class="strong"><strong>Subnet 0</strong></span> This has a subnet ID of 0, or 000 in binary. To find the address, you start with the network address in binary and substitute 000 for the subnet ID bits. Well gee, those bits are already all zero! What this means is that the address for subnet 0 is the same as the address for the network as a whole: 211.77.20.0. This is always the case: subnet 0 always has the same address as the network.</p><p><span class="strong"><strong>Subnet 1</strong></span> This has a subnet ID of 1 in decimal or 001 in binary. To find the address, you substitute 001 for the subnet ID bits, which yields the following:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>001</strong></span>00000</td></tr><tr><td>Converting to decimal, you get 211.77.20.32.</td></tr></table><p><span class="strong"><strong>Subnet 2</strong></span> This has a subnet ID of 2, or 010 in binary. To find its address, you substitute 010 for the subnet ID bits, to give you the following:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>010</strong></span>00000</td></tr><tr><td>Which is 211.77.20.64 in binary.</td></tr></table><p><span class="strong"><strong>Subnet 3</strong></span> This has a subnet ID of 011. As you can see, the first three octets of the address are always 211.77.20. The last octet here is <span class="strong"><strong>011</strong></span>00000, which is 96 in decimal, so the whole address is 211.77.20.96.</p><p>Starting to see a pattern here? Yes, the address of any subnet can be found by adding 32 to the last octet of the previous subnet. This pattern occurs for all subnetting choices; the increment depends on how many bits you are using for the subnet ID. Here, the increment is 32, which is 2<sup>5</sup>; 5 is the number of host ID bits left after you took three subnet ID bits.</p><p><span class="strong"><strong>Subnet 4</strong></span> This has a subnet ID of 100. Its address is 211.77.20.128.</p><p><span class="strong"><strong>Subnet 5</strong></span> This has a subnet ID of 101. Its address is 211.77.20.160.</p><p><span class="strong"><strong>Subnet 6</strong></span> This has a subnet ID of 110. Its address is 211.77.20.192.</p><p><span class="strong"><strong>Subnet 7</strong></span> This has a subnet ID of 111. Its address is 211.77.20.224.</p><div class="figure"><a id="determining_subnet_addresses_for_a_class"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e20949"/><img alt="Determining subnet addresses for a Class C network This diagram shows each of the eight possible subnets created when you use three bits for the subnet ID in a Class C network. The binary subnet ID is simply substituted for the subnet bits, and the resulting 32-bit number is converted to dotted decimal form." src="httpatomoreillycomsourcenostarchimages287837.png.jpg"/></div></div><p class="title">Figure 19-6. Determining subnet addresses for a Class C network This diagram shows each of the eight possible subnets created when you use three bits for the subnet ID in a Class C network. The binary subnet ID is simply substituted for the subnet bits, and the resulting 32-bit number is converted to dotted decimal form.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-109"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The subnet addresses in a subnetted network are always evenly spaced numerically, with the spacing depending on the number of subnet ID bits.</p></div><p>This example needed only seven subnets, 0 through 6. Subnet 7 would be a spare. Notice that the last subnet has the same last octet as the subnet mask for the network? That's because I substituted 111 for the subnet ID bits, just as in the subnet mask calculation.</p></div><div class="sect2" title="Class B Subnet ID and Address Determination Example"><div class="titlepage"><div><div><h2 class="title"><a id="class_b_subnet_id_and_address_determinat"/>Class B Subnet ID and Address Determination Example</h2></div></div></div><p>Let's look at the other example now, Class B network 166.113.0.0. In binary this is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>0100110 01110001 00000000 00000000</td></tr></table><p>You're using five bits for the subnet ID, leaving 11 host ID bits. The network address with the subnet ID bits highlighted is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>0100110 01110001 <span class="strong"><strong>00000</strong></span>000 00000000</td></tr></table><p>Here, only the third octet will ever change for the different subnets. The first two will always be 166.113, and the last octet will always be 0. There are 32 possible subnets; I'll list the first few so you can see the pattern (refer to <a class="xref" href="ch19s04.html#determining_subnet_addresses_for_a-id001" title="Figure 19-7. Determining subnet addresses for a Class B network This is the same as Figure 19-6, but for a Class B network with five subnet ID bits (I have not shown all 32 subnets, for obvious reasons).">Figure 19-7</a> as well):</p><p><span class="strong"><strong>Subnet 0</strong></span> This has a subnet ID of 00000. This means the address will be 166.113.0.0, which is the network address, as you would expect.</p><p><span class="strong"><strong>Subnet 1</strong></span> This has a subnet ID of 00001. The address becomes</p><table border="0" class="simplelist" summary="Simple list"><tr><td>10100110 01110001 <span class="strong"><strong>00001</strong></span>000 00000000</td></tr><tr><td>This is 116.113.8.0 in decimal.</td></tr></table><p><span class="strong"><strong>Subnet 2</strong></span> This has a subnet ID of 00010, giving an address of 116.113.<span class="strong"><strong>00010</strong></span>000.0 or 116.113.16.0.</p><p><span class="strong"><strong>Subnet 3</strong></span> This has a subnet ID of 00011 and a subnet address of 116.113.24.0.</p><div class="figure"><a id="determining_subnet_addresses_for_a-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e21014"/><img alt="Determining subnet addresses for a Class B network This is the same as , but for a Class B network with five subnet ID bits (I have not shown all 32 subnets, for obvious reasons)." src="httpatomoreillycomsourcenostarchimages287839.png.jpg"/></div></div><p class="title">Figure 19-7. Determining subnet addresses for a Class B network This is the same as <a class="xref" href="ch19s04.html#determining_subnet_addresses_for_a_class" title="Figure 19-6. Determining subnet addresses for a Class C network This diagram shows each of the eight possible subnets created when you use three bits for the subnet ID in a Class C network. The binary subnet ID is simply substituted for the subnet bits, and the resulting 32-bit number is converted to dotted decimal form.">Figure 19-6</a>, but for a Class B network with five subnet ID bits (I have not shown all 32 subnets, for obvious reasons).</p></div><p><a class="indexterm" id="idx-CHP-19-0751"/>Again, the pattern here is obvious: You add eight to the third octet to get successive addresses. The last subnet here is 31, which has a subnet address of 116.113.248.0, which has the same third and fourth octets as the subnet mask of 255.255.248.0.</p></div><div class="sect2" title="Using Subnet Address Formulas to Calculate Subnet Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="using_subnet_address_formulas_to_calcula"/>Using Subnet Address Formulas to Calculate Subnet Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-19-0752"/>Since the subnet addresses form a pattern, and the pattern depends on the number of subnet ID bits, it is possible to express the subnet addresses using a single formula for each subnetting option. I have shown these formulas for each of the Classes A, B, and C in the subnetting summary tables in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>. The formulas can be used to directly calculate the address of subnet <span class="emphasis"><em>N</em></span>, where <span class="emphasis"><em>N</em></span> is numbered from 0 up to one less than the total number of subnets, as I have done earlier.</p><p>In these formulas, the network ID bits are shown as x., x.y., or x.y.z. for the three classes. This just means that the subnet addresses have as those octets whatever the numbers are in those octets for the network address. In the examples, x.y would be 166.113 for the Class B network, and x.y.z would be 211.77.20 for the Class C network.</p><p>When the number of subnet bits is eight or less, the formula is relatively simple, and a calculation is done for only one octet, as a multiplication of <span class="emphasis"><em>N</em></span>, such as <span class="emphasis"><em>N</em></span>*4 or <span class="emphasis"><em>N</em></span>*32. This is usually the case, since the number of subnets is usually less than 256, and it's the case with both of the examples.</p><p>In the Class C network with three subnet ID bits, the formula from the table is x.y.z.<span class="emphasis"><em>N</em></span>*32. For this network, all subnets are of the form 211.77.20.<span class="emphasis"><em>N</em></span>*32, with <span class="emphasis"><em>N</em></span> going from zero to seven. So, subnet 5 is 211.77.20.(5*32), which is 211.77.20.160, as you saw before. Similarly, in the Class B network with five subnet ID bits, the formula is x.y.<span class="emphasis"><em>N</em></span>*8.0. In this case, x.y is 166.113. Subnet 26 would have the address 166.113.(26*8).0, or 166.113.208.0.</p><p>This is pretty simple stuff, and it makes the formulas a good shortcut for quickly determining subnet addresses, especially when there are many subnets. They can also be used in a spreadsheet.</p><p>The only place where using the formulas requires a bit of care is when the number of subnet bits is nine or more. This means that the subnet identifier crosses an octet boundary, and this causes the formula to become more complex.</p><p>When the number of subnet bits is greater than eight, some of the octets are of the form <span class="emphasis"><em>N</em></span> divided by an integer, such as <span class="emphasis"><em>N</em></span>/8. This is an integer division, which means divide <span class="emphasis"><em>N</em></span> by 8, keep the integer part, and drop the fractional part or remainder. Other octets are calculated based on the modulo of <span class="emphasis"><em>N</em></span>, shown as <span class="emphasis"><em>N</em></span>%8. This is the exact opposite: It means divide <span class="emphasis"><em>N</em></span> by 8, drop the integer, and keep the remainder. For example, 33/5 in integer math is 6 (6 with a remainder of 3, drop the remainder, or alternately, 6.6, drop the fraction), and 33%5 is 3 (6 with a remainder of 3, drop the 6, keep the remainder).</p><p>Let's take as an example the Class B network and suppose that for some strange reason you decided to use ten bits for the subnet ID instead of five. In this case, the formula is x.y.<span class="emphasis"><em>N</em></span>/4.(N%4)*64. Subnet 23 in this case would have the address 166.113.23/4.(23%4)*64. The 23/4 becomes just 5 (the fractional .75 is dropped). 23 modulo 4 is 3, which is multiplied by 64 to get 192. So the subnet address is 166.113.5.192. Subnet 709 would be 116.113.709/4.(709%4)*64, which is 116.113.177.64.</p><p>Okay, now for the real fun! If you subnet a Class A address using more than 16 bits for the subnet ID, you are crossing <span class="emphasis"><em>two</em></span> octet boundaries, and the formulas become very … interesting, involving both integer division <span class="emphasis"><em>and</em></span> modulo. Suppose you were in charge of Class A address 21.0.0.0 and decide to subnet it. However, you sat down to do this after having had a few stiff ones at the office holiday party, so your judgment is a bit impaired. You decide that it would be a great idea to choose 21 bits for the subnet ID, since you like the number 21. This gives you a couple million subnets.</p><p>The formula for subnet addresses in this case is rather long and complicated: x.<span class="emphasis"><em>N</em></span>/8192.(<span class="emphasis"><em>N</em></span>/32)%256.(<span class="emphasis"><em>N</em></span>%32)*8. Yikes. Well, this is a bit involved—so much so that it might be easier to just take a subnet number and do it in binary, the long way. But let's take an example and see how it works for, say, subnet 987654. The first octet is 21. The second octet is 987654/8192, integer division. This is 120. The third octet is (987654/32)%256. The result of the division is 30864 (you drop the fraction). Then you take 30864%256, which yields a remainder of 144. The fourth octet is (987654%32)*8. This is 6*8 or 48. So subnet address 987654 is 21.120.144.48.</p><p>(Don't drink and drive. Don't drink and subnet either.)</p></div></div>
<div class="sect1" title="IP Subnetting Step 5: Determining Host Addresses for Each Subnet"><div class="titlepage"><div><div><h1 class="title"><a id="ip_subnetting_step_5_determining_host_ad"/>IP Subnetting Step 5: Determining Host Addresses for Each Subnet</h1></div></div></div><p>Once you know the addresses of each of the subnets in the network, you use these addresses as the basis for assigning IP addresses to the individual hosts in each subnet. You start by associating a subnet base address with each physical network (since at least in theory, the subnets correspond to the physical networks). You then sequentially assign hosts particular IP addresses within the subnet (or in a different manner, if you prefer!).</p><p>Determining host addresses is really quite simple once you know the subnet address. All you do is substitute the numbers 1, 2, 3, and so on for the host ID bits in the subnet address. You must do this in binary and then convert the address to decimal form. Again, you can take some shortcuts once the rather obvious pattern of how to assign addresses emerges. You'll look at those near the end of the chapter.</p><div class="sect2" title="Class C Host Address Determination Example"><div class="titlepage"><div><div><h2 class="title"><a id="class_c_host_address_determination_examp"/>Class C Host Address Determination Example</h2></div></div></div><p>Let's start with the Class C example again, 211.77.20.0, which you divided into eight subnets using three subnet bits. Here's how the address appears with the subnet bits shown in bold, and the host ID bits shown in italics:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>000</strong></span><span class="bolditalic">00000</span></td></tr></table><p>The first subnet is subnet 0, which has all zeros for those subnet bits, and thus the same address as the network as a whole: 211.77.20.0. You substitute the numbers 1, 2, 3, and so on for the italicized bits to get the host IDs. (Remember that you don't start with zero here because for the host ID, the all-zeros and all-ones binary patterns have special meaning). So it goes like this:</p><p>The first host address has the number 1 for the host ID, or 00001 in binary. So it is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>000</strong></span><span class="bolditalic">00001</span></td></tr></table><p>In decimal, this is 211.77.20.1.</p><p>The second host address has the number 2 for the host ID, or 00010 in binary. Its binary value is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>000</strong></span><span class="bolditalic">00010</span></td></tr></table><p>In decimal, this is 211.77.20.2.</p><p>I'm sure you get the picture already; the third host will be 211.77.20.3, the fourth 211.77.20.4, and so on. There is a maximum of 30 hosts in each subnet, as you saw earlier. So the last host in this subnet will be found by substituting 30 (11110 in binary) for the host ID bits, resulting in a decimal address of 211.77.20.30.</p><p>You can do the same thing for each of the other subnets; the only thing that changes is the values in the subnet ID bits. Let's take subnet 6, for example. It has 110 for the subnet bits instead of 000. So its subnet base address is 211.77.20.192, or</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>110</strong></span><span class="bolditalic">00000</span></td></tr></table><p>You assign hosts to this subnet by substituting 00001, then 00010, then 00011 for the host ID bits as shown earlier. Let's take the hosts one at a time:</p><p>The first host address is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>110</strong></span><span class="bolditalic">00001</span></td></tr></table><p>or 211.77.20.193.</p><p>The second host address is</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010011 01001101 00010100 <span class="strong"><strong>110</strong></span><span class="bolditalic">00010</span></td></tr></table><p>or 211.77.20.194.</p><p>And so on, all the way up to the last host in the subnet, which is 211.77.20.222. <a class="xref" href="ch19s05.html#determining_host_addresses_for_a_class_c" title="Figure 19-8. Determining host addresses for a Class C network This diagram shows how both subnet addresses and host addresses are determined in a two-step process. The subnet addresses are found by substituting subnet ID values (shown in bold) for the subnet ID bits of the network. Then, for any given subnet address, you can determine a host address by substituting a host number (shown in bold and italicized) for the host ID bits within that subnet. So, for example, host 2 in subnet 6 has 110 for the subnet ID and 00010 for the host ID, resulting in a final octet value of 11000010, or 194.">Figure 19-8</a> shows graphically how subnet and host addresses are calculated for this sample network.</p><p>One more address you may wish to calculate is the broadcast address for the subnet. This is one of the special cases, as discussed in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>, found by substituting all ones for the host ID. For subnet 0, this would be 211.77.20.31. For subnet 6, it would be 211.77.20.223. That's pretty much all there is to it.</p><div class="figure"><a id="determining_host_addresses_for_a_class_c"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e21218"/><img alt="Determining host addresses for a Class C network This diagram shows how both subnet addresses and host addresses are determined in a two-step process. The subnet addresses are found by substituting subnet ID values (shown in bold) for the subnet ID bits of the network. Then, for any given subnet address, you can determine a host address by substituting a host number (shown in bold and italicized) for the host ID bits within that subnet. So, for example, host 2 in subnet 6 has 110 for the subnet ID and 00010 for the host ID, resulting in a final octet value of 11000010, or 194." src="httpatomoreillycomsourcenostarchimages287841.png.jpg"/></div></div><p class="title">Figure 19-8. Determining host addresses for a Class C network This diagram shows how both subnet addresses and host addresses are determined in a two-step process. The subnet addresses are found by substituting subnet ID values (shown in bold) for the subnet ID bits of the network. Then, for any given subnet address, you can determine a host address by substituting a host number (shown in bold and italicized) for the host ID bits within that subnet. So, for example, host 2 in subnet 6 has 110 for the subnet ID and 00010 for the host ID, resulting in a final octet value of 11000010, or 194.</p></div></div><div class="sect2" title="Class B Host Address Determination Example"><div class="titlepage"><div><div><h2 class="title"><a id="class_b_host_address_determination_examp"/>Class B Host Address Determination Example</h2></div></div></div><p><a class="indexterm" id="idx-CHP-19-0753"/>You can do the same thing for the Class B network, naturally. The address of that network is 166.113.0.0. Now say you want to define the hosts that go in subnet 13. You substitute 13 in binary (01101) for the subnet ID bits to get the following subnet address, which is shown with the subnet ID bits in bold and the host ID bits in italics:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>10100110 01110001 <span class="strong"><strong>01101</strong></span><span class="bolditalic">000 00000000</span></td></tr></table><p>This is the subnet address 166.113.104.0. Now you have 11 bits of host ID, so you can have a maximum of 2,046 hosts. The first is found by substituting 000 00000001 for the host ID bits, which gives an address of 166.113.104.1. The second host is 166.113.104.2, and so on. The last is found by substituting 111 11111110, which gives an address of 166.113.111.254. Note that since the host ID bits extend over two octets, two octets change as you increment the host ID, unlike the Class C example. The broadcast address is 166.113.111.255.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-110"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In a subnetted network, the address of Host H within subnet number <span class="emphasis"><em>S</em></span> is found by plugging in the binary value of <span class="emphasis"><em>S</em></span> for the network's subnet ID bits, and the binary value of <span class="emphasis"><em>H</em></span> for the subnet's host ID bits.</p></div></div><div class="sect2" title="Shortcuts for Computing Host Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="shortcuts_for_computing_host_addresses"/>Shortcuts for Computing Host Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-19-0754"/><a class="indexterm" id="idx-CHP-19-0755"/>As you can see, defining the host IDs is really quite straightforward. If you can substitute bits and convert to decimal, you have all you need to know. You can also see that, as was the case with defining the subnet addresses, there are patterns that you can use in defining host IDs and understanding how they work. These generally define ways for which you can more quickly determine certain host addresses by working directly in decimal instead of bothering with binary substitutions. This is a bit more complex conceptually, so proceed only if you are feeling a bit brave.</p><p>The following are some of the shortcuts you can use in determining host IP addresses in a subnet environment:</p><p><span class="strong"><strong>First Host Address</strong></span> <span class="emphasis"><em>The first host address is always the subnet address with the last octet incremented by 1</em></span>. So in the Class C example, subnet 3's base address is 211.77.20.96. The first host address in subnet 3 is thus 211.77.20.97.</p><p><span class="strong"><strong>Subsequent Host Addresses</strong></span> After you find the first host address, to get the next one, you just add one to the last octet of the previous address. If this makes the last octet 256 (which can happen only if there are more than eight host ID bits), you "wrap around" this to zero and increment the third octet.</p><p><span class="strong"><strong>Directly Calculating Host Addresses</strong></span> If the number of host ID bits is eight or less, you can find host <span class="emphasis"><em>N</em></span>'s address by adding <span class="emphasis"><em>N</em></span> to the last octet's decimal value. For example, in the Class C example, subnet 3's base address is 211.77.20.96. Therefore, host 23 in this subnet has an address of 211.77.20.119. If there are more than eight bits in the host ID, this works for only the first 255 hosts, after which you need to wrap around and increase the value of the third octet. Consider again subnet 13 in the Class B example, which has a base address of 166.113.104.0. Host 214 on this subnet has address 166.113.104.0, but host 314 isn't 166.113.104.314. It is 166.113.105.58 (host 255 is 166.113.104.255, then host 256 is 166.113.105.0, and you count up 58 more (314–256) to get to 314, 166.113.105.58).</p><p><span class="strong"><strong>Range of Host Addresses</strong></span> For a range of hosts for any subnet, the first address is the base address of subnet with last octet incremented by one. The last address is the base address of <span class="emphasis"><em>next subnet after this one</em></span>, less two in the last octet (which may require changing a 0 in the last octet to 254 and reducing the value of the third octet by 1). For example, consider subnet 17 in the Class B example. Its subnet address is 166.113.136.0. The address of subnet 18 is 166.113.144.0. So the range of hosts for subnet 17 is 166.113.136.1 to 166.113.143.254.</p><p><span class="strong"><strong>Broadcast Address</strong></span> <span class="emphasis"><em>The broadcast address for a subnet is always one less than the base address of the subsequent subnet</em></span>. Or alternatively, one more than the last real host address of the subnet. So for subnet 17 in the Class B example, the broadcast address is 166.113.143.255.</p><p>Did I just confuse you? Well, remember that these are shortcuts, and sometimes when you take a shortcut, you get lost. Just kidding; it's really not that hard once you play around with it a bit.</p><p>In closing, remember the following quick summary when working with IP addresses in a subnet environment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The network ID is the same for all hosts in all subnets and for all subnets in the network.</p></li><li class="listitem"><p>The subnet ID is the same for all hosts in each subnet, but it's unique to each subnet in the network.</p></li><li class="listitem"><p>The host ID is unique within each subnet. Each subnet has the same set of host IDs.</p></li><li class="listitem"><p>Subnetting is fun! (Okay, okay, sorry….)</p></li></ul></div></div></div>
<div class="chapter" title="Chapter&#xA0;20.&#xA0;IP CLASSLESS ADDRESSING&#x2014;CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING"><div class="titlepage"><div><div><h1 class="title"><a id="ip_classless_addressing_classless_inter-"/>Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e21328"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>As the Internet began to grow dramatically, three main problems arose with the original classful addressing scheme described in the previous chapters. These difficulties were addressed partially through subnet addressing, which provides more flexibility for the administrators of individual networks on an Internet. Subnetting, however, doesn't really tackle the problems in general terms. Some of these issues remain due to the use of classes even with subnets.</p><p>While development began on version 6 of the Internet Protocol (<a class="indexterm" id="idx-CHP-20-0756"/>IPv6; see <a class="xref" href="pt07.html" title="Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)">Part II-4</a>) and its roomy 128-bit addressing system in the mid-1990s, developers recognized that it would take many years before widespread deployment of IPv6 would be possible. In order to extend the life of IPv4 until the newer version could be completed, it was necessary to take a new approach to addressing IPv4 devices. This new system calls for eliminating the notion of address classes entirely, creating a new <span class="emphasis"><em>classless addressing</em></span> scheme sometimes called <span class="emphasis"><em>Classless Inter-Domain Routing (CIDR)</em></span><a class="indexterm" id="idx-CHP-20-0757"/>.</p><p>In this chapter, I describe modern classless IP addressing. I begin with an overview of the concepts behind classless addressing and the idea behind <span class="emphasis"><em>supernetting</em></span>, including why it was created and what its advantages and disadvantages are. I then define <a class="indexterm" id="idx-CHP-20-0758"/>CIDR and describe how the system works in more detail, including the notation used for address blocks. I list each of the CIDR address block sizes and show how they relate to the older Class A, B, and C networks. I conclude with a CIDR addressing example that's similar to the examples in <a class="xref" href="ch19.html" title="Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE">Chapter 19</a>, but this one focuses on CIDR and is a bit more condensed.</p><div class="sect1" title="IP Classless Addressing and Supernetting Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ip_classless_addressing_and_supernetting"/>IP Classless Addressing and Supernetting Overview</h1></div></div></div><p>Subnet addressing was an important development in the evolution of IP addressing, because it solved some important issues with the conventional, two-level class-based addressing scheme. Subnetting's contribution to flexibility in IP addressing was to allow each network to have its own two-level hierarchy, thereby giving the administrator of each network the equivalent of an Internet within the Internet.</p><p>When you looked at the advantages of subnetting in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>, you saw that subnetting was local within each organization and invisible to other organizations. This is an advantage in that it lets each organization tailor its network without other groups having to worry about the details of how this is done. Unfortunately, this invisibility also represents a key <span class="emphasis"><em>disadvantage</em></span> of subnetted classful addressing: It cannot correct the fundamental inefficiencies associated with that type of addressing, because organizations are still assigned address blocks based on classes.</p><div class="sect2" title="The Main Problem with Classful Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="the_main_problem_with_classful_add-id001"/>The Main Problem with Classful Addressing</h2></div></div></div><p>A key weakness of the subnetting system is its low <a class="indexterm" id="idx-CHP-20-0759"/>granularity. A Class B address block contains a very large number of addresses (65,534), but a Class C block has only a relatively small number (254). There are many thousands of medium-sized organizations that need more than 254 IP addresses, but a small percentage of these needs 65,534 or anything even close to it. (The lack of a good match to a medium-sized organization with 5,000 hosts is illustrated in <a class="xref" href="ch17s07.html#the_main_problem_with_classful_addressin" title="Figure 17-5. The main problem with classful addressing In this scale diagram, each square represents 50 available addresses. Since a Class C address has only 254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000 hosts is caught in the middle. It can only choose to either waste 90 percent of a Class B address or use 20 different Class C networks.">Figure 17-5</a> in <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a>.) When setting up their networks, these companies and groups would tend to request Class B address blocks and not Class C blocks, because they needed more than 254 hosts, without considering how many of the 65,000-odd addresses they really would use.</p><p>Due to how the classes of the older system were designed, there are over two million Class C address blocks, but only 16,384 Class B networks. While 16,384 seems like a lot at first glance, there are millions of organizations and corporations around the world. Class B allocations were being consumed at a rapid pace, while the smaller Class C networks were relatively unused.</p><p>The folks handing out Internet addresses needed a way to better utilize the address space so that it would not run out before the transition to IPv6. Subnetting didn't help a great deal with this problem. Why? Because it only works <span class="emphasis"><em>within</em></span> the classful address blocks. If an organization needing 2,000 IP addresses requested a Class B block, they could use subnetting to more efficiently manage their block. However, subnetting could do nothing about the fact that this organization would never use over 62,000 of the addresses in its block—about 97 percent of their allocated address space.</p><p>The only solution to this would be to convince—or at worst case, force—companies to use many smaller Class C blocks instead of wasting the bulk of a Class B assignment. Many organizations resisted this due to the complexity involved, and this caused the other main problem that subnetting didn't correct: the growth of Internet routing tables. Replacing one Class B network with 10 Class C networks means ten times as many entries for routers to maintain.</p></div><div class="sect2" title="The Solution: Eliminate Address Classes"><div class="titlepage"><div><div><h2 class="title"><a id="the_solution_eliminate_address_classes"/>The Solution: Eliminate Address Classes</h2></div></div></div><p>It was clear that as long as there were only three sizes of networks, the allocation efficiency problem could never be properly rectified. The solution was to get rid of the classes completely, in favor of a <a class="indexterm" id="idx-CHP-20-0760"/><span class="emphasis"><em>classless</em></span> allocation scheme. This system would solve both of the main problems with classful addressing: inefficient address space use and the exponential growth of routing tables.</p><p>This system was developed in the early 1990s and formalized in 1993 in RFCs 1517, 1518, 1519, and 1520. The technology was called <span class="emphasis"><em>Classless Inter-Domain Routing (CIDR)</em></span>. Despite this name, the scheme deals with both addressing and routing matters, since they are inextricably linked.</p><p>The idea behind CIDR is to adapt the concept of subnetting a single network to the entire Internet. In essence, classless addressing means that instead of breaking a particular network into subnets, you can aggregate networks into larger "supernets." CIDR is sometimes called <span class="emphasis"><em>supernetting</em></span> for this reason: It applies the principles of subnetting to larger networks. It is this aggregation of networks into supernets that allowed CIDR to resolve the problem of growing Internet routing tables.</p><p>Of course, if you are going to apply subnetting concepts to the entire Internet, you need to be able to have subnets of different sizes. After all, that's one of the primary goals in eliminating the classes. So, more accurately, CIDR is an Internet-wide application of not just regular one-level subnetting, but of Variable Length Subnet Masking (VLSM), introduced in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>. Just as VLSM allows you split a network as many times as you want to create subnets, sub-subnets, and sub-sub-subnets, CIDR lets you do this with the entire Internet, as many times as needed.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-111"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Classless Inter-Domain Routing (CIDR)</em></span> is a system of IP addressing and routing that solves the many problems of classful addressing by eliminating fixed address classes in favor of a flexible, multiple-level, hierarchical structure of networks of varying sizes.</p></div></div><div class="sect2" title="The Many Benefits of Classless Addressing and Routing"><div class="titlepage"><div><div><h2 class="title"><a id="the_many_benefits_of_classless_addressin"/>The Many Benefits of Classless Addressing and Routing</h2></div></div></div><p>CIDR provides numerous advantages over the classful addressing scheme, whether or not subnetting is used:</p><p><span class="strong"><strong>Efficient Address Space Allocation</strong></span> Instead of allocating addresses in fixed-size blocks of low granularity, under CIDR, addresses are allocated in sizes of any binary multiple. So a company that needs 5,000 addresses can be assigned a block of 8,190 instead of 65,534, as shown in <a class="xref" href="ch20.html#classless_addressing_cidr_solves_the_gra" title="Figure 20-1. Classless addressing (CIDR) solves the granularity problem Figure 17-5 in Chapter 17 illustrates the primary problem with classful addressing: the great distance between the size of Class B and Class C networks. CIDR solves this issue by allowing any number of bits to be used for the network ID. In the case of an organization with 5,000 hosts, a /19 network with 8,190 hosts can be assigned. This reduces the address space waste for such an organization by about 95.">Figure 20-1</a>. Or to think of it another way, the equivalent of a single Class B network can be shared among eight companies that each need 8,190 or fewer IP addresses.</p><p><span class="strong"><strong>Elimination of Class Imbalances</strong></span> There are no more Class A, B, and C networks, so there is no problem with some portions of the address space being widely used while others are neglected.</p><p><span class="strong"><strong>Efficient Routing Entries</strong></span> CIDR's multiple-level hierarchical structure allows a small number of routing entries to represent a large number of networks. Network descriptions can be aggregated and represented by a single entry. Since CIDR is hierarchical, the detail of lower-level, smaller networks can be hidden from routers that move traffic between large groups of networks. This is discussed more completely in <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a>, which covers IP routing issues.</p><p><span class="strong"><strong>No Separate Subnetting Method</strong></span> CIDR implements the concepts of subnetting within the Internet itself. An organization can use the same method used on the Internet to subdivide its internal network into subnets of arbitrary complexity, without needing a separate subnetting mechanism.</p><div class="figure"><a id="classless_addressing_cidr_solves_the_gra"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e21463"/><img alt="Classless addressing (CIDR) solves the granularity problem in illustrates the primary problem with classful addressing: the great distance between the size of Class B and Class C networks. CIDR solves this issue by allowing any number of bits to be used for the network ID. In the case of an organization with 5,000 hosts, a /19 network with 8,190 hosts can be assigned. This reduces the address space waste for such an organization by about 95." src="httpatomoreillycomsourcenostarchimages287843.png.jpg"/></div></div><p class="title">Figure 20-1. Classless addressing (CIDR) solves the granularity problem <a class="xref" href="ch17s07.html#the_main_problem_with_classful_addressin" title="Figure 17-5. The main problem with classful addressing In this scale diagram, each square represents 50 available addresses. Since a Class C address has only 254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000 hosts is caught in the middle. It can only choose to either waste 90 percent of a Class B address or use 20 different Class C networks.">Figure 17-5</a> in <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a> illustrates the primary problem with classful addressing: the great distance between the size of Class B and Class C networks. CIDR solves this issue by allowing any number of bits to be used for the network ID. In the case of an organization with 5,000 hosts, a /19 network with 8,190 hosts can be assigned. This reduces the address space waste for such an organization by about 95.</p></div><p>Since the main benefit of classful addressing was its simplicity, it's no surprise that the main drawback of CIDR is its greater complexity. One issue is that it is no longer possible to determine, by looking at the first octet, how many bits of an IP address represent the network ID and how many represent the host ID. A bit more care needs to be used in setting up routers as well, to make sure that routing is accomplished correctly.</p></div></div></div>
<div class="sect1" title="IP Supernetting: CIDR Hierarchical Addressing and Notation"><div class="titlepage"><div><div><h1 class="title"><a id="ip_supernetting_cidr_hierarchical_addres"/>IP Supernetting: CIDR Hierarchical Addressing and Notation</h1></div></div></div><p>When you first looked at IP addressing in <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a>, you saw that IP addresses were designed to be divided into a network identifier (network ID) and host identifier (host ID). Then, when subnets were introduced, you "stole" bits from the host ID to create a subnet ID, giving the IP address a total of three <a class="indexterm" id="idx-CHP-20-0761"/>hierarchical levels. With VLSM, you further subnetted the subnets, taking more bits from the host ID to give you a multiple-level hierarchy with sub-subnets, sub-sub-subnets, and so forth.</p><p>In a classless environment, you completely change how you look at IP addresses by applying VLSM concepts not just to one network, but to the entire Internet. In essence, the Internet becomes just one giant network that is subnetted into a number of large blocks. Some of these large blocks are then broken down into smaller blocks, which can in turn be broken down further. This breaking down can occur multiple times, allowing you to split the "pie" of Internet addresses into slices of many different sizes to suit the needs of the organization.</p><p>As the name implies, classless addressing completely eliminates the prior notions of classes. There are no more Class A, B, and C blocks that are divided by the first few bits of the address. Instead, under <a class="indexterm" id="idx-CHP-20-0762"/>CIDR, all Internet blocks can be of arbitrary size. Instead of having all networks use 8 (Class A), 16 (Class B), or 24 (Class C) bits for the network ID, you can have large networks with, say, 13 bits for the network ID (leaving 19 bits for the host ID), or very small ones that use 28 bits for the network ID (only 4 bits for the host ID). The size of the network is still based on the binary power of the number of host ID bits.</p><div class="sect2" title="CIDR (Slash) Notation"><div class="titlepage"><div><div><h2 class="title"><a id="cidr_slash_notation"/>CIDR (Slash) Notation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-20-0763"/><a class="indexterm" id="idx-CHP-20-0764"/>You'll recall that when you used subnetting, you had a problem: Subnetting could be done by taking any number of available host ID bits, so how would devices know where the line was between the subnet ID and host ID? The same problem occurs under CIDR. There are no classes, so you can't tell anything by looking at the first few bits of an IP address. Since addresses can have the dividing point between host ID and network ID occur anywhere, you need additional information in order to interpret IP addresses properly. Under CIDR, this impacts not only addresses within an organization, but also addresses in the entire Internet, since there are no classes and each network can be a different size.</p><p>For this reason, just as subnetting required the use of a subnet mask to show which bits belong to the network ID or subnet ID and which belong to the host ID, CIDR uses a subnet mask to show where the line is drawn between host ID and network ID. However, for simplicity, under CIDR you don't usually work with 32-bit binary subnet masks. Instead, you use <span class="emphasis"><em>slash notation</em></span>, more properly called <span class="emphasis"><em>CIDR notation</em></span>. This notation shows the size of the network, sometimes called the <a class="indexterm" id="idx-CHP-20-0765"/><span class="emphasis"><em>prefix length</em></span>, by following an IP address with an integer that tells you how many bits are used for the network ID (prefix).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-112"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since there are no address classes in CIDR, you cannot tell the size of the network ID of an address from the address alone. In CIDR, the length of the prefix (network ID) is indicated by placing it following a <a class="indexterm" id="idx-CHP-20-0766"/>slash after the address. This is called <a class="indexterm" id="idx-CHP-20-0767"/><span class="emphasis"><em>CIDR notation</em></span>, or <span class="emphasis"><em>slash notation</em></span>.</p></div><p>For example, consider the network specification 184.13.152.0/22. The 22 means this network has 22 bits for the network ID and 10 bits for the host ID. This is equivalent to specifying a network with an address of 184.13.152.0 and a subnet mask of 255.255.252.0, as you can see in <a class="xref" href="ch20s02.html#cidr_slash_notation_and_its_subnet_mask_" title="Figure 20-2. CIDR (slash) notation and its subnet mask equivalent A classless network is normally specified in CIDR, or slash notation, such as this example: 184.13.152.0/22. Here, the /22 means the first 22 bits of the address are the network ID. The equivalent subnet mask can be calculated by creating a 32-bit number with 22 ones followed by 10 zeros.">Figure 20-2</a>. This sample network provides a total of 1,022 hosts (210–2). The table in the following section shows all the different possible network sizes that can be configured under CIDR.</p><div class="figure"><a id="cidr_slash_notation_and_its_subnet_mask_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e21549"/><img alt="CIDR (slash) notation and its subnet mask equivalent A classless network is normally specified in CIDR, or slash notation, such as this example: 184.13.152.0/22. Here, the /22 means the first 22 bits of the address are the network ID. The equivalent subnet mask can be calculated by creating a 32-bit number with 22 ones followed by 10 zeros." src="httpatomoreillycomsourcenostarchimages287845.png.jpg"/></div></div><p class="title">Figure 20-2. CIDR (slash) notation and its subnet mask equivalent A classless network is normally specified in CIDR, or slash notation, such as this example: 184.13.152.0/22. Here, the /22 means the first 22 bits of the address are the network ID. The equivalent subnet mask can be calculated by creating a 32-bit number with 22 ones followed by 10 zeros.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-79"/>Note</h3><p><span class="emphasis"><em>You may recall that under classful subnetting, the bits used for the subnet ID did not need to be contiguous. Even though this ability was almost never used to avoid confusion, noncontiguous subnet ID bits were possible. Under CIDR, the requirement for contiguous subnet ID bits has been made official—you could not use slash notation otherwise</em></span>.</p></div></div><div class="sect2" title="Supernetting: Subnetting the Internet"><div class="titlepage"><div><div><h2 class="title"><a id="supernetting_subnetting_the_internet"/>Supernetting: Subnetting the Internet</h2></div></div></div><p>In theory, then, what CIDR does is provide the central address-assignment authority with the flexibility to hand out address blocks of different sizes to organizations based on their need. However, when CIDR was developed, a shift was made in the method by which public IP addresses were assigned. Having everyone in the world attempt to get addresses from one organization wasn't the best method. It was necessary under the classful scheme because the hierarchy was only two levels deep. The Internet Assigned Numbers Authority (IANA) handed out network IDs to everyone, who then assigned host IDs (or subnetted).</p><p>Under CIDR, you have many hierarchical levels: You split big blocks into smaller blocks, and then still-smaller blocks, and so on. It makes sense to manage blocks in a similar hierarchical manner as well. So what happens is that <a class="indexterm" id="idx-CHP-20-0768"/>IANA/ICANN divides addresses into large blocks, which it distributes to the four <a class="indexterm" id="idx-CHP-20-0769"/><span class="emphasis"><em>regional Internet registries (RIRs)</em></span>: APNIC, ARIN, LACNIC, and RIPE NCC. These then further divide the address blocks and distribute them to lower-level national Internet registries (NIRs), local Internet registries (LIRs), and/or individual organizations such as Internet service providers (ISPs). This is all explained in the background discussion of Internet authorities and registries in <a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a>.</p><p>ISPs can then divide these blocks into smaller ones and then allocate them to their customers. These customers are sometimes smaller ISPs themselves, which repeat the process. They split their blocks into pieces of different sizes and allocate them to their customers, some of whom are even smaller ISPs and some of whom are end users. The number of times this can occur is limited only by how many addresses are in the original block.</p><p>It's also worth noting that while CIDR is based on subnetting concepts, subnetting itself is not used in CIDR—or at least, not in the way it is used under classful addressing. There is no explicit subnetting using a subnet ID within CIDR. All IP addresses are interpreted only as having a network ID and a host ID. An organization does the equivalent of subnetting by dividing its own network into subnetworks using the same general method that ISPs do. This probably seems a bit confusing. Later in this chapter, I provide a detailed example of hierarchical address block assignments and how splitting works under CIDR.</p></div><div class="sect2" title="Common Aspects of Classful and Classless Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="common_aspects_of_classful_and_classless"/>Common Aspects of Classful and Classless Addressing</h2></div></div></div><p>There are a few aspects of addressing that were defined under the "classful" scheme that don't change under CIDR:</p><p><span class="strong"><strong>Private Address Blocks</strong></span> Certain blocks of addresses are still reserved for private network addressing. These addresses are not directly routed on the Internet, but can be used in conjunction with Network Address Translation (NAT; see <a class="xref" href="ch28.html" title="Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL">Chapter 28</a>) to allow IP hosts without public addresses to access the Internet.</p><p><span class="strong"><strong>Addresses with Special Meanings</strong></span> The special meanings assigned to certain network ID and host ID patterns are the same as before. This is also why you still must subtract two from the number of hosts in each network. These represent the all-zeros case that refers to the network as a whole and the all-ones address used for broadcast.</p><p><span class="strong"><strong>Loopback Addresses</strong></span> The network 127.0.0.0 is still reserved for loopback functionality. (In CIDR it is given the notation 127.0.0.0/8.)</p><p>Finally, note that use of classless addressing requires hardware and software designed to handle it. If the hardware and software are still assuming that they are operating in a classful environment, they will not properly interpret addresses. Since CIDR has now been around for more than a decade, this is usually not a problem with modern systems.</p></div></div>
<div class="sect1" title="IP Classless Addressing Block Sizes and Classful Network Equivalents"><div class="titlepage"><div><div><h1 class="title"><a id="ip_classless_addressing_block_sizes_and_"/>IP Classless Addressing Block Sizes and Classful Network Equivalents</h1></div></div></div><p>Because CIDR allows you to divide IP addresses into network IDs and host IDs along any bit boundary, it allows for the creation of dozens of different sizes of networks. As with subnetting, the size of network is a trade-off between the number of bits used for the network ID and the number used for the host ID. Unlike conventional subnetting, where a single choice is made for all subnets, CIDR allows many levels of hierarchical division of the Internet, so many sizes of networks exist simultaneously. Larger networks are created and subdivided into smaller ones.</p><p>Since many people are used to looking at IP address <a class="indexterm" id="idx-CHP-20-0770"/>blocks in terms of their classful sizes, it is common to express CIDR address blocks in terms of their classful equivalents. First, at this point it should be simple to see that a CIDR /8 network is equal in size to a Class A network, a /16 is equivalent to a Class B network, and a/24 is equivalent to a Class C network. This is because Class A networks use 8 bits for the network ID, Class B networks use 16, and Class C networks use 24. However, remember that these CIDR equivalents do not need to have any particular ranges for their first octets as in the classful scheme.</p><p>Each time you reduce the prefix length, you are defining a network about double the size of the one with the higher number, since you have increased the number of bits in the host ID by one. So, a /15 network is equal in size to two /16 networks.</p><p><a class="xref" href="ch20s03.html#cidr_address_blocks_and_classful_address" title="Table 20-1. CIDR Address Blocks and Classful Address Equivalents">Table 20-1</a> shows each of the possible theoretical ways to divide the 32 bits of an IP address into network ID and host ID bits under CIDR. For each, I have shown the number of hosts in each network, and the way a network of each size is represented in both slash notation and as a conventional subnet mask. I have also shown the equivalent number of Class A, Class B, and Class C networks for each.</p><p>Keep the following things in mind while looking at this table:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Some of the entries shown are more theoretical than practical and are included merely for completeness. This is particularly the case with the larger networks. For example, I doubt anyone ever actually works with a /1 or /2 CIDR network; there would be only two of the former and four of the latter encompassing the entire IP address space! Most of the time, you will be working with smaller networks, /16 and below.</p></li><li class="listitem"><p>Under normal circumstances, you cannot have a /31 or /32 CIDR network, because it would have zero valid host IDs. (There is a special case: /31 networks can be used for point-to-point links, where it is obvious who the intended recipient is of each transmission, and where broadcasts are not necessary. This is described in RFC 3021.)</p></li><li class="listitem"><p>In the columns showing the number of equivalent Class A, B, and C networks I have only shown numbers in the range of 1/256 to 256 for simplicity. Obviously, a /6 network, in addition to being equal in size to four Class A networks, also equals 1,024 Class B networks, and 262,144 Class C networks, but few people would bother referring to a /6 as being 262,144 Class C networks.</p></li></ul></div><div class="table"><a id="cidr_address_blocks_and_classful_address"/><p class="title">Table 20-1. CIDR Address Blocks and Classful Address Equivalents</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="CIDR Address Blocks and Classful Address Equivalents"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Bits for Network ID</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Bits for Host ID</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># of Hosts per Network</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prefix Length in Slash Notation</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Equivalent Subnet Mask</p></th><th colspan="3" style="border-bottom: 0.5pt solid ; "><p># of Equivalent Classful <a class="indexterm" id="idx-CHP-20-0771"/>Addressing Networks</p></th></tr><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class A</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class B</p></th><th style="border-bottom: 0.5pt solid ; "><p>Class C</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>31</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,147,483,646</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,073,741,822</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>29</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>536,870,910</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>224.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>28</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>268,435,454</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>240.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>27</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>134,217,726</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>248.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>26</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>67,108,862</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>252.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>25</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>33,554,430</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>254.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16,777,214</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.0.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>256</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>23</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8,388,606</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.128.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>22</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4,194,302</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.192.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>21</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,097,150</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.224.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>20</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,048,574</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.240.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>19</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>524,286</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.248.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>262,142</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.252.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/64</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>131,070</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.254.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>65,534</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.0.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/256</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>256</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32,766</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.128.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2</p></td><td style="border-bottom: 0.5pt solid ; "><p>128</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16,382</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/18</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.192.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/4</p></td><td style="border-bottom: 0.5pt solid ; "><p>64</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>19</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8,190</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/19</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.224.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8</p></td><td style="border-bottom: 0.5pt solid ; "><p>32</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>20</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4,094</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/20</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.240.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/16</p></td><td style="border-bottom: 0.5pt solid ; "><p>16</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>21</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2,046</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/21</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.248.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/32</p></td><td style="border-bottom: 0.5pt solid ; "><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>22</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1,022</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/22</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.252.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/64</p></td><td style="border-bottom: 0.5pt solid ; "><p>4</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>23</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>510</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/23</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.254.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/128</p></td><td style="border-bottom: 0.5pt solid ; "><p>2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>254</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/256</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>25</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>126</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/25</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>1/2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>26</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>62</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/26</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.192</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>1/4</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>27</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/27</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.224</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>1/8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>28</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/28</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.240</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>1/16</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>29</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/29</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.248</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>1/32</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>/30</p></td><td style="border-right: 0.5pt solid ; "><p>255.255.255.252</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style=""><p>1/64</p></td></tr></tbody></table></div></div></div>
<div class="sect1" title="IP CIDR Addressing Example"><div class="titlepage"><div><div><h1 class="title"><a id="ip_cidr_addressing_example"/>IP CIDR Addressing Example</h1></div></div></div><p>The multiple hierarchical levels of CIDR make the technology seem rather complicated. However, understanding how CIDR works really is not that difficult, assuming you already know how subnetting is done. In particular, if you know how VLSM functions, you basically already know how CIDR works, since they are pretty much the same thing. They differ only in the way that the hierarchical division of networks is accomplished, and in the terminology.</p><p>To show how CIDR works better, let's take an example that will illustrate the power of classless <a class="indexterm" id="idx-CHP-20-0772"/>addressing: its ability to selectively subdivide a large block of addresses into smaller ones that suit the needs of various organizations. Since address allocation in CIDR typically starts with larger blocks owned by larger ISPs, let's start there as well.</p><p>Suppose you have an ISP that is just starting up. It's not a major ISP, but a moderate-sized one with only a few customers, so it needs only a relatively small allocation. It begins with the block 71.94.0.0/15. The /15 on the end of the block address tells you that this is a block of addresses where the first 15 bits are the network ID and the last 17 are the host ID. This block was obtained from a larger ISP, carved from a larger block of addresses by that ISP. For example, 71.94.0.0/15 would be equal to half of the address block 71.92.0.0/14, a quarter of the block 71.88.0.0/13, and so on.</p><p>The ISP's block is equal in size to two Class B networks and has a total of 131,070 possible host addresses. This ISP can choose to divide this block in a variety of ways, depending on the needs of its clients and its own internal use. However, this ISP is just starting up, so it is not even sure of what its ultimate needs will be. Let's say it expects to resell about half of its address space to other ISPs, but isn't sure what sizes they will need yet. Of the other half, it plans to split it into four different sizes of blocks to match the needs of different-sized organizations.</p><p>To imagine how the ISP divides its address space, you can consider the analogy of cutting up a pie. The ISP will first cut the pie in half and reserve one-half for its future ISP customers. It will then cut the other half into some large pieces and some small pieces. This is illustrated in <a class="xref" href="ch20s04.html#example_of_a_hierarchical_division_of_a_" title="Figure 20-3. Example of a hierarchical division of a /15 CIDR address block This diagram shows one method by which an ISP with a relatively large /15 address block (131,070 hosts) might choose to hierarchically divide it. In this case it is first divided in half into two /16 blocks. One is reserved, while the other is divided into four /18 blocks. Each of those is divided into blocks of a different size to allow allocation to organizations requiring up to 62, 126, 254, or 510 hosts, respectively.">Figure 20-3</a>. (Okay, I know it's a square pie. I wanted to show the individual small blocks to scale.)</p><p>The actual process of division might follow the progression described in the following section and illustrated in <a class="xref" href="ch20s04.html#hierarchical_address_division_using_cidr" title="Figure 20-4. Hierarchical address division using CIDR">Figure 20-4</a>.</p><div class="sect2" title="First Level of Division"><div class="titlepage"><div><div><h2 class="title"><a id="first_level_of_division"/>First Level of Division</h2></div></div></div><p>The "pie" is initially cut down the middle by using the single leftmost host ID bit as an extra network bit. Here's the network address block, 71.94.0.0/15 in binary, with the leftmost host ID bit shown in bold:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>01000111 0101111<span class="strong"><strong>0</strong></span> 00000000 00000000</td></tr></table><div class="figure"><a id="example_of_a_hierarchical_division_of_a_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e22480"/><img alt="Example of a hierarchical division of a /15 CIDR address block This diagram shows one method by which an ISP with a relatively large /15 address block (131,070 hosts) might choose to hierarchically divide it. In this case it is first divided in half into two /16 blocks. One is reserved, while the other is divided into four /18 blocks. Each of those is divided into blocks of a different size to allow allocation to organizations requiring up to 62, 126, 254, or 510 hosts, respectively." src="httpatomoreillycomsourcenostarchimages287847.png.jpg"/></div></div><p class="title">Figure 20-3. Example of a hierarchical division of a /15 CIDR address block This diagram shows one method by which an ISP with a relatively large /15 address block (131,070 hosts) might choose to hierarchically divide it. In this case it is first divided in half into two /16 blocks. One is reserved, while the other is divided into four /18 blocks. Each of those is divided into blocks of a different size to allow allocation to organizations requiring up to 62, 126, 254, or 510 hosts, respectively.</p></div><p>To make the split, you make one network equal to this binary network address with the highlighted bit remaining zero, and the other one with it changed to a one. This creates two subnetworks—not subnets as in the classful sense of the word, but portions of the original network—that I have numbered based on the numeric value of what is substituted into the new network ID bits, as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>Subnetwork 0: 01000111 0101111<span class="strong"><strong>0</strong></span> 00000000 00000000</td></tr><tr><td>Subnetwork 1: 01000111 0101111<span class="strong"><strong>1</strong></span> 00000000 00000000</td></tr></table><p>Because bit 16 is now also part of the network address, these are /16 networks, the size of a classful Class B network. So the subnetworks are as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>Subnetwork 0: 71.94.0.0/16</td></tr><tr><td>Subnetwork 1: 71.95.0.0/16</td></tr></table><p>You'll notice subnetwork 0 has the same IP address as the larger network it came from; this is always true of the subnetwork 0 in a network.</p><div class="figure"><a id="hierarchical_address_division_using_cidr"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e22510"/><img alt="Hierarchical address division using CIDR" src="httpatomoreillycomsourcenostarchimages287849.png.jpg"/></div></div><p class="title">Figure 20-4. Hierarchical address division using CIDR</p></div></div><div class="sect2" title="Second Level of Division"><div class="titlepage"><div><div><h2 class="title"><a id="second_level_of_division"/>Second Level of Division</h2></div></div></div><p>Let's say you set aside subnetwork 0 earlier for future ISP allocations. You then choose to divide the second subnetwork into four. These you will then further subdivide into different sizes to meet the customer's needs. To divide into four groups, you need two more bits from the host ID of subnetwork 1, as shown here in bold and underlined next to the original subnet bit:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>01000111 0101111<span class="strong"><strong>1 <span class="underline">00</span></strong></span>000000 00000000</td></tr></table><p>These two bits are replaced by the patterns 00, 01, 10, and 11 to get four sub-subnetworks. They will be /18 networks, since you took two extra bits from the host ID of a /16 as shown here:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>Sub-subnetwork 1-0: 01000111 0101111<span class="strong"><strong>1 <span class="underline">00</span></strong></span>000000 00000000 (71.95.0.0/18)</td></tr><tr><td>Sub-subnetwork 1-1: 01000111 0101111<span class="strong"><strong>1 <span class="underline">01</span></strong></span>000000 00000000 (71.95.64.0/18)</td></tr><tr><td>Sub-subnetwork 1-2: 01000111 0101111<span class="strong"><strong>1 <span class="underline">10</span></strong></span>000000 00000000 (71.95.128.0/18)</td></tr><tr><td>Sub-subnetwork 1-3: 01000111 0101111<span class="strong"><strong>1 <span class="underline">11</span></strong></span>000000 00000000 (71.95.192.0/18)</td></tr></table><p>Each of these has 16,382 addresses.</p></div><div class="sect2" title="Third Level of Division"><div class="titlepage"><div><div><h2 class="title"><a id="third_level_of_division"/>Third Level of Division</h2></div></div></div><p>You now take each of the four /18 networks and further subdivide it. You want to make each of these contain a number of blocks of different sizes corresponding to the potential customers. One way to do this would be as follows:</p><p><span class="strong"><strong>Larger Organizations</strong></span> Customers needing up to 510 addresses require a /23 network. You divide sub-subnetwork 1-0, 71.95.0.0/18 by taking five bits from the host ID field:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>01000111 0101111<span class="strong"><strong>1 <span class="underline">00</span></strong></span><span class="bolditalic"><span class="underline">00000</span></span>0 00000000</td></tr></table><p>You substitute into these five bits 00000, 00001, 00010 and so on, giving you 32 different /23 networks in this block, each containing nine bits for the host ID, for 510 hosts. The first will be sub-sub-subnetwork 1-0-0, 71.95.0.0/23; the second sub-sub-subnetwork 1-0-1, 71.95.2.0/23; the last will be sub-sub-subnetwork 1-0-31: 71.95.62.0/23.</p><p><span class="strong"><strong>Medium-Sized Organizations</strong></span> For customers needing up to 254 addresses, you divide sub-subnetwork 1-1, 71.95.64.0/18, by taking six bits from the host ID field:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>01000111 0101111<span class="strong"><strong>1 <span class="underline">01</span></strong></span><span class="bolditalic"><span class="underline">000000</span></span> 00000000</td></tr></table><p>This gives you 64 different /24 networks. The first will be sub-sub-subnetwork 1-1-0, 71.95.64.0/24, the second sub-sub-subnetwork 1-1-1, 71.95.65.0/24, and so on.</p><p><span class="strong"><strong>Smaller Organizations</strong></span> For customers with up to 126 hosts, you divide sub-subnetwork 1-2, 71.95.128.0/18, by taking seven bits from the host ID field, as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>01000111 0101111<span class="strong"><strong>1</strong></span> <span class="strong"><strong><span class="underline">10</span></strong></span><span class="bolditalic"><span class="underline">000000 0</span></span>0000000</td></tr></table><p>Seven bits allow 128 of these /25 networks within the /18 block. The first will be 71.95.128.0/25, the second 71.95.128.128/25, the third 71.95.129.0/25, and so on.</p><p><span class="strong"><strong>Very Small Organizations</strong></span> For customers with up to 60 hosts, you divide sub-subnetwork 1-3, 71.95.192.0/18, by taking eight bits from the host ID field:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>01000111 0101111<span class="strong"><strong>1 <span class="underline">11</span></strong></span><span class="bolditalic"><span class="underline">000000</span></span> <span class="bolditalic"><span class="underline">00</span></span>000000</td></tr></table><p>This gives you 256 different /26 networks within the /18 block. The first will be 71.95.192.0/26, the second 71.95.192.64/26, and so on.</p><p>This example shows only one of many different ways to slice up this pie. The ISP might decide that creating four different sizes of customer networks in advance was not the right way to go. It might instead just take the tack of dividing the pie in half, dividing it in half again, and so on, as many times as needed to create slices of the right size. Alternatively, if most of their customers needed around 50, 100, 200, or 500 hosts, the previous example might be the easiest to administer.</p><p>It would still be possible for the ISP to divide any of the smaller blocks further if they needed to do so. They could split a /26 sub-sub-subnetwork into four /28 sub-sub-sub-subnetworks for very small customers, for example. Also, an individual customer of this ISP could do the same thing, dividing its own block to suit the internal structure of its network.</p></div></div>
<div class="chapter" title="Chapter&#xA0;21.&#xA0;INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING"><div class="titlepage"><div><div><h1 class="title"><a id="internet_protocol_datagram_encapsulation"/>Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e22650"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>The primary job of the Internet Protocol (IP) is to deliver data between devices over an internetwork. On its journey between two hosts in an internetwork, this data may travel across many physical networks. To help ensure that the data is sent and received properly, it is <span class="emphasis"><em>encapsulated</em></span> within a message called an <span class="emphasis"><em>IP datagram</em></span>. This datagram includes several fields that help manage the operation of IP and ensure that data gets where it needs to go.</p><p>In this chapter, I take a look at how IP takes data passed to it from higher layers and packages it for transmission. I begin with a general discussion of IP datagrams and encapsulation. I then describe the general format of IP datagrams, including the fields used in the IP header and how they are interpreted. I also include a brief discussion of IP datagram options and their use.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-113"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>This chapter assumes at least passing familiarity with IP addressing concepts, as outlined in Chapters <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a>–<a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>. It also makes reference to the chapter on datagram fragmentation and reassembly (<a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a>)</em></span>.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-80"/>Note</h3><p><a class="indexterm" id="idx-CHP-21-0773"/><span class="emphasis"><em>IP datagrams are sometimes called</em></span> IP packets. <span class="emphasis"><em>Whether</em></span> datagram <span class="emphasis"><em>or</em></span> packet <span class="emphasis"><em>is the preferred term seems to depend on whom you ask; even the standards don't use one term exclusively. On the other hand, I have seen IP datagrams called</em></span> IP frames, <span class="emphasis"><em>and that's definitely not correct! <a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a> describes these terms more completely</em></span>.</p></div><div class="sect1" title="IP Datagram Encapsulation"><div class="titlepage"><div><div><h1 class="title"><a id="ip_datagram_encapsulation"/>IP Datagram Encapsulation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-21-0774"/>In <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>, which described OSI Reference Model concepts, I looked at several ways that protocols at various layers in a networking protocol stack interact with each other. One of the most important concepts in interprotocol operation is that of <span class="emphasis"><em>encapsulation</em></span>. Most data originates within the higher layers of the OSI model. The protocols at these layers pass the data down to lower layers for transmission, usually in the form of discrete messages. Upon receipt, each lower-level protocol takes the entire contents of the message received and encapsulates it into its own message format, adding a header and possibly a footer that contain important control information.</p><p>You might think of encapsulation as similar to sending a letter enclosed in an <a class="indexterm" id="idx-CHP-21-0775"/>envelope. You write a letter and put it in an envelope with a name and address, but if you give it to a courier for overnight delivery; the courier takes that envelope and puts it in a larger delivery envelope. In a similar way, messages at higher networking layers are encapsulated in lower-layer messages, which can then in turn be further encapsulated.</p><p>Due to the prominence of TCP/IP, IP is one of the most important places where data encapsulation occurs on a modern network. Data is passed to IP typically from one of the two main transport layer protocols: the Transmission Control Protocol (TCP) or User Datagram Protocol (UDP). This data is already in the form of a TCP or UDP message with TCP or UDP headers. This is then encapsulated into the body of an IP message, usually called an <span class="emphasis"><em>IP datagram</em></span> or <span class="emphasis"><em>IP packet</em></span>. Encapsulation and formatting of an IP datagram is also sometimes called <span class="emphasis"><em>packaging</em></span>—again, the envelope is an obvious comparison.</p><p><a class="xref" href="ch21.html#ip_datagram_encapsulation_the_upper-laye" title="Figure 21-1. IP datagram encapsulation The upper-layer message is packaged into a TCP or UDP message, which becomes the payload of an IP datagram. The IP datagram is then passed down to layer 2, where it is encapsulated in a LAN, WAN, or WLAN frame. It is then converted to bits and transmitted at the physical layer.">Figure 21-1</a> displays this entire process, which looks very similar to the drawing of the OSI Reference Model as a whole, as shown in <a class="xref" href="ch05s03.html#osi_reference_model_data_encapsulation_e" title="Figure 5-5. OSI Reference Model data encapsulation Each protocol creates a protocol data unit (PDU) for transmission, each of which includes headers required by that protocol and data to be transmitted. This data becomes the service data unit (SDU) of the next layer below it.">Figure 5-5</a> in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>. As you can see, an upper-layer message is packaged into a TCP or UDP message. This then becomes the payload of an IP datagram, shown here with only one header (things can get a bit more complex than this). The IP datagram is then passed down to layer 2, where it is encapsulated into some sort of local area network (LAN), wide area network (WAN), or wireless LAN (WLAN) frame, and then converted to bits and transmitted at the physical layer.</p><p>If the message to be transmitted is too large to pass through the underlying network, it may first be fragmented. This is analogous to splitting up a large delivery into multiple smaller envelopes or boxes. In this case, each IP datagram carries only part of the higher-layer message. The receiving device must reassemble the message from the IP datagrams.</p><div class="figure"><a id="ip_datagram_encapsulation_the_upper-laye"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e22746"/><img alt="IP datagram encapsulation The upper-layer message is packaged into a TCP or UDP message, which becomes the payload of an IP datagram. The IP datagram is then passed down to layer 2, where it is encapsulated in a LAN, WAN, or WLAN frame. It is then converted to bits and transmitted at the physical layer." src="httpatomoreillycomsourcenostarchimages287851.png.jpg"/></div></div><p class="title">Figure 21-1. IP datagram encapsulation The upper-layer message is packaged into a TCP or UDP message, which becomes the payload of an IP datagram. The IP datagram is then passed down to layer 2, where it is encapsulated in a LAN, WAN, or WLAN frame. It is then converted to bits and transmitted at the physical layer.</p></div><p>The IP datagram is somewhat similar in concept to a frame used in Ethernet or another data link layer, except that IP datagrams are designed to facilitate transmission across an internetwork, while data link layer frames are used only for direct delivery within a physical network. The fields included in the IP header are used to manage internetwork datagram delivery. This includes key information for delivery, such as the address of the destination device, identification of the type of frame, and control bits. The header follows a format that you will examine shortly.</p><p>Once data is encapsulated into an IP datagram, it is passed down to the data link layer for transmission across the current "hop" of the internetwork. There it is further encapsulated, IP header and all, into a data link layer frame such as an Ethernet frame. An IP datagram may be encapsulated into many such data link layer frames as it is routed across the internetwork; on each hop, the IP datagram is removed from the data link layer frame and then repackaged into a new one for the next hop. The IP datagram, however, is not changed (except for some control fields) until it reaches its final destination.</p></div></div>
<div class="sect1" title="IP Datagram General Format"><div class="titlepage"><div><div><h1 class="title"><a id="ip_datagram_general_format"/>IP Datagram General Format</h1></div></div></div><p>Data transmitted over an internetwork using IP is carried in messages called <span class="emphasis"><em>IP datagrams</em></span>. As is the case with all network protocol messages, IP uses a specific <a class="indexterm" id="idx-CHP-21-0776"/>format for its datagrams. Here, I will discuss the IP version 4 (IPv4) datagram <a class="indexterm" id="idx-CHP-21-0777"/>format, which was defined in RFC 791 along with the rest of IPv4.</p><p>The IPv4 datagram is conceptually divided into two pieces: the <span class="emphasis"><em>header</em></span> and the <span class="emphasis"><em>payload</em></span>. The header contains addressing and control fields, while the payload carries the actual data to be sent over the internetwork. Unlike some message formats, IP datagrams do not have a footer following the payload.</p><p>Even though IP is a relatively simple, connectionless, and unreliable protocol, the IPv4 header carries a fair bit of information, which makes it rather large. It is at least 20 bytes long, and with options it can be significantly longer. The IP datagram format is described in Tables <a class="xref" href="ch21s02.html#internet_protocol_version__ipv_datagram" title="Table 21-1. Internet Protocol Version 4 (IPv4) Datagram Format">Table 21-1</a>, <a class="xref" href="ch21s02.html#ipv_flags_subfields" title="Table 21-2. IPv4 Flags Subfields">Table 21-2</a>, and <a class="xref" href="ch21s02.html#ipv_protocol_subfields" title="Table 21-3. IPv4 Protocol Subfields">Table 21-3</a>, and illustrated in <a class="xref" href="ch21s02.html#ipv4_datagram_format_this_diagram_shows_" title="Figure 21-2. IPv4 datagram format This diagram shows the all-important IPv4 datagram format. The first 20 bytes are the fixed IP header, followed by an optional Options section, and a variable-length Data area. Note that the Type of Service field is shown as originally defined in the IPv4 standard.">Figure 21-2</a>.</p><div class="table"><a id="internet_protocol_version__ipv_datagram"/><p class="title">Table 21-1. Internet Protocol Version 4 (IPv4) Datagram Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Internet Protocol Version 4 (IPv4) Datagram Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2 (4 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the version of IP used to generate the datagram. For IPv4, this is the number 4. This field ensures compatibility between devices that may be running different versions of IP. In general, a device running an older version of IP will reject datagrams created by newer implementations, under the assumption that the older version may not be able to interpret the newer datagram correctly.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IHL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2 (4 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the length of the IP header, in 32-bit words. This includes the length of any options fields and padding. The normal value of this field when no options are used is 5 (5 32-bit words = 5*4 = 20 bytes). Contrast this with the longer Total Length field in this table.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TOS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>A field designed to carry information to provide quality-of-service features, such as prioritized delivery for IP datagrams. This has not been as widely used as originally defined, and its meaning has been redefined for use by a technique called <span class="emphasis"><em>Differentiated Services (DS)</em></span>, as discussed in the "IP Datagram Type of Service (TOS) Field" section of this chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the total length of the IP datagram, in bytes. Since this field is 16 bits wide, the maximum length of an IP datagram is 65,535 bytes, though most are much smaller.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identification</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>This field contains a 16-bit value that is common to each of the fragments belonging to a particular message; for datagrams originally sent unfragmented, it is still filled in so it can be used if the datagram must be fragmented by a router during delivery. The recipient uses this field to reassemble messages without accidentally mixing fragments from different messages. This is needed because fragments may arrive from multiple messages mixed together, since IP datagrams can be received out of order from any device. (See the discussion of IP message fragmentation in <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a>.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3/8 (3 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Three control flags, two of which are used to manage fragmentation (as described in the topic on fragmentation), and one that is reserved. See <a class="xref" href="ch21s02.html#ipv_flags_subfields" title="Table 21-2. IPv4 Flags Subfields">Table 21-2</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Fragment Offset</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1 5/8 (13 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>When fragmentation of a message occurs, this field specifies the offset, or position, in the message where the data in this fragment goes in units of eight bytes (64 bits). The first fragment has an offset of 0. (See the discussion of fragmentation in <a class="xref" href="ch27.html" title="Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING">Chapter 27</a> for a description of how the field is used.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TTL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>This specifies how long the datagram is allowed to live on the network, in router hops. Each router decrements the value of the TTL field (reduces it by one) prior to transmitting it. If the TTL field drops to zero, the datagram is assumed to have taken too long a route and is discarded. (See the "IP Datagram Time to Live (TTL) Field" section later in this chapter for more information.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Protocol</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the higher-layer protocol (generally either a transport layer protocol or encapsulated network layer protocol) carried in the datagram. <a class="xref" href="ch21s02.html#ipv_protocol_subfields" title="Table 21-3. IPv4 Protocol Subfields">Table 21-3</a> shows the protocol values of this field, which were originally defined by the IETF "Assigned Numbers" standard, RFC 1700, and are now maintained by the Internet Assigned Numbers Authority (IANA).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Header Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A checksum is computed over the header to provide basic protection against corruption in transmission. This is not the more complex cyclic redundancy check (CRC) code that's typically used by data link layer technologies such as Ethernet; it's just a 16-bit checksum. It is calculated by dividing the header bytes into words (a word is two bytes) and then adding them together. Only the header is checksummed; not the data. At each hop, the device receiving the datagram does the same checksum calculation, and if there is a mismatch, it discards the datagram as damaged.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Source Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is the 32-bit IP address of the originator of the datagram. Note that even though intermediate devices such as routers may handle the datagram, they do not normally put their address into this field—the address is always that of the device that originally sent the datagram.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Destination Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is the 32-bit IP address of the intended recipient of the datagram. Again, even though devices such as routers may be the intermediate targets of the datagram, this field is always used to specify the ultimate destination.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>One or more of several types of options may be included after the standard headers in certain IP datagrams, as discussed later in this chapter, in the "IP Datagram Options and Option Format" section.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Padding</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>If one or more options are included, and the number of bits used for them is not a multiple of 32, enough 0 bits are added to pad out the header to a multiple of 32 bits (four bytes).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>This is the data that will be transmitted in the datagram. It is either an entire higher-layer message or a fragment of one.</p></td></tr></tbody></table></div></div><div class="table"><a id="ipv_flags_subfields"/><p class="title">Table 21-2. IPv4 Flags Subfields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv4 Flags Subfields"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DF</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>When set to 1, this says that the datagram should not be fragmented. Since the fragmentation process is generally invisible to higher layers, most protocols don't care about this and don't set this flag. It is, however, used for testing the maximum transmission unit (MTU) of a link.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>MF</p></td><td style="border-right: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style=""><p>When set to 0, this indicates the last fragment in a message; when set to 1, it indicates that more fragments are yet to come in the fragmented message. If no fragmentation is used for a message, there is only one fragment (the whole message), and this flag is 0. If fragmentation is used, all fragments but the last set this flag to 1 so that the recipient knows when all fragments have been sent.</p></td></tr></tbody></table></div></div><div class="table"><a id="ipv_protocol_subfields"/><p class="title">Table 21-3. IPv4 Protocol Subfields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv4 Protocol Subfields"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value (Hexadecimal)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value (Decimal)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Protocol</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>00</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>01</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>ICMP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>02</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>IGMP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>03</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>GGP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>04</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>IP-in-IP Encapsulation</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>06</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>TCP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>08</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>EGP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-bottom: 0.5pt solid ; "><p>UDP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>50</p></td><td style="border-bottom: 0.5pt solid ; "><p>Encapsulating Security Payload (ESP) Extension Header</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>33</p></td><td style="border-right: 0.5pt solid ; "><p>51</p></td><td style=""><p>Authentication Header (AH) Extension Header</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-81"/>Note</h3><p><span class="emphasis"><em>The last two entries in <a class="xref" href="ch21s02.html#ipv_protocol_subfields" title="Table 21-3. IPv4 Protocol Subfields">Table 21-3</a> are used when IPSec inserts additional headers into the datagram: the AH or ESP headers. See <a class="xref" href="ch29.html" title="Chapter 29. IP SECURITY (IPSEC) PROTOCOLS">Chapter 29</a> for more information</em></span><a class="indexterm" id="idx-CHP-21-0778"/>.</p></div><div class="figure"><a id="ipv4_datagram_format_this_diagram_shows_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e23159"/><img alt="IPv4 datagram format This diagram shows the all-important IPv4 datagram format. The first 20 bytes are the fixed IP header, followed by an optional Options section, and a variable-length Data area. Note that the Type of Service field is shown as originally defined in the IPv4 standard." src="httpatomoreillycomsourcenostarchimages287853.png.jpg"/></div></div><p class="title">Figure 21-2. IPv4 datagram format This diagram shows the all-important IPv4 datagram format. The first 20 bytes are the fixed IP header, followed by an optional Options section, and a variable-length Data area. Note that the Type of Service field is shown as originally defined in the IPv4 standard.</p></div><div class="sect2" title="IP Datagram Time to Live (TTL) Field"><div class="titlepage"><div><div><h2 class="title"><a id="ip_datagram_time_to_live_ttl_field"/>IP Datagram Time to Live (TTL) Field</h2></div></div></div><p>Let's look at the <a class="indexterm" id="idx-CHP-21-0779"/>Time to Live (TTL) field. Since IP datagrams are sent from router to router as they travel across an internetwork, a datagram could be passed from Router A to Router B to Router C, and then back to Router A. This is called a <span class="emphasis"><em>router loop</em></span>, and it's something that we don't want to happen.</p><p>To ensure that datagrams don't circle around endlessly, the TTL <a class="indexterm" id="idx-CHP-21-0780"/>field was designed to contain a time value (in seconds), which would be filled in when the datagram was originally sent. Routers would decrease the time value periodically, and if it ever hit zero, destroy the datagram. The TTL <a class="indexterm" id="idx-CHP-21-0781"/>field was also designed to ensure that time-critical datagrams wouldn't become stale or pass their expiration date.</p><p>In practice, this field is not used in exactly this manner. Routers today are fast and usually take far less than a second to forward a datagram, which makes it impractical to measure the time that a datagram lives. Instead, this field is used as a maximum hop count for the datagram. Each time a router processes a datagram, it reduces the value of the TTL field by one. If doing this results in the field being zero, the datagram is said to have expired, at which point it is dropped, and usually an Internet Control Message Protocol (ICMP) Time Exceeded message is sent to inform the originator of the message that it has expired. The TTL field is one of the primary mechanisms by which networks are protected from <a class="indexterm" id="idx-CHP-21-0782"/>router loops. (See the description of ICMP Time Exceeded messages in <a class="xref" href="ch32.html" title="Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS">Chapter 32</a> for more on how TTL helps IP handle router <a class="indexterm" id="idx-CHP-21-0783"/>loops.)</p></div><div class="sect2" title="IP Datagram Type of Service (TOS) Field"><div class="titlepage"><div><div><h2 class="title"><a id="ip_datagram_type_of_service_tos_field"/>IP Datagram Type of Service (TOS) Field</h2></div></div></div><p><a class="indexterm" id="idx-CHP-21-0784"/><a class="indexterm" id="idx-CHP-21-0785"/>The <a class="indexterm" id="idx-CHP-21-0786"/>Type of Service (TOS) field is a one-byte field that was originally intended to provide certain quality-of-service (QoS) features for IP datagram delivery. It allowed IP datagrams to be tagged with information indicating not only their precedence, but also the preferred manner in which they should be delivered. It was divided into a number of subfields, as shown in <a class="xref" href="ch21s02.html#original_definition_of_ipv_type_of_servi" title="Table 21-4. Original Definition of IPv4 Type of Service (TOS) Field">Table 21-4</a> and <a class="xref" href="ch21s02.html#ipv4_datagram_format_this_diagram_shows_" title="Figure 21-2. IPv4 datagram format This diagram shows the all-important IPv4 datagram format. The first 20 bytes are the fixed IP header, followed by an optional Options section, and a variable-length Data area. Note that the Type of Service field is shown as originally defined in the IPv4 standard.">Figure 21-2</a>.</p><p>The lack of QoS features has been considered a weakness of IP for a long time. But as you can see in <a class="xref" href="ch21s02.html#original_definition_of_ipv_type_of_servi" title="Table 21-4. Original Definition of IPv4 Type of Service (TOS) Field">Table 21-4</a>, these features were built into IP from the start. The fact is that even though this field was defined in the standard in the early 1980s, it was not widely used by hardware and software. For years, it was just passed around with all zeros in the bits and mostly ignored.</p><p>The Internet Engineering Task Force (IETF), seeing the field unused, attempted to revive its use. In 1998, RFC 2474 redefined the first six bits of the TOS field to support a technique called <a class="indexterm" id="idx-CHP-21-0787"/><span class="emphasis"><em>Differentiated Services (DS)</em></span>. Under DS, the values in the TOS field are called <span class="emphasis"><em>codepoints</em></span> and are associated with different service levels. (See RFC 2474 for all the details.)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-114"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>Be sure to read the remainder of this chapter for more information on how IP options are used in datagrams and <a class="xref" href="ch22.html" title="Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY">Chapter 22</a> for some more context on the use of fragmentation-related fields such as Identification, Fragment Offset, and More Fragments</em></span>.</p></div><div class="table"><a id="original_definition_of_ipv_type_of_servi"/><p class="title">Table 21-4. Original Definition of IPv4 Type of Service (TOS) Field</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Original Definition of IPv4 Type of Service (TOS) Field"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Precedence</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3/8 (3 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>A field indicating the priority of the datagram. There were eight defined values, from lowest to highest priority:</p>
<p>000: Routine</p>
<p>001: Priority</p>
<p>010: Immediate</p>
<p>011: Flash</p>
<p>100: Flash Override</p>
<p>101: CRITIC/ECP</p>
<p>110: Internetwork Control</p>
<p>111: Network Control</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 0 to request normal delay in delivery; set to 1 if a low delay delivery is requested.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>T</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 0 to request normal delivery throughput; set to 1 if higher throughput delivery is requested.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 0 to request normal reliability in delivery; set to 1 if higher reliability delivery is requested.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; "><p>2/8 (2 bits)</p></td><td style=""><p>Not used.</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="IP Datagram Options and Option Format"><div class="titlepage"><div><div><h1 class="title"><a id="ip_datagram_options_and_option_format"/>IP Datagram Options and Option Format</h1></div></div></div><p><a class="indexterm" id="idx-CHP-21-0788"/><a class="indexterm" id="idx-CHP-21-0789"/>All IP datagrams must include the standard 20-byte header that contains key information such as the source and destination address of the datagram, fragmentation control parameters, length information, and more. In addition to these invariable fields, the creators of IPv4 included the ability to add <span class="emphasis"><em>options</em></span> that provide additional flexibility in how IP handles datagrams. Use of these options is, of course, optional. However, all devices that handle IP datagrams must be capable of properly reading and handling them.</p><p>The IP datagram may contain zero, one, or more options, so the total length of the Options field in the IP header is variable. Each of the options can be a single byte or multiple bytes in length, depending on how much information the option needs to convey. When more than one option is included, they are concatenated and put into the Options field as a whole. Since the IP header must be a multiple of 32 bits, a Padding field is included if the number of bits in all options together is not a multiple of 32 bits.</p><p>Each IP option has its own subfield format, generally structured as shown in Tables <a class="xref" href="ch21s03.html#ipv_option_format" title="Table 21-5. IPv4 Option Format">Table 21-5</a> and <a class="xref" href="ch21s03.html#ipv_options_option_type_subfields" title="Table 21-6. IPv4 Options: Option Type Subfields">Table 21-6</a>, and illustrated in <a class="xref" href="ch21s03.html#ipv4_options_field_format_this_diagram_s" title="Figure 21-3. IPv4 Options field format This diagram shows the full field format for an IPv4 option. Note that a few simple options may consist of only the Option Type subfield, with the Option Length and Option Data subfields omitted.">Figure 21-3</a>. For most options, all three subfields are used: Option <a class="indexterm" id="idx-CHP-21-0790"/>Type, Option Length, and Option Data. For a few simple options, however, this complex substructure is not needed. In those cases, the option type itself communicates all the information required, so the Option Type field appears, and the Option Length and Option Data subfields are omitted.</p><div class="table"><a id="ipv_option_format"/><p class="title">Table 21-5. IPv4 Option Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv4 Option Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Option Type subfield is divided into three subsubfields, as shown in <a class="xref" href="ch21s03.html#ipv_options_option_type_subfields" title="Table 21-6. IPv4 Options: Option Type Subfields">Table 21-6</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 or 1</p></td><td style="border-bottom: 0.5pt solid ; "><p>For variable-length <a class="indexterm" id="idx-CHP-21-0791"/>options, indicates the size of the entire option, including all three subfields shown here, in bytes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Option Data</p></td><td style="border-right: 0.5pt solid ; "><p>0 or variable</p></td><td style=""><p>For variable-length <a class="indexterm" id="idx-CHP-21-0792"/>options, contains data to be sent as part of the option.</p></td></tr></tbody></table></div></div><div class="table"><a id="ipv_options_option_type_subfields"/><p class="title">Table 21-6. IPv4 Options: Option Type Subfields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IPv4 Options: Option Type Subfields"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sub-Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Copied Flag</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>This bit is set to 1 if the option is intended to be copied into all fragments when a datagram is fragmented; it is cleared to 0 if the option should not be copied into fragments.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Class</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2/8 (2 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies one of four potential values that indicate the general category into which the option belongs. In fact, only two of the values are used: 0 is for Control options, and 2 for Debugging and Measurement.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Option Number</p></td><td style="border-right: 0.5pt solid ; "><p>5/8 (5 bits)</p></td><td style=""><p>Specifies the kind of option. 32 different values can be specified for each of the two option classes. Of these, a few are more commonly employed. See <a class="xref" href="ch21s03.html#common_ipv_options" title="Table 21-7. Common IPv4 Options">Table 21-7</a> for more information on the specific options.</p></td></tr></tbody></table></div></div><p><a class="xref" href="ch21s03.html#common_ipv_options" title="Table 21-7. Common IPv4 Options">Table 21-7</a> lists the most common IPv4 options, showing the option class, option number, and length for each (a length of 1 indicates that an option consists of only an Option Type field). The table also provides a brief description of how each is used.</p><div class="figure"><a id="ipv4_options_field_format_this_diagram_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e23498"/><img alt="IPv4 Options field format This diagram shows the full field format for an IPv4 option. Note that a few simple options may consist of only the Option Type subfield, with the Option Length and Option Data subfields omitted." src="httpatomoreillycomsourcenostarchimages287855.png.jpg"/></div></div><p class="title">Figure 21-3. IPv4 Options field format This diagram shows the full field format for an IPv4 option. Note that a few simple options may consist of only the Option Type subfield, with the Option Length and Option Data subfields omitted.</p></div><div class="table"><a id="common_ipv_options"/><p class="title">Table 21-7. Common IPv4 Options</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common IPv4 Options"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length (Bytes)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Option Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>End of Options List</p></td><td style="border-bottom: 0.5pt solid ; "><p>An option containing just a single zero byte, used to mark the end of a list of options.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No Operation</p></td><td style="border-bottom: 0.5pt solid ; "><p>A "dummy option" used as internal padding to align certain options on a 32-bit boundary when required.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Security</p></td><td style="border-bottom: 0.5pt solid ; "><p>An option provided for the military to indicate the security classification of IP datagrams.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Loose Source Route</p></td><td style="border-bottom: 0.5pt solid ; "><p>One of two options for source routing of IP datagrams.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Record Route</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows the route used by a datagram to be recorded within the header for the datagram itself. If a source device sends a datagram with this option in it, each router that handles the datagram adds its IP address to this option. The recipient can then extract the list of IP addresses to see the route taken by the datagram. Note that the length of this option is set by the originating device. It cannot be enlarged as the datagram is routed, and if it fills up before it arrives at its destination, only a partial route will be recorded.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Strict Source Route</p></td><td style="border-bottom: 0.5pt solid ; "><p>One of two options for source routing of IP datagrams.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Timestamp</p></td><td style="border-bottom: 0.5pt solid ; "><p>Works similar to the Record Route option, but each device puts in a timestamp, so the recipient can see how long it took for the datagram to travel between routers. As with the Record Route option, the length of this option is set by the originating device and cannot be enlarged by intermediate devices.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; "><p>Traceroute</p></td><td style=""><p>Used in the enhanced implementation of the traceroute utility, as described in RFC 1393. Also see <a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a>, which discusses ICMP traceroute messages.</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-115"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each IPv4 datagram has a 20-byte mandatory header and may also include one or more <span class="emphasis"><em>options</em></span>. Each option has its own field format, and most are variable in size.</p></div><p>Normally, IP datagrams are routed without any specific instructions from devices about the path a datagram should take from the source to the destination. It's the job of routers to use routing protocols and to figure out those details. In some cases, however, it may be advantageous to have the source of a datagram specify the route a datagram takes through the network. This process is called <span class="emphasis"><em>source routing</em></span>.</p><p>There are two IP options that support source routing. In each, the option includes a list of IP addresses that specify the routers that must be used to reach the destination. When <span class="emphasis"><em>strict</em></span> source routing is used, the path specified in the option must be used exactly, in sequence, with no other routers permitted to handle the datagram at all. In contrast, <span class="emphasis"><em>loose</em></span> source routing specifies a list of IP addresses that must be followed in sequence, but it allows intervening hops between the devices on the list. (For full details on the exact structure used by each option type, please refer to RFC 791.)</p></div>
<div class="chapter" title="Chapter&#xA0;22.&#xA0;IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY"><div class="titlepage"><div><div><h1 class="title"><a id="ip_datagram_size_fragmentation_and_reass"/>Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e23687"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The main responsibility of the Internet Protocol (IP) is to deliver data between internetworked devices. As you saw in the preceding chapter, this requires that data received from higher layers be encapsulated into IP datagrams for transmission. These datagrams are then passed down to the data link layer, where they are sent over physical network links. In order for this to work properly, each datagram must be small enough to fit within the frame format of the underlying technology. If the message is bigger than the maximum frame size of the underlying network, it may be necessary to fragment the message. The datagrams are then sent individually and reassembled into the original message.</p><p>IP is designed to manage datagram size and to make fragmentation and reassembly seamless. This chapter explores issues related to managing the size of IP datagrams. I start with an overview of datagram size issues and the important concept of a network's maximum transmission unit (MTU), discussing why fragmentation is necessary. I then describe the process by which messages are fragmented by the source device, and possibly by routers along the path to the destination, and how they are reassembled by the recipient.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-116"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>Understanding fragmentation and reassembly requires some knowledge of the basic format of IP datagrams and some of the fields they contain. If you haven't yet read the chapter describing the general format of IP datagrams in <a class="xref" href="ch21.html" title="Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 21</a>, you may wish to review it before proceeding here.</em></span></p></div><div class="sect1" title="IP Datagram Size, MTU, and Fragmentation Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ip_datagram_size_mtu_and_fragmentation_o"/>IP Datagram Size, MTU, and Fragmentation Overview</h1></div></div></div><p><a class="indexterm" id="idx-CHP-22-0793"/>As the core network layer protocol of the TCP/IP protocol suite, IP is designed to implement potentially large internetworks of devices. When we work with IP, we get used to the concept of hosts being able to send information back and forth, even though the hosts may be quite far apart. Although we can usually consider the TCP/IP internetwork to be like a large, abstract virtual network of devices, we must always remember that underneath the network layer, data always travels across one or more physical networks. The implementation of IP must take this reality into account as well.</p><p>In order to send messages using IP, we encapsulate the higher-layer data into IP datagrams. These datagrams must then be sent down to the data link layer, where they are further encapsulated into the frames of whatever technology will be used to physically convey them, either directly to their destination or indirectly to the next intermediate step in their journey to their intended recipient. The data link layer implementation puts the entire IP datagram into the data portion (the payload) of its frame format, just as IP puts transport layer messages—transport headers and all—into its IP Data field. This immediately presents us with a potential issue: matching the size of the IP datagram to the size of the underlying data link layer frame size.</p><div class="sect2" title="IP Datagram Size and the Underlying Network Frame Size"><div class="titlepage"><div><div><h2 class="title"><a id="ip_datagram_size_and_the_underlying_netw"/>IP Datagram Size and the Underlying Network Frame Size</h2></div></div></div><p>The underlying network that a device uses to connect to other devices could be a local area network (LAN) connection (like Ethernet or Token Ring), wireless LAN (WLAN) link (such as 802.11), dial-up connection, Digital Subscriber Line (DSL) connection, T1 link, or other wide area network (WAN) connection. Each physical network will generally use its own frame format, and each format has a limit on how much data can be sent in a single frame. If the IP datagram is too large for the data link layer frame format's payload section, we have a problem!</p><p>For example, consider a <a class="indexterm" id="idx-CHP-22-0794"/>Fiber Distributed Data Interface (<a class="indexterm" id="idx-CHP-22-0795"/>FDDI) network. The maximum size of the data field in FDDI is around 4,470 bytes. This means FDDI can handle an IP datagram of up to 4,470 bytes. In contrast, a regular Ethernet frame uses a frame format that limits the size of the payload it sends to 1,500 bytes. This means that Ethernet cannot deal with IP datagrams greater than 1,500 bytes.</p><p>Now, remember that in sending a datagram across an internetwork, it may pass across more than one physical network. To access a site on the Internet, for example, we typically send a request through our local router, which then connects to other routers that eventually relay the request to the Internet site. Each hop as the datagram is forwarded may use a different physical network, with a different maximum underlying frame size.</p><p>The whole idea behind a network layer protocol is to implement this concept of a virtual network where devices can communicate over great distances. This means that higher layers shouldn't need to worry about details like the size limits of underlying data link layer technologies. This task falls to <a class="indexterm" id="idx-CHP-22-0796"/>IP.</p></div><div class="sect2" title="MTU and Datagram Fragmentation"><div class="titlepage"><div><div><h2 class="title"><a id="mtu_and_datagram_fragmentation"/>MTU and Datagram Fragmentation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-22-0797"/><a class="indexterm" id="idx-CHP-22-0798"/>
Each device on an IP internetwork must know the capacity of its immediate data link layer connection to other devices. This capacity is called the <a class="indexterm" id="idx-CHP-22-0799"/><span class="emphasis"><em>maximum transmission unit (MTU)</em></span><a class="indexterm" id="idx-CHP-22-0800"/> of the network, also known as the <a class="indexterm" id="idx-CHP-22-0801"/><span class="emphasis"><em>maximum transfer unit</em></span>.</p><p>If an IP layer receives a message to be sent across the internetwork, it looks at the size of the message and then computes how large the IP datagram would be after the addition of the 20 or more bytes needed for the IP header. If the total length is greater than the MTU of the underlying network, the IP layer will fragment the message into multiple IP fragments. Thus, if a host is connected to its local network using an Ethernet LAN, it may use an MTU of 1,500 bytes for IP datagrams, and it will fragment anything larger.</p><p><a class="xref" href="ch22.html#ip_maximum_transmission_unit_mtu_and_fra" title="Figure 22-1. IP maximum transmission unit (MTU) and fragmentation In this simple example, Device A is sending to Device B over a small internetwork consisting of one router and two physical links. The link from Device A to the router has an MTU of 3,300 bytes, but from the router to Device B, it is only 1,300 bytes. Thus, any IP datagrams larger than 1,300 bytes will need to be fragmented.">Figure 22-1</a> shows an example of different MTUs and fragmentation.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-117"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The size of the largest IP datagram that can be transmitted over a physical network is called that network's <span class="emphasis"><em>maximum transmission unit (MTU)</em></span>. If a datagram is passed from a network with a high MTU to one with a low MTU, it must be fragmented to fit the other network's smaller MTU.</p></div><p>Since some physical networks on the path between devices may have a smaller MTU than others, it may be necessary to fragment the datagram more than once. For example, suppose the source device wants to send an IP message 12,000 bytes long. Its local connection has an MTU of 3,300 bytes. It will need to divide this message into four fragments for transmission: three that are about 3,300 bytes long and a fourth remnant about 2,100 bytes long. (I'm oversimplifying by ignoring the extra headers required; the "The IP Message Fragmentation Process" section later in this chapter includes the full details of the fragmentation process.)</p><div class="figure"><a id="ip_maximum_transmission_unit_mtu_and_fra"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e23789"/><img alt="IP maximum transmission unit (MTU) and fragmentation In this simple example, Device A is sending to Device B over a small internetwork consisting of one router and two physical links. The link from Device A to the router has an MTU of 3,300 bytes, but from the router to Device B, it is only 1,300 bytes. Thus, any IP datagrams larger than 1,300 bytes will need to be fragmented." src="httpatomoreillycomsourcenostarchimages287857.png.jpg"/></div></div><p class="title">Figure 22-1. IP maximum transmission unit (MTU) and fragmentation In this simple example, Device A is sending to Device B over a small internetwork consisting of one router and two physical links. The link from Device A to the router has an MTU of 3,300 bytes, but from the router to Device B, it is only 1,300 bytes. Thus, any IP datagrams larger than 1,300 bytes will need to be fragmented.</p></div></div><div class="sect2" title="Multiple-Stage Fragmentation"><div class="titlepage"><div><div><h2 class="title"><a id="multiple-stage_fragmentation"/>Multiple-Stage Fragmentation</h2></div></div></div><p>While the <a class="indexterm" id="idx-CHP-22-0802"/>IP fragments are in transit, they may need to pass over a hop between two routers where the physical network's MTU is only 1,300 bytes. In this case, each of the fragments will again need to be fragmented. The 3,300-byte fragments will end up in three pieces each (two of about 1,300 bytes and one of around 700 bytes), and the final 2,100-byte fragment will become a 1,300-byte and 800-byte fragment. So, instead of having four fragments, we will end up with eleven (3*3+1*2) fragments, as shown in <a class="xref" href="ch22.html#ipv4_datagram_fragmentation_this_example" title="Figure 22-2. IPv4 datagram fragmentation. This example illustrates a two-step fragmentation of a large IP datagram. The boxes represent datagrams or datagram fragments and are shown to scale. The original datagram is 12,000 bytes, represented by the large, gray box. To transmit this data over the first local link, Device A splits it into four fragments, shown on the left. The first router must fragment each of these into smaller fragments to send them over the 1,300-byte MTU link, as shown on the bottom. Note that the second router does not reassemble the 1,300-byte fragments, even though its link to Device B has an MTU of 3,300 bytes. (The &quot;IP Fragmentation Process&quot; section later in this chapter describes the process by which the fragments in this example are created.)">Figure 22-2</a>.</p><div class="figure"><a id="ipv4_datagram_fragmentation_this_example"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e23810"/><img alt="IPv4 datagram fragmentation. This example illustrates a two-step fragmentation of a large IP datagram. The boxes represent datagrams or datagram fragments and are shown to scale. The original datagram is 12,000 bytes, represented by the large, gray box. To transmit this data over the first local link, Device A splits it into four fragments, shown on the left. The first router must fragment each of these into smaller fragments to send them over the 1,300-byte MTU link, as shown on the bottom. Note that the second router does not reassemble the 1,300-byte fragments, even though its link to Device B has an MTU of 3,300 bytes. (The &quot;IP Fragmentation Process&quot; section later in this chapter describes the process by which the fragments in this example are created.)" src="httpatomoreillycomsourcenostarchimages287859.png.jpg"/></div></div><p class="title">Figure 22-2. IPv4 datagram fragmentation. This example illustrates a two-step fragmentation of a large IP datagram. The boxes represent datagrams or datagram fragments and are shown to scale. The original datagram is 12,000 bytes, represented by the large, gray box. To transmit this data over the first local link, Device A splits it into four fragments, shown on the left. The first router must fragment each of these into smaller fragments to send them over the 1,300-byte MTU link, as shown on the bottom. Note that the second router does not reassemble the 1,300-byte fragments, even though its link to Device B has an MTU of 3,300 bytes. (The "IP Fragmentation Process" section later in this chapter describes the process by which the fragments in this example are created.)</p></div></div><div class="sect2" title="Internet Minimum MTU: 576 Bytes"><div class="titlepage"><div><div><h2 class="title"><a id="internet_minimum_mtu_576_bytes"/>Internet Minimum MTU: 576 Bytes</h2></div></div></div><p><a class="indexterm" id="idx-CHP-22-0803"/>Routers are required to handle an MTU of at least 576 bytes. This value is specified in RFC 791; it was chosen to allow a data block of at least 512 bytes, plus room for the standard IP header and options. Since this is the minimum size specified in the IP standard, 576 bytes has become a common default MTU value used for IP datagrams. Even if a host is connected over a local network with an MTU larger than 576 bytes, it may choose to use an MTU value of 576 to ensure that no further fragmentation will be required by intermediate routers.</p><div class="note" title="Note"><h3 class="title"><a id="note-82"/>Note</h3><p><span class="emphasis"><em>While intermediate routers may further fragment an already-fragmented IP message, they do not reassemble fragments. Reassembly is done only by the recipient device. This has some advantages and some disadvantages, as we will see when we examine the reassembly process in the "IP Message Reassembly" section later in this chapter</em></span>.</p></div></div><div class="sect2" title="MTU Path Discovery"><div class="titlepage"><div><div><h2 class="title"><a id="mtu_path_discovery"/>MTU Path Discovery</h2></div></div></div><p><a class="indexterm" id="idx-CHP-22-0804"/>When we're trying to send a great deal of data, efficiency in message transmissions becomes important. The larger the IP datagram we send, the smaller the percentage of bytes wasted for overhead such as header fields. This means that, ideally, we want to use the largest MTU possible without requiring fragmentation for its transmission.</p><p>To determine the optimal MTU to use for a route between two devices, we would need to know the MTU of every link on that route—information that the endpoints of the connection simply don't have. However, the connection endpoint can determine the MTU of the overall route by using <span class="emphasis"><em>MTU path discovery</em></span>, which uses an error-reporting mechanism built into TCP/IP <a class="indexterm" id="idx-CHP-22-0805"/>Internet Control Message Protocol (ICMP).</p><p>One of the message types defined in ICMP version 4 (ICMPv4) is the <a class="indexterm" id="idx-CHP-22-0806"/>Destination Unreachable message (see <a class="xref" href="ch32.html" title="Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS">Chapter 32</a>), which is returned under various conditions where an IP datagram cannot be delivered. One of these situations is when a datagram is too large to be forwarded by a router over a physical link, but this datagram has its Don't Fragment (DF) flag set to prevent fragmentation. In this case, the datagram must be discarded and a Destination Unreachable message sent back to the source. A device can exploit this capability by testing the path with datagrams of different sizes, to see how large they must be before they are rejected.</p><p>The source node typically sends a datagram that has the MTU of its local physical link, since that represents an upper bound for any path to or from that device. If this datagram goes through without any errors, the device knows it can use that value for future datagrams to that destination. If it gets back any Destination Unreachable - Fragmentation Needed and DF Set messages, it knows that a link between it and the destination has a smaller MTU. It tries again using a smaller datagram size, and it continues until it finds the largest MTU that can be used on the path.</p></div></div></div>
<div class="sect1" title="IP Message Fragmentation Process"><div class="titlepage"><div><div><h1 class="title"><a id="ip_message_fragmentation_process"/>IP Message Fragmentation Process</h1></div></div></div><p>As explained in the previous section, when an IP datagram is too large for the MTU of the underlying data link layer technology used for the next leg of its journey, it must be fragmented before it can be sent across the network. The higher-layer message to be transmitted is not sent in a single IP datagram, but rather broken down into fragments that are sent separately. In some cases, the fragments themselves may need to be fragmented further.</p><p><a class="indexterm" id="idx-CHP-22-0807"/>Fragmentation is key to implementing a network-layer internetwork that is independent of lower-layer details, but it introduces significant complexity to IP. Remember that IP is an unreliable, connectionless protocol. IP datagrams can take any of several routes on their way from the source to the destination, and some may not even make it to the destination at all. When a message is fragmented, this converts a single datagram into many, which introduces several new concerns:</p><p><span class="strong"><strong>Sequencing and Placement</strong></span> The fragments will typically be sent in sequential order from the beginning of the message to the end, but they won't necessarily show up in the order in which they were sent. The receiving device must be able to determine the sequence of the fragments to reassemble them in the correct order. In fact, some implementations send the last fragment first, so the receiving device will immediately know the full size of the original, complete datagram. This makes keeping track of the order of segments even more essential.</p><p><span class="strong"><strong>Separation of Fragmented Messages</strong></span> A source device may need to send more than one fragmented message at a time, or it may send multiple datagrams that are fragmented en route. This means that the destination may be receiving multiple sets of fragments that must be put back together. Imagine a box containing pieces from two, three, or more jigsaw puzzles, and you understand this issue.</p><p><span class="strong"><strong>Completion</strong></span> The destination device must be able to tell when it has received all of the fragments so it knows when to start reassembly (or when to give up if it didn't get all the pieces).</p><p>To address these concerns and allow the proper reassembly of the fragmented message, IP includes several fields in the IP format header that convey information from the source to the destination about the fragments. Some of these fields contain a common value for all the fragments of the message; others are different for each fragment.</p><div class="sect2" title="The IP Fragmentation Process"><div class="titlepage"><div><div><h2 class="title"><a id="the_ip_fragmentation_process"/>The IP Fragmentation Process</h2></div></div></div><p><a class="indexterm" id="idx-CHP-22-0808"/>The device performing the fragmentation follows a specific algorithm to divide the message into fragments for transmission. The exact implementation of the fragmentation process depends on the device. For example, consider an IP message 12,000 bytes wide (including the 20-byte IP header) that needs to be sent over a link with an MTU of 3,300 bytes. <a class="xref" href="ch22s02.html#ipv4_datagram_fragmentation_process_in_t" title="Figure 22-3. IPv4 datagram fragmentation process In this diagram, the MF and Fragment Offset fields of each fragment are shown for reference. The Data fields are shown to scale (the length of each is proportional to the number of bytes in the fragment).">Figure 22-3</a> depicts a typical method by which this fragmentation might be performed.</p><div class="figure"><a id="ipv4_datagram_fragmentation_process_in_t"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e23900"/><img alt="IPv4 datagram fragmentation process In this diagram, the MF and Fragment Offset fields of each fragment are shown for reference. The Data fields are shown to scale (the length of each is proportional to the number of bytes in the fragment)." src="httpatomoreillycomsourcenostarchimages287861.png.jpg"/></div></div><p class="title">Figure 22-3. IPv4 datagram fragmentation process In this diagram, the MF and Fragment Offset fields of each fragment are shown for reference. The Data fields are shown to scale (the length of each is proportional to the number of bytes in the fragment).</p></div><p>The four fragments shown in <a class="xref" href="ch22s02.html#ipv4_datagram_fragmentation_process_in_t" title="Figure 22-3. IPv4 datagram fragmentation process In this diagram, the MF and Fragment Offset fields of each fragment are shown for reference. The Data fields are shown to scale (the length of each is proportional to the number of bytes in the fragment).">Figure 22-3</a> are created as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The first fragment is created by taking the first 3,300 bytes of the 12,000-byte IP datagram. This includes the original header, which becomes the IP header of the first fragment (with certain fields changed, as described in the next section). So, 3,280 bytes of data are in the first fragment. This leaves 8,700 bytes (11,980–3,280) to encapsulate.</p></li><li class="listitem"><p>The next 3,280 bytes of data are taken from the 8,700 bytes that remain after the first fragment is built and paired with a new header to create the second fragment. This leaves 5,420 bytes.</p></li><li class="listitem"><p>The third fragment is created from the next 3,280 bytes of data, with a 20-byte header. This leaves 2,140 bytes of data.</p></li><li class="listitem"><p>The remaining 2,140 bytes are placed into the fourth fragment, with a 20-byte header.</p></li></ul></div><p>There are two important points here. First, IP fragmentation does <span class="emphasis"><em>not</em></span> work by fully encapsulating the original IP message into the Data fields of the fragments. If this were the case, the first 20 bytes of the Data field of the first fragment would contain the original IP header. (This technique is used by some other protocols, such as the PPP Multilink Protocol, discussed in <a class="xref" href="ch09.html" title="Chapter 9. TCP/IP SERIAL LINE INTERNET PROTOCOL (SLIP) AND POINT-TO-POINT PROTOCOL (PPP) OVERVIEW AND FUNDAMENTALS">Chapter 9</a>.) The original IP header is transformed into the IP header of the first fragment.</p><p>Second, note that the total number of bytes transmitted increases: we are sending 12,060 bytes (3,300*3+2,160), instead of 12,000 bytes. The extra 60 bytes are from the additional headers in the second, third, and fourth fragments. (The increase in size could theoretically be even larger if the headers contain options.)</p></div><div class="sect2" title="Fragmentation-Related IP Datagram Header Fields"><div class="titlepage"><div><div><h2 class="title"><a id="fragmentation-related_ip_datagram_header"/>Fragmentation-Related IP Datagram Header Fields</h2></div></div></div><p><a class="indexterm" id="idx-CHP-22-0809"/>When a sending device or router fragments a datagram, it must provide information that will allow the receiving device to identify the fragments and reassemble them into the original datagram. This information is recorded by the fragmenting device in a number of fields in the IP datagram header:</p><p><span class="strong"><strong>Total Length</strong></span> After fragmenting, the <a class="indexterm" id="idx-CHP-22-0810"/>Total Length field indicates the length of each fragment, not the length of the overall message. Normally, the fragment size is selected to match the MTU value in bytes. However, fragments must have a length that is a multiple of 8, to allow proper offset specification (handled by the Fragment Offset field). The last fragment will usually be shorter than the others because it will contain a leftover piece, unless the message length happens to be an exact multiple of the fragment size.</p><p><span class="strong"><strong>Identification</strong></span> To solve the problem of pieces from many jigsaw puzzles in the same box, a unique identifier is assigned to each message being fragmented. This is like writing a different number on the bottom of each piece of a jigsaw puzzle before tossing it in the box. This value is placed in the Identification field in the IP header of each fragment sent. The Identification field is 16 bits wide, so a total of 65,536 different identifiers can be used. Obviously, we want to make sure that each message that is being fragmented for delivery has a different identifier. The source can decide how it generates unique identifiers. This may be done through something as simple as a counter that is incremented each time a new set of fragments is created.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-22-0811"/>More Fragments</strong></span> The More Fragments flag is set to a 1 for all fragments except the last one, which has it set to 0. When the fragment with a value of 0 in the More Fragments flag is seen, the destination knows it has received the last fragment of the message.</p><p><span class="strong"><strong>Fragment Offset</strong></span> The Fragment Offset field solves the problem of sequencing fragments by indicating to the recipient device where in the overall message each particular fragment should be placed. The field is 13 bits wide, so the offset can be from 0 to 8,191. Fragments are specified in units of 8 bytes, which is why fragment length must be a multiple of 8. Uncoincidentally, 8,191*8 is 65,528, just about the maximum size allowed for an IP datagram. In the example shown in <a class="xref" href="ch22s02.html#ipv4_datagram_fragmentation_process_in_t" title="Figure 22-3. IPv4 datagram fragmentation process In this diagram, the MF and Fragment Offset fields of each fragment are shown for reference. The Data fields are shown to scale (the length of each is proportional to the number of bytes in the fragment).">Figure 22-3</a>, the first fragment would have a Fragment Offset of 0, the second would have an offset of 410 (3,280/8), the third would have an offset of 820 (6,560/8), and the fourth would have an offset of 1,230.</p><p>An IP datagram has a couple of other fields related to fragmentation. First, if a datagram containing options must be fragmented, some of the options may be copied to each of the fragments. This is controlled by the <a class="indexterm" id="idx-CHP-22-0812"/>Copied flag in each option field.</p><p>Second, in the IP header, there is a flag called <a class="indexterm" id="idx-CHP-22-0813"/>Don't Fragment. This field can be set to 1 by a transmitting device to specify that a datagram should not be fragmented in transit. This may be used in certain circumstances where the entire message must be delivered intact for some reason. It may also be used if the destination device has a limited IP implementation and cannot reassemble fragments, and it is also used for testing the MTU of a link. Normally, however, devices don't care about fragmentation, and this field is left at 0.</p><p>If a router encounters a datagram too large to pass over the next physical network but with the Don't Fragment bit set to 1, it cannot fragment the datagram and it cannot pass it along either, so it is stuck. It will generally drop the datagram and return an ICMP Destination Unreachable error message: "Fragmentation Needed and Don't Fragment Bit Set." This is used in MTU path discovery, as described earlier in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-118"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> When an MTU requirement forces a datagram to be fragmented, it is split into several smaller IP datagrams, each containing part of the original. The header of the original datagram is changed into the header of the first fragment, and new headers are created for the other fragments. Each is set to the same Identification value to mark them as part of the same original datagram. The Fragment Offset of each is set to the location where the fragment belongs in the original. The More Fragments field is set to 1 for all fragments but the last, to let the recipient know when it has received all the fragments.</p></div></div></div>
<div class="sect1" title="IP Message Reassembly"><div class="titlepage"><div><div><h1 class="title"><a id="ip_message_reassembly"/>IP Message Reassembly</h1></div></div></div><p><a class="indexterm" id="idx-CHP-22-0814"/>When a datagram is fragmented, it becomes multiple fragment datagrams. The destination of the overall message must collect these fragments and reassemble them into the original message.</p><p>While <a class="indexterm" id="idx-CHP-22-0815"/>reassembly is the complement to fragmentation, the two processes are not symmetric. A primary differentiation between the two is that intermediate routers can fragment a single datagram or further fragment a datagram that is already a fragment, but intermediate devices do not perform reassembly; reassembly happens only at the message's ultimate destination. Thus, if a datagram at an intermediate router on one side of a physical network with an MTU of 1,300 bytes causes fragmentation of a 3,300-byte datagram, the router on the other end of this 1,300 MTU link will <span class="emphasis"><em>not</em></span> restore the 3,300-byte datagram to its original state. It will send all the 1,300-byte fragments on down the internetwork, as shown in <a class="xref" href="ch22.html#ipv4_datagram_fragmentation_this_example" title="Figure 22-2. IPv4 datagram fragmentation. This example illustrates a two-step fragmentation of a large IP datagram. The boxes represent datagrams or datagram fragments and are shown to scale. The original datagram is 12,000 bytes, represented by the large, gray box. To transmit this data over the first local link, Device A splits it into four fragments, shown on the left. The first router must fragment each of these into smaller fragments to send them over the 1,300-byte MTU link, as shown on the bottom. Note that the second router does not reassemble the 1,300-byte fragments, even though its link to Device B has an MTU of 3,300 bytes. (The &quot;IP Fragmentation Process&quot; section later in this chapter describes the process by which the fragments in this example are created.)">Figure 22-2</a>, earlier in the chapter.</p><p>In IP version 4 (IPv4), fragmentation can be performed by a router between the source and destination of an IP datagram, but reassembly is done only by the destination device.</p><p>There are a number of reasons why the decision was made to implement IP reassembly this way. Perhaps the most important reason is that fragments can take different routes to get from the source to destination, so any given router may not see all the fragments in a message. Another reason is that if routers needed to worry about reassembling fragments, their complexity would increase. Finally, reassembly of a message requires that we wait for all fragments before sending on the reassembled message. Having routers do this would slow down routing. Since routers don't reassemble messages, they can immediately forward all fragments on to the ultimate recipient.</p><p>However, there are drawbacks to this design as well. One is that it results in more, smaller fragments traveling over longer routes than if intermediate reassembly occurred. This increases the chances of a fragment getting lost and the entire message being discarded. Another is a potential inefficiency in the utilization of data link layer frame capacity. In the example of a 3,300-byte datagram being fragmented for a 1,300-byte MTU link, the 1,300-byte fragments would not be reassembled back into a 3,300-byte datagram at the end of the 1,300-MTU link. If the next link after that one also had an MTU of 3,300 bytes, we would need to send three frames, each encapsulating a 1,300-byte fragment, instead of a single larger frame, which is slightly slower.</p><p>As described in the previous section, several IP header fields are filled in when a message is fragmented to give the receiving device the information it requires to properly reassemble the fragments. The receiving device follows a procedure to keep track of the fragments as they are received and build up its copy of the total received message from the source device. Most of its efforts are geared toward dealing with the potential difficulties associated with IP being an unreliable protocol.</p><p>The details of implementation of the reassembly process are specific to each device, but reassembly generally includes the following functions:</p><p><span class="strong"><strong>Fragment Recognition and Fragmented Message Identification</strong></span> The recipient knows it has received a message fragment the first time it sees a datagram with the More Fragments bit set to 1 or the Fragment Offset a value other than 0. It identifies the message based on the source and destination IP addresses, the protocol specified in the header, and the Identification field generated by the sender.</p><p><span class="strong"><strong>Buffer Initialization</strong></span> The receiving device initializes a buffer where it can store the fragments of the message as they are received. It keeps track of which portions of this buffer have been filled with received fragments, perhaps using a special table. By doing this, it knows when the buffer is partially filled with received fragments and when it is completely full.</p><p><span class="strong"><strong>Timer Initialization</strong></span> The receiving device sets up a timer for reassembly of the message. Since it is possible that some fragments may never show up, this timer ensures that the device will not wait an infinite time trying to reassemble the message.</p><p><span class="strong"><strong>Fragment Receipt and Processing</strong></span> Whenever a fragment of this message arrives (as indicated by it having the same source and destination addresses, protocol, and Identification as the first fragment), the fragment is processed. It is inserted into the message buffer in the location indicated by its Fragment Offset field. The device also makes note of the fact that this portion of the message has been received.</p><p>Reassembly is complete when the entire buffer has been filled and the fragment with the More Fragments bit set to 0 is received, indicating that it is the last fragment of the datagram. The reassembled datagram is then processed in the same way as a normal, unfragmented datagram. On the other hand, if the timer for the reassembly expires with any of the fragments missing, the message cannot be reconstructed. The fragments are discarded, and an ICMP Time Exceeded message is generated. Since IP is unreliable, it relies on higher-layer protocols such as the Transmission Control Protocol (TCP) to determine that the message was not properly received and then retransmit it.</p></div>
<div class="chapter" title="Chapter&#xA0;23.&#xA0;IP ROUTING AND MULTICASTING"><div class="titlepage"><div><div><h1 class="title"><a id="ip_routing_and_multicasting"/>Chapter 23. IP ROUTING AND MULTICASTING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e24040"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>The essential functions of Internet Protocol (IP) datagram encapsulation and addressing are sometimes compared to putting a letter in an envelope and then writing the address of the recipient on it. Once our IP datagram "envelope" is filled and labeled, it is ready to go, but it's still sitting on our desk. The last of the main functions of IP is to get the envelope to our intended recipient. This is the process of datagram <span class="emphasis"><em>delivery</em></span>. When the recipient is not on our local network, this delivery requires that the datagram be <span class="emphasis"><em>routed</em></span> from our network to the one where the destination resides.</p><p>This chapter concludes our look at IP version 4 (IPv4) with a discussion of some of the particulars of how it routes datagrams over an internetwork. I begin with an overview of the process and contrast direct and indirect delivery of data between devices. I discuss the main method used to route datagrams over the internetwork, and I explain briefly how IP routing tables are built and maintained. I describe how the move from classful to classless addressing using Classless Inter-Domain Routing (CIDR) has impacted routing.</p><p>I conclude with a brief look at the issues related to IP multicasting. Multicasting isn't really a part of routing, but many of the issues in multicasting are related to datagram <a class="indexterm" id="idx-CHP-23-0816"/>delivery and routing.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-119"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>This chapter focuses on routing issues that are directly related to how IP works. Routing is a complex and important topic in networking, and you'll find much more information about it in Chapters <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a> through <a class="xref" href="ch41.html" title="Chapter 41. OTHER ROUTING PROTOCOLS">Chapter 41</a></em></span>.</p></div><div class="sect1" title="IP Datagram Delivery"><div class="titlepage"><div><div><h1 class="title"><a id="ip_datagram_delivery"/>IP Datagram Delivery</h1></div></div></div><p>The overall job of IP is to transmit messages from higher-layer protocols over an internetwork of devices. These messages must be packaged and addressed, and fragmented if necessary, and then they must be <span class="emphasis"><em>delivered</em></span>. The process of delivery can be either simple or complex, depending on the proximity of the source and destination devices. We can divide all IP datagram deliveries into two general types: direct delivery and indirect delivery. <a class="xref" href="ch23.html#direct_and_indirect_routed_delivery_of_i" title="Figure 23-1. Direct and indirect (routed) delivery of IP datagrams This diagram shows three examples of IP datagram delivery. The first transmission (#1, dark arrow) shows a direct delivery between two devices on the local network. The second (#2, light arrow) shows indirect delivery within the local network, between a client and server separated by a router. The third (#3, medium arrow) shows a more distant indirect delivery, between a client on the local network and a server across the Internet.">Figure 23-1</a> shows some examples of IP <a class="indexterm" id="idx-CHP-23-0817"/>datagram delivery types.<a class="indexterm" id="idx-CHP-23-0818"/><a class="indexterm" id="idx-CHP-23-0819"/></p><div class="figure"><a id="direct_and_indirect_routed_delivery_of_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject9_d1e24104"/><img alt="Direct and indirect (routed) delivery of IP datagrams This diagram shows three examples of IP datagram delivery. The first transmission (#1, dark arrow) shows a direct delivery between two devices on the local network. The second (#2, light arrow) shows indirect delivery within the local network, between a client and server separated by a router. The third (#3, medium arrow) shows a more distant indirect delivery, between a client on the local network and a server across the Internet." src="httpatomoreillycomsourcenostarchimages287863.png.jpg"/></div></div><p class="title">Figure 23-1. Direct and indirect (routed) delivery of IP datagrams This diagram shows three examples of IP datagram delivery. The first transmission (#1, dark arrow) shows a direct delivery between two devices on the local network. The second (#2, light arrow) shows indirect delivery within the local network, between a client and server separated by a router. The third (#3, medium arrow) shows a more distant indirect delivery, between a client on the local network and a server across the Internet.</p></div><div class="sect2" title="Direct Datagram Delivery"><div class="titlepage"><div><div><h2 class="title"><a id="direct_datagram_delivery"/>Direct Datagram Delivery</h2></div></div></div><p>When datagrams are sent between two devices on the same physical network, the datagrams may be delivered directly from the source to the destination. For example, if you wanted to deliver a letter to a neighbor on your street, you would probably just put her name on the envelope and stick it right in her mailbox.<a class="indexterm" id="idx-CHP-23-0820"/></p><p>Direct delivery is obviously a simple delivery method. The source simply sends the IP datagram down to its data link layer implementation. The data link layer encapsulates the datagram in a frame that is sent over the physical network directly to the recipient's data link layer, which passes it up to the IP layer.</p></div><div class="sect2" title="Indirect Datagram Delivery (Routing)"><div class="titlepage"><div><div><h2 class="title"><a id="indirect_datagram_delivery_routing"/>Indirect Datagram Delivery (Routing)</h2></div></div></div><p>When two devices are not on the same physical network, the delivery of datagrams from one to the other is <span class="emphasis"><em>indirect</em></span>. Since the source device cannot see the destination on its local network, it must send the datagram through one or more intermediate devices to deliver it. Indirect delivery is like mailing a letter to a friend in a different city. You don't deliver it yourself; you use the postal system. The letter journeys through the postal system, possibly taking several intermediate steps, and ends up in your friend's neighborhood, where a postal carrier puts it into his mailbox.<a class="indexterm" id="idx-CHP-23-0821"/></p><p>Indirect delivery is much more complicated, because we can't send the data straight to the recipient. In fact, we usually will not even know exactly where the recipient is. Sure, we have its address, but we may not know what network it is on, or where that network is relative to our own. (If I told you my address, you would know it's somewhere in Bennington, Vermont, but could you find it?) Just as we must rely on the postal system in the envelope analogy, we must rely on the internetwork itself to indirectly deliver datagrams. And like the postal system, IP doesn't require you to know how to get the message to its recipient; you just put it into the system.</p><p>The devices that accomplish this magic of indirect delivery are generally known as <span class="emphasis"><em>routers</em></span>, and indirect delivery is more commonly called <span class="emphasis"><em>routing</em></span>. Like entrusting a letter to your local mail carrier or mailbox, a host that needs to deliver a message to a distant device generally sends datagrams to its local router. The router connects to one or more other routers, and they each maintain information about where to send datagrams so that they reach their final destination.</p><p>Indirect delivery is almost always required when communicating with distant devices, such as those on the Internet or across a wide area network (WAN) link. However, it may also be needed even to send a message to a device in the next room of your office, if that device is not connected directly to your device at layer 2.</p><div class="note" title="Note"><h3 class="title"><a id="note-83"/>Note</h3><p><span class="emphasis"><em>In the past, routers were often called gateways. Today, this term more generally can refer to devices that connect networks in a variety of ways. You will still sometimes hear routers called gateways, especially in the context of terms like default gateway, but since it is ambiguous, the term router is preferred</em></span>.<a class="indexterm" id="idx-CHP-23-0822"/></p></div></div><div class="sect2" title="The Relationship Between Datagram Routing and Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="the_relationship_between_datagram_routin"/>The Relationship Between Datagram Routing and Addressing</h2></div></div></div><p>Each time a datagram is to be sent, the sender must determine first whether it can be delivered directly or if routing is required. IP addressing is what allows a device to quickly determine whether or not it is on the same network as its intended recipient. The following are the three main categories of addressing (see <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a>):</p><p><a class="indexterm" id="idx-CHP-23-0823"/><span class="strong"><strong>Conventional Classful Addressing</strong></span> We know the class of each address by looking at the first few bits. This tells us which bits of an address are the network ID. If the network ID of the destination is the same as our own, the recipient is on the same network; otherwise, it is not. Refer to <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a> for more on classful addressing.</p><p><span class="strong"><strong>Subnetted Classful Addressing</strong></span> We use our subnet mask to determine our network ID and subnet ID and that of the destination address. If the network ID and subnet are the same, the recipient is on the same subnet. If only the network ID is the same, the recipient is on a different subnet of the same network. If the network ID is different, the destination is on a different network entirely. See <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a> for a full discussion of subnetting.</p><p><span class="strong"><strong>Classless Addressing</strong></span> The same basic technique is used as for subnetted classful addressing, except that there are no subnets. We use the slash number to determine what part of the address is the network ID and compare the source and destination as before; see <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>. (There are complications here, however, as discussed in the "IP Routing in a Subnet or Classless Addressing (CIDR) Environment" section later in this chapter.)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-120"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The delivery of IP datagrams is divided into two categories: <span class="emphasis"><em>direct</em></span> and <span class="emphasis"><em>indirect</em></span>. Direct delivery is possible when two devices are on the same physical network. When they are not, indirect delivery, more commonly called <span class="emphasis"><em>routing</em></span>, is required to get the datagrams from the source to the destination. A device can tell which type of delivery is required by looking at the IP address of the destination, in conjunction with supplemental information such as the subnet mask, which tells the device what network or subnet it is on.</p></div><p>The determination of what type of delivery is required is the first step in the source deciding where to send a datagram. If it realizes the destination is on the same local network, it will address the datagram to the recipient directly at the data link layer. Otherwise, it will send the datagram to the data link layer address of one of the routers to which it is connected. The IP address of the datagram will still be that of the ultimate destination. Mapping between IP addresses and data link layer addresses is accomplished using the TCP/IP Address Resolution Protocol (ARP), which is discussed in <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>.</p><p>Routing is done in indirect delivery to get the datagram to the local network of the recipient. Once the datagram has been routed to the recipient's physical network, it is sent to the recipient by the recipient's local router. So, you could say that indirect delivery includes direct delivery as its final step.</p><div class="note" title="Note"><h3 class="title"><a id="note-84"/>Note</h3><p><span class="emphasis"><em>Strictly speaking, any process of delivery between a source and destination device can be considered routing, even if the devices are on the same network. It is common, however, for the process of routing to refer more specifically to indirect delivery</em></span>.</p></div></div></div></div>
<div class="sect1" title="IP Routing Concepts and the Process of Next-Hop Routing"><div class="titlepage"><div><div><h1 class="title"><a id="ip_routing_concepts_and_the_process_of_n"/>IP Routing Concepts and the Process of Next-Hop Routing</h1></div></div></div><p><a class="indexterm" id="idx-CHP-23-0824"/>IP's ability to route information is what allows us to use it to create the equivalent of a virtual internetwork that spans potentially thousands of physical networks, allowing devices even on opposite ends of the globe communicate. Let's take a brief look at key IP routing concepts.</p><p>To continue with our postal system analogy, I can send a letter from my home in the United States to someone in, say, India, and the postal systems of both countries will work (or should work) to deliver the letter to its destination. However, when I drop a letter in the mailbox, it's not like someone shows up, grabs the letter, and hand-delivers it to the right address in India. The letter travels from the mailbox to my local post office. From there, it probably goes to a regional distribution center, and then from there, to a hub for international traffic. It goes to India, perhaps via an intermediate country. When it gets to India, the Indian postal system uses its own network of offices and facilities to route the letter to its destination. The envelope hops from one location to the next, until it reaches its destination.</p><p>IP routing works in very much the same manner. Even though IP lets devices connect over the internetwork using indirect delivery, all of the actual communication of datagrams occurs over physical networks using routers. We don't know exactly where the destination device's network is, and we certainly don't have any way to connect directly to each of the thousands of networks out there. Instead, we rely on these intermediate devices—routers—that are each physically connected to each other in a variety of ways to form a mesh containing millions of paths between networks. The datagram is handed off from one router to the next, until it gets to the physical network of the destination device. This process is called <span class="emphasis"><em>next-hop routing</em></span>, as illustrated in <a class="xref" href="ch23s02.html#ip_datagram_next-hop_routing_this_is_the" title="Figure 23-2. IP datagram next-hop routing This is the same diagram as that shown in Figure 23-1, except it explicitly shows the hops taken by each of the three sample transmissions. The direct delivery of the first transmission has only one hop (remember that the switch doesn't count because it is invisible at layer 3). The local indirect delivery passes through one router, so it has two hops. The Internet delivery has six hops. (Actual Internet routes can be much longer.)">Figure 23-2</a>.<a class="indexterm" id="idx-CHP-23-0825"/></p><p>This is a critical concept in how IP works: routing is done step by step, one hop at a time. When we decide to send a datagram to a device on a distant network, we don't know the exact path that the datagram will take; we have only enough information to send it to the correct router to which we are attached. That router, in turn, looks at the IP address of the destination and decides where the datagram should hop to next. This process continues until the datagram reaches the destination host's network.</p><p>At first, next-hop routing may seem like a strange way of sending datagrams over an internetwork. In fact, it is part of what makes IP so powerful. On each step of the journey to any other host, a router needs to know only where the next step for the datagram is. Without this concept, each device and router would need to know what path to take to every other host on the internetwork, which would be quite impractical.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-121"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Indirect delivery of IP datagrams is accomplished using a process called <span class="emphasis"><em>next-hop routing</em></span>, where each message is handed from one router to the next until it reaches the network of the destination. The main advantage of this is that each router needs to know only which neighboring router should be the next recipient of a given datagram, rather than needing to know the exact route to every destination network.</p></div><div class="figure"><a id="ip_datagram_next-hop_routing_this_is_the"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject9_d1e24248"/><img alt="IP datagram next-hop routing This is the same diagram as that shown in , except it explicitly shows the hops taken by each of the three sample transmissions. The direct delivery of the first transmission has only one hop (remember that the switch doesn't count because it is invisible at layer 3). The local indirect delivery passes through one router, so it has two hops. The Internet delivery has six hops. (Actual Internet routes can be much longer.)" src="httpatomoreillycomsourcenostarchimages287865.png.jpg"/></div></div><p class="title">Figure 23-2. IP datagram next-hop routing This is the same diagram as that shown in <a class="xref" href="ch23.html#direct_and_indirect_routed_delivery_of_i" title="Figure 23-1. Direct and indirect (routed) delivery of IP datagrams This diagram shows three examples of IP datagram delivery. The first transmission (#1, dark arrow) shows a direct delivery between two devices on the local network. The second (#2, light arrow) shows indirect delivery within the local network, between a client and server separated by a router. The third (#3, medium arrow) shows a more distant indirect delivery, between a client on the local network and a server across the Internet.">Figure 23-1</a>, except it explicitly shows the hops taken by each of the three sample transmissions. The direct delivery of the first transmission has only one hop (remember that the switch doesn't count because it is invisible at layer 3). The local indirect delivery passes through one router, so it has two hops. The Internet delivery has six hops. (Actual Internet routes can be much longer.)</p></div><p>Another key concept related to the principle of <a class="indexterm" id="idx-CHP-23-0826"/>next-hop routing is that routers, not hosts, are designed to accomplish routing. Most hosts are connected to the rest of the internetwork (or Internet) using only one router. It would be a maintenance nightmare to need to give each host the intelligence to know how to route to every other host. Instead, hosts decide only if they are sending to their own local network or to another network. If the destination is another network, a host just sends the datagram to its router and says, "Here, <span class="emphasis"><em>you</em></span> take care of this." If a host has a connection to more than one router, it needs to know only which router to use for certain sets of distant networks.</p><p>Again, each hop consists of the traversal of a physical network. Once a source sends a datagram to its local router, the data link layer on the router passes it up to the router's IP layer. There, the datagram's header is examined, and the router decides which device should get the datagram next. It then passes the datagram back down to the data link layer to be sent over one of the router's physical network links, typically to another router. The router will have a record of the physical addresses of the routers to which it is connected, or it will use ARP to determine these addresses.</p></div>
<div class="sect1" title="IP Routes and Routing Tables"><div class="titlepage"><div><div><h1 class="title"><a id="ip_routes_and_routing_tables"/>IP Routes and Routing Tables</h1></div></div></div><p>As described in the previous section, routers are responsible for forwarding traffic on an IP internetwork. Each router accepts datagrams from a variety of sources, examines the IP address of the destination, and decides the next hop that the datagram needs to take to get it that much closer to its final destination. But how does a router know where to send different datagrams?</p><p>Each router maintains a set of information that provides a mapping between different network IDs and the other routers to which it is connected. This information is contained in a data structure normally called a <span class="emphasis"><em>routing table</em></span>. Each entry in the table, called a <span class="emphasis"><em>routing entry</em></span>, provides information about one network (or subnetwork or host). It basically says, "If the destination of this datagram is in the following network, the next hop you should take is to the following device." Each time a datagram is received, the router checks its destination IP address against the <a class="indexterm" id="idx-CHP-23-0827"/>routing entries in its table to decide where to send the datagram and then sends it on to its next hop.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-122"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A router make decisions about how to route datagrams using its internal <span class="emphasis"><em>routing table</em></span>. The table contains entries specifying to which router datagrams should be sent in order to reach a particular network.</p></div><p>Obviously, the fewer entries in this table, the faster the router can decide what to do with datagrams. (This was a big part of the motivation for classless addressing, which aggregates <a class="indexterm" id="idx-CHP-23-0828"/>routes into supernetworks to reduce router table size, as described in the next section.) Some routers have connections to only two other devices, so they don't have much of a decision to make. Typically, the router will simply take datagrams coming from one of its interfaces and, if necessary, send them out on the other one. For example, consider a small company's router acting as the interface between a network of three hosts and the Internet. Any datagrams sent to the router from a host on this network will need to go over the router's connection to the router at the Internet service provider (ISP).</p><p>When a router has connections to more than two devices, things become considerably more complex. A certain distant network may be more easily reachable using a particular connection. The routing table not only contains information about the networks directly connected to the router, but also information that the router has learned about more distant networks.</p><p><a class="xref" href="ch23s03.html#ip_routing_and_routing_tables_this_diagr" title="Figure 23-3. IP routing and routing tables This diagram shows a small, simple internetwork consisting of four LANs each served by a router. The routing table for each lists the router to which datagrams for each destination network should be sent. Notice that due to the triangle, R1, R2, and R3 can send to each other. However, R2 and R3 must send through R1 to deliver to R4, and R4 must use R1 to reach either of the others.">Figure 23-3</a> shows an example with four routers. Routers R1, R2, and R3 are connected in a triangle, so that each router can send directly to the others, as well as to its own local network. R1's local network is 11.0.0.0/8, R2's is 12.0.0.0/8, and R3's is 13.0.0.0/8. R1 knows that any datagram it sees with 11 as the first octet is on its local network. It will also have a routing entry that says that any IP address starting with 12 should go to R2, and any IP address starting with 13 should go to R3. R1 also connects to router R4, which has 14.0.0.0/8 as its local network. R1 will have an entry for this local network, but R2 and R3 also need to know how to reach 14.0.0.0/8, even though they don't connect to its router directly. Most likely, they will have an entry that says that any datagrams intended for 14.0.0.0/8 should be sent to R1. R1 will then forward them to R4. Similarly, R4 will send any traffic intended for 12.0.0.0/8 or 13.0.0.0/8 through R1.</p><div class="figure"><a id="ip_routing_and_routing_tables_this_diagr"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject9_d1e24307"/><img alt="IP routing and routing tables This diagram shows a small, simple internetwork consisting of four LANs each served by a router. The routing table for each lists the router to which datagrams for each destination network should be sent. Notice that due to the triangle, R1, R2, and R3 can send to each other. However, R2 and R3 must send through R1 to deliver to R4, and R4 must use R1 to reach either of the others." src="httpatomoreillycomsourcenostarchimages287867.png.jpg"/></div></div><p class="title">Figure 23-3. IP routing and routing tables This diagram shows a small, simple internetwork consisting of four LANs each served by a router. The routing table for each lists the router to which datagrams for each destination network should be sent. Notice that due to the triangle, R1, R2, and R3 can send to each other. However, R2 and R3 must send through R1 to deliver to R4, and R4 must use R1 to reach either of the others.</p></div><p>Now, imagine that this process is expanded to handle thousands of networks and routers. Not only do routers need to know which of their local connections to use for each network, but they want to know, if possible, what is the <span class="emphasis"><em>best</em></span> connection to use for each network. Since routers are interconnected in a mesh, there are usually multiple routes between any two devices, but we want to take the best route whenever we can. This may be the shortest route, the least congested route, or the route considered optimal based on other criteria.</p><p>Determining which routes we should use for different networks is an important but very complex job. Routers plan <a class="indexterm" id="idx-CHP-23-0829"/>routes and exchange information about routes and networks using IP <span class="emphasis"><em>routing protocols</em></span>. R2 and R3 use these protocols to find out that 14.0.0.0/8 exists and that it is connected to them via R1. (I discuss these support protocols in Chapters <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a> through <a class="xref" href="ch41.html" title="Chapter 41. OTHER ROUTING PROTOCOLS">Chapter 41</a>.)</p><div class="note" title="Note"><h3 class="title"><a id="note-85"/>Note</h3><p><span class="emphasis"><em>There is a difference between a routable protocol and a routing protocol. IP is a routable protocol, which means its messages (datagrams) can be routed. Examples of routing protocols are the Routing Information Protocol (RIP) and Border Gateway Protocol (BGP), which are used to exchange routing information between routers (see <a class="xref" href="ch38.html" title="Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)">Chapter 38</a> and <a class="xref" href="ch40.html" title="Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)">Chapter 40</a>)</em></span>.<a class="indexterm" id="idx-CHP-23-0830"/></p></div></div>
<div class="sect1" title="IP Routing in a Subnet or Classless Addressing (CIDR) Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ip_routing_in_a_subnet_or_classless_addr"/>IP Routing in a Subnet or Classless Addressing (CIDR) Environment</h1></div></div></div><p>As discussed in the previous chapters, there are three main categories of <a class="indexterm" id="idx-CHP-23-0831"/>IP addressing: classful, subnetted classful, and classless. The method used for determining whether direct or indirect delivery of a datagram is required is different for each type of addressing. The type of addressing used in the network also impacts how routers decide to forward traffic <a class="indexterm" id="idx-CHP-23-0832"/>in an internetwork.</p><p>One of the main reasons why the traditional class-based addressing scheme was created was that it made both addressing and routing relatively simple. Remember that IPv4 was developed in the late 1970s, when the cheap and powerful computer hardware we take for granted today was still science fiction. For the internetwork to function properly, routers needed to be able to look at an IP address and quickly decide what to do with it.</p><p>Classful addressing was intended to make this possible. There was only a two-level hierarchy for the entire internetwork: network ID and host ID. Routers could tell by looking at the first four bits which of the bits in any IP address were the network ID and which were the host ID. Then they needed only consult their routing tables to find the network ID and see which router offered the best route to that network.</p><p>The addition of subnetting to conventional addressing didn't really change this for the main routers on the Internet, because subnetting is internal to the organization. The main routers handling large volumes of traffic on the Internet didn't look at subnets at all. The additional level of hierarchy that subnets represent existed only for the routers within each organization that chose to use subnetting. These routers, when deciding what to do with datagrams within the organization's network, needed to extract not only the network ID of IP addresses, but also the subnet ID. This told them which internal physical network should get the datagram.</p><p>Classless addressing is formally called <span class="emphasis"><em>Classless Inter-Domain Routing (CIDR)</em></span>. The fact that the name includes <span class="emphasis"><em>routing</em></span> but not <span class="emphasis"><em>addressing</em></span> is evidence that CIDR was introduced in large part to improve the efficiency of routing. This improvement occurs because classless networks use a multiple-level hierarchy. Each network can be broken down into subnetworks, sub-subnetworks, and so on. This means that when we are deciding how to route <a class="indexterm" id="idx-CHP-23-0833"/>in a CIDR environment, we can also describe routes in a hierarchical manner. Many smaller networks can be described using a single, higher-level network description that represents them all to routers in the rest of the internetwork. This technique, sometimes called <span class="emphasis"><em>route aggregation</em></span>, reduces routing table size.<a class="indexterm" id="idx-CHP-23-0834"/></p><p>Let's refer back to the detailed example I presented in <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>. An ISP started with the block 71.94.0.0/15 and subdivided it multiple times to create smaller blocks for itself and its customers. To the customers and users of this block, these smaller blocks must be differentiated; the ISP obviously needs to know how to route traffic to the correct customer. To everyone else on the Internet, however, these details are unimportant in deciding how to route datagrams to anyone in that ISP's block.</p><p>For example, suppose I am using a host with IP address 211.42.113.5 and I need to send a message to 71.94.1.43. My local router and the main routers on the Internet don't know where in the 71.94.0.0/15 block that address is, and they don't need to know. They just know that anything with the first 15 bits containing the binary equivalent of 71.94 goes to the router that handles 71.94.0.0/15, which is the aggregated address of the entire block. They let the ISP's routers figure out which of its constituent subnetworks contains 71.94.1.43.</p><p>Contrast this with a classful environment. Here, each of the customers of this ISP would probably have one or more Class C address blocks, each of which would require a separate routing entry, and these blocks would need to be known by <span class="emphasis"><em>all</em></span> routers on the Internet. Thus, instead of just one 71.94.0.0/15 entry, there would be dozens or even hundreds of entries for each customer network. In the classless scheme, only one entry exists, for the parent ISP.</p><p>CIDR provides benefits to routing but also increases its complexity. Under CIDR, we cannot determine which bits are the network ID and which are the host ID just from the IP address. To make matters worse, we can have networks, subnetworks, sub-subnetworks, and so on that all have the same base address!</p><p>In our example, 71.94.0.0/15 is the complete network, and subnetwork 0 is 71.94.0.0/16. They have a different prefix length (the number of network ID bits) but the same base address. If a router has more than one match for a network ID in this manner, it must use the match with the longest network identifier first, since it represents a more specific network description.</p></div>
<div class="sect1" title="IP Multicasting"><div class="titlepage"><div><div><h1 class="title"><a id="ip_multicasting"/>IP Multicasting</h1></div></div></div><p>The great bulk of TCP/IP communications uses IP to send messages from one source device to one recipient device, in a process called <span class="emphasis"><em>unicast</em></span> communication. This is the type of messaging we normally use TCP/IP for, so when you use the Internet, you are using unicast for pretty much everything.<a class="indexterm" id="idx-CHP-23-0835"/></p><p>IP does, however, also support the ability to have one device send a message to a set of recipients. This is called <span class="emphasis"><em>multicasting</em></span>. IP multicasting has been officially supported since IPv4 was first defined, but has not seen widespread use over the years, due largely to lack of support for multicasting in many hardware devices. Interest in multicasting has increased in recent years, and support for multicasting was made a standard part of the next-generation IP version 6 (IPv6) protocol. Here, we will take a brief look at multicasting, which is a large and complex subject.</p><p>The idea behind IP multicasting is to allow a device on an IP internetwork to send datagrams not to just one recipient, but to an arbitrary collection of other devices. IP multicasting is modeled after the similar function used in the data link layer to allow a single hardware device to send to various members of a group. Multicasting is relatively easy at the data link layer, however, because all the devices can communicate directly. In contrast, at the network layer, we are connecting together devices that may be quite far away from each other and must route datagrams between these different networks. This necessarily complicates multicasting when done using IP (except in the special case where we use IP multicasting only between devices on the same data link layer network).</p><p>There are three primary functions that must be performed to implement IP multicasting: addressing, group management, and datagram processing/routing.</p><div class="sect2" title="Multicast Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="multicast_addressing"/>Multicast Addressing</h2></div></div></div><p>Special addressing must be used for multicasting. A <span class="emphasis"><em>multicast address</em></span> identifies not a single device, but a <span class="emphasis"><em>multicast group</em></span> of devices that listen for certain datagrams sent to them. In IPv4, one-sixteenth of the entire address space was set aside for multicast addresses: the Class D block of the original classful addressing scheme. Various techniques are used to define the meaning of addresses within this block and to define a mapping between <a class="indexterm" id="idx-CHP-23-0836"/>IP multicast and data link layer multicast addresses. (See the discussion of IP multicast addressing in <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a>; mapping of IP multicast addresses to hardware layer multicast addresses is discussed in <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>.)</p></div><div class="sect2" title="Multicast Group Management"><div class="titlepage"><div><div><h2 class="title"><a id="multicast_group_management"/>Multicast Group Management</h2></div></div></div><p>Group management encompasses all of the activities required to set up groups of devices. Devices must be able to dynamically join groups and leave groups, and information about groups must be propagated around the IP internetwork. To support these activities, additional techniques are required. The <span class="emphasis"><em>Internet Group Management Protocol (IGMP)</em></span> is the chief tool used for this purpose. It defines a message format to allow information about groups and group membership to be sent between devices and routers on the Internet.<a class="indexterm" id="idx-CHP-23-0837"/></p></div><div class="sect2" title="Multicast Datagram Processing and Routing"><div class="titlepage"><div><div><h2 class="title"><a id="multicast_datagram_processing_and_routin"/>Multicast Datagram Processing and Routing</h2></div></div></div><p>Handling and routing datagrams in a multicast environment is probably the most complicated function. There are several issues here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Since we are sending from one device to many, we need to actually create multiple copies of the datagram for delivery, in contrast to the single datagram used in the unicast case. Routers must be able to tell when they need to create these copies.</p></li><li class="listitem"><p>Routers must use special algorithms to determine how to forward multicast datagrams. Since each one can lead to many copies being sent to various places, efficiency is important to avoid creating unnecessary volumes of traffic.</p></li><li class="listitem"><p>Routers must be able to handle datagrams sent to a multicast group, even if the source is not a group member.</p></li></ul></div><p>Routing in a multicast environment requires significantly more intelligence on the part of router hardware. Several special protocols, such as the <a class="indexterm" id="idx-CHP-23-0838"/>Distance Vector Multicast Routing Protocol (DVMRP) and the <a class="indexterm" id="idx-CHP-23-0839"/>multicast version of Open Shortest Past First (OSPF), are used to enable routers to forward multicast traffic effectively. These algorithms must balance the need to ensure that every device in a group receives a copy of all datagrams intended for that group with the need to prevent unnecessary traffic from moving across the internetwork.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-123"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IP multicasting allows special applications to be developed where one device sends information to multiple devices, across a private internetwork or the global Internet. It is more complex than conventional unicast IP and requires special attention, particularly in the areas of addressing and routing.</p></div><p>This overview has only scratched the surface of IP multicasting. The complexity involved in handling groups and forwarding messages to multicast groups is one reason why support for the feature has been quite uneven and, as a consequence, it is not used widely. Another issue is the demanding nature of multicasting: It uses a great deal of network bandwidth for copies of messages, and it also requires more work of already-busy routers.</p></div></div></body></html>