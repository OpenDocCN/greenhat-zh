<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Strings and Ranges"><div class="titlepage"><div><div><h1 class="title"><a id="strings_and_ranges"/>Chapter 3. Strings and Ranges</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id5"/><div class="mediaobject"><a id="I_mediaobject3_d1e2676"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>I’ve made use of strings in many of my programs so far. In fact, a string was featured in the very first program in the book. Here it is again:<a id="IDX-CHP-3-0001" class="indexterm"/></p><a id="I_programlisting3_d1e2688"/><pre class="programlisting">puts 'hello world'</pre><p>Although that first program used a string enclosed within single quotes, my second program used a string in double quotes:</p><a id="I_programlisting3_d1e2692"/><pre class="programlisting">print('Enter your name: ' )
name = gets()
puts( "Hello #{name}" )</pre><p>Double-quoted strings do more work than single-quoted strings. In particular, they have the ability to evaluate bits of themselves as though they were programming code. To have something evaluated, you need to place it between a pair of curly brackets preceded by a hash mark (<code class="literal">#</code>).<a id="IDX-CHP-3-0002" class="indexterm"/></p><p>In the previous example, <code class="literal">#{name}</code> in a double-quoted string tells Ruby to get the value of the <code class="literal">name</code> variable and insert that value into the string itself. The second line of code calls the <code class="literal">gets()</code> method to get some user input, which is then assigned to the variable <code class="literal">name</code>. If the user entered <strong class="userinput"><code>Fred</code></strong>, the final line of code would evaluate the embedded variable, <code class="literal">#{name}</code>, and the string “Hello Fred” would be displayed. The <span class="emphasis"><em>1strings.rb</em></span> sample program provides a few more examples of embedded evaluation in double-quoted strings. For example, here I have created an object, ob, from a custom class, MyClass, and used embedded evaluation to display the values of its <code class="literal">name</code> and <code class="literal">number</code> attributes:</p><p><span class="emphasis"><em>1strings.rb</em></span></p><a id="I_programlisting3_d1e2737"/><pre class="programlisting">class MyClass
    attr_accessor :name
    attr_accessor :number

    def initialize( aName, aNumber )
        @name    = aName
        @number = aNumber
    end

    def ten
        return 10
    end

end

ob = MyClass.new( "James Bond", "007" )
puts( "My name is #{ob.name} and my number is #{ob.number}" )</pre><p>When the final line of code executes, this is displayed:</p><a id="I_programlisting3_d1e2742"/><pre class="programlisting">My name is James Bond and my number is 007</pre><p>A double-quoted string can also evaluate expressions such as <code class="literal">2*3</code>, bits of code such as the method-call <code class="literal">ob.ten</code> (where <code class="literal">ten</code> is a method name), and escape characters such as <code class="literal">\n</code> and <code class="literal">\t</code> (representing a newline and a tab). A single-quoted string does no such evaluation. A single-quoted string can, however, use a backslash to indicate that the next character should be used literally. This is useful when a single-quoted string contains a single-quote character, like this:<a id="IDX-CHP-3-0003" class="indexterm"/></p><a id="I_programlisting3_d1e2767"/><pre class="programlisting">'It\'s my party'</pre><p>Assuming that the method named <code class="literal">ten</code> returns the value 10, you might write the following code:</p><a id="I_programlisting3_d1e2774"/><pre class="programlisting">puts( "A tab\ta new line\na calculation #{2*3} and method-call #{ob.ten}" )</pre><p>Because this is a double-quoted string, the embedded elements are evaluated, and the following is displayed:<a id="IDX-CHP-3-0004" class="indexterm"/></p><a id="I_programlisting3_d1e2783"/><pre class="programlisting">A tab        new line
calculation 6 and method-call 10</pre><p>Now let’s see what happens when a single-quoted string is used:</p><a id="I_programlisting3_d1e2787"/><pre class="programlisting">puts( 'A tab\tnew line\na calculation #{2*3} and method-call #{ob.ten}' )</pre><p>This time, no embedded evaluation is done, so this is what is displayed:</p><a id="I_programlisting3_d1e2791"/><pre class="programlisting">A tab\tnew line\ncalculation #{2*3} and method-call #{ob.ten}</pre><div class="sect1" title="User-Defined String Delimiters"><div class="titlepage"><div><div><h1 class="title"><a id="user-defined_string_delimiters"/>User-Defined String Delimiters</h1></div></div></div><p>If, for some reason, single and double quotes aren’t convenient—for example, if your strings contain lots of quote characters and you don’t want to have to keep putting backslashes in front of them—you can also delimit strings in many other ways.</p><p>The standard alternative delimiters for double-quoted strings are <code class="literal">%Q</code> and <code class="literal">/</code> or <code class="literal">%/</code> and <code class="literal">/</code>, while for single-quoted strings they are <code class="literal">%q</code> and <code class="literal">/</code>. Thus . . .<a id="IDX-CHP-3-0005" class="indexterm"/><a id="IDX-CHP-3-0006" class="indexterm"/><a id="IDX-CHP-3-0007" class="indexterm"/><a id="IDX-CHP-3-0008" class="indexterm"/><a id="IDX-CHP-3-0009" class="indexterm"/></p><p><span class="emphasis"><em>2strings.rb</em></span></p><a id="I_programlisting3_d1e2838"/><pre class="programlisting">%Q/This is the same as a double-quoted string./
%/This is also the same as a double-quoted string./
%q/And this is the same as a single-quoted string/</pre><p>You can even define your own string delimiters. They must be nonalphanumeric characters, and they may include nonprinting characters such as newlines or tabs as well as various characters that normally have a special meaning in Ruby such as the hash mark (<code class="literal">#</code>). Your chosen character should be placed after <code class="literal">%q</code> or <code class="literal">%Q</code>, and you should be sure to terminate the string with the same character. If your delimiter is an opening square bracket, the corresponding closing bracket should be used at the end of the string, like this:</p><p><span class="emphasis"><em>3strings.rb</em></span></p><a id="I_programlisting3_d1e2854"/><pre class="programlisting">%Q[This is a string]</pre><p>You will find examples of a broad range of user-selected string delimiters in the sample program <span class="emphasis"><em>3strings.rb</em></span>. Here are two examples using an asterisk (<code class="literal">*</code>) after <code class="literal">%Q</code> instead of a double-quoted string and using an exclamation point (<code class="literal">!</code>) after <code class="literal">%q</code> instead of a single-quoted string:</p><a id="I_programlisting3_d1e2873"/><pre class="programlisting">puts( %Q*a)Here's a tab\ta new line\na calculation using \*
 #{2*3} and a method-call #{ob.ten}* )
puts( %q!b)Here's a tab\ta new line\na calculation using \* #{2*3} and a
 method-call #{ob.ten}! )</pre><p>Here, as in the previous program, ob is a user-defined object whose method named <code class="literal">ten</code> returns the integer, 10. The previous code produces the following output:</p><a id="I_programlisting3_d1e2881"/><pre class="programlisting">a)Here's a tab    a new line
a calculation using * 6 and a method-call 10
b)Here's a tab\ta new line\na calculation using \* #{2*3} and a method-call #{ob.ten}</pre><p>Although there may be times when it is useful to delimit a string by some esoteric character such as a newline or an asterisk, in many cases the disadvantages (not least the mental anguish and confusion) resulting from such arcane practices may significantly outweigh the advantages.</p></div></div>
<div class="sect1" title="Backquotes"><div class="titlepage"><div><div><h1 class="title"><a id="backquotes"/>Backquotes</h1></div></div></div><p>One other type of string deserves a special mention: a string enclosed by backquotes—that is, the inward-pointing quote character that is usually tucked away up toward the top-left corner of the keyboard: <code class="literal">`</code>.<a id="IDX-CHP-3-0010" class="indexterm"/></p><p>Ruby considers anything enclosed by back-quotes to be a command that can be passed for execution by the operating system using a method such as <code class="literal">print</code> or <code class="literal">puts</code>. By now, you will probably already have guessed that Ruby provides more than one way of doing this. It turns out <code class="literal">%x/some command/</code> has the same effect as <code class="literal">`somecommand`</code> and so does <code class="literal">%x{some command}</code>. On the Windows operating system, for example, each of the three lines shown next would pass the command <code class="literal">dir</code> to the operating system, causing a directory listing to be displayed:<a id="IDX-CHP-3-0011" class="indexterm"/><a id="IDX-CHP-3-0012" class="indexterm"/></p><p><span class="emphasis"><em>4backquotes.rb</em></span></p><a id="I_programlisting3_d1e2928"/><pre class="programlisting">puts(`dir`)
puts(%x/dir/)
puts(%x{dir})</pre><p>You can also embed commands inside double-quoted strings like this:</p><a id="I_programlisting3_d1e2932"/><pre class="programlisting">print( "Goodbye #{%x{calc}}" )</pre><p>Be careful if you do this. The command itself is evaluated first. Your Ruby program then waits until the process that starts has terminated. In the present case, the calculator will pop up. You are now free to do some calculations, if you want. Only when you close the calculator will the string “Goodbye” be displayed.</p></div>
<div class="sect1" title="String Handling"><div class="titlepage"><div><div><h1 class="title"><a id="string_handling"/>String Handling</h1></div></div></div><p>Before leaving the subject of strings, you’ll take a quick look at a few common string operations.</p><div class="sect2" title="Concatenation"><div class="titlepage"><div><div><h2 class="title"><a id="concatenation"/>Concatenation</h2></div></div></div><p>You can concatenate strings using <code class="literal">&lt;&lt;</code> or <code class="literal">+</code> or just by placing a space between them. Here are three examples of string concatenation; in each case, <code class="literal">s</code> is assigned the string “Hello world”:<a id="IDX-CHP-3-0013" class="indexterm"/><a id="IDX-CHP-3-0014" class="indexterm"/><a id="IDX-CHP-3-0015" class="indexterm"/></p><p><span class="emphasis"><em>hello_world_concat.rb</em></span></p><a id="I_programlisting3_d1e2971"/><pre class="programlisting">s = "Hello " &lt;&lt; "world"
s = "Hello " + "world"
s = "Hello "  "world"</pre><p>Note that when you use the <code class="literal">&lt;&lt;</code> method, you can append Fixnum integers (in the range 0 to 255), in which case those integers are converted to the character with that character code. Character codes 65 to 90 are converted to the uppercase characters <span class="emphasis"><em>A</em></span> to <span class="emphasis"><em>Z</em></span>, 97 to 122 are converted to the lowercase <span class="emphasis"><em>a</em></span> to <span class="emphasis"><em>z</em></span>, and other codes are converted to punctuation, special characters, and nonprinting characters. However, if you want to print the number itself, you must convert it to a string using the <code class="literal">to_s</code> method. The <code class="literal">to_s</code> method is obligatory when concatenating Fixnums using the <code class="literal">+</code> method or a space; attempting to concatenate a number without using <code class="literal">to_s</code> is an error. The following program prints out characters and numeric codes for values between 0 and 126, which include the standard Western alphanumeric and punctuation characters:<a id="IDX-CHP-3-0016" class="indexterm"/></p><p><span class="emphasis"><em>char_codes.rb</em></span></p><a id="I_programlisting3_d1e3011"/><pre class="programlisting">i = 0
begin
    s = "[" &lt;&lt; i &lt;&lt; ":" &lt;&lt; i.to_s &lt;&lt; "]"
    puts(s)
    i += 1
end until i == 126</pre><p>For examples of concatenating using <code class="literal">&lt;&lt;</code>, <code class="literal">+</code>, or a space, see <span class="emphasis"><em>string_contact.rb</em></span>:</p><p><span class="emphasis"><em>string_contact.rb</em></span></p><a id="I_programlisting3_d1e3027"/><pre class="programlisting">s1 = "This " &lt;&lt; "is" &lt;&lt; " a string " &lt;&lt; 36 # char 36 is '$'
s2 = "This "  + "is" + " a string "  + 36.to_s
s3 = "This "  "is"  " a string "  + 36.to_s

puts("(s1):" &lt;&lt; s1)
puts("(s2):" &lt;&lt; s2)
puts("(s3):" &lt;&lt; s3)</pre><p>The previous program produces this output:</p><a id="I_programlisting3_d1e3032"/><pre class="programlisting">(s1):This is a string $
(s2):This is a string 36
(s3):This is a string 36</pre></div><div class="sect2" title="What About Commas?"><div class="titlepage"><div><div><h2 class="title"><a id="what_about_commas_question"/>What About Commas?</h2></div></div></div><p>You may sometimes see Ruby code that uses commas to separate strings and other data types. In some circumstances, these commas appear to have the effect of concatenating strings. For example, the following code might, at first sight, seem to create and display a string from three substrings plus an integer:<a id="IDX-CHP-3-0017" class="indexterm"/></p><a id="I_programlisting3_d1e3044"/><pre class="programlisting">s4 = "This " , "is" , " not a string!", 10
print("print (s4):" , s4, "\n")</pre><p>In fact, a list separated by commas creates an array—an ordered list of the original strings. The <span class="emphasis"><em>string_concat.rb</em></span> program contains examples that prove this to be the case:</p><a id="I_programlisting3_d1e3051"/><pre class="programlisting">x = "This " , "is" , " not a string!", 36
print("print (x):" , x, "\n")
puts("puts(x):", x)
puts("puts x.class is: " &lt;&lt; (x.class).to_s )

print("print(x):" , x, "\n")
puts("puts(x):", x)
puts("puts x.class is: " &lt;&lt; (x.class).to_s )</pre><p>The previous code causes the following to be displayed:</p><a id="I_programlisting3_d1e3055"/><pre class="programlisting">print (x):This is not a string!36
puts(x):
This
is
 not a string!
36
puts x.class is: Array</pre><p>The first <code class="literal">print</code> statement here looks as though it is displaying a single string. This is because each successive item in the array, <code class="literal">x</code>, is printed on the same line as the preceding item. When you use <code class="literal">puts</code> instead of <code class="literal">print</code>, you can see that each item is printed on a separate line. This is because <code class="literal">puts</code> prints each item in turn and appends a carriage return after it. The fact that you are dealing with an array rather than a string is confirmed when you ask Ruby to print the class of the <code class="literal">x</code> object. It displays <code class="literal">Array</code>. You’ll learn about arrays in more depth in the next chapter.</p></div><div class="sect2" title="String Assignment"><div class="titlepage"><div><div><h2 class="title"><a id="string_assignment"/>String Assignment</h2></div></div></div><p>The Ruby String class provides a number of useful string-handling methods. Most of these methods create new string objects. So, for example, in the following code, the <code class="literal">s</code> on the left side of the assignment on the second line is not the same object as the <code class="literal">s</code> on the right side:</p><a id="I_programlisting3_d1e3092"/><pre class="programlisting">s = "hello world"
s = s + "!"</pre><p>A few string methods actually alter the string itself without creating a new object. These methods generally end with an exclamation mark (for example, the <code class="literal">capitalize!</code> method changes the original string, whereas the <code class="literal">capitalize</code> method does not). In addition, the string itself is also modified—and no new string is created—when you assign a character at an index of the string. For example, <code class="literal">s[1] = 'A'</code> would place the character <span class="emphasis"><em>A</em></span> at index 1 (the second character) of the string <code class="literal">s</code>.<a id="IDX-CHP-3-0018" class="indexterm"/><a id="IDX-CHP-3-0019" class="indexterm"/><a id="IDX-CHP-3-0020" class="indexterm"/></p><p>If in doubt, you can check an object’s identity using the <code class="literal">object_id</code> method. I’ve provided a few examples of operations that do and do not create new strings in the <span class="emphasis"><em>string_assign.rb</em></span> program. Run this, and check the <code class="literal">object_id</code> of <code class="literal">s</code> after each string operation is performed.<a id="IDX-CHP-3-0021" class="indexterm"/></p><p><span class="emphasis"><em>string_assign.rb</em></span></p><a id="I_programlisting3_d1e3147"/><pre class="programlisting">s = "hello world"
print( "1) s='#{s}' and s.object_id=#{s.object_id}\n" )
s = s + "!"            # this creates a new string object
print( "2) s='#{s}' and s.object_id=#{s.object_id}\n" )
s = s.capitalize       # this creates a new string object
print( "3) s='#{s}' and s.object_id=#{s.object_id}\n" )
s.capitalize!          # but this modifies the original string object
print( "4) s='#{s}' and s.object_id=#{s.object_id}\n" )
s[1] = 'A'             # this also modifies the original string object
print( "5) s='#{s}' and s.object_id=#{s.object_id}\n" )</pre><p>This produces output similar to that shown next. The actual object ID values may differ, but the important thing to notice is when consecutive values remain the same, showing that the string object, <code class="literal">s</code>, remains the same and, when they change, showing that a new string object, <code class="literal">s</code>, has been created:</p><a id="I_programlisting3_d1e3157"/><pre class="programlisting">1) s='hello world' and s.object_id=29573230
2) s='hello world!' and s.object_id=29573190
3) s='Hello world!' and s.object_id=29573160
4) s='Hello world!' and s.object_id=29573160
5) s='HAllo world!' and s.object_id=29573160</pre></div><div class="sect2" title="Indexing into a String"><div class="titlepage"><div><div><h2 class="title"><a id="indexing_into_a_string"/>Indexing into a String</h2></div></div></div><p>In one of the previous examples, I treated a string as an array of characters and specified a character index with an integer inside square brackets: <code class="literal">s[1]</code>. Strings and arrays in Ruby are indexed from the first character at index 0. So, for instance, to replace the character <span class="emphasis"><em>e</em></span> with <span class="emphasis"><em>u</em></span> in the string <code class="literal">s</code> (which currently contains “Hello world”), you would assign a new character to index 1:</p><a id="I_programlisting3_d1e3176"/><pre class="programlisting">s[1] = 'u'</pre><p>If you index into a string in order to find a character at a specific location, the behavior differs according to which version of Ruby you are using. Ruby 1.8 returns a numeric ASCII code of the character, whereas Ruby 1.9 returns the character itself.</p><a id="I_programlisting3_d1e3180"/><pre class="programlisting">s = "Hello world"
puts( s[1] )    #=&gt; Ruby 1.8 displays 101; Ruby 1.9 displays 'e'</pre><p>To obtain the actual character from the numeric value returned by Ruby 1.8, you can use a double index to print a single character, starting at index 1:</p><a id="I_programlisting3_d1e3184"/><pre class="programlisting">s = "Hello world"
puts( s[1,1] ) # prints out 'e'</pre><p>If, on the other hand, you need the numeric value of the character returned by Ruby 1.9, you can use the <code class="literal">ord</code> method like this:</p><a id="I_programlisting3_d1e3191"/><pre class="programlisting">puts( s[1].ord)</pre><p>The <code class="literal">ord</code> method does not exist in Ruby 1.8, so the previous code causes an “undefined method” error. To ensure compatibility between Ruby 1.8 and 1.9, you should use the double-index technique, with the first index indicating the starting position and the second index indicating the number of characters. For example, this returns one character at position 1: <code class="literal">s[1,1]</code>. You can see some more examples in the <span class="emphasis"><em>char_in_string.rb</em></span> program:</p><p><span class="emphasis"><em>char_in_string.rb</em></span></p><a id="I_programlisting3_d1e3208"/><pre class="programlisting">s = "Hello world"
puts( s[1] )
achar=s[1]
puts( achar )
puts( s[1,1] )
puts( achar.ord )</pre><p>When you run this code, Ruby 1.9 displays this:</p><a id="I_programlisting3_d1e3212"/><pre class="programlisting">e
e
e
101</pre><p>whereas Ruby 1.8 displays this:</p><a id="I_programlisting3_d1e3216"/><pre class="programlisting">101
101
e
undefined method `ord' for 101:Fixnum (NoMethodError)</pre><p>You can also use double-indexes to return more than one character. If you want to return three characters starting at position 1, you would enter this:</p><a id="I_programlisting3_d1e3220"/><pre class="programlisting">puts( s[1,3] )     # prints 'ell'</pre><p>This tells Ruby to start at position 1 and return the next three characters. Alternatively, you could use the two-dot range notation:<a id="IDX-CHP-3-0022" class="indexterm"/><a id="IDX-CHP-3-0023" class="indexterm"/><a id="IDX-CHP-3-0024" class="indexterm"/><a id="IDX-CHP-3-0025" class="indexterm"/><a id="IDX-CHP-3-0026" class="indexterm"/><a id="IDX-CHP-3-0027" class="indexterm"/><a id="IDX-CHP-3-0028" class="indexterm"/></p><a id="I_programlisting3_d1e3259"/><pre class="programlisting">puts( s[1..3] )     # also prints 'ell'</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Ranges are discussed in more detail later in this chapter.</p></div><p>Strings can also be indexed using negative values, in which case −1 is the index of the last character, and, once again, you can specify the number of characters to be returned:</p><p><span class="emphasis"><em>string_index.rb</em></span></p><a id="I_programlisting3_d1e3270"/><pre class="programlisting">puts( s[-1,1] )     # prints 'd'
puts( s[-5,5] )     # prints 'world'</pre><p>When specifying ranges using a negative index, you must use negative values for both the start and end indexes:</p><p><span class="emphasis"><em>string_methods.rb</em></span></p><a id="I_programlisting3_d1e3277"/><pre class="programlisting">puts( s[-5..5] )    # this prints an empty string!
puts( s[-5..-1] )   # prints 'world'</pre><p>Finally, you may want to experiment with a few of the standard methods available for manipulating strings. These include methods to change the case of a string, reverse it, insert substrings, remove repeating characters, and so on. I’ve provided a few examples in <span class="emphasis"><em>string_methods.rb</em></span>. The method names are generally descriptive of their functions. However, bear in mind that methods such as <code class="literal">reverse</code> (with no <code class="literal">!</code> at the end) return a new string but do not modify the original string, whereas <code class="literal">reverse!</code> (with the <code class="literal">!</code>) modifies the original string. You saw similar behavior with the <code class="literal">capitalize</code> end <code class="literal">capitalize!</code> methods used earlier.</p><p>The <code class="literal">insert</code> method takes two arguments, an index and a string, and it inserts the string argument at the given index of the string, <code class="literal">s</code>. The <code class="literal">squeeze</code> method returns a string with any repeating character, such as the second adjacent <span class="emphasis"><em>l</em></span> in “Hello” removed. The <code class="literal">split</code> method splits a string into an array. I’ll have more to say on <code class="literal">split</code> when I discuss regular expressions in <a class="xref" href="ch06.html" title="Chapter 6. Conditional Statements">Chapter 6</a>. The following examples assume that <code class="literal">s</code> is the string “Hello world” and the output is shown in the <code class="literal">#=&gt;</code> comments. In the program supplied in this book’s code archive, you may also experiment using much longer strings:<a id="IDX-CHP-3-0029" class="indexterm"/><a id="IDX-CHP-3-0030" class="indexterm"/></p><a id="I_programlisting3_d1e3342"/><pre class="programlisting">s.length            #=&gt; 11
s.reverse!          #=&gt; Hello world
s.reverse           #=&gt; dlrow olleH
s.upcase            #=&gt; HELLO WORLD
s.capitalize        #=&gt; Hello world
s.swapcase          #=&gt; hELLO WORLD
s.downcase          #=&gt; hello world
s.insert(7,"NOT ")  #=&gt; hello wNOT orld
s.squeeze           #=&gt; helo wNOT orld
s.split             #=&gt; ["helo", "wNOT", "orld"]</pre></div><div class="sect2" title="Removing Newline Characters: chop and chomp"><div class="titlepage"><div><div><h2 class="title"><a id="removing_newline_characters_colon_chop_a"/>Removing Newline Characters: chop and chomp</h2></div></div></div><p>A couple of handy string-processing methods deserve special mention. The <code class="literal">chop</code> and <code class="literal">chomp</code> methods can be used to remove characters from the end of a string. The <code class="literal">chop</code> method returns a string with the last character removed or with the carriage return and newline characters removed (<code class="literal">\r\n</code>) if these are found at the end of the string. The <code class="literal">chomp</code> method returns a string with the terminating carriage return or newline character removed (or both the carriage return <span class="emphasis"><em>and</em></span> the newline character if both are found).<a id="IDX-CHP-3-0031" class="indexterm"/><a id="IDX-CHP-3-0032" class="indexterm"/><a id="IDX-CHP-3-0033" class="indexterm"/><a id="IDX-CHP-3-0034" class="indexterm"/><a id="IDX-CHP-3-0035" class="indexterm"/><a id="IDX-CHP-3-0036" class="indexterm"/><a id="IDX-CHP-3-0037" class="indexterm"/><a id="IDX-CHP-3-0038" class="indexterm"/></p><p>These methods are useful when you need to remove line feeds entered by the user or read from a file. For instance, when you use <code class="literal">gets</code> to read in a line of text, this returns the line including the terminating <span class="emphasis"><em>record separator</em></span>, which, by default, is the newline character.</p><div class="sidebar"><a id="the_record_separator_colon_dollar_solid"/><p class="title">The Record Separator: $/</p><p>Ruby predefines a variable, <code class="literal">$/</code>, as a record separator. This variable is used by methods such as <code class="literal">gets</code> and <code class="literal">chomp</code>. The <code class="literal">gets</code> method reads in a string up to and including the record separator. The <code class="literal">chomp</code> method returns a string with the record separator removed from the end (if present); otherwise, it returns the original string unmodified. You can redefine the record separator if you want, like this:</p><a id="I_programlisting3_d1e3426"/><pre class="programlisting">$/= "*"        # the "*" character is now the record separator</pre><p>When you redefine the record separator, this new character (or string) will now be used by methods such as <code class="literal">gets</code> and <code class="literal">chomp</code>. Here’s an example:</p><a id="I_programlisting3_d1e3436"/><pre class="programlisting">$/= "world"
s = gets()     # user enters "Had we but world enough and time..."
puts( s )      # displays "Had we but world"</pre></div><p><span class="emphasis"><em>record_separator.rb</em></span></p><p>You can remove the newline character using either <code class="literal">chop</code> or <code class="literal">chomp</code>. In most cases, <code class="literal">chomp</code> is preferable because it won’t remove the final character unless it is the record separator (usually a newline), whereas <code class="literal">chop</code> will remove the last character no matter what it is. Here are some examples:</p><p><span class="emphasis"><em>chop_chomp.rb</em></span></p><a id="I_programlisting3_d1e3458"/><pre class="programlisting"># NOTE: s1 includes a carriage return and linefeed
s1 = "Hello world
"
s2 = "Hello world"
s1.chop           # returns "Hello world"
s1.chomp          # returns "Hello world"
s2.chop           # returns "Hello worl" - note the missing 'd'!
s2.chomp          # returns "Hello world"</pre><p>The <code class="literal">chomp</code> method also lets you specify a character or string to use as the separator:</p><a id="I_programlisting3_d1e3465"/><pre class="programlisting">s2.chomp('rld')   # returns "Hello wo"</pre></div><div class="sect2" title="Format Strings"><div class="titlepage"><div><div><h2 class="title"><a id="format_strings"/>Format Strings</h2></div></div></div><p>Ruby provides the <code class="literal">printf</code> method to print “format strings” containing specifiers starting with a percent sign (<code class="literal">%</code>). The format string may be followed by one or more data items separated by commas; the list of data items should match the number and type of the format specifiers. The actual data items replace the matching specifiers in the string, and they are formatted accordingly. These are some common formatting specifiers:<a id="IDX-CHP-3-0039" class="indexterm"/><a id="IDX-CHP-3-0040" class="indexterm"/><a id="IDX-CHP-3-0041" class="indexterm"/><a id="IDX-CHP-3-0042" class="indexterm"/><a id="IDX-CHP-3-0043" class="indexterm"/><a id="IDX-CHP-3-0044" class="indexterm"/><a id="IDX-CHP-3-0045" class="indexterm"/><a id="IDX-CHP-3-0046" class="indexterm"/><a id="IDX-CHP-3-0047" class="indexterm"/><a id="IDX-CHP-3-0048" class="indexterm"/><a id="IDX-CHP-3-0049" class="indexterm"/><a id="IDX-CHP-3-0050" class="indexterm"/><a id="IDX-CHP-3-0051" class="indexterm"/><a id="IDX-CHP-3-0052" class="indexterm"/></p><a id="I_programlisting3_d1e3525"/><pre class="programlisting">%d - decimal number
%f - floating-point number
%o - octal number
%p - inspect object
%s - string
%x - hexadecimal number</pre><p>You can control floating-point precision by putting a point-number before the floating-point formatting specifier, <code class="literal">%f</code>. For example, this would display the floating-point value to six digits (the default) followed by a carriage return (<code class="literal">"\n"</code>):<a id="IDX-CHP-3-0053" class="indexterm"/><a id="IDX-CHP-3-0054" class="indexterm"/></p><p><span class="emphasis"><em>string_printf.rb</em></span></p><a id="I_programlisting3_d1e3544"/><pre class="programlisting">printf( "%f\n", 10.12945 )        #=&gt; 10.129450</pre><p>And the following would display the floating-point value to two digits (<code class="literal">"%0.02f"</code>). It is purely a matter of stylistic preference whether the floating-point specifier includes a preceding 0 or not and <code class="literal">"%0.2f"</code> is equivalent.</p><a id="I_programlisting3_d1e3554"/><pre class="programlisting">printf( "%0.02f\n", 10.12945 )     #=&gt; 10.13</pre><p>Here are a couple more examples:</p><a id="I_programlisting3_d1e3558"/><pre class="programlisting">printf("d=%d f=%f o=%o x=%x s=%s\n", 10, 10, 10, 10, 10)</pre><p>That would output <code class="literal">d=10 f=10.000000 o=12 x=a s=10</code>.</p><a id="I_programlisting3_d1e3566"/><pre class="programlisting">printf("0.04f=%0.04f : 0.02f=%0.02f\n", 10.12945, 10.12945)</pre><p>That would output <code class="literal">0.04f=10.1295 : 0.02f=10.13</code>.</p></div></div>
<div class="sect1" title="Ranges"><div class="titlepage"><div><div><h1 class="title"><a id="ranges"/>Ranges</h1></div></div></div><p>In Ruby, a Range is a class that represents a set of values defined by a starting value and an ending value. Typically a range is defined using integers, but it may also be defined using other ordered values such as floating-point numbers or characters. Values can be negative, though you should be careful that your starting value is lower than your ending value!</p><p>Here are a few examples:</p><p><span class="emphasis"><em>ranges.rb</em></span></p><a id="I_programlisting3_d1e3583"/><pre class="programlisting">a = (1..10)
b = (-10..-1)
c = (-10..10)
d = ('a'..'z')</pre><p>You can also specify ranges using three dots instead of two; this creates a range that omits the final value:</p><a id="I_programlisting3_d1e3587"/><pre class="programlisting">d = ('a'..'z')         # this two-dot range = 'a'..'z'
e = ('a'...'z')        # this three-dot range = 'a'..'y'</pre><p>You can create an array of the values defined by a range using the <code class="literal">to_a</code> method, like this:<a id="IDX-CHP-3-0055" class="indexterm"/></p><a id="I_programlisting3_d1e3597"/><pre class="programlisting">(1..10).to_a</pre><p>Note that <code class="literal">to_a</code> is not defined for floating-point numbers for the simple reason that the number of possible values between two floating-point numbers is not finite.</p><div class="sect2" title="Ranges of Strings"><div class="titlepage"><div><div><h2 class="title"><a id="ranges_of_strings"/>Ranges of Strings</h2></div></div></div><p>You can even create ranges of strings—though you would need to take great care in so doing because you might end up with more than you bargain for. For example, see whether you can figure out which values are specified by this range:</p><p><span class="emphasis"><em>str_range.rb</em></span></p><a id="I_programlisting3_d1e3612"/><pre class="programlisting">str_range = ('abc'..'def')</pre><p>At first sight, the range from <code class="literal">'abc'</code> to <code class="literal">'def'</code> might not look like much. In fact, this defines a range of no less than 2,110 values! They are ordered like this: <code class="literal">abc</code>, <code class="literal">abd</code>, <code class="literal">abe</code>, and so on, until the end of the <span class="emphasis"><em>a</em></span>s; then you start on the <span class="emphasis"><em>b</em></span>s: <code class="literal">baa</code>, <code class="literal">bab</code>, <code class="literal">bac</code>, and so on. Suffice to say that ranges of this sort are probably rather a rare requirement and are best used with extreme caution or not at all.</p></div><div class="sect2" title="Iterating with a Range"><div class="titlepage"><div><div><h2 class="title"><a id="iterating_with_a_range"/>Iterating with a Range</h2></div></div></div><p>You may use a range to iterate from a start value to an end value. For example, here is one way of printing all the numbers from 1 to 10:</p><p><span class="emphasis"><em>for_to.rb</em></span></p><a id="I_programlisting3_d1e3656"/><pre class="programlisting">for i in (1..10) do
    puts( i )
end</pre><div class="sidebar"><a id="digging_deeper-id2"/><p class="title">Digging Deeper</p><p>Here you will learn how to create and iterate over ranges, write multiline strings with heredocs, and define your own string delimiters.<a id="IDX-CHP-3-0056" class="indexterm"/><a id="IDX-CHP-3-0057" class="indexterm"/><a id="IDX-CHP-3-0058" class="indexterm"/><a id="IDX-CHP-3-0059" class="indexterm"/></p><p><span class="bolditalic">Heredocs</span></p><p>Although you can write long strings spanning multiple lines between single or double quotes, many Ruby programmers prefer to use an alternative type of string called a <span class="emphasis"><em>heredoc</em></span>. A heredoc is a block of text that starts by specifying an end marker, which is simply an identifier of your choice. Here, I specify <code class="literal">EODOC</code> as the end marker:</p><p><span class="emphasis"><em>heredoc.rb</em></span></p><a id="I_programlisting3_d1e3693"/><pre class="programlisting">hdoc1 = &lt;&lt;EODOC</pre><p>This tells Ruby that everything following the previous line is a single string that terminates when the end marker is located. The string is assigned to the variable, <code class="literal">hdoc1</code>. Here is an example of a complete heredoc assignment:</p><a id="I_programlisting3_d1e3700"/><pre class="programlisting">hdoc1 = &lt;&lt;EODOC
I wandered lonely as a #{"cloud".upcase},
That floats on high o'er vale and hill...
EODOC</pre><p>By default, heredocs are treated as double-quoted strings, so expressions such as <code class="literal">#{"cloud".upcase}</code> will be evaluated. If you want a heredoc to be treated as single-quoted string, specify its end marker between single quotes:</p><a id="I_programlisting3_d1e3707"/><pre class="programlisting">hdoc2 = &lt;&lt;'EODOC'
I wandered lonely as a #{"cloud".upcase},
That floats on high o'er vale and hill...
EODOC</pre><p>The end marker of a heredoc must, by default, be placed flush with the left margin. If you want to indent it, you should use <code class="literal">&lt;&lt;-</code> rather than <code class="literal">&lt;&lt;</code> when assigning the end marker:</p><a id="I_programlisting3_d1e3718"/><pre class="programlisting">hdoc3 = &lt;&lt;-EODOC
I wandered lonely as a #{"cloud".upcase},
That floats on high o'er vale and hill...
    EODOC</pre><p>It is up to you to pick an appropriate end marker. It is even legitimate (though, perhaps, not particularly sensible!) to use a reserved word:</p><a id="I_programlisting3_d1e3722"/><pre class="programlisting">hdoc4 = &lt;&lt;def
I wandered lonely as a #{"cloud".upcase},
That floats on high o'er vale and hill...
def</pre><p>A variable to which a heredoc is assigned can be used just like any other string variable:<a id="IDX-CHP-3-0060" class="indexterm"/><a id="IDX-CHP-3-0061" class="indexterm"/><a id="IDX-CHP-3-0062" class="indexterm"/><a id="IDX-CHP-3-0063" class="indexterm"/></p><a id="I_programlisting3_d1e3740"/><pre class="programlisting">puts( hdoc1 )</pre><p><span class="bolditalic">String Literals</span></p><p>As explained earlier in this chapter, you can optionally delimit strings by <code class="literal">%q/</code> and <code class="literal">/</code> for single-quoted strings and either <code class="literal">%Q/</code> and <code class="literal">/</code> or <code class="literal">%/</code> and <code class="literal">/</code> for double-quoted strings.</p><p>Ruby provides similar means of delimiting back-quoted strings, regular expressions, symbols, and arrays of either single-quoted or double-quoted strings. The ability to define arrays of strings in this way is particularly useful since it avoids the necessity of entering string delimiters for each item. Here is a reference to these string literal delimiters:</p><a id="I_programlisting3_d1e3768"/><pre class="programlisting">%q/    /    # single-quoted
%Q/    /    # double-quoted
%/     /    # double-quoted
%w/    /    # array
%W/    /    # array double-quoted
%r|    |    # regular expression
%s/    /    # symbol
%x/    /    # operating system command</pre><p>Note that you may choose which delimiters to use. I have used <code class="literal">/</code> except with the regular expression where I have used <code class="literal">|</code> (since <code class="literal">/</code> is the “normal” regular expression delimiter), but I could equally have used square brackets, asterisks, ampersands, or other symbols (for example, <code class="literal">%W*dog cat #{1+2}*</code> or <code class="literal">%s&amp;dog&amp;</code>). Here is an example of these literals in use:<a id="IDX-CHP-3-0064" class="indexterm"/><a id="IDX-CHP-3-0065" class="indexterm"/></p><p><span class="emphasis"><em>literals.rb</em></span></p><a id="I_programlisting3_d1e3798"/><pre class="programlisting">p %q/dog cat #{1+2}/        #=&gt; "dog cat \#{1+2}"
p %Q/dog cat #{1+2}/        #=&gt; "dog cat 3"
p %/dog cat #{1+2}/         #=&gt; "dog cat 3"
p %w/dog cat #{1+2}/        #=&gt; ["dog", "cat", "\#{1+2}"]
p %W/dog cat #{1+2}/        #=&gt; ["dog", "cat", "3"]
p %r|^[a-z]*$|              #=&gt; /^[a-z]*$/
p %s/dog/                   #=&gt; :dog
p %x/vol/                   #=&gt; " Volume in drive C is OS [etc...]"</pre></div></div></div></body></html>