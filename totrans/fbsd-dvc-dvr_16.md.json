["```\nstruct ifnet {\n        void    *if_softc;              /* Driver private data.         */\n        void    *if_l2com;              /* Protocol bits.               */\n        struct  vnet *if_vnet;          /* Network stack instance.      */\n        TAILQ_ENTRY(ifnet) if_link;     /* ifnet linkage.               */\n        char    if_xname[IFNAMSIZ];     /* External name.               */\n        const char *if_dname;           /* Driver name.                 */\n        int     if_dunit;       /* Unit number or IF_DUNIT_NONE.        */\n        u_int   if_refcount;            /* Reference count.             */\n\n        /*\n         * Linked list containing every address associated with\n         * this interface.\n         */\n        struct  ifaddrhead if_addrhead;\n\n        int     if_pcount;      /* Number of promiscuous listeners.     */\n        struct  carp_if *if_carp;       /* CARP interface.              */\n        struct  bpf_if *if_bpf;         /* Packet filter.               */\n        u_short if_index;       /* Numeric abbreviation for interface.  */\n        short   if_timer;       /* Time until if_watchdog is called.    */\n        struct  ifvlantrunk *if_vlantrunk; /* 802.1Q data.              */\n        int     if_flags;       /* Flags (e.g., up, down, broadcast).   */\n        int     if_capabilities;/* Interface features and capabilities. */\n        int     if_capenable;   /* Enabled features and capabilities.   */\n        void    *if_linkmib;            /* Link specific MIB data.      */\n        size_t  if_linkmiblen;          /* Length of above.             */\n        struct  if_data if_data;        /* Interface information.       */\n        struct  ifmultihead if_multiaddrs; /* Multicast addresses.      */\n        int     if_amcount;     /* Number of multicast requests.        */\n\n        /* Interface methods.                                           */\n        int     (*if_output)\n                (struct ifnet *, struct mbuf *, struct sockaddr *,\n                    struct route *);\n        void    (*if_input)\n                (struct ifnet *, struct mbuf *);\n        void    (*if_start)\n                (struct ifnet *);\n        int     (*if_ioctl)\n                (struct ifnet *, u_long, caddr_t);\n        void    (*if_watchdog)\n                (struct ifnet *);\n        void    (*if_init)\n                (void *);\n        int     (*if_resolvemulti)\n                (struct ifnet *, struct sockaddr **, struct sockaddr *);\n        void    (*if_qflush)\n                (struct ifnet *);\n        int     (*if_transmit)\n                (struct ifnet *, struct mbuf *);\n        void    (*if_reassign)\n                (struct ifnet *, struct vnet *, char *);\n\n        struct  vnet *if_home_vnet;     /* Where we originate from.     */\n        struct  ifaddr *if_addr;        /* Link level address.          */\n        void    *if_llsoftc;            /* Link level softc.            */\n        int     if_drv_flags;           /* Driver managed status flags. */\n        struct  ifaltq if_snd;        /* Output queue, includes altq. */\n        const u_int8_t *if_broadcastaddr; /* Link level broadcast addr. */\n        void    *if_bridge;             /* Bridge glue.                 */\n        struct  label *if_label;        /* Interface MAC label.         */\n\n        /* Only used by IPv6\\.                                           */\n        struct  ifprefixhead if_prefixhead;\n        void    *if_afdata[AF_MAX];\n        int     if_afdata_initialized;\n        struct  rwlock if_afdata_lock;\n        struct  task if_linktask;\n        struct  mtx if_addr_mtx;\n\n        LIST_ENTRY(ifnet) if_clones;    /* Clone interfaces.            */\n        TAILQ_HEAD(, ifg_list) if_groups; /* Linked list of groups.     */\n        void    *if_pf_kif;             /* pf(4) glue.                  */\n        void    *if_lagg;               /* lagg(4) glue.                */\n        u_char  if_alloctype;           /* Type (e.g., Ethernet).       */\n\n        /* Spare fields.                                                */\n        char    if_cspare[3];           /* Spare characters.            */\n        char    *if_description;        /* Interface description.       */\n        void    *if_pspare[7];          /* Spare pointers.              */\n        int     if_ispare[4];           /* Spare integers.              */\n};\n```", "```\n#include <net/if.h>\n#include <net/if_types.h>\n#include <net/if_var.h>\n\nstruct ifnet *\nif_alloc(u_char type);\n\nvoid\nif_initname(struct ifnet *ifp, const char *name, int unit);\n\nvoid\nif_attach(struct ifnet *ifp);\n\nvoid\nif_detach(struct ifnet *ifp);\n\nvoid\nif_free(struct ifnet *ifp);\n```", "```\n#include <net/if.h>\n#include <net/if_types.h>\n#include <net/if_var.h>\n#include <net/ethernet.h>\n\nvoid\nether_ifattach(struct ifnet *ifp, const u_int8_t *lla);\n```", "```\nvoid\nether_ifattach(struct ifnet *ifp, const u_int8_t *lla)\n{\n        struct ifaddr *ifa;\n        struct sockaddr_dl *sdl;\n        int i;\n\n        ifp->if_addrlen = ETHER_ADDR_LEN;\n        ifp->if_hdrlen = ETHER_HDR_LEN;\n        if_attach(ifp);\n        ifp->if_mtu = ETHERMTU;\n      ifp->if_output = ether_output;\n      ifp->if_input = ether_input;\n      ifp->if_resolvemulti = ether_resolvemulti;\n#ifdef VIMAGE\n      ifp->if_reassign = ether_reassign;\n#endif\n        if (ifp->if_baudrate == 0)\n                ifp->if_baudrate = IF_Mbps(10);\n        ifp->if_broadcastaddr = etherbroadcastaddr;\n\n        ifa = ifp->if_addr;\n        KASSERT(ifa != NULL, (\"%s: no lladdr!\\n\", __func__));\n        sdl = (struct sockaddr_dl *)ifa->ifa_addr;\n        sdl->sdl_type = IFT_ETHER;\n        sdl->sdl_alen = ifp->if_addrlen;\n        bcopy(lla, LLADDR(sdl), ifp->if_addrlen);\n\n        bpfattach(ifp, DLT_EN10MB, ETHER_HDR_LEN);\n        if (ng_ether_attach_p != NULL)\n                (*ng_ether_attach_p)(ifp);\n\n        /* Print Ethernet MAC address (if lla is nonzero). */\n        for (i = 0; i < ifp->if_addrlen; i++)\n                if (lla[i] != 0)\n                        break;\n        if (i != ifp->if_addrlen)\n                if_printf(ifp, \"Ethernet address: %6D\\n\", lla, \":\");\n}\n```", "```\n#include <net/if.h>\n#include <net/if_types.h>\n#include <net/if_var.h>\n#include <net/ethernet.h>\n\nvoid\nether_ifdetach(struct ifnet *ifp);\n```", "```\nstruct ifmedia {\n        int     ifm_mask;               /* Mask of bits to ignore.      */\n        int     ifm_media;              /* User-set media word.         */\n        struct ifmedia_entry *ifm_cur;  /* Currently selected media.    */\n\n        /*\n         * Linked list containing every media type supported by\n         * an interface.\n         */\n        LIST_HEAD(, ifmedia_entry) ifm_list;\n\n        ifm_change_cb_t ifm_change;     /* Media change callback.       */\n        ifm_stat_cb_t   ifm_status;     /* Media status callback.       */\n};\n```", "```\n#include <net/if.h>\n#include <net/if_media.h>\n\nvoid\nifmedia_init(struct ifmedia *ifm, int dontcare_mask,\n    ifm_change_cb_t change_callback, ifm_stat_cb_t status_callback);\n\nvoid\nifmedia_add(struct ifmedia *ifm, int mword, int data, void\n *aux);\n\nvoid\nifmedia_set(struct ifmedia *ifm, int mword);\n\nvoid\nifmedia_removeall(struct ifmedia *ifm);\n```", "```\ntypedef int (*ifm_change_cb_t)(struct ifnet *ifp);\n```", "```\ntypedef void (*ifm_stat_cb_t)(struct ifnet *ifp, struct ifmediareq *req);\n```", "```\n#define IFM_ETHER       0x00000020\n#define IFM_10_T        3               /* 10BASE-T, RJ45\\.              */\n#define IFM_10_2        4               /* 10BASE2, thin Ethernet.      */\n#define IFM_10_5        5               /* 10BASE5, thick Ethernet.     */\n#define IFM_100_TX      6               /* 100BASE-TX, RJ45\\.            */\n#define IFM_100_FX      7               /* 100BASE-FX, fiber.           */\n#define IFM_100_T4      8               /* 100BASE-T4\\.                  */\n#define IFM_100_VG      9               /* 100VG-AnyLAN.                */\n#define IFM_100_T2      10              /* 100BASE-T2\\.                  */\n#define IFM_1000_SX     11      /* 1000BASE-SX, multimode fiber.        */\n#define IFM_10_STP      12      /* 10BASE-T, shielded twisted-pair.     */\n#define IFM_10_FL       13              /* 10BASE-FL, fiber.            */\n#define IFM_1000_LX     14      /* 1000BASE-LX, single-mode fiber.      */\n#define IFM_1000_CX     15      /* 1000BASE-CX, shielded twisted-pair.  */\n#define IFM_1000_T      16              /* 1000BASE-T.                  */\n#define IFM_HPNA_1      17              /* HomePNA 1.0 (1Mb/s).         */\n#define IFM_10G_LR      18      /* 10GBASE-LR, single-mode fiber.       */\n#define IFM_10G_SR      19      /* 10GBASE-SR, multimode fiber.         */\n#define IFM_10G_CX4     20              /* 10GBASE-CX4\\.                 */\n#define IFM_2500_SX     21      /* 2500BASE-SX, multimode fiber.        */\n#define IFM_10G_TWINAX  22              /* 10GBASE, Twinax.             */\n#define IFM_10G_TWINAX_LONG     23      /* 10GBASE, Twinax long.        */\n#define IFM_10G_LRM     24      /* 10GBASE-LRM, multimode fiber.        */\n#define IFM_UNKNOWN     25              /* Undefined.                   */\n#define IFM_10G_T       26              /* 10GBASE-T, RJ45\\.             */\n\n#define IFM_AUTO        0               /* Automatically select media.  */\n#define IFM_MANUAL      1               /* Manually select media.       */\n#define IFM_NONE        2               /* Unselect all media.          */\n\n/* Shared options.                                                      */\n#define IFM_FDX         0x00100000      /* Force full-duplex.           */\n#define IFM_HDX         0x00200000      /* Force half-duplex.           */\n#define IFM_FLOW        0x00400000      /* Enable hardware flow control.*/\n#define IFM_FLAG0       0x01000000      /* Driver-defined flag.         */\n#define IFM_FLAG1       0x02000000      /* Driver-defined flag.         */\n#define IFM_FLAG2       0x04000000      /* Driver-defined flag.         */\n#define IFM_LOOP        0x08000000      /* Put hardware in loopback.    */\n```", "```\nIFM_ETHER | IFM_100_TX\n```", "```\nstatic int\nem_setup_interface(device_t dev, struct adapter *adapter)\n{\n        struct ifnet *ifp;\n\n        ifp = adapter->ifp = if_alloc(IFT_ETHER);\n        if (ifp == NULL) {\n                device_printf(dev, \"cannot allocate ifnet structure\\n\");\n                return (-1);\n        }\n\n        if_initname(ifp, device_get_name(dev), device_get_unit(dev));\n        ifp->if_mtu = ETHERMTU;\n        ifp->if_init = em_init;\n        ifp->if_softc = adapter;\n        ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n        ifp->if_ioctl = em_ioctl;\n        ifp->if_start = em_start;\n        IFQ_SET_MAXLEN(&ifp->if_snd, adapter->num_tx_desc - 1);\n        ifp->if_snd.ifq_drv_maxlen = adapter->num_tx_desc - 1;\n        IFQ_SET_READY(&ifp->if_snd);\n\n      ether_ifattach(ifp, adapter->hw.mac.addr);\n\n        ifp->if_capabilities = ifp->if_capenable = 0;\n\n        /* Enable checksum offload. */\n      ifp->if_capabilities |= IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM;\n      ifp->if_capenable |= IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM;\n\n        /* Enable TCP segmentation offload. */\n        ifp->if_capabilities |= IFCAP_TSO4;\n        ifp->if_capenable |= IFCAP_TSO4;\n\n        /* Enable VLAN support. */\n        ifp->if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);\n        ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU;\n        ifp->if_capenable |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU;\n\n        /* Interface can filter VLAN tags. */\n        ifp->if_capabilities |= IFCAP_VLAN_HWFILTER;\n\n#ifdef DEVICE_POLLING\n        ifp->if_capabilities |= IFCAP_POLLING;\n#endif\n\n        /* Enable Wake-on-LAN (WOL) via magic packet? */\n      if (adapter->wol) {\n                ifp->if_capabilities |= IFCAP_WOL;\n                ifp->if_capenable |= IFCAP_WOL_MAGIC;\n        }\n\n      ifmedia_init(&adapter->media, IFM_IMASK, em_media_change,\n            em_media_status);\n\n      if ((adapter->hw.phy.media_type == e1000_media_type_fiber) ||\n            (adapter->hw.phy.media_type == e1000_media_type_internal_serdes))\n        {\n                u_char fiber_type = IFM_1000_SX;\n\n                ifmedia_add(&adapter->media,\n                    IFM_ETHER | fiber_type, 0, NULL);\n                ifmedia_add(&adapter->media,\n                    IFM_ETHER | fiber_type | IFM_FDX, 0, NULL);\n        } else {\n                ifmedia_add(&adapter->media,\n                    IFM_ETHER | IFM_10_T, 0, NULL);\n                ifmedia_add(&adapter->media,\n                    IFM_ETHER | IFM_10_T | IFM_FDX, 0, NULL);\n                ifmedia_add(&adapter->media,\n                    IFM_ETHER | IFM_100_TX, 0, NULL);\n                ifmedia_add(&adapter->media,\n                    IFM_ETHER | IFM_100_TX | IFM_FDX, 0, NULL);\n\n                if (adapter->hw.phy.type != e1000_phy_ife) {\n                        ifmedia_add(&adapter->media,\n                            IFM_ETHER | IFM_1000_T, 0, NULL);\n                        ifmedia_add(&adapter->media,\n                            IFM_ETHER | IFM_1000_T | IFM_FDX, 0, NULL);\n                }\n        }\n\n        ifmedia_add(&adapter->media, IFM_ETHER | IFM_AUTO, 0, NULL);\n      ifmedia_set(&adapter->media, IFM_ETHER | IFM_AUTO);\n\n        return (0);\n}\n```", "```\nstruct mbuf {\n      struct m_hdr m_hdr;\n      union {\n                struct {\n                        struct pkthdr MH_pkthdr;\n                        union {\n                                struct m_ext MH_ext;\n                                char MH_databuf[MHLEN];\n                        } MH_dat;\n                } MH;\n                char M_databuf[MLEN];\n        } M_dat;\n};\n```", "```\nstruct m_hdr {\n        struct mbuf     *mh_next;         /* Next mbuf in chain.          */\n        struct mbuf     *mh_nextpkt;      /* Next chain in queue/record.  */\n        caddr_t          mh_data;         /* Location of data.            */\n        int              mh_len;          /* Data length.                 */\n        int              mh_flags;        /* Flags.                       */\n        short            mh_type;         /* Data type.                   */\n        uint8_t          pad[M_HDR_PAD];  /* Padding for word alignment.  */\n};\n```", "```\nstatic int\nciss_setup_msix(struct ciss_softc *sc)\n{\n        int i, count, error;\n\n        i = ciss_lookup(sc->ciss_dev);\n      if (ciss_vendor_data[i].flags & CISS_BOARD_NOMSI)\n                return (EINVAL);\n\n        count = pci_msix_count(sc->ciss_dev);\n        if (count < CISS_MSI_COUNT) {\n                count = pci_msi_count(sc->ciss_dev);\n                if (count < CISS_MSI_COUNT)\n                        return (EINVAL);\n        }\n\n        count = MIN(count, CISS_MSI_COUNT);\n        error = pci_alloc_msix(sc->ciss_dev, &count);\n        if (error) {\n                error = pci_alloc_msi(sc->ciss_dev, &count);\n                if (error)\n                        return (EINVAL);\n        }\n\n        sc->ciss_msi = count;\n        for (i = 0; i < count; i++)\n              sc->ciss_irq_rid[i] = i + 1;\n\n        return (0);\n}\n```", "```\n...\n        /*\n         * Use MSI/MSI-X?\n         */\n        sc->ciss_irq_rid[0] = 0;\n        if (method == CISS_TRANSPORT_METHOD_PERF) {\n                ciss_printf(sc, \"Performant Transport\\n\");\n\n                if (ciss_force_interrupt != 1 && ciss_setup_msix(sc) == 0)\n                        intr = ciss_perf_msi_intr;\n                else\n                        intr = ciss_perf_intr;\n\n                sc->ciss_interrupt_mask =\n                    CISS_TL_PERF_INTR_OPQ | CISS_TL_PERF_INTR_MSI;\n        } else {\n                ciss_printf(sc, \"Simple Transport\\n\");\n\n                if (ciss_force_interrupt == 2)\n                      ciss_setup_msix(sc);\n\n                sc->ciss_perf = NULL;\n                intr = ciss_intr;\n                sc->ciss_interrupt_mask = sqmask;\n        }\n\n        /*\n         * Disable interrupts.\n         */\n        CISS_TL_SIMPLE_DISABLE_INTERRUPTS(sc);\n\n        /*\n         * Set up the interrupt handler.\n         */\n        sc->ciss_irq_resource = bus_alloc_resource_any(sc->ciss_dev,\n            SYS_RES_IRQ, &sc->ciss_irq_rid[0], RF_ACTIVE | RF_SHAREABLE);\n        if (sc->ciss_irq_resource == NULL) {\n                ciss_printf(sc, \"cannot allocate interrupt resource\\n\");\n                return (ENXIO);\n        }\n\n        error = bus_setup_intr(sc->ciss_dev, sc->ciss_irq_resource,\n            INTR_TYPE_CAM | INTR_MPSAFE, NULL, intr, sc, &sc->ciss_intr);\n        if (error) {\n                ciss_printf(sc, \"cannot set up interrupt\\n\");\n                return (ENXIO);\n        }\n...\n```", "```\n#include <dev/pci/pcivar.h>\n\nint\npci_msix_count(device_t dev);\n\nint\npci_msi_count(device_t dev);\n\nint\npci_alloc_msix(device_t dev, int *count);\n\nint\npci_alloc_msi(device_t dev, int *count);\n\nint\npci_release_msi(device_t dev);\n```"]