["```\nint factorial(int n) {\n  if (n == 1) return 1;\n   else return n * factorial(n - 1);\n}\n```", "```\nint iterativeArraySum(int integers[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += integers[i];\n    }\n    return sum;\n}\n```", "```\nint arraySumDelegate(int integers[], int size) {\n  if (size == 0) return 0;\n  int lastNumber = integers[size - 1];\n    int allButLastSum = iterativeArraySum(integers, size - 1);\n  return lastNumber + allButLastSum;\n}\n```", "```\nint arraySumRecursive(int integers[], int size) {\n    if (size == 0) return 0;\n    int lastNumber = integers[size - 1];\n    int allButLastSum = arraySumRecursive(integers, size - 1);\n    return lastNumber + allButLastSum;\n}\n```", "```\nint arraySumRecursiveExtraParams(int integers[], int size, int sum,\n int currentIndex) {\n    if (currentIndex == size) return sum;\n    sum += integers[currentIndex];\n    return arraySumRecursiveExtraParameters(integers, size, sum, currentIndex + 1);\n}\n```", "```\nint a[10] = {20, 3, 5, 22, 7, 9, 14, 17, 4, 9};\nint total = arraySumRecursiveExtraParameters(a, 10, 0, 0);\n```", "```\nint zeroCountIterative(int numbers[], int size) {\n   int sum = 0;\n int count = 0;\n   for (int i = 0; i < size; i++) {\n      if (numbers[i] == 0) count ++;\n   }\n   return count;\n}\n```", "```\nint count;\nint zeroCountRecursive(int numbers[], int size) {\n   if (size == 0) return count;\n   if (numbers[size - 1] == 0) count++;\n   zeroCountRecursive(numbers, size - 1);\n}\n```", "```\nint zeroCountStatic(int numbers[], int size) {\n static int count = 0;\n   if (size == 0) return count;\n   if (numbers[size - 1] == 0) count++;\n   zeroCountStatic(numbers, size - 1);\n}\n```", "```\nint zeroCountRecursive(int numbers[], int size) {\n   if (size == 0) return 0;\n int count = zeroCountRecursive(numbers, size - 1);\n if (numbers[size - 1] == 0) count++;\n return count;\n}\n```", "```\nstruct listNnode {\n    int data;\n    listNode * next;\n};\ntypedef listNode * listPtr;\n```", "```\nint countNegative(listPtr head) {\n    if (head == NULL) return 0;\n    int listCount = countNegative(head->next);\n    if (head->data < 0) listCount++;\n    return listCount;\n}\n```", "```\nstruct treeNode {\n    int data;\n    treeNode * left;\n    treeNode * right;\n};\ntypedef treeNode * treePtr;\n```", "```\nint maxValue(treePtr root) {\n  if (root == NULL) return 0;\n  if (root->right == NULL && root->left == NULL)\n        return root->data;\n  int leftMax = maxValue(root->left);\n  int rightMax = maxValue(root->right);\n  int maxNum = root->data;\n    if (leftMax > maxNum) maxNum = leftMax;\n    if (rightMax > maxNum) maxNum = rightMax;\n    return maxNum;\n}\n```", "```\nclass binaryTree {\n    public:\n      int countLeaves();\n    private:\n        struct binaryTreeNode {\n            int data;\n            binaryTreeNode * left;\n            binaryTreeNode * right;\n        };\n        typedef treeNode * treePtr;\n        treePtr _root;\n};\n```", "```\nint numLeaves = bt.countLeaves();\n```", "```\nstruct binaryTreeNode {\n    int data;\n    treeNode * left;\n    treeNode * right;\n};\ntypedef binaryTreeNode * treePtr;\nint countLeaves(treePtr rootPtr) {\n    if (rootPtr == NULL) return 0;\n    if (rootPtr->right == NULL && rootPtr->left == NULL)\n        return 1;\n    int leftCount = countLeaves(rootPtr->left);\n    int rightCount = countLeaves(rootPtr->right);\n    return leftCount + rightCount;\n}\n```", "```\nclass binaryTree {\n      public:\n          int publicCountLeaves();\n      private:\n          struct binaryTreeNode {\n              int data;\n              binaryTreeNode * left;\n              binaryTreeNode * right;\n          };\n          typedef binaryTreeNode * treePtr;\n          treePtr _root;\n          int privateCountLeaves(treePtr rootPtr);\n  };\n int binaryTree::privateCountLeaves(treePtr rootPtr) {\n      if (rootPtr == NULL) return 0;\n      if (rootPtr->right == NULL && rootPtr->left == NULL)\n          return 1;\n      int leftCount = privateCountLeaves(rootPtr->left);\n      int rightCount = privateCountLeaves(rootPtr->right);\n      return leftCount + rightCount;\n  }\n int binaryTree::publicCountLeaves() {\n     return privateCountLeaves(_root);\n  }\n```", "```\nint binaryTree::stackBasedCountLeaves() {\n    if (_root == NULL) return 0;\n    int leafCount = 0;\n  stack<binaryTreeNode *> nodes;\n  nodes.push(_root);\n    while (!nodes.empty()) {\n        treePtr currentNode = nodes.top();\n      nodes.pop();\n        if (currentNode->left == NULL && currentNode->right == NULL)\n            leafCount++;\n        else {\n            if (currentNode->right != NULL) nodes.push(currentNode->right);\n            if (currentNode->left != NULL) nodes.push(currentNode->left);\n        }\n    }\n    return leafCount;\n}\n```", "```\nvoid displayListForwardsRecursion(listPtr head) {\n    if (head != NULL) {\n        cout << head->data << \"\\n\";\n        displayListForwardsRecursion(head->next);\n    }\n}\nvoid displayListBackwardsRecursion(listPtr head) {\n    if (head != NULL) {\n        displayListBackwardsRecursion(head->next);\n        cout << head->data << \"\\n\";\n    }\n}\n```", "```\nvoid displayListForwardsIterative(listPtr head) {\n   for (listPtr current = head; current != NULL; current = current->next)\n        cout << current->data << \"\\n\";\n}\nvoid displayListBackwardsIterative(listPtr head) {\n   stack<listPtr> nodes;\n   for (listPtr current = head; current != NULL; current = current->next)\n        nodes.push(current);\n   while (!nodes.empty()) {\n      nodePtr current = nodes.top();\n      nodes.pop();\n      cout << current->data << \"\\n\";\n    }\n}\n```"]