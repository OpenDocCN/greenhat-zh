<html><head></head><body>
<p class="calibre1">isolation.tools.setVersion.disable = "TRUE" </p>
<p class="calibre1">isolation.tools.getVersion.disable = "TRUE" </p>
<p class="calibre1">monitor_control.disable_directexec = "TRUE" </p>
<p class="calibre1">monitor_control.disable_chksimd = "TRUE" </p>
<p class="calibre1">monitor_control.disable_ntreloc = "TRUE" </p>
<p class="calibre1">monitor_control.disable_selfmod = "TRUE" </p>
<p class="calibre1">monitor_control.disable_reloc = "TRUE" </p>
<p class="calibre1">monitor_control.disable_btinout = "TRUE" </p>
<p class="calibre1">monitor_control.disable_btmemspace = "TRUE" </p>
<p class="calibre1">monitor_control.disable_btpriv = "TRUE" </p>
<p class="calibre1">monitor_control.disable_btseg = "TRUE" </p>
<p class="calibre1"> <i class="calibre4">Listing 17-5: VMware’s </i>.vmx <i class="calibre4"> file undocumented options used to thwart anti-VM techniques</i> The directexec parameter causes user-mode code to be emulated, instead of being run directly on the CPU, thus thwarting certain anti-VM techniques. </p>
<p class="calibre1">The first four settings are used by VMware backdoor commands so that VMware Tools running in the guest cannot get information about the host. </p>
<p class="calibre1">These changes will protect against all of ScoopyNG’s checks, other than the sixth, when running on a multiprocessor machine. However, we do not recommend using these settings in VMware, because they disable the usefulness of VMware Tools and they may have serious negative effects on the performance of your virtual machines. Add these options only after you’ve Anti-Virtual Machine Techniques</p>
<p class="calibre1"><b class="calibre3">379</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p413"/>exhausted all other techniques. These techniques have been mentioned for completeness, but modifying a  <i class="calibre4">.vmx</i> file to try to catch ten of the potentially hundreds of ways that VMware might be detected can be a bit of a wild-goose chase. </p>
<p class="calibre1"><b class="calibre3">Escaping the Virtual Machine</b></p>
<p class="calibre1">VMware has its vulnerabilities, which can be exploited to crash the host operating system or even run code in it. </p>
<p class="calibre1">Many publicized vulnerabilities are found in VMware’s shared folders feature or in tools that exploit the drag-and-drop functionality of VMware Tools. </p>
<p class="calibre1">One well-publicized vulnerability uses shared folders to allow a guest to write to any file on the host operating system in order to modify or compromise the host operating system. Although this particular technique doesn’t work with the current version of VMware, several different flaws have been discovered in the shared folders feature. Disable shared folders in the virtual machine settings to prevent this type of attack. </p>
<p class="calibre1">Another well-publicized vulnerability was found in the virtual machine display function in VMware. An exploit for this vulnerability is known as Cloudburst, and it is publicly available as part of the Canvas penetration-testing tool (this vulnerability has also been patched by VMware). </p>
<p class="calibre1">Certain publicly available tools assist in exploiting VMware once the host has been infected, including VMchat, VMcat, VMftp, VMdrag-n-hack, and VMdrag-n-sploit. These tools are of little use until you have escaped the virtual machine, and you shouldn’t need to worry about them if malware is being run in the virtual machine. </p>
<p class="calibre1"><b class="calibre3">Conclusion</b></p>
<p class="calibre1">This chapter introduced the most popular anti-VMware techniques. Because malware authors use these techniques to slow down analysis, it’s important to be able to recognize them. We have explained these techniques in detail so that you can find them in disassembly or debugging, and we’ve explored ways to overcome them without needing to modify malware at the disassembly level. </p>
<p class="calibre1">When performing basic dynamic analysis, you should always use a virtual machine. However, if your subject malware doesn’t seem to run, consider trying another virtual machine with VMware Tools uninstalled before debugging or disassembling the malware in search of virtual machine detection. </p>
<p class="calibre1">You might also run your subject malware in a different virtual environment (like VirtualBox or Parallels) or even on a physical machine. </p>
<p class="calibre1">As with anti-debugging techniques, anti-VM techniques can be spotted using common sense while slowly debugging a process. For example, if you see code terminating prematurely at a conditional jump, it may be doing so as a result of an anti-VM technique. As always, be aware of these types of issues and look ahead in the code to determine what action to take. </p>
<p class="calibre1"><b class="calibre3">380</b></p>
<p class="calibre1">Chapter 17</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p414"/><b class="calibre3">L A B S</b></p>
<p class="calibre1"><b class="calibre3">Lab 17-1</b></p>
<p class="calibre1">Analyze the malware found in  <i class="calibre4">Lab17-01.exe</i> inside VMware. This is the same malware as  <i class="calibre4">Lab07-01.exe</i>, with added anti-VMware techniques. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">The anti-VM techniques found in this lab may not work in your environment. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What anti-VM techniques does this malware use? </p>
<p class="calibre1">2. </p>
<p class="calibre1">If you have the commercial version of IDA Pro, run the IDA Python script from Listing 17-4 in Chapter 17 (provided here as  <i class="calibre4">findAntiVM.py</i>). </p>
<p class="calibre1">What does it find? </p>
<p class="calibre1">3. </p>
<p class="calibre1">What happens when each anti-VM technique succeeds? </p>
<p class="calibre1">4. </p>
<p class="calibre1">Which of these anti-VM techniques work against your virtual machine? </p>
<p class="calibre1">5. </p>
<p class="calibre1">Why does each anti-VM technique work or fail? </p>
<p class="calibre1">6. </p>
<p class="calibre1">How could you disable these anti-VM techniques and get the malware to run? </p>
<p class="calibre1"><b class="calibre3">Lab 17-2</b></p>
<p class="calibre1">Analyze the malware found in the file  <i class="calibre4">Lab17-02.dll</i> inside VMware. After answering the first question in this lab, try to run the installation exports using  <i class="calibre4">rundll32.exe</i> and monitor them with a tool like procmon. The following is an example command line for executing the DLL: </p>
<p class="calibre1">rundll32.exe Lab17-02.dll,InstallRT (or InstallSA/InstallSB)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What are the exports for this DLL? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What happens after the attempted installation using  <i class="calibre4">rundll32.exe</i>? </p>
<p class="calibre1">3. </p>
<p class="calibre1">Which files are created and what do they contain? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What method of anti-VM is in use? </p>
<p class="calibre1">5. </p>
<p class="calibre1">How could you force the malware to install during runtime? </p>
<p class="calibre1">6. </p>
<p class="calibre1">How could you permanently disable the anti-VM technique? </p>
<p class="calibre1">7. </p>
<p class="calibre1">How does each installation export function work? </p>
<p class="calibre1">Anti-Virtual Machine Techniques</p>
<p class="calibre1"><b class="calibre3">381</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p415"/><b class="calibre3">Lab 17-3</b></p>
<p class="calibre1">Analyze the malware  <i class="calibre4">Lab17-03.exe</i> inside VMware. This lab is similar to <i class="calibre4">Lab12-02.exe</i>, with added anti-VMware techniques. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What happens when you run this malware in a virtual machine? </p>
<p class="calibre1">2. </p>
<p class="calibre1">How could you get this malware to run and drop its keylogger? </p>
<p class="calibre1">3. </p>
<p class="calibre1">Which anti-VM techniques does this malware use? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What system changes could you make to permanently avoid the anti-VM </p>
<p class="calibre1">techniques used by this malware? </p>
<p class="calibre1">5. </p>
<p class="calibre1">How could you patch the binary in OllyDbg to force the anti-VM techniques to permanently fail? </p>
<p class="calibre1"><b class="calibre3">382</b></p>
<p class="calibre1">Chapter 17</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p416"/><b class="calibre3">P A C K E R S   A N D   U N P A C K I N G</b></p>
<p class="calibre1">Packing programs, known as  <i class="calibre4">packers</i>, have become </p>
<p class="calibre1">extremely popular with malware writers because they </p>
<p class="calibre1">help malware hide from antivirus software, complicate </p>
<p class="calibre1">malware analysis, and shrink the size of a malicious </p>
<p class="calibre1">executable. Most packers are easy to use and are freely available. Basic static analysis isn’t useful on a packed program; packed malware must be unpacked before it can be analyzed statically, which makes analysis more complicated and challenging. </p>
<p class="calibre1">Packers are used on executables for two main reasons: to shrink programs or to thwart detection or analysis. Even though there are a wide variety of packers, they all follow a similar pattern: They transform an executable to create a new executable that stores the transformed executable as data and contains an unpacking stub that is called by the OS. </p>
<p class="calibre1">We begin this chapter with some background information about how packers work and how to recognize them. Then we will discuss unpacking strategies, starting with simple ones and then moving on to strategies that are progressively more complicated. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p417"/><b class="calibre3">Packer Anatomy</b></p>
<p class="calibre1">When malware has been packed, an analyst typically has access to only the packed file, and cannot examine the original unpacked program or the program that packed the malware. In order to unpack an executable, we must undo the work performed by the packer, which requires that we understand how a packer operates. </p>
<p class="calibre1">All packers take an executable file as input and produce an executable file as output. The packed executable is compressed, encrypted, or otherwise transformed, making it harder to recognize and reverse-engineer. </p>
<p class="calibre1">Most packers use a compression algorithm to compress the original executable. A packer designed to make the file difficult to analyze may encrypt the original executable and employ anti-reverse-engineering techniques, such as anti-disassembly, anti-debugging, or anti-VM. Packers can pack the entire executable, including all data and the resource section, or pack only the code and data sections. </p>
<p class="calibre1">To maintain the functionality of the original program, a packing program needs to store the program’s import information. The information can be stored in any format, and there are several common strategies, which are covered in depth later in this chapter. When unpacking a program, reconstructing the import section can sometimes be challenging and time-consuming, but it’s necessary for analyzing the program’s functionality. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The Unpacking Stub</b></i></p>
<p class="calibre1">Nonpacked executables are loaded by the OS. With packed programs, the unpacking stub is loaded by the OS, and then the unpacking stub loads the original program. The code entry point for the executable points to the unpacking stub rather than the original code. The original program is generally stored in one or more extra sections of the file. </p>
<p class="calibre1">The unpacking stub can be viewed by a malware analyst, and understanding the different parts of the stub is fundamental to unpacking the executable. The unpacking stub is often small, since it does not contribute to the main functionality of the program, and its function is typically simple: unpack the original executable. If you attempt to perform static analysis on the packed program, you will be analyzing the stub, not the original program. </p>
<p class="calibre1">The unpacking stub performs three steps:</p>
<p class="calibre1"></p>
<p class="calibre1">Unpacks the original executable into memory</p>
<p class="calibre1"></p>
<p class="calibre1">Resolves all of the imports of the original executable</p>
<p class="calibre1"></p>
<p class="calibre1">Transfers execution to the original entry point (OEP)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Loading the Executable</b></i></p>
<p class="calibre1">When regular executables load, a loader reads the PE header on the disk, and allocates memory for each of the executable’s sections based on that header. The loader then copies the sections into the allocated spaces in memory. </p>
<p class="calibre1"><b class="calibre3">384</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p418"/>Packed executables also format the PE header so that the loader will allocate space for the sections, which can come from the original program, or the unpacking stub can create the sections. The unpacking stub unpacks the code for each section and copies it into the space that was allocated. The exact unpacking method used depends on the goals of the packer, and it is generally contained within the stub. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Resolving Imports</b></i></p>
<p class="calibre1">As discussed in Chapter 1, nonpacked PE files include a section that tells the loader which functions to import, and another section that stores the addresses of the names of all the imported functions. The Windows loader reads the import information, determines which functions are needed, and then fills in the addresses. </p>
<p class="calibre1">The Windows loader cannot read import information that is packed. For a packed executable, the unpacking stub will resolve the imports. The specific approach depends on the packer. </p>
<p class="calibre1">The most common approach is to have the unpacking stub import only the LoadLibrary and GetProcAddress functions. After the unpacking stub unpacks the original executable, it reads the original import information. It will call LoadLibrary for each library, in order to load the DLL into memory, and will then use GetProcAddress to get the address for each function. </p>
<p class="calibre1">Another approach is to keep the original import table intact, so that the Windows loader can load the DLLs and the imported functions. This is the simplest approach, since the unpacking stub does not need to resolve the imports. However, static analysis of the packed program will reveal all the original imports, so this approach lacks stealth. Additionally, since the imported functions are stored in plaintext in the executable, the compression possible with this approach is not optimal. </p>
<p class="calibre1">A third approach is to keep one import function from each DLL contained in the original import table. This approach will reveal only one function per imported library during analysis, so it’s stealthier than the previous approach, but analysis will still reveal all the libraries that are imported. This approach is simpler for the packer to implement than the first approach, since the libraries do not need to be loaded by the unpacking stub, but the unpacking stub must still resolve the majority of the functions. </p>
<p class="calibre1">The final approach is the removal of all imports (including LoadLibrary and GetProcAddress). The packer must find all the functions needed from other libraries without using functions, or it must find LoadLibrary and GetProcAddress, and use them to locate all the other libraries. This process is discussed in Chapter 19, because it is similar to what shellcode must do. </p>
<p class="calibre1">The benefit of this approach is that the packed program includes no imports at all, which makes it stealthy. However, in order to use this approach, the unpacking stub must be complex. </p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">385</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p419"/> <i class="calibre4"><b class="calibre3">The Tail Jump</b></i></p>
<p class="calibre1">Once the unpacking stub is complete, it must transfer execution to the OEP. </p>
<p class="calibre1">The instruction that transfers execution to the OEP is commonly referred to as the  <i class="calibre4">tail jump</i>. </p>
<p class="calibre1">A jump instruction is the simplest and most popular way to transfer execution. Since it’s so common, many malicious packers will attempt to obscure this function by using a ret or call instruction. Sometimes the tail jump is obscured with OS functions that transfer control, such as NtContinue or ZwContinue. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Unpacking Illustrated</b></i></p>
<p class="calibre1">Figures 18-1 through 18-4 illustrate the packing and unpacking process, as follows:</p>
<p class="calibre1"></p>
<p class="calibre1">Figure 18-1 shows the original executable. The header and sections are visible, and the starting point is set to the OEP. </p>
<p class="calibre1"></p>
<p class="calibre1">Figure 18-2 shows the packed executable as it exists on disk. All that is visible is the new header, the unpacking stub, and packed original code. </p>
<p class="calibre1">Header</p>
<p class="calibre1">Imports</p>
<p class="calibre1">Exports</p>
<p class="calibre1">Entry Point</p>
<p class="calibre1">.text Section</p>
<p class="calibre1">Entry Point</p>
<p class="calibre1">Header</p>
<p class="calibre1">.data Section</p>
<p class="calibre1">Unpacking Stub</p>
<p class="calibre1">Packed</p>
<p class="calibre1">.rsrc Section</p>
<p class="calibre1">Original Code</p>
<p class="calibre1"> <i class="calibre4">Figure 18-1: The original executable, </i></p>
<p class="calibre1"> <i class="calibre4">Figure 18-2: The packed executable, </i></p>
<p class="calibre1"> <i class="calibre4">prior to packing</i></p>
<p class="calibre1"> <i class="calibre4">after the original code is packed and </i></p>
<p class="calibre1"> <i class="calibre4">the unpacking stub is added</i></p>
<p class="calibre1"></p>
<p class="calibre1">Figure 18-3 shows the packed executable as it exists when it’s loaded into memory. The unpacking stub has unpacked the original code, and valid </p>
<p class="calibre1">.text and .data sections are visible. The starting point for the executable still points to the unpacking stub, and the import table is usually not valid at this stage. </p>
<p class="calibre1"></p>
<p class="calibre1">Figure 18-4 shows the fully unpacked executable. The import table has been reconstructed, and the starting point has been edited to point to the OEP. </p>
<p class="calibre1">Note that the final unpacked program is different than the original program. The unpacked program still has the unpacking stub and any other code that the packing program added. The unpacking program has a PE </p>
<p class="calibre1">header that has been reconstructed by the unpacker and will not be exactly the same as the original program. </p>
<p class="calibre1"><b class="calibre3">386</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p420"/>Header</p>
<p class="calibre1">Header</p>
<p class="calibre1">Exports</p>
<p class="calibre1">Entry Point</p>
<p class="calibre1">Exports</p>
<p class="calibre1">.text Section</p>
<p class="calibre1">.text Section</p>
<p class="calibre1">.data Section</p>
<p class="calibre1">.data Section</p>
<p class="calibre1">.rsrc Section</p>
<p class="calibre1">.rsrc Section</p>
<p class="calibre1">Entry Point</p>
<p class="calibre1">Unpacking Stub</p>
<p class="calibre1">Unpacking Stub</p>
<p class="calibre1">Imports</p>
<p class="calibre1"> <i class="calibre4">Figure 18-3: The program after being </i></p>
<p class="calibre1"> <i class="calibre4">Figure 18-4: The fully unpacked </i></p>
<p class="calibre1"> <i class="calibre4">unpacked and loaded into memory. The </i></p>
<p class="calibre1"> <i class="calibre4">program. The import table is </i></p>
<p class="calibre1"> <i class="calibre4">unpacking stub unpacks everything neces-</i></p>
<p class="calibre1"> <i class="calibre4">reconstructed, and the starting </i></p>
<p class="calibre1"> <i class="calibre4">sary for the code to run. The program’s </i></p>
<p class="calibre1"> <i class="calibre4">point is back to the original entry </i></p>
<p class="calibre1"> <i class="calibre4">starting point still points to the unpacking </i></p>
<p class="calibre1"> <i class="calibre4">point (OEP). </i></p>
<p class="calibre1"> <i class="calibre4">stub, and there are no imports. </i></p>
<p class="calibre1"><b class="calibre3">Identifying Packed Programs</b></p>
<p class="calibre1">An early step when analyzing malware is to recognize that it is packed. We have covered techniques for detecting if malware is packed in earlier chapters. Here, we’ll provide a review and also introduce a new technique. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Indicators of a Packed Program</b></i></p>
<p class="calibre1">The following list summarizes signs to look for when determining whether malware is packed. </p>
<p class="calibre1"></p>
<p class="calibre1">The program has few imports, and particularly if the only imports are LoadLibrary and GetProcAddress. </p>
<p class="calibre1"></p>
<p class="calibre1">When the program is opened in IDA Pro, only a small amount of code is recognized by the automatic analysis. </p>
<p class="calibre1"></p>
<p class="calibre1">When the program is opened in OllyDbg, there is a warning that the program may be packed. </p>
<p class="calibre1"></p>
<p class="calibre1">The program shows section names that indicate a particular packer (such as UPX0). </p>
<p class="calibre1"></p>
<p class="calibre1">The program has abnormal section sizes, such as a .text section with a Size of Raw Data of 0 and Virtual Size of nonzero. </p>
<p class="calibre1">Packer-detection tools such as PEiD can also be used to determine if an executable is packed. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Entropy Calculation</b></i></p>
<p class="calibre1">Packed executables can also be detected via a technique known as  <i class="calibre4">entropy</i> <i class="calibre4">calculation</i>. Entropy is a measure of the disorder in a system or program, and while there is not a well-defined standard mathematical formula for calculating entropy, there are many well-formed measures of entropy for digital data. </p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">387</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p421"/>Compressed or encrypted data more closely resembles random data, and therefore has high entropy; executables that are not encrypted or compressed have lower entropy. </p>
<p class="calibre1">Automated tools for detecting packed programs often use heuristics like entropy. One such free automated tool is Mandiant Red Curtain, which calculates a threat score for any executable using measures such as entropy. Red Curtain can scan a filesystem for suspected packed binaries. </p>
<p class="calibre1"><b class="calibre3">Unpacking Options</b></p>
<p class="calibre1">There are three options for unpacking a packed executable: automated static unpacking, automated dynamic unpacking, and manual dynamic unpacking. The automated unpacking techniques are faster and easier than manual dynamic unpacking, but automated techniques don’t always work. If you have identified the kind of packer used, you should determine if an automated unpacker is available. If not, you may be able to find information about how to unpack the packer manually. </p>
<p class="calibre1">When dealing with packed malware, remember that your goal is to analyze the behavior of the malware, which does not always require you to re-create the original malware. Most of the time, when you unpack malware, you create a new binary that is not identical to the original, but does all the same things as the original. </p>
<p class="calibre1"><b class="calibre3">Automated Unpacking</b></p>
<p class="calibre1">Automated static unpacking programs decompress and/or decrypt the executable. This is the fastest method, and when it works, it is the best method, since it does not run the executable, and it restores the executable to its original state. Automatic static unpacking programs are specific to a single packer, and they will not work on packers that are designed to thwart analysis. </p>
<p class="calibre1">PE Explorer, a free program for working with EXE and DLL files, comes with several static unpacking plug-ins as part of the default setup. The default plug-ins support NSPack, UPack, and UPX. Unpacking files with PE Explorer is completely seamless. If PE Explorer detects that a file you’ve chosen to open is packed, it will automatically unpack the executable. Note that if you want to examine the unpacked executable outside PE Explorer, you’ll need to save it. </p>
<p class="calibre1">Automated dynamic unpackers run the executable and allow the unpacking stub to unpack the original executable code. Once the original executable is unpacked, the program is written to disk, and the unpacker reconstructs the original import table. </p>
<p class="calibre1">The automated unpacking program must determine where the unpacking stub ends and the original executable begins, which is difficult. When the packer fails to identify the end of the unpacking stub correctly, unpacking fails. </p>
<p class="calibre1"><b class="calibre3">388</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p422"/>Unfortunately, currently there are no good publicly available automated dynamic unpackers. Many publicly available tools will do an adequate job on some packers, but none is quite ready for serious usage. </p>
<p class="calibre1">Both automated unpacking techniques work quickly and are easy to use, but they have limited success. A malware analyst must know the difference between automated static and dynamic unpackers: Automated dynamic unpacking programs run the malicious executable, and automated static unpacking programs do not. Any time that the malicious program will run, it is necessary to make sure that happens in a safe environment, as discussed in Chapter 2. </p>
<p class="calibre1"><b class="calibre3">Manual Unpacking</b></p>
<p class="calibre1">Sometimes, packed malware can be unpacked automatically by an existing program, but more often it must be unpacked manually. Manual unpacking can sometimes be done quickly, with minimal effort; other times it can be a long, arduous process. </p>
<p class="calibre1">There are two common approaches to manually unpacking a program:</p>
<p class="calibre1"></p>
<p class="calibre1">Discover the packing algorithm and write a program to run it in reverse. </p>
<p class="calibre1">By running the algorithm in reverse, the program undoes each of the steps of the packing program. There are automated tools that do this, but this approach is still inefficient, since the program written to unpack the malware will be specific to the individual packing program used. So, even with automation, this process takes a significant amount of time to complete. </p>
<p class="calibre1"></p>
<p class="calibre1">Run the packed program so that the unpacking stub does the work for you, and then dump the process out of memory, and manually fix up the PE header so that the program is complete. This is the more efficient approach. </p>
<p class="calibre1">Let’s walk through a simple manual unpacking process. For the purposes of this example, we’ll unpack an executable that was packed with UPX. Although UPX can easily be unpacked automatically with the UPX </p>
<p class="calibre1">program, it is simple and makes a good example. You’ll work through this process yourself in the first lab for this chapter. </p>
<p class="calibre1">Begin by loading the packed executable into OllyDbg. The first step is to find the OEP, which was the first instruction of the program before it was packed. Finding the OEP for a function can be one of the more difficult tasks in the manual unpacking process, and will be covered in detail later in the chapter. For this example, we will use an automated tool that is a part of the OllyDump plug-in for OllyDbg. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">OllyDump, a plug-in for OllyDbg, has two good features for unpacking: It can</i> <i class="calibre4">dump the memory of the current process, and it can search for the OEP for a packed</i> <i class="calibre4">executable. </i></p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">389</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p423"/>In OllyDbg, select <b class="calibre3">Plugins</b><b class="calibre3">OllyDump</b><b class="calibre3">Find OEP by Section Hop</b>. The program will hit a breakpoint just before the OEP executes. </p>
<p class="calibre1">When that breakpoint is hit, all of the code is unpacked into memory, and the original program is ready to be run, so the code is visible and available for analysis. The only remaining step is to modify the PE header for this code so that our analysis tools can interpret the code properly. </p>
<p class="calibre1">The debugger will be broken on the instruction that is the OEP. Write down the value of the OEP, and do not close OllyDbg. </p>
<p class="calibre1">Now we’ll use the OllyDump plug-in to dump the executable. Select <b class="calibre3">Plugins</b><b class="calibre3">OllyDump</b><b class="calibre3">Dump Debugged Process</b>. This will dump everything from process memory onto disk. There are a few options on the screen for dumping the file to disk. </p>
<p class="calibre1">If OllyDbg just dumped the program without making any changes, then the dumped program will include the PE header of the packed program, which is not the same as the PE header of the unpacked program. We would need to change two things to correct the header:</p>
<p class="calibre1"></p>
<p class="calibre1">The import table must be reconstructed. </p>
<p class="calibre1"></p>
<p class="calibre1">The entry point in the PE header must point to the OEP. </p>
<p class="calibre1">Fortunately, if you don’t change any of the options on the dump screen, OllyDump will perform these steps automatically. The entry point of the executable will be set to the current instruction pointer, which in this case was the OEP, and the import table will be rebuilt. Click the <b class="calibre3">Dump</b> button, and you are finished unpacking this executable. We were able to unpack this program in just a few simple steps because OEP was located and the import table was reconstructed automatically by OllyDump. With complex unpackers it will not be so simple and the rest of the chapter covers how to unpack when OllyDump fails. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Rebuilding the Import Table with Import Reconstructor</b></i></p>
<p class="calibre1">Rebuilding the import table is complicated, and it doesn’t always work in OllyDump. The unpacking stub must resolve the imports to allow the application to run, but it does not need to rebuild the original import table. When OllyDbg fails, it’s useful to try to use Import Reconstructor (ImpRec) to perform these steps. </p>
<p class="calibre1">ImpRec can be used to repair the import table for packed programs. </p>
<p class="calibre1">Run ImpRec, and open the drop-down menu at the top of the screen. You should see the running processes. Select the packed executable. Next, enter the RVA value of the OEP (not the entire address) in the OEP field on the right. For example, if the image base is 0x400000 and the OEP is 0x403904, enter <b class="calibre3">0x3904</b>. Next, click the <b class="calibre3">IAT autosearch</b> button. You should see a window with a message stating that ImpRec found the original import address table (IAT). Now click <b class="calibre3">GetImports</b>. A listing of all the files with imported functions should appear on the left side of the main window. If the operation was successful, all the imports should say valid:YES. If the GetImports function was not successful, then the import table cannot be fixed automatically using ImpRec. </p>
<p class="calibre1"><b class="calibre3">390</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p424"/>Strategies for manually fixing the table are discussed later in this chapter. For now, we’ll assume that the import table was discovered successfully. </p>
<p class="calibre1">Click the <b class="calibre3">Fix Dump</b> button. You’ll be asked for the path to the file that you dumped earlier with OllyDump, and ImpRec will write out a new file with an underscore appended to the filename. </p>
<p class="calibre1">You can execute the file to make sure that everything has worked, if you’re not sure whether you’ve done it correctly. This basic unpacking process will work for most packed executables, and should be tried first. </p>
<p class="calibre1">As mentioned earlier, the biggest challenge of manually unpacking malware is finding the OEP, as we’ll discuss next. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Finding the OEP</b></i></p>
<p class="calibre1">There are many strategies for locating the OEP, and no single strategy will work against all packers. Analysts generally develop personal preferences, and they will try their favorite strategies first. But to be successful, analysts must be familiar with many techniques in case their favorite method does not work. Choosing the wrong technique can be frustrating and time-consuming. </p>
<p class="calibre1">Finding the OEP is a skill that must be developed with practice. This section contains a variety of strategies to help you develop your skills, but the only way to really learn is to practice. </p>
<p class="calibre1">In order to find the OEP, you need to run the malicious program in a debugger and use single-stepping and breakpoints. Recall the different types of breakpoints described in Chapter 8. OllyDbg offers four types of breakpoints, which are triggered by different conditions: the standard INT 3 breakpoints, the memory breakpoint provided by OllyDbg, hardware breakpoints, and run tracing with break conditions. </p>
<p class="calibre1">Packed code and the unpacking stub are often unlike the code that debuggers ordinarily deal with. Packed code is often self-modifying, containing call instructions that do not return, code that is not marked as code, and other oddities. These features can confuse the debuggers and cause breakpoints to fail. </p>
<p class="calibre1">Using an automated tool to find the OEP is the easiest strategy, but much like the automated unpacking approach, these tools do not always work. You may need to find the OEP manually. </p>
<p class="calibre1"><b class="calibre3">Using Automated Tools to Find the OEP</b></p>
<p class="calibre1">In the previous example, we used an automated tool to find the OEP. The most commonly used automatic tool for finding the OEP is the OllyDump plug-in within OllyDbg, called Find OEP by Section Hop. Normally, the unpacking stub is in one section and the executable is packed into another section. OllyDbg detects when there is a transfer from one section to another and breaks there, using either the step-over or step-into method. The step-over method will step-over any call instructions. Calls are often used to execute code in another section, and this method is designed to prevent OllyDbg from incorrectly labeling those calls the OEP. However, if a call function does not return, then OllyDbg will not locate the OEP. </p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">391</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p425"/>Malicious packers often include call functions that do not return in an effort to confuse the analyst and the debugger. The step-into option steps into each call function, so it’s more likely to find the OEP, but also more likely to produce false positives. In practice you should try both the step-over and the step-into methods. </p>
<p class="calibre1"><b class="calibre3">Finding the OEP Manually</b></p>
<p class="calibre1">When automated methods for finding the OEP fail, you will need to find it manually. The simplest manual strategy is to look for the tail jump. As mentioned earlier, this instruction jumps from the unpacking stub to the OEP. </p>
<p class="calibre1">Normally, it’s a jmp instruction, but some malware authors make it a ret instruction in order to evade detection. </p>
<p class="calibre1">Often, the tail jump is the last valid instruction before a bunch of bytes that are invalid instructions. These bytes are padding to ensure that the section is properly byte-aligned. Generally, IDA Pro is used to search through the packed executable for the tail jump. Listing 18-1 shows a simple tail jump example. </p>
<p class="calibre1">00416C31   PUSH EDI</p>
<p class="calibre1">00416C32   CALL EBP</p>
<p class="calibre1">00416C34   POP EAX</p>
<p class="calibre1">00416C35   POPAD</p>
<p class="calibre1">00416C36   LEA EAX,DWORD PTR SS:[ESP-80]</p>
<p class="calibre1">00416C3A   PUSH 0</p>
<p class="calibre1">00416C3C   CMP ESP,EAX</p>
<p class="calibre1">00416C3E   JNZ SHORT Sample84.00416C3A</p>
<p class="calibre1">00416C40   SUB ESP,-80</p>
<p class="calibre1">00416C43 JMP Sample84.00401000</p>
<p class="calibre1">00416C48   DB 00</p>
<p class="calibre1">00416C49   DB 00</p>
<p class="calibre1">00416C4A   DB 00</p>
<p class="calibre1">00416C4B   DB 00</p>
<p class="calibre1">00416C4C   DB 00</p>
<p class="calibre1">00416C4D   DB 00</p>
<p class="calibre1">00416C4E   DB 00</p>
<p class="calibre1"> <i class="calibre4">Listing 18-1: A simple tail jump</i></p>
<p class="calibre1">This example shows the tail jump for UPX at , which is located at address 0x00416C43. Two features indicate clearly that this is the tail jump: It’s located at the end of the code, and it links to an address that is very far away. If we were examining this jump in a debugger, we would see that there are hundreds of 0x00 bytes after the jump, which is uncommon; a return generally follows a jump, but this one isn’t followed by any meaningful code. </p>
<p class="calibre1">The other feature that makes this jump stick out is its size. Normally, jumps are used for conditional statements and loops, and go to addresses that are within a few hundred bytes, but this jump goes to an address that’s 0x15C43 bytes away. That is not consistent with a reasonable jmp statement. </p>
<p class="calibre1">The graph view in IDA Pro often makes the tail jump very easy to spot, as shown in Figure 18-5. IDA Pro colors a jump red when it can’t determine <b class="calibre3">392</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p426"/><img src="index-426_1.png" alt="Image 89" class="calibre2"/></p>
<p class="calibre1">where the jump goes. Normally, jumps are within the same function, and IDA Pro will draw an arrow to the target of a jmp instruction. In the case of a tail jump, IDA Pro encounters an error and colors the jump red. </p>
<p class="calibre1"> <i class="calibre4">Figure 18-5: A tail jump is highlighted in red in the IDA Pro graph view. </i></p>
<p class="calibre1">The tail jump transfers execution to the original program, which is packed on disk. Therefore, the tail jump goes to an address that does not contain valid instructions when the unpacking stub starts, but does contain valid instructions when the program is running. Listing 18-2 shows the disassembly at the address of the jump target when the program is loaded in OllyDbg. The instruction ADD BYTE PTR DS:[EAX],AL corresponds to two 0x00 </p>
<p class="calibre1">bytes, which is not a valid instruction, but OllyDbg is attempting to disassemble this instruction anyway. </p>
<p class="calibre1">00401000   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1">00401002   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1">00401004   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1">00401006   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1">00401008   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1">0040100A   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1">0040100C   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1">0040100E   ADD BYTE PTR DS:[EAX],AL</p>
<p class="calibre1"> <i class="calibre4">Listing 18-2: Instruction bytes stored at OEP before the original program is unpacked</i> Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">393</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p427"/>Listing 18-3 contains the disassembly found at the same address when the tail jump is executed. The original executable has been unpacked, and there are now valid instructions at that location. This change is another hall-mark of a tail jump. </p>
<p class="calibre1">00401000   CALL Sample84.004010DC</p>
<p class="calibre1">00401005   TEST EAX,EAX</p>
<p class="calibre1">00401007   JNZ SHORT Sample84.0040100E</p>
<p class="calibre1">00401009   CALL Sample84.00401018</p>
<p class="calibre1">0040100E   PUSH EAX</p>
<p class="calibre1">0040100F   CALL DWORD PTR DS:[414304] ; kernel32.ExitProcess 00401015   RETN</p>
<p class="calibre1"> <i class="calibre4">Listing 18-3: Instruction bytes stored at OEP after the original program is unpacked</i> Another way to find the tail jump is to set a read breakpoint on the stack. </p>
<p class="calibre1">Remember for read breakpoints, you must use either a hardware breakpoint or an OllyDbg memory breakpoint. Most functions in disassembly, including the unpacking stub, begin with a push instruction of some sort, which you can use to your advantage. First, make a note of the memory address on the stack where the first value is pushed, and then set a breakpoint on read for that stack location. </p>
<p class="calibre1">After that initial push, everything else on the stack will be higher on the stack (at a lower memory address). Only when the unpacking stub is complete will that stack address from the original push be accessed. Therefore, that address will be accessed via a pop instruction, which will hit the breakpoint and break execution. The tail jump is generally just after the pop instruction. It’s often necessary to try several different types of breakpoints on that address. A hardware breakpoint on read is a good type to try first. </p>
<p class="calibre1">Note that the OllyDbg interface does not allow you to set a breakpoint in the stack window. You must view the stack address in the memory dump window and set a breakpoint on it there. </p>
<p class="calibre1">Another strategy for manually finding OEP is to set breakpoints after every loop in the code. This allows you to monitor each instruction being executed without consuming a huge amount of time going through the same code in a loop over and over again. Normally, the code will have several loops, including loops within loops. Identify the loops by scanning through the code and setting a breakpoint after each loop. This method is manually intensive and generally takes longer than other methods, but it is easy to comprehend. The biggest pitfall with this method is setting a breakpoint in the wrong place, which will cause the executable to run to completion without hitting the breakpoint. If this happens, don’t be discouraged. Go back to where you left off and keeping setting breakpoints further along in the process until you find the OEP. </p>
<p class="calibre1">Another common pitfall is stepping over a function call that never returns. </p>
<p class="calibre1">When you step-over the function call, the program will continue to run, and the breakpoint will never be hit. The only way to address this is to start over, return to the same function call, and step-into the function instead of stepping <b class="calibre3">394</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p428"/>over it. Stepping into every function can be time consuming, so it’s advisable to use trial and error to determine when to step-over versus step-into. </p>
<p class="calibre1">Another strategy for finding the tail jump is to set a breakpoint on GetProcAddress. Most unpackers will use GetProcAddress to resolve the imports for the original function. A breakpoint that hits on GetProcAddress is far into the unpacking stub, but there is still a lot of code before the tail jump. Setting a breakpoint at GetProcAddress allows you to bypass the beginning of the unpacking stub, which often contains the most complicated code. </p>
<p class="calibre1">Another approach is to set a breakpoint on a function that you know will be called by the original program and work backward. For example, in most Windows programs, the OEP can be found at the beginning of a standard wrapper of code that is outside the main method. Because the wrapper is always the same, you can find it by setting a breakpoint on one of the functions it calls. </p>
<p class="calibre1">For command-line programs, this wrapper calls the GetVersion and GetCommandLineA functions very early in the process, so you can try to break when those functions are called. The program isn’t loaded yet, so you can’t set a breakpoint on the call to GetVersion, but you can set one on the first instruction of GetVersion, which works just as well. </p>
<p class="calibre1">In GUI programs, GetModuleHandleA is usually the first function to be called. After the program breaks, examine the previous stack frame to see where the call originated. There’s a good chance that the beginning of the function that called GetModuleHandleA or GetVersion is the OEP. Beginning at the call instruction, scroll up and search for the start of the function. Most functions start with push ebp, followed by mov ebp, esp. Try to dump the program with the beginning of that function as the OEP. If you’re right, and that function is the OEP, then you are finished. If you’re wrong, then the program will still be dumped, because the unpacking stub has already finished. </p>
<p class="calibre1">You will be able to view and navigate the program in IDA Pro, but you won’t necessarily know where the program starts. You might get lucky and IDA Pro might automatically identify WinMain or DllMain. </p>
<p class="calibre1">The last tactic for locating the OEP is to use the Run Trace option in OllyDbg. Run Trace gives you a number of additional breakpoint options, and allows you to set a breakpoint on a large range of addresses. For example, many packers leave the .text section for the original file. Generally, there is nothing in the .text section on disk, but the section is left in the PE header so that the loader will create space for it in memory. The OEP is always within the original .text section, and it is often the first instruction called within that section. The Run Trace option allows you to set a breakpoint to trigger whenever any instruction is executed within the .text section. When the breakpoint is triggered, the OEP can usually be found. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Repairing the Import Table Manually</b></i></p>
<p class="calibre1">OllyDump and ImpRec are usually able to rebuild the import table by searching through the program in memory for what looks like a list of imported functions. But sometimes this fails, and you need to learn a little more about how the import table works in order to analyze the malware. </p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">395</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p429"/>The import table is actually two tables in memory. The first table is the list of names or ordinals used by the loader or unpacking stub to determine which functions are needed. The second table is the list of the addresses of all the functions that are imported. When the code is running, only the second table is needed, so a packer can remove the list of names to thwart analysis. If the list of names is removed, then you may need to manually rebuild the table. </p>
<p class="calibre1">Analyzing malware without import information is extremely difficult, so it’s best to repair the import information whenever possible. The simplest strategy is to repair the imports one at a time as you encounter them in the disassembly. To do this, open the file in IDA Pro without any import information. When you see a call to an imported function, label that imported function in the disassembly. Calls to imported functions are an indirect call to an address that is outside the loaded program, as shown in Listing 18-4. </p>
<p class="calibre1">push eax</p>
<p class="calibre1">call dword_401244</p>
<p class="calibre1">... </p>
<p class="calibre1">dword_401244: 0x7c4586c8</p>
<p class="calibre1"> <i class="calibre4">Listing 18-4: Call to an imported function when the import table is not properly reconstructed</i> The listing shows a call instruction with a target based on a DWORD pointer. </p>
<p class="calibre1">In IDA Pro, we navigate to the DWORD and see that it has a value of 0x7c4586c8, which is outside our loaded program. Next, we open OllyDbg and navigate to the address 0x7c4586c8 to see what is there. OllyDbg has labeled that address WriteFile, and we can now label that import address as imp_WriteFile, so that we know what the function does. You’ll need to go through these steps for each import you encounter. The cross-referencing feature of IDA Pro will then label all calls to the imported functions. Once you’ve labeled enough functions, you can effectively analyze the malware. </p>
<p class="calibre1">The main drawbacks to this method are that you may need to label a lot of functions, and you cannot search for calls to an import until you have labeled it. The other drawback to this approach is that you can’t actually run your unpacked program. This isn’t a showstopper, because you can use the unpacked program for static analysis, and you can still use the packed program for dynamic analysis. </p>
<p class="calibre1">Another strategy, which does allow you to run the unpacked program, is to manually rebuild the import table. If you can find the table of imported functions, then you can rebuild the original import table by hand. The PE </p>
<p class="calibre1">file format is an open standard, and you can enter the imported functions one at time, or you could write a script to enter the information for you. </p>
<p class="calibre1">The biggest drawback is that this approach can be very tedious and time-consuming. </p>
<p class="calibre1"><b class="calibre3">396</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p430"/><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Sometimes malware authors use more than one packer. This doubles the work for the</i> <i class="calibre4">analyst, but with persistence, it’s usually possible to unpack even double-packed malware. The strategy is simple: Undo the first layer of packing using any of the techniques</i> <i class="calibre4">we’ve just described, and then repeat to undo the second layer of packing. The strategies</i> <i class="calibre4">are the same, regardless of the number of packers used. </i></p>
<p class="calibre1"><b class="calibre3">Tips and Tricks for Common Packers</b></p>
<p class="calibre1">This section covers just a sampling of popular packers that you are likely to encounter when analyzing malware. For each packer covered, we’ve included a description and a strategy for unpacking manually. Automated unpackers are also listed for some of these, but they do not always work. For each packer, strategies for finding the OEP and potential complications are also included. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">UPX</b></i></p>
<p class="calibre1">The most common packer used for malware is the Ultimate Packer for eXecutables (UPX). UPX is open source, free, and easy to use, and it supports a wide variety of platforms. UPX compresses the executable, and is designed for performance rather than security. UPX is popular because of its high decompression speed, and the small size and low memory requirements of its decompression routine. </p>
<p class="calibre1">UPX was not designed to be difficult to reverse-engineer, and it does not pose much of a challenge for a malware analyst. Most programs packed with UPX can be unpacked with UPX as well, and the command line has a -d option that you can use to decompress a UPX-packed executable. </p>
<p class="calibre1">Because it’s fairly easy to overcome, UPX is a good packer for learning how to manually unpack malware. However, many stealthy malicious programs are designed to appear to be packed with UPX, when they are really packed with another packer or a modified version of UPX. When this is the case, the UPX program will not be able to unpack the executable. </p>
<p class="calibre1">You can find the OEP for UPX by using many of the strategies outlined earlier in this chapter. You can also use the Find OEP by Section Hop feature in OllyDump, or simply page down through the unpacking stub until you see the tail jump. Dumping the file and reconstructing the import table with OllyDump will be successful. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">PECompact</b></i></p>
<p class="calibre1">PECompact is a commercial packer designed for speed and performance. </p>
<p class="calibre1">A discontinued free student version is still often used by malware authors. </p>
<p class="calibre1">Programs packed with this packer can be difficult to unpack, because it includes anti-debugging exceptions and obfuscated code. PECompact has a plug-in framework that allows third-party tools to be incorporated, and malware authors often include third-party tools that make unpacking even more difficult. </p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">397</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p431"/>Unpacking PECompact manually is largely the same as unpacking UPX. The program generates some exceptions, so you will need to have OllyDbg set to pass exceptions to the program. This was discussed in detail in Chapter 16. </p>
<p class="calibre1">You can find the OEP by looking for the tail jump. Step over a few functions, and you will see a tail jump consisting of a jmp eax followed by many 0x00 bytes. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">ASPack</b></i></p>
<p class="calibre1">ASPack is focused on security, and it employs techniques to make it difficult to unpack programs. ASPack uses self-modifying code, which makes it difficult to set breakpoints and to analyze in general. </p>
<p class="calibre1">Setting a breakpoint can cause programs packed with ASPack to terminate prematurely, but these programs can still be manually unpacked using hardware breakpoints set on the stack address. Additionally, ASPack is so popular that there are many automated unpackers available. Their effectiveness varies, but automated unpacking is always worth trying as a first option. </p>
<p class="calibre1">Although you may successfully unpack an ASPack packed file using automated techniques, most likely you’ll need to unpack files manually. Begin by opening the code for the unpacking stub. Early in the code, you will see a PUSHAD instruction. Determine which stack addresses are used to store the registers, and set a hardware breakpoint on one of those addresses. Ensure that it is set to break on a read instruction. When the corresponding POPAD </p>
<p class="calibre1">instruction is called, the breakpoint will be triggered and you will be just a few instructions away from the tail jump that leads to the OEP. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Petite</b></i></p>
<p class="calibre1">Petite is similar to ASPack in a number of ways. Petite also uses anti-debugging mechanisms to make it difficult to determine the OEP, and the Petite code uses single-step exceptions in order to break into the debugger. This can be resolved by passing single-step exceptions to the program, as described in Chapter 16. The best strategy is to use a hardware breakpoint on the stack to find the OEP, as with ASPack. Petite uses a complicated code structure that makes it easy to spot the OEP once you have gotten close because the original code looks normal unlike the Petite wrapper code. </p>
<p class="calibre1">Petite also keeps at least one import from each library in the original import table. Although this does not affect how difficult it is to unpack, you can easily determine which DLLs the malware uses without unpacking it. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">WinUpack</b></i></p>
<p class="calibre1">WinUpack is a packer with a GUI front end, designed for optimal compression, and not for security. There is a command-line version of this packer called UPack, and there are automated unpackers specific to UPack and WinUpack. </p>
<p class="calibre1"><b class="calibre3">398</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p432"/>Although security isn’t its focus, WinUpack does include security measures that make it difficult to find the OEP, and render techniques such as searching for the tail jump or using OllyDump useless. Listing 18-5 shows the tail jump for this executable. </p>
<p class="calibre1">010103A6   POP ECX</p>
<p class="calibre1">010103A7   OR ECX,ECX</p>
<p class="calibre1">010103A9   MOV DWORD PTR SS:[EBP+3A8],EAX</p>
<p class="calibre1">010103AF   POPAD</p>
<p class="calibre1">010103B0   JNZ SHORT Sample_upac.010103BA</p>
<p class="calibre1">010103B2   MOV EAX,1</p>
<p class="calibre1">010103B7   RETN 0C</p>
<p class="calibre1">010103BA PUSH Sample_upac.01005F85</p>
<p class="calibre1">010103BF RETN</p>
<p class="calibre1">010103C0   MOV EAX,DWORD PTR SS:[EBP+426]</p>
<p class="calibre1">010103C6   LEA ECX,DWORD PTR SS:[EBP+43B]</p>
<p class="calibre1">010103CC   PUSH ECX</p>
<p class="calibre1">010103CD   PUSH EAX</p>
<p class="calibre1">010103CE   CALL DWORD PTR SS:[EBP+F49]</p>
<p class="calibre1">010103D4   MOV DWORD PTR SS:[EBP+555],EAX</p>
<p class="calibre1">010103DA   LEA EAX,DWORD PTR SS:[EBP+447]</p>
<p class="calibre1">010103E0   PUSH EAX</p>
<p class="calibre1">010103E1   CALL DWORD PTR SS:[EBP+F51]</p>
<p class="calibre1">010103E7   MOV DWORD PTR SS:[EBP+42A],EAX</p>
<p class="calibre1"> <i class="calibre4">Listing 18-5: Tail jump for a program packed with UPack</i> In this listing, the tail jump at  is in the middle of the unpacking stub, so it is difficult to spot. A push instruction at  followed by a return instruction is extremely common for a tail jump. The code jumps all around before arriving at the tail jump in order to make it harder to spot. To further obscure the tail jump, the push that precedes the retn instruction is modified by the packer shortly before it is called. The jump is also not very far, so you can’t identify it by searching for long jumps. Because the OEP is in the same section as the unpacking stub, OllyDump cannot automatically identify the tail jump via its section-hopping method. </p>
<p class="calibre1">The best strategy for finding the OEP for a program packed with UPack is to set a breakpoint on GetProcAddress, and then single-step carefully over instructions looking for the loops that set the import resolution. If you set the breakpoints at every jmp or call instruction, you will be single-stepping forever, but if you set the breakpoints too sparsely, the program will probably miss your breakpoints and run until completion. </p>
<p class="calibre1">Do not be discouraged if the program runs to completion without hitting your breakpoints. Simply restart the application in the debugger and try again. Making mistakes is a part of the process. Eventually, you will single-step onto a ret instruction that is the tail jump. </p>
<p class="calibre1">Sometimes, recognizing the tail jump can be tricky. In this case, it jumps about 0x4000 bytes away. Most unpacking stubs are much smaller than 0x4000, and a jump of that size usually is a jump to the OEP. A good way to double-check is to examine the code around the OEP, which should look more like Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">399</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p433"/>ordinary code compared to the unpacking stub. The unpacking stub often has many conditional jumps and returns in the middle of a function, but the code around the OEP should not have these unusual elements. </p>
<p class="calibre1">Another strategy that works on UPack is to set a breakpoint on GetModuleHandleA for GUI programs or GetCommandLineA for command-line programs. In Windows, these functions are called shortly after the OEP. </p>
<p class="calibre1">Once the breakpoint is triggered, search backward through the code to find the OEP. </p>
<p class="calibre1">Sometimes WinUpack crashes OllyDbg by using a PE header that OllyDbg parses incorrectly. In Chapter 16, we showed that OllyDbg isn’t perfect and has issues parsing binaries that run just fine on Windows outside the debugger. If you encounter this problem, always try to use WinDbg before attempting to decipher PE header errors. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Themida</b></i></p>
<p class="calibre1">Themida is a very complicated packer with many features. Most of the features are anti-debugging and anti-analysis, which make it a very secure packer that’s difficult to unpack and analyze. </p>
<p class="calibre1">Themida contains features that prevent analysis with VMware, debuggers, and Process Monitor (procmon). Themida also has a kernel component, which makes it much more difficult to analyze. Code running in the kernel has very few restrictions, and analysis code generally runs in user space, and is therefore subject to more restrictions. </p>
<p class="calibre1">Because Themida includes so many features, the packed executable is unusually bulky. In addition, unlike most packers, Themida’s code continues to run the entire time that the original program is running. </p>
<p class="calibre1">Some automated tools are designed to unpack Themida files, but their success varies based on the version of Themida and the settings used when the program was packed. Themida has so many features and settings that it is impossible to find a single unpacking strategy that will always work. </p>
<p class="calibre1">If automated tools don’t work, another great strategy is to use ProcDump to dump the process from memory without debugging. ProcDump is a tool from Microsoft for dumping the contents of a Windows process. It’s designed to work with a debugger, but is not itself a debugger. The biggest advantage of ProcDump is that you can dump process memory without stopping or debugging the process, which is extremely useful for packers that have advanced anti-debugging measures. Even when you cannot debug an executable, you can use ProcDump to dump the unpacked contents while the executable is running. This process doesn’t completely restore the original executable, but it does allow you to run strings and do some analysis on the code. </p>
<p class="calibre1"><b class="calibre3">Analyzing Without Fully Unpacking</b></p>
<p class="calibre1">Some programs, including those packed with Themida, can be very difficult to unpack. At times, you might spend all day trying to unpack a program and have no success. Perhaps the packer is using a new technique that you simply <b class="calibre3">400</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p434"/>cannot solve. If that happens, you may be in luck—you don’t always need to create a fully unpacked working executable in order to analyze a piece of malware. </p>
<p class="calibre1">The simplest case occurs when a program that is unpacked fails to execute because you can’t completely repair the import table and PE header. In that case, you can still use IDA Pro to analyze the program, even though it is not fully executable. Once you have the dumped program on disk, you can have IDA Pro analyze specific sections of code by navigating to the memory address and marking that section as code. You can also run Strings on the program (as discussed in Chapter 1), which might reveal the imported functions and other useful information. </p>
<p class="calibre1">The analysis that’s possible without fully unpacking is very limited, but depending on your goal, it may be sufficient. </p>
<p class="calibre1">Some unpackers do not actually unpack the entire original program before the program begins running. Instead, they unpack a portion of the original program, and run that portion. When it is time to run the next portion of code, that portion is unpacked into memory and run. This creates considerable overhead for the executable, but makes it very difficult for an analyst to unpack. </p>
<p class="calibre1">Reverse-engineering the technique that unpacks individual chunks of code can enable you to write a script to unpack all of the code, or at least large portions of it. Another option is to focus more on dynamic analysis. </p>
<p class="calibre1"><b class="calibre3">Packed DLLs</b></p>
<p class="calibre1">There are additional complications associated with packing DLLs, so this capability is not supported by all packers. Handling the exports of the DLL is one complication. The export table in the DLL points to the address of the exported functions, and if the DLL is packed, then the exported functions are also packed. The packer must account for this to ensure that the DLL </p>
<p class="calibre1">operates properly. </p>
<p class="calibre1">Unpacking a DLL is not much different from unpacking an EXE. The key thing to remember is that DLLs have an OEP, just like executables. All DLLs have a function called DllMain, which is called when the DLL is loaded. </p>
<p class="calibre1">The OEP in a DLL is the original start of DllMain. The start address listed in the packed DLL is the address of the unpacking stub, which is placed into DllMain rather than into the main method. OllyDbg can load DLLs, and OllyDbg has a tool called  <i class="calibre4">loadDll.exe</i>, which allows you to load and debug DLLs. </p>
<p class="calibre1">The problem is that the DllMain method will be called prior to breaking in OllyDbg. By the time the break occurs, the unpacking stub will have already executed, and it will be very difficult to find the OEP. </p>
<p class="calibre1">To get around this, open the PE file and locate the Characteristics field in the IMAGE_FILE_HEADER section. The bit in the 0x2000 place in the IMAGE_FILE_HEADER is set to 1 for DLLs. If this field is changed to a 0, then the file will be interpreted as an executable. OllyDbg will open the program as an EXE, and you will be able to apply all of the unpacking strategies discussed in this chapter. After you’ve found the OEP, change the bit back so that the program will be treated as a DLL again. </p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">401</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p435"/><b class="calibre3">Conclusion</b></p>
<p class="calibre1">This chapter covered a large number of strategies for dealing with packed software. We started with the basics of how packers work and how to unpack software, and then discussed some automated unpacking tools and strategies. </p>
<p class="calibre1">Next, we covered techniques that can be used to manually unpack malicious software. No single strategy or tool will work in all cases, so you need to be familiar with several techniques. </p>
<p class="calibre1">In the next chapter, we will cover shellcode and strategies for recognizing and analyzing malicious shellcode. </p>
<p class="calibre1"><b class="calibre3">402</b></p>
<p class="calibre1">Chapter 18</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p436"/><b class="calibre3">L A B S</b></p>
<p class="calibre1">Your goal for the labs in this chapter is simply to unpack the code for further analysis. For each lab, you should try to unpack the code so that other static analysis techniques can be used. While you may be able to find an automated unpacker that will work with some of these labs, automated unpackers won’t help you learn the skills you need when you encounter custom packers. Also, once you master unpacking, you may be able to manually unpack a file in less time than it takes to find, download, and use an automated unpacker. </p>
<p class="calibre1">Each lab is a packed version of a lab from a previous chapter. Your task in each case is to unpack the lab and identify the chapter in which it appeared. </p>
<p class="calibre1">The files are  <i class="calibre4">Lab18-01.exe</i> through  <i class="calibre4">Lab18-05.exe</i>. </p>
<p class="calibre1">Packers and Unpacking</p>
<p class="calibre1"><b class="calibre3">403</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p437"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p438"/><b class="calibre3">PART 6</b></p>
<p class="calibre1"><b class="calibre3">S P E C I A L   T O P I C S</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p439"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p440"/><b class="calibre3">S H E L L C O D E   A N A L Y S I S</b></p>
<p class="calibre1"> <i class="calibre4">Shellcode</i> refers to a payload of raw executable code. </p>
<p class="calibre1">The name  <i class="calibre4">shellcode</i> comes from the fact that attackers would usually use this code to obtain interactive shell </p>
<p class="calibre1">access on the compromised system. However, over </p>
<p class="calibre1">time, the term has become commonly used to describe </p>
<p class="calibre1">any piece of self-contained executable code. </p>
<p class="calibre1">Shellcode is often used alongside an exploit to subvert a running program, or by malware performing process injection. Exploitation and process injection are similar in that the shellcode is added to a running program and executed after the process has started. </p>
<p class="calibre1">Shellcode requires its authors to manually perform several actions that software developers usually never worry about. For example, the shellcode package cannot rely on actions the Windows loader performs during normal program startup, including the following:</p>
<p class="calibre1"></p>
<p class="calibre1">Placing the program at its preferred memory location</p>
<p class="calibre1"></p>
<p class="calibre1">Applying address relocations if it cannot be loaded at its preferred memory location</p>
<p class="calibre1"></p>
<p class="calibre1">Loading required libraries and resolving external dependencies</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p441"/>This chapter will introduce you to these shellcode techniques, demonstrated by full, working real-world examples. </p>
<p class="calibre1"><b class="calibre3">Loading Shellcode for Analysis</b></p>
<p class="calibre1">Loading and running shellcode in a debugger is problematic because shellcode is usually just a binary chunk of data that cannot run in the same way as a normal executable. To make things easier, we’ll use  <i class="calibre4">shellcode_launcher.exe</i> (included with the labs available at  <i class="calibre4">http://www.practicalmalwareanalysis.com/</i>) to load and jump to pieces of shellcode. </p>
<p class="calibre1">As discussed in Chapter 5, loading shellcode into IDA Pro for static analysis is relatively simple, but the user must provide input during the load process, since there is no executable file format that describes the contents of shellcode. First, you must ensure the correct processor type is selected in the load process dialog. For samples in this chapter, you can use the <b class="calibre3">Intel 80x86 processors: metapc</b> processor type and select <b class="calibre3">32-bit disassembly</b> when prompted. IDA Pro loads the binary but performs no automatic analysis (analysis must be done manually). </p>
<p class="calibre1"><b class="calibre3">Position-Independent Code</b></p>
<p class="calibre1"> <i class="calibre4">Position-independent code (PIC) </i> is code that uses no hard-coded addresses for either code or data. Shellcode is PIC. It cannot assume that it will be located at a particular memory location when it executes, because at runtime, different versions of a vulnerable program may load the shellcode into different memory locations. The shellcode must ensure that all memory access for both code and data uses PIC techniques. </p>
<p class="calibre1">Table 19-1 shows several common types of x86 code and data access, and whether they are PIC. </p>
<p class="calibre1"><b class="calibre3">Table 19-1: </b>Different Types of x86 Code and Data Access <b class="calibre3">Instruction mnemonics</b></p>
<p class="calibre1"><b class="calibre3">Instruction bytes</b></p>
<p class="calibre1"><b class="calibre3">Position-independent? </b></p>
<p class="calibre1">call    sub_401000</p>
<p class="calibre1">E8 C1 FF FF FF </p>
<p class="calibre1">Yes</p>
<p class="calibre1">jnz     short loc_401044</p>
<p class="calibre1">75 0E </p>
<p class="calibre1">Yes</p>
<p class="calibre1">mov     edx, dword_407030 </p>
<p class="calibre1">8B 15 30 70 40 00</p>
<p class="calibre1">No</p>
<p class="calibre1">mov     eax, [ebp-4] </p>
<p class="calibre1">8B 45 FC</p>
<p class="calibre1">Yes</p>
<p class="calibre1">In the table, the call instruction contains a 32-bit signed relative displacement that is added to the address immediately following the call instruction in order to calculate the target location. Because the call instruction shown in the table is located at 0x0040103A, adding the offset value 0xFFFFFFC1  </p>
<p class="calibre1">to the location of the instruction, plus the size of the call instruction (5 bytes), results in the call target 0x00401000. </p>
<p class="calibre1">The jnz instruction is very similar to call, except that it uses only an 8-bit signed relative displacement. The jnz instruction is located at 0x00401034. </p>
<p class="calibre1"><b class="calibre3">408</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p442"/>Adding together this location, the offset stored in the instruction (0xe) , and the size of the instruction (2 bytes) results in the jump target 0x00401044. </p>
<p class="calibre1">As you can see, control-flow instructions such as call and jump are already position-independent. They calculate target addresses by adding a relative offset stored in the instruction to the current location specified by the EIP </p>
<p class="calibre1">register. (Certain forms of call and jump allow programmers to use absolute, or nonrelative, addressing that is not position-independent, but they are easily avoided.)</p>
<p class="calibre1">The mov instruction at  shows an instruction accessing the global data variable dword_407030. The last 4 bytes in this instruction show the memory location 0x00407030. This particular instruction is not position-independent and must be avoided by shellcode authors. </p>
<p class="calibre1">Compare the mov instruction at  to the mov instruction at , which accesses a DWORD from the stack. This instruction uses the EBP register as a base, and contains a signed relative offset: 0xFC (-4). This type of data access is position-independent and is the model that shellcode authors must use for all data access: Calculate a runtime address and refer to data only by using offsets from this location. (The following section discusses finding an appropriate runtime address.)</p>
<p class="calibre1"><b class="calibre3">Identifying Execution Location</b></p>
<p class="calibre1">Shellcode needs to dereference a base pointer when accessing data in a position-independent manner. Adding or subtracting values to this base value will allow it to safely access data that is included with the shellcode. </p>
<p class="calibre1">Because the x86 instruction set does not provide EIP-relative data access, as it does for control-flow instructions, a general-purpose register must first be loaded with the current instruction pointer, to be used as the base pointer. </p>
<p class="calibre1">Obtaining the current instruction pointer may not be immediately obvious, because the instruction pointer on x86 systems cannot be directly accessed by software. In fact, there is no way to assemble the instruction mov eax, eip to directly load a general-purpose register with the current instruction pointer. However, shellcode uses two popular techniques to address this issue: call/pop and fnstenv instructions. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using call/pop</b></i></p>
<p class="calibre1">When a call instruction is executed, the processor pushes the address of the instruction following the call onto the stack, and then branches to the requested location. This function executes, and when it completes, it executes a ret instruction to pop the return address off the top of the stack and load it into the instruction pointer. As a result, execution returns to the instruction just after the call. </p>
<p class="calibre1">Shellcode can abuse this convention by immediately executing a pop instruction after a call, which will load the address immediately following the call into the specified register. Listing 19-1 shows a simple Hello World example that uses this technique. </p>
<p class="calibre1">Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">409</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p443"/>Bytes            Disassembly</p>
<p class="calibre1">83 EC 20         sub     esp, 20h</p>
<p class="calibre1">31 D2            xor     edx, edx</p>
<p class="calibre1">E8 0D 00 00 00   call    sub_17 </p>
<p class="calibre1">48 65 6C 6C 6F   db 'Hello World!',0 </p>
<p class="calibre1">20 57 6F 72 6C</p>
<p class="calibre1">64 21 00</p>
<p class="calibre1">sub_17: </p>
<p class="calibre1">5F               pop     edi             ; edi gets string pointer 52               push    edx               ; uType: MB_OK </p>
<p class="calibre1">57               push    edi               ; lpCaption</p>
<p class="calibre1">57               push    edi               ; lpText</p>
<p class="calibre1">52               push    edx               ; hWnd: NULL</p>
<p class="calibre1">B8 EA 07 45 7E   mov     eax, 7E4507EAh    ; MessageBoxA FF D0            call    eax </p>
<p class="calibre1">52               push    edx               ; uExitCode</p>
<p class="calibre1">B8 FA CA 81 7C   mov     eax, 7C81CAFAh    ; ExitProcess FF D0            call    eax </p>
<p class="calibre1"> <i class="calibre4">Listing 19-1: call/pop Hello World example</i></p>
<p class="calibre1">The call at  transfers control to sub_17 at . This is PIC because the call instruction uses an EIP relative value (0x0000000D) to calculate the call target. The pop instruction at  loads the address stored on top of the stack into EDI. </p>
<p class="calibre1">Remember that the EIP value saved by the call instruction points to the location immediately following the call, so after the pop instruction, EDI will contain a pointer to the db declaration at . This db declaration is assembly language syntax to create a sequence of bytes to spell out the string Hello World!. After the pop at , EDI will point to this Hello World! string. </p>
<p class="calibre1">This method of intermingling code and data is normal for shellcode, but it can easily confuse disassemblers who try to interpret the data following the call instruction as code, resulting in either nonsensical disassembly or completely halting the disassembly process if invalid opcode combinations are encountered. As seen in Chapter 15, using call/pop pairs to obtain pointers to data may be incorporated into larger programs as an additional anti-reverse-engineering technique. </p>
<p class="calibre1">The remaining code calls MessageBoxA  to show the “Hello World!” message, and then ExitProcess  to cleanly exit. This sample uses hard-coded locations for both function calls because imported functions in shellcode are not automatically resolved by the loader, but hard-coded locations make this code fragile. (These addresses come from a Windows XP SP3 box, and may differ from yours.)</p>
<p class="calibre1">To find these function addresses with OllyDbg, open any process and press CTRL-G to bring up the Enter Expression to Follow dialog. Enter <b class="calibre3">MessageBoxA</b> in the dialog and press ENTER. The debugger should show the location of the function, as long as the library with this export ( <i class="calibre4">user32.dll </i>) is loaded by the process being debugged. </p>
<p class="calibre1"><b class="calibre3">410</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p444"/>To load and step through this example with  <i class="calibre4">shellcode_launcher.exe</i>, enter the following at the command line:</p>
<p class="calibre1"><b class="calibre3">shellcode_launcher.exe -i helloworld.bin -bp -L user32</b></p>
<p class="calibre1">The -L user32 option is required because the shellcode does not call LoadLibraryA, so  <i class="calibre4">shellcode_launcher.exe</i> must make sure this library is loaded. </p>
<p class="calibre1">The -bp option inserts a breakpoint instruction just prior to jumping to the shellcode binary specified with the -i option. Recall that debuggers can be registered for just-in-time debugging and can be launched automatically (or when prompted) when a program encounters a breakpoint. If a debugger such as OllyDbg has been registered as a just-in-time debugger, it will open and attach to the process that encountered a breakpoint. This allows you to skip over the contents of the  <i class="calibre4">shellcode_launcher.exe</i> program and begin at the start of the shellcode binary. </p>
<p class="calibre1">You can set OllyDbg as your just-in-time debugger by selecting <b class="calibre3">Options</b></p>
<p class="calibre1"><b class="calibre3">Just-in-time Debugging</b><b class="calibre3">Make OllyDbg Just-in-time Debugger</b>. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Readers who wish to execute this example may need to modify the hard-coded function</i> <i class="calibre4">locations for MessageBoxA and ExitProcess. These addresses can be found as described</i> <i class="calibre4">in the text. Once the addresses have been found, you can patch </i> helloworld.bin <i class="calibre4"> within</i> <i class="calibre4">OllyDbg by placing the cursor on the instruction that loads the hard-coded function</i> <i class="calibre4">location into register EAX and then pressing the spacebar. This brings up OllyDbg’s</i> <i class="calibre4">Assemble At dialog, which allows you to enter your own assembly code. This will be</i> <i class="calibre4">assembled by OllyDbg and overwrite the current instruction. Simply replace the</i> <i class="calibre4">7E4507EAh value with the correct value from your machine, and OllyDbg will patch</i> <i class="calibre4">the program in memory, allowing the shellcode to execute correctly. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using fnstenv</b></i></p>
<p class="calibre1">The x87 floating-point unit (FPU) provides a separate execution environment within the normal x86 architecture. It contains a separate set of special-purpose registers that need to be saved by the OS on a context switch when a process is performing floating-point arithmetic with the FPU. Listing 19-2 </p>
<p class="calibre1">shows the 28-byte structure used by the fstenv and fnstenv instructions to store the state of the FPU to memory when executing in 32-bit protected mode. </p>
<p class="calibre1">struct FpuSaveState {</p>
<p class="calibre1">uint32_t    control_word; </p>
<p class="calibre1">uint32_t    status_word; </p>
<p class="calibre1">uint32_t    tag_word; </p>
<p class="calibre1">uint32_t    fpu_instruction_pointer; </p>
<p class="calibre1">uint16_t    fpu_instruction_selector; </p>
<p class="calibre1">uint16_t    fpu_opcode; </p>
<p class="calibre1">uint32_t    fpu_operand_pointer; </p>
<p class="calibre1">uint16_t    fpu_operand_selector; </p>
<p class="calibre1">uint16_t    reserved; </p>
<p class="calibre1">}; </p>
<p class="calibre1"> <i class="calibre4">Listing 19-2: FpuSaveState structure definition</i></p>
<p class="calibre1">Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">411</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p445"/>The only field that matters for use here is fpu_instruction_pointer at byte offset 12. This will contain the address of the last CPU instruction that used the FPU, providing context information for exception handlers to identify which FPU instructions may have caused a fault. This field is required because the FPU is running in parallel with the CPU. If the FPU </p>
<p class="calibre1">generates an exception, the exception handler cannot simply look at the interrupt return address to identify the instruction that caused the fault. </p>
<p class="calibre1">Listing 19-3 shows the disassembly of another Hello World program that uses fnstenv to obtain the EIP value. </p>
<p class="calibre1">Bytes            Disassembly</p>
<p class="calibre1">83 EC 20         sub     esp, 20h</p>
<p class="calibre1">31 D2            xor     edx, edx</p>
<p class="calibre1">EB 15            jmp     short loc_1C</p>
<p class="calibre1">EA 07 45 7E      dd 7E4507EAh               ; MessageBoxA FA CA 81 7C      dd 7C81CAFAh               ; ExitProcess 48 65 6C 6C 6F   db 'Hello World!',0</p>
<p class="calibre1">20 57 6F 72 6C </p>
<p class="calibre1">64 21 00            </p>
<p class="calibre1">loc_1C:</p>
<p class="calibre1">D9 EE            fldz </p>
<p class="calibre1">D9 74 24 F4      fnstenv byte ptr [esp-0Ch] </p>
<p class="calibre1">5B               pop     ebx       </p>
<p class="calibre1">; ebx points to fldz </p>
<p class="calibre1">8D 7B F3         lea     edi, [ebx-0Dh]   ; load HelloWorld pointer 52               push    edx                ; uType: MB_OK </p>
<p class="calibre1">57               push    edi                ; lpCaption</p>
<p class="calibre1">57               push    edi                ; lpText</p>
<p class="calibre1">52               push    edx                ; hWnd: NULL</p>
<p class="calibre1">8B 43 EB         mov     eax, [ebx-15h]  ; </p>
<p class="calibre1">load </p>
<p class="calibre1">MessageBoxA</p>
<p class="calibre1">FF D0            call    eax                ; call MessageBoxA 52               push    edx                ; uExitCode</p>
<p class="calibre1">8B 43 EF         mov     eax, [ebx-11h]   ; load ExitProcess FF D0            call    eax                ; call ExitProcess <i class="calibre4">Listing 19-3: fnstenv Hello World example</i></p>
<p class="calibre1">The fldz instruction at  pushes the floating-point number 0.0 onto the FPU stack. The fpu_instruction_pointer value is updated within the FPU to point to the fldz instruction. </p>
<p class="calibre1">Performing the fnstenv at  stores the FpuSaveState structure onto the stack at [esp-0ch], which allows the shellcode to do a pop at  that loads EBX with the fpu_instruction_pointer value. Once the pop executes, EBX will contain a value that points to the location of the fldz instruction in memory. The shellcode then starts using EBX as a base register to access the data embedded in the code. </p>
<p class="calibre1">As in the previous Hello World example, which used the call/pop technique, this code calls MessageBoxA and ExitProcess using hard-coded locations, but here the function locations are stored as data along with the ASCII string to print. The lea instruction at  loads the address of the Hello <b class="calibre3">412</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p446"/>World! string by subtracting 0x0d from the address of the fldz instruction stored in EBX. The mov instruction at  loads the first function location for MessageBoxA, and the mov instruction at  loads the second function location for ExitProcess. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Listing 19-3 is a contrived example, but it is common for shellcode to store or create</i> <i class="calibre4">function pointer arrays. We used the fldz instruction in this example, but any non-control FPU instruction can be used. </i></p>
<p class="calibre1">This example can be executed using  <i class="calibre4">shellcode_launcher.exe</i> with the following command:</p>
<p class="calibre1"><b class="calibre3">shellcode_launcher.exe -i hellofstenv.bin -bp -L user32</b></p>
<p class="calibre1"><b class="calibre3">Manual Symbol Resolution</b></p>
<p class="calibre1">Shellcode exists as a binary blob that gains execution. It must do something useful once it gains execution, which usually means interacting with the system through APIs. </p>
<p class="calibre1">Remember that shellcode cannot use the Windows loader to ensure that all required libraries are loaded and available, and to make sure that all external symbols are resolved. Instead, it must find the symbols itself. The shellcode in the previous examples used hard-coded addresses to find the symbols, but this very fragile method will work only on a specific version of an OS and service pack. Shellcode must dynamically locate the functions in order to work reliably in different environments, and for that task, it typically uses LoadLibraryA and GetProcAddress. </p>
<p class="calibre1">LoadLibraryA loads the specified library and returns a handle. The GetProcAddress function searches the library’s exports for the given symbol name or ordinal number. If shellcode has access to these two functions, it can load any library on the system and find exported symbols, at which point it has full access to the API. </p>
<p class="calibre1">Both functions are exported from  <i class="calibre4">kernel32.dll</i>, so the shellcode must do the following:</p>
<p class="calibre1"></p>
<p class="calibre1">Find  <i class="calibre4">kernel32.dll</i> in memory. </p>
<p class="calibre1"></p>
<p class="calibre1">Parse  <i class="calibre4">kernel32.dll</i>’s PE file and search the exported functions for LoadLibraryA and GetProcAddress. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Finding kernel32.dll in Memory</b></i></p>
<p class="calibre1">In order to locate  <i class="calibre4">kernel32.dll</i>, we’ll follow a series of undocumented Windows structures. One of these structures contains the load address of  <i class="calibre4">kernel32.dll</i>. </p>
<p class="calibre1">Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">413</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p447"/><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Most of the Windows structures are listed on the Microsoft Developer Network (MSDN)</i> <i class="calibre4">site, but they are not fully documented. Many contain byte arrays named Reserved,</i> <i class="calibre4">with the warning “This structure may be altered in future versions of Windows.” For</i> <i class="calibre4">full listings of these structures, see </i> http://undocumented.ntinternals.net/ <i class="calibre4">. </i></p>
<p class="calibre1">Figure 19-1 shows the data structures that are typically followed in order to find the base address for  <i class="calibre4">kernel32.dll</i> (only relevant fields and offsets within each structure are shown). </p>
<p class="calibre1"><b class="calibre3">TEB</b></p>
<p class="calibre1">... </p>
<p class="calibre1">0x30: PPEB peb; </p>
<p class="calibre1"><b class="calibre3">PEB</b></p>
<p class="calibre1">... </p>
<p class="calibre1">... </p>
<p class="calibre1">0x0c: PPEB_LDR_data ldr; </p>
<p class="calibre1">... </p>
<p class="calibre1"><b class="calibre3">PEB_LDR_Data</b></p>
<p class="calibre1">... </p>
<p class="calibre1">0x0c: LIST_ENTRY InLoadOrderLinks; </p>
<p class="calibre1">0x14: LIST_ENTRY InMemoryOrderLinks; </p>
<p class="calibre1">0x1c: LIST_ENTRY InInitializationOrderLinks; </p>
<p class="calibre1">... </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">ntdll.dll</b></i><b class="calibre3"> LDR_DATA_TABLE_ENTRY</b></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">kernel32.dll</b></i><b class="calibre3"> LDR_DATA_TABLE_ENTRY</b></p>
<p class="calibre1">0x00: LIST_ENTRY InLoadOrderLinks; </p>
<p class="calibre1">0x00: LIST_ENTRY InLoadOrderLinks; </p>
<p class="calibre1">0x08: LIST_ENTRY InMemoryOrderLinks; </p>
<p class="calibre1">0x08: LIST_ENTRY InMemoryOrderLinks; </p>
<p class="calibre1">0x10: LIST_ENTRY InInitializationOrderLinks; </p>
<p class="calibre1">0x10: LIST_ENTRY InInitializationOrderLinks; </p>
<p class="calibre1">... </p>
<p class="calibre1">0x18: PVOID DllBase; </p>
<p class="calibre1">... </p>
<p class="calibre1">0x24: UNICODE_STRING FullDllName; </p>
<p class="calibre1"> <i class="calibre4">Figure 19-1: Structure traversal to find </i> kernel32.dll <i class="calibre4"> DllBase</i> The process begins with the TEB, accessible from the FS segment register. Offset 0x30 within the TEB is the pointer to the PEB. Offset 0xc within the PEB is the pointer to the PEB_LDR_DATA structure, which contains three doubly linked lists of LDR_DATA_TABLE structures—one for each loaded module. </p>
<p class="calibre1">The DllBase field in the  <i class="calibre4">kernel32.dll</i> entry is the value we’re seeking. </p>
<p class="calibre1">Three LIST_ENTRY structures link the LDR_DATA_TABLE entries together in different orders, by name. The InInitializationOrderLinks entry is typically followed by shellcode. From Windows 2000 through Vista,  <i class="calibre4">kernel32.dll</i> is the second DLL initialized, just after  <i class="calibre4">ntdll.dll</i>, which means that the second entry in the InInitializationOrderLinks list of structures should belong to <i class="calibre4">kernel32.dll</i>. However, beginning with Windows 7,  <i class="calibre4">kernel32.dll</i> is no longer the second module to be initialized, so this simple algorithm no longer works. Portable shellcode will instead need to examine the UNICODE_STRING </p>
<p class="calibre1">FullDllName field to confirm it is  <i class="calibre4">kernel32.dll</i>. </p>
<p class="calibre1">When traversing the LIST_ENTRY structures, it is important to realize that the Flink and Blink pointers point to the equivalent LIST_ENTRY in the next and previous LDR_DATA_TABLE structures. This means that when following the InInitializationOrderLinks to get to  <i class="calibre4">kernel32.dll</i>’s LDR_DATA_TABLE_ENTRY, you need to add only eight to the pointer to get the DllBase, instead of adding 0x18, which you would have to do if the pointer pointed to the start of the structure. </p>
<p class="calibre1"><b class="calibre3">414</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p448"/>Listing 19-4 contains sample assembly code that finds the base address of <i class="calibre4">kernel32.dll. </i></p>
<p class="calibre1">; __stdcall DWORD findKernel32Base(void); </p>
<p class="calibre1">findKernel32Base:</p>
<p class="calibre1">push    esi</p>
<p class="calibre1">xor     eax, eax</p>
<p class="calibre1">mov     eax, [fs:eax+0x30]   ; eax gets pointer to PEB</p>
<p class="calibre1">test    eax, eax            </p>
<p class="calibre1">; if high bit set: Win9x</p>
<p class="calibre1">js      .kernel32_9x </p>
<p class="calibre1">mov     eax, [eax + 0x0c] </p>
<p class="calibre1">; eax gets pointer to PEB_LDR_DATA</p>
<p class="calibre1">;esi gets pointer to 1st</p>
<p class="calibre1">;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink</p>
<p class="calibre1">mov     esi, [eax + 0x1c]</p>
<p class="calibre1">;eax gets pointer to 2nd</p>
<p class="calibre1">;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink</p>
<p class="calibre1">lodsd </p>
<p class="calibre1">mov     eax, [eax + 8]      </p>
<p class="calibre1">; eax gets LDR_DATA_TABLE_ENTRY.DllBase</p>
<p class="calibre1">jmp     near .finished</p>
<p class="calibre1">.kernel32_9x:</p>
<p class="calibre1">jmp     near .kernel32_9x </p>
<p class="calibre1">; Win9x not supported: infinite loop</p>
<p class="calibre1">.finished:</p>
<p class="calibre1">pop     esi</p>
<p class="calibre1">ret</p>
<p class="calibre1"> <i class="calibre4">Listing 19-4: findKernel32Base implementation</i></p>
<p class="calibre1">The listing accesses the TEB using the FS segment register at  to get the pointer to the PEB. The js ( jump if signed) instruction at  is used to test whether the most significant bit of the PEB pointer is set, in order to differentiate between Win9x and WinNT systems. In WinNT (including Windows 2000, XP, and Vista), the most significant bit of the PEB pointer is typically never set, because high memory addresses are reserved for the OS. </p>
<p class="calibre1">Using the sign bit to identify the OS family fails on systems that use the /3GB </p>
<p class="calibre1">boot option, which causes the user-level/kernel-level memory split to occur at 0xC0000000 instead of 0x8000000, but this is ignored for this simple example. This shellcode chose not to support Win9x, so it enters an infinite loop at  if Win9x is detected. </p>
<p class="calibre1">The shellcode proceeds to PEB_LDR_DATA at . It assumes that it is running under Windows Vista or earlier, so it can simply retrieve the second LDR_DATA_TABLE_ENTRY in the InInitializationOrderLinks linked list at  and return its DllBase field. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Parsing PE Export Data</b></i></p>
<p class="calibre1">Once you find the base address for  <i class="calibre4">kernel32.dll</i>, you must parse it to find exported symbols. As with finding the location of  <i class="calibre4">kernel32.dll</i>, this process involves following several structures in memory. </p>
<p class="calibre1">Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">415</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p449"/>PE files use relative virtual addresses (RVAs) when defining locations within a file. These addresses can be thought of as offsets within the PE </p>
<p class="calibre1">image in memory, so the PE image base address must be added to each RVA to turn it into a valid pointer. </p>
<p class="calibre1">The export data is stored in IMAGE_EXPORT_DIRECTORY. An RVA to this is stored in the array of IMAGE_DATA_DIRECTORY structures at the end of the IMAGE_OPTIONAL_HEADER. The location of the IMAGE_DATA_DIRECTORY array depends on whether the PE file is for a 32-bit application or a 64-bit application. </p>
<p class="calibre1">Typical shellcode assumes it is running on a 32-bit platform, so it knows at compile time that the correct offset from the PE signature to the directory array is as follows:</p>
<p class="calibre1">sizeof(PE_Signature) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER) = 120 bytes The relevant fields in the IMAGE_EXPORT_DIRECTORY structure are shown in Figure 19-2. AddressOfFunctions is an array of RVAs that points to the actual export functions. It is indexed by an export ordinal (an alternative way of finding an exported symbol). </p>
<p class="calibre1">The shellcode needs to map the export name to the ordinal in order to use this array, and it does so using the AddressOfNames and AddressOfNameOrdinals arrays. These two arrays exist in parallel. They have the same number of entries, and equivalent indices into these arrays are directly related. </p>
<p class="calibre1">AddressOfNames is an array of 32-bit RVAs that point to the strings of symbol names. AddressOfNameOrdinals is an array of 16-bit ordinals. For a given index idx into these arrays, the symbol at AddressOfNames[idx] has the export ordinal value at AddressOfNameOrdinals[idx]. The AddressOfNames array is sorted alpha-betically so that a binary search can quickly find a specific string, though most shellcode simply performs a linear search starting at the beginning of the array. </p>
<p class="calibre1">To find the export address of a symbol, follow these steps: 1. </p>
<p class="calibre1">Iterate over the AddressOfNames array looking at each char* entry, and perform a string comparison against the desired symbol until a match is found. Call this index into AddressOfNames iName. </p>
<p class="calibre1">2. </p>
<p class="calibre1">Index into the AddressOfNameOrdinals array using iName. The value retrieved is the value iOrdinal. </p>
<p class="calibre1">3. </p>
<p class="calibre1">Use iOrdinal to index into the AddressOfFunctions array. The value retrieved is the RVA of the exported symbol. Return this value to the requester. </p>
<p class="calibre1">A sample implementation of this algorithm is shown later in the chapter as part of a full Hello World example. </p>
<p class="calibre1"><b class="calibre3">416</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p450"/>;BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie) mov  edi, edi</p>
<p class="calibre1">push ebp</p>
<p class="calibre1">mov  ebp, esp</p>
<p class="calibre1">... </p>
<p class="calibre1">;ATOM __stdcall AddAtomA(LPCSTR lpString)</p>
<p class="calibre1">mov  edi, edi</p>
<p class="calibre1">push ebp</p>
<p class="calibre1">mov  ebp, esp</p>
<p class="calibre1">... </p>
<p class="calibre1">;ATOM __stdcall AddAtomW(LPCWSTR lpString)</p>
<p class="calibre1">mov  edi, edi</p>
<p class="calibre1">push ebp</p>
<p class="calibre1">mov  ebp, esp</p>
<p class="calibre1">... </p>
<p class="calibre1">... </p>
<p class="calibre1"><b class="calibre3">IMAGE_EXPORT_DIRECTORY</b></p>
<p class="calibre1">"ActivateActCtx" </p>
<p class="calibre1">"lstrln" </p>
<p class="calibre1">"AddAtomA" </p>
<p class="calibre1">"lstrlnA" </p>
<p class="calibre1">... </p>
<p class="calibre1">"AddAtomW" </p>
<p class="calibre1">"lstrlnW" </p>
<p class="calibre1">0x18: NumberOfNames</p>
<p class="calibre1">0x1c: AddressOfFunctions</p>
<p class="calibre1">0x20: AddressOfNames</p>
<p class="calibre1">0x24: AddressOfNameOrdinals</p>
<p class="calibre1">... </p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">... </p>
<p class="calibre1">3b6</p>
<p class="calibre1">3b7</p>
<p class="calibre1">3b8</p>
<p class="calibre1"> <i class="calibre4">Figure 19-2: </i> kernel32.dll <i class="calibre4"> IMAGE_EXPORT_DIRECTORY</i></p>
<p class="calibre1">Once the shellcode finds LoadLibraryA, it can load arbitrary libraries. The return value of LoadLibraryA is treated as a HANDLE in the Win32 API. Examining the HANDLE values shows that it is actually a 32-bit pointer to the dllBase of the library that was loaded, which means that the shellcode can skip using GetProcAddress and continue using its own PE parsing code with the dllBase pointers returned from LoadLibraryA (which is also beneficial when hashed names are used, as explained in the next section). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using Hashed Exported Names</b></i></p>
<p class="calibre1">The algorithm just discussed has a weakness: It performs a strcmp against each export name until it finds the correct one. This requires that the full name of each API function the shellcode uses be included as an ASCII string. </p>
<p class="calibre1">When the size of the shellcode is constrained, these strings could push the size of the shellcode over the limit. </p>
<p class="calibre1">Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">417</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p451"/>A common way to address this problem is to calculate a hash of each symbol string and compare the result with a precomputed value stored in the shellcode. The hash function does not need to be sophisticated; it only needs to guarantee that within each DLL used by the shellcode, the hashes that the shellcode uses are unique. Hash collisions between symbols in different DLLs and between symbols the shellcode does not use are fine. </p>
<p class="calibre1">The most common hash function is the 32-bit rotate-right-additive hash, as shown in Listing 19-5. </p>
<p class="calibre1">; __stdcall DWORD hashString(char* symbol); </p>
<p class="calibre1">hashString:</p>
<p class="calibre1">push    esi</p>
<p class="calibre1">push    edi</p>
<p class="calibre1">mov     esi, dword [esp+0x0c]   ; load function argument in esi</p>
<p class="calibre1">.calc_hash:</p>
<p class="calibre1">xor     edi, edi </p>
<p class="calibre1">cld</p>
<p class="calibre1">.hash_iter:</p>
<p class="calibre1">xor     eax, eax</p>
<p class="calibre1">lodsb                 </p>
<p class="calibre1">; load next byte of input string</p>
<p class="calibre1">cmp     al, ah</p>
<p class="calibre1">je      .hash_done              ; check if at end of symbol ror     edi, 0x0d </p>
<p class="calibre1">; rotate right 13 (0x0d)</p>
<p class="calibre1">add     edi, eax</p>
<p class="calibre1">jmp     near .hash_iter</p>
<p class="calibre1">.hash_done:</p>
<p class="calibre1">mov     eax, edi</p>
<p class="calibre1">pop     edi</p>
<p class="calibre1">pop     esi</p>
<p class="calibre1">retn    4</p>
<p class="calibre1"> <i class="calibre4">Listing 19-5: hashString implementation</i></p>
<p class="calibre1">This function calculates a 32-bit DWORD hash value of the string pointer argument. The EDI register is treated as the current hash value, and is initialized to zero at . Each byte of the input string is loaded via the lodsb instruction at . If the byte is not NULL, the current hash is rotated right by 13 (0x0d) at , and the current byte is added into the hash. This hash is returned in EAX so that its caller can compare the result with the value compiled into the code. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">The particular algorithm in Listing 19-5 has become commonly used due to its inclusion in Metasploit, but variations that use different rotation amounts and hash sizes</i> <i class="calibre4">are sometimes seen. </i></p>
<p class="calibre1"><b class="calibre3">A Full Hello World Example</b></p>
<p class="calibre1">Listing 19-6 shows a full implementation of the findSymbolByHash function that can be used to find exported symbols in loaded DLLs. </p>
<p class="calibre1"><b class="calibre3">418</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p452"/>; __stdcall DWORD findSymbolByHash(DWORD dllBase, DWORD symHash); findSymbolByHash:</p>
<p class="calibre1">pushad</p>
<p class="calibre1">mov     ebp, [esp + 0x24]       ; load 1st arg: dllBase</p>
<p class="calibre1">mov     eax, [ebp + 0x3c]  </p>
<p class="calibre1">; get offset to PE signature</p>
<p class="calibre1">; load edx w/ DataDirectories array: assumes PE32</p>
<p class="calibre1">mov     edx, [ebp + eax + 4+20+96] </p>
<p class="calibre1">add     edx, ebp                ; edx:= addr IMAGE_EXPORT_DIRECTORY</p>
<p class="calibre1">mov     ecx, [edx + 0x18]     ; ecx:= NumberOfNames</p>
<p class="calibre1">mov     ebx, [edx + 0x20]       ; ebx:= RVA of AddressOfNames add     ebx, ebp                ; rva-&gt;va</p>
<p class="calibre1">.search_loop:</p>
<p class="calibre1">jecxz   .error_done             ; if at end of array, jmp to done dec     ecx                     ; dec loop counter</p>
<p class="calibre1">; esi:= next name, uses ecx*4 because each pointer is 4 bytes mov     esi, [ebx+ecx*4]        </p>
<p class="calibre1">add     esi, ebp                ; rva-&gt;va</p>
<p class="calibre1">push    esi       </p>
<p class="calibre1">call    hashString  </p>
<p class="calibre1">; hash the current string</p>
<p class="calibre1">; check hash result against arg #2 on stack: symHash</p>
<p class="calibre1">cmp     eax, [esp + 0x28] </p>
<p class="calibre1">jnz     .search_loop</p>
<p class="calibre1">; at this point we found the string in AddressOfNames</p>
<p class="calibre1">mov     ebx, [edx+0x24]         ; ebx:= ordinal table rva add     ebx, ebp                ; rva-&gt;va</p>
<p class="calibre1">; turn cx into ordinal from name index. </p>
<p class="calibre1">; use ecx*2: each value is 2 bytes</p>
<p class="calibre1">mov     cx, [ebx+ecx*2] </p>
<p class="calibre1">mov     ebx, [edx+0x1c]         ; ebx:= RVA of AddressOfFunctions add     ebx, ebp                ; rva-&gt;va</p>
<p class="calibre1">; eax:= Export function rva. Use ecx*4: each value is 4 bytes mov     eax, [ebx+ecx*4]         </p>
<p class="calibre1">add     eax, ebp                ; rva-&gt;va</p>
<p class="calibre1">jmp     near .done</p>
<p class="calibre1">.error_done:</p>
<p class="calibre1">xor     eax, eax                ; clear eax on error</p>
<p class="calibre1">.done:</p>
<p class="calibre1">mov     [esp + 0x1c], eax  </p>
<p class="calibre1">; overwrite eax saved on stack</p>
<p class="calibre1">popad</p>
<p class="calibre1">retn    8</p>
<p class="calibre1"> <i class="calibre4">Listing 19-6: findSymbolByHash implementation</i></p>
<p class="calibre1">The function takes as arguments a pointer to the base of the DLL and a 32-bit hash value that corresponds to the symbol to find. It returns the pointer to the requested function in register EAX. Remember that all addresses in a PE file are stored as RVAs, so code needs to continuously add the dllBase value (kept in register EBP in this example) to the RVAs retrieved from PE </p>
<p class="calibre1">structures to create pointers it can actually use. </p>
<p class="calibre1">The code begins parsing the PE file at  to get the pointer to the PE </p>
<p class="calibre1">signature. A pointer to IMAGE_EXPORT_DIRECTORY is created at  by adding the correct offset, assuming this is a 32-bit PE file. The code begins parsing the Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">419</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p453"/>IMAGE_EXPORT_DIRECTORY structure at , loading the NumberOfNames value and the AddressOfNames pointer. Each string pointer in AddressOfNames is passed to the hashString function at , and the result of this calculation is compared against the value passed as the function argument at . </p>
<p class="calibre1">Once the correct index into AddressOfNames is found, it is used as an index into the AddressOfNameOrdinals array at location  to obtain the corresponding ordinal value, which is used as an index into the AddressOfFunctions array at . This is the value the user wants, so it is written to the stack at , overwriting the EAX value saved by the pushad instruction so that this value is preserved by the following popad instruction. </p>
<p class="calibre1">Listing 19-7 shows a complete Hello World shellcode example that uses the previously defined findKernel32Base and findSymbolByHash functions, instead of relying on hard-coded API locations. </p>
<p class="calibre1">mov     ebp, esp</p>
<p class="calibre1">sub     esp, 24h</p>
<p class="calibre1">call    sub_A0             ; call to real start of code db 'user32',0   </p>
<p class="calibre1">db 'Hello World!!!!',0</p>
<p class="calibre1">sub_A0:</p>
<p class="calibre1">pop     ebx                 ; ebx gets pointer to data</p>
<p class="calibre1">call    findKernel32Base </p>
<p class="calibre1">mov     [ebp-4], eax        ; store kernel32 base address push    0EC0E4E8Eh          ; LoadLibraryA hash</p>
<p class="calibre1">push    dword ptr [ebp-4]</p>
<p class="calibre1">call    findSymbolByHash </p>
<p class="calibre1">mov     [ebp-14h], eax      ; store LoadLibraryA location lea     eax, [ebx]        ; eax points to "user32" </p>
<p class="calibre1">push    eax</p>
<p class="calibre1">call    dword ptr [ebp-14h] ; LoadLibraryA</p>
<p class="calibre1">mov     [ebp-8], eax        ; store user32 base address</p>
<p class="calibre1">push    0BC4DA2A8h        ; MessageBoxA hash</p>
<p class="calibre1">push    dword ptr [ebp-8]   ; user32 dll location</p>
<p class="calibre1">call    findSymbolByHash</p>
<p class="calibre1">mov     [ebp-0Ch], eax      ; store MessageBoxA location push    73E2D87Eh           ; ExitProcess hash</p>
<p class="calibre1">push    dword ptr [ebp-4]   ; kernel32 dll location</p>
<p class="calibre1">call    findSymbolByHash</p>
<p class="calibre1">mov     [ebp-10h], eax      ; store ExitProcess location xor     eax, eax</p>
<p class="calibre1">lea     edi, [ebx+7]        ; edi:= "Hello World!!!!" pointer push    eax                 ; uType: MB_OK</p>
<p class="calibre1">push    edi                 ; lpCaption</p>
<p class="calibre1">push    edi                 ; lpText</p>
<p class="calibre1">push    eax                 ; hWnd: NULL</p>
<p class="calibre1">call    dword ptr [ebp-0Ch] ; call MessageBoxA</p>
<p class="calibre1">xor     eax, eax</p>
<p class="calibre1">push    eax                 ; uExitCode</p>
<p class="calibre1">call    dword ptr [ebp-10h] ; call ExitProcess</p>
<p class="calibre1"> <i class="calibre4">Listing 19-7: Position-independent Hello World</i></p>
<p class="calibre1"><b class="calibre3">420</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p454"/>The code begins by using a call/pop at  to obtain a pointer to the data starting at . It then calls findKernel32Base at  to find  <i class="calibre4">kernel32.dll</i> and calls findSymbolByHash at  to find the export in  <i class="calibre4">kernel32.dll</i> with the hash 0xEC0E4E8E. This is the ror-13-additive hash of the string LoadLibraryA. </p>
<p class="calibre1">When this function returns EAX, it will point to the actual memory location for LoadLibraryA. </p>
<p class="calibre1">The code loads a pointer to the "user32" string at  and calls the LoadLibraryA function. It then finds the exported function MessageBoxA at  </p>
<p class="calibre1">and calls it to display the “Hello World!!!!” message. Finally, it calls ExitProcess to cleanly exit. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Using the shellcode’s PE parsing ability instead of GetProcAddress has the additional</i> <i class="calibre4">benefit of making reverse-engineering of the shellcode more difficult. The hash values</i> <i class="calibre4">hide the API calls used from casual inspection. </i></p>
<p class="calibre1"><b class="calibre3">Shellcode Encodings</b></p>
<p class="calibre1">In order to execute, the shellcode binary must be located somewhere in the program’s address space when it is triggered. When paired with an exploit, this means that the shellcode must be present before the exploit occurs or be passed along with the exploit. For example, if the program is performing some basic filtering on input data, the shellcode must pass this filter, or it will not be in the vulnerable process’s memory space. This means that shellcode often must look like legitimate data in order to be accepted by a vulnerable program. </p>
<p class="calibre1">One example is a program that uses the unsafe string functions strcpy and strcat, both of which do not set a maximum length on the data they write. If a program reads or copies malicious data into a fixed-length buffer using either of these functions, the data can easily exceed the size of the buffer and lead to a buffer-overflow attack. These functions treat strings as an array of characters terminated by a NULL (0x00) byte. Shellcode that an attacker wants copied into this buffer must look like valid data, which means that it must not have any NULL bytes in the middle that would prematurely end the string-copy operation. </p>
<p class="calibre1">Listing 19-8 shows a small piece of disassembly of code used to access the registry, with seven NULL bytes in this selection alone. This code could typically not be used as-is in a shellcode payload. </p>
<p class="calibre1">57                  push    edi</p>
<p class="calibre1">50                  push    eax             ; phkResult</p>
<p class="calibre1">6A 01               push    1               ; samDesired 8D 8B D0 13 <b class="calibre3">00 00   </b>lea     ecx, [ebx+13D0h]</p>
<p class="calibre1">6A <b class="calibre3">00  </b>             push    0               ; ulOptions 51                  push    ecx             ; lpSubKey</p>
<p class="calibre1">68 02 <b class="calibre3">00 00 </b>80      push    80000002h       ; hKey: HKEY_LOCAL_MACHINE</p>
<p class="calibre1">FF 15 20 <b class="calibre3">00</b> 42 <b class="calibre3">00</b>   call    ds:RegOpenKeyExA <i class="calibre4">Listing 19-8: Typical code with highlighted NULL bytes</i> Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">421</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p455"/>Programs may perform additional sanity checks on data that the shellcode must pass in order to succeed, such as the following:</p>
<p class="calibre1"></p>
<p class="calibre1">All bytes are printable (less than 0x80) ASCII bytes. </p>
<p class="calibre1"></p>
<p class="calibre1">All bytes are alphanumeric ( <i class="calibre4">A</i> through  <i class="calibre4">Z</i>,  <i class="calibre4">a</i> through  <i class="calibre4">z</i>, or 0 through 9). </p>
<p class="calibre1">To overcome filtering limitations by the vulnerable program, nearly all shellcode encodes the main payload to pass the vulnerable program’s filter and inserts a decoder that turns the encoded payload into executable bytes. </p>
<p class="calibre1">Only the small decoder section must be written carefully so that its instruction bytes will pass the strict filter requirements; the rest of the payload can be encoded at compile time to also pass the filter. If the shellcode writes the decoded bytes back on top of the encoded bytes (as usual), the shellcode is self-modifying. When the decoding is complete, the decoder transfers control to the main payload to execute. </p>
<p class="calibre1">The following are common encoding techniques:</p>
<p class="calibre1"></p>
<p class="calibre1">XOR all payload bytes with constant byte mask. Remember that for all values of the same size  <i class="calibre4">a</i>,  <i class="calibre4">b</i> that ( <i class="calibre4">a</i> XOR  <i class="calibre4">b</i>) XOR  <i class="calibre4">b</i> ==  <i class="calibre4">a</i>. </p>
<p class="calibre1"></p>
<p class="calibre1">Use an alphabetic transform where a single byte of payload is split into two 4-bit nibbles and added to a printable ASCII character (such as  <i class="calibre4">A</i> or  <i class="calibre4">a</i>). </p>
<p class="calibre1">Shellcode encodings have additional benefits for the attackers, in that they make analysis more difficult by hiding human-readable strings such as URLs or IP addresses. Also, they may help evade network IDSs. </p>
<p class="calibre1"><b class="calibre3">NOP Sleds</b></p>
<p class="calibre1">A  <i class="calibre4">NOP sled</i> (also known as a  <i class="calibre4">NOP slide</i>) is a long sequence of instructions preceding shellcode, as shown in Figure 19-3. NOP sleds are not required to be present with shellcode, but they are often included as part of an exploit to increase the likelihood of the exploit succeeding. Shellcode authors can do this by creating a large NOP sled immediately preceding the shellcode. As long as execution is directed somewhere within the NOP sled, the shellcode will eventually run. </p>
<p class="calibre1">Jump Location</p>
<p class="calibre1">NOP Sled</p>
<p class="calibre1">Decoder</p>
<p class="calibre1">Encoded Payload</p>
<p class="calibre1"> <i class="calibre4">Figure 19-3: NOP sled and shellcode layout</i></p>
<p class="calibre1">Traditional NOP sleds are made up of long sequences of the NOP (0x90) instruction, but exploit authors can be creative in order to avoid detection. </p>
<p class="calibre1">Other popular opcodes are in the 0x40 to 0x4f range. These opcodes are single-byte instructions that increment or decrement the general-purpose registers. </p>
<p class="calibre1"><b class="calibre3">422</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p456"/>This opcode byte range also consists of only printable ASCII characters. This is often useful because the NOP sled executes before the decoder runs, so it must pass the same filtering requirements as the rest of the shellcode. </p>
<p class="calibre1"><b class="calibre3">Finding Shellcode</b></p>
<p class="calibre1">Shellcode can be found in a variety of sources, including network traffic, web pages, media files, and malware. Because it is not always possible to create an environment with the correct version of the vulnerable program that the exploit targets, the malware analyst must try to reverse-engineer shellcode using only static analysis. </p>
<p class="calibre1">Malicious web pages typically use JavaScript to profile a user’s system and check for vulnerable versions of the browser and installed plug-ins. </p>
<p class="calibre1">The JavaScript unescape is typically used to convert the encoded shellcode text into a binary package suitable for execution. Shellcode is often stored as an encoded text string included with the script that triggers the exploit. </p>
<p class="calibre1">The encoding understood by unescape treats the text %u <i class="calibre4">XXYY</i> as an encoded big-endian Unicode character, where  <i class="calibre4">XX</i> and  <i class="calibre4">YY</i> are hex values. On little-endian machines (such as x86), the byte sequence  <i class="calibre4">YY</i>  <i class="calibre4">XX</i> will be the result after decoding. For example, consider this text string:</p>
<p class="calibre1">%u1122%u3344%u5566%u7788%u99aa%ubbcc%uddee </p>
<p class="calibre1">It will be decoded to the following binary byte sequence: 22 11 44 33 66 55 88 77 aa 99 cc bb ee dd</p>
<p class="calibre1">A % symbol that is not immediately followed by the letter u is treated as a single encoded hex byte. For example, the text string %41%42%43%44 will be decoded to the binary byte sequence 41 42 43 44. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Both single- and double-byte encoded characters can be used within the same text string. </i></p>
<p class="calibre1"> <i class="calibre4">This is a popular technique wherever JavaScript is used, including in PDF documents. </i></p>
<p class="calibre1">Shellcode used within a malicious executable is usually easy to identify because the entire program will be written using shellcode techniques as obfuscation, or a shellcode payload will be stored within the malware and will be injected into another process. </p>
<p class="calibre1">The shellcode payload is usually found by looking for the typical process-injection API calls discussed in Chapter 12: VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread. The buffer written into the other process probably contains shellcode if the malware launches a remote thread without applying relocation fix-ups or resolving external dependencies. This may be convenient for the malware writer, since shellcode can bootstrap itself and execute without help from the originating malware. </p>
<p class="calibre1">Sometimes shellcode is stored unencoded within a media file. Disassemblers such as IDA Pro can load arbitrary binary files, including those suspected of containing shellcode. However, even if IDA Pro loads the file, it may not analyze the shellcode, because it does not know which bytes are valid code. </p>
<p class="calibre1">Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">423</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p457"/>Finding shellcode usually means searching for the initial decoder that is likely present at the start of the shellcode. Useful opcodes to search for are listed in Table 19-2. </p>
<p class="calibre1"><b class="calibre3">Table 19-2: </b>Some Opcode Bytes to Search For</p>
<p class="calibre1"><b class="calibre3">Instruction type</b></p>
<p class="calibre1"><b class="calibre3">Common opcodes</b></p>
<p class="calibre1">Call</p>
<p class="calibre1">0xe8</p>
<p class="calibre1">Unconditional jumps</p>
<p class="calibre1">0xeb, 0xe9</p>
<p class="calibre1">Loops</p>
<p class="calibre1">0xe0, 0xe1, 0xe2</p>
<p class="calibre1">Short conditional jumps</p>
<p class="calibre1">0x70 through 0x7f</p>
<p class="calibre1">Attempt to disassemble each instance of the opcodes listed in Table 19-2 </p>
<p class="calibre1">in the loaded file. Any valid code should be immediately obvious. Just remember that the payload is likely encoded, so only the decoder will be visible at first. </p>
<p class="calibre1">If none of those searches work, there may still be embedded shellcode, because some file formats allow for encoded embedded data. For example, exploits targeting the CVE-2010-0188 critical vulnerability in Adobe Reader use malformed TIFF images, embedded within PDFs, stored as a Base64-encoded string, which may be zlib-compressed. When working with particular file formats, you will need to be familiar with that format and the kind of data it can contain in order to search for malicious content. </p>
<p class="calibre1"><b class="calibre3">Conclusion</b></p>
<p class="calibre1">Shellcode authors must employ techniques to work around inherent limitations of the odd runtime environment in which shellcode executes. This includes identifying where in memory the shellcode is executing and manually resolving all of the shellcode’s external dependencies so that it can interact with the system. To save on space, these dependencies are usually obfuscated by using hash values instead of ASCII function names. It is also common for nearly the entire shellcode to be encoded so that it bypasses any data filtering by the targeted process. All of these techniques can easily frustrate beginning analysts, but the material in this chapter should help you recognize these common activities, so you can instead focus on understanding the main functionality of the shellcode. </p>
<p class="calibre1"><b class="calibre3">424</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p458"/><b class="calibre3">L A B S</b></p>
<p class="calibre1">In these labs, we’ll use what we’ve covered in Chapter 19 to analyze samples inspired by real shellcode. Because a debugger cannot easily load and run shellcode directly, we’ll use a utility called  <i class="calibre4">shellcode_launcher.exe</i> to dynamically analyze shellcode binaries. You’ll find instructions on how to use this utility in Chapter 19 and in the detailed analyses in Appendix C. </p>
<p class="calibre1"><b class="calibre3">Lab 19-1</b></p>
<p class="calibre1">Analyze the file  <i class="calibre4">Lab19-01.bin</i> using  <i class="calibre4">shellcode_launcher.exe</i>. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">How is the shellcode encoded? </p>
<p class="calibre1">2. </p>
<p class="calibre1">Which functions does the shellcode manually import? </p>
<p class="calibre1">3. </p>
<p class="calibre1">What network host does the shellcode communicate with? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What filesystem residue does the shellcode leave? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What does the shellcode do? </p>
<p class="calibre1"><b class="calibre3">Lab 19-2</b></p>
<p class="calibre1">The file  <i class="calibre4">Lab19-02.exe</i> contains a piece of shellcode that will be injected into another process and run. Analyze this file. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What process is injected with the shellcode? </p>
<p class="calibre1">2. </p>
<p class="calibre1">Where is the shellcode located? </p>
<p class="calibre1">3. </p>
<p class="calibre1">How is the shellcode encoded? </p>
<p class="calibre1">4. </p>
<p class="calibre1">Which functions does the shellcode manually import? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What network hosts does the shellcode communicate with? </p>
<p class="calibre1">6. </p>
<p class="calibre1">What does the shellcode do? </p>
<p class="calibre1"><b class="calibre3">Lab 19-3</b></p>
<p class="calibre1">Analyze the file  <i class="calibre4">Lab19-03.pdf</i>. If you get stuck and can’t find the shellcode, just skip that part of the lab and analyze file  <i class="calibre4">Lab19-03_sc.bin</i> using <i class="calibre4"> </i></p>
<p class="calibre1"> <i class="calibre4">shellcode_launcher.exe</i>. </p>
<p class="calibre1">Shellcode Analysis</p>
<p class="calibre1"><b class="calibre3">425</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p459"/> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What exploit is used in this PDF? </p>
<p class="calibre1">2. </p>
<p class="calibre1">How is the shellcode encoded? </p>
<p class="calibre1">3. </p>
<p class="calibre1">Which functions does the shellcode manually import? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What filesystem residue does the shellcode leave? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What does the shellcode do? </p>
<p class="calibre1"><b class="calibre3">426</b></p>
<p class="calibre1">Chapter 19</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p460"/><b class="calibre3">C + +   A N A L Y S I S</b></p>
<p class="calibre1">Malware analysis is conducted without access to source </p>
<p class="calibre1">code, but the specific source language has a significant impact on the assembly. For example, C++ has several </p>
<p class="calibre1">features and constructs that do not exist in C, and </p>
<p class="calibre1">these can complicate analysis of the resulting assembly. </p>
<p class="calibre1">Malicious programs written in C++ create challenges for the malware analyst that make it harder to determine the purpose of assembly code. </p>
<p class="calibre1">Understanding basic C++ features and how they appear in assembly language is critical to analyzing malware written in C++. </p>
<p class="calibre1"><b class="calibre3">Object-Oriented Programming</b></p>
<p class="calibre1">Unlike C, C++ is an object-oriented programming language, following a programming model that uses objects that contain data as well as functions to manipulate the data. The functions in object-oriented programming are like functions in C programs, except that they are associated with a particular object or class of objects. Functions within a C++ class are often called  <i class="calibre4">methods</i> </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p461"/>to draw a distinction. Although many features of object-oriented programming are irrelevant to malware analysis because they do not impact the assembly, a few can complicate analysis. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">To learn more about C++, consider reading </i> Thinking in C++ <i class="calibre4"> by Bruce Eckel, available as a free download from </i> http://www.mindviewinc.com/ <i class="calibre4">. </i></p>
<p class="calibre1">In object-orientation, code is arranged in user-defined data types called <i class="calibre4">classes</i>. Classes are like structs, except that they store function information in addition to data. Classes are like a blueprint for creating an object—one that specifies the functions and data layout for an object in memory. </p>
<p class="calibre1">When executing object-oriented C++ code, you use the class to create an object of the class. This object is referred to as an  <i class="calibre4">instance</i> of the class. You can have multiple instances of the same class. Each instance of a class has its own data, but all objects of the same type share the same functions. To access data or call a function, you must reference an object of that type. </p>
<p class="calibre1">Listing 20-1 shows a simple C++ program with a class and a single object. </p>
<p class="calibre1">class SimpleClass {</p>
<p class="calibre1">public:</p>
<p class="calibre1">int x; </p>
<p class="calibre1">void HelloWorld() {</p>
<p class="calibre1">printf("Hello World\n"); </p>
<p class="calibre1">}</p>
<p class="calibre1">}; </p>
<p class="calibre1">int _tmain(int argc, _TCHAR* argv[])</p>
<p class="calibre1">{</p>
<p class="calibre1">SimpleClass myObject; </p>
<p class="calibre1">myObject.HelloWorld(); </p>
<p class="calibre1">}</p>
<p class="calibre1"> <i class="calibre4">Listing 20-1: A simple C++ class</i></p>
<p class="calibre1">In this example, the class is called SimpleClass. It has one data element, x, and a single function, HelloWorld. We create an instance of SimpleClass named myObject and call the HelloWorld function for that object. (The public keyword is a compiler-enforced abstraction mechanism with no impact on the assembly code.)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The this Pointer</b></i></p>
<p class="calibre1">As we have established, data and functions are associated with objects. In order to access a piece of data, you use the form  <i class="calibre4">ObjectName.variableName</i>. </p>
<p class="calibre1">Functions are called similarly with  <i class="calibre4">ObjectName.functionName</i>. For example, in Listing 20-1, if we wanted to access the x variable, we would use myObject.x. </p>
<p class="calibre1"><b class="calibre3">428</b></p>
<p class="calibre1">Chapter 20</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p462"/>In addition to accessing variables using the object name and the variable name, you can also access variables for the current object using only the variable name. Listing 20-2 shows an example. </p>
<p class="calibre1">class SimpleClass {</p>
<p class="calibre1">public:</p>
<p class="calibre1">int x; </p>
<p class="calibre1">void HelloWorld() {</p>
<p class="calibre1">if (x == 10) printf("X is 10.\n"); </p>
<p class="calibre1">}</p>
<p class="calibre1">... </p>
<p class="calibre1">}; </p>
<p class="calibre1">int _tmain(int argc, _TCHAR* argv[])</p>
<p class="calibre1">{</p>
<p class="calibre1">SimpleClass myObject; </p>
<p class="calibre1">myObject.x = 9; </p>
<p class="calibre1">myObject.HelloWorld(); </p>
<p class="calibre1">SimpleClass myOtherObject; </p>
<p class="calibre1">myOtherOject.x = 10; </p>
<p class="calibre1">myOtherObject.HelloWorld(); </p>
<p class="calibre1">}</p>
<p class="calibre1"> <i class="calibre4">Listing 20-2: A C++ example with the this pointer </i></p>
<p class="calibre1">In the HelloWorld function, the variable x is accessed as just x at , and not  <i class="calibre4">ObjectName</i>.x. That same variable, which refers to the same address in memory, is accessed in the main method at  using myObject.x. </p>
<p class="calibre1">Within the HelloWorld method, the variable can be accessed just as x because it is assumed to refer to the object that was used to call the function, which in the first case is myObject . Depending on which object is used to call the HelloWorld function, a different memory address storing the x variable will be accessed. For example, if the function were called with myOtherObject.HelloWorld, then an x reference at  would access a different memory location than when that is called with myObject.HelloWorld. The this pointer is used to keep track of which memory address to access when accessing the x variable. </p>
<p class="calibre1">The this pointer is implied in every variable access within a function that doesn’t specify an object; it is an implied parameter to every object function call. Within Microsoft-generated assembly code, the this parameter is usually passed in the ECX register, although sometimes ESI is used instead. </p>
<p class="calibre1">In Chapter 6, we covered the stdcall, cdecl, and fastcall calling conventions. The C++ calling convention for the this pointer is often called  <i class="calibre4">thiscall</i>. </p>
<p class="calibre1">Identifying the thiscall convention can be one easy way to identify object-oriented code when looking at disassembly. </p>
<p class="calibre1">C++ Analysis</p>
<p class="calibre1"><b class="calibre3">429</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p463"/>The assembly in Listing 20-3, generated from Listing 20-2, demonstrates the usage of the this pointer. </p>
<p class="calibre1">;Main Function</p>
<p class="calibre1">00401100                 push    ebp</p>
<p class="calibre1">00401101                 mov     ebp, esp</p>
<p class="calibre1">00401103                 sub     esp, 1F0h</p>
<p class="calibre1">00401109</p>
<p class="calibre1">mov     [ebp+var_10], offset off_404768</p>
<p class="calibre1">00401110</p>
<p class="calibre1">mov     [ebp+var_C], 9</p>
<p class="calibre1">00401117</p>
<p class="calibre1">lea     ecx, [ebp+var_10]</p>
<p class="calibre1">0040111A                 call    sub_4115D0</p>
<p class="calibre1">0040111F                 mov     [ebp+var_34], offset off_404768</p>
<p class="calibre1">00401126                 mov     [ebp+var_30], 0Ah</p>
<p class="calibre1">0040112D</p>
<p class="calibre1">lea     ecx, [ebp+var_34]</p>
<p class="calibre1">00401130                 call    sub_4115D0</p>
<p class="calibre1">;HelloWorld Function</p>
<p class="calibre1">004115D0                 push    ebp</p>
<p class="calibre1">004115D1                 mov     ebp, esp</p>
<p class="calibre1">004115D3                 sub     esp, 9Ch</p>
<p class="calibre1">004115D9                 push    ebx</p>
<p class="calibre1">004115DA                 push    esi</p>
<p class="calibre1">004115DB                 push    edi</p>
<p class="calibre1">004115DC                 mov   [ebp+var_4], ecx</p>
<p class="calibre1">004115DF                 mov   eax, [ebp+var_4]</p>
<p class="calibre1">004115E2                 cmp     dword ptr [eax+4], 0Ah</p>
<p class="calibre1">004115E6                 jnz     short loc_4115F6</p>
<p class="calibre1">004115E8                 push    offset aXIs10_  ; "X is 10.\n" </p>
<p class="calibre1">004115ED                 call    ds:__imp__printf</p>
<p class="calibre1"> <i class="calibre4">Listing 20-3: The this pointer shown in disassembly</i></p>
<p class="calibre1">The main method first allocates space on the stack. The beginning of the object is stored at var_10 on the stack at . The first data value stored in that object is the variable x, which is set at an offset of 4 from the beginning of the object. The value x is accessed at  and is labeled var_C by IDA Pro. </p>
<p class="calibre1">IDA Pro can’t determine whether the values are both part of the same object, and it labels x as a separate value. The pointer to the object is then placed into ECX for the function call . Within the HelloWorld function, the value of ECX is retrieved and used as the this pointer . Then at an offset of 4, the code accesses the value for x . When the main function calls HelloWorld for the second time, it loads a different pointer into ECX. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Overloading and Mangling</b></i></p>
<p class="calibre1">C++ supports a coding construct known as  <i class="calibre4">method overloading</i>, which is the ability to have multiple functions with the same name, but that accept different parameters. When the function is called, the compiler determines which version of the function to use based on the number and types of parameters used in the call, as shown in Listing 20-4. </p>
<p class="calibre1"><b class="calibre3">430</b></p>
<p class="calibre1">Chapter 20</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p464"/><img src="index-464_1.png" alt="Image 90" class="calibre2"/></p>
<p class="calibre1">LoadFile (String filename) {</p>
<p class="calibre1">... </p>
<p class="calibre1">}</p>
<p class="calibre1">LoadFile (String filename, int Options) {</p>
<p class="calibre1">... </p>
<p class="calibre1">}</p>
<p class="calibre1">Main () {</p>
<p class="calibre1">LoadFile ("c:\myfile.txt"); //Calls the first LoadFile function LoadFile ("c:\myfile.txt", GENERIC_READ); //Calls the second LoadFile</p>
<p class="calibre1">}</p>
<p class="calibre1"> <i class="calibre4">Listing 20-4: Function overloading example</i></p>
<p class="calibre1">As you can see in the listing, there are two LoadFile functions: one that takes only a string and another that takes a string and an integer. When the LoadFile function is called within the main method, the compiler selects the function to call based on the number of parameters supplied. </p>
<p class="calibre1">C++ uses a technique called  <i class="calibre4">name mangling</i> to support method overloading. In the PE file format, each function is labeled with only its name, and the function parameters are not specified in the compiled binary format. </p>
<p class="calibre1">To support overloading, the names in the file format are modified so that the name information includes the parameter information. For example, if a function called TestFunction is part of the SimpleClass class and accepts two integers as parameters, the mangled name of that function would be </p>
<p class="calibre1">?TestFunction@SimpleClass@@QAEXHH@Z. </p>
<p class="calibre1">The algorithm for mangling the names is compiler-specific, but IDA Pro can demangle the names for most compilers. For example, Figure 20-1 shows the function TestFunction. IDA Pro demangles the function and shows the original name and parameters. </p>
<p class="calibre1"> <i class="calibre4">Figure 20-1: IDA Pro listing of a demangled function name</i> The internal function names are visible only if there are symbols in the code you are analyzing. Malware usually has the internal symbols removed; however, some imported or exported C++ functions with mangled names may be visible in IDA Pro. </p>
<p class="calibre1">C++ Analysis</p>
<p class="calibre1"><b class="calibre3">431</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p465"/> <i class="calibre4"><b class="calibre3">Inheritance and Function Overriding</b></i></p>
<p class="calibre1"> <i class="calibre4">Inheritance</i> is an object-oriented programming concept in which parent-child relationships are established between classes. Child classes inherit functions and data from parent classes. A child class automatically has all the functions and data of the parent class, and usually defines additional functions and data. For example, Listing 20-5 shows a class called Socket. </p>
<p class="calibre1">class Socket {</p>
<p class="calibre1">... </p>
<p class="calibre1">public:</p>
<p class="calibre1">void setDestinationAddr (INetAddr * addr) {</p>
<p class="calibre1">... </p>
<p class="calibre1">}</p>
<p class="calibre1">... </p>
<p class="calibre1">}; </p>
<p class="calibre1">class UDPSocket : publicSocket {</p>
<p class="calibre1">public:</p>
<p class="calibre1">void sendData (char * buf, INetAddr * addr) {</p>
<p class="calibre1">    setDestinationAddr(addr)</p>
<p class="calibre1">... </p>
<p class="calibre1">}</p>
<p class="calibre1">... </p>
<p class="calibre1">}; </p>
<p class="calibre1"> <i class="calibre4">Listing 20-5: Inheritance example</i></p>
<p class="calibre1">The Socket class has a function to set the destination address, but it has no function to sendData because it’s not a specific type of socket. A child class called UDPSocket can send data and implements the sendData function at , and it can also call the setDestinationAddr function defined in the Socket class. </p>
<p class="calibre1">In Listing 20-5, the sendData function at  can call the setDestinationAddr function at  even though that function is not defined in the UDPSocket class, because the functionality of the parent class is automatically included in the child class. </p>
<p class="calibre1">Inheritance helps programmers more efficiently reuse code, but it’s a feature that does not require any runtime data structures and generally isn’t visible in assembly code. </p>
<p class="calibre1"><b class="calibre3">Virtual vs. Nonvirtual Functions</b></p>
<p class="calibre1">A  <i class="calibre4">virtual function</i> is one that can be overridden by a subclass and whose execution is determined at  <i class="calibre4">runtime</i>. If a function is defined within a parent class and a function with the same name is defined in a child class, the child class’s function overrides the parent’s function. </p>
<p class="calibre1">Several popular programming models use this functionality in order to greatly simplify complex programming tasks. To illustrate why this is useful, return to the socket example in Listing 20-5. There, we have code that is going to sendData over the network, and we want it to be able to send data via TCP and UDP. One easy way to accomplish this is to create a parent class <b class="calibre3">432</b></p>
<p class="calibre1">Chapter 20</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p466"/>called Socket with a virtual function called sendData. Then we have two chil-dren classes called UDPSocket and TCPSocket, which override the sendData function to send the data over the appropriate protocol. </p>
<p class="calibre1">In the code that uses the socket, we create an object of type Socket, and create whichever socket we are using in this instance. Each time we call the sendData function, the sendData function will be called from the proper subclass of Socket, whether UDPSocket or TCPSocket, based on which type of Socket object was originally created. </p>
<p class="calibre1">The biggest advantage here is that if a new protocol—QDP, for example—</p>
<p class="calibre1">is invented, you simply create a new QDPSocket class, and then change the line of code where the object is created. Then all calls to sendData will call the new QDPSocket version of sendData without the need to change all the calls individually. </p>
<p class="calibre1">In the case of nonvirtual functions, the function to be executed is determined at compile time. If the object is an instance of the parent class, the parent class’s function will be called, even if the object at runtime belongs to the child class. When a virtual function is called on an object of the child class, the child class’s version of the function may be called, if the object is typed as an instance of the parent class. </p>
<p class="calibre1">Table 20-1 shows a code snippet that will execute differently if the function is virtual or nonvirtual. </p>
<p class="calibre1"><b class="calibre3">Table 20-1: </b>Source Code Example for Virtual Functions <b class="calibre3">Non-virtual function</b></p>
<p class="calibre1"><b class="calibre3">Virtual function</b></p>
<p class="calibre1">class A {</p>
<p class="calibre1">class A {</p>
<p class="calibre1">public:</p>
<p class="calibre1">public:</p>
<p class="calibre1">void foo() {</p>
<p class="calibre1"><b class="calibre3">virtual</b> void foo() {</p>
<p class="calibre1">printf("Class A\n"); </p>
<p class="calibre1">printf("Class A\n"); </p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">}; </p>
<p class="calibre1">}; </p>
<p class="calibre1">class B : public A {</p>
<p class="calibre1">class B : public A {</p>
<p class="calibre1">public:</p>
<p class="calibre1">public:</p>
<p class="calibre1">void foo() {</p>
<p class="calibre1"><b class="calibre3">virtual</b> void foo() {</p>
<p class="calibre1">printf("Class B\n"); </p>
<p class="calibre1">printf("Class B\n"); </p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">}; </p>
<p class="calibre1">}; </p>
<p class="calibre1">void g(A&amp; arg) {</p>
<p class="calibre1">void g(A&amp; arg) {</p>
<p class="calibre1">arg.foo(); </p>
<p class="calibre1">arg.foo(); </p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">int _tmain(int argc, _TCHAR* argv[])</p>
<p class="calibre1">int _tmain(int argc, _TCHAR* argv[])</p>
<p class="calibre1">{</p>
<p class="calibre1">{</p>
<p class="calibre1">B b; </p>
<p class="calibre1">B b; </p>
<p class="calibre1">A a; </p>
<p class="calibre1">A a; </p>
<p class="calibre1">g(b); </p>
<p class="calibre1">g(b); </p>
<p class="calibre1">return 0; </p>
<p class="calibre1">return 0; </p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">C++ Analysis</p>
<p class="calibre1"><b class="calibre3">433</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p467"/>The code contains two classes: class A and class B. The class B class overrides the foo method from class A. The code also contains a function to call the foo method from outside either class. If the function is not declared as virtual, it will print “Class A.” If it is declared as virtual, it will print “Class B.” The code on either side is identical except for the virtual keywords at  and . </p>
<p class="calibre1">In the case of nonvirtual functions, the determination of which function to call is made at compile time. In the two code samples in Listing 20-6, when this code is compiled, the object at  is of class A. While the object at  </p>
<p class="calibre1">could be a subclass of class A, at compile time, we know that it is an object of class A, and the foo function for class A is called. This is why the code on the left will print “Class A.” </p>
<p class="calibre1">In the case of virtual functions, the determination of which function to call is made at runtime. If a class A object is called at runtime, then the class A version of the function is called. If the object is of class B, then the class B </p>
<p class="calibre1">function is called. This is why the code on the right will print “Class B.” </p>
<p class="calibre1">This functionality is often referred to as  <i class="calibre4">polymorphism</i>. The biggest advantage to polymorphism is that it allows objects that perform different functionality to share a common interface. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Use of Vtables</b></i></p>
<p class="calibre1">The C++ compiler will add special data structures when it compiles code to support virtual functions. These data structures are called  <i class="calibre4">virtual function</i> <i class="calibre4">tables</i>, or  <i class="calibre4">vtables</i>. These tables are simply arrays of function pointers. Each class using virtual functions has its own vtable, and each virtual function in a class has an entry in the vtable. </p>
<p class="calibre1">Table 20-2 shows a disassembly of g function from the two code snippets in Table 20-1. On the left is the nonvirtual function call to foo, and on the right is the virtual call. </p>
<p class="calibre1"><b class="calibre3">Table 20-2: </b>Assembly Code of the Example from Table 20-1</p>
<p class="calibre1"><b class="calibre3">Non-virtual function call</b></p>
<p class="calibre1"><b class="calibre3">Virtual function call</b></p>
<p class="calibre1">00401000   push    ebp</p>
<p class="calibre1">00401000   push    ebp</p>
<p class="calibre1">00401001   mov     ebp, esp</p>
<p class="calibre1">00401001   mov     ebp, esp</p>
<p class="calibre1">00401003   mov     ecx, [ebp+arg_0]</p>
<p class="calibre1">00401003   mov</p>
<p class="calibre1">eax, [ebp+arg_0]</p>
<p class="calibre1">00401006   call    sub_401030</p>
<p class="calibre1">00401006   mov</p>
<p class="calibre1">edx, [eax]</p>
<p class="calibre1">0040100B   pop     ebp</p>
<p class="calibre1">00401008   mov     ecx, [ebp+arg_0]</p>
<p class="calibre1">0040100C   retn</p>
<p class="calibre1">0040100B   mov     eax, [edx]</p>
<p class="calibre1">0040100D   call    eax</p>
<p class="calibre1">0040100F   pop     ebp</p>
<p class="calibre1">00401010   retn</p>
<p class="calibre1">The source code change is small, but the assembly looks completely different. The function call on the left looks the same as the C functions that we have seen before. The virtual function call on the right looks different. The biggest difference is that we can’t see the destination for the call instruction, which can pose a big problem when analyzing disassembled C++, because we need to track down the target of the call instruction. </p>
<p class="calibre1"><b class="calibre3">434</b></p>
<p class="calibre1">Chapter 20</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p468"/>The argument for the g function is a reference, which can be used as a pointer, to an object of class A (or any subclass of class A). The assembly code accesses the pointer to the beginning of the object . The code then accesses the first 4 bytes of the object . </p>
<p class="calibre1">Figure 20-2 shows how the virtual function is used in Table 20-2 to determine which code to call. The first 4 bytes of the object are a pointer to the vtable. The first 4-byte entry of the vtable is a pointer to the code for the first virtual function. </p>
<p class="calibre1">Object</p>
<p class="calibre1">Vtable</p>
<p class="calibre1">Code</p>
<p class="calibre1">vtable</p>
<p class="calibre1">Function 1</p>
<p class="calibre1">push ebp</p>
<p class="calibre1">mov ebp, esp</p>
<p class="calibre1">object data1</p>
<p class="calibre1">Function 2</p>
<p class="calibre1">... </p>
<p class="calibre1">object data2</p>
<p class="calibre1">... </p>
<p class="calibre1">... </p>
<p class="calibre1"> <i class="calibre4">Figure 20-2: C++ object with a virtual function table (vtable)</i> To figure out which function is being called, you find where the vtable is being accessed, and you see which offset is being called. In Table 20-2, we see the first vtable entry being accessed. To find the code that is called, we must find the vtable in memory and then go to the first function in the list. </p>
<p class="calibre1">Nonvirtual functions do not appear in a vtable because there is no need for them. The target for nonvirtual function calls is fixed at compile time. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Recognizing a Vtable</b></i></p>
<p class="calibre1">In order to identify the call destination, we need to determine the type of object and locate the vtable. If you can spot the new operator for the constructor (a concept described in the next section), you can typically discover the address of the vtable being accessed nearby. </p>
<p class="calibre1">The vtable looks like an array of function pointers. For example, Listing 20-6 shows the vtable for a class with three virtual functions. When you see a vtable, only the first value in the table should have a cross-reference. </p>
<p class="calibre1">The other elements of the table are accessed by their offset from the beginning of the table, and there are no accesses directly to items within the table. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">In this example, the line labeled off_4020F0 is the beginning of the vtable, but don’t</i> <i class="calibre4">confuse this with switch offset tables, covered in Chapter 6. A switch offset table</i> <i class="calibre4">would have offsets to locations that are not subroutines, labeled loc_###### instead</i> <i class="calibre4">of sub_######. </i></p>
<p class="calibre1">004020F0 <b class="calibre3">off_4020F0</b>      dd offset sub_4010A0</p>
<p class="calibre1">004020F4                 dd offset sub_4010C0</p>
<p class="calibre1">004020F8                 dd offset sub_4010E0</p>
<p class="calibre1"> <i class="calibre4">Listing 20-6: A vtable in IDA Pro</i></p>
<p class="calibre1">C++ Analysis</p>
<p class="calibre1"><b class="calibre3">435</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p469"/><img src="index-469_1.jpg" alt="Image 91" class="calibre2"/></p>
<p class="calibre1">You can recognize virtual functions by their cross-references. Virtual functions are not directly called by other parts of the code, and when you check cross-references for a virtual function, you should not see any calls to that function. For example, Figure 20-3 shows the cross-references for a virtual function. Both cross-references are offsets to the function, and neither is a call instruction. Virtual functions almost always appear this way, whereas nonvirtual functions are typically referenced via a call instruction. </p>
<p class="calibre1"> <i class="calibre4">Figure 20-3: Cross-references for a virtual function</i> Once you have found a vtable and virtual functions, you can use that information to analyze them. When you identify a vtable, you instantly know that all functions within that table belong to the same class, and that functions within the same class are somehow related. You can also use vtables to determine if class relationships exist. </p>
<p class="calibre1">Listing 20-7, an expansion of Listing 20-6, includes vtables for two classes. </p>
<p class="calibre1">004020DC off_4020DC      dd offset sub_401100</p>
<p class="calibre1">004020E0                 dd offset sub_4010C0</p>
<p class="calibre1">004020E4</p>
<p class="calibre1">dd offset sub_4010E0</p>
<p class="calibre1">004020E8                 dd offset sub_401120</p>
<p class="calibre1">004020EC                 dd offset unk_402198</p>
<p class="calibre1">004020F0 off_4020F0      dd offset sub_4010A0</p>
<p class="calibre1">004020F4                 dd offset sub_4010C0</p>
<p class="calibre1">004020F8</p>
<p class="calibre1">dd offset sub_4010E0</p>
<p class="calibre1"> <i class="calibre4">Listing 20-7: Vtables for two different classes</i></p>
<p class="calibre1">Notice that the functions at  and  are the same, and that there are two cross-references for this function, as shown in Figure 20-3. The two cross-references are from the two vtables that point to this function, which suggests an inheritance relationship. </p>
<p class="calibre1">Remember that child classes automatically include all functions from a parent class, unless they override it. In Listing 20-7, sub_4010E0 at  and  is a function from the parent class that is also in the vtable for the child class, because it can also be called for the child class. </p>
<p class="calibre1">You can’t always differentiate a child class from a parent class, but if one vtable is larger than the other, it is the subclass. In this example, the vtable at offset 4020F0 is the parent class, and the vtable at offset 4020DC is the child class because its vtable is larger. (Remember that child classes always have the same functions as the parent class and may have additional functions.) <b class="calibre3">436</b></p>
<p class="calibre1">Chapter 20</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p470"/><b class="calibre3">Creating and Destroying Objects</b></p>
<p class="calibre1">Two special functions for C++ classes are the  <i class="calibre4">constructor</i> and  <i class="calibre4">destructor</i>. When an object is created, the constructor is called. When an object is destroyed, the destructor is called. </p>
<p class="calibre1">The constructor performs any initialization needed by the object. </p>
<p class="calibre1">Objects can be created on the stack or stored on the heap. For objects created on the stack, there is no need to allocate specific memory for the object; the object will simply be stored on the stack along with other local variables. </p>
<p class="calibre1">The destructor for objects is automatically called when the objects go out of scope. Sometimes this tends to complicate disassembly, because the compiler may need to add exception handling code in order to guarantee that object destructors are called. </p>
<p class="calibre1">For objects that are not stored on the stack, the memory is allocated with the new operator, which is a C++ keyword that creates heap space for a new object and calls the constructor. In disassembly, the new operator is usually an imported function that can be spotted easily. For example, Listing 20-8 shows the IDA Pro disassembly using the new operator implemented as an imported function. Since this is the new operator and not a regular function, it has an unusual function name. IDA Pro identifies the function properly as the new operator and labels it as such. Similarly, a delete operator is called when heap-allocated objects are to be freed. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Object creation and deletion are key elements of the execution flow for a C++ program. </i></p>
<p class="calibre1"> <i class="calibre4">Reverse-engineering these routines can usually provide key insight into the object layout</i> <i class="calibre4">and aid analysis in other member functions. </i></p>
<p class="calibre1">00401070  push    ebp</p>
<p class="calibre1">00401071  mov     ebp, esp</p>
<p class="calibre1">00401073  sub     esp, 1Ch</p>
<p class="calibre1">00401076  mov     [ebp+var_10],  offset off_4020F0</p>
<p class="calibre1">0040107D  mov     [ebp+var_10],  offset off_4020DC</p>
<p class="calibre1">00401084  mov     [ebp+var_4], offset off_4020F0</p>
<p class="calibre1">0040108B  push    4</p>
<p class="calibre1">0040108D  call    ??2@YAPAXI@Z    ; operator new(uint)</p>
<p class="calibre1"> <i class="calibre4">Listing 20-8: The new operator in disassembly</i></p>
<p class="calibre1">In Listing 20-8, we’re looking at an object stored on the stack. The offset moved into location var_10 is the vtable. The compiler here shows some strange behavior by putting different offsets into the same location twice in a row. The instruction at  is useless, because the second offset at  will overwrite what is stored at . </p>
<p class="calibre1">If we were to look at the offsets for this code, we would see that they are the vtables for the two classes. The first offset is the vtable for the parent class, and the second offset is the vtable for the class of the object being created. </p>
<p class="calibre1">C++ Analysis</p>
<p class="calibre1"><b class="calibre3">437</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p471"/><b class="calibre3">Conclusion</b></p>
<p class="calibre1">In order to analyze malicious programs written in C++, you need to understand C++ features and how they affect the assembly code. By understanding inheritance, vtables, the this pointer, and name mangling, you won’t be slowed down by C++ code, and you’ll be able to take advantage of any clues provided by the additional structure created by C++ classes. </p>
<p class="calibre1"><b class="calibre3">438</b></p>
<p class="calibre1">Chapter 20</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p472"/><b class="calibre3">L A B S</b></p>
<p class="calibre1"><b class="calibre3">Lab 20-1</b></p>
<p class="calibre1">The purpose of this first lab is to demonstrate the usage of the this pointer. </p>
<p class="calibre1">Analyze the malware in  <i class="calibre4">Lab20-01.exe</i>. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">Does the function at 0x401040 take any parameters? </p>
<p class="calibre1">2. </p>
<p class="calibre1">Which URL is used in the call to URLDownloadToFile? </p>
<p class="calibre1">3. </p>
<p class="calibre1">What does this program do? </p>
<p class="calibre1"><b class="calibre3">Lab 20-2</b></p>
<p class="calibre1">The purpose of this second lab is to demonstrate virtual functions. Analyze the malware in  <i class="calibre4">Lab20-02.exe</i>. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">This program is not dangerous to your computer, but it will try to upload possibly sensitive files from your machine. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What can you learn from the interesting strings in this program? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What do the imports tell you about this program? </p>
<p class="calibre1">3. </p>
<p class="calibre1">What is the purpose of the object created at 0x4011D9? Does it have any virtual functions? </p>
<p class="calibre1">4. </p>
<p class="calibre1">Which functions could possibly be called by the call [edx] instruction at 0x401349? </p>
<p class="calibre1">5. </p>
<p class="calibre1">How could you easily set up the server that this malware expects in order to fully analyze the malware without connecting it to the Internet? </p>
<p class="calibre1">6. </p>
<p class="calibre1">What is the purpose of this program? </p>
<p class="calibre1">7. </p>
<p class="calibre1">What is the purpose of implementing a virtual function call in this program? </p>
<p class="calibre1"><b class="calibre3">Lab 20-3</b></p>
<p class="calibre1">This third lab is a longer and more realistic piece of malware. This lab comes with a configuration file named  <i class="calibre4">config.dat</i> that must be in the same directory as the lab in order to execute properly. Analyze the malware in  <i class="calibre4">Lab20-03.exe</i>. </p>
<p class="calibre1">C++ Analysis</p>
<p class="calibre1"><b class="calibre3">439</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p473"/> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What can you learn from the interesting strings in this program? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What do the imports tell you about this program? </p>
<p class="calibre1">3. </p>
<p class="calibre1">At 0x4036F0, there is a function call that takes the string Config error, followed a few instructions later by a call to CxxThrowException. Does the function take any parameters other than the string? Does the function return anything? What can you tell about this function from the context in which it’s used? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What do the six entries in the switch table at 0x4025C8 do? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What is the purpose of this program? </p>
<p class="calibre1"><b class="calibre3">440</b></p>
<p class="calibre1">Chapter 20</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p474"/><b class="calibre3">6 4 - B I T   M A L W A R E</b></p>
<p class="calibre1">Almost all current malware is 32-bit, but some is writ-</p>
<p class="calibre1">ten for the 64-bit architecture in order to interact </p>
<p class="calibre1">with 64-bit OSs. As 64-bit OSs become more popular, </p>
<p class="calibre1">so will 64-bit malware. </p>
<p class="calibre1">Several 64-bit architectures have been introduced. The first to be supported by Windows, Itanium, was designed for performance computing and was not compatible with x86. AMD later introduced a 64-bit architecture called AMD64, which was compatible with x86 code. Intel adopted AMD64 </p>
<p class="calibre1">and called its implementation EM64T. This architecture is now known as x64, or x86-64, and it is the most popular implementation of 64-bit code on Windows. All current Windows versions are available in 64-bit versions, which support both 64-bit and 32-bit applications. </p>
<p class="calibre1">The x64 architecture was designed as an upgrade to x86, and the instruction sets are not drastically different. Because most instructions are unchanged from x86 to x64, when you open a 64-bit executable in IDA Pro, you should be familiar with most of the instructions. One of the biggest complications </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p475"/>associated with 64-bit malware analysis is that not all tools support x64 assembly. For example, as of this writing, OllyDbg does not support 64-bit applications, although WinDbg does. IDA Pro supports x64 assembly, but it requires the IDA Pro Advanced version. </p>
<p class="calibre1">This chapter addresses the differences between 32-bit and 64-bit systems, and provides a few hints to help analyze 64-bit code. </p>
<p class="calibre1"><b class="calibre3">Why 64-Bit Malware? </b></p>
<p class="calibre1">Knowing that 32-bit malware can target both 32-bit and 64-bit machines, why would anyone bother to write 64-bit malware? </p>
<p class="calibre1">While you can run both 32-bit and 64-bit applications on the same system, you cannot run 32-bit code within 64-bit applications. When a processor is running 32-bit code, it is running in 32-bit mode, and you cannot run 64-bit code. Therefore, anytime malware needs to run inside the process space of a 64-bit process, it must be 64-bit. </p>
<p class="calibre1">Here are a few examples of why malware might need to be compiled for the x64 architecture:</p>
<p class="calibre1"><b class="calibre3">Kernel code</b></p>
<p class="calibre1">All kernel code for an OS is within a single memory space, and all kernel code running in a 64-bit OS must be 64-bit. Because rootkits often run within the kernel, rootkits that target 64-bit OSs must be compiled into 64-bit machine code. Also, because antivirus and host-based security code often contain kernel elements, malware designed to interfere with these applications must be 64-bit, or at least have 64-bit components. </p>
<p class="calibre1">Microsoft has made changes to the 64-bit versions of Windows that make it difficult to run malicious kernel code by detecting unauthorized modifications to the kernel and restricting the Windows ability to load drivers that aren’t digitally signed. (These changes are covered in detail at the end of Chapter 10.)</p>
<p class="calibre1"><b class="calibre3">Plug-ins and injected code</b></p>
<p class="calibre1">These must be 64-bit in order to run properly in a 64-bit process. For example, a malicious Internet Explorer plug-in or ActiveX control must be 64-bit if the computer is running the 64-bit version of Internet Explorer. Code injected using the techniques covered in Chapter 12 also runs within another process. If the target process is 64-bit, the injected code must also be 64-bit. </p>
<p class="calibre1"><b class="calibre3">Shellcode</b></p>
<p class="calibre1">Shellcode is usually run as part of an exploit within the process that it is exploiting. In order to exploit a vulnerability in the 64-bit version of Internet Explorer, for example, a malware author would need to write 64-bit shellcode. As more users run a mix of 64-bit and 32-bit applications, malware writers will need to write a separate version of shellcode for 32-bit and 64-bit victims. </p>
<p class="calibre1"><b class="calibre3">442</b></p>
<p class="calibre1">Chapter 21</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p476"/><b class="calibre3">Differences in x64 Architecture</b></p>
<p class="calibre1">The following are the most important differences between Windows 64-bit and 32-bit architecture:</p>
<p class="calibre1"></p>
<p class="calibre1">All addresses and pointers are 64 bits. </p>
<p class="calibre1"></p>
<p class="calibre1">All general-purpose registers—including RAX, RBX, RCX, and so on—</p>
<p class="calibre1">have increased in size, although the 32-bit versions can still be accessed. </p>
</body></html>