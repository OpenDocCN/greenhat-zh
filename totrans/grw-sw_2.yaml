- en: Part II. PRODUCT AND TECHNOLOGY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. DEFINING THE PRODUCT")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. DRIVING RELEASES")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. EVALUATING YOUR TOOLS AND METHODS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. ASSESSING YOUR TECHNOLOGY")'
  prefs: []
  type: TYPE_NORMAL
- en: This section of the book covers product and technology, two areas at the heart
    of the intellectual property of the company. Superior product definition leads
    to superior product, and good technical tools and methods enable quicker high-quality
    results. Understanding how to balance product and technology is one of the secrets
    of effective development management.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. DEFINING THE PRODUCT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, a *product definition* is not a knowledge or resource issue; it
    is a *relationship* issue. When you and your development team build strong relationships
    with marketing staff and with your customers, defining the product becomes much
    simpler. Open and regular communication with members of other teams can help you
    align your development goals with company goals. In addition, developing trust
    among corporate divisions as well as between the company and its customers can
    result in a quicker consensus on the most appropriate product definition.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most difficult relationship strains occur between marketing and
    development teams. Establishing a positive relationship between these teams can
    be challenging, because the roles played by marketing and engineering staff are
    very different. Marketing's function is to understand customer needs and promise
    the solutions required to meet those needs.
  prefs: []
  type: TYPE_NORMAL
- en: Engineering's role emphasizes the practical aspects of building products efficiently
    and then supporting them after they are built. With a strong relationship between
    the two teams, they can work together to devise the best and most balanced solutions
    to meet the customer's and company's needs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers the basics of defining a product. You'll learn about crucial
    relationships, study example processes for creating product definitions, read
    about what goes into a product definition, and learn a bit about prototyping and
    how to use templates to help define a product. In addition, you'll learn how products
    are put together and how different partners in the relationship perceive the product.
  prefs: []
  type: TYPE_NORMAL
- en: Product Definition Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a refined product definition can be a challenge for companies for
    several reasons: The number of options surpasses the company''s ability to build
    them, information is lacking, and the relationships between marketing and engineering
    are weak. However, if the marketing and engineering teams'' relationship can be
    improved, they can work together to define the product through a process of high-level
    reviews and quick cost assessments.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a joint and cooperative definition doesn't necessarily imply that engineering
    and marketing have completely overlapping responsibilities and authorities in
    product definition. Some companies give engineering the final word, while others
    give marketing the lead role. When the marketing team is strong, the marketing-driven
    approach usually works the best. In either situation, cooperative behavior produces
    the best results.
  prefs: []
  type: TYPE_NORMAL
- en: During the initial product definition process, short daily discussions between
    marketing and engineering encourage more rapid closure on choosing the best options
    to pursue. The daily discussion becomes a *continuous conversation* that allows
    iterative refinement of the requirements and ultimately the definition. The teams
    can analyze the feature costs, timeline, and definition in stages—be they quick
    overviews, intermediate level reviews, or fuller definition reviews. At each stage,
    the teams work together to select and eliminate options through thoughtful analysis
    and data collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, the marketing/engineering evaluation works as follows: First, engineering
    works with marketing to define preliminary quick estimates of product size and
    scope. Next, both teams agree on how to pare down the list. Remaining items are
    analyzed with more detail. Then this process is repeated until both teams agree
    on a final set of product definitions, costs, and timelines. [Figure 5-1](ch05.html#sifting_through_initial_product_ideas_to
    "Figure 5-1. Sifting through initial product ideas to produce final choices")
    illustrates this filtering process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sifting through initial product ideas to produce final choices](tagoreillycom20090324nostarchimages266069.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5-1. Sifting through initial product ideas to produce final choices**'
  prefs: []
  type: TYPE_NORMAL
- en: If a trusting relationship does not exist between the marketing and engineering
    teams, the steps in the process will degrade. For example, if marketing treats
    preliminary quick estimates from engineering as full commitments and pressures
    engineering to meet those commitments, engineers will probably stop providing
    quick estimates. Engineers create quick estimates based on limited information;
    these estimates are unsuitable for accurate budgeting and scheduling, but fine
    for establishing ballpark costs so that the initial direction can be set. Providing
    quick estimates as cost ranges emphasizes the uncertainty involved, but the analysis
    is insufficient to use in creating an accurate project schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Once mistrust has soured the engineering and marketing relationship, the very
    expensive process shown in [Figure 5-2](ch05.html#wasteful_selection_process "Figure 5-2. Wasteful
    selection process") ensues. In this case, both teams treat conversations as mini-contracts,
    eliminating speculative discussions. All feature and project ideas require extensive
    evaluation before engineering will provide any type of estimate, and engineering
    devotes considerable time to precise, in-depth estimates. Marketing has to invest
    substantially more time in fully defining every idea before presenting them to
    engineering. Worst of all, engineering must create detailed estimates for *all*
    of the options before presenting them to marketing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wasteful selection process](tagoreillycom20090324nostarchimages266071.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5-2. Wasteful selection process**'
  prefs: []
  type: TYPE_NORMAL
- en: Why do so many companies choose such a wasteful approach to product definition?
    Past bad behavior usually drives defensive relationships. If in the past, engineering
    produced quick estimates based on initial ideas, and then marketing insisted that
    these numbers be treated as final, engineering has little incentive to provide
    quick estimates in the future.
  prefs: []
  type: TYPE_NORMAL
- en: When operating under a successful approach, however, engineering and marketing
    can collect more information and refine definitions for the ideas that will be
    implemented. [Figure 5-3](ch05.html#clarity_of_definition_versus_amount_of_d "Figure 5-3. Clarity
    of definition versus amount of detail") illustrates the pyramid of information
    associated with refining a definition. Each layer reflects more product information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A refined definition starts at the *top level* and focuses on the customer''s
    needs. As the definition process continues, marketing and engineering produce
    a more detailed description of the product: detailed requirements, high-level
    implementation descriptions, detailed concept models and prototypes, and then
    the functional specifications. Then engineering considers the product architecture,
    examines the requirements of the product''s construction, and prepares a detailed
    description of its features and user interface. Finally, engineering and marketing
    together flesh out the complete definition of the product offering.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clarity of definition versus amount of detail](tagoreillycom20090324nostarchimages266073.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5-3. Clarity of definition versus amount of detail**'
  prefs: []
  type: TYPE_NORMAL
- en: The process is challenging because the teams must make product decisions based
    on incomplete information. Decisions involve trade-offs between features, timelines,
    resources, and implementation approaches. Making sound *initial* decisions requires
    not waiting until development is building the product before thoroughly analyzing
    what needs to be built. If questions about the technical feasibility of specific
    functions of features arise, a senior engineer should be asked to create simple
    prototypes for these technical areas before building the software. Prototypes
    are discussed in detail later on.
  prefs: []
  type: TYPE_NORMAL
- en: Product Definition Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you strive to define your product, create a document that outlines product
    specifications, and continue to update this document as you work with marketing
    staff and customers to refine the focus. Sketches and notes might be useful for
    initial discussions, but they will not provide sufficient background data for
    the future as you are required to make revisions and improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Small companies benefit from short, concise definitions rather than formal specifications.
    Instead of creating a complex specification that's time consuming to create and
    maintain and difficult to read, create your product definition with readability
    and idea sharing in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple definitions improve development agility. Follow these general guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the documentation short and readable. Focus on high-level definitions of
    functionality, and do not elaborate on detailed specifics. Simplicity in definition
    can sometimes require negotiating with marketing and other teams about the nature
    of the document. Too much complexity will render the document less readable as
    reviewers fill in every detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid adding implementation details as part of the definition, because they
    do not provide clarity to the solution and can limit your options later when you're
    considering how to supply what the customer needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the document readable in layout. Avoid a formalized template that requires
    labeling and numbering every statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include pictures as focal points for written definitions. Reviewers might have
    a hard time visualizing the top-level system definition if only text is provided.
    A diagram can be used to clarify difficult concepts and acts as a catalyst for
    ongoing discussions of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layer the discussion by starting with overview information before explaining
    the lower-level details. Overview information provides context for the product
    including audience, most important objectives, and problems solved. Engineers
    often describe systems linearly from start to finish. For nontechnical or even
    unfamiliar readers, an overview provides context that makes the lower-level details
    much easier to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create user interface prototypes as part of the product definition, and use
    them selectively in your requirements document. Pages and pages of screen captures
    don't add context or value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider employing use cases to define sections of the product. A *use case*
    describes all the steps a user would take to obtain a specific goal using the
    product. Use cases supplement and clarify the product definition but should not
    be considered full specifications in themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make requirements testable and nonambiguous. Avoid words that require interpretation
    or those that QA cannot measure. Requirements outside of functional requirements
    fall into this category. For example, don't say your product requires *rapid response,
    high speed*, and *support for large data sets*. It's better to use definitions
    such as *2 seconds or less response on all screens using our standard hardware*,
    *translation data rate minimum of 1.5MB per second*, and *support for data sets
    of 500 million user records*. Creating nonambiguous and testable requirements
    doesn't mean that the specification has to be formal and extensive. Just ensure
    that what you do specify is clear and worthwhile. "Good quality" doesn't cut it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a requirements definition template to organize your requirements document.
    A template organizes the information in a consistent way from document to document,
    which provides an easy context for people in your company who read it. A good
    template can help you avoid omitting important topics if it properly lists all
    of the types of information needed. The best templates are accepted by the team
    as being practical and useful—not just a form to fill out to keep management happy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of good templates for requirement definitions exist. Review multiple
    templates before selecting one that suits your needs. [Figure 5-4](ch05s03.html#sample_requirements_template
    "Figure 5-4. Sample requirements template") illustrates an example template. (For
    this template, instructions are written in italics. You should replace all the
    words in italics with the information required for your project.)
  prefs: []
  type: TYPE_NORMAL
- en: Prioritize requirements as you define the product. If you discuss priorities
    with marketing early on, product definitions will be smoother and you can avoid
    having to check back with marketing to clarify issues. Establish priorities for
    *agile* and *iterative* processes, as they allow you to make trade-offs in the
    design. They also assist in the project planning, allowing you to organize efforts
    to focus on highest priority items earlier. Completing the highest priority features
    first will minimize problems that occur when plans are changed or schedules are
    shortened as business needs change.
  prefs: []
  type: TYPE_NORMAL
- en: The Whole Product Concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customers demand products that offer complete solutions to meet their needs.
    Software makes a start at solving a customer's problems, but it often falls short
    in several areas. It must meet the customer's expectations; it should offer flexible
    options; it should include APIs or other interconnections so that it can integrate
    with other systems; and it should include supporting services, such as access
    to trained call center staff, to professional training, and to onsite support.
    Software that provides solutions in all these areas is called a *whole product*
    offering.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample requirements template](tagoreillycom20090324nostarchimages266075.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5-4. Sample requirements template**'
  prefs: []
  type: TYPE_NORMAL
- en: When defining a product, consider the whole product concept and not just product
    features. Consider your customers' needs and think about how they make purchasing
    decisions. Do your product's features *and* supporting infrastructure meet customer
    needs? If not, adding new features might be only part of the answer; you might
    also consider adding new interfaces with other systems that make the product easier
    to deploy in various environments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*You can learn more about the whole product concept by reading* Crossing the
    Chasm *by Geoffrey A. Moore or* The Marketing Imagination *by Theodore Levitt.
    (See "Additional Reading" on [Additional Reading](ch02s09.html "Additional Reading").)
    Then discuss your product definition with the marketing team with this concept
    in mind*.'
  prefs: []
  type: TYPE_NORMAL
- en: Define the Product Using Prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The marketing group's first attempt at product definition provides a high-level
    view of the customer's requirements. This definition does not include enough detail
    for engineering to build the product, however; several additional layers of information
    are required to help you build a solution. Engineering must create working definitions
    of the product's *user interface (UI)*, *application programming interface (API)*,
    and *business logic*. The most expensive way to create such working-level definitions
    is for individual engineers to decide how to build the software, build it, and
    then present the results to marketing. Invariably, this approach leads to several
    expensive cycles of rework. A better way is to spend the required time up front
    defining the product in key areas and working with marketing until reaching agreement
    on a product definition.
  prefs: []
  type: TYPE_NORMAL
- en: After the product has been sufficiently defined, presenting a series of prototypes
    to marketing and the customer along with new ideas will allow for several quick
    review cycles and a better final product.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes in General
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Engineers want to deliver software that solves the customer's problems, rather
    than simply delivering code that's been built based on a marketing requirements
    document. Generally, marketing and the customer are unable to provide a detailed
    definition of the best solution. They need to experience a *prototype* to appreciate
    and understand what they like and dislike about various choices. Prototypes allow
    customers to "touch and feel" the product to help them make informed decisions.
    Without a prototype, realizing a clear product definition can require a long process
    of trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes are helpful in obtaining information from the customer and marketing
    staff. The process only begins with the first prototype developers create—the
    development team will collect feedback and improve the prototype until marketing
    and ultimately the customer are pleased with the results. The feedback and prototype
    improvement cycle enables you to define the product effectively. It also protects
    you from time wasted traveling too far down the wrong development paths.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a number of techniques to create prototypes. Paper sketches of the
    interfaces can be presented in different sequences to describe concepts to customers.
    Better yet, you can use software-based tools to create interfaces that resemble
    the final software. Many such tools are designed specifically to assist in creating
    rapid prototypes, allowing you to define a prototype that is both accessible and
    easy to distribute to others for their feedback. Some example systems are discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created a prototype, review it with marketing and the customer,
    as well as with other teams. Talk with QA, customer service, and operations; they
    can offer new insights into how the product definition prototype affects other
    parts of the company and help you define ways to improve the product.
  prefs: []
  type: TYPE_NORMAL
- en: Quick and Nimble Approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Limit the time spent creating prototypes to make it easier to consider alternative
    approaches and changes later on. In addition, avoid creating expensive prototypes,
    because the high costs can make developers less likely to investigate alternative
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Discourage engineers from spending more than a few days creating each prototype.
    A developer who has spent many days creating a prototype might be reluctant to
    make significant changes to it. The developer might also be tempted to turn the
    prototype into the product itself, which is a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes are usually discarded after you've learned what you need to know
    from them—another reason to limit resources spent on prototyping. Discarding prototypes
    will prevent you from being saddled with the flaws inherent in a quick construction.
    For this reason, you should discourage or prohibit the reuse of prototype code
    in production code. If the prototype tests the technical feasibility of a concept
    and the engineer must write it in the language of the final product, ask the engineer
    not to use the prototype code. Have her build the application from scratch, because
    building the product on top of prototype code hurts its long-term quality.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Always throw prototypes away. Do not use prototype code in products*.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, make it clear to everyone involved that the prototype is *not the product*
    to avoid unnecessary negative or positive expectations associated with the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Clickable User Interface Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a *clickable prototype*, the user can click through and navigate UI screens.
    Clickable prototypes should have no features or functions connected to any of
    the clickable buttons. Their only purpose is to let the customer test the UI.
    By experimenting with clickable prototypes, customers can get a feel for the navigation
    and workflow of the planned system.
  prefs: []
  type: TYPE_NORMAL
- en: Many commercial UI prototyping tools are available. These are some examples
    of popular commercial tools for rapid prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Basic
  prefs: []
  type: TYPE_NORMAL
- en: Visual Basic has a great drag-and-drop interface, and you avoid the temptation
    of developing the final product atop the prototype since most commercial programs
    are not written in Visual Basic. [http://msdn2.microsoft.com/en-us/vbasic/default.aspx](http://msdn2.microsoft.com/en-us/vbasic/default.aspx)
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visio
  prefs: []
  type: TYPE_NORMAL
- en: Visio allows you to create pages that can be linked to icons to build a UI prototype
    that is clickable. [http://office.microsoft.com/en-us/visio/default.aspx](http://office.microsoft.com/en-us/visio/default.aspx)
  prefs: []
  type: TYPE_NORMAL
- en: Adobe Dreamweaver
  prefs: []
  type: TYPE_NORMAL
- en: By using the HTML editor Dreamweaver, you can create a highly portable UI simulation
    that people can load in any web browser. [http://www.adobe.com/products/dreamweaver/](http://www.adobe.com/products/dreamweaver/)
  prefs: []
  type: TYPE_NORMAL
- en: Axure RP
  prefs: []
  type: TYPE_NORMAL
- en: Axure RP is a rapid prototyping tool that can create HTML pages or an executable
    that you can distribute easily to a client for review. [http://www.axure.com/](http://www.axure.com/)
  prefs: []
  type: TYPE_NORMAL
- en: You can also create prototypes using systems not normally considered to be prototyping
    tools, such as Microsoft Word, PowerPoint, Excel, or Adobe Acrobat. Using these
    tools, you can produce a sequence of screens to represent various workflows.
  prefs: []
  type: TYPE_NORMAL
- en: User Interface Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the UI design early in the product life cycle. By all means, don't wait
    to improve the UI until after you have shipped the product! It will be too late
    to make significant changes without incurring significant costs and creating confusion
    for your customers. Many engineering teams without UI experience design an interface
    based on ease of implementation rather than ease of use. As the interface is the
    primary customer contact point, a poor interface can make customers unhappy with
    a product, even if the rest of the product is superior.
  prefs: []
  type: TYPE_NORMAL
- en: If the product requires a particularly challenging UI design, hire a human factors
    engineer or usability engineer to help refine the interface. These experts understand
    how people work with software and can help you make the product easy to use. Their
    input can greatly improve the product and your customer's satisfaction with it
    and with your company.
  prefs: []
  type: TYPE_NORMAL
- en: Human factors engineers and usability engineers are not usually employees at
    small firms, because they typically don't have enough work to justify full-time
    employment. Hiring a usability consultant can be expensive but is a worthwhile
    expenditure, and good usability engineers are worth their fees. The consulting
    engineer can quickly devise great solutions for new UIs and evaluate existing
    UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Build a Relationship with Marketing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cooperative arrangement and good relationship between engineering and marketing
    can help both teams jointly own the product definition, roadmap, and delivery.
    In fact, they *should* jointly own these things. A good relationship with marketing
    will help you do a better job as development manager, improve the quality of your
    company's product through better definitions, and make it easier to respond to
    problems that occur during the project tenure.
  prefs: []
  type: TYPE_NORMAL
- en: Reach out to marketing and build a trusting relationship at the start. Behave
    in a manner that encourages mutual trust and cooperation between the marketing
    and development teams. Help build the partnership by communicating regularly—daily,
    or at least several times a week—to build trust and increase your understanding
    of each other's ways of working and particular needs. Your team's relationship
    with marketing will be defined by how you handle failures, as much as how you
    handle successes. Partnership means joint success and failure. When the partnership
    produces success, you can share the credit. When part of the project fails, you
    can jointly accept the failure rather than trying to minimize your roles or blame
    the other party.
  prefs: []
  type: TYPE_NORMAL
- en: To be a strong partner with marketing, you should understand basic marketing
    concepts, including how product requirements are defined by marketing, how items
    are packaged, and how various types of customers can be served by a single product
    offering. Spend time learning about the science and art of marketing by consulting
    books or signing up for an introductory marketing course.
  prefs: []
  type: TYPE_NORMAL
- en: Although marketing and engineering are the major sources of product definitions
    in many small companies, other teams also contribute to the product definition.
    Make sure that you build relationships with operations, sales, quality assurance,
    and finance. A great relationship with marketing without support from other teams
    can lead to lack of company support for any plan. Understanding the concerns of
    and seeking input from other groups will strengthen your team's relationships
    throughout the company.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Poor Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be surprised to hear this, but the relationship between marketing
    and engineering teams can be adversarial at times. A natural push-pull tension
    exists between marketing and engineering over product definition, feature set,
    cost, and delivery schedules. Marketing teams commonly complain that engineering
    delivered the product late and that it is missing features. Development teams
    complain that marketing folks keep changing their minds about what features to
    include or that they have made feature promises to a client without first discussing
    them with engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Finger-pointing and defensive behaviors will quickly erode a work environment
    and slow down product development, because each group will demand a more complete
    analysis before responding to the other group's concerns, as discussed earlier
    in the chapter. Marketing and engineering teams that cannot work together cooperatively
    can make the product development process a nightmare. Game playing, such as "we
    must have one more feature, but you cannot change the schedule," can frustrate
    both teams, ruin the product definition process, and wreck morale.
  prefs: []
  type: TYPE_NORMAL
- en: '**POLITICS VERSUS PRODUCTIVITY**'
  prefs: []
  type: TYPE_NORMAL
- en: The marketing person I worked with had a long laundry list of things he wanted.
    To help with initial paring, I did a quick order-of-magnitude sizing on all of
    the items based on sketchy definitions. We agreed that we would revisit those
    of interest and figure out the details and then estimate them. Doing a detailed
    estimate on each item would take too long and required a lot more definition time.
  prefs: []
  type: TYPE_NORMAL
- en: The marketing VP stepped in and selected the items he wanted. He insisted that
    quick estimates were the final estimates and that he would base the final plans
    on them. Because of the politics of the company, saying no was not an option.
    This VP's actions changed the dynamic of engineering-marketing cooperation in
    the wrong way. Engineering would not do quick estimates for marketing going forward.
  prefs: []
  type: TYPE_NORMAL
- en: —Engineering manager
  prefs: []
  type: TYPE_NORMAL
- en: Keep Marketing and Engineering Teams Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Marketing and engineering teams should be located in the same facility to encourage
    cooperation and produce the best product definitions. When team offices are in
    the same vicinity, the teams can communicate better and build trust. The opportunities
    for creating a joint product definition are improved when the teams can easily
    talk and share their ideas on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, splitting marketing and engineering into two separate facilities
    can make it difficult to establish the close working relationship that good product
    definitions require. With remote teams, people miss opportunities for casual communication
    that helps build trusting relationships. They communicate more often through documents,
    email, and formal meetings. Whiteboard discussions, which can be valuable during
    the product definition process, are awkward to set up when teams reside in different
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: Build a Balanced Relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important requirements for building a good relationship between
    marketing and engineering is *balance*. You should be able to say no to a marketing
    request without that decision being considered a rebuff. Disagreements needn't
    result in the marketing manager asking the CEO to force a decision upon you. If
    you regularly find yourself in situations in which you cannot say *no*, perhaps
    you should say *yes* to a new position.
  prefs: []
  type: TYPE_NORMAL
- en: Before saying *no* to a marketing request, consider alternative choices that
    could be answered with a *maybe* or a *yes*. If you offer options to marketing's
    requests, you can improve the collaborative relationship and work together to
    seek the best solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking for positive alternatives, consider these options: fit in a new
    feature or new product later in the product roadmap, swap a planned set of functionality
    with the new request, or delay a planned release to add the new functionality.
    In any case, be sure that you can support the alternative solutions that you propose.'
  prefs: []
  type: TYPE_NORMAL
- en: Customer Perception of the Product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The customer's perception of a product never really matches reality. For that
    matter, the perceptions of marketing and sales often do not match reality. Even
    engineering's perception of the product does not always match reality.
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand this concept, study [Figure 5-5](ch05s06.html#customer_perception_internal_perception_
    "Figure 5-5. Customer perception, internal perception, and engineering perception"),
    which provides a Venn diagram with some interesting mismatches of perceptions
    that highlight classic problem areas. The three perception circles show all the
    different cases that can occur with mismatched expectations. Each case is labeled
    with a letter. Examine each overlap case separately to see potential problems
    and solutions for perception mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Customer perception, internal perception, and engineering perception](tagoreillycom20090324nostarchimages266077.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5-5. Customer perception, internal perception, and engineering perception**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Alignment'
  prefs: []
  type: TYPE_NORMAL
- en: We all perceive the same thing the same way. Perception probably matches reality.
    For these features, the product works as designed and the customer expectations
    match. Smile. This is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'B: Fooling Ourselves'
  prefs: []
  type: TYPE_NORMAL
- en: Sales and marketing believe the product offers capabilities that do not exist.
    Fortunately, customers are unaware of these fictional capabilities. The better
    the communication between engineering, sales, and marketing, the less likely this
    misperception will happen. If engineering and marketing regularly communicate
    during development, they should be in alignment about the feature set. Good documentation
    and good sales training will bring the sales team up to speed. If sales' understanding
    is incomplete and staff presents the wrong information to the customer, they have
    created a larger problem, which is case C.
  prefs: []
  type: TYPE_NORMAL
- en: 'C: Defects, Omissions, or Overselling'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, what was sold does not match what engineering built. The cause
    of this mismatch can be a product defect, problems with the documentation, or
    sales intentionally overselling the product.
  prefs: []
  type: TYPE_NORMAL
- en: '*Overselling* occurs when sales tells the customer that the product includes
    a feature that the product does not in fact offer. Some sales people do this to
    make the sale and then pressure engineers to add the feature quickly to avoid
    embarrassing the company.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defect and omission cases are straightforward to correct: Either correct the
    code or change the documentation to match what is being delivered. If a sales
    person intentionally oversells the product, marketing and senior management should
    take corrective action with the person to avoid the situation in the future. Having
    single sales people define product direction without the active participation
    of engineering, marketing, and management will derail the longer-term product
    planning and hurt the company.'
  prefs: []
  type: TYPE_NORMAL
- en: 'D: Great Expectations'
  prefs: []
  type: TYPE_NORMAL
- en: The customer thinks the product does something that it doesn't actually do,
    even if your company did not tell the customer that the feature is supported.
    This occurs when the customer makes unwarranted assumptions about the product.
    Good customer-facing documentation, marketing collateral, and proper training
    for the customer should keep this problem to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'E: Hidden Capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the product includes undocumented features that can be unintended
    artifacts of how the software is constructed. The development team might be unaware
    of these capabilities. Sometimes an engineer might add such features intentionally
    without documenting them. Hidden capabilities can be benign unless the customer
    becomes aware of them and exploits them.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden capabilities should be documented and the cause investigated. If an unintentional
    side effect of the code creates the capability, it should be either documented
    as a feature or disabled. If the capability was intentional but added without
    permission, talk to the engineer who added it to prevent this from happening in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'F: Code Artifacts and Unsupported Features'
  prefs: []
  type: TYPE_NORMAL
- en: An *artifact* describes a behavior that was unintended and covers some aspect
    of the system that was an unusual and unexpected case. This behavior or hidden
    feature was not intended to be included in the product. It does not appear on
    your test systems and is unknown to you.
  prefs: []
  type: TYPE_NORMAL
- en: When a customer discovers code artifacts or unsupported features, big problems
    can result. Customers can exploit unintended code artifact effects on their systems,
    and because your company does not support the artifact, it might not appear in
    the next new release, leaving the customer without that option in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the customer-use model helps you identify and avoid such problems.
    Talk to customers about how they use the product to help identify unusual and
    unplanned uses. Ideally, map out a customer-use model. Understand how your customers
    use the product.
  prefs: []
  type: TYPE_NORMAL
- en: Unsupported features can appear when an engineer adds undocumented and unplanned
    features into a release—perhaps the engineer wanted to experiment with a nifty
    idea. Some customer service and support technicians will hear of this feature
    and tell a customer that it is legitimate, because they want to help the customer
    with a problem. To avoid unplanned features, tell the development team that adding
    in features without approval is unacceptable. See the next section for more discussion
    of this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'G: Missed Opportunities'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the customer is unaware of a feature of the product because the
    company somehow missed the opportunity to describe the feature and improve the
    sales potential of the product. You can avoid this situation by fully documenting
    all features and training sales staff on the most important features. Keep customer-facing
    documentation up to date to avoid creating missed opportunities in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Surprise! Unplanned Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding features in the product that an engineer added without your knowledge
    is an unpleasant surprise. Engineers will add unplanned features in the product
    code for three main reasons, all of which are unacceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: The engineer wants to please someone (a client, a customer service representative,
    or a senior manager) but knows management will not approve this feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The engineer thinks he knows better than everyone else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The engineer wants to experiment with a new feature but does not want to ask
    permission to add it to the product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building unapproved features can delay implementation of required features and
    can hurt your product. In some cases, these unapproved features can force required
    features out of a release due to lack of development time. Unplanned features
    can also create inconsistency in the product, because often an engineer will implement
    them only in one section of the product. Such features often do not fit an overall
    product definition or strategy. They also ensure big problems for QA and documentation
    teams because the hidden feature's behavior differs from the documented behavior.
    Finally, adding unapproved features to a product shows an engineer's disrespect
    for everyone else in the company.
  prefs: []
  type: TYPE_NORMAL
- en: 'A small "back-door" feature might increase immediate customer value and please
    a client. However, your customers will be upset if they try using this feature
    in another part of the software suite and find it''s unsupported: The surprise
    feature becomes a major problem for your company. When a customer expresses displeasure,
    you might be forced to scramble to provide support for the feature. Completing
    support for a feature after the product is released can be 10 times more expensive
    than creating the feature at the start and providing support. Suddenly, the small
    change has disrupted your company''s next few releases and potentially its future
    revenue.'
  prefs: []
  type: TYPE_NORMAL
- en: If an engineer adds unapproved features to product code, pull her aside and
    coach her about her action's impact on the product and the company. When talking
    to the responsible engineer, remember that your goal is not to stifle innovation,
    but to encourage team discussion of key features before they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '**BEST INTENTIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: A customer service employee made a feature request of an engineer working on
    one piece of our system. The engineer thought it was a neat change, so he implemented
    it without telling anyone else. When the release came out, the customer service
    person told key customers about the feature and the customers started using it.
    A few customers really liked the feature and started using it extensively. Customers
    built up their own data files tied into this feature.
  prefs: []
  type: TYPE_NORMAL
- en: However, two key customers quickly found out that the product did not support
    the feature in all areas. This was a huge problem for them and they became vocal
    about it. As large customers were pushing for the change, they forced us to change
    our release strategy to support this change. Full feature support was not cheap;
    we had to implement it as a quickly planned release. This left other customers
    unhappy and affected our ability to support other critical new features. The unplanned
    feature really upset the marketing team. Going forward, I instituted clear rules
    for engineers not to add in any features without approval.
  prefs: []
  type: TYPE_NORMAL
- en: —Product development manager
  prefs: []
  type: TYPE_NORMAL
- en: Improving a Product in an Alpha Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can effectively improve a product definition during its *alpha release*—an
    early version of the software created and released specifically to solicit customer
    feedback. You can identify cooperative customers who know that the alpha software
    is not ready for production use but want to contribute to its definition. Choosing
    existing customers who are enthusiastic about your product will minimize your
    risks and improve your results.
  prefs: []
  type: TYPE_NORMAL
- en: Success with an alpha release requires that you actively drive the client's
    evaluation. A *passive* alpha release, in which you send clients the software
    and then wait for their evaluations, will not produce the feedback you need. Instead,
    schedule an evaluation time with your alpha reviewers so that you can get direct
    feedback from them as they are using the product. If the testers are remote, set
    up regular conferences to discuss their impressions of the product. The goal of
    the alpha release is not to identify bugs, but to solicit conceptual flaws in
    the overall product definition, workflow, and features that would lower the value
    of the product. ([Chapter 6](ch06.html "Chapter 6. DRIVING RELEASES") discusses
    practical aspects of using alpha releases.)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding an Existing Product's Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Product definition isn't strictly limited to an initial release. Defining the
    future of a product requires a clear understanding of the product *as it stands*.
    Because you might not have been involved at the beginning of the product definition
    process, you can step back and take a snapshot view of the product and its features
    to illuminate any problem areas. Understanding an existing product also requires
    that you check "under the hood" for code and construction particulars.
  prefs: []
  type: TYPE_NORMAL
- en: The customer scrutinizes the product based on its functions and ability to meet
    requirements. However, under the hood, each product can consist of software packaging
    (the wrapper around the product executables and libraries that make it easy to
    unpack, install, set up, and use), multiple code executables, data files, and
    a database. Small companies often do not properly maintain documentation of a
    product's "internal engine."
  prefs: []
  type: TYPE_NORMAL
- en: Unraveling which software modules are included in which external product can
    be difficult if many executables have been built over time and staff changes have
    occurred during the process. In a few cases, engineers create hierarchies of code
    components as part of the build or packaging, which makes the product composition
    difficult to sort out.
  prefs: []
  type: TYPE_NORMAL
- en: For software services with many different components, tracking down which pieces
    the customer uses and which the administrator uses can be a complex task. Sometimes
    components are included in the software build but are no longer in use. If the
    product has a long history in the market, you should talk with multiple engineers,
    QA, and operations staff to determine the product composition.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, your company might have heavily customized a product to accommodate
    particular customers' needs. If the development team did not record these customization
    details, determining exactly which parts of a product are important to which customers
    becomes a huge problem when it comes time to maintain or update the product.
  prefs: []
  type: TYPE_NORMAL
- en: Three case histories illustrate the problems with unclear product definitions
    mapping to code. In all cases, much work was required to reach agreement on defining
    the product and then documenting the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 1: Many Compatible Modules'
  prefs: []
  type: TYPE_NORMAL
- en: The product offering at Company A had more than 150 different modules that had
    been developed over a decade. The operations team had built these modules into
    a hierarchy; the result was a few dozen different product offerings with overlapping
    modules. Seven levels of grouping hierarchy were required to build some products.
    The hierarchy and grouping had built up until the people building and packaging
    the products were unclear about their actual contents.
  prefs: []
  type: TYPE_NORMAL
- en: Unraveling this problem required getting the marketing descriptions, licensing
    descriptions, and the homemade packaging file. The development manager wrote a
    program to map components to products and identify overlaps and licensing issues.
    As it turned out, many conflicts existed, including license duplications. Going
    through the process simplified reorganization of the licensing and packaging and
    identified extra software that was being included unintentionally in some packages.
    This resulted in lost revenue for the company, as a key product was being given
    away instead of being sold with every shipment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 2: Too Much Custom Code'
  prefs: []
  type: TYPE_NORMAL
- en: Company B had created many different products and service offerings. Unfortunately,
    no one had documented them along with pricing and construction information. Management
    had no clear vision of the various offerings, and sales treated the offerings
    as full custom efforts and made no effort to address the process and cost issues
    associated with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Marketing, engineering, and management resolved this issue by defining each
    product's content, construction, and pricing, and then publishing the results.
    They produced a standard pricing spreadsheet that they required everyone to use.
    This lowered the need for expensive new development with each new customer. It
    also streamlined the process of bringing in new customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 3: Undocumented System with Legacy Code'
  prefs: []
  type: TYPE_NORMAL
- en: Company C offered *Software as a Service (SaaS)*, which allowed customers to
    access the software through an API. The system included multiple modules that
    talked to each other and resided on different services. To complicate the situation,
    the company had gone through several different versions of the system, and legacy
    code still resided in the production code. Various employees offered different
    answers about the product's composition because few understood the big picture
    that included all the elements.
  prefs: []
  type: TYPE_NORMAL
- en: After talking to operations and engineering staff, the engineering manager wrote
    a high-level summary showing the different modules and how they corresponded to
    the system. The manager created a detailed system diagram that showed the various
    servers and which modules were deployed to each one, including those used only
    by operations. The team used this summary for future testing and planning, which
    allowed for identification of modules to be removed from the system, lowering
    maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases, the core problem was that although construction of the product
    changed over time, nobody in the company drove the choices or documented them.
    Development management needs to work actively with marketing to define product
    composition and keep internal documents up to date. Product composition issues
    might appear to be unlikely problems, but they do occur regularly in small companies.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is some additional reading on topics presented in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *Crossing the Chasm*, by Geoffrey A. Moore (Collins, 2002) |'
  prefs: []
  type: TYPE_TB
- en: '| *Developing Products in Half the Time: New Rules, New Tools*, by Preston
    G. Smith and Donald G. Reinertsen (Wiley, 1997) |'
  prefs: []
  type: TYPE_TB
- en: '| *Effective Prototyping for Software Makers*, by Jonathan Arnowitz, Michael
    Arent, and Nevin Berger (Morgan Kaufmann, 2006) |'
  prefs: []
  type: TYPE_TB
- en: '| *Essentials of Marketing: A Global-managerial Approach*, by E. Jerome McCarthy
    and William Perreault (McGraw-Hill, 2005) |'
  prefs: []
  type: TYPE_TB
- en: '| *Software Requirements*, by Karl E. Wiegers (Microsoft Press, 2003) |'
  prefs: []
  type: TYPE_TB
- en: '| *The Marketing Imagination*, by Theodore M. Levitt (Free Press, 1986) |'
  prefs: []
  type: TYPE_TB
- en: '| *User Interface Design for Programmers*, by Joel Spolsky (Apress, 2001) |'
  prefs: []
  type: TYPE_TB
- en: '| *Winning at New Products: Accelerating the Process from Idea to Launch*,
    by Robert G. Cooper (Basic Books, 2001) |'
  prefs: []
  type: TYPE_TB
- en: Chapter 6. DRIVING RELEASES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-defined and well-built release process is vital to getting your company's
    software product into your customers' hands. In fact, the method you use to deliver
    the code is not as important as the release process you use to *prepare* it for
    delivery. A weak release process can not only add delays and unpredictability
    to your product delivery, but it can result in a low-quality product and a tarnished
    company image.
  prefs: []
  type: TYPE_NORMAL
- en: Small companies often have weak release processes because management doesn't
    realize the value of a well-defined plan. A company's release process isn't considered
    as important as product development and sales. Although the release process doesn't
    affect a company's *short-term* bottom line, ignoring its importance can lead
    to ill-advised approaches, such as emailing the product's executables to customers
    from a developer's computer.
  prefs: []
  type: TYPE_NORMAL
- en: An unplanned, "ad hoc" release will negatively affect the company's *long-term*
    bottom line. The problems created by past ad hoc releases become most apparent
    as your company starts to grow. Ad hoc releases are *not repeatable*, they are
    *impossible to support* long term, and they are *error prone*. A release that
    is not repeatable will lead to problems if and when you need to re-create and
    repair earlier release code, which typically occurs in supporting a customer using
    an older version of your product. Second, because of the casual nature of the
    delivery, ad hoc releases are difficult if not impossible to support. In some
    cases, engineers will ship a code copy built on a local machine rather than a
    copy from the source control repository, making it difficult to know which content
    ended up in which customer's hands. Third, ad hoc releases are error-prone because
    they do not go through the proper testing, documenting, and labeling necessary
    to ensure a high-quality, supportable release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other problems associated with poor release planning can create nightmares
    for small companies: Poor release naming can lead to mistakes in the content;
    releases can ship without plans for resolving customer problems; and customers
    can become upset because a delivered release was unexpected and they were uninformed
    of its contents.'
  prefs: []
  type: TYPE_NORMAL
- en: Release Planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most underrated aspect of the release planning process is its ability
    to reinforce or undermine your company's values and image. Over time, your releases
    should match your company's long-term vision, whether from the standpoint of strategy
    or corporate image. For example, if you want your company and its products to
    be known for their high quality, the release plans should support high-quality
    releases. If you want to be known for rapid innovation, releases should be innovative
    and frequent.
  prefs: []
  type: TYPE_NORMAL
- en: Release planning also involves thinking ahead about the type and nature of releases.
    For example, you might decide that engineering will not plan patch releases in
    advance because releases will be designed to fix only serious problems. However,
    engineering can plan for such releases' quick delivery. Mapping out in advance
    each type of release will better prepare your team for the inevitable changes
    and surprises that will occur. Planning a release strategy is much better than
    letting releases just *happen*.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the release timeline and associated early release strategy as part
    of release planning. Then, with guidelines in place, you can establish release
    criteria and processes to create more efficient and higher-quality releases.
  prefs: []
  type: TYPE_NORMAL
- en: Release Timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your company's *release timeline* is the most influential part of matching your
    release strategy to your company's overall strategy and product vision. A clear
    timeline allows for more realistic release plans and lets your company establish
    appropriate customer expectations. On the other hand, not planning release timelines
    means that your results will be variable and unpredictable, and they probably
    won't convey the image you want your customers to see. Develop a timeline with
    marketing and review it with the executive team to generate input and support
    to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This section is intended as an introduction to release timelines and timeline
    planning. Release planning requires an understanding of several topics covered
    in Chapters [Chapter 12](ch12.html "Chapter 12. PROJECT ESTIMATING"), [Chapter 13](ch13.html
    "Chapter 13. STARTING A PROJECT"), [Chapter 14](ch14.html "Chapter 14. PROJECT
    EXECUTION AND TRACKING"), and [Chapter 15](ch15.html "Chapter 15. DESIGNING A
    SOFTWARE DEVELOPMENT PROCESS")*.'
  prefs: []
  type: TYPE_NORMAL
- en: Your strategy for a release timeline will also define the types of releases
    you will create and guidelines for when they occur. When defining a release timeline,
    consider your customers' needs and your company's desired market image. For example,
    if your product is complex and customers want to upgrade versions only once a
    year, plan for major releases to occur yearly and optional minor releases to occur
    intermittently. At the other extreme, some product markets are highly competitive
    and change rapidly; quarterly or more frequent releases might be required.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the practical minimum time for a release. For example, if a release
    requires four weeks of testing and a two-week approval cycle, more than six weeks
    must pass between releases. Alternatively, if you are building a web-hosted product
    that can be tested in a single day, fewer timeline restrictions apply to your
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if your main product can be customized for individual customers,
    you could release customized versions more often than general releases. Another
    consideration is how far in advance your customers need to be informed of imminent
    releases. If, for example, customers require four weeks' notice before new software
    is released and available, having less than a four-week development cycle does
    not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have created an overall release strategy, consider your short-term
    plans for the next 6 to 12 months. During this period, you can map out your expectations
    for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of major releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of minor releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customized releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expectations for patches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expectations of work not included on the normal release cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these expectations in mind, you can plan and number the near-term releases.
    When you are assigning approximate timelines, allow gaps in your schedule to accommodate
    unexpected issues and patch creation. If you do not include time for surprises,
    you will be habitually late in releasing your product. Make sure you have an up-front
    agreement with marketing and other teams about the flexibility of timelines. If
    product release dates require rigid, unmovable dates, increase the buffer time
    to allow for unknown events and opportunities that will occur.
  prefs: []
  type: TYPE_NORMAL
- en: As you plan the next few releases, consider both start and end dates for each
    release cycle. Releases that consider only end dates can suffer from overlapping
    resource use if separate parallel release efforts are planned. By mapping out
    start and end times for each planned release, you can determine where and when
    resource conflicts might occur.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for your next major release, consider the milestones for that release
    before finalizing your plan. If you plan a release date without considering testing,
    approvals, customer checkpoints, alpha releases, or beta releases, you will have
    to backpedal later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look into the early release strategy and its impact on release timelines
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Early Release Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *early release strategy* is an approach that provides customers with prerelease
    versions of the product to improve the product definition and minimize the risks
    of uncovering problems in production or post-production. Companies use many different
    prerelease approaches, but this book uses the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: Alpha release
  prefs: []
  type: TYPE_NORMAL
- en: An *alpha release* is early product code delivered to a few customers who can
    test the product's features and concepts and offer feedback. This code has typically
    undergone limited testing by either engineering or QA, and it might not yet be
    feature-complete. Customers should anticipate lower quality since alpha code is
    not production ready.
  prefs: []
  type: TYPE_NORMAL
- en: Beta release
  prefs: []
  type: TYPE_NORMAL
- en: A *beta release* is early product code delivered to a few customers with intended
    final product features usually completed but not fully tested. As with the alpha
    release, the hope is that customers will provide feedback on product features
    and concepts. In addition, because the code has undergone more testing, customers
    can often use it for practical applications, which can help them provide early
    feedback about implementation problems or omissions. Customer expectation of quality
    varies depending on your company's history in delivering beta releases.
  prefs: []
  type: TYPE_NORMAL
- en: Limited release
  prefs: []
  type: TYPE_NORMAL
- en: A *limited release* is a complete, production-ready product release delivered
    to a few friendly customers before widespread release with the goal of identifying
    serious problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](ch06.html#release_types_alpha_beta_and_limited "Figure 6-1. Release
    types: alpha, beta, and limited") illustrates how a company might use these different
    release strategies at different points in the release cycle. Although the figure
    shows a milestone diagram, it does not imply any particular process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Release types: alpha, beta, and limited](tagoreillycom20090324nostarchimages266079.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6-1. Release types: alpha, beta, and limited**'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these approaches poses different risks and rewards. Review all three
    release approaches with marketing, and decide together which risks are appropriate
    for your company. All early releases impose costs on marketing and development
    that will slow delivery of the full releases.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha Release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alpha releases allow customers to offer useful feedback early in the production
    cycle while it is still relatively easy to make changes to the product code. In
    addition, customers can help you find problems that can be corrected well before
    QA has invested considerable time reviewing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two notable problems occur with alpha releases, however: First, customers often
    have inappropriately high expectations for the release. When reality does not
    meet those expectations, the customer can get a negative impression of the software
    and might not want to use the production version. To minimize such problems, you
    should properly describe the state of the alpha code to the customer along with
    the alpha release. Also consider adding a startup screen that highlights the fact
    that this is an alpha release with alpha code. This can help minimize problems
    that might occur, for example, if a primary customer contact passes the code to
    others in his company without passing them the disclaimers.'
  prefs: []
  type: TYPE_NORMAL
- en: A second problem occurs when customers use alpha releases in a production environment.
    Sometimes impatient customers will run their production data against alpha or
    beta code despite their having agreed not to do so. Then, when a serious problem
    occurs with alpha or beta code, these customers will argue for immediate repair
    and data recovery. The common justification? "The new feature was so critical
    that we needed it immediately." You can avoid this problem by disabling or limiting
    the capabilities of the alpha release to prevent a customer from using it in a
    production setting. Unfortunately, this might not always be possible, as some
    alpha testing requires that the product be used on large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If a customer has a history of misusing alpha releases, consider giving them
    only beta or limited releases or not using that customer for an early release
    program*.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, alpha releases are useful, but consider the risks and work to minimize
    them before shipping alpha code.
  prefs: []
  type: TYPE_NORMAL
- en: Beta Release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goals of a beta release are to get advance notice of problems when the customer
    uses the code and to get feedback on new features. However, making changes to
    the code in response to beta feedback can require production schedule changes,
    because beta code versions are typically sent to customers near the end of the
    release cycle—before QA has completed testing.
  prefs: []
  type: TYPE_NORMAL
- en: A beta release faces the same risks faced by an alpha release, but the quality
    risk is lower than an alpha because QA has completed more product testing. In
    a beta release, that extra QA testing lessens the chance of a code malfunction
    disillusioning the customer. It also provides a more appropriate opportunity to
    test the code in actual customer situations to determine whether customers can
    uncover any prerelease problems. Make sure your customers have a clear understanding
    about the valid uses and risks associated with beta code. To improve your beta
    results, engineering should let the customer know the true status of the code
    and set the proper expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Limited Release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A limited release differs from alpha and beta releases because the code is ready
    to ship. The goal of a limited release is to reduce the risk of widespread visibility
    in the event of problems. As a result, limited releases are sent only to *friendly*
    customers. This approach works well if errors or problems found post-release are
    costly to repair, especially if customer safety or data is at risk.
  prefs: []
  type: TYPE_NORMAL
- en: Because problems in the code haven't reached all your customers and the code
    is production-ready, the limited release is a risk-reduction technique. If someone
    discovers a large problem, a few users will be unhappy, but not your entire user
    base. The situation is better than a full release because the team can focus directly
    on fewer customers. If a customer finds problems, the release team can create
    a patch as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest disadvantage of this approach is that only a few customers review
    the code; most customers get the new final software a few weeks later. Limited
    releases also add to the overall cost of software development, as the development
    team does not fully focus on the next release during a limited release.
  prefs: []
  type: TYPE_NORMAL
- en: Planning Product End of Life
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Small companies can benefit from creating an *end-of-life* process—that is,
    a process for retiring products. Planning for this stage might seem odd at first.
    Most software managers in small companies think, "We just created our product
    line, so why would we think about killing parts of it? End of life is something
    that large companies worry about. Not us." However, end of life issues can arrive
    *earlier* in small companies that tend to attempt several different solutions
    to a problem. And every software product has an ongoing cost that small companies
    can least afford. The real benefits of a good product retirement plan are improved
    customer satisfaction, reduced internal costs of supporting your customer base,
    and improved profits if your company can remove unprofitable products from production.
  prefs: []
  type: TYPE_NORMAL
- en: When and how do you actually realize those benefits? When you're planning for
    your next release, review your products and consider candidates for end of life.
    From an engineering perspective, a good candidate could be software whose platform
    is old or obsolete. *Platform* in this case includes the hardware, operating system,
    or even a third-party software package. From a marketing point of view, the key
    factors for end of life are customer use and revenue. Products with small customer
    followings, significant technology issues, and little future potential might be
    good candidates for retirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s true that retiring a product can annoy some customers who still use it,
    but sometimes the cost of supporting that product exceeds the value to the customer
    and the company. You and your team are in the best position to identify the costs
    associated with ongoing builds, testing, support, and maintenance. You''re also
    best equipped to identify technical failings, which raises another important point:
    Sometimes development needs to take the initiative and raise the issue of retiring
    products. However, the engineers'' assessment must recognize and balance technical
    dislikes and costs to the business of product end of life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you reach internal consensus to retire a product, create an end-of-life
    process. This process keeps you from missing important steps that can cause problems
    for your customers, cost your company money, cost your customers money, and hurt
    your image with your customers. Major steps to consider for this process include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding customer impact
  prefs: []
  type: TYPE_NORMAL
- en: Marketing and sales can do the footwork to establish whether retiring the product
    will impact current customers. Consider providing an alternative solution for
    these customers among supported products.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing contractual and legal obligations
  prefs: []
  type: TYPE_NORMAL
- en: Establish whether contractual or legal issues affect product retirement. Legal
    issues might exist that govern how long you need to maintain customer data after
    you have retired the product.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plan and timeline
  prefs: []
  type: TYPE_NORMAL
- en: When you identify products for end of life, work out a timeline and plan the
    process with input from the marketing team. This plan should describe the steps
    and schedule required for removing the product from production.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with your customers
  prefs: []
  type: TYPE_NORMAL
- en: Inform customers of your decision as soon as you decide to retire a product.
    When possible, talk to customers directly and follow up in writing.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the steps
  prefs: []
  type: TYPE_NORMAL
- en: 'Your end of life plan should align with the release schedule so that you remove
    the product during a normal release. It should also include release-related steps,
    such as the following, for removing it as a supported product:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the product from the engineering software build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the code from the release media or platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the code from the packaging and release software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating the product end of life event in release notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning customer data
  prefs: []
  type: TYPE_NORMAL
- en: Many systems have customer data associated with them. Naturally, you need a
    method for returning the data to the customers. Engineering should identify a
    migration path for current customers to another available product to improve and
    sustain customer goodwill.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting or storing customer data
  prefs: []
  type: TYPE_NORMAL
- en: After you have retired the product and shipped the customer data, the plan needs
    to describe whether the customer data is permanently stored or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '**PRODUCT END OF LIFE**'
  prefs: []
  type: TYPE_NORMAL
- en: My company had a customer-customizable reporting interface to our production
    server. When I joined the company, I discovered that this product had no specification
    and had not been properly tested, and large customer reports could slow down the
    system for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: I first looked at testing and repair, but discovered that the estimated costs
    would be high. With marketing, we looked next at how it was being used and anecdotally
    heard that the usage was low.
  prefs: []
  type: TYPE_NORMAL
- en: By agreement with product marketing, we made this product a candidate for end
    of life. Marketing surveyed our customers. They found that customers occasionally
    used it. Unfortunately, one customer liked it. We decided to end of life the product
    and worked to create standard reports to meet the one customer's most common use.
  prefs: []
  type: TYPE_NORMAL
- en: Because we were a small company, the end of life for the offering occurred three
    months after the initial discussions. This decision reduced the testing burden,
    which was high for that product. It also prevented the future quality issues that
    would have occurred if more customers had started to use it, as the product had
    significant quality problems. Overall, it proved to be a good company decision.
  prefs: []
  type: TYPE_NORMAL
- en: —Director of engineering
  prefs: []
  type: TYPE_NORMAL
- en: Overall, planning for product end of life solves many potential problems and
    improves customer attitudes toward your company, even if they are unhappy with
    the end of life decision.
  prefs: []
  type: TYPE_NORMAL
- en: The Release Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *release process* describes the steps required to release the product once
    development has built and tested it. It is a single step in the overall product
    development process. To develop a release process, first consider the process
    goals. Internal releases need to be named clearly and consistently. The process
    needs to support customer communication about critical issues such as timing and
    features. It also needs to be repeatable, must minimize release errors, and must
    have a review and improvement mechanism in place.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look first at criteria for release, followed by advice for defining a
    release process.
  prefs: []
  type: TYPE_NORMAL
- en: Release Criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Release criteria* define what a successful release should look like. It answers
    the age-old question, "Are we there yet?" Knowing in advance what you expect in
    a release—when it comes to features, timing, process steps, and quality—will allow
    you to guide your team toward success while monitoring progress. If the criteria
    have gained consensus within your team, it can also minimize pressure to release
    the product prematurely.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem that often arises without release criteria is "tunnel vision." Without
    a definition of what a *completed* release means, engineering will focus only
    on delivery date. The release will consist of what is available near the delivery
    date, with less attention paid to functionality and quality.
  prefs: []
  type: TYPE_NORMAL
- en: Release criteria can and should be unique to each company. For example, a company
    whose product and image require high quality will produce release criteria of
    high minimum quality standards; a company that emphasizes customer satisfaction
    should produce release criteria that require proper customer communication prior
    to the release; and a company that emphasizes ease of use should produce release
    criteria that require specific approval ratings from customers before the product
    is shipped.
  prefs: []
  type: TYPE_NORMAL
- en: It is wise to work with marketing and consider your business needs before setting
    the release standards. Ensuring that you have corporate buy-in on those standards
    will help the team make good decisions when the pressure is on near release time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set release criteria, consider the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the minimum quality acceptable for a release?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the minimum testing required for each type of release? (For example,
    patch releases might have different testing standards.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of customer communication is required before and after a release?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the minimum that should be done in an emergency release? (An *emergency
    release* is a release that must be created immediately to prevent significant
    harm to the customer or your business.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the minimum level of customer data compatibility that's acceptable for
    a release?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the maximum delay for the release that does not significantly harm the
    customer?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the earliest that your company can release the software? (For some businesses,
    releasing server-based software early will be disruptive to customers who might
    be planning for changes on a specific day.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How extensively do features need to be described to customers well before the
    release? Is there room for making late feature set modifications without being
    disruptive?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When considering all of these criteria, be careful not to overdefine the minimum
    standards for a release. Sure, management wants the best in all categories, but
    from a practical standpoint, that cannot happen. It is better to emphasize one
    aspect of the release criteria with higher standards and set more generous lower
    standards for other aspects of the release to provide some flexibility in decisions.
  prefs: []
  type: TYPE_NORMAL
- en: With release criteria in place, defining a release process will simplify the
    mechanics of pulling a release together and make it easier to estimate and automate
    releases.
  prefs: []
  type: TYPE_NORMAL
- en: Process Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With these major goals in mind, consider several important steps when designing
    the *release process*. Integrate these steps into the major development process.
  prefs: []
  type: TYPE_NORMAL
- en: Final release naming and numbering
  prefs: []
  type: TYPE_NORMAL
- en: Engineering and marketing jointly define the final release name and release
    contents. Typically, marketing and engineering agree on release naming before
    the product is developed, but finalizing the names and numbers occurs near the
    end of the cycle, as changes might be required.
  prefs: []
  type: TYPE_NORMAL
- en: Early customer release notification
  prefs: []
  type: TYPE_NORMAL
- en: Marketing should provide customers with advanced notice of the release so they
    can plan for implementing the new product and not be surprised when it arrives.
    As early as possible, provide customers with release notification for any platform
    changes intended as part of the release. Customers might need to change usage
    or hardware to support your release and will be upset if they're notified too
    late to make a pain-free transition. This can also affect the customers' budgeting
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Customer release information
  prefs: []
  type: TYPE_NORMAL
- en: Engineering and marketing should create customer documentation as appropriate
    for the release—typically an update to existing documentation. This documentation
    can include release notes, marketing release communications, product brochures,
    press releases, and any pricing or service level changes. Engineering should review
    with marketing the final set of release changes and check marketing material to
    see the impact of late changes.
  prefs: []
  type: TYPE_NORMAL
- en: Release notes
  prefs: []
  type: TYPE_NORMAL
- en: The documentation team should produce release notes describing what is present
    in the release in a high-level overview. These notes describe changes in the release
    relative to the current version.
  prefs: []
  type: TYPE_NORMAL
- en: Informing customers of the status of their reported defects
  prefs: []
  type: TYPE_NORMAL
- en: Customers want to know whether defects they reported will be included in a release
    for their internal planning. A release process should require that customer service
    provide individual customers with the status of their reported issues relative
    to the release. Many software companies avoid doing this because of the time involved,
    but providing defect resolution notes can greatly improve customer goodwill. Customers
    will appreciate that you are being responsive to their needs. When the customer
    base is large, an acceptable alternative approach is to include a selected list
    of defect resolutions as part of the release notes. However, with a small customer
    base common to small growing companies, consider the individualized approach.
  prefs: []
  type: TYPE_NORMAL
- en: Internal training
  prefs: []
  type: TYPE_NORMAL
- en: Engineering, customer support, and marketing need to ensure that any staff working
    directly with customers are properly trained on the new release.
  prefs: []
  type: TYPE_NORMAL
- en: Product release
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the release engineer makes the software available to the customer.
    The physical release of the software can be through a CD, via a new download setup,
    or by switching the server software to the new version. Be sure to document and
    automate the release steps. The release process documentation should specifically
    describe the locations of the source files, configuration files, and releasable
    files. It should also provide enough detail so that anyone on the team could perform
    the product release.
  prefs: []
  type: TYPE_NORMAL
- en: Release acknowledgment
  prefs: []
  type: TYPE_NORMAL
- en: Marketing should inform customers of the product's release in an email right
    after the release ships.
  prefs: []
  type: TYPE_NORMAL
- en: Post-release review
  prefs: []
  type: TYPE_NORMAL
- en: After the release, host a review meeting to discuss issues that occurred during
    the release cycle and ways to improve the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Post-release tracking
  prefs: []
  type: TYPE_NORMAL
- en: QA should track the defect count and the customer call count after a release.
    Learning about customer concerns will lead to improvements in the code or documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Post-release Review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *post-release review* is an opportunity to review the last release, suggest
    changes to improve future performance, and boost team morale. The review meeting
    should include development teams as well as other teams involved in the release
    cycle: marketing, customer service, and QA, for example. Informal one-hour sessions
    will probably be sufficient. The session should cover these points:'
  prefs: []
  type: TYPE_NORMAL
- en: What went well in the release that we should continue doing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What were the problems, and what could we do differently?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What risks should we have identified earlier, and how can we spot them next
    time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How would we prioritize the problems we encountered?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What solutions can we identify?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a long release cycle that lasted more than nine months, a few post-release
    review meetings of one to two hours each can be helpful. These meetings require
    much preparation, and everyone should be aware of that. Create an agenda for each
    meeting, and ask all participants to come prepared with their thoughts on the
    agenda. Also, arrange for a conference room with a whiteboard and mark out general
    categories of problems that are relevant to the release to help people generate
    ideas during the meeting.
  prefs: []
  type: TYPE_NORMAL
- en: To get ideas flowing at the start of the meeting, pass out large sticky notes
    and ask participants to write down issues or problems, one issue per note. Each
    person can post one problem at a time and say a few lines about it. This is not
    the time for detailed discussion, however—it's about collecting thoughts and ideas.
    Move around the room from person to person to assure that everyone, even quiet
    team members, can have his or her say.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the length of the session, attendees can prioritize the issues
    and problems at the end of the meeting or in a second meeting. After you've grouped
    similar issues together, ask the team to set priorities for important outstanding
    issues. At the end of the prioritization, write up the results to highlight the
    issues and priorities and send this to everyone who participated. Then ask the
    group to be prepared to talk about potential solutions for the highest ranking
    problems at the next meeting. At a follow-up meeting, each person can present
    solutions to the highest priority issues, using sticky notes to summarize ideas
    in a single sentence. Avoid lengthy discussions on single topics until everyone
    has had a chance to present his or her ideas. In-depth discussions can occur later.
  prefs: []
  type: TYPE_NORMAL
- en: After the solutions meeting, write up the top problems and their solutions.
    Then ask team members to review the results and provide additional ideas. Select
    the problems you can address, and let the team know the plan for making improvements.
    Any problems you cannot address directly can be discussed with the executive team.
    Larger, expensive solutions might require that you write a business case to justify
    the costs and efforts. Large or small, make a good faith effort to address the
    important issues, and inform people about which issues you aren't addressing and
    why.
  prefs: []
  type: TYPE_NORMAL
- en: Be thorough and follow through with the ideas and solutions generated in post-release
    reviews. Conducting an abbreviated review with no follow-up can be worse than
    having no review at all, because a lack of attention to issues can result in staff
    cynicism and a belief that the problems will never improve.
  prefs: []
  type: TYPE_NORMAL
- en: Release Version Identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software naming and version numbering might seem inconsequential, but small
    companies often run into difficulties by not properly identifying their releases.
    Poorly identified releases lead to wasted time and effort due to the following
    possible consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Engineers add code to the wrong release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marketing sends the wrong information to customers about what is included in
    a release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QA and engineers find bugs difficult to track down because of improper release
    identification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nobody knows which customer has which release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This issue is so common in small companies that this chapter provides an extended
    discussion of product numbering issues and practices*.'
  prefs: []
  type: TYPE_NORMAL
- en: While large firms usually apply a well-defined version numbering sequence, small
    firms often use inconsistent version identifiers. Frequently, the first identifiers
    are release names based on feature sets. Examples would be the *Database Throughput
    Release* or the *Customer ABC Support Release*.
  prefs: []
  type: TYPE_NORMAL
- en: As your company gets a few releases under its belt, the need to identify each
    release in a unique and informative way increases for several reasons. Customers
    reporting issues need a clear version number to reference when reporting problems.
    Development needs to know which of the upcoming releases will get which critical
    feature. And both engineering and QA need to know which errors were found in which
    version to resolve each issue properly.
  prefs: []
  type: TYPE_NORMAL
- en: Clear release identifiers also make defect-repair planning easier, since you
    can assign individual defects to specific future releases. They also aid the documentation
    team in pulling together release notes. All of these reasons should push you toward
    an effective release naming method as early as possible in your company's growth.
  prefs: []
  type: TYPE_NORMAL
- en: Three-Number Release IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot of psychology in how people react to numbers—a version number
    of 17 might imply that the developers never got it right and had to keep putting
    out major releases, while when a major new version comes out, the company renames
    it something new, like *version 2.0*. Most software goes through quick cycles
    of initial growth and sustained use, and a common and simple numbering approach
    uses three numbers separated by periods, followed by a build number. This is referred
    to here as *three-number release identification* (or *release IDs*). With this
    method, an example release number could look something like *3.5.2 build 13* or
    *3.5.2 B13* (see [Figure 6-2](ch06s03.html#release_numbers_illustrated "Figure 6-2. Release
    numbers illustrated")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Release numbers illustrated](tagoreillycom20090324nostarchimages266081.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6-2. Release numbers illustrated**'
  prefs: []
  type: TYPE_NORMAL
- en: The first number is the *major release number*, sometimes known as the *marketing
    number*. This number is incremented no more than once a year, and it rarely gets
    far into the teens for most projects, because customers perceive version numbers
    such as *17.0.1* to be too old and outdated for their purposes—they expect a new
    major release instead of an updated old one. For long-lived products with many
    releases, marketing typically renames the product with a major rollout instead
    of issuing a new release number. Mature products do not undergo future major releases,
    only minor ones, limiting the first number.
  prefs: []
  type: TYPE_NORMAL
- en: The second number defines the *minor release number*, which represents feature
    changes rather than substantial changes to the system. A minor release occurs
    regularly during the year. Either *0* or *1* works for a starting value, but it
    should be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The third number, the *patch release number*, changes when a small defect is
    repaired (with a patch) in an existing release. This number can start with either
    *0* or *1* but should be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: A *build number* tracks the software executable version during the release cycle.
    For convenience purposes, most build systems auto-increment the build number with
    each new executable. A development cycle for a release requires the creation of
    multiple builds, which engineering and QA then evaluate and test. With such an
    iterative process, the build number uniquely identifies the final build from earlier
    builds of the release.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples help illustrate how to apply numbers to a sequence of releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.0.0 B104: Initial release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1.1.0 B99: A minor release with notable changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1.2.0 B57: Another minor release with notable changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1.2.1 B12: Patch release to 1.2.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1.2.2 B9: Patch release to 1.2.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2.0.0 B89: Major upgrade to first release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2.0.1 B14: Patch release to 2.0.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch Releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the release numbering system allows for patch releases, it should not
    *encourage* them. That's an important distinction. Treat patch releases as an
    admission of a mistake, not as a quick opportunity to drop in another feature.
    Marketing might put pressure on engineering to add a critical feature to a patch
    release, but resisting this temptation will allow the required patch to be released
    quickly and with properly focused testing. Adding new features should always move
    the release into the minor release category, which requires more testing and time
    to ensure proper quality.
  prefs: []
  type: TYPE_NORMAL
- en: Patch releases do require full regression testing to ensure that the patch does
    not make the product fail. Hence, patch releases have a high cost per benefit
    compared to a regular release.
  prefs: []
  type: TYPE_NORMAL
- en: Some companies avoid patch releases and bundle many patch issues into a quickly
    created minor release. This approach can be effective, but only if the minor releases
    go out often enough that your customers aren't suffering from the lingering problems.
  prefs: []
  type: TYPE_NORMAL
- en: Component Numbers vs. Release Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software releases commonly include more than one component or product that a
    customer uses. In a multi-component release, some components interact with other
    components, thus requiring a simultaneous release. The choice on how to label
    release components is both a marketing and engineering decision, because it has
    implications on customer perception, customer service, defect tracking, and engineering
    defect investigations. Consider the issues related to different component naming
    strategies while your company is in the startup stage, rather than waiting until
    your company is in the growth stage.^([[4](#ftn.CHP-6-FNOTE-1)]) A thoughtful
    component naming convention allows you to track the dependent pieces and use these
    names in discussions internally and with customers.
  prefs: []
  type: TYPE_NORMAL
- en: Each customer-viewable component in a release requires a unique identifier.
    One approach is to allow the components to keep individual numbers that change
    when the component changes and then bundle them together into the release. Another
    approach is to assign all the components in the release the same release number
    regardless of whether they have changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-3](ch06s03.html#two_approaches_to_component_numbering "Figure 6-3. Two
    approaches to component numbering") illustrates two common approaches—independent
    component numbers and dependent component numbers matching the release.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two approaches to component numbering](tagoreillycom20090324nostarchimages266083.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6-3. Two approaches to component numbering**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Independent component numbering* allows different numbers to be used for each
    component. In this approach, the numbers advance only when the component is changed.
    Tracking down components for a past release can be difficult down the road, however.
    A table showing the mapping must be publicly available and kept up to date so
    that teams working on the code can easily identify the source version of particular
    user-reported problems. Relying only on the source control system to track this
    is a poor strategy and is prone to operator error—plus, it''s time consuming.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dependent component numbering* matches the components to the release number.
    The modules all get their numbers advanced to the release number even if no code
    changes. This approach makes it much easier to track what changes are included
    in which modules in each release. Determining the history of defects in each release
    is much easier with common release numbering.'
  prefs: []
  type: TYPE_NORMAL
- en: Numbering Across Releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbering across releases has several different driving concerns. Most software
    consumers expect release numbers to be sequential. Development organizations assign
    release numbers early, often before development has a clear idea of what will
    go in each release.
  prefs: []
  type: TYPE_NORMAL
- en: Early release numbering can cause problems with sequential release numbering.
    Early release numbering reflects the *future* planned release order. The original
    intent for the release numbers was to release them in sequence, but this does
    not always work out.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-4](ch06s03.html#release_numbers_fixed_at_project_start "Figure 6-4. Release
    numbers fixed at project start") illustrates an example of out-of-sequence release
    numbers. At the start of release 2.3.4, the plan was to release 2.3.4 first and
    then 2.3.5\. In this case, development delayed release 2.3.4, while 2.3.5 shipped
    as planned. Following release 2.3.5, development released number 2.3.4, and now
    the numbering is out of order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A company can live with an out-of-order release sequence; however, an alternative
    approach is to renumber future releases so that numbers are always sequential.
    Sequential numbering avoids confusion months or years later when, inevitably,
    problems occur in a past release. Referring to [Figure 6-4](ch06s03.html#release_numbers_fixed_at_project_start
    "Figure 6-4. Release numbers fixed at project start"), when the planned 2.3.4
    release does not release before 2.3.5, you should retire the number 2.3.4 as a
    non-release and rename it with the next incremental number, 2.3.6\. Do not increment
    the number until it is clear where final delivery will fall relative to other
    releases. For this example, the timeline would look like that shown in [Figure 6-5](ch06s03.html#release_numbers_always_sequential_at_rel
    "Figure 6-5. Release numbers always sequential at release"). One caution when
    you renumber a release: Make certain that the documentation and the source code
    identifiers use the new number.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Release numbers fixed at project start](tagoreillycom20090324nostarchimages266085.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6-4. Release numbers fixed at project start**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Release numbers always sequential at release](tagoreillycom20090324nostarchimages266087.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6-5. Release numbers always sequential at release**'
  prefs: []
  type: TYPE_NORMAL
- en: Software for the Gentleman Farmer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a humorous cross-section of component numbering frustrations, read the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*All names are intended to be fictitious. Any resemblance to real names or
    companies is coincidental*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You own a software company, Givemeabreakfarming Software, Inc., that writes
    software for people who want to run small, part-time hobby farms but don''t have
    much farming experience. You produce a suite of products. The main product is
    FarmingBreak, and you also provide add-on programs to help with specific activities
    and crops: CowBreak, CornBreak, and WheatBreak. Customers must buy the main program,
    FarmingBreak, to use any of the add-on programs. After the first release, your
    products were all numbered 1.0\. The version number of each product is visible
    on the product''s user screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CowBreak product was rushed to release and had a weak feature set, so you
    provide an upgraded version four months after your first release. As you map out
    the next release, you realize that you have a numbering choice. You can do one
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Increment all items to version 1.1 and recompile all the modules to match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment only CowBreak to 1.1 and leave the other products numbered at 1.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You decide to take the easy way out and modify only CowBreak. This avoids having
    to increment the number for all products to 1.1 and then explain to customers
    that nothing has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Later you reach another decision point for the WheatBreak upgrade release. Should
    you call it 1.1 or go to 1.2? You elect to call it 1.1\. Immediately after the
    release, a major problem is found, so you have to send out a patch. After the
    patch, WheatBreak is numbered 1.1.1.
  prefs: []
  type: TYPE_NORMAL
- en: You again modify CowBreak and name it 1.2 to add major dairy functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As your business progresses, you map out a release to FarmingBreak, which you
    decided to call version 1.1\. However, you have to change the database, and all
    of the products need to be recompiled to new versions, so you up their numbers.
    Now you have FarmingBreak at 1.1, WheatBreak at 1.2, CowBreak at 1.3, and CornBreak
    at 1.1\. For new customers, this doesn't pose a huge problem—you just send them
    the latest versions of your software regardless of the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few years down the road, your products are at the following version numbers:
    FarmingBreak 1.8, WheatBreak 1.9.2, CowBreak 1.4, CornBreak 1.5.3, and SoyBreak
    1.1.3\. During this time, you make one more database change that is incompatible
    with past versions. A customer calls with a problem in FarmingBreak 1.5 that you
    recall fixing a while back in FarmingBreak 1.6\. The customer also has CornBreak
    1.3.1 and SoyBreak 1.1\. You agree to ship him an updated FarmingBreak copy, but
    you can''t remember whether his other products are compatible or not. Furthermore,
    he doesn''t want to upgrade to your latest versions, as he heard they were slow—so
    that eliminates the easy solution. At this point, you don''t have version compatibility
    at hand and can''t easily tell what is compatible, since you didn''t keep all
    the products synchronized in version number. To resolve this situation, you stay
    up all night and read your notes until you can figure out which version numbers
    go with the customer''s release. You then re-create those versions to ship to
    the customer, since you didn''t save compiled copies, only the source.'
  prefs: []
  type: TYPE_NORMAL
- en: Vowing to clean up some of your mistakes, when you make some major upgrades
    to FarmingBreak, you increment all your products to 2.0 and archive copies of
    the code. From now on, you will keep your product numbers synchronized so you
    won't have to keep capability notes. Version 2.0 is a success.
  prefs: []
  type: TYPE_NORMAL
- en: 'With success in hand, you announce to the press that version 2.1 is due out
    in six months. Two months after the announcement, your marketing team (yes, your
    company has grown) insists that CucumberBreak must have an immediate release in
    one month to deal with a strong competitor. Now you have a problem: If you call
    CucumberBreak version 2.1, then your main release will have to become 2.2, but
    you already announced it as 2.1 and have done all of your internal planning using
    that number. Hmm … maybe you jumped too quickly to synchronized numbering. You
    decide to keep the *main release* name as 2.1, but you allow release components
    to have numbers out of synchronization with the release. Going forward, you will
    keep careful records of component capability.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-6-FNOTE-1)]) See the book's introduction for definitions of various
    company stages.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is some additional reading on topics presented in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *The Build Master: Microsoft''s Software Configuration Management Best Practices*,
    by Vincent Maraia (Addison-Wesley Professional, 2005) |'
  prefs: []
  type: TYPE_TB
- en: '| *Manage It!: Your Guide to Modern, Pragmatic Project Management*, by Johanna
    Rothman (Pragmatic Bookshelf, 2007) |'
  prefs: []
  type: TYPE_TB
- en: '| "Software release life cycle," from Wikipedia, [http://en.wikipedia.org/wiki/Software_release_life_cycle](http://en.wikipedia.org/wiki/Software_release_life_cycle)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Software Release Methodology*, by Michael E. Bays (Prentice Hall, 1999)
    |'
  prefs: []
  type: TYPE_TB
- en: Chapter 7. EVALUATING YOUR TOOLS AND METHODS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern software development requires that a set of key tools and methods be
    used to protect intellectual property, produce quality code, and manage operations
    efficiently. Although large companies can afford a large support staff to maintain
    tools and enforce the use of specific approaches, small companies do not often
    have that luxury.
  prefs: []
  type: TYPE_NORMAL
- en: Failing to protect your company's *intellectual property* is gambling with your
    company's assets and shareholder value. *Intellectual property* doesn't just refer
    to your company's code, it also includes how you build and release your product,
    your ideas and data, how you track defects (bugs) and the defect data, and what
    technical documentation you create. A large component of a small company's value
    consists of intellectual property. If your company is being sold, the purchasing
    company considers the intellectual property as part of the offer price. If you
    have poorly maintained your company's intellectual property, then the buyer will
    see less value and make a lower offer for your company.
  prefs: []
  type: TYPE_NORMAL
- en: 'To protect your intellectual property, and ultimately your company''s value,
    review your tools and the methods you use in at least the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Data backup Have a systematic and automatic approach to creating secure secondary
    backup copies of data on a regular basis.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Document availability Provide an easy method for making available all technical
    and product documentation for internal use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Source code control and configuration management Track and archive source code
    files during and after development, and identify sets of files into defined releases.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Software builds Control how the software source creates the executable code
    that clients can use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bug tracking Use appropriate technology to track defects (bugs) and their repair.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Release method Employ the appropriate methods and technology to release your
    software.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider *tools and methods* in terms of your overall software development processes
    and practices throughout software development and support. [Figure 7-1](ch07.html#tools_and_methods_used_across_the_softwa
    "Figure 7-1. Tools and methods used across the software release cycle") illustrates
    this interaction. *Backup* and *document communication* cover the entire software
    release cycle. *Source code control* and *software builds* apply during code development
    until development releases the product. *Bug tracking* tracks problems discovered
    at any time. The *release method* describes the process of making the product
    available to your customers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the different tools and methods used across the software
    release cycle, individually and in detail. Although some considerations might
    seem routine, digging deeper can help you uncover hidden risks and opportunities
    for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tools and methods used across the software release cycle](tagoreillycom20090324nostarchimages266089.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7-1. Tools and methods used across the software release cycle**'
  prefs: []
  type: TYPE_NORMAL
- en: Backing Up Intellectual Property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *backup mechanism* provides the first level of protection for your company's
    intellectual property. Without a backup mechanism in place, all intellectual property
    can disappear instantly if it resides on your server's disk drives, because disk
    drives can and do fail for a number of reasons. In addition, without having secure
    backups, you can lose intellectual property due to a fire, a malicious hacker,
    or a malevolent employee. A development manager must either ensure that a backup
    mechanism exists or immediately direct its creation. If a separate IT organization
    backs up your intellectual property, you should review the organization's backup
    strategy. Often you will be surprised to find that your important data is not
    a part of their backup strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several best practices are recommended for file backup. You can customize these
    to your company''s needs based on costs and staffing requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Full copies of files are stored on permanent media (tape or CD, for example)
    and are not overwritten.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full copies are stored on a regular basis in an offsite location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users are notified about which parts of the file system are backed up so that
    they can appropriately store their critical data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup copies are made daily. A company usually can't afford to lose more than
    a day's data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control and configuration management tools are used and the repository
    is backed up. To be effective, this requires team discipline, as the team needs
    to check files into the repository often.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoration of files from the backups is tested periodically. Otherwise, system
    administrators can discover backups that are incomplete or unusable after disaster
    has struck. Common causes of backup problems are ignored error messages in the
    backup logs, unexpected mechanical device failures, and the omission of needed
    files from the backup list. Test your backups at least once a quarter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Backup failures discovered after disaster strikes are a common occurrence,
    so the remedy bears repeating: Regularly test your backups by restoring backed
    up files to test their viability*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of different backup approaches can be used, with different trade-offs
    for complexity, cost, risk, time to implement, and time to recover data. Your
    choice will depend on how you determine the relative balance of these needs for
    your company. Common backup approach considerations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Amount of disk space to include in the backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choice of backup media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amount of automation in the backup process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of use of the equipment versus associated costs to purchase and staff time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularity of the backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage location of backup media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choice of complete backups or partial backups on a regular basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup Frequency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three common approaches to frequency of backup are used:'
  prefs: []
  type: TYPE_NORMAL
- en: Daily full backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weekly full backups, with daily differential backups from the last full backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monthly full backups, with weekly differential backups and daily incremental
    backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companies also use variations on these approaches. [Figure 7-2](ch07.html#three_backup_approaches
    "Figure 7-2. Three backup approaches") illustrates these approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '![Three backup approaches](tagoreillycom20090324nostarchimages266091.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7-2. Three backup approaches**'
  prefs: []
  type: TYPE_NORMAL
- en: These approaches trade off administrator time and backup media space for ease
    and availability of data recovery. *Daily full backups* require the most backup
    media and potentially the most operator time, depending on the equipment used
    to perform the backup. However, a full backup approach allows you to restore files
    using a single day's stored backup, while other approaches do not permit this.
    You should start with this approach. When the backup time starts taking too long,
    try differential backups.
  prefs: []
  type: TYPE_NORMAL
- en: '*Weekly full backups plus daily differential backups* from the last full backup
    takes less time during the week than full backups. However, in some cases you
    might need two sources of backup media to recover multiple files. The extra effort
    in recovery and the time to recover creates an effort "hill" you''ll need to climb
    to recover files. This extra effort can make the backup administrator slow or
    reluctant to locate file versions that have been inadvertently lost. This approach
    works well for companies in the growth stage.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Monthly full backups with weekly differential and daily incremental backups*
    require the fewest number of backup media and administrator efforts over a given
    month. However, a series of tapes can be required to recover a set of files. Set
    up each weekly differential to cover all files that changed since the weekly backup
    (and not the last weekly). Avoid this approach unless you must back up large amounts
    of data and you have limited backup capabilities, or you are not concerned with
    time involved for file recovery during normal business operations.'
  prefs: []
  type: TYPE_NORMAL
- en: If full or full-plus-incremental backups don't seem right for your situation,
    you can use other strategies regarding frequency and amount of data for your backups.
    For example, the backup administrator could modify the approach to conduct full
    backups every *other* day. This would save backup time, but it increases the loss
    risk to two days' work instead of one day's work. Alternatively, the administrator
    could perform the incremental backups to cover only a single day's changes. An
    example would be setting Friday's incremental backup to cover only Friday's changed
    files instead of all the changes that occurred since the last full backup. Recovering
    the system to Friday's state would require the last full backup media plus all
    the incremental backups created that week. However, with this approach, the daily
    backups will take less time during the week. This modification trades administrator
    time for decreased cost to recover files.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should choose the simplest backup and recovery approach when
    you're starting out—probably one of the first two options. As the data grows,
    look at other strategies and consider changing your backup equipment to minimize
    administrator effort. However, don't skimp on performing proper backups on important
    information because the backups take too much time.
  prefs: []
  type: TYPE_NORMAL
- en: Offsite Copies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regardless of the backup approach you choose, you should move your backup copies
    offsite to another location on a regular basis. Your choice of backup schedule
    reflects the trade-off of effort and risk. On the risk side, consider how many
    days of development work your company could afford to lose as part of disaster
    recovery. On the effort side, consider how much time your company can afford to
    spend making additional copies and moving them offsite.
  prefs: []
  type: TYPE_NORMAL
- en: As tapes can be required to recover lost files, consider the time hit spent
    creating tapes for shipment offsite. An expensive and time-consuming approach
    is to create duplicate copies for onsite and offsite copies every night. Most
    small companies use a simple approach of alternating onsite and offsite storage
    of their full backup copies. This approach is not very expensive, but it makes
    file recovery more difficult when you need to recover a file that is stored in
    an offsite backup.
  prefs: []
  type: TYPE_NORMAL
- en: Some customers might compel you to keep offsite copies of product code. Additionally,
    some customer contracts can require *software escrow* (periodic archiving of your
    source code with a third party). Customers ask for software escrow to minimize
    their risk; if your company fails, the customer receives a copy of the source
    code. This requirement forces periodic full backups of parts of your source code
    in addition to the regular backups.
  prefs: []
  type: TYPE_NORMAL
- en: Most small companies look for simple solutions to offsite backups. If you start
    with the assumption that a disaster will damage only your physical facility, then
    moving copies out of the facility will be sufficient. The media should be stored
    in a commercial backup storage facility or a second building in the same town—not
    at the administrator's home. Storing backup media in a person's home can be a
    problem if the person leaves the company (or the country).
  prefs: []
  type: TYPE_NORMAL
- en: To create your offsite backups, you could create an additional copy of each
    backup daily, but this would double your daily backup time. Instead, take full
    backups from your regular process offsite. If you need quick access to backup
    files in your facility, consider making duplicate copies of offsite backup media.
  prefs: []
  type: TYPE_NORMAL
- en: Disk-Only Backup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some system administrators use a dangerous backup practice of making periodic
    image copies of disk files to another disk, overwriting the last copy. When used
    as the sole backup mechanism, this method suffers from many weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Corrupt source files might corrupt the backup copy and permanent records do
    not exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A disgruntled employee can alter the data. The backup files will store a copy
    of the problem code as the administrator creates these periodically but does not
    create a permanent record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally, hardware does fail. Although unlikely, both disks could fail,
    obliterating all your files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can delete files by accident. If you discover a lost file after the administrator
    makes the backup image, you cannot recover the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk-to-disk backups are usually done with onsite disks. Consequently, if disaster
    strikes your building, you will have lost everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, avoid disk-only backup approaches in which you image your data and
    then overwrite the image. It will not help if you need to restore a file that
    was deleted weeks ago. Instead, back up to a permanent or stable medium. A disk-to-disk
    backup can be cost and time effective only if different images are made and saved
    regularly and a complete backup is kept on permanent media.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Managing Development Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can improve your development team's productivity by making development documentation
    easy to create and access through wikis, intranets, or content management systems.
    This will encourage the creation and use of documentation. Not having a system
    will lead to minimal documentation being created and shared.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many managers ignore documentation during the company startup
    phase because of lack of interest and because its absence does not appear to be
    an immediate problem. A small team can track internal documents easily, but as
    the team and product line grows, tracking all the internal documentation becomes
    difficult because of the number of documents and versions that can exist. Locating
    the most current version of a file for a six-month-old project requires an archeologist's
    skill and patience when a documentation repository does not exist or the document
    creator is no longer with the company.
  prefs: []
  type: TYPE_NORMAL
- en: With no development documentation, the task of training new people is difficult.
    The lack of documentation also wastes the time of the current team as they try
    to locate information that doesn't exist. As individual engineers store pieces
    of essential information, lack of diversified information creates a bottleneck
    when a key engineer is not available—development can get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: Small company development environments often release many projects in rapid
    succession; you can't expect developers to remember the details of projects from
    more than a few months back. The cost of poor documentation can be realized months
    or years later when developers badly need the information. Trying to understand
    someone else's code can be difficult enough; trying to understand the motivations
    of specific design decisions can be nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Development documentation covers many topics in addition to functional specifications.
    Here is a sample list of categories to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Product definition documents and specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical background information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal design documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer system architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data file format information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database design schemas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application programming interface (API) description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use various methods to make internal documentation available in small
    firms. Simple methods include keeping the main copy on local directories of work
    machines, emailing copies of documents to those who need them, creating copies
    in shared directories, and creating intranet pages and links.
  prefs: []
  type: TYPE_NORMAL
- en: All of the simple approaches have drawbacks, however. Document submitters can
    find many categories in which to place a file, and the team can find it difficult
    to track down the desired information. In addition, when a developer locates the
    information, she might not be able to determine whether she found the current
    version. With some approaches, opening the documents requires many mouse clicks.
    Simple approaches limit the file or text formats that are acceptable and do not
    block simultaneous edits. Finally, simple approaches do not provide levels of
    restricted access, so everyone has full access to every document.
  prefs: []
  type: TYPE_NORMAL
- en: One reasonable solution is to set up a wiki with a tool such as MediaWiki ([http://www.mediawiki.org/](http://www.mediawiki.org/)).
    Wikis are simple to use, but creating and editing wiki pages is not always "what
    you see is what you get," or WYSIWYG—it can involve a multi-step process of cutting,
    pasting, and formatting information into the wiki from other documents. Wikis
    also require an administrator who can set up and maintain the site.
  prefs: []
  type: TYPE_NORMAL
- en: A *content management system* provides a method for everyone to access and edit
    documentation. A number of great open source systems are available, with Plone
    ([http://plone.org/](http://plone.org/)) being one good example. Excellent commercial
    systems exist as well, such as Microsoft Project Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits generally exceed the costs, however, as a good system will:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow easy searches for files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow different levels of access for different account groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make file uploads simple for all file types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make reading documentation easy, requiring a single click to open and instantly
    view documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple commercial and open source tools are available for use in creating
    collaboration sites. Selecting the proper content management tool, setting it
    up, and maintaining it constitutes a major project. In addition, the content system
    administrator will require time to set up the system and organize the data. You
    will need to assign a person to drive the process.
  prefs: []
  type: TYPE_NORMAL
- en: All data storage systems need a *gardener* to keep them organized. Without constant
    maintenance, the data in the systems quickly becomes "weedy" and out of date.
    As the data grows, the administrator will reorganize the layout as needed and
    manage or archive data that has become too old.
  prefs: []
  type: TYPE_NORMAL
- en: Source Control Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Source control versioning (SCV)* software allows you to save and retrieve
    multiple versions of different files, tag groups of files, and retrieve desired
    versions of files in a straightforward way. SCV software allows a team of development
    engineers to work on a product collaboratively, effectively sharing the use of
    a common set of source files. SCV software acts as a traffic cop to avoid file
    collisions and an archivist to track which files correspond with which product
    version.'
  prefs: []
  type: TYPE_NORMAL
- en: SCV software supports the definition of *named versions* of sets of the source
    code files. With SCV software, you can re-create a named version of the code later.
    SCV software also helps manage conflicts when two developers want to use the same
    file at the same time. An engineer can reserve, or *lock*, a file for editing,
    preventing other engineers from modifying that file while it is locked. Without
    SCV locks, an engineer working on a file could find her changes overwritten by
    another engineer who modifies the same particular source file.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Review the default behavior of your system for file checkout and locking.
    A common problem for engineers is assuming they have a lock on a file when they
    check out the file from the repository, but the default behavior for many systems
    is to lock files only when specifically requested to do so. Choose and configure
    your tools carefully to achieve the desired behavior, and then train your team
    to use the tools properly*.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a second engineer can make his changes on a duplicate copy of
    the source file and use the SCV *merge* feature to merge his changes in with the
    first engineer's changes after the lock is released. Newer SCV systems have effective
    merge systems that allow for two sets of changes to the same file to be correctly
    combined under the review of the last engineer checking in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Unfortunately, file merge can be flawed or can get confused on some SCV systems,
    effectively corrupting the resulting file. In some cases, sections of code or
    bug fixes are inadvertently removed from the source file without clear detection
    by the merging engineer. Engineers need to check the source file carefully to
    ensure that the merge was handled properly*.'
  prefs: []
  type: TYPE_NORMAL
- en: Although SCV systems are well entrenched in software companies, management rarely
    defines best practices for their use. It is a good idea to set up best practices
    for the development team to minimize errors and potential team friction. These
    include the following practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'For single-repository systems: Allow single-person checkout of files.'
  prefs: []
  type: TYPE_NORMAL
- en: This method implies that only a single engineer can check out a file for modification
    at one time and avoids the potential for code merging. Automatic code merging
    causes problems that you might not see until after a release, because it can accidentally
    and silently remove earlier repairs from the system. An alternative is to require
    manual merging of files for cases in which multiple engineers need to work together.
    If a developer must perform a manual merge of files, he can carefully inspect
    the merged code sections. If they overlap, the developer can create a new version
    of the code to incorporate both sets of changes as appropriate. Even with a careful
    merge, the merged code often has unexpected behavior because each engineer built
    his code from what was previously there, not accounting for the others' changes.
  prefs: []
  type: TYPE_NORMAL
- en: When planning work, ask developers to examine the sections of the code with
    which they need to work in advance and set up a process that avoids coding collisions.
    Developers can work around each other, communicating clearly about where in the
    code they are working and being considerate about how long they check out common
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This recommendation does not apply to systems designed to work without a single
    main repository, such as Git*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For single-repository systems: Lock-breaking should be rare.'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking locks on other engineers' files is a bad practice. An engineer who
    needs a locked file should first ask the lock holder to check in her work. Breaking
    another engineer's file lock forces her to merge her changes into your file. Merging
    is time consuming if done by hand and error prone if done automatically. Both
    types of merges often lead to hard-to-find errors and create the potential for
    bug repairs to be accidentally dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This recommendation does not apply to systems designed to work without a single
    main repository, such as Git*.'
  prefs: []
  type: TYPE_NORMAL
- en: Comment file check-in notes should be descriptive and useful.
  prefs: []
  type: TYPE_NORMAL
- en: Comments should always be required for all code check-ins. The comment should
    be descriptive—simply adding "fixed bugs" is not useful to anyone. Describe the
    defect number as well as the section of the code that is changed to make the comment
    useful for other team members and QA. Descriptive comments are especially useful
    for tracking down defects as regression behavior changes.
  prefs: []
  type: TYPE_NORMAL
- en: Use macro variables to simplify build identification.
  prefs: []
  type: TYPE_NORMAL
- en: Key names and numbers in the code are changed as new builds are created and
    files are checked in. Most source control systems have macro languages that allow
    for easy substitution of text into the file during check-in. Examples of common
    macro items are product names, release versions, build dates, build numbers, copyright
    years, legal disclaimers, and version numbers. The development team should be
    required to use the macro feature.
  prefs: []
  type: TYPE_NORMAL
- en: Using macro names makes it much simpler to keep source files up to date when
    global information changes. For example, the user interface can display the product
    version numbers to the client, enabling them to associate problems with specific
    code versions. Macros eliminate the need to check the version number manually
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Other approaches to automatically labeling code versions exist, including
    using build-and-release systems to update the numbering*.'
  prefs: []
  type: TYPE_NORMAL
- en: Companies in the very early stages of development do not always use a source
    control system, especially if only one to three engineers are on staff and they
    communicate frequently and maintain separate files. As these companies add developers
    to the team, they might resist using a SCV system because of the extra effort
    involved in setting them up and using them. Startup engineers can resist SCV systems
    on cultural grounds, as they like the idea of working "fast and loose." In this
    environment, you'll need to provide careful preparation and introduction of the
    system. Involve the engineers in the discussion and point out the costs of "fast
    and loose" when new engineers end up inadvertently stomping on others' work and
    the difficulty of recovering an older version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: SCV packages vary considerably in quality, complexity, and scope. Some tools
    are tightly integrated with information reporting, bug tracking, and build systems.
    Investigate at least three packages before settling on one to use.
  prefs: []
  type: TYPE_NORMAL
- en: Software Build Method and Timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *software build method* is the approach you use for extracting the desired
    versions of source files, creating one or more executable versions of the code,
    and then storing it in the appropriate location for use. A standardized software
    build method ensures that one set of source files compiles into the same program,
    thereby avoiding the potential errors of manual program creation. Usually, the
    build method interacts with the source control tool.
  prefs: []
  type: TYPE_NORMAL
- en: In small companies, software build methods often start out being ad hoc designs.
    Different programs have different build methods because the methods were created
    by different engineers, probably at different times. Ad hoc designs are often
    problematic, and few people know how to use them. One engineer might be the only
    person who knows how to build certain program executables.
  prefs: []
  type: TYPE_NORMAL
- en: You must ensure that the build process for each product is *written down* and
    *tested successfully by a second engineer*. Having a second engineer go through
    the steps of building the code usually ensures that the instructions are correct.
    Often the creator of the instructions will leave out details or make mistakes
    because she knows the process too well. Ask the engineer in charge of the build
    to include a list of common problems that could occur and potential solutions
    to these problems.
  prefs: []
  type: TYPE_NORMAL
- en: When builds are done regularly, productivity is affected as well. Most small
    companies start out creating builds as needed. As the team grows larger, build
    collisions occur, with two engineers trying to build the code set at the same
    time, but using different files. At this point, regular builds become essential.
  prefs: []
  type: TYPE_NORMAL
- en: '*Daily builds* work best, although development can build the software less
    often. At some companies the daily builds are really *nightly builds* that occur
    every evening. With daily builds, the build administrator finds file check-in
    mistakes daily, instead of later in the development cycle. In addition, the team
    will not push to delay a build so they can add more features or code—with weekly
    or less regular builds, the team might be tempted to delay weekly builds to accommodate
    last-minute changes. The team will also discover code integration problems after
    a while, making the debugging and repair considerably more difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: Building software during working hours has advantages over nightly builds. Daytime
    builds allow the team to see problems immediately so that the developer who created
    the problem can fix it quickly. With a nighttime build, the developer who created
    the problem might not return to work until later in the morning, leaving other
    developers with the task of cleaning up the problem or sitting idle, waiting for
    the developer's return.
  prefs: []
  type: TYPE_NORMAL
- en: With either nightly or daily builds, the developer who creates the problem should
    be held responsible for fixing it promptly. Breaking the build breaks the team's
    momentum and adds delays to the project. As developers can perform trial compiles
    and tests in their own local accounts, they have few excuses for breaking the
    build.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The best approach is for the build administrator to configure development
    sandboxes at the start of the project to ensure consistency of layout and versions.
    Mismatched sandboxes can lead to broken builds after check-in of code*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the code becomes more complex and the team grows larger, you should hire
    a single person to control and monitor daily software builds: a *build engineer*.
    The build engineer builds the software, maintains the build tools, and reviews
    build problems from the previous night. Require the build engineer to pursue build
    problems until they have been resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you should move from an ad hoc build system to a repeatable system
    that runs regularly. Do not wait until your company is in growth mode to set up
    the system. Document this system and have an alternative engineer trained to understand
    how it works. Finally, treat your build system as an important part of your development
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Software Release Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software release process describes the tools and methods required to get
    the software into the customer's hands. A release process moves the executable
    and supporting files into the release location. The process can include automatic
    changes to the database, creation of multiple image copies of files for multiple
    servers, and changing of file attributes so they correctly run on the production
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: As software distribution models vary considerably, release processes vary as
    well. The mechanisms of the process include customer downloads from a website,
    CD distributions, or files copied to customer-acceptable servers.
  prefs: []
  type: TYPE_NORMAL
- en: Like many processes, the software release process in small companies is usually
    ad hoc. As the software and product line become more complex, the frequency of
    release mistakes will increase, as each release is often a slight variation on
    a basic theme, providing opportunities for typing mistakes or mistaken assumptions
    about what is required to use the release.
  prefs: []
  type: TYPE_NORMAL
- en: At many small companies, only one person knows how to release the product—releasing
    software is a thankless task and not interesting to many engineers. If the engineer
    releases the code properly, nobody notices; if the engineer makes a mistake, everyone
    complains. Making the release effort more appealing to engineers is difficult,
    but showing appreciation for the engineer's effort is always worthwhile. In general,
    spread the release knowledge around the team and make it as simple as possible.
    Ensure that the release engineer writes down the process clearly and that at least
    two other people know the release process.
  prefs: []
  type: TYPE_NORMAL
- en: You should automate the release process as much as possible. Release automation
    can be as simple as shell scripts, or you can include more complex scripts or
    commercial programs. In all cases, automation not only shortens release time,
    but it reduces release errors. Serious release mistakes can take days of engineering
    work and recovery time.
  prefs: []
  type: TYPE_NORMAL
- en: As the company grows, teams other than engineering can take over the release
    process, such as members of the IT or operations groups. Not having releases assigned
    to your team does not mean that you can ignore associated problems, however. Work
    with the managers of the other teams to improve the release workflow. Some additional
    engineering effort can lead to savings for the company overall.
  prefs: []
  type: TYPE_NORMAL
- en: '**RIGHT INSTRUCTIONS, WRONG ORDER**'
  prefs: []
  type: TYPE_NORMAL
- en: Our company had a separate release engineer who released the software during
    the nighttime when the server was not heavily used. The engineering team would
    create a set of release instructions, which QA would test, and the release engineer
    would execute to release the software.
  prefs: []
  type: TYPE_NORMAL
- en: On one release, the release engineer executed the release instructions in the
    wrong order. This led to product data being improperly updated. Several engineers
    worked for three days to fix the problem, as they had to write custom SQL scripts
    to correct it.
  prefs: []
  type: TYPE_NORMAL
- en: —Director of engineering
  prefs: []
  type: TYPE_NORMAL
- en: Bug-Tracking System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bug-tracking software records problems and enhancement requests for your company's
    software products. Many different commercial and open source tools are available
    with different feature sets. Given the significant capabilities of this software,
    you should select an available tool rather than creating an ad hoc tool of your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bug-tracking programs are a necessary part of a quality assurance process.
    Note that tracking of defects is only a part of the total QA process, which includes
    unit testing, test planning, traceability of test coverage, and recording, evaluation,
    repair, and validation of defects. Spend time considering your choice of tools
    based on how well they support the QA process you want to put in place. Some common
    issues that arise when considering bug systems that might affect your choice are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cost If the bug-tracking system is expensive on a per-person basis, deploying
    it to everyone in the company may not seem cost effective.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Configurability of workflow Some systems have very limited ability to change
    their built-in defect workflow, which would force you to match their flow.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data collection Some systems will not allow you to change the data collected
    at each step or put entry restrictions on the data users enter during each step.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remote access Systems have variable abilities to permit access and bug entry
    remotely. If you have development teams working on the same product internationally,
    this could be a big problem.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reporting A manager's ability to see what is going on depends on flexibility
    in getting reports of the data in the system. Reporting capabilities vary considerably.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SVC integration Integration with source control systems can simplify associating
    bugs with code.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Small companies tend to use bug-tracking tools in sloppy and changeable ways,
    leading to wasted efforts and quality problems. Here is a humorous top ten list
    of abuses of a defect-tracking tool. Avoid these strategies at all costs:'
  prefs: []
  type: TYPE_NORMAL
- en: Submitters do not review and "close" defect reports when development makes the
    repair and assigns the defect ticket back to submitters for review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reported problems are ignored by the assigned engineer because no process for
    nagging the engineer exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submitters enter a defect so badly worded that nobody can figure out the problem
    or whether a problem even exists. When asked, the submitter does not remember
    what he was concerned about.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defect submissions describe ten different problems in one defect report so engineering
    finds it nearly impossible to close the ticket out or track any of the problems
    individually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A defect submitter assigns the problem an incorrect and unusual status state,
    making the defect untracked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A submitter enters a core-dump error message into the defect system but does
    not include an explanation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A submitter's full defect report says "the software is broken."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system administrator turns on the email feature of the defect system so
    that email replies automatically log into the defect system—along with all of
    the reply messages in the email chain. Defects become massive in size and nearly
    impossible to read after a few exchanges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A support team member pastes in a 50-page customer email chain into a defect
    ticket with no explanation: "This customer is unhappy about something, but dang
    if I can figure it out."'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Drum roll, please….)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A submitter writes schedule reminder notes into the defect system, because she
    thinks that someone will actually read the defect reports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With all the potential ways to abuse a defect-reporting system, having some
    human intervention is usually necessary. Without enforcement and review of data
    in a bug-tracking system, so much junk data gets stored that people ignore older
    defects. Ensure that the defect tool has a clear process associated with it and
    enforce the process. A great way to enforce the process is to have a gatekeeper
    or gardener for the bug system who is responsible for the health of the bug data,
    not the system per se.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the defect system process, define and enforce standards for *resolution
    notes*. Resolution notes describe how the defect was resolved and are useful to
    the submitter, but they are also helpful in defect analysis and end-of-project
    reviews. Train other teams that use the bug-tracking system in proper system use,
    including customer service, sales, marketing, technical writing, and any consultants.
    Failure to train people will lead to extra effort in development dealing with
    the defects that people improperly submit.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, first make sure that your team has a useable defect-reporting system,
    and then ensure that your team has a proper process for using it. Monitor the
    usage and refer offenders to the proper correction institution. Finally, refer
    to [Chapter 17](ch17.html "Chapter 17. UNDERSTANDING QUALITY ASSURANCE") for more
    information on bug tracking and entry.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the Right Development Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you have reviewed all the basics of tools and methods, you can select
    at least one replacement system. Fortunately, in many small companies, the development
    manager can direct the choice of development tools. Having this choice gives you
    the flexibility to change and reconfigure systems as your needs change. This is
    not necessarily the case in large companies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Managers in startup companies often base their tool selection on two criteria:
    familiarity and price (preferably, free). A thoughtful choice, however, will prevent
    future problems when the company grows and the product takes off.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't let price alone drive you toward selecting only from free, open source
    tools. Establish your long-term needs before ruling out buying a commercial tool.
    Since the cost of changing to a different tool later is usually very high, picking
    a tool based just on short-term finances will sometimes lead to painful development
    issues a few years later. If price must be an overriding factor (that is, if there
    literally is no money to spend), plan in advance for a transition strategy to
    your ideal tool when money is available.
  prefs: []
  type: TYPE_NORMAL
- en: '**TOP-DOWN TOOL SELECTION**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many large companies do not give engineering management the choice of tools.
    They have multiple layers of management and many different projects. A senior
    technology manager removed from individual developers will choose the tools. Choice
    of tools will usually reflect several factors: price, technology features, ability
    to handle the largest and most complex project in the company, and what is commonly
    being used in different divisions.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if your group isn't currently using one of the newly chosen tools,
    libraries, or databases, then you will be forced to convert your software to the
    new tools whether it makes business sense or not.
  prefs: []
  type: TYPE_NORMAL
- en: Tool vendors can push hard during the selection process. Vendors may offer low
    introductory prices, free first-year licenses, bundled software, or promises of
    special future features. When considering these incentives, ask for a longer-term
    price guarantee for future purchases—ideally, five years. Do not include promises
    of future features in your decision process unless the feature description (along
    with a delivery date) is included in the purchase contract alongside a penalty
    clause. Once the sale is made, you may see your vendor's priorities change.
  prefs: []
  type: TYPE_NORMAL
- en: Smaller vendors may take special interest in making the sale to you because
    they can use your company as a reference account, get a sale, and have the potential
    for future sales automatically as your company grows. In contrast, larger vendors
    will likely press less hard, as their sales focus is likely to be larger companies
    willing to buy larger numbers of tools at once. As the selector, you may feel
    camaraderie and empathy for another small company trying to reach success; however,
    recognize this influence when making your decision. Do not make the wrong choice
    simply to help out another small company.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a development organization uses a tool, it can be expensive to replace,
    because of the costs associated with migrating the data and retraining the team.
    To make the best choice, create a table comparing tool options covering these
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial cost Consider initial sale price and installation costs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Impact on productivity Weigh the savings in salary time due to more efficiency
    of the system and fewer errors.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recurring costs As you add more users, consider what happens to the cost per
    person. Some products have low introductory rates for small teams but can get
    expensive per person as your company grows. Nailing down the recurring costs as
    part of the original deal gives you perspective on the future.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Maintenance costs Consider how much labor and maintenance the tool will require.
    A few tools require half- or full-time staff to maintain them for a good-sized
    team.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Integration with other tools Know whether the tool integrates well with other
    tools—for example, consider whether a defect tool integrates with source control
    and whether the source control program integrates with the integrated development
    environments (IDEs) being used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: System performance after growth Consider what the system performance will be
    when the team size grows.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remote development Know whether the system can handle users who are working
    remotely. Consider its effectiveness with different development centers overseas,
    if necessary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ease of use Consider how easy the tool is to learn and use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data security Does the tool manage your data securely so it won't be lost or
    revealed inadvertently?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data access Know whether data can be reasonably imported and exported, which
    allows for future migration and integration with other tools.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tool familiarity can be another trap in the selection process. Many people will
    choose a tool one of the team members is already familiar with instead of taking
    a risk with something new. A familiar tool has the benefit of less training time—at
    least for the person selecting it. However, choosing an inferior tool based on
    one person's familiarity can lead to team resentment, as other team members will
    have to live with the tool's problems. Tools are changing so rapidly that choosing
    a known tool can result in choosing an obsolete tool. Instead, spend the time
    to investigate other options rather than simply choosing what's familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time pressures often force managers to make decisions before they can fully
    assess a product. Delegating the investigation and recommendation of tool choices
    to an interested senior engineer can improve the selection process. Delegation
    of the investigation benefits you and the team because it helps build trust: You
    will have shown the team that you trust them with the company''s interests as
    well as their own. In contrast, engineers can react negatively if you select a
    tool without their involvement.'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the engineer to deeply investigate at least three tools before making the
    recommendation. A deep investigation requires trying the tool with realistic data
    on real problems your team faces. This will ensure that the tool meets the team's
    needs not only on the surface, but also in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Once the tool is chosen, make the selecting engineer the tool's champion. He
    should help other engineers with the transition, answer questions, and monitor
    the tool's use. Having the selecting engineer actively use the tool will let him
    understand its problems and investigate potential solutions. More of his credibility
    will be at stake for making the tool a success, and he will be more likely to
    ensure that his peers are satisfied with the choice, because he has to work with
    them daily.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is some additional reading on topics presented in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *The Build Master: Microsoft''s Software Configuration Management Best Practices*,
    by Vincent Maraia (Addison-Wesley, 2005) |'
  prefs: []
  type: TYPE_TB
- en: '| "Defect Tracking Tools," [http://www.testingfaqs.org/t-track.html](http://www.testingfaqs.org/t-track.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| DMOZ Open Directory Project website, [http://www.dmoz.org/](http://www.dmoz.org/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Software Release Methodology*, by Michael E. Bays (Prentice Hall, 1999)
    |'
  prefs: []
  type: TYPE_TB
- en: Chapter 8. ASSESSING YOUR TECHNOLOGY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evaluating your technology base *early* helps you avoid problems that create
    crises *later*. As development manager, you are entrusted and expected to keep
    the technology in working order at all times. If you fail to do this, any serious
    problems that are encountered can lead to you making poor decisions while under
    duress. Better to learn your technology early and well, before you face major
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand your company''s technology, you must evaluate a number of key
    areas. Unfortunately, a thorough technology assessment is not always a top priority
    in small companies. The following list covers some of the most common technical
    areas that management does not fully scrutinize:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| System documentation | System API |'
  prefs: []
  type: TYPE_TB
- en: '| System scalability | Security |'
  prefs: []
  type: TYPE_TB
- en: '| Failure modes | Data reporting and analysis |'
  prefs: []
  type: TYPE_TB
- en: '| Error handling and messages | International support |'
  prefs: []
  type: TYPE_TB
- en: '| Software system flexibility | Test harness |'
  prefs: []
  type: TYPE_TB
- en: '| Third-party packages |   |'
  prefs: []
  type: TYPE_TB
- en: 'As you assess your technology, consider the completeness, quality, and long-term
    impact of choices made to date: Regarding completeness, consider all the key technologies
    in place; regarding quality, consider whether the technologies being used are
    reliable and implemented with current best practices. This chapter provides an
    expanded discussion of considerations for each technology area.'
  prefs: []
  type: TYPE_NORMAL
- en: System Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many small and growing companies do not sufficiently document their software
    or systems for many reasons, including lack of interest in doing the job, pressure
    to achieve short-term goals, changing definitions, and perceived lack of need.
    Most engineers want to write code, not technical documents. Time pressures can
    be considerable in small firms because the next delivery is always around the
    corner. Changing definitions make it difficult to keep documentation up to date.
    And the need is not perceived: The senior architect understands the system in
    detail, so why document it for others, when he can explain it?'
  prefs: []
  type: TYPE_NORMAL
- en: Good system overview documentation is critical. Without it, your company faces
    long-term problems and lost opportunities. New engineers need a technical overview
    of the system as part of their initial training. In addition, as the development
    team makes changes to the system, they might not see the far-reaching effects
    of their changes without access to proper overview drawings and descriptions.
    Documentation is also important because your growing company might eventually
    face audits by customers or certification agencies (for example, Cardholder Information
    Security Program, or CISP, in the financial world). Audits usually require system
    documentation. Finally, if another company wants to buy your firm, it will review
    your technical documents as part of the due diligence.
  prefs: []
  type: TYPE_NORMAL
- en: Your first step in documenting your system is to create a *system overview diagram*.
    You can obtain the information you need by interviewing development team members
    and possibly by gleaning data from any partial documentation that exists. Create
    the diagram as a useful working document, not just fluff for sales presentations.
    Summarize the software and system correctly and in detail. Organize the diagram
    for easy understanding by rearranging the layout to minimize the number of crossing
    or overlapping lines. Make it visually consistent by using only a few box sizes
    and a few types of symbols. Finally, label paths and contents clearly and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the overview diagram, examine the system documentation for the
    amount of detail. Too little detail provides little utility, while too much detail
    makes the document difficult to use and maintain. Review the documentation to
    ensure that you have included enough information by asking these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the documentation sufficiently complete to support training a new engineer
    if two individuals on your team left their jobs?
  prefs: []
  type: TYPE_NORMAL
- en: Multiple people leaving a company at the same time is a common occurrence. People
    who enjoy working in startup situations might look for the next opportunity and
    invite co-workers to join them.
  prefs: []
  type: TYPE_NORMAL
- en: Is documentation sufficiently complete that removing a team member will not
    disrupt operations?
  prefs: []
  type: TYPE_NORMAL
- en: Nobody on the team should be so critical that losing him or her would mean that
    production would fall apart. You should be able to deal with a personnel change
    without losing too much ground.
  prefs: []
  type: TYPE_NORMAL
- en: Would the documentation satisfy a company that might be interested in buying
    your company? Will your documentation support a reasonable valuation?
  prefs: []
  type: TYPE_NORMAL
- en: Scrambling to create documentation when someone is interested in acquiring your
    company does not result in good work. From a buyer's perspective, a large part
    of the corporate value of a software firm is its intellectual property. Failing
    to build detailed documentation can have an impact on company purchase price.
  prefs: []
  type: TYPE_NORMAL
- en: Does documentation provide accurate, up-to-date technical documentation so a
    customer can understand how to integrate his system with your software?
  prefs: []
  type: TYPE_NORMAL
- en: A poorly defined application program interface (API) or poor integration documents
    will frustrate customers and consume valuable development time.
  prefs: []
  type: TYPE_NORMAL
- en: Do not stop at a high-level system diagram when considering your system documentation.
    Consider all of the interface directions, including control files, APIs, and error
    messages. Consider descriptions of how your system fits together, as well as inclusion
    of customer usage models. Consider risk when thinking about the documentation.
    If only one engineer is an expert on important aspects of the product, that engineer
    needs to document these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'A minimum list of recommended system documentation includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| System overview |'
  prefs: []
  type: TYPE_TB
- en: '| Outstanding issues^([[5](#ftn.CHP-8-FNOTE-1)]) |'
  prefs: []
  type: TYPE_TB
- en: '| Detailed system architecture description |'
  prefs: []
  type: TYPE_TB
- en: '| API description and usage |'
  prefs: []
  type: TYPE_TB
- en: '| Error handling, including cases and messages |'
  prefs: []
  type: TYPE_TB
- en: '| Control file formats |'
  prefs: []
  type: TYPE_TB
- en: '| Internationalization support description |'
  prefs: []
  type: TYPE_TB
- en: '| Database schemas |'
  prefs: []
  type: TYPE_TB
- en: '| List of technologies and libraries used |'
  prefs: []
  type: TYPE_TB
- en: '| Build instructions for all product parts |'
  prefs: []
  type: TYPE_TB
- en: '| Packaging and release instructions for all modules |'
  prefs: []
  type: TYPE_TB
- en: '| Workflow required to support the system |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-8-FNOTE-1)]) To qualify as an outstanding issue, the issue should
    have the potential of creating a noticeable impact on the product. The description
    should explain the impact and why the issue is unresolved.
  prefs: []
  type: TYPE_NORMAL
- en: System Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*System scalability* describes the ability of the program or system to maintain
    acceptable performance as the volume of users and data increases significantly.
    Scalability means that the usability and speed of the system do not degrade significantly
    as usage increases. Obviously, at some level, all systems will fail, but setting
    a reasonable maximum expected usage size and knowing that the software can handle
    that size is what scalability is all about.'
  prefs: []
  type: TYPE_NORMAL
- en: When a young company starts developing a new project, development focuses first
    on creating core functionality, and scalability is often an afterthought. The
    team might consider scalability of the system at times, but this objective is
    not analyzed, monitored, or properly tested because of the expense and time involved.
    Few companies run enough tests to generate an accurate scaling model for what
    happens at different volumes of usage.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring scalability creates a huge risk factor for the company, however. (Are
    you noticing a theme here?) Scalability problems can sink a company if its system
    fails or slows down when the volume reaches the peak. For example, without proper
    scalability design and testing, systems with high uptime requirements can fail
    at high load, sometimes in unexpected ways. These failures can result in the loss
    of customers or even a direct financial loss if your company has guaranteed system
    availability.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed *system diagram* provides a great starting point for examining system
    scalability. The diagram should show hardware, applications, and software for
    the entire system—a whole system overview in enough detail to analyze it. You
    can create a scaling model from a detailed diagram if you have reliable test data.
    If you do not yet have the test data, the diagram can direct you to the tests
    you need to run and help you identify potential failure points.
  prefs: []
  type: TYPE_NORMAL
- en: Various methods and tools can be used to evaluate systems, including commercial
    packages used by IT shops, modeling programs, and even Excel spreadsheets. Your
    choice of approach depends on the complexity of the system. You can use a spreadsheet
    successfully to build up scalability models for simple systems with the proper
    data. For complex systems, system-modeling tools are better choices.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis alone does not ensure system scalability; you must also create a test
    lab to experience in practice how the system performs. As most modern systems
    find the biggest delays in the data layer, senior database engineers usually run
    the labs and perform the analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability presents an ongoing problem to the development team, requiring vigilance
    as the team develops new code. Engineers not trained in database scaling can easily
    create queries that slow down the system. The engineer most experienced with database
    queries can review all database queries as part of the code review process. Finding
    and fixing a problem in the design phase is far less expensive than discovering
    the problem in a test lab.
  prefs: []
  type: TYPE_NORMAL
- en: Failure Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *failure mode* occurs when your software or system fails in ways that you
    did not expect and from which your software does not directly recover. *Failure
    mode analysis* involves a systematic analysis of general ways the program or system
    can fail. Small company development teams often do not systematically examine
    how their product or service can break. Instead, most wait for a failure to occur
    and patch the system to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Small company developers usually focus on making the product work, rather than
    looking for what will cause it to fail. Breaking the product is a job for quality
    assurance. However, the QA team does not have the insight into the internals of
    the code that are required to perform a proper risk analysis. Engineers themselves
    need to analyze the risks and failure modes of every product or system.
  prefs: []
  type: TYPE_NORMAL
- en: A failure mode review must examine the system as a whole and in parts. Failures
    can occur in components or in the interactions of several components; some single
    components might show no obvious failure issues, but their interactions with other
    components can cause the system to break. In addition, a review must consider
    how unexpected customer data or usage can affect the system, including the effects
    of unusual data, overload of data streams, data size issues, data rate issues,
    and timing issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'External abnormal occurrences can also cause problems to the system and should
    be studied. Using a system diagram as your reference point, ask a series of questions
    about what could happen, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if third-party vendors do not provide the bandwidth needed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if someone cuts a cable or a machine goes down?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a system loses data, how does its recovery mechanism work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What synchronization problems can be identified?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when the wrong data enters the system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the system respond to data provided in the wrong order?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will the system detect unauthorized access?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FAILURE MODE**'
  prefs: []
  type: TYPE_NORMAL
- en: The company I joined had a complex system that synchronized data between two
    different data sets. The system had a synchronization problem that would occur
    a few times each month. When this occurred, an engineer would repair the problems
    directly in the database.
  prefs: []
  type: TYPE_NORMAL
- en: While reviewing risk factors for the system, I starting asking questions about
    this failure mode and became concerned. Under certain conditions, the failure
    rate could be high—it would require a system problem and a failure in the monitoring
    of the system by the operations team. The architect believed they would never
    see this problem, as it required that a system problem would have to go unmonitored
    by the operations team for many hours. The system had real-time monitoring in
    place, so he believed it would not happen. As the company planned for increased
    system traffic volume over the next year, I insisted that we plug this failure
    mode in the next release.
  prefs: []
  type: TYPE_NORMAL
- en: A few months after the release, the meltdown system failure occurred, causing
    a key system component to stop. The operations team had turned off the monitoring
    of this server six months earlier without engineering's knowledge, because the
    monitoring code gave too many false warnings. By the time we discovered the problem,
    the improperly synchronized data far exceeded what we could have repaired manually.
    Fortunately, the automatic repair mechanism did the corrections and kept the system
    running. We were one system redundancy away from a complete meltdown of our business.
  prefs: []
  type: TYPE_NORMAL
- en: —Software manager
  prefs: []
  type: TYPE_NORMAL
- en: Scale the analysis based on the potential problems a failure would create. Although
    intense failure mode analysis approaches can be used, most products require a
    less intensive examination, except for cases in which failure could have an extreme
    adverse effect on the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring a systematic analysis of failure modes will improve the reliability
    of your product or system. As a manager, require an analysis for every major release
    of a system. Perform this analysis early in the development cycle and act on any
    issues uncovered.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling and Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Error handling* and *messaging* concern how you process your system''s reasonably
    expected usage problems. Error handling occurs within normal operation of the
    system and allows for continued usage. It differs from failure modes, as failure
    modes represent system or product failure cases in which the system operation
    *breaks*. With a failure mode, manual intervention is often required for recovery.
    With error handling, the processing is routine and part of normal product usage.
    Error messaging describes the message sent to the user when the error is detected
    and is sometimes used to describe all of error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling is designed as the product is created. When an engineer sees
    a use case that results in a detectable error, she creates an exception case in
    the code to handle it while informing the user about the problem. However, development
    teams often do not examine the messages after the initial creation, causing many
    error messages to go untested and ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Development teams in young companies rarely document error conditions because
    the lack of error documentation does not block sales and does not cause short-term
    problems. However, not documenting error conditions opens testing holes and opportunities
    for failure modes to occur as part of the error processing. For example, an untested
    warning message, when activated, can cause the program to fail or cause database
    corruption. In addition to identifying problems earlier, documenting error conditions
    helps QA test efforts and simplifies internationalization of your software. Knowing
    the error conditions will also support risk analysis. With all of these benefits,
    it is best to create error documentation before your company enters its growth
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*A good standard practice is for QA to test all error handling and be able
    to run unit tests during development. QA''s careful checking of error conditions
    can assist in documenting the conditions as well as finding critical failures
    that can occur in the error resolution code*.'
  prefs: []
  type: TYPE_NORMAL
- en: To create the error documentation, request a list of all the error phrases in
    the system from your development team. Ask the team to identify error conditions
    that are not currently associated with a textual message. Use this information
    to improve the product's error handling by creating log file records. This can
    improve your testing because you can create targeted test cases to activate those
    error conditions. Documentation should cover the general error modes, error display,
    and error recovery. In addition, document error conditions that only a system
    administrator of your product would see. These conditions are often neglected
    in testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also useful to review error messages for reasonable practices. Since
    developers focus first on the successful workflow, they might not spend much time
    thinking about the unsuccessful workflows. For unsuccessful workflows, developers
    should consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Does a recovery path exist to resolve the issue for the customer?
  prefs: []
  type: TYPE_NORMAL
- en: A good recovery path puts the user back to the location where the problem occurs,
    retaining as much of the entered data as possible, so that the customer can attempt
    his task again in a different way or at least save his data.
  prefs: []
  type: TYPE_NORMAL
- en: Does the error message provide information that hackers could use to break into
    the system?
  prefs: []
  type: TYPE_NORMAL
- en: For example, does the message provide a list of data elements when a fatal flaw
    occurs?
  prefs: []
  type: TYPE_NORMAL
- en: If multiple errors occur, does the system separately list messages for each?
    Does each message provide useful information?
  prefs: []
  type: TYPE_NORMAL
- en: A useful message should clearly describe the problem; provide data that would
    assist development in resolving the problem if the customer cannot do so; and
    provide a location of the problem in the code, rather than a generic "it broke."
  prefs: []
  type: TYPE_NORMAL
- en: Software System Flexibility and Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*System flexibility* describes the ease of expanding the product with new feature
    sets and capabilities. *System maintainability*, on the other hand, describes
    the ease of coding bug repairs and adding minor features. Both are determined
    by the architecture and techniques used to create the code and resulting quality
    of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: When engineering builds product code with flexibility and maintainability in
    mind, the company gains a long-term corporate advantage. Flexible code can be
    a decisive factor in product success, because cost and time to market is critical
    for small companies. With maintainable code, the lower overall cost of working
    on the code, especially when someone other than the author is doing the work,
    can mean the difference between success and failure for a growing company in a
    competitive market. Understanding the state of the code will allow you to make
    much better predictions about the costs of making major changes to your product.
  prefs: []
  type: TYPE_NORMAL
- en: 'As head of engineering, you need to know the flexibility aspects of your company''s
    code as well as its maintainability. These things affect both short-term and long-term
    planning: In the short term, maintainability and flexibility affect the cost of
    repairs. In the long term, maintainability and flexibility affect your decision
    of when to overhaul or replace the current code.'
  prefs: []
  type: TYPE_NORMAL
- en: Many small companies lack foresight about how code will be reused across the
    system. With few customers on board, receiving the proper input to plan for the
    future can be challenging. If the team focuses on quick delivery, programmers
    will often reinvent similar code rather than ensure that the code offers maximum
    reuse. This approach creates a maintenance nightmare, however, because the code
    now contains many different versions of similar functions. As the product changes
    and grows, changes to functionality will require far more effort, as each different
    version of the function will need to be modified. Because developers implement
    functions in different ways, the cost of modifying two similar functions with
    one change can be more than twice the cost of merging the function code from the
    start.
  prefs: []
  type: TYPE_NORMAL
- en: Software maintenance problems build up over time and are sometimes unnoticed
    because they amount to small increments in a total effort.
  prefs: []
  type: TYPE_NORMAL
- en: However, when they become more important because of significantly slower development
    efforts and more quality issues, the difficulty in recovering can be too large
    to be easily resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two cases, observed "in the wild" and related to flexibility
    and maintainability of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Engineering builds the software to minimize costs, but intends to replace the
    software at a specific time.
  prefs: []
  type: TYPE_NORMAL
- en: Engineering should test this assumption with the executive team before building
    the system in this way. Don't surprise your company with a quickly built system
    that cannot be modified easily. Instead, let the executive team know and get their
    buy-in before opting for this choice.
  prefs: []
  type: TYPE_NORMAL
- en: New customers are supported by engineering copying old code and customizing
    it to meet the customer's needs.
  prefs: []
  type: TYPE_NORMAL
- en: This provides a short-term boost but a long-term disaster. The problems associated
    with copy-and-customize do not justify the quick support provided for new customers.
    The maintenance cost of the application multiplies with each copy. Changes development
    makes to improve one customer's code base are not portable to another customer's
    code base; this situation stalls out your product development and turns your efforts
    into custom coding.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding both flexibility and maintainability, you need to make conscious choices
    and get buy-in from the executive team, and you should continue to be aware of
    your product's status. There is no "one-size-fits-all" solution to flexibility
    and maintainability problems. Different product roadmaps have different requirements
    and expectations as to when the software will be overhauled or replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Third-Party Packages Integrated into the System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most small software companies, the development team integrates third-party
    code into the product because it shortens development time. You need to identify
    and document these packages for a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Potential investors will request this information as part of due diligence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External security audits will require a list of third-party packages used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages can increase your product costs if the vendor raises its
    rates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party package vendors can change licensing requirements, making it difficult
    to meet your goals and the license requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages can affect the quality of your product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third-party package that you have modified can increase ongoing costs, because
    the vendor might deliver later versions of the package, which means you will have
    to modify your code again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party vendors can go out of business or drop support for the package,
    leaving you with a major problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To determine what packages have been included in a system, ask the system architect
    to create a list. (Do not be surprised if no documentation exists.) Turn the list
    into a one-page summary and make it available to the development team for review.
    Then, ask the team to identify potential risks, including those that might appear
    as the product usage grows. Example risks include scalability issues, quality
    concerns, and overall utility.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have documented a list of third-party packages, assign a senior engineer
    to maintain this list and make it easily available. This will help avoid a crisis
    when trying to pull the information together at the last minute and will keep
    the team thinking about the impact of integrating new packages into the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Analyzing the third-party code in the existing system does bring to light the
    process of "make versus buy" decisions. With all of the potential problems that
    third-party code can present, why use it at all? For most small companies, cash
    is limited, so getting a product to market quickly is a key goal. The best strategy
    for achieving this goal is to create only the sections of the product that are
    not currently available as third-party packages and buy the rest, but only when
    the business case makes sense. When reviewing the business case, you should consider
    all the issues raised in this section as well as cost and time to build compared
    to cost and time to buy and integrate. A good rule of thumb is this: Buy when
    the cost and time are less than or nearly equal to the build option.'
  prefs: []
  type: TYPE_NORMAL
- en: System Application Programming Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Small company development teams commonly underdocument system application programming
    interfaces (APIs). The API allows customers and other companies to communicate
    with your product or system through a data or software interface. Most modern
    programs use an API because it provides huge flexibility and speed advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Customers often complain because incomplete documentation forces them to make
    assumptions about how the product API works. This can lead to wasted customer
    efforts and demands to change the implementation. Incomplete documentation also
    forces costs back onto your company, as your development and support teams have
    to answer questions about proper usage. A poorly documented API probably has not
    been completely tested either, leaving your customers to find problems, especially
    with lesser-used features.
  prefs: []
  type: TYPE_NORMAL
- en: Review the current API specification to ensure that it clearly states legal
    data values, interaction of data elements, error conditions, and error handling.
    If the documentation requires more information, ask an engineer and a documentation
    writer to fill in the gaps. If you create a solid API definition before your company
    hits its growth phase, your company will avoid serious problems with unhappy partners
    and customers (as well as the costs of supporting them).
  prefs: []
  type: TYPE_NORMAL
- en: API documentation needs more than just an interface description—it needs well-chosen
    use case examples. Providing an API description without use case examples is like
    handing someone a foreign language dictionary and expecting them to learn the
    language. Use cases should illustrate common usages that you expect your customers
    to integrate with their product to solve their problems. If you continue to update
    the descriptions as more customers use your product, the API document can be a
    positive asset in technical sales.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although many engineers consider product-usage security an IT or operations
    team task, the engineering team should play the major role in creating a secure
    product. Consequently, you must make security an integral part of your development
    process. The most effective way to do this is to review security elements as programmers
    develop the code and as QA tests it.
  prefs: []
  type: TYPE_NORMAL
- en: Security often becomes a high-priority development issue when some driving event
    occurs—a customer asks questions about security before buying the product, a certifying
    organization requires a security audit, or a hacker breaks into the system. Don't
    wait until a driving event occurs. Instead, secure your product before being asked
    to do so, either by hiring an outside consultant or assigning the project to a
    team member. Whatever your choice, select one member from engineering and QA as
    the security gurus for their respective teams. Then ask them to spend time learning
    about security practices and testing methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Software security requires continuous focus during every development cycle.
    By assigning a software engineer to review the code for security flaws before
    QA tests the code, you can find problems earlier and improve security with less
    impact on cost and time. Security flaws found late in the development process
    can be very costly to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Making security a priority in your system requires that you take extra measures.
    Consider acquiring security analysis tools appropriate for your product or system,
    and use them for every release. In critical systems, use a security consultant
    to review your system and identify problems. The additional costs are always justifiable
    by the results—problems identified before the product is released.
  prefs: []
  type: TYPE_NORMAL
- en: When determining how much to budget for the security effort, consider the types
    of security failures, the costs of each, and the probabilities of each. These
    costs will vary considerably based on the type of industry the product supports
    and the nature of the product. Devise a development plan in which sufficient money
    is spent on security to bring the failure probability multiplied by the cost down
    to a reasonable level.
  prefs: []
  type: TYPE_NORMAL
- en: Most companies do not spend enough time and effort building secure products
    or systems. More important, the effort spent is often at the wrong time in the
    development cycle—during testing or post-release recovery. But testing and repairing
    security in a built system is very expensive and sometimes impossible. As a practice,
    establish security requirements at the beginning, and then ensure they are considered
    and reviewed during the design.
  prefs: []
  type: TYPE_NORMAL
- en: Do not wait until an audit or hacker forces you into action, because your team
    will have a much greater problem improving security after the software has been
    built. Take software security seriously, because the damage done by poor security
    can be impossible to repair later.
  prefs: []
  type: TYPE_NORMAL
- en: Data Reporting and Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many companies' products store customer data, especially if the company offers
    a web-hosted service. Small company systems commonly store customer data in a
    database from which the team designs SQL queries that allow the program code to
    access data. In addition to allowing programmers to enter and modify the data
    in the database, many products include a data-reporting functionality that is
    often added through separate modules or through a purchased reporting software
    package.
  prefs: []
  type: TYPE_NORMAL
- en: A simple database approach can work well to get the initial product off the
    ground. As your customer base grows or the volume of queries grows significantly,
    however, the system will slow down. If this happens rapidly, your product's release
    cycle might not occur often enough to correct the problem before it becomes a
    huge issue.
  prefs: []
  type: TYPE_NORMAL
- en: Investigate the query speed of your product and estimate where speed problems
    might occur. Also, estimate likely customer volume increases and timing. If you
    do this in advance, you will be prepared when speed might become an issue. Typically,
    query speed becomes an issue when your company enters a growth phase. You can
    minimize speed problems by carefully reviewing and testing SQL queries in a lab,
    but this will only get you so far. Large reports covering months or years of data
    will slow down over time. As a rule of thumb, when a report takes more than 10
    seconds to display, customers become dissatisfied with the wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database information displayed in reports can change over time. Customers find
    it disconcerting to see their data from two months ago change from what your system
    reported two months earlier. Changes happen because the algorithm for displaying
    the report changed or because parts of the underlying data changed. An example
    of underlying data change might be the removal of an account that the customer
    created in error and you closed. These inconsistencies can be handled in several
    ways: by letting the customer know about the volatility of past data and getting
    their acceptance; by restricting any changes to past data even if the data contains
    errors; by modifying the database or business logic so that reports don''t appear
    to change; or by using a data warehouse. A data warehouse, although expensive,
    can be a great solution in terms of both data consistency and speed.'
  prefs: []
  type: TYPE_NORMAL
- en: Data Warehouse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *data warehouse* stores snapshots summarizing the data at regular intervals
    with the goal of providing rapid access and consistency in responses. Common snapshot
    intervals are daily, weekly, or monthly, depending on the data and the customer
    need. Data warehouses are an expensive, albeit effective, approach to improving
    data reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data warehouse requires that you decide, in advance, what data to
    accumulate, how it's accumulated, and how it will be reported. While you can add
    reports to the data warehouse after it has been built, it should be initially
    designed to meet your long-term needs. Any changes added after the warehouse has
    been built do not become useful immediately, because data must accumulate before
    it can be of enough significance to measure in a report. Because creating a data
    warehouse has many pitfalls, you should hire someone with experience in data warehouse
    creation before taking this approach. Both database and IT experience are required
    to set up the warehouse properly.
  prefs: []
  type: TYPE_NORMAL
- en: A data warehouse solves the data change problem as well. Because the warehouse
    takes snapshots of data used to generate a report, the displayed data will not
    change even if the underlying data has changed. So, for example, monthly historical
    data will not change unless you run that month's generation routine again. This
    can be especially useful when the formula for calculating some of the presented
    data necessarily had to change over time, but the new formula isn't appropriate
    for the older data. On the other hand, for customers who want to propagate changes
    back in time, the data warehouse provides a means for doing this in a controlled
    manner. Such changes can be analyzed and proper business logic applied before
    running the program to update the warehouse, so that the changes are verified
    as correct and made when appropriate for the business needs.
  prefs: []
  type: TYPE_NORMAL
- en: Data warehouses are an order of magnitude more expensive than a pure database
    approach and are time consuming to set up and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the need for a warehouse is justified from a business perspective
    before building it. For the following reasons, creating a data warehouse is an
    expensive and lengthy task:'
  prefs: []
  type: TYPE_NORMAL
- en: A data warehouse often requires that you acquire additional hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data warehouse requires rewriting all of your reports and creating a program
    to generate the summary data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data warehouse requires ongoing maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the costs and time delays, plan for a data warehouse *before* your
    company hits its growth phase to minimize the disruption. Waiting until data access
    becomes a problem will not allow your company enough time to solve the problem,
    as building a data warehouse can easily take six months or more.
  prefs: []
  type: TYPE_NORMAL
- en: International Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many web applications and some desktop applications require *international support*,
    and that means much more than just translating English text into another language.
    It often requires rethinking and reworking parts of your software. In addition
    to language support, other issues include changes in user interfaces, changes
    to workflow because customers or business practices differ, legal issues related
    to site usage or guarantees, and currency issues if you are selling the product
    or the product deals with money.
  prefs: []
  type: TYPE_NORMAL
- en: In most American startups, development builds the first product to support English-only
    for the US market. The introduction of support for other countries and languages
    often follows from sales opportunities rather than a technology plan. Ad hoc internationalization
    can lead to major surprises for development and the entire company due to the
    unexpected costs, lack of required expertise, and development delays.
  prefs: []
  type: TYPE_NORMAL
- en: Treat international support as a major release. Recognize that internationalizing
    your product will increase your operating costs and add release delay going into
    the future. You can implement internationalization during the company growth phase,
    but planning for it in advance can save you headaches later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Assessing the internationalization costs requires a detailed review. [Appendix B](apb.html
    "Appendix B. INTERNATIONALIZATION") covers internationalization issues by providing
    questions to ask your company management regarding internationalization along
    with options to consider during development. It also includes an overview of best
    practices when implementing internationalization on a site*.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the Big Picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered many technological areas that require adequate review.
    Trying to make all of the areas ideal may not be practical. In fact, for most
    business, the different areas vary in importance. A good approach is to review
    of all of the technological areas and assess which are terrible, which are tolerable,
    and which are great. Then, bring the terrible areas up to at least tolerable.
    This will minimize your technological risks with the least investment.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is some additional reading on topics presented in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs: []
  type: TYPE_NORMAL
- en: '*Developing Software with UML: Object-Oriented Analysis and Design in Practice*,
    by Bernd Oestereich (Addison-Wesley Professional, 2002)'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Fine Art of Technical Writing*, by Carol Rosenblum Perry (Blue Heron Publishing,
    1991)'
  prefs: []
  type: TYPE_NORMAL
- en: '"Software Documentation," from Wikipedia, [http://en.wikipedia.org/wiki/Software_documentation](http://en.wikipedia.org/wiki/Software_documentation)'
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs: []
  type: TYPE_NORMAL
- en: '"Scalability," from Wikipedia, [http://en.wikipedia.org/wiki/Scalability](http://en.wikipedia.org/wiki/Scalability)'
  prefs: []
  type: TYPE_NORMAL
- en: Risk Factors
  prefs: []
  type: TYPE_NORMAL
- en: '*Manage It!: Your Guide to Modern, Pragmatic Project Management*, by Johanna
    Rothman (Pragmatic Bookshelf, 2007)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Waltzing with Bears: Managing Risk on Software Projects*, by Tom DeMarco and
    Timothy Lister (Dorset House Publishing, 2003)'
  prefs: []
  type: TYPE_NORMAL
- en: System API
  prefs: []
  type: TYPE_NORMAL
- en: '[http://lcsd05.cs.tamu.edu/slides/keynote.pdf](http://lcsd05.cs.tamu.edu/slides/keynote.pdf),
    "How to Design a Good API and Why It Matters," by Joshua Bloch, provides a good
    summary discussion of APIs'
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs: []
  type: TYPE_NORMAL
- en: '*Code Complete: A Practical Handbook of Software Construction*, by Steve McConnell
    (Microsoft Press, 2004)'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Pragmatic Programmer: From Journeyman to Master*, by Andrew Hunt and David
    Thomas (Addison-Wesley Professional, 1999)'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs: []
  type: TYPE_NORMAL
- en: '*Secure Coding: Principles and Practices*, by Mark G. Graff and Kenneth R.
    Van Wyk (O''Reilly, 2003)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Securing Java: Getting Down to Business with Mobile Code*, by Gary McGraw
    and Edward W. Felten (Wiley, 1999)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Security Engineering: A Guide to Building Dependable Distributed Systems*,
    by Ross J. Anderson (Wiley, 2008)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.pcisecuritystandards.org/](https://www.pcisecuritystandards.org/),
    PCI Security Standards Council website focuses on account data protection'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.cert.org/cert/information/developers.html](http://www.cert.org/cert/information/developers.html),
    CERT Information for Developers, provides information for developers on coding
    standards'
  prefs: []
  type: TYPE_NORMAL
- en: Data Reporting
  prefs: []
  type: TYPE_NORMAL
- en: '*The Data Warehouse Lifecycle Toolkit*, by Ralph Kimball, Margy Ross, Warren
    Thornthwaite, and Joy Mundy (Wiley, 2008)'
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs: []
  type: TYPE_NORMAL
- en: '*Developing International Software*, by Dr. International (Microsoft Press,
    2002)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Maximizing ROI on Software Development*, by Vijay Sikka (Auerbach, 2004)'
  prefs: []
  type: TYPE_NORMAL
