<html><head></head><body><section class="chapter" epub:type="chapter" id="packet_filtering" title="Chapter&#xA0;21.&#xA0;Packet Filtering"><div class="titlepage"><div><div><h2 class="title">Chapter 21. Packet Filtering</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>The name’s Pond, James Pond.</em></span><br/>
<span class="emphasis"><em>My x86 loaded,</em></span><br/>
<span class="emphasis"><em>licensed to filter.</em></span></p></div></div><p><a class="indexterm" id="idx0153"/><a class="indexterm" id="idx0937"/><a class="indexterm" id="idx1668"/><a class="indexterm" id="idx1760"/><span class="inlinemediaobject"><a id="inline_id00022"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> Packet filtering and traffic manipulation are among the most basic tools in network security. OpenBSD includes a very powerful in-kernel packet filter, <code class="literal">pf(4)</code>, or PF. This tool not only performs standard filtering, but it can also inspect, reassemble, redirect, and otherwise abuse packets in several ways; translate addresses in several different directions simultaneously; authenticate users; and manage bandwidth. Along with PF, OpenBSD includes programs that let you turn your system into a load balancer, transparent proxy, or any number of other network devices.</p><p>PF is one of the high points of OpenBSD and deserves its own book. That book is <span class="emphasis"><em>The Book of PF</em></span>, <span class="emphasis"><em>2nd edition</em></span>, by Peter Hansteen (No Starch Press, 2010), which goes into detail on many different PF use cases. This chapter covers the basics of PF so that you can protect a small network or an individual server. If you want to protect a web farm and transparently relay traffic to only the active servers with sufficient free capacity to handle the load, get Peter’s book.</p><p><a class="indexterm" id="idx0862"/><a class="indexterm" id="idx1436"/><a class="indexterm" id="idx1475"/>That said, not even Peter’s book covers PF in its entirety. OpenBSD lets you fold, spindle, and mutilate TCP/IP far beyond anything any reasonable person could ever expect to support in the real world. For complete details on PF, read the <code class="literal">pf(4)</code>, <code class="literal">pfctl(8)</code>, and <code class="literal">pf.conf(5)</code> man pages, and the OpenBSD PF FAQ at <span class="emphasis"><em><a class="ulink" href="http://www.OpenBSD.org/faq/pf/" target="_top">http://www.OpenBSD.org/faq/pf/</a></em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="ch21note01"/>Note</h3><p>PF is still undergoing active development. While the configuration syntax doesn’t change as often as it used to, check <code class="literal">pf.conf(5)</code> for the latest information on your version of OpenBSD.</p></div><div class="sect1" title="Firewalls"><div class="titlepage"><div><div><h2 class="title" id="firewalls" style="clear: both">Firewalls</h2></div></div></div><p>The word <span class="emphasis"><em>firewall</em></span> has been tortured beyond recognition over the past 20 or so years, until it has ceased to mean much of anything in particular. In general, a firewall sits between a private and public network, and controls the traffic between the two.</p><p>You can buy a firewall for your cable modem for under $100, and you can purchase an enterprise firewall cluster for $1 million. What’s the difference? They’re all firewalls, much as rats and cats and elephants are all mammals, but some are welcome in your home and most are not.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id337427" id="id337427">45</a>]</sup> Which you permit, of course, is your personal preference. And firewalls are much the same.</p><p>Some firewalls filter application-level traffic. Some only filter based on protocol or ports. Some firewalls inspect protocol flags and ensure traffic sanity. Others just pass packets. And some firewalls just translate network addresses and claim that provides security. Worse, the price tag bears no relationship to the feature set.</p><p>At their most basic, all firewalls filter packets and can perform network address translation (NAT). OpenBSD can perform those tasks as well or better than most commercial firewalls. If you want application proxies, however, they don’t come with the core OpenBSD system (with the exception of FTP and TFTP proxies, which are necessary for those protocols to function with NAT). Several popular application proxies run quite well on OpenBSD, but they are not part of OpenBSD. For example, I’ve used Squid (<span class="emphasis"><em>/usr/ports/www/squid</em></span>) and several related packages to build a web proxy and filter on OpenBSD that is comparable to anything the big companies offer, and an assortment of other proxies to manage just about everything else. If you are interested in firewalls, I highly recommend that you assemble your own highly featured firewall from available components at least once, for the sake of education if nothing else.</p><p>A firewall is what you make it. You can send all your traffic through a simple OpenBSD packet filter and honestly declare that you have a firewall, or you can set up application proxies, authentication, and so on, and still say you have a firewall. A plain packet filter is a firewall just as much as one of those umpteen-integrated-application-proxy, six-figure-price-tag devices. Remember this the next time someone says he has a firewall.</p><p><a class="indexterm" id="idx0690"/><a class="indexterm" id="idx0717"/><a class="indexterm" id="idx1176"/><a class="indexterm" id="idx1677"/><a class="indexterm" id="idx1766"/><a class="indexterm" id="idx2392"/>Realistically, a firewall is not a security device. It is a point of policy enforcement.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id337464" id="id337464">46</a>]</sup> The firewall doesn’t secure anything; it prevents access to certain services. But blocking access doesn’t secure inherently insecure services—it just means you can’t access them. If your firewall permits access to a service, the firewall doesn’t add any security to that service.</p><p>In order to build an effective firewall, you must understand TCP/IP. If <a class="xref" href="ch11.html" title="Chapter 11. Overview of TCP/IP">Chapter 11</a> was a revelation to you, get a copy of <span class="emphasis"><em>The TCP/IP Guide</em></span> (No Starch Press, 2005). Read it. Mark it up. Highlight it. And read it again.</p><p>Many of the examples in this chapter assume that you are building a firewall. This means that your host has two or more network interfaces (including VLAN interfaces) and that you want to protect the network on one side from the network on the other side. While this is a popular application for OpenBSD, everything covered here works just as well on individual hosts. I filter packets on lone web servers, on desktops, and on any host sitting naked on the Internet.</p></div><div class="sect1" title="Enabling and Configuring PF"><div class="titlepage"><div><div><h2 class="title" id="enabling_and_configuring_pf" style="clear: both">Enabling and Configuring PF</h2></div></div></div><p>OpenBSD enables PF by default at system boot with these <span class="emphasis"><em>rc.conf</em></span> variables:</p><a id="I_programlisting21_id497057"/><pre class="programlisting">pf=YES
pf_rules=/etc/pf.conf</pre><p>To disable PF at boot, set <code class="literal">pf</code> to <code class="literal">NO</code> in <span class="emphasis"><em>rc.conf.local</em></span>.</p><p>The default configuration file for PF is <span class="emphasis"><em>/etc/pf.conf</em></span>. There’s nothing special about this file—it’s just a standard location. The <code class="literal">pf(4)</code> kernel interface doesn’t read the file directly; the PF control program <code class="literal">pfctl(8)</code> reads the file and sends the configuration to the kernel.</p><p>The default PF configuration (hard-coded in <span class="emphasis"><em>/etc/rc</em></span>) blocks all network traffic except for ICMP and SSH. During boot, PF replaces those defaults with rules from <span class="emphasis"><em>/etc/pf.conf</em></span>. If an error in <span class="emphasis"><em>pf.conf</em></span> renders the file unparsable when the system boots, PF can’t load those rules; instead, it retains the default configuration. You’ll be able to connect to your machine to correct your rules, but that’s about it. (And, as anyone who administers remote firewalls can tell you, this ability can save you a lot of driving and phone calls.)</p><p>Running PF by default, even with a permissive ruleset, cleans up incoming traffic before the rest of the kernel has to deal with it. PF reassembles packets before handing them to the kernel, and obviously bogus traffic, such as packets too short to be legitimate, is discarded.</p><p><a class="indexterm" id="idx0945"/><a class="indexterm" id="idx1670"/><a class="indexterm" id="idx2235"/><a class="indexterm" id="idx2237"/><a class="indexterm" id="idx2291"/><a class="indexterm" id="idx2292"/><a class="indexterm" id="idx2420"/>If you want to forward packets between interfaces (that is, act like a “firewall”), tell the kernel to forward packets with the <code class="literal">net.inet.ip.forwarding</code> and <code class="literal">net.inet6.ip6.forwarding</code> sysctls. (See <span class="emphasis"><em>/etc/sysctl.conf</em></span> for commented-out examples.)</p><a id="I_programlisting21_id497177"/><pre class="programlisting">#net.inet.ip.forwarding=1
#net.inet6.ip6.forwarding=1</pre><p>Remove the pound signs and reboot, or use <code class="literal">sysctl(8)</code> to enable and disable packet forwarding on the fly.</p></div><div class="sect1" title="Packet-Filtering Basics"><div class="titlepage"><div><div><h2 class="title" id="packet-filtering_basics" style="clear: both">Packet-Filtering Basics</h2></div></div></div><p>Packet filtering is comparing packets to a list of rules and accepting, rejecting, or altering them as those rules dictate. As a network administrator, you get to decide which packets are naughty and which are nice. When you filter packets for a single host, you can legitimately call that host <span class="emphasis"><em>hardened</em></span>. (The word <span class="emphasis"><em>hardened</em></span> means almost exactly what <span class="emphasis"><em>firewall</em></span> means: nothing.) When you send all packets on your network through a single host that filters packets, you have a basic firewall.</p><p>A basic packet filter might allow you to filter based on only the TCP or UDP protocol number. Some don’t even allow you to filter by ICMP type or cannot cope with protocols other than those enumerated in the GUI. PF, however, can cope with almost anything you throw at it. If you need a machine to communicate with another over IP protocol 184, PF will support you. Many commercial firewalls won’t let you pass such traffic, or claim that they do but throw a tantrum if you actually try it.</p><div class="sect2" title="Packet-Filtering Concepts"><div class="titlepage"><div><div><h3 class="title" id="packet-filtering_concepts">Packet-Filtering Concepts</h3></div></div></div><p><a class="xref" href="ch11.html" title="Chapter 11. Overview of TCP/IP">Chapter 11</a> described how TCP connections can be in a variety of states. A TCP connection that is just starting goes through a three-way handshake process. A client requests a connection by sending a synchronization request, or SYN, packet to the server. The server responds by sending the client an acknowledgment of the SYN, as well as its own SYN request, or a SYN+ACK packet. The client responds with its own ACK.</p><p>Every part of this three-way handshake must complete for any actual data to transfer between the two machines. Your packet-filtering rules must permit each part of the three-way handshake and the subsequent data transmission. PF automatically recognizes these three-way handshakes and tracks them through <span class="emphasis"><em>stateful inspection</em></span>.</p><div class="sect3" title="Stateful Inspection"><div class="titlepage"><div><div><h4 class="title" id="stateful_inspection">Stateful Inspection</h4></div></div></div><p>PF maintains a list of permitted connections that have completed connection setup, which is called a <span class="emphasis"><em>state table</em></span>. When a client sends out a SYN packet, PF records that packet in a table and waits for a corresponding SYN+ACK packet. If a SYN+ACK packet arrives at PF, but PF has no record of a corresponding SYN request, the SYN+ACK packet is rejected.</p><p><a class="indexterm" id="idx0382"/><a class="indexterm" id="idx0505"/><a class="indexterm" id="idx0882"/><a class="indexterm" id="idx1676"/><a class="indexterm" id="idx1690"/><a class="indexterm" id="idx2033"/><a class="indexterm" id="idx2239"/><a class="indexterm" id="idx2429"/><a class="indexterm" id="idx2473"/>PF has a series of built-in timeouts that dictate how long idle connections remain in the state table, how long to wait for each stage of the three-way handshake, and so on. The state table is self-maintaining, and I’ve never had to adjust any of these timeouts. (On occasion, I have needed to increase the maximum size of the state table.)</p><p>UDP is technically stateless, but some applications expect a certain amount of state. When your system transmits a UDP packet, the application might well expect a UDP packet or 10 in response, or no packets, depending on the application.</p><p>DNS queries are a common example of UDP packets flowing back and forth, and while UDP has no state, DNS certainly does. (ICMP behaves similarly.) You can have PF either expect this back-and-forth or not, by adding these flows to the state table as your protocol dictates.</p><div class="note" title="Note"><h3 class="title"><a id="ch21note02"/>Note</h3><p>PF can also operate without stateful inspection, allowing traffic to and from hosts and ports based on individual packet characteristics. <span class="emphasis"><em>Stateless filtering</em></span> is slower than stateful inspection, harder to correctly configure, and generally considered less secure and less useful than stateful inspection.</p></div></div><div class="sect3" title="Packet Reassembly"><div class="titlepage"><div><div><h4 class="title" id="packet_reassembly-id00001">Packet Reassembly</h4></div></div></div><p>Packets can be mangled during transit, usually by <span class="emphasis"><em>fragmentation</em></span>. Part of a packet filter’s job is to sensibly <span class="emphasis"><em>reassemble</em></span> those packets. PF can reassemble and rationalize packets in a variety of ways. (Old versions of PF called this <span class="emphasis"><em>scrubbing</em></span>.)</p></div><div class="sect3" title="Default Accept vs. Default Deny"><div class="titlepage"><div><div><h4 class="title" id="default_accept_vs_default_deny">Default Accept vs. Default Deny</h4></div></div></div><p>One of the essential concepts in packet filtering is the question of default accept versus default deny:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>default accept</em></span> stance means that you allow any type of connection except what you specifically deny. The default PF rules are an example of a default accept stance.</p></li><li class="listitem"><p>A <span class="emphasis"><em>default deny</em></span> stance means that you allow only explicitly permitted connections. All other connections are refused.</p></li></ul></div><p>Once you have chosen your default, you can adjust your rules to hide or reveal network services as needed. In today’s world, I recommend default deny on all systems, because this stance protects new services as they are added to a system. In most environments where I’ve seen a default accept stance used in the past decade, it’s because the system administrators did not understand the network protocol they were using. This is particularly common in VoIP installations (yes, you <span class="emphasis"><em>can</em></span> packet filter VoIP servers!)</p><p>In addition to packet filtering and reassembly, PF offers several other important features, including NAT, connection redirection, and bandwidth management, to name a few. We’ll consider each separately. All are configured in <span class="emphasis"><em>pf.conf</em></span> and managed with <code class="literal">pfctl(8)</code>.</p></div></div><div class="sect2" title="“My Network Can Do No Wrong”"><div class="titlepage"><div><div><h3 class="title" id="my_network_can_do_no_wrong">“My Network Can Do No Wrong”</h3></div></div></div><p><a class="indexterm" id="idx0067"/><a class="indexterm" id="idx0196"/><a class="indexterm" id="idx1302"/><a class="indexterm" id="idx1645"/><a class="indexterm" id="idx1678"/>Many network administrators who build a firewall carefully filter and restrict incoming traffic, but only apply minimal restrictions on outgoing traffic. While control of incoming traffic is among the most in-your-face issues of network management, control of outgoing traffic is also important.</p><p>Even if you trust your users, malware can convert a skilled engineer’s workstation into a garbage-spewing pest. Do not assume that your network can do no wrong. It can be malicious, and one day it will be, but careful traffic control can minimize the damage you inflict on your neighbors, clients, customers, and reputation.</p><p>Is there any reason for your staff desktops to connect to any random remote mail server? If not, block it, and even if a workstation is infected with a spambot, the rest of the world won’t blacklist you. Is there any reason for your users to connect to remote DNS servers, or should they use your company’s? Block outbound DNS, and prevent your users from becoming unwitting amplifiers of denial-of-service attacks. I strongly recommend a default deny stance for outbound as well as inbound traffic, and explicitly allowing desirable traffic.</p><p>Some networks might be exceptions, of course. If every system on your network runs OpenBSD, you’re pretty safe from routine malware, but already we see malware targeting televisions, Blu-ray, streaming media players, and other appliances with network connectivity. Protect yourself now.</p><p>Anytime that you catch yourself thinking that your network can do no wrong, stop and remind yourself that you are not as smart as the combination of every malware author in the world.</p></div><div class="sect2" title="What Packet Filtering Doesn’t Do"><div class="titlepage"><div><div><h3 class="title" id="what_packet_filtering_doesnt_do">What Packet Filtering Doesn’t Do</h3></div></div></div><p>Packet filtering controls network connections based entirely on TCP/IP protocols and related characteristics, such as port numbers. If you want to block all traffic from certain IP addresses, packet filtering is your friend. If you want to allow only connections to a particular TCP/IP port, packet filtering will work for you. If you want to allow entrance only to packets with the ECN flag set, but no other flags, PF will support you (even though that’s a pretty daft thing to do).</p><p>You can filter protocols that operate at a logical protocol layer such as IPsec, SKIP, VINES, and so on, but only on the network protocol. If it’s a different protocol layer, PF can’t help.</p><div class="note" title="Note"><h3 class="title"><a id="ch21note03"/>Note</h3><p>PF can even filter by MAC address. There’s special support for this specific media layer protocol via tags added on <code class="literal">bridge(4)</code> interfaces, as documented in <code class="literal">ifconfig(4)</code>.</p></div><p>Similarly, PF doesn’t know anything about applications or application protocols. If you allow TCP/IP connections to port 25 on a server within your network, you might think that you’re allowing connections to the mail server on that host. Actually, you’re allowing connections to whatever daemon happens to be running on port 25 on that host! PF doesn’t recognize an SMTP data stream; it sees only that the connection goes to port 25. (I have a system that offers SSH on many ports commonly assigned to other services, just so I can saunter past whatever naïve packet filter I happen to be stuck behind.)</p></div></div><div class="sect1" title="PF Components"><div class="titlepage"><div><div><h2 class="title" id="pf_components" style="clear: both">PF Components</h2></div></div></div><p><a class="indexterm" id="idx0691"/><a class="indexterm" id="idx1067"/><a class="indexterm" id="idx1673"/><a class="indexterm" id="idx1674"/><a class="indexterm" id="idx1675"/><a class="indexterm" id="idx1784"/>Before we dive into PF, let’s look at the basic components of packet filtering on OpenBSD. In addition to the <code class="literal">pf(4)</code> kernel module, we’ll look at the packet filter control program and the configuration file <span class="emphasis"><em>/etc/pf.conf</em></span>. Knowledge of interface groups also helps.</p><div class="sect2" title="Packet Filter Control and Configuration"><div class="titlepage"><div><div><h3 class="title" id="packet_filter_control_and_configuration">Packet Filter Control and Configuration</h3></div></div></div><p>Use the packet filter control program <code class="literal">pfctl(8)</code> to manage, configure, and extract information from PF. You can see the current packet filter rules and settings, connections being processed, the state of the TCP/IP transactions, debugging information, and all kinds of other details. You can also parse rules files and install them in the actual packet filter.</p><p>You’ll see many different options for <code class="literal">pfctl</code>, addressing every aspect of packet-filter management. Many of these are rather lengthy, but you need to type only as much of the word arguments to make a command unique. For example, instead of typing <code class="literal">pfctl -s rules</code>, you can get away with <code class="literal">pfctl -sr</code> because no other argument to <code class="literal">pfctl -s</code> begins with an <code class="literal">r</code>. That said, I give all examples in their full form, as it’s impossible to guarantee that OpenBSD won’t add some other argument that begins with <code class="literal">r</code> in the future.</p><p>I focus on using <code class="literal">pfctl</code> for viewing PF output, but OpenBSD also includes PF views in <code class="literal">systat(1)</code>. For a dynamic display of PF activity, somewhat like <code class="literal">top(1)</code> for the network, look at <code class="literal">systat</code>. Run <code class="literal">systat</code> by giving the name of the view as an argument, such as <code class="literal">systat pf</code>. And, as always, any time you want more detail from <code class="literal">pfctl</code>, add one or two <code class="literal">-v</code> arguments for verbose mode.</p><p>You configure PF in <span class="emphasis"><em>/etc/pf.conf</em></span>. The <span class="emphasis"><em>pf.conf</em></span> file contains statements and rules, whose format varies with the features they configure. You’ll be very good friends with this file before we’re through.</p></div><div class="sect2" title="Interface Groups"><div class="titlepage"><div><div><h3 class="title" id="interface_groups">Interface Groups</h3></div></div></div><p>OpenBSD lets you put interfaces in named groups, which you can refer to in PF rules. This abstracts away the actual physical interface, and lets you build policy-based rulesets. Take a look at this interface:</p><a id="I_programlisting21_id497769"/><pre class="programlisting"># <span class="strong"><strong>ifconfig em0</strong></span>
em0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
…
        groups: egress
…</pre><p>This interface is in the <code class="literal">egress</code> group. An interface is assigned to the <code class="literal">egress</code> group if a default route is reached over it.</p><p><a class="indexterm" id="idx0694"/><a class="indexterm" id="idx0696"/>To move this interface to a new group, <code class="literal">dmz</code>, remove it from the <code class="literal">egress</code> group and add it to the <code class="literal">dmz</code> group. An interface group is created when you assign the first interface to it, and one interface can be in any number of groups.</p><a id="I_programlisting21_id497830"/><pre class="programlisting"># <span class="strong"><strong>ifconfig em0 -group egress</strong></span>
# <span class="strong"><strong>ifconfig em0 group dmz</strong></span>
# <span class="strong"><strong>ifconfig em0</strong></span>
em0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
…
        groups: dmz
…</pre><p>You can now write rules that reference interface groups instead of specific interfaces.</p></div><div class="sect2" title="PF Configuration"><div class="titlepage"><div><div><h3 class="title" id="pf_configuration">PF Configuration</h3></div></div></div><p>Let’s dismantle the default <span class="emphasis"><em>pf.conf</em></span> from an OpenBSD system and identify some parts. Many of the default entries are commented out, but identifying them will help you understand how the components fit together.</p><p>It begins with an <span class="emphasis"><em>option</em></span>:</p><a id="I_programlisting21_id497886"/><pre class="programlisting">set skip on lo</pre><p>Options turn features on and off, or set general rules on how other features behave. The <code class="literal">skip</code> option disables PF on a per-interface basis.</p><p>Next comes the <code class="literal">anchor</code> setting:</p><a id="I_programlisting21_id497905"/><pre class="programlisting">anchor "ftp-proxy/*",</pre><p>An <span class="emphasis"><em>anchor</em></span> is a set of dynamic sub-rules for packet filtering. If a packet hits an anchor as it’s processed through the filter rules, it’s dropped into this sub-ruleset for further processing. <code class="literal">pfctl</code> can change the rules running in the kernel, and an anchor is a way of saying, “Add new rules here.”</p><p>Anchors are generally used for letting outside software add rules to the firewall. For example, FTP is a complicated protocol that requires all sorts of firewall rules. OpenBSD includes an FTP proxy that dynamically adds the necessary rules for permitted FTP connections.</p><p>Then come two <span class="emphasis"><em>packet-filtering</em></span> rules:</p><a id="I_programlisting21_id497936"/><pre class="programlisting">pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021
pass</pre><p>The first is a rule to support FTP traffic, in combination with the FTP anchor. We’ll look at anchors and FTP handling in more detail in the next chapter. The other is a much simpler packet-filtering rule, which permits all traffic.</p><p><a class="indexterm" id="idx1093"/><a class="indexterm" id="idx1684"/>Up next are two <span class="emphasis"><em>tables</em></span>, which are lists of IP addresses:</p><a id="I_programlisting21_id497974"/><pre class="programlisting">table &lt;spamd-white&gt; persist
table &lt;nospamd&gt; persist file "/etc/mail/nospamd"</pre><p>External programs can dynamically alter tables, and you can add addresses to tables directly within <span class="emphasis"><em>pf.conf</em></span> or in an external file. These two tables are used by the antispam software <code class="literal">spamd(8)</code>.</p><p>After the tables is another packet-filtering rule:</p><a id="I_programlisting21_id497993"/><pre class="programlisting">pass in <span class="strong"><strong>on egress</strong></span> proto tcp from any port smtp \
    rdr-to 127.0.0.1 port spamd</pre><p>This rule is interesting in that it refers to an interface group. Traffic is permitted in, as long as it arrives on an interface in the <code class="literal">egress</code> group.</p><p>And the final rule is as follows:</p><a id="I_programlisting21_id498016"/><pre class="programlisting">block in on ! lo0 proto tcp to port 6000:6010</pre><p>This packet-filtering rule stops traffic. If a packet arrives on any interface except the loopback interface, and the packet is a TCP protocol going to port 6000 through 6010 inclusive, it is blocked.</p><p>This is the sort of thing you’ll see in <span class="emphasis"><em>pf.conf</em></span>. Let’s dive into some specifics of filtering rules.</p></div></div><div class="sect1" title="Filtering Rules"><div class="titlepage"><div><div><h2 class="title" id="filtering_rules" style="clear: both">Filtering Rules</h2></div></div></div><p>Filtering rules are the heart of PF. You can use PF without doing any of the fancy redirection, address translation, load balancing, or redundancy, but packet filtering is the bedrock on which most of these features are based. To start with, however, basic packet filtering is defined as access control for network packets by source, destination, protocol, and protocol characteristics.</p><p>PF processes filtering rules in order. The last rule that matches a packet is acted on. A typical packet-filtering rule looks like this:</p><a id="I_programlisting21_id498052"/><pre class="programlisting"><span class="strong"><strong>1</strong></span>pass <span class="strong"><strong>2</strong></span>in <span class="strong"><strong>3</strong></span>on egress <span class="strong"><strong>4</strong></span>proto tcp <span class="strong"><strong>5</strong></span>from any <span class="strong"><strong>6</strong></span>to 192.0.2.12 <span class="strong"><strong>7</strong></span>port 80</pre><p>The first word of the filter rule is a keyword that describes the results of this rule <span class="strong"><strong>1</strong></span>. PF will either <code class="literal">pass</code> or <code class="literal">block</code> packets that match a rule. (There’s also <code class="literal">match</code>, which we’ll look at in the next chapter.) The rest of the line is a description of matching packets. If the packet matches the description, the rule is applied.</p><p>The second statement is the direction the packet is going. Packets are either going in or out. In this rule, the packet is going <code class="literal">in</code> <span class="strong"><strong>2</strong></span>—it is entering the system. Not only do we define a direction, but we also define an interface group. Packets must be entering this system on an interface in the <code class="literal">egress</code> group to match this rule <span class="strong"><strong>3</strong></span>.</p><p><a class="indexterm" id="idx0146"/><a class="indexterm" id="idx0389"/><a class="indexterm" id="idx1020"/><a class="indexterm" id="idx1644"/><a class="indexterm" id="idx1685"/><a class="indexterm" id="idx1686"/>We then have several statements that define traffic characteristics. (This rule is almost like a regular expression for TCP/IP.) This rule applies to TCP connections <span class="strong"><strong>4</strong></span>, coming from any IP address <span class="strong"><strong>5</strong></span>, if the connection is made to the IP address 192.0.2.12 <span class="strong"><strong>6</strong></span> on port 80 <span class="strong"><strong>7</strong></span>.</p><p>If a packet matches all of these characteristics, it can pass. If any of these characteristics isn’t matched, the packet does not match this rule, and PF continues processing the rules, looking for a matching one.</p><p>TCP and UDP rules implicitly check connection state. A TCP packet that matches this rule needs to be a SYN packet, the start of a standard TCP/IP connection. PF uses the state table to manage follow-up packets in the same connection (see <a class="xref" href="ch21.html#filtering_rules_and_the_state_table" title="Filtering Rules and the State Table">Filtering Rules and the State Table</a>).</p><div class="sect2" title="Default Permit or Default Deny"><div class="titlepage"><div><div><h3 class="title" id="default_permit_or_default_deny">Default Permit or Default Deny</h3></div></div></div><p>I touched earlier on the idea of default accept versus default deny. Set this stance at the beginning of your packet-filtering rules with one of the following two statements:</p><a id="I_programlisting21_id498256"/><pre class="programlisting">pass
block</pre><p>The default <span class="emphasis"><em>pf.conf</em></span> has a default pass stance, but it’s for people who haven’t yet configured a firewall. I recommend starting your filter rules with a lone <code class="literal">block</code> statement, and then adding rules to explicitly permit desirable traffic. Remember that the last matching rule wins.</p></div><div class="sect2" title="Packet Pattern Matching"><div class="titlepage"><div><div><h3 class="title" id="packet_pattern_matching">Packet Pattern Matching</h3></div></div></div><p>One of the most intensive parts of PF is the syntax used to describe packets. Most filter rules describe packets by protocol, port, direction, and other characteristics. PF compares each arriving packet to the state table, and if the packet isn’t part of the state table, it compares the packet to the filter rules. If the rule matches the packet description, the packet is passed or blocked as desired.</p><p>Once you define whether you’re in a default accept or default deny stance, the filter rules describe exceptions to your default. So if you block packets by default, most of your filter rules will be <code class="literal">pass</code> statements that describe particular desirable connections.</p><div class="sect3" title="Direction"><div class="titlepage"><div><div><h4 class="title" id="direction">Direction</h4></div></div></div><p>The keywords <code class="literal">in</code> and <code class="literal">out</code> describe the direction the packets are going. In many commercial firewalls, the word <code class="literal">in</code> means traffic entering the protected network, and <code class="literal">out</code> refers to traffic leaving the protected network. OpenBSD does not magically know which side of the network is protected and which is not. As far as PF knows, it’s managing traffic between two interfaces. The keyword <code class="literal">in</code> means traffic flowing into the machine from the network, and <code class="literal">out</code> means traffic leaving the machine and entering the network.</p><p><a class="indexterm" id="idx0026"/><a class="indexterm" id="idx1498"/><a class="indexterm" id="idx1571"/><a class="indexterm" id="idx1890"/>When you see <code class="literal">in</code> or <code class="literal">out</code> in a PF rule, do not think about your network as a whole. Instead, imagine that you’re very small and sitting on your CPU, grilling steaks over the heat sink and watching packets enter and leave the computer. You cannot see what lies beyond the case, just the packets as they come and go. Packets coming in are approaching you, and packets going out are receding.</p></div><div class="sect3" title="Interface Matching"><div class="titlepage"><div><div><h4 class="title" id="interface_matching">Interface Matching</h4></div></div></div><p>The <code class="literal">on</code> keyword describes an interface or interface group to which this rule applies. You must specify an interface.</p><p>If you want a rule to match every interface on the system, use the interface name <code class="literal">all</code>. This example stops all traffic entering the machine on the interface <code class="literal">fxp0</code>, but allows all traffic leaving the system on the interface group <code class="literal">egress</code>:</p><a id="I_programlisting21_id498419"/><pre class="programlisting">block in on fxp0
pass out on egress</pre><p>This ruleset implies that interface <code class="literal">fxp0</code> is special for some reason, so it’s not treated like the rest of the <code class="literal">egress</code> group.</p></div><div class="sect3" title="Address Families"><div class="titlepage"><div><div><h4 class="title" id="address_families">Address Families</h4></div></div></div><p>Rules can apply to specific address families, either <code class="literal">inet</code> for IPv4 or <code class="literal">inet6</code> for IPv6. Here’s how to prohibit IPv4 but permit IPv6:</p><a id="I_programlisting21_id498454"/><pre class="programlisting">block in on egress inet
pass in on egress inet6</pre><p>Presumably, you have later rules that more tightly restrict IPv6.</p></div><div class="sect3" title="Network Protocol"><div class="titlepage"><div><div><h4 class="title" id="network_protocol">Network Protocol</h4></div></div></div><p>PF can recognize almost any network protocol by number or name. The <code class="literal">proto</code> keyword tells PF to match a protocol. Network protocols can be given by name from <span class="emphasis"><em>/etc/protocols</em></span>, protocol number, or even a list (see <a class="xref" href="ch21.html#using_lists" title="Using Lists">Using Lists</a>).</p><a id="I_programlisting21_id498490"/><pre class="programlisting">block in on egress proto tcp
pass in on egress proto udp</pre><p>You can use this to pass protocols other than IP and IPv6. Here’s how to allow the protocols necessary for IPsec:</p><a id="I_programlisting21_id498498"/><pre class="programlisting">pass in on egress proto esp
pass in on egress proto ah</pre><p><a class="indexterm" id="idx0008"/><a class="indexterm" id="idx0418"/><a class="indexterm" id="idx0795"/><a class="indexterm" id="idx1454"/><a class="indexterm" id="idx2193"/>This functionality somewhat overlaps the <code class="literal">inet</code> and <code class="literal">inet6</code> statements. If you prefer, you could explicitly allow IP, ICMP, TCP, UDP, and all the various IPv6 protocols.</p></div><div class="sect3" title="Source and Destination Address"><div class="titlepage"><div><div><h4 class="title" id="source_and_destination_address">Source and Destination Address</h4></div></div></div><p>Almost every filter rule specifies a source and/or destination address.</p><a id="I_programlisting21_id498582"/><pre class="programlisting">pass in on egress from 198.51.100.0/24 to 192.0.2.0/24</pre><p>IP addresses can appear either as individual addresses or as an address with a netmask (as shown in the preceding example). The keyword <code class="literal">any</code> means any IP address. The keyword <code class="literal">all</code> is shorthand for “from any to any.”</p><p>You can also use hostnames instead of IP addresses. <code class="literal">pfctl</code> will check the IP address of the host when loading the rules, and insert the actual IP address into the rules.</p><a id="I_programlisting21_id498608"/><pre class="programlisting">pass in on egress from www.michaelwlucas.com</pre><p>If the IP address of the host changes, PF won’t notice until you reload the rules with <code class="literal">pfctl</code>. If the hostname cannot be found, the rules won’t parse, and <code class="literal">pfctl</code> will not be able to load them. I recommend not using hostnames in filter rules, much as I recommend not wearing medieval plate armor while swimming, but it is an available option.</p><p>To say “anything but this address,” use the exclamation point as a negation character.</p><a id="I_programlisting21_id498630"/><pre class="programlisting">block in from !192.0.2.0/24</pre><p>This says “block everything except the addresses 192.0.2.0/24.” That’s not the same as saying “pass 192.0.2.0/24,” but it can help simplify your rules.</p><p>You can also use lists, macros, and tables as IP addresses. Lists and macros are discussed later in this chapter, and tables are covered in the next chapter.</p></div><div class="sect3" title="Source and Destination Variants"><div class="titlepage"><div><div><h4 class="title" id="source_and_destination_variants">Source and Destination Variants</h4></div></div></div><p>You can use the name of an interface or interface group instead of an IP address.</p><a id="I_programlisting21_id498657"/><pre class="programlisting">pass out on egress from egress</pre><p>This lets traffic leave via the <code class="literal">egress</code> interface group, from any IP address on any interface in that group, to any IP address.</p><p>If you put the interface name or group in parentheses, PF updates its rules whenever the IP address on the interface changes. This is useful for dial-up connections, or if you add and remove IP addresses from an interface.</p><a id="I_programlisting21_id498675"/><pre class="programlisting">pass out on egress from (egress)</pre><p><a class="indexterm" id="idx1068"/>You can specify a network that is directly attached to an interface or an interface group by following the name with <code class="literal">:network</code>.</p><a id="I_programlisting21_id498693"/><pre class="programlisting">pass in on egress from egress:network</pre><p>Suppose the <code class="literal">egress</code> group has only one interface, and that interface has an IP address of 192.0.2.88/25. This rule would translate to the following:</p><a id="I_programlisting21_id498705"/><pre class="programlisting">pass in on egress from 192.0.2.0/25</pre><p>This rule means that any host on the local network to an <code class="literal">egress</code> interface can communicate anywhere. When you add another interface to the <code class="literal">egress</code> group, the rules automatically update to accommodate the new interface’s network.</p><p>To filter on broadcast traffic for an interface or group, use the <code class="literal">:broadcast</code> modifier.</p><a id="I_programlisting21_id498728"/><pre class="programlisting">block in on egress from egress:broadcast</pre><p>Again, suppose that the <code class="literal">egress</code> group has only one interface, and that interface has an IP address of 192.0.2.88/25. This rule would translate to the following, blocking broadcast traffic on the local subnet:</p><a id="I_programlisting21_id498741"/><pre class="programlisting">block in on egress from 192.0.2.127</pre><p>Use the <code class="literal">:peer</code> modifier to indicate the IP address of the far side of a point-to-point link, such as a dial-up connection.</p><a id="I_programlisting21_id498754"/><pre class="programlisting">pass in on egress from egress:peer</pre><p>Here, we completely trust our dial-up provider.</p></div><div class="sect3" title="Interface Main Address"><div class="titlepage"><div><div><h4 class="title" id="interface_main_address">Interface Main Address</h4></div></div></div><p>To use only the first IP address on an interface, add the <code class="literal">:0</code> modifier with an interface or group name.</p><a id="I_programlisting21_id498778"/><pre class="programlisting">pass out on egress from (egress:0)</pre><p>The <code class="literal">egress</code> interface group might have 98 IP addresses scattered across three interfaces, but only one address on each interface is the first address. This host can communicate out through the <code class="literal">egress</code> interface group, but only from primary IP addresses. The aliased IP addresses cannot initiate outbound connections.</p><p>The problem with the <code class="literal">:0</code> modifier is that the kernel has a very weak idea of what is the “first” address on an interface. The kernel has a list of addresses associated with an interface. The address at the top of this list is the “first” or “main” address at the moment, but this address can change. If this might cause problems, specify an IP address in your rule rather than rely on <code class="literal">:0</code>.</p><p><a class="indexterm" id="idx0419"/><a class="indexterm" id="idx0745"/><a class="indexterm" id="idx2201"/>You can attach <code class="literal">:0</code> to any of the other interface modifiers, that is, to IP addresses other than the first from the rule. OpenBSD can’t tell if IP addresses on remote machines are aliases or actual IP addresses, but you can prohibit traffic to or from aliases on the local machine.</p><p>Note that the first address on an interface is either an IPv4 address <span class="emphasis"><em>or</em></span> an IPv6 address. If you want to allow the first address of each protocol, specify the address family in the rule.</p><a id="I_programlisting21_id498849"/><pre class="programlisting">pass out on egress inet from egress:0
pass out on egress inet6 from egress:0</pre><p>Otherwise, PF will use only the first address it sees, regardless of address family.</p></div><div class="sect3" title="Source and Destination Port"><div class="titlepage"><div><div><h4 class="title" id="source_and_destination_port">Source and Destination Port</h4></div></div></div><p>Filter rules can describe TCP and UDP ports.</p><a id="I_programlisting21_id498872"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port 80</pre><p>This example permits access to TCP port 80 on the server 192.0.2.12. Presumably, this is a web server.</p><p>You could use a service name from <span class="emphasis"><em>/etc/services</em></span> instead of a port number, or even use a list (as described later in this chapter). You can also use ranges, as shown in <a class="xref" href="ch21.html#port_ranges" title="Table 21-1. Table 21-1: Port Ranges">Table 21-1</a>.</p><div class="table"><a id="port_ranges"/><div class="table-title">Table 21-1. Table 21-1: Port Ranges</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Symbol</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Meaning</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">!=</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Not equal</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Less than</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&gt;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Greater than</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;=</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Less than or equal to</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&gt;=</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Greater than or equal to</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&gt;&lt;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Range</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">&lt;&gt;</code></p></td><td style="vertical-align: top; "><p>Inverse range</p></td></tr></tbody></table></div></div><p>For example, to specify all ports over 1024, you could use the greater-than operator (<code class="literal">&gt;</code>).</p><a id="I_programlisting21_id499091"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port &gt; 1024</pre><p>To specify all ports between 1000 and 2000, excluding both 1000 and 2000, use the range operator (<code class="literal">&gt;&lt;</code>).</p><a id="I_programlisting21_id499104"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port 1000 &gt;&lt; 2000</pre><p><a class="indexterm" id="idx1669"/><a class="indexterm" id="idx1672"/><a class="indexterm" id="idx1785"/>To include ports 1000 and 2000 in your range, use the inclusive range operator (<code class="literal">:</code>). (Note that you cannot have space on either side of the colon.)</p><a id="I_programlisting21_id499138"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port 1000:2000</pre><p>To pass traffic on all ports less than 1000 and greater than 2000, use the inverse range operator (<code class="literal">&lt;&gt;</code>).</p><a id="I_programlisting21_id499151"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port 1000 &lt;&gt; 2000</pre><p>Ranges let you express large numbers of ports in very few rules.</p></div></div><div class="sect2" title="A Complete Ruleset"><div class="titlepage"><div><div><h3 class="title" id="a_complete_ruleset">A Complete Ruleset</h3></div></div></div><p>The following is a complete ruleset for a desktop machine, using many of the features described previously. We’ll look at some more complicated rulesets later, but this illustrates many basic principles of PF rules.</p><p>Interface group <code class="literal">egress</code> is attached to the public network, and interface group <code class="literal">inside</code> is connected to my private network.</p><a id="I_programlisting21_id499183"/><pre class="programlisting"><span class="strong"><strong>1</strong></span> set skip on lo
<span class="strong"><strong>2</strong></span> block
<span class="strong"><strong>3</strong></span> pass in on egress from egress:network
<span class="strong"><strong>4</strong></span> pass in on inside from inside:network
<span class="strong"><strong>5</strong></span> pass in on egress proto tcp from any to egress:0 port 22
<span class="strong"><strong>6</strong></span> pass out all</pre><p>The first rule disables packet filtering on the loopback interface <span class="strong"><strong>1</strong></span>, and the second defines a default deny stance <span class="strong"><strong>2</strong></span>. The second and third rules permit all connections from IP addresses directly connected to the external <span class="strong"><strong>3</strong></span> and internal interfaces <span class="strong"><strong>4</strong></span>. If I install a web server on my desktop, I want to be able to view it from any machine on the network I control. Then I permit inbound SSH connections from anywhere in the world to the primary IP address on any <code class="literal">egress</code> interface <span class="strong"><strong>5</strong></span>. Finally, I permit all outbound traffic, so my desktop can freely access the outside world <span class="strong"><strong>6</strong></span>.</p><p>I’ve said before that PF rules are processed in order, and these rules illustrate that. I establish a default, blocking all traffic, and then use individual rules to carve out exceptions to that global block.</p></div><div class="sect2" title="Activating Rules"><div class="titlepage"><div><div><h3 class="title" id="activating_rules">Activating Rules</h3></div></div></div><p>For your PF rules to take effect, you must load them into the kernel using <code class="literal">pfctl -f</code>.</p><a id="I_programlisting21_id499292"/><pre class="programlisting"># <span class="strong"><strong>pfctl -f /etc/pf.conf</strong></span></pre><p>First, <code class="literal">pfctl</code> reads and parses the rules file. If the file parses correctly, <code class="literal">pfctl</code> expands any variables in the file, performs any necessary DNS lookups to transform hostnames into IP addresses, and feeds the complete rules into the kernel. The kernel reads the new rules, and then swaps between the old and new rules in one operation. At no time are the packet-filtering rules missing, scrambled, or a hybrid of the two rulesets. Also note that <code class="literal">pfctl -f</code> won’t enable PF if it’s disabled.</p><p><a class="indexterm" id="idx1782"/><a class="indexterm" id="idx2408"/>Personally, I like to know that my edited packet-filter configuration parses before the scheduled change time. It’s embarrassing to announce to your team that “the new firewall configuration will be active at noon” and spend the whole time tracking down a misplaced comma or a parenthesis where you should have put in a curly brace. To test your syntax without installing the rules, use the <code class="literal">-n</code> flag with <code class="literal">-f</code>. Add <code class="literal">-v</code> for verbose mode, to see how <code class="literal">pfctl</code> expands your macros, groups, and so on.</p><a id="I_programlisting21_id499360"/><pre class="programlisting"># <span class="strong"><strong>pfctl -nvf /etc/pf.conf</strong></span></pre><p>The rules might still have errors, but only errors of comprehension rather than syntax.</p><p>Loading new rules doesn’t remove any existing open connections or state entries. If my old ruleset allowed outbound SSH connections, and I remove that permission from the newly installed rules, existing SSH connections remain open. I can either specifically kill those connections with <code class="literal">pfctl -k</code> or flush the state table.</p></div><div class="sect2" title="Viewing Active Rules"><div class="titlepage"><div><div><h3 class="title" id="viewing_active_rules">Viewing Active Rules</h3></div></div></div><p>To see how these rules are interpreted inside PF, view the currently installed ruleset with <code class="literal">pfctl -s rules</code>. Here are the rules generated by the configuration in <a class="xref" href="ch21.html#a_complete_ruleset" title="A Complete Ruleset">A Complete Ruleset</a>:</p><a id="I_programlisting21_id499405"/><pre class="programlisting">  # <span class="strong"><strong>pfctl -s rules</strong></span>
<span class="strong"><strong>1</strong></span> block drop all
<span class="strong"><strong>2</strong></span> pass in on egress inet6 from 2001:db8:4::/64 flags S/SA
<span class="strong"><strong>3</strong></span> pass in on egress inet from 192.0.2.0/28 flags S/SA
<span class="strong"><strong>4</strong></span> pass in on inside inet from 192.168.1.0/24 flags S/SA
<span class="strong"><strong>5</strong></span> pass in on egress inet proto tcp to 192.0.2.5 port = 22 flags S/SA
<span class="strong"><strong>6</strong></span> pass out all flags S/SA</pre><p>The first rule establishes a default deny stance <span class="strong"><strong>1</strong></span>. I then specifically allow connections from hosts on the networks local to interfaces in the <code class="literal">egress</code> group, for both IPv6 <span class="strong"><strong>2</strong></span> and IPv4 <span class="strong"><strong>3</strong></span>. This desktop also accepts connections from my private network <span class="strong"><strong>4</strong></span>.</p><p>The private network permits connections only from IPv4 addresses because the interface in the private group has only an IPv4 address. (I really should add an IPv6 address, but it hasn’t caused me any trouble, so I’ll probably forget all about it once again.) Then there’s a rule permitting inbound SSH traffic <span class="strong"><strong>5</strong></span>, followed by a final rule to pass all outbound traffic <span class="strong"><strong>6</strong></span>.</p><p>If I change any IP address on my desktop, my firewall rules update to accommodate them. That’s a really nice feature of interface groups. If I moved my desktop regularly, I would put the interface group names in parentheses so PF would watch for IP address changes.</p><div class="note" title="Note"><h3 class="title"><a id="ch21note04"/>Note</h3><p><a class="indexterm" id="idx1687"/><a class="indexterm" id="idx1789"/><a class="indexterm" id="idx2236"/><a class="indexterm" id="idx2376"/>One thing you’ll probably notice is that the pass rules end with <code class="literal">flags S/SA</code>. This means that out of the SYN and ACK flags, matching packets can have only the SYN flag set, indicating that these are requests to establish a connection. You can filter on TCP flags, but doing so requires in-depth understanding of TCP, and most people should never do it. To see how SYN and SYN+ACK packets affect connections, you need to understand the state table.</p></div><p>To see how often a packet triggers each rule, add <code class="literal">-v</code> to the <code class="literal">pfctl</code> command.</p><p>To see how the rules impact traffic in a constantly updating display, run <code class="literal">systat rules</code>.</p></div></div><div class="sect1" title="Filtering Rules and the State Table"><div class="titlepage"><div><div><h2 class="title" id="filtering_rules_and_the_state_table" style="clear: both">Filtering Rules and the State Table</h2></div></div></div><p>OpenBSD tracks approved connections in the state table. Packets that are part of an approved connection are allowed to pass. Consider this rule from an earlier example:</p><a id="I_programlisting21_id499597"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port 80</pre><p>If a packet matches this rule, and it has the TCP/IP flags that indicate this is the start of a TCP connection, PF permits the connection. PF also makes an entry in the state table. If a packet arrives that matches the state table, PF passes the packet without consulting the rules.</p><div class="sect2" title="TCP States"><div class="titlepage"><div><div><h3 class="title" id="tcp_states">TCP States</h3></div></div></div><p>First, we’ll look at a state table entry for a TCP connection. To view the state table, enter <span class="strong"><strong><code class="literal">pfctl -s states</code></strong></span>.</p><a id="I_programlisting21_id499630"/><pre class="programlisting"># <span class="strong"><strong>pfctl -s states</strong></span>
<span class="strong"><strong>1</strong></span>all <span class="strong"><strong>2</strong></span>tcp <span class="strong"><strong>3</strong></span>192.0.2.12:80 &lt;- <span class="strong"><strong>4</strong></span>198.51.100.227:55635 <span class="strong"><strong>5</strong></span>ESTABLISHED:ESTABLISHED
…</pre><p>This state table entry represents one specific connection that the packet filter approved. This state applies to all interfaces <span class="strong"><strong>1</strong></span>. If a state applies to only one interface, you’ll see the interface name here.</p><p>This TCP connection <span class="strong"><strong>2</strong></span> was bound for 192.0.2.12 port 80 <span class="strong"><strong>3</strong></span>, and came from the host 198.51.100.227 port 55635 <span class="strong"><strong>4</strong></span>. When the first SYN packet arrived from 198.51.100.227 port 55635, PF added this entry to the state table. When 192.0.2.12 sent a SYN+ACK packet back to 198.51.100.227 port 55635, PF consulted the state table. This was clearly a match to the permitted SYN packet, so PF permitted that packet, even though no explicit rule in <span class="emphasis"><em>pf.conf</em></span> permitted that connection. Data exchange between these two hosts and these two ports proceeded.</p><p><a class="indexterm" id="idx2316"/><a class="indexterm" id="idx2475"/>PF knows what an actual TCP/IP data exchange looks like. There’s a three-way handshake in the beginning, and a similar dance when the connection is finished and PF tracks the state of the connection. This particular connection is established on both sides <span class="strong"><strong>5</strong></span>, meaning that the initial setup negotiation succeeded, and data can flow back and forth freely.</p><p>If your server is busy enough, and you keep refreshing the state table view, you’ll catch connections in other states. Here’s the same connection as the data exchange ends and is being torn down:</p><a id="I_programlisting21_id499743"/><pre class="programlisting">all tcp 192.0.2.12:80 &lt;- 198.51.100.227:55635  FIN_WAIT_2:FIN_WAIT_2</pre><div class="note" title="Note"><h3 class="title"><a id="ch21note05"/>Note</h3><p>One possible problem with viewing the state table is that <code class="literal">pfctl</code> displays a snapshot. By the time your eyes scroll down the screen, the table has changed. Personally, I find that’s the only way I can cope with the information. If you need to view states in a constantly updating display, in near real time, run <code class="literal">systat states</code>.</p></div><p>The state table is very specific. A state table entry permitting 198.51.100.227 port 55635 to 192.0.2.12 port 80 does not permit traffic between other hosts and ports. PF knows how traffic should flow, and it won’t allow traffic that isn’t obviously part of an existing TCP/IP exchange. If a packet arrives from 198.51.100.227 that looks like it’s part of this data exchange, except that it comes from port 55634 instead of 55635, the state table entry won’t match. Similarly, if PF knows that the connection is in a <code class="literal">FIN_WAIT_2</code> state, or almost finished, a subsequent data packet with an ACK flag set won’t match and will be discarded. This is because a SYN request from the same host, from the same port, should not arrive—the client should know that the port is busy closing the previous connection. A new connection should come from a different port on the client and create a new state table entry.</p><p>Without stateful inspection, you would need to write firewall rules that not only permitted incoming traffic, but also permitted the responses. Your firewall rules would need to permit outbound connections to thousands of high-numbered ports, instead of just the single ports attached to desirable connections. Filtering based on TCP flags would be nearly impossible.</p><div class="note" title="Note"><h3 class="title"><a id="ch21note06"/>Note</h3><p>As a consultant in the 1990s, I made a couple of rent payments dismantling such rules that had been shoehorned into stateless packet filters because they just aren’t realistic without stateful inspection. Plus, carefully tracking data exchanges not only simplifies rules, but also prevents a whole slew of TCP/IP-based attacks. You don’t hear much about these attacks anymore, thanks to stateful inspection.</p></div></div><div class="sect2" title="UDP States"><div class="titlepage"><div><div><h3 class="title" id="udp_states">UDP States</h3></div></div></div><p>The state entries for UDP connections are similar to those for TCP connections.</p><a id="I_programlisting21_id499812"/><pre class="programlisting">all udp 192.0.2.12:53 &lt;- 198.51.100.227:38469       SINGLE:MULTIPLE</pre><p><a class="indexterm" id="idx1005"/><a class="indexterm" id="idx1078"/><a class="indexterm" id="idx1198"/><a class="indexterm" id="idx1679"/>This is a DNS query, bound for 192.0.2.12 port 53 from 198.51.100.227 port 38469. The client sent a single packet, and the destination replied with multiple packets. While stateful inspection cannot identify the state of this connection by flags, it can track the source and destination addresses and ports. You would need to write only a single rule permitting access to 192.0.2.12 port 53, and stateful inspection would permit the matching reply packets.</p></div><div class="sect2" title="ICMP States"><div class="titlepage"><div><div><h3 class="title" id="icmp_states">ICMP States</h3></div></div></div><p>ICMP falls somewhere in between TCP and UDP. PF is aware of ICMP types and knows legitimate responses to ICMP packets, and by using stateful inspection, you get all of these benefits automatically. Much as you could write rules that permit specific TCP flags, you can write rules that permit certain ICMP types and codes. Most of us cannot manage that, and those of us who can know better. (ICMP errors referring to an existing TCP or UDP state are matched to the state, and don’t need to be allowed separately.)</p><div class="note" title="Note"><h3 class="title"><a id="ch21note07"/>Note</h3><p>OpenBSD’s stateful inspection actually tracks more detail than source and destination addresses and ports. Add <code class="literal">-v</code> to the <code class="literal">pfctl</code> command to see more information, including timing, the number of packets passed as a result of the state, and more.</p></div></div></div><div class="sect1" title="Packet Filtering with Lists and Macros"><div class="titlepage"><div><div><h2 class="title" id="packet_filtering_with_lists_and_macros" style="clear: both">Packet Filtering with Lists and Macros</h2></div></div></div><p>PF includes many ways to have one rule reference several similar items, or symbolically represent something with a variable. The basic ways are lists and macros.</p><div class="sect2" title="Using Lists"><div class="titlepage"><div><div><h3 class="title" id="using_lists">Using Lists</h3></div></div></div><p>A <span class="emphasis"><em>list</em></span> is a way to represent several similar items in one rule. You might want to use a list if, for example, you want a particular group of TCP ports open on a certain group of hosts, and your rule entries would be repetitions of one rule with minor changes. Opening ports 80 and 443 to one host requires two rules: one for each port. If you have 30 web servers, you would need 60 rules. This is a pain to maintain and error-prone, but lists let you express these common elements more easily.</p><p>A list is represented in curly braces within a rule. To make the rule more readable, you can put a comma between items.</p><a id="I_programlisting21_id499934"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port {80, 443}</pre><p>This one <span class="emphasis"><em>pf.conf</em></span> statement creates two rules, opening both TCP ports 80 and 443 to the target host.</p><a id="I_programlisting21_id499945"/><pre class="programlisting">pass in on egress from any to 192.0.2.12 port = 80 flags S/SA
pass in on egress from any to 192.0.2.12 port = 443 flags S/SA</pre><p><a class="indexterm" id="idx1265"/><a class="indexterm" id="idx1680"/>You could also use a list to have this rule cover multiple web servers.</p><a id="I_programlisting21_id499967"/><pre class="programlisting">pass in on egress proto tcp from any to {192.0.2.12, 192.0.2.13} port {80, 443}</pre><p>This expands to four rules: one for each combination of server and port.</p><p>Remember that each entry in the list creates its own rules. The list entries do not combine to create a single rule.</p></div><div class="sect2" title="Using Macros"><div class="titlepage"><div><div><h3 class="title" id="using_macros">Using Macros</h3></div></div></div><p>A macro is a variable that you create and define for use within PF rules. Macros keep <span class="emphasis"><em>pf.conf</em></span> more readable, maintainable, and manageable.</p><p>Macro names must begin with a letter, but can include letters, numbers, and underscores. You cannot give a macro a name that’s used elsewhere in PF, like <code class="literal">pass</code>, <code class="literal">block</code>, or <code class="literal">proto</code>. Frequent uses of macros include interface names, network addresses, and ports.</p><p>Earlier, we saw a list that included the popular web ports 80 and 443. You could make these a macro, as follows:</p><a id="I_programlisting21_id500019"/><pre class="programlisting">web_ports="{80, 443}"</pre><p>Our sample rule would then become this:</p><a id="I_programlisting21_id500026"/><pre class="programlisting">pass in on egress proto tcp from any to 192.0.2.12 port $web_ports</pre><p>When combined with braces, macros can simplify your <span class="emphasis"><em>pf.conf</em></span> file. Consider the following <span class="emphasis"><em>pf.conf</em></span> snippet:</p><a id="I_programlisting21_id500042"/><pre class="programlisting">webservers="{192.0.2.12, 192.0.2.13, 192.0.2.14, 192.0.2.15}"
web_ports="{80, 443}"
pass in on egress proto tcp from any to $webservers port $web_ports</pre><p>This expands to eight rules, but requires only three easy-to-understand configuration statements. When you add a new web server, add its IP address to the list in the <code class="literal">webservers</code> macro. What’s more, you might use the <code class="literal">webservers</code> macro in dozens of places throughout your rules. Changing the IP address list once is much easier and more likely to be correct than doing so in each rule.</p><p>While you probably use interface groups to represent IP addresses local to your machine, you might have other IP addresses that you need to represent. Macros are great for this, too.</p><a id="I_programlisting21_id500066"/><pre class="programlisting">internal_ip="10.10.0.0/16"</pre><p>Or if you have multiple disparate blocks, you could use a list inside the macro.</p><a id="I_programlisting21_id500074"/><pre class="programlisting">internal_ip="{10.0.0.0/24, 10.0.5.0/24, 10.0.10.0/24}"</pre><p><a class="indexterm" id="idx0796"/><a class="indexterm" id="idx1019"/><a class="indexterm" id="idx1199"/><a class="indexterm" id="idx1455"/><a class="indexterm" id="idx1688"/><a class="indexterm" id="idx2012"/>You don’t see macros or lists when viewing the running PF rules with <code class="literal">pfctl</code>; instead, you see the rules that they expand to.</p></div><div class="sect2" title="A Common Error: List Exclusions and Negations"><div class="titlepage"><div><div><h3 class="title" id="a_common_error_list_exclusions_and_negat">A Common Error: List Exclusions and Negations</h3></div></div></div><p>Lists can be counterintuitive, and it’s easy to write lists that negate other rules. For example, this seems like it should work:</p><a id="I_programlisting21_id500142"/><pre class="programlisting">clients = "{192.0.2.0/24, !192.0.2.128/29}"
pass in on egress from $clients</pre><p>The idea here is that our clients have the IP addresses 192.0.2.0/24. We want to permit all of those addresses except for the small chunk in the middle, 192.0.2.128/29. That seems reasonable, right? But much like excluding commands from <code class="literal">sudo(8)</code>, this breaks. Remember that each entry in a list expands into another rule. This creates two rules.</p><a id="I_programlisting21_id500155"/><pre class="programlisting">pass in on egress inet from 192.0.2.0/24 flags S/SA
pass in on egress inet from ! 192.0.2.128/29 flags S/SA</pre><p>The first rule passes in everything from the 192.0.2.0/24 subnet. That’s what we wanted. The second rule, however, passes in <span class="emphasis"><em>everything</em></span> that’s not in the subnet 192.0.2.128/29, also known as “everyone in the world”—not what we were hoping to achieve.</p><p>Similarly, negating an entire list expands to negating each individual item in the list. If you need to do this sort of exclusion, use a table, as described in the next chapter.</p></div></div><div class="sect1" title="Sanitizing Traffic"><div class="titlepage"><div><div><h2 class="title" id="sanitizing_traffic" style="clear: both">Sanitizing Traffic</h2></div></div></div><p>All sorts of weird traffic arrives at Internet hosts. Some of that traffic is broken garbage. Other parts tell you that someone else is running broken garbage.</p><p>PF tries to sanitize and normalize traffic before otherwise processing it. The normalizations include discarding illegal packets, packet reassembly, and packet modification.</p><div class="sect2" title="Illegal Packets"><div class="titlepage"><div><div><h3 class="title" id="illegal_packets">Illegal Packets</h3></div></div></div><p>Some of the random stuff that arrives at a host is garbage. If a packet is shorter than the IP header, it can’t be a real IP packet, and if a TCP packet is too short to include a full TCP header, it can’t be a real packet.</p><p>If the packet length doesn’t match the length given in the header, it’s somehow corrupt. PF has no way to figure out where these packets came from, or if they’re maliciously damaged or just corrupted in transit. Since the kernel can’t do anything with them, PF automatically drops them.</p></div><div class="sect2" title="Packet Reassembly"><div class="titlepage"><div><div><h3 class="title" id="packet_reassembly-id00002">Packet Reassembly</h3></div></div></div><p><a class="indexterm" id="idx0060"/><a class="indexterm" id="idx1671"/><a class="indexterm" id="idx1683"/><a class="indexterm" id="idx1783"/><a class="indexterm" id="idx2032"/><a class="indexterm" id="idx2204"/>Before the packet filter can decide how to handle a packet, the packet should be free of ambiguities and random weirdness. Reassembly cleans up these ambiguities, and the default reassembly settings are suitable for most environments. You get reassembly when you enable PF.</p></div><div class="sect2" title="Packet Modification"><div class="titlepage"><div><div><h3 class="title" id="packet_modification">Packet Modification</h3></div></div></div><p>Sometimes you need to modify packets. These days, PF handles everything for most environments. If you need to modify packets, such as clearing the “do not fragment” bit on fragmented UDP packets, see the <code class="literal">scrub</code> keyword in <code class="literal">pf.conf(5)</code>.</p></div><div class="sect2" title="Blocking Spoofed Packets"><div class="titlepage"><div><div><h3 class="title" id="blocking_spoofed_packets">Blocking Spoofed Packets</h3></div></div></div><p>Another classic IP attack is sending packets that appear to come from the private network to a firewall, in an attempt to evade the packet filter. Most firewalls today block this type of attack, so attackers rarely bother, but you should still protect against spoofed attacks. Just because everyone else has had their measles shot doesn’t mean you should go without one.</p><p>For an antispoofing rule, use <code class="literal">antispoof for</code> and an interface name.</p><a id="I_programlisting21_id500329"/><pre class="programlisting">antispoof for fxp0</pre><p>When fed into the packet filter, the rules would look something like this:</p><a id="I_programlisting21_id500335"/><pre class="programlisting">block drop in on ! fxp0 inet from 192.0.2.5/28
block drop in inet from 192.0.2.5 set ( prio 0 )</pre><p>The first rule drops any traffic that arrives from an address local to interface <code class="literal">fxp0</code> on any interface other than <code class="literal">fxp0</code>. Packets from an address local to interface <code class="literal">fxp0</code> should always arrive on your system via <code class="literal">fxp0</code>.</p><p>The second rule drops any traffic that comes from the address of interface <code class="literal">fxp0</code>. Packets with that source address should never arrive from the outside world. If the system needs to communicate with itself, it uses interface <code class="literal">lo0</code>.</p><p>You could use interface groups instead of interface names, but I don’t recommend doing so. If you have multiple <code class="literal">egress</code> interfaces, using antispoofing rules on the egress group won’t block outside packets that arrive at the wrong egress interface. Take the time to enumerate your interfaces in your antispoofing rules.</p><p>Instead of listing a single interface, you can also use a list or a macro.</p><a id="I_programlisting21_id500385"/><pre class="programlisting">antispoof for {lo0, fxp0, em0}</pre><p>Antispoofing rules can mess with packets passed over the loopback interface. I recommend skipping filtering on <code class="literal">lo0</code>, although PF includes special built-in protection for 127.0.0.0/8 addresses.</p><p>Now that you have basic packet filtering, let’s consider some of PF’s core settings.</p></div></div><div class="sect1" title="PF Options"><div class="titlepage"><div><div><h2 class="title" id="pf_options" style="clear: both">PF Options</h2></div></div></div><p><a class="indexterm" id="idx1770"/><a class="indexterm" id="idx1772"/><a class="indexterm" id="idx1773"/><a class="indexterm" id="idx2096"/><a class="indexterm" id="idx2097"/><a class="indexterm" id="idx2098"/><a class="indexterm" id="idx2099"/>Options are basic settings that affect core PF functions. Options answer questions like these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Do we reassemble fragments into packets?</p></li><li class="listitem"><p>How many entries should the state table support?</p></li><li class="listitem"><p>Is logging on?</p></li></ul></div><p>All options start with the <code class="literal">set</code> keyword. Because options affect how all other parts of PF operate, I recommend placing them at the very top of <span class="emphasis"><em>pf.conf</em></span>.</p><p>Here, we’ll look at some of the more commonly used options.</p><div class="sect2" title="The set block-policy Option"><div class="titlepage"><div><div><h3 class="title" id="the_set_block-policy_option">The set block-policy Option</h3></div></div></div><p>Will your firewall silently drop forbidden packets, or respond to the client with “sorry, not allowed?” The block policy determines which approach it takes. By default, PF drops blocked packets, but you can override the global block policy on individual filter rules.</p><p>Strictly speaking, when PF drops packets, it should return an error to the client, so that legitimate clients can immediately recognize that they cannot connect. Using <code class="literal">set block-policy return</code> tells PF to return these polite errors: an RST for TCP connections and an ICMP unreachable message for other types of connections.</p><p>Unfortunately, politeness has largely been overwhelmed by the modern Internet. PF’s default, <code class="literal">set block-policy drop</code>, tells PF to not return any kind of error on blocked packets. Client applications such as web browsers, vulnerability scanners, worms, and other malware must wait for the network protocol to time out before realizing that they cannot connect.</p><p>I recommend dropping blocked packets silently.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id467314" id="id467314">47</a>]</sup></p></div><div class="sect2" title="The set limit Option"><div class="titlepage"><div><div><h3 class="title" id="the_set_limit_option">The set limit Option</h3></div></div></div><p>PF includes limits on the size of various internal tables used to track fragments, states, address tables, and other memory-consuming items. I have needed to adjust these limits on very rare occasions. The existing limits are chosen because they are sufficient for most users in most environments.</p><p>View the existing limits with <code class="literal">pfctl</code>.</p><a id="I_programlisting21_id500592"/><pre class="programlisting"># <span class="strong"><strong>pfctl -s memory</strong></span>
states        hard limit    10000
src-nodes     hard limit    10000
frags         hard limit     1536
tables        hard limit     1000
table-entries hard limit   200000</pre><p>Let’s take a look at what each limit represents.</p><div class="sect3" title="frags Limit"><div class="titlepage"><div><div><h4 class="title" id="frags_limit">frags Limit</h4></div></div></div><p><a class="indexterm" id="idx0883"/><a class="indexterm" id="idx1771"/><a class="indexterm" id="idx1776"/><a class="indexterm" id="idx1777"/><a class="indexterm" id="idx2207"/><a class="indexterm" id="idx2242"/><a class="indexterm" id="idx2249"/><a class="indexterm" id="idx2315"/>When PF receives a fragmented packet, it holds onto that fragment and waits for other fragments of that packet to arrive. Once it has all the pieces, it reassembles the fragment and processes it. The <code class="literal">frags</code> limit controls the number of packet fragments awaiting reassembly at one time. (You shouldn’t need to change this.)</p><p>To see the total number of fragments PF has processed, and how many arrive per second, use <code class="literal">pfctl -s info</code> and look at the Counters section.</p><a id="I_programlisting21_id500720"/><pre class="programlisting"># <span class="strong"><strong>pfctl -s info</strong></span>
…
  fragment                             368            0.0/s
…</pre><p>This host has been sitting on the naked Internet for three months in an Internet colocation site, and has received only 368 fragments. I do not need to increase PF’s memory for fragments, and I certainly don’t want to reduce the limit in case I receive a sudden barrage of fragments.</p><p>If you suspect that fragments are flowing in, run <code class="literal">systat pf</code> for constantly updating counters of PF statistics.</p></div><div class="sect3" title="The src-nodes Limit"><div class="titlepage"><div><div><h4 class="title" id="the_src-nodes_limit">The src-nodes Limit</h4></div></div></div><p>PF can track a number of states per source address. You might want to limit each client to, say, 10 connections to a specific server. This connection limit includes connections being set up and those still waiting to finish. Here’s an example of this sort of rule:</p><a id="I_programlisting21_id500760"/><pre class="programlisting">pass in proto tcp to $webserver port 80 keep state(max-src-states 10)</pre><p>PF’s load balancer features use <code class="literal">src-nodes</code> to help track which clients are attached to which servers, through the <code class="literal">sticky-address</code> and <code class="literal">source-track</code> options.</p><p>If you use these features, and think you might be out of source nodes, check usage with <code class="literal">pfctl -s Sources</code>.</p></div><div class="sect3" title="The states Limit"><div class="titlepage"><div><div><h4 class="title" id="the_states_limit">The states Limit</h4></div></div></div><p>The <code class="literal">states</code> limit controls how many entries can be in the stateful inspection list. The default of 10,000 is adequate for most environments.</p><p>You can view the current usage with <code class="literal">pfctl -s info</code>.</p><a id="I_programlisting21_id500812"/><pre class="programlisting"># <span class="strong"><strong>pfctl -s info</strong></span>
Status: Enabled for 1 days 18:01:06              Debug: err
State Table                          Total             Rate
  current entries                       30
  searches                        54510751            6.3/s
  inserts                          2459724            0.3/s
  removals                         2459694            0.3/s
…</pre><div class="note" title="Note"><h3 class="title"><a id="ch21note08"/>Note</h3><p><a class="indexterm" id="idx0288"/><a class="indexterm" id="idx1551"/><a class="indexterm" id="idx1774"/><a class="indexterm" id="idx2100"/><a class="indexterm" id="idx2430"/>I have needed to change the state table more than once. Each time, it was because of a strangely written application that required clients to make dozens of connections to a single TCP/IP port. I’m certain that the application developers had their reasons for doing so (possible reasons do include ignorance and malice). Multiplied by thousands of simultaneous users, that became a lot of states. As I wasn’t in a position to tell the developers to write their application like normal people, I had to adjust the state table.</p></div><p>If you suspect that the state table is having trouble, use <code class="literal">systat pf</code> and/or <code class="literal">systat states</code> to view state activity in real time.</p></div><div class="sect3" title="The tables and table-entries Limits"><div class="titlepage"><div><div><h4 class="title" id="the_tables_and_table-entries_limits">The tables and table-entries Limits</h4></div></div></div><p>The <code class="literal">tables</code> and <code class="literal">table-entries</code> limits control how many tables PF can create, and how many entries can go into a single table. I have never had to adjust these, and I would suggest that if your filter rules need more than 1000 tables, you should probably reconsider how you’ve designed it. A table might need to hold more than 100,000 addresses, but that’s very much the exception these days.</p></div><div class="sect3" title="Setting Limits"><div class="titlepage"><div><div><h4 class="title" id="setting_limits">Setting Limits</h4></div></div></div><p>To change a limit, use <code class="literal">set limit</code>, the name of the limit, and the new value. Here’s how to double the size of the default state table:</p><a id="I_programlisting21_id500939"/><pre class="programlisting">set limit states 20000</pre><p>Again, don’t change these defaults lightly. Increase them only if existing limits cause a specific problem. And don’t decrease them, or you won’t be prepared for problems and spikes.</p></div></div><div class="sect2" title="The set optimization Option"><div class="titlepage"><div><div><h3 class="title" id="the_set_optimization_option">The set optimization Option</h3></div></div></div><p>PF includes a variety of timeouts, which default to values reasonable for the modern Internet. Some environments, such as satellite uplinks, do require slightly different timeouts.</p><p>You can adjust PF’s timeouts with <code class="literal">set optimization</code>. (The name is a leftover from the early days of PF, but has stuck around.) This has four values:</p><div class="blockquote" title="normal"><blockquote class="blockquote" title="normal"><div class="blockquote-title"><span class="strong"><strong><code class="literal">normal</code></strong></span></div><p>The <code class="literal">normal</code> optimization is the default. If you don’t specify an optimization, the standard timeouts are used.</p></blockquote></div><div class="blockquote" title="conservative"><blockquote class="blockquote" title="conservative"><div class="blockquote-title"><span class="strong"><strong><code class="literal">conservative</code></strong></span></div><p>The <code class="literal">conservative</code> optimization is for environments where you want to be absolutely sure you don’t time out connections. (State table entries will stick around longer.) This setting uses more memory and processor time—possibly much more on a busy network. I use it to ease the minds of managers of industrial networks who are less concerned about buying more hardware and more concerned about the possibility of a meeting caused by some executive’s idle connection timing out.</p></blockquote></div><div class="blockquote" title="high-latency"><blockquote class="blockquote" title="high-latency"><div class="blockquote-title"><span class="strong"><strong><code class="literal">high-latency</code></strong></span></div><p><a class="indexterm" id="idx0039"/><a class="indexterm" id="idx0966"/><a class="indexterm" id="idx1071"/><a class="indexterm" id="idx1775"/><a class="indexterm" id="idx2101"/>If you connect over a satellite uplink or carrier pigeon, use the <code class="literal">high-latency</code> optimization.</p></blockquote></div><div class="blockquote" title="aggressive"><blockquote class="blockquote" title="aggressive"><div class="blockquote-title"><span class="strong"><strong><code class="literal">aggressive</code></strong></span></div><p>If you have a busy firewall, with many connections coming and going, you might try the <code class="literal">aggressive</code> optimization. This times out idle connections more quickly, reducing memory and processor use. Many people report that <code class="literal">aggressive</code> timeouts work perfectly well in their environments, but if low timeouts cause trouble for you, turn them off.</p></blockquote></div><p>Configure any of these by using <code class="literal">set optimization</code> and the optimization name.</p><a id="I_programlisting21_id501112"/><pre class="programlisting">set optimization conservative</pre></div><div class="sect2" title="The set skip Option"><div class="titlepage"><div><div><h3 class="title" id="the_set_skip_option">The set skip Option</h3></div></div></div><p>You can tell PF to not manage an interface. By default, it watches all interfaces, but some interfaces don’t really require filtering. Your loopback interface, <code class="literal">lo0</code>, passes traffic only from the local machine to itself. Packet filtering on <code class="literal">lo0</code> is an interesting educational exercise, but not terribly useful in production.</p><a id="I_programlisting21_id501138"/><pre class="programlisting">set skip on lo0</pre><p>You can also specify multiple interfaces to skip.</p><a id="I_programlisting21_id501146"/><pre class="programlisting">set skip on {lo0 fxp0 fxp1}</pre><p>It’s fairly common to skip filtering on the physical interfaces beneath a trunk in favor of filtering on the trunk itself.</p><p>This will get you started with packet filtering. If you have a single server with simple functions, you can protect it quite nicely using the techniques covered in this chapter. But PF can do a lot more than what we’ve talked about here, such as control bandwidth and have applications dynamically change rules. In the next chapter, we’ll touch on a few of PF’s more advanced functions.</p></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id337427"><p><sup>[<a class="para" href="#id337427">45</a>] </sup>Sorry, cats and elephants, find your own place to live.</p></div><div class="footnote" epub:type="footnote" id="ftn.id337464"><p><sup>[<a class="para" href="#id337464">46</a>] </sup>Blatantly stolen from Henning Brauer. Thankfully, he’s so sick of this book by now, he won’t notice.</p></div><div class="footnote" epub:type="footnote" id="ftn.id467314"><p><sup>[<a class="para" href="#id467314">47</a>] </sup>Mind you, if PF included an option to insult the client when a packet is dropped, somewhat like sudo, I would need to change my recommendation. But that’s a fault in the underlying network protocol, not PF.</p></div></div></section></body></html>