- en: Chapter 4. STORAGE WITH XEN
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用XEN的存储
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages333191.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages333191.png.jpg)'
- en: Throughout this book, so far, we've talked about Xen mostly as an integrated
    whole, a complete virtualization *solution*, to use marketing's word. The reality
    is a bit more complex than that. Xen itself is only one component of a platform
    that aims to free users from having to work with real hardware. The Xen hypervisor
    virtualizes a processor (along with several other basic components, as outlined
    in [Chapter 2](ch02.html "Chapter 2. GETTING STARTED")), but it relies on several
    underlying technologies to provide seamless abstractions of the resources a computer
    needs. This distinction is clearest in the realm of storage, where Xen has to
    work closely with a virtualized storage layer to provide the capabilities we expect
    of a virtual machine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，到目前为止，我们主要将Xen视为一个整体，一个完整的虚拟化**解决方案**，用市场营销的话来说。实际上，情况要复杂得多。Xen本身只是旨在让用户摆脱与真实硬件打交道的一个平台的一部分。Xen虚拟机管理程序虚拟化了一个处理器（以及第2章中概述的几个其他基本组件），但它依赖于几种底层技术来提供计算机所需的资源无缝抽象。这种区别在存储领域最为明显，在那里Xen必须与虚拟化存储层紧密合作，以提供我们期望的虚拟机的功能。
- en: By that we mean that Xen, combined with appropriate storage mechanisms, provides
    near total hardware independence. The user can run the Xen machine anywhere, move
    the instance about almost at will, add storage freely, save the filesystem state
    cleanly, and remove it easily after it's done.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Xen结合适当的存储机制，几乎提供了完全的硬件独立性。用户可以在任何地方运行Xen机器，几乎可以随意移动实例，自由添加存储，干净地保存文件系统状态，并在完成后轻松删除。
- en: Sounds good? Let's get started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来不错？让我们开始吧。
- en: 'Storage: The Basics'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储：基础知识
- en: 'The first thing to know about storage—before we dive into configuration on
    the dom0 side—is how to communicate its existence to the domain. DomUs find their
    storage by examining the domU config file for a `disk=` line. Usually it''ll look
    something like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入dom0侧的配置之前，首先要知道的是如何将存储的存在通知给域。DomUs通过检查domU配置文件中的`disk=`行来找到它们的存储。通常它看起来像这样：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line defines two devices, which appear to the domU as `sda` and `sdb`.
    Both are physical,^([[26](#ftn.CHP-4-FNOTE-1)]) as indicated by the `phy:` prefix—other
    storage backends have their own prefixes, such as `file:` and `tap:` for file-backed
    devices. You can mix and match backing device types as you like—we used to provide
    a pair of `phy:` volumes and a file-backed read-only "rescue" image.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行定义了两个设备，它们在domU中表现为`sda`和`sdb`。两者都是物理的，如`phy:`前缀所示——其他存储后端有自己的前缀，例如`file:`和`tap:`用于文件支持的设备。您可以按需混合和匹配后端设备类型——我们曾经提供了一对`phy:`卷和一个文件支持的只读“救援”镜像。
- en: We call this a line, but it's really more of a stanza—you can put the strings
    on separate lines, indent them with tabs, and put spaces after the commas if you
    think that makes it more readable. In this case, we're using LVM, with a volume
    group named *cleopatra* and a pair of logical volumes called *menas* and *menas_swap*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为一行，但实际上它更像是一节——如果您认为这样更易读，可以将字符串放在单独的行上，用制表符缩进，并在逗号后留空格。在这种情况下，我们使用LVM，有一个名为*cleopatra*的卷组，以及两个名为*menas*和*menas_swap*的逻辑卷。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*By convention, we''ll tend to use the same name for a domain, its devices,
    and its config file. Thus, here, the logical volumes* menas *and* menas_swap *belong
    to the domain* menas, *which has the config file* /etc/xen/menas *and network
    interfaces with similar names. This helps to keep everything organized*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*按照惯例，我们倾向于使用与域、其设备和其配置文件相同的名称。因此，在这里，逻辑卷* menas *和* menas_swap *属于域* menas，*它具有配置文件*
    /etc/xen/menas *和具有类似名称的网络接口。这有助于保持一切井井有条*。'
- en: 'You can examine the storage attached to a domain by using the `xm block-list`
    command—for example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`xm block-list`命令来检查连接到域的存储——例如：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, armed with this knowledge, we can move on to creating backing storage in
    the dom0.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拥有了这些知识，我们可以继续在dom0中创建后备存储。
- en: '* * *'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[26](#CHP-4-FNOTE-1)]) As you may gather, a *physical* device is one that
    can be accessed via the block device semantics, rather than necessarily a discrete
    piece of hardware. The prefix instructs Xen to treat the device as a basic block
    device, rather than providing the extra translation required for a file-backed
    image.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#CHP-4-FNOTE-1)]) 如您所料，*物理* 设备是通过块设备语义访问的设备，而不是必然是一块独立的硬件。前缀指示 Xen 将设备视为基本块设备，而不是为基于文件的镜像提供额外的转换。
- en: Varying Types of Storage
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储类型的不同
- en: It should come as little surprise, this being the world of open source, that
    Xen supports many different storage options, each with its own strengths, weaknesses,
    and design philosophy. These options broadly fall into the categories of *file
    based* and *device based*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源的世界里，Xen 支持许多不同的存储选项，每个选项都有其自身的优点、缺点和设计理念。这些选项大致可以分为 *基于文件* 和 *基于设备* 的类别。
- en: Xen can use a *file* as a block device. This has the advantage of being simple,
    easy to move, mountable from the host OS with minimal effort, and easy to manage.
    It also used to be very slow, but this problem has mostly vanished with the advent
    of the blktap driver. The file-based block devices differ in the means by which
    Xen accesses them (basic loopback versus blktap) and the internal format (AIO,
    QCOW, etc.).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Xen 可以使用 *文件* 作为块设备。这有一个优点，就是简单、易于移动、易于从主机操作系统上挂载，并且易于管理。它曾经非常慢，但随着 blktap 驱动程序的出现，这个问题已经基本消失。基于文件的块设备在
    Xen 访问它们的方式（基本循环回环与 blktap）和内部格式（AIO、QCOW 等）上有所不同。
- en: Xen can also perform I/O to a *physical* device. This has the obvious drawback
    of being difficult to scale beyond your ability to add physical devices to the
    machine. The physical device, however, can be anything the kernel has a driver
    for, including hardware RAID, fibre channel, MD, network block devices, or LVM.
    Because Xen accesses these devices via DMA (direct memory access) between the
    device driver and the Xen instance, mapping I/O directly into the guest OS's memory
    region, a domU can access physical devices at near-native speeds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Xen 也可以对 *物理* 设备进行 I/O 操作。这显然有一个缺点，就是很难扩展到超出你能够添加物理设备到机器的能力。然而，物理设备可以是内核有驱动程序的任何东西，包括硬件
    RAID、光纤通道、MD、网络块设备或 LVM。因为 Xen 通过设备驱动程序和 Xen 实例之间的 DMA（直接内存访问）访问这些设备，直接将 I/O 映射到客户操作系统的内存区域，所以
    domU 可以以接近原生速度访问物理设备。
- en: No matter what, though, all storage backends look the same from within the Xen
    virtual domain. The hypervisor exports a Xen VBD (virtual block device) to the
    domU, which in turn presents the device to the guest OS with an administrator-defined
    mapping to traditional Unix device nodes. Usually this will be a device of the
    form `hdx` or `sdx`, although many distros now use `xvdx` for *xen virtual disk*.
    (The `hd` and `sd` devices generally work, as well.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论什么情况，所有存储后端在 Xen 虚拟域内部看起来都一样。虚拟机管理程序将 Xen VBD（虚拟块设备）导出到 domU，然后将其以管理员定义的映射方式呈现给客户操作系统，通常是
    `hdx` 或 `sdx` 形式的设备。虽然许多发行版现在使用 `xvdx` 作为 *xen 虚拟磁盘*。(`hd` 和 `sd` 设备通常也可以工作。)
- en: We recommend blktap (a specialized form of file backend) and LVM for storage
    backends. These both work, offer good manageability, can be resized and moved
    freely, and support some mechanism for the sort of things we expect of filesystems
    now that we Live In The Future. blktap is easy to set up and good for testing,
    while LVM is scalable and good for production.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐使用 blktap（一种特殊的文件后端）和 LVM 作为存储后端。这两个都工作良好，具有良好的可管理性，可以自由调整大小和移动，并支持一些我们现在期望的文件系统机制。blktap
    设置简单，适合测试，而 LVM 可扩展性好，适合生产。
- en: None of this is particularly Xen-specific. LVM is actually used (outside of
    Xen) by default for the root device on many distros, notably Red Hat, because
    of the management advantages that come with an abstracted storage layer. blktap
    is simply a Xen-specific mechanism for using a file as a block device, just like
    the traditional block loop driver. It's superior to the loop mechanism because
    it allows for vastly improved performance and more versatile filesystem formats,
    such as QCOW, but it's not fundamentally different from the administrator's perspective.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切并没有特别针对 Xen。实际上，LVM 在许多发行版（如 Red Hat）的根设备上默认使用（在 Xen 之外），因为抽象存储层带来的管理优势。blktap
    简单来说就是 Xen 特定的机制，用于将文件用作块设备，就像传统的块循环驱动程序一样。它比循环机制更优越，因为它允许大幅提高性能和更灵活的文件系统格式，如
    QCOW，但从管理员的角度来看，它并没有本质上的不同。
- en: Let's get to it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Basic Setup: Files'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本设置：文件
- en: For people who don't want the hassle and overhead of LVM, Xen supports fast
    and efficient file-backed block devices using the blktap driver and library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不想处理LVM的麻烦和开销的人来说，Xen通过blktap驱动和库支持快速高效的文件支持块设备。
- en: blktap (blk being the worn-down stub of "block" after being typed hundreds of
    times) includes a kernel driver and a userspace daemon. The kernel driver directly
    maps the blocks contained by the backing file, avoiding much of the indirection
    involved in mounting a file via loopback. It works with many file formats used
    for virtual block devices, including the basic "raw" image format obtainable by
    `dd` ing a block device.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: blktap（由于“block”这个词被输入了数百次，所以“blk”是磨损的占位符）包括一个内核驱动和一个用户空间守护进程。内核驱动直接映射由后端文件包含的块，避免了通过循环回环挂载文件时涉及的大部分间接操作。它支持许多用于虚拟块设备的文件格式，包括通过
    `dd` 命令从块设备获取的基本“raw”镜像格式。
- en: 'You can create a file using the `dd` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `dd` 命令创建一个文件：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Your version of dd might require slightly different syntax—for example, it
    might require you to specify the block size in bytes*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的dd版本可能需要稍微不同的语法——例如，它可能需要你指定字节的块大小*。'
- en: 'Now `dd` will chug away for a bit, copying zeroes to a file. Eventually it''ll
    finish:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `dd` 命令会持续一段时间，将零复制到文件中。最终它会完成：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Thus armed with a filesystem image, you can attach it using the tap driver,
    make a filesystem on it, and mount it as usual with the `mount` command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了文件系统镜像，你可以使用tap驱动程序将其附加，创建一个文件系统，并像通常一样使用 `mount` 命令挂载它。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we use the `xm(8)` command to attach the block device to domain 0\. In
    this case the `xm` command is followed by the block-attach subcommand, with the
    arguments `<domain id to attach the device to> <backend device> <frontend device>
    <mode>` and optionally `[backend domain id]`. To decompose our example, we are
    attaching *anthony.img* read/write using the tap:aio driver to */dev/xvda1* in
    domain 0 using domain 0 to mediate access (because we tend to avoid using non-dom0
    driver domains). When the file is attached as */dev/xvda1*, we can create a filesystem
    on it and mount it as with any block device.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `xm(8)` 命令将块设备附加到域0。在这种情况下，`xm` 命令后面跟着块附加子命令，带有参数 `<要附加设备的域ID> <后端设备>
    <前端设备> <模式>` 以及可选的 `[后端域ID]`。为了分解我们的示例，我们将使用 tap:aio 驱动将 *anthony.img* 以读写方式附加到域0中的
    */dev/xvda1*，使用域0来调解访问（因为我们倾向于避免使用非dom0驱动程序域）。当文件作为 */dev/xvda1* 附加时，我们可以在它上面创建一个文件系统，就像任何块设备一样挂载它。
- en: 'Now that it''s mounted, you can put something in it. (See [Chapter 3](ch03.html
    "Chapter 3. PROVISIONING DOMUS") for details.) In this case, we''ll just copy
    over a filesystem tree that we happen to have lying around:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它已经挂载，你可以在里面放些东西。（有关详细信息，请参阅[第3章](ch03.html "第3章。为DOMUS提供配置"））。在这种情况下，我们只是复制一个我们恰好有的文件系统树：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a `disk=` line to the domU config (in our example, */etc/xen/anthony*)
    to reflect the filesystem:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在domU配置文件（在我们的示例中为 */etc/xen/anthony*）中添加一个 `disk=` 行，以反映文件系统：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you should be able to start the domain with its new root device:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够使用新的根设备启动域：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Watch the console and bask in its soothing glow.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 观察控制台，享受它那令人舒缓的光芒。
- en: MOUNTING PARTITIONS WITHIN A FILE-BACKED VBD
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件支持的VBD内挂载分区
- en: There's nothing that keeps you from partitioning a virtual block device as if
    it were a hard drive. However, if something goes wrong and you need to mount the
    subpartitions from within dom0, it can be harder to recover. The standard mount
    `-o loop filename /mnt` won't work, and neither will something like `mount /dev/xvda1
    /mnt` (even if the device is attached as `/dev/xvda`, Xen will not automatically
    scan for a partition table and create appropriate devices).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能阻止你将虚拟块设备分区，就像对待硬盘一样。然而，如果出了问题，你需要从dom0内部挂载子分区，恢复可能会更困难。标准的挂载命令 `-o loop
    filename /mnt` 不会起作用，类似 `mount /dev/xvda1 /mnt` 的命令也不会（即使设备已连接为 `/dev/xvda`，Xen
    也不会自动扫描分区表并创建适当的设备）。
- en: '`kpartx` will solve this problem. It reads the partition table of a block device
    and adds mappings for the device mapper, which then provides device file-style
    interfaces to the partitions. After that, you can mount them as usual.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`kpartx` 将解决这个问题。它读取块设备的分区表，并为设备映射器添加映射，然后它提供设备文件样式接口到分区。之后，你可以像通常一样挂载它们。'
- en: 'Let''s say you''ve got an image with a partition table that describes two partitions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含描述两个分区的分区表的镜像：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`kpartx` will then find the two partitions and create */dev/mapper/xvda1* and
    */dev/mapper/xvda2*. Now you should be able to mount and use the newly created
    device nodes as usual.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'LVM: Device-Independent Physical Devices'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flat files are well and good, but they're not as robust as simply providing
    each domain with its own physical volume (or volumes). The best way to use Xen's
    physical device support is, in our opinion, LVM.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: LVM, short for *logical volume management*, is Linux's answer to VxFS's storage
    pools or Windows Dynamic Disks. It is what the marketing people call *enterprise
    grade*. In keeping with the software mantra that "all problems can be solved by
    adding another layer of abstraction," LVM aims to abstract away the idea of "disks"
    to improve manageability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Instead, LVM (as one might guess from the name) operates on logical volumes.
    This higher-level view allows the administrator much more flexibility—storage
    can be moved around and reallocated with near impunity. Even better, from Xen's
    perspective, there's no difference between an LVM logical volume and a traditional
    partition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Sure, setting up LVM is a bit more work up front, but it'll save you some headaches
    down the road when you have eight domUs on that box and you are trying to erase
    the partition for the third one. Using LVM and naming the logical volume to correspond
    to the domU name makes it quite a bit harder to embarrass yourself by erasing
    the wrong partition.^([[27](#ftn.CHP-4-FNOTE-2)])
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: QCOW
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we've talked exclusively about the "raw" file format—but it's
    not the only option. One possible replacement is the QCOW format used by the QEMU
    project. It's got a lot to recommend it—a fast, robust format that supports sparse
    allocation, encryption, compression, and copy-on-write. We like it, but support
    isn't quite mature yet, so we're not recommending it as your primary storage option.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, it might be fun to try. To start working with QCOW, it'll be convenient
    to have QEMU. (While Xen includes some of the QEMU tools, the full package includes
    more functionality.) Download it from [http://www.nongnu.org/qemu/download.html](http://www.nongnu.org/qemu/download.html).
    As usual, we recommend the source install, especially because the QEMU folks eschew
    standard package management for their binary distribution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Install QEMU via the standard process:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: QEMU includes the `qemu-img` utility, which is used to create and manipulate
    the various sorts of image files that QEMU supports, including QCOW, vmdk, raw,
    and others.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command creates an image in QCOW format (`-f qcow`) with a size of 1,024MB.
    Of course, you'll want to replace the filename and size with appropriate values
    for your application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also convert a raw image to a QCOW image with the `img2qcow` utility,
    which is included as part of the Xen distribution:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can use the QCOW image directly as a domain''s root disk with the tap driver.
    Configure the guest domain to use the QCOW image as its root filesystem. In the
    domain''s config file under */etc/xen*, add a `disk=` line similar to:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接使用QCOW镜像作为具有tap驱动器的域的根磁盘。配置客户域使用QCOW镜像作为其根文件系统。在*/etc/xen*下的域配置文件中添加一个类似于的`disk=`行：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can extend this line with another disk, thus:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用另一个磁盘扩展这一行，如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Basic Setup: LVM'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本设置：LVM
- en: The high-level unit that LVM operates on is the *volume group*, or *VG*. Each
    group maps *physical extents* (disk regions of configurable size) to *logical
    extents*. The physical extents are hosted on what LVM refers to as *physical volumes*,
    or *PVs*. Each VG can contain one or more of these, and the PVs themselves can
    be any sort of block device supported by the kernel. The logical extents, reasonably
    enough, are on *logical volumes*, abbreviated *LVs*. These are the devices that
    LVM actually presents to the system as usable block devices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: LVM操作的高级单元是*卷组*或*VG*。每个组将*物理扩展*（可配置大小的磁盘区域）映射到*逻辑扩展*。物理扩展托管在LVM所说的*物理卷*或*PV*上。每个VG可以包含一个或多个这样的物理卷，而物理卷本身可以是内核支持的任何类型的块设备。合理地讲，逻辑扩展位于*逻辑卷*上，简称*LV*。这些是LVM实际向系统呈现为可用块设备的设备。
- en: As we're fond of saying, there really is no substitute for experience. Here's
    a five-minute illustrated tutorial in setting up logical volumes (see [Figure 4-1](ch04s03.html#this_diagram_shows_a_single_vg_with_two_
    "Figure 4-1. This diagram shows a single VG with two PVs. From this VG, we've
    carved out three logical volumes, lv1, lv2, and lv3\. lv1 and lv3 are being used
    by domUs, one of which treats the entire volume as a single partition and one
    of which breaks the LV into subpartitions for / and /var.")).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们常说的那样，经验确实无可替代。这里有一个五分钟的图文教程，介绍如何设置逻辑卷（见[图4-1](ch04s03.html#this_diagram_shows_a_single_vg_with_two_
    "图4-1. 此图显示了一个包含两个PV的单个VG。从这个VG中，我们划分出了三个逻辑卷，lv1、lv2和lv3。lv1和lv3被domUs使用，其中一个将整个卷视为单个分区，另一个将LV划分为用于/和/var的子分区。")）。
- en: '![This diagram shows a single VG with two PVs. From this VG, we''ve carved
    out three logical volumes, lv1, lv2, and lv3\. lv1 and lv3 are being used by domUs,
    one of which treats the entire volume as a single partition and one of which breaks
    the LV into subpartitions for / and /var.](httpatomoreillycomsourcenostarchimages333209.png.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![此图显示了一个包含两个PV的单个VG。从这个VG中，我们划分出了三个逻辑卷，lv1、lv2和lv3。lv1和lv3被domUs使用，其中一个将整个卷视为单个分区，另一个将LV划分为用于/和/var的子分区。](httpatomoreillycomsourcenostarchimages333209.png.jpg)'
- en: Figure 4-1. This diagram shows a single VG with two PVs. From this VG, we've
    carved out three logical volumes, lv1, lv2, and lv3\. lv1 and lv3 are being used
    by domUs, one of which treats the entire volume as a single partition and one
    of which breaks the LV into subpartitions for / and /var.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 此图显示了一个包含两个PV的单个VG。从这个VG中，我们划分出了三个逻辑卷，lv1、lv2和lv3。lv1和lv3被domUs使用，其中一个将整个卷视为单个分区，另一个将LV划分为用于/和/var的子分区。
- en: Begin with some hard drives. In this example, we'll use two SATA disks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些硬盘开始。在这个例子中，我们将使用两个SATA硬盘。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Given that Xen is basically a server technology, it would probably be most
    sensible to use RAID-backed redundant storage, rather than actual hard drives.
    They could also be partitions on drives, network block devices, UFS-formatted
    optical media … whatever sort of block device you care to mention. We''re going
    to give instructions using a partition on two hard drives, however. These instructions
    will also hold if you''re just using one drive*.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*鉴于Xen基本上是一种服务器技术，可能最明智的做法是使用RAID支持的冗余存储，而不是实际的硬盘驱动器。它们也可以是硬盘上的分区、网络块设备、UFS格式的光盘媒体……无论您想提及的任何类型的块设备。不过，我们将使用两个硬盘上的分区来提供指令。如果您只使用一个硬盘，这些指令同样适用*。'
- en: Warning
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*Note that we are going to repartition and format these drives, which will
    destroy all data on them*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我们将重新分区和格式化这些驱动器，这将破坏它们上的所有数据*。'
- en: First, we partition the drives and set the type to *Linux LVM*. Although this
    isn't strictly necessary—you can use the entire drive as a PV, if desired—it's
    generally considered good Unix hygiene. Besides, you'll need to partition if you
    want to use only a portion of the disk for LVM, which is a fairly common scenario.
    (For example, if you want to boot from one of the physical disks that you're using
    with LVM, you will need a separate */boot* partition.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们分区驱动器并将类型设置为 *Linux LVM*。尽管这不是严格必要的——如果您愿意，可以使用整个驱动器作为 PV——但通常被认为是良好的 Unix
    卫生习惯。此外，如果您只想将磁盘的一部分用于 LVM，您将需要分区，这是一个相当常见的场景。（例如，如果您想从您用于 LVM 的物理磁盘之一启动，您将需要一个单独的
    */boot* 分区。）
- en: So, in this example, we have two disks, sda and sdb. We want the first 4GB of
    each drive to be used as LVM physical volumes, so we'll partition them with `fdisk`
    and set the type to 8e (Linux LVM).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，我们有两个磁盘，sda 和 sdb。我们希望每个驱动器的第一个 4GB 被用作 LVM 物理卷，所以我们将使用 `fdisk` 对它们进行分区，并将类型设置为
    8e（Linux LVM）。
- en: If any partitions on the disk are in use, you will need to reboot to get the
    kernel to reread the partition table. (We think this is ridiculous, by the way.
    Isn't this supposed to be the future?)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果磁盘上的任何分区正在使用中，您将需要重新启动以使内核重新读取分区表。（顺便说一句，我们认为这是荒谬的。这不是应该属于未来吗？）
- en: Next, make sure that you've got LVM and that it's LVM2, because LVM1 is deprecated.^([[28](#ftn.CHP-4-FNOTE-3)])
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保您有 LVM，并且它是 LVM2，因为 LVM1 已被弃用。[28](#ftn.CHP-4-FNOTE-3)
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You might need to load the driver. If `vgscan` complains that the driver is
    missing, run:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要加载驱动程序。如果 `vgscan` 抱怨驱动程序缺失，请运行：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, `dm` stands for *device mapper*, which is a low-level volume manager
    that functions as the backend for LVM.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`dm` 代表 *device mapper*，它是一个低级卷管理器，作为 LVM 的后端。
- en: Having established that all three of these components are working, create physical
    volumes as illustrated in [Figure 4-2](ch04s03.html#this_diagram_shows_a_single_block_device
    "Figure 4-2. This diagram shows a single block device after pvcreate has been
    run on it. It's mostly empty, except for a small identifier on the front.").
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认这三个组件都正常工作后，根据 [图 4-2](ch04s03.html#this_diagram_shows_a_single_block_device
    "图 4-2。此图显示了在它上面运行了 `pvcreate` 的单个块设备。它大部分是空的，除了前面有一个小的标识符。") 中的说明创建物理卷。
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![This diagram shows a single block device after pvcreate has been run on it.
    It''s mostly empty, except for a small identifier on the front.](httpatomoreillycomsourcenostarchimages333211.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![此图显示了在它上面运行了 `pvcreate` 的单个块设备。它大部分是空的，除了前面有一个小的标识符。](httpatomoreillycomsourcenostarchimages333211.png.jpg)'
- en: Figure 4-2. This diagram shows a single block device after pvcreate has been
    run on it. It's mostly empty, except for a small identifier on the front.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2。此图显示了在它上面运行了 `pvcreate` 的单个块设备。它大部分是空的，除了前面有一个小的标识符。
- en: 'Bring these components together into a volume group by running `vgcreate`.
    Here we''ll create a volume group named *cleopatra* on the devices sda1 and sdb1:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `vgcreate` 将这些组件组合成一个卷组。在这里，我们将在设备 sda1 和 sdb1 上创建一个名为 *cleopatra* 的卷组：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, make volumes from the volume group using `lvcreate`, as shown in [Figure 4-3](ch04s03.html#lvcreate_creates_a_logical_volume_devvgl
    "Figure 4-3. lvcreate creates a logical volume, /dev/vg/lvol, by chopping some
    space out of the LV, which is transparently mapped to possibly discontinuous physical
    extents on PVs."). Think of it as a more powerful and versatile form of partitioning.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `lvcreate` 从卷组创建卷，如图 4-3 所示。[图 4-3](ch04s03.html#lvcreate_creates_a_logical_volume_devvgl
    "图 4-3。`lvcreate` 创建了一个逻辑卷，/dev/vg/lvol，通过从 LV 中切割一些空间，这些空间透明地映射到 PV 上的可能不连续的物理扩展区。")。将其视为一种更强大、更通用的分区形式。
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we've created a mirrored logical volume that keeps its logs in core (rather
    than on a separate physical device). Note that this step takes a group name rather
    than a device node. Also, the mirror is purely for illustrative purposes—it's
    not required if you're using some sort of redundant device, such as hardware RAID
    or MD. Finally, it's an administrative convenience to give LVs human-readable
    names using the `-n` option. It's not required but quite recommended.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个镜像逻辑卷，其日志保存在核心（而不是在单独的物理设备上）。请注意，这一步需要一个组名而不是设备节点。此外，镜像纯粹是为了说明目的——如果你使用某种冗余设备，如硬件
    RAID 或 MD，则不是必需的。最后，使用 `-n` 选项给 LVs 赋予人类可读的名称是一种管理上的便利。这不是必需的，但非常推荐。
- en: '![lvcreate creates a logical volume, /dev/vg/lvol, by chopping some space out
    of the LV, which is transparently mapped to possibly discontinuous physical extents
    on PVs.](httpatomoreillycomsourcenostarchimages333213.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![lvcreate 创建一个逻辑卷，/dev/vg/lvol，通过从 LV 中切割一些空间，这些空间透明地映射到 PV 上的可能不连续的物理扩展。](httpatomoreillycomsourcenostarchimages333213.png)'
- en: Figure 4-3. lvcreate creates a logical volume, /dev/vg/lvol, by chopping some
    space out of the LV, which is transparently mapped to possibly discontinuous physical
    extents on PVs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3。lvcreate 通过从 LV 中切割一些空间来创建一个逻辑卷，/dev/vg/lvol，这些空间透明地映射到 PV 上的可能不连续的物理扩展。
- en: 'Create a filesystem using your favorite filesystem-creation tool:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的文件系统创建工具创建一个文件系统：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, the LV is ready to mount and access, just as if it were a normal
    disk.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，LV 已经准备好挂载和访问，就像它是一个普通磁盘一样。
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To make the new device a suitable root for a Xen domain, copy a filesystem into
    it. We used one from [http://stacklet.com/](http://stacklet.com/)—we just mounted
    their root filesystem and copied it over to our new volume.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使新设备成为 Xen 域的合适根目录，将文件系统复制到其中。我们使用了一个来自 [http://stacklet.com/](http://stacklet.com/)
    的文件系统——我们只是挂载了他们的根文件系统并将其复制到我们新的卷中。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, to use it with Xen, we can specify the logical volume to the guest
    domain just as we would any physical device. (Note that here we're back to the
    same example we started the chapter with.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了与 Xen 一起使用，我们可以将逻辑卷指定给客户域，就像我们指定任何物理设备一样。（注意，在这里我们回到了本章开始时的同一个示例。）
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At this point, start the machine. Cross your fingers, wave a dead chicken, perform
    the accustomed ritual. In this case our deity is propitiated by an `xm create`.
    Standards have come down in the past few millennia.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，开始启动机器。交叉手指，挥舞一只死鸡，进行习惯的仪式。在这种情况下，我们的神通过 `xm create` 来平息。在过去几千年中，标准已经降低。
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '* * *'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[27](#CHP-4-FNOTE-2)]) This example is not purely academic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#CHP-4-FNOTE-2)]) 此示例并非纯粹学术。
- en: ^([[28](#CHP-4-FNOTE-3)]) This is unlikely to be a problem unless you are using
    Slackware.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#CHP-4-FNOTE-3)]) 除非您使用 Slackware，否则这不太可能成为问题。
- en: Enlarge Your Disk
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩大磁盘
- en: Both file-backed images and LVM disks can be expanded transparently from the
    dom0\. We're going to assume that disk space is so plentiful that you will never
    need to shrink an image.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统图像和 LVM 磁盘都可以从 dom0 中透明地扩展。我们假设磁盘空间非常充足，您永远不会需要缩小图像。
- en: Be sure to stop the domain before attempting to resize its underlying filesystem.
    For one thing, all of the user-space resize tools that we know of won't attempt
    to resize a mounted filesystem. For another, the Xen hypervisor won't pass along
    changes to the underlying block device's size without restarting the domain. Most
    important, even if you were able to resize the backing store with the domain running,
    data corruption would almost certainly result.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试调整其底层文件系统大小之前，请确保停止域。一方面，我们知道的所有的用户空间调整工具都不会尝试调整挂载的文件系统的大小。另一方面，Xen 虚拟机管理程序不会在没有重启域的情况下将更改传递给底层块设备的大小。最重要的是，即使您能够在域运行时调整后端存储，数据损坏几乎肯定会发生。
- en: File-Backed Images
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统图像
- en: 'The principle behind augmenting file-backed images is simple: We append more
    bits to the file, then expand the filesystem.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 增强文件系统图像背后的原理很简单：我们在文件中追加更多位，然后扩展文件系统。
- en: First, make sure that nothing is using the file. Stop any domUs that have it
    mounted. Detach it from the dom0\. Failure to do this will likely result in filesystem
    corruption.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保没有任何东西在使用该文件。停止任何挂载了该文件的 domUs。将其从 dom0 中分离。不这样做可能会导致文件系统损坏。
- en: Next, use `dd` to add some bits to the end. In this case we're directing 1GB
    from our */dev/zero* bit hose to *anthony.img*. (Note that not specifying an output
    file causes `dd` to write to stdout.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `dd` 在末尾添加一些位。在这种情况下，我们将 1GB 从我们的 */dev/zero* 位管路中引导到 *anthony.img*。
    （注意，如果不指定输出文件，`dd` 将写入 stdout。）
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Use `resize2fs` to extend the filesystem (or the equivalent tool for your choice
    of filesystem).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `resize2fs` 来扩展文件系统（或您选择的文件系统的等效工具）。
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`resize2fs` will default to making the filesystem the size of the underlying
    device if there''s no partition table.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有分区表，`resize2fs` 将默认将文件系统的大小设置为底层设备的大小。
- en: If the image contains partitions, you'll need to rearrange those before resizing
    the filesystem. Use `fdisk` to delete the partition that you wish to resize and
    recreate it, making sure that the starting cylinder remains the same.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像包含分区，您需要在调整文件系统大小之前重新排列这些分区。使用 `fdisk` 删除您希望调整大小的分区，并重新创建它，确保起始柱面保持不变。
- en: LVM
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LVM
- en: It's just as easy, or perhaps even easier, to use LVM to expand storage. LVM
    was designed from the beginning to increase the flexibility of storage devices,
    so it includes an easy mechanism to extend a volume (as well as shrink and move).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LVM扩展存储同样简单，或许甚至更简单。LVM从一开始就是为了提高存储设备的灵活性而设计的，因此它包括一个简单的机制来扩展卷（以及缩小和移动）。
- en: 'If there''s free space in the volume group, simply issue the command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卷组中有空闲空间，只需简单地发出以下命令：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the volume group is full, you''ll need to expand it. Just add a disk to
    the machine and extend the vg:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卷组已满，你需要扩展它。只需向机器添加一个磁盘并扩展vg：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, just as in the previous example, handle the filesystem-level expansion—we'll
    present this one using ReiserFS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像之前的例子一样，处理文件系统级别的扩展——我们将使用ReiserFS来展示这个过程。
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Copy-on-Write and Snapshots
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copy-on-Write和快照
- en: One of the other niceties that a real storage option gives you is copy-on-write,
    which means that, rather than the domU overwriting a file when it's changed, the
    backend instead transparently writes a copy elsewhere.^([[29](#ftn.CHP-4-FNOTE-4)])
    As a corollary, the original filesystem remains as a *snapshot*, with all modifications
    directed to the copy-on-write clone.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 真实存储选项为你提供的另一个优点是写时复制，这意味着当domU更改文件时，后端而不是覆盖文件，而是在其他地方透明地写入一个副本。[29](#ftn.CHP-4-FNOTE-4)]
    作为推论，原始文件系统仍然作为一个*快照*存在，所有修改都指向写时复制的克隆。
- en: 'This snapshot provides the ability to save a filesystem''s state, taking a
    snapshot of it at a given time or at set intervals. There are two useful things
    about snapshots: for one, they allow for easy recovery from user error.^([[30](#ftn.CHP-4-FNOTE-5)])
    For another, they give you a checkpoint that''s known to be consistent—it''s something
    that you can conveniently back up and move elsewhere. This eliminates the need
    to take servers offline for backups, such as we had to do in the dark ages.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快照提供了保存文件系统状态的能力，在给定时间或设定间隔内对其进行快照。关于快照有两个有用的方面：一方面，它们允许从用户错误中轻松恢复。[30](#ftn.CHP-4-FNOTE-5)]
    另一方面，它们提供了一个已知是一致的检查点——你可以方便地将其备份并移动到其他地方。这消除了需要关闭服务器进行备份的需求，就像我们在黑暗时代所做的那样。
- en: CoW likewise has a bunch of uses. Of these, the most fundamental implication
    for Xen is that it can dramatically reduce the on-disk overhead of each virtual
    machine—rather than using a simple file as a block device or a logical volume,
    many machines can share a single base filesystem image, only requiring disk space
    to write their changes to that filesystem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CoW同样有很多用途。其中，对Xen最基本的影响是它可以显著减少每个虚拟机在磁盘上的开销——而不是使用一个简单的文件作为块设备或逻辑卷，许多机器可以共享一个单独的基文件系统镜像，只需在文件系统中写入它们的更改即可。
- en: CoW also comes with its own disadvantages. First, there's a speed penalty. The
    CoW infrastructure slows disk access down quite a bit compared with writing directly
    to the device, for both reading and writing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: CoW也有自己的缺点。首先，存在速度惩罚。与直接写入设备相比，CoW基础设施会显著减慢磁盘访问速度，无论是读取还是写入。
- en: If you're using sparse allocation for CoW volumes, the speed penalty becomes
    greater due to the overhead of allocating and remapping blocks. This leads to
    fragmentation, which carries its own set of performance penalties. CoW can also
    lead to the administrative problem of oversubscription; by making it possible
    to oversubscribe disk space, it makes life much harder if you accidentally run
    out. You can avoid all of this by simply allocating space in advance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为CoW卷使用稀疏分配，由于分配和重新映射块的开销，速度惩罚会更大。这会导致碎片化，并带来自己的一套性能惩罚。CoW也可能导致过度订阅的管理问题；通过使过度订阅磁盘空间成为可能，如果你不小心用完，这会使生活变得更加困难。你可以通过预先分配空间来避免所有这些问题。
- en: There's also a trade-off in terms of administrative complexity, as with most
    interesting features. Ultimately, you, the Xen administrator, have to decide how
    much complexity is worth having.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数有趣的功能一样，在管理复杂性方面也存在权衡。最终，作为Xen管理员，你必须决定多少复杂性是值得拥有的。
- en: 'We''ll discuss device mapper snapshots, as used by LVM because they''re the
    implementation that we''re most familiar with. For shared storage, we''ll focus
    on NFS and go into more detail on shared storage systems in [Chapter 9](ch09.html
    "Chapter 9. XEN MIGRATION"). We also outline a CoW solution with UnionFS in [Chapter 7](ch07.html
    "Chapter 7. HOSTING UNTRUSTED USERS UNDER XEN: LESSONS FROM THE TRENCHES"). Finally,
    you might want to try QCOW block devices—although we haven''t had much luck with
    them, your mileage may vary.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论 LVM 所使用的设备映射器快照，因为我们最熟悉这种实现。对于共享存储，我们将关注 NFS，并在第 9 章（[第 9 章](ch09.html
    "第 9 章。XEN 迁移")）中更详细地介绍共享存储系统。我们还在第 7 章（[第 7 章](ch07.html "第 7 章。在 XEN 下托管不受信任的用户：来自战壕的经验教训")）中概述了一个使用
    UnionFS 的 CoW 解决方案。最后，你可能想尝试 QCOW 块设备——尽管我们在这方面没有太多运气，但你的体验可能会有所不同。
- en: '* * *'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[29](#CHP-4-FNOTE-4)]) This is traditionally abbreviated CoW, partly because
    it's shorter, but mostly because "cow" is an inherently funny word. Just ask Wikipedia.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#CHP-4-FNOTE-4)]) 这通常被缩写为 CoW，部分原因是因为它更短，但主要是因为 "cow" 这个词本身就很幽默。问问维基百科就知道了。
- en: ^([[30](#CHP-4-FNOTE-5)]) It's not as hard you might suppose to `rm` your home
    directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#CHP-4-FNOTE-5)]) 删除你的家目录并不像你想象的那么困难。
- en: LVM and Snapshots
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LVM 和快照
- en: LVM snapshots are designed more to *back up* and *checkpoint* a filesystem than
    as a means of long-term storage. It's important to keep LVM snapshots relatively
    fresh—or, in other words, make sure to drop them when your backup is done.^([[31](#ftn.CHP-4-FNOTE-6)])
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 快照设计得更多的是为了 *备份* 和 *检查点* 文件系统，而不是作为长期存储的手段。保持 LVM 快照相对较新很重要——换句话说，确保在备份完成后删除它们。[^([[31](#ftn.CHP-4-FNOTE-6))]]
- en: 'Snapshot volumes can also be used as read-write backing store for domains,
    especially in situations where you just want to generate a quick domU for testing,
    based on some preexisting disk image. The LVM documentation notes that you can
    create a basic image, snapshot it multiple times, and modify each snapshot slightly
    for another domain. In this case, LVM snapshots would act like a block-level UnionFS.
    However, note that when a snapshot fills up, it''s immediately dropped by the
    kernel. This may lead to data loss. The basic procedure for adding an LVM snapshot
    is simple: Make sure that you have some unused space in your volume group, and
    create a snapshot volume for it.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 快照卷也可以用作域的读写后端存储，尤其是在你只想基于某个现有的磁盘镜像快速生成一个用于测试的 domU 的情况下。LVM 文档指出，你可以创建一个基本镜像，多次快照它，并对每个快照进行轻微修改以用于另一个域。在这种情况下，LVM
    快照会像块级 UnionFS 一样工作。然而，请注意，当快照填满时，内核会立即丢弃它。这可能会导致数据丢失。添加 LVM 快照的基本步骤很简单：确保你的卷组中有一些未使用的空间，并为它创建一个快照卷。
- en: 'THE XEN L IVECD REVISITED: COPY-ON-WRITE IN ACTION'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Xen LiveCD 重新审视：COPY-ON-WRITE 实际操作
- en: The Xen LiveCD actually is a pretty nifty release. One of its neatest features
    is the ability to automatically create copy-on-write block devices when a Xen
    domain starts, based on read-only images on the CD.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Xen LiveCD 实际上是一个相当不错的发布。它最酷的功能之一是能够在 Xen 域启动时自动创建基于 CD 上只读镜像的 copy-on-write
    块设备。
- en: The implementation uses the device mapper to set up block devices and snapshots
    based on flat files, and is surprisingly simple.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实现使用设备映射器根据平面文件设置块设备和快照，并且出奇地简单。
- en: 'First, the basic storage is defined with a line like this in the domain config
    file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在域配置文件中，基本存储是通过这样一行定义的：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the use of the `cow:` prefix, which we haven't mentioned yet. This is actually
    a custom prefix rather than part of the normal Xen package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `cow:` 前缀，我们之前还没有提到过。这实际上是一个自定义前缀，而不是正常 Xen 软件包的一部分。
- en: 'We can add custom prefixes like cow: because */etc/xen/scripts/create_block_device*
    falls through to a script with a name of the form *block-[type]* if it finds an
    unknown device type—in this case, cow. The *block-cow* script expects one argument,
    either `create or destroy`, which the domain builder provides when it calls the
    script. *block-cow* then calls either the *create_cow or destroy_cow* script,
    as appropriate.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加自定义前缀，如 cow:，因为 */etc/xen/scripts/create_block_device* 如果遇到未知设备类型（在这种情况下是
    cow），会跳转到以 *block-[type]* 形式命名的脚本。*block-cow* 脚本期望一个参数，即 `create` 或 `destroy`，这是在调用脚本时域构建器提供的。*block-cow*
    然后根据需要调用 *create_cow* 或 *destroy_cow* 脚本。
- en: The real setup takes place in a script, */usr/sbin/create_cow*. This script
    essentially uses the device mapper to create a copy-on-write device based on an
    LVM snapshot,^([[32](#ftn.CHP-4-FNOTE-7)]) which it presents to the domain. We
    won't reproduce it here, but it's a good example of how standard Linux features
    can form the basis for complex, abstracted functions. In other words, a good hack.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的设置发生在脚本中，`/usr/sbin/create_cow`。此脚本本质上使用设备映射器根据LVM快照创建一个基于写时复制的设备，^([[32](#ftn.CHP-4-FNOTE-7)])
    并将其呈现给域。我们在此不重复它，但它是一个很好的例子，说明了标准Linux功能如何成为复杂、抽象功能的基础。换句话说，这是一个很好的技巧。
- en: First, check to see whether you have the driver `dm_snapshot`. Most modern distros
    ship with this driver built as a loadable module. (If it's not built, go to your
    Linux kernel source tree and compile it.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查您是否有`dm_snapshot`驱动程序。大多数现代发行版都将其作为可加载模块构建。如果未构建，请转到您的Linux内核源树并编译它。
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Manually load it if necessary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，手动加载它。
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Create the snapshot using the `lvcreate` command with the `-s` option to indicate
    "snapshot." The other parameters specify a length and name as in an ordinary logical
    volume. The final parameter specifies the *origin*, or volume being snapshotted.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`-s`选项的`lvcreate`命令创建快照，以指示“快照”。其他参数指定长度和名称，就像普通逻辑卷一样。最后一个参数指定*源*，或被快照的卷。
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This snapshot then appears to be a frozen image of the filesystem—writes will
    happen as normal on the original volume, but the snapshot will retain changed
    files as they were when the snapshot was taken, up to the maximum capacity of
    the snapshot.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此快照看起来像是文件系统的冻结图像——原始卷上的写入将按正常进行，但快照将保留在快照创建时更改的文件，直到达到快照的最大容量。
- en: When making a snapshot, the length indicates the maximum amount of changed data
    that the snapshot will be able to store. If the snapshot fills up, it'll be dropped
    automatically by the kernel driver and will become unusable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建快照时，长度表示快照能够存储的最大更改数据量。如果快照满了，内核驱动程序会自动将其丢弃，使其变得不可用。
- en: 'For a sample script that uses an LVM snapshot to back up a Xen instance, see
    [Chapter 7](ch07.html "Chapter 7. HOSTING UNTRUSTED USERS UNDER XEN: LESSONS FROM
    THE TRENCHES").'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用LVM快照备份Xen实例的示例脚本，请参阅[第7章](ch07.html "第7章。在XEN下托管不受信任的用户：来自战壕的经验教训")。
- en: '* * *'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[31](#CHP-4-FNOTE-6)]) Even if you add no data to the snapshot itself, it
    can run out of space (and corrupt itself) just keeping up with changes in the
    main LV.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#CHP-4-FNOTE-6)]) 即使您没有向快照本身添加任何数据，它也可能因为跟上主LV的变化而耗尽空间（并损坏自身）。
- en: ^([[32](#CHP-4-FNOTE-7)]) More properly, a device mapper snapshot, which LVM
    snapshots are based on. LVM snapshots are device mapper snapshots, but device
    mapper snapshots can be based on any pair of block devices, LVM or not. The LVM
    tools provide a convenient frontend to the arcane commands used by `dmsetup`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#CHP-4-FNOTE-7)]) 更确切地说，是一个设备映射器快照，LVM快照就是基于这个的。LVM快照是设备映射器快照，但设备映射器快照可以基于任何一对块设备，无论是LVM还是其他设备。LVM工具提供了一个方便的前端，用于`dmsetup`使用的晦涩命令。
- en: Storage and Migration
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储 和 迁移
- en: These two storage techniques—flat files and LVM—lend themselves well to easy
    and automated *cold migration*, in which the administrator halts the domain, copies
    the domain's config file and backing storage to another physical machine, and
    restarts the domain.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种存储技术——平面文件和LVM——非常适合于简单和自动化的*冷迁移*，在这种迁移中，管理员会停止域，将域的配置文件和备份存储复制到另一台物理机器上，然后重新启动域。
- en: Copying over a file-based backend is as simple as copying any file over the
    network. Just drop it onto the new box in its corresponding place in the filesystem,
    and start the machine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于文件的后端上复制就像在网络中复制任何文件一样简单。只需将其放入文件系统中的相应位置，然后启动机器。
- en: 'Copying an LVM is a bit more involved, but it is still straightforward: Make
    the target device, mount it, and move the files in whatever fashion you care to.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 复制LVM稍微复杂一些，但仍然简单明了：创建目标设备，挂载它，然后以您关心的任何方式移动文件。
- en: Check [Chapter 9](ch09.html "Chapter 9. XEN MIGRATION") for more details on
    this sort of migration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅[第9章](ch09.html "第9章。XEN迁移")以获取此类迁移的更多详细信息。
- en: Network Storage
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络存储
- en: 'These two storage methods only apply to locally accessible storage. Live migration,
    in which a domain is moved from one machine to another without being halted, requires
    one other piece of this puzzle: The filesystem must be accessible over the network
    to multiple machines. This is an area of active development, with several competing
    solutions. Here we''ll discuss NFS-based storage. We will address other solutions,
    including ATA over Ethernet and iSCSI, in [Chapter 9](ch09.html "Chapter 9. XEN
    MIGRATION").'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种存储方法仅适用于本地可访问的存储。实时迁移，即在不停机的情况下将域从一个机器移动到另一个机器，需要这个谜题的另一部分：文件系统必须通过网络对多台机器可访问。这是一个活跃的开发领域，有几种竞争性解决方案。在这里，我们将讨论基于NFS的存储。我们将在[第9章](ch09.html
    "第9章。XEN迁移")中讨论其他解决方案，包括以太网上的ATA和iSCSI。
- en: NFS
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NFS
- en: NFS is older than we are, and it is used by organizations of all sizes. It's
    easy to set up and relatively easy to administer. Most operating systems can interact
    with it. For these reasons, it's probably the easiest, cheapest, and fastest way
    to set up a live migration-capable Xen domain.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: NFS比我们还要古老，它被各种规模的组织所使用。它易于设置，相对容易管理。大多数操作系统都可以与之交互。因此，它可能是设置具有实时迁移功能的Xen域最简单、最便宜、最快的方式。
- en: 'The idea is to marshal Xen''s networking metaphor: The domains are connected
    (in the default setup) to a virtual network switch. Because the dom0 is also attached
    to this switch, it can act as an NFS server for the domUs.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是利用Xen的网络隐喻：域（在默认设置中）连接到一个虚拟网络交换机。因为dom0也连接到这个交换机，所以它可以作为domUs的NFS服务器。
- en: 'In this case we''re exporting a directory tree—neither a physical device nor
    a file. NFS server setup is quite simple, and it''s cross platform, so you can
    use any NFS device you like. (We prefer FreeBSD-based NFS servers, but NetApp
    and several other companies produce fine NFS appliances. As we might have mentioned,
    we''ve had poor luck using Linux as an NFS server.) Simply export your OS image.
    In our example, on the FreeBSD NFS server at 192.0.2.7, we have a full Slackware
    image at */usr/xen/images/slack*. Our */etc/exports* looks a bit like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们导出的是一个目录树——既不是物理设备也不是文件。NFS服务器设置相当简单，并且它是跨平台的，因此您可以使用您喜欢的任何NFS设备。（我们更喜欢基于FreeBSD的NFS服务器，但NetApp和其他几家公司也生产出色的NFS设备。正如我们可能提到的，我们使用Linux作为NFS服务器时运气不佳。）只需导出您的操作系统镜像。在我们的示例中，在192.0.2.7的FreeBSD
    NFS服务器上，我们有一个完整的Slackware镜像在`*/usr/xen/images/slack*`。我们的`*/etc/exports*`看起来有点像这样：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We leave further server-side setup to your doubtless extensive experience with
    NFS. One easy refinement would be to make / read-only and shared, then export
    read-write VM-specific */var* and */home* partitions—but in the simplest case,
    just export a full image.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务器端的进一步设置留给您无疑丰富的NFS经验。一个简单的改进是使`/`为只读和共享，然后导出只读的VM特定`*/var*`和`*/home*`分区——但在最简单的情况下，只需导出一个完整镜像。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Although NFS does imply a performance hit, it''s important to recall that
    Xen''s network buffers and disk buffers are provided by the same paravirtualized
    device infrastructure, and so the actual network hardware is not involved. There
    is increased overhead in transversing the networking stack, but performance is
    usually better than gigabit Ethernet, so it is not as bad as you might think*.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管NFS确实会带来性能损失，但重要的是要记住，Xen的网络缓冲区和磁盘缓冲区由相同的半虚拟化设备基础设施提供，因此实际的网络硬件并未参与。在穿越网络堆栈时会有增加的开销，但性能通常比千兆以太网要好，所以并没有您想象的那么糟糕*。'
- en: 'Now configure the client (`CONFIG_IP_PNP=y`). First, you''ll need to make some
    changes to the domU''s kernel to enable root on NFS:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置客户端（`CONFIG_IP_PNP=y`）。首先，您需要对domU的内核进行一些修改，以启用NFS上的root访问：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you want to do everything via DHCP (although you should probably still specify
    a MAC address in your domain config file), add DHCP support under that tree: `CONFIG_IP_PNP_DHCP`:
    or `CONFIG_IP_PNP_BOOTP` if you''re old school. If you are okay specifying the
    IP in your domU config file, skip that step.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想通过DHCP完成所有操作（尽管您可能仍然需要在您的域配置文件中指定MAC地址），在该树中添加DHCP支持：`CONFIG_IP_PNP_DHCP`：或者如果您是老派用户，可以使用`CONFIG_IP_PNP_BOOTP`。如果您可以在domU配置文件中指定IP，则可以跳过该步骤。
- en: 'Now you need to enable support for root on NFS. Make sure NFS support is Y
    and not M; that is, `CONFIG_NFS_FS=Y`. Next, enable root over NFS: `CONFIG_ROOT_NFS=Y`.
    In *menuconfig*, you can find that option under:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要启用NFS对root的支持。确保NFS支持设置为Y而不是M；即，`CONFIG_NFS_FS=Y`。接下来，启用通过NFS的root访问：`CONFIG_ROOT_NFS=Y`。在*menuconfig*中，您可以在以下位置找到该选项：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that *menuconfig* won't give you the option of selecting root over NFS
    until you select kernel-level IP autoconfiguration.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*menuconfig* 不会给你选择通过 NFS 选择根目录的选项，直到你选择了内核级别的 IP 自动配置。
- en: Build the kernel as normal and install it somewhere where Xen can load it. Most
    likely this isn't what you want for a dom0 kernel, so make sure to avoid overwriting
    the boot kernel.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按正常方式构建内核并将其安装到 Xen 可以加载的地方。很可能是你不想为 dom0 内核这样做，所以请确保不要覆盖启动内核。
- en: 'Now configure the domain that you''re going to boot over NFS. Edit the domain''s
    config file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置你将要通过 NFS 启动的域。编辑域的配置文件：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that we''re just adding extra Linux kernel configuration to the domain
    config—values not used by Xen will be passed to the kernel command line. You can
    also explicitly put this configuration in the "extra" parameter. If you want to
    set the IP address via DHCP, you can replace the last three lines above with:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是在域配置中添加了额外的 Linux 内核配置——Xen 未使用的值将被传递到内核命令行。你还可以明确地将此配置放在“extra”参数中。如果你想通过
    DHCP 设置 IP 地址，可以将上面的最后三行替换为：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can then use DHCP to specify the NFS server and NFS root as well in the
    usual manner. Boot the domain and you're done. Because the storage is accessible
    to any machine on the network, Xen's live migration should work as well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像往常一样使用 DHCP 来指定 NFS 服务器和 NFS 根。启动域并完成。因为存储对网络上的任何机器都是可访问的，所以 Xen 的实时迁移应该也能正常工作。
- en: Closing Suggestions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束建议
- en: This might seem like a bewildering, or even excessive, variety of storage options,
    but all of these have their places—be it in a hosting environment, or on the desktop,
    or in a storage pool for utility computing. The recommendations we've made in
    this chapter are a start, but in the end the best advice we can offer is to try
    all of these and see what works best. Find the right trade-off between ease of
    administration and scalability.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个令人困惑的，甚至过度的存储选项多样性，但所有这些都有其位置——无论是在托管环境中，还是在桌面上，还是在用于效用计算的存储池中。我们在本章中提出的建议是一个起点，但最终我们能给出的最好建议是尝试所有这些，看看哪种最适合。在管理便捷性和可扩展性之间找到合适的平衡。
- en: Finally, you can combine and extend many of these options. For example, the
    Xen LiveCD uses flat images with LVM snapshots. Depending on your application,
    the best solution might be simple filesystem images or a combination of software
    RAID and LVM. Keep experimenting and see what fits best. These are all examples
    of the flexibility of Xen's standards-based architecture, which relies on user-extensible
    scripts to define available storage using easily understood semantics. In [Chapter 5](ch05.html
    "Chapter 5. NETWORKING"), we'll look at how these same principles apply to Xen's
    network setup.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以结合和扩展这些选项中的许多。例如，Xen LiveCD 使用带有 LVM 快照的平面镜像。根据你的应用，最佳解决方案可能是简单的文件系统镜像或软件
    RAID 和 LVM 的组合。继续实验，看看哪种最适合。这些都是 Xen 基于标准的架构灵活性的例子，该架构依赖于用户可扩展的脚本来定义易于理解的语义来使用可用存储。在[第
    5 章](ch05.html "第 5 章。网络")中，我们将探讨这些相同的原则如何应用于 Xen 的网络设置。
