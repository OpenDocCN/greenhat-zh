<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page61"/><img src="../images/85-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter5"/><a href="toc.html#chapter5"><b>THE LADDIE ALARM SYSTEM: A SAMPLE APPLIANCE</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">Previous chapters covered how to build and secure a daemon and how to communicate with the daemon while it is running. We’ll tie these topics together in this chapter by building <i>Laddie,</i> a Linux-based alarm system.<sup>1</sup></p>&#13;
<p class="indent">Laddie uses the five status inputs on a standard PC parallel port as sensor inputs to the alarm system. The heart of the Laddie appliance is the <i>ladd</i> (pronounced <i>lad-dee)</i> daemon that polls the status lines and reports input transitions using syslog(). An alarm system is a good choice for a sample application since most readers will have some familiarity with alarm systems and because an alarm system application is simple to write, understand, and modify.</p>&#13;
<p class="indent">This chapter includes the following five sections:</p>&#13;
<ul>&#13;
<li>Introduction to alarm systems</li>&#13;
<li>A functional specification for Laddie</li>&#13;
<li><a id="page62"/>Laddie hardware design</li>&#13;
<li>Laddie software design</li>&#13;
<li>Building and testing Laddie</li>&#13;
</ul>&#13;
<p class="indent1">As you read this chapter, keep in mind that the alarm system itself is not as important as the techniques used to build it. Don’t let the implementation details overshadow the design principles being taught.</p>&#13;
<p class="secl"><a id="chapter5.1"/><a href="toc.html#chapter5.1"><b>Introduction to Alarm Systems</b></a></p>&#13;
<p class="noindent">This section presents the concepts and definitions used to describe alarm systems in general and Laddie in particular.</p>&#13;
<p class="secs"><a id="chapter5.2"/><a href="toc.html#chapter5.2"><i><b>Sensors</b></i></a></p>&#13;
<p class="noindent">An alarm <i>sensor</i> is a small device or switch that detects movement in a room or activity in an area. An <i>alarm system</i> monitors several alarm sensors and reports any unexpected activity they pick up. The area that a sensor protects is called a <i>zone.</i> Zones are given <i>names</i> that usually describe the area protected; typical zone names might include <i>Garage, Second Floor Windows,</i> and <i>Refrigerator.</i></p>&#13;
<p class="indent">Figure 5-1 shows an example arrangement of sensors and zones for a small business. There are door sensors on the front and back doors and a motion detector that looks for movement near the office and storeroom.</p>&#13;
<p class="imgc"><img src="../images/86-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 5-1: An example alarm system</i></p>&#13;
<p class="secls"><b>Types of Sensors</b></p>&#13;
<p class="noindent">Since an alarm system can only report what its sensors detect, it is important to choose sensors carefully. Let’s consider the types of sensors that are available.</p>&#13;
<p class="noindent1"><b>Magnetic reed switches</b></p>&#13;
<p class="bl">These are most often used to monitor doors; they are placed with the switch on the doorframe and the magnet on the door.</p>&#13;
<p class="noindent1"><a id="page63"/><b>PIR motion detectors</b></p>&#13;
<p class="bl"><i>Passive Infrared (PIR)</i> motion detectors detect minute changes in the movement of infrared (heat) sources. A person or animal can set off a PIR motion detector, but, for example, a baseball cannot.</p>&#13;
<p class="noindent1"><b>Acoustic sensors</b></p>&#13;
<p class="bl">Acoustic sensors detect specific sounds. They are often used to detect the sound of breaking glass, and are so sensitive that a single acoustic sensor can protect all of the windows in a room.</p>&#13;
<p class="noindent1"><b>Floor mat sensors</b></p>&#13;
<p class="bl">Floor mat sensors have switches that can detect the weight of a person. They are very thin and are usually placed under carpet at entryways.</p>&#13;
<p class="noindent1"><b>Vibration sensors</b></p>&#13;
<p class="bl">Vibration sensors can detect very slight physical motion. They are often used to protect cars.</p>&#13;
<p class="noindent1"><b>Smoke and carbon monoxide detectors</b></p>&#13;
<p class="bl">These sensors are used to detect potential fires.</p>&#13;
<p class="noindent1"><b>Temperature sensors</b></p>&#13;
<p class="bl">Thermostats and other temperature sensors trip at a certain temperature or simply report the current temperature in the zone. They are often used to protect temperature-sensitive equipment and supplies.</p>&#13;
<p class="secls"><b>Sensor Contact Type</b></p>&#13;
<p class="noindent">To the alarm system, most sensors look like switches. The switch contacts can be either open when not in alarm (called <i>normally open</i> or <i>NO</i> sensors), or closed when not in alarm (<i>normally closed</i> or <i>NC</i> sensors). When you install a sensor, you have to tell the alarm system the <i>contact type</i> of the sensor—that is, whether the contacts are normally open or normally closed. Most sensors are normally closed. A normally closed sensor has the desirable property of triggering an alarm if the wires to the sensor are cut.</p>&#13;
<p class="indent">Another helpful feature of the sensor-and-zone setup is that it is possible to cascade sensors within a zone, as long as the cascaded sensors are all of the same contact type. Figure 5-2 shows how to cascade normally open sensors and Figure 5-3 shows how to cascade normally closed sensors.</p>&#13;
<p class="imgc"><img src="../images/87-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 5-2: How to cascade normally open sensors</i></p>&#13;
<p class="imgc"><a id="page64"/><img src="../images/88-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 5-3: How to cascade normally closed sensors</i></p>&#13;
<p class="indent1">Logically, the alarm system sees just one sensor in each zone, even if there are actually several cascaded sensors there.</p>&#13;
<p class="secls"><b>Latching a Sensor</b></p>&#13;
<p class="noindent">Most sensors return to the non-alarm or normal state when the detected condition is removed—for example, when someone closes a door or steps off of a floor mat. You usually want to configure the alarm system to latch alarms detected by these sensors. <i>Latched</i> alarms remain in alarm, even if the detected condition is removed, until they are manually cleared by a user.</p>&#13;
<p class="indent">However, you might not want to latch every sensor. For example, you might want to automatically remove an alarm when the temperature in a thermostat-protected room returns to normal.</p>&#13;
<p class="indent">Think about the type of sensor you’re using and your specific needs when you set alarms in a zone to be latching or non-latching.</p>&#13;
<p class="secs"><a id="chapter5.3"/><a href="toc.html#chapter5.3"><i><b>Enabling a Zone</b></i></a></p>&#13;
<p class="noindent">Mark zones as <i>enabled</i> if the sensors in the zone are working and you want to monitor the zone. Unused inputs can be ignored by disabling the zone. Also, you may find it convenient to temporarily disable zones when you want to leave a door or window open.</p>&#13;
<p class="secl"><a id="chapter5.4"/><a href="toc.html#chapter5.4"><b>A Functional Specification for Laddie</b></a></p>&#13;
<p class="noindent">The Laddie alarm system monitors up to five zones and raises an alarm when a change occurs in one of the monitored zones. Alarms are reported to Laddie’s five different user interfaces. In addition to being able to view the status of the zones that Laddie monitors, the user interfaces allow you to test and clear alarms, view logs, and configure zones. Configuration parameters include the following:</p>&#13;
<ul>&#13;
<li>Zone name</li>&#13;
<li>Contact type</li>&#13;
<li>Latching or non-latching</li>&#13;
<li>Enabled or disabled</li>&#13;
</ul>&#13;
<p class="indent"><a id="page65"/>Laddie’s functional specification is divided into two parts: one that allows users to access alarm configuration and status and another that allows Laddie to handle alarms.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>As a reminder,</i> Laddie <i>refers to the whole appliance, and</i> ladd <i>refers just to the daemon that monitors the five input pins on the parallel port. It’s easy to confuse the two, since they are pronounced the same.</i></p>&#13;
<p class="secs"><a id="chapter5.5"/><a href="toc.html#chapter5.5"><i><b>ladd’s Configuration and Status</b></i></a></p>&#13;
<p class="noindent">ladd has one configuration and status table, called <i>Zone</i>, that is visible to all of the user interfaces as an RTA table. The Zone table has five rows, with each row defined by the following data structure:</p>&#13;
<p class="imgl"><img src="../images/89-1.jpg" alt=""/></p>&#13;
<p class="indent">Let’s consider each of these fields in turn.</p>&#13;
<p class="seca"><b>id (Configuration)</b></p>&#13;
<p class="bl">Zones are identified by a number between one and five. The id field is initialized when ladd starts, and users cannot edit it. You can use the id field in user interface programs to uniquely identify a particular zone.</p>&#13;
<p class="seca"><b>name (Configuration)</b></p>&#13;
<p class="bl">This field stores the brief mnemonic or name that the user assigns to the zone.</p>&#13;
<p class="seca"><b>enabled (Configuration)</b></p>&#13;
<p class="bl">Only zones marked <i>enabled</i> cause the system to enter an alarm state. Zones marked <i>disabled</i> do not generate log messages or cause alarm states. This field holds an integer instead of a boolean, since RTA does not support a boolean data type.</p>&#13;
<p class="seca"><b>edge (Configuration)</b></p>&#13;
<p class="bl">For the hardware described in the next section, a normally closed sensor triggers an alarm on a zero-to-one edge on the input pin. Normally open sensors on Laddie trigger an alarm on a one-to-zero edge. “Laddie’s Hardware Design” on page 68 describes open and closed sensors in more detail.</p>&#13;
<p class="seca"><a id="page66"/><b>latching (Configuration)</b></p>&#13;
<p class="bl">The user sets this field to 1 to have an alarm persist even after the sensor pin returns to its normal state. The user must manually clear latched alarms.</p>&#13;
<p class="seca"><b>input (Status)</b></p>&#13;
<p class="bl">This field shows the most recent raw value of the input pin. This is a status field, and the user is not able to edit it.</p>&#13;
<p class="seca"><b>alarm (Status)</b></p>&#13;
<p class="bl">Each zone is said to be in either an <i>alarm</i> condition or in a <i>safe</i> condition. This field is set by the ladd daemon in response to detected edges on the input pin. A write callback on this field lets a user test a zone by writing a 1 to it. An alarm is cleared when the user sets this field to 0.</p>&#13;
<p class="seca"><b>count (Status)</b></p>&#13;
<p class="bl">This field contains the number of input edges that have caused an alarm. This field is incremented only when the zone is marked <i>enabled</i>; it is not incremented by user-initiated tests of the zone. This is a readonly, statistic field that is set to zero when ladd starts.</p>&#13;
<p class="indent1">You may recall that the advantage of RTA is that it gives all of the user interfaces the same API for daemon configuration, status, and statistics. The API defined by RTA is that of a PostgreSQL database. The advantages of PostgreSQL are that SQL is widely used and understood and there are many bindings for PostgreSQL, including C, PHP, Java, and Perl. Figure 5-4 illustrates Laddie’s use of RTA to allow five different UIs to get status and set configuration using only one daemon-side protocol.</p>&#13;
<p class="imgc"><img src="../images/90-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 5-4: One daemon with many user interfaces</i></p>&#13;
<p class="indent1">Let’s look at the SQL for some typical Laddie configuration changes and queries.</p>&#13;
<p class="indent1"><a id="page67"/>To disable zone 2, type:</p>&#13;
<p class="ex">UPDATE Zone SET enabled = 0 WHERE id = 2</p>&#13;
<p class="indent">To find out how many times zone 4 has gone into alarm, type:</p>&#13;
<p class="ex">SELECT count FROM Zone WHERE id = 4</p>&#13;
<p class="indent">To clear all alarms in the system, type:</p>&#13;
<p class="ex">UPDATE Zone SET alarm = 0</p>&#13;
<p class="indent">Any program that can issue commands like these can function as a user interface for Laddie. Watch for commands like these later in the book as we go through the five user interfaces currently available for Laddie.</p>&#13;
<p class="secs"><a id="chapter5.6"/><a href="toc.html#chapter5.6"><i><b>ladd’s Alarm Handling</b></i></a></p>&#13;
<p class="noindent">ladd responds to an alarm by sending a log message using syslog(). The text of the log message depends on whether the alarm was detected by the hardware or was a test alarm issued by a user. The text also depends on whether the alarm was set or cleared. For a zone with ID <i>n</i> and the name <i>zone_name,</i> the four log messages are:</p>&#13;
<ul>&#13;
<li>Alarm set on zone <i>n, zone_name</i></li>&#13;
<li>Alarm cleared on zone <i>n, zone_name</i></li>&#13;
<li>User set alarm on zone <i>n, zone_name</i></li>&#13;
<li>User cleared alarm on zone <i>n, zone_name</i></li>&#13;
</ul>&#13;
<p class="indent">Some users do not care <i>which</i> zone is in alarm; they just want to know if <i>any</i> zone is in alarm. To address this need, ladd provides two other log messages:</p>&#13;
<ul>&#13;
<li>Alarm system status: alarm</li>&#13;
<li>Alarm system status: safe</li>&#13;
</ul>&#13;
<p class="indent">These messages are sent when the first zone goes into alarm and after the last zone is cleared. Laddie also sets all four control pins on the parallel port to 1 (see Table 5-1) to indicate any alarm in the system. It sets the control pins low when all alarms are cleared.</p>&#13;
<p class="indent">One nice aspect of our overall architecture for Laddie is that ladd itself does not need to send signals to the UI, send email, or send SNMP traps. We leave all of this to a separate process, greatly simplifying the design and implementation of the ladd daemon. (The event processor is described in the next chapter.) Syslog-as-output not only simplifies ladd, it makes debug and test easier too since we can easily examine the log files for the messages we expect and we can use the logger command to generate test events for the event processor. The data flow for an alarm response is depicted in Figure 5-5.</p>&#13;
<p class="imgc"><a id="page68"/><img src="../images/92-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 5-5: Processing alarm events in Laddie</i></p>&#13;
<p class="secl"><a id="chapter5.7"/><a href="toc.html#chapter5.7"><b>Laddie’s Hardware Design</b></a></p>&#13;
<p class="noindent">This section presents the hardware needed to use Laddie as a real alarm system. You can skip over this section if you are uncomfortable with electronic circuits or if you aren’t interested in seeing how the hardware works.</p>&#13;
<p class="indent">The pins on the parallel port are divided into three main groups: data lines, control lines, and status lines. Each group is controlled using a register, which is available at a particular I/O address. The data lines are at the base address of the parallel port, the status lines are at the base address plus one, and the control lines are at the base address plus two. Table 5-1 shows how the pins on a 25-pin parallel port connector relate to the printer port names, to the port registers, and to the alarm system.</p>&#13;
<p class="tcap"><b>Table 5-1:</b> Laddie’s Use of the PC Parallel Port</p>&#13;
<p class="imgc"><img src="../images/92-2.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page69"/>The alarm daemon uses the data lines as output and the status lines as input. Figure 5-6 shows a schematic for one alarm sensor. The daemon initializes the parallel port by setting the output pins to 0xFF, making pin 2 a high level. When the sensor S1 is open, no current flows through the 2K ohm resistor R1, and the voltage at pin 15 is pulled high. When the sensor is closed, pin 15 is shorted to ground through pin 21.</p>&#13;
<p class="indent">In other words, pin 15 is biased high when the alarm sensor is open and pulled low when the sensor is closed. By reading the status lines, which includes pin 15, the daemon can detect whether the sensor is open or closed. This description applies to all five of the status inputs on the parallel port.</p>&#13;
<p class="imgc"><img src="../images/93-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 5-6: A normally open alarm sensor from Laddie</i></p>&#13;
<p class="secl"><a id="chapter5.8"/><a href="toc.html#chapter5.8"><b>Laddie’s Software Design</b></a></p>&#13;
<p class="noindent">We used the empty daemon introduced in Chapter 4 to build the ladd daemon. But whether we used the empty daemon, wrote a select()-based program, or wrote a threads-based program, there would still be three main subroutines:</p>&#13;
<p class="bl1"><b><span class="bb">appInit()</span></b> Initialize hardware. Start timer. Register the Zone table with RTA.</p>&#13;
<p class="bl1"><b><span class="bb">poll_timeout()</span></b> Read the status lines. Log relevant changes.</p>&#13;
<p class="bl1"><b><span class="bb">user_update()</span></b> Send logs for user changes to the alarm status.</p>&#13;
<p class="indent1">These routines are described in more detail in the next few sections.</p>&#13;
<p class="secs"><a id="chapter5.9"/><a href="toc.html#chapter5.9"><i><b>The appInit() Callback Subroutine</b></i></a></p>&#13;
<p class="noindent"><a id="page70"/>The appInit() subroutine is the first callback subroutine the empty daemon invokes. This callback subroutine is responsible for performing any application-specific initialization, setting up any timer callback subroutines, and registering any RTA tables. In ladd, the appInit() subroutine initializes the Zone array of ZONE structures, calls rta_add_table() to register the Zone table with RTA, initializes the parallel port, and starts a periodic 100-millisecond timer with poll_timeout() as its callback subroutine. Note that once the appInit() subroutine returns, the daemon is ready to accept connections from the user interfaces.</p>&#13;
<p class="indent">Although the COLDEFs or TBLDEF for the Zone array are not shown, Table 5-2 should give you an idea of what they contain.</p>&#13;
<p class="tcap"><b>Table 5-2:</b> The Columns in Laddie’s Zone Table</p>&#13;
<p class="imgc"><img src="../images/94-1.jpg" alt=""/></p>&#13;
<p class="indent">All of the initialization code for ladd is in the appInit() routine given below.</p>&#13;
<p class="imgl"><img src="../images/94-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page71"/><img src="../images/95-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter5.10"/><a href="toc.html#chapter5.10"><i><b>The poll_timeout() Callback Subroutine</b></i></a></p>&#13;
<p class="noindent">The poll_timeout() subroutine performs the bulk of the alarm daemon’s functions. This subroutine reads the parallel port, processes the input pins, and modifies the state of the appropriate ZONE data structure. This subroutine is invoked every 100 milliseconds, as specified by the call to add_timer(). Note the following salient features of the poll_timeout() subroutine.</p>&#13;
<ul>&#13;
<li>The main responsibility of poll_timeout() is to set the alarm field for each zone in the Zone table. As mentioned above, the alarm field shows whether or not a particular zone is in an alarm condition.</li>&#13;
<li>The subroutine treats each zone independently of the other zones. That is, one zone can be in alarm condition while another is in the safe condition.</li>&#13;
<li>The alarm field for a particular zone is modified only if the enabled field is nonzero. This feature allows a user to disable a zone in cases where there is either no sensor or where the user wishes to ignore a sensor.</li>&#13;
<li>When poll_timeout() detects that the zone has entered the alarm condition, it sets the alarm field to 1 and sends a syslog message. In a later chapter, we’ll show you how to convert syslog messages into email and SNMP traps.</li>&#13;
<li>Similarly, when this subroutine detects that the input pin transitions back to the normal state, it clears the alarm variable, and, if the latching field is set to zero, it sends a syslog message. This mechanism allows the user to configure a zone so that once it enters the alarm condition, it must be cleared manually.</li>&#13;
<li>The poll_alarm() subroutine also maintains a global alarm variable, GlobalAlarm, which is set to one if any zone is in alarm condition and is set to zero if all zones are safe. The subroutine tracks when this GlobalAlarm variable changes states. When the GlobalAlarm variable is set, the control pins of the parallel port are set high. When the GlobalAlarm variable changes state, then an appropriate syslog message is sent.</li>&#13;
</ul>&#13;
<p class="indent"><a id="page72"/>All of the polling for new alarms is done in the poll_timeout() routine given below.</p>&#13;
<p class="imgl"><img src="../images/96-1.jpg" alt=""/></p>&#13;
<p class="imgl"><img src="../images/96-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page73"/><img src="../images/97-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter5.11"/><a href="toc.html#chapter5.11"><i><b>The user_update() Callback Subroutine</b></i></a></p>&#13;
<p class="noindent">The user_update() callback subroutine is invoked whenever the user manually modifies the alarm field in a ZONE data structure. This callback subroutine is responsible for sending a syslog message whenever the user manually clears the alarm condition (for latched zones) or manually sets the alarm condition. In Chapter 7, we’ll show you how to use the syslog message to update the user interfaces.</p>&#13;
<p class="indent">This callback subroutine is included in the RTA COLDEF structure for our alarm daemon. Take a look at the snippet of source code below, and you’ll see that the user_update subroutine is included in the write callback entry. The user_update subroutine is invoked whenever the user writes to the alarm variable in a ZONE data structure.</p>&#13;
<p class="imgl"><img src="../images/97-2.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page74"/>The user_update() subroutine shown below checks to see if a user has set the alarm variable and caused it to change. If the alarm variable has changed, the user_update() subroutine writes a syslog message.</p>&#13;
<p class="imgl"><img src="../images/98-1.jpg" alt=""/></p>&#13;
<p class="indent">In the last two sections, we showed you the alarm daemon source code and explained how the source code works. Did you notice how easy it was to implement the alarm daemon? The next section shows you how to build and test the alarm daemon.</p>&#13;
<p class="secl"><a id="chapter5.12"/><a href="toc.html#chapter5.12"><b>Building and Testing ladd</b></a></p>&#13;
<p class="noindent">You don’t need to install a whole set of alarm sensors to run this daemon—all you need is a standard PC with a parallel port. Before running the daemon, you must create the directory /opt/laddie/ladd/, because the alarm daemon creates a PID file in this directory. Use these commands to create this directory as root:</p>&#13;
<p class="ex">mkdir /opt/laddie/ladd</p>&#13;
<p class="indent">The source code for ladd is on the companion CD in /Code/src/ladd. Compile the alarm daemon and then run the daemon as root, as shown in the following commands:</p>&#13;
<p class="ex">cd /Code/src/ladd<br/>make<br/>su<br/>./ladd</p>&#13;
<p class="indent"><a id="page75"/>To make sure that the alarm daemon is running and responding to user requests, invoke the psql SQL command shown below, and verify that the Zone table is displayed.</p>&#13;
<p class="imgl"><img src="../images/99-1.jpg" alt=""/></p>&#13;
<p class="indent">Typically, you would add hardware sensors to your alarm appliance, but you can simulate an alarm without the hardware sensors.</p>&#13;
<p class="indent">Consider zone 1. Our approach is to invoke the alarm write callback using this command:</p>&#13;
<p class="ex">UPDATE Zone SET name = "BackDoor", enabled=1, edge=0, WHERE id=1;</p>&#13;
<p class="indent">Next, we’ll simulate an alarm on the input of zone 1 with the following command:</p>&#13;
<p class="ex">UPDATE Zone SET alarm=1 WHERE id=1;</p>&#13;
<p class="indent">Verify that ladd generated a log saying <i>User set alarm on zone 1.</i> Then manually clear the alarm, as such:</p>&#13;
<p class="ex">UPDATE Zone SET alarm=0 WHERE id=1;</p>&#13;
<p class="indent">Again verify that ladd generates a message for syslog. We’ll show you how to build more accessible user interfaces to the alarm daemon in future chapters.</p>&#13;
<p class="secl"><a id="chapter5.13"/><a href="toc.html#chapter5.13"><b>Summary</b></a></p>&#13;
<p class="noindent"><a id="page76"/>This chapter tied the previous chapters together by showing you how to build ladd, a simple alarm daemon, using RTA and the empty daemon. You saw the design of ladd’s RTA table, the control point by which the user interfaces manage the alarm daemon. You also saw the alarm daemon’s source code, including the three subroutines used by the empty daemon to implement the alarm daemon’s run-time behavior. Finally, you saw how to configure the alarm daemon and how to manually set and clear an alarm from the command line.</p>&#13;
<p class="indent">The next chapter continues to develop Laddie’s design by showing you how to handle events on an appliance, including events such as ladd sending messages to syslog.</p>&#13;
<p class="noindent1">__________________</p>&#13;
<p class="foot"><sup>1</sup> Laddie is a sample appliance used to illustrate the techniques and software presented in this book. Laddie is <i>not</i> a commercially viable alarm system and should never be used in place of a real alarm system.</p>&#13;
</div>&#13;
</body></html>