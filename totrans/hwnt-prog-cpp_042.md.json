["```\n        1.0 == 1.5      (1 + 1/2   or 1 + 1/21)    (1.1     binary)\n        1.0 == 1.25     (1 + 1/4   or 1 + 1/22)    (l.oi    binary)\n        1.0 == 1.125    (1 + 1/8   or 1 + 1/23)    (1.001   binary)\n        1.0 == 1.0625   (1 + 1/16  or 1 + 1/24)    (1.0001  binary)\n        1.0 == 1.03125  (1 + 1/32  or 1 + 1/25)    (1.00001 binary)\n\n```", "```\n  1 /************************************************\n  2  * accuracy test.                               *\n  3  *                                              *\n  4  * This program figures out how many bits       *\n  5  * accuracy you have on your system.  It does   *\n  6  * this by adding up checking the series:       *\n  7  *                                              *\n  8  *              1.0 == 1.1 (binary)             *\n  9  *              1.0 == 1.01 (binary)            *\n 10  *              1.0 == 1.001 (binary)           *\n 11  *              ....                            *\n 12  *                                              *\n 13  * Until the numbers are equal.   The result is *\n 14  * the number of bits that are stored in the    *\n 15  * fraction part of the floating point number.   *\n 16  ************************************************/\n 17 #include <iostream>\n 18\n 19 int main()\n 20 {\n 21     /* two numbers to work with */\n 22     float number1, number2;\n 23\n 24     /* loop counter and accuracy check */\n 25     int counter;\n 26\n 27     number1 = 1.0;\n 28     number2 = 1.0;\n 29     counter = 0;\n 30\n 31     while (number1 + number2 != number1) {\n 32         ++counter;      // One more bit accurate\n 33\n 34         // Turn numbers like 0.1 binary\n 35         // into 0.01 binary.\n 36         number2 = number2 / 2.0;\n 37     }\n 38     std::cout << counter << \" bits accuracy.\\n\";\n 39     return (0);\n 40 }\n\n```"]