<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;TROUBLESHOOTING"><div class="titlepage"><div><div><h1 class="title"><a id="troubleshooting"/>Chapter 15. TROUBLESHOOTING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e15698"/><img src="httpatomoreillycomsourcenostarchimages333191.png.jpg" alt="image with no caption"/></div></div><p>With any luck, you're just reading this chapter for fun, not because your server has just erupted in a tower of flame. Of course, sysadmins being almost comically lazy, it's most likely the latter, but the former is at least vaguely possible, right?</p><p>If the machine is in fact already broken, don't panic. Xen is complex, but the issues discussed here are fixable problems with known solutions. There's a vast arsenal of tools, a great deal of information to work with, and a lot of expertise available.</p><p>In this section, we'll outline a number of troubleshooting steps and techniques, with particular reference to Xen's peculiarities. We'll include explanations for some of the vague error messages that you might come across, and we'll make some suggestions about where to get help if all else fails.</p><p>Let's start with a general overview of our approach to troubleshooting, which will help to put the specific discussion of Xen-related problems in context.</p><p>The most important thing when troubleshooting is to get a clear idea of the machine's <a id="idx-CHP-15-1036" class="indexterm"/>state: what it's doing, what problems it's having, what telegraphic errors it's spitting out, and where the errors are coming from. This is doubly important in Xen because its modular, standards-based design brings together diverse and unrelated tools, each with its own methods of logging and error handling.</p><p>Our usual troubleshooting <a id="idx-CHP-15-1037" class="indexterm"/>technique is to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Reproduce the problem.</p></li><li class="listitem"><p>If the problem generates an error message, use that as a starting point.</p></li><li class="listitem"><p>If the error message doesn't provide enough information to solve the problem, consult the logs.</p></li><li class="listitem"><p>If the logs don't help, use <code class="literal">set -x</code> to make sure the scripts are firing correctly, and closely examine the control flow of the non—Xen-specific parts of the system.</p></li><li class="listitem"><p>Use <code class="literal">strace</code> or <code class="literal">pdb</code> to track the flow of execution in the more Xen-specific bits and see what's failing.</p></li></ul></div><p>If you get truly stuck, you might want to think about asking for help. Xen has a couple of excellent mailing lists (<span class="emphasis"><em>xen-devel</em></span> and <span class="emphasis"><em>xen-users</em></span>) and a useful IRC channel, <span class="emphasis"><em>#xen</em></span> on <em class="filename">irc.oftc.net</em>. For more information about how and where to get help, see the end of the chapter.</p><div class="sect1" title="Troubleshooting Phase 1: Error Messages"><div class="titlepage"><div><div><h1 class="title"><a id="troubleshooting_phase_1_error_messages"/>Troubleshooting Phase 1: Error Messages</h1></div></div></div><p>The first sign that something's amiss is likely to be an error message and an abrupt exit. These usually occur in response to some action—booting the machine, perhaps, or creating a domU.</p><p>Xen's error messages can be, frankly, infuriating. They're somewhat vague and developer oriented, and they usually come from somewhere deep in the bowels of the code where it's difficult to determine what particular class of user error is responsible, or even if it's user error at all.</p><p>Better admins than us have been driven mad, have thrown their machines out the window and vowed to spend the rest of their lives wearing animal skins, killing dinner with fire-hardened spears. And who can say they are wrong?</p><p>Regardless, the error messages are a useful diagnostic and often provide enough information to solve the problem.</p><div class="sect2" title="Errors at Dom0 Boot"><div class="titlepage"><div><div><h2 class="title"><a id="errors_at_dom0_boot"/>Errors at Dom0 Boot</h2></div></div></div><p>The first place to look for information about <a id="idx-CHP-15-1038" class="indexterm"/>system-wide problems (if only because there's nothing else to do while the machine boots) is the boot output, both from the hypervisor and the dom0 kernel.<a id="idx-CHP-15-1039" class="indexterm"/><a id="idx-CHP-15-1040" class="indexterm"/></p><div class="sidebar"><a id="reading_boot_error_messages"/><p class="title">READING BOOT ERROR MESSAGES</p><p>When a machine's broken badly enough <a id="idx-CHP-15-1041" class="indexterm"/>that it can't boot, it often reboots itself immediately. This can lead to difficulty when trying to diagnose the problem. We suggest using a serial console with some sort of scrollback buffer to preserve the messages on another computer. This also makes it easy to log output, for example by using GNU screen.</p><p>If you refuse to use serial consoles, or if you wish to otherwise do something before the box reboots, you can append noreboot to both the Xen and Linux kernel lines in GRUB. (If you miss either, it'll reboot. It's finicky that way.)</p></div><p>Many of the Xen-specific <a id="idx-CHP-15-1042" class="indexterm"/>problems we've encountered at boot have to do with kernel/hypervisor mismatches. The Xen kernel must match the <a id="idx-CHP-15-1043" class="indexterm"/>dom0 kernel in terms of PAE support, and if the hypervisor is 64 bit, the dom0 must be 64 bit or i386-PAE. Of course, if the hypervisor is 32 bit, so must be the dom0.</p><p>You can run an <a id="idx-CHP-15-1044" class="indexterm"/>i386-PAE dom0 with an x86_64 hypervisor and x86_64 <a id="idx-CHP-15-1045" class="indexterm"/>domUs, but only on recent Xen kernels (in fact, this is what some versions of the Citrix Xen product do). In no case can you mismatch the PAE-ness. Modern versions of Xen don't even include the compile-time option to run in i386 non-PAE mode, causing all sorts of problems if you want to run older operating systems, such as NetBSD 4.</p><p>Of course, many of the problems that we've had at boot aren't especially Xen-specific; for example, the machine may not boot properly if the initrd isn't correctly matched to the kernel. This often causes people trouble when moving to the Xen.org kernel because it puts the drivers for the root device into an initrd, rather than into the kernel.</p><p>If your distro expects an initrd, you probably want to use your distro's initrd creation script after installing the Xen.org kernel. With CentOS, after installing the Xen.org kernel, make sure that <span class="emphasis"><em>/etc/modprobe.conf</em></span> correctly describes your root device (with an entry like <code class="literal">alias scsi_hostadapter sata_nv</code>), then run something like:</p><a id="I_programlisting15_d1e15839"/><pre class="programlisting"># mkinitrd  /boot/initrd-2.6.18.8-xen.img 2.6.18.8-xen</pre><p>Replace <span class="emphasis"><em>/boot/initrd-2.6.18.8-xen.img</em></span> with the desired filename of your new initrd, and replace <span class="emphasis"><em>2.6.18.8-xen</em></span> with the output of <code class="literal">uname -r</code> for the kernel that you're building the initrd for. (Other options, such as <code class="literal">--preload</code>, may also come in handy. Refer to the distro manual for more information.)</p><p>Assuming you've booted successfully, there are a variety of informative error messages that Xen can give you. Usually these are in response to an attempt to do something, like starting <code class="literal">xend</code> or creating a domain.</p></div><div class="sect2" title="DomU Preboot Errors"><div class="titlepage"><div><div><h2 class="title"><a id="domu_preboot_errors"/>DomU Preboot Errors</h2></div></div></div><p>If you're using PyGRUB (or another bootloader, such as pypxeboot), you may see the message <code class="literal">VmError: Boot loader didn't return any data!</code> This means that PyGRUB, for some reason, wasn't able to find a kernel. Usually this is either because the disks aren't specified properly or because there isn't a valid GRUB configuration in the <a id="idx-CHP-15-1046" class="indexterm"/>domU. Check the disk configuration and make sure that <span class="emphasis"><em>/boot/grub/menu.lst</em></span> exists in the filesystem on the first domU VBD.<a id="idx-CHP-15-1047" class="indexterm"/><a id="idx-CHP-15-1048" class="indexterm"/></p><div class="note" title="Note"><h3 class="title"><a id="note-54"/>Note</h3><p><span class="emphasis"><em>There's some leeway; PyGRUB will check a bunch of filenames, including but not limited to</em></span> /boot/grub/menu.lst, /boot/grub/grub.conf, /grub/menu.lst, <span class="emphasis"><em>and</em></span> /grub/grub.conf. <span class="emphasis"><em>Remember that PyGRUB is a good emulation of GRUB, but it's not exact</em></span>.</p></div><p>You can troubleshoot PyGRUB problems by running PyGRUB manually:</p><a id="I_programlisting15_d1e15894"/><pre class="programlisting"># /usr/bin/pygrub type:/path/to/disk/image</pre><p>This should give you a PyGRUB <a id="idx-CHP-15-1049" class="indexterm"/>boot menu. When you choose a kernel from the menu, PyGRUB exits with a message like:</p><a id="I_programlisting15_d1e15904"/><pre class="programlisting">Linux (kernel /var/lib/xen/boot_kerne.hH9kEk)(args "bootdev=xbd1")</pre><p>This means that PyGRUB successfully loaded a kernel and placed it in the dom0 filesystem. Check the listed location to make sure it's actually there.</p><p>PyGRUB is quite picky about the terminal it's connected to. If PyGRUB exits, complaining about libncurses, or if PyGRUB on the same domain works for some people and not for others, you might have a problem with the terminal.</p><p>For example, with the version of PyGRUB that comes with CentOS 5.1, you can repeatedly get a failure by executing <code class="literal">xm create -c</code> from a terminal window less than 19 lines long. If you suspect this may be the problem, resize your console to 80 x 24 and try again.</p><p>PyGRUB will also expect to find your terminal type (the value of the <code class="literal">TERM</code> variable) in the terminfo database. Manually setting <code class="literal">TERM=vt100</code> before <a id="idx-CHP-15-1050" class="indexterm"/>creating the domain is usually sufficient.</p></div><div class="sect2" title="Creating Domains in Low-Memory Conditions"><div class="titlepage"><div><div><h2 class="title"><a id="creating_domains_in_low-memory_condition"/>Creating Domains in Low-Memory Conditions</h2></div></div></div><p>This is one of the most informative error messages in Xen's arsenal:<a id="idx-CHP-15-1051" class="indexterm"/></p><a id="I_programlisting15_d1e15939"/><pre class="programlisting">XendError: Error creating domain: I need 131072 KiB, but dom0_min_mem
is 262144 and shrinking to 262144 KiB would leave only -16932 KiB
free.</pre><p>The error means that the system doesn't have enough memory to create the domU as requested. (The system in this case had only 384MiB, so the error really isn't surprising.)</p><p>The solution is to adjust <code class="literal">dom0_min_mem</code> to compensate or adjust the domU to require less memory. Or, as in this case, do both (and possibly add more memory).<a id="idx-CHP-15-1052" class="indexterm"/></p></div><div class="sect2" title="Configuring Devices in the DomU"><div class="titlepage"><div><div><h2 class="title"><a id="configuring_devices_in_the_domu"/>Configuring Devices in the DomU</h2></div></div></div><p>Most likely, if the domU fails to start because of missing devices, the problem is tied to storage. (Broken network setups don't usually cause the boot to fail outright, although they can render your VM less than useful after booting.)<a id="idx-CHP-15-1053" class="indexterm"/><a id="idx-CHP-15-1054" class="indexterm"/></p><p>Sometimes the domU will load its kernel and get through the first part of its boot sequence but then complain about not being able to access its root device, despite a correctly specified root kernel parameter. Most likely, the problem is that the domU doesn't have the root device node in the <span class="emphasis"><em>/dev</em></span> directory in the initrd.</p><p>This can lead to trouble when attempting to use the semantically more correct <code class="literal">xvd*</code> devices. Because many distros don't include the appropriate device nodes, they'll fail to boot. The solution, then, is to use the <code class="literal">hd*</code> or <code class="literal">sd*</code> devices in the <code class="literal">disk=</code> line, thus:</p><a id="I_programlisting15_d1e15985"/><pre class="programlisting">disk = ['<a id="idx-CHP-15-1055" class="indexterm"/>phy:/dev/tempest/sebastian,sda1,r']
root = "/dev/sda1"</pre><p>After starting the domain successfully, you can create the <code class="literal">xvd</code> devices properly or edit your udev configuration.</p><p>The Xen block driver may also have trouble attaching to virtual drives that use the <code class="literal">sdX</code> naming convention if the domU kernel includes a SCSI driver. In that case, use the <code class="literal">xvdX</code> convention, like this:</p><a id="I_programlisting15_d1e16004"/><pre class="programlisting">disk = ['phy:/dev/tempest/sebastian,xvda1,r']</pre></div><div class="sect2" title="Troubleshooting Disks"><div class="titlepage"><div><div><h2 class="title"><a id="troubleshooting_disks"/>Troubleshooting Disks</h2></div></div></div><p>Most disk-related errors will cause the domU creation to fail immediately. This makes them fairly easy to troubleshoot. Here are some examples:<a id="idx-CHP-15-1056" class="indexterm"/></p><a id="I_programlisting15_d1e16014"/><pre class="programlisting">Error: DestroyDevice() takes exactly 3 arguments (2 given)</pre><p>These pop up frequently and usually mean that something's wrong in the device specification. Check the config file for typos in the <code class="literal">vif=</code> and <code class="literal">disk=</code> lines. If the message refers to a block device, the problem is often that you're referring to a nonexistent device or file.</p><p>There are a few other errors that have similar causes. For example:</p><a id="I_programlisting15_d1e16026"/><pre class="programlisting">Error: Unable to find number for device (cdrom)</pre><p>This, too, is usually caused by a <code class="literal">phy:</code> device with an incorrectly specified backing device.</p><p>However, this isn't the only possible cause. If you're using file-backed block devices, rather than LVM volumes, the kernel may have run out of block loops on which to mount these devices. (In this case, the message is particularly frustrating because it seems entirely independent of the domain's config.) You can confirm this by looking for an error in the logs like:</p><a id="I_programlisting15_d1e16035"/><pre class="programlisting">Error: Device 769 (vbd) could not be connected. Backend device not found.</pre><p>Although this message usually means that you've mistyped the name of the domain's backing storage device, it may instead mean that you've run out of block loops. The default loop driver only creates seven of the things—barely enough for three domains with root and swap devices.</p><p>We might suggest that you move to LVM, but that's probably overkill. The more direct answer is to make more loops. If your loop driver is a module, edit <span class="emphasis"><em>/etc/modules.conf</em></span> and add:</p><a id="I_programlisting15_d1e16045"/><pre class="programlisting">options loop max_loop=64</pre><p>or another number of your choice; each domU file-backed VBD will require one loop device in dom0. (Do this in whatever domain is used as the backend, usually dom0, although Xen's new stub domains promise to make non-dom0 driver domains much more prevalent.) Then reload the module. Shut down all domains that use loop devices (and detach loops from the dom0) and then run:</p><a id="I_programlisting15_d1e16049"/><pre class="programlisting"># rmmod loop
# insmod loop</pre><p>If the loop driver is built into the kernel, you can add the <code class="literal">max_loop</code> option to the dom0 kernel command line. For example, in <span class="emphasis"><em>/boot/grub/menu.lst</em></span>:</p><a id="I_programlisting15_d1e16059"/><pre class="programlisting">module linux-2.6-xen0 max_loop=64</pre><p>Reboot and the problem should go away.</p></div><div class="sect2" title="VM Restarting Too Fast"><div class="titlepage"><div><div><h2 class="title"><a id="vm_restarting_too_fast"/>VM Restarting Too Fast</h2></div></div></div><p>Disk problems, if they don't announce themselves through a specific error message, often manifest in log entries like the following:<a id="idx-CHP-15-1057" class="indexterm"/></p><a id="I_programlisting15_d1e16073"/><pre class="programlisting">[2007-08-23 16:06:51 xend.XendDomainInfo 2889] ERROR
(XendDomainInfo:1675) VM sebastian <a id="idx-CHP-15-1058" class="indexterm"/>restarting too fast (4.260192
seconds since the last restart). Refusing to restart to avoid loops.</pre><p>This one is really just Xen's way of asking for help; the domain is stuck in a reboot cycle. Start the domain with the <code class="literal">-c</code> option (for console autoconnect) and look at what's causing it to die on startup. In this case, the domain booted and immediately panicked for lack of a root device.</p><div class="note" title="Note"><h3 class="title"><a id="note-55"/>Note</h3><p><span class="emphasis"><em>In this case, the VM is restarting every 4.2 seconds, long enough to get console output. If the restarting too fast number is less than 1 or 2 seconds, often <em class="replaceable"><code>xm create -c</code></em> shows no output. If this happens, check the logs for informative messages. See later sections of this chapter for more details on Xen's logging</em></span>.</p></div></div></div></div>
<div class="sect1" title="Troubleshooting Xen's Networking"><div class="titlepage"><div><div><h1 class="title"><a id="troubleshooting_xens_networking"/>Troubleshooting Xen's Networking</h1></div></div></div><p>In our experience, troubleshooting Xen's networking is a straightforward process, given some general networking knowledge. Unless you've modified the networking scripts, Xen will fairly reliably create the <code class="literal">vif</code> devices. However, if you have problems, here are some general guidelines.(We'll focus on <code class="literal">network-bridge</code> here, although similar steps apply to <code class="literal">network-route</code> and <code class="literal">network-nat</code>.)<a id="idx-CHP-15-1059" class="indexterm"/><a id="idx-CHP-15-1060" class="indexterm"/></p><p>To troubleshoot networking, you really need to understand how Xen does networking. There are a number of scripts and systems working together, and it's important to decompose each problem and isolate it to the appropriate components. Check <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a> for a general overview of Xen's network components.</p><p>The first thing to do is run the network script with the <code class="literal">status</code> argument. For example, if you're using <code class="literal">network-bridge, /etc/xen/scripts/network-bridge status</code> will provide a helpful dump of the state of your network as seen in dom0. At this point you can use <code class="literal">brctl show</code> to examine the network in more detail, and use the <code class="literal">xm vnet-create</code> and <code class="literal">vnet-delete</code> commands in conjunction with the rest of the userspace tools to get a properly set up bridge and Xen virtual network devices.<a id="idx-CHP-15-1061" class="indexterm"/></p><p>When you've got the backend sorted, you can address the frontend. Check the logs and check <code class="literal">dmesg</code> from within the domU to make sure that the domU is initializing its network devices.</p><p>If these look normal, we usually attack the problem more systematically, from bottom to top. First, make sure that the relevant devices show up in the domU. Xen creates these pretty reliably. If they aren't there, check the domU config and the logs for relevant-looking error messages.</p><p>At the next level (because we know that the dom0's networking works, right?) we want to check that the link is functioning. Our basic tool for that is <code class="literal">arping</code> from within the domU, combined with <code class="literal">tcpdump -i [interface]</code> on the domU's interface in the dom0.</p><a id="I_programlisting15_d1e16162"/><pre class="programlisting"># xm list
Name          ID   Mem     VCPUs      State        Time(s)
Domain-0      0    1024    8          r-----       76770.8
caliban       72   256     1          -b----       4768.3</pre><p>Here we're going to demonstrate connectivity between the domain <span class="emphasis"><em>caliban</em></span> (IP address 192.0.2.86) and the dom0 (at 192.0.2.67).</p><a id="I_programlisting15_d1e16169"/><pre class="programlisting"># arping 192.0.2.67
ARPING 192.0.2.67 from 192.168.42.86 eth0
Unicast reply from 192.0.2.67 [00:12:3F:AC:3D:BD]  0.752ms
Unicast reply from 192.0.2.67 [00:12:3F:AC:3D:BD]  0.671ms
Unicast reply from 192.0.2.67 [00:12:3F:AC:3D:BD]  2.561ms</pre><p>Note that the dom0 replies with its MAC address when queried via ARP.</p><a id="I_programlisting15_d1e16174"/><pre class="programlisting"># tcpdump -i vif72.0
tcpdump: WARNING: vif72.0: no IPv4 address <a id="idx-CHP-15-1062" class="indexterm"/>assigned
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on vif1.0, link-type EN10MB (Ethernet), capture size 96 bytes
18:59:33.704649 arp who-has caliban (00:12:3f:ac:3d:bd (oui Unknown)) tell
192.168.42.86
18:59:33.707406 arp reply caliban is-at 00:12:3f:ac:3d:bd (oui Unknown)
18:59:34.714986 arp who-has caliban (00:12:3f:ac:3d:bd (oui Unknown)) tell
192.168.42.86</pre><p>The ARP queries show up correctly in the dom0.</p><p>Now, most of the time, you will see appropriate output in <code class="literal">tcpdump</code> as shown. This tells you that Xen is moving packets from the domU to the dom0. Do you see a response to the ARP who-has? (It should be ARP is-at.) If not, it's possible your bridge in the dom0 isn't set up correctly. One easy way to check the bridge is to run <code class="literal">brctl show</code>:</p><a id="I_programlisting15_d1e16192"/><pre class="programlisting"># brctl show
bridge name     bridge id               STP enabled     interfaces
eth0            8000.00304867164c       no              caliban
                                                        prospero
                                                        ariel</pre><div class="note" title="Note"><h3 class="title"><a id="note-56"/>Note</h3><p><span class="emphasis"><em>In Xen.org versions before Xen 3.2, the bridge name is, by default</em></span>, <em class="replaceable"><code>xenbr0</code></em> <span class="emphasis"><em>for</em></span> <em class="replaceable"><code>network-bridge</code></em>. <span class="emphasis"><em>Xen 3.2 and later, however, named the bridge eth0 (0, in this case, is the number of the related network interface). RHEL/CentOS, by default, creates another bridge</em></span>, <em class="replaceable"><code>virbr0</code></em>, <span class="emphasis"><em>which is part of the libvirt stuff. In practical terms, it functions like</em></span> <em class="replaceable"><code>network-nat</code></em>, <span class="emphasis"><em>with a DHCP server handing out private addresses on the dom0</em></span>.</p></div><p>Now, for <a id="idx-CHP-15-1063" class="indexterm"/>troubleshooting purposes, a bridge is like a switch. Make sure the bridge (switch) your domU interface is connected to is also connected to an interface that touches the network you want the domU on, usually a <code class="literal">pethX</code> device. (As explained in <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a>, <code class="literal">network-bridge</code> renames <code class="literal">ethX</code> to <code class="literal">pethX</code> and creates a fake <code class="literal">ethX</code> device from <code class="literal">vif0.x</code> when it starts up.)</p><p>Check the easy stuff. Can anything else on the bridge see traffic from the outside world? Do <code class="literal">tcpdump -n -i peth0</code>. Are the packets flowing properly?</p><p>Check your routes. Don't forget higher-level stuff, like DNS servers.</p><div class="sect2" title="The DomU Interface Number Increments with Every Reboot"><div class="titlepage"><div><div><h2 class="title"><a id="the_domu_interface_number_increments_wit"/>The DomU Interface Number Increments with Every Reboot</h2></div></div></div><p>When Xen creates a domain, it looks at the <code class="literal">vif=[]</code> statement. Each string within the <code class="literal">[ ]</code> characters (it's a Python array) is another network device. If I just say <code class="literal">vif=['','']</code> it creates two network devices for me, with random MAC addresses. In the <a id="idx-CHP-15-1064" class="indexterm"/>domU, they are (ideally) named <code class="literal">eth0</code> and <code class="literal">eth1</code>. In the dom0, they are named <code class="literal">vifX.0</code> and <code class="literal">vifX.1</code>, where <code class="literal">X</code> is the domain number.</p><p>Most modern Linux distros, by default, lock <code class="literal">ethX</code> to a particular MAC address on the first boot. In RHEL/CentOS, the setting is <code class="literal">HWADDR=</code> in <span class="emphasis"><em>/etc/sysconfig/network-scripts/ifcfg-ethX</em></span>. Most other distros use <code class="literal">udev</code> to handle persistent MAC addresses, as described in <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a>. We circumvent the problem by specifying the MAC address on the <code class="literal">vif=</code> line in the <code class="literal">xm config</code> file:</p><a id="I_programlisting15_d1e16319"/><pre class="programlisting">vif=['mac=00:16:3E:AA:AA:AB','mac=00:16:3E:AA:AA:AC']</pre><p>Here we're using the XenSource MAC prefix, <code class="literal">00:16:3E</code>. If you start your MAC with that prefix, you know it won't conflict with any assigned hardware MAC addresses.</p><p>If you don't specify the MAC address, it'll be randomly generated every time the domU boots, which causes some inconvenience if your domU OS has locked down <code class="literal">ethX</code> to a particular MAC. For more on the possible effects and why it's a good idea to specify a MAC address, see <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a>.</p></div><div class="sect2" title="iptables"><div class="titlepage"><div><div><h2 class="title"><a id="iptables"/>iptables</h2></div></div></div><p>The <code class="literal">iptables</code> rules can also be a source of trouble with Xen. As with any <code class="literal">iptables</code> setup, it's easy to mess up in subtle ways and break everything. The best way we've found to make sure that <code class="literal">iptables</code> rules are working is to send packets through and watch what happens to them. Run <code class="literal">iptables -L -v</code> to see counters for how many packets have hit each rule or have been affected by the chain policy.<a id="idx-CHP-15-1065" class="indexterm"/></p><div class="note" title="Note"><h3 class="title"><a id="note-57"/>Note</h3><p><span class="emphasis"><em>The interface counters for vifs that are examined from the dom0 end will be inverted; outgoing traffic will report as incoming, and vice versa. See <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a> for more information about why that happens</em></span>.</p></div><p>You may also have trouble getting <a id="idx-CHP-15-1066" class="indexterm"/>antispoof to work. If you enable antispoof but find you can still spoof arbitrary IP addresses in the domU, add the following to your network startup:</p><a id="I_programlisting15_d1e16368"/><pre class="programlisting">echo  1 &gt;/proc/sys/net/bridge/bridge-nf-call-iptables</pre><p>This will cause packets sent through the bridges to traverse the forward chain, where Xen puts the antispoof rules. We added the command to the end of <span class="emphasis"><em>/etc/xen/scripts/network-bridge</em></span>.</p><p>Another <a id="idx-CHP-15-1067" class="indexterm"/>problem can occur if you're using vifnames, as we suggest in <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a>. Make sure the names are short—eight characters or less. Longer names can get truncated, and different parts of the system truncate at different lengths (at least in CentOS 5.0). In our particular case, we saw problems where the actual vifnames were truncated at one length, and our firewall rules (for antispoof) were truncated at another length, blocking all packets from the domain in question. It is better to avoid the problem and keep the vifnames short.</p></div></div>
<div class="sect1" title="Memory Issues"><div class="titlepage"><div><div><h1 class="title"><a id="memory_issues"/>Memory Issues</h1></div></div></div><p>Xen (or rather, the Linux driver domain) can act rather strangely when memory is running low. Because Xen and the dom0 require a certain amount of contiguous, unswappable memory, it's surprisingly easy (in our experience) to find the oom-killer snacking on processes like candy. This even happens when there's plenty of swap available.<a id="idx-CHP-15-1068" class="indexterm"/></p><p>The best solution we've found—and we freely admit that it's not perfect—is to give dom0 more memory. We also prefer to fix its memory allocation at something like 512MB so that it doesn't have to cope with Xen constantly adjusting its memory size.</p><p>The basic way of tuning dom0's memory allocation is by adjusting the <code class="literal">dom0_mem</code> kernel parameter, which sets an upper limit, and the <code class="literal">dom0-min-mem</code> parameter in <span class="emphasis"><em>/etc/xen/xend-config.sxp</em></span>, which sets a lower limit. Again, we usually set both of these to the same value.</p><p>To set the maximum amount of memory available to the dom0, edit <span class="emphasis"><em>menu.lst</em></span> and put the option after the kernel line, like this:</p><a id="I_programlisting15_d1e16413"/><pre class="programlisting">kernel /xen.gz dom0_mem=512M noreboot</pre><p>In the absence of units, Xen will assume that the value is in KB.</p><p>Next, edit <span class="emphasis"><em>/etc/xen/xend-config.sxp</em></span> and add a line that says:<sup>[<a id="CHP-15-FNOTE-1" href="#ftn.CHP-15-FNOTE-1" class="footnote">85</a>]</sup></p><a id="I_programlisting15_d1e16428"/><pre class="programlisting">(dom0-min-mem 512)</pre><p>We do this because we've seen the dom0 have problems with ballooning. Ballooning usually works, but, like taking backups from a nonquiescent filesystem, <span class="emphasis"><em>usually works</em></span> is not good enough for something as important as the dom0.<a id="I_indexterm15_d1e16435" class="indexterm"/><a id="I_indexterm15_d1e16440" class="indexterm"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-15-FNOTE-1" href="#CHP-15-FNOTE-1" class="para">85</a>] </sup>Recent versions of Xen also support the option <code class="literal">(enable-dom0-ballooning no)</code>.</p></div></div></div>
<div class="sect1" title="Other Messages"><div class="titlepage"><div><div><h1 class="title"><a id="other_messages"/>Other Messages</h1></div></div></div><a id="I_programlisting15_d1e16448"/><pre class="programlisting">xenconsole: Could not read tty from store: No such file or directory</pre><p>This message usually shows up in response to an attempt to connect to a domain's virtual console (especially when Xen's kernel doesn't match its userland; for example, if we've upgraded Xen's supporting tools without changing the hypervisor).<a id="idx-CHP-15-1069" class="indexterm"/></p><p>If this is a paravirtualized domain, first try killing and restarting the <code class="literal">xenconsoled</code> process. Make sure it dies. We have seen cases where <code class="literal">xenconsoled</code> hangs and must be killed with a <code class="literal">-9</code>.</p><a id="I_programlisting15_d1e16468"/><pre class="programlisting"># pkill xenconsoled &amp;&amp; /usr/sbin/xenconsoled</pre><p>Then reconnect with <code class="literal">xm console</code>.</p><p>If the problem persists, you're most likely trying to access a domain that doesn't have the necessary Xen frontend console device configured in. There are several possibilities: If this is a custom kernel, you may have simply forgotten to include it, for example. Check the configuration of the domain's kernel and the initrd for the xvc driver.</p><p>If you are accessing an HVM domain running a default (nonenlightened) kernel that doesn't include the console driver, try using the framebuffer or booting a different kernel. You might also be able to set <code class="literal">serial=pty</code> in the domain config file and set the domU OS to use com1 as the console. See <a class="xref" href="ch12.html" title="Chapter 12. HVM: BEYOND PARAVIRTUALIZATION">Chapter 12</a> for details.</p><a id="I_programlisting15_d1e16484"/><pre class="programlisting">VmError: (22, 'Invalid argument')
<a id="idx-CHP-15-1070" class="indexterm"/></pre><p>This error can mean a number of things. Often the problem is a version mismatch between the tools and the running Xen hypervisor. Although the binaries installed in <span class="emphasis"><em>/usr/sbin</em></span> may be correct, the underlying Python modules may be wrong. Check that they're correct using whatever evidence is available: dates, comments in the files themselves, output of <code class="literal">xm info</code>, and so on.</p><p>The error can also indicate a PAE mismatch. In this case <em class="filename">xend-debug.log</em> will give a succinct description of the problem:</p><a id="I_programlisting15_d1e16505"/><pre class="programlisting"># tail /var/log/xen/xend-debug.log
ERROR: Non PAE-kernel on PAE host.
ERROR: Error constructing guest OS</pre><p>Incidentally, your dom0—which is, after all, just a special Xen guest domain—can also suffer from this problem. If it happens, the hypervisor will report a PAE mismatch in a large boxed-off error message at boot time and immediately reboot.</p><a id="I_programlisting15_d1e16509"/><pre class="programlisting">"no version for struct_module found: kernel tainted"</pre><p>We got this error while trying to install the binary Xen distribution on a Slackware machine. The binary distro comes with a very minimal kernel, so it needs an initrd with appropriate modules. For some reason, the default script loaded modules in the wrong order, causing some loads to fail with the preceding message.</p><p>We fixed the problem by changing the load order in the initrd; specific directions would depend on your distro.</p><div class="sect2" title="A Constant Stream of 4GiB seg fixup Messages"><div class="titlepage"><div><div><h2 class="title"><a id="a_constant_stream_of_4gib_seg_fixup_mess"/>A Constant Stream of 4GiB seg fixup Messages</h2></div></div></div><p>Sometimes, on booting a newly installed i386 domain, you'll be greeted with screens full of messages like this:</p><a id="I_programlisting15_d1e16520"/><pre class="programlisting">4gb seg fixup, process init (pid 1), cs:ip 73:b7ec2fc5</pre><p>These are related to the <span class="emphasis"><em>/lib/tls</em></span> problem: Xen is complaining because it's having to emulate a <a id="idx-CHP-15-1071" class="indexterm"/>4GiB segment for the benefit of some process that's using negative offsets to access the stack. You may also see a giant message at boot, reminding you to address this issue.</p><p>To solve this problem, you want to use a glibc that does not do this. You can compile glibc with the <code class="literal">-mno-tls-direct-seg-refs</code> option or install the appropriate libc6-xen package for your distribution (both Red Hat–like and Debian-like distros have created packages to address this problem).</p><p>With Red Hat (and its derived distros), you can also run these commands:</p><a id="I_programlisting15_d1e16538"/><pre class="programlisting"># echo 'hwcap 0 nosegneg' &gt; /etc/ld.so.conf.d/libc6-xen.conf
# ldconfig</pre><p>This will instruct the dynamic loader to avoid that particular optimization.</p><p>For Debian-based distros (using the 2.6.18 kernel), you can simply run:</p><a id="I_programlisting15_d1e16544"/><pre class="programlisting"># apt-get install libc6-xen</pre><p>If all else fails (or if you are just too lazy to find a version of gcc with <code class="literal">no-tls-direct-seg-refs</code>), you can do as the <a id="idx-CHP-15-1072" class="indexterm"/>error message advises and move the TLS library out of the way:</p><a id="I_programlisting15_d1e16558"/><pre class="programlisting"># mv /lib/tls /lib/tls.disabled</pre><p>In our experience, there isn't any problem with moving the library. Everything will continue to function as expected.</p></div><div class="sect2" title="The Importance of Disk Drivers (initrd Problems)"><div class="titlepage"><div><div><h2 class="title"><a id="the_importance_of_disk_drivers_initrd_pr"/>The Importance of Disk Drivers (initrd Problems)</h2></div></div></div><p>Often when using a distro kernel, a Xen domU will boot but be unable to locate its root device. For example:<a id="idx-CHP-15-1073" class="indexterm"/></p><a id="I_programlisting15_d1e16570"/><pre class="programlisting">VFS: Cannot open root device "sda1" or unknown-block(0,0)
Please append a correct "root=" boot option
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</pre><p>The underlying problem here—at least in this case—is that the domU kernel doesn't have the necessary drivers compiled in, and the ramdisk was not specified. A look at the boot output confirms this, with the messages:</p><a id="I_programlisting15_d1e16574"/><pre class="programlisting">XENBUS: Device with no driver: device/vbd/769
XENBUS: Device with no driver: device/vbd/770
XENBUS: Device with no driver: device/vif/0</pre><p>Nearly all distro kernels come with a minimal kernel and require an <a id="idx-CHP-15-1074" class="indexterm"/>initrd with the disk driver to finish booting. These <a id="idx-CHP-15-1075" class="indexterm"/>messages may simply come from the kernel before the initrd has loaded, or they can indicate a serious problem if the initrd doesn't contain the necessary drivers.</p><p>If the kernel managed to load its initrd correctly and failed to switch to its real root, you'll find yourself stuck in the initrd with a very limited selection of files. In this case, make sure that your devices exist (<code class="literal">/dev/sda1</code> in this example) and that you've got the Xen disk frontend kernel module.</p><p>We also commonly see this within PyGRUB domUs after a kernel upgrade (and new initrd) if the modules config (<span class="emphasis"><em>/etc/modules</em></span> on Debian, <span class="emphasis"><em>/etc/modprobe.conf</em></span> on Red Hat) didn't specify <code class="literal">xenblk</code>. For RHEL/CentOS domUs, you can solve this problem by running <code class="literal">mkinitrd</code> with the <code class="literal">--preload xenblk</code> switch.</p><p>If you use an external kernel and want to use a distro kernel, you must specify a <code class="literal">ramdisk=</code> line in the domain config file, and specify a ramdisk that includes the <code class="literal">xenblk</code> (and <code class="literal">xennet</code>, if you want network before boot) drivers.</p><p>Another solution to this problem would be to compile Xen from source and build a sufficiently generic domU kernel, with the <code class="literal">xenblk</code> and <code class="literal">xennet</code> drivers already compiled in. Even if you continue to boot the dom0 from the distro kernel (probably a good idea), this will sidestep the distro-specific issues found with both Red Hat and Debian kernels.</p><p>This may cause problems with some domU distros because the expected initrd won't be there. Sometimes it can be difficult to build an initrd against a kernel with disk drivers built in. However, the generic kernel will usually at least boot.</p><p>We often find it useful to keep these generic kernels as a secondary rescue boot option within the domU PyGRUB config because they work no matter how badly the initrd is messed up.</p></div><div class="sect2" title="XenStore"><div class="titlepage"><div><div><h2 class="title"><a id="xenstore"/>XenStore</h2></div></div></div><p>Sometimes the XenStore gets corrupted, or <code class="literal">xenstored</code> dies, or for various other reasons the XenStore ceases to store and report information. For example, this may happen if the block device holding the XenStore database becomes full.<a id="idx-CHP-15-1076" class="indexterm"/></p><p>The most obvious symptom is that <code class="literal">xm list</code> will report domain names incorrectly, for example:</p><a id="I_programlisting15_d1e16652"/><pre class="programlisting"># xm list
Name                                     ID Mem(MiB) VCPUs State   Time(s)
Domain-0                                  0     2554     2 r-----  16511.2
Domain-10                                10      127     1 -b----   1671.5
Domain-11                                11      255     1 -b----    442.0
Domain-14                                14       63     1 -b----   1758.2
Domain-15                                15       62     1 -b----   7507.7
Domain-16                                16      127     1 -b----  11194.9
Domain-6                                  6       94     1 -b----   5454.2
Domain-7                                  7       62     1 -b----    270.8
Domain-9                                  9      127     1 -b----   1715.7</pre><p>Obviously, this is problematic. For one thing, it means that all commands that can take a name or ID, such as <code class="literal">xm console</code>, will no longer recognize names.</p><p>Unfortunately, <code class="literal">xenstored</code> cannot be restarted, so you'll have to reboot. If you're running a version of Xen prior to 3.1 (including the RHEL 5.x version), you'll have to remove <span class="emphasis"><em>/var/lib/xenstored/tdb</em></span> first, then reboot.<a id="idx-CHP-15-1077" class="indexterm"/></p></div></div>
<div class="sect1" title="Xen's Logs"><div class="titlepage"><div><div><h1 class="title"><a id="xens_logs"/>Xen's Logs</h1></div></div></div><p>These <a id="idx-CHP-15-1078" class="indexterm"/>error messages make a good start for Xen <a id="idx-CHP-15-1079" class="indexterm"/>troubleshooting, but sometimes they're not helpful enough to solve the problem. In these cases, we need to dig deeper.<a id="idx-CHP-15-1080" class="indexterm"/></p><div class="sect2" title="dmesg and xm dmesg"><div class="titlepage"><div><div><h2 class="title"><a id="dmesg_and_xm_dmesg"/>dmesg and xm dmesg</h2></div></div></div><p>Although the output of <code class="literal">xm dmesg</code> isn't a log in the usual sense of a log file, it's an important source of diagnostic output. If you've got a problem whose source isn't obvious from the error message, begin by looking at the Xen kernel message buffer. As you probably know, the Linux <code class="literal">dmesg</code> command prints out the Linux kernel's message buffer, which ordinarily contains all kernel messages since the system's last boot (or, if the system's been up for a while, it displays a succession of boring status messages).</p><p>Because Xen could be said to act as a kernel in its own right, it includes an equivalent tool, <code class="literal">xm dmesg</code>, to print out messages from the hypervisor boot (the lines that begin with <code class="literal">(XEN)</code> in the startup messages). For example:</p><a id="I_programlisting15_d1e16711"/><pre class="programlisting"># xm dmesg | tail -3

(XEN) (file=platform_hypercall.c, line=129) Domain 0 says that IO-APIC
REGSEL is good
(XEN) microcode: error! Bad data in microcode data file
(XEN) microcode: Error in the microcode data</pre><p>In this case, the errors are harmless. The processor simply runs on its factory-installed microcode.</p><div class="note" title="Note"><h3 class="title"><a id="note-58"/>Note</h3><p><span class="emphasis"><em>Like the kernel, Xen retains only a fixed-size message buffer. Older messages go off into oblivion</em></span>.</p></div></div><div class="sect2" title="Logs and What Xen Writes to Them"><div class="titlepage"><div><div><h2 class="title"><a id="logs_and_what_xen_writes_to_them"/>Logs and What Xen Writes to Them</h2></div></div></div><p>If <code class="literal">xm dmesg</code> isn't enlightening, Xen's next line of communication is its extensive logging. Let's look at the various logs that Xen uses and what we can do with them.</p><p>We can summarize Xen's <a id="idx-CHP-15-1081" class="indexterm"/>logs as follows, in rough order of importance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>/var/log/xen/xend.log</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/xen/xend-debug.log</em></span><a id="idx-CHP-15-1082" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/xen/xen-hotplug.log</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/syslog</em></span><a id="idx-CHP-15-1083" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/debug</em></span></p></li></ul></div><p>Most of your Xen troubleshooting will involve the first two <a id="idx-CHP-15-1084" class="indexterm"/>logs. <em class="filename">xend.log</em> is the main <code class="literal">xend</code> log, as you might suppose. It records domain startups, shutdowns, device creation, debugging whatever, and occasionally includes giant incomprehensible Python dumps. It's the first thing to check.</p><p><em class="filename">xend-debug.log</em> has information relating to more experimental features of Xen, such as the framebuffer. It'll also have verbose tracebacks when Xen runs into trouble.</p><p>Because <code class="literal">xend</code> uses the syslog facility, messages from Xen also show up in the system-wide <span class="emphasis"><em>/var/log/syslog</em></span> and <span class="emphasis"><em>/var/log/debug</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="note-59"/>Note</h3><p><span class="emphasis"><em>We hasten to add that syslog is almost humorously configurable. Even the term</em></span> system-wide <span class="emphasis"><em>only applies to the default configuration; syslog can consolidate logs across multiple hosts, categorize messages into various channels, write to arbitrary files, and so on, but we're going to assume that, if you've configured syslog, you can translate what we say about Xen's use of it to apply to your configuration</em></span>.</p></div><p>Finally, if you're using HVM, <code class="literal">qemu-dm</code> will write its own logs. By and large, you can safely ignore these. In our experience, problems with HVM domains haven't been the fault of QEMU's device emulation.</p><p>If the kernel messages prove to be unenlightening, it's time to take a look at the log files. First, let's configure Xen to ensure that they're as round, firm, and fully packed as possible.</p><div class="sidebar"><a id="the_importance_of_a_debug_build"/><p class="title">THE IMPORTANCE OF A DEBUG BUILD</p><p>For troubleshooting (and, in fact, general use) we recommend building Xen with all of its debugging options turned on. This makes the error messages more informative and plentiful, making it easier to figure out where problems are coming from and, with any luck, eliminate them.<a id="idx-CHP-15-1085" class="indexterm"/></p><p>Although it might seem that copious debugging output would cause a perfor-mance hit, in our experience it's negligible when running Xen normally. A debug build gives you the option of running Xen with excessive debugging output, but it performs about as well as a normal build when you're not using that mode. If you find that the error messages are unhelpful, it might be a good idea to make sure that you have all the the debugging knobs set to <span class="strong"><strong>full</strong></span>. To enable <a id="idx-CHP-15-1086" class="indexterm"/>full output for the hypervisor, add the options <code class="literal">loglvl=all guest_loglvl=all</code> to your hypervisor command line (usually in <span class="emphasis"><em>/boot/grub/menu.lst</em></span>).</p><p>See <a class="xref" href="ch14.html" title="Chapter 14. TIPS">Chapter 14</a> for more information on building Xen, including how to set the debugging options.</p></div></div></div>
<div class="sect1" title="Applying the Debugger"><div class="titlepage"><div><div><h1 class="title"><a id="applying_the_debugger"/>Applying the Debugger</h1></div></div></div><p>If even the maximum-verbosity logging isn't enough, it's time to attack the problem at the Python level, with the <a id="idx-CHP-15-1087" class="indexterm"/>debugger.</p><p>One investigation to try is to run the <code class="literal">xend</code> server in the foreground and watch its debug output. This will let you see somewhat more information than simply following the logs.</p><p>With current versions of Xen, the debug functionality is included in the releases.<sup>[<a id="CHP-15-FNOTE-2" href="#ftn.CHP-15-FNOTE-2" class="footnote">86</a>]</sup> Enable the debug output with the following:</p><a id="I_programlisting15_d1e16856"/><pre class="programlisting"># export XEND_DEBUG=1
# export XEND_DAEMONIZE=0

# xend start</pre><p>This will start <code class="literal">xend</code> in the foreground and tell it to print debug messages as it goes along.</p><p>You can also get copious debugging information for the XenStore by setting <code class="literal">XENSTORED_TRACE=1</code> somewhere where <code class="literal">xend</code>'s environment will pick it up, perhaps at the top of <span class="emphasis"><em>/etc/init.d/xend</em></span> or in root's <span class="emphasis"><em>.bashrc</em></span>.</p><div class="sect2" title="Xen's Backend Architecture: Making Sense of the Debug Information"><div class="titlepage"><div><div><h2 class="title"><a id="xens_backend_architecture_making_sense_o"/>Xen's Backend Architecture: Making Sense of the Debug Information</h2></div></div></div><p>Of course, all this debugging output is more useful with some idea of how Xen is <a id="idx-CHP-15-1088" class="indexterm"/>structured.<a id="idx-CHP-15-1089" class="indexterm"/></p><p>If you take a look at the actual <code class="literal">xend</code> executable, the first thing you'll notice is that it's really very short. There's not much to it; all of the heavy lifting is done in external Python libraries, which live in <span class="emphasis"><em>/xen/xend/server</em></span> in one of the Python library directories. (In the case of the system I'm sitting in front of, this is <span class="emphasis"><em>/usr/lib/python2.4/site-packages/xen/xend/server</em></span>.)</p><p>Likewise, <code class="literal">xm</code> is also a short Python script. The take-home message here is that most of the error messages that you'll see emanate from somewhere in this directory tree, and they'll helpfully print the responsible file and line number so you can examine the Python script more closely. For example, look at this line from <span class="emphasis"><em>/var/log/xen/xend.log</em></span>:</p><a id="I_programlisting15_d1e16910"/><pre class="programlisting">[2007-08-07 20:14:26 6008] WARNING (XendAPI:672) API call:
VM.get_auto_power_on not found</pre><p>At the beginning is the date, time, and <code class="literal">xend</code>'s Process ID (PID). Then comes the severity of the error (in this case, <code class="literal">WARNING</code>, which is merely irritating). After that is the file and line number where the error occurred, followed by the contents of the error message.</p><div class="sidebar"><a id="xens_hierarchy_of_informative_messages"/><p class="title">XEN'S HIERARCHY OF INFORMATIVE MESSAGES</p><p><code class="literal">WARNING</code> is only one point along the continuum <a id="idx-CHP-15-1090" class="indexterm"/>of messages. At the lowest extreme of severity, we have <code class="literal">DEBUG</code>, which the developers use for whatever output strikes their fancy. It's often useful, but it generates a lot of data to wade through. Slightly more significantly, we have <code class="literal">INFO</code>. Messages at this level are supposed to be interesting or useful to the administrator but not indicative of a problem.<a id="idx-CHP-15-1091" class="indexterm"/><a id="idx-CHP-15-1092" class="indexterm"/><a id="idx-CHP-15-1093" class="indexterm"/></p><p>Then comes <code class="literal">WARNING</code>, which indicates a problem, but not a critical one. For example, the previous message tells us that we'd have trouble if we're relying on the <code class="literal">VM.get_auto_power_on</code> function but that nothing bad will happen if we don't try touseit.</p><p>Finally, Xen uses <code class="literal">ERROR</code> for genuine, beyond-denial errors—the sort of thing thatcan't be put off or ignored. Generally this means that a domain is exiting abnormally.<a id="idx-CHP-15-1094" class="indexterm"/></p></div><p>Armed with this information, you can do several things. To continue our earlier example, we'll open <span class="emphasis"><em>/usr/lib/python2.5/site-packages/xen/xend/XendAPI.py</em></span> and add a line near the top of the file to import the <a id="idx-CHP-15-1095" class="indexterm"/>debugger module, <code class="literal">pdb</code>.</p><a id="I_programlisting15_d1e16976"/><pre class="programlisting">import pdb</pre><p>Having done that, you can set a breakpoint. Just add a line near line 672:</p><a id="I_programlisting15_d1e16980"/><pre class="programlisting">pdb.set_trace()</pre><p>Then try rerunning the server (or redoing whatever other behavior you're concerned with) and note that <code class="literal">xend</code> starts the debugger when it hits your new breakpoint.</p><p>At this point you can do everything that you might expect in a debugger: change the values of variables, step through a function, step into subroutines, and so forth. In this case, we might backtrace, figure out why it's trying to call <code class="literal">VM.get_auto_power_on</code>, and maybe wrap it in an error-handling block.</p></div><div class="sect2" title="Domain Stays in Blocked State"><div class="titlepage"><div><div><h2 class="title"><a id="domain_stays_in_blocked_state"/>Domain Stays in Blocked State</h2></div></div></div><p>This heading is a bit of a misnomer. The reality is that the "blocked" state reported by tools like <code class="literal">xm list</code> simply means that the domain is idle. The true problem is that the domain seems unresponsive.<a id="idx-CHP-15-1096" class="indexterm"/><a id="idx-CHP-15-1097" class="indexterm"/></p><p>Usually we find that this problem is related to the console; for example:</p><a id="I_programlisting15_d1e17013"/><pre class="programlisting">[root@localhost ~]# xm create -c sebastian.cfg
Using config file "/etc/xen/sebastian.cfg".
Going to boot Fedora Core (2.6.18-1.2798.fc6xen)
  kernel: /vmlinuz-2.6.18-1.2798.fc6xen
  initrd: /initrd-2.6.18-1.2798.fc6xen.img
Started domain sebastian
rtc: IRQ 8 is not free.
i8042.c: No controller found.</pre><p>(and then an <a id="idx-CHP-15-1098" class="indexterm"/>indefinite hang). Upon breaking out and looking at the output of <code class="literal">xm list</code>, we note that the <a id="idx-CHP-15-1099" class="indexterm"/>domain stays in a blocked state and consumes very little CPU time.</p><a id="I_programlisting15_d1e17032"/><pre class="programlisting">[root@localhost ~]# xm list
Name                                      ID Mem(MiB) VCPUs State  Time(s)
Domain-0                                   0     3476     2 r-----   407.1
sebastian                                 13      499     1 -b----    19.9</pre><p>A quick look at <span class="emphasis"><em>/var/log/xen/xend-debug.log</em></span> suggested an answer:</p><a id="I_programlisting15_d1e17039"/><pre class="programlisting">10/09/2007 20:11:48 Autoprobing TCP port
10/09/2007 20:11:48 Autoprobing selected port 5900</pre><p>Port 5900 is VNC. Aha! The problem was that Xen wasn't using the virtual console device that <code class="literal">xm</code> console connects to. In this case, we traced it to user error. We specified the framebuffer and forgot about it. The kernel, as instructed, used the framebuffer as console rather than emulated serial console that we were expecting. When we started a VNC client and connected to port 5900, it gave us the expected graphical console.</p><div class="note" title="Note"><h3 class="title"><a id="note-60"/>Note</h3><p><span class="emphasis"><em>If we had put a</em></span> <em class="replaceable"><code>getty</code></em> <span class="emphasis"><em>on xvc0, even though we wouldn't have seen boot output, we'd at least get a login prompt when the machine booted</em></span>.</p></div></div><div class="sect2" title="Debugging Hotplug"><div class="titlepage"><div><div><h2 class="title"><a id="debugging_hotplug"/>Debugging Hotplug</h2></div></div></div><p>Xen makes extensive <a id="idx-CHP-15-1100" class="indexterm"/>use of udev to create and destroy virtual devices, both in the dom0 and the domU. Most of its interaction with Linux's hotplug subsystem gets logged in <span class="emphasis"><em>/var/log/xen/xen-hotplug.log</em></span>. (We're going to treat hotplug as synonymous with udev because we can't think of any system that still uses the pre-udev hotplug implementation.)<a id="idx-CHP-15-1101" class="indexterm"/></p><p>First, we examine the effects of the script. In this case, we use <code class="literal">udevmonitor</code> to see udev events. It should show an <code class="literal">add</code> event for each <code class="literal">vif</code> and <code class="literal">vbd</code> as well as an <code class="literal">online</code> event for the <code class="literal">vif</code>. These go through the rules in <span class="emphasis"><em>/etc/udev/rules.d/xen-backend.rules</em></span>, which executes appropriate scripts in <span class="emphasis"><em>/etc/xen/scripts</em></span>.</p><p>At this point you can add some extra logging. At the top of the script for the device you're interested in (e.g., blktap), put:</p><a id="I_programlisting15_d1e17105"/><pre class="programlisting">set -x
exec 2&gt;&gt;/var/log/xen-hotplug.log</pre><p>This will cause the shell to expand the commands in the script and write them to <em class="filename">xen-hotplug.log</em>, enabling you (hopefully) to trace down the source of the problem and eliminate it.</p><p>Hotplug can also act as a bit of a catchall for any virtual device problem. Some hotplug-related errors take the form of the dreaded <code class="literal">Hotplug scripts not working</code> message, like the following:</p><a id="I_programlisting15_d1e17117"/><pre class="programlisting">Error: Device 0 (vkbd) could not be connected. Hotplug scripts not working.</pre><p>This seems to be associated with messages like the following:</p><a id="I_programlisting15_d1e17121"/><pre class="programlisting">DEBUG (DevController:148) Waiting for devices irq.
DEBUG (DevController:148) Waiting for devices vkbd.
DEBUG (DevController:153) Waiting for 0.
DEBUG (DevController:539) hotplugStatusCallback
/local/domain/0/backend/vkbd/4/0/hotplug-status</pre><p>In this case, however, these messages turned out to be red herrings. The answer came out of <em class="filename">xend-debug.log</em>, which said:</p><a id="I_programlisting15_d1e17129"/><pre class="programlisting">/usr/lib/xen/bin/xen-vncfb: error while loading shared libraries:
libvncserver.so.0: cannot open shared object file: No such file or
directory</pre><p>As it developed, <code class="literal">libvncserver</code> was installed in <span class="emphasis"><em>/usr/local</em></span>, which the runtime linker had been ignoring. After adding <span class="emphasis"><em>/usr/local/lib</em></span> to <span class="emphasis"><em>/etc/ld.so.conf</em></span>, <code class="literal">xen-vncfb</code> started up happily.</p></div><div class="sect2" title="strace"><div class="titlepage"><div><div><h2 class="title"><a id="strace"/>strace</h2></div></div></div><p>One important generic troubleshooting technique is to use strace to look at what the Xen control tools are really doing. For example, if Xen is failing to find an external binary (like xen-vncfb), strace can reveal that problem with a command like the following:<a id="idx-CHP-15-1102" class="indexterm"/></p><a id="I_programlisting15_d1e17156"/><pre class="programlisting"># strace -e trace=open -f xm create prospero 2&gt;&amp;1 | grep ENOENT | less</pre><p>Unfortunately, it'll also give you a lot of other, entirely harmless output while Python proceeds to pull in the entirety of its runtime environment based on crude guesses about filenames.</p><p>Another example of strace's usefulness comes from when we were setting up PyGRUB:</p><a id="I_programlisting15_d1e17162"/><pre class="programlisting"># strace xm create -c prospero
(snipped)
mknod("/var/lib/xen/xenbl.4961", S_IFIFO|0600) = -1 ENOENT (No such file or
directory)</pre><p>As it turned out, we didn't have a directory required by PyGRUB's backend. Thus:</p><a id="I_programlisting15_d1e17166"/><pre class="programlisting"># mkdir -p /var/lib/xen/</pre><p>and everything works fine.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-15-FNOTE-2" href="#CHP-15-FNOTE-2" class="para">86</a>] </sup>Once upon a time you had to download a patch and rebuild. Thankfully, this is no longer the case.</p></div></div></div>
<div class="sect1" title="Python Path Issues"><div class="titlepage"><div><div><h1 class="title"><a id="python_path_issues"/>Python Path Issues</h1></div></div></div><p>The Python <a id="idx-CHP-15-1103" class="indexterm"/>path itself can be the subject of some irritation. Just as you've got your shell executable path, manpath, library path, and so forth, Python has its own internal search path that it examines for modules. If the path doesn't include the Xen modules, you can wind up with errors like the following:</p><a id="I_programlisting15_d1e17181"/><pre class="programlisting"># xm create -c sebastian.cfg
Using config file "/etc/xen/sebastian.cfg".
Traceback (most recent call last):
  File "/usr/bin/pygrub", line 26, in ?
    import grub.fsys
ImportError: No module named fsys</pre><p>Unfortunately, the mechanisms for adjusting the search path aren't exactly intuitive. In most cases, we just fall back to either creating some symlinks or moving the Xen files into some directory that's already in Python's path.</p><p>The correct solution is to add a <span class="emphasis"><em>.pth</em></span> file to a directory that's already in Python's path. This <span class="emphasis"><em>.pth</em></span> file should contain the path of a directory with Python modules. For example:</p><a id="I_programlisting15_d1e17193"/><pre class="programlisting"># echo "/usr/local/lib/python2.5/site-packages" &gt;&gt;
/usr/lib/python2.5/local.pth</pre><p>Confirm that the path updated correctly by starting Python:</p><a id="I_programlisting15_d1e17197"/><pre class="programlisting"># python

&gt;&gt;&gt;&gt; import sys
&gt;&gt;&gt;&gt; print sys.path
['', '/usr/lib/python25.zip', 'usr/lib/python2.5' (etc)
'/usr/local/lib/python2.5/site-packages']</pre><div class="sect2" title="Mysterious Lockups"><div class="titlepage"><div><div><h2 class="title"><a id="mysterious_lockups"/>Mysterious Lockups</h2></div></div></div><p><a id="idx-CHP-15-1104" class="indexterm"/>Mysterious lockups are among the most frustrating aspects of dealing with computers; sometimes they just don't work.<a id="idx-CHP-15-1105" class="indexterm"/></p><p>If Xen (or the dom0) hangs mysteriously, chances are you have a kernel panic in the dom0. In this case, you have two problems: first, the crash; second, your console logging isn't adequate to its task.</p><p>A serial console improves your life immensely. If you're using serial, you should see an informative panic message on the serial console. If you don't see that, you may want to try typing CTRL-A three times on the console to switch the input to the Xen hypervisor. This will at least confirm that Xen and the hardware are still up.</p><p>If you don't have a serial console, try to keep your VGA console on tty1 because often the panic message won't go anywhere else. Sometimes a digital camera is handy for saving the output of a kernel panic.</p><p>If the box reboots before you can see the panic message on your console, and serial isn't an option, you can try adding <code class="literal">panic=0</code> to the <code class="literal">module</code> line that specifies your Linux kernel in the domU <em class="filename">menu.lst</em> file. This has the obvious disadvantage of hanging your computer rather than rebooting, but it's good for test setups because it'll at least let you see the computer's final messages.</p></div><div class="sect2" title="Kernel Parameters: A Safe Mode"><div class="titlepage"><div><div><h2 class="title"><a id="kernel_parameters_a_safe_mode"/>Kernel Parameters: A Safe Mode</h2></div></div></div><p>If even the hypervisor serial console doesn't work—that is, if the machine is <span class="emphasis"><em>really</em></span> frozen—there are some <a id="idx-CHP-15-1106" class="indexterm"/>kernel parameters that we've had good luck with in the past.<a id="idx-CHP-15-1107" class="indexterm"/><a id="idx-CHP-15-1108" class="indexterm"/></p><p>The <code class="literal">ignorebiostables</code> option to the Linux kernel (on the <code class="literal">module</code> line) may help to avoid hangs when under I/O stress on certain Intel chipsets. If your machine is crashing—the hardware is full-on ceasing to function—it might be worth a shot. (I know, it's only one step removed from waving a dead chicken over the server, but you work with what you've got.)<a id="idx-CHP-15-1109" class="indexterm"/></p><p>In a similar vein, <code class="literal">acpi=off</code> and <code class="literal">nousb</code> have been reported to improve stability on some hardware. You may also want to disable hyperthreading in the BIOS. Some Xen versions have had trouble with it.</p><p>If you want to add all of these options at once, your <span class="emphasis"><em>/boot/grub/menu.lst</em></span> entry for Xen will look something like this:</p><a id="I_programlisting15_d1e17279"/><pre class="programlisting">root hd0(0)
kernel /boot/xen-3.0.gz
module /boot/vmlinuz-2.6-xen ignorebiostables acpi=off noapic nousb</pre></div></div>
<div class="sect1" title="Getting Help"><div class="titlepage"><div><div><h1 class="title"><a id="getting_help"/>Getting Help</h1></div></div></div><p>You can, of course, email us directly with Xen-related questions. No guarantee that we'll be able to help, but asking is easy enough. There's also a list of Xen consultants on the Xen wiki at <a class="ulink" href="http://wiki.xensource.com/xenwiki/Consultants">http://wiki.xensource.com/xenwiki/Consultants</a>. (If you happen to be a Xen consultant, feel free to add yourself.)</p><div class="sect2" title="Mailing Lists"><div class="titlepage"><div><div><h2 class="title"><a id="mailing_lists"/>Mailing Lists</h2></div></div></div><p>There are several popular <a id="idx-CHP-15-1110" class="indexterm"/>mailing lists devoted to Xen. You can sign up and read digests at <a class="ulink" href="http://lists.xensource.com/">http://lists.xensource.com/</a>. We recommend reading the Xen-users mailing list at least. Xen-devel can be interesting, but the high volume of patches might discourage people who aren't actively involved in Xen development. At any rate, both lists are good places to look for help, but Xen-users is a much better place to start if you have a question that involves <span class="emphasis"><em>using</em></span> Xen, rather than hacking at it.<a id="idx-CHP-15-1111" class="indexterm"/></p></div><div class="sect2" title="The Xen Wiki"><div class="titlepage"><div><div><h2 class="title"><a id="the_xen_wiki"/>The Xen Wiki</h2></div></div></div><p><a id="idx-CHP-15-1112" class="indexterm"/>Xen has a fairly extensive wiki at <a class="ulink" href="http://wiki.xensource.com/">http://wiki.xensource.com/</a>. Some of it is out of date, but it's still a valuable starting point. Of course, new contributors are always welcome. Take a look, poke around, and add your own experiences, tips, and cool tidbits.</p></div><div class="sect2" title="The Xen IRC Channel"><div class="titlepage"><div><div><h2 class="title"><a id="the_xen_irc_channel"/>The Xen IRC Channel</h2></div></div></div><p>There's a fairly popular <a id="idx-CHP-15-1113" class="indexterm"/>Xen IRC channel, <span class="emphasis"><em>#xen</em></span> on <em class="filename">irc.oftc.net</em>. Feel free to stop by and chat.<a id="idx-CHP-15-1114" class="indexterm"/></p></div><div class="sect2" title="Bugzilla"><div class="titlepage"><div><div><h2 class="title"><a id="bugzilla"/>Bugzilla</h2></div></div></div><p>Xen maintains a bug database, just like all software projects above a certain size. It's publicly accessible at <a class="ulink" href="http://bugzilla.xensource.com/">http://bugzilla.xensource.com/</a><a id="idx-CHP-15-1115" class="indexterm"/>. Type keywords into the search box, press the button, and read the results.<a id="idx-CHP-15-1116" class="indexterm"/></p></div><div class="sect2" title="Your Distro Vendor"><div class="titlepage"><div><div><h2 class="title"><a id="your_distro_vendor"/>Your Distro Vendor</h2></div></div></div><p>Don't forget the specific documentation and support resources of your vendor. Xen is a complex piece of software, and the specifics of how it's integrated vary between distros. Although the distro documentation may not be as complete as, say, this book, it's likely to at least point in the correct direction.<a id="idx-CHP-15-1117" class="indexterm"/></p></div><div class="sect2" title="xen-bugtool"><div class="titlepage"><div><div><h2 class="title"><a id="xen-bugtool"/>xen-bugtool</h2></div></div></div><p>If all else fails, you can use <code class="literal">xen-bugtool</code> to annoy the developers directly. The purpose of <code class="literal">xen-bugtool</code> is to collect the relevant troubleshooting information so you can conveniently attach it to a bug report or make it available to a mailing list.<a id="idx-CHP-15-1118" class="indexterm"/><a id="idx-CHP-15-1119" class="indexterm"/></p><p>Simply run <code class="literal">xen-bugtool</code> on the affected box (in the dom0, of course). It'll start an interactive session and ask you what data to include and what to do with the data.</p><p>The <code class="literal">xen-bugtool</code> script collects the following information:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The output of <code class="literal">xm dmesg</code></p></li><li class="listitem"><p>The output of <code class="literal">xm info</code></p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/messages</em></span> (if desired)</p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/xen/xend-debug.log</em></span> (if desired)</p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/xen/xen-hotplug.log</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/var/log/xen/xend.log</em></span></p></li></ol></div><p><code class="literal">xen-bugtool</code> will save this data as a <span class="emphasis"><em>.tar.bz2</em></span>, after which it's up to you to decide what to do with it. We recommend uploading it somewhere web-accessible and sending a message to the Xen-devel mailing list.</p></div></div>
<div class="sect1" title="Some Last Words of Encouragement"><div class="titlepage"><div><div><h1 class="title"><a id="some_last_words_of_encouragement"/>Some Last Words of Encouragement</h1></div></div></div><p>This chapter describes a troubleshooting work flow that works for us. In general, we try to hit the obvious stuff before escalating to more invasive and labor-intensive methods.</p><p>We've also tried to list error messages that we've seen, along with possible solutions. Obviously, we can't be encyclopedic, but we've probably hit most of the common error messages in our years working with Xen, and we can at least give you a decent starting point.</p><p>Don't get depressed! Concentrate! Remember that the odds are very good that someone has seen and solved this problem before. And, don't forget: There's no shame in giving up occasionally. You can't beat the computer all the time. Well, maybe you can, but we can't. Good luck.</p></div></body></html>