- en: Chapter 7. Newbus and Resource Allocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 新型总线与资源分配
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: Until now, we’ve examined only pseudo-devices, which provide a superb introduction
    to driver writing. However, most drivers need to interact with real hardware.
    This chapter shows you how to write drivers that do just that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只检查了伪设备，它们为编写驱动程序提供了极好的介绍。然而，大多数驱动程序需要与真实硬件交互。本章将向您展示如何编写这样的驱动程序。
- en: I’ll start by introducing *Newbus*, which is the infrastructure used in FreeBSD
    to manage the hardware devices on the system (McKusick and Neville-Neil, 2005).
    I’ll then describe the basics of a Newbus driver, and I’ll conclude this chapter
    by talking about hardware resource allocation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先介绍 *新型总线*，这是FreeBSD用于管理系统硬件设备的底层架构（McKusick和Neville-Neil，2005）。然后，我将描述新型总线驱动程序的基本知识，并在本章结束时讨论硬件资源分配。
- en: Autoconfiguration and Newbus Drivers
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动配置与新型总线驱动程序
- en: '*Autoconfiguration* is the procedure carried out by FreeBSD to enable the hardware
    devices on a machine (McKusick and Neville-Neil, 2005). It works by systematically
    probing a machine’s I/O buses in order to identify their child devices. For each
    identified device, an appropriate Newbus driver is assigned to configure and initialize
    it. Note that it’s possible for a device to be unidentifiable or unsupported.
    As a result, no Newbus driver will be assigned.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动配置*是FreeBSD执行的过程，以启用机器上的硬件设备（McKusick和Neville-Neil，2005）。它通过系统地探测机器的I/O总线以识别其子设备来实现。对于每个识别的设备，都会分配一个适当的新型总线驱动程序来配置和初始化它。请注意，设备可能无法识别或不受支持。因此，不会分配任何新型总线驱动程序。'
- en: A *Newbus driver* is any driver in FreeBSD that controls a device that is bound
    to an I/O bus (that is, roughly every driver that is not a pseudo-device driver).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*新型总线驱动程序*是FreeBSD中任何控制绑定到I/O总线的设备（即，大致上不是伪设备驱动程序的每个驱动程序）的驱动程序。'
- en: 'In general, three components are common to all Newbus drivers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有新型总线驱动程序都包含以下三个组件：
- en: The `device_foo` functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_foo` 函数'
- en: A device method table
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备方法表
- en: A `DRIVER_MODULE` macro call
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRIVER_MODULE` 宏调用'
- en: device_foo Functions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: device_foo 函数
- en: The `device_foo` functions are, more or less, the operations executed by a Newbus
    driver during autoconfiguration. [Table 7-1](ch07.html#device_underscore_foo_functions-id1
    "Table 7-1. device_foo Functions") briefly introduces each `device_foo` function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_foo` 函数基本上是新型总线驱动程序在自动配置期间执行的操作。[表7-1](ch07.html#device_underscore_foo_functions-id1
    "表7-1. device_foo 函数")简要介绍了每个`device_foo`函数。'
- en: Table 7-1. device_foo Functions
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-1. device_foo 函数
- en: '| Function | Description |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `device_identify` | Add new device to I/O bus |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `device_identify` | 将新设备添加到I/O总线 |'
- en: '| `device_probe` | Probe for specific device(s) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `device_probe` | 检测特定设备 |'
- en: '| `device_attach` | Attach to device |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `device_attach` | 连接到设备 |'
- en: '| `device_detach` | Detach from device |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `device_detach` | 从设备断开连接 |'
- en: '| `device_shutdown` | Shut down device |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `device_shutdown` | 关闭设备 |'
- en: '| `device_suspend` | Device suspend requested |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `device_suspend` | 请求设备挂起 |'
- en: '| `device_resume` | Resume has occurred |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `device_resume` | 已发生恢复 |'
- en: The `device_identify` function adds a new device (instance) to an I/O bus. This
    function is used only by buses that cannot directly identify their children. Recall
    that autoconfiguration begins by identifying the child devices on each I/O bus.
    Modern buses can directly identify the devices that are connected to them. Older
    buses, such as ISA, have to use the `device_identify` routine provided by their
    associated drivers to identify their child devices (McKusick and Neville-Neil,
    2005). You’ll learn how to associate a driver with an I/O bus shortly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_identify` 函数向I/O总线添加一个新的设备（实例）。此函数仅用于无法直接识别其子设备的总线。回想一下，自动配置首先通过识别每个I/O总线上的子设备开始。现代总线可以直接识别连接到它们的设备。较老的总线，如ISA，必须使用它们相关驱动程序提供的`device_identify`例程来识别其子设备（McKusick和Neville-Neil，2005）。你将很快学习如何将驱动程序与I/O总线关联起来。'
- en: All identified child devices are passed to every Newbus driver’s `device_probe`
    function. A `device_probe` function tells the kernel whether its driver can handle
    the identified device.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有识别的子设备都传递给每个新型总线驱动程序的`device_probe`函数。`device_probe`函数告诉内核其驱动程序是否可以处理识别的设备。
- en: 'Note that there may be more than one driver that can handle an identified child
    device. Thus, `device_probe`’s return value is used to specify how well its driver
    matches the identified device. The `device_probe` function that returns the highest
    value denotes the best Newbus driver for the identified device. The following
    excerpt from `<sys/bus.h>` shows the constants used to indicate success (that
    is, a match):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能有多个驱动程序可以处理已识别的子设备。因此，`device_probe`的返回值用于指定其驱动程序与已识别设备的匹配程度。返回最高值的`device_probe`函数表示最适合已识别设备的最佳Newbus驱动程序。以下是从`<sys/bus.h>`中摘录的用于表示成功（即匹配）的常量：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, success codes are values less than or equal to zero. The standard
    UNIX error codes (that is, positive values) are used as failure codes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，成功代码是小于或等于零的值。标准的UNIX错误代码（即正值）用作失败代码。
- en: Once the best driver has been found to handle a device, its `device_attach`
    function is called. A `device_attach` function initializes a device and any essential
    software (for example, device nodes).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到处理设备的最佳驱动程序，就会调用其`device_attach`函数。`device_attach`函数初始化设备及其任何必要软件（例如，设备节点）。
- en: The `device_detach` function disconnects a driver from a device. This function
    should set the device to a sane state and release any resources that were allocated
    during `device_attach`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_detach`函数将驱动程序从设备断开连接。此函数应将设备设置为合理状态，并释放在`device_attach`期间分配的任何资源。'
- en: A Newbus driver’s `device_shutdown`, `device_suspend`, and `device_resume` functions
    are called when the system is shut down, when its device is suspended, or when
    its device returns from suspension, respectively. These functions let a driver
    manage its device as these events occur.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统关闭、其设备挂起或其设备从挂起状态恢复时，分别调用Newbus驱动的`device_shutdown`、`device_suspend`和`device_resume`函数。这些函数允许驱动程序在发生这些事件时管理其设备。
- en: Device Method Table
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备方法表
- en: A device method table, `device_method_t`, specifies which `device_foo` functions
    a Newbus driver implements. It is defined in the `<sys/bus.h>` header.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设备方法表，`device_method_t`，指定了Newbus驱动程序实现了哪些`device_foo`函数。它在`<sys/bus.h>`头文件中定义。
- en: 'Here is an example device method table for a fictitious PCI device:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个虚构PCI设备的示例设备方法表：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, not every `device_foo` function has to be defined. If a `device_foo`
    function is undefined, the corresponding operation is unsupported.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，并非每个`device_foo`函数都必须定义。如果一个`device_foo`函数未定义，则相应的操作不受支持。
- en: Unsurprisingly, the `device_probe` and `device_attach` functions must be defined
    for every Newbus driver. For drivers on older buses, the `device_identify` function
    must also be defined.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，每个Newbus驱动程序都必须定义`device_probe`和`device_attach`函数。对于旧总线的驱动程序，还必须定义`device_identify`函数。
- en: DRIVER_MODULE Macro
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRIVER_MODULE 宏
- en: 'The `DRIVER_MODULE` macro registers a Newbus driver with the system. This macro
    is defined in the `<sys/bus.h>` header. Here is its function prototype:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`DRIVER_MODULE`宏将Newbus驱动程序注册到系统中。此宏在`<sys/bus.h>`头文件中定义。以下是它的函数原型：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The arguments expected by this macro are as follows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏期望的参数如下。
- en: name
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: name
- en: The `name` argument is used to identify the driver.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`参数用于识别驱动程序。'
- en: busname
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: busname
- en: The `busname` argument specifies the driver’s I/O bus (for example, `isa`, `pci`,
    `usb`, and so on).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`busname`参数指定了驱动程序的I/O总线（例如，`isa`、`pci`、`usb`等）。'
- en: driver
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序
- en: 'The `driver` argument expects a filled-out `driver_t` structure. This argument
    is best understood with an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`driver`参数期望一个填充好的`driver_t`结构。此参数最好通过示例来理解：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `"foo_pci"` is
    this example driver’s official name, ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `foo_pci_methods` is its device method table, and ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `sizeof(struct foo_pci_softc)` is the size of its software context.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![foo_pci](httpatomoreillycomsourcenostarchimages1137499.png) `"foo_pci"`是本例驱动程序的官方名称，![foo_pci_methods](httpatomoreillycomsourcenostarchimages1137501.png)
    `foo_pci_methods`是其设备方法表，![foo_pci_softc_sizeof](httpatomoreillycomsourcenostarchimages1137503.png)
    `sizeof(struct foo_pci_softc)`是其软件上下文的大小。
- en: devclass
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: devclass
- en: The `devclass` argument expects an uninitialized `devclass_t` variable, which
    will be used by the kernel for internal bookkeeping.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`devclass`参数期望一个未初始化的`devclass_t`变量，内核将使用它进行内部记账。'
- en: evh
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: evh
- en: The `evh` argument denotes an optional module event handler. Generally, we’ll
    always set `evh` to `0`, because `DRIVER_MODULE` supplies its own module event
    handler.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`evh`参数表示一个可选的模块事件处理器。通常，我们会始终将`evh`设置为`0`，因为`DRIVER_MODULE`提供了自己的模块事件处理器。'
- en: arg
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: arg
- en: The `arg` argument is the `void *` argument for the module event handler specified
    by `evh`. If `evh` is set to `0`, `arg` must be too.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg` 参数是 `evh` 指定的事件处理程序的 `void *` 参数。如果 `evh` 设置为 `0`，则 `arg` 也必须为 `0`。'
- en: Tying Everything Together
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切联系在一起
- en: You now know enough to write your first Newbus driver. [Example 7-1](ch07s02.html#foo_underscore_pci.c
    "Example 7-1. foo_pci.c") is a simple Newbus driver (based on code written by
    Murray Stokely) for a fictitious PCI device.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经足够了解如何编写你的第一个 Newbus 驱动程序。[示例 7-1](ch07s02.html#foo_underscore_pci.c "示例
    7-1. foo_pci.c") 是一个简单的基于 Murray Stokely 编写的代码的虚构 PCI 设备的 Newbus 驱动程序。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take a quick look at this code and try to discern some of its structure. If
    you don’t understand all of it, don’t worry; an explanation follows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下这段代码，并尝试理解其结构。如果你不理解其中的所有内容，不要担心；解释将随后提供。
- en: Example 7-1. foo_pci.c
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1. foo_pci.c
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This driver begins by defining its ![](httpatomoreillycomsourcenostarchimages1137499.png)
    software context, which will maintain a ![](httpatomoreillycomsourcenostarchimages1137501.png)
    pointer to its device and the ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `cdev` returned by the ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `make_dev` call.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此驱动程序首先定义其 ![](httpatomoreillycomsourcenostarchimages1137499.png) 软件上下文，该上下文将维护对其设备和一个
    ![](httpatomoreillycomsourcenostarchimages1137503.png) `cdev` 的指针，该 `cdev` 是由
    ![](httpatomoreillycomsourcenostarchimages1137509.png) `make_dev` 调用返回的。
- en: Next, its ![](httpatomoreillycomsourcenostarchimages1137505.png) character device
    switch table is defined. This table contains four `d_foo` functions named `foo_pci_open`,
    `foo_pci_close`, `foo_pci_read`, and `foo_pci_write`. I’ll describe these functions
    in [d_foo Functions](ch01s05.html#d_underscore_foo_functions "d_foo Functions")
    in [d_foo Functions](ch07s02.html#d_underscore_foo_functions-id2 "d_foo Functions").
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义了其 ![](httpatomoreillycomsourcenostarchimages1137505.png) 字符设备切换表。此表包含四个名为
    `foo_pci_open`、`foo_pci_close`、`foo_pci_read` 和 `foo_pci_write` 的 `d_foo` 函数。我将在
    [d_foo 函数](ch01s05.html#d_underscore_foo_functions "d_foo 函数") 中描述这些函数。
- en: Then a ![](httpatomoreillycomsourcenostarchimages1137507.png) `devclass_t` variable
    is declared. This variable is passed to the ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `DRIVER_MODULE` macro as its ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `devclass` argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后声明了一个 ![](httpatomoreillycomsourcenostarchimages1137507.png) `devclass_t`
    变量。该变量作为其 ![](httpatomoreillycomsourcenostarchimages1137511.png) `devclass` 参数传递给
    ![](httpatomoreillycomsourcenostarchimages1137513.png) `DRIVER_MODULE` 宏。
- en: Finally, the `d_foo` and `device_foo` functions are defined. These functions
    are described in the order they would execute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义了 `d_foo` 和 `device_foo` 函数。这些函数将按照它们执行的顺序进行描述。
- en: foo_pci_probe Function
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foo_pci_probe 函数
- en: The `foo_pci_probe` function is the `device_probe` implementation for this driver.
    Before I walk through this function, a description of the `pci_ids` array (found
    around the middle of [Example 7-1](ch07s02.html#foo_underscore_pci.c "Example 7-1. foo_pci.c"))
    is needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo_pci_probe` 函数是该驱动程序的 `device_probe` 实现。在我详细说明此函数之前，需要描述 `pci_ids` 数组（位于
    [示例 7-1](ch07s02.html#foo_underscore_pci.c "示例 7-1. foo_pci.c")) 的描述。'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This array is composed of three `_pcsid` structures. Each `_pcsid` structure
    contains a ![](httpatomoreillycomsourcenostarchimages1137499.png) PCI ID and a
    ![](httpatomoreillycomsourcenostarchimages1137501.png) description of the PCI
    device. As you might have guessed, `pci_ids` lists the devices that [Example 7-1](ch07s02.html#foo_underscore_pci.c
    "Example 7-1. foo_pci.c") supports.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组由三个 `_pcsid` 结构组成。每个 `_pcsid` 结构包含一个 ![](httpatomoreillycomsourcenostarchimages1137499.png)
    PCI ID 和一个 ![](httpatomoreillycomsourcenostarchimages1137501.png) PCI 设备的描述。正如你可能猜到的，`pci_ids`
    列出了该设备支持的设备。
- en: Now that I’ve described `pci_ids`, let’s walk through `foo_pci_probe`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我已经描述了 `pci_ids`，让我们来看看 `foo_pci_probe`。
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` describes
    an identified device found on the PCI bus. So this function begins by ![](httpatomoreillycomsourcenostarchimages1137501.png)
    obtaining the PCI ID of `dev`. Then it ![](httpatomoreillycomsourcenostarchimages1137505.png)
    determines if `dev`’s PCI ID is listed in ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `pci_ids`. If it is, `dev`’s verbose description is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    set and the success code `BUS_PROBE_DEFAULT` is ![](httpatomoreillycomsourcenostarchimages1137509.png)
    returned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![图片](httpatomoreillycomsourcenostarchimages1137499.png) `dev` 描述了在 PCI
    总线上找到的已识别设备。因此，此函数首先 ![图片](httpatomoreillycomsourcenostarchimages1137501.png)
    获取 `dev` 的 PCI ID。然后它 ![图片](httpatomoreillycomsourcenostarchimages1137505.png)
    确定是否将 `dev` 的 PCI ID 列在 ![图片](httpatomoreillycomsourcenostarchimages1137503.png)
    `pci_ids` 中。如果是，则将 `dev` 的详细描述 ![图片](httpatomoreillycomsourcenostarchimages1137507.png)
    设置，并返回成功代码 `BUS_PROBE_DEFAULT` ![图片](httpatomoreillycomsourcenostarchimages1137509.png)。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The verbose description is printed to the system console when `foo_pci_attach`
    executes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `foo_pci_attach` 执行时，详细描述将打印到系统控制台。
- en: foo_pci_attach Function
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foo_pci_attach 函数
- en: 'The `foo_pci_attach` function is the `device_attach` implementation for this
    driver. Here is its function definition (again):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo_pci_attach` 函数是此驱动程序的 `device_attach` 实现。以下是它的函数定义（再次）：'
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` describes
    a device under this driver’s control. Thus, this function starts by getting `dev`’s
    ![](httpatomoreillycomsourcenostarchimages1137501.png) software context and ![](httpatomoreillycomsourcenostarchimages1137503.png)
    unit number. Then a character device node is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    created and the variables `sc->device` and `sc->cdev->si_drv1` are set to ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `dev` and ![](httpatomoreillycomsourcenostarchimages1137509.png) `sc`, respectively.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![图片](httpatomoreillycomsourcenostarchimages1137499.png) `dev` 表示该驱动程序控制下的设备。因此，此函数首先获取
    `dev` 的 ![图片](httpatomoreillycomsourcenostarchimages1137501.png) 软件上下文和 ![图片](httpatomoreillycomsourcenostarchimages1137503.png)
    单元号。然后创建一个字符设备节点，并将变量 `sc->device` 和 `sc->cdev->si_drv1` 分别设置为 ![图片](httpatomoreillycomsourcenostarchimages1137505.png)
    `dev` 和 ![图片](httpatomoreillycomsourcenostarchimages1137509.png) `sc`。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `d_foo` functions (described next) use `sc->device` and `cdev->si_drv1`
    to gain access to `dev` and `sc`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `d_foo` 函数（将在后面描述）使用 `sc->device` 和 `cdev->si_drv1` 来访问 `dev` 和 `sc`。
- en: d_foo Functions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: d_foo 函数
- en: 'Because every `d_foo` function in [Example 7-1](ch07s02.html#foo_underscore_pci.c
    "Example 7-1. foo_pci.c") just prints a debug message (that is to say, they’re
    all basically the same), I’m only going to walk through one of them: `foo_pci_open`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 [示例 7-1](ch07s02.html#foo_underscore_pci.c "示例 7-1. foo_pci.c") 中的每个 `d_foo`
    函数只是打印一条调试信息（也就是说，它们基本上都是相同的），所以我只将遍历其中一个：`foo_pci_open`。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` is the `cdev`
    returned by the `make_dev` call in `foo_pci_attach`. So, this function first ![](httpatomoreillycomsourcenostarchimages1137501.png)
    obtains its software context. Then it ![](httpatomoreillycomsourcenostarchimages1137503.png)
    prints a debug message.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![图片](httpatomoreillycomsourcenostarchimages1137499.png) `dev` 是 `foo_pci_attach`
    中的 `make_dev` 调用返回的 `cdev`。因此，此函数首先 ![图片](httpatomoreillycomsourcenostarchimages1137501.png)
    获取其软件上下文。然后它 ![图片](httpatomoreillycomsourcenostarchimages1137503.png) 打印一条调试信息。
- en: foo_pci_detach Function
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foo_pci_detach 函数
- en: 'The `foo_pci_detach` function is the `device_detach` implementation for this
    driver. Here is its function definition (again):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo_pci_detach` 函数是此驱动程序的 `device_detach` 实现。以下是它的函数定义（再次）：'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` describes
    a device under this driver’s control. Thus, this function simply obtains `dev`’s
    ![](httpatomoreillycomsourcenostarchimages1137501.png) software context to ![](httpatomoreillycomsourcenostarchimages1137503.png)
    destroy its device node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![图片](httpatomoreillycomsourcenostarchimages1137499.png) `dev` 表示该驱动程序控制下的设备。因此，此函数只是简单地获取
    `dev` 的 ![图片](httpatomoreillycomsourcenostarchimages1137501.png) 软件上下文来 ![图片](httpatomoreillycomsourcenostarchimages1137503.png)
    销毁其设备节点。
- en: Don’t Panic
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别慌
- en: 'Now that we’ve discussed [Example 7-1](ch07s02.html#foo_underscore_pci.c "Example 7-1. foo_pci.c"),
    let’s give it a try:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了 [示例 7-1](ch07s02.html#foo_underscore_pci.c "示例 7-1. foo_pci.c")，让我们试一试：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, it ![](httpatomoreillycomsourcenostarchimages1137499.png) fails miserably,
    because `foo_pci_probe` is probing for fictitious PCI devices. Before concluding
    this chapter, one additional topic bears mentioning.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它 ![图片](httpatomoreillycomsourcenostarchimages1137499.png) 完全失败，因为 `foo_pci_probe`
    正在探测虚构的 PCI 设备。在结束本章之前，还有一个额外的话题需要提及。
- en: Hardware Resource Management
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件资源管理
- en: As part of configuring and operating devices, a driver might need to manage
    hardware resources, such as interrupt-request lines (IRQs), I/O ports, or I/O
    memory (McKusick and Neville-Neil, 2005). Naturally, Newbus includes several functions
    for doing just that.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为配置和操作设备的一部分，驱动程序可能需要管理硬件资源，例如中断请求线（IRQs）、I/O 端口或 I/O 内存（McKusick 和 Neville-Neil，2005）。自然，Newbus
    包含了执行此操作所需的一些函数。
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `bus_alloc_resource` function allocates hardware resources for a specific
    device to use. If successful, a `struct resource` pointer is returned; otherwise,
    `NULL` is returned. This function is normally called during `device_attach`. If
    it is called during `device_probe`, all allocated resources must be released (via
    `bus_release_resource`) before returning. Most of the arguments for `bus_alloc_resource`
    are common to the other hardware resource management functions. These arguments
    are described in the next few paragraphs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_alloc_resource` 函数为特定设备分配硬件资源。如果成功，则返回一个 `struct resource` 指针；否则，返回 `NULL`。此函数通常在
    `device_attach` 期间调用。如果在 `device_probe` 期间调用，则在返回之前必须释放所有分配的资源（通过 `bus_release_resource`）。`bus_alloc_resource`
    的大多数参数与其他硬件资源管理函数的参数相同。这些参数将在接下来的几段中描述。'
- en: The `dev` argument is the device that requires ownership of the hardware resource(s).
    Before allocation, resources are owned by the parent bus.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev` 参数是需要拥有硬件资源（s）的设备。在分配之前，资源归父总线所有。'
- en: The `type` argument represents the type of resource `dev` wants allocated. Valid
    values for this argument are listed in [Table 7-2](ch07s03.html#symbolic_constants_for_hardware_resource
    "Table 7-2. Symbolic Constants for Hardware Resources").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 参数表示 `dev` 想要分配的资源类型。此参数的有效值列在 [表 7-2](ch07s03.html#symbolic_constants_for_hardware_resource
    "表 7-2. 硬件资源符号常量") 中。'
- en: Table 7-2. Symbolic Constants for Hardware Resources
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-2. 硬件资源符号常量
- en: '| Constant | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SYS_RES_IRQ` | Interrupt-request line |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `SYS_RES_IRQ` | 中断请求线 |'
- en: '| `SYS_RES_IOPORT` | I/O port |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `SYS_RES_IOPORT` | I/O 端口 |'
- en: '| `SYS_RES_MEMORY` | I/O memory |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `SYS_RES_MEMORY` | I/O 内存 |'
- en: The `rid` argument expects a resource ID (RID). If `bus_alloc_resource` is successful,
    a RID is returned in `rid` that may differ from what you passed. You’ll learn
    more about RIDs later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`rid` 参数期望一个资源 ID（RID）。如果 `bus_alloc_resource` 成功，则 `rid` 中返回的 RID 可能与您传递的
    RID 不同。您将在稍后了解更多关于 RID 的信息。'
- en: The `start` and `end` arguments are the start and end addresses of the hardware
    resource(s). To employ the default bus values, simply pass `0ul` as `start` and
    `˜0ul` as `end`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 和 `end` 参数是硬件资源（s）的起始和结束地址。要使用默认总线值，只需将 `start` 传递为 `0ul`，将 `end` 传递为
    `˜0ul`。'
- en: The `count` argument denotes the size of the hardware resource(s). If you used
    the default bus values for `start` and `end`, `count` is used only if it is larger
    than the default bus value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 参数表示硬件资源的大小。如果你使用了 `start` 和 `end` 的默认总线值，则只有在 `count` 大于默认总线值时才会使用
    `count`。'
- en: The `flags` argument details the characteristics of the hardware resource. Valid
    values for this argument are listed in [Table 7-3](ch07s03.html#bus_underscore_alloc_underscore_resource
    "Table 7-3. bus_alloc_resource Symbolic Constants").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags` 参数详细说明了硬件资源的特征。此参数的有效值列在 [表 7-3](ch07s03.html#bus_underscore_alloc_underscore_resource
    "表 7-3. `bus_alloc_resource` 符号常量") 中。'
- en: Table 7-3. bus_alloc_resource Symbolic Constants
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-3. `bus_alloc_resource` 符号常量
- en: '| Constant | Description |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `RF_ALLOCATED` | Allocate hardware resource, but don’t activate it |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `RF_ALLOCATED` | 分配硬件资源，但不激活它 |'
- en: '| `RF_ACTIVE` | Allocate hardware resource and activate resource automatically
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `RF_ACTIVE` | 分配硬件资源并自动激活资源 |'
- en: '| `RF_SHAREABLE` | Hardware resource permits contemporaneous sharing; you should
    always set this flag, unless the resource cannot be shared |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `RF_SHAREABLE` | 硬件资源允许同时共享；您应该始终设置此标志，除非资源不能共享 |'
- en: '| `RF_TIMESHARE` | Hardware resource permits time-division sharing |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `RF_TIMESHARE` | 硬件资源允许时分共享 |'
- en: The `bus_alloc_resource_any` function is a convenience wrapper for `bus_alloc_resource`
    that sets `start`, `end`, and `count` to their default bus values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_alloc_resource_any` 函数是 `bus_alloc_resource` 的便利包装器，它将 `start`、`end` 和
    `count` 设置为其默认总线值。'
- en: The `bus_activate_resource` function activates a previously allocated hardware
    resource. Naturally, resources must be activated before they can be used. Most
    drivers simply pass `RF_ACTIVE` to `bus_alloc_resource` or `bus_alloc_resource_any`
    to avoid calling `bus_activate_resource`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_activate_resource` 函数激活一个之前分配的硬件资源。自然，资源必须在使用之前被激活。大多数驱动程序只是简单地将`RF_ACTIVE`传递给`bus_alloc_resource`或`bus_alloc_resource_any`，以避免调用`bus_activate_resource`。'
- en: The `bus_deactivate_resource` function deactivates a hardware resource. This
    function is primarily used in bus drivers (so we’ll never call it).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_deactivate_resource` 函数使一个硬件资源失效。这个函数主要用于总线驱动程序（因此我们永远不会调用它）。'
- en: The `bus_release_resource` function releases a previously allocated hardware
    resource. Of course, the resource cannot be in use on release. If successful,
    `0` is returned; otherwise, the kernel panics.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_release_resource` 函数释放了一个之前分配的硬件资源。当然，在释放时资源不能处于使用状态。如果成功，返回`0`；否则，内核会崩溃。'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We’ll cover an example that employs IRQs in [Chapter 8](ch08.html "Chapter 8. Interrupt
    Handling") and [Chapter 9](ch09.html "Chapter 9. Case Study: Parallel Port Printer
    Driver"), and I’ll go over an example that requires I/O ports and I/O memory in
    [Chapter 10](ch10.html "Chapter 10. Managing and Using Resources") and [Chapter 11](ch11.html
    "Chapter 11. Case Study: Intelligent Platform Management Interface Driver").'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章（[第8章. 中断处理](ch08.html "第8章. 中断处理")）和第9章（[第9章. 案例研究：并行端口打印机驱动程序](ch09.html
    "第9章. 案例研究：并行端口打印机驱动程序")）中介绍使用中断的示例，我将在第10章（[第10章. 管理和使用资源](ch10.html "第10章. 管理和使用资源")）和第11章（[第11章.
    案例研究：智能平台管理接口驱动程序](ch11.html "第11章. 案例研究：智能平台管理接口驱动程序")）中介绍需要I/O端口和I/O内存的示例。
- en: Conclusion
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter introduced you to the basics of Newbus driver development— working
    with real hardware. The remainder of this book builds upon the concepts described
    here to complete your understanding of Newbus.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Newbus驱动程序开发的基础——与真实硬件一起工作。本书的其余部分将在此基础上构建，以完成您对Newbus的理解。
