- en: Chapter 7. Newbus and Resource Allocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 新型总线与资源分配
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: Until now, we’ve examined only pseudo-devices, which provide a superb introduction
    to driver writing. However, most drivers need to interact with real hardware.
    This chapter shows you how to write drivers that do just that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只检查了伪设备，它们为编写驱动程序提供了极好的介绍。然而，大多数驱动程序需要与真实硬件交互。本章将向您展示如何编写这样的驱动程序。
- en: I’ll start by introducing *Newbus*, which is the infrastructure used in FreeBSD
    to manage the hardware devices on the system (McKusick and Neville-Neil, 2005).
    I’ll then describe the basics of a Newbus driver, and I’ll conclude this chapter
    by talking about hardware resource allocation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先介绍 *新型总线*，这是FreeBSD用于管理系统硬件设备的底层架构（McKusick和Neville-Neil，2005）。然后，我将描述新型总线驱动程序的基本知识，并在本章结束时讨论硬件资源分配。
- en: Autoconfiguration and Newbus Drivers
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动配置与新型总线驱动程序
- en: '*Autoconfiguration* is the procedure carried out by FreeBSD to enable the hardware
    devices on a machine (McKusick and Neville-Neil, 2005). It works by systematically
    probing a machine’s I/O buses in order to identify their child devices. For each
    identified device, an appropriate Newbus driver is assigned to configure and initialize
    it. Note that it’s possible for a device to be unidentifiable or unsupported.
    As a result, no Newbus driver will be assigned.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动配置*是FreeBSD执行的过程，以启用机器上的硬件设备（McKusick和Neville-Neil，2005）。它通过系统地探测机器的I/O总线以识别其子设备来实现。对于每个识别的设备，都会分配一个适当的新型总线驱动程序来配置和初始化它。请注意，设备可能无法识别或不受支持。因此，不会分配任何新型总线驱动程序。'
- en: A *Newbus driver* is any driver in FreeBSD that controls a device that is bound
    to an I/O bus (that is, roughly every driver that is not a pseudo-device driver).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*新型总线驱动程序*是FreeBSD中任何控制绑定到I/O总线的设备（即，大致上不是伪设备驱动程序的每个驱动程序）的驱动程序。'
- en: 'In general, three components are common to all Newbus drivers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有新型总线驱动程序都包含以下三个组件：
- en: The `device_foo` functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_foo` 函数'
- en: A device method table
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备方法表
- en: A `DRIVER_MODULE` macro call
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRIVER_MODULE` 宏调用'
- en: device_foo Functions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: device_foo 函数
- en: The `device_foo` functions are, more or less, the operations executed by a Newbus
    driver during autoconfiguration. [Table 7-1](ch07.html#device_underscore_foo_functions-id1
    "Table 7-1. device_foo Functions") briefly introduces each `device_foo` function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_foo` 函数基本上是新型总线驱动程序在自动配置期间执行的操作。[表7-1](ch07.html#device_underscore_foo_functions-id1
    "表7-1. device_foo 函数")简要介绍了每个`device_foo`函数。'
- en: Table 7-1. device_foo Functions
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-1. device_foo 函数
- en: '| Function | Description |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `device_identify` | Add new device to I/O bus |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `device_identify` | 将新设备添加到I/O总线 |'
- en: '| `device_probe` | Probe for specific device(s) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `device_probe` | 检测特定设备 |'
- en: '| `device_attach` | Attach to device |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `device_attach` | 连接到设备 |'
- en: '| `device_detach` | Detach from device |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `device_detach` | 从设备断开连接 |'
- en: '| `device_shutdown` | Shut down device |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `device_shutdown` | 关闭设备 |'
- en: '| `device_suspend` | Device suspend requested |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `device_suspend` | 请求设备挂起 |'
- en: '| `device_resume` | Resume has occurred |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `device_resume` | 已发生恢复 |'
- en: The `device_identify` function adds a new device (instance) to an I/O bus. This
    function is used only by buses that cannot directly identify their children. Recall
    that autoconfiguration begins by identifying the child devices on each I/O bus.
    Modern buses can directly identify the devices that are connected to them. Older
    buses, such as ISA, have to use the `device_identify` routine provided by their
    associated drivers to identify their child devices (McKusick and Neville-Neil,
    2005). You’ll learn how to associate a driver with an I/O bus shortly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_identify` 函数向I/O总线添加一个新的设备（实例）。此函数仅用于无法直接识别其子设备的总线。回想一下，自动配置首先通过识别每个I/O总线上的子设备开始。现代总线可以直接识别连接到它们的设备。较老的总线，如ISA，必须使用它们相关驱动程序提供的`device_identify`例程来识别其子设备（McKusick和Neville-Neil，2005）。你将很快学习如何将驱动程序与I/O总线关联起来。'
- en: All identified child devices are passed to every Newbus driver’s `device_probe`
    function. A `device_probe` function tells the kernel whether its driver can handle
    the identified device.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有识别的子设备都传递给每个新型总线驱动程序的`device_probe`函数。`device_probe`函数告诉内核其驱动程序是否可以处理识别的设备。
- en: 'Note that there may be more than one driver that can handle an identified child
    device. Thus, `device_probe`’s return value is used to specify how well its driver
    matches the identified device. The `device_probe` function that returns the highest
    value denotes the best Newbus driver for the identified device. The following
    excerpt from `<sys/bus.h>` shows the constants used to indicate success (that
    is, a match):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, success codes are values less than or equal to zero. The standard
    UNIX error codes (that is, positive values) are used as failure codes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Once the best driver has been found to handle a device, its `device_attach`
    function is called. A `device_attach` function initializes a device and any essential
    software (for example, device nodes).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The `device_detach` function disconnects a driver from a device. This function
    should set the device to a sane state and release any resources that were allocated
    during `device_attach`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: A Newbus driver’s `device_shutdown`, `device_suspend`, and `device_resume` functions
    are called when the system is shut down, when its device is suspended, or when
    its device returns from suspension, respectively. These functions let a driver
    manage its device as these events occur.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Device Method Table
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A device method table, `device_method_t`, specifies which `device_foo` functions
    a Newbus driver implements. It is defined in the `<sys/bus.h>` header.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example device method table for a fictitious PCI device:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, not every `device_foo` function has to be defined. If a `device_foo`
    function is undefined, the corresponding operation is unsupported.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Unsurprisingly, the `device_probe` and `device_attach` functions must be defined
    for every Newbus driver. For drivers on older buses, the `device_identify` function
    must also be defined.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: DRIVER_MODULE Macro
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DRIVER_MODULE` macro registers a Newbus driver with the system. This macro
    is defined in the `<sys/bus.h>` header. Here is its function prototype:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The arguments expected by this macro are as follows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: name
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `name` argument is used to identify the driver.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: busname
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `busname` argument specifies the driver’s I/O bus (for example, `isa`, `pci`,
    `usb`, and so on).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: driver
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `driver` argument expects a filled-out `driver_t` structure. This argument
    is best understood with an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `"foo_pci"` is
    this example driver’s official name, ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `foo_pci_methods` is its device method table, and ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `sizeof(struct foo_pci_softc)` is the size of its software context.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: devclass
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `devclass` argument expects an uninitialized `devclass_t` variable, which
    will be used by the kernel for internal bookkeeping.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: evh
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `evh` argument denotes an optional module event handler. Generally, we’ll
    always set `evh` to `0`, because `DRIVER_MODULE` supplies its own module event
    handler.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: arg
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `arg` argument is the `void *` argument for the module event handler specified
    by `evh`. If `evh` is set to `0`, `arg` must be too.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Tying Everything Together
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now know enough to write your first Newbus driver. [Example 7-1](ch07s02.html#foo_underscore_pci.c
    "Example 7-1. foo_pci.c") is a simple Newbus driver (based on code written by
    Murray Stokely) for a fictitious PCI device.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a quick look at this code and try to discern some of its structure. If
    you don’t understand all of it, don’t worry; an explanation follows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1. foo_pci.c
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This driver begins by defining its ![](httpatomoreillycomsourcenostarchimages1137499.png)
    software context, which will maintain a ![](httpatomoreillycomsourcenostarchimages1137501.png)
    pointer to its device and the ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `cdev` returned by the ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `make_dev` call.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Next, its ![](httpatomoreillycomsourcenostarchimages1137505.png) character device
    switch table is defined. This table contains four `d_foo` functions named `foo_pci_open`,
    `foo_pci_close`, `foo_pci_read`, and `foo_pci_write`. I’ll describe these functions
    in [d_foo Functions](ch01s05.html#d_underscore_foo_functions "d_foo Functions")
    in [d_foo Functions](ch07s02.html#d_underscore_foo_functions-id2 "d_foo Functions").
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Then a ![](httpatomoreillycomsourcenostarchimages1137507.png) `devclass_t` variable
    is declared. This variable is passed to the ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `DRIVER_MODULE` macro as its ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `devclass` argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `d_foo` and `device_foo` functions are defined. These functions
    are described in the order they would execute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: foo_pci_probe Function
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `foo_pci_probe` function is the `device_probe` implementation for this driver.
    Before I walk through this function, a description of the `pci_ids` array (found
    around the middle of [Example 7-1](ch07s02.html#foo_underscore_pci.c "Example 7-1. foo_pci.c"))
    is needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This array is composed of three `_pcsid` structures. Each `_pcsid` structure
    contains a ![](httpatomoreillycomsourcenostarchimages1137499.png) PCI ID and a
    ![](httpatomoreillycomsourcenostarchimages1137501.png) description of the PCI
    device. As you might have guessed, `pci_ids` lists the devices that [Example 7-1](ch07s02.html#foo_underscore_pci.c
    "Example 7-1. foo_pci.c") supports.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Now that I’ve described `pci_ids`, let’s walk through `foo_pci_probe`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` describes
    an identified device found on the PCI bus. So this function begins by ![](httpatomoreillycomsourcenostarchimages1137501.png)
    obtaining the PCI ID of `dev`. Then it ![](httpatomoreillycomsourcenostarchimages1137505.png)
    determines if `dev`’s PCI ID is listed in ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `pci_ids`. If it is, `dev`’s verbose description is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    set and the success code `BUS_PROBE_DEFAULT` is ![](httpatomoreillycomsourcenostarchimages1137509.png)
    returned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The verbose description is printed to the system console when `foo_pci_attach`
    executes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: foo_pci_attach Function
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `foo_pci_attach` function is the `device_attach` implementation for this
    driver. Here is its function definition (again):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` describes
    a device under this driver’s control. Thus, this function starts by getting `dev`’s
    ![](httpatomoreillycomsourcenostarchimages1137501.png) software context and ![](httpatomoreillycomsourcenostarchimages1137503.png)
    unit number. Then a character device node is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    created and the variables `sc->device` and `sc->cdev->si_drv1` are set to ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `dev` and ![](httpatomoreillycomsourcenostarchimages1137509.png) `sc`, respectively.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `d_foo` functions (described next) use `sc->device` and `cdev->si_drv1`
    to gain access to `dev` and `sc`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: d_foo Functions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because every `d_foo` function in [Example 7-1](ch07s02.html#foo_underscore_pci.c
    "Example 7-1. foo_pci.c") just prints a debug message (that is to say, they’re
    all basically the same), I’m only going to walk through one of them: `foo_pci_open`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` is the `cdev`
    returned by the `make_dev` call in `foo_pci_attach`. So, this function first ![](httpatomoreillycomsourcenostarchimages1137501.png)
    obtains its software context. Then it ![](httpatomoreillycomsourcenostarchimages1137503.png)
    prints a debug message.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: foo_pci_detach Function
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `foo_pci_detach` function is the `device_detach` implementation for this
    driver. Here is its function definition (again):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `dev` describes
    a device under this driver’s control. Thus, this function simply obtains `dev`’s
    ![](httpatomoreillycomsourcenostarchimages1137501.png) software context to ![](httpatomoreillycomsourcenostarchimages1137503.png)
    destroy its device node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Panic
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve discussed [Example 7-1](ch07s02.html#foo_underscore_pci.c "Example 7-1. foo_pci.c"),
    let’s give it a try:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, it ![](httpatomoreillycomsourcenostarchimages1137499.png) fails miserably,
    because `foo_pci_probe` is probing for fictitious PCI devices. Before concluding
    this chapter, one additional topic bears mentioning.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Resource Management
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of configuring and operating devices, a driver might need to manage
    hardware resources, such as interrupt-request lines (IRQs), I/O ports, or I/O
    memory (McKusick and Neville-Neil, 2005). Naturally, Newbus includes several functions
    for doing just that.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `bus_alloc_resource` function allocates hardware resources for a specific
    device to use. If successful, a `struct resource` pointer is returned; otherwise,
    `NULL` is returned. This function is normally called during `device_attach`. If
    it is called during `device_probe`, all allocated resources must be released (via
    `bus_release_resource`) before returning. Most of the arguments for `bus_alloc_resource`
    are common to the other hardware resource management functions. These arguments
    are described in the next few paragraphs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `dev` argument is the device that requires ownership of the hardware resource(s).
    Before allocation, resources are owned by the parent bus.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The `type` argument represents the type of resource `dev` wants allocated. Valid
    values for this argument are listed in [Table 7-2](ch07s03.html#symbolic_constants_for_hardware_resource
    "Table 7-2. Symbolic Constants for Hardware Resources").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2. Symbolic Constants for Hardware Resources
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `SYS_RES_IRQ` | Interrupt-request line |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `SYS_RES_IOPORT` | I/O port |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `SYS_RES_MEMORY` | I/O memory |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: The `rid` argument expects a resource ID (RID). If `bus_alloc_resource` is successful,
    a RID is returned in `rid` that may differ from what you passed. You’ll learn
    more about RIDs later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The `start` and `end` arguments are the start and end addresses of the hardware
    resource(s). To employ the default bus values, simply pass `0ul` as `start` and
    `˜0ul` as `end`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The `count` argument denotes the size of the hardware resource(s). If you used
    the default bus values for `start` and `end`, `count` is used only if it is larger
    than the default bus value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The `flags` argument details the characteristics of the hardware resource. Valid
    values for this argument are listed in [Table 7-3](ch07s03.html#bus_underscore_alloc_underscore_resource
    "Table 7-3. bus_alloc_resource Symbolic Constants").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-3. bus_alloc_resource Symbolic Constants
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '| Constant | Description |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `RF_ALLOCATED` | Allocate hardware resource, but don’t activate it |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `RF_ACTIVE` | Allocate hardware resource and activate resource automatically
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `RF_SHAREABLE` | Hardware resource permits contemporaneous sharing; you should
    always set this flag, unless the resource cannot be shared |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `RF_TIMESHARE` | Hardware resource permits time-division sharing |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: The `bus_alloc_resource_any` function is a convenience wrapper for `bus_alloc_resource`
    that sets `start`, `end`, and `count` to their default bus values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The `bus_activate_resource` function activates a previously allocated hardware
    resource. Naturally, resources must be activated before they can be used. Most
    drivers simply pass `RF_ACTIVE` to `bus_alloc_resource` or `bus_alloc_resource_any`
    to avoid calling `bus_activate_resource`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_activate_resource` 函数激活一个之前分配的硬件资源。自然，资源必须在使用之前被激活。大多数驱动程序只是简单地将`RF_ACTIVE`传递给`bus_alloc_resource`或`bus_alloc_resource_any`，以避免调用`bus_activate_resource`。'
- en: The `bus_deactivate_resource` function deactivates a hardware resource. This
    function is primarily used in bus drivers (so we’ll never call it).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_deactivate_resource` 函数使一个硬件资源失效。这个函数主要用于总线驱动程序（因此我们永远不会调用它）。'
- en: The `bus_release_resource` function releases a previously allocated hardware
    resource. Of course, the resource cannot be in use on release. If successful,
    `0` is returned; otherwise, the kernel panics.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_release_resource` 函数释放了一个之前分配的硬件资源。当然，在释放时资源不能处于使用状态。如果成功，返回`0`；否则，内核会崩溃。'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We’ll cover an example that employs IRQs in [Chapter 8](ch08.html "Chapter 8. Interrupt
    Handling") and [Chapter 9](ch09.html "Chapter 9. Case Study: Parallel Port Printer
    Driver"), and I’ll go over an example that requires I/O ports and I/O memory in
    [Chapter 10](ch10.html "Chapter 10. Managing and Using Resources") and [Chapter 11](ch11.html
    "Chapter 11. Case Study: Intelligent Platform Management Interface Driver").'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章（[第8章. 中断处理](ch08.html "第8章. 中断处理")）和第9章（[第9章. 案例研究：并行端口打印机驱动程序](ch09.html
    "第9章. 案例研究：并行端口打印机驱动程序")）中介绍使用中断的示例，我将在第10章（[第10章. 管理和使用资源](ch10.html "第10章. 管理和使用资源")）和第11章（[第11章.
    案例研究：智能平台管理接口驱动程序](ch11.html "第11章. 案例研究：智能平台管理接口驱动程序")）中介绍需要I/O端口和I/O内存的示例。
- en: Conclusion
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter introduced you to the basics of Newbus driver development— working
    with real hardware. The remainder of this book builds upon the concepts described
    here to complete your understanding of Newbus.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Newbus驱动程序开发的基础——与真实硬件一起工作。本书的其余部分将在此基础上构建，以完成您对Newbus的理解。
