- en: Chapter 0x200. PROGRAMMING
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第0x200章。 编程
- en: '*Hacker* is a term for both those who write code and those who exploit it.
    Even though these two groups of hackers have different end goals, both groups
    use similar problem-solving techniques. Since an understanding of programming
    helps those who exploit, and an understanding of exploitation helps those who
    program, many hackers do both. There are interesting hacks found in both the techniques
    used to write elegant code and the techniques used to exploit programs. Hacking
    is really just the act of finding a clever and counterintuitive solution to a
    problem.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*黑客*这个词既指编写代码的人，也指利用它的人。尽管这两个黑客群体有不同的最终目标，但两组都使用类似的问题解决技术。由于理解编程有助于那些利用它的人，而理解利用有助于那些编程的人，许多黑客都两者兼顾。在编写优雅代码的技术和利用程序的技术中，都发现了有趣的黑客技巧。黑客实际上只是找到对问题的一种巧妙且反直觉的解决方案的行为。'
- en: The hacks found in program exploits usually use the rules of the computer to
    bypass security in ways never intended. Programming hacks are similar in that
    they also use the rules of the computer in new and inventive ways, but the final
    goal is efficiency or smaller source code, not necessarily a security compromise.
    There are actually an infinite number of programs that can be written to accomplish
    any given task, but most of these solutions are unnecessarily large, complex,
    and sloppy. The few solutions that remain are small, efficient, and neat. Programs
    that have these qualities are said to have *elegance*, and the clever and inventive
    solutions that tend to lead to this efficiency are called *hacks*. Hackers on
    both sides of programming appreciate both the beauty of elegant code and the ingenuity
    of clever hacks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序漏洞中发现的黑客攻击通常使用计算机的规则以从未打算过的方式绕过安全措施。编程黑客在这一点上相似，它们也以新的和创造性的方式使用计算机的规则，但最终目标是效率或更小的源代码，而不一定是安全妥协。实际上，有无限多的程序可以编写来完成任何给定的任务，但其中大多数解决方案都是不必要的大、复杂和杂乱。剩下的少数解决方案则是小、高效和整洁的。具有这些品质的程序被称为*优雅*，而倾向于导致这种效率的巧妙和创造性的解决方案被称为*黑客*。编程两边的黑客都欣赏优雅代码的美丽和巧妙黑客的独创性。
- en: In the business world, more importance is placed on churning out functional
    code than on achieving clever hacks and elegance. Because of the tremendous exponential
    growth of computational power and memory, spending an extra five hours to create
    a slightly faster and more memory efficient piece of code just doesn't make business
    sense when dealing with modern computers that have gigahertz of processing cycles
    and gigabytes of memory. While time and memory optimizations go without notice
    by all but the most sophisticated of users, a new feature is marketable. When
    the bottom line is money, spending time on clever hacks for optimization just
    doesn't make sense.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业界，人们更重视快速生成功能代码，而不是实现巧妙黑客和优雅。由于计算能力和内存的指数级增长，在处理具有千兆赫兹处理周期和千兆字节内存的现代计算机时，额外花费五个小时来创建稍微快一些和更高效的代码在商业上是没有意义的。尽管时间和内存优化对除了最复杂的用户之外的所有用户来说都是不言而喻的，但新功能是可销售的。当底线是金钱时，在优化上花费时间进行巧妙黑客攻击是没有意义的。
- en: 'True appreciation of programming elegance is left for the hackers: computer
    hobbyists whose end goal isn''t to make a profit but to squeeze every possible
    bit of functionality out of their old Commodore 64s, exploit writers who need
    to write tiny and amazing pieces of code to slip through narrow security cracks,
    and anyone else who appreciates the pursuit and the challenge of finding the best
    possible solution. These are the people who get excited about programming and
    really appreciate the beauty of an elegant piece of code or the ingenuity of a
    clever hack. Since an understanding of programming is a prerequisite to understanding
    how programs can be exploited, programming is a natural starting point.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 真正欣赏编程优雅之处的是黑客们：这些是电脑爱好者，他们的最终目标不是盈利，而是从他们的老式Commodore 64中榨取每一丝可能的功能，需要编写微小而惊人的代码以穿过狭窄的安全缝隙的漏洞制造者，以及任何其他欣赏追求和挑战找到最佳解决方案的人。这些人会对编程感到兴奋，并真正欣赏优雅代码的美丽或巧妙黑客的独创性。由于理解编程是理解程序如何被利用的先决条件，因此编程是一个自然的起点。
- en: What Is Programming?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是编程？
- en: 'Programming is a very natural and intuitive concept. A program is nothing more
    than a series of statements written in a specific language. Programs are everywhere,
    and even the technophobes of the world use programs every day. Driving directions,
    cooking recipes, football plays, and DNA are all types of programs. A typical
    program for driving directions might look something like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是一个非常自然和直观的概念。程序不过是一系列用特定语言编写的语句。程序无处不在，甚至世界上的技术恐惧者每天都在使用程序。驾驶指示、烹饪食谱、足球战术和DNA都是程序的类型。一个典型的驾驶指示程序可能看起来像这样：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Anyone who knows English can understand and follow these driving directions,
    since they're written in English. Granted, they're not eloquent, but each instruction
    is clear and easy to understand, at least for someone who reads English.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任何懂英语的人都能理解并遵循这些驾驶指示，因为它们是用英语写的。诚然，它们并不优雅，但每个指令都很清晰，易于理解，至少对于阅读英语的人来说是这样的。
- en: But a computer doesn't natively understand English; it only understands machine
    language. To instruct a computer to do something, the instructions must be written
    in its language. However, *machine language* is arcane and difficult to work with—it
    consists of raw bits and bytes, and it differs from architecture to architecture.
    To write a program in machine language for an Intel *x*86 processor, you would
    have to figure out the value associated with each instruction, how each instruction
    interacts, and myriad low-level details. Programming like this is painstaking
    and cumbersome, and it is certainly not intuitive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但计算机本身并不理解英语；它只理解机器语言。要指示计算机做某事，指令必须用它的语言编写。然而，*机器语言*是晦涩难懂的，难以操作——它由原始的比特和字节组成，并且因架构而异。要为Intel
    *x*86处理器编写机器语言的程序，你必须找出每个指令的值，每个指令如何交互，以及无数的底层细节。这样的编程既费力又繁琐，当然不是直观的。
- en: What's needed to overcome the complication of writing machine language is a
    translator. An *assembler* is one form of machine-language translator—it is a
    program that translates assembly language into machine-readable code. *Assembly
    language* is less cryptic than machine language, since it uses names for the different
    instructions and variables, instead of just using numbers. However, assembly language
    is still far from intuitive. The instruction names are very esoteric, and the
    language is architecture specific. Just as machine language for Intel *x*86 processors
    is different from machine language for Sparc processors, *x*86 assembly language
    is different from Sparc assembly language. Any program written using assembly
    language for one processor's architecture will not work on another processor's
    architecture. If a program is written in *x*86 assembly language, it must be rewritten
    to run on Sparc architecture. In addition, in order to write an effective program
    in assembly language, you must still know many low-level details of the processor
    architecture you are writing for.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要克服编写机器语言的复杂性，需要一个翻译器。*汇编器*是机器语言翻译器的一种形式——它是一个将汇编语言翻译成机器可读代码的程序。*汇编语言*比机器语言更易于理解，因为它使用不同的指令和变量名，而不是仅仅使用数字。然而，汇编语言仍然离直观性很远。指令名非常晦涩，且语言是针对特定架构的。正如Intel
    *x*86处理器的机器语言与Sparc处理器的机器语言不同一样，*x*86汇编语言与Sparc汇编语言也不同。使用某一处理器架构编写的汇编语言程序在另一处理器架构上无法运行。如果程序是用*x*86汇编语言编写的，它必须重写以在Sparc架构上运行。此外，为了有效地编写汇编语言程序，你仍然需要了解你正在编写的处理器架构的许多底层细节。
- en: These problems can be mitigated by yet another form of translator called a compiler.
    A *compiler* converts a high-level language into machine language. High-level
    languages are much more intuitive than assembly language and can be converted
    into many different types of machine language for different processor architectures.
    This means that if a program is written in a high level language, the program
    only needs to be written once; the same piece of program code can be compiled
    into machine language for various specific architectures. C, C++, and Fortran
    are all examples of high-level languages. A program written in a high-level language
    is much more readable and English-like than assembly language or machine language,
    but it still must follow very strict rules about how the instructions are worded,
    or the compiler won't be able to understand it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以通过另一种称为编译器的翻译器来解决。*编译器*将高级语言转换为机器语言。高级语言比汇编语言更直观，并且可以转换为针对不同处理器架构的许多不同类型的机器语言。这意味着如果程序是用高级语言编写的，那么程序只需要编写一次；相同的程序代码可以被编译成适用于各种特定架构的机器语言。C、C++和Fortran都是高级语言的例子。用高级语言编写的程序比汇编语言或机器语言更易于阅读，更像英语，但它仍然必须遵循非常严格的关于指令措辞的规则，否则编译器将无法理解它。
- en: Pseudo-code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pseudo-code
- en: Programmers have yet another form of programming language called pseudo-code.
    *Pseudo-code* is simply English arranged with a general structure similar to a
    high-level language. It isn't understood by compilers, assemblers, or any computers,
    but it is a useful way for a programmer to arrange instructions. Pseudo-code isn't
    well defined; in fact, most people write pseudo-code slightly differently. It's
    sort of the nebulous missing link between English and high-level programming languages
    like C. Pseudo-code makes for an excellent introduction to common universal programming
    concepts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员还有一种编程语言的形态，称为伪代码。*伪代码*只是用类似于高级语言的通用结构排列的英语。它不被编译器、汇编器或任何计算机理解，但它是一种程序员安排指令的有用方式。伪代码没有明确的定义；事实上，大多数人写的伪代码略有不同。它有点像是英语和像C这样的高级编程语言之间的模糊的缺失环节。伪代码是介绍通用编程概念的绝佳方式。
- en: Control Structures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: Without control structures, a program would just be a series of instructions
    executed in sequential order. This is fine for very simple programs, but most
    programs, like the driving directions example, aren't that simple. The driving
    directions included statements like, *Continue on Main Street until you see a
    church on your right* and *If the street is blocked because of construction*….
    These statements are known as *control structures*, and they change the flow of
    the program's execution from a simple sequential order to a more complex and more
    useful flow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有控制结构，程序就只是一系列按顺序执行的指令。这对于非常简单的程序来说是可以的，但大多数程序，如驾驶指南示例，并不那么简单。驾驶指南中包含了诸如“*继续沿Main
    Street行驶，直到你看到右手边的教堂*”和“*如果街道因施工而堵塞*”之类的语句……这些语句被称为*控制结构*，它们改变了程序执行流程，从简单的顺序执行转变为更复杂、更有用的流程。
- en: If-Then-Else
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: If-Then-Else
- en: 'In the case of our driving directions, Main Street could be under construction.
    If it is, a special set of instructions needs to address that situation. Otherwise,
    the original set of instructions should be followed. These types of special cases
    can be accounted for in a program with one of the most natural controlstructures:
    the *if-then-else structure*. In general, it looks something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的驾驶指南中，Main Street可能会在施工中。如果是这样，就需要一套特殊的指令来处理这种情况。否则，应遵循原始的指令集。这些特殊的情况可以通过程序中的最自然的控制结构之一来处理：*if-then-else结构*。一般来说，它看起来像这样：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For this book, a C-like pseudo-code will be used, so every instruction will
    end with a semicolon, and the sets of instructions will be grouped with curly
    braces and indentation. The if-then-else pseudo-code structure of the preceding
    driving directions might look something like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将使用类似C语言的伪代码，因此每条指令都将以分号结束，指令集将通过花括号和缩进来分组。前面提到的驾驶指南的if-then-else伪代码结构可能看起来像这样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each instruction is on its own line, and the various sets of conditional instructions
    are grouped between curly braces and indented for readability. In C and many other
    programming languages, the `then` keyword is implied and therefore left out, so
    it has also been omitted in the preceding pseudo-code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令都在单独的一行上，各种条件指令集被大括号包围并缩进以提高可读性。在C语言和许多其他编程语言中，`then`关键字是隐含的，因此省略了，所以在前面的伪代码中也没有包含。
- en: Of course, other languages require the `then` keyword in their syntax— BASIC,
    Fortran, and even Pascal, for example. These types of syntactical differences
    in programming languages are only skin deep; the underlying structure is still
    the same. Once a programmer understands the concepts these languages are trying
    to convey, learning the various syntactical variations is fairly trivial. Since
    C will be used in the later sections, the pseudo code used in this book will follow
    a C-like syntax, but remember that pseudo-code can take on many forms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，其他语言在它们的语法中需要`then`关键字——例如BASIC、Fortran和Pascal。这些编程语言中的语法差异只是表面现象；底层结构仍然是相同的。一旦程序员理解了这些语言试图传达的概念，学习各种语法变体就相对简单。由于本书后面的部分将使用C语言，所以本书中使用的伪代码将遵循C语言类似的语法，但请记住，伪代码可以有多种形式。
- en: 'Another common rule of C-like syntax is when a set of instructions bounded
    by curly braces consists of just one instruction, the curly braces are optional.
    For the sake of readability, it''s still a good idea to indent these instructions,
    but it''s not syntactically necessary. The driving directions from before can
    be rewritten following this rule to produce an equivalent piece of pseudo-code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C语言类似语法中另一个常见的规则是，当由大括号包围的指令集只包含一个指令时，大括号是可选的。为了提高可读性，仍然建议缩进这些指令，但这在语法上不是必需的。根据这个规则，之前的驾驶指南可以被重写为等价的伪代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This rule about sets of instructions holds true for all of the control structures
    mentioned in this book, and the rule itself can be described in pseudo-code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这条关于指令集的规则适用于本书中提到的所有控制结构，并且该规则本身可以用伪代码来描述。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Even the description of a syntax itself can be thought of as a simple program.
    There are variations of if-then-else, such as select/case statements, but the
    logic is still basically the same: If this happens do these things, otherwise
    do these other things (which could consist of even more if-then statements).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 语法本身的描述也可以被视为一个简单的程序。if-then-else有各种变体，例如select/case语句，但逻辑基本上是相同的：如果发生这种情况就做这些事情，否则做其他事情（这可能包括更多的if-then语句）。
- en: While/Until Loops
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: While/Until Loops
- en: 'Another elementary programming concept is the while control structure, which
    is a type of loop. A programmer will often want to execute a set of instructions
    more than once. A program can accomplish this task through looping, but it requires
    a set of conditions that tells it when to stop looping, lest it continue into
    infinity. A *while loop* says to execute the following set of instructions in
    a loop *while* a condition is true. A simple program for a hungry mouse could
    look something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基本的编程概念是while控制结构，它是一种循环。程序员经常希望多次执行一组指令。程序可以通过循环来完成这个任务，但这需要一组条件来告诉它何时停止循环，否则它将无限期地继续。一个*while循环*告诉在条件为真时循环执行以下指令集。一个简单的饥饿鼠标程序可能看起来像这样：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The set of two instructions following the while statement will be repeated *while*
    the mouse is still hungry. The amount of food the mouse finds each time could
    range from a tiny crumb to an entire loaf of bread. Similarly, the number of times
    the set of instructions in the while statement is executed changes depending on
    how much food the mouse finds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在while语句之后的两个指令集将会在鼠标仍然饥饿的情况下重复执行。鼠标每次找到的食物量可能从一小块面包屑到一整条面包不等。同样，while语句中的指令集执行次数取决于鼠标找到的食物量。
- en: 'Another variation on the while loop is an until loop, a syntax that is available
    in the programming language Perl (C doesn''t use this syntax). An *until loop*
    is simply a while loop with the conditional statement inverted. The same mouse
    program using an until loop would be:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: while循环的另一种变体是until循环，这种语法在编程语言Perl中可用（C语言不使用这种语法）。一个*until循环*实际上是一个条件语句反转的while循环。使用until循环的相同鼠标程序可能是这样的：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Logically, any until-like statement can be converted into a while loop. The
    driving directions from before contained the statement *Continue on Main Street
    until you see a church on your right*. This can easily be changed into a standard
    while loop by simply inverting the condition.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，任何类似until的语句都可以转换成while循环。之前的驾驶指示中包含有*Continue on Main Street until you
    see a church on your right*（继续在主街上行驶，直到你看到右边的教堂）这样的语句。通过简单地反转条件，可以轻松地将其转换为标准的while循环。
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For Loops
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: For循环
- en: 'Another looping control structure is the *for loop*. This is generally used
    when a programmer wants to loop for a certain number of iterations. The driving
    direction *Drive straight down Destination Road for 5 miles* could be converted
    to a for loop that looks something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种循环控制结构是*for循环*。这通常用于程序员想要循环一定次数的情况。例如，*Drive straight down Destination Road
    for 5 miles*（直行下目的地道路5英里）可以转换为一个类似以下的for循环：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In reality, a for loop is just a while loop with a counter. The same statement
    can be written as such:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，for循环只是一个带有计数器的while循环。同样的语句可以写成如下形式：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The C-like pseudo-code syntax of a for loop makes this even more apparent:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C样式的伪代码语法使得for循环的这种特性更加明显：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, the counter is called `i`, and the for statement is broken up
    into three sections, separated by semicolons. The first section declares the counter
    and sets it to its initial value, in this case 0\. The second section is like
    a while statement using the counter: *While* the counter meets this condition,
    keep looping. The third and final section describes what action should be taken
    on the counter during each iteration. In this case, `i++` is a shorthand way of
    saying, *Add 1 to the counter called i*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，计数器被称为`i`，for语句被分成三个部分，由分号分隔。第一部分声明计数器并将其设置为初始值，在这种情况下是0。第二部分类似于使用计数器的while语句：*While*计数器满足这个条件，继续循环。第三部分和最后一部分描述了在每次迭代期间应该对计数器执行什么操作。在这种情况下，`i++`是一个简写方式，表示*将计数器i的值加1*。
- en: 'Using all of the control structures, the driving directions from [What Is Programming?](ch02.html#what_is_programming
    "What Is Programming?") can be converted into a C-like pseudo-code that looks
    something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有的控制结构，[什么是编程？](ch02.html#what_is_programming "什么是编程？")中的驾驶指示可以转换成类似以下的C样式的伪代码：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: More Fundamental Programming Concepts
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更基本的编程概念
- en: In the following sections, more universal programming concepts will be introduced.
    These concepts are used in many programming languages, with a few syntactical
    differences. As I introduce these concepts, I will integrate them into pseudo-code
    examples using C-like syntax. By the end, the pseudo code should look very similar
    to C code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将介绍更多通用的编程概念。这些概念在许多编程语言中使用，只有一些语法上的差异。在介绍这些概念时，我将使用C样式的语法将它们整合到伪代码示例中。最终，伪代码应该看起来非常类似于C代码。
- en: Variables
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: The counter used in the for loop is actually a type of variable. A *variable*
    can simply be thought of as an object that holds data that can be changed— hence
    the name. There are also variables that don't change, which are aptly called *constants*.
    Returning to the driving example, the speed of the car would be a variable, while
    the color of the car would be a constant. In pseudo code, variables are simple
    abstract concepts, but in C (and in many other languages), variables must be declared
    and given a type before they can be used. This is because a C program will eventually
    be compiled into an executable program. Like a cooking recipe that lists all the
    required ingredients before giving the instructions, variable declarations allow
    you to make preparations before getting into the meat of the program. Ultimately,
    all variables are stored in memory somewhere, and their declarations allow the
    compiler to organize this memory more efficiently. In the end though, despite
    all of the variable type declarations, everything is all just memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在for循环中使用的计数器实际上是一种变量类型。*变量*可以简单地理解为持有可变数据的对象——因此得名。也存在一些不改变的变量，这些变量被称为*常量*。回到驾驶的例子，汽车的速度就是一个变量，而汽车的颜色则是一个常量。在伪代码中，变量是简单的抽象概念，但在C（以及许多其他语言）中，变量在使用之前必须声明并指定其类型。这是因为C程序最终会被编译成可执行程序。就像烹饪食谱在给出指令之前列出所有必需的原料一样，变量声明允许你在进入程序的核心部分之前做好准备。最终，所有变量都存储在某个地方的内存中，它们的声明允许编译器更有效地组织这些内存。尽管如此，尽管有所有变量类型的声明，但本质上一切都是内存。
- en: In C, each variable is given a type that describes the information that is meant
    to be stored in that variable. Some of the most common types are `int` (integer
    values), `float` (decimal floating-point values), and `char` (single character
    values). Variables are declared simply by using these keywords before listing
    the variables, as you can see below.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，每个变量都被赋予一个类型，该类型描述了要存储在该变量中的信息。最常见的类型包括 `int`（整数值）、`float`（十进制浮点值）和
    `char`（单个字符值）。变量可以通过在列出变量之前使用这些关键字来声明，如下所示。
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The variables `a` and `b` are now defined as integers, `k` can accept floating
    point values (such as 3.14), and `z` is expected to hold a character value, like
    *A* or *w*. Variables can be assigned values when they are declared or anytime
    afterward, using the = operator.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `a` 和 `b` 现在定义为整数，`k` 可以接受浮点值（如 3.14），而 `z` 预期将包含字符值，如 *A* 或 *w*。变量可以在声明时或之后任何时间使用等号运算符赋值。
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After the following instructions are executed, the variable `a` will contain
    the value of 13, `k` will contain the number 3.14, `z` will contain the character
    *w*, and `b` will contain the value 18, since 13 plus 5 equals 18\. Variables
    are simply a way to remember values; however, with C, you must first declare each
    variable's type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下指令后，变量 `a` 将包含 13 的值，`k` 将包含数字 3.14，`z` 将包含字符 *w*，而 `b` 将包含值 18，因为 13 加
    5 等于 18。变量只是记住值的一种方式；然而，在 C 语言中，你必须首先声明每个变量的类型。
- en: Arithmetic Operators
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '| 算术运算符 |'
- en: The statement `b = a + 7` is an example of a very simple arithmetic operator.
    In C, the following symbols are used for various arithmetic operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 `b = a + 7` 是一个非常简单的算术运算符的例子。在 C 语言中，以下符号用于各种算术运算。
- en: The first four operations should look familiar. Modulo reduction may seem like
    a new concept, but it's really just taking the remainder after division. If `a`
    is 13, then 13 divided by 5 equals 2, with a remainder of 3, which means that
    `a % 5 = 3`. Also, since the variables `a` and `b` are integers, the statement
    `b = a / 5` will result in the value of 2 being stored in `b`, since that's the
    integer portion of it. Floating-point variables must be used to retain the more
    correct answer of 2.6.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个操作应该看起来很熟悉。模数减少可能是一个新概念，但实际上它只是除法后的余数。如果 `a` 是 13，那么 13 除以 5 等于 2，余数为 3，这意味着
    `a % 5 = 3`。另外，由于变量 `a` 和 `b` 是整数，所以 `b = a / 5` 的语句将导致 2 的整数值存储在 `b` 中，因为那是它的整数部分。为了保留更准确的答案
    2.6，必须使用浮点变量。
- en: '| Operation | Symbol | Example |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 符号 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Addition | + | `b = a + 5` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | + | `b = a + 5` |'
- en: '| Subtraction | - | `b = a - 5` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | - | `b = a - 5` |'
- en: '| Multiplication | * | `b = a * 5` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | * | `b = a * 5` |'
- en: '| Division | / | `b = a / 5` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | / | `b = a / 5` |'
- en: '| Modulo reduction | % | `b = a % 5` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 模数减少 | % | `b = a % 5` |'
- en: To get a program to use these concepts, you must speak its language. The C language
    also provides several forms of shorthand for these arithmetic operations. One
    of these was mentioned earlier and is used commonly in for loops.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使程序使用这些概念，你必须使用它的语言。C 语言还提供了这些算术运算的几种简写形式。其中之一在前面提到过，并且在 for 循环中常用。
- en: '| Full Expression | Shorthand | Explanation |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 完整表达式 | 简写 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `i = i + 1` | `i++ or ++i` | Add 1 to the variable. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `i = i + 1` | `i++ 或 ++i` | 将 1 加到变量上。 |'
- en: '| `i = i - 1` | `i-- or --i` | Subtract 1 from the variable. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `i = i - 1` | `i-- 或 --i` | 从变量中减去 1。 |'
- en: These shorthand expressions can be combined with other arithmetic operations
    to produce more complex expressions. This is where the difference between `i++`
    and `++i` becomes apparent. The first expression means *Increment the value of
    `i` by 1* after *evaluating the arithmetic operation*, while the second expression
    means *Increment the value of `i` by 1* before *evaluating the arithmetic operation*.
    The following example will help clarify.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简写表达式可以与其他算术运算结合，产生更复杂的表达式。这就是 `i++` 和 `++i` 之间的区别变得明显的地方。第一个表达式意味着在 *评估算术运算后*
    将 `i` 的值增加 1，而第二个表达式意味着在 *评估算术运算前* 将 `i` 的值增加 1。以下示例将有助于澄清。
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the end of this set of instructions, `b` will contain 30 and `a` will contain
    6, since the shorthand of `b = a++ * 6;` is equivalent to the following statements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一组指令执行完毕后，变量 `b` 将包含 30，而 `a` 将包含 6，因为 `b = a++ * 6;` 的简写相当于以下语句：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, if the instruction `b = ++a * 6;` is used, the order of the addition
    to `a` changes, resulting in the following equivalent instructions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用指令 `b = ++a * 6;`，则对 `a` 的加法顺序会改变，从而导致以下等效指令：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the order has changed, in this case `b` will contain 36, and `a` will
    still contain 6.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于顺序已改变，在这种情况下 `b` 将包含 36，而 `a` 仍然包含 6。
- en: Quite often in programs, variables need to be modified in place. For example,
    you might need to add an arbitrary value like 12 to a variable, and store the
    result right back in that variable (for example, `i = i + 12`). This happens commonly
    enough that shorthand also exists for it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，变量经常需要就地修改。例如，你可能需要向一个变量添加一个任意的值，比如 12，并将结果直接存储在那个变量中（例如，`i = i + 12`）。这种情况经常发生，因此也存在简写形式。
- en: '| Full Expression | Shorthand | Explanation |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 完整表达式 | 简写 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `i = i + 12` | `i+=12` | Add some value to the variable. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `i = i + 12` | `i+=12` | 向变量添加一些值。 |'
- en: '| `i = i - 12` | `i-=12` | Subtract some value from the variable. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `i = i - 12` | `i-=12` | 从变量中减去一些值。 |'
- en: '| `i = i * 12` | `i*=12` | Multiply some value by the variable. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `i = i * 12` | `i*=12` | 将一些值乘以变量。 |'
- en: '| `i = i / 12` | `i/=12` | Divide some value from the variable. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `i = i / 12` | `i/=12` | 从变量中除以一些值。 |'
- en: Comparison Operators
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Variables are frequently used in the conditional statements of the previously
    explained control structures. These conditional statements are based on some sort
    of comparison. In C, these comparison operators use a shorthand syntax that is
    fairly common across many programming languages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 变量经常用于之前解释的控制结构的条件语句中。这些条件语句基于某种比较。在 C 语言中，这些比较运算符使用一种在许多编程语言中相当常见的简写语法。
- en: '| Condition | Symbol | Example |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 符号 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Less than | < | `(a < b)` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | < | `(a < b)` |'
- en: '| Greater than | > | `(a > b)` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | > | `(a > b)` |'
- en: '| Less than or equal to | <= | `(a <= b)` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 小于或等于 | <= | `(a <= b)` |'
- en: '| Greater than or equal to | >= | `(a >= b)` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 大于或等于 | >= | `(a >= b)` |'
- en: '| Equal to | == | `(a == b)` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 等于 | == | `(a == b)` |'
- en: '| Not equal to | != | `(a != b)` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 不等于 | != | `(a != b)` |'
- en: Most of these operators are self-explanatory; however, notice that the shorthand
    for *equal to* uses double equal signs. This is an important distinction, since
    the double equal sign is used to test equivalence, while the single equal sign
    is used to assign a value to a variable. The statement `a = 7` means *Put the
    value 7 in the variable `a`*, while `a == 7` means *Check to see whether the variable
    `a` is equal to 7*. (Some programming languages like Pascal actually use := for
    variable assignment to eliminate visual confusion.) Also, notice that an exclamation
    point generally means *not*. This symbol can be used by itself to invert any expression.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些运算符都是不言自明的；然而，请注意，*等于* 的简写使用双等号。这是一个重要的区别，因为双等号用于测试等价性，而单等号用于将值赋给变量。语句
    `a = 7` 的意思是 *将值 7 放入变量 `a` 中*，而 `a == 7` 的意思是 *检查变量 `a` 是否等于 7*。（一些编程语言如 Pascal
    实际上使用 := 来进行变量赋值以消除视觉上的混淆。）此外，请注意，感叹号通常表示 *非*。这个符号可以单独使用来反转任何表达式。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These comparison operators can also be chained together using shorthand for
    OR and AND.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较运算符也可以通过 OR 和 AND 的简写形式连接在一起。
- en: '| Logic | Symbol | Example |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑 | 符号 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| OR | &#124;&#124; | `((a < b) &#124;&#124; (a < c))` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| OR | &#124;&#124; | `((a < b) &#124;&#124; (a < c))` |'
- en: '| AND | && | `((a < b) && !(a < c))` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| AND | && | `((a < b) && !(a < c))` |'
- en: The example statement consisting of the two smaller conditions joined with OR
    logic will fire true if `a` is less than `b`, OR if `a` is less than `c`. Similarly,
    the example statement consisting of two smaller comparisons joined with AND logic
    will fire true if `a` is less than `b` AND `a` is not less than `c`. These statements
    should be grouped with parentheses and can contain many different variations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由两个较小的条件通过 OR 逻辑连接的示例语句将在 `a` 小于 `b` 或 `a` 小于 `c` 时触发为真。同样，由两个较小的比较通过 AND 逻辑连接的示例语句将在
    `a` 小于 `b` 且 `a` 不小于 `c` 时触发为真。这些语句应该用括号分组，并且可以包含许多不同的变体。
- en: Many things can be boiled down to variables, comparison operators, and control
    structures. Returning to the example of the mouse searching for food, hunger can
    be translated into a Boolean true/false variable. Naturally, 1 means true and
    0 means false.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多事情都可以归结为变量、比较运算符和控制结构。回到鼠标寻找食物的例子，饥饿可以翻译成一个布尔值 true/false 变量。自然地，1 表示 true，0
    表示 false。
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here's another shorthand used by programmers and hackers quite often. C doesn't
    really have any Boolean operators, so any nonzero value is considered true, and
    a statement is considered false if it contains 0\. In fact, the comparison operators
    will actually return a value of 1 if the comparison is true and a value of 0 if
    it is false. Checking to see whether the variable `hungry` is equal to 1 will
    return 1 if `hungry` equals 1 and 0 if `hungry` equals 0\. Since the program only
    uses these two cases, the comparison operator can be dropped altogether.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由程序员和黑客经常使用的一种简写。C语言实际上没有布尔运算符，所以任何非零值都被认为是真的，如果语句包含0，则该语句被认为是假的。实际上，比较运算符会在比较为真时返回1，在比较为假时返回0。检查变量
    `hungry` 是否等于1，如果 `hungry` 等于1，则返回1，如果 `hungry` 等于0，则返回0。由于程序只使用这两种情况，比较运算符可以完全省略。
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A smarter mouse program with more inputs demonstrates how comparison operators
    can be combined with variables.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更智能的鼠标程序，具有更多输入，展示了比较运算符如何与变量结合使用。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example assumes there are also variables that describe the presence of
    a cat and the location of the food, with a value of 1 for true and 0 for false.
    Just remember that any nonzero value is considered true, and the value of 0 is
    considered false.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子假设还有描述猫的存在和食物位置的变量，值为1表示真，值为0表示假。只需记住，任何非零值都被认为是真的，而0的值被认为是假的。
- en: Functions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Sometimes there will be a set of instructions the programmer knows he will
    need several times. These instructions can be grouped into a smaller subprogram
    called a *function*. In other languages, functions are known as subroutines or
    procedures. For example, the action of turning a car actually consists of many
    smaller instructions: Turn on the appropriate blinker, slow down, check for oncoming
    traffic, turn the steering wheel in the appropriate direction, and so on. The
    driving directions from the beginning of this chapter require quite a few turns;
    however, listing every little instruction for every turn would be tedious (and
    less readable). You can pass variables as arguments to a function in order to
    modify the way the function operates. In this case, the function is passed the
    direction of the turn.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候程序员会知道他需要多次使用一组指令。这些指令可以被组合成一个更小的子程序，称为**函数**。在其他语言中，函数被称为子程序或过程。例如，转向汽车的动作实际上由许多更小的指令组成：打开适当的转向灯，减速，检查来车，转动方向盘到适当的方向，等等。本章开头的驾驶指示需要很多转弯；然而，列出每个转弯的每一个小指令将会很繁琐（并且可读性较差）。你可以将变量作为参数传递给函数，以修改函数的操作方式。在这种情况下，函数接收转弯的方向作为参数。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function describes all the instructions needed to make a turn. When a program
    that knows about this function needs to turn, it can just call this function.
    When the function is called, the instructions found within it are executed with
    the arguments passed to it; afterward, execution returns to where it was in the
    program, after the function call. Either left or right can be passed into this
    function, which causes the function to turn in that direction.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数描述了完成转弯所需的所有指令。当一个了解这个函数的程序需要转弯时，它只需调用这个函数。当函数被调用时，其中的指令会根据传递给它的参数执行；之后，执行会返回到函数调用后的程序位置。可以向这个函数传递左转或右转，这将导致函数向该方向转弯。
- en: By default in C, functions can return a value to a caller. For those familiar
    with functions in mathematics, this makes perfect sense. Imagine a function that
    calculates the factorial of a number—naturally, it returns the result.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，默认情况下，函数可以向调用者返回一个值。对于那些熟悉数学函数的人来说，这完全合理。想象一个计算一个数字阶乘的函数——自然地，它返回结果。
- en: 'In C, functions aren''t labeled with a "function" keyword; instead, they are
    declared by the data type of the variable they are returning. This format looks
    very similar to variable declaration. If a function is meant to return an integer
    (perhaps a function that calculates the factorial of some number *x*), the function
    could look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，函数不是用“函数”关键字标记的；相反，它们通过返回变量的数据类型来声明。这种格式看起来非常类似于变量声明。如果一个函数旨在返回一个整数（可能是一个计算某个数字
    *x* 的阶乘的函数），该函数可能看起来像这样：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function is declared as an integer because it multiplies every value from
    1 to *x* and returns the result, which is an integer. The return statement at
    the end of the function passes back the contents of the variable *x* and ends
    the function. This factorial function can then be used like an integer variable
    in the main part of any program that knows about it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数被声明为整数类型，因为它将 1 到 *x* 的每个值相乘并返回结果，这是一个整数。函数末尾的返回语句将变量 *x* 的内容传递回并结束函数。然后，这个阶乘函数可以像整数变量一样在任何了解它的程序的主要部分中使用。
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the end of this short program, the variable `b` will contain 120, since the
    factorial function will be called with the argument of 5 and will return 120.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短程序结束时，变量 `b` 将包含 120，因为阶乘函数将使用 5 作为参数并返回 120。
- en: 'Also in C, the compiler must "know" about functions before it can use them.
    This can be done by simply writing the entire function before using it later in
    the program or by using function prototypes. A *function prototype* is simply
    a way to tell the compiler to expect a function with this name, this return data
    type, and these data types as its functional arguments. The actual function can
    be located near the end of the program, but it can be used anywhere else, since
    the compiler already knows about it. An example of a function prototype for the
    `factorial()` function would look something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，编译器在可以使用函数之前必须“知道”它们。这可以通过在程序后面使用之前简单地编写整个函数来实现，或者通过使用函数原型。*函数原型*只是告诉编译器预期一个具有此名称、此返回数据类型以及这些数据类型作为其功能参数的函数。实际函数可以位于程序末尾附近，但可以在任何其他地方使用，因为编译器已经知道它了。`factorial()`
    函数的函数原型示例可能看起来像这样：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Usually, function prototypes are located near the beginning of a program. There's
    no need to actually define any variable names in the prototype, since this is
    done in the actual function. The only thing the compiler cares about is the function's
    name, its return data type, and the data types of its functional arguments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数原型位于程序的开头附近。在原型中实际上不需要定义任何变量名称，因为这是在实际函数中完成的。编译器所关心的是函数的名称、其返回数据类型以及其功能参数的数据类型。
- en: 'If a function doesn''t have any value to return, it should be declared as `void`,
    as is the case with the `turn()` function I used as an example earlier. However,
    the `turn()` function doesn''t yet capture all the functionality that our driving
    directions need. Every turn in the directions has both a direction and a street
    name. This means that a turning function should have two variables: the direction
    to turn and the street to turn on to. This complicates the function of turning,
    since the proper street must be located before the turn can be made. A more complete
    turning function using proper C-like syntax is listed below in pseudo-code.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数没有要返回的值，它应该被声明为 `void`，就像我之前用作示例的 `turn()` 函数一样。然而，`turn()` 函数还没有捕获我们所需的全部转向功能。方向指示中的每个转向都有方向和街道名称。这意味着转向函数应该有两个变量：转向的方向和要转向的街道。这使转向功能变得复杂，因为必须在转向之前找到正确的街道。下面列出了一个使用正确
    C 语法伪代码的更完整的转向函数。
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function includes a section that searches for the proper intersection by
    looking for street signs, reading the name on each street sign, and storing that
    name in a variable called `current_intersection_name`. It will continue to look
    for and read street signs until the target street is found; at that point, the
    remaining turning instructions will be executed. The pseudo-code driving instructions
    can now be changed to use this turning function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包括一个部分，通过寻找路标、读取每个路标上的名称并将该名称存储在名为 `current_intersection_name` 的变量中来寻找合适的交叉点。它将继续寻找和读取路标，直到找到目标街道；在那个时刻，剩余的转向指令将被执行。现在可以将伪代码的转向指令更改为使用此转向函数。
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Functions aren't commonly used in pseudo-code, since pseudo-code is mostly used
    as a way for programmers to sketch out program concepts before writing compilable
    code. Since pseudo-code doesn't actually have to work, full functions don't need
    to be written out—simply jotting down *Do some complex stuff here* will suffice.
    But in a programming language like C, functions are used heavily. Most of the
    real usefulness of C comes from collections of existing functions called *libraries*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在伪代码中通常不常用函数，因为伪代码主要是程序员在编写可编译代码之前勾勒程序概念的一种方式。由于伪代码实际上不需要真正工作，所以不需要写出完整的函数——只需简单地写下“在这里做一些复杂的事情”就足够了。但在像C这样的编程语言中，函数被大量使用。C的大部分实用性来自于被称为*库*的现有函数集合。
- en: Getting Your Hands Dirty
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摸索实践
- en: Now that the syntax of C feels more familiar and some fundamental programming
    concepts have been explained, actually programming in C isn't that big of a step.
    C compilers exist for just about every operating system and processor architecture
    out there, but for this book, Linux and an *x*86-based processor will be used
    exclusively. Linux is a free operating system that everyone has access to, and
    *x*86-based processors are the most popular consumer-grade processor on the planet.
    Since hacking is really about experimenting, it's probably best if you have a
    C compiler to follow along with.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在C的语法感觉更加熟悉，一些基本编程概念也已经解释清楚，实际上用C编程并不是一大步。C编译器几乎适用于所有操作系统和处理器架构，但在这本书中，我们将专门使用Linux和基于*x*86的处理器。Linux是一个免费的操作系统，每个人都可以访问，基于*x*86的处理器是地球上最受欢迎的消费级处理器。由于黑客精神实际上就是实验，所以如果你有一个C编译器来跟随，那可能最好不过了。
- en: Included with this book is a Live CD you can use to follow along if your computer
    has an *x*86 processor. Just put the CD in the drive and reboot your computer.
    It will boot into a Linux environment without modifying your existing operating
    system. From this Linux environment you can follow along with the book and experiment
    on your own.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑有*x*86处理器，这本书中包含了一个Live CD，你可以用它来跟随。只需将CD放入驱动器，重新启动你的电脑。它将启动到一个Linux环境中，而不会修改你的现有操作系统。从这个Linux环境中，你可以跟随这本书，并自己进行实验。
- en: Let's get right to it. The firstprog.c program is a simple piece of C code that
    will print "Hello, world!" 10 times.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入正题。第一个`firstprog.c`程序是一段简单的C代码，它将打印“Hello, world!” 10次。
- en: Getting Your Hands Dirty
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摸索实践
- en: firstprog.c
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: firstprog.c
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The main execution of a C program begins in the aptly named `main()`function.
    Any text following two forward slashes (//) is a comment, which is ignored by
    the compiler.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C程序的主要执行开始于名为`main()`的函数。任何跟在两个正斜杠（//）后面的文本都是注释，编译器会忽略它。
- en: The first line may be confusing, but it's just C syntax that tells the compiler
    to include headers for a standard input/output (I/O) library named `stdio`. This
    header file is added to the program when it is compiled. It is located at /usr/include/stdio.h,
    and it defines several constants and function prototypes for corresponding functions
    in the standard I/O library. Since the `main()` function uses the `printf()` function
    from the standard I/O library, a function prototype is needed for `printf()` before
    it can be used. This function prototype (along with many others) is included in
    the stdio.h header file. A lot of the power of C comes from its extensibility
    and libraries. The rest of the code should make sense and look a lot like the
    pseudo-code from before. You may have even noticed that there's a set of curly
    braces that can be eliminated. It should be fairly obvious what this program will
    do, but let's compile it using GCC and run it just to make sure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行可能有些令人困惑，但这只是C语法，告诉编译器包含一个名为`stdio`的标准输入/输出（I/O）库的头文件。当程序编译时，这个头文件会被添加到程序中。它位于/usr/include/stdio.h，它定义了标准I/O库中相应函数的几个常量和函数原型。由于`main()`函数使用了标准I/O库中的`printf()`函数，所以在使用之前需要一个`printf()`函数原型。这个函数原型（以及许多其他原型）包含在stdio.h头文件中。C的很多力量来自于其可扩展性和库。其余的代码应该很容易理解，看起来也和之前的伪代码很相似。你可能甚至注意到有一组可以省略的大括号。这个程序将做什么应该很明显，但让我们使用GCC编译它并运行它，以确保一切正常。
- en: The *GNU Compiler Collection (GCC)* is a free C compiler that translates C into
    machine language that a processor can understand. The outputted translation is
    an executable binary file, which is called `a.out` by default. Does the compiled
    program do what you thought it would?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU编译器集合（GCC）*是一个免费的C语言编译器，可以将C语言翻译成处理器可以理解的机器语言。输出的翻译是一个可执行二进制文件，默认情况下称为`a.out`。编译后的程序是否做了你想象中的事情？'
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Bigger Picture
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整体图景
- en: Okay, this has all been stuff you would learn in an elementary programming class—basic,
    but essential. Most introductory programming classes just teach how to read and
    write C. Don't get me wrong, being fluent in C is very useful and is enough to
    make you a decent programmer, but it's only a piece of the bigger picture. Most
    programmers learn the language from the top down and never see the big picture.
    Hackers get their edge from knowing how all the pieces interact within this bigger
    picture. To see the bigger picture in the realm of programming, simply realize
    that C code is meant to be compiled. The code can't actually do anything until
    it's compiled into an executable binary file. Thinking of C-source as a program
    is a common misconception that is exploited by hackers every day. The binary `a.out`'s
    instructions are written in machine language, an elementary language the CPU can
    understand. Compilers are designed to translate the language of C code into machine
    language for a variety of processor architectures. In this case, the processor
    is in a family that uses the *x*86 architecture. There are also Sparc processor
    architectures (used in Sun Workstations) and the PowerPC processor architecture
    (used in pre-Intel Macs). Each architecture has a different machine language,
    so the compiler acts as a middle ground—translating C code into machine language
    for the target architecture.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些都是你在基础编程课程中会学到的东西——基础但重要。大多数入门级编程课程只是教授如何阅读和编写C语言。请别误会，精通C语言非常有用，足以让你成为一个合格的程序员，但它只是整体图景中的一小部分。大多数程序员从上到下学习语言，从未看到整体图景。黑客通过了解所有这些部分在这个整体图景中的相互作用来获得优势。在编程领域看到整体图景，只需意识到C代码是为了编译而设计的。代码在编译成可执行二进制文件之前实际上什么也不能做。将C源代码视为程序是一种常见的误解，黑客每天都在利用这种误解。`a.out`的二进制指令是用机器语言编写的，这是一种CPU可以理解的基本语言。编译器被设计成将C代码翻译成适用于各种处理器架构的机器语言。在这种情况下，处理器属于使用*x*86架构的家族。还有Sparc处理器架构（用于Sun工作站）和PowerPC处理器架构（用于预Intel
    Mac）。每种架构都有不同的机器语言，因此编译器充当中间人——将C代码翻译成目标架构的机器语言。
- en: As long as the compiled program works, the average programmer is only concerned
    with source code. But a hacker realizes that the compiled program is what actually
    gets executed out in the real world. With a better understanding of how the CPU
    operates, a hacker can manipulate the programs that run on it. We have seen the
    source code for our first program and compiled it into an executable binary for
    the *x*86 architecture. But what does this executable binary look like? The GNU
    development tools include a program called `objdump`, which can be used to examine
    compiled binaries. Let's start by looking at the machine code the `main()` function
    was translated into.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 只要编译后的程序能正常工作，普通程序员只关心源代码。但黑客意识到，编译后的程序才是实际在现实世界中执行的内容。通过对CPU运行方式的更好理解，黑客可以操纵运行在其上的程序。我们已经看到了第一个程序的源代码，并将其编译成了*x*86架构的可执行二进制文件。但这个可执行二进制文件看起来是什么样子呢？GNU开发工具包中包含一个名为`objdump`的程序，它可以用来检查编译后的二进制文件。让我们先看看`main()`函数被转换成的机器代码。
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `objdump` program will spit out far too many lines of output to sensibly
    examine, so the output is piped into `grep` with the command-line option to only
    display 20 lines after the regular expression `main.:`. Each byte is represented
    in *hexadecimal notation*, which is a base-16 numbering system. The numbering
    system you are most familiar with uses a base-10 system, since at 10 you need
    to add an extra symbol. Hexadecimal uses 0 through 9 to represent 0 through 9,
    but it also uses A through F to represent the values 10 through 15\. This is a
    convenient notation since a byte contains 8 bits, each of which can be either
    true or false. This means a byte has 256 (2⁸) possible values, so each byte can
    be described with 2 hexadecimal digits.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`objdump`程序会输出过多的行，以至于无法合理地检查，因此输出被管道传输到`grep`，使用命令行选项仅显示正则表达式`main.:`之后的20行。每个字节都以*十六进制表示法*表示，这是一种基数为16的计数系统。你最熟悉的计数系统使用的是基数为10的系统，因为到了10就需要添加一个额外的符号。十六进制使用0到9来表示0到9，但它也使用A到F来表示10到15的值。这种表示法很方便，因为一个字节包含8位，每一位可以是真或假。这意味着一个字节有256（2⁸）种可能的值，所以每个字节可以用2个十六进制数字来描述。'
- en: The hexadecimal numbers—starting with `0x8048374` on the far left—are memory
    addresses. The bits of the machine language instructions must be put somewhere,
    and this somewhere is called *memory*. Memory is just a collection of bytes of
    temporary storage space that are numbered with addresses.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最左侧开始的十六进制数字是内存地址。机器语言指令的位必须放在某个地方，这个地方就叫做*内存*。内存只是由带有地址的临时存储空间字节组成的集合。
- en: Like a row of houses on a local street, each with its own address, memory can
    be thought of as a row of bytes, each with its own memory address. Each byte of
    memory can be accessed by its address, and in this case the CPU accesses this
    part of memory to retrieve the machine language instructions that make up the
    compiled program. Older Intel *x*86 processors use a 32-bit addressing scheme,
    while newer ones use a 64-bit one. The 32-bit processors have 2^(32) (or 4,294,967,296)
    possible addresses, while the 64-bit ones have 2^(64) (1.84467441 x 10^(19)) possible
    addresses. The 64-bit processors can run in 32-bit compatibility mode, which allows
    them to run 32-bit code quickly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像当地街道上一排房子，每栋房子都有自己的地址一样，内存可以看作是一排字节，每个字节都有自己的内存地址。每个内存字节都可以通过其地址来访问，在这种情况下，CPU通过访问这部分内存来检索构成编译程序的机器语言指令。较老的Intel
    *x*86处理器使用32位寻址方案，而较新的处理器使用64位寻址方案。32位处理器有2^(32)（或4,294,967,296）个可能的地址，而64位处理器有2^(64)（1.84467441
    x 10^(19)）个可能的地址。64位处理器可以在32位兼容模式下运行，这允许它们快速运行32位代码。
- en: The hexadecimal bytes in the middle of the listing above are the machine language
    instructions for the *x*86 processor. Of course, these hexadecimal values are
    only representations of the bytes of binary 1s and 0s the CPU can understand.
    But since *0101010110001001111001011000001111101100111100001* … isn't very useful
    to anything other than the processor, the machine code is displayed as hexadecimal
    bytes and each instruction is put on its own line, like splitting a paragraph
    into sentences.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上列中间的十六进制字节是*x*86处理器的机器语言指令。当然，这些十六进制值只是CPU能够理解的二进制1s和0s字节的表现形式。但由于*0101010110001001111001011000001111101100111100001*…对除了处理器之外的东西没有太大用处，因此机器代码以十六进制字节的形式显示，并且每条指令都单独放在一行上，就像将一个段落拆分成句子一样。
- en: 'Come to think of it, the hexadecimal bytes really aren''t very useful themselves,
    either—that''s where assembly language comes in. The instructions on the far right
    are in assembly language. Assembly language is really just a collection of mnemonics
    for the corresponding machine language instructions. The instruction `ret` is
    far easier to remember and make sense of than `0xc3` or `11000011`. Unlike C and
    other compiled languages, assembly language instructions have a direct one-to-one
    relationship with their corresponding machine language instructions. This means
    that since every processor architecture has different machine language instructions,
    each also has a different form of assembly language. Assembly is just a way for
    programmers to represent the machine language instructions that are given to the
    processor. Exactly how these machine language instructions are represented is
    simply a matter of convention and preference. While you can theoretically create
    your own *x*86 assembly language syntax, most people stick with one of the two
    main types: AT&T syntax and Intel syntax. The assembly shown in the output on
    [The Bigger Picture](ch02s05.html#the_bigger_picture "The Bigger Picture") is
    AT&T syntax, as just about all of Linux''s disassembly tools use this syntax by
    default. It''s easy to recognize AT&T syntax by the cacophony of % and $ symbols
    prefixing everything (take a look again at the example on [The Bigger Picture](ch02s05.html#the_bigger_picture
    "The Bigger Picture")). The same code can be shown in Intel syntax by providing
    an additional command-line option, `-M intel`, to `objdump`, as shown in the output
    below.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看，十六进制字节本身其实也不是非常有用——这就是汇编语言的作用所在。最右侧的指令是汇编语言。汇编语言实际上只是对应机器语言指令的助记符集合。指令`ret`比`0xc3`或`11000011`更容易记住和理解。与C和其他编译语言不同，汇编语言指令与其对应的机器语言指令有一个直接的、一对一的关系。这意味着由于每个处理器架构都有不同的机器语言指令，因此每个架构也有不同的汇编语言形式。汇编语言只是程序员用来表示处理器所接受的机器语言指令的一种方式。这些机器语言指令的确切表示只是惯例和偏好的问题。虽然理论上你可以创建自己的*x*86汇编语言语法，但大多数人还是坚持使用两种主要类型之一：AT&T语法和Intel语法。在[更大的图景](ch02s05.html#the_bigger_picture
    "更大的图景")的输出中显示的汇编语言是AT&T语法，因为几乎所有的Linux反汇编工具默认都使用这种语法。通过%和$符号的嘈杂前缀很容易识别AT&T语法（再次查看[更大的图景](ch02s05.html#the_bigger_picture
    "更大的图景")上的示例）。可以通过向`objdump`提供额外的命令行选项`-M intel`来以Intel语法显示相同的代码，如下面的输出所示。
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Personally, I think Intel syntax is much more readable and easier to understand,
    so for the purposes of this book, I will try to stick with this syntax. Regardless
    of the assembly language representation, the commands a processor understands
    are quite simple. These instructions consist of an operation and sometimes additional
    arguments that describe the destination and/or the source for the operation. These
    operations move memory around, perform some sort of basic math, or interrupt the
    processor to get it to do something else. In the end, that's all a computer processor
    can really do. But in the same way millions of books have been written using a
    relatively small alphabet of letters, an infinite number of possible programs
    can be created using a relatively small collection of machine instructions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我认为Intel语法更易于阅读和理解，因此为了本书的目的，我将尽量坚持这种语法。无论汇编语言表示如何，处理器能理解的命令都非常简单。这些指令由一个操作和一些有时描述操作目的和/或源的额外参数组成。这些操作移动内存，执行某种基本数学运算，或者中断处理器以使其执行其他操作。最终，计算机处理器真正能做的就是这些。但就像使用相对较小的字母表写出了数百万本书一样，使用相对较小的机器指令集合可以创建无限多的可能程序。
- en: Processors also have their own set of special variables called *registers*.
    Most of the instructions use these registers to read or write data, so understanding
    the registers of a processor is essential to understanding the instructions. The
    bigger picture keeps getting bigger….
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器也有它们自己的一组特殊变量，称为**寄存器**。大多数指令使用这些寄存器来读取或写入数据，因此理解处理器的寄存器对于理解指令是至关重要的。整体图景一直在不断扩大…。
- en: The x86 Processor
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: x86 处理器
- en: 'The 8086 CPU was the first *x*86 processor. It was developed and manufactured
    by Intel, which later developed more advanced processors in the same family: the
    80186, 80286, 80386, and 80486\. If you remember people talking about 386 and
    486 processors in the ''80s and ''90s, this is what they were referring to.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 8086 CPU 是第一个 *x*86 处理器。它由英特尔开发和制造，后来在该系列中开发了更先进的处理器：80186、80286、80386 和 80486。如果你记得在
    80 年代和 90 年代人们谈论 386 和 486 处理器，他们所指的就是这些。
- en: The *x*86 processor has several registers, which are like internal variables
    for the processor. I could just talk abstractly about these registers now, but
    I think it's always better to see things for yourself. The GNU development tools
    also include a debugger called GDB. *Debuggers* are used by programmers to step
    through compiled programs, examine program memory, and view processor registers.
    A programmer who has never used a debugger to look at the inner workings of a
    program is like a seventeenth-century doctor who has never used a microscope.
    Similar to a microscope, a debugger allows a hacker to observe the microscopic
    world of machine code—but a debugger is far more powerful than this metaphor allows.
    Unlike a microscope, a debugger can view the execution from all angles, pause
    it, and change anything along the way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*86 处理器有几个寄存器，它们就像是处理器的内部变量。我现在可以抽象地谈论这些寄存器，但我认为亲自看到这些事物总是更好的。GNU 开发工具还包括一个名为
    GDB 的调试器。*调试器*被程序员用来逐步执行编译后的程序，检查程序内存，并查看处理器寄存器。一个从未使用调试器查看程序内部工作原理的程序员就像是一个从未使用显微镜的十七世纪医生。与显微镜类似，调试器允许黑客观察机器代码的微观世界——但调试器的功能远比这个比喻所允许的强大。与显微镜不同，调试器可以从所有角度查看执行过程，暂停它，并在过程中更改任何内容。'
- en: Below, GDB is used to show the state of the processor registers right before
    the program starts.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，使用 GDB 显示程序开始前的处理器寄存器状态。
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A breakpoint is set on the `main()` function so execution will stop right before
    our code is executed. Then GDB runs the program, stops at the breakpoint, and
    is told to display all the processor registers and their current states.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数上设置了断点，以便在执行我们的代码之前停止执行。然后 GDB 运行程序，在断点处停止，并被告知显示所有处理器寄存器和它们当前的状态。
- en: The first four registers (*EAX, ECX, EDX*, and *EBX*) are known as general purpose
    registers. These are called the *Accumulator, Counter, Data*, and *Base* registers,
    respectively. They are used for a variety of purposes, but they mainly act as
    temporary variables for the CPU when it is executing machine instructions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个寄存器（*EAX, ECX, EDX* 和 *EBX*）被称为通用寄存器。它们分别被称为*累加器、计数器、数据*和*基址*寄存器。它们用于各种目的，但主要在
    CPU 执行机器指令时作为临时变量。
- en: The second four registers (*ESP, EBP, ESI*, and *EDI*) are also general purpose
    registers, but they are sometimes known as pointers and indexes. These stand for
    *Stack Pointer, Base Pointer, Source Index*, and *Destination Index*, respectively.
    The first two registers are called pointers because they store 32-bit addresses,
    which essentially point to that location in memory. These registers are fairly
    important to program execution and memory management; we will discuss them more
    later. The last two registers are also technically pointers, which are commonly
    used to point to the source and destination when data needs to be read from or
    written to. There are load and store instructions that use these registers, but
    for the most part, these registers can be thought of as just simple general-purpose
    registers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组四个寄存器（*ESP, EBP, ESI* 和 *EDI*）也是通用寄存器，但有时它们也被称为指针和索引。它们分别代表*堆栈指针、基指针、源索引*和*目标索引*。前两个寄存器被称为指针，因为它们存储
    32 位地址，本质上指向内存中的那个位置。这些寄存器对程序执行和内存管理非常重要；我们稍后会更详细地讨论它们。最后两个寄存器在技术上也是指针，通常用于在需要从或向内存读取或写入数据时指向源和目标。有一些加载和存储指令使用这些寄存器，但大部分情况下，这些寄存器可以被视为简单的通用寄存器。
- en: The *EIP* register is the *Instruction Pointer* register, which points to the
    current instruction the processor is reading. Like a child pointing his finger
    at each word as he reads, the processor reads each instruction using the EIP register
    as its finger. Naturally, this register is quite important and will be used a
    lot while debugging. Currently, it points to a memory address at `0x804838a`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*EIP* 寄存器是 *指令指针* 寄存器，它指向处理器正在读取的当前指令。就像一个孩子在他阅读时用手指指着每个单词一样，处理器使用 EIP 寄存器作为其手指来读取每个指令。自然地，这个寄存器非常重要，在调试时将被大量使用。目前，它指向
    `0x804838a` 的内存地址。'
- en: The remaining *EFLAGS* register actually consists of several bit flags that
    are used for comparisons and memory segmentations. The actual memory is split
    into several different segments, which will be discussed later, and these registers
    keep track of that. For the most part, these registers can be ignored since they
    rarely need to be accessed directly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的 *EFLAGS* 寄存器实际上由几个用于比较和内存分段的位标志组成。实际内存被分成几个不同的段，这将在后面讨论，这些寄存器跟踪这些信息。在大多数情况下，可以忽略这些寄存器，因为它们很少需要直接访问。
- en: Assembly Language
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编语言
- en: Since we are using Intel syntax assembly language for this book, our tools must
    be configured to use this syntax. Inside GDB, the disassembly syntax can be set
    to Intel by simply typing `set disassembly intel` or `set dis intel`, for short.
    You can configure this setting to run every time GDB starts up by putting the
    command in the file .gdbinit in your home directory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这本书中使用Intel语法的汇编语言，我们的工具必须配置为使用此语法。在 GDB 中，可以通过简单地输入 `set disassembly intel`
    或简写为 `set dis intel` 来设置反汇编语法为 Intel。您可以通过将命令放入家目录中的 `.gdbinit` 文件来配置此设置，以便每次
    GDB 启动时都运行。
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that GDB is configured to use Intel syntax, let''s begin understanding
    it. The assembly instructions in Intel syntax generally follow this style:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在GDB已配置为使用Intel语法，让我们开始理解它。Intel语法的汇编指令通常遵循以下风格：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The destination and source values will either be a register, a memory address,
    or a value. The operations are usually intuitive mnemonics: The `mov`operation
    will move a value from the source to the destination, `sub` will subtract, `inc`
    will increment, and so forth. For example, the instructions below will move the
    value from ESP to EBP and then subtract 8 from ESP (storing the result in ESP).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目标和源值将是一个寄存器、一个内存地址或一个值。操作通常是直观的助记符：`mov` 操作将从源移动值到目标，`sub` 将执行减法，`inc` 将执行增量，等等。例如，下面的指令将把值从
    ESP 移动到 EBP，然后从 ESP 中减去 8（将结果存储在 ESP 中）。
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are also operations that are used to control the flow of execution. The
    `cmp` operation is used to compare values, and basically any operation beginning
    with `j` is used to jump to a different part of the code (depending on the result
    of the comparison). The example below first compares a 4-byte value located at
    EBP minus 4 with the number 9\. The next instruction is shorthand for *jump if
    less than or equal to*, referring to the result of the previous comparison. If
    that value is less than or equal to 9, execution jumps to the instruction at `0x8048393`.
    Otherwise, execution flows to the next instruction with an unconditional jump.
    If the value isn't less than or equal to 9, execution will jump to `0x80483a6`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些操作用于控制执行流程。`cmp` 操作用于比较值，基本上任何以 `j` 开头的操作都用于跳转到代码的另一个部分（取决于比较的结果）。下面的示例首先比较位于
    EBP 减 4 的 4 字节值与数字 9。接下来的指令是 `jump if less than or equal to` 的简写，指的是上一个比较的结果。如果该值小于或等于
    9，执行将跳转到 `0x8048393` 处的指令。否则，执行将流向下一个指令，进行无条件跳转。如果该值不小于或等于 9，执行将跳转到 `0x80483a6`。
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These examples have been from our previous disassembly, and we have our debugger
    configured to use Intel syntax, so let's use the debugger to step through the
    first program at the assembly instruction level.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例来自我们之前的反汇编，并且我们的调试器已配置为使用Intel语法，所以让我们使用调试器在汇编指令级别逐步执行第一个程序。
- en: The `-g` flag can be used by the GCC compiler to include extra debugging information,
    which will give GDB access to the source code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 标志可以被 GCC 编译器用来包含额外的调试信息，这将使 GDB 能够访问源代码。'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, the source code is listed and the disassembly of the `main()` function
    is displayed. Then a breakpoint is set at the start of `main()`, and the program
    is run. This breakpoint simply tells the debugger to pause the execution of the
    program when it gets to that point. Since the breakpoint has been set at the start
    of the `main()` function, the program hits the breakpoint and pauses before actually
    executing any instructions in `main()`. Then the value of EIP (the Instruction
    Pointer) is displayed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，列出源代码并显示`main()`函数的反汇编代码。然后，在`main()`函数的开始处设置一个断点，并运行程序。这个断点简单地告诉调试器在到达该点时暂停程序的执行。由于断点是在`main()`函数的开始处设置的，程序在执行`main()`函数中的任何指令之前就会遇到断点并暂停。然后，会显示EIP（指令指针）的值。
- en: Notice that EIP contains a memory address that points to an instruction in the
    `main()` function's disassembly (shown in bold). The instructions before this
    (shown in italics) are collectively known as the *function prologue* and are generated
    by the compiler to set up memory for the rest of the `main()` function's local
    variables. Part of the reason variables need to be declared in C is to aid the
    construction of this section of code. The debugger knows this part of the code
    is automatically generated and is smart enough to skip over it. We'll talk more
    about the function prologue later, but for now we can take a cue from GDB and
    skip it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，EIP包含一个指向`main()`函数反汇编（以粗体显示）中的指令的内存地址。在此之前的指令（以斜体显示）统称为*函数序言*，由编译器生成，用于为`main()`函数的其余局部变量设置内存。变量需要声明在C中的部分原因是为了帮助构建这部分代码。调试器知道这部分代码是自动生成的，并且足够智能，可以跳过它。我们稍后会更多地讨论函数序言，但现在我们可以从GDB那里得到启示，跳过它。
- en: The GDB debugger provides a direct method to examine memory, using the command
    `x`, which is short for *examine*. Examining memory is a critical skill for any
    hacker. Most hacker exploits are a lot like magic tricks—they seem amazing and
    magical, unless you know about sleight of hand and misdirection. In both magic
    and hacking, if you were to look in just the right spot, the trick would be obvious.
    That's one of the reasons a good magician never does the same trick twice. But
    with a debugger like GDB, every aspect of a program's execution can be deterministically
    examined, paused, stepped through, and repeated as often as needed. Since a running
    program is mostly just a processor and segments of memory, examining memory is
    the first way to look at what's really going on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: GDB调试器提供了一个直接检查内存的方法，使用命令`x`，它是`examine`的缩写。检查内存是任何黑客的关键技能。大多数黑客攻击都类似于魔术表演——除非你知道手法和误导，否则它们看起来神奇而神秘。在魔术和黑客攻击中，如果你只看对的地方，技巧就会很明显。这也是为什么一个好的魔术师永远不会重复同一个魔术。但是，使用像GDB这样的调试器，可以确定地检查、暂停、单步执行和重复程序的每个执行方面，直到需要为止。由于运行中的程序主要是处理器和内存段，检查内存是查看真正发生事情的第一种方法。
- en: 'The examine command in GDB can be used to look at a certain address of memory
    in a variety of ways. This command expects two arguments when it''s used: the
    location in memory to examine and how to display that memory.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: GDB中的检查命令可以以多种方式查看内存中的特定地址。当使用此命令时，它期望两个参数：要检查的内存位置以及如何显示该内存。
- en: 'The display format also uses a single-letter shorthand, which is optionally
    preceded by a count of how many items to examine. Some common format letters are
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 显示格式也使用单字母缩写，这些缩写可以有一个可选的计数，表示要检查的项目数量。以下是一些常见的格式字母：
- en: '| **`o`** Display in octal. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **`o`** 以八进制显示。 |'
- en: '| **`x`** Display in hexadecimal. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **`x`** 以十六进制显示。 |'
- en: '| **`u`** Display in unsigned, standard base-10 decimal. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **`u`** 以无符号、标准的十进制显示。 |'
- en: '| **`t`** Display in binary. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **`t`** 以二进制显示。 |'
- en: These can be used with the examine command to examine a certain memory address.
    In the following example, the current address of the EIP register is used. Shorthand
    commands are often used with GDB, and even `info register eip` can be shortened
    to just `i r eip`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令可以与`examine`命令一起使用来检查特定的内存地址。在下面的示例中，使用了EIP寄存器的当前地址。在GDB中，通常使用简写命令，甚至`info
    register eip`也可以简写为`i r eip`。
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The memory the EIP register is pointing to can be examined by using the address
    stored in EIP. The debugger lets you reference registers directly, so `$eip` is
    equivalent to the value EIP contains at that moment. The value `077042707` in
    octal is the same as `0x00fc45c7` in hexadecimal, which is the same as `16532935`
    in base-10 decimal, which in turn is the same as `00000000111111000100010111000111`
    in binary. A number can also be prepended to the format of the examine command
    to examine multiple units at the target address.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 EIP 中存储的地址来检查 EIP 指向的内存。调试器允许你直接引用寄存器，因此 `$eip` 等同于那一刻 EIP 包含的值。八进制值
    `077042707` 等同于十六进制的 `0x00fc45c7`，也等同于十进制的 `16532935`，进而等同于二进制的 `00000000111111000100010111000111`。也可以将数字添加到检查命令的格式中，以检查目标地址的多个单元。
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The default size of a single unit is a four-byte unit called a *word*. The
    size of the display units for the examine command can be changed by adding a size
    letter to the end of the format letter. The valid size letters are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 单个单元的默认大小是四个字节的单元，称为 *字*。可以通过在格式字母的末尾添加大小字母来更改检查命令的显示单元大小。有效的大小字母如下：
- en: '| **`b`** A single byte |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **`b`** 一个单字节 |'
- en: '| **`h`** A halfword, which is two bytes in size |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **`h`** 一个半字，大小为两个字节 |'
- en: '| **`w`** A word, which is four bytes in size |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **`w`** 一个字，大小为四个字节 |'
- en: '| **`g`** A giant, which is eight bytes in size |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **`g`** 一个巨大的，大小为八字节 |'
- en: This is slightly confusing, because sometimes the term *word* also refers to
    2-byte values. In this case a *double word* or *DWORD* refers to a 4-byte value.
    In this book, words and DWORDs both refer to 4-byte values. If I'm talking about
    a 2-byte value, I'll call it a *short* or a halfword. The following GDB output
    shows memory displayed in various sizes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点令人困惑，因为有时术语 *字* 也指 2 字节值。在这种情况下，*双字* 或 *DWORD* 指的是 4 字节值。在这本书中，字和 DWORD 都指
    4 字节值。如果我在谈论一个 2 字节值，我会称它为 *短* 或半字。以下 GDB 输出显示了以各种大小显示的内存。
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you look closely, you may notice something odd about the data above. The
    first e`x`amine command shows the first eight bytes, and naturally, the e`x`amine
    commands that use bigger units display more data in total. However, the first
    e`x`amine shows the first two bytes to be `0xc7` and `0x45`, but when a halfword
    is examined at the exact same memory address, the value `0x45c7` is shown, with
    the bytes reversed. This same byte-reversal effect can be seen when a full four-byte
    word is shown as `0x00fc45c7`, but when the first four bytes are shown byte by
    byte, they are in the order of `0xc7, 0x45, 0xfc`, and `0x00`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察，你可能会注意到数据中有些奇怪的地方。第一个 `x`amine 命令显示了前八个字节，自然地，使用更大单元的 `x`amine 命令会显示更多的数据。然而，第一个
    `x`amine 显示的前两个字节是 `0xc7` 和 `0x45`，但当在确切的相同内存地址检查半字时，显示的值是 `0x45c7`，字节顺序相反。当以
    `0x00fc45c7` 显示完整的四个字节时，也可以看到相同的字节反转效果，但当逐字节显示前四个字节时，它们的顺序是 `0xc7, 0x45, 0xfc`
    和 `0x00`。
- en: This is because on the *x*86 processor values are stored in *little-endian byte
    order*, which means the least significant byte is stored first. For example, if
    four bytes are to be interpreted as a single value, the bytes must be used in
    reverse order. The GDB debugger is smart enough to know how values are stored,
    so when a word or halfword is examined, the bytes must be reversed to display
    the correct values in hexadecimal. Revisiting these values displayed both as hexadecimal
    and unsigned decimals might help clear up any confusion.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在 *x*86 处理器上，值以 *小端字节序* 存储的，这意味着最低有效字节首先存储。例如，如果要将四个字节解释为单个值，则必须以相反的顺序使用字节。GDB
    调试器足够智能，知道值是如何存储的，因此当检查字或半字时，必须反转字节以在十六进制中显示正确的值。重新查看以十六进制和无符号十进制显示的这些值可能有助于消除任何混淆。
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first four bytes are shown both in hexadecimal and standard unsigned decimal
    notation. A command-line calculator program called `bc` is used to show that if
    the bytes are interpreted in the incorrect order, a horribly incorrect value of
    `3343252480` is the result. The byte order of a given architecture is an important
    detail to be aware of. While most debugging tools and compilers will take care
    of the details of byte order automatically, eventually you will directly manipulate
    memory by yourself.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个字节同时以十六进制和标准无符号十进制表示。使用名为 `bc` 的命令行计算器程序来显示，如果字节以错误的顺序解释，结果将是可怕的错误值 `3343252480`。给定架构的字节序是一个需要了解的重要细节。虽然大多数调试工具和编译器会自动处理字节序的细节，但最终你将直接自己操作内存。
- en: In addition to converting byte order, GDB can do other conversions with the
    examine command. We've already seen that GDB can disassemble machine language
    instructions into human-readable assembly instructions. The examine command also
    accepts the format letter `i`, short for *instruction*, to display the memory
    as disassembled assembly language instructions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转换字节顺序外，GDB 还可以使用 `examine` 命令进行其他转换。我们已经看到 GDB 可以将机器语言指令反汇编成人类可读的汇编指令。`examine`
    命令也接受格式字母 `i`，代表 *instruction*，以显示内存为反汇编的汇编语言指令。
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the output above, the `a.out` program is run in GDB, with a breakpoint set
    at `main().` Since the EIP register is pointing to memory that actually contains
    machine language instructions, they disassemble quite nicely.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，`a.out` 程序在 GDB 中运行，并在 `main()` 处设置了断点。由于 EIP 寄存器指向实际包含机器语言指令的内存，它们反汇编得相当好。
- en: The previous `objdump` disassembly confirms that the seven bytes EIP is pointing
    to actually are machine language for the corresponding assembly instruction.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `objdump` 汇编确认，EIP 所指向的七个字节实际上是对应汇编指令的机器语言。
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This assembly instruction will move the value of 0 into memory located at the
    address stored in the EBP register, minus 4\. This is where the C variable `i`
    is stored in memory; `i` was declared as an integer that uses 4 bytes of memory
    on the *x*86 processor. Basically, this command will zero out the variable `i`
    for the for loop. If that memory is examined right now, it will contain nothing
    but random garbage. The memory at this location can be examined several different
    ways.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编指令会将值 0 移入存储在 EBP 寄存器地址减 4 的内存中。这是 C 变量 `i` 在内存中的存储位置；`i` 被声明为一个占用 4 个字节的整数，在
    *x86* 处理器上。基本上，这个命令会将循环中的变量 `i` 清零。如果现在检查这个内存，它将只包含随机垃圾。这个位置的内存可以通过几种不同的方式进行检查。
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The EBP register is shown to contain the address `0xbffff808`, and the assembly
    instruction will be writing to a value offset by 4 less than that, `0xbffff804`.
    The examine command can examine this memory address directly or by doing the math
    on the fly. The `print` command can also be used to do simple math, but the result
    is stored in a temporary variable in the debugger. This variable named `$1` can
    be used later to quickly re-access a particular location in memory. Any of the
    methods shown above will accomplish the same task: displaying the 4 garbage bytes
    found in memory that will be zeroed out when the current instruction executes.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: EBP 寄存器显示包含地址 `0xbffff808`，汇编指令将写入比这低 4 个偏移量的值，即 `0xbffff804`。可以使用 `examine`
    命令直接检查这个内存地址，或者通过即时计算。`print` 命令也可以用来进行简单的数学运算，但结果存储在调试器的临时变量中。这个名为 `$1` 的变量可以在以后快速重新访问内存中的特定位置。上述任何一种方法都可以完成相同的任务：显示在当前指令执行时将被清零的内存中的
    4 个垃圾字节。
- en: Let's execute the current instruction using the command `nexti`, which is short
    for *next instruction*. The processor will read the instruction at EIP, execute
    it, and advance EIP to the next instruction.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `nexti` 命令执行当前指令，它代表 *next instruction*。处理器将读取 EIP 中的指令，执行它，并将 EIP 前进到下一个指令。
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As predicted, the previous command zeroes out the 4 bytes found at EBP minus
    4, which is memory set aside for the C variable `i`. Then EIP advances to the
    next instruction. The next few instructions actually make more sense to talk about
    in a group.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如预测的那样，之前的命令将 EBP 减 4 找到的 4 个字节清零，这是为 C 变量 `i` 预留的内存。然后 EIP 前进到下一个指令。接下来的几个指令实际上更值得作为一个组来讨论。
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first instruction, `cmp`, is a compare instruction, which will compare
    the memory used by the C variable `i` with the value 9\. The next instruction,
    `jle` stands for *jump if less than or equal to*. It uses the results of the previous
    comparison (which are actually stored in the EFLAGS register) to jump EIP to point
    to a different part of the code if the destination of the previous comparison
    operation is less than or equal to the source. In this case the instruction says
    to jump to the address `0x8048393` if the value stored in memory for the C variable
    `i` is less than or equal to the value 9\. If this isn''t the case, the EIP will
    continue to the next instruction, which is an unconditional jump instruction.
    This will cause the EIP to jump to the address `0x80483a6`. These three instructions
    combine to create an if-then-else control structure: *If the i is less than or
    equal to 9, then go to the instruction at address 0x8048393; otherwise, go to
    the instruction at address 0x80483a6*. The first address of `0x8048393` (shown
    in bold) is simply the instruction found after the fixed jump instruction, and
    the second address of `0x80483a6` (shown in italics) is located at the end of
    the function.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令，`cmp`，是一个比较指令，它将 C 变量 `i` 所使用的内存与值 9 进行比较。下一条指令，`jle`，代表 *跳转如果小于或等于*。它使用前一次比较的结果（实际上存储在
    EFLAGS 寄存器中）来决定是否将 EIP 跳转到代码的不同部分。如果前一次比较操作的目标小于或等于源，则执行跳转。在这种情况下，指令表示如果 C 变量
    `i` 存储在内存中的值小于或等于 9，则跳转到地址 `0x8048393`。如果不是这种情况，EIP 将继续执行下一条指令，这是一条无条件跳转指令。这将导致
    EIP 跳转到地址 `0x80483a6`。这三条指令组合起来创建了一个 if-then-else 控制结构：*如果 i 小于或等于 9，则跳转到地址 0x8048393
    的指令；否则，跳转到地址 0x80483a6*。`0x8048393` 的第一个地址（加粗显示）是固定跳转指令之后的指令，而 `0x80483a6` 的第二个地址（斜体显示）位于函数的末尾。
- en: Since we know the value 0 is stored in the memory location being compared with
    the value 9, and we know that 0 is less than or equal to 9, EIP should be at `0x8048393`
    after executing the next two instructions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道值 0 存储在正在与值 9 进行比较的内存位置中，并且我们知道 0 小于或等于 9，因此在执行下两条指令后，EIP 应该位于 `0x8048393`。
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As expected, the previous two instructions let the program execution flow down
    to `0x8048393`, which brings us to the next two instructions. The first instruction
    is another `mov` instruction that will write the address `0x8048484` into the
    memory address contained in the ESP register. But what is ESP pointing to?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，前两条指令让程序执行流程下转到 `0x8048393`，这带我们来到了下两条指令。第一条指令是另一个 `mov` 指令，它将地址 `0x8048484`
    写入 ESP 寄存器所包含的内存地址。但 ESP 指向的是什么？
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Currently, ESP points to the memory address `0xbffff800`, so when the `mov`
    instruction is executed, the address `0x8048484` is written there. But why? What's
    so special about the memory address `0x8048484`? There's one way to find out.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，ESP 指向内存地址 `0xbffff800`，因此当执行 `mov` 指令时，地址 `0x8048484` 被写入那里。但为什么？内存地址 `0x8048484`
    有什么特别之处？有一种方法可以找出答案。
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A trained eye might notice something about the memory here, in particular the
    range of the bytes. After examining memory for long enough, these types of visual
    patterns become more apparent. These bytes fall within the printable ASCII range.
    *ASCII* is an agreed-upon standard that maps all the characters on your keyboard
    (and some that aren't) to fixed numbers. The bytes `0x48, 0x65, 0x6c`, and `0x6f`
    all correspond to letters in the alphabet on the ASCII table shown below. This
    table is found in the man page for ASCII, available on most Unix systems by typing
    `man ascii`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的眼睛可能会注意到这里内存的一些情况，特别是字节的范围。经过足够长时间的内存检查，这些类型的视觉模式会变得更加明显。这些字节位于可打印的 ASCII
    范围内。*ASCII* 是一个协议，将键盘上的所有字符（以及一些不是的字符）映射到固定的数字。字节 `0x48, 0x65, 0x6c` 和 `0x6f`
    都对应于下面显示的 ASCII 表中的字母。这个表可以在 ASCII 的 man 页面上找到，大多数 Unix 系统中可以通过输入 `man ascii`
    来访问。
- en: ASCII Table
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASCII 表
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Thankfully, GDB's examine command also contains provisions for looking at this
    type of memory. The `c` format letter can be used to automatically look up a byte
    on the ASCII table, and the `s` format letter will display an entire string of
    character data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，GDB 的 examine 命令也包含查看此类内存的条款。可以使用 `c` 格式字母自动查找 ASCII 表上的字节，而 `s` 格式字母将显示整个字符串字符数据。
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: These commands reveal that the data string `"Hello, world!\n"` is stored at
    memory address `0x8048484`. This string is the argument for the `printf()` function,
    which indicates that moving the address of this string to the address tored in
    ESP (`0x8048484`) has something to do with this function. The following output
    shows the data string's address being moved into the address ESP is pointing to.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令显示数据字符串 `"Hello, world!\n"` 存储在内存地址 `0x8048484`。这个字符串是 `printf()` 函数的参数，这表明将这个字符串的地址移动到
    ESP (`0x8048484`) 中与这个函数有关。下面的输出显示了数据字符串的地址被移动到 ESP 指向的地址。
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The next instruction is actually called the `printf()` function; it prints the
    data string. The previous instruction was setting up for the function call, and
    the results of the function call can be seen in the output below in bold.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令实际上是 `printf()` 函数；它打印数据字符串。前面的指令是为函数调用做准备，函数调用的结果可以在下面的输出中用粗体看到。
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Continuing to use GDB to debug, let's examine the next two instructions. Once
    again, they make more sense to look at in a group.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 GDB 进行调试，让我们检查下两条指令。再次，它们作为一个组来看更有意义。
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: These two instructions basically just increment the variable `i` by 1\. The
    `lea` instruction is an acronym for *Load Effective Address*, which will load
    the familiar address of EBP minus 4 into the EAX register. The execution of this
    instruction is shown below.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令基本上只是将变量 `i` 递增 1。`lea` 指令是 *Load Effective Address* 的缩写，它将 EBP 减 4 的熟悉地址加载到
    EAX 寄存器中。此指令的执行情况如下所示。
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The following `inc` instruction will increment the value found at this address
    (now stored in the EAX register) by 1\. The execution of this instruction is also
    shown below.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `inc` 指令将此地址（现在存储在 EAX 寄存器中）的值加 1。此指令的执行情况也如下所示。
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The end result is the value stored at the memory address EBP minus 4 (`0xbffff804`),
    incremented by 1\. This behavior corresponds to a portion of C code in which the
    variable `i` is incremented in the for loop.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是存储在内存地址 EBP 减 4 (`0xbffff804`) 处的值，加 1。这种行为对应于一段 C 代码，其中变量 `i` 在 for 循环中被递增。
- en: The next instruction is an unconditional jump instruction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是一个无条件跳转指令。
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When this instruction is executed, it will send the program back to the instruction
    at address `0x804838b`. It does this by simply setting EIP to that value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此指令时，它将程序送回到地址 `0x804838b` 的指令。它是通过简单地设置 EIP 为该值来做到这一点的。
- en: Looking at the full disassembly again, you should be able to tell which parts
    of the C code have been compiled into which machine instructions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看完整的反汇编代码，你应该能够判断出哪些 C 代码被编译成了哪些机器指令。
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The instructions shown in bold make up the for loop, and the instructions in
    italics are the `printf()` call found within the loop. The program execution will
    jump back to the compare instruction, continue to execute the `printf()` call,
    and increment the counter variable until it finally equals 10\. At this point
    the conditional `jle` instruction won't execute; instead, the instruction pointer
    will continue to the unconditional jump instruction, which exits the loop and
    ends the program.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体显示的指令构成了 for 循环，斜体显示的是循环内的 `printf()` 调用。程序执行将跳回比较指令，继续执行 `printf()` 调用，并递增计数器变量，直到它最终等于
    10。此时，条件 `jle` 指令不会执行；相反，指令指针将继续到无条件跳转指令，退出循环并结束程序。
- en: Back to Basics
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归基础
- en: Now that the idea of programming is less abstract, there are a few other important
    concepts to know about C. Assembly language and computer processors existed before
    higher-level programming languages, and many modern programming concepts have
    evolved through time. In the same way that knowing a little about Latin can greatly
    improve one's understanding of the English language, knowledge of low-level programming
    concepts can assist the comprehension of higher-level ones. When continuing to
    the next section, remember that C code must be compiled into machine instructions
    before it can do anything.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编程的概念不那么抽象了，还有一些关于 C 语言的重要概念需要了解。汇编语言和计算机处理器在高级编程语言之前就存在了，许多现代编程概念都是随着时间的推移而演化的。就像对拉丁语的一点点了解可以极大地提高一个人对英语语言的理解一样，对底层编程概念的了解可以帮助理解高级概念。在继续下一节时，请记住，C
    代码必须编译成机器指令后才能执行任何操作。
- en: Strings
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: The value `"Hello, world!\n"` passed to the `printf()` function in the previous
    program is a string—technically, a character array. In C, an *array* is simply
    a list of *n* elements of a specific data type. A 20-character array is simply
    20 adjacent characters located in memory. Arrays are also referred to as *buffers*.
    The char_array.c program is an example of a character array.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中传递给`printf()`函数的值`"Hello, world!\n"`是一个字符串——技术上讲，是一个字符数组。在C语言中，*数组*简单地是一系列特定数据类型的*n*个元素。一个20个字符的数组仅仅是内存中20个相邻的字符。数组也被称为*缓冲区*。char_array.c程序是一个字符数组的例子。
- en: char_array.c
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: char_array.c
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The GCC compiler can also be given the `-o` switch to define the output file
    to compile to. This switch is used below to compile the program into an executable
    binary called `char_array`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: GCC编译器也可以使用`-o`开关来定义编译输出的文件。此开关在下面用于将程序编译成名为`char_array`的可执行二进制文件。
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding program, a 20-element character array is defined as `str_a`,
    and each element of the array is written to, one by one. Notice that the number
    begins at 0, as opposed to 1\. Also notice that the last character is a 0\. (This
    is also called a *null byte*.) The character array was defined, so 20 bytes are
    allocated for it, but only 12 of these bytes are actually used. The null byte
    at the end is used as a delimiter character to tell any function that is dealing
    with the string to stop operations right there. The remaining extra bytes are
    just garbage and will be ignored. If a null byte is inserted in the fifth element
    of the character array, only the characters `Hello` would be printed by the `printf()`
    function.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，定义了一个20个元素的字符数组`str_a`，并且逐个将数组元素写入。请注意，数字从0开始，而不是从1开始。同时请注意，最后一个字符是0。（这通常也被称为*空字节*。）由于字符数组被定义，因此为它分配了20个字节，但实际上只使用了12个字节。末尾的空字节用作分隔符，以告诉任何处理字符串的函数在此处停止操作。剩余的额外字节只是垃圾，将被忽略。如果在字符数组的第五个元素中插入一个空字节，`printf()`函数只会打印出`Hello`。
- en: 'Since setting each character in a character array is painstaking and strings
    are used fairly often, a set of standard functions was created for string manipulation.
    For example, the `strcpy()` function will copy a string from a source to a destination,
    iterating through the source string and copying each byte to the destination (and
    stopping after it copies the null termination byte). The order of the function''s
    arguments is similar to Intel assembly syntax: destination first and then source.
    The char_array.c program can be rewritten using `strcpy()` to accomplish the same
    thing using the string library. The next version of the char_array program shown
    below includes string.h since it uses a string function.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逐个设置字符数组中的每个字符非常繁琐，而字符串的使用相当频繁，因此创建了一套标准函数用于字符串操作。例如，`strcpy()`函数将从源字符串复制到目标字符串，遍历源字符串并将每个字节复制到目标位置（并在复制空终止字节后停止）。函数参数的顺序类似于Intel汇编语法：目标在前，然后是源。char_array.c程序可以使用`strcpy()`重写，以使用字符串库完成相同的功能。下面所示的char_array程序的下一个版本包括string.h，因为它使用了字符串函数。
- en: char_array2.c
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: char_array2.c
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Let's take a look at this program with GDB. In the output below, the compiled
    program is opened with GDB and breakpoints are set before, in, and after the `strcpy()`
    call shown in bold. The debugger will pause the program at each breakpoint, giving
    us a chance to examine registers and memory. The `strcpy()` function's code comes
    from a shared library, so the breakpoint in this function can't actually be set
    until the program is executed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用GDB来看看这个程序。在下面的输出中，编译后的程序用GDB打开，并在加粗显示的`strcpy()`调用之前、期间和之后设置了断点。调试器将在每个断点暂停程序，给我们机会检查寄存器和内存。`strcpy()`函数的代码来自共享库，因此在此函数中设置断点实际上只能在程序执行后进行。
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When the program is run, the `strcpy()` breakpoint is resolved. At each breakpoint,
    we're going to look at EIP and the instructions it points to. Notice that the
    memory location for EIP at the middle breakpoint is different.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，`strcpy()`断点被解决。在每个断点处，我们将查看EIP及其指向的指令。请注意，中间断点的EIP内存位置不同。
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The address in EIP at the middle breakpoint is different because the code for
    the `strcpy()` function comes from a loaded library. In fact, the debugger shows
    EIP for the middle breakpoint in the `strcpy()` function, while EIP at the other
    two breakpoints is in the `main()` function. I'd like to point out that EIP is
    able to travel from the main code to the `strcpy()` code and back again. Each
    time a function is called, a record is kept on a data structure simply called
    the stack. The *stack* lets EIP return through long chains of function calls.
    In GDB, the `bt` command can be used to backtrace the stack. In the output below,
    the stack backtrace is shown at each breakpoint.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 中间断点处的EIP地址不同，因为`strcpy()`函数的代码来自一个已加载的库。实际上，调试器显示中间断点处的`strcpy()`函数的EIP，而其他两个断点处的EIP在`main()`函数中。我想指出，EIP能够从主代码跳转到`strcpy()`代码，然后再返回。每次函数被调用时，都会在称为堆栈的数据结构上保留一个记录。堆栈允许EIP通过一系列函数调用返回。在GDB中，可以使用`bt`命令来回溯堆栈。在下面的输出中，堆栈回溯显示在每个断点处。
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: At the middle breakpoint, the backtrace of the stack shows its record of the
    `strcpy()` call. Also, you may notice that the `strcpy()` function is at a slightly
    different address during the second run. This is due to an exploit protection
    method that is turned on by default in the Linux kernel since 2.6.11\. We will
    talk about this protection in more detail later.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间断点处，堆栈的回溯显示了`strcpy()`函数的调用记录。同时，你可能注意到在第二次运行时`strcpy()`函数的地址略有不同。这是由于自Linux内核2.6.11以来默认启用的一个利用保护方法。我们将在稍后详细讨论这个保护机制。
- en: Signed, Unsigned, Long, and Short
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名，未签名，长整型和短整型
- en: By default, numerical values in C are signed, which means they can be both negative
    and positive. In contrast, unsigned values don't allow negative numbers. Since
    it's all just memory in the end, all numerical values must be stored in binary,
    and unsigned values make the most sense in binary. A 32-bit unsigned integer can
    contain values from 0 (all binary 0s) to 4,294,967,295 (all binary 1s). A 32-bit
    signed integer is still just 32 bits, which means it can only be in one of 2^(32)
    possible bit combinations. This allows 32-bit signed integers to range from –2,147,483,648
    to 2,147,483,647\. Essentially, one of the bits is a flag marking the value positive
    or negative. Positively signed values look the same as unsigned values, but negative
    numbers are stored differently using a method called two's complement. *Two's
    complement* represents negative numbers in a form suited for binary adders—when
    a negative value in two's complement is added to a positive number of the same
    magnitude, the result will be 0\. This is done by first writing the positive number
    in binary, then inverting all the bits, and finally adding 1\. It sounds strange,
    but it works and allows negative numbers to be added in combination with positive
    numbers using simple binary adders.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C语言中的数值是有符号的，这意味着它们可以是负数也可以是正数。相比之下，无符号值不允许负数。由于最终都是内存，所有数值都必须以二进制形式存储，无符号值在二进制中更有意义。一个32位无符号整数可以包含从0（所有二进制0）到4,294,967,295（所有二进制1）的值。一个32位有符号整数仍然是32位，这意味着它只能处于2^(32)种可能的位组合之一。这允许32位有符号整数从-2,147,483,648到2,147,483,647的范围。本质上，其中一位是一个标记值正或负的标志。正的有符号值看起来和无符号值一样，但负数使用称为二进制补码的方法存储。二进制补码以适合二进制加法器的方式表示负数——当二进制补码中的负值与相同大小的正值相加时，结果将是0。这是通过首先以二进制形式写出正数，然后反转所有位，最后加1来完成的。这听起来很奇怪，但它确实有效，并允许使用简单的二进制加法器将负数与正数相加。
- en: This can be explored quickly on a smaller scale using `pcalc`, a simple programmer's
    calculator that displays results in decimal, hexadecimal, and binary formats.
    For simplicity's sake, 8-bit numbers are used in this example.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用`pcalc`（一个简单的程序员计算器，以十进制、十六进制和二进制格式显示结果）在较小的规模上快速探索。为了简化，本例中使用8位数字。
- en: '[PRE64]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: First, the binary value 01001001 is shown to be positive 73\. Then all the bits
    are flipped, and 1 is added to result in the two's complement representation for
    negative 73, 10110111\. When these two values are added together, the result of
    the original 8 bits is 0\. The program `pcalc` shows the value 256 because it's
    not aware that we're only dealing with 8-bit values. In a binary adder, that carry
    bit would just be thrown away because the end of the variable's memory would have
    been reached. This example might shed some light on how two's complement works
    its magic.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，二进制值01001001被显示为正73。然后所有位都被反转，并加1得到负73的二进制补码表示10110111。当这两个值相加时，原始8位的结果为0。程序`pcalc`显示值为256，因为它不知道我们只处理8位值。在二进制加法器中，那个进位位会被丢弃，因为变量的内存末尾已经到达。这个例子可能有助于阐明二进制补码是如何发挥其魔力的。
- en: In C, variables can be declared as unsigned by simply prepending the keyword
    `unsigned` to the declaration. An unsigned integer would be declared with `unsigned
    int`. In addition, the size of numerical variables can be extended or shortened
    by adding the keywords `long` or `short`. The actual sizes will vary depending
    on the architecture the code is compiled for. The language of C provides a macro
    called `sizeof()` that can determine the size of certain data types. This works
    like a function that takes a data type as its input and returns the size of a
    variable declared with that data type for the target architecture. The datatype_sizes.c
    program explores the sizes of various data types, using the `sizeof()` function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，可以通过在声明前简单添加关键字`unsigned`来声明变量为无符号。无符号整数可以用`unsigned int`声明。此外，可以通过添加关键字`long`或`short`来扩展或缩短数值变量的大小。实际的大小将取决于代码编译的架构。C语言提供了一种名为`sizeof()`的宏，可以确定某些数据类型的大小。这就像一个函数，它接受一个数据类型作为输入，并返回目标架构上用该数据类型声明的变量的大小。`datatype_sizes.c`程序通过使用`sizeof()`函数探索各种数据类型的大小。
- en: datatype_sizes.c
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: datatype_sizes.c
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This piece of code uses the `printf()` function in a slightly different way.
    It uses something called a format specifier to display the value returned from
    the `sizeof()` function calls. Format specifiers will be explained in depth later,
    so for now, let's just focus on the program's output.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以稍微不同的方式使用了`printf()`函数。它使用了一种称为格式说明符的东西来显示`sizeof()`函数调用返回的值。格式说明符将在稍后深入解释，所以现在让我们只关注程序输出。
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As previously stated, both signed and unsigned integers are four bytes in size
    on the *x*86 architecture. A float is also four bytes, while a char only needs
    a single byte. The `long` and `short` keywords can also be used with floating-point
    variables to extend and shorten their sizes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在*x*86架构上，有符号和无符号整数的大小都是四字节。浮点数也是四字节，而字符只需要一个字节。`long`和`short`关键字也可以与浮点变量一起使用，以扩展和缩短它们的大小。
- en: Pointers
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针
- en: The EIP register is a pointer that "points" to the current instruction during
    a program's execution by containing its memory address. The idea of pointers is
    used in C, also. Since the physical memory cannot actually be moved, the information
    in it must be copied. It can be very computationally expensive to copy large chunks
    of memory to be used by different functions or in different places. This is also
    expensive from a memory standpoint, since space for the new destination copy must
    be saved or allocated before the source can be copied. Pointers are a solution
    to this problem. Instead of copying a large block of memory, it is much simpler
    to pass around the address of the beginning of that block of memory.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: EIP寄存器是一个指针，在程序执行过程中通过包含其内存地址来“指向”当前指令。指针的概念在C语言中也被使用。由于物理内存实际上不能移动，其中的信息必须被复制。复制大量内存以供不同函数或不同地方使用可能会非常耗费计算资源。从内存的角度来看，这也是昂贵的，因为必须在复制源之前保存或分配新目标复制所需的空间。指针是解决这个问题的方法。而不是复制一大块内存，传递那块内存块的起始地址要简单得多。
- en: Pointers in C can be defined and used like any other variable type. Since memory
    on the *x*86 architecture uses 32-bit addressing, pointers are also 32 bits in
    size (4 bytes). Pointers are defined by prepending an asterisk (*) to the variable
    name. Instead of defining a variable of that type, a pointer is defined as something
    that points to data of that type. The pointer.c program is an example of a pointer
    being used with the `char` data type, which is only 1 byte in size.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的指针可以像任何其他变量类型一样定义和使用。由于*x*86架构上的内存使用32位寻址，指针的大小也是32位（4字节）。指针通过在变量名前加上一个星号(*)来定义。不是定义一个该类型的变量，而是定义一个指向该类型数据的指针。`pointer.c`程序是一个使用`char`数据类型的指针的例子，`char`数据类型的大小仅为1字节。
- en: pointer.c
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pointer.c
- en: '[PRE67]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As the comments in the code indicate, the first pointer is set at the beginning
    of the character array. When the character array is referenced like this, it is
    actually a pointer itself. This is how this buffer was passed as a pointer to
    the `printf()` and `strcpy()` functions earlier. The second pointer is set to
    the first pointer's address plus two, and then some things are printed (shown
    in the output below).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码中的注释所示，第一个指针被设置在字符数组的起始位置。当以这种方式引用字符数组时，它实际上就是一个指针。这就是这个缓冲区之前是如何作为一个指针传递给`printf()`和`strcpy()`函数的。第二个指针被设置为第一个指针的地址加2，然后打印了一些内容（如下面的输出所示）。
- en: '[PRE68]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Let's take a look at this with GDB. The program is recompiled, and a breakpoint
    is set on the tenth line of the source code. This will stop the program after
    the `"Hello, world!\n"` string has been copied into the `str_a`buffer and the
    pointer variable is set to the beginning of it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用GDB来看看这个例子。程序被重新编译，并在源代码的第10行设置了断点。这将使得程序在将`"Hello, world!\n"`字符串复制到`str_a`缓冲区并且指针变量被设置为它的起始地址后停止。
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When the pointer is examined as a string, it's apparent that the given string
    is there and is located at memory address `0xbffff7e0`. Remember that the string
    itself isn't stored in the pointer variable—only the memory address `0xbffff7e0`
    is stored there.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当指针被作为一个字符串检查时，很明显给定的字符串就在那里，并且位于内存地址`0xbffff7e0`。记住，字符串本身并没有存储在指针变量中——只有内存地址`0xbffff7e0`被存储在那里。
- en: In order to see the actual data stored in the pointer variable, you must use
    the address-of operator. The address-of operator is a *unary operator*, which
    simply means it operates on a single argument. This operator is just an ampersand
    (&) prepended to a variable name. When it's used, the address of that variable
    is returned, instead of the variable itself. This operator exists both in GDB
    and in the C programming language.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到指针变量中实际存储的数据，你必须使用地址运算符。地址运算符是一个*一元运算符*，这意味着它只对一个参数进行操作。这个运算符只是变量名前加上一个&符号。当它被使用时，返回的是变量的地址，而不是变量本身。这个运算符在GDB和C编程语言中都存在。
- en: '[PRE70]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When the address-of operator is used, the pointer variable is shown to be located
    at the address `0xbffff7dc` in memory, and it contains the address `0xbffff7e0`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用地址运算符时，指针变量显示其在内存中的地址为`0xbffff7dc`，并且它包含地址`0xbffff7e0`。
- en: The address-of operator is often used in conjunction with pointers, since pointers
    contain memory addresses. The addressof.c program demonstrates the address-of
    operator being used to put the address of an integer variable into a pointer.
    This line is shown in bold below.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 地址运算符通常与指针一起使用，因为指针包含内存地址。`addressof.c`程序演示了地址运算符被用来将一个整型变量的地址放入指针中。下面这行内容被加粗显示。
- en: addressof.c
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: addressof.c
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The program itself doesn't actually output anything, but you can probably guess
    what happens, even before debugging with GDB.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 程序本身实际上并没有输出任何内容，但你可能猜得出会发生什么，甚至在用GDB调试之前。
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As usual, a breakpoint is set and the program is executed in the debugger. At
    this point the majority of the program has executed. The first `print` command
    shows the value of `int_var`, and the second shows its address using the address-of
    operator. The next two print commands show that `int_ptr` contains the address
    of `int_var`, and they also show the address of the `int_ptr` for good measure.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，设置了断点并在调试器中执行程序。此时，程序的大部分已经执行完毕。第一个`print`命令显示了`int_var`的值，第二个显示了它的地址，使用了地址运算符。接下来的两个打印命令显示了`int_ptr`包含`int_var`的地址，并且还显示了`int_ptr`的地址作为额外信息。
- en: An additional unary operator called the *dereference* operator exists for use
    with pointers. This operator will return the data found in the address the pointer
    is pointing to, instead of the address itself. It takes the form of an asterisk
    in front of the variable name, similar to the declaration of a pointer. Once again,
    the dereference operator exists both in GDB and in C. Used in GDB, it can retrieve
    the integer value `int_ptr` points to.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着一个额外的单目运算符，称为解引用运算符，用于与指针一起使用。这个运算符将返回指针指向的地址中的数据，而不是地址本身。它以变量名前的星号(*)形式出现，类似于指针的声明。再次强调，解引用运算符在
    GDB 和 C 中都存在。在 GDB 中使用时，它可以检索 `int_ptr` 指向的整数值。
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: A few additions to the addressof.c code (shown in addressof2.c) will demonstrate
    all of these concepts. The added `printf()` functions use format parameters, which
    I'll explain in the next section. For now, just focus on the program's output.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 addressof.c 代码（在 addressof2.c 中显示）中添加一些内容（将演示所有这些概念。添加的 `printf()` 函数使用格式参数，我将在下一节中解释。现在，只需关注程序输出即可。
- en: addressof2.c
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: addressof2.c
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The results of compiling and executing addressof2.c are as follows.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行 addressof2.c 的结果如下。
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When the unary operators are used with pointers, the address-of operator can
    be thought of as moving backward, while the dereference operator moves forward
    in the direction the pointer is pointing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当单目运算符与指针一起使用时，地址运算符可以被认为是向相反方向移动，而解引用运算符则沿着指针指向的方向前进。
- en: Format Strings
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式字符串
- en: The `printf()` function can be used to print more than just fixed strings. This
    function can also use format strings to print variables in many different formats.
    A *format string* is just a character string with special escape sequences that
    tell the function to insert variables printed in a specific format in place of
    the escape sequence. The way the `printf()` function has been used in the previous
    programs, the `"Hello, world!\n"` string technically is the format string; however,
    it is devoid of special escape sequences. These *escape sequences* are also called
    *format parameters*, and for each one found in the format string, the function
    is expected to take an additional argument. Each format parameter begins with
    a percent sign (%) and uses a single-character shorthand very similar to formatting
    characters used by GDB's examine command.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()` 函数不仅可以打印固定字符串，还可以使用格式字符串以多种不同的格式打印变量。*格式字符串* 只是一个包含特殊转义序列的字符字符串，这些转义序列告诉函数在转义序列的位置插入以特定格式打印的变量。在前面程序中使用
    `printf()` 函数的方式中，`"Hello, world!\n"` 字符串在技术上是一个格式字符串；然而，它没有特殊的转义序列。这些 *转义序列*
    也被称为 *格式参数*，并且对于格式字符串中找到的每个格式参数，函数都期望有一个额外的参数。每个格式参数以百分号(%)开头，并使用与 GDB 的 examine
    命令中使用的格式字符非常相似的单一字符缩写。'
- en: '| Parameter | Output Type |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 输出类型 |'
- en: '| --- | --- |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%d` | Decimal |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 十进制 |'
- en: '| `%u` | Unsigned decimal |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `%u` | 无符号十进制 |'
- en: '| `%x` | Hexadecimal |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 十六进制 |'
- en: All of the preceding format parameters receive their data as values, not pointers
    to values. There are also some format parameters that expect pointers, such as
    the following.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述格式参数都接收它们的值，而不是值的指针。还有一些格式参数期望指针，如下所示。
- en: '| Parameter | Output Type |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 输出类型 |'
- en: '| --- | --- |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%s` | String |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 字符串 |'
- en: '| `%n` | Number of bytes written so far |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `%n` | 已写入的字节数 |'
- en: The `%s` format parameter expects to be given a memory address; it prints the
    data at that memory address until a null byte is encountered. The `%n`format parameter
    is unique in that it actually writes data. It also expects to be given a memory
    address, and it writes the number of bytes that have been written so far into
    that memory address.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`%s` 格式参数期望得到一个内存地址；它将打印该内存地址处的数据，直到遇到空字节。`%n` 格式参数是独一无二的，因为它实际上会写入数据。它也期望得到一个内存地址，并将迄今为止写入该内存地址的字节数写入进去。'
- en: For now, our focus will just be the format parameters used for displaying data.
    The fmt_strings.c program shows some examples of different format parameters.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的重点将只是用于显示数据的格式参数。fmt_strings.c 程序展示了不同格式参数的一些示例。
- en: fmt_strings.c
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fmt_strings.c
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding code, additional variable arguments are passed to each `printf()`
    call for every format parameter in the format string. The final `printf()` call
    uses the argument `A`, which will provide the address of the variable `A`. The
    program's compilation and execution are as follows.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，为格式字符串中的每个格式参数的每个 `printf()` 调用传递了额外的变量参数。最后的 `printf()` 调用使用参数 `A`，这将提供变量
    `A` 的地址。程序的编译和执行如下。
- en: '[PRE77]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The first two calls to `printf()` demonstrate the printing of variables `A`
    and `B`, using different format parameters. Since there are three format parameters
    in each line, the variables `A` and `B` need to be supplied three times each.
    The `%d` format parameter allows for negative values, while `%u` does not, since
    it is expecting unsigned values.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()` 的前两次调用演示了使用不同的格式参数打印变量 `A` 和 `B`。由于每行有三个格式参数，变量 `A` 和 `B` 需要分别提供三次。`%d`
    格式参数允许负值，而 `%u` 不允许，因为它期望无符号值。'
- en: When the variable `A` is printed using the `%u` format parameter, it appears
    as a very high value. This is because `A` is a negative number stored in two's
    complement, and the format parameter is trying to print it as if it were an unsigned
    value. Since two's complement flips all the bits and adds one, the very high bits
    that used to be zero are now one.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量 `A` 使用 `%u` 格式参数打印时，它显示为一个非常高的值。这是因为 `A` 是一个以二进制补码形式存储的负数，而格式参数正试图将其作为无符号值打印。由于二进制补码翻转所有位并加一，之前为零的高位现在变为一位。
- en: The third line in the example, labeled `[field width on B]`, shows the use of
    the field-width option in a format parameter. This is just an integer that designates
    the minimum field width for that format parameter. However, this is not a maximum
    field width—if the value to be outputted is greater than the field width, the
    field width will be exceeded. This happens when 3 is used, since the output data
    needs 5 bytes. When 10 is used as the field width, 5 bytes of blank space are
    outputted before the output data. Additionally, if a field width value begins
    with a 0, this means the field should be padded with zeros. When 08 is used, for
    example, the output is 00031337.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的第三行，标记为 `[field width on B]`，展示了在格式参数中使用字段宽度选项。这只是一个指定该格式参数的最小字段宽度的整数。然而，这并不是最大字段宽度——如果要输出的值大于字段宽度，则字段宽度将被超出。当使用
    3 时就会发生这种情况，因为输出数据需要 5 个字节。当使用 10 作为字段宽度时，在输出数据之前输出 5 个空格字节。此外，如果字段宽度值以 0 开头，这意味着字段应该用零填充。例如，当使用
    08 时，输出为 00031337。
- en: The fourth line, labeled `[string]`, simply shows the use of the `%s` format
    parameter. Remember that the variable string is actually a pointer containing
    the address of the string, which works out wonderfully, since the `%s` format
    parameter expects its data to be passed by reference.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 `[string]` 的第四行简单地展示了 `%s` 格式参数的使用。记住，变量字符串实际上是一个包含字符串地址的指针，这工作得非常好，因为 `%s`
    格式参数期望通过引用传递数据。
- en: The final line just shows the address of the variable `A`, using the unary address
    operator to dereference the variable. This value is displayed as eight hexadecimal
    digits, padded by zeros.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的行仅显示了变量 `A` 的地址，使用一元地址运算符取消引用变量。此值以八个十六进制数字显示，并用零填充。
- en: As these examples show, you should use `%d` for decimal, `%u` for unsigned,
    and `%x` for hexadecimal values. Minimum field widths can be set by putting a
    number right after the percent sign, and if the field width begins with 0, it
    will be padded with zeros. The `%s` parameter can be used to print strings and
    should be passed the address of the string. So far, so good.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例所示，你应该使用 `%d` 打印十进制值，使用 `%u` 打印无符号值，使用 `%x` 打印十六进制值。可以通过在百分号后直接放置一个数字来设置最小字段宽度，如果字段宽度以
    0 开头，它将被零填充。`%s` 参数可以用来打印字符串，并且应该传递字符串的地址。到目前为止，一切顺利。
- en: Format strings are used by an entire family of standard I/O functions, including
    `scanf()`, which basically works like `printf()` but is used for input instead
    of output. One key difference is that the `scanf()` function expects all of its
    arguments to be pointers, so the arguments must actually be variable addresses—not
    the variables themselves. This can be done using pointer variables or by using
    the unary address operator to retrieve the address of the normal variables. The
    input.c program and execution should help explain.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串被一系列标准I/O函数使用，包括`scanf()`，它基本上像`printf()`一样工作，但用于输入而不是输出。一个关键的区别是，`scanf()`函数期望其所有参数都是指针，因此参数必须是变量地址——而不是变量本身。这可以通过使用指针变量或使用一元地址运算符来检索普通变量的地址来实现。`input.c`程序和执行结果应该有助于解释。
- en: input.c
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`input.c`'
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In input.c, the `scanf()` function is used to set the `count` variable. The
    output below demonstrates its use.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`input.c`文件中，使用`scanf()`函数来设置`count`变量。下面的输出展示了其用法。
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Format strings are used quite often, so familiarity with them is valuable. In
    addition, the ability to output the values of variables allows for debugging in
    the program, without the use of a debugger. Having some form of immediate feedback
    is fairly vital to the hacker's learning process, and something as simple as printing
    the value of a variable can allow for lots of exploitation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串被非常频繁地使用，因此熟悉它们是有价值的。此外，能够输出变量的值允许在程序中进行调试，而不需要使用调试器。对于黑客的学习过程来说，某种形式的即时反馈是相当关键的，而像打印变量值这样简单的事情就可以允许进行大量的利用。
- en: Typecasting
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: '*Typecasting* is simply a way to temporarily change a variable''s data type,
    despite how it was originally defined. When a variable is typecast into a different
    type, the compiler is basically told to treat that variable as if it were the
    new data type, but only for that operation. The syntax for typecasting is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*只是临时改变变量数据类型的一种方法，尽管它最初是如何定义的。当一个变量被转换为不同类型时，编译器基本上被指示将那个变量视为新数据类型，但仅限于该操作。类型转换的语法如下：'
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This can be used when dealing with integers and floating-point variables, as
    typecasting.c demonstrates.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在处理整数和浮点变量时使用，正如`typecasting.c`文件所展示的。
- en: typecasting.c
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`typecasting.c`'
- en: '[PRE81]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The results of compiling and executing typecasting.c are as follows.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行`typecasting.c`的结果如下。
- en: '[PRE82]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As discussed earlier, dividing the integer 13 by 5 will round down to the incorrect
    answer of 2, even if this value is being stored into a floating-point variable.
    However, if these integer variables are typecast into floats, they will be treated
    as such. This allows for the correct calculation of 2.6.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将整数13除以5将向下取整到错误答案2，即使这个值被存储到浮点变量中。然而，如果这些整数变量被转换为浮点数，它们将被视为这样。这允许正确计算2.6。
- en: This example is illustrative, but where typecasting really shines is when it
    is used with pointer variables. Even though a pointer is just a memory address,
    the C compiler still demands a data type for every pointer. One reason for this
    is to try to limit programming errors. An integer pointer should only point to
    integer data, while a character pointer should only point to character data. Another
    reason is for pointer arithmetic. An integer is four bytes in size, while a character
    only takes up a single byte. The pointer_types.c program will demonstrate and
    explain these concepts further. This code uses the format parameter `%p` to output
    memory addresses. This is shorthand meant for displaying pointers and is basically
    equivalent to `0x%08x`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是说明性的，但类型转换真正发挥作用的地方是当它与指针变量一起使用时。尽管指针只是一个内存地址，但C编译器仍然要求每个指针都有一个数据类型。这样做的一个原因是为了尽量减少编程错误。整数指针应该只指向整数数据，而字符指针应该只指向字符数据。另一个原因是用于指针算术。整数的大小是四个字节，而字符只占用一个字节。`pointer_types.c`程序将进一步演示和解释这些概念。此代码使用格式参数`%p`来输出内存地址。这是一个用于显示指针的简写，基本上等同于`0x%08x`。
- en: pointer_types.c
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`pointer_types.c`'
- en: '[PRE83]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this code two arrays are defined in memory—one containing integer data and
    the other containing character data. Two pointers are also defined, one with the
    integer data type and one with the character data type, and they are set to point
    at the start of the corresponding data arrays. Two separate for loops iterate
    through the arrays using pointer arithmetic to adjust the pointer to point at
    the next value. In the loops, when the integer and character values are actually
    printed with the `%d` and `%c` format parameters, notice that the corresponding
    `printf()` arguments must dereference the pointer variables. This is done using
    the unary * operator and has been marked above in bold.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，内存中定义了两个数组——一个包含整数数据，另一个包含字符数据。还定义了两个指针，一个具有整数数据类型，一个具有字符数据类型，并将它们设置为指向对应数据数组的起始位置。两个独立的for循环通过指针算术迭代数组，以调整指针指向下一个值。在循环中，当使用`%d`和`%c`格式参数实际打印整数和字符值时，请注意相应的`printf()`参数必须取消引用指针变量。这是通过使用一元`*`运算符完成的，并在上面用粗体标出。
- en: '[PRE84]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Even though the same value of 1 is added to `int_pointer` and `char_pointer`
    in their respective loops, the compiler increments the pointer's addresses by
    different amounts. Since a char is only 1 byte, the pointer to the next char would
    naturally also be 1 byte over. But since an integer is 4 bytes, a pointer to the
    next integer has to be 4 bytes over.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在各自的循环中向`int_pointer`和`char_pointer`添加相同的值1，编译器也会以不同的数量增加指针的地址。由于char只有1个字节，指向下一个char的指针自然会多1个字节。但既然整数是4个字节，指向下一个整数的指针就必须多4个字节。
- en: In pointer_types2.c, the pointers are juxtaposed such that the `int_pointer`
    points to the character data and vice versa. The major changes to the code are
    marked in bold.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在pointer_types2.c中，指针被并置，使得`int_pointer`指向字符数据，反之亦然。代码的主要更改用粗体标出。
- en: pointer_types2.c
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pointer_types2.c
- en: '[PRE85]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The output below shows the warnings spewed forth from the compiler.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示了编译器输出的警告。
- en: '[PRE86]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In an attempt to prevent programming mistakes, the compiler gives warnings about
    pointers that point to incompatible data types. But the compiler and perhaps the
    programmer are the only ones that care about a pointer's type. In the compiled
    code, a pointer is nothing more than a memory address, so the compiler will still
    compile the code if a pointer points to an incompatible data type—it simply warns
    the programmer to anticipate unexpected results.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止编程错误，编译器会对指向不兼容数据类型的指针给出警告。但编译器和可能还有程序员是唯一关心指针类型的人。在编译后的代码中，指针不过是一个内存地址，所以如果指针指向不兼容的数据类型，编译器仍然会编译代码——它只是警告程序员要预料到意外的结果。
- en: '[PRE87]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Even though the `int_pointer` points to character data that only contains 5
    bytes of data, it is still typed as an integer. This means that adding 1 to the
    pointer will increment the address by 4 each time. Similarly, the `char_pointer`'s
    address is only incremented by 1 each time, stepping through the 20 bytes of integer
    data (five 4-byte integers), one byte at a time. Once again, the littleendian
    byte order of the integer data is apparent when the 4-byte integer is examined
    one byte at a time. The 4-byte value of `0x00000001` is actually stored in memory
    as `0x01, 0x00, 0x00, 0x00`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`int_pointer`指向的字符数据只包含5个字节的数据，它仍然被类型化为整数。这意味着每次向指针添加1时，地址会增加4。同样，`char_pointer`的地址每次只增加1，逐字节遍历20个字节的整数数据（五个4字节的整数）。再次强调，当逐字节检查4字节的整数时，整数数据的littleendian字节序是明显的。`0x00000001`的4字节值实际上在内存中存储为`0x01,
    0x00, 0x00, 0x00`。
- en: There will be situations like this in which you are using a pointer that points
    to data with a conflicting type. Since the pointer type determines the size of
    the data it points to, it's important that the type is correct. As you can see
    in pointer_types3.c below, typecasting is just a way to change the type of a variable
    on the fly.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将会出现这种情况，即你使用了一个指向具有冲突类型的数据的指针。由于指针类型决定了它指向的数据的大小，因此确保类型正确非常重要。正如你在下面的pointer_types3.c中可以看到，类型转换只是动态更改变量类型的一种方式。
- en: pointer_types3.c
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pointer_types3.c
- en: '[PRE88]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this code, when the pointers are initially set, the data is typecast into
    the pointer's data type. This will prevent the C compiler from complaining about
    the conflicting data types; however, any pointer arithmetic will still be incorrect.
    To fix that, when 1 is added to the pointers, they must first be typecast into
    the correct data type so the address is incremented by the correct amount. Then
    this pointer needs to be typecast back into the pointer's data type once again.
    It doesn't look too pretty, but it works.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，当指针最初设置时，数据会被转换成指针的数据类型。这将防止C编译器对冲突的数据类型发出抱怨；然而，任何指针运算仍然是不正确的。为了修复这个问题，当向指针加1时，它们必须首先被转换成正确的数据类型，以便地址能以正确的量增加。然后这个指针需要再次被转换回指针的数据类型。这看起来不太美观，但它是有效的。
- en: '[PRE89]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Naturally, it is far easier just to use the correct data type for pointers in
    the first place; however, sometimes a generic, typeless pointer is desired. In
    C, a void pointer is a typeless pointer, defined by the `void` keyword. Experimenting
    with void pointers quickly reveals a few things about typeless pointers. First,
    pointers cannot be de-referenced unless they have a type. In order to retrieve
    the value stored in the pointer's memory address, the compiler must first know
    what type of data it is. Secondly, void pointers must also be typecast before
    doing pointer arithmetic. These are fairly intuitive limitations, which means
    that a void pointer's main purpose is to simply hold a memory address.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，一开始就为指针使用正确的数据类型要容易得多；然而，有时需要一个通用的、无类型的指针。在C语言中，空指针是一个无类型的指针，由`void`关键字定义。对空指针的实验很快就会揭示关于无类型指针的一些事情。首先，指针不能被取消引用除非它们有一个类型。为了检索指针内存地址中存储的值，编译器必须首先知道它是什么类型的数据。其次，在进行指针运算之前，空指针也必须进行类型转换。这些限制相当直观，这意味着空指针的主要目的是简单地持有内存地址。
- en: The pointer_types3.c program can be modified to use a single void pointer by
    typecasting it to the proper type each time it's used. The compiler knows that
    a void pointer is typeless, so any type of pointer can be stored in a void pointer
    without typecasting. This also means a void pointer must always be typecast when
    dereferencing it, however. These differences can be seen in pointer_types4.c,
    which uses a void pointer.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过每次使用时将其类型转换成正确的类型来修改pointer_types3.c程序，以使用单个空指针。编译器知道空指针是无类型的，所以任何类型的指针都可以存储在空指针中而不需要类型转换。这也意味着在取消引用时，空指针必须始终进行类型转换。这些差异可以在使用空指针的pointer_types4.c中看到。
- en: pointer_types4.c
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pointer_types4.c
- en: '[PRE90]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The results of compiling and executing pointer_types4.c are as follows.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行pointer_types4.c的结果如下。
- en: '[PRE91]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The compilation and output of this pointer_types4.c is basically the same as
    that for pointer_types3.c. The void pointer is really just holding the memory
    addresses, while the hard-coded typecasting is telling the compiler to use the
    proper types whenever the pointer is used.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: pointer_types4.c的编译和输出基本上与pointer_types3.c相同。空指针实际上只是持有内存地址，而硬编码的类型转换则告诉编译器在指针使用时使用正确的类型。
- en: Since the type is taken care of by the typecasts, the void pointer is truly
    nothing more than a memory address. With the data types defined by typecasting,
    anything that is big enough to hold a four-byte value can work the same way as
    a void pointer. In pointer_types5.c, an unsigned integer is used to store this
    address.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型由类型转换处理，空指针实际上不过是一个内存地址。通过类型转换定义的数据类型，任何足够大以容纳四个字节值的对象都可以像空指针一样工作。在pointer_types5.c中，使用无符号整数来存储这个地址。
- en: pointer_types5.c
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pointer_types5.c
- en: '[PRE92]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is rather hacky, but since this integer value is typecast into the proper
    pointer types when it is assigned and de-referenced, the end result is the same.
    Notice that instead of typecasting multiple times to do pointer arithmetic on
    an unsigned integer (which isn't even a pointer), the `sizeof()` function is used
    to achieve the same result using normal arithmetic.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当是种权宜之计，但因为这个整数值在赋值和取消引用时被转换成了正确的指针类型，最终结果是一样的。注意，不是通过多次类型转换对无符号整数（它甚至不是一个指针）进行指针运算，而是使用`sizeof()`函数通过常规算术达到相同的结果。
- en: '[PRE93]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The important thing to remember about variables in C is that the compiler is
    the only thing that cares about a variable's type. In the end, after the program
    has been compiled, the variables are nothing more than memory addresses. This
    means that variables of one type can easily be coerced into behaving like another
    type by telling the compiler to typecast them into the desired type.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C语言中的变量，需要记住的重要一点是编译器是唯一关心变量类型的。最终，在程序编译完成后，变量不过是一些内存地址。这意味着可以通过告诉编译器将它们类型转换为所需的类型，轻松地将一种类型的变量强制转换为另一种类型的行为。
- en: Command-Line Arguments
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行参数
- en: Many nongraphical programs receive input in the form of command-line arguments.
    Unlike inputting with `scanf()`, command-line arguments don't require user interaction
    after the program has begun execution. This tends to be more efficient and is
    a useful input method.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 许多非图形程序以命令行参数的形式接收输入。与使用`scanf()`输入不同，命令行参数在程序开始执行后不需要用户交互。这通常更高效，并且是一种有用的输入方法。
- en: 'In C, command-line arguments can be accessed in the `main()` function by including
    two additional arguments to the function: an integer and a pointer to an array
    of strings. The integer will contain the number of arguments, and the array of
    strings will contain each of those arguments. The commandline.c program and its
    execution should explain things.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，可以通过向函数添加两个额外的参数来在`main()`函数中访问命令行参数：一个整数和一个指向字符串数组的指针。整数将包含参数的数量，字符串数组将包含每个参数。commandline.c程序及其执行应该能解释清楚。
- en: commandline.c
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: commandline.c
- en: '[PRE94]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The zeroth argument is always the name of the executing binary, and the rest
    of the argument array (often called an *argument vector*) contains the remaining
    arguments as strings.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 零级参数始终是执行二进制的名称，其余的参数数组（通常称为*参数向量*）包含剩余的参数作为字符串。
- en: Sometimes a program will want to use a command-line argument as an integer as
    opposed to a string. Regardless of this, the argument is passed in as a string;
    however, there are standard conversion functions. Unlike simple typecasting, these
    functions can actually convert character arrays containing numbers into actual
    integers. The most common of these functions is `atoi()`, which is short for *ASCII
    to integer*. This function accepts a pointer to a string as its argument and returns
    the integer value it represents. Observe its usage in convert.c.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 有时程序可能希望将命令行参数用作整数而不是字符串。不管怎样，参数都是以字符串的形式传递的；然而，存在标准转换函数。与简单的类型转换不同，这些函数实际上可以将包含数字的字符数组转换为实际的整数。这些函数中最常见的是`atoi()`，它是*ASCII
    to integer*的缩写。这个函数接受一个指向字符串的指针作为其参数，并返回它所表示的整数值。观察它在convert.c中的使用。
- en: convert.c
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: convert.c
- en: '[PRE95]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The results of compiling and executing convert.c are as follows.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行convert.c的结果如下。
- en: '[PRE96]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the preceding code, an `if` statement makes sure that three arguments are
    used before these strings are accessed. If the program tries to access memory
    that doesn't exist or that the program doesn't have permission to read, the program
    will crash. In C it's important to check for these types of conditions and handle
    them in program logic. If the error-checking `if` statement is commented out,
    this memory violation can be explored. The convert2.c program should make this
    more clear.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个`if`语句确保在访问这些字符串之前使用了三个参数。如果程序尝试访问不存在或程序没有权限读取的内存，程序将会崩溃。在C语言中，检查这些类型的条件并在程序逻辑中处理它们非常重要。如果注释掉了错误检查的`if`语句，就可以探索这种内存违规。convert2.c程序应该使这一点更加明确。
- en: convert2.c
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: convert2.c
- en: '[PRE97]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The results of compiling and executing convert2.c are as follows.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行convert2.c的结果如下。
- en: '[PRE98]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: When the program isn't given enough command-line arguments, it still tries to
    access elements of the argument array, even though they don't exist. This results
    in the program crashing due to a segmentation fault.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序没有足够的命令行参数时，它仍然试图访问参数数组中的元素，即使它们不存在。这导致程序由于段错误而崩溃。
- en: Memory is split into segments (which will be discussed later), and some memory
    addresses aren't within the boundaries of the memory segments the program is given
    access to. When the program attempts to access an address that is out of bounds,
    it will crash and die in what's called a *segmentation fault*. This effect can
    be explored further with GDB.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 内存被分割成段（稍后将会讨论），并且一些内存地址不在程序被赋予访问权限的内存段边界内。当程序尝试访问超出范围的地址时，它将崩溃并称为*段错误*。这种效果可以通过GDB进一步探索。
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The program is executed with a single command-line argument of `test` within
    GDB, which causes the program to crash. The `where` command will sometimes show
    a useful backtrace of the stack; however, in this case, the stack was too badly
    mangled in the crash. A breakpoint is set on main and the program is re-executed
    to get the value of the argument vector (shown in bold). Since the argument vector
    is a pointer to list of strings, it is actually a pointer to a list of pointers.
    Using the command `x/3xw` to examine the first three memory addresses stored at
    the argument vector's address shows that they are themselves pointers to strings.
    The first one is the zeroth argument, the second is the `test` argument, and the
    third is zero, which is out of bounds. When the program tries to access this memory
    address, it crashes with a segmentation fault.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中使用单个命令行参数`test`执行程序，这会导致程序崩溃。`where`命令有时会显示有用的堆栈回溯；然而，在这种情况下，堆栈在崩溃时被严重破坏。在`main`函数上设置断点并重新执行程序以获取参数向量（以粗体显示）的值。由于参数向量是指向字符串列表的指针，因此它实际上是指向指针列表的指针。使用`x/3xw`命令检查参数向量地址存储的前三个内存地址，显示它们自身是指向字符串的指针。第一个是指零参数，第二个是`test`参数，第三个是零，超出了范围。当程序尝试访问这个内存地址时，它会因段错误而崩溃。
- en: Variable Scoping
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域
- en: Another interesting concept regarding memory in C is variable scoping or context—in
    particular, the contexts of variables within functions. Each function has its
    own set of local variables, which are independent of everything else. In fact,
    multiple calls to the same function all have their own contexts. You can use the
    `printf()` function with format strings to quickly explore this;check it out in
    scope.c.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C语言中内存的另一个有趣的概念是变量作用域或上下文——特别是函数内变量的上下文。每个函数都有自己的局部变量集合，它们与其他一切无关。实际上，对同一函数的多次调用都有自己的上下文。你可以使用带有格式字符串的`printf()`函数快速探索这一点；在scope.c中查看它。
- en: scope.c
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scope.c
- en: '[PRE100]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The output of this simple program demonstrates nested function calls.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单程序的输出展示了嵌套函数调用。
- en: '[PRE101]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In each function, the variable `i` is set to a different value and printed.
    Notice that within the `main()` function, the variable `i` is 3, even after calling
    `func1()` where the variable `i` is 5\. Similarly, within `func1()` the variable
    `i` remains 5, even after calling `func2()` where `i` is 7, and so forth. The
    best way to think of this is that each function call has its own version of the
    variable `i`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个函数中，变量`i`被设置为不同的值并打印出来。注意，在`main()`函数中，变量`i`是3，即使在调用`func1()`之后，变量`i`是5。同样，在`func1()`中，变量`i`保持为5，即使在调用`func2()`之后，`i`是7，依此类推。最好的理解方式是，每个函数调用都有自己的变量`i`版本。
- en: Variables can also have a global scope, which means they will persist across
    all functions. Variables are global if they are defined at the beginning of the
    code, outside of any functions. In the scope2.c example code shown below, the
    variable `j` is declared globally and set to 42\. This variable can be read from
    and written to by any function, and the changes to it will persist between functions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以具有全局作用域，这意味着它们将在所有函数中持续存在。如果变量在代码的开始处定义，且不在任何函数内部，则变量是全局的。在下面的scope2.c示例代码中，变量`j`被全局声明并设置为42。这个变量可以被任何函数读取和写入，并且对其的更改将在函数之间持续存在。
- en: scope2.c
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scope2.c
- en: '[PRE102]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The results of compiling and executing scope2.c are as follows.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行scope2.c的结果如下。
- en: '[PRE103]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In the output, the global variable `j` is written to in `func2()`, and the change
    persists in all functions except `func3()`, which has its own local variable called
    `j`. In this case, the compiler prefers to use the local variable. With all these
    variables using the same names, it can be a little confusing, but remember that
    in the end, it's all just memory. The global variable `j` is just stored in memory,
    and every function is able to access that memory. The local variables for each
    function are each stored in their own places in memory, regardless of the identical
    names. Printing the memory addresses of these variables will give a clearer picture
    of what's going on. In the scope3.c example code below, the variable addresses
    are printed using the unary address-of operator.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，全局变量`j`在`func2()`中被写入，并且这种变化在除了`func3()`之外的所有函数中都持续存在，因为`func3()`有自己的局部变量名为`j`。在这种情况下，编译器更倾向于使用局部变量。由于所有这些变量都使用相同的名称，可能会有些混乱，但请记住，最终，这都只是内存。全局变量`j`只是存储在内存中，每个函数都能访问那个内存。每个函数的局部变量都存储在内存中的特定位置，无论名称是否相同。打印这些变量的内存地址将给出更清晰的画面。在下面的scope3.c示例代码中，变量地址是通过使用一元地址运算符来打印的。
- en: scope3.c
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scope3.c
- en: '[PRE104]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The results of compiling and executing scope3.c are as follows.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行scope3.c的结果如下。
- en: '[PRE105]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In this output, it is obvious that the variable `j` used by `func3()` is different
    than the `j` used by the other functions. The `j` used by `func3()` is located
    at `0xbffff7d0`, while the `j` used by the other functions is located at `0x08049988`.
    Also, notice that the variable `i` is actually a different memory address for
    each function.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，很明显`func3()`使用的变量`j`与其他函数使用的`j`不同。`func3()`使用的`j`位于`0xbffff7d0`，而其他函数使用的`j`位于`0x08049988`。此外，请注意变量`i`对每个函数来说实际上是一个不同的内存地址。
- en: In the following output, GDB is used to stop execution at a breakpoint in `func3()`.
    Then the backtrace command shows the record of each function call on the stack.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，GDB用于在`func3()`的断点处停止执行。然后回溯命令显示了堆栈上每个函数调用的记录。
- en: '[PRE106]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The backtrace also shows the nested function calls by looking at records kept
    on the stack. Each time a function is called, a record called a *stack frame*
    is put on the stack. Each line in the backtrace corresponds to a stack frame.
    Each stack frame also contains the local variables for that context. The local
    variables contained in each stack frame can be shown in GDB by adding the word
    *full* to the backtrace command.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯还通过查看堆栈上保留的记录来显示嵌套函数调用。每次函数被调用时，都会在堆栈上放置一个称为*堆栈帧*的记录。回溯中的每一行对应一个堆栈帧。每个堆栈帧还包含该上下文中的局部变量。可以通过在回溯命令中添加单词*full*来在GDB中显示每个堆栈帧包含的局部变量。
- en: '[PRE107]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The full backtrace clearly shows that the local variable `j` only exists in
    `func3()`'s context. The global version of the variable `j` is used in the other
    function's contexts.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的回溯清楚地显示局部变量`j`仅在`func3()`的上下文中存在。全局版本的变量`j`在其他函数的上下文中使用。
- en: In addition to globals, variables can also be defined as static variables by
    prepending the keyword `static` to the variable definition. Similar to global
    variables, a *static variable* remains intact between function calls; however,
    static variables are also akin to local variables since they remain local within
    a particular function context. One different and unique feature of static variables
    is that they are only initialized once. The code in static.c will help explain
    these concepts.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 除了全局变量之外，变量也可以通过在变量定义前添加关键字`static`来定义为静态变量。与全局变量类似，*静态变量*在函数调用之间保持不变；然而，静态变量也类似于局部变量，因为它们在特定的函数上下文中保持局部。静态变量的一个不同且独特的特性是它们只初始化一次。static.c中的代码将有助于解释这些概念。
- en: static.c
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: static.c
- en: '[PRE108]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The aptly named `static_var` is defined as a static variable in two places:
    within the context of `main()` and within the context of `function()`. Since static
    variables are local within a particular functional context, these variables can
    have the same name, but they actually represent two different locations in memory.
    The function simply prints the values of the two variables in its context and
    then adds 1 to both of them. Compiling and executing this code will show the difference
    between the static and nonstatic variables.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 正确命名的`static_var`在两个地方被定义为静态变量：在`main()`的上下文中和在`function()`的上下文中。由于静态变量在特定的功能上下文中是局部的，这些变量可以具有相同的名称，但它们实际上代表内存中的两个不同位置。该函数只是在其上下文中打印两个变量的值，然后将它们各自加1。编译和执行此代码将显示静态变量和非静态变量之间的差异。
- en: '[PRE109]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Notice that the `static_var` retains its value between subsequent calls to `function()`.
    This is because static variables retain their values, but also because they are
    only initialized once. In addition, since the static variables are local to a
    particular functional context, the `static_var` in the context of `main()` retains
    its value of 1337 the entire time.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`static_var`在后续调用`function()`之间保留其值。这是因为静态变量保留其值，也因为它们只初始化一次。此外，由于静态变量是特定功能上下文内的局部变量，`main()`上下文中的`static_var`在整个过程中都保留了其值为1337。
- en: Once again, printing the addresses of these variables by dereferencing them
    with the unary address operator will provide greater viability into what's really
    going on. Take a look at static2.c for an example.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，通过使用一元地址运算符解引用这些变量的地址来打印它们，将提供对实际发生情况的更深入了解。请查看static2.c以获取示例。
- en: static2.c
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: static2.c
- en: '[PRE110]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The results of compiling and executing static2.c are as follows.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行static2.c的结果如下。
- en: '[PRE111]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: With the addresses of the variables displayed, it is apparent that the `static_var`
    in `main()` is different than the one found in `function()`, since they are located
    at different memory addresses (`0x804968c` and `0x8049688`, respectively). You
    may have noticed that the addresses of the local variables all have very high
    addresses, like `0xbffff814`, while the global and static variables all have very
    low memory addresses, like `0x0804968c` and `0x8049688`. That's very astute of
    you—noticing details like this and asking why is one of the cornerstones of hacking.
    Read on for your answers.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 显示变量地址后，很明显，`main()`中的`static_var`与`function()`中找到的`static_var`不同，因为它们位于不同的内存地址（分别为`0x804968c`和`0x8049688`）。你可能已经注意到，局部变量的地址都非常高，如`0xbffff814`，而全局和静态变量的内存地址都非常低，如`0x0804968c`和`0x8049688`。你非常敏锐——注意到这样的细节并询问为什么是黑客技术的基石之一。继续阅读以获取你的答案。
- en: Memory Segmentation
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分段
- en: 'A compiled program''s memory is divided into five segments: text, data, bss,
    heap, and stack. Each segment represents a special portion of memory that is set
    aside for a certain purpose.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 编译程序的内存被分为五个部分：文本段、数据段、bss段、堆和栈。每个部分代表内存中为特定目的预留的特殊部分。
- en: 'The *text segment* is also sometimes called the *code segment*. This is where
    the assembled machine language instructions of the program are located. The execution
    of instructions in this segment is nonlinear, thanks to the aforementioned high-level
    control structures and functions, which compile into branch, jump, and call instructions
    in assembly language. As a program executes, the EIP is set to the first instruction
    in the text segment. The processor then follows an execution loop that does the
    following:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*文本段*有时也被称为*代码段*。这是程序汇编的机器语言指令所在的位置。由于上述高级控制结构和函数将编译成汇编语言中的分支、跳转和调用指令，该段中的指令执行是非线性的。当程序执行时，EIP被设置为文本段中的第一条指令。然后处理器遵循一个执行循环，执行以下操作：'
- en: Reads the instruction that EIP is pointing to
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取EIP指向的指令
- en: Adds the byte length of the instruction to EIP
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指令的字节长度添加到EIP
- en: Executes the instruction that was read in step 1
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行步骤1中读取的指令
- en: Goes back to step 1
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回步骤1
- en: Sometimes the instruction will be a jump or a call instruction, which changes
    the EIP to a different address of memory. The processor doesn't care about the
    change, because it's expecting the execution to be nonlinear anyway. If EIP is
    changed in step 3, the processor will just go back to step 1 and read the instruction
    found at the address of whatever EIP was changed to.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 有时指令将是一个跳转或调用指令，这会将EIP更改为内存中的不同地址。处理器并不关心这种变化，因为它本来就在期待执行是非线性的。如果EIP在步骤3中发生变化，处理器将直接回到步骤1，并读取EIP更改到的地址处的指令。
- en: Write permission is disabled in the text segment, as it is not used to store
    variables, only code. This prevents people from actually modifying the program
    code; any attempt to write to this segment of memory will cause the program to
    alert the user that something bad happened, and the program will be killed. Another
    advantage of this segment being read-only is that it can be shared among different
    copies of the program, allowing multiple executions of the program at the same
    time without any problems. It should also be noted that this memory segment has
    a fixed size, since nothing ever changes in it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 文本段中的写权限被禁用，因为它不用于存储变量，只用于存储代码。这防止了人们实际修改程序代码；任何尝试写入此内存段的尝试都将导致程序通知用户发生了错误，并且程序将被终止。这个段的只读性还有另一个优点，即它可以被程序的不同副本共享，允许程序同时执行而不会出现任何问题。还应该注意的是，这个内存段的大小是固定的，因为其中没有任何东西会发生变化。
- en: The data and bss segments are used to store global and static program variables.
    The *data segment* is filled with the initialized global and static variables,
    while the *bss segment* is filled with their uninitialized counterparts. Although
    these segments are writable, they also have a fixed size. Remember that global
    variables persist, despite the functional context (like the variable `j` in the
    previous examples). Both global and static variables are able to persist because
    they are stored in their own memory segments.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 数据段和bss段用于存储全局和静态程序变量。*数据段*填充了初始化的全局和静态变量，而*bss段*填充了它们的未初始化对应物。尽管这些段是可写的，但它们也有一个固定的大小。记住，全局变量是持久的，尽管它们的功能上下文（如前例中的变量`j`）。全局和静态变量能够持久存在，因为它们存储在自己的内存段中。
- en: The *heap segment* is a segment of memory a programmer can directly control.
    Blocks of memory in this segment can be allocated and used for whatever the programmer
    might need. One notable point about the heap segment is that it isn't of fixed
    size, so it can grow larger or smaller as needed. All of the memory within the
    heap is managed by allocator and deallocator algorithms, which respectively reserve
    a region of memory in the heap for use and remove reservations to allow that portion
    of memory to be reused for later reservations. The heap will grow and shrink depending
    on how much memory is reserved for use. This means a programmer using the heap
    allocation functions can reserve and free memory on the fly. The growth of the
    heap moves downward toward higher memory addresses.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆段*是程序员可以直接控制的内存段。该段中的内存块可以被分配并用于程序员可能需要的任何用途。关于堆段的一个显著点是它的大小不是固定的，因此它可以根据需要增长或缩小。堆中的所有内存都由分配器和释放器算法管理，分别保留堆中的内存区域以供使用，并取消保留以允许该部分内存被重新用于后续的保留。堆的大小将根据保留的内存量而增长和缩小。这意味着使用堆分配函数的程序员可以在运行时保留和释放内存。堆的增长是向更高内存地址方向下降的。'
- en: The *stack segment* also has variable size and is used as a temporary scratch
    pad to store local function variables and context during function calls. This
    is what GDB's backtrace command looks at. When a program calls a function, that
    function will have its own set of passed variables, and the function's code will
    be at a different memory location in the text (or code) segment. Since the context
    and the EIP must change when a function is called, the stack is used to remember
    all of the passed variables, the location the EIP should return to after the function
    is finished, and all the local variables used by that function. All of this information
    is stored together on the stack in what is collectively called a *stack frame*.
    The stack contains many stack frames.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈段*也具有可变大小，并在函数调用期间用作临时暂存区，用于存储局部函数变量和上下文。这就是GDB的backtrace命令查看的内容。当程序调用一个函数时，该函数将有自己的传递变量集，并且函数的代码将在文本（或代码）段的不同内存位置。由于上下文和EIP在函数调用时必须改变，因此栈用于记住所有传递的变量、函数完成后EIP应返回的位置以及该函数使用的所有局部变量。所有这些信息都存储在栈上，统称为*栈帧*。栈包含许多栈帧。'
- en: In general computer science terms, a *stack* is an abstract data structure that
    is used frequently. It has *first-in, last-out (FILO) ordering*, which means the
    first item that is put into a stack is the last item to come out of it. Think
    of it as putting beads on a piece of string that has a knot on one end—you can't
    get the first bead off until you have removed all the other beads. When an item
    is placed into a stack, it's known as *pushing*, and when an item is removed from
    a stack, it's called *popping*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学的一般术语中，*栈*是一种常用的抽象数据结构。它具有*先进后出（FILO）*的顺序，这意味着首先放入栈中的项目是最后从栈中出来的。想象一下，在一条一端有结的线绳上串珠子——你无法取下第一个珠子，直到你移除了所有的其他珠子。当一个项目放入栈中时，这被称为*压入*，而当一个项目从栈中移除时，这被称为*弹出*。
- en: As the name implies, the stack segment of memory is, in fact, a stack data structure,
    which contains stack frames. The ESP register is used to keep track of the address
    of the end of the stack, which is constantly changing as items are pushed into
    and popped off of it. Since this is very dynamic behavior, it makes sense that
    the stack is also not of a fixed size. Opposite to the dynamic growth of the heap,
    as the stack changes in size, it grows upward in a visual listing of memory, toward
    lower memory addresses.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，内存的栈段实际上是一个栈数据结构，其中包含栈帧。ESP寄存器用于跟踪栈末端的地址，该地址随着项目的推入和弹出而不断变化。由于这是一种非常动态的行为，因此栈不是固定大小的也很有道理。与堆的动态增长相反，当栈改变大小时，它在内存的可视列表中向上增长，朝向较低的内存地址。
- en: 'The FILO nature of a stack might seem odd, but since the stack is used to store
    context, it''s very useful. When a function is called, several things are pushed
    to the stack together in a *stack frame*. The EBP register—sometimes called the
    *frame pointer (FP)* or *local base (LB) pointer*— is used to reference local
    function variables in the current stack frame. Each stack frame contains the parameters
    to the function, its local variables, and two pointers that are necessary to put
    things back the way they were: the saved frame pointer (SFP) and the return address.
    The *SFP* is used to restore EBP to its previous value, and the *return address*
    is used to restore EIP to the next instruction found after the function call.
    This restores the functional context of the previous stack frame.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的FILO特性可能看起来有些奇怪，但鉴于栈用于存储上下文，它非常有用。当一个函数被调用时，一些东西会一起推入栈中，形成一个*栈帧*。EBP寄存器——有时被称为*帧指针（FP）*或*局部基（LB）指针*——用于引用当前栈帧中的局部函数变量。每个栈帧都包含函数的参数、其局部变量以及两个必要的指针，用于将事物恢复原状：保存的帧指针（SFP）和返回地址。*SFP*用于将EBP恢复到其先前的值，而*返回地址*用于将EIP恢复到函数调用后找到的下一条指令。这恢复了先前栈帧的功能上下文。
- en: 'The following stack_example.c code has two functions: `main()` and `test_function()`.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下stack_example.c代码有两个函数：`main()`和`test_function()`。
- en: Memory Segmentation
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分段
- en: stack_example.c
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stack_example.c
- en: '[PRE112]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This program first declares a test function that has four arguments, which
    are all declared as integers: `a`, `b`, `c`, and `d`. The local variables for
    the function include a single character called `flag` and a 10-character buffer
    called `buffer`. The memory for these variables is in the stack segment, while
    the machine instructions for the function''s code is stored in the text segment.
    After compiling the program, its inner workings can be examined with GDB. The
    following output shows the disassembled machine instructions for `main()` and
    `test_function()`. The `main()` function starts at `0x08048357` and `test_function()`starts
    at `0x08048344`. The first few instructions of each function (shown in bold below)
    set up the stack frame. These instructions are collectively called the *procedure
    prologue* or *function prologue*. They save the frame pointer on the stack, and
    they save stack memory for the local function variables. Sometimes the function
    prologue will handle some stack alignment as well. The exact prologue instructions
    will vary greatly depending on the compiler and compiler options, but in general
    these instructions build the stack frame.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序首先声明了一个具有四个参数的测试函数，这些参数都被声明为整数：`a`、`b`、`c`和`d`。函数的局部变量包括一个名为`flag`的单个字符和一个名为`buffer`的10字符缓冲区。这些变量的内存位于栈段中，而函数代码的机器指令存储在文本段中。编译程序后，可以使用GDB检查其内部工作原理。下面的输出显示了`main()`和`test_function()`的反汇编机器指令。`main()`函数从`0x08048357`开始，`test_function()`从`0x08048344`开始。每个函数的前几条指令（以下用粗体显示）设置栈帧。这些指令统称为*过程序言*或*函数序言*。它们在栈上保存帧指针，并为局部函数变量保存栈内存。有时函数序言还会处理一些栈对齐。确切的序言指令将根据编译器和编译器选项有很大差异，但通常这些指令构建栈帧。
- en: '[PRE113]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: When the program is run, the `main()` function is called, which simply calls
    `test_function()`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，调用`main()`函数，该函数简单地调用`test_function()`。
- en: When the `test_function()` is called from the `main()` function, the various
    values are pushed to the stack to create the start of the stack frame as follows.
    When `test_function()` is called, the function arguments are pushed onto the stack
    in reverse order (since it's FILO). The arguments for the function are 1, 2, 3,
    and 4, so the subsequent push instructions push 4, 3, 2, and finally 1 onto the
    stack. These values correspond to the variables `d`, `c`, `b`, and `a` in the
    function. The instructions that put these values on the stack are shown in bold
    in the `main()` function's disassembly below.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当从`main()`函数调用`test_function()`函数时，各种值被推送到栈中以创建栈帧的起始部分，如下所示。当调用`test_function()`时，函数参数以相反的顺序（因为它是FILO）推送到栈上。函数的参数是1、2、3和4，因此后续的推指令将4、3、2和最后1推送到栈上。这些值对应于函数中的变量`d`、`c`、`b`和`a`。将这些值推送到栈上的指令在下面的`main()`函数反汇编中用粗体显示。
- en: '[PRE114]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Next, when the assembly call instruction is executed, the return address is
    pushed onto the stack and the execution flow jumps to the start of `test_function()`
    at `0x08048344`. The return address value will be the location of the instruction
    following the current EIP—specifically, the value stored during step 3 of the
    previously mentioned execution loop. In this case, the return address would point
    to the leave instruction in `main()` at `0x0804838b`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当执行汇编调用指令时，返回地址被推送到栈上，执行流程跳转到`test_function()`的起始地址`0x08048344`。返回地址的值将是当前EIP之后的指令位置——具体来说，是之前提到的执行循环的第3步中存储的值。在这种情况下，返回地址将指向`main()`中的leave指令，地址为`0x0804838b`。
- en: 'The call instruction both stores the return address on the stack and jumps
    EIP to the beginning of `test_function()`, so `test_function()`''s procedure prologue
    instructions finish building the stack frame. In this step, the current value
    of EBP is pushed to the stack. This value is called the saved frame pointer (SFP)
    and is later used to restore EBP back to its original state. The current value
    of ESP is then copied into EBP to set the new frame pointer. This frame pointer
    is used to reference the local variables of the function (`flag` and `buffer`).
    Memory is saved for these variables by subtracting fromESP. In the end, the stack
    frame looks something like this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 调用指令既将返回地址存储在堆栈上，又将 EIP 跳转到 `test_function()` 的开始处，因此 `test_function()` 的过程序言指令完成了堆栈帧的构建。在这一步中，当前
    EBP 的值被推送到堆栈上。这个值被称为保存的帧指针（SFP），稍后用于将 EBP 恢复到其原始状态。然后，当前 ESP 的值被复制到 EBP 中以设置新的帧指针。这个帧指针用于引用函数的局部变量（`flag`
    和 `buffer`）。通过从 ESP 中减去来为这些变量保存内存。最后，堆栈帧看起来可能如下所示：
- en: '![](httpatomoreillycomsourcenostarchimages254229.png.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](httpatomoreillycomsourcenostarchimages254229.png.jpg)'
- en: Figure 0x200-1.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x200-1。
- en: We can watch the stack frame construction on the stack using GDB. In the following
    output, a breakpoint is set in `main()` before the call to `test_function()`and
    also at the beginning of `test_function()`. GDB will put the first breakpoint
    before the function arguments are pushed to the stack, and the second breakpoint
    after `test_function()`'s procedure prologue. When the program is run, execution
    stops at the breakpoint, where the register's ESP (stack pointer), EBP (frame
    pointer), and EIP (execution pointer) are examined.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 GDB 在堆栈上观察堆栈帧的构建过程。在下面的输出中，在调用 `test_function()` 之前以及在 `test_function()`
    开始处设置了断点。GDB 将第一个断点放在函数参数推送到堆栈之前，第二个断点放在 `test_function()` 的过程序言之后。当程序运行时，执行会在断点处停止，此时会检查寄存器的
    ESP（堆栈指针）、EBP（帧指针）和 EIP（执行指针）。
- en: '[PRE115]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This breakpoint is right before the stack frame for the `test_function()` call
    is created. This means the bottom of this new stack frame is at the current value
    of ESP, `0xbffff7f0`. The next breakpoint is right after the procedure prologue
    for `test_function()`, so continuing will build the stack frame. The output below
    shows similar information at the second breakpoint. The local variables (`flag`
    and `buffer`) are referenced relative to the frame pointer (EBP).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断点正好在创建 `test_function()` 调用的堆栈帧之前。这意味着这个新堆栈帧的底部位于当前 ESP 的值，`0xbffff7f0`。下一个断点正好在
    `test_function()` 的过程序言之后，所以继续执行将构建堆栈帧。下面的输出显示了第二个断点处的类似信息。局部变量（`flag` 和 `buffer`）相对于帧指针（EBP）进行引用。
- en: '[PRE116]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The stack frame is shown on the stack at the end. The four arguments to the
    function can be seen at the bottom of the stack frame (![](httpatomoreillycomsourcenostarchimages254261.png)
    ), with the return address found directly on top (![](httpatomoreillycomsourcenostarchimages254461.png)).
    Above that is the saved frame pointer of `0xbffff808` (![](httpatomoreillycomsourcenostarchimages254537.png)),
    which is what EBP was in the previous stack frame. The rest of the memory is saved
    for the local stack variables: `flag` and `buffer`. Calculating their relative
    addresses to EBP show their exact locations in the stack frame. Memory for the
    `flag` variable is shown at ![](httpatomoreillycomsourcenostarchimages254530.png)
    and memory for the buffer variable is shown at ![](httpatomoreillycomsourcenostarchimages254488.png).
    The extra space in the stack frame is just padding.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈帧在堆栈的末尾显示。函数的四个参数可以在堆栈帧的底部看到（![](httpatomoreillycomsourcenostarchimages254261.png)），返回地址直接位于其上方（![](httpatomoreillycomsourcenostarchimages254461.png)）。之上是
    `0xbffff808` 的保存帧指针（![](httpatomoreillycomsourcenostarchimages254537.png)），这是前一个堆栈帧中
    EBP 的值。其余的内存为局部堆栈变量 `flag` 和 `buffer` 保存。计算它们相对于 EBP 的相对地址以显示它们在堆栈帧中的确切位置。`flag`
    变量的内存显示在 ![](httpatomoreillycomsourcenostarchimages254530.png) 和缓冲区变量的内存显示在 ![](httpatomoreillycomsourcenostarchimages254488.png)。堆栈帧中的额外空间只是填充。
- en: After the execution finishes, the entire stack frame is popped off of the stack,
    and the EIP is set to the return address so the program can continue execution.
    If another function was called within the function, another stack frame would
    be pushed onto the stack, and so on. As each function ends, its stack frame is
    popped off of the stack so execution can be returned to the previous function.
    This behavior is the reason this segment of memory is organized in a FILO data
    structure.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完成后，整个栈帧将从栈中弹出，EIP被设置为返回地址，以便程序可以继续执行。如果在函数内部调用了另一个函数，另一个栈帧将被推入栈中，依此类推。随着每个函数的结束，其栈帧将从栈中弹出，以便执行可以返回到上一个函数。这种行为是为什么这个内存段以FILO（先进后出）数据结构组织的原因。
- en: The various segments of memory are arranged in the order they were presented,
    from the lower memory addresses to the higher memory addresses. Since most people
    are familiar with seeing numbered lists that count downward, the smaller memory
    addresses are shown at the top. Some texts have this reversed, which can be very
    confusing; so for this book, smaller memory addresses are always shown at the
    top. Most debuggers also display memory in this style, with the smaller memory
    addresses at the top and the higher ones at the bottom.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的不同段按照它们被呈现的顺序排列，从较低的内存地址到较高的内存地址。由于大多数人熟悉向下计数的编号列表，较小的内存地址显示在顶部。有些文本将这个顺序颠倒，这可能会非常令人困惑；因此，在这本书中，较小的内存地址总是显示在顶部。大多数调试器也以这种方式显示内存，较小的内存地址在顶部，较高的在底部。
- en: Since the heap and the stack are both dynamic, they both grow in different directions
    toward each other. This minimizes wasted space, allowing the stack to be larger
    if the heap is small and vice versa.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆和栈都是动态的，它们都向对方的方向增长。这最小化了浪费的空间，使得当堆较小时，栈可以更大，反之亦然。
- en: '![](httpatomoreillycomsourcenostarchimages254381.png.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](httpatomoreillycomsourcenostarchimages254381.png.jpg)'
- en: Figure 0x200-2.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x200-2。
- en: Memory Segments in C
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C语言中的内存段
- en: In C, as in other compiled languages, the compiled code goes into the text segment,
    while the variables reside in the remaining segments. Exactly which memory segment
    a variable will be stored in depends on how the variable is defined. Variables
    that are defined outside of any functions are considered to be global. The `static`
    keyword can also be prepended to any variable declaration to make the variable
    static. If static or global variables are initialized with data, they are stored
    in the data memory segment; otherwise, these variables are put in the bss memory
    segment. Memory on the heap memory segment must first be allocated using a memory
    allocation function called `malloc()`. Usually, pointers are used to reference
    memory on the heap. Finally, the remaining function variables are stored in the
    stack memory segment. Since the stack can contain many different stack frames,
    stack variables can maintain uniqueness within different functional contexts.
    The memory_segments.c program will help explain these concepts in C.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，与其他编译型语言一样，编译后的代码存放在文本段，而变量则位于剩余的段中。变量将被存储在哪个内存段中，取决于变量的定义方式。在函数外部定义的变量被认为是全局变量。也可以在任意变量声明前加上`static`关键字，使变量成为静态变量。如果静态或全局变量被初始化为数据，它们将被存储在数据内存段中；否则，这些变量将被放置在bss内存段中。堆内存段的内存必须首先使用名为`malloc()`的内存分配函数进行分配。通常，指针用于引用堆上的内存。最后，剩余的函数变量被存储在堆栈内存段中。由于堆栈可以包含许多不同的栈帧，因此栈变量可以在不同的功能上下文中保持唯一性。`memory_segments.c`程序将帮助解释C语言中的这些概念。
- en: memory_segments.c
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: memory_segments.c
- en: '[PRE117]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Most of this code is fairly self-explanatory because of the descriptive variable
    names. The global and static variables are declared as described earlier, and
    initialized counterparts are also declared. The stack variable is declared both
    in `main()` and in `function()` to showcase the effect of functional contexts.
    The heap variable is actually declared as an integer pointer, which will point
    to memory allocated on the heap memory segment. The `malloc()`function is called
    to allocate four bytes on the heap. Since the newly allocated memory could be
    of any data type, the `malloc()` function returns a void pointer, which needs
    to be typecast into an integer pointer.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量命名具有描述性，大部分代码相当直观。全局和静态变量声明方式如前所述，并且也声明了初始化后的对应变量。栈变量在`main()`和`function()`中都被声明，以展示函数上下文的影响。堆变量实际上被声明为一个整数指针，它将指向堆内存段上分配的内存。调用`malloc()`函数在堆上分配四个字节。由于新分配的内存可以是任何数据类型，`malloc()`函数返回一个空指针，需要将其转换为整数指针。
- en: '[PRE118]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The first two initialized variables have the lowest memory addresses, since
    they are located in the data memory segment. The next two variables, `static_var`
    and `global_var`, are stored in the bss memory segment, since they aren't initialized.
    These memory addresses are slightly larger than the previous variables' addresses,
    since the bss segment is located below the data segment. Since both of these memory
    segments have a fixed size after compilation, there is little wasted space, and
    the addresses aren't very far apart.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个初始化变量具有最低的内存地址，因为它们位于数据内存段。接下来的两个变量，`static_var`和`global_var`，存储在bss内存段，因为它们未初始化。这些内存地址略大于前一个变量的地址，因为bss段位于数据段下方。由于这两个内存段在编译后都具有固定的大小，因此几乎没有浪费的空间，地址之间也不是很远。
- en: The heap variable is stored in space allocated on the heap segment, which is
    located just below the bss segment. Remember that memory in this segment isn't
    fixed, and more space can be dynamically allocated later. Finally, the last two
    `stack_var`s have very large memory addresses, since they are located in the stack
    segment. Memory in the stack isn't fixed, either; however, this memory starts
    at the bottom and grows backward toward the heap segment. This allows both memory
    segments to be dynamic without wasting space in memory. The first `stack_var`
    in the `main()` function's context is stored in the stack segment within a stack
    frame. The second `stack_var` in `function()` has its own unique context, so that
    variable is stored within a different stack frame in the stack segment. When `function()`
    is called near the end of the program, a new stack frame is created to store (among
    other things) the `stack_var` for `function()`'s context. Since the stack grows
    back up toward the heap segment with each new stack frame, the memory address
    for the second `stack_var`(`0xbffff814`) is smaller than the address for the first
    `stack_var` (`0xbffff834`) found within `main()`'s context.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 堆变量存储在堆段上分配的空间中，该段位于bss段下方。请记住，这个段的内存不是固定的，以后还可以动态分配更多空间。最后，最后两个`stack_var`具有非常大的内存地址，因为它们位于栈段。栈中的内存也不是固定的；然而，这个内存从底部开始，向后增长到堆段。这允许两个内存段都是动态的，而不会在内存中浪费空间。`main()`函数上下文中的第一个`stack_var`存储在栈段内的栈帧中。`function()`中的第二个`stack_var`有自己的独特上下文，因此该变量存储在栈段中的不同栈帧中。当在程序接近结束时调用`function()`，会创建一个新的栈帧来存储（其他事物中包括）`function()`上下文的`stack_var`。由于栈随着每个新的栈帧向上增长到堆段，因此第二个`stack_var`（`0xbffff814`）的内存地址小于在`main()`上下文中找到的第一个`stack_var`（`0xbffff834`）的地址。
- en: Using the Heap
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用堆
- en: Using the other memory segments is simply a matter of how you declare variables.
    However, using the heap requires a bit more effort. As previously demonstrated,
    allocating memory on the heap is done using the `malloc()`function. This function
    accepts a size as its only argument and reserves that much space in the heap segment,
    returning the address to the start of this memory as a void pointer. If the `malloc()`
    function can't allocate memory for some reason, it will simply return a NULL pointer
    with a value of 0\. The corresponding deallocation function is `free()`. This
    function accepts a pointer as its only argument and frees that memory space on
    the heap so it can be used again later. These relatively simple functions are
    demonstrated in heap_example.c.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他内存段仅仅是变量声明方式的问题。然而，使用堆则需要更多的努力。正如之前所演示的，在堆上分配内存是通过使用`malloc()`函数来完成的。这个函数接受一个大小作为其唯一的参数，并在堆段中保留相应大小的空间，以空指针的形式返回该内存的起始地址。如果由于某种原因`malloc()`函数无法分配内存，它将简单地返回一个值为0的NULL指针。相应的释放函数是`free()`。这个函数接受一个指针作为其唯一的参数，并释放堆上的内存空间，以便以后再次使用。这些相对简单的函数在heap_example.c中得到了演示。
- en: heap_example.c
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: heap_example.c
- en: '[PRE119]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This program accepts a command-line argument for the size of the first memory
    allocation, with a default value of 50\. Then it uses the `malloc()` and `free()`
    functions to allocate and deallocate memory on the heap. There are plenty of `printf()`
    statements to debug what is actually happening when the program is executed. Since
    `malloc()` doesn't know what type of memory it's allocating, it returns a void
    pointer to the newly allocated heap memory, which must be typecast into the appropriate
    type. After every `malloc()` call, there is an error-checking block that checks
    whether or not the allocation failed. If the allocation fails and the pointer
    is NULL, `fprintf()` is used to print an error message to standard error and the
    program exits. The `fprintf()` function is very similar to `printf()`; however,
    its first argument is `stderr`, which is a standard filestream meant for displaying
    errors. This function will be explained more later, but for now, it's just used
    as a way to properly display an error. The rest of the program is pretty straightforward.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序接受一个命令行参数作为第一次内存分配的大小，默认值为50。然后它使用`malloc()`和`free()`函数在堆上分配和释放内存。程序中有大量的`printf()`语句来调试程序执行时实际发生的事情。由于`malloc()`不知道它正在分配哪种类型的内存，它返回一个指向新分配堆内存的空指针，这必须转换为适当类型。在每次`malloc()`调用之后，都有一个错误检查块来检查分配是否失败。如果分配失败且指针为NULL，则使用`fprintf()`将错误消息打印到标准错误，并退出程序。`fprintf()`函数与`printf()`非常相似；然而，它的第一个参数是`stderr`，这是一个用于显示错误的标准文件流。这个函数将在稍后进行更多解释，但现在，它只是用作正确显示错误的一种方式。程序的其余部分相当直接。
- en: '[PRE120]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: In the preceding output, notice that each block of memory has an incrementally
    higher memory address in the heap. Even though the first 50 bytes were deallocated,
    when 15 more bytes are requested, they are put after the 12 bytes allocated for
    the `int_ptr`. The heap allocation functions control this behavior, which can
    be explored by changing the size of the initial memory allocation.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的输出中，注意每个内存块在堆中都有一个递增更高的内存地址。尽管前50字节已被释放，但当请求额外的15字节时，它们被放置在为`int_ptr`分配的12字节之后。堆分配函数控制这种行为，可以通过改变初始内存分配的大小来探索。 '
- en: '[PRE121]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: If a larger block of memory is allocated and then deallocated, the final 15-byte
    allocation will occur in that freed memory space, instead. By experimenting with
    different values, you can figure out exactly when the allocation function chooses
    to reclaim freed space for new allocations. Often, simple informative `printf()`
    statements and a little experimentation can reveal many things about the underlying
    system.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配了一个较大的内存块然后释放，最终的15字节分配将发生在释放的内存空间中。通过实验不同的值，你可以找出分配函数何时选择回收释放的空间以供新的分配使用。通常，简单的信息性`printf()`语句和一些实验可以揭示许多关于底层系统的东西。
- en: Error-Checked malloc()
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带错误检查的malloc()
- en: In heap_example.c, there were several error checks for the `malloc()` calls.
    Even though the `malloc()` calls never failed, it's important to handle all potential
    cases when coding in C. But with multiple `malloc()` calls, this error-checking
    code needs to appear in multiple places. This usually makes the code look sloppy,
    and it's inconvenient if changes need to be made to the error-checking code or
    if new `malloc()` calls are needed. Since all the error-checking code is basically
    the same for every `malloc()` call, this is a perfect place to use a function
    instead of repeating the same instructions in multiple places. Take a look at
    errorchecked_heap.c for an example.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `heap_example.c` 中，对 `malloc()` 调用进行了多次错误检查。尽管 `malloc()` 调用从未失败，但在 C 语言编程中处理所有潜在情况是很重要的。但是，由于有多个
    `malloc()` 调用，错误检查代码需要出现在多个地方。这通常会使代码看起来杂乱无章，如果需要修改错误检查代码或需要新的 `malloc()` 调用，这会很不方便。由于每个
    `malloc()` 调用的错误检查代码基本上都是相同的，这是一个使用函数而不是在多个地方重复相同指令的完美场所。请查看 `errorchecked_heap.c`
    以获取示例。
- en: errorchecked_heap.c
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: errorchecked_heap.c
- en: '[PRE122]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The errorchecked_heap.c program is basically equivalent to the previous heap_example.c
    code, except the heap memory allocation and error checking has been gathered into
    a single function. The first line of code [`void *errorchecked_malloc(unsigned
    int);`] is the function prototype. This lets the compiler know that there will
    be a function called `errorchecked_malloc()` that expects a single, unsigned integer
    argument and returns a `void` pointer. The actual function can then be anywhere;
    in this case it is after the `main()` function. The function itself is quite simple;
    it just accepts the size in bytes to allocate and attempts to allocate that much
    memory using `malloc()`. If the allocation fails, the error-checking code displays
    an error and the program exits; otherwise, it returns the pointer to the newly
    allocated heap memory. This way, the custom `errorchecked_malloc()` function can
    be used in place of a normal `malloc()`, eliminating the need for repetitious
    error checking afterward. This should begin to highlight the usefulness of programming
    with functions.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorchecked_heap.c` 程序基本上等同于之前的 `heap_example.c` 代码，除了将堆内存分配和错误检查合并到一个函数中。代码的第一行
    `void *errorchecked_malloc(unsigned int);` 是函数原型。这使编译器知道将有一个名为 `errorchecked_malloc()`
    的函数，它期望一个无符号整数参数，并返回一个 `void` 指针。实际的函数可以放在任何地方；在这种情况下，它位于 `main()` 函数之后。该函数本身相当简单；它只是接受要分配的字节数，并尝试使用
    `malloc()` 分配这么多内存。如果分配失败，错误检查代码将显示错误并退出程序；否则，它将返回指向新分配堆内存的指针。这样，自定义的 `errorchecked_malloc()`
    函数就可以用来替代正常的 `malloc()`，从而消除后续重复错误检查的需要。这种方式开始凸显使用函数编程的实用性。'
- en: Building on Basics
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立在基础之上
- en: Once you understand the basic concepts of C programming, the rest is pretty
    easy. The bulk of the power of C comes from using other functions. In fact, if
    the functions were removed from any of the preceding programs, all that would
    remain are very basic statements.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了 C 编程的基本概念，其余的部分就相对简单了。C 语言的强大之处主要来自于使用其他函数。实际上，如果从任何先前的程序中移除这些函数，剩下的将只是非常基础的语句。
- en: File Access
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件访问
- en: 'There are two primary ways to access files in C: file descriptors and filestreams.
    *File descriptors* use a set of low-level I/O functions, and *filestreams* are
    a higher-level form of buffered I/O that is built on the lower-level functions.
    Some consider the filestream functions easier to program with; however, file descriptors
    are more direct. In this book, the focus will be on the low-level I/O functions
    that use file descriptors.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中访问文件主要有两种方式：文件描述符和文件流。*文件描述符*使用一组低级 I/O 函数，而*文件流*是基于低级函数构建的更高层次的缓冲 I/O
    形式。有些人认为文件流函数更容易编程；然而，文件描述符更为直接。在这本书中，我们将重点关注使用文件描述符的低级 I/O 函数。
- en: The bar code on the back of this book represents a number. Because this number
    is unique among the other books in a bookstore, the cashier can scan the number
    at checkout and use it to reference information about this book in the store's
    database. Similarly, a file descriptor is a number that is used to reference open
    files. Four common functions that use file descriptors are `open(), close(), read()`,
    and `write()`. All of these functions will return –1 if there is an error. The
    `open()` function opens a file for reading and/or writing and returns a file descriptor.
    The returned file descriptor is just an integer value, but it is unique among
    open files. The file descriptor is passed as an argument to the other functions
    like a pointer to the opened file. For the `close()` function, the file descriptor
    is the only argument. The `read()` and `write()` functions' arguments are the
    file descriptor, a pointer to the data to read or write, and the number of bytes
    to read or write from that location. The arguments to the `open()` function are
    a pointer to the filename to open and a series of predefined flags that specify
    the access mode. These flags and their usage will be explained in depth later,
    but for now let's take a look at a simple note-taking program that uses file descriptors—simplenote.c.
    This program accepts a note as a command-line argument and then adds it to the
    end of the file /tmp/notes. This program uses several functions, including a familiar
    looking error-checked heap memory allocation function. Other functions are used
    to display a usage message and to handle fatal errors. The `usage()` function
    is simply defined before `main()`, so it doesn't need a function prototype.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书背面的条形码代表一个数字。因为这个数字在书店中的其他书籍中是唯一的，收银员可以在结账时扫描这个数字，并使用它来参考商店数据库中关于这本书的信息。同样，文件描述符是一个用于引用打开文件的数字。使用文件描述符的四个常见函数是
    `open()`、`close()`、`read()` 和 `write()`。所有这些函数在出现错误时都会返回 -1。`open()` 函数用于打开一个文件以供读取和/或写入，并返回一个文件描述符。返回的文件描述符只是一个整数值，但在打开的文件中是唯一的。文件描述符作为参数传递给其他函数，就像指向打开文件的指针一样。对于
    `close()` 函数，文件描述符是唯一的参数。`read()` 和 `write()` 函数的参数是文件描述符、指向要读取或写入的数据的指针以及从该位置读取或写入的字节数。`open()`
    函数的参数是要打开的文件名的指针以及一系列预定义的标志，这些标志指定了访问模式。这些标志及其用法将在稍后进行深入解释，但现在让我们看看一个使用文件描述符的简单记事程序——simplenote.c。这个程序接受一个命令行参数作为笔记，并将其添加到
    `/tmp/notes` 文件的末尾。这个程序使用了几个函数，包括一个看起来熟悉的错误检查堆内存分配函数。其他函数用于显示用法消息和处理致命错误。`usage()`
    函数在 `main()` 之前简单地定义，因此不需要函数原型。
- en: simplenote.c
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: simplenote.c
- en: '[PRE123]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Besides the strange-looking flags used in the `open()` function, most of this
    code should be readable. There are also a few standard functions that we haven't
    used before. The `strlen()` function accepts a string and returns its length.
    It's used in combination with the `write()` function, since it needs to know how
    many bytes to write. The `perror()` function is short for *print error* and is
    used in `fatal()` to print an additional error message (if it exists) before exiting.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 `open()` 函数中使用的看起来奇怪的标志外，大部分代码应该是可读的。还有一些我们之前没有使用过的标准函数。`strlen()` 函数接受一个字符串并返回其长度。它与
    `write()` 函数一起使用，因为它需要知道要写入多少字节。`perror()` 函数是 *print error* 的缩写，并在 `fatal()`
    中用于在退出前打印一个额外的错误消息（如果有的话）。
- en: '[PRE124]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output of the program''s execution is pretty self-explanatory, but there
    are some things about the source code that need further explanation. The files
    fcntl.h and sys/stat.h had to be included, since those files define the flags
    used with the `open()` function. The first set of flags is found in fcntl.h and
    is used to set the access mode. The access mode must use at least one of the following
    three flags:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行的输出相当直观，但关于源代码还有一些需要进一步解释的地方。由于 fcntl.h 和 sys/stat.h 文件定义了与 `open()` 函数一起使用的标志，因此必须包含这些文件。第一组标志位于
    fcntl.h 中，用于设置访问模式。访问模式必须使用以下三个标志之一：
- en: '| **`O_RDONLY`** Open file for read-only access. |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| **`O_RDONLY`** 以只读方式打开文件。|'
- en: '| **`O_WRONLY`** Open file for write-only access. |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| **`O_WRONLY`** 以只写方式打开文件。|'
- en: '| **`O_RDWR`** Open file for both read and write access. |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| **`O_RDWR`** 以读写方式打开文件。|'
- en: 'These flags can be combined with several other optional flags using thebitwise
    OR operator. A few of the more common and useful of these flags areas follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志可以使用位或运算符与几个其他可选标志组合。以下是一些更常见且有用的标志：
- en: '| **`O_APPEND`** Write data at the end of the file. |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| **`O_APPEND`** 在文件末尾写入数据。|'
- en: '| **`O_TRUNC`** If the file already exists, truncate the file to 0 length.
    |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| **`O_TRUNC`** 如果文件已存在，则将文件截断到0长度。 |'
- en: '| **`O_CREAT`** Create the file if it doesn''t exist. |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| **`O_CREAT`** 如果文件不存在，则创建文件。 |'
- en: Bitwise operations combine bits using standard logic gates such as OR and AND.
    When two bits enter an OR gate, the result is 1 if either the first bit *or* the
    second bit is 1\. If two bits enter an AND gate, the result is 1 only if both
    the first bit *and* the second bit are 1\. Full 32-bit values can use these bitwise
    operators to perform logic operations on each corresponding bit. The source code
    of bitwise.c and the program output demonstrate these bitwise operations.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '位操作使用标准逻辑门，如或和与，来组合位。当两个位进入一个或门时，如果第一个位或第二个位中的任何一个为 1，则结果为 1。如果两个位进入一个与门，只有当第一个位和第二个位都为
    1 时，结果才为 1。32 位全值可以使用这些位操作符对每个对应的位执行逻辑操作。bitwise.c 的源代码和程序输出演示了这些位操作。 '
- en: bitwise.c
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bitwise.c
- en: '[PRE125]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The results of compiling and executing bitwise.c are as follows.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行 bitwise.c 的结果如下。
- en: '[PRE126]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The flags used for the `open()` function have values that correspond to single
    bits. This way, flags can be combined using OR logic without destroying any information.
    The fcntl_flags.c program and its output explore some of the flag values defined
    by fcntl.h and how they combine with each other.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `open()` 函数的标志具有与单个位对应的值。这样，标志可以通过或逻辑组合，而不会破坏任何信息。fcntl_flags.c 程序及其输出探讨了
    fcntl.h 中定义的一些标志值以及它们是如何相互组合的。
- en: fcntl_flags.c
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fcntl_flags.c
- en: '[PRE127]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The results of compiling and executing fcntl_flags.c are as follows.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行 fcntl_flags.c 的结果如下。
- en: '[PRE128]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Using bit flags in combination with bitwise logic is an efficient and commonly
    used technique. As long as each flag is a number that only has unique bits turned
    on, the effect of doing a bitwise OR on these values is the same as adding them.
    In fcntl_flags.c, 1 + 1024 + 64 = 1089\. This technique only works when all the
    bits are unique, though.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位标志与位逻辑结合是一种高效且常用的技术。只要每个标志都是一个只有唯一位被打开的数字，对这些值进行位或操作的效果就等同于它们的和。在 fcntl_flags.c
    中，1 + 1024 + 64 = 1089。尽管如此，这种方法只有在所有位都是唯一的时候才有效。
- en: File Permissions
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件权限
- en: If the `O_CREAT` flag is used in access mode for the `open()` function, an additional
    argument is needed to define the file permissions of the newly created file. This
    argument uses bit flags defined in sys/stat.h, which can be combined with each
    other using bitwise OR logic.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `open()` 函数的访问模式中使用 `O_CREAT` 标志，则需要额外的参数来定义新创建文件的文件权限。此参数使用在 sys/stat.h
    中定义的位标志，可以通过位或逻辑组合在一起。
- en: '| **`S_IRUSR`** Give the file read permission for the user (owner). |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IRUSR`** 给文件用户（所有者）读权限。 |'
- en: '| **`S_IWUSR`** Give the file write permission for the user (owner). |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IWUSR`** 给文件用户（所有者）写权限。 |'
- en: '| **`S_IXUSR`** Give the file execute permission for the user (owner). |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IXUSR`** 给文件用户（所有者）执行权限。 |'
- en: '| **`S_IRGRP`** Give the file read permission for the group. |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IRGRP`** 给文件组读权限。 |'
- en: '| **`S_IWGRP`** Give the file write permission for the group. |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IWGRP`** 给文件组写权限。 |'
- en: '| **`S_IXGRP`** Give the file execute permission for the group. |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IXGRP`** 给文件组执行权限。 |'
- en: '| **`S_IROTH`** Give the file read permission for other (anyone). |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IROTH`** 给文件其他（任何人）读权限。 |'
- en: '| **`S_IWOTH`** Give the file write permission for other (anyone). |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IWOTH`** 给文件其他（任何人）写权限。 |'
- en: '| **`S_IXOTH`** Give the file execute permission for other (anyone). |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| **`S_IXOTH`** 给文件其他（任何人）执行权限。 |'
- en: If you are already familiar with Unix file permissions, those flags should make
    perfect sense to you. If they don't make sense, here's a crash course in Unix
    file permissions.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉 Unix 文件权限，那么这些标志应该对你来说非常合理。如果它们不合理，这里有一个 Unix 文件权限的快速入门课程。
- en: Every file has an owner and a group. These values can be displayed using `ls
    -l` and are shown below in the following output.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都有一个所有者和一个组。这些值可以使用 `ls -l` 显示，以下输出中显示了这些值。
- en: '[PRE129]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: For the /etc/passwd file, the owner is root and the group is also root. For
    the other two simplenote files, the owner is reader and the group is users.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 /etc/passwd 文件，所有者是 root，组也是 root。对于其他两个 simplenote 文件，所有者是 reader，组是 users。
- en: 'Read, write, and execute permissions can be turned on and off for three different
    fields: user, group, and other. User permissions describe what the owner of the
    file can do (read, write, and/or execute), group permissions describe what users
    in that group can do, and other permissions describe what everyone else can do.
    These fields are also displayed in the front of the `ls -l` output. First, the
    user read/write/execute permissions are displayed, using `r` for read, `w` for
    write, `x` for execute, and - for off. The next three characters display the group
    permissions, and the last three characters are for the other permissions. In the
    output above, the simplenote program has all three user permissions turned on
    (shown in bold). Each permission corresponds to a bit flag; read is 4 (100 in
    binary), write is 2 (010 in binary), and execute is 1 (001 in binary). Since each
    value only contains unique bits, a bitwise OR operation achieves the same result
    as adding these numbers together does. These values can be added together to define
    permissions for user, group, and other using the `chmod` command.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 读、写、执行权限可以针对三个不同的字段：用户、组和其他进行开启和关闭。用户权限描述文件所有者可以做什么（读、写和/或执行），组权限描述该组中的用户可以做什么，其他权限描述其他所有人可以做什么。这些字段也在`ls
    -l`输出的前面显示。首先显示用户读/写/执行权限，使用`r`表示读，`w`表示写，`x`表示执行，-表示关闭。接下来的三个字符显示组权限，最后三个字符是其他权限。在上面的输出中，simplenote程序的所有三个用户权限都已开启（以粗体显示）。每个权限对应一个位标志；读是4（二进制中的100），写是2（二进制中的010），执行是1（二进制中的001）。由于每个值只包含唯一的位，位或操作可以达到与将这些数字相加相同的结果。这些值可以相加，以使用`chmod`命令定义用户、组和其他用户的权限。
- en: '[PRE130]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The first command (`chmod 721`) gives read, write, and execute permissions to
    the user, since the first number is 7 (4 + 2 + 1), write and execute permissions
    to group, since the second number is 3 (2 + 1), and only execute permission to
    other, since the third number is 1\. Permissions can also be added or subtracted
    using `chmod`. In the next `chmod` command, the argument `ugo-wx` means *Subtract
    write and execute permissions from user, group, and other*. The final `chmod u+w`
    command gives write permission to user.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令（`chmod 721`）为用户赋予读、写和执行权限，因为第一个数字是7（4 + 2 + 1），为组赋予写和执行权限，因为第二个数字是3（2
    + 1），为其他用户只赋予执行权限，因为第三个数字是1。权限也可以通过`chmod`命令添加或移除。在下一个`chmod`命令中，参数`ugo-wx`意味着*从用户、组和其他用户中移除读写执行权限*。最后的`chmod
    u+w`命令为用户赋予写权限。
- en: In the simplenote program, the `open()` function uses `S_IRUSR|S_IWUSR` for
    its additional permission argument, which means the /tmp/notes file should only
    have user read and write permission when it is created.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在simplenote程序中，`open()`函数使用`S_IRUSR|S_IWUSR`作为其附加权限参数，这意味着在创建时/tmp/notes文件应该只有用户读和写权限。
- en: '[PRE131]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: User IDs
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户ID
- en: Every user on a Unix system has a unique user ID number. This user ID can be
    displayed using the `id` command.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: Unix系统上的每个用户都有一个唯一的用户ID号。这个用户ID可以使用`id`命令显示。
- en: '[PRE132]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The root user with user ID 0 is like the administrator account, which has full
    access to the system. The `su` command can be used to switch to a different user,
    and if this command is run as root, it can be done without a password. The `sudo`
    command allows a single command to be run as the root user. On the LiveCD, `sudo`
    has been configured so it can be executed without a password, for simplicity's
    sake. These commands provide a simple method to quickly switch between users.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 根用户（用户ID为0）类似于管理员账户，它对系统拥有完全访问权限。可以使用`su`命令切换到不同的用户，如果这个命令以root身份运行，则无需密码即可完成。`sudo`命令允许单个命令以root用户身份运行。在LiveCD上，为了简化操作，`sudo`已被配置为无需密码即可执行。这些命令提供了一种简单的方法来快速在用户之间切换。
- en: '[PRE133]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: As the user jose, the simplenote program will run as jose if it is executed,
    but it won't have access to the /tmp/notes file. This file is owned by the user
    reader, and it only allows read and write permission to its owner.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 作为jose用户，如果执行simplenote程序，它将以jose的身份运行，但无法访问/tmp/notes文件。这个文件属于reader用户，并且只允许所有者读写权限。
- en: '[PRE134]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This is fine if reader is the only user of the simplenote program; however,
    there are many times when multiple users need to be able to access certain portions
    of the same file. For example, the /etc/passwd file contains account information
    for every user on the system, including each user's default login shell. The command
    `chsh` allows any user to change his or her own login shell. This program needs
    to be able to make changes to the /etc/passwd file, but only on the line that
    pertains to the current user's account. The solution to this problem in Unix is
    the `set user ID (setuid)` permission. This is an additional file permission bit
    that can be set using `chmod`. When a program with this flag is executed, it runs
    as the user ID of the file's owner.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读者是 simplenote 程序的唯一用户，这没问题；然而，很多时候，多个用户需要能够访问同一文件的某些部分。例如，/etc/passwd 文件包含系统上每个用户的账户信息，包括每个用户的默认登录
    shell。`chsh` 命令允许任何用户更改自己的登录 shell。此程序需要能够更改 `/etc/passwd` 文件，但仅限于与当前用户账户相关的行。Unix
    中解决此问题的方法是设置 `set user ID (setuid)` 权限。这是一个可以使用 `chmod` 设置的附加文件权限位。当带有此标志的程序执行时，它将以文件所有者的用户
    ID 运行。
- en: '[PRE135]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The `chsh` program has the `setuid` flag set, which is indicated by an `s` in
    the `ls` output above. Since this file is owned by root and has the `setuid` permission
    set, the program will run as the root user when *any* user runs this program.
    The /etc/passwd file that `chsh` writes to is also owned by root and only allows
    the owner to write to it. The program logic in `chsh` is designed to only allow
    writing to the line in /etc/passwd that corresponds to the user running the program,
    even though the program is effectively running as root. This means that a running
    program has both a real user ID and an effective user ID. These IDs can be retrieved
    using the functions `getuid()` and `geteuid()`, respectively, as shown in uid_demo.c.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`chsh` 程序设置了 `setuid` 标志，这在上面 `ls` 输出的 `s` 中有所指示。由于此文件属于 root 用户并且设置了 `setuid`
    权限，因此当任何用户运行此程序时，程序将以 root 用户身份运行。`chsh` 写入的 `/etc/passwd` 文件也属于 root 用户，并且只允许所有者写入。`chsh`
    中的程序逻辑设计为只允许写入与运行程序的用户对应的 `/etc/passwd` 中的行，尽管程序实际上是以 root 身份运行的。这意味着正在运行程序具有真实用户
    ID 和有效用户 ID。这些 ID 可以分别使用 `getuid()` 和 `geteuid()` 函数检索，如 uid_demo.c 中所示。'
- en: uid_demo.c
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uid_demo.c
- en: '[PRE136]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The results of compiling and executing uid_demo.c are as follows.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行 uid_demo.c 的结果如下。
- en: '[PRE137]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In the output for uid_demo.c, both user IDs are shown to be 999 when `uid_demo`
    is executed, since 999 is the user ID for reader. Next, the `sudo` command is
    used with the `chown` command to change the owner and group of `uid_demo` to root.
    The program can still be executed, since it has execute permission for other,
    and it shows that both user IDs remain 999, since that's still the ID of the user.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在 uid_demo.c 的输出中，当执行 `uid_demo` 时，两个用户 ID 都显示为 999，因为 999 是读者的用户 ID。接下来，使用
    `sudo` 命令与 `chown` 命令一起使用，将 `uid_demo` 的所有者和组更改为 root。由于程序对其他用户有执行权限，因此程序仍然可以执行，并且它显示两个用户
    ID 仍然为 999，因为那仍然是用户的 ID。
- en: '[PRE138]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Since the program is owned by root now, `sudo` must be used to change file permissions
    on it. The `chmod u+s` command turns on the `setuid` permission, which can be
    seen in the following `ls -l` output. Now when the user reader executes `uid_demo`,
    the effective user ID is 0 for root, which means the program can access files
    as root. This is how the `chsh` program is able to allow any user to change his
    or her login shell stored in /etc/passwd.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序现在属于 root 用户，因此必须使用 `sudo` 来更改其文件权限。`chmod u+s` 命令开启了 `setuid` 权限，这在下面的
    `ls -l` 输出中可以看到。现在当用户 reader 执行 `uid_demo` 时，有效用户 ID 为 0（root），这意味着程序可以以 root
    身份访问文件。这就是 `chsh` 程序能够允许任何用户更改其存储在 `/etc/passwd` 中的登录 shell的原因。
- en: This same technique can be used in a multiuser note-taking program. The next
    program will be a modification of the simplenote program; it will also record
    the user ID of each note's original author. In addition, a new syntax for `#include`
    will be introduced.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相同的技术可以用于多用户笔记程序中。下一个程序将是 simplenote 程序的修改版；它还将记录每个笔记原始作者的用户 ID。此外，将引入新的 `#include`
    语法。
- en: The `ec_malloc()` and `fatal()` functions have been useful in many of our programs.
    Rather than copy and paste these functions into each program, they can be put
    in a separate include file.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`ec_malloc()` 和 `fatal()` 函数在我们的许多程序中都很有用。与其将这些函数复制粘贴到每个程序中，不如将它们放入一个单独的包含文件中。'
- en: hacking.h
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hacking.h
- en: '[PRE139]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In this new program, hacking.h, the functions can just be included. In C, when
    the filename for a `#include` is surrounded by `<` and `>`, the compiler looks
    for this file in standard include paths, such as /usr/include/. If the filename
    is surrounded by quotes, the compiler looks in the current directory. Therefore,
    if hacking.h is in the same directory as a program, it can be included with that
    program by typing `#include "hacking.h"`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新程序 hacking.h 中，函数可以直接包含。在 C 语言中，当 `#include` 的文件名被 `<` 和 `>` 包围时，编译器会在标准包含路径中查找此文件，例如
    /usr/include/。如果文件名被引号包围，编译器会在当前目录中查找。因此，如果 hacking.h 与程序在同一个目录中，可以通过输入 `#include
    "hacking.h"` 来与该程序一起包含。
- en: The changed lines for the new notetaker program (notetaker.c) are displayed
    in bold.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 notetaker 程序（notetaker.c）中更改的行以粗体显示。
- en: notetaker.c
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: notetaker.c
- en: '[PRE140]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The output file has been changed from /tmp/notes to /var/notes, so the data
    is now stored in a more permanent place. The `getuid()` function is used to get
    the real user ID, which is written to the datafile on the line before the note's
    line is written. Since the `write()` function is expecting a pointer for its source,
    the `&` operator is used on the integer value `userid` to provide its address.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件已从 /tmp/notes 更改为 /var/notes，因此数据现在存储在一个更永久的位置。使用 `getuid()` 函数获取真实用户 ID，该
    ID 写在笔记行之前的数据文件中。由于 `write()` 函数期望一个源指针，因此对整数值 `userid` 使用 `&` 运算符以提供其地址。
- en: '[PRE141]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: In the preceding output, the notetaker program is compiled and changed to be
    owned by root, and the `setuid` permission is set. Now when the program is executed,
    the program runs as the root user, so the file /var/notes is also owned by root
    when it is created.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，notetaker 程序被编译并更改为主属为 root，并设置了 `setuid` 权限。现在当程序执行时，程序以 root 用户身份运行，因此当创建文件
    /var/notes 时，它也由 root 拥有。
- en: '[PRE142]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The /var/notes file contains the user ID of reader (999) and the note. Because
    of little-endian architecture, the 4 bytes of the integer 999 appear reversed
    in hexadecimal (shown in bold above).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: /var/notes 文件包含读者的用户 ID（999）和笔记。由于小端架构，整数 999 的 4 个字节在十六进制中显示为反转（如上粗体所示）。
- en: In order for a normal user to be able to read the note data, a corresponding
    `setuid` root program is needed. The notesearch.c program will read the note data
    and only display the notes written by that user ID. Additionally, an optional
    command-line argument can be supplied for a search string. When this is used,
    only notes matching the search string will be displayed.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使普通用户能够读取笔记数据，需要一个相应的 `setuid` root 程序。notesearch.c 程序将读取笔记数据，并且只显示由该用户 ID
    编写的笔记。此外，还可以提供一个可选的命令行参数作为搜索字符串。当使用此参数时，只有与搜索字符串匹配的笔记将被显示。
- en: notesearch.c
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: notesearch.c
- en: '[PRE143]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Most of this code should make sense, but there are some new concepts. The filename
    is defined at the top instead of using heap memory. Also, the function `lseek()`
    is used to rewind the read position in the file. The function call of `lseek(fd,
    length * -1, SEEK_CUR);` tells the program to move the read position forward from
    the current position in the file by `length * -1` bytes. Since this turns out
    to be a negative number, the position is moved backward by `length` bytes.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码应该是有意义的，但有一些新概念。文件名在顶部定义，而不是使用堆内存。此外，使用 `lseek()` 函数来重置文件中的读取位置。函数调用 `lseek(fd,
    length * -1, SEEK_CUR);` 告诉程序将读取位置向前移动 `length * -1` 个字节。由于这会变成一个负数，因此位置会向后移动
    `length` 个字节。
- en: '[PRE144]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: When compiled and `setuid` root, the notesearch program works as expected. But
    this is just a single user; what happens if a different user uses the notetaker
    and notesearch programs?
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译并设置 `setuid` 为 root 时，notesearch 程序按预期工作。但这只是一个单一用户；如果不同的用户使用 notetaker 和
    notesearch 程序会发生什么？
- en: '[PRE145]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: When the user jose uses these programs, the real user ID is 501\. This means
    that value is added to all notes written with notetaker, and only notes with a
    matching user ID will be displayed by the notesearch program.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户 jose 使用这些程序时，真实用户 ID 是 501。这意味着该值将添加到所有使用 notetaker 编写的笔记中，并且只有具有匹配用户 ID
    的笔记将由 notesearch 程序显示。
- en: '[PRE146]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Similarly, all notes for the user reader have the user ID 999 attached to them.
    Even though both the notetaker and notesearch programs are `suid`root and have
    full read and write access to the /var/notes datafile, the program logic in the
    notesearch program prevents the current user from viewing other users' notes.
    This is very similar to how the /etc/passwd file stores user information for all
    users, yet programs like `chsh` and `passwd` allow any user to change his own
    shell or password.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，所有面向用户读者的笔记都附有用户ID 999。尽管笔记记录程序和笔记搜索程序都是`suid`root，并且对`/var/notes`数据文件具有完全的读写权限，但笔记搜索程序中的程序逻辑阻止当前用户查看其他用户的笔记。这非常类似于`/etc/passwd`文件存储所有用户的信息，而像`chsh`和`passwd`这样的程序允许任何用户更改自己的shell或密码。
- en: Structs
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: Sometimes there are multiple variables that should be grouped together and treated
    like one. In C, *structs* are variables that can contain many other variables.
    Structs are often used by various system functions and libraries, so understanding
    how to use structs is a prerequisite to using these functions.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，应该将多个变量分组在一起并作为一个整体处理。在C语言中，*结构体*是包含许多其他变量的变量。结构体经常被各种系统函数和库使用，因此理解如何使用结构体是使用这些函数的先决条件。
- en: A simple example will suffice for now. When dealing with many time functions,
    these functions use a time struct called `tm`, which is defined in /usr/include/time.h.
    The struct's definition is as follows.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用一个简单的例子就足够了。在处理许多时间函数时，这些函数使用一个名为`tm`的时间结构体，该结构体在`/usr/include/time.h`中定义。结构体的定义如下。
- en: '[PRE147]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: After this struct is defined, `struct tm` becomes a usable variable type, which
    can be used to declare variables and pointers with the data type of the `tm` struct.
    The time_example.c program demonstrates this. When `time.h` is included, the `tm`
    struct is defined, which is later used to declare the `current_time` and `time_ptr`
    variables.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这个结构体之后，`struct tm`成为一个可用的变量类型，可以用来声明具有`tm`结构体数据类型的变量和指针。time_example.c程序演示了这一点。当包含`time.h`头文件时，`tm`结构体被定义，之后用于声明`current_time`和`time_ptr`变量。
- en: time_example.c
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: time_example.c
- en: '[PRE148]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The `time()` function will return the number of seconds since January 1, 1970\.
    Time on Unix systems is kept relative to this rather arbitrary point in time,
    which is also known as the *epoch*. The `localtime_r()` function expects two pointers
    as arguments: one to the number of seconds since epoch and the other to a `tm`
    struct. The pointer `time_ptr` has already been set to the address of `current_time`,
    an empty `tm` struct. The address-of operator is used to provide a pointer to
    `seconds_since_epoch` for the other argument to `localtime_r()`, which fills the
    elements of the `tm` struct. The elements of structs can be accessed in three
    different ways; the first two are the proper ways to access struct elements, and
    the third is a hacked solution. If a struct variable is used, its elements can
    be accessed by adding the elements'' names to the end of the variable name with
    a period. Therefore, `current_time.tm_hour` will access just the `tm_hour` element
    of the `tm` struct called `current_time`. Pointers to structs are often used,
    since it is much more efficient to pass a four-byte pointer than an entire data
    structure. Struct pointers are so common that C has a built-in method to access
    struct elements from a struct pointer without needing to dereference the pointer.
    When using a struct pointer like `time_ptr`, struct elements can be similarly
    accessed by the struct element''s name, but using a series of characters that
    looks like an arrow pointing right. Therefore, `time_ptr->tm_min` will access
    the `tm_min` element of the `tm` struct that is pointed to by `time_ptr`. The
    seconds could be accessed via either of these proper methods, using the `tm_sec`
    element or the `tm` struct, but a third method is used. Can you figure out how
    this third method works?'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`time()` 函数将返回自1970年1月1日以来的秒数。Unix系统中的时间相对于这个相当任意的时刻来保持，这也被称为*纪元*。`localtime_r()`
    函数期望两个指针作为参数：一个是指自纪元以来的秒数，另一个是指向 `tm` 结构体的指针。指针 `time_ptr` 已经被设置为 `current_time`
    的地址，一个空的 `tm` 结构体。使用地址运算符提供 `seconds_since_epoch` 的指针作为 `localtime_r()` 的另一个参数，它填充了
    `tm` 结构体的元素。结构体的元素可以通过三种不同的方式访问；前两种是访问结构体元素的正确方式，第三种是一个修改过的解决方案。如果使用结构体变量，可以通过将元素名称添加到变量名称的末尾并使用点号来访问其元素。因此，`current_time.tm_hour`
    将访问名为 `current_time` 的 `tm` 结构体中的 `tm_hour` 元素。结构体指针通常被使用，因为传递一个四字节的指针比传递整个数据结构要高效得多。结构体指针如此常见，以至于C语言内置了一种方法，可以从结构体指针访问结构体元素，而无需解引用指针。当使用结构体指针如
    `time_ptr` 时，可以通过结构体元素名称以类似的方式访问结构体元素，但使用一系列看起来像指向右方的箭头的字符。因此，`time_ptr->tm_min`
    将访问 `time_ptr` 所指向的 `tm` 结构体中的 `tm_min` 元素。秒数可以通过这些正确的方法之一访问，使用 `tm_sec` 元素或 `tm`
    结构体，但使用了第三种方法。你能弄清楚这种第三种方法是如何工作的吗？'
- en: '[PRE149]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The program works as expected, but how are the seconds being accessed in the
    `tm` struct? Remember that in the end, it's all just memory. Since `tm_sec` is
    defined at the beginning of the `tm` struct, that integer value is also found
    at the beginning. In the line `second = *((int *) time_ptr)`, the variable `time_ptr`
    is typecast from a `tm` struct pointer to an integer pointer. Then this typecast
    pointer is dereferenced, returning the data at the pointer's address. Since the
    address to the `tm` struct also points to the first element of this struct, this
    will retrieve the integer value for `tm_sec` in the struct. The following addition
    to the time_example.c code (time_example2.c) also dumps the bytes of the `current_time`.
    This shows that the elements of `tm` struct are right next to each other in memory.
    The elements further down in the struct can also be directly accessed with pointers
    by simply adding to the address of the pointer.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 程序按预期工作，但在 `tm` 结构体中是如何访问秒数的呢？记住，最终，这都只是内存。由于 `tm_sec` 在 `tm` 结构体的开头定义，这个整数值也在开头。在
    `second = *((int *) time_ptr)` 这一行中，变量 `time_ptr` 被从 `tm` 结构体指针转换为整数指针。然后这个转换后的指针被解引用，返回指针地址处的数据。由于
    `tm` 结构体的地址也指向这个结构体的第一个元素，这将检索结构体中 `tm_sec` 的整数值。time_example.c 代码（time_example2.c）的以下添加部分也输出了
    `current_time` 的字节。这表明 `tm` 结构体的元素在内存中紧挨着。结构体中更低的元素也可以通过简单地增加指针的地址来直接通过指针访问。
- en: time_example2.c
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: time_example2.c
- en: '[PRE150]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The results of compiling and executing time_example2.c are as follows.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行 time_example2.c 的结果如下。
- en: '[PRE151]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: While struct memory can be accessed this way, assumptions are made about the
    type of variables in the struct and the lack of any padding between variables.
    Since the data types of a struct's elements are also stored in the struct, using
    proper methods to access struct elements is much easier.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过这种方式访问结构体的内存，但会假设结构体中变量的类型以及变量之间没有填充。由于结构体元素的类型数据也存储在结构体中，因此使用适当的方法访问结构体元素要容易得多。
- en: Function Pointers
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数指针
- en: A *pointer* simply contains a memory address and is given a data type that describes
    where it points. Usually, pointers are used for variables; however, they can also
    be used for functions. The funcptr_example.c program demonstrates the use of function
    pointers.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 指针简单地包含一个内存地址，并赋予一个描述它指向位置的数据类型。通常，指针用于变量；然而，它们也可以用于函数。`funcptr_example.c`程序演示了函数指针的使用。
- en: funcptr_example.c
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: funcptr_example.c
- en: '[PRE152]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In this program, a function pointer aptly named `function_ptr` is declared in
    `main()`. This pointer is then set to point at the function `func_one()` and is
    called; then it is set again and used to call `func_two()`. The output below shows
    the compilation and execution of this source code.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，在`main()`函数中声明了一个名为`function_ptr`的函数指针。然后这个指针被设置为指向函数`func_one()`，并调用它；之后它又被设置并用于调用`func_two()`。下面的输出显示了此源代码的编译和执行过程。
- en: '[PRE153]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Pseudo-random Numbers
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪随机数
- en: Since computers are deterministic machines, it is impossible for them to produce
    truly random numbers. But many applications require some form of randomness. The
    pseudo-random number generator functions fill this need by generating a stream
    of numbers that is *pseudo-random*. These functions can produce a seemingly random
    sequence of numbers started from a seed number; however, the same exact sequence
    can be generated again with the same seed. Deterministic machines cannot produce
    true randomness, but if the seed value of the pseudo-random generation function
    isn't known, the sequence will seem random. The generator must be seeded with
    a value using the function `srand()`, and from that point on, the function `rand()`
    will return a pseudo-random number from 0 to `RAND_MAX`. These functions and `RAND_MAX`
    are defined in stdlib.h. While the numbers `rand()` returns will appear to be
    random, they are dependent on the seed value provided to `srand()`. To maintain
    pseudo-randomness between subsequent program executions, the randomizer must be
    seeded with a different value each time. One common practice is to use the number
    of seconds since epoch (returned from the `time()` function) as the seed. The
    rand_example.c program demonstrates this technique.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机是确定性机器，它们无法产生真正的随机数。但许多应用程序需要某种形式的随机性。伪随机数生成函数通过生成一个伪随机数流来满足这一需求。这些函数可以从一个种子数开始生成一个看似随机的数列；然而，使用相同的种子可以再次生成相同的序列。确定性机器无法产生真正的随机性，但如果伪随机生成函数的种子值未知，序列将看起来是随机的。生成器必须使用`srand()`函数用值初始化，从那时起，`rand()`函数将返回一个从0到`RAND_MAX`的伪随机数。这些函数和`RAND_MAX`在`stdlib.h`中定义。虽然`rand()`返回的数字看起来是随机的，但它们依赖于提供给`srand()`的种子值。为了在后续程序执行之间保持伪随机性，随机化器每次都必须用不同的值初始化。一种常见的做法是使用自纪元以来的秒数（由`time()`函数返回）作为种子。`rand_example.c`程序演示了这种技术。
- en: rand_example.c
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rand_example.c
- en: '[PRE154]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Notice how the modulus operator is used to obtain random values from 1 to 20.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模运算符是如何用来从1到20获取随机值的。
- en: '[PRE155]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The program's output just displays random numbers. Pseudo-randomness can also
    be used for more complex programs, as you will see in this section's final script.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出仅显示随机数。伪随机性也可以用于更复杂的程序，正如本节最后脚本中将看到的那样。
- en: A Game of Chance
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个机会游戏
- en: The final program in this section is a set of games of chance that use many
    of the concepts we've discussed. The program uses pseudo-random number generator
    functions to provide the element of chance. It has three different game functions,
    which are called using a single global function pointer, and it uses structs to
    hold data for the player, which is saved in a file. Multi-user file permissions
    and user IDs allow multiple users to play and maintain their own account data.
    The game_of_chance.c program code is heavily documented, and you should be able
    to understand it at this point.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后的程序是一系列使用我们讨论过的许多概念的随机游戏。程序使用伪随机数生成器函数来提供随机元素。它有三个不同的游戏函数，这些函数通过一个全局函数指针调用，并且它使用结构体来保存玩家的数据，这些数据保存在一个文件中。多用户文件权限和用户
    ID 允许多个用户玩游戏并维护他们自己的账户数据。game_of_chance.c 程序代码有大量的文档，你应该能够在这个阶段理解它。
- en: game_of_chance.c
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: game_of_chance.c
- en: '[PRE156]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Since this is a multi-user program that writes to a file in the /var directory,
    it must be suid root.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个多用户程序，它会在 /var 目录下写入文件，因此它必须是 suid root。
- en: '[PRE157]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Play around with this program a little bit. The Find the Ace game is a demonstration
    of a principle of conditional probability; although it is counterintuitive, changing
    your pick will increase your chances of finding the ace from 33 percent to 50
    percent. Many people have difficulty understanding this truth—that's why it's
    counterintuitive. The secret of hacking is understanding little-known truths like
    this and using them to produce seemingly magical results.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 试着玩一下这个程序。找到 A 约游戏是一个条件概率原理的演示；尽管它不符合直觉，但改变你的选择将增加你找到 A 约的概率从 33% 提高到 50%。许多人难以理解这个真理——这就是为什么它不符合直觉。黑客的秘密在于理解这样的小众真理，并利用它们产生看似神奇的结果。
