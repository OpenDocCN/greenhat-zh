- en: Chapter 0x200. PROGRAMMING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hacker* is a term for both those who write code and those who exploit it.
    Even though these two groups of hackers have different end goals, both groups
    use similar problem-solving techniques. Since an understanding of programming
    helps those who exploit, and an understanding of exploitation helps those who
    program, many hackers do both. There are interesting hacks found in both the techniques
    used to write elegant code and the techniques used to exploit programs. Hacking
    is really just the act of finding a clever and counterintuitive solution to a
    problem.'
  prefs: []
  type: TYPE_NORMAL
- en: The hacks found in program exploits usually use the rules of the computer to
    bypass security in ways never intended. Programming hacks are similar in that
    they also use the rules of the computer in new and inventive ways, but the final
    goal is efficiency or smaller source code, not necessarily a security compromise.
    There are actually an infinite number of programs that can be written to accomplish
    any given task, but most of these solutions are unnecessarily large, complex,
    and sloppy. The few solutions that remain are small, efficient, and neat. Programs
    that have these qualities are said to have *elegance*, and the clever and inventive
    solutions that tend to lead to this efficiency are called *hacks*. Hackers on
    both sides of programming appreciate both the beauty of elegant code and the ingenuity
    of clever hacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the business world, more importance is placed on churning out functional
    code than on achieving clever hacks and elegance. Because of the tremendous exponential
    growth of computational power and memory, spending an extra five hours to create
    a slightly faster and more memory efficient piece of code just doesn't make business
    sense when dealing with modern computers that have gigahertz of processing cycles
    and gigabytes of memory. While time and memory optimizations go without notice
    by all but the most sophisticated of users, a new feature is marketable. When
    the bottom line is money, spending time on clever hacks for optimization just
    doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'True appreciation of programming elegance is left for the hackers: computer
    hobbyists whose end goal isn''t to make a profit but to squeeze every possible
    bit of functionality out of their old Commodore 64s, exploit writers who need
    to write tiny and amazing pieces of code to slip through narrow security cracks,
    and anyone else who appreciates the pursuit and the challenge of finding the best
    possible solution. These are the people who get excited about programming and
    really appreciate the beauty of an elegant piece of code or the ingenuity of a
    clever hack. Since an understanding of programming is a prerequisite to understanding
    how programs can be exploited, programming is a natural starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: What Is Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programming is a very natural and intuitive concept. A program is nothing more
    than a series of statements written in a specific language. Programs are everywhere,
    and even the technophobes of the world use programs every day. Driving directions,
    cooking recipes, football plays, and DNA are all types of programs. A typical
    program for driving directions might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Anyone who knows English can understand and follow these driving directions,
    since they're written in English. Granted, they're not eloquent, but each instruction
    is clear and easy to understand, at least for someone who reads English.
  prefs: []
  type: TYPE_NORMAL
- en: But a computer doesn't natively understand English; it only understands machine
    language. To instruct a computer to do something, the instructions must be written
    in its language. However, *machine language* is arcane and difficult to work with—it
    consists of raw bits and bytes, and it differs from architecture to architecture.
    To write a program in machine language for an Intel *x*86 processor, you would
    have to figure out the value associated with each instruction, how each instruction
    interacts, and myriad low-level details. Programming like this is painstaking
    and cumbersome, and it is certainly not intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: What's needed to overcome the complication of writing machine language is a
    translator. An *assembler* is one form of machine-language translator—it is a
    program that translates assembly language into machine-readable code. *Assembly
    language* is less cryptic than machine language, since it uses names for the different
    instructions and variables, instead of just using numbers. However, assembly language
    is still far from intuitive. The instruction names are very esoteric, and the
    language is architecture specific. Just as machine language for Intel *x*86 processors
    is different from machine language for Sparc processors, *x*86 assembly language
    is different from Sparc assembly language. Any program written using assembly
    language for one processor's architecture will not work on another processor's
    architecture. If a program is written in *x*86 assembly language, it must be rewritten
    to run on Sparc architecture. In addition, in order to write an effective program
    in assembly language, you must still know many low-level details of the processor
    architecture you are writing for.
  prefs: []
  type: TYPE_NORMAL
- en: These problems can be mitigated by yet another form of translator called a compiler.
    A *compiler* converts a high-level language into machine language. High-level
    languages are much more intuitive than assembly language and can be converted
    into many different types of machine language for different processor architectures.
    This means that if a program is written in a high level language, the program
    only needs to be written once; the same piece of program code can be compiled
    into machine language for various specific architectures. C, C++, and Fortran
    are all examples of high-level languages. A program written in a high-level language
    is much more readable and English-like than assembly language or machine language,
    but it still must follow very strict rules about how the instructions are worded,
    or the compiler won't be able to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers have yet another form of programming language called pseudo-code.
    *Pseudo-code* is simply English arranged with a general structure similar to a
    high-level language. It isn't understood by compilers, assemblers, or any computers,
    but it is a useful way for a programmer to arrange instructions. Pseudo-code isn't
    well defined; in fact, most people write pseudo-code slightly differently. It's
    sort of the nebulous missing link between English and high-level programming languages
    like C. Pseudo-code makes for an excellent introduction to common universal programming
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Control Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without control structures, a program would just be a series of instructions
    executed in sequential order. This is fine for very simple programs, but most
    programs, like the driving directions example, aren't that simple. The driving
    directions included statements like, *Continue on Main Street until you see a
    church on your right* and *If the street is blocked because of construction*….
    These statements are known as *control structures*, and they change the flow of
    the program's execution from a simple sequential order to a more complex and more
    useful flow.
  prefs: []
  type: TYPE_NORMAL
- en: If-Then-Else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the case of our driving directions, Main Street could be under construction.
    If it is, a special set of instructions needs to address that situation. Otherwise,
    the original set of instructions should be followed. These types of special cases
    can be accounted for in a program with one of the most natural controlstructures:
    the *if-then-else structure*. In general, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For this book, a C-like pseudo-code will be used, so every instruction will
    end with a semicolon, and the sets of instructions will be grouped with curly
    braces and indentation. The if-then-else pseudo-code structure of the preceding
    driving directions might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each instruction is on its own line, and the various sets of conditional instructions
    are grouped between curly braces and indented for readability. In C and many other
    programming languages, the `then` keyword is implied and therefore left out, so
    it has also been omitted in the preceding pseudo-code.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, other languages require the `then` keyword in their syntax— BASIC,
    Fortran, and even Pascal, for example. These types of syntactical differences
    in programming languages are only skin deep; the underlying structure is still
    the same. Once a programmer understands the concepts these languages are trying
    to convey, learning the various syntactical variations is fairly trivial. Since
    C will be used in the later sections, the pseudo code used in this book will follow
    a C-like syntax, but remember that pseudo-code can take on many forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common rule of C-like syntax is when a set of instructions bounded
    by curly braces consists of just one instruction, the curly braces are optional.
    For the sake of readability, it''s still a good idea to indent these instructions,
    but it''s not syntactically necessary. The driving directions from before can
    be rewritten following this rule to produce an equivalent piece of pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This rule about sets of instructions holds true for all of the control structures
    mentioned in this book, and the rule itself can be described in pseudo-code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Even the description of a syntax itself can be thought of as a simple program.
    There are variations of if-then-else, such as select/case statements, but the
    logic is still basically the same: If this happens do these things, otherwise
    do these other things (which could consist of even more if-then statements).'
  prefs: []
  type: TYPE_NORMAL
- en: While/Until Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another elementary programming concept is the while control structure, which
    is a type of loop. A programmer will often want to execute a set of instructions
    more than once. A program can accomplish this task through looping, but it requires
    a set of conditions that tells it when to stop looping, lest it continue into
    infinity. A *while loop* says to execute the following set of instructions in
    a loop *while* a condition is true. A simple program for a hungry mouse could
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The set of two instructions following the while statement will be repeated *while*
    the mouse is still hungry. The amount of food the mouse finds each time could
    range from a tiny crumb to an entire loaf of bread. Similarly, the number of times
    the set of instructions in the while statement is executed changes depending on
    how much food the mouse finds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another variation on the while loop is an until loop, a syntax that is available
    in the programming language Perl (C doesn''t use this syntax). An *until loop*
    is simply a while loop with the conditional statement inverted. The same mouse
    program using an until loop would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Logically, any until-like statement can be converted into a while loop. The
    driving directions from before contained the statement *Continue on Main Street
    until you see a church on your right*. This can easily be changed into a standard
    while loop by simply inverting the condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another looping control structure is the *for loop*. This is generally used
    when a programmer wants to loop for a certain number of iterations. The driving
    direction *Drive straight down Destination Road for 5 miles* could be converted
    to a for loop that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In reality, a for loop is just a while loop with a counter. The same statement
    can be written as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The C-like pseudo-code syntax of a for loop makes this even more apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the counter is called `i`, and the for statement is broken up
    into three sections, separated by semicolons. The first section declares the counter
    and sets it to its initial value, in this case 0\. The second section is like
    a while statement using the counter: *While* the counter meets this condition,
    keep looping. The third and final section describes what action should be taken
    on the counter during each iteration. In this case, `i++` is a shorthand way of
    saying, *Add 1 to the counter called i*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using all of the control structures, the driving directions from [What Is Programming?](ch02.html#what_is_programming
    "What Is Programming?") can be converted into a C-like pseudo-code that looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: More Fundamental Programming Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, more universal programming concepts will be introduced.
    These concepts are used in many programming languages, with a few syntactical
    differences. As I introduce these concepts, I will integrate them into pseudo-code
    examples using C-like syntax. By the end, the pseudo code should look very similar
    to C code.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The counter used in the for loop is actually a type of variable. A *variable*
    can simply be thought of as an object that holds data that can be changed— hence
    the name. There are also variables that don't change, which are aptly called *constants*.
    Returning to the driving example, the speed of the car would be a variable, while
    the color of the car would be a constant. In pseudo code, variables are simple
    abstract concepts, but in C (and in many other languages), variables must be declared
    and given a type before they can be used. This is because a C program will eventually
    be compiled into an executable program. Like a cooking recipe that lists all the
    required ingredients before giving the instructions, variable declarations allow
    you to make preparations before getting into the meat of the program. Ultimately,
    all variables are stored in memory somewhere, and their declarations allow the
    compiler to organize this memory more efficiently. In the end though, despite
    all of the variable type declarations, everything is all just memory.
  prefs: []
  type: TYPE_NORMAL
- en: In C, each variable is given a type that describes the information that is meant
    to be stored in that variable. Some of the most common types are `int` (integer
    values), `float` (decimal floating-point values), and `char` (single character
    values). Variables are declared simply by using these keywords before listing
    the variables, as you can see below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The variables `a` and `b` are now defined as integers, `k` can accept floating
    point values (such as 3.14), and `z` is expected to hold a character value, like
    *A* or *w*. Variables can be assigned values when they are declared or anytime
    afterward, using the = operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After the following instructions are executed, the variable `a` will contain
    the value of 13, `k` will contain the number 3.14, `z` will contain the character
    *w*, and `b` will contain the value 18, since 13 plus 5 equals 18\. Variables
    are simply a way to remember values; however, with C, you must first declare each
    variable's type.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The statement `b = a + 7` is an example of a very simple arithmetic operator.
    In C, the following symbols are used for various arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: The first four operations should look familiar. Modulo reduction may seem like
    a new concept, but it's really just taking the remainder after division. If `a`
    is 13, then 13 divided by 5 equals 2, with a remainder of 3, which means that
    `a % 5 = 3`. Also, since the variables `a` and `b` are integers, the statement
    `b = a / 5` will result in the value of 2 being stored in `b`, since that's the
    integer portion of it. Floating-point variables must be used to retain the more
    correct answer of 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Symbol | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Addition | + | `b = a + 5` |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | - | `b = a - 5` |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | * | `b = a * 5` |'
  prefs: []
  type: TYPE_TB
- en: '| Division | / | `b = a / 5` |'
  prefs: []
  type: TYPE_TB
- en: '| Modulo reduction | % | `b = a % 5` |'
  prefs: []
  type: TYPE_TB
- en: To get a program to use these concepts, you must speak its language. The C language
    also provides several forms of shorthand for these arithmetic operations. One
    of these was mentioned earlier and is used commonly in for loops.
  prefs: []
  type: TYPE_NORMAL
- en: '| Full Expression | Shorthand | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `i = i + 1` | `i++ or ++i` | Add 1 to the variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `i = i - 1` | `i-- or --i` | Subtract 1 from the variable. |'
  prefs: []
  type: TYPE_TB
- en: These shorthand expressions can be combined with other arithmetic operations
    to produce more complex expressions. This is where the difference between `i++`
    and `++i` becomes apparent. The first expression means *Increment the value of
    `i` by 1* after *evaluating the arithmetic operation*, while the second expression
    means *Increment the value of `i` by 1* before *evaluating the arithmetic operation*.
    The following example will help clarify.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of this set of instructions, `b` will contain 30 and `a` will contain
    6, since the shorthand of `b = a++ * 6;` is equivalent to the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the instruction `b = ++a * 6;` is used, the order of the addition
    to `a` changes, resulting in the following equivalent instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since the order has changed, in this case `b` will contain 36, and `a` will
    still contain 6.
  prefs: []
  type: TYPE_NORMAL
- en: Quite often in programs, variables need to be modified in place. For example,
    you might need to add an arbitrary value like 12 to a variable, and store the
    result right back in that variable (for example, `i = i + 12`). This happens commonly
    enough that shorthand also exists for it.
  prefs: []
  type: TYPE_NORMAL
- en: '| Full Expression | Shorthand | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `i = i + 12` | `i+=12` | Add some value to the variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `i = i - 12` | `i-=12` | Subtract some value from the variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `i = i * 12` | `i*=12` | Multiply some value by the variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `i = i / 12` | `i/=12` | Divide some value from the variable. |'
  prefs: []
  type: TYPE_TB
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables are frequently used in the conditional statements of the previously
    explained control structures. These conditional statements are based on some sort
    of comparison. In C, these comparison operators use a shorthand syntax that is
    fairly common across many programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Symbol | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Less than | < | `(a < b)` |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than | > | `(a > b)` |'
  prefs: []
  type: TYPE_TB
- en: '| Less than or equal to | <= | `(a <= b)` |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than or equal to | >= | `(a >= b)` |'
  prefs: []
  type: TYPE_TB
- en: '| Equal to | == | `(a == b)` |'
  prefs: []
  type: TYPE_TB
- en: '| Not equal to | != | `(a != b)` |'
  prefs: []
  type: TYPE_TB
- en: Most of these operators are self-explanatory; however, notice that the shorthand
    for *equal to* uses double equal signs. This is an important distinction, since
    the double equal sign is used to test equivalence, while the single equal sign
    is used to assign a value to a variable. The statement `a = 7` means *Put the
    value 7 in the variable `a`*, while `a == 7` means *Check to see whether the variable
    `a` is equal to 7*. (Some programming languages like Pascal actually use := for
    variable assignment to eliminate visual confusion.) Also, notice that an exclamation
    point generally means *not*. This symbol can be used by itself to invert any expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These comparison operators can also be chained together using shorthand for
    OR and AND.
  prefs: []
  type: TYPE_NORMAL
- en: '| Logic | Symbol | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| OR | &#124;&#124; | `((a < b) &#124;&#124; (a < c))` |'
  prefs: []
  type: TYPE_TB
- en: '| AND | && | `((a < b) && !(a < c))` |'
  prefs: []
  type: TYPE_TB
- en: The example statement consisting of the two smaller conditions joined with OR
    logic will fire true if `a` is less than `b`, OR if `a` is less than `c`. Similarly,
    the example statement consisting of two smaller comparisons joined with AND logic
    will fire true if `a` is less than `b` AND `a` is not less than `c`. These statements
    should be grouped with parentheses and can contain many different variations.
  prefs: []
  type: TYPE_NORMAL
- en: Many things can be boiled down to variables, comparison operators, and control
    structures. Returning to the example of the mouse searching for food, hunger can
    be translated into a Boolean true/false variable. Naturally, 1 means true and
    0 means false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here's another shorthand used by programmers and hackers quite often. C doesn't
    really have any Boolean operators, so any nonzero value is considered true, and
    a statement is considered false if it contains 0\. In fact, the comparison operators
    will actually return a value of 1 if the comparison is true and a value of 0 if
    it is false. Checking to see whether the variable `hungry` is equal to 1 will
    return 1 if `hungry` equals 1 and 0 if `hungry` equals 0\. Since the program only
    uses these two cases, the comparison operator can be dropped altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A smarter mouse program with more inputs demonstrates how comparison operators
    can be combined with variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This example assumes there are also variables that describe the presence of
    a cat and the location of the food, with a value of 1 for true and 0 for false.
    Just remember that any nonzero value is considered true, and the value of 0 is
    considered false.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes there will be a set of instructions the programmer knows he will
    need several times. These instructions can be grouped into a smaller subprogram
    called a *function*. In other languages, functions are known as subroutines or
    procedures. For example, the action of turning a car actually consists of many
    smaller instructions: Turn on the appropriate blinker, slow down, check for oncoming
    traffic, turn the steering wheel in the appropriate direction, and so on. The
    driving directions from the beginning of this chapter require quite a few turns;
    however, listing every little instruction for every turn would be tedious (and
    less readable). You can pass variables as arguments to a function in order to
    modify the way the function operates. In this case, the function is passed the
    direction of the turn.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function describes all the instructions needed to make a turn. When a program
    that knows about this function needs to turn, it can just call this function.
    When the function is called, the instructions found within it are executed with
    the arguments passed to it; afterward, execution returns to where it was in the
    program, after the function call. Either left or right can be passed into this
    function, which causes the function to turn in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: By default in C, functions can return a value to a caller. For those familiar
    with functions in mathematics, this makes perfect sense. Imagine a function that
    calculates the factorial of a number—naturally, it returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, functions aren''t labeled with a "function" keyword; instead, they are
    declared by the data type of the variable they are returning. This format looks
    very similar to variable declaration. If a function is meant to return an integer
    (perhaps a function that calculates the factorial of some number *x*), the function
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function is declared as an integer because it multiplies every value from
    1 to *x* and returns the result, which is an integer. The return statement at
    the end of the function passes back the contents of the variable *x* and ends
    the function. This factorial function can then be used like an integer variable
    in the main part of any program that knows about it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At the end of this short program, the variable `b` will contain 120, since the
    factorial function will be called with the argument of 5 and will return 120.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also in C, the compiler must "know" about functions before it can use them.
    This can be done by simply writing the entire function before using it later in
    the program or by using function prototypes. A *function prototype* is simply
    a way to tell the compiler to expect a function with this name, this return data
    type, and these data types as its functional arguments. The actual function can
    be located near the end of the program, but it can be used anywhere else, since
    the compiler already knows about it. An example of a function prototype for the
    `factorial()` function would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Usually, function prototypes are located near the beginning of a program. There's
    no need to actually define any variable names in the prototype, since this is
    done in the actual function. The only thing the compiler cares about is the function's
    name, its return data type, and the data types of its functional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function doesn''t have any value to return, it should be declared as `void`,
    as is the case with the `turn()` function I used as an example earlier. However,
    the `turn()` function doesn''t yet capture all the functionality that our driving
    directions need. Every turn in the directions has both a direction and a street
    name. This means that a turning function should have two variables: the direction
    to turn and the street to turn on to. This complicates the function of turning,
    since the proper street must be located before the turn can be made. A more complete
    turning function using proper C-like syntax is listed below in pseudo-code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function includes a section that searches for the proper intersection by
    looking for street signs, reading the name on each street sign, and storing that
    name in a variable called `current_intersection_name`. It will continue to look
    for and read street signs until the target street is found; at that point, the
    remaining turning instructions will be executed. The pseudo-code driving instructions
    can now be changed to use this turning function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Functions aren't commonly used in pseudo-code, since pseudo-code is mostly used
    as a way for programmers to sketch out program concepts before writing compilable
    code. Since pseudo-code doesn't actually have to work, full functions don't need
    to be written out—simply jotting down *Do some complex stuff here* will suffice.
    But in a programming language like C, functions are used heavily. Most of the
    real usefulness of C comes from collections of existing functions called *libraries*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Your Hands Dirty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the syntax of C feels more familiar and some fundamental programming
    concepts have been explained, actually programming in C isn't that big of a step.
    C compilers exist for just about every operating system and processor architecture
    out there, but for this book, Linux and an *x*86-based processor will be used
    exclusively. Linux is a free operating system that everyone has access to, and
    *x*86-based processors are the most popular consumer-grade processor on the planet.
    Since hacking is really about experimenting, it's probably best if you have a
    C compiler to follow along with.
  prefs: []
  type: TYPE_NORMAL
- en: Included with this book is a Live CD you can use to follow along if your computer
    has an *x*86 processor. Just put the CD in the drive and reboot your computer.
    It will boot into a Linux environment without modifying your existing operating
    system. From this Linux environment you can follow along with the book and experiment
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get right to it. The firstprog.c program is a simple piece of C code that
    will print "Hello, world!" 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Your Hands Dirty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: firstprog.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The main execution of a C program begins in the aptly named `main()`function.
    Any text following two forward slashes (//) is a comment, which is ignored by
    the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The first line may be confusing, but it's just C syntax that tells the compiler
    to include headers for a standard input/output (I/O) library named `stdio`. This
    header file is added to the program when it is compiled. It is located at /usr/include/stdio.h,
    and it defines several constants and function prototypes for corresponding functions
    in the standard I/O library. Since the `main()` function uses the `printf()` function
    from the standard I/O library, a function prototype is needed for `printf()` before
    it can be used. This function prototype (along with many others) is included in
    the stdio.h header file. A lot of the power of C comes from its extensibility
    and libraries. The rest of the code should make sense and look a lot like the
    pseudo-code from before. You may have even noticed that there's a set of curly
    braces that can be eliminated. It should be fairly obvious what this program will
    do, but let's compile it using GCC and run it just to make sure.
  prefs: []
  type: TYPE_NORMAL
- en: The *GNU Compiler Collection (GCC)* is a free C compiler that translates C into
    machine language that a processor can understand. The outputted translation is
    an executable binary file, which is called `a.out` by default. Does the compiled
    program do what you thought it would?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The Bigger Picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, this has all been stuff you would learn in an elementary programming class—basic,
    but essential. Most introductory programming classes just teach how to read and
    write C. Don't get me wrong, being fluent in C is very useful and is enough to
    make you a decent programmer, but it's only a piece of the bigger picture. Most
    programmers learn the language from the top down and never see the big picture.
    Hackers get their edge from knowing how all the pieces interact within this bigger
    picture. To see the bigger picture in the realm of programming, simply realize
    that C code is meant to be compiled. The code can't actually do anything until
    it's compiled into an executable binary file. Thinking of C-source as a program
    is a common misconception that is exploited by hackers every day. The binary `a.out`'s
    instructions are written in machine language, an elementary language the CPU can
    understand. Compilers are designed to translate the language of C code into machine
    language for a variety of processor architectures. In this case, the processor
    is in a family that uses the *x*86 architecture. There are also Sparc processor
    architectures (used in Sun Workstations) and the PowerPC processor architecture
    (used in pre-Intel Macs). Each architecture has a different machine language,
    so the compiler acts as a middle ground—translating C code into machine language
    for the target architecture.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the compiled program works, the average programmer is only concerned
    with source code. But a hacker realizes that the compiled program is what actually
    gets executed out in the real world. With a better understanding of how the CPU
    operates, a hacker can manipulate the programs that run on it. We have seen the
    source code for our first program and compiled it into an executable binary for
    the *x*86 architecture. But what does this executable binary look like? The GNU
    development tools include a program called `objdump`, which can be used to examine
    compiled binaries. Let's start by looking at the machine code the `main()` function
    was translated into.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `objdump` program will spit out far too many lines of output to sensibly
    examine, so the output is piped into `grep` with the command-line option to only
    display 20 lines after the regular expression `main.:`. Each byte is represented
    in *hexadecimal notation*, which is a base-16 numbering system. The numbering
    system you are most familiar with uses a base-10 system, since at 10 you need
    to add an extra symbol. Hexadecimal uses 0 through 9 to represent 0 through 9,
    but it also uses A through F to represent the values 10 through 15\. This is a
    convenient notation since a byte contains 8 bits, each of which can be either
    true or false. This means a byte has 256 (2⁸) possible values, so each byte can
    be described with 2 hexadecimal digits.
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal numbers—starting with `0x8048374` on the far left—are memory
    addresses. The bits of the machine language instructions must be put somewhere,
    and this somewhere is called *memory*. Memory is just a collection of bytes of
    temporary storage space that are numbered with addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Like a row of houses on a local street, each with its own address, memory can
    be thought of as a row of bytes, each with its own memory address. Each byte of
    memory can be accessed by its address, and in this case the CPU accesses this
    part of memory to retrieve the machine language instructions that make up the
    compiled program. Older Intel *x*86 processors use a 32-bit addressing scheme,
    while newer ones use a 64-bit one. The 32-bit processors have 2^(32) (or 4,294,967,296)
    possible addresses, while the 64-bit ones have 2^(64) (1.84467441 x 10^(19)) possible
    addresses. The 64-bit processors can run in 32-bit compatibility mode, which allows
    them to run 32-bit code quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal bytes in the middle of the listing above are the machine language
    instructions for the *x*86 processor. Of course, these hexadecimal values are
    only representations of the bytes of binary 1s and 0s the CPU can understand.
    But since *0101010110001001111001011000001111101100111100001* … isn't very useful
    to anything other than the processor, the machine code is displayed as hexadecimal
    bytes and each instruction is put on its own line, like splitting a paragraph
    into sentences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Come to think of it, the hexadecimal bytes really aren''t very useful themselves,
    either—that''s where assembly language comes in. The instructions on the far right
    are in assembly language. Assembly language is really just a collection of mnemonics
    for the corresponding machine language instructions. The instruction `ret` is
    far easier to remember and make sense of than `0xc3` or `11000011`. Unlike C and
    other compiled languages, assembly language instructions have a direct one-to-one
    relationship with their corresponding machine language instructions. This means
    that since every processor architecture has different machine language instructions,
    each also has a different form of assembly language. Assembly is just a way for
    programmers to represent the machine language instructions that are given to the
    processor. Exactly how these machine language instructions are represented is
    simply a matter of convention and preference. While you can theoretically create
    your own *x*86 assembly language syntax, most people stick with one of the two
    main types: AT&T syntax and Intel syntax. The assembly shown in the output on
    [The Bigger Picture](ch02s05.html#the_bigger_picture "The Bigger Picture") is
    AT&T syntax, as just about all of Linux''s disassembly tools use this syntax by
    default. It''s easy to recognize AT&T syntax by the cacophony of % and $ symbols
    prefixing everything (take a look again at the example on [The Bigger Picture](ch02s05.html#the_bigger_picture
    "The Bigger Picture")). The same code can be shown in Intel syntax by providing
    an additional command-line option, `-M intel`, to `objdump`, as shown in the output
    below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I think Intel syntax is much more readable and easier to understand,
    so for the purposes of this book, I will try to stick with this syntax. Regardless
    of the assembly language representation, the commands a processor understands
    are quite simple. These instructions consist of an operation and sometimes additional
    arguments that describe the destination and/or the source for the operation. These
    operations move memory around, perform some sort of basic math, or interrupt the
    processor to get it to do something else. In the end, that's all a computer processor
    can really do. But in the same way millions of books have been written using a
    relatively small alphabet of letters, an infinite number of possible programs
    can be created using a relatively small collection of machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Processors also have their own set of special variables called *registers*.
    Most of the instructions use these registers to read or write data, so understanding
    the registers of a processor is essential to understanding the instructions. The
    bigger picture keeps getting bigger….
  prefs: []
  type: TYPE_NORMAL
- en: The x86 Processor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 8086 CPU was the first *x*86 processor. It was developed and manufactured
    by Intel, which later developed more advanced processors in the same family: the
    80186, 80286, 80386, and 80486\. If you remember people talking about 386 and
    486 processors in the ''80s and ''90s, this is what they were referring to.'
  prefs: []
  type: TYPE_NORMAL
- en: The *x*86 processor has several registers, which are like internal variables
    for the processor. I could just talk abstractly about these registers now, but
    I think it's always better to see things for yourself. The GNU development tools
    also include a debugger called GDB. *Debuggers* are used by programmers to step
    through compiled programs, examine program memory, and view processor registers.
    A programmer who has never used a debugger to look at the inner workings of a
    program is like a seventeenth-century doctor who has never used a microscope.
    Similar to a microscope, a debugger allows a hacker to observe the microscopic
    world of machine code—but a debugger is far more powerful than this metaphor allows.
    Unlike a microscope, a debugger can view the execution from all angles, pause
    it, and change anything along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Below, GDB is used to show the state of the processor registers right before
    the program starts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A breakpoint is set on the `main()` function so execution will stop right before
    our code is executed. Then GDB runs the program, stops at the breakpoint, and
    is told to display all the processor registers and their current states.
  prefs: []
  type: TYPE_NORMAL
- en: The first four registers (*EAX, ECX, EDX*, and *EBX*) are known as general purpose
    registers. These are called the *Accumulator, Counter, Data*, and *Base* registers,
    respectively. They are used for a variety of purposes, but they mainly act as
    temporary variables for the CPU when it is executing machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The second four registers (*ESP, EBP, ESI*, and *EDI*) are also general purpose
    registers, but they are sometimes known as pointers and indexes. These stand for
    *Stack Pointer, Base Pointer, Source Index*, and *Destination Index*, respectively.
    The first two registers are called pointers because they store 32-bit addresses,
    which essentially point to that location in memory. These registers are fairly
    important to program execution and memory management; we will discuss them more
    later. The last two registers are also technically pointers, which are commonly
    used to point to the source and destination when data needs to be read from or
    written to. There are load and store instructions that use these registers, but
    for the most part, these registers can be thought of as just simple general-purpose
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: The *EIP* register is the *Instruction Pointer* register, which points to the
    current instruction the processor is reading. Like a child pointing his finger
    at each word as he reads, the processor reads each instruction using the EIP register
    as its finger. Naturally, this register is quite important and will be used a
    lot while debugging. Currently, it points to a memory address at `0x804838a`.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining *EFLAGS* register actually consists of several bit flags that
    are used for comparisons and memory segmentations. The actual memory is split
    into several different segments, which will be discussed later, and these registers
    keep track of that. For the most part, these registers can be ignored since they
    rarely need to be accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are using Intel syntax assembly language for this book, our tools must
    be configured to use this syntax. Inside GDB, the disassembly syntax can be set
    to Intel by simply typing `set disassembly intel` or `set dis intel`, for short.
    You can configure this setting to run every time GDB starts up by putting the
    command in the file .gdbinit in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that GDB is configured to use Intel syntax, let''s begin understanding
    it. The assembly instructions in Intel syntax generally follow this style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The destination and source values will either be a register, a memory address,
    or a value. The operations are usually intuitive mnemonics: The `mov`operation
    will move a value from the source to the destination, `sub` will subtract, `inc`
    will increment, and so forth. For example, the instructions below will move the
    value from ESP to EBP and then subtract 8 from ESP (storing the result in ESP).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are also operations that are used to control the flow of execution. The
    `cmp` operation is used to compare values, and basically any operation beginning
    with `j` is used to jump to a different part of the code (depending on the result
    of the comparison). The example below first compares a 4-byte value located at
    EBP minus 4 with the number 9\. The next instruction is shorthand for *jump if
    less than or equal to*, referring to the result of the previous comparison. If
    that value is less than or equal to 9, execution jumps to the instruction at `0x8048393`.
    Otherwise, execution flows to the next instruction with an unconditional jump.
    If the value isn't less than or equal to 9, execution will jump to `0x80483a6`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These examples have been from our previous disassembly, and we have our debugger
    configured to use Intel syntax, so let's use the debugger to step through the
    first program at the assembly instruction level.
  prefs: []
  type: TYPE_NORMAL
- en: The `-g` flag can be used by the GCC compiler to include extra debugging information,
    which will give GDB access to the source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, the source code is listed and the disassembly of the `main()` function
    is displayed. Then a breakpoint is set at the start of `main()`, and the program
    is run. This breakpoint simply tells the debugger to pause the execution of the
    program when it gets to that point. Since the breakpoint has been set at the start
    of the `main()` function, the program hits the breakpoint and pauses before actually
    executing any instructions in `main()`. Then the value of EIP (the Instruction
    Pointer) is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that EIP contains a memory address that points to an instruction in the
    `main()` function's disassembly (shown in bold). The instructions before this
    (shown in italics) are collectively known as the *function prologue* and are generated
    by the compiler to set up memory for the rest of the `main()` function's local
    variables. Part of the reason variables need to be declared in C is to aid the
    construction of this section of code. The debugger knows this part of the code
    is automatically generated and is smart enough to skip over it. We'll talk more
    about the function prologue later, but for now we can take a cue from GDB and
    skip it.
  prefs: []
  type: TYPE_NORMAL
- en: The GDB debugger provides a direct method to examine memory, using the command
    `x`, which is short for *examine*. Examining memory is a critical skill for any
    hacker. Most hacker exploits are a lot like magic tricks—they seem amazing and
    magical, unless you know about sleight of hand and misdirection. In both magic
    and hacking, if you were to look in just the right spot, the trick would be obvious.
    That's one of the reasons a good magician never does the same trick twice. But
    with a debugger like GDB, every aspect of a program's execution can be deterministically
    examined, paused, stepped through, and repeated as often as needed. Since a running
    program is mostly just a processor and segments of memory, examining memory is
    the first way to look at what's really going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examine command in GDB can be used to look at a certain address of memory
    in a variety of ways. This command expects two arguments when it''s used: the
    location in memory to examine and how to display that memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The display format also uses a single-letter shorthand, which is optionally
    preceded by a count of how many items to examine. Some common format letters are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`o`** Display in octal. |'
  prefs: []
  type: TYPE_TB
- en: '| **`x`** Display in hexadecimal. |'
  prefs: []
  type: TYPE_TB
- en: '| **`u`** Display in unsigned, standard base-10 decimal. |'
  prefs: []
  type: TYPE_TB
- en: '| **`t`** Display in binary. |'
  prefs: []
  type: TYPE_TB
- en: These can be used with the examine command to examine a certain memory address.
    In the following example, the current address of the EIP register is used. Shorthand
    commands are often used with GDB, and even `info register eip` can be shortened
    to just `i r eip`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The memory the EIP register is pointing to can be examined by using the address
    stored in EIP. The debugger lets you reference registers directly, so `$eip` is
    equivalent to the value EIP contains at that moment. The value `077042707` in
    octal is the same as `0x00fc45c7` in hexadecimal, which is the same as `16532935`
    in base-10 decimal, which in turn is the same as `00000000111111000100010111000111`
    in binary. A number can also be prepended to the format of the examine command
    to examine multiple units at the target address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The default size of a single unit is a four-byte unit called a *word*. The
    size of the display units for the examine command can be changed by adding a size
    letter to the end of the format letter. The valid size letters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`b`** A single byte |'
  prefs: []
  type: TYPE_TB
- en: '| **`h`** A halfword, which is two bytes in size |'
  prefs: []
  type: TYPE_TB
- en: '| **`w`** A word, which is four bytes in size |'
  prefs: []
  type: TYPE_TB
- en: '| **`g`** A giant, which is eight bytes in size |'
  prefs: []
  type: TYPE_TB
- en: This is slightly confusing, because sometimes the term *word* also refers to
    2-byte values. In this case a *double word* or *DWORD* refers to a 4-byte value.
    In this book, words and DWORDs both refer to 4-byte values. If I'm talking about
    a 2-byte value, I'll call it a *short* or a halfword. The following GDB output
    shows memory displayed in various sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely, you may notice something odd about the data above. The
    first e`x`amine command shows the first eight bytes, and naturally, the e`x`amine
    commands that use bigger units display more data in total. However, the first
    e`x`amine shows the first two bytes to be `0xc7` and `0x45`, but when a halfword
    is examined at the exact same memory address, the value `0x45c7` is shown, with
    the bytes reversed. This same byte-reversal effect can be seen when a full four-byte
    word is shown as `0x00fc45c7`, but when the first four bytes are shown byte by
    byte, they are in the order of `0xc7, 0x45, 0xfc`, and `0x00`.
  prefs: []
  type: TYPE_NORMAL
- en: This is because on the *x*86 processor values are stored in *little-endian byte
    order*, which means the least significant byte is stored first. For example, if
    four bytes are to be interpreted as a single value, the bytes must be used in
    reverse order. The GDB debugger is smart enough to know how values are stored,
    so when a word or halfword is examined, the bytes must be reversed to display
    the correct values in hexadecimal. Revisiting these values displayed both as hexadecimal
    and unsigned decimals might help clear up any confusion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first four bytes are shown both in hexadecimal and standard unsigned decimal
    notation. A command-line calculator program called `bc` is used to show that if
    the bytes are interpreted in the incorrect order, a horribly incorrect value of
    `3343252480` is the result. The byte order of a given architecture is an important
    detail to be aware of. While most debugging tools and compilers will take care
    of the details of byte order automatically, eventually you will directly manipulate
    memory by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to converting byte order, GDB can do other conversions with the
    examine command. We've already seen that GDB can disassemble machine language
    instructions into human-readable assembly instructions. The examine command also
    accepts the format letter `i`, short for *instruction*, to display the memory
    as disassembled assembly language instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the output above, the `a.out` program is run in GDB, with a breakpoint set
    at `main().` Since the EIP register is pointing to memory that actually contains
    machine language instructions, they disassemble quite nicely.
  prefs: []
  type: TYPE_NORMAL
- en: The previous `objdump` disassembly confirms that the seven bytes EIP is pointing
    to actually are machine language for the corresponding assembly instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This assembly instruction will move the value of 0 into memory located at the
    address stored in the EBP register, minus 4\. This is where the C variable `i`
    is stored in memory; `i` was declared as an integer that uses 4 bytes of memory
    on the *x*86 processor. Basically, this command will zero out the variable `i`
    for the for loop. If that memory is examined right now, it will contain nothing
    but random garbage. The memory at this location can be examined several different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The EBP register is shown to contain the address `0xbffff808`, and the assembly
    instruction will be writing to a value offset by 4 less than that, `0xbffff804`.
    The examine command can examine this memory address directly or by doing the math
    on the fly. The `print` command can also be used to do simple math, but the result
    is stored in a temporary variable in the debugger. This variable named `$1` can
    be used later to quickly re-access a particular location in memory. Any of the
    methods shown above will accomplish the same task: displaying the 4 garbage bytes
    found in memory that will be zeroed out when the current instruction executes.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's execute the current instruction using the command `nexti`, which is short
    for *next instruction*. The processor will read the instruction at EIP, execute
    it, and advance EIP to the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As predicted, the previous command zeroes out the 4 bytes found at EBP minus
    4, which is memory set aside for the C variable `i`. Then EIP advances to the
    next instruction. The next few instructions actually make more sense to talk about
    in a group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first instruction, `cmp`, is a compare instruction, which will compare
    the memory used by the C variable `i` with the value 9\. The next instruction,
    `jle` stands for *jump if less than or equal to*. It uses the results of the previous
    comparison (which are actually stored in the EFLAGS register) to jump EIP to point
    to a different part of the code if the destination of the previous comparison
    operation is less than or equal to the source. In this case the instruction says
    to jump to the address `0x8048393` if the value stored in memory for the C variable
    `i` is less than or equal to the value 9\. If this isn''t the case, the EIP will
    continue to the next instruction, which is an unconditional jump instruction.
    This will cause the EIP to jump to the address `0x80483a6`. These three instructions
    combine to create an if-then-else control structure: *If the i is less than or
    equal to 9, then go to the instruction at address 0x8048393; otherwise, go to
    the instruction at address 0x80483a6*. The first address of `0x8048393` (shown
    in bold) is simply the instruction found after the fixed jump instruction, and
    the second address of `0x80483a6` (shown in italics) is located at the end of
    the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we know the value 0 is stored in the memory location being compared with
    the value 9, and we know that 0 is less than or equal to 9, EIP should be at `0x8048393`
    after executing the next two instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the previous two instructions let the program execution flow down
    to `0x8048393`, which brings us to the next two instructions. The first instruction
    is another `mov` instruction that will write the address `0x8048484` into the
    memory address contained in the ESP register. But what is ESP pointing to?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Currently, ESP points to the memory address `0xbffff800`, so when the `mov`
    instruction is executed, the address `0x8048484` is written there. But why? What's
    so special about the memory address `0x8048484`? There's one way to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A trained eye might notice something about the memory here, in particular the
    range of the bytes. After examining memory for long enough, these types of visual
    patterns become more apparent. These bytes fall within the printable ASCII range.
    *ASCII* is an agreed-upon standard that maps all the characters on your keyboard
    (and some that aren't) to fixed numbers. The bytes `0x48, 0x65, 0x6c`, and `0x6f`
    all correspond to letters in the alphabet on the ASCII table shown below. This
    table is found in the man page for ASCII, available on most Unix systems by typing
    `man ascii`.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, GDB's examine command also contains provisions for looking at this
    type of memory. The `c` format letter can be used to automatically look up a byte
    on the ASCII table, and the `s` format letter will display an entire string of
    character data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: These commands reveal that the data string `"Hello, world!\n"` is stored at
    memory address `0x8048484`. This string is the argument for the `printf()` function,
    which indicates that moving the address of this string to the address tored in
    ESP (`0x8048484`) has something to do with this function. The following output
    shows the data string's address being moved into the address ESP is pointing to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The next instruction is actually called the `printf()` function; it prints the
    data string. The previous instruction was setting up for the function call, and
    the results of the function call can be seen in the output below in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Continuing to use GDB to debug, let's examine the next two instructions. Once
    again, they make more sense to look at in a group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: These two instructions basically just increment the variable `i` by 1\. The
    `lea` instruction is an acronym for *Load Effective Address*, which will load
    the familiar address of EBP minus 4 into the EAX register. The execution of this
    instruction is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The following `inc` instruction will increment the value found at this address
    (now stored in the EAX register) by 1\. The execution of this instruction is also
    shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The end result is the value stored at the memory address EBP minus 4 (`0xbffff804`),
    incremented by 1\. This behavior corresponds to a portion of C code in which the
    variable `i` is incremented in the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction is an unconditional jump instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When this instruction is executed, it will send the program back to the instruction
    at address `0x804838b`. It does this by simply setting EIP to that value.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the full disassembly again, you should be able to tell which parts
    of the C code have been compiled into which machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The instructions shown in bold make up the for loop, and the instructions in
    italics are the `printf()` call found within the loop. The program execution will
    jump back to the compare instruction, continue to execute the `printf()` call,
    and increment the counter variable until it finally equals 10\. At this point
    the conditional `jle` instruction won't execute; instead, the instruction pointer
    will continue to the unconditional jump instruction, which exits the loop and
    ends the program.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the idea of programming is less abstract, there are a few other important
    concepts to know about C. Assembly language and computer processors existed before
    higher-level programming languages, and many modern programming concepts have
    evolved through time. In the same way that knowing a little about Latin can greatly
    improve one's understanding of the English language, knowledge of low-level programming
    concepts can assist the comprehension of higher-level ones. When continuing to
    the next section, remember that C code must be compiled into machine instructions
    before it can do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The value `"Hello, world!\n"` passed to the `printf()` function in the previous
    program is a string—technically, a character array. In C, an *array* is simply
    a list of *n* elements of a specific data type. A 20-character array is simply
    20 adjacent characters located in memory. Arrays are also referred to as *buffers*.
    The char_array.c program is an example of a character array.
  prefs: []
  type: TYPE_NORMAL
- en: char_array.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The GCC compiler can also be given the `-o` switch to define the output file
    to compile to. This switch is used below to compile the program into an executable
    binary called `char_array`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, a 20-element character array is defined as `str_a`,
    and each element of the array is written to, one by one. Notice that the number
    begins at 0, as opposed to 1\. Also notice that the last character is a 0\. (This
    is also called a *null byte*.) The character array was defined, so 20 bytes are
    allocated for it, but only 12 of these bytes are actually used. The null byte
    at the end is used as a delimiter character to tell any function that is dealing
    with the string to stop operations right there. The remaining extra bytes are
    just garbage and will be ignored. If a null byte is inserted in the fifth element
    of the character array, only the characters `Hello` would be printed by the `printf()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since setting each character in a character array is painstaking and strings
    are used fairly often, a set of standard functions was created for string manipulation.
    For example, the `strcpy()` function will copy a string from a source to a destination,
    iterating through the source string and copying each byte to the destination (and
    stopping after it copies the null termination byte). The order of the function''s
    arguments is similar to Intel assembly syntax: destination first and then source.
    The char_array.c program can be rewritten using `strcpy()` to accomplish the same
    thing using the string library. The next version of the char_array program shown
    below includes string.h since it uses a string function.'
  prefs: []
  type: TYPE_NORMAL
- en: char_array2.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at this program with GDB. In the output below, the compiled
    program is opened with GDB and breakpoints are set before, in, and after the `strcpy()`
    call shown in bold. The debugger will pause the program at each breakpoint, giving
    us a chance to examine registers and memory. The `strcpy()` function's code comes
    from a shared library, so the breakpoint in this function can't actually be set
    until the program is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When the program is run, the `strcpy()` breakpoint is resolved. At each breakpoint,
    we're going to look at EIP and the instructions it points to. Notice that the
    memory location for EIP at the middle breakpoint is different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The address in EIP at the middle breakpoint is different because the code for
    the `strcpy()` function comes from a loaded library. In fact, the debugger shows
    EIP for the middle breakpoint in the `strcpy()` function, while EIP at the other
    two breakpoints is in the `main()` function. I'd like to point out that EIP is
    able to travel from the main code to the `strcpy()` code and back again. Each
    time a function is called, a record is kept on a data structure simply called
    the stack. The *stack* lets EIP return through long chains of function calls.
    In GDB, the `bt` command can be used to backtrace the stack. In the output below,
    the stack backtrace is shown at each breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: At the middle breakpoint, the backtrace of the stack shows its record of the
    `strcpy()` call. Also, you may notice that the `strcpy()` function is at a slightly
    different address during the second run. This is due to an exploit protection
    method that is turned on by default in the Linux kernel since 2.6.11\. We will
    talk about this protection in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Signed, Unsigned, Long, and Short
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, numerical values in C are signed, which means they can be both negative
    and positive. In contrast, unsigned values don't allow negative numbers. Since
    it's all just memory in the end, all numerical values must be stored in binary,
    and unsigned values make the most sense in binary. A 32-bit unsigned integer can
    contain values from 0 (all binary 0s) to 4,294,967,295 (all binary 1s). A 32-bit
    signed integer is still just 32 bits, which means it can only be in one of 2^(32)
    possible bit combinations. This allows 32-bit signed integers to range from –2,147,483,648
    to 2,147,483,647\. Essentially, one of the bits is a flag marking the value positive
    or negative. Positively signed values look the same as unsigned values, but negative
    numbers are stored differently using a method called two's complement. *Two's
    complement* represents negative numbers in a form suited for binary adders—when
    a negative value in two's complement is added to a positive number of the same
    magnitude, the result will be 0\. This is done by first writing the positive number
    in binary, then inverting all the bits, and finally adding 1\. It sounds strange,
    but it works and allows negative numbers to be added in combination with positive
    numbers using simple binary adders.
  prefs: []
  type: TYPE_NORMAL
- en: This can be explored quickly on a smaller scale using `pcalc`, a simple programmer's
    calculator that displays results in decimal, hexadecimal, and binary formats.
    For simplicity's sake, 8-bit numbers are used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: First, the binary value 01001001 is shown to be positive 73\. Then all the bits
    are flipped, and 1 is added to result in the two's complement representation for
    negative 73, 10110111\. When these two values are added together, the result of
    the original 8 bits is 0\. The program `pcalc` shows the value 256 because it's
    not aware that we're only dealing with 8-bit values. In a binary adder, that carry
    bit would just be thrown away because the end of the variable's memory would have
    been reached. This example might shed some light on how two's complement works
    its magic.
  prefs: []
  type: TYPE_NORMAL
- en: In C, variables can be declared as unsigned by simply prepending the keyword
    `unsigned` to the declaration. An unsigned integer would be declared with `unsigned
    int`. In addition, the size of numerical variables can be extended or shortened
    by adding the keywords `long` or `short`. The actual sizes will vary depending
    on the architecture the code is compiled for. The language of C provides a macro
    called `sizeof()` that can determine the size of certain data types. This works
    like a function that takes a data type as its input and returns the size of a
    variable declared with that data type for the target architecture. The datatype_sizes.c
    program explores the sizes of various data types, using the `sizeof()` function.
  prefs: []
  type: TYPE_NORMAL
- en: datatype_sizes.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code uses the `printf()` function in a slightly different way.
    It uses something called a format specifier to display the value returned from
    the `sizeof()` function calls. Format specifiers will be explained in depth later,
    so for now, let's just focus on the program's output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As previously stated, both signed and unsigned integers are four bytes in size
    on the *x*86 architecture. A float is also four bytes, while a char only needs
    a single byte. The `long` and `short` keywords can also be used with floating-point
    variables to extend and shorten their sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EIP register is a pointer that "points" to the current instruction during
    a program's execution by containing its memory address. The idea of pointers is
    used in C, also. Since the physical memory cannot actually be moved, the information
    in it must be copied. It can be very computationally expensive to copy large chunks
    of memory to be used by different functions or in different places. This is also
    expensive from a memory standpoint, since space for the new destination copy must
    be saved or allocated before the source can be copied. Pointers are a solution
    to this problem. Instead of copying a large block of memory, it is much simpler
    to pass around the address of the beginning of that block of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers in C can be defined and used like any other variable type. Since memory
    on the *x*86 architecture uses 32-bit addressing, pointers are also 32 bits in
    size (4 bytes). Pointers are defined by prepending an asterisk (*) to the variable
    name. Instead of defining a variable of that type, a pointer is defined as something
    that points to data of that type. The pointer.c program is an example of a pointer
    being used with the `char` data type, which is only 1 byte in size.
  prefs: []
  type: TYPE_NORMAL
- en: pointer.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As the comments in the code indicate, the first pointer is set at the beginning
    of the character array. When the character array is referenced like this, it is
    actually a pointer itself. This is how this buffer was passed as a pointer to
    the `printf()` and `strcpy()` functions earlier. The second pointer is set to
    the first pointer's address plus two, and then some things are printed (shown
    in the output below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at this with GDB. The program is recompiled, and a breakpoint
    is set on the tenth line of the source code. This will stop the program after
    the `"Hello, world!\n"` string has been copied into the `str_a`buffer and the
    pointer variable is set to the beginning of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When the pointer is examined as a string, it's apparent that the given string
    is there and is located at memory address `0xbffff7e0`. Remember that the string
    itself isn't stored in the pointer variable—only the memory address `0xbffff7e0`
    is stored there.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see the actual data stored in the pointer variable, you must use
    the address-of operator. The address-of operator is a *unary operator*, which
    simply means it operates on a single argument. This operator is just an ampersand
    (&) prepended to a variable name. When it's used, the address of that variable
    is returned, instead of the variable itself. This operator exists both in GDB
    and in the C programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When the address-of operator is used, the pointer variable is shown to be located
    at the address `0xbffff7dc` in memory, and it contains the address `0xbffff7e0`.
  prefs: []
  type: TYPE_NORMAL
- en: The address-of operator is often used in conjunction with pointers, since pointers
    contain memory addresses. The addressof.c program demonstrates the address-of
    operator being used to put the address of an integer variable into a pointer.
    This line is shown in bold below.
  prefs: []
  type: TYPE_NORMAL
- en: addressof.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The program itself doesn't actually output anything, but you can probably guess
    what happens, even before debugging with GDB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As usual, a breakpoint is set and the program is executed in the debugger. At
    this point the majority of the program has executed. The first `print` command
    shows the value of `int_var`, and the second shows its address using the address-of
    operator. The next two print commands show that `int_ptr` contains the address
    of `int_var`, and they also show the address of the `int_ptr` for good measure.
  prefs: []
  type: TYPE_NORMAL
- en: An additional unary operator called the *dereference* operator exists for use
    with pointers. This operator will return the data found in the address the pointer
    is pointing to, instead of the address itself. It takes the form of an asterisk
    in front of the variable name, similar to the declaration of a pointer. Once again,
    the dereference operator exists both in GDB and in C. Used in GDB, it can retrieve
    the integer value `int_ptr` points to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: A few additions to the addressof.c code (shown in addressof2.c) will demonstrate
    all of these concepts. The added `printf()` functions use format parameters, which
    I'll explain in the next section. For now, just focus on the program's output.
  prefs: []
  type: TYPE_NORMAL
- en: addressof2.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing addressof2.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: When the unary operators are used with pointers, the address-of operator can
    be thought of as moving backward, while the dereference operator moves forward
    in the direction the pointer is pointing.
  prefs: []
  type: TYPE_NORMAL
- en: Format Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `printf()` function can be used to print more than just fixed strings. This
    function can also use format strings to print variables in many different formats.
    A *format string* is just a character string with special escape sequences that
    tell the function to insert variables printed in a specific format in place of
    the escape sequence. The way the `printf()` function has been used in the previous
    programs, the `"Hello, world!\n"` string technically is the format string; however,
    it is devoid of special escape sequences. These *escape sequences* are also called
    *format parameters*, and for each one found in the format string, the function
    is expected to take an additional argument. Each format parameter begins with
    a percent sign (%) and uses a single-character shorthand very similar to formatting
    characters used by GDB's examine command.
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Output Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Decimal |'
  prefs: []
  type: TYPE_TB
- en: '| `%u` | Unsigned decimal |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Hexadecimal |'
  prefs: []
  type: TYPE_TB
- en: All of the preceding format parameters receive their data as values, not pointers
    to values. There are also some format parameters that expect pointers, such as
    the following.
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Output Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | String |'
  prefs: []
  type: TYPE_TB
- en: '| `%n` | Number of bytes written so far |'
  prefs: []
  type: TYPE_TB
- en: The `%s` format parameter expects to be given a memory address; it prints the
    data at that memory address until a null byte is encountered. The `%n`format parameter
    is unique in that it actually writes data. It also expects to be given a memory
    address, and it writes the number of bytes that have been written so far into
    that memory address.
  prefs: []
  type: TYPE_NORMAL
- en: For now, our focus will just be the format parameters used for displaying data.
    The fmt_strings.c program shows some examples of different format parameters.
  prefs: []
  type: TYPE_NORMAL
- en: fmt_strings.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, additional variable arguments are passed to each `printf()`
    call for every format parameter in the format string. The final `printf()` call
    uses the argument `A`, which will provide the address of the variable `A`. The
    program's compilation and execution are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The first two calls to `printf()` demonstrate the printing of variables `A`
    and `B`, using different format parameters. Since there are three format parameters
    in each line, the variables `A` and `B` need to be supplied three times each.
    The `%d` format parameter allows for negative values, while `%u` does not, since
    it is expecting unsigned values.
  prefs: []
  type: TYPE_NORMAL
- en: When the variable `A` is printed using the `%u` format parameter, it appears
    as a very high value. This is because `A` is a negative number stored in two's
    complement, and the format parameter is trying to print it as if it were an unsigned
    value. Since two's complement flips all the bits and adds one, the very high bits
    that used to be zero are now one.
  prefs: []
  type: TYPE_NORMAL
- en: The third line in the example, labeled `[field width on B]`, shows the use of
    the field-width option in a format parameter. This is just an integer that designates
    the minimum field width for that format parameter. However, this is not a maximum
    field width—if the value to be outputted is greater than the field width, the
    field width will be exceeded. This happens when 3 is used, since the output data
    needs 5 bytes. When 10 is used as the field width, 5 bytes of blank space are
    outputted before the output data. Additionally, if a field width value begins
    with a 0, this means the field should be padded with zeros. When 08 is used, for
    example, the output is 00031337.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth line, labeled `[string]`, simply shows the use of the `%s` format
    parameter. Remember that the variable string is actually a pointer containing
    the address of the string, which works out wonderfully, since the `%s` format
    parameter expects its data to be passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: The final line just shows the address of the variable `A`, using the unary address
    operator to dereference the variable. This value is displayed as eight hexadecimal
    digits, padded by zeros.
  prefs: []
  type: TYPE_NORMAL
- en: As these examples show, you should use `%d` for decimal, `%u` for unsigned,
    and `%x` for hexadecimal values. Minimum field widths can be set by putting a
    number right after the percent sign, and if the field width begins with 0, it
    will be padded with zeros. The `%s` parameter can be used to print strings and
    should be passed the address of the string. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: Format strings are used by an entire family of standard I/O functions, including
    `scanf()`, which basically works like `printf()` but is used for input instead
    of output. One key difference is that the `scanf()` function expects all of its
    arguments to be pointers, so the arguments must actually be variable addresses—not
    the variables themselves. This can be done using pointer variables or by using
    the unary address operator to retrieve the address of the normal variables. The
    input.c program and execution should help explain.
  prefs: []
  type: TYPE_NORMAL
- en: input.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In input.c, the `scanf()` function is used to set the `count` variable. The
    output below demonstrates its use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Format strings are used quite often, so familiarity with them is valuable. In
    addition, the ability to output the values of variables allows for debugging in
    the program, without the use of a debugger. Having some form of immediate feedback
    is fairly vital to the hacker's learning process, and something as simple as printing
    the value of a variable can allow for lots of exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Typecasting* is simply a way to temporarily change a variable''s data type,
    despite how it was originally defined. When a variable is typecast into a different
    type, the compiler is basically told to treat that variable as if it were the
    new data type, but only for that operation. The syntax for typecasting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This can be used when dealing with integers and floating-point variables, as
    typecasting.c demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: typecasting.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing typecasting.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As discussed earlier, dividing the integer 13 by 5 will round down to the incorrect
    answer of 2, even if this value is being stored into a floating-point variable.
    However, if these integer variables are typecast into floats, they will be treated
    as such. This allows for the correct calculation of 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: This example is illustrative, but where typecasting really shines is when it
    is used with pointer variables. Even though a pointer is just a memory address,
    the C compiler still demands a data type for every pointer. One reason for this
    is to try to limit programming errors. An integer pointer should only point to
    integer data, while a character pointer should only point to character data. Another
    reason is for pointer arithmetic. An integer is four bytes in size, while a character
    only takes up a single byte. The pointer_types.c program will demonstrate and
    explain these concepts further. This code uses the format parameter `%p` to output
    memory addresses. This is shorthand meant for displaying pointers and is basically
    equivalent to `0x%08x`.
  prefs: []
  type: TYPE_NORMAL
- en: pointer_types.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In this code two arrays are defined in memory—one containing integer data and
    the other containing character data. Two pointers are also defined, one with the
    integer data type and one with the character data type, and they are set to point
    at the start of the corresponding data arrays. Two separate for loops iterate
    through the arrays using pointer arithmetic to adjust the pointer to point at
    the next value. In the loops, when the integer and character values are actually
    printed with the `%d` and `%c` format parameters, notice that the corresponding
    `printf()` arguments must dereference the pointer variables. This is done using
    the unary * operator and has been marked above in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Even though the same value of 1 is added to `int_pointer` and `char_pointer`
    in their respective loops, the compiler increments the pointer's addresses by
    different amounts. Since a char is only 1 byte, the pointer to the next char would
    naturally also be 1 byte over. But since an integer is 4 bytes, a pointer to the
    next integer has to be 4 bytes over.
  prefs: []
  type: TYPE_NORMAL
- en: In pointer_types2.c, the pointers are juxtaposed such that the `int_pointer`
    points to the character data and vice versa. The major changes to the code are
    marked in bold.
  prefs: []
  type: TYPE_NORMAL
- en: pointer_types2.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The output below shows the warnings spewed forth from the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In an attempt to prevent programming mistakes, the compiler gives warnings about
    pointers that point to incompatible data types. But the compiler and perhaps the
    programmer are the only ones that care about a pointer's type. In the compiled
    code, a pointer is nothing more than a memory address, so the compiler will still
    compile the code if a pointer points to an incompatible data type—it simply warns
    the programmer to anticipate unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `int_pointer` points to character data that only contains 5
    bytes of data, it is still typed as an integer. This means that adding 1 to the
    pointer will increment the address by 4 each time. Similarly, the `char_pointer`'s
    address is only incremented by 1 each time, stepping through the 20 bytes of integer
    data (five 4-byte integers), one byte at a time. Once again, the littleendian
    byte order of the integer data is apparent when the 4-byte integer is examined
    one byte at a time. The 4-byte value of `0x00000001` is actually stored in memory
    as `0x01, 0x00, 0x00, 0x00`.
  prefs: []
  type: TYPE_NORMAL
- en: There will be situations like this in which you are using a pointer that points
    to data with a conflicting type. Since the pointer type determines the size of
    the data it points to, it's important that the type is correct. As you can see
    in pointer_types3.c below, typecasting is just a way to change the type of a variable
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: pointer_types3.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In this code, when the pointers are initially set, the data is typecast into
    the pointer's data type. This will prevent the C compiler from complaining about
    the conflicting data types; however, any pointer arithmetic will still be incorrect.
    To fix that, when 1 is added to the pointers, they must first be typecast into
    the correct data type so the address is incremented by the correct amount. Then
    this pointer needs to be typecast back into the pointer's data type once again.
    It doesn't look too pretty, but it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, it is far easier just to use the correct data type for pointers in
    the first place; however, sometimes a generic, typeless pointer is desired. In
    C, a void pointer is a typeless pointer, defined by the `void` keyword. Experimenting
    with void pointers quickly reveals a few things about typeless pointers. First,
    pointers cannot be de-referenced unless they have a type. In order to retrieve
    the value stored in the pointer's memory address, the compiler must first know
    what type of data it is. Secondly, void pointers must also be typecast before
    doing pointer arithmetic. These are fairly intuitive limitations, which means
    that a void pointer's main purpose is to simply hold a memory address.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer_types3.c program can be modified to use a single void pointer by
    typecasting it to the proper type each time it's used. The compiler knows that
    a void pointer is typeless, so any type of pointer can be stored in a void pointer
    without typecasting. This also means a void pointer must always be typecast when
    dereferencing it, however. These differences can be seen in pointer_types4.c,
    which uses a void pointer.
  prefs: []
  type: TYPE_NORMAL
- en: pointer_types4.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing pointer_types4.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The compilation and output of this pointer_types4.c is basically the same as
    that for pointer_types3.c. The void pointer is really just holding the memory
    addresses, while the hard-coded typecasting is telling the compiler to use the
    proper types whenever the pointer is used.
  prefs: []
  type: TYPE_NORMAL
- en: Since the type is taken care of by the typecasts, the void pointer is truly
    nothing more than a memory address. With the data types defined by typecasting,
    anything that is big enough to hold a four-byte value can work the same way as
    a void pointer. In pointer_types5.c, an unsigned integer is used to store this
    address.
  prefs: []
  type: TYPE_NORMAL
- en: pointer_types5.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is rather hacky, but since this integer value is typecast into the proper
    pointer types when it is assigned and de-referenced, the end result is the same.
    Notice that instead of typecasting multiple times to do pointer arithmetic on
    an unsigned integer (which isn't even a pointer), the `sizeof()` function is used
    to achieve the same result using normal arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to remember about variables in C is that the compiler is
    the only thing that cares about a variable's type. In the end, after the program
    has been compiled, the variables are nothing more than memory addresses. This
    means that variables of one type can easily be coerced into behaving like another
    type by telling the compiler to typecast them into the desired type.
  prefs: []
  type: TYPE_NORMAL
- en: Command-Line Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many nongraphical programs receive input in the form of command-line arguments.
    Unlike inputting with `scanf()`, command-line arguments don't require user interaction
    after the program has begun execution. This tends to be more efficient and is
    a useful input method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, command-line arguments can be accessed in the `main()` function by including
    two additional arguments to the function: an integer and a pointer to an array
    of strings. The integer will contain the number of arguments, and the array of
    strings will contain each of those arguments. The commandline.c program and its
    execution should explain things.'
  prefs: []
  type: TYPE_NORMAL
- en: commandline.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The zeroth argument is always the name of the executing binary, and the rest
    of the argument array (often called an *argument vector*) contains the remaining
    arguments as strings.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a program will want to use a command-line argument as an integer as
    opposed to a string. Regardless of this, the argument is passed in as a string;
    however, there are standard conversion functions. Unlike simple typecasting, these
    functions can actually convert character arrays containing numbers into actual
    integers. The most common of these functions is `atoi()`, which is short for *ASCII
    to integer*. This function accepts a pointer to a string as its argument and returns
    the integer value it represents. Observe its usage in convert.c.
  prefs: []
  type: TYPE_NORMAL
- en: convert.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing convert.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, an `if` statement makes sure that three arguments are
    used before these strings are accessed. If the program tries to access memory
    that doesn't exist or that the program doesn't have permission to read, the program
    will crash. In C it's important to check for these types of conditions and handle
    them in program logic. If the error-checking `if` statement is commented out,
    this memory violation can be explored. The convert2.c program should make this
    more clear.
  prefs: []
  type: TYPE_NORMAL
- en: convert2.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing convert2.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: When the program isn't given enough command-line arguments, it still tries to
    access elements of the argument array, even though they don't exist. This results
    in the program crashing due to a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: Memory is split into segments (which will be discussed later), and some memory
    addresses aren't within the boundaries of the memory segments the program is given
    access to. When the program attempts to access an address that is out of bounds,
    it will crash and die in what's called a *segmentation fault*. This effect can
    be explored further with GDB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The program is executed with a single command-line argument of `test` within
    GDB, which causes the program to crash. The `where` command will sometimes show
    a useful backtrace of the stack; however, in this case, the stack was too badly
    mangled in the crash. A breakpoint is set on main and the program is re-executed
    to get the value of the argument vector (shown in bold). Since the argument vector
    is a pointer to list of strings, it is actually a pointer to a list of pointers.
    Using the command `x/3xw` to examine the first three memory addresses stored at
    the argument vector's address shows that they are themselves pointers to strings.
    The first one is the zeroth argument, the second is the `test` argument, and the
    third is zero, which is out of bounds. When the program tries to access this memory
    address, it crashes with a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Scoping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another interesting concept regarding memory in C is variable scoping or context—in
    particular, the contexts of variables within functions. Each function has its
    own set of local variables, which are independent of everything else. In fact,
    multiple calls to the same function all have their own contexts. You can use the
    `printf()` function with format strings to quickly explore this;check it out in
    scope.c.
  prefs: []
  type: TYPE_NORMAL
- en: scope.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The output of this simple program demonstrates nested function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: In each function, the variable `i` is set to a different value and printed.
    Notice that within the `main()` function, the variable `i` is 3, even after calling
    `func1()` where the variable `i` is 5\. Similarly, within `func1()` the variable
    `i` remains 5, even after calling `func2()` where `i` is 7, and so forth. The
    best way to think of this is that each function call has its own version of the
    variable `i`.
  prefs: []
  type: TYPE_NORMAL
- en: Variables can also have a global scope, which means they will persist across
    all functions. Variables are global if they are defined at the beginning of the
    code, outside of any functions. In the scope2.c example code shown below, the
    variable `j` is declared globally and set to 42\. This variable can be read from
    and written to by any function, and the changes to it will persist between functions.
  prefs: []
  type: TYPE_NORMAL
- en: scope2.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing scope2.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: In the output, the global variable `j` is written to in `func2()`, and the change
    persists in all functions except `func3()`, which has its own local variable called
    `j`. In this case, the compiler prefers to use the local variable. With all these
    variables using the same names, it can be a little confusing, but remember that
    in the end, it's all just memory. The global variable `j` is just stored in memory,
    and every function is able to access that memory. The local variables for each
    function are each stored in their own places in memory, regardless of the identical
    names. Printing the memory addresses of these variables will give a clearer picture
    of what's going on. In the scope3.c example code below, the variable addresses
    are printed using the unary address-of operator.
  prefs: []
  type: TYPE_NORMAL
- en: scope3.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing scope3.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In this output, it is obvious that the variable `j` used by `func3()` is different
    than the `j` used by the other functions. The `j` used by `func3()` is located
    at `0xbffff7d0`, while the `j` used by the other functions is located at `0x08049988`.
    Also, notice that the variable `i` is actually a different memory address for
    each function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following output, GDB is used to stop execution at a breakpoint in `func3()`.
    Then the backtrace command shows the record of each function call on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The backtrace also shows the nested function calls by looking at records kept
    on the stack. Each time a function is called, a record called a *stack frame*
    is put on the stack. Each line in the backtrace corresponds to a stack frame.
    Each stack frame also contains the local variables for that context. The local
    variables contained in each stack frame can be shown in GDB by adding the word
    *full* to the backtrace command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The full backtrace clearly shows that the local variable `j` only exists in
    `func3()`'s context. The global version of the variable `j` is used in the other
    function's contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to globals, variables can also be defined as static variables by
    prepending the keyword `static` to the variable definition. Similar to global
    variables, a *static variable* remains intact between function calls; however,
    static variables are also akin to local variables since they remain local within
    a particular function context. One different and unique feature of static variables
    is that they are only initialized once. The code in static.c will help explain
    these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: static.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The aptly named `static_var` is defined as a static variable in two places:
    within the context of `main()` and within the context of `function()`. Since static
    variables are local within a particular functional context, these variables can
    have the same name, but they actually represent two different locations in memory.
    The function simply prints the values of the two variables in its context and
    then adds 1 to both of them. Compiling and executing this code will show the difference
    between the static and nonstatic variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `static_var` retains its value between subsequent calls to `function()`.
    This is because static variables retain their values, but also because they are
    only initialized once. In addition, since the static variables are local to a
    particular functional context, the `static_var` in the context of `main()` retains
    its value of 1337 the entire time.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, printing the addresses of these variables by dereferencing them
    with the unary address operator will provide greater viability into what's really
    going on. Take a look at static2.c for an example.
  prefs: []
  type: TYPE_NORMAL
- en: static2.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing static2.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: With the addresses of the variables displayed, it is apparent that the `static_var`
    in `main()` is different than the one found in `function()`, since they are located
    at different memory addresses (`0x804968c` and `0x8049688`, respectively). You
    may have noticed that the addresses of the local variables all have very high
    addresses, like `0xbffff814`, while the global and static variables all have very
    low memory addresses, like `0x0804968c` and `0x8049688`. That's very astute of
    you—noticing details like this and asking why is one of the cornerstones of hacking.
    Read on for your answers.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Segmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A compiled program''s memory is divided into five segments: text, data, bss,
    heap, and stack. Each segment represents a special portion of memory that is set
    aside for a certain purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *text segment* is also sometimes called the *code segment*. This is where
    the assembled machine language instructions of the program are located. The execution
    of instructions in this segment is nonlinear, thanks to the aforementioned high-level
    control structures and functions, which compile into branch, jump, and call instructions
    in assembly language. As a program executes, the EIP is set to the first instruction
    in the text segment. The processor then follows an execution loop that does the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the instruction that EIP is pointing to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds the byte length of the instruction to EIP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executes the instruction that was read in step 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Goes back to step 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes the instruction will be a jump or a call instruction, which changes
    the EIP to a different address of memory. The processor doesn't care about the
    change, because it's expecting the execution to be nonlinear anyway. If EIP is
    changed in step 3, the processor will just go back to step 1 and read the instruction
    found at the address of whatever EIP was changed to.
  prefs: []
  type: TYPE_NORMAL
- en: Write permission is disabled in the text segment, as it is not used to store
    variables, only code. This prevents people from actually modifying the program
    code; any attempt to write to this segment of memory will cause the program to
    alert the user that something bad happened, and the program will be killed. Another
    advantage of this segment being read-only is that it can be shared among different
    copies of the program, allowing multiple executions of the program at the same
    time without any problems. It should also be noted that this memory segment has
    a fixed size, since nothing ever changes in it.
  prefs: []
  type: TYPE_NORMAL
- en: The data and bss segments are used to store global and static program variables.
    The *data segment* is filled with the initialized global and static variables,
    while the *bss segment* is filled with their uninitialized counterparts. Although
    these segments are writable, they also have a fixed size. Remember that global
    variables persist, despite the functional context (like the variable `j` in the
    previous examples). Both global and static variables are able to persist because
    they are stored in their own memory segments.
  prefs: []
  type: TYPE_NORMAL
- en: The *heap segment* is a segment of memory a programmer can directly control.
    Blocks of memory in this segment can be allocated and used for whatever the programmer
    might need. One notable point about the heap segment is that it isn't of fixed
    size, so it can grow larger or smaller as needed. All of the memory within the
    heap is managed by allocator and deallocator algorithms, which respectively reserve
    a region of memory in the heap for use and remove reservations to allow that portion
    of memory to be reused for later reservations. The heap will grow and shrink depending
    on how much memory is reserved for use. This means a programmer using the heap
    allocation functions can reserve and free memory on the fly. The growth of the
    heap moves downward toward higher memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The *stack segment* also has variable size and is used as a temporary scratch
    pad to store local function variables and context during function calls. This
    is what GDB's backtrace command looks at. When a program calls a function, that
    function will have its own set of passed variables, and the function's code will
    be at a different memory location in the text (or code) segment. Since the context
    and the EIP must change when a function is called, the stack is used to remember
    all of the passed variables, the location the EIP should return to after the function
    is finished, and all the local variables used by that function. All of this information
    is stored together on the stack in what is collectively called a *stack frame*.
    The stack contains many stack frames.
  prefs: []
  type: TYPE_NORMAL
- en: In general computer science terms, a *stack* is an abstract data structure that
    is used frequently. It has *first-in, last-out (FILO) ordering*, which means the
    first item that is put into a stack is the last item to come out of it. Think
    of it as putting beads on a piece of string that has a knot on one end—you can't
    get the first bead off until you have removed all the other beads. When an item
    is placed into a stack, it's known as *pushing*, and when an item is removed from
    a stack, it's called *popping*.
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, the stack segment of memory is, in fact, a stack data structure,
    which contains stack frames. The ESP register is used to keep track of the address
    of the end of the stack, which is constantly changing as items are pushed into
    and popped off of it. Since this is very dynamic behavior, it makes sense that
    the stack is also not of a fixed size. Opposite to the dynamic growth of the heap,
    as the stack changes in size, it grows upward in a visual listing of memory, toward
    lower memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FILO nature of a stack might seem odd, but since the stack is used to store
    context, it''s very useful. When a function is called, several things are pushed
    to the stack together in a *stack frame*. The EBP register—sometimes called the
    *frame pointer (FP)* or *local base (LB) pointer*— is used to reference local
    function variables in the current stack frame. Each stack frame contains the parameters
    to the function, its local variables, and two pointers that are necessary to put
    things back the way they were: the saved frame pointer (SFP) and the return address.
    The *SFP* is used to restore EBP to its previous value, and the *return address*
    is used to restore EIP to the next instruction found after the function call.
    This restores the functional context of the previous stack frame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following stack_example.c code has two functions: `main()` and `test_function()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory Segmentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: stack_example.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This program first declares a test function that has four arguments, which
    are all declared as integers: `a`, `b`, `c`, and `d`. The local variables for
    the function include a single character called `flag` and a 10-character buffer
    called `buffer`. The memory for these variables is in the stack segment, while
    the machine instructions for the function''s code is stored in the text segment.
    After compiling the program, its inner workings can be examined with GDB. The
    following output shows the disassembled machine instructions for `main()` and
    `test_function()`. The `main()` function starts at `0x08048357` and `test_function()`starts
    at `0x08048344`. The first few instructions of each function (shown in bold below)
    set up the stack frame. These instructions are collectively called the *procedure
    prologue* or *function prologue*. They save the frame pointer on the stack, and
    they save stack memory for the local function variables. Sometimes the function
    prologue will handle some stack alignment as well. The exact prologue instructions
    will vary greatly depending on the compiler and compiler options, but in general
    these instructions build the stack frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: When the program is run, the `main()` function is called, which simply calls
    `test_function()`.
  prefs: []
  type: TYPE_NORMAL
- en: When the `test_function()` is called from the `main()` function, the various
    values are pushed to the stack to create the start of the stack frame as follows.
    When `test_function()` is called, the function arguments are pushed onto the stack
    in reverse order (since it's FILO). The arguments for the function are 1, 2, 3,
    and 4, so the subsequent push instructions push 4, 3, 2, and finally 1 onto the
    stack. These values correspond to the variables `d`, `c`, `b`, and `a` in the
    function. The instructions that put these values on the stack are shown in bold
    in the `main()` function's disassembly below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Next, when the assembly call instruction is executed, the return address is
    pushed onto the stack and the execution flow jumps to the start of `test_function()`
    at `0x08048344`. The return address value will be the location of the instruction
    following the current EIP—specifically, the value stored during step 3 of the
    previously mentioned execution loop. In this case, the return address would point
    to the leave instruction in `main()` at `0x0804838b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call instruction both stores the return address on the stack and jumps
    EIP to the beginning of `test_function()`, so `test_function()`''s procedure prologue
    instructions finish building the stack frame. In this step, the current value
    of EBP is pushed to the stack. This value is called the saved frame pointer (SFP)
    and is later used to restore EBP back to its original state. The current value
    of ESP is then copied into EBP to set the new frame pointer. This frame pointer
    is used to reference the local variables of the function (`flag` and `buffer`).
    Memory is saved for these variables by subtracting fromESP. In the end, the stack
    frame looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254229.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x200-1.
  prefs: []
  type: TYPE_NORMAL
- en: We can watch the stack frame construction on the stack using GDB. In the following
    output, a breakpoint is set in `main()` before the call to `test_function()`and
    also at the beginning of `test_function()`. GDB will put the first breakpoint
    before the function arguments are pushed to the stack, and the second breakpoint
    after `test_function()`'s procedure prologue. When the program is run, execution
    stops at the breakpoint, where the register's ESP (stack pointer), EBP (frame
    pointer), and EIP (execution pointer) are examined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This breakpoint is right before the stack frame for the `test_function()` call
    is created. This means the bottom of this new stack frame is at the current value
    of ESP, `0xbffff7f0`. The next breakpoint is right after the procedure prologue
    for `test_function()`, so continuing will build the stack frame. The output below
    shows similar information at the second breakpoint. The local variables (`flag`
    and `buffer`) are referenced relative to the frame pointer (EBP).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack frame is shown on the stack at the end. The four arguments to the
    function can be seen at the bottom of the stack frame (![](httpatomoreillycomsourcenostarchimages254261.png)
    ), with the return address found directly on top (![](httpatomoreillycomsourcenostarchimages254461.png)).
    Above that is the saved frame pointer of `0xbffff808` (![](httpatomoreillycomsourcenostarchimages254537.png)),
    which is what EBP was in the previous stack frame. The rest of the memory is saved
    for the local stack variables: `flag` and `buffer`. Calculating their relative
    addresses to EBP show their exact locations in the stack frame. Memory for the
    `flag` variable is shown at ![](httpatomoreillycomsourcenostarchimages254530.png)
    and memory for the buffer variable is shown at ![](httpatomoreillycomsourcenostarchimages254488.png).
    The extra space in the stack frame is just padding.'
  prefs: []
  type: TYPE_NORMAL
- en: After the execution finishes, the entire stack frame is popped off of the stack,
    and the EIP is set to the return address so the program can continue execution.
    If another function was called within the function, another stack frame would
    be pushed onto the stack, and so on. As each function ends, its stack frame is
    popped off of the stack so execution can be returned to the previous function.
    This behavior is the reason this segment of memory is organized in a FILO data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: The various segments of memory are arranged in the order they were presented,
    from the lower memory addresses to the higher memory addresses. Since most people
    are familiar with seeing numbered lists that count downward, the smaller memory
    addresses are shown at the top. Some texts have this reversed, which can be very
    confusing; so for this book, smaller memory addresses are always shown at the
    top. Most debuggers also display memory in this style, with the smaller memory
    addresses at the top and the higher ones at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Since the heap and the stack are both dynamic, they both grow in different directions
    toward each other. This minimizes wasted space, allowing the stack to be larger
    if the heap is small and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254381.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x200-2.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Segments in C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C, as in other compiled languages, the compiled code goes into the text segment,
    while the variables reside in the remaining segments. Exactly which memory segment
    a variable will be stored in depends on how the variable is defined. Variables
    that are defined outside of any functions are considered to be global. The `static`
    keyword can also be prepended to any variable declaration to make the variable
    static. If static or global variables are initialized with data, they are stored
    in the data memory segment; otherwise, these variables are put in the bss memory
    segment. Memory on the heap memory segment must first be allocated using a memory
    allocation function called `malloc()`. Usually, pointers are used to reference
    memory on the heap. Finally, the remaining function variables are stored in the
    stack memory segment. Since the stack can contain many different stack frames,
    stack variables can maintain uniqueness within different functional contexts.
    The memory_segments.c program will help explain these concepts in C.
  prefs: []
  type: TYPE_NORMAL
- en: memory_segments.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is fairly self-explanatory because of the descriptive variable
    names. The global and static variables are declared as described earlier, and
    initialized counterparts are also declared. The stack variable is declared both
    in `main()` and in `function()` to showcase the effect of functional contexts.
    The heap variable is actually declared as an integer pointer, which will point
    to memory allocated on the heap memory segment. The `malloc()`function is called
    to allocate four bytes on the heap. Since the newly allocated memory could be
    of any data type, the `malloc()` function returns a void pointer, which needs
    to be typecast into an integer pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The first two initialized variables have the lowest memory addresses, since
    they are located in the data memory segment. The next two variables, `static_var`
    and `global_var`, are stored in the bss memory segment, since they aren't initialized.
    These memory addresses are slightly larger than the previous variables' addresses,
    since the bss segment is located below the data segment. Since both of these memory
    segments have a fixed size after compilation, there is little wasted space, and
    the addresses aren't very far apart.
  prefs: []
  type: TYPE_NORMAL
- en: The heap variable is stored in space allocated on the heap segment, which is
    located just below the bss segment. Remember that memory in this segment isn't
    fixed, and more space can be dynamically allocated later. Finally, the last two
    `stack_var`s have very large memory addresses, since they are located in the stack
    segment. Memory in the stack isn't fixed, either; however, this memory starts
    at the bottom and grows backward toward the heap segment. This allows both memory
    segments to be dynamic without wasting space in memory. The first `stack_var`
    in the `main()` function's context is stored in the stack segment within a stack
    frame. The second `stack_var` in `function()` has its own unique context, so that
    variable is stored within a different stack frame in the stack segment. When `function()`
    is called near the end of the program, a new stack frame is created to store (among
    other things) the `stack_var` for `function()`'s context. Since the stack grows
    back up toward the heap segment with each new stack frame, the memory address
    for the second `stack_var`(`0xbffff814`) is smaller than the address for the first
    `stack_var` (`0xbffff834`) found within `main()`'s context.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the other memory segments is simply a matter of how you declare variables.
    However, using the heap requires a bit more effort. As previously demonstrated,
    allocating memory on the heap is done using the `malloc()`function. This function
    accepts a size as its only argument and reserves that much space in the heap segment,
    returning the address to the start of this memory as a void pointer. If the `malloc()`
    function can't allocate memory for some reason, it will simply return a NULL pointer
    with a value of 0\. The corresponding deallocation function is `free()`. This
    function accepts a pointer as its only argument and frees that memory space on
    the heap so it can be used again later. These relatively simple functions are
    demonstrated in heap_example.c.
  prefs: []
  type: TYPE_NORMAL
- en: heap_example.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This program accepts a command-line argument for the size of the first memory
    allocation, with a default value of 50\. Then it uses the `malloc()` and `free()`
    functions to allocate and deallocate memory on the heap. There are plenty of `printf()`
    statements to debug what is actually happening when the program is executed. Since
    `malloc()` doesn't know what type of memory it's allocating, it returns a void
    pointer to the newly allocated heap memory, which must be typecast into the appropriate
    type. After every `malloc()` call, there is an error-checking block that checks
    whether or not the allocation failed. If the allocation fails and the pointer
    is NULL, `fprintf()` is used to print an error message to standard error and the
    program exits. The `fprintf()` function is very similar to `printf()`; however,
    its first argument is `stderr`, which is a standard filestream meant for displaying
    errors. This function will be explained more later, but for now, it's just used
    as a way to properly display an error. The rest of the program is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, notice that each block of memory has an incrementally
    higher memory address in the heap. Even though the first 50 bytes were deallocated,
    when 15 more bytes are requested, they are put after the 12 bytes allocated for
    the `int_ptr`. The heap allocation functions control this behavior, which can
    be explored by changing the size of the initial memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: If a larger block of memory is allocated and then deallocated, the final 15-byte
    allocation will occur in that freed memory space, instead. By experimenting with
    different values, you can figure out exactly when the allocation function chooses
    to reclaim freed space for new allocations. Often, simple informative `printf()`
    statements and a little experimentation can reveal many things about the underlying
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Error-Checked malloc()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In heap_example.c, there were several error checks for the `malloc()` calls.
    Even though the `malloc()` calls never failed, it's important to handle all potential
    cases when coding in C. But with multiple `malloc()` calls, this error-checking
    code needs to appear in multiple places. This usually makes the code look sloppy,
    and it's inconvenient if changes need to be made to the error-checking code or
    if new `malloc()` calls are needed. Since all the error-checking code is basically
    the same for every `malloc()` call, this is a perfect place to use a function
    instead of repeating the same instructions in multiple places. Take a look at
    errorchecked_heap.c for an example.
  prefs: []
  type: TYPE_NORMAL
- en: errorchecked_heap.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The errorchecked_heap.c program is basically equivalent to the previous heap_example.c
    code, except the heap memory allocation and error checking has been gathered into
    a single function. The first line of code [`void *errorchecked_malloc(unsigned
    int);`] is the function prototype. This lets the compiler know that there will
    be a function called `errorchecked_malloc()` that expects a single, unsigned integer
    argument and returns a `void` pointer. The actual function can then be anywhere;
    in this case it is after the `main()` function. The function itself is quite simple;
    it just accepts the size in bytes to allocate and attempts to allocate that much
    memory using `malloc()`. If the allocation fails, the error-checking code displays
    an error and the program exits; otherwise, it returns the pointer to the newly
    allocated heap memory. This way, the custom `errorchecked_malloc()` function can
    be used in place of a normal `malloc()`, eliminating the need for repetitious
    error checking afterward. This should begin to highlight the usefulness of programming
    with functions.
  prefs: []
  type: TYPE_NORMAL
- en: Building on Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you understand the basic concepts of C programming, the rest is pretty
    easy. The bulk of the power of C comes from using other functions. In fact, if
    the functions were removed from any of the preceding programs, all that would
    remain are very basic statements.
  prefs: []
  type: TYPE_NORMAL
- en: File Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two primary ways to access files in C: file descriptors and filestreams.
    *File descriptors* use a set of low-level I/O functions, and *filestreams* are
    a higher-level form of buffered I/O that is built on the lower-level functions.
    Some consider the filestream functions easier to program with; however, file descriptors
    are more direct. In this book, the focus will be on the low-level I/O functions
    that use file descriptors.'
  prefs: []
  type: TYPE_NORMAL
- en: The bar code on the back of this book represents a number. Because this number
    is unique among the other books in a bookstore, the cashier can scan the number
    at checkout and use it to reference information about this book in the store's
    database. Similarly, a file descriptor is a number that is used to reference open
    files. Four common functions that use file descriptors are `open(), close(), read()`,
    and `write()`. All of these functions will return –1 if there is an error. The
    `open()` function opens a file for reading and/or writing and returns a file descriptor.
    The returned file descriptor is just an integer value, but it is unique among
    open files. The file descriptor is passed as an argument to the other functions
    like a pointer to the opened file. For the `close()` function, the file descriptor
    is the only argument. The `read()` and `write()` functions' arguments are the
    file descriptor, a pointer to the data to read or write, and the number of bytes
    to read or write from that location. The arguments to the `open()` function are
    a pointer to the filename to open and a series of predefined flags that specify
    the access mode. These flags and their usage will be explained in depth later,
    but for now let's take a look at a simple note-taking program that uses file descriptors—simplenote.c.
    This program accepts a note as a command-line argument and then adds it to the
    end of the file /tmp/notes. This program uses several functions, including a familiar
    looking error-checked heap memory allocation function. Other functions are used
    to display a usage message and to handle fatal errors. The `usage()` function
    is simply defined before `main()`, so it doesn't need a function prototype.
  prefs: []
  type: TYPE_NORMAL
- en: simplenote.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Besides the strange-looking flags used in the `open()` function, most of this
    code should be readable. There are also a few standard functions that we haven't
    used before. The `strlen()` function accepts a string and returns its length.
    It's used in combination with the `write()` function, since it needs to know how
    many bytes to write. The `perror()` function is short for *print error* and is
    used in `fatal()` to print an additional error message (if it exists) before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program''s execution is pretty self-explanatory, but there
    are some things about the source code that need further explanation. The files
    fcntl.h and sys/stat.h had to be included, since those files define the flags
    used with the `open()` function. The first set of flags is found in fcntl.h and
    is used to set the access mode. The access mode must use at least one of the following
    three flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`O_RDONLY`** Open file for read-only access. |'
  prefs: []
  type: TYPE_TB
- en: '| **`O_WRONLY`** Open file for write-only access. |'
  prefs: []
  type: TYPE_TB
- en: '| **`O_RDWR`** Open file for both read and write access. |'
  prefs: []
  type: TYPE_TB
- en: 'These flags can be combined with several other optional flags using thebitwise
    OR operator. A few of the more common and useful of these flags areas follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`O_APPEND`** Write data at the end of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| **`O_TRUNC`** If the file already exists, truncate the file to 0 length.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`O_CREAT`** Create the file if it doesn''t exist. |'
  prefs: []
  type: TYPE_TB
- en: Bitwise operations combine bits using standard logic gates such as OR and AND.
    When two bits enter an OR gate, the result is 1 if either the first bit *or* the
    second bit is 1\. If two bits enter an AND gate, the result is 1 only if both
    the first bit *and* the second bit are 1\. Full 32-bit values can use these bitwise
    operators to perform logic operations on each corresponding bit. The source code
    of bitwise.c and the program output demonstrate these bitwise operations.
  prefs: []
  type: TYPE_NORMAL
- en: bitwise.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing bitwise.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The flags used for the `open()` function have values that correspond to single
    bits. This way, flags can be combined using OR logic without destroying any information.
    The fcntl_flags.c program and its output explore some of the flag values defined
    by fcntl.h and how they combine with each other.
  prefs: []
  type: TYPE_NORMAL
- en: fcntl_flags.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing fcntl_flags.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Using bit flags in combination with bitwise logic is an efficient and commonly
    used technique. As long as each flag is a number that only has unique bits turned
    on, the effect of doing a bitwise OR on these values is the same as adding them.
    In fcntl_flags.c, 1 + 1024 + 64 = 1089\. This technique only works when all the
    bits are unique, though.
  prefs: []
  type: TYPE_NORMAL
- en: File Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the `O_CREAT` flag is used in access mode for the `open()` function, an additional
    argument is needed to define the file permissions of the newly created file. This
    argument uses bit flags defined in sys/stat.h, which can be combined with each
    other using bitwise OR logic.
  prefs: []
  type: TYPE_NORMAL
- en: '| **`S_IRUSR`** Give the file read permission for the user (owner). |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IWUSR`** Give the file write permission for the user (owner). |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IXUSR`** Give the file execute permission for the user (owner). |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IRGRP`** Give the file read permission for the group. |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IWGRP`** Give the file write permission for the group. |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IXGRP`** Give the file execute permission for the group. |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IROTH`** Give the file read permission for other (anyone). |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IWOTH`** Give the file write permission for other (anyone). |'
  prefs: []
  type: TYPE_TB
- en: '| **`S_IXOTH`** Give the file execute permission for other (anyone). |'
  prefs: []
  type: TYPE_TB
- en: If you are already familiar with Unix file permissions, those flags should make
    perfect sense to you. If they don't make sense, here's a crash course in Unix
    file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Every file has an owner and a group. These values can be displayed using `ls
    -l` and are shown below in the following output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: For the /etc/passwd file, the owner is root and the group is also root. For
    the other two simplenote files, the owner is reader and the group is users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read, write, and execute permissions can be turned on and off for three different
    fields: user, group, and other. User permissions describe what the owner of the
    file can do (read, write, and/or execute), group permissions describe what users
    in that group can do, and other permissions describe what everyone else can do.
    These fields are also displayed in the front of the `ls -l` output. First, the
    user read/write/execute permissions are displayed, using `r` for read, `w` for
    write, `x` for execute, and - for off. The next three characters display the group
    permissions, and the last three characters are for the other permissions. In the
    output above, the simplenote program has all three user permissions turned on
    (shown in bold). Each permission corresponds to a bit flag; read is 4 (100 in
    binary), write is 2 (010 in binary), and execute is 1 (001 in binary). Since each
    value only contains unique bits, a bitwise OR operation achieves the same result
    as adding these numbers together does. These values can be added together to define
    permissions for user, group, and other using the `chmod` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The first command (`chmod 721`) gives read, write, and execute permissions to
    the user, since the first number is 7 (4 + 2 + 1), write and execute permissions
    to group, since the second number is 3 (2 + 1), and only execute permission to
    other, since the third number is 1\. Permissions can also be added or subtracted
    using `chmod`. In the next `chmod` command, the argument `ugo-wx` means *Subtract
    write and execute permissions from user, group, and other*. The final `chmod u+w`
    command gives write permission to user.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplenote program, the `open()` function uses `S_IRUSR|S_IWUSR` for
    its additional permission argument, which means the /tmp/notes file should only
    have user read and write permission when it is created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: User IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every user on a Unix system has a unique user ID number. This user ID can be
    displayed using the `id` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The root user with user ID 0 is like the administrator account, which has full
    access to the system. The `su` command can be used to switch to a different user,
    and if this command is run as root, it can be done without a password. The `sudo`
    command allows a single command to be run as the root user. On the LiveCD, `sudo`
    has been configured so it can be executed without a password, for simplicity's
    sake. These commands provide a simple method to quickly switch between users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: As the user jose, the simplenote program will run as jose if it is executed,
    but it won't have access to the /tmp/notes file. This file is owned by the user
    reader, and it only allows read and write permission to its owner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This is fine if reader is the only user of the simplenote program; however,
    there are many times when multiple users need to be able to access certain portions
    of the same file. For example, the /etc/passwd file contains account information
    for every user on the system, including each user's default login shell. The command
    `chsh` allows any user to change his or her own login shell. This program needs
    to be able to make changes to the /etc/passwd file, but only on the line that
    pertains to the current user's account. The solution to this problem in Unix is
    the `set user ID (setuid)` permission. This is an additional file permission bit
    that can be set using `chmod`. When a program with this flag is executed, it runs
    as the user ID of the file's owner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The `chsh` program has the `setuid` flag set, which is indicated by an `s` in
    the `ls` output above. Since this file is owned by root and has the `setuid` permission
    set, the program will run as the root user when *any* user runs this program.
    The /etc/passwd file that `chsh` writes to is also owned by root and only allows
    the owner to write to it. The program logic in `chsh` is designed to only allow
    writing to the line in /etc/passwd that corresponds to the user running the program,
    even though the program is effectively running as root. This means that a running
    program has both a real user ID and an effective user ID. These IDs can be retrieved
    using the functions `getuid()` and `geteuid()`, respectively, as shown in uid_demo.c.
  prefs: []
  type: TYPE_NORMAL
- en: uid_demo.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing uid_demo.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: In the output for uid_demo.c, both user IDs are shown to be 999 when `uid_demo`
    is executed, since 999 is the user ID for reader. Next, the `sudo` command is
    used with the `chown` command to change the owner and group of `uid_demo` to root.
    The program can still be executed, since it has execute permission for other,
    and it shows that both user IDs remain 999, since that's still the ID of the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Since the program is owned by root now, `sudo` must be used to change file permissions
    on it. The `chmod u+s` command turns on the `setuid` permission, which can be
    seen in the following `ls -l` output. Now when the user reader executes `uid_demo`,
    the effective user ID is 0 for root, which means the program can access files
    as root. This is how the `chsh` program is able to allow any user to change his
    or her login shell stored in /etc/passwd.
  prefs: []
  type: TYPE_NORMAL
- en: This same technique can be used in a multiuser note-taking program. The next
    program will be a modification of the simplenote program; it will also record
    the user ID of each note's original author. In addition, a new syntax for `#include`
    will be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: The `ec_malloc()` and `fatal()` functions have been useful in many of our programs.
    Rather than copy and paste these functions into each program, they can be put
    in a separate include file.
  prefs: []
  type: TYPE_NORMAL
- en: hacking.h
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: In this new program, hacking.h, the functions can just be included. In C, when
    the filename for a `#include` is surrounded by `<` and `>`, the compiler looks
    for this file in standard include paths, such as /usr/include/. If the filename
    is surrounded by quotes, the compiler looks in the current directory. Therefore,
    if hacking.h is in the same directory as a program, it can be included with that
    program by typing `#include "hacking.h"`.
  prefs: []
  type: TYPE_NORMAL
- en: The changed lines for the new notetaker program (notetaker.c) are displayed
    in bold.
  prefs: []
  type: TYPE_NORMAL
- en: notetaker.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The output file has been changed from /tmp/notes to /var/notes, so the data
    is now stored in a more permanent place. The `getuid()` function is used to get
    the real user ID, which is written to the datafile on the line before the note's
    line is written. Since the `write()` function is expecting a pointer for its source,
    the `&` operator is used on the integer value `userid` to provide its address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, the notetaker program is compiled and changed to be
    owned by root, and the `setuid` permission is set. Now when the program is executed,
    the program runs as the root user, so the file /var/notes is also owned by root
    when it is created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The /var/notes file contains the user ID of reader (999) and the note. Because
    of little-endian architecture, the 4 bytes of the integer 999 appear reversed
    in hexadecimal (shown in bold above).
  prefs: []
  type: TYPE_NORMAL
- en: In order for a normal user to be able to read the note data, a corresponding
    `setuid` root program is needed. The notesearch.c program will read the note data
    and only display the notes written by that user ID. Additionally, an optional
    command-line argument can be supplied for a search string. When this is used,
    only notes matching the search string will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: notesearch.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code should make sense, but there are some new concepts. The filename
    is defined at the top instead of using heap memory. Also, the function `lseek()`
    is used to rewind the read position in the file. The function call of `lseek(fd,
    length * -1, SEEK_CUR);` tells the program to move the read position forward from
    the current position in the file by `length * -1` bytes. Since this turns out
    to be a negative number, the position is moved backward by `length` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: When compiled and `setuid` root, the notesearch program works as expected. But
    this is just a single user; what happens if a different user uses the notetaker
    and notesearch programs?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: When the user jose uses these programs, the real user ID is 501\. This means
    that value is added to all notes written with notetaker, and only notes with a
    matching user ID will be displayed by the notesearch program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, all notes for the user reader have the user ID 999 attached to them.
    Even though both the notetaker and notesearch programs are `suid`root and have
    full read and write access to the /var/notes datafile, the program logic in the
    notesearch program prevents the current user from viewing other users' notes.
    This is very similar to how the /etc/passwd file stores user information for all
    users, yet programs like `chsh` and `passwd` allow any user to change his own
    shell or password.
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes there are multiple variables that should be grouped together and treated
    like one. In C, *structs* are variables that can contain many other variables.
    Structs are often used by various system functions and libraries, so understanding
    how to use structs is a prerequisite to using these functions.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example will suffice for now. When dealing with many time functions,
    these functions use a time struct called `tm`, which is defined in /usr/include/time.h.
    The struct's definition is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: After this struct is defined, `struct tm` becomes a usable variable type, which
    can be used to declare variables and pointers with the data type of the `tm` struct.
    The time_example.c program demonstrates this. When `time.h` is included, the `tm`
    struct is defined, which is later used to declare the `current_time` and `time_ptr`
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: time_example.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The `time()` function will return the number of seconds since January 1, 1970\.
    Time on Unix systems is kept relative to this rather arbitrary point in time,
    which is also known as the *epoch*. The `localtime_r()` function expects two pointers
    as arguments: one to the number of seconds since epoch and the other to a `tm`
    struct. The pointer `time_ptr` has already been set to the address of `current_time`,
    an empty `tm` struct. The address-of operator is used to provide a pointer to
    `seconds_since_epoch` for the other argument to `localtime_r()`, which fills the
    elements of the `tm` struct. The elements of structs can be accessed in three
    different ways; the first two are the proper ways to access struct elements, and
    the third is a hacked solution. If a struct variable is used, its elements can
    be accessed by adding the elements'' names to the end of the variable name with
    a period. Therefore, `current_time.tm_hour` will access just the `tm_hour` element
    of the `tm` struct called `current_time`. Pointers to structs are often used,
    since it is much more efficient to pass a four-byte pointer than an entire data
    structure. Struct pointers are so common that C has a built-in method to access
    struct elements from a struct pointer without needing to dereference the pointer.
    When using a struct pointer like `time_ptr`, struct elements can be similarly
    accessed by the struct element''s name, but using a series of characters that
    looks like an arrow pointing right. Therefore, `time_ptr->tm_min` will access
    the `tm_min` element of the `tm` struct that is pointed to by `time_ptr`. The
    seconds could be accessed via either of these proper methods, using the `tm_sec`
    element or the `tm` struct, but a third method is used. Can you figure out how
    this third method works?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The program works as expected, but how are the seconds being accessed in the
    `tm` struct? Remember that in the end, it's all just memory. Since `tm_sec` is
    defined at the beginning of the `tm` struct, that integer value is also found
    at the beginning. In the line `second = *((int *) time_ptr)`, the variable `time_ptr`
    is typecast from a `tm` struct pointer to an integer pointer. Then this typecast
    pointer is dereferenced, returning the data at the pointer's address. Since the
    address to the `tm` struct also points to the first element of this struct, this
    will retrieve the integer value for `tm_sec` in the struct. The following addition
    to the time_example.c code (time_example2.c) also dumps the bytes of the `current_time`.
    This shows that the elements of `tm` struct are right next to each other in memory.
    The elements further down in the struct can also be directly accessed with pointers
    by simply adding to the address of the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: time_example2.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The results of compiling and executing time_example2.c are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: While struct memory can be accessed this way, assumptions are made about the
    type of variables in the struct and the lack of any padding between variables.
    Since the data types of a struct's elements are also stored in the struct, using
    proper methods to access struct elements is much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Function Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *pointer* simply contains a memory address and is given a data type that describes
    where it points. Usually, pointers are used for variables; however, they can also
    be used for functions. The funcptr_example.c program demonstrates the use of function
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: funcptr_example.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: In this program, a function pointer aptly named `function_ptr` is declared in
    `main()`. This pointer is then set to point at the function `func_one()` and is
    called; then it is set again and used to call `func_two()`. The output below shows
    the compilation and execution of this source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Pseudo-random Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since computers are deterministic machines, it is impossible for them to produce
    truly random numbers. But many applications require some form of randomness. The
    pseudo-random number generator functions fill this need by generating a stream
    of numbers that is *pseudo-random*. These functions can produce a seemingly random
    sequence of numbers started from a seed number; however, the same exact sequence
    can be generated again with the same seed. Deterministic machines cannot produce
    true randomness, but if the seed value of the pseudo-random generation function
    isn't known, the sequence will seem random. The generator must be seeded with
    a value using the function `srand()`, and from that point on, the function `rand()`
    will return a pseudo-random number from 0 to `RAND_MAX`. These functions and `RAND_MAX`
    are defined in stdlib.h. While the numbers `rand()` returns will appear to be
    random, they are dependent on the seed value provided to `srand()`. To maintain
    pseudo-randomness between subsequent program executions, the randomizer must be
    seeded with a different value each time. One common practice is to use the number
    of seconds since epoch (returned from the `time()` function) as the seed. The
    rand_example.c program demonstrates this technique.
  prefs: []
  type: TYPE_NORMAL
- en: rand_example.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the modulus operator is used to obtain random values from 1 to 20.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: The program's output just displays random numbers. Pseudo-randomness can also
    be used for more complex programs, as you will see in this section's final script.
  prefs: []
  type: TYPE_NORMAL
- en: A Game of Chance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final program in this section is a set of games of chance that use many
    of the concepts we've discussed. The program uses pseudo-random number generator
    functions to provide the element of chance. It has three different game functions,
    which are called using a single global function pointer, and it uses structs to
    hold data for the player, which is saved in a file. Multi-user file permissions
    and user IDs allow multiple users to play and maintain their own account data.
    The game_of_chance.c program code is heavily documented, and you should be able
    to understand it at this point.
  prefs: []
  type: TYPE_NORMAL
- en: game_of_chance.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a multi-user program that writes to a file in the /var directory,
    it must be suid root.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Play around with this program a little bit. The Find the Ace game is a demonstration
    of a principle of conditional probability; although it is counterintuitive, changing
    your pick will increase your chances of finding the ace from 33 percent to 50
    percent. Many people have difficulty understanding this truth—that's why it's
    counterintuitive. The secret of hacking is understanding little-known truths like
    this and using them to produce seemingly magical results.
  prefs: []
  type: TYPE_NORMAL
