- en: Part III. Advanced IDA Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 11. Customizing IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After spending some time with IDA, you may have developed some preferred settings
    that you wish to use as defaults every time you open a new database. Some of the
    options you have changed may already carry over from session to session, while
    other options seem to need resetting every time you load a new database. In this
    chapter we examine the various ways in which you can modify IDA’s behavior through
    configuration files and menu-accessible options. We also examine where IDA stores
    various configuration settings and discuss the difference between database-specific
    settings and global settings.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of IDA’s default behavior is governed by settings contained in various
    configuration files. For the most part, configuration files are stored in the
    *<IDADIR>/cfg* directory, with one notable exception being the plug-ins configuration
    file, which resides at *<IDADIR>/plugins/plugins.cfg* (*plugins.cfg* will be covered
    in [Chapter 17](ch17.html "Chapter 17. The IDA Plug-in Architecture")). While
    you may notice quite a few files in the main configuration directory, the majority
    of the files are used by processor modules and are applicable only when certain
    CPU types are being analyzed. The three principal configuration files are *ida.cfg*,
    *idagui.cfg*, and *idatui.cfg*. Options that apply to all versions of IDA are
    generally found in *ida.cfg*, while *idagui.cfg* and *idatui.cfg* contain options
    specific to the GUI versions and the text-mode versions of IDA, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Main Configuration File: ida.cfg'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA’s principal configuration file is *ida.cfg*. Early in the startup process,
    this file is read to assign default processor types for various file extensions
    and to tune IDA’s memory usage parameters. Once a processor type has been specified,
    the file is then read a second time to process additional configuration options.
    The options contained in *ida.cfg* apply to all versions of IDA regardless of
    the user interface that is being used.
  prefs: []
  type: TYPE_NORMAL
- en: General options of interest in *ida.cfg* include memory-tuning parameters (`VPAGESIZE`),
    whether backup files are created (`CREATE_BACKUPS`), and the name of the external
    graph viewer (`GRAPH_VISUALIZER`).
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally when working with very large input fields, IDA may report that
    not enough memory is available to create a new database. In such cases, increasing
    the `VPAGESIZE` and then reopening the input file is usually sufficient to solve
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: A large number of options that control the format of disassembly lines are also
    contained in *ida.cfg*, including the default values for many of the options accessible
    via Options ▸ General. These include default values for the number of opcode bytes
    to display (`OPCODE_BYTES`), how far instructions should be indented (`INDENTATION`),
    whether the stack pointer offset should be displayed with each instruction (`SHOW_SP`),
    and the maximum number of cross-references to be displayed with a disassembly
    line (`SHOW_XREFS`). Additional options control the format of disassembly lines
    while in graph mode.
  prefs: []
  type: TYPE_NORMAL
- en: The global option specifying the maximum name length for named program locations
    (as opposed to stack variables) is contained in *ida.cfg* and is called `MAX_NAMES_LENGTH`.
    This option defaults to 15 characters and causes IDA to generate a warning message
    any time you enter a name longer than the current limit. The default length is
    kept small because some assemblers cannot handle names longer than 15 characters.
    If you do not plan to run an IDA-generated disassembly back through an assembler,
    then you may safely increase the limit.
  prefs: []
  type: TYPE_NORMAL
- en: The list of characters allowed in user-assigned names is governed by the `NameChars`
    options. By default this list allows alphanumeric characters and the four special
    characters `_$?@`. If IDA complains about the characters that you wish to use
    when you assign new names to locations or stack variables, then you may want to
    add additional characters to the `NameChars` set. For example, `NameChars` is
    the option to modify if you want to make the dot (`.`) character legal for use
    in IDA names. You should avoid the use of the semicolon, colon, comma, and space
    characters within names because they may lead to confusion, as these characters
    are typically considered delimiters for various disassembly line parts.
  prefs: []
  type: TYPE_NORMAL
- en: The last two options worth mentioning influence IDA’s behavior when parsing
    C header files (see [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures")).
    The `C_HEADER_PATH` option specifies a list of directories that IDA will search
    to resolve `#include` dependencies. By default, a common directory used by Microsoft’s
    Visual Studio is listed. If you use a different compiler or if your C header files
    are in a nonstandard location, you should consider editing this option. The `C_PREDEFINED_MACROS`
    option can be used to specify a default list of preprocessor macros that IDA will
    incorporate regardless of whether IDA has encountered them while parsing a C header
    file. This option offers a limited workaround facility for dealing with macros
    that may be defined in header files to which you do not have access.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of *ida.cfg* contains options specific to various processor
    modules. The only documentation available for options in this section of the file
    comes in the form of the comments (if any) associated with each option. The processor-specific
    options specified in *ida.cfg* generally dictate the default settings in the `Processor
    options` section of IDA’s initial file-loading dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The last step in processing *ida.cfg* is to search for a file named *<IDADIR>/cfg/idauser.cfg*.
    If present,^([[72](#ftn.CHP-11-FN-1)]) this file is treated as an extension of
    *ida.cfg*, and any options in the file will override corresponding options in
    *ida.cfg*. If you do not feel comfortable editing *ida.cfg*, then you should create
    *idauser.cfg* and add to it all of the options that you wish to override. In addition,
    *idauser.cfg* offers the easiest means for transferring your customized options
    from one version of IDA to another. For example, with *idauser.cfg* you do not
    need to re-edit *ida.cfg* each time you upgrade your copy of IDA. Instead, simply
    copy your existing *idauser.cfg* to your new IDA installation any time you upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI Configuration File: idagui.cfg'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuration items specific to the GUI version of IDA are located in their
    own file: *<IDADIR>/cfg/idagui.cfg*. This file is organized into roughly three
    sections: default GUI behaviors, keyboard hotkey mappings, and file extension
    configuration for the File ▸ Open dialog. In this section we discuss a few of
    the more interesting options. Consult *idagui.cfg* for the complete list of available
    options, which in most cases are accompanied by comments describing their purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: The Windows GUI version of IDA allows a secondary help file to be specified
    using the `HELPFILE` option. Any file specified here does not replace IDA’s primary
    help file. The intended purpose of this option is to provide access to supplemental
    information that may apply in specific reverse engineering situations. When a
    supplemental help file is specified, ctrl-F1 causes IDA to open the named file
    and search for a topic that matches the word under the cursor. If no match is
    found, then you are taken to the help file’s index. As an example, unless you
    count auto comments, IDA does not offer any help information regarding the instruction
    mnemonics in a disassembly. If you are analyzing an x86 binary, you might like
    to have an x86 instruction reference available on command. If you can locate a
    help file that happens to contain topics for each x86 instruction,^([[73](#ftn.CHP-11-FN-2)])
    then help for any instruction is only a hotkey away. The only word of caution
    concerning supplemental help files is that IDA supports only the older WinHelp-style
    help files (*.hlp*). IDA does not support the use of compiled HTML help files
    (*.chm*) as secondary help files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft Windows Vista and later do not provide native support for 32-bit WinHelp
    files because the *WinHlp32.exe* file does not ship with these operating systems.
    Please refer to Microsoft Knowledge Base article 917607^([[74](#ftn.CHP-11-FN-3)])
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: A common question asked about using IDA is “How can I patch binaries using IDA?”
    In a nutshell, the answer is “You can’t,” but we will put off discussing the details
    of this issue until [Chapter 14](ch14.html "Chapter 14. Patching Binaries and
    Other IDA Limitations"). What you can do with IDA is patch the database to modify
    instructions or data in almost any way you see fit. Once we discuss scripting
    ([Chapter 15](ch15.html "Chapter 15. IDA Scripting")), you will understand that
    modifying the database is not terribly difficult. But what if you are not interested
    in or not ready to learn IDA’s scripting language? IDA contains a database-patching
    menu that is not shown by default. The `DISPLAY_PATCH_SUBMENU` option is used
    to show or hide IDA’s patching menu, which shows up as Edit ▸ Patch Program. The
    options available on this menu are discussed in [Chapter 14](ch14.html "Chapter 14. Patching
    Binaries and Other IDA Limitations").
  prefs: []
  type: TYPE_NORMAL
- en: The single-line input box at the bottom of your IDA workspace is known as the
    IDA comand line. You can use the `DISPLAY_COMMAND_LINE` option to control whether
    this field is displayed or not. By default the command will be shown. If you are
    tight on screen space and you don’t anticipate the need to enter one-line scripts,
    then turning this feature off can help you regain a small amount of room in your
    IDA display. Note that this command line does not allow you to execute operating
    system commands as if you were entering them at a command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The hotkey configuration section of *idagui.cfg* is used to specify mappings
    between IDA actions and hotkey sequences. Hotkey reassignment is useful in many
    instances, including making additional commands available via hot-keys, changing
    default sequences to sequences that are easier to remember, or changing sequences
    that might conflict with other sequences in use by the operating system or your
    terminal application (useful primarily for the console version of IDA).
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtually every option that IDA makes available through menu items or toolbar
    buttons is listed in this section. Unfortunately, the names of the commands tend
    not to match the text used on IDA’s menus, so it may take some effort to determine
    exactly which configuration file option maps to a specific menu option. For example,
    the Jump ▸ Jump to Problem command equates to the `JumpQ` option (which *does*
    happen to match its hotkey: ctrl-Q) in *idagui.cfg*. In addition, while many commands
    have matching comments to describe their purpose, many commands have no description
    at all, so you are left to determine the behavior of a command based on its name
    within the configuration file. A trick that may help you figure out what menu
    item a configuration file action is associated with is to *search* for the action
    in IDA’s help system. The results of such searches usually lead to the description
    of the action’s corresponding menu item.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines represent example hotkey assignments in *idagui.cfg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line is the hotkey assignment for IDA’s `Abort` command, which in
    this case has no hotkey assignment. The unquoted value `0` indicates that no hotkey
    has been assigned to a command. The second line shows the hotkey assignment for
    IDA’s `Quit` action. Hotkey sequences are specified as a quoted string naming
    the key sequence. Numerous examples of hotkey assignments exist within *idagui.cfg*.
  prefs: []
  type: TYPE_NORMAL
- en: The final portion of *idagui.cfg* associates file type descriptions with their
    associated file extensions and specifies which file types will be listed in the
    Files of type drop-down list within the File ▸ Open dialog. A large number of
    file types are already described in the configuration file; however, if you find
    yourself frequently working with a file type that is not available, you may want
    to edit the file types list to add your file type to the list. The `FILE_EXTENSIONS`
    option describes all file associations known to IDA. The following line is an
    example of a typical file type association.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The line contains three comma-separated components: a name for the association
    (`CLASS_JAVA`), a description, and a filename pattern. Wildcards are allowed in
    the filename pattern, and multiple patterns can be specified by using a semicolon
    to separate them. A second type of file association allows several existing associations
    to be grouped into a single category. For example, the following line groups all
    associations whose names begin with `EXE_` into a single association named `EXE`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the pattern specifier in this case is not quoted. We might define
    our own file association as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can choose any name we like for the association as long as it is not already
    in use; however, simply adding a new association to the `FILE_EXTENSIONS` list
    is not sufficient to make that association appear in the File ▸ Open dialog. The
    `DEFAULT_FILE_FILTER` option lists the names of all associations that will appear
    in the File ▸ Open dialog. To complete the process and make our new association
    available, we would need to add `IDA_BOOK` to the `DEFAULT_FILE_FILTER` list.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the *idauser.cfg* file, the last line in *idagui.cfg* contains a
    directive to include a file named *<IDADIR>/cfg/idauserg.cfg*. If you do not feel
    comfortable editing *idagui.cfg*, then you should create *idauserg.cfg* and add
    to it all of the options that you wish to override.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Console Configuration File: idatui.cfg'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The analog to *idagui.cfg* for users of the console version of IDA is *<IDADIR>/cfg/idatui.cfg*.
    This file is very similar in layout and functionality to *idagui.cfg*. Among other
    things, hotkey specifications are made in the exact same manner as they are in
    *idagui.cfg*. Because the two files are so similar, we will detail only the differences
    here.
  prefs: []
  type: TYPE_NORMAL
- en: First, the options `DISPLAY_PATCH_SUBMENU` and `DISPLAY_COMMAND_LINE` are not
    available in the console version and are not included in *idatui.cfg*. The File
    ▸ Open dialog used in the console version is far simpler than the dialog used
    in the GUI version, so all of the file association commands available in *idagui.cfg*
    are missing in *idatui.cfg*.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a few options are available *only* for console versions of
    IDA. For example, you can use the `NOVICE` option to have IDA start in a beginner
    mode, in which it disables some of its more complex functionality in an attempt
    to be easier to learn. A notable difference in novice mode is the almost complete
    lack of subviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'Console users are far more likely to rely on the use of hotkey sequences. To
    facilitate the automation of common hotkey sequences, console mode IDA provides
    a keyboard macro definition syntax. Several example macros can be found in *idatui.cfg*;
    however, the ideal location to place any macros that you develop is *<IDADIR>/cfg/idausert.cfg*
    (the console equivalent of *idauserg.cfg*). A sample macro contained in the default
    *idatui.cfg* might look like the following (in the actual *idatui.cfg*, this macro
    is commented out):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Macro` definitions are introduced with the `MACRO` keyword ![](httpatomoreillycomsourcenostarchimages854061.png)
    followed by the hotkey ![](httpatomoreillycomsourcenostarchimages854063.png) to
    be associated with the macro. The macro sequence itself is specified between braces
    as a sequence of key name strings or characters, which may in turn represent hotkey
    sequences themselves. The preceding example macro, activated using alt-H, opens
    the Jump to Address dialog using the G hotkey, enters the label *start* into the
    dialog one character at a time, and then closes the dialog using the enter key.
    Note that we could not use the syntax “start” to enter the name of the symbol,
    as this would be taken as the name of a hotkey and result in an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Macros and novice mode are not available in the GUI version of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note about configuration file options, it is important to know that
    if IDA encounters any errors while parsing its configuration files, it immediately
    terminates with an error message that attempts to describe the nature of the problem.
    It is not possible to start IDA until the error condition has been corrected.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[72](#CHP-11-FN-1)]) This file does not ship with IDA. Users must generate
    this file on their own if they wish IDA to find it.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[73](#CHP-11-FN-2)]) Pedram Amini swears by this WinHelp32 file: [http://pedram.redhive.com/openrce/opcodes.hlp](http://pedram.redhive.com/openrce/opcodes.hlp).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[74](#CHP-11-FN-3)]) See [http://support.microsoft.com/kb/917607](http://support.microsoft.com/kb/917607).
  prefs: []
  type: TYPE_NORMAL
- en: Additional IDA Configuration Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA has a tremendous number of additional options that must be configured through
    the IDA user interface. Options for formatting individual disassembly lines were
    discussed in [Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation"). Additional
    IDA options are accessed via the Options menu, and in most cases, any options
    that you modify apply only to the currently opened database. Values for those
    options are stored in the associated database file when the database is closed.
    IDA’s Color (Options ▸ Colors) and Font (Options ▸ Font) options are two of the
    exceptions to this rule in that they are global options that, once set, remain
    in effect in all future IDA sessions. For Windows versions of IDA, option values
    are stored in the Windows registry under the `HKEY_CURRENT_USER\Software\Hex-Rays\IDA`
    registry key. For non-Windows versions of IDA, these values are stored in your
    home directory in a proprietary format file named `$HOME/.idapro/ida.reg`.
  prefs: []
  type: TYPE_NORMAL
- en: Another piece of information that is saved in the registry concerns dialogs
    for which you may choose the Do not display this dialog box again option. This
    message occasionally appears in the form of a checkbox in the lower-right portion
    of some informational message dialogs that you may not wish to see in the future.
    Should you select this option, a registry value is created under the `HKEY_CURRENT_USER\Software\Hex-Rays\IDA\Hidden
    Messages` registry key. If, at a later time, you wish to have a hidden dialog
    displayed once again, you will need to delete the appropriate value under this
    registry key.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The color of virtually every item in an IDA display can be customized via the
    Options ▸ Colors dialog shown in [Figure 11-1](ch11s02.html#the_color_selection_dialog
    "Figure 11-1. The color selection dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The color selection dialog](httpatomoreillycomsourcenostarchimages854231.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1. The color selection dialog
  prefs: []
  type: TYPE_NORMAL
- en: The Disassembly tab controls the colors used for various parts of each line
    in the disassembly window. Examples of each type of text that can appear in a
    disassembly are given in the example window ![](httpatomoreillycomsourcenostarchimages854061.png).
    When you select an item in the example window, the item’s type is listed at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Using the Change Color button, you may assign any color you wish to any item you
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: The color selection dialog contains tabs for assigning colors used in the navigation
    band, the debugger, the jump arrows in the left margin of the text disassembly
    view, and various components in the graph view. Specifically, the Graph tab controls
    the coloring of graph nodes, their title bars, and the edges that connect each
    node, while the Disassembly tab controls the coloring of disassembled text in
    the graph view. The Misc tab allows for customizing the colors used in IDA’s message
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing IDA Toolbars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to menus and hotkeys, the GUI version of IDA offers a large number
    of toolbar buttons spread across more than two dozen toolbars. Toolbars are typically
    docked in the main toolbar area beneath IDA’s menu bar. Two predefined toolbar
    arrangements accessible using the View ▸ Toolbars menu are Basic mode, which enables
    seven of IDA’s toolbars, and Advanced mode, which enables every IDA toolbar. Individual
    toolbars can be detached, dragged, and relocated to any location on the screen
    to suit your personal taste. If you find that you have no need for a particular
    toolbar, you can remove it from the display entirely via the View ▸ Toolbars menu,
    which is shown in [Figure 11-2](ch11s02.html#the_toolbar_configuration_menu "Figure 11-2. The
    toolbar configuration menu").
  prefs: []
  type: TYPE_NORMAL
- en: This menu also appears if you right-click anywhere within the docking area of
    the IDA display. Turning off the Main toolbar removes all toolbars from the docking
    area and is useful if you need to maximize the amount of screen space dedicated
    to the disassembly window. Any changes that you make to your toolbar arrangement
    are stored with the current database. Opening a second database will restore the
    toolbars to the arrangement that was in effect when the second database was last
    saved. Opening a new binary to create a new database restores the toolbar arrangement
    based on IDA’s current default toolbar settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![The toolbar configuration menu](httpatomoreillycomsourcenostarchimages854233.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2. The toolbar configuration menu
  prefs: []
  type: TYPE_NORMAL
- en: If you settle on a toolbar arrangement that you happen to like and wish to make
    it the default, then you should save the current desktop arrangement as your default
    desktop using Windows ▸ Save Desktop, which opens the dialog shown in [Figure 11-3](ch11s02.html#the_save_disassembly_desk-top_dialog
    "Figure 11-3. The Save Disassembly Desktop dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Save Disassembly Desktop dialog](httpatomoreillycomsourcenostarchimages854235.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3. The Save Disassembly Desktop dialog
  prefs: []
  type: TYPE_NORMAL
- en: Each time you save a desktop configuration, you are asked to supply a name for
    the configuration. When the Default checkbox is selected, the current desktop
    layout becomes the default for all new databases and the desktop to which you
    will revert if you choose Windows ▸ Reset desktop. To restore the display to one
    of your custom desktops, select **Windows** ▸ **Load Desktop** and choose the
    named layout that you wish to load. Saving and restoring desktops is particularly
    useful in situations that involve using multiple monitors with different sizes
    and/or resolutions (which may be common with laptops using different docking stations
    or when connecting to projectors for presentations).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When starting out with IDA, you may be perfectly satisfied with both its default
    behaviors and its default GUI layout. As you become more comfortable with IDA’s
    basic features, you are certain to find ways to customize IDA to your particular
    tastes. While there is no way to provide complete coverage of every possible option
    IDA offers in a single chapter, we have attempted to provide pointers to the principal
    locations in which those options may be found. We have also attempted to highlight
    those options that you are most likely to want to manipulate at some point in
    your IDA experience. Discovering additional useful options is left as a matter
    of exploration for inquisitive readers.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12. Library Recognition Using FLIRT Signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point it is time to start moving beyond IDA’s more obvious capabilities
    and begin our exploration of what to do after “The initial autoanalysis has been
    finished.”^([[75](#ftn.CHP-12-FN-1)]) In this chapter we discuss techniques for
    recognizing standard code sequences such as the library code contained in statically
    linked binaries or standard initialization and helper functions inserted by compilers.
  prefs: []
  type: TYPE_NORMAL
- en: When you set out to reverse engineer any binary, the last thing that you want
    to do is waste time reverse engineering library functions whose behavior you could
    learn much more easily simply by reading a man page, reading some source code,
    or doing a little Internet research. The challenge presented by statically linked
    binaries is that they blur the distinction between application code and library
    code. In a statically linked binary, entire libraries are combined with application
    code to form a single monolithic executable file. Fortunately for us, tools are
    available that enable IDA to recognize and mark library code, allowing us to focus
    our attention on the unique code within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Fast Library Identification and Recognition Technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fast Library Identification and Recognition Technology, better known as FLIRT,^([[76](#ftn.CHP-12-FN-2)])
    encompasses the set of techniques employed by IDA to identify sequences of code
    as library code. At the heart of FLIRT are pattern-matching algorithms that enable
    IDA to quickly determine whether a disassembled function matches one of the many
    signatures known to IDA. The *<IDADIR>/sig* directory contains the signature files
    that ship with IDA. For the most part, these are libraries that ship with common
    Windows compilers, though a few non-Windows signatures are also included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signature files utilize a custom format in which the bulk of the signature
    data is compressed and wrapped in an IDA-specific header. In most cases, signature
    filenames do not clearly indicate which library the associated signatures were
    generated from. Depending on how they were created, signature files may contain
    a library name comment that describes their contents. If we view the first few
    lines of extracted ASCII content from a signature file, this comment is often
    revealed. The following Unix-style command^([[77](#ftn.CHP-12-FN-3)]) generally
    reveals the comment in the second or third line of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Within IDA, there are two ways to view comments associated with signature files.
    First, you can access the list of signatures that have been applied to a binary
    via View ▸ Open Subviews ▸ Signatures. Second, the list of all signature files
    is displayed as part of the manual signature application process, which is initiated
    via File ▸ Load File ▸ FLIRT Signature File.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[75](#CHP-12-FN-1)]) IDA generates this message in the Output window when
    it has finished its automated processing of a newly loaded binary.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[76](#CHP-12-FN-2)]) See [http://www.hex-rays.com/idapro/flirt.htm](http://www.hex-rays.com/idapro/flirt.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[77](#CHP-12-FN-3)]) The `strings` command was discussed in [Chapter 2](ch02.html
    "Chapter 2. Reversing and Disassembly Tools"), while the `head` command is used
    to view only the first few lines (three in the example) of its input source.
  prefs: []
  type: TYPE_NORMAL
- en: Applying FLIRT Signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a binary is first opened, IDA attempts to apply special signature files,
    designated as startup signatures, to the entry point of the binary. It turns out
    that the entry point code generated by various compilers is sufficiently unique
    that matching entry point signatures is a useful technique for identifying the
    compiler that may have been used to generate a given binary.
  prefs: []
  type: TYPE_NORMAL
- en: MAIN VS. _START
  prefs: []
  type: TYPE_NORMAL
- en: Recall that a program’s entry point is the address of the first instruction
    that will be executed. Many longtime C programmers incorrectly believe that this
    is the address of the function named `main`, when in fact it is not. The file
    type of the program, *not* the language used to create the program, dictates the
    manner in which command-line arguments are provided to a program. In order to
    reconcile any differences between the way the loader presents command-line arguments
    and the way the program expects to receive them (via parameters to `main`, for
    example), some initialization code must execute prior to transferring control
    to `main`. It is this initialization that IDA designates as the entry point of
    the program and labels `_start`.
  prefs: []
  type: TYPE_NORMAL
- en: This initialization code is also responsible for any initialization tasks that
    must take place before `main` is allowed to run. In a C++ program, this code is
    responsible for ensuring that constructors for globally declared objects are called
    prior to execution of `main`. Similarly, cleanup code is inserted that executes
    after `main` completes in order to invoke destructors for all global objects prior
    to the actual termination of the program.
  prefs: []
  type: TYPE_NORMAL
- en: If IDA identifies the compiler used to create a particular binary, then the
    signature file for the corresponding compiler libraries is loaded and applied
    to the remainder of the binary. The signatures that ship with IDA tend to be related
    to proprietary compilers such as Microsoft Visual C++ or Borland Delphi. The reason
    behind this is that a finite number of binary libraries ship with these compilers.
    For open source compilers, such as GNU gcc, the binary variations of the associated
    libraries are as numerous as the operating systems the compilers ship with. For
    example, each version of FreeBSD ships with a unique version of the C standard
    library. For optimal pattern matching, signature files would need to be generated
    for each version of the library. Consider the difficulty in collecting every variation
    of *libc.a*^([[78](#ftn.CHP-12-FN-4)]) that has shipped with every version of
    every Linux distribution. It simply is not practical. In part, these differences
    are due to changes in the library source code that result in different compiled
    code, but huge differences also result from the use of different compilation options,
    such as optimization settings and the use of different compiler versions to build
    the library. The net result is that IDA ships with very few signature files for
    open source compiler libraries. The good news, as you shall soon see, is that
    Hex-Rays makes tools available that allow you to generate your own signature files
    from static libraries.
  prefs: []
  type: TYPE_NORMAL
- en: So, under what circumstances might you be required to manually apply signatures
    to one of your databases? Occasionally IDA properly identifies the compiler used
    to build the binary but has no signatures for the related compiler libraries.
    In such cases, either you will need to live without signatures, or you will need
    to obtain copies of the static libraries used in the binary and generate your
    own signatures. Other times, IDA may simply fail to identify a compiler, making
    it impossible to determine which signatures should be applied to a database. This
    is common when analyzing obfuscated code in which the startup routines have been
    sufficiently mangled to preclude compiler identification. The first thing to do,
    then, would be to de-obfuscate the binary sufficiently before you could have any
    hope of matching library signatures. We will discuss techniques for dealing with
    obfuscated code in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis").
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the reason, if you wish to manually apply signatures to a database,
    you do so via File ▸ Load File ▸ FLIRT Signature File, which opens the signature
    selection dialog shown in [Figure 12-1](ch12s02.html#flirt_signature_selection
    "Figure 12-1. FLIRT signature selection").
  prefs: []
  type: TYPE_NORMAL
- en: '![FLIRT signature selection](httpatomoreillycomsourcenostarchimages854237.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1. FLIRT signature selection
  prefs: []
  type: TYPE_NORMAL
- en: The File column reflects the name of each *.sig* file in IDA’s *<IDADIR>/sig*
    directory. Note that there is no means to specify an alternate location for *.sig*
    files. If you ever generate your own signatures, they need to be placed into *<IDADIR>/sig*
    along with every other *.sig* file. The Library name column displays the library
    name comment that is embedded within each file. Keep in mind that these comments
    are only as descriptive as the creator of the signatures (which could be you!)
    chooses to make them.
  prefs: []
  type: TYPE_NORMAL
- en: When a library module is selected, the signatures contained in the corresponding
    *.sig* file are loaded and compared against every function within the database.
    Only one set of signatures may be applied at a time, so you will need to repeat
    the process if you wish to apply several different signature files to a database.
    When a function is found to match a signature, the function is marked as a library
    function, and the function is automatically renamed according to the signature
    that has been matched.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only functions named with an IDA dummy name can be automatically renamed. In
    other words, if you have renamed a function, and that function is later matched
    by a signature, then the function will not be renamed as a result of the match.
    Therefore, it is to your benefit to apply signatures as early in your analysis
    process as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that statically linked binaries blur the distinction between application
    code and library code. If you are fortunate enough to have a statically linked
    binary that has not had its symbols stripped, you will at least have useful function
    names (as useful as the trustworthy programmer has chosen to create) to help you
    sort your way through the code. However, if the binary has been stripped, you
    will have perhaps hundreds of functions, all with IDA-generated names that fail
    to indicate what the function does. In both cases, IDA will be able to identify
    library functions only if signatures are available (function names in an unstripped
    binary do not provide IDA with enough information to definitively identify a function
    as a library function). [Figure 12-2](ch12s02.html#statically_linked_with_no_signatures
    "Figure 12-2. Statically linked with no signatures") shows the Overview Navigator
    for a statically linked binary.
  prefs: []
  type: TYPE_NORMAL
- en: '![Statically linked with no signatures](httpatomoreillycomsourcenostarchimages854239.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2. Statically linked with no signatures
  prefs: []
  type: TYPE_NORMAL
- en: In this display, no functions have been identified as library functions, so
    you may find yourself analyzing far more code than you really need to. After application
    of an appropriate set of signatures, the Overview Navigator is transformed as
    shown in [Figure 12-3](ch12s02.html#statically_linked_binary_with_signatures "Figure 12-3. Statically
    linked binary with signatures applied").
  prefs: []
  type: TYPE_NORMAL
- en: '![Statically linked binary with signatures applied](httpatomoreillycomsourcenostarchimages854241.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3. Statically linked binary with signatures applied
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Overview Navigator provides the best indication of the effectiveness
    of a particular set of signatures. With a large percentage of matched signatures,
    substantial portions of code will be marked as library code and renamed accordingly.
    In the example in [Figure 12-3](ch12s02.html#statically_linked_binary_with_signatures
    "Figure 12-3. Statically linked binary with signatures applied"), it is highly
    likely that the actual application-specific code is concentrated in the far left
    portion of the navigator display.
  prefs: []
  type: TYPE_NORMAL
- en: There are two points worth remembering when applying signatures. First, signatures
    are useful even when working with a binary that has not been stripped, in which
    case you are using signatures more to help IDA identify library functions than
    to rename those functions. Second, statically linked binaries may be composed
    of several separate libraries, requiring the application of several sets of signatures
    in order to completely identify all library functions. With each additional signature
    application, additional portions of the Overview Navigator will be transformed
    to reflect the discovery of library code. [Figure 12-4](ch12s02.html#static_binary_with_first_of_several_sign
    "Figure 12-4. Static binary with first of several signatures applied") shows one
    such example. In this figure, you see a binary that was statically linked with
    both the C standard library and the OpenSSL^([[79](#ftn.CHP-12-FN-5)]) cryptographic
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '![Static binary with first of several signatures applied](httpatomoreillycomsourcenostarchimages854243.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4. Static binary with first of several signatures applied
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you see that following application of the appropriate signatures
    for the version of OpenSSL in use in this application, IDA has marked a small
    band (the lighter band toward the left edge of the address range) as library code.
    Statically linked binaries are often created by taking the application code first
    and then appending required libraries to create the resulting executable. Given
    this picture, we can conclude that the memory space to the right of the OpenSSL
    library is likely occupied by additional library code, while the application code
    is most likely in the very narrow band to the left of the OpenSSL library. If
    we continue to apply signatures to the binary shown in [Figure 12-4](ch12s02.html#static_binary_with_first_of_several_sign
    "Figure 12-4. Static binary with first of several signatures applied"), we eventually
    arrive at the display of [Figure 12-5](ch12s02.html#static_binary_following_application_of_s
    "Figure 12-5. Static binary following application of several signatures").
  prefs: []
  type: TYPE_NORMAL
- en: '![Static binary following application of several signatures](httpatomoreillycomsourcenostarchimages854245.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5. Static binary following application of several signatures
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have applied signatures for *libc*, *libcrypto*, *libkrb5*,
    *libresolv*, and others. In some cases we selected signatures based on strings
    located within the binary; in other cases we chose signatures based on their close
    relationship to other libraries already located within the binary. The resulting
    display continues to show a dark band in the middle of the navigation band and
    a smaller dark band at the extreme left edge of the navigation band. Further analysis
    is required to determine the nature of these remaining nonlibrary portions of
    the binary. In this case we would learn that the wider dark band in the middle
    is part of an unidentified library, while the dark band on the left is the application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[78](#CHP-12-FN-4)]) *libc.a* is the version of the C standard library used
    in statically linked binaries on Unix-style systems.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[79](#CHP-12-FN-5)]) See [http://www.openssl.org/](http://www.openssl.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating FLIRT Signature Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed previously, it is simply impractical for IDA to ship with signature
    files for every static library in existence. In order to provide IDA users with
    the tools and information necessary to create their own signatures, Hex-Rays distributes
    the Fast Library Acquisition for Identification and Recognition (FLAIR) tool set.
    The FLAIR tools are made available on your IDA distribution CD or via download
    from the Hex-Rays website^([[80](#ftn.CHP-12-FN-6)]) for authorized customers.
    Like several other IDA add-ons, the FLAIR tools are distributed in a Zip file.
    Hex-Rays does not necessarily release a new version of the FLAIR tools with each
    version of IDA, so you should use the most recent version of FLAIR that does not
    exceed your version of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation of the FLAIR utilities is a simple matter of extracting the contents
    of the associated Zip file, though we highly recommend that you create a dedicated
    *flair* directory as the destination because the Zip file is not organized with
    a top-level directory. Inside the FLAIR distribution you will find several text
    files that constitute the documentation for the FLAIR tools. Files of particular
    interest include these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**readme.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a top-level overview of the signature-creation process.
  prefs: []
  type: TYPE_NORMAL
- en: '**plb.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: This file describes the use of the static library parser, *plb.exe*. Library
    parsers are discussed in more detail in [Creating Pattern Files](ch12s03.html#creating_pattern_files
    "Creating Pattern Files") in [Creating Pattern Files](ch12s03.html#creating_pattern_files
    "Creating Pattern Files").
  prefs: []
  type: TYPE_NORMAL
- en: '**pat.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: This file details the format of pattern files, which represent the first step
    in the signature-creation process. Pattern files are also described in [Creating
    Pattern Files](ch12s03.html#creating_pattern_files "Creating Pattern Files") in
    [Creating Pattern Files](ch12s03.html#creating_pattern_files "Creating Pattern
    Files").
  prefs: []
  type: TYPE_NORMAL
- en: '**sigmake.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: This file describes the use of *sigmake.exe* for generating *.sig* files from
    pattern files. Please refer to [Creating Signature Files](ch12s03.html#creating_signature_files
    "Creating Signature Files") in [Creating Signature Files](ch12s03.html#creating_signature_files
    "Creating Signature Files") for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Additional top-level content of interest includes the *bin* directory, which
    contains all of the FLAIR tools executable files, and the *startup* directory,
    which contains pattern files for common startup sequences associated with various
    compilers and their associated output file types (PE, ELF, and so on). Prior to
    version 6.1, the FLAIR tools area is available for Windows only; however, the
    resulting signature files may be used with all IDA variants (Windows, Linux, and
    OS X).
  prefs: []
  type: TYPE_NORMAL
- en: Signature-Creation Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic process for creating signatures files does not seem complicated, as
    it boils down to four simple-sounding steps.
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a copy of the static library for which you wish to create a signature
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Utilize one of the FLAIR parsers to create a pattern file for the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run *sigmake.exe* to process the resulting pattern file and generate a signature
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the new signature file in IDA by copying it to *<IDADIR>/sig*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, in practice, only the last step is as easy as it sounds. In the
    following sections, we discuss the first three steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and Acquiring Static Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in the signature-generation process is to locate a copy of the
    static library for which you wish to generate signatures. This can pose a bit
    of a challenge for a variety of reasons. The first obstacle is to determine which
    library you actually need. If the binary you are analyzing has not been stripped,
    you might be lucky enough to have actual function names available in your disassembly,
    in which case an Internet search will probably provide several pointers to likely
    candidates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stripped binaries are not quite as forthcoming regarding their origins. Lacking
    function names, you may find that a good `strings` search may yield sufficiently
    unique strings to allow for library identification, such as the following, which
    is a dead giveaway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Copyright notices and error strings are often sufficiently unique that once
    again you can use an Internet search to narrow your candidates. If you choose
    to run `strings` from the command line, remember to use the `-a` option to force
    `strings` to scan the entire binary; otherwise you may miss some potentially useful
    string data.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of open source libraries, you are likely to find source code readily
    available. Unfortunately, while the source code may be useful in helping you understand
    the behavior of the binary, you cannot use it to generate your signatures. It
    might be possible to use the source to build your own version of the static library
    and then use that version in the signature-generation process. However, in all
    likelihood, variations in the build process will result in enough differences
    between the resulting library and the library you are analyzing that any signatures
    you generate will not be terribly accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best option is to attempt to determine the exact origin of the binary in
    question. By this we mean the exact operating system, operating system version,
    and distribution (if applicable). Given this information, the best option for
    creating signatures is to copy the libraries in question from an identically configured
    system. Naturally, this leads to the next challenge: Given an arbitrary binary,
    on what system was it created? A good first step is to use the `file` utility
    to obtain some preliminary information about the binary in question. In [Chapter 2](ch02.html
    "Chapter 2. Reversing and Disassembly Tools") we saw some sample output from `file`.
    In several cases, this output was sufficient to provide likely candidate systems.
    The following is just one example of very specific output from `file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case we might head straight to a FreeBSD 8.0 system and track down
    *libc.a* for starters. The following example is somewhat more ambiguous, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We appear to have narrowed the source of the file to a Linux system, which,
    given the abundance of available Linux distributions, is not saying much. Turning
    to `strings` we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here the search has been narrowed to Red Hat distributions (or derivatives)
    that shipped with gcc version 4.5.1\. GCC tags such as this are not uncommon in
    binaries compiled using gcc, and fortunately for us, they survive the stripping
    process and remain visible to `strings`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the `file` utility is not the be all and end all in file identification.
    The following output demonstrates a simple case in which `file` seems to know
    the type of the file being examined but for which the output is rather nonspecific.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example was taken from a Solaris 10 x86 system. Here again, the `strings`
    utility might be useful in pinpointing this fact.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Pattern Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point you should have one or more libraries for which you wish to create
    signatures. The next step is to create a pattern file for each library. Pattern
    files are created using an appropriate FLAIR parser utility. Like executable files,
    library files are built to various file format specifications. FLAIR provides
    parsers for several popular library file formats. As detailed in FLAIR’s *readme.txt*
    file, the following parsers can be found in FLAIR’s *bin* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**plb.exe/plb**'
  prefs: []
  type: TYPE_NORMAL
- en: Parser for OMF libraries (commonly used by Borland compilers)
  prefs: []
  type: TYPE_NORMAL
- en: '**pcf.exe/pcf**'
  prefs: []
  type: TYPE_NORMAL
- en: Parser for COFF libraries (commonly used by Microsoft compilers)
  prefs: []
  type: TYPE_NORMAL
- en: '**pelf.exe/pelf**'
  prefs: []
  type: TYPE_NORMAL
- en: Parser for ELF libraries (found on many Unix systems)
  prefs: []
  type: TYPE_NORMAL
- en: '**ppsx.exe/ppsx**'
  prefs: []
  type: TYPE_NORMAL
- en: Parser for Sony PlayStation PSX libraries
  prefs: []
  type: TYPE_NORMAL
- en: '**ptmobj.exe/ptmobj**'
  prefs: []
  type: TYPE_NORMAL
- en: Parser for TriMedia libraries
  prefs: []
  type: TYPE_NORMAL
- en: '**pomf166.exe/pomf166**'
  prefs: []
  type: TYPE_NORMAL
- en: Parser for Kiel OMF 166 object files
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a pattern file for a given library, specify the parser that corresponds
    to the library’s format, the name of the library you wish to parse, and the name
    of the resulting pattern file that should be generated. For a copy of *libc.a*
    from a FreeBSD 8.0 system, you might use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the parser reports the file that was parsed (*libc.a*), the number of
    functions that were skipped (1),^([[81](#ftn.CHP-12-FN-7)]) and the number of
    signature patterns that were generated (1089). Each parser accepts a slightly
    different set of command-line options documented only through the parser’s usage
    statement. Executing a parser with no arguments displays the list of command-line
    options accepted by that parser. The *plb.txt* file contains more detailed information
    on the options accepted by the *plb* parser. This file is a good basic source
    of information, since other parsers accept many of the options it describes as
    well. In many cases, simply naming the library to be parsed and the pattern file
    to be generated is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pattern file is a text file that contains, one per line, the extracted patterns
    that represent functions within a parsed library. A few lines from the pattern
    file created previously are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The format of an individual pattern is described in FLAIR’s *pat.txt* file.
    In a nutshell, the first portion of a pattern lists the initial byte sequence
    of the function to a maximum of 32 bytes. Allowance is made for bytes that may
    vary as a result of relocation entries. Such bytes are displayed using two dots.
    Dots are also used to fill the pattern out to 64 characters^([[82](#ftn.CHP-12-FN-8)])
    when a function is shorter than 32 bytes (as `_ffs` is in the previous code).
    Beyond the initial 32 bytes, additional information is recorded to provide more
    precision in the signature-matching process. Additional information encoded into
    each pattern line includes a CRC16^([[83](#ftn.CHP-12-FN-9)]) value computed over
    a portion of the function, the length of the function in bytes, and a list of
    symbol names referenced by the function. In general, longer functions that reference
    many other symbols yield more complex pattern lines. In the file *libc_FreeBSD80.pat*
    generated previously, some pattern lines exceed 20,000 characters in length.
  prefs: []
  type: TYPE_NORMAL
- en: Several third-party programmers have created utilities designed to generate
    patterns from existing IDA databases. One such utility is IDB_2_PAT,^([[84](#ftn.CHP-12-FN-10)])
    an IDA plug-in written by J.C. Roberts that is capable of generating patterns
    for one or more functions in an existing database. Utilities such as these are
    useful if you expect to encounter similar code in additional databases and have
    no access to the original library files used to create the binary being analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Signature Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have created a pattern file for a given library, the next step in the
    signature-creation process is to generate a *.sig* file suitable for use with
    IDA. The format of an IDA signature file is substantially different from that
    of a pattern file. Signature files utilize a proprietary binary format designed
    both to minimize the amount of space required to represent all of the information
    present in a pattern file and to allow for efficient matching of signatures against
    actual database content. A high-level description of the structure of a signature
    file is available on the Hex-Rays website.^([[85](#ftn.CHP-12-FN-11)])
  prefs: []
  type: TYPE_NORMAL
- en: 'FLAIR’s *sigmake* utility is used to create signature files from pattern files.
    By splitting pattern generation and signature generation into two distinct phases,
    the signature-generation process is completely independent of the pattern-generation
    process, which allows for the use of third-party pattern generators. In its simplest
    form, signature generation takes place by using *sigmake* to parse a *.pat* file
    and create a *.sig* file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If all goes well, a *.sig* file is generated and ready to install into *<IDADIR>/sig*.
    However, the process seldom runs that smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sigmake` documentation file, *sigmake.txt*, recommends that signature filenames
    follow the MS-DOS 8.3 name-length convention. This is not a hard-and-fast requirement,
    however. When longer filenames are used, only the first eight characters of the
    base filename are displayed in the signature-selection dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Signature generation is often an iterative process, as it is during this phase
    when *collisions* must be handled. A collision occurs anytime two functions have
    identical patterns. If collisions are not resolved in some manner, it is not possible
    to determine which function is actually being matched during the signature-application
    process. Therefore, `sigmake` must be able to resolve each generated signature
    to exactly one function name. When this is not possible, based on the presence
    of identical patterns for one or more functions, `sigmake` refuses to generate
    a *.sig* file and instead generates an *exclusions file* (*.exc*). A more typical
    first pass using `sigmake` and a new *.pat* file (or set of *.pat* files) might
    yield the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The documentation being referred to is *sigmake.txt*, which describes the use
    of `sigmake` and the collision-resolution process. In reality, each time `sigmake`
    is executed, it searches for a corresponding exclusions file that might contain
    information on how to resolve any collisions that `sigmake` may encounter while
    processing the named pattern file. In the absence of such an exclusions file,
    and when collisions occur, `sigmake` generates such an exclusions file rather
    than a signature file. In the previous example, we would find a newly created
    file named *libc_FreeBSD80.exc*. When first created, exclusions files are text
    files that detail the conflicts that `sigmake` encountered while processing the
    pattern file. The exclusions file must be edited to provide `sigmake` with guidance
    as to how it should resolve the conflicting patterns. The general process for
    editing an exclusions file follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'When generated by `sigmake`, all exclusions files begin with the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent of these lines it to remind you what to do to resolve collisions
    before you can successfully generate signatures. The most important thing to do
    is delete the four lines that begin with semicolons, or `sigmake` will fail to
    parse the exclusions file during subsequent execution. The next step is to inform
    `sigmake` of your desire for collision resolution. A few lines extracted from
    *libc_FreeBSD80.exc* appear here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These lines detail three separate collisions. In this case, we are being told
    that the function `index` is indistinguishable from `strchr`, `rindex` has the
    same signature as `strrchr`, and `flsl` collides with `fls`. If you are familiar
    with any of these functions, this result may not surprise you, as the colliding
    functions are essentially identical (for example, `index` and `strchr` perform
    the same action).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to leave you in control of your own destiny, `sigmake` expects you
    to designate no more than one function in each group as the proper function for
    the associated signature. You select a function by prefixing the name with a plus
    character (`+`) if you want the name applied anytime the corresponding signature
    is matched in a database or a minus character (`-`) if you simply want a comment
    added to the database whenever the corresponding signature is matched. If you
    do not want any names applied when the corresponding signature is matched in a
    database, then you do not add any characters. The following listing represents
    one possible way to provide a valid resolution for the three collisions noted
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case we elect to use the name `index` whenever the first signature
    is matched, do nothing at all when the second signature is matched, and have a
    comment about `fls` added when the third signature is matched. The following points
    are useful when attempting to resolve collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: To perform minimal collision resolution, simply delete the four commented lines
    at the beginning of the exclusions file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Never add a `+/-` to more than one function in a collision group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a collision group contains only a single function, *do not* add a `+/-` in
    front of that function; simply leave it alone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subsequent failures of `sigmake` cause data, including comment lines, to be
    appended to any existing exclusions file. This extra data should be removed and
    the original data corrected (if the data was correct, `sigmake` would not have
    failed a second time) before rerunning `sigmake`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have made appropriate changes to your exclusions file, you must save
    the file and rerun `sigmake` using the same command-line arguments that you used
    initially. The second time through, `sigmake` should locate, and abide by, your
    exclusions file, resulting in the successful generation of a *.sig* file. Successful
    operation of `sigmake` is noted by the lack of error messages and the presence
    of a *.sig* file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After a signature file has been successfully generated, you make it available
    to IDA by copying it to your *<IDADIR>/sig* directory. Then your new signatures
    are available using File ▸ Load File ▸ FLIRT Signature File.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have purposefully glossed over all of the options that can be
    supplied to both the pattern generators and `sigmake`. A rundown of available
    options is provided in *plb.txt* and *sigmake.txt*. The only option we will make
    note of is the `-n` option used with `sigmake`. This option allows you to embed
    a descriptive name inside a generated signature file. This name is displayed during
    the signature-selection process (see [Figure 12-1](ch12s02.html#flirt_signature_selection
    "Figure 12-1. FLIRT signature selection")), and it can be very helpful when sorting
    through the list of available signatures. The following command line embeds the
    name string “FreeBSD 8.0 C standard library” within the generated signature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative, library names can be specified using directives within exclusion
    files. However, since exclusion files may not be required in all signature-generation
    cases, the command-line option is generally more useful. For further details,
    please refer to *sigmake.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: Startup Signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA also recognizes a specialized form of signatures called *startup signatures*.
    Startup signatures are applied when a binary is first loaded into a database in
    an attempt to identify the compiler that was used to create the binary. If IDA
    can identify the compiler used to build a binary, then additional signature files,
    associated with the identified compiler, are automatically loaded during the initial
    analysis of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the compiler type is initially unknown when a file is first loaded,
    startup signatures are grouped by and selected according to the file type of the
    binary being loaded. For example, if a Windows PE binary is being loaded, then
    startup signatures specific to PE binaries are loaded in an effort to determine
    the compiler used to build the PE binary in question.
  prefs: []
  type: TYPE_NORMAL
- en: In order to generate startup signatures, `sigmake` processes patterns that describe
    the startup routine^([[86](#ftn.CHP-12-FN-12)]) generated by various compilers
    and groups the resulting signatures into a single type-specific signature file.
    The `startup` directory in the FLAIR distribution contains the startup patterns
    used by IDA, along with the script, *startup.bat*, used to create the corresponding
    startup signatures from those patterns. Refer to *startup.bat* for examples of
    using `sigmake` to create startup signatures for a specific file format.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of PE files, you would notice several *pe_*.pat* files in the startup
    directory that describe startup patterns used by several popular Windows compilers,
    including *pe_vc.pat* for Visual Studio patterns and *pe_gcc.pat* for Cygwin/gcc
    patterns. If you wish to add additional startup patterns for PE files, you would
    need to add them to one of the existing PE pattern files or create a new pattern
    file with a `pe_` prefix in order for the startup signature-generation script
    to properly find your patterns and incorporate them into the newly generated PE
    signatures.
  prefs: []
  type: TYPE_NORMAL
- en: One last note about startup patterns concerns their format, which unfortunately
    is slightly different from patterns generated for library functions. The difference
    lies in the fact that a startup pattern line is capable of relating the pattern
    to additional sets of signatures that should also be applied if a match against
    the pattern is made. Other than the example startup patterns included in the *startup*
    directory, the format of a startup pattern is not documented in any of the text
    files included with FLAIR.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[80](#CHP-12-FN-6)]) The current version is *flair61.zip* and is available
    here: [http://www.hex-rays.com/idapro/ida/flair61.zip](http://www.hex-rays.com/idapro/ida/flair61.zip).
    A username and password supplied by Hex-Rays are required to access the download.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[81](#CHP-12-FN-7)]) The plb and pcf parsers may skip some functions depending
    on the command-line options supplied to the parsers and the structure of the library
    being parsed.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[82](#CHP-12-FN-8)]) At two characters per byte, 64 hexadecimal characters
    are required to display the contents of 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[83](#CHP-12-FN-9)]) This is a 16-bit cyclic redundancy check value. The
    CRC16 implementation utilized for pattern generation is included with the FLAIR
    tool distribution in the file *crc16.cpp*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[84](#CHP-12-FN-10)]) See [http://www.openrce.org/downloads/details/26/IDB_2_PAT](http://www.openrce.org/downloads/details/26/IDB_2_PAT).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[85](#CHP-12-FN-11)]) See [http://www.hex-rays.com/idapro/flirt.htm](http://www.hex-rays.com/idapro/flirt.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[86](#CHP-12-FN-12)]) The startup routine is generally designated as the
    program’s entry point. In a C/C++ program, the purpose of the startup routine
    is to initialize the program’s environment prior to passing control to the `main`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated library code identification is an essential capability that significantly
    reduces the amount of time required to analyze statically linked binaries. With
    its FLIRT and FLAIR capabilities, IDA makes such automated code recognition not
    only possible but extensible by allowing users to create their own library signatures
    from existing static libraries. Familiarity with the signature-generation process
    is an essential skill for anyone who expects to encounter statically linked binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13. Extending IDA’s Knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By now it should be clear that a high-quality disassembly is much more than
    a list of mnemonics and operands derived from a sequence of bytes. In order to
    make a disassembly useful, it is important to augment the disassembly with information
    derived from the processing of various API-related data such as function prototypes
    and standard datatypes. In [Chapter 8](ch08.html "Chapter 8. Datatypes and Data
    Structures") we discussed IDA’s handling of data structures, including how to
    access standard API data structures and how to define your own custom data structures.
    In this chapter, we continue our discussion of extending IDA’s knowledge by examining
    the use of IDA’s `idsutils` and `loadint` utilities. These utilities are available
    on your IDA distribution CD or via download at the Hex-Rays download site.^([[87](#ftn.CHP-13-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting Function Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IDA derives its knowledge of functions from two sources: type library (*.til*)
    files and IDS utilities (*.ids*) files. During the initial analysis phase, IDA
    uses information stored in these files to both improve the accuracy of the disassembly
    and make the disassembly more readable. It does so by incorporating function parameter
    names and types as well as comments that have been associated with various library
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures") we discussed
    type library files as the mechanism by which IDA stores the layout of complex
    data structures. Type library files are also the means by which IDA records information
    about a function’s calling conventions and parameter sequence. IDA uses function
    signature information in several ways. First, when a binary uses shared libraries,
    IDA has no way to know what calling conventions may be employed by the functions
    in those libraries. In such cases, IDA attempts to match library functions against
    their associated signatures in a type library file. If a matching signature is
    found, IDA can understand the calling convention used by the function and make
    adjustments to the stack pointer as necessary (recall that `stdcall` functions
    perform their own stack cleanup). The second use for function signatures is to
    annotate the parameters being passed to a function with comments that denote exactly
    which parameter is being pushed on the stack prior to calling the function. The
    amount of information present in the comment depends on how much information was
    present in the function signature that IDA was able to parse. The two signatures
    that follow are both legal C declarations, though the second provides more insight
    into the function, as it provides formal parameter names in addition to datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'IDA’s type libraries contain signature information for a large number of common
    API functions, including a substantial portion of the Windows API. A default disassembly
    of a call to the `RegOpenKey` function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that IDA has added comments in the right margin ![](httpatomoreillycomsourcenostarchimages854061.png),
    indicating which parameter is being pushed at each instruction leading up to the
    call to `RegOpenKey`. When formal parameter names are available in the function
    signature, IDA attempts to go one step further and automatically name variables
    that correspond to specific parameters. In two cases in the preceding example
    ![](httpatomoreillycomsourcenostarchimages854063.png), we can see that IDA has
    named a local variable (`hKey`) and a global variable (`SubKey`) based on their
    correspondence with formal parameters in the `RegOpenKey` prototype. If the parsed
    function prototype had contained only type information and no formal parameter
    names, then the comments in the preceding example would name the datatypes of
    the corresponding arguments rather than the parameter names. In the case of the
    `lpSubKey` parameter, the parameter name is not displayed as a comment because
    the parameter happens to point to a global string variable, and the content of
    the string is being displayed using IDA’s repeating comment facility. Finally,
    note that IDA has recognized `RegOpenKey` as a `stdcall` function and automatically
    adjusted the stack pointer ![](httpatomoreillycomsourcenostarchimages854093.png)
    as `RegOpenKey` would do upon returning. All of this information is extracted
    from the function’s signature, which IDA also displays as a comment within the
    disassembly at the appropriate import table location, as shown in the following
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The comment displaying the function prototype comes from an IDA .*til* file
    containing information on Windows API functions.
  prefs: []
  type: TYPE_NORMAL
- en: Under what circumstances might you wish to generate your own function type signatures?^([[88](#ftn.CHP-13-FN-2)])
    Whenever you encounter a binary that is linked, either dynamically or statically,
    to a library for which IDA has no function prototype information, you may want
    to generate type signature information for all of the functions contained in that
    library in order to provide IDA with the ability to automatically annotate your
    disassembly. Examples of such libraries might include common graphics or encryption
    libraries that are not part of a standard Windows distribution but that might
    be in widespread use. The OpenSSL cryptographic library is one example of such
    a library.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we were able to add complex datatype information to a database’s local
    .*til* file in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures"),
    we can add function prototype information to that same .*til* file by having IDA
    parse one or more function prototypes via File ▸ Load File▸ Parse C Header File.
    Similarly, you may use *tilib.exe* (see [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures")) to parse header files and create standalone *.til* files,
    which can be made globally available by copying them into *<IDADIR>/til*.
  prefs: []
  type: TYPE_NORMAL
- en: This is all well and good when you happen to have access to source code that
    you then allow IDA (or *tilib.exe*)to parse on your behalf. Unfortunately, more
    often than you would like, you will have no access to source code, yet you will
    want the same high-quality disassembly. How can you go about educating IDA if
    you have no source code for it to consume? This is the precisely the purpose of
    the IDS utilities, or `idsutils`. The IDS utilities are a set of three utility
    programs used to create .*ids* files. We first discuss what a .*ids* file is and
    then turn our attention to creating our own .*ids* files.
  prefs: []
  type: TYPE_NORMAL
- en: MANUALLY OVERRIDING PURGED BYTES
  prefs: []
  type: TYPE_NORMAL
- en: Library functions that make use of the `stdcall` calling convention can wreak
    havoc with IDA’s stack-pointer analysis. Lacking any type library or *.ids* file
    information, IDA has no way of knowing whether an imported function uses the `stdcall`
    convention. This is significant, as IDA may not be able to properly track the
    behavior of the stack pointer across calls to functions for which it has no calling
    convention information. Beyond knowing that a function utilizes `stdcall`, IDA
    must also know exactly how many bytes the function removes from the stack when
    the function completes. Lacking information on calling conventions, IDA attempts
    to automatically determine whether a function utilizes `stdcall` using a mathematical
    analysis technique known as the *simplex* method.^([[89](#ftn.CHP-13-FN-3)]) Alternatively,
    users may intervene manually to specify the number of purged bytes themselves.
    [Figure 13-1](ch13.html#editing_an_imported_function "Figure 13-1. Editing an
    imported function") shows a specialized form of the function editing dialog used
    for imported functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing an imported function](httpatomoreillycomsourcenostarchimages854247.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1. Editing an imported function
  prefs: []
  type: TYPE_NORMAL
- en: You can access this dialog by navigating to the import table entry for a given
    function and then editing the function (Edit ▸ Functions ▸ Edit Function, or alt-P).
    Note the limited functionality of this particular dialog (as opposed to the Edit
    Function dialog of [Figure 7-7](ch07s03.html#function_editing_dialog "Figure 7-7. Function
    editing dialog")). Because this is an imported function entry, IDA has no access
    to the compiled body of the function and therefore no associated information regarding
    the structure of the function’s stack frame and no direct evidence that the function
    uses the `stdcall` convention. Lacking such information, IDA sets the Purged bytes
    field to −1, indicating that it does not know whether the function clears any
    bytes from the stack upon return. To override IDA in such cases, enter the correct
    value for the number of purged bytes, and IDA will incorporate the provided information
    into its stack-pointer analysis wherever the associated function is called. In
    cases for which IDA is aware of the behavior of the function (as in [Figure 13-1](ch13.html#editing_an_imported_function
    "Figure 13-1. Editing an imported function")), the Purged bytes field may already
    be filled in. Note that this field is never filled in as a result of simplex method
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: IDS Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA uses .*ids* files to supplement its knowledge of library functions. A .*ids*
    file describes the content of a shared library by listing every exported function
    contained within the library. Information detailed for each function includes
    the function’s name, its associated ordinal number,^([[90](#ftn.CHP-13-FN-4)])
    whether the function utilizes `stdcall`, and if so, how many bytes the function
    clears from the stack upon return, and optional comments to be displayed when
    the function is referenced within a disassembly. In practice, .*ids* files are
    actually compressed .*idt* files, with .*idt* files containing the textual descriptions
    of each library function.
  prefs: []
  type: TYPE_NORMAL
- en: When an executable file is first loaded into a database, IDA determines which
    shared library files the executable depends on. For each shared library, IDA searches
    for a corresponding .*ids* file in the *<IDADIR>/ids* hierarchy in order to obtain
    descriptions of any library functions that the executable may reference. It is
    important to understand that .*ids* files do not necessarily contain function
    signature information. Therefore, IDA may not provide function parameter analysis
    based on information contained solely in .*ids* files. IDA can, however, perform
    accurate stack pointer accounting when a .*ids* file contains correct information
    concerning the calling conventions employed by functions and the number of bytes
    that the functions clear from the stack. In situations where a DLL exports mangled
    names, IDA may be able to infer a function’s parameter signature from the mangled
    name, in which case this information becomes available when the .*ids* file is
    loaded. We describe the syntax of .*idt* files in the next section. In this regard,
    .*til* files contain more useful information with respect to disassembling function
    calls, though source code is required in order to generate .*til* files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating IDS Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IDA’s `idsutils` utilities are used to create .*ids* files. The utilities include
    two library parsers, *dll2idt* for extracting information from Windows DLLs and
    *ar2idt* for extracting information from ar-style libraries. In both cases, the
    output is a text .*idt* file containing a single line per exported function that
    maps the exported function’s ordinal number to the function’s name. The syntax
    for .*idt* files, which is very straightforward, is described in the *readme.txt*
    file included with `idsutils`. The majority of lines in a .*idt* file are used
    to describe exported functions according to the following scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: An export entry begins with a positive number. This number represents the ordinal
    number of the exported function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ordinal number is followed by a space and then a `Name` directive in the
    form `Name=`*`function`*, for example, `Name=RegOpenKeyA`. If the special ordinal
    value zero is used, then the `Name` directive is used to specify the name of the
    library described in the current .*idt* file, such as in this example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An optional `Pascal` directive may be used to specify that a function uses
    the `stdcall` calling convention and to indicate how many bytes the function removes
    from the stack upon return. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An optional `Comment` directive can be appended to an export entry to specify
    a comment to be displayed with the function at each reference to the function
    within a disassembly. A completed export entry might look like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additional, optional directives are described in the `idsutils` *readme.txt*
    file. The purpose of the `idsutils` parsing utilities is to automate, as much
    as possible, the creation of .*idt* files. The first step in creating a .*idt*
    file is to obtain a copy of the library that you wish to parse; the next step
    is to parse it using the appropriate parsing utility. If we wished to create a
    .*idt* file for the OpenSSL -related library *ssleay32.dll*, we would use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Successful parsing in this case results in a file named *SSLEAY32.idt*. The
    difference in capitalization between the input filename and the output filename
    is due to the fact that *dll2idt* derives the name of the output file based on
    information contained within the DLL itself. The first few lines of the resulting
    .*idt* file are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is not possible for the parsers to determine whether a function
    uses `stdcall` and, if so, how many bytes are purged from the stack. The addition
    of any `Pascal` or `Comment` directives must be performed manually using a text
    editor prior to creating the final .*ids* file. The final steps for creating a
    .*ids* are to use the *zipids* utility to compress the .*idt* file and then to
    copy the resulting .*ids* file to *<IDADIR>/ids*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At this point, IDA loads *SSLEAY32.ids* anytime a binary that links to *ssleay32.dll*
    is loaded. If you elect not to copy your newly created .*ids* files into *<IDADIR>/ids*,
    you can load them at any time via File ▸ Load File ▸ IDS File.
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional step in the use of .*ids* files allows you to link .*ids* files
    to specific .*sig* or .*til* files. When you choose .*ids* files, IDA utilizes
    an IDS configuration file named *<IDADIR>/ida/idsnames*. This text file contains
    lines to allow for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Map a shared library name to its corresponding .*ids* filename. This allows
    IDA to locate the correct .*ids* file when a shared library name does not translate
    neatly to an MS-DOS-style 8.3 filename as with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Map a .*ids* file to a .*til* file. In such cases, IDA automatically loads
    the specified .*til* file whenever it loads the specified .*ids* file. The following
    example would cause *openssl.til* to be loaded anytime *SSLEAY32.ids* is loaded
    (see `idsnames` for syntax details):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Map a .*sig* file to a corresponding .*ids* file. In this case, IDA loads the
    indicated .*ids* file anytime the named .*sig* file is applied to a disassembly.
    The following line directs IDA to load *SSLEAY32.ids* anytime a user applies the
    *libssl.sig* FLIRT signature:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") we will look at a script-oriented
    alternative to the library parsers provided by `idsutils`, and we’ll leverage
    IDA’s function-analysis capabilities to generate more descriptive .*idt* files.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[87](#CHP-13-FN-1)]) See [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
    A valid IDA username and password are required.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[88](#CHP-13-FN-2)]) In this case we are using the term *signature* to refer
    to a function’s parameter type(s), quantity, and sequence rather than a pattern
    of code to match the compiled function.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[89](#CHP-13-FN-3)]) Use of the simplex method as introduced in IDA version
    5.1 is described in a blog post by Ilfak here: [http://www.hexblog.com/2006/06/](http://www.hexblog.com/2006/06/).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[90](#CHP-13-FN-4)]) An *ordinal number* is an integer index associated with
    each exported function. The use of ordinals allows a function to be located using
    an integer lookup table rather than by a slower string comparison against the
    function’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting Predefined Comments with loadint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation") we covered
    IDA’s concept of *auto comments*, which, when enabled, cause IDA to display comments
    describing each assembly language instruction. Two examples of such comments are
    shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The source of these predefined comments is the file *<IDADIR>/ida.int*, which
    contains comments sorted first by CPU type and second by instruction type. When
    auto comments are turned on, IDA searches for comments associated with each instruction
    in the disassembly and displays them in the right margin if they are present in
    *ida.int*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadint`^([[91](#ftn.CHP-13-FN-5)]) utilities provide you with the ability
    to modify existing comments or add new comments to *ida.int*. As with the other
    add-on utilities we have discussed, `loadint` is documented in a *readme.txt*
    file included with the `loadint` distribution. The `loadint` distribution also
    contains the predefined comments for all of IDA’s processor modules in the form
    of numerous .*cmt* files. Modifying existing comments is a simple matter of locating
    the comment file associated with your processor of interest (for example, *pc.cmt*
    for x86), making changes to any comments whose text you wish to modify, running
    *loadint* to re-create the *ida.int* comment file, and finally copying the resulting
    *ida.int* file into your main IDA directory, where it will be loaded the next
    time IDA is launched. A simple run to rebuild the comment database looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples of changes that you might wish to make include modifying existing
    comments or enabling comments for instructions that have no assigned comment.
    In the *pc.cmt* file, for example, several of the more common instructions are
    commented out so as not to generate too many comments when auto comments are enabled.
    The following lines, extracted from *pc.cmt*, demonstrate that x86 `mov` instructions
    do not generate comments by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Should you wish to enable comments for `mov` instructions, you would uncomment
    the middle line and rebuild the comment database as detailed previously.
  prefs: []
  type: TYPE_NORMAL
- en: A note buried within the documentation for `loadint` points out that *loadint*
    must be able to locate the file *ida.hlp*, which is included with your IDA distribution.
    If you receive the following error message, you should copy *ida.hlp* into your
    *loadint* directory and then rerun *loadint*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you may use the `-n` switch with `loadint` to specify the location
    of `<IDADIR>`, as shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The file *comment.cmt* serves as the master input file to the `loadint` process.
    The syntax for this file is described in the `loadint` documentation. In a nutshell,
    *comment.cmt* creates the mappings from processor types to associated comment
    files. Individual processor-specific comment files in turn specify the mappings
    from specific instructions to the associated comment text for each instruction.
    The entire process is governed by several sets of enumerated (C-style enums) constants
    that define all of the processor types (found in *comment.cmt*) and all of the
    possible instructions for each processor (found in *allins.hpp*).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to add predefined comments for a completely new processor type,
    the process is somewhat more involved than simply changing existing comments and
    is fairly closely linked to the process for creating new processor modules (see
    [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules")). Without diving too
    deeply into processor modules, providing comments for a completely new processor
    type requires that you first create a new enumerated constant set (shared with
    your processor module) within *allins.hpp* that defines one constant for each
    instruction in the instruction set of interest. Second, you must create a comment
    file that maps each enumerated instruction constant to its associated comment
    text. Third, you must define a new constant for your processor type (again, shared
    with your processor module) and create an entry in *comment.cmt* that maps your
    processor type to its associated comment file. Once you have completed these steps,
    you must run *loadint* to build a new comment database that incorporates your
    new processor type and associated comments.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[91](#CHP-13-FN-5)]) The current version is *loadint61.zip*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `idsutils` and `loadint` may not seem immediately useful to you, you will
    learn to appreciate their capabilities once you begin to step outside IDA’s more
    common use cases. For a relatively small investment of time, the creation of a
    single .*ids* or .*til* file can save you countless hours whenever you encounter
    the libraries described by those files in future projects. Keep in mind that it
    is not possible for IDA to ship with descriptions for every library in existence.
    The intended purpose of the tools covered in this chapter is to provide you with
    the flexibility to address gaps in IDA’s library coverage whenever you stray off
    IDA’s beaten path.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14. Patching Binaries and Other IDA Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the most frequently asked questions by new or prospective IDA users is
    “How can I use IDA to patch binaries?” The simple answer is “You can’t.” IDA’s
    intended purpose is to assist you in understanding the behavior of a binary by
    offering you the best disassembly possible. IDA is not designed to make it easy
    for you to modify the binaries you are examining. Not wanting to take no for an
    answer, die-hard patchers often follow up with questions such as “What about the
    Edit ▸ Patch Program menu?” and “What is the purpose of File ▸ Produce File ▸
    Create EXE File?” In this chapter we discuss these apparent anomalies and see
    if we can’t coax IDA into helping us, at least a little bit, with developing patches
    for binary program files.
  prefs: []
  type: TYPE_NORMAL
- en: The Infamous Patch Program Menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First mentioned in [Chapter 11](ch11.html "Chapter 11. Customizing IDA"), the
    Edit ▸ Patch Program menu is a hidden feature in the GUI version of IDA that must
    be enabled by editing the *idagui.cfg* configuration file (the Patch menu is available
    by default in console versions of IDA). [Figure 14-1](ch14.html#the_patch_program_submenu
    "Figure 14-1. The Patch Program submenu") shows the options available on the Edit
    ▸ Patch Program submenu.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Patch Program submenu](httpatomoreillycomsourcenostarchimages854250.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1. The Patch Program submenu
  prefs: []
  type: TYPE_NORMAL
- en: Each of the submenu items teases you with the notion that you are going to be
    able to modify the binary in potentially interesting ways. In actuality, what
    these options offer are three different ways to modify the database. In fact,
    these menu items, perhaps more than any others, make perfectly clear the distinction
    between an IDA database and the binary file from which the database was created.
    Once a database is created, IDA never references the original binary. Given its
    true behavior, this menu item would be more aptly named *Patch Database*.
  prefs: []
  type: TYPE_NORMAL
- en: All is not completely lost, however, as the menu options in [Figure 14-1](ch14.html#the_patch_program_submenu
    "Figure 14-1. The Patch Program submenu") do offer you the easiest way to observe
    the effect of any changes that you might eventually make to the original binary.
    Later in this chapter you will learn how to export the changes you have made and
    eventually use that information to patch the original binary.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Individual Database Bytes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Edit ▸ Patch Program ▸ Change Byte menu option is used to edit one or more
    byte values within an IDA database. [Figure 14-2](ch14.html#the_patch_bytes_dialog
    "Figure 14-2. The Patch Bytes dialog") shows the related byte-editing dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Patch Bytes dialog](httpatomoreillycomsourcenostarchimages854253.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2. The Patch Bytes dialog
  prefs: []
  type: TYPE_NORMAL
- en: The dialog displays 16-byte values beginning at the current cursor location.
    You may change some or all of the displayed bytes, but you cannot make changes
    beyond the 16th byte without closing the dialog, repositioning the cursor to a
    new location farther into the database, and reopening the dialog. Note that the
    dialog displays the virtual address and the file offset value for the bytes that
    you are changing. This File offset value reflects the hexa-decimal offset at which
    the bytes reside within the original binary file. The fact that IDA retains the
    original file offset information for every byte in the database will be useful
    if you do wish to develop a patch for the original binary. Finally, regardless
    of the number of changes that have been made to the bytes in the database, the
    Original value field of the dialog always displays the original byte values loaded
    into the database. There is no automated capability for reverting changes to their
    original byte values, though it is possible to create an IDA script to perform
    such a task.
  prefs: []
  type: TYPE_NORMAL
- en: A better method for editing database bytes was introduced in IDA 5.5 in the
    form of a more capable Hex View window (see [Chapter 5](ch05.html "Chapter 5. IDA
    Data Displays")). With an integrated hex-editing capability, there is little need
    to use IDA’s change bytes capability.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a Word in the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Somewhat less useful than the byte-patching capability is IDA’s word-patching
    capability. [Figure 14-3](ch14.html#the_patch_word_dialog "Figure 14-3. The Patch
    Word dialog") shows IDA’s Patch Word dialog, which is capable of patching only
    one 2-byte word at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Patch Word dialog](httpatomoreillycomsourcenostarchimages854256.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-3. The Patch Word dialog
  prefs: []
  type: TYPE_NORMAL
- en: As with the byte-patching dialog, the virtual address and file offset are displayed.
    An important point to remember is that the word value is displayed using the natural
    byte ordering of the underlying processor. For example, in an x86 disassembly,
    words are treated as little-endian values, while in a MIPS disassembly, words
    are treated as big-endian values. Keep this in mind when entering new word values.
    As with the byte-patching dialog, the Original value field always displays the
    initial value loaded from the original binary file regardless of the number of
    times the word value may have been modified using the word-patching dialog. As
    with byte editing, it may be easier to perform your editing within IDA’s Hex View
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Assemble Dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most interesting capability accessible from the Patch Program menu
    is the Assemble option (Edit ▸ Patch Program ▸ Assemble). Unfortunately, this
    capability is not available for all processor types, as it relies on the presence
    of an internal assembler capability within the current processor module. For example,
    the x86 processor module is known to support assembly, while the MIPS processor
    module is known not to support assembly. When an assembler is not available, you
    will receive an error message stating, “Sorry, this processor module doesn’t support
    the assembler.”
  prefs: []
  type: TYPE_NORMAL
- en: The Assemble option allows you to enter assembly language statements that are
    assembled using an internal assembler. The resulting instruction bytes are then
    written to the current screen location. [Figure 14-4](ch14.html#the_assemble_instruction_dialog
    "Figure 14-4. The Assemble Instruction dialog") shows the Assemble Instruction
    dialog used for instruction entry.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Assemble Instruction dialog](httpatomoreillycomsourcenostarchimages854259.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-4. The Assemble Instruction dialog
  prefs: []
  type: TYPE_NORMAL
- en: You can enter one instruction at a time into the Instruction field. The assembler
    component for IDA’s x86 processor module accepts the same syntax used in x86 disassembly
    listings. When you click OK (or press enter), your instruction is assembled, and
    the corresponding instruction bytes are entered into the database beginning at
    the virtual address displayed in the Address field. The internal IDA assembler
    allows you to use symbolic names within your instructions as long as those names
    exist within the program. Syntax such as `mov [ebp+var_4], eax` and `call sub_401896`
    is perfectly legal, and the assembler will correctly resolve symbolic references.
  prefs: []
  type: TYPE_NORMAL
- en: Following entry of an instruction, the dialog remains open and ready to accept
    a new instruction at the virtual address immediately following the previously
    entered instruction. While you enter additional instructions, the dialog displays
    the previous instruction entered in the Previous line field.
  prefs: []
  type: TYPE_NORMAL
- en: When entering new instructions, you must pay attention to instruction alignment,
    especially when the instruction that you are entering is a different length than
    the instruction it is replacing. When a new instruction is shorter than the instruction
    it is replacing, you need to consider what to do with the excess bytes left over
    from the old instruction (inserting NOP^([[92](#ftn.CHP-14-FN-1)]) instructions
    is one possible option). When a new instruction is longer than the instruction
    that it is replacing, IDA will overwrite as many bytes of subsequent instructions
    as is required to fit the new instruction. This may or may not be the behavior
    you want, which is why careful planning is necessary before using the assembler
    to modify program bytes. One way to view the assembler is as a word processor
    that is stuck in overwrite mode. There is no easy way to open up space to insert
    new instructions without overwriting existing instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to remember that IDA’s database-patching capabilities are limited
    to small, simple patches that easily fit into existing space within the database.
    If you have a patch that requires substantial additional space, you will need
    to locate space that is allocated within the original binary but not used by the
    binary. Such space is often present in the form of padding, inserted by compilers
    to align sections of a binary to particular file boundaries. For example, in many
    Windows PE files, individual program sections must begin at file offsets that
    are multiples of 512 bytes. When a section does not consume an even multiple of
    512 bytes of space, that section must be padded within the file in order to maintain
    a 512-byte boundary for the next section. The following lines from a disassembled
    PE file demonstrate this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, IDA is using an align directive ![](httpatomoreillycomsourcenostarchimages854061.png)
    to indicate that the section is padded to a 512-byte (`200h`) boundary beginning
    from address `.text:00409644`. The upper end of the padding is the next multiple
    of 512 bytes, or `.text:00409800`. The padded area is generally filled with zeros
    by the compiler and stands out quite prominently in hex view. In this particular
    binary, there is space within the file to insert up to 444 (0x1BC = 409800h –
    409644h) bytes of patched program data, which would overwrite some or all of the
    zero padding at the end of the `.text` section. You might patch a function to
    jump to this area of the binary, execute the newly inserted program instructions,
    and then jump back to the original function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the next section in the binary, the `.idata` section, does not actually
    begin until address `.idata:0040A000`. This is a result of a memory- (not file-)
    alignment restriction that requires PE sections to begin in 4Kb (one memory page)
    boundaries. In theory it should be possible to inject an additional 2,048 bytes
    of patched data into the memory range `00409800-0040A000`. The difficulty in doing
    so lies in the fact that no bytes corresponding to this memory range are present
    within the disk image of the executable. In order to use this space, we would
    need to perform more than a simple overwrite of portions of the original binary
    file. First we would need to insert a 2,048-byte block of data between the end
    of the existing `.text` section and the beginning of the `.idata` section. Second,
    we would need to adjust the size of the `.text` section within the PE file headers.
    Finally, we’d need to adjust the location of `.idata` and all subsequent sections
    within the PE headers to reflect the fact that all following sections are now
    located 2,048 bytes deeper into the file. These changes may not sound terribly
    complicated, but they require some attention to detail and a good working knowledge
    of the PE file format.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[92](#CHP-14-FN-1)]) *NOP* stands for *no operation* and is an instruction
    often used simply to fill in space in a program.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Output Files and Patch Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more interesting menu options in IDA is the File ▸ Produce File menu.
    According to the options on this menu, IDA can generate MAP, ASM, INC, LST, EXE,
    DIF, and HTML files. Many of these sound intriguing, so each is described in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: IDA-Generated MAP Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *.map* file describes the overall layout of a binary, including information
    about the sections that make up the binary and the location of symbols within
    each section. When generating a *.map* file, you are asked for the name of the
    file you wish to create and the types of symbols you would like to store in the
    *.map* file. [Figure 14-5](ch14s02.html#map_file-generation_options "Figure 14-5. MAP
    file-generation options") shows the MAP file options dialog, in which you select
    the information you wish to include in the *.map* file.
  prefs: []
  type: TYPE_NORMAL
- en: '![MAP file-generation options](httpatomoreillycomsourcenostarchimages854262.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-5. MAP file-generation options
  prefs: []
  type: TYPE_NORMAL
- en: Address information in a *.map* file is represented using *logical addresses*.
    A logical address describes a symbol’s location using a segment number and a segment
    offset. The first few lines of a simple *.map* file are shown in the following
    listing. In this listing we show three segments and the first two of many symbols.
    The logical address of `_fprintf` indicates that it resides at byte offset `69h`
    within the first (`.text`) segment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: MAP files generated by IDA are compatible with Borland’s Turbo Debugger. The
    principle purpose of *.map* files is to assist in restoring symbol names when
    debugging binaries that may have been stripped.
  prefs: []
  type: TYPE_NORMAL
- en: IDA-Generated ASM Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA can generate a *.asm* file from the current database. The general idea is
    to create a file that could be run through an assembler to re-create the underlying
    binary file. IDA attempts to dump enough information, including such things as
    structure layouts, to make successful assembly possible. Whether you will be able
    to successfully assemble the generated *.asm* file depends on a number of factors,
    not the least of which is whether your particular assembler understands the syntax
    IDA uses.
  prefs: []
  type: TYPE_NORMAL
- en: The target assembly language syntax is determined by the Target assembler setting
    found on the Analysis tab under the Options ▸ General menu. By default IDA generates
    an assembly file representing the entire database. However, you may limit the
    scope of the listing by clicking and dragging or using shift-up arrow or shift-down
    arrow to scroll and select the region you wish to dump. In console versions of
    IDA, you would utilize the `Anchor` (alt-L) command to set an anchor point at
    the start of a selection region and then use the arrow keys to extend the size
    of the region.
  prefs: []
  type: TYPE_NORMAL
- en: IDA-Generated INC Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An INC (include) file contains definitions of data structures and enumerated
    datatypes. This is essentially a dump of the contents of the Structures windows
    in a form suitable for consumption by an assembler.
  prefs: []
  type: TYPE_NORMAL
- en: IDA-Generated LST Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An LST file is nothing more than a text file dump of the contents of the IDA
    disassembly window. You can narrow the scope of the generating listing by selecting
    a range of addresses to dump, as described previously for ASM files.
  prefs: []
  type: TYPE_NORMAL
- en: IDA-Generated EXE Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this is the most promising menu option, it unfortunately is also the most
    crippled. In a nutshell, it doesn’t work for most file types, and you can expect
    to receive an error message stating, “This type of output file is not supported.”
  prefs: []
  type: TYPE_NORMAL
- en: While this would be an ideal capability for a patcher, in general it is very
    difficult to regenerate executable files from an IDA database. The information
    that you are presented with in an IDA database is comprised primarily of the contents
    of the sections that make up the original input file. In many cases, however,
    IDA does not process every section of an input file, and certain information is
    lost when the file is loaded into the database, making generation of an executable
    from the database impossible. The simplest example of such loss is the fact that
    IDA does not load the resource (`.rsrc`) section of PE files by default, which
    makes restoration of the resource section from the database impossible.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, IDA processes information from the original binary but does
    not make it easily accessible in its original form. Examples include symbol tables,
    import tables, and export tables, which would require a fair amount of effort
    to properly reconstruct in order to generate a functional executable file.
  prefs: []
  type: TYPE_NORMAL
- en: 'One effort to provide an EXE-generation capability for IDA is the pe_scripts^([[93](#ftn.CHP-14-FN-2)])
    of Atli Mar Gudmundsson. These are a set of IDA scripts for working with PE files.
    One of the scripts is titled *pe_write.idc*, and its goal is to dump a working
    PE image out of an existing database. If you intend to patch a PE file, the proper
    sequence of events for using the scripts is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the desired PE file into IDA. Make sure that you uncheck the **Make imports
    section** option in the loader dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the included *pe_sections.idc* script to map all sections from the original
    binary into the new database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make any desired changes to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the *pe_write.idc* script to dump the database contents to a new PE
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scripting with IDC is the subject of [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting").
  prefs: []
  type: TYPE_NORMAL
- en: IDA-Generated DIF Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An IDA DIF file is a plaintext file that lists all bytes that have been modified
    within an IDA database. This is the most useful file format if your goal is to
    patch an original binary based on changes made to an IDA database. The format
    of the file is quite simple, as shown in the example *.dif* file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The file includes a one-line header comment followed by the name of the original
    binary file and then a list of bytes within the file that have changed. Each change
    line specifies the file offset (not virtual address) of the changed byte, the
    original value of the byte, and the current value of the byte within the database.
    In this example, the database for *dif_example.exe* has been modified at four
    locations corresponding to byte offsets `0x2F8`–`0x2FB` within the original file.
    It is a trivial task to write a program to parse IDA *.dif* files and apply the
    changes to the original binary file to generate a patched version of the binary.
    One such utility is available at the companion website for this book.^([[94](#ftn.CHP-14-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: IDA-Generated HTML Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDA takes advantage of the markup capabilities available with HTML in order
    to generate colorized disassembly listings. An IDA-generated HTML file is essentially
    an LST file with HTML tags added to produce a listing that is colored similarly
    to the actual IDA disassembly window. Unfortunately, the generated HTML files
    do not contain any hyperlinks that would make navigating the file any easier than
    if one used a standard text listing. For example, one useful feature would be
    the addition of hyperlinks to all name references, which would make following
    name references as simple as following a link.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[93](#CHP-14-FN-2)]) See [http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip](http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[94](#CHP-14-FN-3)]) See [http://www.idabook.com/chapter14/ida_patcher.c](http://www.idabook.com/chapter14/ida_patcher.c).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA is not a binary file editor. Keep that fact in mind anytime you think about
    patching a binary with IDA. However, it is a particularly good tool for helping
    you enter and visualize potential changes. By familiarizing yourself with IDA’s
    full range of features and combining the information that IDA can generate with
    appropriate scripts or external programs, binary patching easily becomes possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, we will cover the many ways in which IDA’s capabilities
    can be extended. For anyone interested in making the most out of IDA’s capabilities,
    basic scripting skills and an understanding of IDA’s plug-in architecture are
    essential, as they offer you the capability to add behaviors wherever you feel
    IDA is lacking.
  prefs: []
  type: TYPE_NORMAL
