<html><head></head><body><div class="part" title="Part&#xA0;IV.&#xA0;Extending IDA&#x2019;s Capabilities"><div class="titlepage"><div><div><h1 class="title"><a id="extending_idaas_capabilities"/>Part IV. Extending IDA’s Capabilities</h1></div></div></div><div class="partintro" id="id3184046" title="Extending IDA’s Capabilities"><div/><p/></div></div>
<div class="chapter" title="Chapter&#xA0;15.&#xA0;IDA Scripting"><div class="titlepage"><div><div><h1 class="title"><a id="ida_scripting"/>Chapter 15. IDA Scripting</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id15"/><div class="mediaobject"><a id="I_mediaobject1_d1e18212"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>It is a simple fact that no application can meet every need of every user. It is just not possible to anticipate every potential use case that may arise. Application developers are faced with the choice of responding to an endless stream of feature requests or offering users a means to solve their own problems. IDA takes the latter approach by integrating scripting features that allow users to exercise a tremendous amount of programmatic control over IDA’s actions.<a class="indexterm" id="IDX-CHP-15-0001"/><a class="indexterm" id="IDX-CHP-15-0002"/></p><p>Potential uses for scripts are infinite and can range from simple one-liners to full-blown programs that automate common tasks or perform complex analysis functions. From an automation standpoint, IDA scripts can be viewed as macros,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-1" id="CHP-15-FN-1">95</a>]</sup> while from an analysis point of view, IDA’s scripting languages serve as the query languages that provide programmatic access to the contents of an IDA database. IDA supports scripting using two different languages. IDA’s original, embedded scripting language is named <span class="emphasis"><em>IDC</em></span>, perhaps because its syntax bears a close resemblance to C. Since the release of IDA 5.4,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-2" id="CHP-15-FN-2">96</a>]</sup> integrated scripting with Python has also been supported through the integration of the IDAPython plug-in by Gergely Erdelyi.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-3" id="CHP-15-FN-3">97</a>]</sup> For the remainder of this chapter we will cover the basics of writing and executing both IDC and Python scripts as well as some of the more useful functions available to script authors.<a class="indexterm" id="IDX-CHP-15-0003"/><a class="indexterm" id="IDX-CHP-15-0004"/><a class="indexterm" id="IDX-CHP-15-0005"/><a class="indexterm" id="IDX-CHP-15-0006"/></p><div class="sect1" title="Basic Script Execution"><div class="titlepage"><div><div><h1 class="title"><a id="basic_script_execution"/>Basic Script Execution</h1></div></div></div><p>Before diving into the details of either scripting language, it is useful to understand the most common ways that scripts can be executed. Three menu options, File ▸ Script File, File ▸ IDC Command, and File ▸ Python Command<sup>[<a class="footnote" href="#ftn.CHP-15-FN-4" id="CHP-15-FN-4">98</a>]</sup> are available to access IDA’s scripting engine. Selecting File ▸ Script File indicates that you wish to run a standalone script, at which point you are presented with a file-selection dialog that lets you choose the script to run. Each time you run a new script, the program is added to a list of recent scripts to provide easy access to edit or rerun the script. <a class="xref" href="ch15.html#the_recent_scripts_window" title="Figure 15-1. The Recent Scripts window">Figure 15-1</a> shows the Recent Scripts window accessible via the View ▸ Recent Scripts menu option.<a class="indexterm" id="IDX-CHP-15-0007"/><a class="indexterm" id="IDX-CHP-15-0008"/></p><div class="figure"><a id="the_recent_scripts_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e18289"/><img alt="The Recent Scripts window" src="httpatomoreillycomsourcenostarchimages854265.png.jpg"/></div></div><p class="title">Figure 15-1. The Recent Scripts window</p></div><p>Double-clicking a listed script causes the script to be executed. A pop-up, context-sensitive menu offers options to remove a script from the list or to open a script for editing using the editor specified under Options ▸ General on the Misc tab.</p><p>As an alternative to executing a standalone script file, you may elect to open a script entry dialog using File ▸ IDC Command or File ▸ Python Command. <a class="xref" href="ch15.html#the_script_entry_dialog" title="Figure 15-2. The script entry dialog">Figure 15-2</a> shows the resulting script entry dialog (for an IDC script in this case), which is useful in situations where you wish to execute only a few statements but don’t want to go to the trouble of creating a standalone script file.</p><div class="figure"><a id="the_script_entry_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e18303"/><img alt="The script entry dialog" src="httpatomoreillycomsourcenostarchimages854268.png.jpg"/></div></div><p class="title">Figure 15-2. The script entry dialog</p></div><p>Some restrictions apply to the types of statements that you can enter in the script dialog, but the dialog is very useful in cases where creating a full-blown script file is overkill.<a class="indexterm" id="IDX-CHP-15-0009"/><a class="indexterm" id="IDX-CHP-15-0010"/><a class="indexterm" id="IDX-CHP-15-0011"/><a class="indexterm" id="IDX-CHP-15-0012"/><a class="indexterm" id="IDX-CHP-15-0013"/></p><p>The last way to easily execute script commands is to use IDA’s command line. The command line is available only in GUI versions of IDA, and its presence is controlled by the value of the <code class="literal">DISPLAY_COMMAND_LINE</code> option in <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/idagui.cfg</em></span>. The command line has been enabled by default since IDA 5.4. <a class="xref" href="ch15.html#the_ida_command_line" title="Figure 15-3. The IDA command line">Figure 15-3</a> shows the command line as it appears in the lower-left corner of the IDA workspace, beneath the output window.<a class="indexterm" id="IDX-CHP-15-0014"/></p><div class="figure"><a id="the_ida_command_line"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e18347"/><img alt="The IDA command line" src="httpatomoreillycomsourcenostarchimages854271.png.jpg"/></div></div><p class="title">Figure 15-3. The IDA command line</p></div><p>The interpreter that will be used to execute the command line is labeled to the left of the command-line entry box. In <a class="xref" href="ch15.html#the_ida_command_line" title="Figure 15-3. The IDA command line">Figure 15-3</a>, the command line is configured to execute IDC statements. Clicking this label opens the pop-up menu shown in <a class="xref" href="ch15.html#the_ida_command_line" title="Figure 15-3. The IDA command line">Figure 15-3</a>, allowing either interpreter (IDC or Python) to be associated with the command line.</p><p>Although the command line contains only a single line of text, you can enter multiple statements by separating each statement with a semicolon. As a convenience, the history of recent commands is accessible with the up arrow key. If you find yourself frequently needing to execute very short scripts, you will find the command line very useful.</p><p>With a basic ability to execute scripts under our belts, it is time to focus on the specifics of IDA’s two available scripting languages, IDC and Python. We begin with a description of IDA’s native scripting language, IDC, and conclude with a discussion of IDA’s Python integration, which will rely heavily on the foundation built by the IDC sections that follow.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-1" id="ftn.CHP-15-FN-1">95</a>] </sup>Many applications offer facilities that allow users to record sequences of actions into a single complex action called a <span class="emphasis"><em>macro</em></span>. Replaying or triggering a macro causes the entire sequence of recorded steps to be executed. Macros provided an easy means to automate a complex series of actions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-2" id="ftn.CHP-15-FN-2">96</a>] </sup>For a comprehensive list of features introduced with each new version of IDA, visit <a class="ulink" href="http://www.hex-rays.com/idapro/idanew48.htm">http://www.hex-rays.com/idapro/idanew48.htm</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-3" id="ftn.CHP-15-FN-3">97</a>] </sup>See <a class="ulink" href="http://code.google.com/p/idapython/">http://code.google.com/p/idapython/</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-4" id="ftn.CHP-15-FN-4">98</a>] </sup>This option is only available if Python is properly installed. Refer to <a class="xref" href="ch03.html" title="Chapter 3. IDA Pro Background">Chapter 3</a> for details.</p></div></div></div>
<div class="sect1" title="The IDC Language"><div class="titlepage"><div><div><h1 class="title"><a id="the_idc_language"/>The IDC Language</h1></div></div></div><p>Unlike for some other aspects of IDA, a reasonable amount of help is available for the IDC language in IDA’s help system. Topics available at the top level of the help system include <span class="emphasis"><em>IDC language</em></span>, which covers the basics of IDC syntax, and <span class="emphasis"><em>Index of IDC functions</em></span>, which provides an exhaustive list of built-in functions available to IDC programmers.<a class="indexterm" id="IDX-CHP-15-0015"/><a class="indexterm" id="IDX-CHP-15-0016"/><a class="indexterm" id="IDX-CHP-15-0017"/><a class="indexterm" id="IDX-CHP-15-0018"/></p><p>IDC is a scripting language that borrows most of its syntactic elements from C. Beginning with IDA 5.6, IDC actually takes on more of the flavor of C++ with the introduction of object-oriented features and exception handling. Because of its similarity to C and C++, we will describe IDC in terms of these languages and focus primarily on where IDC differs.</p><div class="sect2" title="IDC Variables"><div class="titlepage"><div><div><h2 class="title"><a id="idc_variables"/>IDC Variables</h2></div></div></div><p>IDC is a loosely typed language, meaning that variables have no explicit type. The three primary datatypes used in IDC are integers (IDA documentation uses the type name <span class="emphasis"><em>long</em></span>), strings, and floating point values, with the overwhelming majority of operations taking place on integers and strings. Strings are treated as a native datatype in IDC, and there is no need to keep track of the space required to store a string or whether a string is null terminated or not. Beginning with IDA 5.6, IDC incorporates a number of additional variable types, including objects, references, and function pointers.<a class="indexterm" id="IDX-CHP-15-0019"/><a class="indexterm" id="IDX-CHP-15-0020"/><a class="indexterm" id="IDX-CHP-15-0021"/></p><p>All variables must be declared prior to their use. IDC supports local variables and, since IDA 5.4, global variables as well. The IDC keyword <code class="literal">auto</code> is used to introduce a local variable declaration, and local variable declarations may include initial values. The following examples show legal IDC local variable declarations:</p><a id="I_programlisting1_d1e18418"/><pre class="programlisting">auto addr, reg, val;   // legal, multiple variables declared with no initializers
auto count = 0;        // declaration with initialization</pre><p>IDC recognizes C-style multiline comments using <code class="literal">/* */</code> and C++–style line-terminating comments using <code class="literal">//</code>. Also, note that several variables may be declared in a single statement and that all statements in IDC are terminated using a semicolon (as in C). IDC does not support C-style arrays (slices are introduced in IDA 5.6), pointers (though references are supported beginning with IDA 5.6), or complex datatypes such as structs and unions. Classes are introduced in IDA 5.6.</p><p>Global variable declarations are introduced using the <code class="literal">extern</code> keyword, and their declarations are legal both inside and outside of any function definition. It is not legal to provide an initial value when a global variable is declared. The following listing shows the declaration of two global variables.</p><a id="I_programlisting1_d1e18433"/><pre class="programlisting">extern outsideGlobal;

static main() {
   extern insideGlobal;
   outsideGlobal = "Global";
   insideGlobal = 1;
}</pre><p>Global variables are allocated the first time they are encountered during an IDA session and persist as long as that session remains active, regardless of the number of databases that you may open and close.<a class="indexterm" id="IDX-CHP-15-0022"/><a class="indexterm" id="IDX-CHP-15-0023"/><a class="indexterm" id="IDX-CHP-15-0024"/><a class="indexterm" id="IDX-CHP-15-0025"/><a class="indexterm" id="IDX-CHP-15-0026"/><a class="indexterm" id="IDX-CHP-15-0027"/><a class="indexterm" id="IDX-CHP-15-0028"/><a class="indexterm" id="IDX-CHP-15-0029"/></p></div><div class="sect2" title="IDC Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="idc_expressions"/>IDC Expressions</h2></div></div></div><p>With a few exceptions, IDC supports virtually all of the arithmetic and logical operators available in C, including the ternary operator (<code class="literal">? :</code>). Compound assignment operators of the form <code class="literal">op=</code> (<code class="literal">+=</code>, <code class="literal">*=</code>, <code class="literal">&gt;&gt;=</code>, and the like) are not supported. The comma operator is supported beginning with IDA 5.6. All integer operands are treated as signed values. This affects integer comparisons (which are always signed) and the right-shift operator (<code class="literal">&gt;&gt;</code>), which always performs an arithmetic shift with sign bit replication. If you require logical right shifts, you must implement them yourself by masking off the top bit of the result, as shown here:<a class="indexterm" id="IDX-CHP-15-0030"/></p><a id="I_programlisting1_d1e18494"/><pre class="programlisting">result = (x &gt;&gt; 1) &amp; 0x7fffffff;  //set most significant bit to zero</pre><p>Because strings are a native type in IDC, some operations on strings take on a different meaning than they might in C. The assignment of a string operand into a string variable results in a string copy operation; thus there is no need for string copying or duplicating functions such as C’s <code class="literal">strcpy</code> and <code class="literal">strdup</code>. Also, the addition of two string operands results in the concatenation of the two operands; thus “Hello” + “World” yields “HelloWorld”; there is no need for a concatenation function such as C’s <code class="literal">strcat</code>. Starting with IDA 5.6, IDC offers a slice operator for use with strings. Python programmers will be familiar with slices, which basically allow you to specify subsequences of array-like variables. Slices are specified using square brackets and a start (inclusive) and end (exclusive) index. At least one index is required. The following listing demonstrates the use of IDC slices.<a class="indexterm" id="IDX-CHP-15-0031"/><a class="indexterm" id="IDX-CHP-15-0032"/></p><a id="I_programlisting1_d1e18513"/><pre class="programlisting">auto str = "String to slice";
auto s1, s2, s3, s4;
s1 = str[7:9];     // "to"
s2 = str[:6];      // "String", omitting start index starts at 0
s3 = str[10:];     // "slice", omitting end index goes to end of string
s4 = str[5];       // "g", single element slice, similar to array element access</pre><p>Note that while there are no array datatypes available in IDC, the slice operator effectively allows you to treat IDC strings as if they were arrays.</p></div><div class="sect2" title="IDC Statements"><div class="titlepage"><div><div><h2 class="title"><a id="idc_statements"/>IDC Statements</h2></div></div></div><p>As in C, all simple statements are terminated with a semicolon. The only C-style compound statement that IDC does not support is the <code class="literal">switch</code> statement. When using <code class="literal">for</code> loops, keep in mind that IDC does not support compound assignment operators, which may affect you if you wish to count by anything other than one, as shown here:<a class="indexterm" id="IDX-CHP-15-0033"/><a class="indexterm" id="IDX-CHP-15-0034"/><a class="indexterm" id="IDX-CHP-15-0035"/><a class="indexterm" id="IDX-CHP-15-0036"/><a class="indexterm" id="IDX-CHP-15-0037"/><a class="indexterm" id="IDX-CHP-15-0038"/><a class="indexterm" id="IDX-CHP-15-0039"/><a class="indexterm" id="IDX-CHP-15-0040"/><a class="indexterm" id="IDX-CHP-15-0041"/></p><a id="I_programlisting1_d1e18566"/><pre class="programlisting">auto i;
for (i = 0; i &lt; 10; i += 2) {}     // illegal, += is not supported
for (i = 0; i &lt; 10; i = i + 2) {}  // legal</pre><p>With IDA 5.6, IDC introduces <code class="literal">try</code>/<code class="literal">catch</code> blocks and the associated <code class="literal">throw</code> statement, which are syntactically similar to C++ exceptions.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-5" id="CHP-15-FN-5">99</a>]</sup> IDA’s built-in help contains specifics on IDC’s exception-handling implementation.</p><p>For compound statements, IDC utilizes the same bracing (<code class="literal">{}</code>) syntax and semantics as C. Within a braced block, it is permissible to declare new variables as long as the variable declarations are the first statements within the block. However, IDC does not rigorously enforce the scope of the newly introduced variables, because such variables may be referenced beyond the block in which they were declared. Consider the following example:</p><a id="I_programlisting1_d1e18590"/><pre class="programlisting">if (1) {    //always true
   auto x;
   x = 10;
}
else {      //never executes
   auto y;
   y = 3;
}
Message("x = %d\n", x);   // x remains accessible after its block terminates
Message("y = %d\n", y);   // IDC allows this even though the else did not execute</pre><p>The output statements (the <code class="literal">Message</code> function is analogous to C’s <code class="literal">printf</code>) will inform us that <code class="literal">x = 10</code> and <code class="literal">y = 0</code>. Given that IDC does not strictly enforce the scope of <code class="literal">x</code>, it is not terribly surprising that we are allowed to print the value of <code class="literal">x</code>. What is somewhat surprising is that <code class="literal">y</code> is accessible at all, given that the block in which <code class="literal">y</code> is declared is never executed. This is simply a quirk of IDC. Note that while IDC may loosely enforce variable scoping within a function, variables declared within one function continue to remain inaccessible in any other function.</p></div><div class="sect2" title="IDC Functions"><div class="titlepage"><div><div><h2 class="title"><a id="idc_functions"/>IDC Functions</h2></div></div></div><p>IDC supports user-defined functions in standalone programs (<span class="emphasis"><em>.idc</em></span> files) only. User-defined functions are not supported when using the IDC command dialog (see <a class="xref" href="ch15s02.html#using_the_idc_command_dialog" title="USING THE IDC COMMAND DIALOG">USING THE IDC COMMAND DIALOG</a> in <a class="xref" href="ch15s02.html#using_the_idc_command_dialog" title="USING THE IDC COMMAND DIALOG">USING THE IDC COMMAND DIALOG</a>). IDC’s syntax for declaring user-defined functions is where it differs most from C. The <code class="literal">static</code> keyword is used to introduce a user-defined function, and the function’s parameter list consists solely of a comma-separated list of parameter names. The following listing details the basic structure of a user-defined function:<a class="indexterm" id="IDX-CHP-15-0042"/><a class="indexterm" id="IDX-CHP-15-0043"/></p><a id="I_programlisting1_d1e18640"/><pre class="programlisting">static my_func(x, y, z) {
   //declare any local variables first
   auto a, b, c;
   //add statements to define the function's behavior
   // ...
}</pre><p>Prior to IDA 5.6, all function parameters are strictly call-by-value. Call-by-reference parameter passing was introduced with IDA 5.6. Interestingly, whether a parameter is passed using call-by-value or call-by-reference is determined by the manner in which the function is called, not the manner in which the function is declared. The unary <code class="literal">&amp;</code> operator is used in a function call (<span class="emphasis"><em>not</em></span> the function declaration) to denote that an argument is being passed by reference. The following examples show invocations of the <code class="literal">my_func</code> function from the previous listing making use of both call-by-value and call-by-reference parameter passing.<a class="indexterm" id="IDX-CHP-15-0044"/><a class="indexterm" id="IDX-CHP-15-0045"/><a class="indexterm" id="IDX-CHP-15-0046"/></p><a id="I_programlisting1_d1e18664"/><pre class="programlisting">auto q = 0, r = 1, s = 2;
my_func(q, r, s);   //all three arguments passed using call-by-value
                    //upon return, q, r, and s hold 0, 1, and 2 respectively
my_func(q, &amp;r, s);  //q and s passed call-by-value, r is passed call-by-reference
                    //upon return, q, and s hold 0 and 2 respectively, but r may have
                    //changed. In this second case, any changes
 that my_func makes to its
                    //formal parameter y will be reflected in the
 caller as changes to r</pre><p>Function declarations never indicate whether a function explicitly returns a value or what type of value is returned when a function does yield a result.</p><div class="sidebar"><a id="using_the_idc_command_dialog"/><p class="title">USING THE IDC COMMAND DIALOG</p><p>The IDC command dialog offers a simple interface for entering short sequences of IDC code. The command dialog is a great tool for rapidly entering and testing new scripts without the hassle of creating a standalone script file. The most important thing to keep in mind when using the command dialog is that you <span class="emphasis"><em>must</em></span> not define any functions inside the dialog. In essence, IDA wraps your statements within a function and then calls that function in order to execute your statements. If you were to define a function within the dialog, the net effect would be a function defined within a function, and since nested function declarations are not allowed in IDC (or in C for that matter), a syntax error would result.<a class="indexterm" id="IDX-CHP-15-0047"/></p></div><p>When you wish to return a value from a function, use a <code class="literal">return</code> statement to return the desired value. It is permissible to return entirely different datatypes from different paths of execution within a function. In other words, a function may return a string in some cases, while in other cases the same function may return an integer. As in C, use of a <code class="literal">return</code> statement within a function is optional. However, unlike C, any function that does not explicitly return a value implicitly returns the value zero.<a class="indexterm" id="IDX-CHP-15-0048"/><a class="indexterm" id="IDX-CHP-15-0049"/><a class="indexterm" id="IDX-CHP-15-0050"/><a class="indexterm" id="IDX-CHP-15-0051"/></p><p>As a final note, beginning with IDA 5.6, functions take a step closer to becoming first-class objects in IDC. It is now possible to pass function references as arguments to other functions and return function references as the result of a function. The following listing demonstrates the use of function parameters and functions as return values.<a class="indexterm" id="IDX-CHP-15-0052"/></p><a id="I_programlisting1_d1e18710"/><pre class="programlisting">static getFunc() {
   return Message;  //return the built-in Message function as a result
}

static useFunc(func, arg) {  //func here is expected to be a function reference
   func(arg);
}

static main() {
   auto f = getFunc();
   f("Hello World\n");       //invoke the returned function f
   useFunc(f, "Print me\n"); //no need for &amp; operator,
 functions always call-by-reference
}</pre></div><div class="sect2" title="IDC Objects"><div class="titlepage"><div><div><h2 class="title"><a id="idc_objects"/>IDC Objects</h2></div></div></div><p>Another feature introduced in IDA 5.6 is the ability to define classes and, as a result, have variables that represent objects. In the discussion that follows, we assume that you have some familiarity with an object-oriented programming language such as C++ or Java.</p><div class="sidebar"><a id="ida_scripting_evolves"/><p class="title">IDA SCRIPTING EVOLVES</p><p>If you haven’t gotten the idea that a large number of changes to IDC were introduced with IDA 5.6, then you haven’t been paying attention. Following the integration of IDAPython in IDA 5.4, Hex-Rays looked to rejuvenate IDC, resulting in many of the features mentioned in this chapter being introduced in IDA 5.6. Along the way, JavaScript was even contemplated as a potential addition to IDA’s scripting lineup.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-6" id="CHP-15-FN-6">100</a>]</sup>.<a class="indexterm" id="IDX-CHP-15-0053"/></p></div><p>IDC defines a root class named <code class="literal">object</code> from which all classes ultimately derive, and single inheritance is supported when creating new classes. IDC does not make use of access specifiers such as <code class="literal">public</code> and <code class="literal">private</code>; all class members are effectively public. Class declarations contain only the definitions of the class’s member functions. In order to create data members within a class, you simply create an assignment statement that assigns a value to the data member. The following listing will help to clarify.</p><a id="I_programlisting1_d1e18743"/><pre class="programlisting">class ExampleClass {
   ExampleClass(x, y) {   //constructor
      this.a = x;         //all ExampleClass objects have data member a
      this.b = y;         //all ExampleClass objects have data member b
   }
   ~ExampleClass() {      //destructor
   }
   foo(x) {
      this.a = this.a + x;
   }
   //...   other member functions as desired
};

static main() {
   ExampleClass ex;            //DON'T DO THIS!! This is not
 a valid variable declaration
   auto ex = ExampleClass(1, 2);   //reference variables are initialized by assigning
                                   //the result of calling the class constructor
   ex.foo(10);                 //dot notation is used to access members
   ex.z = "string";            //object ex now has a member z, BUT the class does not
}</pre><p>For more information on IDC classes and their syntax, refer to the appropriate section within IDA’s built-in help file.<a class="indexterm" id="IDX-CHP-15-0054"/><a class="indexterm" id="IDX-CHP-15-0055"/><a class="indexterm" id="IDX-CHP-15-0056"/><a class="indexterm" id="IDX-CHP-15-0057"/></p></div><div class="sect2" title="IDC Programs"><div class="titlepage"><div><div><h2 class="title"><a id="idc_programs"/>IDC Programs</h2></div></div></div><p>For any scripting applications that require more than a few IDC statements, you are likely to want to create a standalone IDC program file. Among other things, saving your scripts as programs gives you some measure of persistence and portability.<a class="indexterm" id="IDX-CHP-15-0058"/></p><p>IDC program files require you to make use of user-defined functions. At a minimum, you must define a function named <code class="literal">main</code> that takes no arguments. In most cases, you will also want to include the file <span class="emphasis"><em>idc.idc</em></span> in order to pick up useful macro definitions that it contains. The following listing details the components of a minimal IDC program file:</p><a id="I_programlisting1_d1e18781"/><pre class="programlisting">#include &lt;idc.idc&gt;    // useful include directive
//declare additional functions as required
static main() {
   //do something fun here
}</pre><p>IDC recognizes the following C-style preprocessor directives:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>#include</code></strong> &lt;<span class="bolditalic">file</span>&gt;</span></dt><dd><p>Includes the named file in the current file.</p></dd><dt><span class="term"><strong class="userinput"><code>#define</code></strong> &lt;<span class="bolditalic">name</span>&gt; [<span class="bolditalic">optional value</span>]</span></dt><dd><p>Creates a macro named <span class="emphasis"><em>name</em></span> and optionally assigns it the specified value. IDC predefines a number of macros that may be used to test various aspects of your script’s execution environment. These include <span class="emphasis"><em>_NT_</em></span>, <span class="emphasis"><em>_LINUX_</em></span>, <span class="emphasis"><em>_MAC_</em></span>, <span class="emphasis"><em>_GUI_</em></span>, and <code class="literal">_</code><span class="emphasis"><em>TXT_</em></span> among others. See the <span class="emphasis"><em>Predefined symbols</em></span> section of the IDA help file for more information on these and other symbols.<a class="indexterm" id="IDX-CHP-15-0059"/><a class="indexterm" id="IDX-CHP-15-0060"/><a class="indexterm" id="IDX-CHP-15-0061"/><a class="indexterm" id="IDX-CHP-15-0062"/><a class="indexterm" id="IDX-CHP-15-0063"/><a class="indexterm" id="IDX-CHP-15-0064"/><a class="indexterm" id="IDX-CHP-15-0065"/><a class="indexterm" id="IDX-CHP-15-0066"/></p></dd><dt><span class="term"><strong class="userinput"><code>#ifdef</code></strong> &lt;<span class="bolditalic">name</span>&gt;</span></dt><dd><p>Tests for the existence of the named macro and optionally processes any statements that follow if the named macro exists.</p></dd><dt><span class="term"><strong class="userinput"><code>#else</code></strong></span></dt><dd><p>Optionally used in conjunction with an <code class="literal">#ifdef</code> to provide an alternative set of statements to process in the event the named macro does not exist.</p></dd><dt><span class="term"><strong class="userinput"><code>#endif</code></strong></span></dt><dd><p>This is a required terminator for an <code class="literal">#ifdef</code> or <code class="literal">#ifdef/#else</code> block.</p></dd><dt><span class="term"><strong class="userinput"><code>#undef</code></strong> &lt;<span class="bolditalic">name</span>&gt;</span></dt><dd><p>Deletes the named macro.</p></dd></dl></div></div><div class="sect2" title="Error Handling in IDC"><div class="titlepage"><div><div><h2 class="title"><a id="error_handling_in_idc"/>Error Handling in IDC</h2></div></div></div><p>No one is ever going to praise IDC for its error-reporting capabilities. There are two types of errors that you can expect to encounter when running IDC scripts: parsing errors and runtime errors.<a class="indexterm" id="IDX-CHP-15-0067"/><a class="indexterm" id="IDX-CHP-15-0068"/></p><p><span class="emphasis"><em>Parsing errors</em></span> are those errors that prevent your program from ever being executed and include such things as syntax errors, references to undefined variables, and supplying an incorrect number of arguments to a function. During the parsing phase, IDC reports only the first parsing error that it encounters. In some cases, error messages correctly identify both the location and the type of an error (<code class="literal">hello_world.idc,20: Missing semicolon</code>), while in other cases, error messages offer no real assistance (<code class="literal">Syntax error near: &lt;END&gt;</code>). Only the first error encountered during parsing is reported. As a result, in a script with 15 syntax errors, it may take 15 attempts at running the script before you are informed of every error.<a class="indexterm" id="IDX-CHP-15-0069"/></p><p><span class="emphasis"><em>Runtime errors</em></span> are generally encountered less frequently than parsing errors. When encountered, runtime errors cause a script to terminate immediately. One example of a runtime error results from an attempt to call an undefined function that for some reason is not detected when the script is initially parsed. Another problem arises with scripts that take an excessive amount of time to execute. Once a script is started, there is no easy way to terminate the script if it inadvertently ends up in an infinite loop or simply takes longer to execute than you are willing to wait. Once a script has executed for more than two to three seconds, IDA displays the dialog shown in <a class="xref" href="ch15s02.html#script_cancellation_dialog" title="Figure 15-4. Script cancellation dialog">Figure 15-4</a>.</p><p>This dialog is the only means by which you can terminate a script that fails to terminate properly.</p><div class="figure"><a id="script_cancellation_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e18946"/><img alt="Script cancellation dialog" src="httpatomoreillycomsourcenostarchimages854274.png.jpg"/></div></div><p class="title">Figure 15-4. Script cancellation dialog</p></div><p>Debugging is another of IDC’s weak points. Other than liberal use of output statements, there is no way to debug IDC scripts. With the introduction of exception handling (<code class="literal">try/catch</code>) in IDA 5.6, it does become possible to build more robust scripts that can terminate or continue as gracefully as you choose.<a class="indexterm" id="IDX-CHP-15-0070"/><a class="indexterm" id="IDX-CHP-15-0071"/><a class="indexterm" id="IDX-CHP-15-0072"/><a class="indexterm" id="IDX-CHP-15-0073"/></p></div><div class="sect2" title="Persistent Data Storage in IDC"><div class="titlepage"><div><div><h2 class="title"><a id="persistent_data_storage_in_idc"/>Persistent Data Storage in IDC</h2></div></div></div><p>Perhaps you are the curious type who, not trusting that we would provide sufficient coverage of IDA’s scripting capability, raced off to see what the IDA help system has to say on the subject. If so, welcome back, and if not, we appreciate you sticking with us this far. In any case, somewhere along the way you may have acquired knowledge that claims that IDC does in fact support arrays, in which case you must surely be questioning the quality of this book. We urge you to give us a chance to sort out this potential confusion.</p><p>As mentioned previously, IDC does not support arrays in the traditional sense of declaring a large block of storage and then using a subscript notation to access individual items within that block. However, IDA’s documentation on scripting does mention something called <span class="emphasis"><em>global persistent arrays</em></span>. IDC global arrays are better thought of as <span class="emphasis"><em>persistent named objects</em></span>. The objects just happen to be sparse arrays.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-7" id="CHP-15-FN-7">101</a>]</sup> Global arrays are stored within an IDA database and are persistent across script invocations and IDA sessions. Data is stored in global arrays by specifying an index and a data value to be stored at the specified index in the array. Each element in an array can simultaneously hold one integer value and one string value. IDC’s global arrays provide no means for storing floating point values.<a class="indexterm" id="IDX-CHP-15-0074"/><a class="indexterm" id="IDX-CHP-15-0075"/><a class="indexterm" id="IDX-CHP-15-0076"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>For the overly curious, IDA’s internal mechanism for storing persistent arrays is called a netnode. While the array-manipulation functions described next provide an abstracted interface to netnodes, lower-level access to netnode data is available using the IDA SDK, which is discussed, along with netnodes, in <a class="xref" href="ch16.html" title="Chapter 16. The IDA Software Development Kit">Chapter 16</a>.<a class="indexterm" id="IDX-CHP-15-0077"/></p></div><p>All interaction with global arrays occurs through the use of IDC functions dedicated to array manipulation. Descriptions of these functions follow:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long CreateArray(string name)</code></strong></span></dt><dd><p>This function creates a persistent object with the specified name. The return value is an integer handle required for all future access to the array. If the named object already exists, the return value is −1.</p></dd><dt><span class="term"><strong class="userinput"><code>long GetArrayId(string name)</code></strong></span></dt><dd><p>Once an array has been created, subsequent access to the array must be done through an integer handle, which can be obtained by looking up the array name. The return value for this function is an integer handle to be used for all future interaction with the array. If the named array does not exist, the return value is −1.</p></dd><dt><span class="term"><strong class="userinput"><code>long SetArrayLong(long id, long idx, long value)</code></strong></span></dt><dd><p>Stores an integer <code class="literal">value</code> into the array referred to by <code class="literal">id</code> at the position specified by <code class="literal">idx</code>. The return value is 1 on success or 0 on failure. The operation will fail if the array <code class="literal">id</code> is invalid.<a class="indexterm" id="IDX-CHP-15-0078"/><a class="indexterm" id="IDX-CHP-15-0079"/><a class="indexterm" id="IDX-CHP-15-0080"/></p></dd><dt><span class="term"><strong class="userinput"><code>long SetArrayString(long id, long idx, string str)</code></strong></span></dt><dd><p>Stores a string <code class="literal">value</code> into the array referred to by <code class="literal">id</code> at the position specified by <code class="literal">idx</code>. The return value is 1 on success or 0 on failure. The operation will fail if the array <code class="literal">id</code> is invalid.</p></dd><dt><span class="term"><strong class="userinput"><code>string or long GetArrayElement(long tag, long id, long idx)</code></strong></span></dt><dd><p>While there are distinct functions for storing data into an array depending on the type of data to be stored, there is only one function for retrieving data from an array. This function retrieves either an integer or a string value from the specified index (<code class="literal">idx</code>) in the specified array (<code class="literal">id</code>). Whether an integer or a string is retrieved is determined by the value of the <code class="literal">tag</code> parameter, which must be one of the constants <code class="literal">AR_LONG</code> (to retrieve an integer) or <code class="literal">AR_STR</code> (to retrieve a string).</p></dd><dt><span class="term"><strong class="userinput"><code>long DelArrayElement(long tag, long id, long idx)</code></strong></span></dt><dd><p>Deletes the contents of the specified array location from the specified array. The value of <code class="literal">tag</code> determines whether the integer value or string value associated with the specified index is deleted.</p></dd><dt><span class="term"><strong class="userinput"><code>void DeleteArray(long id)</code></strong></span></dt><dd><p>Deletes the array referenced by <code class="literal">id</code> and all of its associated contents. Once an array has been created, it continues to exist, even after a script terminates, until a call is made to <code class="literal">DeleteArray</code> to remove the array from the database in which it was created.</p></dd><dt><span class="term"><strong class="userinput"><code>long RenameArray(long id, string newname)</code></strong></span></dt><dd><p>Renames the array referenced by <code class="literal">id</code> to <code class="literal">newname</code>. Returns 1 if successful or 0 if the operation fails.</p></dd></dl></div><p>Possible uses for global arrays include approximating global variables, approximating complex datatypes, and providing persistent storage across script invocations. Global variables for a script are simulated by creating a global array when the script begins and storing global values in the array. These global values are shared either by passing the array handle to functions requiring access to the values or by requiring any function that requires access to perform a name lookup for the desired array.</p><p>Values stored in an IDC global array persist for the lifetime of the database in which the script was executed. You may test for the existence of an array by examining the return value of the <code class="literal">CreateArray</code> function. If the values stored in an array are applicable only to a specific invocation of a script, then the array should be deleted before the script terminates. Deleting the array ensures that no global values carry over from one execution of a script to a subsequent execution of the same script.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-5" id="ftn.CHP-15-FN-5">99</a>] </sup>See <a class="ulink" href="http://www.cplusplus.com/doc/tutorial/exceptions/">http://www.cplusplus.com/doc/tutorial/exceptions/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-6" id="ftn.CHP-15-FN-6">100</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=101">http://www.hexblog.com/?p=101</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-7" id="ftn.CHP-15-FN-7">101</a>] </sup>Sparse arrays do not necessarily preallocate space for the entire array, nor are they limited to a particular maximum index. Instead, space for array elements is allocated on an as-needed basis when elements are added to the array.</p></div></div></div>
<div class="sect1" title="Associating IDC Scripts with Hotkeys"><div class="titlepage"><div><div><h1 class="title"><a id="associating_idc_scripts_with_hotkeys"/>Associating IDC Scripts with Hotkeys</h1></div></div></div><p>Occasionally you may develop a script so amazing in its utility that you must have access to it with a keystroke or two. When this happens, you will want to assign a hotkey sequence that you can use to quickly activate your script. Fortunately IDA provides a simple means to do this. Every time IDA is launched, the script contained in <span class="emphasis"><em>&lt;IDADIR&gt;/idc/ida.idc</em></span> is executed. The default version of this script contains an empty <code class="literal">main</code> function and thus does nothing. To associate a hotkey with one of your scripts, you need to add two lines to <span class="emphasis"><em>ida.idc</em></span>. The first line you must add is an <code class="literal">include</code> directive to include your script file in <span class="emphasis"><em>ida.idc</em></span>. The second line you must add is a call, within <code class="literal">main</code>, to the <code class="literal">AddHotkey</code> function to associate a specific hotkey with your amazing IDC function. This might leave <span class="emphasis"><em>ida.idc</em></span> looking like this:<a class="indexterm" id="IDX-CHP-15-0081"/><a class="indexterm" id="IDX-CHP-15-0082"/><a class="indexterm" id="IDX-CHP-15-0083"/><a class="indexterm" id="IDX-CHP-15-0084"/><a class="indexterm" id="IDX-CHP-15-0085"/><a class="indexterm" id="IDX-CHP-15-0086"/><a class="indexterm" id="IDX-CHP-15-0087"/><a class="indexterm" id="IDX-CHP-15-0088"/></p><a id="I_programlisting1_d1e19197"/><pre class="programlisting">#include &lt;idc.idc&gt;
#include &lt;my_amazing_script.idc&gt;
static main() {
   AddHotkey("z", "MyAmazingFunc");  //Now 'z' invokes MyAmazingFunc
}</pre><p>If the hotkey you are attempting to associate with your script has already been assigned to another IDA action (menu hotkey or plug-in activation sequence), <code class="literal">AddHotkey</code> silently fails with no way to detect the failure other than the fact that your function fails to execute when your hotkey sequence is activated.</p><p>Two important points here are that the standard include directory for IDC scripts is <span class="emphasis"><em>&lt;IDADIR&gt;/idc</em></span> and that you must not name your script function <code class="literal">main</code>. If you want IDA to find your script easily, you can copy it into <span class="emphasis"><em>&lt;IDADIR&gt;/idc</em></span>. If you intend to leave your script file in another location, then you will need to specify the full path to your script in the <code class="literal">include</code> statement. While testing your script, it will be useful to run your script as a standalone program with a <code class="literal">main</code> function. Once you are ready to associate your script with a hotkey, however, you cannot use the name <code class="literal">main</code>, because it will conflict with the <code class="literal">main</code> function in <span class="emphasis"><em>ida.idc</em></span>. You must rename your <code class="literal">main</code> function and use the new name in the call to <code class="literal">AddHotkey</code>.</p></div>
<div class="sect1" title="Useful IDC Functions"><div class="titlepage"><div><div><h1 class="title"><a id="useful_idc_functions"/>Useful IDC Functions</h1></div></div></div><p>At this point, you have all the information required to write well-formed IDC scripts. What you are lacking is the ability to perform any useful interaction with IDA itself. IDC provides a long list of built-in functions that offer many different ways to access a database. All of the functions are documented to some degree in the IDA help system under the topic <span class="emphasis"><em>Index of IDC functions</em></span>. In most cases, the documentation is nothing more than relevant lines copied from the main IDC include file, <span class="emphasis"><em>idc.idc</em></span>. Becoming comfortable with the rather terse documentation is one of the more frustrating aspects of learning IDC. In general, there is no easy way to answer the question “How do I do <span class="emphasis"><em>x</em></span> in IDC?” The most common way to figure out how to do something is to browse the list of IDC functions looking for one that, based on its name, appears to do what you need. This presumes, of course, that the functions are named according to their purpose, but their purpose may not always be obvious. For example, in many cases, functions that retrieve information from the database are named <code class="literal">Get</code><em class="replaceable"><code>XXX</code></em>; however; in many other cases, the <code class="literal">Get</code> prefix is not used. Functions that change the database may be named <code class="literal">Set</code><em class="replaceable"><code>XXX</code></em>, <code class="literal">Make</code><em class="replaceable"><code>XXX</code></em>, or something else entirely. In summary, if you want to use IDC, get used to browsing the list of functions and reading through their descriptions. If you find yourself at a complete loss, don’t be afraid to use the support forums at Hex-Rays.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-8" id="CHP-15-FN-8">102</a>]</sup><a class="indexterm" id="IDX-CHP-15-0089"/><a class="indexterm" id="IDX-CHP-15-0090"/><a class="indexterm" id="IDX-CHP-15-0091"/><a class="indexterm" id="IDX-CHP-15-0092"/><a class="indexterm" id="IDX-CHP-15-0093"/><a class="indexterm" id="IDX-CHP-15-0094"/><a class="indexterm" id="IDX-CHP-15-0095"/><a class="indexterm" id="IDX-CHP-15-0096"/><a class="indexterm" id="IDX-CHP-15-0097"/><a class="indexterm" id="IDX-CHP-15-0098"/><a class="indexterm" id="IDX-CHP-15-0099"/><a class="indexterm" id="IDX-CHP-15-0100"/><a class="indexterm" id="IDX-CHP-15-0101"/></p><p>The intent of the remainder of this section is to point out some of the more useful (in our experience) IDC functions and group them into functional areas. Even if you intend to script in Python only, familiarity with the listed functions will be useful to you because IDAPython provides Python equivalents to each function listed here. We make no attempt to cover every IDC function, however, since they are already covered in the IDA help system.</p><div class="sect2" title="Functions for Reading and Modifying Data"><div class="titlepage"><div><div><h2 class="title"><a id="functions_for_reading_and_modifying_data"/>Functions for Reading and Modifying Data</h2></div></div></div><p>The following functions provide access to individual bytes, words, and double words in a database:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long Byte(long addr)</code></strong></span></dt><dd><p>Reads a byte value from virtual address <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>long Word(long addr)</code></strong></span></dt><dd><p>Reads a word (2-byte) value from virtual address <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>long Dword(long addr)</code></strong></span></dt><dd><p>Reads a double word (4-byte) value from virtual address <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>void PatchByte(long addr, long val)</code></strong></span></dt><dd><p>Sets a byte value at virtual address <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>void PatchWord(long addr, long val)</code></strong></span></dt><dd><p>Sets a word value at virtual address <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>void PatchDword(long addr, long val)</code></strong></span></dt><dd><p>Sets a double word value at virtual address <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>bool isLoaded(long addr)</code></strong></span></dt><dd><p>Returns 1 if <code class="literal">addr</code> contains valid data, 0 otherwise.</p></dd></dl></div><p>Each of these functions takes the byte ordering (little-endian or big-endian) of the current processor module into account when reading and writing the database. The <code class="literal">Patch</code><em class="replaceable"><code>XXX</code></em> functions also trim the supplied value to an appropriate size by using only the proper number of low-order bytes according to the function called. For example, a call to <code class="literal">PatchByte(0x401010, 0x1234)</code> will patch location <code class="literal">0x401010</code> with the byte value <code class="literal">0x34</code> (the low-order byte of <code class="literal">0x1234</code>). If an invalid address is supplied while reading the database with <code class="literal">Byte</code>, <code class="literal">Word</code>, and <code class="literal">Dword</code>, the values <code class="literal">0xFF</code>, <code class="literal">0xFFFF</code>, and <code class="literal">0xFFFFFFFF</code> will be returned, respectively. Because there is no way to distinguish these error values from legitimate data stored in the database, you may wish to call <code class="literal">isLoaded</code> to determine whether an address in the database contains any data prior to attempting to read from that address.<a class="indexterm" id="IDX-CHP-15-0102"/><a class="indexterm" id="IDX-CHP-15-0103"/><a class="indexterm" id="IDX-CHP-15-0104"/><a class="indexterm" id="IDX-CHP-15-0105"/><a class="indexterm" id="IDX-CHP-15-0106"/><a class="indexterm" id="IDX-CHP-15-0107"/><a class="indexterm" id="IDX-CHP-15-0108"/><a class="indexterm" id="IDX-CHP-15-0109"/><a class="indexterm" id="IDX-CHP-15-0110"/><a class="indexterm" id="IDX-CHP-15-0111"/><a class="indexterm" id="IDX-CHP-15-0112"/><a class="indexterm" id="IDX-CHP-15-0113"/><a class="indexterm" id="IDX-CHP-15-0114"/><a class="indexterm" id="IDX-CHP-15-0115"/></p><p>Because of a quirk in refreshing IDA’s disassembly view, you may find that the results of a patch operation are not immediately visible. In such cases, scrolling away from the patched location and then scrolling back to the patched location generally forces the display to be updated properly.</p></div><div class="sect2" title="User Interaction Functions"><div class="titlepage"><div><div><h2 class="title"><a id="user_interaction_functions"/>User Interaction Functions</h2></div></div></div><p>In order to perform any user interaction at all, you will need to familiarize yourself with IDC input/output functions. The following list summarizes some of IDC’s more useful interface functions:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>void Message(string format, ...)</code></strong></span></dt><dd><p>Prints a formatted message to the output window. This function is analogous to C’s <code class="literal">printf</code> function and accepts a <code class="literal">printf</code>-style format string.</p></dd><dt><span class="term"><strong class="userinput"><code>void print(...)</code></strong></span></dt><dd><p>Prints the string representation of each argument to the output window.</p></dd><dt><span class="term"><strong class="userinput"><code>void Warning(string format, ...)</code></strong></span></dt><dd><p>Displays a formatted message in a dialog.</p></dd><dt><span class="term"><strong class="userinput"><code>string AskStr(string default, string prompt)</code></strong></span></dt><dd><p>Displays an input dialog asking the user to enter a string value. Returns the user’s string or 0 if the dialog was canceled.</p></dd><dt><span class="term"><strong class="userinput"><code>string AskFile(long doSave, string mask, string prompt)</code></strong></span></dt><dd><p>Displays a file-selection dialog to simplify the task of choosing a file. New files may be created for saving data (<code class="literal">doSave = 1</code>), or existing files may be chosen for reading data (<code class="literal">doSave = 0</code>). The displayed list of files may be filtered according to <code class="literal">mask</code> (such as <code class="literal">*.*</code> or <code class="literal">*.idc</code>). Returns the name of the selected file or 0 if the dialog was canceled.</p></dd><dt><span class="term"><strong class="userinput"><code>long AskYN(long default, string prompt)</code></strong></span></dt><dd><p>Prompts the user with a yes or no question, highlighting a default answer (1 = yes, 0 = no, −1 = cancel). Returns an integer representing the selected answer.</p></dd><dt><span class="term"><strong class="userinput"><code>long ScreenEA()</code></strong></span></dt><dd><p>Returns the virtual address of the current cursor location.</p></dd><dt><span class="term"><strong class="userinput"><code>bool Jump(long addr)</code></strong></span></dt><dd><p>Jumps the disassembly window to the specified address.</p></dd></dl></div><p>Because IDC lacks any debugging facilities, you may find yourself using the <code class="literal">Message</code> function as your primary debugging tool. Several other <code class="literal">Ask</code><em class="replaceable"><code>XXX</code></em> functions exist to handle more specialized input cases such as integer input. Please refer to the help system documentation for a complete list of available <code class="literal">Ask</code><em class="replaceable"><code>XXX</code></em> functions. The <code class="literal">ScreenEA</code> function is very useful for picking up the current cursor location when you wish to create a script that tailors its behavior based on the location of the cursor. Similarly, the <code class="literal">Jump</code> function is useful when you have a script that needs to call the user’s attention to a specific location within the disassembly.<a class="indexterm" id="IDX-CHP-15-0116"/><a class="indexterm" id="IDX-CHP-15-0117"/><a class="indexterm" id="IDX-CHP-15-0118"/><a class="indexterm" id="IDX-CHP-15-0119"/><a class="indexterm" id="IDX-CHP-15-0120"/><a class="indexterm" id="IDX-CHP-15-0121"/><a class="indexterm" id="IDX-CHP-15-0122"/><a class="indexterm" id="IDX-CHP-15-0123"/><a class="indexterm" id="IDX-CHP-15-0124"/><a class="indexterm" id="IDX-CHP-15-0125"/><a class="indexterm" id="IDX-CHP-15-0126"/><a class="indexterm" id="IDX-CHP-15-0127"/><a class="indexterm" id="IDX-CHP-15-0128"/><a class="indexterm" id="IDX-CHP-15-0129"/><a class="indexterm" id="IDX-CHP-15-0130"/><a class="indexterm" id="IDX-CHP-15-0131"/></p></div><div class="sect2" title="String-Manipulation Functions"><div class="titlepage"><div><div><h2 class="title"><a id="string-manipulation_functions"/>String-Manipulation Functions</h2></div></div></div><p>Although simple string assignment and concatenation are taken care of with basic operators in IDC, more complex operations must be performed using available string-handling functions, some of which are detailed here:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>string form(string format, ...)   // pre IDA 5.6</code></strong></span></dt><dd><p>Returns a new string formatted according to the supplied format strings and values. This is the rough equivalent to C’s <code class="literal">sprintf</code> function.</p></dd><dt><span class="term"><strong class="userinput"><code>string sprintf(string format, ...)   // IDA 5.6+</code></strong></span></dt><dd><p>With IDA 5.6, <code class="literal">sprintf</code> replaces <code class="literal">form</code> (see above).</p></dd><dt><span class="term"><strong class="userinput"><code>long atol(string val)</code></strong></span></dt><dd><p>Converts the decimal value <code class="literal">val</code> to its corresponding integer representation.</p></dd><dt><span class="term"><strong class="userinput"><code>long xtol(string val)</code></strong></span></dt><dd><p>Converts the hexadecimal value <code class="literal">val</code> (which may optionally begin with <code class="literal">0x</code>) to its corresponding integer representation.</p></dd><dt><span class="term"><strong class="userinput"><code>string ltoa(long val, long radix)</code></strong></span></dt><dd><p>Returns a string representation of <code class="literal">val</code> in the specified <code class="literal">radix</code> (2, 8, 10, or 16).</p></dd><dt><span class="term"><strong class="userinput"><code>long ord(string ch)</code></strong></span></dt><dd><p>Returns the ASCII value of the one-character string <code class="literal">ch</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>long strlen(string str)</code></strong></span></dt><dd><p>Returns the length of the provided string.</p></dd><dt><span class="term"><strong class="userinput"><code>long strstr(string str, string substr)</code></strong></span></dt><dd><p>Returns the index of <code class="literal">substr</code> within <code class="literal">str</code> or −1 if the substring is not found.</p></dd><dt><span class="term"><strong class="userinput"><code>string substr(string str, long start, long end)</code></strong></span></dt><dd><p>Returns the substring containing the characters from <code class="literal">start</code> through <code class="literal">end-1</code> of <code class="literal">str</code>. Using slices (IDA 5.6+) this function is equivalent to <code class="literal">str[start:end]</code>.</p></dd></dl></div><p>Recall that there is no character datatype in IDC, nor is there any array syntax. Lacking slices, if you want to iterate through the individual characters within a string, you must take successive one-character substrings for each character in the string.</p></div><div class="sect2" title="File Input/Output Functions"><div class="titlepage"><div><div><h2 class="title"><a id="file_input_solidus_output_functions"/>File Input/Output Functions</h2></div></div></div><p>The output window may not always be the ideal place to send the output of your scripts. For scripts that generate a large amount of text or scripts that generate binary data, you may wish to output to disk files instead. We have already discussed using the <code class="literal">AskFile</code> function to ask a user for a filename. However, <code class="literal">AskFile</code> returns only a string containing the name of a file. IDC’s file-handling functions are detailed here:<a class="indexterm" id="IDX-CHP-15-0132"/><a class="indexterm" id="IDX-CHP-15-0133"/><a class="indexterm" id="IDX-CHP-15-0134"/><a class="indexterm" id="IDX-CHP-15-0135"/><a class="indexterm" id="IDX-CHP-15-0136"/><a class="indexterm" id="IDX-CHP-15-0137"/><a class="indexterm" id="IDX-CHP-15-0138"/><a class="indexterm" id="IDX-CHP-15-0139"/><a class="indexterm" id="IDX-CHP-15-0140"/><a class="indexterm" id="IDX-CHP-15-0141"/><a class="indexterm" id="IDX-CHP-15-0142"/><a class="indexterm" id="IDX-CHP-15-0143"/><a class="indexterm" id="IDX-CHP-15-0144"/><a class="indexterm" id="IDX-CHP-15-0145"/><a class="indexterm" id="IDX-CHP-15-0146"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long fopen(string filename, string mode)</code></strong></span></dt><dd><p>Returns an integer file handle (or 0 on error) for use with all IDC file I/O functions. The <code class="literal">mode</code> parameter is similar to the modes used in C’s <code class="literal">fopen</code> (<code class="literal">r</code> to read, <code class="literal">w</code> to write, and so on).</p></dd><dt><span class="term"><strong class="userinput"><code>void fclose(long handle)</code></strong></span></dt><dd><p>Closes the file specified by the file handle from <code class="literal">fopen</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>long filelength(long handle)</code></strong></span></dt><dd><p>Returns the length of the indicated file or −1 on error.</p></dd><dt><span class="term"><strong class="userinput"><code>long fgetc(long handle)</code></strong></span></dt><dd><p>Reads a single byte from the given file. Returns −1 on error.</p></dd><dt><span class="term"><strong class="userinput"><code>long fputc(long val, long handle)</code></strong></span></dt><dd><p>Writes a single byte to the given file. Returns 0 on success or −1 on error.</p></dd><dt><span class="term"><strong class="userinput"><code>long fprintf(long handle, string format, ...)</code></strong></span></dt><dd><p>Writes a formatted string to the given file.</p></dd><dt><span class="term"><strong class="userinput"><code>long writestr(long handle, string str)</code></strong></span></dt><dd><p>Writes the specified string to the given file.</p></dd><dt><span class="term"><strong class="userinput"><code>string/long readstr(long handle)</code></strong></span></dt><dd><p>Reads a string from the given file. This function reads all characters (including non-ASCII) up to and including the next line feed (ASCII 0xA) character. Returns the string on success or −1 on end of file.</p></dd><dt><span class="term"><strong class="userinput"><code>long writelong(long handle, long val, long bigendian)</code></strong></span></dt><dd><p>Writes a 4-byte integer to the given file using big-endian (<code class="literal">bigendian</code> = 1) or little-endian (<code class="literal">bigendian</code> = 0) byte order.</p></dd><dt><span class="term"><strong class="userinput"><code>long readlong(long handle, long bigendian)</code></strong></span></dt><dd><p>Reads a 4-byte integer from the given file using big-endian (<code class="literal">bigendian</code> = 1) or little-endian (<code class="literal">bigendian</code> = 0) byte order.</p></dd><dt><span class="term"><strong class="userinput"><code>long writeshort(long handle, long val, long bigendian)</code></strong></span></dt><dd><p>Writes a 2-byte integer to the given file using big-endian (<code class="literal">bigendian</code> = 1) or little-endian (<code class="literal">bigendian</code> = 0) byte order.</p></dd><dt><span class="term"><strong class="userinput"><code>long readshort(long handle, long bigendian)</code></strong></span></dt><dd><p>Reads a 2-byte integer from the given file using big-endian (<code class="literal">bigendian</code> = 1) or little-endian (<code class="literal">bigendian</code> = 0) byte order.</p></dd><dt><span class="term"><strong class="userinput"><code>bool loadfile(long handle, long pos, long addr, long length)</code></strong></span></dt><dd><p>Reads <code class="literal">length</code> number of bytes from position <code class="literal">pos</code> in the given file and writes those bytes into the database beginning at address <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>bool savefile(long handle, long pos, long addr, long length)</code></strong></span></dt><dd><p>Writes <code class="literal">length</code> number of bytes beginning at database address <code class="literal">addr</code> to position <code class="literal">pos</code> in the given file.</p></dd></dl></div></div><div class="sect2" title="Manipulating Database Names"><div class="titlepage"><div><div><h2 class="title"><a id="manipulating_database_names"/>Manipulating Database Names</h2></div></div></div><p>The need to manipulate named locations arises fairly often in scripts. The following IDC functions are available for working with named locations in an IDA database:<a class="indexterm" id="IDX-CHP-15-0147"/><a class="indexterm" id="IDX-CHP-15-0148"/><a class="indexterm" id="IDX-CHP-15-0149"/><a class="indexterm" id="IDX-CHP-15-0150"/><a class="indexterm" id="IDX-CHP-15-0151"/><a class="indexterm" id="IDX-CHP-15-0152"/><a class="indexterm" id="IDX-CHP-15-0153"/><a class="indexterm" id="IDX-CHP-15-0154"/><a class="indexterm" id="IDX-CHP-15-0155"/><a class="indexterm" id="IDX-CHP-15-0156"/><a class="indexterm" id="IDX-CHP-15-0157"/><a class="indexterm" id="IDX-CHP-15-0158"/><a class="indexterm" id="IDX-CHP-15-0159"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>string Name(long addr)</code></strong></span></dt><dd><p>Returns the name associated with the given address or returns the empty string if the location has no name. This function does not return user-assigned names when the names are marked as local.</p></dd><dt><span class="term"><strong class="userinput"><code>string NameEx(long from, long addr)</code></strong></span></dt><dd><p>Returns the name associated with <code class="literal">addr</code>. Returns the empty string if the location has no name. This function returns user-defined local names if <code class="literal">from</code> is any address within a function that also contains <code class="literal">addr</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>bool MakeNameEx(long addr, string name, long flags)</code></strong></span></dt><dd><p>Assigns the given name to the given address. The name is created with attributes specified in the <code class="literal">flags</code> bitmask. These flags are described in the help file documentation for <code class="literal">MakeNameEx</code> and are used to specify attributes such as whether the name is local or public or whether it should be listed in the names window.</p></dd><dt><span class="term"><strong class="userinput"><code>long LocByName(string name)</code></strong></span></dt><dd><p>Returns the address of the location with the given name. Returns BADADDR (−1) if no such name exists in the database.</p></dd><dt><span class="term"><strong class="userinput"><code>long LocByNameEx(long funcaddr, string localname)</code></strong></span></dt><dd><p>Searches for the given local name within the function containing <code class="literal">funcaddr</code>. Returns BADADDR (−1) if no such name exists in the given function.</p></dd></dl></div></div><div class="sect2" title="Functions Dealing with Functions"><div class="titlepage"><div><div><h2 class="title"><a id="functions_dealing_with_functions"/>Functions Dealing with Functions</h2></div></div></div><p>Many scripts are designed to perform analysis of functions within a database. IDA assigns disassembled functions a number of attributes, such as the size of the function’s local variable area or the size of the function’s arguments on the runtime stack. The following IDC functions can be used to access information about functions within a database.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long GetFunctionAttr(long addr, long attrib)</code></strong></span></dt><dd><p>Returns the requested attribute for the function containing the given address. Refer to the IDC help documentation for a list of attribute constants. As an example, to find the ending address of a function, use <strong class="userinput"><code>GetFunctionAttr(addr, FUNCATTR_END);</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>string GetFunctionName(long addr)</code></strong></span></dt><dd><p>Returns the name of the function that contains the given address or an empty string if the given address does not belong to a function.</p></dd><dt><span class="term"><strong class="userinput"><code>long NextFunction(long addr)</code></strong></span></dt><dd><p>Returns the starting address of the next function following the given address. Returns −1 if there are no more functions in the database.</p></dd><dt><span class="term"><strong class="userinput"><code>long PrevFunction(long addr)</code></strong></span></dt><dd><p>Returns the starting address of the nearest function that precedes the given address. Returns −1 if no function precedes the given address.<a class="indexterm" id="IDX-CHP-15-0160"/><a class="indexterm" id="IDX-CHP-15-0161"/><a class="indexterm" id="IDX-CHP-15-0162"/><a class="indexterm" id="IDX-CHP-15-0163"/><a class="indexterm" id="IDX-CHP-15-0164"/><a class="indexterm" id="IDX-CHP-15-0165"/><a class="indexterm" id="IDX-CHP-15-0166"/><a class="indexterm" id="IDX-CHP-15-0167"/><a class="indexterm" id="IDX-CHP-15-0168"/></p></dd></dl></div><p>Use the <code class="literal">LocByName</code> function to find the starting address of a function given the function’s name.</p></div><div class="sect2" title="Code Cross-Reference Functions"><div class="titlepage"><div><div><h2 class="title"><a id="code_cross-reference_functions"/>Code Cross-Reference Functions</h2></div></div></div><p>Cross-references were covered in <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>. IDC offers functions for accessing cross-reference information associated with any instruction. Deciding which functions meet the needs of your scripts can be a bit confusing. It requires you to understand whether you are interested in following the flows leaving a given address or whether you are interested in iterating over all of the locations that refer to a given address. Functions for performing both of the preceding operations are described here. Several of these functions are designed to support iteration over a set of cross-references. Such functions support the notion of a sequence of cross-references and require a <code class="literal">current</code> cross-reference in order to return a <code class="literal">next</code> cross-reference. Examples of using cross-reference iterators are provided in <a class="xref" href="ch15s05.html#enumerating_cross-references" title="Enumerating Cross-References">Enumerating Cross-References</a> in <a class="xref" href="ch15s05.html#enumerating_cross-references" title="Enumerating Cross-References">Enumerating Cross-References</a>.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long Rfirst(long from)</code></strong></span></dt><dd><p>Returns the first location to which the given address transfers control. Returns BADADDR (−1) if the given address refers to no other address.</p></dd><dt><span class="term"><strong class="userinput"><code>long Rnext(long from, long current)</code></strong></span></dt><dd><p>Returns the next location to which the given address (<code class="literal">from</code>) transfers control, given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">Rfirst</code> or <code class="literal">Rnext</code>. Returns BADADDR if no more cross-references exist.</p></dd><dt><span class="term"><strong class="userinput"><code>long XrefType()</code></strong></span></dt><dd><p>Returns a constant indicating the type of the last cross-reference returned by a cross-reference lookup function such as <code class="literal">Rfirst</code>. For code cross-references, these constants are <code class="literal">fl_CN</code> (near call), <code class="literal">fl_CF</code> (far call), <code class="literal">fl_JN</code> (near jump), <code class="literal">fl_JF</code> (far jump), and <code class="literal">fl_F</code> (ordinary sequential flow).<a class="indexterm" id="IDX-CHP-15-0169"/><a class="indexterm" id="IDX-CHP-15-0170"/><a class="indexterm" id="IDX-CHP-15-0171"/></p></dd><dt><span class="term"><strong class="userinput"><code>long RfirstB(long to)</code></strong></span></dt><dd><p>Returns the first location that transfers control to the given address. Returns BADADDR (−1) if there are no references to the given address.</p></dd><dt><span class="term"><strong class="userinput"><code>long RnextB(long to, long current)</code></strong></span></dt><dd><p>Returns the next location that transfers control to the given address (<code class="literal">to</code>), given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">RfirstB</code> or <code class="literal">RnextB</code>. Returns BADADDR if no more cross-references to the given location exist.</p></dd></dl></div><p>Each time a cross-reference function is called, an internal IDC state variable is set that indicates the type of the last cross-reference that was returned. If you need to know what type of cross-reference you have received, then you must call <code class="literal">XrefType</code> prior to calling another cross-reference lookup function.</p></div><div class="sect2" title="Data Cross-Reference Functions"><div class="titlepage"><div><div><h2 class="title"><a id="data_cross-reference_functions"/>Data Cross-Reference Functions</h2></div></div></div><p>The functions for accessing data cross-reference information are very similar to the functions used to access code cross-reference information. These functions are described here:<a class="indexterm" id="IDX-CHP-15-0172"/><a class="indexterm" id="IDX-CHP-15-0173"/><a class="indexterm" id="IDX-CHP-15-0174"/><a class="indexterm" id="IDX-CHP-15-0175"/><a class="indexterm" id="IDX-CHP-15-0176"/><a class="indexterm" id="IDX-CHP-15-0177"/><a class="indexterm" id="IDX-CHP-15-0178"/><a class="indexterm" id="IDX-CHP-15-0179"/><a class="indexterm" id="IDX-CHP-15-0180"/><a class="indexterm" id="IDX-CHP-15-0181"/><a class="indexterm" id="IDX-CHP-15-0182"/><a class="indexterm" id="IDX-CHP-15-0183"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long Dfirst(long from)</code></strong></span></dt><dd><p>Returns the first location to which the given address refers to a data value. Returns BADADDR (−1) if the given address refers to no other addresses.</p></dd><dt><span class="term"><strong class="userinput"><code>long Dnext(long from, long current)</code></strong></span></dt><dd><p>Returns the next location to which the given address (<code class="literal">from</code>) refers a data value, given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">Dfirst</code> or <code class="literal">Dnext</code>. Returns BADADDR if no more cross-references exist.</p></dd><dt><span class="term"><strong class="userinput"><code>long XrefType()</code></strong></span></dt><dd><p>Returns a constant indicating the type of the last cross-reference returned by a cross-reference lookup function such as <code class="literal">Dfirst</code>. For data cross-references, these constants include <code class="literal">dr_O</code> (offset taken), <code class="literal">dr_W</code> (data write), and <code class="literal">dr_R</code> (data read).</p></dd><dt><span class="term"><strong class="userinput"><code>long DfirstB(long to)</code></strong></span></dt><dd><p>Returns the first location that refers to the given address as data. Returns BADADDR (−1) if there are no references to the given address.</p></dd><dt><span class="term"><strong class="userinput"><code>long DnextB(long to, long current)</code></strong></span></dt><dd><p>Returns the next location that refers to the given address (<code class="literal">to</code>) as data, given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">DfirstB</code> or <code class="literal">DnextB</code>. Returns BADADDR if no more cross-references to the given location exist.</p></dd></dl></div><p>As with code cross-references, if you need to know what type of cross-reference you have received, then you must call <code class="literal">XrefType</code> prior to calling another cross-reference lookup function.</p></div><div class="sect2" title="Database Manipulation Functions"><div class="titlepage"><div><div><h2 class="title"><a id="database_manipulation_functions"/>Database Manipulation Functions</h2></div></div></div><p>A number of functions exist for formatting the contents of a database. Here are descriptions of a few of these functions:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>void MakeUnkn(long addr, long flags)</code></strong></span></dt><dd><p>Undefines the item at the specified address. The flags (see the IDC documentation for <code class="literal">MakeUnkn</code>) dictate whether subsequent items will also be undefined and whether any names associated with undefined items will be deleted. Related function <code class="literal">MakeUnknown</code> allows you to undefine large blocks of data.</p></dd><dt><span class="term"><strong class="userinput"><code>long MakeCode(long addr)</code></strong></span></dt><dd><p>Converts the bytes at the specified address into an instruction. Returns the length of the instruction or 0 if the operation fails.</p></dd><dt><span class="term"><strong class="userinput"><code>bool MakeByte(long addr)</code></strong></span></dt><dd><p>Converts the item at the specified address into a data byte. <code class="literal">MakeWord</code> and <code class="literal">MakeDword</code> are also available.<a class="indexterm" id="IDX-CHP-15-0184"/><a class="indexterm" id="IDX-CHP-15-0185"/><a class="indexterm" id="IDX-CHP-15-0186"/><a class="indexterm" id="IDX-CHP-15-0187"/><a class="indexterm" id="IDX-CHP-15-0188"/><a class="indexterm" id="IDX-CHP-15-0189"/><a class="indexterm" id="IDX-CHP-15-0190"/><a class="indexterm" id="IDX-CHP-15-0191"/><a class="indexterm" id="IDX-CHP-15-0192"/><a class="indexterm" id="IDX-CHP-15-0193"/><a class="indexterm" id="IDX-CHP-15-0194"/><a class="indexterm" id="IDX-CHP-15-0195"/><a class="indexterm" id="IDX-CHP-15-0196"/></p></dd><dt><span class="term"><strong class="userinput"><code>bool MakeComm(long addr, string comment)</code></strong></span></dt><dd><p>Adds a regular comment at the given address.</p></dd><dt><span class="term"><strong class="userinput"><code>bool MakeFunction(long begin, long end)</code></strong></span></dt><dd><p>Converts the range of instructions from <code class="literal">begin</code> to <code class="literal">end</code> into a function. If <code class="literal">end</code> is specified as <code class="literal">BADADDR (-1)</code>, IDA attempts to automatically identify the end of the function by locating the function’s return instruction.</p></dd><dt><span class="term"><strong class="userinput"><code>bool MakeStr(long begin, long end)</code></strong></span></dt><dd><p>Creates a string of the current string type (as returned by <code class="literal">GetStringType</code>), spanning the bytes from <code class="literal">begin</code> to <code class="literal">end - 1</code>. If <code class="literal">end</code> is specified as <code class="literal">BADADDR</code>, IDA attempts to automatically identify the end of the string.</p></dd></dl></div><p>Many other <code class="literal">Make</code><em class="replaceable"><code>XXX</code></em> functions exist that offer behavior similar to the functions just described. Please refer to the IDC documentation for a full list of these functions.</p></div><div class="sect2" title="Database Search Functions"><div class="titlepage"><div><div><h2 class="title"><a id="database_search_functions"/>Database Search Functions</h2></div></div></div><p>The majority of IDA’s search capabilities are accessible in IDC in the form of various <code class="literal">Find</code><em class="replaceable"><code>XXX</code></em> functions, some of which are described here. The <code class="literal">flags</code> parameter used in the <code class="literal">Find</code><em class="replaceable"><code>XXX</code></em> functions is a bitmask that specifies the behavior of the find operation. Three of the more useful flags are <code class="literal">SEARCH_DOWN</code>, which causes the search to scan toward higher addresses; <code class="literal">SEARCH_NEXT</code>, which skips the current occurrence in order to search for the next occurrence; and <code class="literal">SEARCH_CASE</code>, which causes binary and text searches to be performed in a case-sensitive manner.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>long FindCode(long addr, long flags)</code></strong></span></dt><dd><p>Searches for an instruction from the given address.</p></dd><dt><span class="term"><strong class="userinput"><code>long FindData(long addr, long flags)</code></strong></span></dt><dd><p>Searches for a data item from the given address.</p></dd><dt><span class="term"><strong class="userinput"><code>long FindBinary(long addr, long flags, string binary)</code></strong></span></dt><dd><p>Searches for a sequence of bytes from the given address. The <code class="literal">binary</code> string specifies a sequence of hexadecimal byte values. If <code class="literal">SEARCH_CASE</code> is not specified and a byte value specifies an uppercase or lowercase ASCII letter, then the search will also match corresponding, complementary case values. For example, “41 42” will match “61 62” (and “61 42”) unless the <code class="literal">SEARCH_CASE</code> flag is set.</p></dd><dt><span class="term"><strong class="userinput"><code>long FindText(long addr, long flags, long row, long column, string text)</code></strong></span></dt><dd><p>Searches for a <code class="literal">text</code> string from the given <code class="literal">column</code> on the given line (<code class="literal">row</code>) at the given address. Note that the disassembly text at a given address may span several lines, hence the need to specify on which line the search should begin.</p></dd></dl></div><p>Also note that <code class="literal">SEARCH_NEXT</code> does not define the direction of search, which may be either up or down according to the <code class="literal">SEARCH_DOWN</code> flag. In addition, when <code class="literal">SEARCH_NEXT</code> is not specified, it is perfectly reasonable for a <code class="literal">Find</code><em class="replaceable"><code>XXX</code></em> function to return the same address that was passed in as the <code class="literal">addr</code> argument when the item at <code class="literal">addr</code> satisfies the search.<a class="indexterm" id="IDX-CHP-15-0197"/><a class="indexterm" id="IDX-CHP-15-0198"/><a class="indexterm" id="IDX-CHP-15-0199"/><a class="indexterm" id="IDX-CHP-15-0200"/><a class="indexterm" id="IDX-CHP-15-0201"/><a class="indexterm" id="IDX-CHP-15-0202"/><a class="indexterm" id="IDX-CHP-15-0203"/><a class="indexterm" id="IDX-CHP-15-0204"/><a class="indexterm" id="IDX-CHP-15-0205"/><a class="indexterm" id="IDX-CHP-15-0206"/><a class="indexterm" id="IDX-CHP-15-0207"/><a class="indexterm" id="IDX-CHP-15-0208"/><a class="indexterm" id="IDX-CHP-15-0209"/></p></div><div class="sect2" title="Disassembly Line Components"><div class="titlepage"><div><div><h2 class="title"><a id="disassembly_line_components"/>Disassembly Line Components</h2></div></div></div><p>From time to time it is useful to extract the text, or portions of the text, of individual lines in a disassembly listing. The following functions provide access to various components of a disassembly line:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>string GetDisasm(long addr)</code></strong></span></dt><dd><p>Returns disassembly text for the given address. The returned text includes any comments but does not include address information.</p></dd><dt><span class="term"><strong class="userinput"><code>string GetMnem(long addr)</code></strong></span></dt><dd><p>Returns the mnemonic portion of the instruction at the given address.</p></dd><dt><span class="term"><strong class="userinput"><code>string GetOpnd(long addr, long opnum)</code></strong></span></dt><dd><p>Returns the text representation of the specified operand at the specified address. Operands are numbered from zero beginning with the leftmost operand.</p></dd><dt><span class="term"><strong class="userinput"><code>long GetOpType(long addr, long opnum)</code></strong></span></dt><dd><p>Returns an integer representing the type for the given operand at the given address. Refer to the IDC documentation for <code class="literal">GetOpType</code> for a complete list of operand type codes.</p></dd><dt><span class="term"><strong class="userinput"><code>long GetOperandValue(long addr, long opnum)</code></strong></span></dt><dd><p>Returns the integer value associated with the given operand at the given address. The nature of the returned value depends on the type of the given operand as specified by <code class="literal">GetOpType</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>string CommentEx(long addr, long type)</code></strong></span></dt><dd><p>Returns the text of any comment present at the given address. If <code class="literal">type</code> is 0, the text of the regular comment is returned. If <code class="literal">type</code> is 1, the text of the repeatable comment is returned. If no comment is present at the given address, an empty string is returned.</p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-8" id="ftn.CHP-15-FN-8">102</a>] </sup>The support forum is currently located at <a class="ulink" href="http://www.hex-rays.com/forum/">http://www.hex-rays.com/forum/</a></p></div></div></div>
<div class="sect1" title="IDC Scripting Examples"><div class="titlepage"><div><div><h1 class="title"><a id="idc_scripting_examples"/>IDC Scripting Examples</h1></div></div></div><p>At this point it is probably useful to see some examples of scripts that perform specific tasks. For the remainder of the chapter we present some fairly common situations in which a script can be used to answer a question about a database.<a class="indexterm" id="IDX-CHP-15-0210"/></p><div class="sect2" title="Enumerating Functions"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_functions"/>Enumerating Functions</h2></div></div></div><p>Many scripts operate on individual functions. Examples include generating the call tree rooted at a specific function, generating the control flow graph of a function, or analyzing the stack frames of every function in a database. <a class="xref" href="ch15s05.html#function_enumeration_script" title="Example 15-1. Function enumeration script">Example 15-1</a> iterates through every function in a database and prints basic information about each function, including the start and end addresses of the function, the size of the function’s arguments, and the size of the function’s local variables. All output is sent to the output window.<a class="indexterm" id="IDX-CHP-15-0211"/><a class="indexterm" id="IDX-CHP-15-0212"/><a class="indexterm" id="IDX-CHP-15-0213"/></p><div class="example"><a id="function_enumeration_script"/><p class="title">Example 15-1. Function enumeration script</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;
static main() {
   auto addr, end, args, locals, frame, firstArg, name, ret;
   addr = 0;
   for (addr = NextFunction(addr); addr != BADADDR; addr = NextFunction(addr)) {
      name = Name(addr);
      end = GetFunctionAttr(addr, FUNCATTR_END);
      locals = GetFunctionAttr(addr, FUNCATTR_FRSIZE);
      frame = GetFrame(addr);     // retrieve a handle to the function's stack frame
      ret = GetMemberOffset(frame, " r");  // " r" is the name of the return address
      if (ret == −1) continue;
      firstArg = ret + 4;
      args = GetStrucSize(frame) - firstArg;
      Message("Function: %s, starts at %x, ends at %x\n", name, addr, end);
      Message("   Local variable area is %d bytes\n", locals);
      Message("   Arguments occupy %d bytes (%d args)\n", args, args / 4);
   }
}</pre></div></div><p>This script uses some of IDC’s structure-manipulation functions to obtain a handle to each function’s stack frame (<code class="literal">GetFrame</code>), determine the size of the stack frame (<code class="literal">GetStrucSize</code>), and determine the offset of the saved return address within the frame (<code class="literal">GetMemberOffset</code>). The first argument to the function lies 4 bytes beyond the saved return address. The size of the function’s argument area is computed as the space between the first argument and the end of the stack frame. Since IDA can’t generate stack frames for imported functions, this script tests whether the function’s stack frame contains a saved return address as a simple means of identifying calls to an imported function.<a class="indexterm" id="IDX-CHP-15-0214"/></p></div><div class="sect2" title="Enumerating Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_instructions"/>Enumerating Instructions</h2></div></div></div><p>Within a given function, you may want to enumerate every instruction. <a class="xref" href="ch15s05.html#instruction_enumeration_script" title="Example 15-2. Instruction enumeration script">Example 15-2</a> counts the number of instructions contained in the function identified by the current cursor position:</p><div class="example"><a id="instruction_enumeration_script"/><p class="title">Example 15-2. Instruction enumeration script</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;
  static main() {
     auto func, end, count, inst;
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    func = GetFunctionAttr(ScreenEA(), FUNCATTR_START);
     if (func != −1) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>       end = GetFunctionAttr(func, FUNCATTR_END);
        count = 0;
        inst = func;
        while (inst &lt; end) {
             count++;
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>          inst = FindCode(inst, SEARCH_DOWN | SEARCH_NEXT);
        }
        Warning("%s contains %d instructions\n", Name(func), count);
     }
     else {
        Warning("No function found at location %x", ScreenEA());
     }
  }</pre></div></div><p>The function begins <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e20924"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> by using <code class="literal">GetFunctionAttr</code> to determine the start address of the function containing the cursor address (<code class="literal">ScreenEA()</code>). If the beginning of a function is found, the next step <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e20936"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> is to determine the end address for the function, once again using the <code class="literal">GetFunctionAttr</code> function. Once the function has been bounded, a loop is executed to step through successive instructions in the function by using the search functionality of the <code class="literal">FindCode</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e20949"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. In this example, the <code class="literal">Warning</code> function is used to display results, since only a single line of output will be generated by the function and output displayed in a Warning dialog is much more obvious than output generated in the message window. Note that this example assumes that all of the instructions within the given function are contiguous. An alternative approach might replace the use of <code class="literal">FindCode</code> with logic to iterate over all of the code cross-references for each instruction within the function. Properly written, this second approach would handle noncontiguous, also known as “chunked,” functions.<a class="indexterm" id="IDX-CHP-15-0215"/><a class="indexterm" id="IDX-CHP-15-0216"/><a class="indexterm" id="IDX-CHP-15-0217"/><a class="indexterm" id="IDX-CHP-15-0218"/><a class="indexterm" id="IDX-CHP-15-0219"/><a class="indexterm" id="IDX-CHP-15-0220"/><a class="indexterm" id="IDX-CHP-15-0221"/><a class="indexterm" id="IDX-CHP-15-0222"/></p></div><div class="sect2" title="Enumerating Cross-References"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_cross-references"/>Enumerating Cross-References</h2></div></div></div><p>Iterating through cross-references can be confusing because of the number of functions available for accessing cross-reference data and the fact that code cross-references are bidirectional. In order to get the data you want, you need to make sure you are accessing the proper type of cross-reference for your situation. In our first cross-reference example, shown in <a class="xref" href="ch15s05.html#enumerating_function_calls" title="Example 15-3. Enumerating function calls">Example 15-3</a>, we derive the list of all function calls made within a function by iterating through each instruction in the function to determine if the instruction calls another function. One method of doing this might be to parse the results of <code class="literal">GetMnem</code> to look for <code class="literal">call</code> instructions. This would not be a very portable solution, because the instruction used to call a function varies among CPU types. Second, additional parsing would be required to determine exactly which function was being called. Cross-references avoid each of these difficulties because they are CPU-independent and directly inform us about the target of the cross-reference.</p><div class="example"><a id="enumerating_function_calls"/><p class="title">Example 15-3. Enumerating function calls</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;
static main() {
  auto func, end, target, inst, name, flags, xref;
  flags = SEARCH_DOWN | SEARCH_NEXT;
  func = GetFunctionAttr(ScreenEA(), FUNCATTR_START);
  if (func != −1) {
    name = Name(func);
    end = GetFunctionAttr(func, FUNCATTR_END);
    for (inst = func; inst &lt; end; inst = FindCode(inst, flags)) {
      for (target = Rfirst(inst); target != BADADDR; target = Rnext(inst, target)) {
        xref = XrefType();
        if (xref == fl_CN || xref == fl_CF) {
          Message("%s calls %s from 0x%x\n", name, Name(target), inst);
        }
      }
    }
  }
  else {
    Warning("No function found at location %x", ScreenEA());
  }
}</pre></div></div><p>In this example, we must iterate through each instruction in the function. For each instruction, we must then iterate through each cross-reference from the instruction. We are interested only in cross-references that call other functions, so we must test the return value of <code class="literal">XrefType</code> looking for <code class="literal">fl_CN</code> or <code class="literal">fl_CF</code>-type cross-references. Here again, this particular solution handles only functions whose instructions happen to be contiguous. Given that the script is already iterating over the cross-references from each instruction, it would not take many changes to produce a flow-driven analysis instead of the address-driven analysis seen here.<a class="indexterm" id="IDX-CHP-15-0223"/><a class="indexterm" id="IDX-CHP-15-0224"/><a class="indexterm" id="IDX-CHP-15-0225"/><a class="indexterm" id="IDX-CHP-15-0226"/><a class="indexterm" id="IDX-CHP-15-0227"/></p><p>Another use for cross-references is to determine every location that references a particular location. For example, if we wanted to create a low-budget security analyzer, we might be interested in highlighting all calls to functions such as <code class="literal">strcpy</code> and <code class="literal">sprintf</code>.</p><div class="sidebar"><a id="dangerous_functions"/><p class="title">DANGEROUS FUNCTIONS</p><p>The C functions <code class="literal">strcpy</code> and <code class="literal">sprintf</code> are generally acknowledged as dangerous to use because they allow for unbounded copying into destination buffers. While each may be safely used by programmers who conduct proper checks on the size of source and destination buffers, such checks are all too often forgotten by programmers unaware of the dangers of these functions. The <code class="literal">strcpy</code> function, for example, is declared as follows:</p><a id="I_programlisting1_d1e21061"/><pre class="programlisting">char *strcpy(char *dest, const char *source);</pre><p>The <code class="literal">strcpy</code> function’s defined behavior is to copy all characters up to and including the first null termination character encountered in the source buffer to the given destination buffer (<code class="literal">dest</code>). The fundamental problem is that there is no way to determine, at runtime, the size of any array. In this instance, <code class="literal">strcpy</code> has no means to determine whether the capacity of the destination buffer is sufficient to hold all of the data to be copied from source. Such unchecked copy operations are a major cause of buffer overflow vulnerabilities.</p></div><p>In the example shown in <a class="xref" href="ch15s05.html#enumerating_a_functionas_callers" title="Example 15-4. Enumerating a function’s callers">Example 15-4</a>, we work in reverse to iterate across all of the cross-references <span class="emphasis"><em>to</em></span> (as opposed to <span class="emphasis"><em>from</em></span> in the preceding example) a particular symbol:<a class="indexterm" id="IDX-CHP-15-0228"/><a class="indexterm" id="IDX-CHP-15-0229"/><a class="indexterm" id="IDX-CHP-15-0230"/></p><div class="example"><a id="enumerating_a_functionas_callers"/><p class="title">Example 15-4. Enumerating a function’s callers</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;
  static list_callers(bad_func) {
     auto func, addr, xref, source;
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    func = LocByName(bad_func);
     if (func == BADADDR) {
        Warning("Sorry, %s not found in database", bad_func);
     }
     else {
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>       for (addr
 = RfirstB(func); addr != BADADDR; addr = RnextB(func, addr)) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>         xref = XrefType();
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>         if (xref == fl_CN || xref == fl_CF) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>             source = GetFunctionName(addr);
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>             Message
("%s is called from 0x%x in %s\n", bad_func, addr, source);
           }
        }
     }
  }
  static main() {
     list_callers("_strcpy");
     list_callers("_sprintf");
  }</pre></div></div><p>In this example, the <code class="literal">LocByName</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21140"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> function is used to find the address of a given (by name) bad function. If the function’s address is found, a loop <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21146"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> is executed in order to process all cross-references to the bad function. For each cross-reference, if the cross-reference type <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21152"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> is determined to be a call-type <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21158"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> cross-reference, the calling function’s name is determined <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21165"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> and is displayed to the user <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21171"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>.</p><p>It is important to note that some modifications may be required to perform a proper lookup of the name of an imported function. In ELF executables in particular, which combine a procedure linkage table (PLT) with a global offset table (GOT) to handle the details of linking to shared libraries, the names that IDA assigns to imported functions may be less than clear. For example, a PLT entry may appear to be named <code class="literal">_memcpy</code>, when in fact it is named <code class="literal">.memcpy</code> and IDA has replaced the dot with an underscore because IDA considers dots invalid characters within names. Further complicating matters is the fact that IDA may actually create a symbol named <code class="literal">memcpy</code> that resides in a section that IDA names <code class="literal">extern</code>. When attempting to enumerate cross-references to <code class="literal">memcpy</code>, we are interested in the PLT version of the symbol because this is the version that is called from other functions in the program and thus the version to which all cross-references would refer.<a class="indexterm" id="IDX-CHP-15-0231"/><a class="indexterm" id="IDX-CHP-15-0232"/><a class="indexterm" id="IDX-CHP-15-0233"/></p></div><div class="sect2" title="Enumerating Exported Functions"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_exported_functions"/>Enumerating Exported Functions</h2></div></div></div><p>In <a class="xref" href="ch13.html" title="Chapter 13. Extending IDA’s Knowledge">Chapter 13</a> we discussed the use of <code class="literal">idsutils</code> to generate <span class="emphasis"><em>.ids</em></span> files that describe the contents of shared libraries. Recall that the first step in generating a <span class="emphasis"><em>.ids</em></span> file involves generating a <span class="emphasis"><em>.idt</em></span> file, which is a text file containing descriptions of each exported function contained in the library. IDC contains functions for iterating through the functions that are exported by a shared library. The script shown in <a class="xref" href="ch15s05.html#a_script_to_generate_.idt_files" title="Example 15-5. A script to generate .idt files">Example 15-5</a> can be run to generate an <span class="emphasis"><em>.idt</em></span> file after opening a shared library with IDA:<a class="indexterm" id="IDX-CHP-15-0234"/><a class="indexterm" id="IDX-CHP-15-0235"/><a class="indexterm" id="IDX-CHP-15-0236"/><a class="indexterm" id="IDX-CHP-15-0237"/><a class="indexterm" id="IDX-CHP-15-0238"/><a class="indexterm" id="IDX-CHP-15-0239"/><a class="indexterm" id="IDX-CHP-15-0240"/><a class="indexterm" id="IDX-CHP-15-0241"/><a class="indexterm" id="IDX-CHP-15-0242"/></p><div class="example"><a id="a_script_to_generate_.idt_files"/><p class="title">Example 15-5. A script to generate <span class="emphasis"><em>.idt</em></span> files</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;
static main() {
   auto entryPoints, i, ord, addr, name, purged, file, fd;
   file = AskFile(1, "*.idt", "Select IDT save file");
   fd = fopen(file, "w");
   entryPoints = GetEntryPointQty();
   fprintf(fd, "ALIGNMENT 4\n");
   fprintf(fd, "0 Name=%s\n", GetInputFile());
   for (i = 0; i &lt; entryPoints; i++) {
      ord = GetEntryOrdinal(i);
      if (ord == 0) continue;
      addr = GetEntryPoint(ord);
      if (ord == addr) {
         continue; //entry point has no ordinal
      }
      name = Name(addr);
      fprintf(fd, "%d Name=%s", ord, name);
      purged = GetFunctionAttr(addr, FUNCATTR_ARGSIZE);
      if (purged &gt; 0) {
         fprintf(fd, " Pascal=%d", purged);
      }
      fprintf(fd, "\n");
   }
}</pre></div></div><p>The output of the script is saved to a file chosen by the user. New functions introduced in this script include <code class="literal">GetEntryPointQty</code>, which returns the number of symbols exported by the library; <code class="literal">GetEntryOrdinal</code>, which returns an ordinal number (an index into the library’s export table); <code class="literal">GetEntryPoint</code>, which returns the address associated with an exported function that has been identified by ordinal number; and <code class="literal">GetInputFile</code>, which returns the name of the file that was loaded into IDA.</p></div><div class="sect2" title="Finding and Labeling Function Arguments"><div class="titlepage"><div><div><h2 class="title"><a id="finding_and_labeling_function_arguments"/>Finding and Labeling Function Arguments</h2></div></div></div><p>Versions of GCC later than 3.4 use <code class="literal">mov</code> statements rather than <code class="literal">push</code> statements in x86 binaries to place function arguments into the stack before calling a function. Occasionally this causes some analysis problems for IDA (newer versions of IDA handle this situation better), because the analysis engine relies on finding <code class="literal">push</code> statements to pinpoint locations at which arguments are pushed for a function call. The following listing shows an IDA disassembly when parameters are pushed onto the stack:</p><a id="I_programlisting1_d1e21309"/><pre class="programlisting">.text:08048894                 push    0               ; protocol
.text:08048896                 push    1               ; type
.text:08048898                 push    2               ; domain
.text:0804889A                 call    _socket</pre><p>Note the comments that IDA has placed in the right margin. Such commenting is possible only when IDA recognizes that parameters are being pushed and when IDA knows the signature of the function being called. When <code class="literal">mov</code> statements are used to place parameters onto the stack, the resulting disassembly is somewhat less informative, as shown here:</p><a id="I_programlisting1_d1e21316"/><pre class="programlisting">.text:080487AD                 mov     [esp+8], 0
.text:080487B5                 mov     [esp+4], 1
.text:080487BD                 mov     [esp], 2
.text:080487C4                 call    _socket</pre><p>In this case, IDA has failed to recognize that the three <code class="literal">mov</code> statements preceding the call are being used to set up the parameters for the function call. As a result, we get less assistance from IDA in the form of automatic comments in the disassembly.</p><p>Here we have a situation where a script might be able to restore some of the information that we are accustomed to seeing in our disassemblies. <a class="xref" href="ch15s05.html#automating_parameter_recognition" title="Example 15-6. Automating parameter recognition">Example 15-6</a> is a first effort at automatically recognizing instructions that are setting up parameters for function calls:</p><div class="example"><a id="automating_parameter_recognition"/><p class="title">Example 15-6. Automating parameter recognition</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;
static main() {
  auto addr, op, end, idx;
  auto func_flags, type, val, search;
  search = SEARCH_DOWN | SEARCH_NEXT;
  addr = GetFunctionAttr(ScreenEA(), FUNCATTR_START);
  func_flags = GetFunctionFlags(addr);
  if (func_flags &amp; FUNC_FRAME) {  //Is this an ebp-based frame?
    end = GetFunctionAttr(addr, FUNCATTR_END);
    for (; addr &lt; end &amp;&amp; addr != BADADDR; addr = FindCode(addr, search)) {
      type = GetOpType(addr, 0);
      if (type == 3) {  //Is this a register indirect operand?
        if (GetOperandValue(addr, 0) == 4) {   //Is the register esp?
          MakeComm(addr, "arg_0");  //[esp] equates to arg_0
        }
      }
      else if (type == 4) {  //Is this a register + displacement operand?
        idx = strstr(GetOpnd(addr, 0), "[esp"); //Is the register esp?
        if (idx != −1) {
          val = GetOperandValue(addr, 0);   //get the displacement
          MakeComm(addr, form("arg_%d", val));  //add a comment
        }
      }
    }
  }
}</pre></div></div><p>The script works only on EBP-based frames and relies on the fact that when parameters are moved into the stack prior to a function call, GCC generates memory references relative to <code class="literal">esp</code>. The script iterates through all instructions in a function; for each instruction that writes to a memory location using <code class="literal">esp</code> as a base register, the script determines the depth within the stack and adds a comment indicating which parameter is being moved. The <code class="literal">GetFunctionFlags</code> function offers access to various flags associated with a function, such as whether the function uses an EBP-based stack frame. Running the script in <a class="xref" href="ch15s05.html#automating_parameter_recognition" title="Example 15-6. Automating parameter recognition">Example 15-6</a> yields the annotated disassembly shown here:<a class="indexterm" id="IDX-CHP-15-0243"/><a class="indexterm" id="IDX-CHP-15-0244"/></p><a id="I_programlisting1_d1e21353"/><pre class="programlisting">.text:080487AD                 mov     [esp+8], 0   ; arg_8
.text:080487B5                 mov     [esp+4], 1   ; arg_4
.text:080487BD                 mov     [esp], 2    ; arg_0
.text:080487C4                 call    _socket</pre><p>The comments aren’t particularly informative. However, we can now tell at a glance that the three <code class="literal">mov</code> statements are used to place parameters onto the stack, which is a step in the right direction. By extending the script a bit further and exploring some more of IDC’s capabilities, we can come up with a script that provides almost as much information as IDA does when it properly recognizes parameters. The output of the final product is shown here:</p><a id="I_programlisting1_d1e21361"/><pre class="programlisting">.text:080487AD                 mov     [esp+8], 0   ;  int protocol
.text:080487B5                 mov     [esp+4], 1   ;  int type
.text:080487BD                 mov     [esp], 2    ;  int domain
.text:080487C4                 call    _socket</pre><p>The extended version of the script in <a class="xref" href="ch15s05.html#automating_parameter_recognition" title="Example 15-6. Automating parameter recognition">Example 15-6</a>, which is capable of incorporating data from function signatures into comments, is available on this book’s website.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-9" id="CHP-15-FN-9">103</a>]</sup></p></div><div class="sect2" title="Emulating Assembly Language Behavior"><div class="titlepage"><div><div><h2 class="title"><a id="emulating_assembly_language_behavior"/>Emulating Assembly Language Behavior</h2></div></div></div><p>There are a number of reasons why you might need to write a script that emulates the behavior of a program you are analyzing. For example, the program you are studying may be self-modifying, as many malware programs are, or the program may contain some encoded data that gets decoded when it is needed at runtime. Without running the program and pulling the modified data out of the running process’s memory, how can you understand the behavior of the program? The answer may lie with an IDC script. If the decoding process is not terribly complex, you may be able to quickly write an IDC script that performs the same actions that are performed by the program when it runs. Using a script to decode data in this way eliminates the need to run a program when you don’t know what the program does or you don’t have access to a platform on which you can run the program. An example of the latter case might occur if you were examining a MIPS binary with your Windows version of IDA. Without any MIPS hardware, you would not be able to execute the MIPS binary and observe any data decoding it might perform. You could, however, write an IDC script to mimic the behavior of the binary and make the required changes within the IDA database, all with no need for a MIPS execution environment.<a class="indexterm" id="IDX-CHP-15-0245"/><a class="indexterm" id="IDX-CHP-15-0246"/><a class="indexterm" id="IDX-CHP-15-0247"/><a class="indexterm" id="IDX-CHP-15-0248"/></p><p>The following x86 code was extracted from a DEFCON<sup>[<a class="footnote" href="#ftn.CHP-15-FN-10" id="CHP-15-FN-10">104</a>]</sup> Capture the Flag binary.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-11" id="CHP-15-FN-11">105</a>]</sup><a class="indexterm" id="IDX-CHP-15-0249"/></p><a id="I_programlisting1_d1e21413"/><pre class="programlisting">.text:08049EDE                 mov     [ebp+var_4], 0
.text:08049EE5
.text:08049EE5 loc_8049EE5:
.text:08049EE5                 cmp     [ebp+var_4], 3C1h
.text:08049EEC                 ja      short locret_8049F0D
.text:08049EEE                 mov     edx, [ebp+var_4]
.text:08049EF1                 add     edx, 804B880h
.text:08049EF7                 mov     eax, [ebp+var_4]
.text:08049EFA                 add     eax, 804B880h
.text:08049EFF                 mov     al, [eax]
.text:08049F01                 xor     eax, 4Bh
.text:08049F04                 mov     [edx], al
.text:08049F06                 lea     eax, [ebp+var_4]
.text:08049F09                 inc     dword ptr [eax]
.text:08049F0B                 jmp     short loc_8049EE5</pre><p>This code decodes a private key that has been embedded within the program binary. Using the IDC script shown in <a class="xref" href="ch15s05.html#emulating_assembly_language_with_idc" title="Example 15-7. Emulating assembly language with IDC">Example 15-7</a>, we can extract the private key without running the program:</p><div class="example"><a id="emulating_assembly_language_with_idc"/><p class="title">Example 15-7. Emulating assembly language with IDC</p><div class="example-contents"><pre class="programlisting">auto var_4, edx, eax, al;
var_4 = 0;
while (var_4 &lt;= 0x3C1) {
   edx = var_4;
   edx = edx + 0x804B880;
   eax = var_4;
   eax = eax + 0x804B880;
   al = Byte(eax);
   al = al ^ 0x4B;
   PatchByte(edx, al);
   var_4++;
}</pre></div></div><p><a class="xref" href="ch15s05.html#emulating_assembly_language_with_idc" title="Example 15-7. Emulating assembly language with IDC">Example 15-7</a> is a fairly literal translation of the preceding assembly language sequence generated according to the following rather mechanical rules.<a class="indexterm" id="IDX-CHP-15-0250"/><a class="indexterm" id="IDX-CHP-15-0251"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>For each stack variable and register used in the assembly code, declare an IDC variable.</p></li><li class="listitem"><p>For each assembly language statement, write an IDC statement that mimics its behavior.</p></li><li class="listitem"><p>Reading and writing stack variables is emulated by reading and writing the corresponding variable declared in your IDC script.</p></li><li class="listitem"><p>Reading from a nonstack location is accomplished using the <code class="literal">Byte</code>, <code class="literal">Word</code>, or <code class="literal">Dword</code> function, depending on the amount of data being read (1, 2, or 4 bytes).</p></li><li class="listitem"><p>Writing to a nonstack location is accomplished using the <code class="literal">PatchByte</code>, <code class="literal">PatchWord</code>, or <code class="literal">PatchDword</code> function, depending on the amount of data being written.</p></li><li class="listitem"><p>In general, if the code appears to contain a loop for which the termination condition is not immediately obvious, it is easiest to begin with an infinite loop such as <code class="literal">while (1) {}</code> and then insert a <code class="literal">break</code> statement when you encounter statements that cause the loop to terminate.</p></li><li class="listitem"><p>When the assembly code calls functions, things get complicated. In order to properly simulate the behavior of the assembly code, you must find a way to mimic the behavior of the function that has been called, including providing a return value that makes sense within the context of the code being simulated. This fact alone may preclude the use of IDC as a tool for emulating the behavior of an assembly language sequence.</p></li></ol></div><p>The important thing to understand when developing scripts such as the previous one is that it is not absolutely necessary to fully understand how the code you are emulating behaves on a global scale. It is often sufficient to understand only one or two instructions at a time and generate correct IDC translations for those instructions. If each instruction has been correctly translated into IDC, then the script as a whole should properly mimic the complete functionality of the original assembly code. We can delay further study of the assembly language algorithm until after the IDC script has been completed, at which point we can use the IDC script to enhance our understanding of the underlying assembly. Once we spend some time considering how our example algorithm works, we might shorten the preceding IDC script to the following:<a class="indexterm" id="IDX-CHP-15-0252"/><a class="indexterm" id="IDX-CHP-15-0253"/></p><a id="I_programlisting1_d1e21487"/><pre class="programlisting">auto var_4, addr;
for (var_4 = 0; var_4 &lt;= 0x3C1; var_4++) {
   addr = 0x804B880 + var_4;
   PatchByte(addr, Byte(addr) ^ 0x4B);
}</pre><p>As an alternative, if we did not wish to modify the database in any way, we could replace the <code class="literal">PatchByte</code> function with a call to <code class="literal">Message</code> if we were dealing with ASCII data, or as an alternative we could write the data to a file if we were dealing with binary data.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-9" id="ftn.CHP-15-FN-9">103</a>] </sup>See <a class="ulink" href="http://www.idabook.com/ch15_examples">http://www.idabook.com/ch15_examples</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-10" id="ftn.CHP-15-FN-10">104</a>] </sup>See <a class="ulink" href="http://www.defcon.org/">http://www.defcon.org/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-11" id="ftn.CHP-15-FN-11">105</a>] </sup>Courtesy of Kenshoto, the organizers of CTF at DEFCON 15. Capture the Flag is an annual hacking competition held at DEFCON.</p></div></div></div>
<div class="sect1" title="IDAPython"><div class="titlepage"><div><div><h1 class="title"><a id="idapython"/>IDAPython</h1></div></div></div><p>IDAPython is a plug-in developed by Gergely Erdelyi that integrates a Python interpreter into IDA. Combined with supplied Python bindings, this plug-in allows you to write Python scripts with full access to all of the capabilities of the IDC scripting language. One clear advantage gained with IDAPython is access to Python’s native data-handling capabilities as well as the full range of Python modules. In addition, IDAPython exposes a significant portion of IDA’s SDK functionality, allowing for far more powerful scripting than is possible using IDC. IDAPython has developed quite a following in the IDA community. Ilfak’s blog<sup>[<a class="footnote" href="#ftn.CHP-15-FN-12" id="CHP-15-FN-12">106</a>]</sup> contains numerous interesting examples of problem solving with Python scripts, while questions, answers, and many other useful IDAPython scripts are frequently posted in the forums at OpenRCE.org.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-13" id="CHP-15-FN-13">107</a>]</sup> In addition, third-party tools such as BinNavi<sup>[<a class="footnote" href="#ftn.CHP-15-FN-14" id="CHP-15-FN-14">108</a>]</sup> from Zynamics rely on IDA and IDAPython in order to perform various subtasks required by the tools.<a class="indexterm" id="IDX-CHP-15-0254"/><a class="indexterm" id="IDX-CHP-15-0255"/><a class="indexterm" id="IDX-CHP-15-0256"/></p><p>Since IDA 5.4, Hex-Rays has been including IDAPython as a standard plug-in. Source code for the plug-in is available for download on the IDA-Python project page,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-15" id="CHP-15-FN-15">109</a>]</sup> and API documentation is available on the Hex-Rays website.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-16" id="CHP-15-FN-16">110</a>]</sup> IDA enables the plug-in only when Python is found to be installed on the computer on which you are running IDA. The Windows version of IDA ships with and installs a compatible version of Python,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-17" id="CHP-15-FN-17">111</a>]</sup> while the Linux and OS X versions of IDA leave proper installation of Python up to you. On Linux, the current version of IDA (6.1) looks for Python 2.6. IDAPython is compatible with Python 2.7, and IDA will work just fine if you create symlinks from the required Python 2.6 libraries to your existing Python 2.7 libraries. If you have Python 2.7, a command similar to the following will create the symlink that will make IDA happy:<a class="indexterm" id="IDX-CHP-15-0257"/><a class="indexterm" id="IDX-CHP-15-0258"/><a class="indexterm" id="IDX-CHP-15-0259"/><a class="indexterm" id="IDX-CHP-15-0260"/></p><a id="I_programlisting1_d1e21564"/><pre class="programlisting"># ln -s /usr/lib/libpython2.7.so.1.0 /usr/lib/libpython2.6.so.1</pre><p>OS X users may find that the version of Python that ships with OS X is older than that required by IDA. If this is the case, a suitable Python installer should be downloaded from <a class="ulink" href="http://www.python.org">www.python.org</a>.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-18" id="CHP-15-FN-18">112</a>]</sup></p><div class="sect2" title="Using IDAPython"><div class="titlepage"><div><div><h2 class="title"><a id="using_idapython"/>Using IDAPython</h2></div></div></div><p>IDAPython bridges Python code into IDA by making available three Python modules, each serving a specific purpose. Access to the core IDA API (as exposed via the SDK) is made available with the <code class="literal">idaapi</code> module. All of the functions present in IDC are made available in IDAPython’s <code class="literal">idc</code> module. The third module that ships with IDAPython is <code class="literal">idautils</code>, which provides a number of utility functions, many of which yield Python lists of various database-related objects such as functions or cross-references. Modules <code class="literal">idc</code> and <code class="literal">idautils</code> are automatically imported for all IDAPython scripts. If you need <code class="literal">idaapi</code>, on the other hand, you must import it yourself.</p><p>When using IDAPython, keep in mind that the plug-in embeds a single instance of the Python interpreter into IDA. This interpreter is not destroyed until you close IDA. As a result, you can view all of your scripts and statements as if they are running within a single Python shell session. For example, once you have imported the <code class="literal">idaapi</code> module for the first time in your IDA session, you need never import it again until you restart IDA. Similarly, initialized variables and function definitions retain their values until they are redefined or until you quit IDA.</p><p>There are a number of strategies for learning IDA’s Python API. If you already have some experience using IDC or programming with the IDA SDK, then you should feel right at home with the <code class="literal">idaapi</code> and <code class="literal">idc</code> modules. A quick review of the additional features in the <code class="literal">idautils</code> module should be all you really need to start making full use of IDAPython. If you have prior experience with IDC or the SDK, then you might dive into the Hex-Ray’s documentation for the Python API to develop a feel for the capabilities it offers. Remember that the <code class="literal">idc</code> module basically mirrors the IDC API and that you may find the list of IDC functions in IDA’s built-in help to be quite useful. Similarly, the descriptions of IDC functions presented earlier in this chapter are equally applicable to the corresponding functions in the <code class="literal">idc</code> module.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-12" id="ftn.CHP-15-FN-12">106</a>] </sup>See <a class="ulink" href="http://www.hexblog.com">http://www.hexblog.com</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-13" id="ftn.CHP-15-FN-13">107</a>] </sup>See <a class="ulink" href="http://www.openrce.org/articles/">http://www.openrce.org/articles/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-14" id="ftn.CHP-15-FN-14">108</a>] </sup>See <a class="ulink" href="http://www.zynamics.com/binnavi.html">http://www.zynamics.com/binnavi.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-15" id="ftn.CHP-15-FN-15">109</a>] </sup>See <a class="ulink" href="http://code.google.com/p/idapython/">http://code.google.com/p/idapython/</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-16" id="ftn.CHP-15-FN-16">110</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/idapython_docs/index.html">http://www.hex-rays.com/idapro/idapython_docs/index.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-17" id="ftn.CHP-15-FN-17">111</a>] </sup>See <a class="ulink" href="http://www.python.org/">http://www.python.org/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-18" id="ftn.CHP-15-FN-18">112</a>] </sup>See <a class="ulink" href="http://www.python.org/download/mac/">http://www.python.org/download/mac/</a></p></div></div></div>
<div class="sect1" title="IDAPython Scripting Examples"><div class="titlepage"><div><div><h1 class="title"><a id="idapython_scripting_examples"/>IDAPython Scripting Examples</h1></div></div></div><p>By way of offering a compare and contrast between IDC and IDAPython, the following sections present the same example cases seen previously in the discussion of IDC. Wherever possible we endeavor to make maximum use of Python-specific features to demonstrate some of the efficiencies that can be gained by scripting in Python.<a class="indexterm" id="IDX-CHP-15-0261"/><a class="indexterm" id="IDX-CHP-15-0262"/><a class="indexterm" id="IDX-CHP-15-0263"/><a class="indexterm" id="IDX-CHP-15-0264"/></p><div class="sect2" title="Enumerating Functions"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_functions-id1"/>Enumerating Functions</h2></div></div></div><p>One of the strengths of IDAPython is the way that it uses Python’s powerful datatypes to simplify access to collections of database objects. In <a class="xref" href="ch15s07.html#function_enumeration_using_python" title="Example 15-8. Function enumeration using Python">Example 15-8</a>, we reimplement the function enumeration script of <a class="xref" href="ch15s05.html#function_enumeration_script" title="Example 15-1. Function enumeration script">Example 15-1</a> in Python. Recall that the purpose of this script is to iterate over every function in a database and print basic information about each function, including the start and end addresses of the function, the size of the function’s arguments, and the size of the function’s local variable space. All output is sent to the output window.</p><div class="example"><a id="function_enumeration_using_python"/><p class="title">Example 15-8. Function enumeration using Python</p><div class="example-contents"><pre class="programlisting">funcs = Functions()<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>
for f in funcs:<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>
   name = Name(f)
   end = GetFunctionAttr(f, FUNCATTR_END)
   locals = GetFunctionAttr(f, FUNCATTR_FRSIZE)
   frame = GetFrame(f)     # retrieve a handle to the function's stack frame
   if frame is None: continue
   ret = GetMemberOffset(frame, " r")  # " r" is the name of the return address
   if ret == −1: continue
   firstArg = ret + 4
   args = GetStrucSize(frame) - firstArg
   Message("Function: %s, starts at %x, ends at %x\n" % (name, f, end))
   Message("   Local variable area is %d bytes\n" % locals)
   Message("   Arguments occupy %d bytes (%d args)\n" % (args, args / 4))</pre></div></div><p>For this particular script, the use of Python gains us little in the way of efficiency other than the use of the <code class="literal">Functions</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21679"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> list generator, which facilitates the <code class="literal">for</code> loop at <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21688"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>.</p></div><div class="sect2" title="Enumerating Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_instructions-id1"/>Enumerating Instructions</h2></div></div></div><p><a class="xref" href="ch15s07.html#instruction_enumeration_in_python" title="Example 15-9. Instruction enumeration in Python">Example 15-9</a> demonstrates how the instruction-counting script of <a class="xref" href="ch15s05.html#instruction_enumeration_script" title="Example 15-2. Instruction enumeration script">Example 15-2</a> might be written in Python, taking advantage of the list generators available in the <code class="literal">idautils</code> module.</p><div class="example"><a id="instruction_enumeration_in_python"/><p class="title">Example 15-9. Instruction enumeration in Python</p><div class="example-contents"><pre class="programlisting">from idaapi import *
func = get_func(here())<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  # here() is synonymous with ScreenEA()
if not func is None:
   fname = Name(func.startEA)
   count = 0
   for i in FuncItems(func.startEA)<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>: count = count + 1
   Warning("%s contains %d instructions\n" % (fname,count))
else:
   Warning("No function found at location %x" % here())</pre></div></div><p>Differences from the IDC version include the use of an SDK function <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21724"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> (accessed via <code class="literal">idaapi</code>) to retrieve a reference to a function object (specifically a <code class="literal">func_t</code>) and the use of the <code class="literal">FuncItems</code> generator <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21739"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> (from <code class="literal">idautils</code>) to provide easy iteration over all of the instructions within the function. Because we can’t use Python’s <code class="literal">len</code> function on a generator, we are still obligated to step through the generator list in order to count each instruction one at a time.<a class="indexterm" id="IDX-CHP-15-0265"/><a class="indexterm" id="IDX-CHP-15-0266"/><a class="indexterm" id="IDX-CHP-15-0267"/><a class="indexterm" id="IDX-CHP-15-0268"/><a class="indexterm" id="IDX-CHP-15-0269"/><a class="indexterm" id="IDX-CHP-15-0270"/><a class="indexterm" id="IDX-CHP-15-0271"/></p></div><div class="sect2" title="Enumerating Cross-References"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_cross-references-id1"/>Enumerating Cross-References</h2></div></div></div><p>The <code class="literal">idautils</code> module contains several generator functions that build cross-reference lists in a somewhat more intuitive way than we saw in IDC. <a class="xref" href="ch15s07.html#enumerating_function_calls_using_python" title="Example 15-10. Enumerating function calls using Python">Example 15-10</a> rewrites the function call enumeration script that we saw previously in <a class="xref" href="ch15s05.html#enumerating_function_calls" title="Example 15-3. Enumerating function calls">Example 15-3</a>.</p><div class="example"><a id="enumerating_function_calls_using_python"/><p class="title">Example 15-10. Enumerating function calls using Python</p><div class="example-contents"><pre class="programlisting">from idaapi import *
func = get_func(here())
if not func is None:
   fname = Name(func.startEA)
   items = FuncItems(func.startEA)
   for i in items:
      for xref in XrefsFrom(i, 0):<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>
         if xref.type == fl_CN or xref.type == fl_CF:
            Message("%s calls %s from 0x%x\n" % (fname, Name(xref.to), i))
else:
   Warning("No function found at location %x" % here())</pre></div></div><p>New in this script is the use of the <code class="literal">XrefsFrom</code> generator <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e21809"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> (from <code class="literal">idautils</code>) to step through all cross-references from the current instruction. <code class="literal">XrefsFrom</code> returns a reference to an <code class="literal">xrefblk_t</code> object that contains detailed information about the current cross-reference.</p></div><div class="sect2" title="Enumerating Exported Functions"><div class="titlepage"><div><div><h2 class="title"><a id="enumerating_exported_functions-id1"/>Enumerating Exported Functions</h2></div></div></div><p><a class="xref" href="ch15s07.html#a_python_script_to_generate_idt_files" title="Example 15-11. A Python script to generate IDT files">Example 15-11</a> is the Python version of the <span class="emphasis"><em>.idt</em></span> generator script from <a class="xref" href="ch15s05.html#a_script_to_generate_.idt_files" title="Example 15-5. A script to generate .idt files">Example 15-5</a>.</p><div class="example"><a id="a_python_script_to_generate_idt_files"/><p class="title">Example 15-11. A Python script to generate IDT files</p><div class="example-contents"><pre class="programlisting">file = AskFile(1, "*.idt", "Select IDT save file")
with open(file, 'w') as fd:
   fd.write("ALIGNMENT 4\n")
   fd.write("0 Name=%s\n" % GetInputFile())
   for i in range(GetEntryPointQty()):
      ord = GetEntryOrdinal(i)
      if ord == 0: continue
      addr = GetEntryPoint(ord)
      if ord == addr: continue   #entry point has no ordinal
      fd.write("%d Name=%s" % (ord, Name(addr)))
      purged = GetFunctionAttr(addr, FUNCATTR_ARGSIZE)
      if purged &gt; 0:
         fd.write(" Pascal=%d" % purged)
      fd.write("\n")</pre></div></div><p>The two scripts look remarkably similar because IDAPython has no generator function for entry-point lists, so we are left to use the same set of functions that were used in <a class="xref" href="ch15s05.html#a_script_to_generate_.idt_files" title="Example 15-5. A script to generate .idt files">Example 15-5</a>. One difference worth noting is that IDAPython deprecates IDC’s file-handling functions in favor of Python’s built-in file-handling functions.</p></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id14"/>Summary</h1></div></div></div><p>Scripting provides a powerful means for extending IDA’s capabilities. Through the years, scripts have been used in a number of innovative ways to fill the needs of IDA users. Many useful scripts are available for download on the Hex-Rays website as well as the mirror site of the former IDA Palace.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-19" id="CHP-15-FN-19">113</a>]</sup> IDA scripts are perfect for small tasks and rapid development, but they are not ideally suited for all situations.</p><p>One of the principal limitations of the IDC language is its lack of support for complex datatypes and the lack of access to a more fully featured API such as the C standard library or the Windows API. At the expense of greater complexity, we can lift these limitations by moving away from scripted extensions and toward compiled extensions. As we will show in the next chapter, compiled extensions require the use of the IDA software development kit (SDK), which has a steeper learning curve than either IDC or IDAPython. However, the power available when developing extensions with the SDK is usually well worth the effort spent learning how to use it.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-19" id="ftn.CHP-15-FN-19">113</a>] </sup>See <a class="ulink" href="http://old.idapalace.net/">http://old.idapalace.net/</a>.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;16.&#xA0;The IDA Software Development Kit"><div class="titlepage"><div><div><h1 class="title"><a id="the_ida_software_development_kit"/>Chapter 16. The IDA Software Development Kit</h1></div></div></div><p>Throughout the course of the book, we have used phrases like “IDA does this,” and “IDA does that.” While IDA certainly does an awful lot for us, the intelligence is more correctly attributed to the various modules upon which IDA relies. For example, it is the processor module that makes all of the decisions during the analysis phase, so one could argue that IDA is only as smart as the processor modules on which it relies. Of course, Hex-Rays puts tremendous effort into ensuring that its processor modules are as capable as possible, and for the casual user, IDA neatly hides its modular architecture beneath its user interface.<a class="indexterm" id="IDX-CHP-16-0001"/></p><p>At some point you may find yourself needing more power than the IDC scripting language has to offer, whether for performance reasons or because you wish to do things that IDC simply was not designed to do. When that moment arrives, it is time to advance to using IDA’s <span class="emphasis"><em>software development kit (SDK)</em></span> to build your own compiled modules for use with IDA.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The IDC scripting engine is built on top of IDA’s SDK. All IDC functions are ultimately translated to calls to one or more SDK functions that perform the actual work. While it is true that if you can do something in IDC, you can do the same thing using the SDK, the reverse does not hold. The SDK offers far more power than is available using IDC alone, and many SDK actions have no IDC counterpart.<a class="indexterm" id="IDX-CHP-16-0002"/><a class="indexterm" id="IDX-CHP-16-0003"/><a class="indexterm" id="IDX-CHP-16-0004"/><a class="indexterm" id="IDX-CHP-16-0005"/><a class="indexterm" id="IDX-CHP-16-0006"/></p></div><p>The SDK exposes IDA’s internal programming interfaces in the form of C++ libraries and the header files required to interface to those libraries. The SDK is required in order to create loader modules to handle new file formats, processor modules to disassemble new CPU instruction sets, and plug-in modules that might be viewed as more powerful, compiled alternatives to scripts.<a class="indexterm" id="IDX-CHP-16-0007"/></p><div class="sidebar"><a id="bells_comma_whistles_comma_and_bullets_t"/><p class="title">BELLS, WHISTLES, AND BULLETS TO THE FOOT</p><p>While working with C++, you will of course have access to a wide variety of C++ libraries, including your operating system’s native APIs. By utilizing such libraries, you may be tempted to incorporate a wide variety of sophisticated features into any modules that you build. However, you should be very careful what functionality you choose to incorporate in this way, as it may lead to instability in IDA. The most concrete example of this is the fact that IDA is a single-threaded application. No effort whatsoever is made to synchronize access to low-level database structures, nor does the SDK provide facilities for doing so. For IDA versions earlier than 5.5, you should never create additional threads that may simultaneously access the database. For versions 5.5 and later, you may create additional threads, but any calls to SDK functions should be queued using the <code class="literal">exec_request_t and execute_sync</code> function described in <span class="emphasis"><em>kernwin.hpp</em></span>. Also, you should understand that any blocking<sup>[<a class="footnote" href="#ftn.CHP-16-FN-1" id="CHP-16-FN-1">114</a>]</sup> operations you perform will render IDA unresponsive until the operation completes.<a class="indexterm" id="IDX-CHP-16-0008"/></p></div><p>In this chapter we introduce some of the core capabilities of the SDK. You will find these capabilities useful whether you are creating plug-ins, loader modules, or processor modules. As each of these types of modules is covered individually in the following three chapters, the examples in this chapter are offered without attempting to supply a specific context in which they might be used.</p><div class="sect1" title="SDK Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="sdk_introduction"/>SDK Introduction</h1></div></div></div><p>IDA’s SDK is distributed in much the same manner as the other IDA extras that we have discussed so far. The Zip file containing the SDK can be found on your original IDA CD, or authorized users can download the SDK from the Hex-Rays website. Each version of the SDK is named for the version of IDA with which it is compatible (for example, <span class="emphasis"><em>idasdk61.zip</em></span> goes with IDA version 6.1). The SDK features the same minimalist documentation typically found in other IDA-related tools, which in the case of the SDK means a top-level <span class="emphasis"><em>readme.txt</em></span> file and additional README files for plug-ins, processor modules, and loaders.<a class="indexterm" id="IDX-CHP-16-0009"/><a class="indexterm" id="IDX-CHP-16-0010"/><a class="indexterm" id="IDX-CHP-16-0011"/><a class="indexterm" id="IDX-CHP-16-0012"/></p><p>The SDK defines the published programming interface that modules may use to interact with IDA. Prior to SDK version 4.9, it was not uncommon for these interfaces to change enough that a module that successfully compiled under SDK 4.8 might no longer compile under a newer SDK, such as version 4.9, without the need for changes. With the introduction of version 4.9 of the SDK, Hex-Rays chose to standardize the existing API, which means that not only would modules require no changes to compile successfully with newer versions of the SDK, but modules would also be binary compatible with newer versions of IDA. This means that module users need no longer wait for module authors to update their source code or make available updated binary versions of their modules each time a new version of IDA is released. It does not mean that existing API interfaces are completely frozen; Hex-Rays continues to introduce new features with each new version of the SDK (that is, each new SDK is a superset of its predecessor). Modules that make use of these newer features are typically not compatible with older versions of IDA or the SDK. That said, there have been occasions where, for various reasons, functions have been renamed or marked as obsolete. The SDK offers macros to allow or disallow the use of deprecated functions, making it easy to note when a function has been deprecated.<a class="indexterm" id="IDX-CHP-16-0013"/></p><div class="sect2" title="SDK Installation"><div class="titlepage"><div><div><h2 class="title"><a id="sdk_installation"/>SDK Installation</h2></div></div></div><p>Prior to version 5.4, the Zip file containing the SDK does not contain a top-level directory. Because the SDK shares several subdirectory names with IDA, it is highly recommended that you create a dedicated SDK directory, such as idasdk53, and extract the SDK contents into that directory. This will make it much easier to distinguish SDK components from IDA components. Beginning with version 5.4, the IDA SDK is packaged within a top-level SDK directory, such as idasdk61, so this step is no longer needed. There is no requirement to install the SDK in a specific location relative to <span class="emphasis"><em>&lt;IDADIR&gt;</em></span>. Regardless of where you choose to install your SDK, we will refer to the SDK directory generically as <span class="emphasis"><em>&lt;SDKDIR&gt;</em></span> for the remainder of the book.</p></div><div class="sect2" title="SDK Layout"><div class="titlepage"><div><div><h2 class="title"><a id="sdk_layout"/>SDK Layout</h2></div></div></div><p>A basic understanding of the directory structure used within the SDK will be helpful, both in knowing where you might find documentation and in knowing where you can expect to find the modules that you build. A quick rundown of what you can expect to find in the SDK follows.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>bin directory</strong></span></span></dt><dd><p>This directory is where the example build scripts save their compiled modules following a successful build. Installing a module involves copying the module from the appropriate subdirectory within <span class="emphasis"><em>bin</em></span> to the appropriate subdirectory in <span class="emphasis"><em>&lt;IDADIR&gt;</em></span>. Module installation will be covered in more detail in <a class="xref" href="ch17.html" title="Chapter 17. The IDA Plug-in Architecture">Chapter 17</a>, <a class="xref" href="ch18.html" title="Chapter 18. Binary Files and IDA Loader Modules">Chapter 18</a>, and <a class="xref" href="ch19.html" title="Chapter 19. IDA Processor Modules">Chapter 19</a>. This directory also contains a postprocessing tool required for the creation of processor modules.<a class="indexterm" id="IDX-CHP-16-0014"/></p></dd><dt><span class="term"><span class="strong"><strong>etc directory</strong></span></span></dt><dd><p>This directory contains source code for two utilities that are required to build some SDK modules. Compiled versions of these utilities are also included with the SDK.<a class="indexterm" id="IDX-CHP-16-0015"/><a class="indexterm" id="IDX-CHP-16-0016"/><a class="indexterm" id="IDX-CHP-16-0017"/><a class="indexterm" id="IDX-CHP-16-0018"/><a class="indexterm" id="IDX-CHP-16-0019"/><a class="indexterm" id="IDX-CHP-16-0020"/><a class="indexterm" id="IDX-CHP-16-0021"/><a class="indexterm" id="IDX-CHP-16-0022"/><a class="indexterm" id="IDX-CHP-16-0023"/><a class="indexterm" id="IDX-CHP-16-0024"/><a class="indexterm" id="IDX-CHP-16-0025"/><a class="indexterm" id="IDX-CHP-16-0026"/><a class="indexterm" id="IDX-CHP-16-0027"/><a class="indexterm" id="IDX-CHP-16-0028"/><a class="indexterm" id="IDX-CHP-16-0029"/><a class="indexterm" id="IDX-CHP-16-0030"/></p></dd><dt><span class="term"><span class="strong"><strong>include directory</strong></span></span></dt><dd><p>This directory contains the header files that define the interface to the IDA API. In short, every API data structure that you are allowed to use and every API function that you are allowed to call are declared in one of the header files in this directory. The SDK’s top-level <span class="emphasis"><em>readme.txt</em></span> file contains an overview of some of the more commonly used header files in this directory. The files in this directory constitute the bulk of the documentation (as in “read the source”) for the SDK.</p></dd><dt><span class="term"><span class="strong"><strong>ldr directory</strong></span></span></dt><dd><p>This directory contains the source code and build scripts for several example loader modules. The README file for loaders is nothing more than a rundown of the contents of this directory.</p></dd><dt><span class="term"><span class="strong"><strong>lib directory</strong></span></span></dt><dd><p>This directory contains a number of subdirectories, which in turn contain the link libraries required to build various IDA modules. The subdirectories are named after the compiler with which they should be used. For example, <code class="literal">x86_win_vc_32</code> (6.1 and later) or <code class="literal">vc.w32</code> (6.0 and earlier) contains the library to use with Visual Studio and 32-bit IDA on Windows, while <code class="literal">x64_mac_gcc_64</code> (6.1 and later) or <code class="literal">gcc64.mac64</code> (6.0 and earlier) contains the library for use with 64-bit IDA on OSX platforms.</p></dd><dt><span class="term"><span class="strong"><strong>module directory</strong></span></span></dt><dd><p>This directory contains the source code and build scripts for several example processor modules. The README file for processor modules is nothing more than a rundown of the contents of this directory.</p></dd><dt><span class="term"><span class="strong"><strong>plug-ins directory</strong></span></span></dt><dd><p>This directory contains the source code and build scripts for several example plug-in modules. The README file for plug-ins provides a high-level overview of the plug-in architecture.</p></dd><dt><span class="term"><span class="strong"><strong>top-level directory</strong></span></span></dt><dd><p>The top level of the SDK contains several make files used for building modules as well as the main <span class="emphasis"><em>readme.txt</em></span> file for the SDK. Several additional <span class="emphasis"><em>install_xxx.txt</em></span> files contain information regarding installation and configuration for various compilers (for example, <span class="emphasis"><em>install_visual.txt</em></span> discusses Visual Studio configuration).</p></dd></dl></div><p>Keep in mind that documentation on using the SDK is sparse. For most developers, knowledge of the SDK has been derived through trial and error and extensive exploration of the contents of the SDK. You may have some luck posting questions to the <span class="emphasis"><em>Research &amp; Resources</em></span> forum on the Hex-Rays support forums, where other IDA users familiar with the SDK may answer them. An excellent third-party resource providing an introduction to the SDK and plug-in writing is Steve Micallef’s guide titled <span class="emphasis"><em>IDA Plug-in Writing in C/C++</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-2" id="CHP-16-FN-2">115</a>]</sup><a class="indexterm" id="IDX-CHP-16-0031"/><a class="indexterm" id="IDX-CHP-16-0032"/><a class="indexterm" id="IDX-CHP-16-0033"/><a class="indexterm" id="IDX-CHP-16-0034"/><a class="indexterm" id="IDX-CHP-16-0035"/><a class="indexterm" id="IDX-CHP-16-0036"/><a class="indexterm" id="IDX-CHP-16-0037"/></p></div><div class="sect2" title="Configuring a Build Environment"><div class="titlepage"><div><div><h2 class="title"><a id="configuring_a_build_environment"/>Configuring a Build Environment</h2></div></div></div><p>One of the more frustrating aspects of using the SDK is not related to programming at all. Instead, you may find that it is relatively easy to code up a solution to a problem only to find that it is virtually impossible to successfully build your module. This is true because it can be difficult to support a wide variety of compilers with a single code base, and coding a solution is complicated by the fact that library file formats recognized by Windows compilers are often incompatible with one another.</p><p>All of the examples included with the SDK were created to be built using Borland tools. From <span class="emphasis"><em>install_make.txt</em></span> we have the following quote from Ilfak:</p><div class="blockquote"><blockquote class="blockquote"><p>WIN32 versions can be created only by Borland C++ CBuilder v4.0. Probably the old BCC v5.2 will work too, but I haven’t checked it.</p></blockquote></div><p>That being said, other <span class="emphasis"><em>install_xxx</em></span> files offer pointers on how to successfully build modules with other compilers. A few of the example modules contain files for building with Visual Studio (<span class="emphasis"><em>&lt;SDKDIR&gt;/plugins/vcsample</em></span>, for example), while <span class="emphasis"><em>install_visual.txt</em></span> offers a series of steps for properly configuring SDK projects using Visual C++ Express 2005.</p><p>In order to build modules using Unix-style tools, either on a Unix-style system such as Linux or using an environment such as MinGW, the SDK provides a script named <span class="emphasis"><em>idamake.pl</em></span> that converts the Borland-style make files into Unix-style make files prior to initiating the build process. This process is discussed in <span class="emphasis"><em>install_linux.txt</em></span>.<a class="indexterm" id="IDX-CHP-16-0038"/><a class="indexterm" id="IDX-CHP-16-0039"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The command-line build scripts provided with the SDK expect an environment variable named IDA to point to <span class="emphasis"><em>&lt;SDKDIR&gt;</em></span> . You can set this globally for all scripts by editing <span class="emphasis"><em>&lt;SDKDIR&gt;/allmake.mak</em></span> and <span class="emphasis"><em>&lt;SDKDIR&gt;/allmake.unx</em></span> to set this variable or by adding an IDA environment variable to your global environment.</p></div><p>Steve Micallef’s guide also provides excellent instructions for configuring build environments for building plug-ins with various compilers. Our personal preference when building SDK modules for Windows versions of IDA is to use the MinGW tools gcc and make. The examples presented in <a class="xref" href="ch17.html" title="Chapter 17. The IDA Plug-in Architecture">Chapter 17</a>, <a class="xref" href="ch18.html" title="Chapter 18. Binary Files and IDA Loader Modules">Chapter 18</a>, and <a class="xref" href="ch19.html" title="Chapter 19. IDA Processor Modules">Chapter 19</a> include makefiles and Visual Studio project files that do not rely on any of the build scripts included with the SDK and that are easy to modify to suit the needs of your projects. Module-specific build configuration will also be discussed in each of these chapters.<a class="indexterm" id="IDX-CHP-16-0040"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-1" id="ftn.CHP-16-FN-1">114</a>] </sup>A blocking operation is an action that causes a program to come to a halt while it awaits completion of the action.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-2" id="ftn.CHP-16-FN-2">115</a>] </sup>See <a class="ulink" href="http://www.binarypool.com/idapluginwriting/">http://www.binarypool.com/idapluginwriting/</a>.</p></div></div></div>
<div class="sect1" title="The IDA Application Programming Interface"><div class="titlepage"><div><div><h1 class="title"><a id="the_ida_application_programming_interfac"/>The IDA Application Programming Interface</h1></div></div></div><p>IDA’s API is defined by the contents of the header files in <span class="emphasis"><em>&lt;SDKDIR&gt;/include</em></span>. There is no single-source index of available functions (though Steve Micallef has collected a rather nice subset in his plug-in writing guide). Many prospective SDK programmers find this fact initially difficult to come to terms with. The reality is that there is never an easy-to-find answer to the question, “How do I do <span class="emphasis"><em>x</em></span> using the SDK?” The two principal options for answering such questions are to post the questions to an IDA user’s forum or attempt to answer them yourself by searching through the API documentation. What documentation, you say? Why, the header files, of course. Granted, these are not the most searchable of documents, but they do contain the complete set of API features. In this case, <code class="literal">grep</code> (or a suitable replacement, preferably built into your programming editor) is your friend. The catch is knowing what to search for, which is not always obvious.<a class="indexterm" id="IDX-CHP-16-0041"/><a class="indexterm" id="IDX-CHP-16-0042"/><a class="indexterm" id="IDX-CHP-16-0043"/><a class="indexterm" id="IDX-CHP-16-0044"/><a class="indexterm" id="IDX-CHP-16-0045"/><a class="indexterm" id="IDX-CHP-16-0046"/><a class="indexterm" id="IDX-CHP-16-0047"/></p><p>There are a few ways to try to narrow your searches through the API. The first way is to leverage your knowledge of the IDC scripting language and attempt to locate similar functionality within the SDK using keywords and possibly function names derived from IDC. However—and this is an extremely frustrating point—while the SDK may contain functions that perform tasks identical to those of IDC functions, the names of those functions are seldom identical. This results in programmers learning two sets of API calls, one for use with IDC and one for use with the SDK. In order to address this situation, <a class="xref" href="apb.html" title="Appendix B. IDC/SDK Cross-Reference">Appendix B</a> presents a complete list of IDC functions and the corresponding SDK 6.1 actions that are carried out to execute those functions.</p><p>The second technique for narrowing down SDK-related searches is to become familiar with the content and, more important, the purpose of the various SDK header files. In general, related functions and associated data structures are grouped into headers files based on functional groups. For example, SDK functions that allow interaction with a user are grouped into <span class="emphasis"><em>kernwin.hpp</em></span>. When a <code class="literal">grep</code>-style search fails to locate a capability that you require, some knowledge of which header file relates to that capability will narrow your search and hopefully limit the number of files that you need to dig deeper into.<a class="indexterm" id="IDX-CHP-16-0048"/><a class="indexterm" id="IDX-CHP-16-0049"/></p><div class="sect2" title="Header Files Overview"><div class="titlepage"><div><div><h2 class="title"><a id="header_files_overview"/>Header Files Overview</h2></div></div></div><p>While the SDK’s <span class="emphasis"><em>readme.txt</em></span> files provide a high-level overview of the most commonly used header files, this section highlights some other useful information for working with these files. First, the majority of the header files use the <span class="emphasis"><em>.hpp</em></span> suffix, while a few use the <span class="emphasis"><em>.h</em></span> suffix. This can easily lead to trivial errors when naming header files to be included in your files. Second, <span class="emphasis"><em>ida.hpp</em></span> is the main header file for the SDK and should be included in all SDK-related projects. Third, the SDK utilizes preprocessor directives designed to preclude access to functions that Hex-Rays considers dangerous (such as <code class="literal">strcpy</code> and <code class="literal">sprintf</code>). For a complete list of these functions refer to the <code class="literal">USE_DANGEROUS_FUNCTIONS</code> macro prior to including <span class="emphasis"><em>ida.hpp</em></span> in your own files. An example is shown here:</p><a id="I_programlisting2_d1e22340"/><pre class="programlisting">#define USE_DANGEROUS_FUNCTIONS
#include &lt;ida.hpp&gt;</pre><p>Failure to define <code class="literal">USE_DANGEROUS_FUNCTIONS</code> will result in a build error to the effect that <code class="literal">dont_use_snprintf</code> is an undefined symbol (in the case of an attempt to use the <code class="literal">snprintf</code> function). In order to compensate for restricting access to these so-called dangerous functions, the SDK defines safer equivalents for each, generally in the form of a <code class="literal">qstr</code><em class="replaceable"><code>XXXX</code></em> function such as <code class="literal">qstrncpy</code> and <code class="literal">qsnprintf</code>. These safer versions are also declared in <span class="emphasis"><em>pro.h</em></span>.<a class="indexterm" id="IDX-CHP-16-0050"/><a class="indexterm" id="IDX-CHP-16-0051"/><a class="indexterm" id="IDX-CHP-16-0052"/><a class="indexterm" id="IDX-CHP-16-0053"/><a class="indexterm" id="IDX-CHP-16-0054"/><a class="indexterm" id="IDX-CHP-16-0055"/><a class="indexterm" id="IDX-CHP-16-0056"/><a class="indexterm" id="IDX-CHP-16-0057"/><a class="indexterm" id="IDX-CHP-16-0058"/><a class="indexterm" id="IDX-CHP-16-0059"/><a class="indexterm" id="IDX-CHP-16-0060"/><a class="indexterm" id="IDX-CHP-16-0061"/><a class="indexterm" id="IDX-CHP-16-0062"/><a class="indexterm" id="IDX-CHP-16-0063"/><a class="indexterm" id="IDX-CHP-16-0064"/><a class="indexterm" id="IDX-CHP-16-0065"/><a class="indexterm" id="IDX-CHP-16-0066"/></p><p>Along similar lines, the SDK restricts access to many standard file input/output variables and functions such as <code class="literal">stdin</code>, <code class="literal">stdout</code>, <code class="literal">fopen</code>, <code class="literal">fwrite</code>, and <code class="literal">fprintf</code>. This restriction is due in part to limitations of the Borland compiler. Here again the SDK defines replacement functions in the form of <code class="literal">q</code><em class="replaceable"><code>XXX</code></em> counterparts such as <code class="literal">qfopen</code> and <code class="literal">qfprintf</code>. If you require access to the standard file functions, then you must define the <code class="literal">USE_STANDARD_FILE_FUNCTIONS</code> macro prior to including <span class="emphasis"><em>fpro.h</em></span> (which is included from <span class="emphasis"><em>kernwin.hpp</em></span>, which is, in turn, included from several other files).</p><p>In most cases, each SDK header file contains a brief description of the file’s purpose and fairly extensive comments describing the data structures and functions that are declared in the file. Together these comments constitute IDA’s API documentation. Brief descriptions of some of the more commonly used SDK header files follow.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>area.hpp</strong></span></span></dt><dd><p>This file defines the <code class="literal">area_t</code> struct, which represents a contiguous block of addresses within a database. This struct serves as the base class for several other classes that build on the concept of an address range. It is seldom necessary to include this file directly, as it is typically included in files defining subclasses of <code class="literal">area_t</code>.</p></dd><dt><span class="term"><span class="strong"><strong>auto.hpp</strong></span></span></dt><dd><p>This file declares functions used to work with IDA’s autoanalyzer. The autoanalyzer performs queued analysis tasks when IDA is not busy processing userinput events.</p></dd><dt><span class="term"><span class="strong"><strong>bytes.hpp</strong></span></span></dt><dd><p>This file declares functions for working with individual database bytes. Functions declared in this file are used to read and write individual database bytes as well as manipulate the characteristics of those bytes. Miscellaneous functions also provide access to flags associated with instruction operands, while other functions allow manipulation of regular and repeatable comments.</p></dd><dt><span class="term"><span class="strong"><strong>dbg.hpp</strong></span></span></dt><dd><p>This file declares functions offering programmatic control of IDA’s debugger.</p></dd><dt><span class="term"><span class="strong"><strong>entry.hpp</strong></span></span></dt><dd><p>This header declares functions for working with a file’s entry points. For shared libraries, each exported function or data value is considered an entry point.</p></dd><dt><span class="term"><span class="strong"><strong>expr.hpp</strong></span></span></dt><dd><p>This file declares functions and data structures for working with IDC constructs. It is possible to modify existing IDC functions, add new IDC functions, or execute IDC statements from within modules.<a class="indexterm" id="IDX-CHP-16-0067"/><a class="indexterm" id="IDX-CHP-16-0068"/><a class="indexterm" id="IDX-CHP-16-0069"/><a class="indexterm" id="IDX-CHP-16-0070"/><a class="indexterm" id="IDX-CHP-16-0071"/><a class="indexterm" id="IDX-CHP-16-0072"/><a class="indexterm" id="IDX-CHP-16-0073"/><a class="indexterm" id="IDX-CHP-16-0074"/><a class="indexterm" id="IDX-CHP-16-0075"/><a class="indexterm" id="IDX-CHP-16-0076"/><a class="indexterm" id="IDX-CHP-16-0077"/><a class="indexterm" id="IDX-CHP-16-0078"/><a class="indexterm" id="IDX-CHP-16-0079"/><a class="indexterm" id="IDX-CHP-16-0080"/><a class="indexterm" id="IDX-CHP-16-0081"/><a class="indexterm" id="IDX-CHP-16-0082"/><a class="indexterm" id="IDX-CHP-16-0083"/><a class="indexterm" id="IDX-CHP-16-0084"/><a class="indexterm" id="IDX-CHP-16-0085"/><a class="indexterm" id="IDX-CHP-16-0086"/><a class="indexterm" id="IDX-CHP-16-0087"/><a class="indexterm" id="IDX-CHP-16-0088"/><a class="indexterm" id="IDX-CHP-16-0089"/><a class="indexterm" id="IDX-CHP-16-0090"/><a class="indexterm" id="IDX-CHP-16-0091"/><a class="indexterm" id="IDX-CHP-16-0092"/></p></dd><dt><span class="term"><span class="strong"><strong>fpro.h</strong></span></span></dt><dd><p>This file contains the alternative file I/O functions, such as <code class="literal">qfopen</code>, discussed previously.<a class="indexterm" id="IDX-CHP-16-0093"/></p></dd><dt><span class="term"><span class="strong"><strong>frame.hpp</strong></span></span></dt><dd><p>This header contains functions used to manipulate stack frames.</p></dd><dt><span class="term"><span class="strong"><strong>funcs.hpp</strong></span></span></dt><dd><p>This header contains functions and data structures for working with disassembled functions as well as functions for working with FLIRT signatures.</p></dd><dt><span class="term"><span class="strong"><strong>gdl.hpp</strong></span></span></dt><dd><p>This file declares support routines for generating graphs using either DOT or GDL.</p></dd><dt><span class="term"><span class="strong"><strong>ida.hpp</strong></span></span></dt><dd><p>This is the main header file required for working with the SDK. This file contains the definition of the <code class="literal">idainfo</code> structure as well as the declaration of the global variable <code class="literal">inf</code>, which contains a number of fields containing information about the current database as well as fields initialized from configuration file settings.</p></dd><dt><span class="term"><span class="strong"><strong>idp.hpp</strong></span></span></dt><dd><p>This file contains declarations of structures that form the foundation of processor modules. The global variable <code class="literal">ph</code>, which describes the current processor module, and the global variable <code class="literal">ash</code>, which describes the current assembler, are defined in this file.</p></dd><dt><span class="term"><span class="strong"><strong>kernwin.hpp</strong></span></span></dt><dd><p>This file declares functions for interacting with the user and the user interface. The SDK equivalents of IDC’s <code class="literal">Ask</code><em class="replaceable"><code>XXX</code></em> functions are declared here, as are functions used to set the display position and configure hotkey associations.</p></dd><dt><span class="term"><span class="strong"><strong>lines.hpp</strong></span></span></dt><dd><p>This file declares functions for generating formatted, colorized disassembly lines.</p></dd><dt><span class="term"><span class="strong"><strong>loader.hpp</strong></span></span></dt><dd><p>This file contains the declarations for the <code class="literal">loader_t</code> and <code class="literal">plugin_t</code> structures required for the creation of loader modules and plug-in modules, respectively, as well as functions useful during the file-loading phase and functions for activating plug-ins.</p></dd><dt><span class="term"><span class="strong"><strong>name.hpp</strong></span></span></dt><dd><p>This file declares functions for manipulating named locations (as opposed to names within structures or stack frames, which are covered in <span class="emphasis"><em>stuct.hpp</em></span> and <span class="emphasis"><em>funcs.hpp</em></span>, respectively).<a class="indexterm" id="IDX-CHP-16-0094"/><a class="indexterm" id="IDX-CHP-16-0095"/><a class="indexterm" id="IDX-CHP-16-0096"/><a class="indexterm" id="IDX-CHP-16-0097"/><a class="indexterm" id="IDX-CHP-16-0098"/><a class="indexterm" id="IDX-CHP-16-0099"/><a class="indexterm" id="IDX-CHP-16-0100"/><a class="indexterm" id="IDX-CHP-16-0101"/><a class="indexterm" id="IDX-CHP-16-0102"/><a class="indexterm" id="IDX-CHP-16-0103"/><a class="indexterm" id="IDX-CHP-16-0104"/><a class="indexterm" id="IDX-CHP-16-0105"/><a class="indexterm" id="IDX-CHP-16-0106"/><a class="indexterm" id="IDX-CHP-16-0107"/><a class="indexterm" id="IDX-CHP-16-0108"/><a class="indexterm" id="IDX-CHP-16-0109"/><a class="indexterm" id="IDX-CHP-16-0110"/><a class="indexterm" id="IDX-CHP-16-0111"/><a class="indexterm" id="IDX-CHP-16-0112"/><a class="indexterm" id="IDX-CHP-16-0113"/><a class="indexterm" id="IDX-CHP-16-0114"/><a class="indexterm" id="IDX-CHP-16-0115"/><a class="indexterm" id="IDX-CHP-16-0116"/><a class="indexterm" id="IDX-CHP-16-0117"/><a class="indexterm" id="IDX-CHP-16-0118"/><a class="indexterm" id="IDX-CHP-16-0119"/></p></dd><dt><span class="term"><span class="strong"><strong>netnode.hpp</strong></span></span></dt><dd><p>Netnodes are the lowest-level storage structure accessible via the API. The details of netnodes are typically hidden by the IDA user interface. This file contains the definition of the <code class="literal">netnode</code> class and functions for low-level manipulation of netnodes.</p></dd><dt><span class="term"><span class="strong"><strong>pro.h</strong></span></span></dt><dd><p>This file includes the top-level typedefs and macros required in any SDK module. You do not need to explicitly include this file in your projects, as it is included from <span class="emphasis"><em>ida.hpp</em></span>. Among other things, the <code class="literal">IDA_SDK_VERSION</code> macro is defined in this file. <code class="literal">IDA_SDK_VERSION</code> provides a means to determine with which version of the SDK a module is being built, and it can be tested to provide conditional compilation when using different versions of the SDK. Note that <code class="literal">IDA_SDK_VERSION</code> was introduced with SDK version 5.2. Prior to SDK 5.2, there is no official way to determine which SDK is being used. An unofficial header file that defines <code class="literal">IDA_SDK_VERSION</code> for older versions of the SDK (<span class="emphasis"><em>sdk_versions.h</em></span>) is available on this book’s website.</p></dd><dt><span class="term"><span class="strong"><strong>search.hpp</strong></span></span></dt><dd><p>This file declares functions for performing different types of searches on a database.</p></dd><dt><span class="term"><span class="strong"><strong>segment.hpp</strong></span></span></dt><dd><p>This file contains the declaration of the <code class="literal">segment_t</code> class, a subclass of <code class="literal">area_t</code>, which is used to describe individual sections (<code class="literal">.text</code>, <code class="literal">.data</code>, etc.) within a binary. Functions for working with segments are also declared here.</p></dd><dt><span class="term"><span class="strong"><strong>struct.hpp</strong></span></span></dt><dd><p>This file contains the declaration of the <code class="literal">struc_t</code> class and functions for manipulating structures within a database.</p></dd><dt><span class="term"><span class="strong"><strong>typeinf.hpp</strong></span></span></dt><dd><p>This file declares functions for working with IDA type libraries. Among other things, functions declared here offer access to function signatures, including function return types and parameter sequences.</p></dd><dt><span class="term"><span class="strong"><strong>ua.hpp</strong></span></span></dt><dd><p>This file declares the <code class="literal">op_t</code> and <code class="literal">insn_t</code> classes used extensively in processor modules. Also declared here are functions used for disassembling individual instructions and for generating the text for various portions of each disassembled line.</p></dd><dt><span class="term"><span class="strong"><strong>xref.hpp</strong></span></span></dt><dd><p>This file declares the datatypes and functions required for adding, deleting, and iterating code and data cross-references.</p></dd></dl></div><p>The preceding list describes approximately half of the header files that ship with the SDK. You are encouraged to familiarize yourself not only with the files in this list but also with all of the other header files as well, as you dig deeper into the SDK. Functions that make up the published API are marked as <code class="literal">ida_export</code>. Only functions designated as <code class="literal">ida_export</code> are exported in the link libraries that ship with the SDK. Don’t be misled by the use of <code class="literal">idaapi</code>, as it merely signifies that a function is to use the <code class="literal">stdcall</code> calling convention on Windows platforms only. You may occasionally run across interesting-looking functions that are not designated as <code class="literal">ida_export</code>; you cannot use these functions in your modules.<a class="indexterm" id="IDX-CHP-16-0120"/><a class="indexterm" id="IDX-CHP-16-0121"/><a class="indexterm" id="IDX-CHP-16-0122"/><a class="indexterm" id="IDX-CHP-16-0123"/><a class="indexterm" id="IDX-CHP-16-0124"/></p></div><div class="sect2" title="Netnodes"><div class="titlepage"><div><div><h2 class="title"><a id="netnodes"/>Netnodes</h2></div></div></div><p>Much of IDA’s API is built around C++ classes that model various aspects of a disassembled binary. The <code class="literal">netnode</code> class, on the other hand, seems wrapped in mystery because it appears to have no direct relationship to constructs within binary files (sections, functions, instructions, etc.).</p><p>Netnodes are the lowest-level and most-general-purpose data storage mechanism accessible within an IDA database. As a module programmer, you will seldom be required to work directly with netnodes. Many of the higher-level data structures hide the fact that they ultimately rely on netnodes for persistent storage within a database. Some of the ways that netnodes are used within a database are detailed in the file <span class="emphasis"><em>nalt.hpp</em></span>, in which we learn, for example, that information about the shared libraries and functions that a binary imports is stored in a netnode named <code class="literal">import_node</code> (yes, netnodes may have names). Netnodes are also the persistent storage mechanisms that facilitate IDC’s global arrays.<a class="indexterm" id="IDX-CHP-16-0125"/><a class="indexterm" id="IDX-CHP-16-0126"/><a class="indexterm" id="IDX-CHP-16-0127"/></p><p>Netnodes are described in extensive detail in the file <span class="emphasis"><em>netnode.hpp</em></span>. But from a high-level perspective, netnodes are storage structures used internally by IDA for a variety of purposes. However, their precise structure is kept hidden, even to SDK programmers. To provide an interface to these storage structures, the SDK defines a <code class="literal">netnode</code> class, which functions as an opaque wrapper around this internal storage structure. The <code class="literal">netnode</code> class contains a single data member called <code class="literal">netnodenumber</code>, which is an integer identifier used to access the internal representation of a netnode. Every netnode is uniquely identified by its <code class="literal">netnodenumber</code>. On 32-bit systems the <code class="literal">netnodenumber</code> is a 32-bit quantity, allowing for 2<sup>32</sup> unique netnodes. On 64-bit systems, a <code class="literal">netnodenumber</code> is a 64-bit integer, which allows for 2<sup>64</sup> unique netnodes. In most cases, the <code class="literal">netnodenumber</code> represents a virtual address within the database, which creates a natural mapping between each address within a database and any net-node that might be required to store information associated with that address. Comment text is an example of arbitrary information that may be associated with an address and thus stored within a netnode associated with that address.</p><p>The recommended way to manipulate netnodes is by invoking member functions of the <code class="literal">netnode</code> class using an instantiated <code class="literal">netnode</code> object. Reading through <span class="emphasis"><em>netnode.hpp</em></span>, you will notice that a number of nonmember functions exist that seem to support netnode manipulation. Use of these functions is discouraged in favor of member functions. You will note, however, that most of the member functions in the <code class="literal">netnode</code> class are thin wrappers around one of the nonmember functions.<a class="indexterm" id="IDX-CHP-16-0128"/><a class="indexterm" id="IDX-CHP-16-0129"/></p><p>Internally, netnodes can be used to store several different types of information. Each netnode may be associated with a name of up to 512 characters and a primary value of up to 1,024 bytes. Member functions of the <code class="literal">netnode</code> class are provided to retrieve (<code class="literal">name</code>) or modify (<code class="literal">rename</code>) a netnode’s name. Additional member functions allow you to treat a netnode’s primary value as an integer (<code class="literal">set_long</code>, <code class="literal">long_value</code>), a string (<code class="literal">set</code>, <code class="literal">valstr</code>), or an arbitrary binary blob<sup>[<a class="footnote" href="#ftn.CHP-16-FN-3" id="CHP-16-FN-3">116</a>]</sup> (<code class="literal">set</code>, <code class="literal">valobj</code>). The function used inherently determines how the primary value is treated.</p><p>Here is where things get a little complicated. In addition to a name and a primary value, every <code class="literal">netnode</code> is also capable of storing 256 sparse arrays in which the array elements can be arbitrarily sized with values up to a maximum of 1,024 bytes each. These arrays fall into three overlapping categories. The first category of arrays is indexed using 32-bit index values and can potentially hold in excess of 4 billion items. The second category of arrays is indexed using 8-bit index values and can thus hold up to 256 items. The last category of arrays is actually hash tables that use strings for keys. Regardless of which of the three categories is used, each element of the array will accept values up to 1,024 bytes in size. In short, a netnode can hold a tremendous amount of data—now we just need to learn how to make it all happen.</p><p>If you are wondering where all of this information gets stored, you are not alone. All netnode content is stored within btree nodes in an IDA database. Btree nodes in turn are stored in an ID0 file, which in turn is archived into an IDB file when you close your database. Any netnode content that you create will not be visible in any of IDA’s display windows; the data is yours to manipulate as you please. This is why netnodes are an ideal place for persistent storage for any plug-ins and scripts that you may wish to use to store results from one invocation to the next.</p><div class="sect3" title="Creating Netnodes"><div class="titlepage"><div><div><h3 class="title"><a id="creating_netnodes"/>Creating Netnodes</h3></div></div></div><p>A potentially confusing point about netnodes is that declaring a <code class="literal">netnode</code> variable within one of your modules does not necessarily create an internal representation of that netnode within the database. A netnode is not created internally until one of the following events takes place:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The netnode is assigned a name.</p></li><li class="listitem"><p>The netnode is assigned a primary value.</p></li><li class="listitem"><p>A value is stored into one of the netnode’s internal arrays.</p></li></ul></div><p>There are three constructors available for declaring netnodes within your modules. The prototypes for each, extracted from <span class="emphasis"><em>netnode.hpp</em></span>, and examples of their use are shown in <a class="xref" href="ch16s02.html#declaring_netnodes" title="Example 16-1. Declaring netnodes">Example 16-1</a>.<a class="indexterm" id="IDX-CHP-16-0130"/><a class="indexterm" id="IDX-CHP-16-0131"/><a class="indexterm" id="IDX-CHP-16-0132"/></p><div class="example"><a id="declaring_netnodes"/><p class="title">Example 16-1. Declaring netnodes</p><div class="example-contents"><pre class="programlisting">#ifdef __EA64__
  typedef ulonglong nodeidx_t;
  #else
  typedef ulong nodeidx_t;
  #endif
  class netnode {
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    netnode();
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>    netnode(nodeidx_t num);
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>    netnode(const char *name, size_t namlen=0, bool do_create=false);
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>    bool create(const char *name, size_t namlen=0);
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>    bool create();
     //... remainder of netnode class follows
  };
  netnode n0;                       //uses<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>
  netnode n1(0x00401110);           //uses<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>
  netnode n2("$ node 2");           //uses<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>
  netnode n3("$ node 3", 0, true);  //uses<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></pre></div></div><p>In this example, only one netnode (<code class="literal">n3</code>) is guaranteed to exist within the database after the code has executed. Netnodes <code class="literal">n1</code> and <code class="literal">n2</code> may exist if they had been previously created and populated with data. Whether it previously existed or not, <code class="literal">n1</code> is capable of receiving new data at this point. If <code class="literal">n2</code> did not exist, meaning that no netnode named <code class="literal">$ node 2</code> could be found in the database, then <code class="literal">n2</code> must be explicitly created (<span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e23210"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> or <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e23216"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>) before data can be stored into it. If we want to guarantee that we can store data into <code class="literal">n2</code>, we need to add the following safety check:</p><a id="I_programlisting2_d1e23225"/><pre class="programlisting">if (BADNODE == (nodeidx_t)n2) {
   n2.create("$ node 2");
}</pre><p>The preceding example demonstrates the use of the <code class="literal">nodeidx_t</code> operator, which allows a netnode to be cast to a <code class="literal">nodeidx_t</code>. The <code class="literal">nodeidx_t</code> operator simply returns the <code class="literal">netnodenumber</code> data member of the associated netnode and allows <code class="literal">netnode</code> variables to be easily converted into integers.</p><p>An important point to understand about netnodes is that a netnode <span class="emphasis"><em>must</em></span> have a valid <code class="literal">netnodenumber</code> before you can store data into the netnode. A <code class="literal">netnodenumber</code> may be explicitly assigned, as with <code class="literal">n1</code> via a constructor shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e23258"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> in the previous example. Alternatively, a <code class="literal">netnodenumber</code> may be internally generated when a netnode is created using the <code class="literal">create</code> flag in a constructor (as with <code class="literal">n3</code> via a constructor shown in <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e23274"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>) or via the <code class="literal">create</code> function (as with <code class="literal">n2</code>). Internally assigned <code class="literal">netnodenumbers</code> begin with <code class="literal">0xFF000000</code> and increment with each newly created netnode.</p><p>We have thus far neglected netnode <code class="literal">n0</code> in our example. As things currently stand, <code class="literal">n0</code> has neither a number nor a name. We could create <code class="literal">n0</code> by name using the <code class="literal">create</code> function in a manner similar to <code class="literal">n2</code>. Or we could use the alternate form of <code class="literal">create</code> to create an unnamed netnode with a valid, internally generated <code class="literal">netnodenumber</code>, as shown here:<a class="indexterm" id="IDX-CHP-16-0133"/><a class="indexterm" id="IDX-CHP-16-0134"/><a class="indexterm" id="IDX-CHP-16-0135"/><a class="indexterm" id="IDX-CHP-16-0136"/><a class="indexterm" id="IDX-CHP-16-0137"/><a class="indexterm" id="IDX-CHP-16-0138"/></p><a id="I_programlisting2_d1e23341"/><pre class="programlisting">n0.create();  //assign an internally generated netnodenumber to n0</pre><p>At this point it is possible to store data into <code class="literal">n0</code>, though we have no way to retrieve that data in the future unless we record the assigned <code class="literal">netnodenumber</code> somewhere or assign <code class="literal">n0</code> a name. This demonstrates the fact that netnodes are easy to access when they are associated with a virtual address (similar to <code class="literal">n1</code> in our example). For all other netnodes, assigning a name makes it possible to perform a named lookup for all future references to the netnode (as with <code class="literal">n2</code> and <code class="literal">n3</code> in our example).</p><p>Note that for our named netnodes, we have chosen to use names prefixed with “<code class="literal">$</code> ”, which is in keeping with the practice, recommended in <span class="emphasis"><em>netnode.hpp</em></span>, for avoiding conflicts with names IDA uses internally.</p></div><div class="sect3" title="Data Storage in Netnodes"><div class="titlepage"><div><div><h3 class="title"><a id="data_storage_in_netnodes"/>Data Storage in Netnodes</h3></div></div></div><p>Now that you understand how to create a netnode that you can store data into, let’s return to the discussion of the internal array storage capability of net-nodes. To store a value into an array within a netnode, we need to specify five pieces of information: an index value, an index size (8 or 32 bits), a value to store, the number of bytes the value contains, and an array (one of 256 available for each category of array) in which to store the value. The index size parameter is specified implicitly by the function that we use to store or retrieve the data. The remaining values are passed into that function as parameters. The parameter that selects which of the 256 possible arrays a value is stored in is usually called a <span class="emphasis"><em>tag</em></span>, and it is often specified (though it need not be) using a character. The netnode documentation distinguishes among a few special types of values termed <span class="emphasis"><em>altvals</em></span>, <span class="emphasis"><em>supvals</em></span>, and <span class="emphasis"><em>hashvals</em></span>. By default, each of these values is typically associated with a specific array tag: <code class="literal">'A'</code> for altvals, <code class="literal">'S'</code> for supvals, and <code class="literal">'H'</code> for hashvals. A fourth type of value, called a <span class="emphasis"><em>charval</em></span>, is not associated with any specific array tag.<a class="indexterm" id="IDX-CHP-16-0139"/><a class="indexterm" id="IDX-CHP-16-0140"/><a class="indexterm" id="IDX-CHP-16-0141"/></p><p>It is important to understand that these value types are associated more with a specific way of storing data into a netnode than with a specific array within a netnode. It is possible to store any type of value in any array simply by specifying an alternate array tag when storing data. In all cases, it is up to you to remember what type of data you stored into a particular array location so that you can use retrieval methods appropriate to the type of the stored data.</p><p><span class="emphasis"><em>Altvals</em></span> provide a simple interface for storing and retrieving integer data in netnodes. Altvals may be stored into any array within a netnode but default to the <code class="literal">'A'</code> array. Regardless of which array you wish to store integers into, using the altval-related functions greatly simplifies matters. The code in <a class="xref" href="ch16s02.html#accessing_netnode_altvals" title="Example 16-2. Accessing netnode altvals">Example 16-2</a> demonstrates data storage and retrieval using altvals.</p><div class="example"><a id="accessing_netnode_altvals"/><p class="title">Example 16-2. Accessing netnode altvals</p><div class="example-contents"><pre class="programlisting">netnode n("$ idabook", 0, true);  //create the netnode if it doesn't exist
sval_t index = 1000;  //sval_t is a 32 bit type, this example uses 32-bit indexes
ulong value = 0x12345678;
n.altset(index, value);   //store value into the 'A' array at index
value = n.altval(index);  //retrieve value from the 'A' array at index
n.altset(index, value, (char)3);  //store into array 3
value = n.altval(index, (char)3); //read from array 3</pre></div></div><p>In this example, you see a pattern that will be repeated for other types of netnode values, namely, the use of an <em class="replaceable"><code>XXX</code></em><code class="literal">set</code> function (in this case, <code class="literal">altset</code>) to store a value into a netnode and an <em class="replaceable"><code>XXX</code></em><code class="literal">val</code> function (in this case, <code class="literal">altval</code>) to retrieve a value from a netnode. If we want to store integers into arrays using 8-bit index values, we need to use slightly different functions, as shown in the next example.<a class="indexterm" id="IDX-CHP-16-0142"/><a class="indexterm" id="IDX-CHP-16-0143"/></p><a id="I_programlisting2_d1e23453"/><pre class="programlisting">netnode n("$ idabook", 0, true);
uchar index = 80;      //this example uses 8-bit index values
ulong value = 0x87654321;
n.altset_idx8(index, value, 'A');  //store, no default tags with xxx_idx8 functions
value = n.altval_idx8(index, 'A'); //retrieve value from the 'A' array at index
n.altset_idx8(index, value, (char)3);  //store into array 3
value = n.altval_idx8(index, (char)3); //read from array 3</pre><p>Here you see that the general rule of thumb for the use of 8-bit index values is to use a function with an <code class="literal">_idx8</code> suffix. Also note that none of the <code class="literal">_idx8</code> functions provide default values for the array tag parameter.<a class="indexterm" id="IDX-CHP-16-0144"/></p><p><span class="emphasis"><em>Supvals</em></span> represent the most versatile means of storing and retrieving data in netnodes. Supvals represent data of arbitrary size, from 1 byte to a maximum of 1,024 bytes. When using 32-bit index values, the default array for storing and retrieving supvals is the <code class="literal">'S'</code> array. Again, however, supvals can be stored into any of the 256 available arrays by specifying an appropriate array tag value. Strings are a common form of arbitrary length data and as such are afforded special handling in supval manipulation functions. The code in <a class="xref" href="ch16s02.html#storing_netnode_supvals" title="Example 16-3. Storing netnode supvals">Example 16-3</a> provides examples of storing supvals into a netnode.</p><div class="example"><a id="storing_netnode_supvals"/><p class="title">Example 16-3. Storing netnode supvals</p><div class="example-contents"><pre class="programlisting">netnode n("$ idabook", 0, true);  //create the netnode if it doesn't exist

char *string_data = "example supval string data";
char binary_data[] = {0xfe, 0xdc, 0x4e, 0xc7, 0x90, 0x00, 0x13, 0x8a,
                      0x33, 0x19, 0x21, 0xe5, 0xaa, 0x3d, 0xa1, 0x95};

//store binary_data into the 'S' array at index 1000, we must supply a
//pointer to data and the size of the data
n.supset(1000, binary_data, sizeof(binary_data));

//store string_data into the 'S' array at index 1001.  If no size is supplied,
//or size is zero, the data size is computed as: strlen(data) + 1
n.supset(1001, string_data);
//store into an array other than 'S' (200 in this case) at index 500
n.supset(500, binary_data, sizeof(binary_data), (char)200);</pre></div></div><p>The <code class="literal">supset</code> function requires an array index, a pointer to some data, the length of the data (in bytes), and an array tag that defaults to <code class="literal">'S'</code> if omitted. If the length parameter is omitted, it defaults to zero. When the length is specified as zero, <code class="literal">supset</code> assumes that the data being stored is a string, computes the length of the data as <code class="literal">strlen</code>(data) + 1, and stores a null termination character along with the string data.<a class="indexterm" id="IDX-CHP-16-0145"/><a class="indexterm" id="IDX-CHP-16-0146"/><a class="indexterm" id="IDX-CHP-16-0147"/><a class="indexterm" id="IDX-CHP-16-0148"/></p><p>Retrieving data from a supval takes a little care, as you may not know the amount of data contained within the supval before you attempt to retrieve it. When you retrieve data from a supval, bytes are copied out of the netnode into a user-supplied output buffer. How do you ensure that your output buffer is of sufficient size to receive the supval data? The first method is to retrieve all supval data into a buffer that is at least 1,024 bytes. The second method is to preset the size of your output buffers by querying the size of the supval. Two functions are available for retrieving supvals. The <code class="literal">supval</code> function is used to retrieve arbitrary data, while the <code class="literal">supstr</code> function is specialized for retrieving string data. Each of these functions expects a pointer to your output buffer along with the size of the buffer. The return value for <code class="literal">supval</code> is the number of bytes copied into the output buffer, while the return value for <code class="literal">supstr</code> is the length of the string copied to the output buffer not including the null terminator, even though the null terminator is copied to the buffer. Each of these functions recognizes the special case in which a <code class="literal">NULL</code> pointer is supplied in place of an output buffer pointer. In such cases, <code class="literal">supval</code> and <code class="literal">supstr</code> return the number of bytes of storage (including any null terminator) required to hold the supval data. <a class="xref" href="ch16s02.html#retrieving_netnode_supvals" title="Example 16-4. Retrieving netnode supvals">Example 16-4</a> demonstrates retrieval of supval data using the <code class="literal">supval</code> and <code class="literal">supstr</code> functions.</p><div class="example"><a id="retrieving_netnode_supvals"/><p class="title">Example 16-4. Retrieving netnode supvals</p><div class="example-contents"><pre class="programlisting">//determine size of element 1000 in 'S' array.  The NULL pointer indicates
//that we are not supplying an output buffer
int len = n.supval(1000, NULL, 0);

char *outbuf = new char[len];  //allocate a buffer of sufficient size
n.supval(1000, outbuf, len);   //extract data from the supval

//determine size of element 1001 in 'S' array.  The NULL pointer indicates
//that we are not supplying an output buffer.
len = n.supstr(1001, NULL, 0);

char *outstr = new char[len];  //allocate a buffer of sufficient size
n.supval(1001, outstr, len);   //extract data from the supval

//retrieve a supval from array 200, index 500
char buf[1024];
len = n.supval(500, buf, sizeof(buf), (char)200);</pre></div></div><p>Using supvals, it is possible to access any data stored in any array within a netnode. For example, supval functions can be used to store and retrieve altval data by limiting the supset and supval operations to the size of an altval. Reading through <span class="emphasis"><em>netnode.hpp</em></span>, you will see that this is in fact the case by observing the inlined implementation of the <code class="literal">altset</code> function, as shown here:<a class="indexterm" id="IDX-CHP-16-0149"/><a class="indexterm" id="IDX-CHP-16-0150"/><a class="indexterm" id="IDX-CHP-16-0151"/><a class="indexterm" id="IDX-CHP-16-0152"/><a class="indexterm" id="IDX-CHP-16-0153"/><a class="indexterm" id="IDX-CHP-16-0154"/><a class="indexterm" id="IDX-CHP-16-0155"/><a class="indexterm" id="IDX-CHP-16-0156"/></p><a id="I_programlisting2_d1e23578"/><pre class="programlisting">bool altset(sval_t alt, nodeidx_t value, char tag=atag) {
   return supset(alt, &amp;value, sizeof(value), tag);
}</pre><p><span class="emphasis"><em>Hashvals</em></span> offer yet another interface to netnodes. Rather than being associated with integer indexes, hashvals are associated with key strings. Overloaded versions of the <code class="literal">hashset</code> function make it easy to associate integer data or array data with a hash key, while the <code class="literal">hashval</code>, <code class="literal">hashstr</code>, and <code class="literal">hashval_long</code> functions allow retrieval of hashvals when provided with the appropriate hash key. Tag values associated with the <code class="literal">hash</code><em class="replaceable"><code>XXX</code></em> functions actually choose one of 256 hash tables, with the default table being <code class="literal">'H'</code>. Alternate tables are selected by specifying a tag other than <code class="literal">'H'</code>.<a class="indexterm" id="IDX-CHP-16-0157"/></p><p>The last interface to netnodes that we will mention is the <span class="emphasis"><em>charval</em></span> interface. The <code class="literal">charval</code> and <code class="literal">charset</code> functions offer a simple means to store single-byte data into a netnode array. There is no default array associated with charval storage and retrieval, so you must specify an array tag for every charval operation. Charvals are stored into the same arrays as altvals and supvals, and the charval functions are simply wrappers around 1-byte supvals.<a class="indexterm" id="IDX-CHP-16-0158"/></p><p>Another capability provided by the <code class="literal">netnode</code> class is the ability to iterate over the contents of a netnode array (or hash table). Iteration is performed using <em class="replaceable"><code>XXX</code></em><code class="literal">1st</code>, <em class="replaceable"><code>XXX</code></em><code class="literal">nxt</code>, <em class="replaceable"><code>XXX</code></em><code class="literal">last</code>, and <em class="replaceable"><code>XXX</code></em><code class="literal">prev</code> functions that are available for altvals, supvals, hashvals, and charvals. The example in <a class="xref" href="ch16s02.html#enumerating_netnode_altvals" title="Example 16-5. Enumerating netnode altvals">Example 16-5</a> illustrates iteration across the default altvals array (<code class="literal">'A'</code>).</p><p>Iteration over supvals, charvals, and hashvals is performed in a very similar manner; however, you will find that the syntax varies depending on the type of values being accessed. For example, iteration over hashvals returns hashkeys rather than array indexes, which must then be used to retrieve hashvals.</p><div class="example"><a id="enumerating_netnode_altvals"/><p class="title">Example 16-5. Enumerating netnode altvals</p><div class="example-contents"><pre class="programlisting">netnode n("$ idabook", 0, true);
//Iterate altvals first to last
for (nodeidx_t idx = n.alt1st(); idx != BADNODE; idx = n.altnxt(idx)) {
   ulong val = n.altval(idx);
   msg("Found altval['A'][%d] = %d\n", idx, val);
}

//Iterate altvals last to first
for (nodeidx_t idx = n.altlast(); idx != BADNODE; idx = n.altprev(idx)) {
   ulong val = n.altval(idx);
   msg("Found altval['A'][%d] = %d\n", idx, val);
}</pre></div></div><div class="sidebar"><a id="netnodes_and_idc_global_arrays"/><p class="title">NETNODES AND IDC GLOBAL ARRAYS</p><p>You may recall from <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a> that the IDC scripting language provides persistent global arrays. Netnodes provide the backing storage for IDC global arrays. When you supply a name to the IDC <code class="literal">CreateArray</code> function, the string <code class="literal">$ idc_array</code> is prepended to the name that you supply to form a netnode name. The <code class="literal">netnodenumber</code> of the newly created netnode is returned to you as the IDC array identifier. The IDC <code class="literal">SetArrayLong</code> function stores an integer into the altvals (<code class="literal">'A'</code>) array, while the <code class="literal">SetArrayString</code> function stores a string into the supvals (<code class="literal">'S'</code>) array. When you retrieve a value from an IDC array using the <code class="literal">GetArrayElement</code> function, the tags that you supply (<code class="literal">AR_LONG or AR_STR</code>) represent the tags to the altval and supval arrays used to store the corresponding integer or strings data.<a class="indexterm" id="IDX-CHP-16-0159"/><a class="indexterm" id="IDX-CHP-16-0160"/><a class="indexterm" id="IDX-CHP-16-0161"/><a class="indexterm" id="IDX-CHP-16-0162"/><a class="indexterm" id="IDX-CHP-16-0163"/><a class="indexterm" id="IDX-CHP-16-0164"/></p><p><a class="xref" href="apb.html" title="Appendix B. IDC/SDK Cross-Reference">Appendix B</a> offers additional insight into the use of netnodes within the implementations of IDC functions and exposes how netnodes are used to store various types of information (such as comments) within a database.</p></div></div><div class="sect3" title="Deleting Netnodes and Netnode Data"><div class="titlepage"><div><div><h3 class="title"><a id="deleting_netnodes_and_netnode_data"/>Deleting Netnodes and Netnode Data</h3></div></div></div><p>The <code class="literal">netnode</code> class also provides functions for deleting individual array elements, the entire contents of an array, or the entire contents of a netnode. Removing an entire netnode is fairly straightforward.<a class="indexterm" id="IDX-CHP-16-0165"/><a class="indexterm" id="IDX-CHP-16-0166"/></p><a id="I_programlisting2_d1e23740"/><pre class="programlisting">netnode n("$ idabook", 0, true);
n.kill();                        //entire contents of n are deleted</pre><p>When deleting individual array elements, or entire array contents, you must take care to choose the proper deletion function because the names of the functions are very similar and choosing the wrong form may result in significant loss of data. Commented examples demonstrating deletion of altvals follow:</p><a id="I_programlisting2_d1e23744"/><pre class="programlisting">netnode n("$ idabook", 0, true);
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> n.altdel(100);       //delete item 100 from the default altval array ('A')
  n.altdel(100, (char)3); //delete item 100 from altval array 3
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> n.altdel();          //delete the entire contents of the default altval array
  n.altdel_all('A');      //alternative to delete default altval array contents
  n.altdel_all((char)3);  //delete the entire contents of altval array 3;</pre><p>Note the similarity in the syntax to delete the entire contents of the default altval array <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e23760"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and the syntax to delete a single element from the default altval array <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e23766"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. If for some reason you fail to specify an index when you want to delete a single element, you may end up deleting an entire array. Similar functions exist to delete supval, charval, and hashval data.</p></div></div><div class="sect2" title="Useful SDK Datatypes"><div class="titlepage"><div><div><h2 class="title"><a id="useful_sdk_datatypes"/>Useful SDK Datatypes</h2></div></div></div><p>IDA’s API defines a number of C++ classes designed to model components typically found in executable files. The SDK contains classes to describe functions, program sections, data structures, individual assembly language instructions, and individual operands within each instruction. Additional classes are defined to implement the tools that IDA uses to manage the disassembly process. Classes falling into this latter category define general database characteristics, loader module characteristics, processor module characteristics, and plug-in module characteristics, and they define the assembly syntax to be used for each disassembled instruction.<a class="indexterm" id="IDX-CHP-16-0167"/><a class="indexterm" id="IDX-CHP-16-0168"/><a class="indexterm" id="IDX-CHP-16-0169"/><a class="indexterm" id="IDX-CHP-16-0170"/><a class="indexterm" id="IDX-CHP-16-0171"/><a class="indexterm" id="IDX-CHP-16-0172"/><a class="indexterm" id="IDX-CHP-16-0173"/></p><p>Some of the more common general-purpose classes are described here. We defer discussion of classes that are more specific to plug-ins, loaders, and processor modules until the appropriate chapters covering those topics. Our goal here is to introduce classes, their purposes, and some important data members of each class. Useful functions for manipulating each class are described in <a class="xref" href="ch16s02.html#commonly_used_sdk_functions" title="Commonly Used SDK Functions">Commonly Used SDK Functions</a> in <a class="xref" href="ch16s02.html#commonly_used_sdk_functions" title="Commonly Used SDK Functions">Commonly Used SDK Functions</a>.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>area_t</code></strong> <span class="strong"><strong>(area.hpp)</strong></span></span></dt><dd><p>This struct describes a range of addresses and is the base class for several other classes. The struct contains two data members, <code class="literal">startEA</code> (inclusive) and <code class="literal">endEA</code> (exclusive), that define the boundaries of the address range. Member functions are defined that compute the size of the address range and that can perform comparisons between two areas.</p></dd><dt><span class="term"><strong class="userinput"><code>func_t</code></strong> <span class="strong"><strong>(funcs.hpp)</strong></span></span></dt><dd><p>This class inherits from <code class="literal">area_t</code>. Additional data fields are added to the class to record binary attributes of the function, such as whether the function uses a frame pointer or not, and attributes describing the function’s local variables and arguments. For optimization purposes, some compilers may split functions into several noncontiguous regions within a binary. IDA terms these regions <span class="emphasis"><em>chunks</em></span> or <span class="emphasis"><em>tails</em></span>. The <code class="literal">func_t</code> class is also used to describe tail chunks.</p></dd><dt><span class="term"><strong class="userinput"><code>segment_t</code></strong> <span class="strong"><strong>(segment.hpp)</strong></span></span></dt><dd><p>The <code class="literal">segment_t</code> class is another subclass of <code class="literal">area_t</code>. Additional data fields describe the name of the segment, the permissions in effect in the segment (readable, writeable, executable), the type of the segment (code, data, etc.), and the number of bits used in a segment address (16, 32, or 64).</p></dd><dt><span class="term"><strong class="userinput"><code>idc_value_t</code></strong> <span class="strong"><strong>(expr.hpp)</strong></span></span></dt><dd><p>This class describes the contents of an IDC value, which may contain at any time a string, an integer, or a floating-point value. The type is utilized extensively when interacting with IDC functions from within a compiled module.</p></dd><dt><span class="term"><strong class="userinput"><code>idainfo</code></strong> <span class="strong"><strong>(ida.hpp)</strong></span></span></dt><dd><p>This struct is populated with characteristics describing the open database. A single global variable named <code class="literal">inf</code>, of type <code class="literal">idainfo</code>, is declared in <span class="emphasis"><em>ida.hpp</em></span>. Fields within this struct describe the name of the processor module that is in use, the input file type (such as <code class="literal">f_PE</code> or <code class="literal">f_MACHO</code> via the <code class="literal">filetype_t</code> enum), the program entry point (<code class="literal">beginEA</code>), the minimum address within the binary (<code class="literal">minEA</code>), the maximum address in the binary (<code class="literal">maxEA</code>), the endianness of the current processor (<code class="literal">mf</code>), and a number of configuration settings parsed from <span class="emphasis"><em>ida.cfg</em></span>.<a class="indexterm" id="IDX-CHP-16-0174"/><a class="indexterm" id="IDX-CHP-16-0175"/><a class="indexterm" id="IDX-CHP-16-0176"/><a class="indexterm" id="IDX-CHP-16-0177"/><a class="indexterm" id="IDX-CHP-16-0178"/><a class="indexterm" id="IDX-CHP-16-0179"/><a class="indexterm" id="IDX-CHP-16-0180"/></p></dd><dt><span class="term"><strong class="userinput"><code>struc_t</code></strong> <span class="strong"><strong>(struct.hpp)</strong></span></span></dt><dd><p>This class describes the layout of structured data within a disassembly. It is used to describe structures within the Structures window as well as to describe the composition of function stack frames. A <code class="literal">struc_t</code> contains flags describing attributes of the structure (such as whether it is a structure or union or whether the structure is collapsed or expanded in the IDA display window), and it also contains an array of structure members.</p></dd><dt><span class="term"><strong class="userinput"><code>member_t</code></strong> <span class="strong"><strong>(struct.hpp)</strong></span></span></dt><dd><p>This class describes a single member of a structured datatype. Included data fields describe the byte offset at which the member begins and ends within its parent structure.</p></dd><dt><span class="term"><strong class="userinput"><code>op_t</code></strong> <span class="strong"><strong>(ua.hpp)</strong></span></span></dt><dd><p>This class describes a single operand within a disassembled instruction. The class contains a zero-based field to store the number of the operand (<code class="literal">n</code>), an operand type field (<code class="literal">type</code>), and a number of other fields whose meaning varies depending on the operand type. The <code class="literal">type</code> field is set to one of the <code class="literal">optype_t</code> constants defined in <span class="emphasis"><em>ua.hpp</em></span> and describes the operand type or addressing mode used for the operand.<a class="indexterm" id="IDX-CHP-16-0181"/></p></dd><dt><span class="term"><strong class="userinput"><code>insn_t</code></strong> <span class="strong"><strong>(ua.hpp)</strong></span></span></dt><dd><p>This class contains information describing a single disassembled instruction. Fields within the class describe the instruction’s address within the disassembly (<code class="literal">ea</code>), the instruction’s type (<code class="literal">itype</code>), the instruction’s length in bytes (<code class="literal">size</code>), and an array of six possible operand values (<code class="literal">Operands</code>) of type <code class="literal">op_t</code> (IDA limits each instruction to a maximum of six operands). The <code class="literal">itype</code> field is set by the processor module. For standard IDA processor modules, the <code class="literal">itype</code> field is set to one of the enumerated constants defined in <span class="emphasis"><em>allins.hpp</em></span>. When a third-party processor module is used, the list of potential <code class="literal">itype</code> values must be obtained from the module developer. Note that the <code class="literal">itype</code> field generally bears no relationship whatsoever to the binary opcode for the instruction.<a class="indexterm" id="IDX-CHP-16-0182"/></p></dd></dl></div><p>The preceding list is by no means a definitive guide to all of the datatypes used within the SDK. This list is intended merely as an introduction to some of the more commonly used classes and some of the more commonly accessed fields within those classes.</p></div><div class="sect2" title="Commonly Used SDK Functions"><div class="titlepage"><div><div><h2 class="title"><a id="commonly_used_sdk_functions"/>Commonly Used SDK Functions</h2></div></div></div><p>While the SDK is programmed using C++ and defines a number of C++ classes, in many cases the SDK favors traditional C-style nonmember functions for manipulation of objects within a database. For most API datatypes, it is more common to find nonmember functions that require a pointer to an object than it is to find a member function to manipulate the object in the manner you desire.<a class="indexterm" id="IDX-CHP-16-0183"/><a class="indexterm" id="IDX-CHP-16-0184"/><a class="indexterm" id="IDX-CHP-16-0185"/><a class="indexterm" id="IDX-CHP-16-0186"/><a class="indexterm" id="IDX-CHP-16-0187"/><a class="indexterm" id="IDX-CHP-16-0188"/><a class="indexterm" id="IDX-CHP-16-0189"/><a class="indexterm" id="IDX-CHP-16-0190"/><a class="indexterm" id="IDX-CHP-16-0191"/><a class="indexterm" id="IDX-CHP-16-0192"/><a class="indexterm" id="IDX-CHP-16-0193"/><a class="indexterm" id="IDX-CHP-16-0194"/><a class="indexterm" id="IDX-CHP-16-0195"/><a class="indexterm" id="IDX-CHP-16-0196"/><a class="indexterm" id="IDX-CHP-16-0197"/><a class="indexterm" id="IDX-CHP-16-0198"/></p><p>In the summaries that follow, we cover API functions that provide functionality similar to many of the IDC functions introduced in <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>. It is unfortunate that functions that perform identical tasks are named one thing in IDC and something different within the API.</p><div class="sect3" title="Basic Database Access"><div class="titlepage"><div><div><h3 class="title"><a id="basic_database_access"/>Basic Database Access</h3></div></div></div><p>The following functions, declared in <span class="emphasis"><em>bytes.hpp</em></span>, provide access to individual bytes, words, and dwords within a database.</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>uchar get_byte(ea_t addr)</code></strong> Reads current byte value from virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>ushort get_word(ea_t addr)</code></strong> Reads current word value from virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>ulong get_long(ea_t addr)</code></strong> Reads current double word value from virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>get_many_bytes(ea_t addr, void *buffer, ssize_t len)</code></strong> Copies <code class="literal">len</code> bytes from the <code class="literal">addr</code> into the supplied buffer.</td></tr><tr><td><strong class="userinput"><code>patch_byte(ea_t addr, ulong val)</code></strong> Sets a byte value at virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>patch_word(long addr, ulonglong val)</code></strong> Sets a word value at virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>patch_long(long addr, ulonglong val)</code></strong> Sets a double word value at virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>patch_many_bytes(ea_t addr, const void *buffer, size_t len)</code></strong> Patches the database beginning at <code class="literal">addr</code> with <code class="literal">len</code> bytes from the user-supplied <code class="literal">buffer</code>.</td></tr><tr><td><strong class="userinput"><code>ulong get_original_byte(ea_t addr)</code></strong> Reads the original byte value (prior to patching) from virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>ulonglong get_original_word(ea_t addr)</code></strong> Reads the original word value from virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>ulonglong get_original_long(ea_t addr)</code></strong> Reads the original double word value from virtual address <code class="literal">addr</code>.</td></tr><tr><td><strong class="userinput"><code>bool isLoaded(ea_t addr)</code></strong> Returns true if <code class="literal">addr</code> contains valid data, false otherwise.</td></tr></table><p>Additional functions exist for accessing alternative data sizes. Note that the <code class="literal">get_original_</code><em class="replaceable"><code>XXX</code></em> functions get the very first <span class="emphasis"><em>original</em></span> value, which is not necessarily the value at an address prior to a patch. Consider the case when a byte value is patched twice; over time this byte has held three different values. After the second patch, both the current value and the original value are accessible, but there is no way to obtain the second value (which was set with the first patch).<a class="indexterm" id="IDX-CHP-16-0199"/><a class="indexterm" id="IDX-CHP-16-0200"/><a class="indexterm" id="IDX-CHP-16-0201"/><a class="indexterm" id="IDX-CHP-16-0202"/><a class="indexterm" id="IDX-CHP-16-0203"/><a class="indexterm" id="IDX-CHP-16-0204"/><a class="indexterm" id="IDX-CHP-16-0205"/><a class="indexterm" id="IDX-CHP-16-0206"/><a class="indexterm" id="IDX-CHP-16-0207"/><a class="indexterm" id="IDX-CHP-16-0208"/><a class="indexterm" id="IDX-CHP-16-0209"/><a class="indexterm" id="IDX-CHP-16-0210"/><a class="indexterm" id="IDX-CHP-16-0211"/><a class="indexterm" id="IDX-CHP-16-0212"/><a class="indexterm" id="IDX-CHP-16-0213"/></p></div><div class="sect3" title="User Interface Functions"><div class="titlepage"><div><div><h3 class="title"><a id="user_interface_functions"/>User Interface Functions</h3></div></div></div><p>Interaction with the IDA user interface is handled by a single <span class="emphasis"><em>dispatcher</em></span> function named <code class="literal">callui</code>. Requests for various user interface services are made by passing a user interface request (one of the enumerated <code class="literal">ui_notification_t</code> constants) to <code class="literal">callui</code> along with any additional parameters required by the request. Parameters required for each request type are specified in <span class="emphasis"><em>kernwin.hpp</em></span>. Fortunately, a number of convenience functions that hide many of the details of using <code class="literal">callui</code> directly are also defined in <span class="emphasis"><em>kernwin.hpp</em></span>. Several common convenience functions are described here:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>msg(char *format, ...)</code></strong> Prints a formatted message to the message window. This function is analogous to C’s <code class="literal">printf</code> function and accepts a <code class="literal">printf</code>-style format string.</td></tr><tr><td><strong class="userinput"><code>warning(char *format, ...)</code></strong> Displays a formatted message in a dialog.</td></tr><tr><td><strong class="userinput"><code>char *askstr(int hist, char *default, char *format, ...)</code></strong> Displays an input dialog asking the user to enter a string value. The <code class="literal">hist</code> parameter dictates how the drop-down history list in the dialog should be populated and should be set to one of the <code class="literal">HIST_</code><em class="replaceable"><code>xxx</code></em> constants defined in <span class="emphasis"><em>kernwin.hpp</em></span>. The <code class="literal">format</code> string and any additional parameters are use to form a prompt string.</td></tr><tr><td><strong class="userinput"><code>char *askfile_c(int dosave, char *default, char *prompt, ...)</code></strong> Displays a file save (<code class="literal">dosave</code> = 1) or file open (<code class="literal">dosave</code> = 0) dialog, initially displaying the directory and file mask specified by default (such as <code class="literal">C:\\windows\\*.exe</code>). Returns the name of the selected file or NULL if the dialog was canceled.</td></tr><tr><td><strong class="userinput"><code>askyn_c(int default, char *prompt, ...)</code></strong> Prompts the user with a yes or no question, highlighting a <span class="emphasis"><em>default</em></span> answer (1 = yes, 0 = no,-1 = cancel). Returns an integer representing the selected answer.</td></tr><tr><td><strong class="userinput"><code>AskUsingForm_c(const char *form, ...)</code></strong> The <code class="literal">form</code> parameter is an ASCII string specification of a dialog and its associated input elements. This function may be used to build customized user interface elements when none of the SDK’s other convenience functions meet your needs. The format of the <code class="literal">form</code> string is detailed in <span class="emphasis"><em>kernwin.hpp</em></span>.</td></tr><tr><td><strong class="userinput"><code>get_screen_ea()</code></strong> Returns the virtual address of the current cursor location.</td></tr><tr><td><strong class="userinput"><code>jumpto(ea_t addr)</code></strong> Jumps the disassembly window to the specified address.</td></tr></table><p>Many more user interface capabilities are available using the API than are available with IDC scripting, including the ability to create customized single- and multicolumn list selection dialogs. Users interested in these capabilities should consult <span class="emphasis"><em>kernwin.hpp</em></span> and the <code class="literal">choose</code> and <code class="literal">choose2</code> functions in particular.</p></div><div class="sect3" title="Manipulating Database Names"><div class="titlepage"><div><div><h3 class="title"><a id="manipulating_database_names-id1"/>Manipulating Database Names</h3></div></div></div><p>The following functions are available for working with named locations within a database:<a class="indexterm" id="IDX-CHP-16-0214"/><a class="indexterm" id="IDX-CHP-16-0215"/><a class="indexterm" id="IDX-CHP-16-0216"/><a class="indexterm" id="IDX-CHP-16-0217"/><a class="indexterm" id="IDX-CHP-16-0218"/><a class="indexterm" id="IDX-CHP-16-0219"/><a class="indexterm" id="IDX-CHP-16-0220"/><a class="indexterm" id="IDX-CHP-16-0221"/><a class="indexterm" id="IDX-CHP-16-0222"/><a class="indexterm" id="IDX-CHP-16-0223"/></p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>get_name(ea_t from, ea_t addr, char *namebuf, size_t maxsize)</code></strong> Returns the name associated with <code class="literal">addr</code>. Returns the empty string if the location has no name. This function provides access to local names when <code class="literal">from</code> is any address in the function that contains <code class="literal">addr</code>. The name is copied into the provided output buffer.</td></tr><tr><td><strong class="userinput"><code>set_name(ea_t addr, char *name, int flags)</code></strong> Assigns the given name to the given address. The name is created with attributes specified in the <code class="literal">flags</code> bitmask. Possible flag values are described in <span class="emphasis"><em>name.hpp</em></span>.</td></tr><tr><td><strong class="userinput"><code>get_name_ea(ea_t funcaddr, char *localname)</code></strong> Searches for the given local name within the function containing <code class="literal">funcaddr</code>. Returns the address of the name or BADADDR (-1) if no such name exists in the given function.</td></tr></table></div><div class="sect3" title="Function Manipulation"><div class="titlepage"><div><div><h3 class="title"><a id="function_manipulation"/>Function Manipulation</h3></div></div></div><p>The API functions for accessing information about disassembled functions are declared in <span class="emphasis"><em>funcs.hpp</em></span>. Functions for accessing stack frame information are declared in <span class="emphasis"><em>frame.hpp</em></span>. Some of the more commonly used functions are described here:<a class="indexterm" id="IDX-CHP-16-0224"/></p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>func_t *get_func(ea_t addr)</code></strong> Returns a pointer to a <code class="literal">func_t</code> object that describes the function containing the indicated address.</td></tr><tr><td><strong class="userinput"><code>size_t get_func_qty()</code></strong> Returns the number of functions present in the database.</td></tr><tr><td><strong class="userinput"><code>func_t *getn_func(size_t n)</code></strong> Returns a pointer to a <code class="literal">func_t</code> object that represents the <span class="emphasis"><em>n</em></span>th function in the database where <em class="replaceable"><code>n</code></em> is between zero (inclusive) and <code class="literal">get_func_qty()</code> (exclusive).</td></tr><tr><td><strong class="userinput"><code>func_t *get_next_func(ea_t addr)</code></strong> Returns a pointer to a <code class="literal">func_t</code> object that describes the next function following the specified address.</td></tr><tr><td><strong class="userinput"><code>get_func_name(ea_t addr, char *name, size_t namesize)</code></strong> Copies the name of the function containing the indicated address into the supplied name buffer.</td></tr><tr><td><strong class="userinput"><code>struc_t *get_frame(ea_t addr)</code></strong> Returns a pointer to a <code class="literal">struc_t</code> object that describes the stack frame for the function that contains the indicated address.</td></tr></table></div><div class="sect3" title="Structure Manipulation"><div class="titlepage"><div><div><h3 class="title"><a id="structure_manipulation"/>Structure Manipulation</h3></div></div></div><p>The <code class="literal">struc_t</code> class is used to access function stack frames as well as structured datatypes defined within type libraries. Some of the basic functions for interacting with structures and their associated members are described here. Many of these functions make use of a type ID (<code class="literal">tid_t</code>) datatype. The API includes functions for mapping a <code class="literal">struc_t</code> to an associated <code class="literal">tid_t</code> and vice versa. Note that both the <code class="literal">struc_t</code> and <code class="literal">member_t</code> classes contain a <code class="literal">tid_t</code> data member, so obtaining type ID information is simple if you already have a pointer to a valid <code class="literal">struc_t</code> or <code class="literal">member_t</code> object.<a class="indexterm" id="IDX-CHP-16-0225"/><a class="indexterm" id="IDX-CHP-16-0226"/><a class="indexterm" id="IDX-CHP-16-0227"/><a class="indexterm" id="IDX-CHP-16-0228"/><a class="indexterm" id="IDX-CHP-16-0229"/><a class="indexterm" id="IDX-CHP-16-0230"/><a class="indexterm" id="IDX-CHP-16-0231"/><a class="indexterm" id="IDX-CHP-16-0232"/><a class="indexterm" id="IDX-CHP-16-0233"/><a class="indexterm" id="IDX-CHP-16-0234"/><a class="indexterm" id="IDX-CHP-16-0235"/><a class="indexterm" id="IDX-CHP-16-0236"/><a class="indexterm" id="IDX-CHP-16-0237"/></p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>tid_t get_struc_id(char *name)</code></strong> Looks up the type ID of a structure given its name.</td></tr><tr><td><strong class="userinput"><code>struc_t *get_struc(tid_t id)</code></strong> Obtains a pointer to a <code class="literal">struc_t</code> representing the structure specified by the given type ID.</td></tr><tr><td><strong class="userinput"><code>asize_t get_struc_size(struc_t *s)</code></strong> Returns the size of the given structure in bytes.</td></tr><tr><td><strong class="userinput"><code>member_t *get_member(struc_t *s, asize_t offset)</code></strong> Returns a pointer to a <code class="literal">member_t</code> object that describes the structure member that resides at the specified <code class="literal">offset</code> into the given structure.</td></tr><tr><td><strong class="userinput"><code>member_t *get_member_by_name(struc_t *s, char *name)</code></strong> Returns a pointer to a <code class="literal">member_t</code> object that describes the structure member identified by the given <code class="literal">name</code>.</td></tr><tr><td><strong class="userinput"><code>tid_t add_struc(uval_t index, char *name, bool is_union=false)</code></strong> Appends a new structure with the given <code class="literal">name</code> into the standard structures list. The structure is also added to the Structures window at the given <code class="literal">index</code>. If <code class="literal">index</code> is <code class="literal">BADADDR</code>, the structure is added as the last structure in the Structures window.</td></tr><tr><td><strong class="userinput"><code>add_struc_member(struc_t *s, char *name, ea_t offset, flags_t flags, typeinfo_t *info, asize_t size)</code></strong> Adds a new member with the given <code class="literal">name</code> to the given structure. The member is either added at the indicated <code class="literal">offset</code> within the structure or appended to the end of the structure if <code class="literal">offset</code> is <code class="literal">BADADDR</code>. The <code class="literal">flags</code> parameter describes the datatype of the new member. Valid flags are defined using the <code class="literal">FF_</code><em class="replaceable"><code>XXX</code></em> constants described in <span class="emphasis"><em>bytes.hpp</em></span>. The <code class="literal">info</code> parameter provides additional information for complex datatypes; it may be set to <code class="literal">NULL</code> for primitive datatypes. The <code class="literal">typeinfo_t</code> datatype is defined in <span class="emphasis"><em>nalt.hpp</em></span>. The <code class="literal">size</code> parameter specifies the number of bytes occupied by the new member.</td></tr></table></div><div class="sect3" title="Segment Manipulation"><div class="titlepage"><div><div><h3 class="title"><a id="segment_manipulation"/>Segment Manipulation</h3></div></div></div><p>The <code class="literal">segment_t</code> class stores information related to the different segments within a database (such as <code class="literal">.text</code> and <code class="literal">.data</code>) as listed in the View ▸ Open Subviews ▸ Segments window. Recall that what IDA terms <span class="emphasis"><em>segments</em></span> are often referred to as <span class="emphasis"><em>sections</em></span> by various executable file formats such as PE and ELF. The following functions provide basic access to <code class="literal">segment_t</code> objects. Additional functions dealing with the <code class="literal">segment_t</code> class are declared in <span class="emphasis"><em>segment.hpp</em></span>.</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>segment_t *getseg(ea_t addr)</code></strong> Returns a pointer to the <code class="literal">segment_t</code> object that contains the given address.</td></tr><tr><td><strong class="userinput"><code>segment_t *ida_export get_segm_by_name(char *name)</code></strong> Returns a pointer to the <code class="literal">segment_t</code> object with the given name.</td></tr><tr><td><strong class="userinput"><code>add_segm(ea_t para, ea_t start, ea_t end, char *name, char *sclass)</code></strong> Creates a new segment in the current database. The segment’s boundaries are specified with the <code class="literal">start</code> (inclusive) and <code class="literal">end</code> (exclusive) address parameters, while the segment’s name is specified by the <code class="literal">name</code> parameter. The segment’s class loosely describes the type of segment being created. Predefined classes include <code class="literal">CODE</code> and <code class="literal">DATA</code>. A complete list of predefined classes may be found in <span class="emphasis"><em>segment.hpp</em></span>. The <code class="literal">para</code> parameter describes the base address of the section when segmented addresses (<code class="literal">seg:offset</code>) are being used, in which case <code class="literal">start</code> and <code class="literal">end</code> are interpreted as offsets rather than as virtual addresses. When segmented addresses are not being used, or all segments are based at 0, this parameter should be set to 0.</td></tr><tr><td><strong class="userinput"><code>add_segm_ex(segment_t *s, char *name, char *sclass, int flags)</code></strong> Alternate method for creating new segments. The fields of <code class="literal">s</code> should be set to reflect the address range of the segment. The segment is named and typed according to the <code class="literal">name</code> and <code class="literal">sclass</code> parameters. The <code class="literal">flags</code> parameter should be set to one of the <code class="literal">ADDSEG_</code><em class="replaceable"><code>XXX</code></em> values defined in <span class="emphasis"><em>segment.hpp</em></span>.</td></tr><tr><td><strong class="userinput"><code>int get_segm_qty()</code></strong> Returns the number of sections present within the database.</td></tr><tr><td><strong class="userinput"><code>segment_t *getnseg(int n)</code></strong> Returns a pointer to a <code class="literal">segment_t</code> object populated with information about the <span class="emphasis"><em>n</em></span>th program section in the database.</td></tr><tr><td><strong class="userinput"><code>int set_segm_name(segment_t *s, char *name, ...)</code></strong> Changes the name of the given segment. The name is formed by treating <code class="literal">name</code> as a format string and incorporating any additional parameters as required by the format string.</td></tr><tr><td><strong class="userinput"><code>get_segm_name(ea_t addr, char *name, size_t namesize)</code></strong> Copies the name of the segment containing the given address into the user-supplied <code class="literal">name</code> buffer. Note the <code class="literal">name</code> may be filtered to replace characters that IDA considers invalid (characters not specified as <code class="literal">NameChars</code> in <span class="emphasis"><em>ida.cfg</em></span>) with a dummy character (typically an underscore as specified by <code class="literal">SubstChar</code> in <span class="emphasis"><em>ida.cfg</em></span>).</td></tr><tr><td><strong class="userinput"><code>get_segm_name(segment_t *s, char *name, size_t namesize)</code></strong> Copies the potentially filtered name of the given segment into the user-supplied <code class="literal">name</code> buffer.</td></tr><tr><td><strong class="userinput"><code>get_true_segm_name(segment_t *s, char *name, size_t namesize)</code></strong> Copies the exact name of the given segment into the user-supplied <code class="literal">name</code> buffer without filtering any characters.</td></tr></table><p>One of the <code class="literal">add_segm</code> functions must be used to actually create a segment. Simply declaring and initializing a <code class="literal">segment_t</code> object does not actually create a segment within the database. This is true with all of the wrapper classes such as <code class="literal">func_t</code> and <code class="literal">struc_t</code>. These classes merely provide a convenient means to access attributes of an underlying database entity. The appropriate functions to create, modify, or delete actual database objects must be utilized in order to make persistent changes to the database.<a class="indexterm" id="IDX-CHP-16-0238"/><a class="indexterm" id="IDX-CHP-16-0239"/><a class="indexterm" id="IDX-CHP-16-0240"/><a class="indexterm" id="IDX-CHP-16-0241"/><a class="indexterm" id="IDX-CHP-16-0242"/><a class="indexterm" id="IDX-CHP-16-0243"/><a class="indexterm" id="IDX-CHP-16-0244"/><a class="indexterm" id="IDX-CHP-16-0245"/><a class="indexterm" id="IDX-CHP-16-0246"/><a class="indexterm" id="IDX-CHP-16-0247"/><a class="indexterm" id="IDX-CHP-16-0248"/><a class="indexterm" id="IDX-CHP-16-0249"/><a class="indexterm" id="IDX-CHP-16-0250"/><a class="indexterm" id="IDX-CHP-16-0251"/></p></div><div class="sect3" title="Code Cross-References"><div class="titlepage"><div><div><h3 class="title"><a id="code_cross-references-id1"/>Code Cross-References</h3></div></div></div><p>A number of functions and enumerated constants are defined in <span class="emphasis"><em>xref.hpp</em></span> for use with code cross-references. Some of these are described here:<a class="indexterm" id="IDX-CHP-16-0252"/><a class="indexterm" id="IDX-CHP-16-0253"/><a class="indexterm" id="IDX-CHP-16-0254"/><a class="indexterm" id="IDX-CHP-16-0255"/><a class="indexterm" id="IDX-CHP-16-0256"/><a class="indexterm" id="IDX-CHP-16-0257"/><a class="indexterm" id="IDX-CHP-16-0258"/><a class="indexterm" id="IDX-CHP-16-0259"/><a class="indexterm" id="IDX-CHP-16-0260"/><a class="indexterm" id="IDX-CHP-16-0261"/><a class="indexterm" id="IDX-CHP-16-0262"/></p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>get_first_cref_from(ea_t from)</code></strong> Returns the first location to which the given address transfers control. Returns BADADDR (-1) if the given address refers to no other addresses.</td></tr><tr><td><strong class="userinput"><code>get_next_cref_from(ea_t from, ea_t current)</code></strong> Returns the next location to which the given address (<code class="literal">from</code>) transfers control, given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">get_first_cref_from</code> or <code class="literal">get_next_cref_from</code>. Returns BADADDR if no more cross-references exist.</td></tr><tr><td><strong class="userinput"><code>get_first_cref_to(ea_t to)</code></strong> Returns the first location that transfers control to the given address. Returns BADADDR (-1) if there are no references to the given address.</td></tr><tr><td><strong class="userinput"><code>get_next_cref_to(ea_t to, ea_t current)</code></strong> Returns the next location that transfers control to the given address (<code class="literal">to</code>), given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">get_first_cref_to</code> or <code class="literal">get_next_cref_to</code>. Returns BADADDR if no more cross-references to the given location exist.</td></tr></table></div><div class="sect3" title="Data Cross-References"><div class="titlepage"><div><div><h3 class="title"><a id="data_cross-references-id1"/>Data Cross-References</h3></div></div></div><p>The functions for accessing data cross-reference information (also declared in <span class="emphasis"><em>xref.hpp</em></span>) are very similar to the functions used to access code cross-reference information. These functions are described here:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>get_first_dref_from(ea_t from)</code></strong> Returns the first location to which the given address refers to a data value. Returns BADADDR (-1) if the given address refers to no other addresses.</td></tr><tr><td><strong class="userinput"><code>get_next_dref_from(ea_t from, ea_t current)</code></strong> Returns the next location to which the given address (<code class="literal">from</code>) refers a data value, given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">get_first_dref_from</code> or <code class="literal">get_next_dref_from</code>. Returns BADADDR if no more cross-references exist.</td></tr><tr><td><strong class="userinput"><code>get_first_dref_to(ea_t to)</code></strong> Returns the first location that refers to the given address as data. Returns BADADDR (-1) if there are no references to the given address.</td></tr><tr><td><strong class="userinput"><code>get_next_dref_to(ea_t to, ea_t current)</code></strong> Returns the next location that refers to the given address (<code class="literal">to</code>) as data, given that <code class="literal">current</code> has already been returned by a previous call to <code class="literal">get_first_dref_to</code> or <code class="literal">get_next_dref_to</code>. Returns BADADDR if no more cross-references to the given location exist.</td></tr></table><p>The SDK contains no equivalent to IDC’s <code class="literal">XrefType</code> function. A variable named <code class="literal">lastXR</code> is declared in <span class="emphasis"><em>xref.hpp</em></span>; however, it is not exported. If you need to determine the exact type of a cross-reference, you must iterate cross-references using an <code class="literal">xrefblk_t</code> structure. The <code class="literal">xrefblk_t</code> is described in “Enumerating Cross-References</p></div></div><div class="sect2" title="Iteration Techniques Using the IDA API"><div class="titlepage"><div><div><h2 class="title"><a id="iteration_techniques_using_the_ida_api"/>Iteration Techniques Using the IDA API</h2></div></div></div><p>Using the IDA API, there are often several different ways to iterate over various database objects. In the following examples we demonstrate some common iteration techniques:<a class="indexterm" id="IDX-CHP-16-0263"/><a class="indexterm" id="IDX-CHP-16-0264"/><a class="indexterm" id="IDX-CHP-16-0265"/><a class="indexterm" id="IDX-CHP-16-0266"/><a class="indexterm" id="IDX-CHP-16-0267"/><a class="indexterm" id="IDX-CHP-16-0268"/><a class="indexterm" id="IDX-CHP-16-0269"/><a class="indexterm" id="IDX-CHP-16-0270"/><a class="indexterm" id="IDX-CHP-16-0271"/><a class="indexterm" id="IDX-CHP-16-0272"/><a class="indexterm" id="IDX-CHP-16-0273"/><a class="indexterm" id="IDX-CHP-16-0274"/></p><div class="sect3" title="Enumerating Functions"><div class="titlepage"><div><div><h3 class="title"><a id="enumerating_functions-id2"/>Enumerating Functions</h3></div></div></div><p>The first technique for iterating through the functions within a database mimics the manner in which we performed the same task using IDC:<a class="indexterm" id="IDX-CHP-16-0275"/></p><a id="I_programlisting2_d1e25105"/><pre class="programlisting">for (func_t *f = get_next_func(0); f != NULL; f = get_next_func(f-&gt;startEA)) {
   char fname[1024];
   get_func_name(f-&gt;startEA, fname, sizeof(fname));
   msg("%08x: %s\n", f-&gt;startEA, fname);
}</pre><p>Alternatively, we can simply iterate through functions by index numbers, as shown in the next example:</p><a id="I_programlisting2_d1e25109"/><pre class="programlisting">for (int idx = 0; idx &lt; get_func_qty(); idx++) {
   char fname[1024];
   func_t *f = getn_func(idx);
   get_func_name(f-&gt;startEA, fname, sizeof(fname));
   msg("%08x: %s\n", f-&gt;startEA, fname);
}</pre><p>Finally, we can work at a somewhat lower level and make use of a data structure called an <code class="literal">areacb_t</code>, also known as an <span class="emphasis"><em>area control block</em></span>, defined in <span class="emphasis"><em>area.hpp</em></span>. Area control blocks are used to maintain lists of related <code class="literal">area_t</code> objects. A global <code class="literal">areacb_t</code> named <code class="literal">funcs</code> is exported (in <span class="emphasis"><em>funcs.hpp</em></span>) as part of the IDA API. Using the <code class="literal">areacb_t</code> class, the previous example can be rewritten as follows:<a class="indexterm" id="IDX-CHP-16-0276"/><a class="indexterm" id="IDX-CHP-16-0277"/></p><a id="I_programlisting2_d1e25144"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> int a = funcs.get_next_area(0);
  while (a != −1) {
     char fname[1024];
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>    func_t *f = (func_t*)funcs.getn_area(a);  // getn_area returns an area_t
     get_func_name(f-&gt;startEA, fname, sizeof(fname));
     msg("%08x: %s\n", f-&gt;startEA, fname);
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>    a = funcs.get_next_area(f-&gt;startEA);
  }</pre><p>In this example, the <code class="literal">get_next_area</code> member function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25168"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25174"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> is used repeatedly to obtain the index values for each area in the <code class="literal">funcs</code> control block. A pointer to each related <code class="literal">func_t</code> area is obtained by supplying each index value to the <code class="literal">getn_area</code> member function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25190"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. Several global <code class="literal">areacb_t</code> variables are declared within the SDK, including the <code class="literal">segs</code> global, which is an area control block containing <code class="literal">segment_t</code> pointers for each section in the binary.</p></div><div class="sect3" title="Enumerating Structure Members"><div class="titlepage"><div><div><h3 class="title"><a id="enumerating_structure_members"/>Enumerating Structure Members</h3></div></div></div><p>Within the SDK, stack frames are modeled using the capabilities of the <code class="literal">struc_t</code> class. The example in <a class="xref" href="ch16s02.html#enumerating_stack_frame_members" title="Example 16-6. Enumerating stack frame members">Example 16-6</a> utilizes structure member iteration as a means of printing the contents of a stack frame.<a class="indexterm" id="IDX-CHP-16-0278"/><a class="indexterm" id="IDX-CHP-16-0279"/><a class="indexterm" id="IDX-CHP-16-0280"/><a class="indexterm" id="IDX-CHP-16-0281"/><a class="indexterm" id="IDX-CHP-16-0282"/><a class="indexterm" id="IDX-CHP-16-0283"/><a class="indexterm" id="IDX-CHP-16-0284"/><a class="indexterm" id="IDX-CHP-16-0285"/><a class="indexterm" id="IDX-CHP-16-0286"/><a class="indexterm" id="IDX-CHP-16-0287"/><a class="indexterm" id="IDX-CHP-16-0288"/><a class="indexterm" id="IDX-CHP-16-0289"/></p><div class="example"><a id="enumerating_stack_frame_members"/><p class="title">Example 16-6. Enumerating stack frame members</p><div class="example-contents"><pre class="programlisting">func_t *func = get_func(get_screen_ea());  //get function at cursor location
msg("Local variable size is %d\n", func-&gt;frsize);
msg("Saved regs size is %d\n", func-&gt;frregs);
struc_t *frame = get_frame(func);          //get pointer to stack frame
if (frame) {
   size_t ret_addr = func-&gt;frsize + func-&gt;frregs;  //offset to return address
   for (size_t m = 0; m &lt; frame-&gt;memqty; m++) {    //loop through members
      char fname[1024];
      get_member_name(frame-&gt;members[m].id, fname, sizeof(fname));
      if (frame-&gt;members[m].soff &lt; func-&gt;frsize) {
         msg("Local variable ");
      }
      else if (frame-&gt;members[m].soff &gt; ret_addr) {
         msg("Parameter ");
      }
      msg("%s is at frame offset %x\n", fname, frame-&gt;members[m].soff);
      if (frame-&gt;members[m].soff == ret_addr) {
         msg("%s is the saved return address\n", fname);
      }
   }
}</pre></div></div><p>This example summarizes a function’s stack frame using information from the function’s <code class="literal">func_t</code> object and the associated <code class="literal">struc_t</code> representing the function’s stack frame. The <code class="literal">frsize</code> and and <code class="literal">frregs</code> fields specify the size of the local variable portion of the stack frame and the number of bytes dedicated to saved registers, respectively. The saved return address can be found within the frame following the local variables and the saved registers. Within the frame itself, the <code class="literal">memqty</code> field specifies the number of defined members contained in the frame structure, which also corresponds to the size of the <code class="literal">members</code> array. A loop is used to retrieve the name of each member and determine whether the member is a local variable or an argument based on its starting offset (<code class="literal">soff</code>) within the frame structure.</p></div><div class="sect3" title="Enumerating Cross-References"><div class="titlepage"><div><div><h3 class="title"><a id="enumerating_cross-references-id2"/>Enumerating Cross-References</h3></div></div></div><p>In <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a> we saw that it is possible to enumerate cross-references from IDC scripts. The same capabilities exist within the SDK, though in a some-what different form. As an example, let’s revisit the idea of listing all calls of a particular function (see <a class="xref" href="ch15s05.html#enumerating_a_functionas_callers" title="Example 15-4. Enumerating a function’s callers">Example 15-4</a> in <a class="xref" href="ch15s05.html#enumerating_exported_functions" title="Enumerating Exported Functions">Enumerating Exported Functions</a>). The following function almost works.</p><a id="I_programlisting2_d1e25302"/><pre class="programlisting">void list_callers(char *bad_func) {
   char name_buf[MAXNAMELEN];
   ea_t func = get_name_ea(BADADDR, bad_func);
   if (func == BADADDR) {
      warning("Sorry, %s not found in database", bad_func);
   }
   else {
      for (ea_t addr = get_first_cref_to(func); addr != BADADDR;
           addr = get_next_cref_to(func, addr)) {
         char *name = get_func_name(addr, name_buf, sizeof(name_buf));
         if (name) {
            msg("%s is called from 0x%x in %s\n", bad_func, addr, name);
         }
         else {
            msg("%s is called from 0x%x\n", bad_func, addr);
         }
      }
   }
}</pre><p>The reason this function almost works is that there is no way to determine the type of cross-reference returned for each iteration of the loop (recall that there is no SDK equivalent for IDC’s <code class="literal">XrefType</code>). In this case we should verify that each cross-reference to the given function is in fact a call type (<code class="literal">fl_CN</code> or <code class="literal">fl_CF</code>) cross-reference.<a class="indexterm" id="IDX-CHP-16-0290"/></p><p>When you need to determine the type of a cross-reference within the SDK, you must use an alternative form of cross-reference iteration facilitated by the <code class="literal">xrefblk_t</code> structure, which is described in <span class="emphasis"><em>xref.hpp</em></span>. The basic layout of an <code class="literal">xrefblk_t</code> is shown in the following listing. (For full details, please see <span class="emphasis"><em>xref.hpp</em></span>.)</p><a id="I_programlisting2_d1e25332"/><pre class="programlisting">struct xrefblk_t {
    ea_t from;     // the referencing address - filled by first_to(),next_to()
    ea_t to;       // the referenced address - filled by first_from(), next_from()
    uchar iscode;  // 1-is code reference; 0-is data reference
    uchar type;    // type of the last returned reference
    uchar user;    // 1-is user defined xref, 0-defined by ida

    //fill the "to" field with the first address to which "from" refers.
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>   bool first_from(ea_t from, int flags);

    //fill the "to" field with the next address to which "from" refers.
    //This function assumes a previous call to first_from.
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>   bool next_from(void);

    //fill the "from" field with the first address that refers to "to".
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>   bool first_to(ea_t to,int flags);

    //fill the "from" field with the next address that refers to "to".
    //This function assumes a previous call to first_to.
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>   bool next_to(void);
  };</pre><p>The member functions of <code class="literal">xrefblk_t</code> are used to initialize the structure <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25363"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25369"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and perform the iteration <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25375"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25381"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>, while the data members are used to access information about the last cross-reference that was retrieved. The <code class="literal">flags</code> value required by the <code class="literal">first_from</code> and <code class="literal">first_to</code> functions dictates which type of cross-references should be returned. Legal values for the <code class="literal">flags</code> parameter include the following (from <span class="emphasis"><em>xref.hpp</em></span>):<a class="indexterm" id="IDX-CHP-16-0291"/><a class="indexterm" id="IDX-CHP-16-0292"/><a class="indexterm" id="IDX-CHP-16-0293"/><a class="indexterm" id="IDX-CHP-16-0294"/></p><a id="I_programlisting2_d1e25416"/><pre class="programlisting">#define XREF_ALL        0x00            // return all references
#define XREF_FAR        0x01            // don't return ordinary flow xrefs
#define XREF_DATA       0x02            // return data references only</pre><p>Note that no flag value restricts the returned references to code only. If you are interested in code cross-references, you must either compare the <code class="literal">xrefblk_t type</code> field to specific cross-reference types (such as <code class="literal">fl_JN</code>) or test the <code class="literal">iscode</code> field to determine if the last returned cross-reference was a code cross-reference.</p><p>The following modified version of the <code class="literal">list_callers</code> function demonstrates the use of an <code class="literal">xrefblk_t</code> iteration structure.</p><a id="I_programlisting2_d1e25437"/><pre class="programlisting">void list_callers(char *bad_func) {
     char name_buf[MAXNAMELEN];
     ea_t func = get_name_ea(BADADDR, bad_func);
     if (func == BADADDR) {
        warning("Sorry, %s not found in database", bad_func);
     }
     else {
        xrefblk_t xr;
        for (bool ok = xr.first_to(func, XREF_ALL); ok; ok = xr.next_to()) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>          if (xr.type != fl_CN &amp;&amp; xr.type != fl_CF) continue;
           char *name = get_func_name(xr.from, name_buf, sizeof(name_buf));
           if (name) {
              msg("%s is called from 0x%x in %s\n", bad_func, xr.from, name);
           }
           else {
              msg("%s is called from 0x%x\n", bad_func, xr.from);
           }
        }
     }
  }</pre><p>Through the use of an <code class="literal">xrefblk_t</code>, we now have the opportunity to examine <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e25451"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> the type of each cross-reference returned by the iterator and decide whether it is interesting to us or not. In this example we simply ignore any cross-reference that is not related to a function call. We did not use the <code class="literal">iscode</code> member of <code class="literal">xrefblk_t</code> because <code class="literal">iscode</code> is true for jump and ordinary flow cross-references in addition to call cross-references. Thus, <code class="literal">iscode</code> alone does not guarantee that the current cross-reference is related to a function call.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-3" id="ftn.CHP-16-FN-3">116</a>] </sup><span class="emphasis"><em>Binary large object</em></span>, or <span class="emphasis"><em>blob</em></span>, is a term often used to refer to arbitray binary data of varying size.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id15"/>Summary</h1></div></div></div><p>The functions and data structures described in this chapter only scratch the surface of IDA’s API. For each of the functional categories described, many more API functions exist that perform more specialized tasks and that provide much finer control over various database elements than can be implemented using IDC. In the following chapters we will cover the details of building plug-in modules, loader modules, and processor modules, and we will continue to expand our presentation of the capabilities of the SDK.</p></div>
<div class="chapter" title="Chapter&#xA0;17.&#xA0;The IDA Plug-in Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="the_ida_plug-in_architecture"/>Chapter 17. The IDA Plug-in Architecture</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id16"/><div class="mediaobject"><a id="I_mediaobject3_d1e25479"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>Over the course of the next few chapters, we will cover the types of modules that can be constructed using the IDA SDK. We will also discuss new features (since IDA 5.7) that allow for the development of these same types of modules using one of IDA’s scripting languages. Whether you ever intend to create your own plug-ins or not, a basic understanding of plug-ins will greatly enhance your experience using IDA, since, arguably, the majority of third-party software developed for use with IDA is distributed in the form of plug-ins. In this chapter, we begin the exploration of IDA modules by discussing the purpose of IDA plug-ins, along with how to build, install, and configure them.<a class="indexterm" id="IDX-CHP-17-0001"/></p><p>Plug-ins are probably best described as the compiled, albeit more powerful, equivalents of IDA scripts. Plug-ins are usually associated with a hotkey and/or a menu item and are typically accessible only after a database has been opened. Individual plug-ins may be general purpose in nature and useful across a wide variety of binary file types and processor architectures, or they may be very specialized, designed to be used only with a specific file format or processor type. In all cases, by virtue of being compiled modules, plug-ins have full access to the IDA API and can generally perform much more complex tasks than you could ever hope to accomplish using scripting alone.<a class="indexterm" id="IDX-CHP-17-0002"/><a class="indexterm" id="IDX-CHP-17-0003"/><a class="indexterm" id="IDX-CHP-17-0004"/><a class="indexterm" id="IDX-CHP-17-0005"/><a class="indexterm" id="IDX-CHP-17-0006"/><a class="indexterm" id="IDX-CHP-17-0007"/><a class="indexterm" id="IDX-CHP-17-0008"/></p><div class="sect1" title="Writing a Plug-in"><div class="titlepage"><div><div><h1 class="title"><a id="writing_a_plug-in"/>Writing a Plug-in</h1></div></div></div><p>All IDA modules, including plug-ins, are implemented as shared library components appropriate to the platform on which the plug-in is expected to execute. Under IDA’s modular architecture, modules are not required to export any functions. Instead, each module type must export a variable of a specific class. In the case of plug-ins, this class is called a <code class="literal">plugin_t</code> and is defined in the SDK’s <span class="emphasis"><em>loader.hpp</em></span> file.</p><div class="sidebar"><a id="the_evolving_ida_api"/><p class="title">THE EVOLVING IDA API</p><p>Since SDK 4.9, Hex-Rays has attempted to minimize changes to existing API functions between releases of IDA. One result of this policy is that binary plug-ins from an older version of IDA can often be copied directly into newer IDA installations and continue to work properly. Nonetheless, IDA’s API has grown with each new release, introducing new functions and new options to take advantage of IDA’s everexpanding list of capabilities. As the SDK has evolved, Hex-Rays has opted to deprecate the occasional API function. When a function (or any other symbol) is deprecated, Hex-Rays moves it into a code block bounded by a test of the <code class="literal">NO_OBSOLETE_FUNCS</code> macro. If you wish to ensure that your plug-ins (or other modules) are not using any deprecated functions, you should define <code class="literal">NO_OBSOLETE_FUNCS</code> prior to including any SDK header files.</p></div><p>In order to understand how to create a plug-in, you must first understand the <code class="literal">plugin_t</code> class and its component data fields (the class has no member functions). The layout of the <code class="literal">plugin_t</code> class is shown here, with comments taken from <span class="emphasis"><em>loader.hpp</em></span>:</p><a id="I_programlisting3_d1e25547"/><pre class="programlisting">class plugin_t {
public:
  int version;          // Should be equal to IDP_INTERFACE_VERSION
  int flags;            // Features of the plugin
  int (idaapi* init)(void); // Initialize plugin
  void (idaapi* term)(void);   // Terminate plugin. This function will be called
                            // when the plugin is unloaded. May be NULL.
  void (idaapi* run)(int arg); // Invoke plugin
  char *comment;               // Long comment about the plugin
  char *help;           // Multiline help about the plugin
  char *wanted_name;    // The preferred short name of the plugin
  char *wanted_hotkey;  // The preferred hotkey to run the plugin
};</pre><p>Every plug-in must export a <code class="literal">plugin_t</code> object named <code class="literal">PLUGIN</code>. Exporting your <code class="literal">PLUGIN</code> object is handled by <span class="emphasis"><em>loader.hpp</em></span>, which leaves you responsible for declaring and initializing the actual object. Since successful plug-in creation relies on properly initializing this object, we describe the purpose of each member here. Note that even if you prefer to take advantage of IDA’s new scripted plug-in capabilities, you will still need to familiarize yourself with each of these fields because they are used in scripted plug-ins as well.<a class="indexterm" id="IDX-CHP-17-0009"/><a class="indexterm" id="IDX-CHP-17-0010"/><a class="indexterm" id="IDX-CHP-17-0011"/><a class="indexterm" id="IDX-CHP-17-0012"/><a class="indexterm" id="IDX-CHP-17-0013"/><a class="indexterm" id="IDX-CHP-17-0014"/><a class="indexterm" id="IDX-CHP-17-0015"/><a class="indexterm" id="IDX-CHP-17-0016"/><a class="indexterm" id="IDX-CHP-17-0017"/><a class="indexterm" id="IDX-CHP-17-0018"/><a class="indexterm" id="IDX-CHP-17-0019"/><a class="indexterm" id="IDX-CHP-17-0020"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>version</code></strong></span></dt><dd><p>This member indicates the version number of the API that was used to build the plug-in. It is typically set to the constant <code class="literal">IDP_INTERFACE_VERSION</code>, which is declared in <span class="emphasis"><em>idp.hpp</em></span>. The value of this constant has not changed since the API was standardized with SDK version 4.9. The original intent of this field was to prevent plug-ins created with earlier versions of an SDK from being loaded into versions of IDA built with newer versions of the SDK.</p></dd><dt><span class="term"><strong class="userinput"><code>flags</code></strong></span></dt><dd><p>This field contains various flags indicating how IDA should treat the plug-in in various situations. The flags are set using a bitwise combination of the <code class="literal">PLUGIN_</code><em class="replaceable"><code>XXX</code></em> constants defined in <span class="emphasis"><em>loader.hpp</em></span>. For many plug-ins, assigning zero to this field will be sufficient. Please refer to <span class="emphasis"><em>loader.hpp</em></span> for the meanings of each flag bit.</p></dd><dt><span class="term"><strong class="userinput"><code>init</code></strong></span></dt><dd><p>This is the first of three function pointers contained in the <code class="literal">plugin_t</code> class. This particular member is a pointer to the plug-in’s initialization function. The function takes no parameters and returns an <code class="literal">int</code>. IDA calls this function to offer your plug-in a chance to be loaded. Initialization of plug-ins is discussed in <a class="xref" href="ch17.html#plug-in_initialization" title="Plug-in Initialization">Plug-in Initialization</a> in <a class="xref" href="ch17.html#plug-in_initialization" title="Plug-in Initialization">Plug-in Initialization</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>term</code></strong></span></dt><dd><p>This member is another function pointer. IDA calls the associated function when your plug-in is unloaded. The function takes no arguments and returns no value. The purpose of this function is to perform any cleanup tasks (deallocating memory, closing handles, saving state, and so on) required by your plug-in before IDA unloads it. This field may be set to NULL if you have no actions to perform when your plug-in is unloaded.</p></dd><dt><span class="term"><strong class="userinput"><code>run</code></strong></span></dt><dd><p>This member points to the function that should be called whenever a user activates (via a hotkey, menu item, or script invocation) your plug-in. This function is the heart of any plug-in, because it is here that the behaviors users associate with the plug-in are defined. This is the function that bears the most resemblance to scripted behaviors. The function receives a single integer parameter (discussed later under <a class="xref" href="ch17.html#plug-in_execution" title="Plug-in Execution">Plug-in Execution</a> in <a class="xref" href="ch17.html#plug-in_execution" title="Plug-in Execution">Plug-in Execution</a>) and returns nothing.</p></dd><dt><span class="term"><strong class="userinput"><code>comment</code></strong></span></dt><dd><p>This member is a pointer to a character string that serves as a comment for the plug-in. It is not used directly by IDA and can safely be set to NULL.</p></dd><dt><span class="term"><strong class="userinput"><code>help</code></strong></span></dt><dd><p>This member is a pointer to a character string that serves as a multiline help string. It is not used directly by IDA and can safely be set to NULL.<a class="indexterm" id="IDX-CHP-17-0021"/><a class="indexterm" id="IDX-CHP-17-0022"/><a class="indexterm" id="IDX-CHP-17-0023"/><a class="indexterm" id="IDX-CHP-17-0024"/><a class="indexterm" id="IDX-CHP-17-0025"/><a class="indexterm" id="IDX-CHP-17-0026"/><a class="indexterm" id="IDX-CHP-17-0027"/><a class="indexterm" id="IDX-CHP-17-0028"/><a class="indexterm" id="IDX-CHP-17-0029"/><a class="indexterm" id="IDX-CHP-17-0030"/></p></dd><dt><span class="term"><strong class="userinput"><code>wanted_name</code></strong></span></dt><dd><p>This member is a pointer to a character string that holds the name of the plug-in. When a plug-in is loaded, this string is added to the Edit ▸ Plugins menu as a means of activating the plug-in. There is no requirement for the name to be unique among loaded plug-ins, though it is difficult to determine which of two identically named plug-ins will be activated when the name is selected from the menu.</p></dd><dt><span class="term"><strong class="userinput"><code>wanted_hotkey</code></strong></span></dt><dd><p>This member is a pointer to a character string that holds the name of the hotkey (such as <code class="literal">"Alt-F8"</code>) that IDA will attempt to associate with the plugin. Here again, there is no need for this value to be unique among loaded plug-ins; however; if the value is not unique, the hotkey will be associated with the last plug-in to request it. <a class="xref" href="ch17s04.html" title="Configuring Plug-ins">Configuring Plug-ins</a> in <a class="xref" href="ch17s04.html" title="Configuring Plug-ins">Configuring Plug-ins</a> discusses how users may override the <code class="literal">wanted_hotkey</code> value.</p></dd></dl></div><p>An example of initializing a <code class="literal">plugin_t</code> object is shown here:</p><a id="I_programlisting3_d1e25778"/><pre class="programlisting">int idaapi idaboook_plugin_init(void);
void idaapi idaboook_plugin_term(void);
void idaapi idaboook_plugin_run(int arg);

char idabook_comment[] = "This is an example of a plugin";
char idabook_name[] = "Idabook";
char idabook_hotkey = "Alt-F9";

plugin_t PLUGIN = {
   IDP_INTERFACE_VERSION, 0, idaboook_plugin_init, idaboook_plugin_term,
    idaboook_plugin_run, idabook_comment, NULL, idabook_name, idabook_hotkey
};</pre><p>The function pointers included in the <code class="literal">plugin_t</code> class allow IDA to locate required functions in your plug-in without requiring you to export those functions or to choose specific names for those functions.</p><div class="sect2" title="The Plug-in Life Cycle"><div class="titlepage"><div><div><h2 class="title"><a id="the_plug-in_life_cycle"/>The Plug-in Life Cycle</h2></div></div></div><p>A typical IDA session begins with the launch of the IDA application itself and proceeds through loading and analyzing a new binary file or existing database before settling down to wait for user interaction. During this process, there are three distinct points at which IDA offers plug-ins a chance to load:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A plug-in may load immediately upon IDA startup, regardless of whether a database is being loaded or not. Loading in this manner is controlled by the presence of the <code class="literal">PLUGIN_FIX</code> bit in <code class="literal">PLUGIN.flags</code>.<a class="indexterm" id="IDX-CHP-17-0031"/></p></li><li class="listitem"><p>A plug-in may load immediately following a processor module and remain loaded until the processor module is unloaded. Tying a plug-in to a processor module is controlled by the <code class="literal">PLUGIN_PROC</code> bit in <code class="literal">PLUGIN.flags</code>.<a class="indexterm" id="IDX-CHP-17-0032"/><a class="indexterm" id="IDX-CHP-17-0033"/><a class="indexterm" id="IDX-CHP-17-0034"/><a class="indexterm" id="IDX-CHP-17-0035"/><a class="indexterm" id="IDX-CHP-17-0036"/><a class="indexterm" id="IDX-CHP-17-0037"/><a class="indexterm" id="IDX-CHP-17-0038"/><a class="indexterm" id="IDX-CHP-17-0039"/><a class="indexterm" id="IDX-CHP-17-0040"/><a class="indexterm" id="IDX-CHP-17-0041"/></p></li><li class="listitem"><p>In the absence of the flag bits just mentioned, IDA offers plug-ins the opportunity to load each time a database is opened in IDA.</p></li></ol></div><p>IDA offers plug-ins the opportunity to load by calling <code class="literal">PLUGIN.init</code>. When called, the <code class="literal">init</code> function should determine whether the plug-in is designed to be loaded given the current state of IDA. The meaning of <span class="emphasis"><em>current state</em></span> varies depending on which of the three preceding situations are applicable when the plug-in is being loaded. Examples of states that a plug-in may be interested in include the input file type (a plug-in may be designed specifically for use with PE files, for example) and the processor type (a plug-in may be designed exclusively for use with x86 binaries).</p><p>To indicate its desires to IDA, <code class="literal">PLUGIN.init</code> must return one of the following values defined in <span class="emphasis"><em>loader.hpp</em></span>.</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="strong"><strong>PLUGIN_SKIP</strong></span> Returning this value signals that the plug-in should not be loaded.</td></tr><tr><td><span class="strong"><strong>PLUGIN_OK</strong></span> Returning this value instructs IDA to make the plug-in available for use with the current database. IDA loads the plug-in when the user activates the plug-in using a menu action or a hotkey.</td></tr><tr><td><span class="strong"><strong>PLUGIN_KEEP</strong></span> Returning this value instructs IDA to make the plug-in available for use with the current database and keep the plug-in loaded in memory.</td></tr></table><p>Once a plug-in has been loaded, it may be activated in one of two ways. The most frequent method of activating a plug-in is at the direction of the user in response to a menu selection or hotkey activation. Each time a plug-in is activated in this way, IDA passes control to the plug-in by calling <code class="literal">PLUGIN.run</code>. An alternate method for plug-in activation is for the plug-in to hook into IDA’s event-notification system. In such cases, a plug-in must express interest in one or more types of IDA events and register a callback function to be called by IDA when any event of interest occurs.</p><p>When it is time for a plug-in to be unloaded, IDA calls <code class="literal">PLUGIN.term</code> (assuming it is non-NULL). The circumstances under which a plug-in is unloaded vary according to the bits set in <code class="literal">PLUGIN.flags</code>. Plug-ins that specify no flag bits are loaded according to the value returned by <code class="literal">PLUGIN.init</code>. These types of plug-ins are unloaded when the database for which they were loaded is closed.</p><p>When a plug-in specifies the <code class="literal">PLUGIN_UNL</code> flag bit, the plug-in is unloaded after each call to <code class="literal">PLUGIN.run</code>. Such plug-ins must be reloaded (resulting in a call to <code class="literal">PLUGIN.init</code>) for each subsequent activation. Plug-ins that specify the <code class="literal">PLUGIN_PROC</code> flag bit are unloaded when the processor module for which they were loaded is unloaded. Processor modules are unloaded whenever a database is closed. Finally, plug-ins that specify the <code class="literal">PLUGIN_FIX</code> flag bit are unloaded only when IDA itself terminates.</p></div><div class="sect2" title="Plug-in Initialization"><div class="titlepage"><div><div><h2 class="title"><a id="plug-in_initialization"/>Plug-in Initialization</h2></div></div></div><p>Plug-ins are initialized in two phases. Static initialization of plug-ins takes place at compile time, while dynamic initialization takes place at load time via actions performed within <code class="literal">PLUGIN.init</code>. As discussed earlier, the <code class="literal">PLUGIN.flags</code> field, which is initialized at compile time, dictates several behaviors of a plug-in.<a class="indexterm" id="IDX-CHP-17-0042"/><a class="indexterm" id="IDX-CHP-17-0043"/><a class="indexterm" id="IDX-CHP-17-0044"/></p><p>When IDA is launched, the <code class="literal">PLUGIN.flags</code> field of every plug-in in <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span> is examined. At this point, IDA calls <code class="literal">PLUGIN.init</code> for each plug-in that specifies the <code class="literal">PLUGIN_FIX</code> flag. <code class="literal">PLUGIN_FIX</code> plug-ins are loaded before any other IDA module and therefore have the opportunity to be notified of any event that IDA is capable of generating, including notifications generated by loader modules and processor modules. The <code class="literal">PLUGIN.init</code> function for such plug-ins should generally return either <code class="literal">PLUGIN_OK</code> or <code class="literal">PLUGIN_KEEP</code>, because it makes little sense to request it to be loaded at startup only to return <code class="literal">PLUGIN_SKIP</code> in <code class="literal">PLUGIN.init</code>.</p><p>However, if your plug-in is designed to perform a one-time initialization task at IDA startup, you may consider performing that task in the plug-in’s <code class="literal">init</code> function and returning <code class="literal">PLUGIN_SKIP</code> to indicate that the plug-in is no longer needed.</p><p>Each time a processor module is loaded, IDA samples the <code class="literal">PLUGIN_PROC</code> flag in every available plug-in and calls <code class="literal">PLUGIN.init</code> for each plug-in in which <code class="literal">PLUGIN_PROC</code> is set. The <code class="literal">PLUGIN_PROC</code> flag allows plug-ins to be created that respond to notifications generated by processor modules and thereby supplement the behavior of those modules. The <code class="literal">PLUGIN.init</code> function for such modules has access to the global <code class="literal">processor_t</code> object, <code class="literal">ph</code>, which may be examined and used to determine whether the plug-in should be skipped or retained. For example, a plug-in designed specifically for use with the MIPS processor module should probably return <code class="literal">PLUGIN_SKIP</code> if the x86 processor module is being loaded, as shown here:</p><a id="I_programlisting3_d1e26002"/><pre class="programlisting">int idaapi mips_init() {
   if (ph.id != PLFM_MIPS) return PLUGIN_SKIP;
   else return PLUGIN_OK;  //or, alternatively PLUGIN_KEEP
}</pre><p>Finally, each time a database is loaded or created, the <code class="literal">PLUGIN.init</code> function for each plug-in that has not already been loaded is called to determine whether the plug-in should be loaded or not. At this point each plug-in may use any number of criteria to determine whether IDA should retain it or not. Examples of specialized plug-ins include those that offer behavior specific to certain file types (ELF, PE, Mach-O, etc.), processor types, or compiler types.</p><p>Regardless of the reason, when a plug-in decides to return <code class="literal">PLUGIN_OK</code> (or <code class="literal">PLUGIN_KEEP</code>), the <code class="literal">PLUGIN.init</code> function should also take care of any one-time initialization actions necessary to ensure that the plug-in is capable of performing properly when it is eventually activated. Any resources that are requested by <code class="literal">PLUGIN.init</code> should be released in <code class="literal">PLUGIN.term</code>. A major difference between <code class="literal">PLUGIN_OK</code> and <code class="literal">PLUGIN_KEEP</code> is that <code class="literal">PLUGIN_KEEP</code> prevents a plug-in from being repeatedly loaded and unloaded and thus reduces the need to allocate, deallocate, and reallocate resources as might be required when a plug-in specifies <code class="literal">PLUGIN_OK</code>. As a general rule of thumb, <code class="literal">PLUGIN.init</code> should return <code class="literal">PLUGIN_KEEP</code> when future invocations of the plug-in may depend on states accumulated during previous invocations of the plug-in. A workaround for this is for plug-ins to store any state information in the open IDA database using a persistent storage mechanism such as netnodes. Using such a technique, subsequent invocations of the plug-in can locate and utilize data stored by earlier invocations of the plug-in. This method has the advantage of providing persistent storage not only across invocations of the plug-in but also across IDA sessions.<a class="indexterm" id="IDX-CHP-17-0045"/><a class="indexterm" id="IDX-CHP-17-0046"/><a class="indexterm" id="IDX-CHP-17-0047"/><a class="indexterm" id="IDX-CHP-17-0048"/><a class="indexterm" id="IDX-CHP-17-0049"/><a class="indexterm" id="IDX-CHP-17-0050"/><a class="indexterm" id="IDX-CHP-17-0051"/></p><p>For plug-ins in which each invocation is completely independent of any previous invocations, it is often suitable for <code class="literal">PLUGIN.init</code> to return <code class="literal">PLUGIN_OK</code>, which has the advantage of reducing IDA’s memory footprint by keeping fewer modules loaded in memory at any given time.</p></div><div class="sect2" title="Event Notification"><div class="titlepage"><div><div><h2 class="title"><a id="event_notification"/>Event Notification</h2></div></div></div><p>While plug-ins are quite frequently activated directly by a user via a menu selection (Edit ▸ Plugins) or through the use of a hotkey, IDA’s event-notification capabilities offer an alternative means of activating plug-ins.</p><p>When you want your plug-ins to be notified of specific events that take place within IDA, you must register a callback function to express interest in specific event types. The <code class="literal">hook_to_notification_point</code> function is used to inform IDA (1) that you are interested in a particular class of events and (2) that IDA should call the function that you indicate each time an event in the indicated class occurs. An example of using <code class="literal">hook_to_notification_point</code> to register interest in database events is shown here:<a class="indexterm" id="IDX-CHP-17-0052"/></p><a id="I_programlisting3_d1e26093"/><pre class="programlisting">//typedef for event hooking callback functions (from loader.hpp)
typedef int idaapi hook_cb_t(void *user_data, int notification_code, va_list va);
//prototype for  hook_to_notification_point (from loader.hpp)
bool hook_to_notification_point(hook_type_t hook_type,
                                hook_cb_t *callback,
                                void *user_data);
int idaapi idabook_plugin_init() {
   //Example call to  hook_to_notification_point
   hook_to_notification_point(HT_IDB, idabook_database_cb, NULL);
}</pre><p>Four broad categories of notification exist: processor notifications (<code class="literal">idp_notify</code> in <span class="emphasis"><em>idp.hpp</em></span>, <code class="literal">HT_IDP</code>), user interface notifications (<code class="literal">ui_notification_t</code> in <span class="emphasis"><em>kernwin.hpp</em></span>, <code class="literal">HT_UI</code>), debugger events (<code class="literal">dbg_notification_t</code> in <span class="emphasis"><em>dbg.hpp</em></span>, <code class="literal">HT_DBG</code>), and database events (<code class="literal">idp_event_t</code> in <span class="emphasis"><em>idp.hpp</em></span>, <code class="literal">HT_IDB</code>). Within each event category are a number of individual notification codes that represent specific events for which you will receive notifications. Examples of database (<code class="literal">HT_IDB</code>) notifications include <code class="literal">idb_event::byte_patched</code>, to indicate that a database byte has been patched, and <code class="literal">idb_event::cmt_changed</code>, to indicate that a regular or repeatable comment has been changed. Each time an event occurs, IDA invokes each registered callback function, passing the specific event-notification code and any additional parameters specific to the notification code. Parameters supplied for each notification code are detailed in the SDK header files that define each notification code.<a class="indexterm" id="IDX-CHP-17-0053"/><a class="indexterm" id="IDX-CHP-17-0054"/><a class="indexterm" id="IDX-CHP-17-0055"/><a class="indexterm" id="IDX-CHP-17-0056"/><a class="indexterm" id="IDX-CHP-17-0057"/><a class="indexterm" id="IDX-CHP-17-0058"/></p><p>Continuing the preceding example, we might define a callback function to handle database events as follows:</p><a id="I_programlisting3_d1e26169"/><pre class="programlisting">int idabook_database_cb(void *user_data, int notification_code, va_list va) {
     ea_t addr;
     ulong original, current;
     switch (notification_code) {
        case idb_event::byte_patched:
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>         addr = va_arg(va, ea_t);
           current = get_byte(addr);
           original = get_original_byte(addr);
           msg("%x was patched to %x.  Original value was %x\n",
                addr, current, original);
           break;
     }
     return 0;
  }</pre><p>This particular example recognizes only the <code class="literal">byte_patched</code> notification message, for which it prints the address of the patched byte, the new value of the byte, and the original value of the byte. Notification callback functions make use of the C++ variable arguments list, <code class="literal">va_list</code>, to provide access to a variable number of arguments, depending on which notification code is being sent to the function. The number and type of arguments provided for each notification code are specified in the header files in which each notification code is defined. The <code class="literal">byte_patched</code> notification code is defined in <span class="emphasis"><em>loader.hpp</em></span> to receive one argument of type <code class="literal">ea_t</code> in its <code class="literal">va_list</code>. The C++ <code class="literal">va_arg</code> macro should be used to retrieve successive arguments from a <code class="literal">va_list</code>. The address of the patched byte is retrieved from the <code class="literal">va_list</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e26207"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> in the preceding example.</p><p>An example of unhooking from database notification events is shown here:</p><a id="I_programlisting3_d1e26215"/><pre class="programlisting">void idaapi idabook_plugin_term() {
   unhook_from_notification_point(HT_IDB, idabook_database_cb, NULL);
}</pre><p>All well-behaved plug-ins should unhook any notifications whenever the plug-in is unloaded. This is one of the intended purposes of the <code class="literal">PLUGIN.term</code> function. Failure to unhook all of your active notifications will almost certainly result in crashing IDA shortly after your plug-in is unloaded.</p></div><div class="sect2" title="Plug-in Execution"><div class="titlepage"><div><div><h2 class="title"><a id="plug-in_execution"/>Plug-in Execution</h2></div></div></div><p>Thus far we have discussed several instances in which IDA calls functions belonging to a plug-in. Plug-in loading and unloading operations result in calls to <code class="literal">PLUGIN.init</code> and <code class="literal">PLUGIN.term</code>, respectively. User plug-in activation via the Edit ▸ Plugins menu or the plug-in’s associated hotkey results in a call to <code class="literal">PLUGIN.run</code>. Finally, callback functions registered by a plug-in may be called in response to various events that take place within IDA.<a class="indexterm" id="IDX-CHP-17-0059"/><a class="indexterm" id="IDX-CHP-17-0060"/><a class="indexterm" id="IDX-CHP-17-0061"/><a class="indexterm" id="IDX-CHP-17-0062"/></p><p>Regardless of how a plug-in comes to be executed, it is important to understand a few essential facts. Plug-in functions are invoked from IDA’s main event-processing loop. While a plug-in is executing, IDA cannot process events, including queued analysis tasks or updates to the user interface. Therefore it is important that your plug-in perform its task as expeditiously as possible and return control to IDA. Otherwise IDA will be completely unresponsive, and there will be no way to regain control. In other words, once your plug-in is executing, there is no simple way to break out of it. You must either wait for your plug-in to complete or kill your IDA process. In the latter case, you are likely to have an open database on your hands that may or may not be corrupt and may or may not be repairable by IDA. The SDK offers three functions that you may use to work around this issue. The <code class="literal">show_wait_box</code> function may be called to display a dialog that displays the message <span class="emphasis"><em>Please wait</em></span>. . . along with a Cancel button. You may periodically test whether the user pressed the Cancel button by calling the <code class="literal">wasBreak</code> function. The advantage to this approach is that when <code class="literal">wasBreak</code> is called, IDA will take the opportunity to update its user interface, and it allows your plug-in the opportunity to decide whether it should stop the processing that it is doing. In any case, you must call <code class="literal">hide_wait_box</code> to remove the Wait dialog from the display.</p><p>Do not attempt to get creative in your plug-ins by having your <code class="literal">PLUGIN.run</code> function create a new thread to handle the processing within your plug-in. IDA is not thread safe. There are no locking mechanisms in place to synchronize access to the many global variables used by IDA, nor are there any locking mechanisms to ensure the atomicity of database transactions. In other words, if you did create a new thread, and you used SDK functions to modify the database from within that thread, you could corrupt the database, because IDA might be in the middle of its own modification to the database that conflicts with your attempted changes.</p><p>Keeping these limitations in mind, for most plug-ins, the bulk of the work performed by the plug-in will be implemented within <code class="literal">PLUGIN.run</code>. Building on our previously initialized <code class="literal">PLUGIN</code> object, a minimal (and boring) implementation for <code class="literal">PLUGIN.run</code> might look like the following:</p><a id="I_programlisting3_d1e26281"/><pre class="programlisting">void idaapi idabook_plugin_run(int arg) {
   msg("idabook plugin activated!\n");
}</pre><p>Every plug-in has the C++ and IDA APIs at its disposal. Additional capabilities are available by linking your plug-in with appropriate platform-specific libraries. For example, the complete Windows API is available for plug-ins developed to run with Windows versions of IDA. To do something more interesting than printing a message to the output window, you need to understand how to accomplish your desired task using available functions from the IDA SDK. Taking the code from <a class="xref" href="ch16s02.html#enumerating_stack_frame_members" title="Example 16-6. Enumerating stack frame members">Example 16-6</a>, for example, we might develop the following function:<a class="indexterm" id="IDX-CHP-17-0063"/></p><a id="I_programlisting3_d1e26290"/><pre class="programlisting">void idaapi extended_plugin_run(int arg) {
   func_t *func = get_func(get_screen_ea());  //get function at cursor location
   msg("Local variable size is %d\n", func-&gt;frsize);
   msg("Saved regs size is %d\n", func-&gt;frregs);
   struc_t *frame = get_frame(func);          //get pointer to stack frame
   if (frame) {
      size_t ret_addr = func-&gt;frsize + func-&gt;frregs;  //offset to return address
      for (size_t m = 0; m &lt; frame-&gt;memqty; m++) {    //loop through members
         char fname[1024];
         get_member_name(frame-&gt;members[m].id, fname, sizeof(fname));
         if (frame-&gt;members[m].soff &lt; func-&gt;frsize) {
            msg("Local variable ");
         }
         else if (frame-&gt;members[m].soff &gt; ret_addr) {
            msg("Parameter ");
         }
         msg("%s is at frame offset %x\n", fname, frame-&gt;members[m].soff);
         if (frame-&gt;members[m].soff == ret_addr) {
            msg("%s is the saved return address\n", fname);
         }
      }
   }
}</pre><p>Using this function, we now have the core of a plug-in that dumps stack frame information for the currently selected function each time the plug-in is activated.</p></div></div></div>
<div class="sect1" title="Building Your Plug-ins"><div class="titlepage"><div><div><h1 class="title"><a id="building_your_plug-ins"/>Building Your Plug-ins</h1></div></div></div><p>On Windows, plug-ins are valid DLL files (that happen to use a <span class="emphasis"><em>.plw</em></span> or .<span class="emphasis"><em>p64</em></span> extension), while on Linux and Mac, a plug-in is a valid shared object file (that uses a <span class="emphasis"><em>.plx/.plx64</em></span> or <span class="emphasis"><em>.pmc/.pmc64</em></span> extension, respectively). Building plug-ins can be a tricky matter, because you must get all of the build settings correct or the build process is almost certain to fail. The SDK contains a number of sample plug-ins, each containing its own makefile. The makefiles were all created with Borland’s build tools for Windows in mind. This poses some challenges when you wish to build with a different tool chain or on a different platform. The <span class="emphasis"><em>install_xxx.txt</em></span> files included with the SDK discuss the use of <span class="emphasis"><em>&lt;SDKDIR&gt;/bin/idamake.pl</em></span> to build plug-ins using GNU make and gcc. The purpose of <span class="emphasis"><em>idamake.pl</em></span> is to generate a GNU make-style makefile from the Borland-style makefiles and then invoke GNU make to build the plug-in.<a class="indexterm" id="IDX-CHP-17-0064"/><a class="indexterm" id="IDX-CHP-17-0065"/></p><p>Our preference for building plug-ins is to use simplified makefiles with the GNU tools (via MinGW on Windows). The simplified makefile in <a class="xref" href="ch17s02.html#a_sample_makefile_for_ida_plug-ins" title="Example 17-1. A sample makefile for IDA plug-ins">Example 17-1</a> can easily be adapted to your own plug-in projects:</p><div class="example"><a id="a_sample_makefile_for_ida_plug-ins"/><p class="title">Example 17-1. A sample makefile for IDA plug-ins</p><div class="example-contents"><pre class="programlisting">#Set this variable to point to your SDK directory
IDA_SDK=../../

PLATFORM=$(shell uname | cut -f 1 -d _)

ifneq "$(PLATFORM)" "MINGW32"
IDA=$(HOME)/ida
endif

#Set this variable to the desired name of your compiled plugin
PROC=idabook_plugin

ifeq "$(PLATFORM)" "MINGW32"
PLATFORM_CFLAGS=-D__NT__ -D__IDP__ -DWIN32 -Os -fno-rtti
PLATFORM_LDFLAGS=-shared -s
LIBDIR=$(shell find ../../ -type d | grep -E "(lib|lib/)gcc.w32")
ifeq ($(strip $(LIBDIR)),)
LIBDIR=../../lib/x86_win_gcc_32
endif
IDALIB=$(LIBDIR)/ida.a
PLUGIN_EXT=.plw

else ifeq "$(PLATFORM)" "Linux"
PLATFORM_CFLAGS=-D__LINUX__
PLATFORM_LDFLAGS=-shared -s
IDALIB=-lida
IDADIR=-L$(IDA)
PLUGIN_EXT=.plx

else ifeq "$(PLATFORM)" "Darwin"
PLATFORM_CFLAGS=-D__MAC__
PLATFORM_LDFLAGS=-dynamiclib
IDALIB=-lida
IDADIR=-L$(IDA)/idaq.app/Contents/MacOs
PLUGIN_EXT=.pmc
endif

#Platform specific compiler flags
CFLAGS=-Wextra -Os $(PLATFORM_CFLAGS)

#Platform specific ld flags
LDFLAGS=$(PLATFORM_LDFLAGS)

#specify any additional libraries that you may need
EXTRALIBS=

# Destination directory for compiled plugins
OUTDIR=$(IDA_SDK)bin/plugins/

#list out the object files in your project here
OBJS=idabook_plugin.o

BINARY=$(OUTDIR)$(PROC)$(PLUGIN_EXT)

all: $(OUTDIR) $(BINARY)

clean:
    -@rm *.o
    -@rm $(BINARY)

$(OUTDIR):
    -@mkdir -p $(OUTDIR)

CC=g++
INC=-I$(IDA_SDK)include/

%.o: %.cpp
    $(CC) -c $(CFLAGS) $(INC) $&lt; -o $@

LD=g++

$(BINARY): $(OBJS)
    $(LD) $(LDFLAGS) -o $@ $(OBJS) $(IDADIR) $(IDALIB) $(EXTRALIBS)

#change idabook_plugin below to the name of your plugin, make sure to add any
#additional files that your plugin is dependent on
idabook_plugin.o: idabook_plugin.cpp</pre></div></div><p>The preceding makefile uses the <code class="literal">uname</code> command to determine the platform on which it is running and configures some build flags accordingly. Additional source files can be added to the plug-in project by appending the names of the associated object files to the <code class="literal">$OBJS</code> variable and to the end of the makefile. If your plug-in requires additional libraries, you should specify the library names in <code class="literal">$EXTRALIBS</code>. The <code class="literal">$IDA_SDK</code> variable is used to specify the location of the <span class="emphasis"><em>&lt;SDKDIR&gt;</em></span>, and <code class="literal">$IDA_SDK</code> may be specified as an absolute or a relative path. In this example, <code class="literal">$IDA_SDK</code> is specified as a relative path, indicating that <span class="emphasis"><em>&lt;SDKDIR&gt;</em></span> lies two directories above the plug-in’s directory. This is in keeping with locating plug-in projects within <span class="emphasis"><em>&lt;SDKDIR&gt;/plugins</em></span> (<span class="emphasis"><em>&lt;SDKDIR&gt;/plugins/</em></span><span class="emphasis"><em>idabook_plugin</em></span> in this case). If you choose to locate your plug-in’s project directory in some other location relative to <span class="emphasis"><em>&lt;SDKDIR&gt;</em></span>, you must ensure that <code class="literal">$IDA_SDK</code> properly refers to <span class="emphasis"><em>&lt;SDKDIR&gt;</em></span>. Finally, the preceding example is configured to store successfully compiled plug-ins in <span class="emphasis"><em>&lt;SDKDIR&gt;/bin/plugins</em></span>. It is important to understand that successfully compiling a plug-in does not necessarily install the plug-in. We cover plug-in installation in the next section.<a class="indexterm" id="IDX-CHP-17-0066"/><a class="indexterm" id="IDX-CHP-17-0067"/><a class="indexterm" id="IDX-CHP-17-0068"/></p><p>The use of Microsoft’s Visual C++ Express to build IDA modules is discussed in <span class="emphasis"><em>install_visual.txt</em></span>. To create a project from scratch using Visual Studio 2008, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Select <span class="strong"><strong>File</strong></span> ▸ <span class="strong"><strong>New</strong></span> ▸ <span class="strong"><strong>Project</strong></span> to open the New Project dialog shown in <a class="xref" href="ch17s02.html#visual_studio_new_project-creation_dialo" title="Figure 17-1. Visual Studio new project-creation dialog">Figure 17-1</a>.</p><div class="figure"><a id="visual_studio_new_project-creation_dialo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e26418"/><img alt="Visual Studio new project-creation dialog" src="httpatomoreillycomsourcenostarchimages854277.png.jpg"/></div></div><p class="title">Figure 17-1. Visual Studio new project-creation dialog</p></div></li><li class="listitem"><p>Specify the project type as <span class="strong"><strong>Visual C++/Win32</strong></span>, choose the <span class="strong"><strong>Win32 Project</strong></span> template, and provide the name and location for your project. We typically create new plug-in projects within the <span class="emphasis"><em>&lt;SDKDIR&gt;/plugins</em></span> directory in order to keep all of our plug-ins grouped together. When you click <span class="strong"><strong>OK</strong></span>, the Win32 Application Wizard appears. Click <span class="strong"><strong>Next</strong></span> to get to the Application Settings step and then set the Application type to <span class="strong"><strong>DLL</strong></span> and the Additional options to <span class="strong"><strong>Empty project</strong></span> before clicking <span class="strong"><strong>Finish</strong></span>, as shown in <a class="xref" href="ch17s02.html#visual_studio_win32_application_wizard" title="Figure 17-2. Visual Studio Win32 Application Wizard">Figure 17-2</a>.<a class="indexterm" id="IDX-CHP-17-0069"/><a class="indexterm" id="IDX-CHP-17-0070"/><a class="indexterm" id="IDX-CHP-17-0071"/></p><div class="figure"><a id="visual_studio_win32_application_wizard"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e26465"/><img alt="Visual Studio Win32 Application Wizard" src="httpatomoreillycomsourcenostarchimages854280.png.jpg"/></div></div><p class="title">Figure 17-2. Visual Studio Win32 Application Wizard</p></div></li><li class="listitem"><p>Once the basic framework of the project has been created, you must configure a few additional settings. Project properties in Visual Studio 2008 are accessed via Project ▸ Properties, which brings up the dialog shown in <a class="xref" href="ch17s02.html#visual_studio_project_properties_dialog" title="Figure 17-3. Visual Studio project properties dialog">Figure 17-3</a>. C/C++ configuration options only become available once a source file has been added to the project, either by adding and editing a new file or adding an existing file.<a class="indexterm" id="IDX-CHP-17-0072"/><a class="indexterm" id="IDX-CHP-17-0073"/></p><div class="figure"><a id="visual_studio_project_properties_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e26484"/><img alt="Visual Studio project properties dialog" src="httpatomoreillycomsourcenostarchimages854283.png.jpg"/></div></div><p class="title">Figure 17-3. Visual Studio project properties dialog</p></div></li></ol></div><p>The settings that require modification are spread throughout the Configuration Properties section at the left side of the dialog. <a class="xref" href="ch17s02.html#visual_studio_project_properties_dialog" title="Figure 17-3. Visual Studio project properties dialog">Figure 17-3</a> is representative of the manner in which properties are set throughout a project. For each property category selected in the left-hand portion of the dialog, a list of configurable properties is displayed in the right-hand portion of the dialog. Note that property categories are organized in a hierarchical fashion. Properties are edited using file-selection controls, single-line edit controls, multiline edit controls, or drop-down-list-selection controls. <a class="xref" href="ch17s02.html#visual_studio_plug-in_configuration_valu" title="Table 17-1. Visual Studio Plug-in Configuration Values (32-bit)">Table 17-1</a> details the properties that must be edited to create a plug-in project.</p><p>Note that Visual Studio allows you to specify separate configuration options for Debug and Release versions of the project (see top left of <a class="xref" href="ch17s02.html#visual_studio_project_properties_dialog" title="Figure 17-3. Visual Studio project properties dialog">Figure 17-3</a>). If you intend to build separate Debug and Release versions of your plug-in, make certain that you have modified the properties in both configurations. Alternatively, you may save some time by selecting All Configurations from the Configurations drop-down list (at the top left of the Properties dialog), in which case your property changes will be applied to all build configurations.</p><div class="table"><a id="visual_studio_plug-in_configuration_valu"/><p class="title">Table 17-1. Visual Studio Plug-in Configuration Values (32-bit)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Visual Studio Plug-in Configuration Values (32-bit)"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Configuration Property Category<a class="indexterm" id="IDX-CHP-17-0074"/></p></th><th style="text-align: left" valign="bottom"><p>Specific Property</p></th><th style="text-align: left" valign="bottom"><p>Property Value</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>General</p></td><td style="text-align: left" valign="top"><p>Output Directory</p></td><td style="text-align: left" valign="top"><p>As desired, often <span class="emphasis"><em>&lt;SDKDIR&gt;\bin\plugins</em></span></p></td></tr><tr><td style="text-align: left" valign="top"><p>C/C++▸General</p></td><td style="text-align: left" valign="top"><p>Additional Include Directories</p></td><td style="text-align: left" valign="top"><p>Add <span class="emphasis"><em>&lt;SDKDIR&gt;\include</em></span></p></td></tr><tr><td style="text-align: left" valign="top"><p>C/C++▸Preprocessor</p></td><td style="text-align: left" valign="top"><p>Preprocessor Definitions</p></td><td style="text-align: left" valign="top"><p>Append “;__NT__;__IDP__”</p></td></tr><tr><td style="text-align: left" valign="top"><p>C/C++▸Code Generation</p></td><td style="text-align: left" valign="top"><p>Runtime Library</p></td><td style="text-align: left" valign="top"><p>Multithreaded (Release)<sup>[<a class="footnote" href="#ftn.CHP-17-TFN-1" id="CHP-17-TFN-1">a</a>]</sup> Multithreaded Debug (Debug) (Not the DLL versions)<sup>[<a class="footnote" href="#ftn.CHP-17-TFN-2" id="CHP-17-TFN-2">b</a>]</sup></p></td></tr><tr><td style="text-align: left" valign="top"><p>Linker▸General</p></td><td style="text-align: left" valign="top"><p>Output File</p></td><td style="text-align: left" valign="top"><p>Change extension to <span class="emphasis"><em>.plw</em></span></p></td></tr><tr><td style="text-align: left" valign="top"><p>Linker▸General</p></td><td style="text-align: left" valign="top"><p>Additional Library Directories</p></td><td style="text-align: left" valign="top"><p>Add <span class="emphasis"><em>&lt;SDKDIR&gt;\lib\x86_win_vc_32</em></span><sup>[<a class="footnote" href="#ftn.CHP-17-TFN-3" id="CHP-17-TFN-3">c</a>]</sup></p></td></tr><tr><td style="text-align: left" valign="top"><p>Linker▸Input</p></td><td style="text-align: left" valign="top"><p>Additional Dependencies</p></td><td style="text-align: left" valign="top"><p>Add <span class="emphasis"><em>ida.lib</em></span> (from <span class="emphasis"><em>\lib\86_win_vc_32</em></span>)</p></td></tr><tr><td style="text-align: left" valign="top"><p>Linker▸Command Line</p></td><td style="text-align: left" valign="top"><p>Additional options</p></td><td style="text-align: left" valign="top"><p>Add <span class="emphasis"><em>/EXPORT:PLUGIN</em></span></p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-TFN-1" id="ftn.CHP-17-TFN-1">a</a>] </sup>Multithreaded in this case refers to the C++ runtime library itself. IDA just happens to be a single-threaded application that makes use of this library. A single-threaded version of the C++ runtime library does not exist.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-TFN-2" id="ftn.CHP-17-TFN-2">b</a>] </sup>Choosing the DLL versions of the C++ library requires that <span class="emphasis"><em>MSVCR80.DLL</em></span> be present on the system on which the plug-in will ultimately run. In order to remove this restriction, choose the non-DLL version of the C++ runtime libraries, which produces a statically linked plug-in that is more portable.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-TFN-3" id="ftn.CHP-17-TFN-3">c</a>] </sup>Prior to SDK version 6.1, add library directory <span class="emphasis"><em>&lt;SDKDIR&gt;\lib\vc.w32</em></span>.</p></div></td></tr></tbody></table></div></div></div>
<div class="sect1" title="Installing Plug-ins"><div class="titlepage"><div><div><h1 class="title"><a id="installing_plug-ins"/>Installing Plug-ins</h1></div></div></div><p>In comparison to the build process, plug-in installation is very simple. Installing a plug-in is accomplished by copying the compiled plug-in module to <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>. Note that Windows systems do not allow an executable file that is in use to be overwritten. So to install a plug-in on a Windows system, you must ensure that any previous version of the plug-in has been unloaded from IDA. Depending on the plug-in loading options, a plug-in may be unloaded when a database is closed. However, plug-ins that have the <code class="literal">PLUGIN_FIX</code> flag set may require IDA to be shut down entirely before the new plug-in can be copied to <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>.<a class="indexterm" id="IDX-CHP-17-0075"/><a class="indexterm" id="IDX-CHP-17-0076"/></p><p>On Linux and OS X systems, executable files can be overwritten while they are in use, so you do not need to ensure that a plug-in is unloaded before installing a new version of it. However, the new version of the plug-in will not be loaded into IDA until the next time IDA offers plug-ins a chance to load.</p><p>Some IDA plug-ins are distributed in binary form only, while others are distributed in both source and binary format. Installing such plug-ins usually involves finding the proper version of the compiled plug-in for your version of IDA and copying that plug-in to <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>. Make sure that you read the documentation (if any!) that accompanies any plug-in that you wish to install, because some plug-ins require the installation of additional components in order to function properly.<a class="indexterm" id="IDX-CHP-17-0077"/><a class="indexterm" id="IDX-CHP-17-0078"/><a class="indexterm" id="IDX-CHP-17-0079"/><a class="indexterm" id="IDX-CHP-17-0080"/><a class="indexterm" id="IDX-CHP-17-0081"/><a class="indexterm" id="IDX-CHP-17-0082"/><a class="indexterm" id="IDX-CHP-17-0083"/></p></div>
<div class="sect1" title="Configuring Plug-ins"><div class="titlepage"><div><div><h1 class="title"><a id="configuring_plug-ins"/>Configuring Plug-ins</h1></div></div></div><p>IDA provides a limited ability to configure plug-ins via settings in <span class="emphasis"><em>&lt;IDADIR&gt;/plugins/plugins.cfg</em></span>. Settings in <span class="emphasis"><em>plugins.cfg</em></span> can be used to specify the following information about a plug-in:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An alternate menu description for the plug-in. This value overrides the plug-in’s <code class="literal">wanted_name</code> data member.</p></li><li class="listitem"><p>A nonstandard location or file extension for the plug-in. By default IDA searches for plug-ins in <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span> and expects plug-ins to have a default, platform-specific file extension.</p></li><li class="listitem"><p>An alternate or additional hotkey used to activate the plug-in. This value overrides the plug-in’s <code class="literal">wanted_hotkey</code> data member.</p></li><li class="listitem"><p>An integer value to be passed to the plug-in’s <code class="literal">PLUGIN.run</code> function each time the plug-in is activated.</p></li><li class="listitem"><p>An optional <code class="literal">DEBUG</code> flag for use with debugger plug-ins. Debugger plug-ins are discussed in <a class="xref" href="ch24.html" title="Chapter 24. The IDA Debugger">Chapter 24</a>.</p></li></ul></div><p>The syntax of a valid plug-in configuration line is described in <span class="emphasis"><em>plugins.cfg</em></span>. A few examples of plug-in configuration lines are shown here:</p><a id="I_programlisting3_d1e26736"/><pre class="programlisting">; Semicolons introduce comments.  A plugin configuration line consists
; of three required components and two optional components
;  plugin_name  plugin_file  hotkey  [integer run arg]  [DEBUG]
The_IdaBook_Plugin   idabook_plugin   Alt-F2  1
IdaBook_Plugin_Alt   idabook_plugin   Alt-F3  2</pre><p>The <code class="literal">wanted_name</code> and <code class="literal">wanted_hotkey</code> data members for a plug-in are chosen by the plug-in’s author and compiled into the plug-in. It is entirely possible that two plug-ins developed by different authors may have identical names or identical hotkey associations. Within <span class="emphasis"><em>plugin.cfg</em></span>, the <code class="literal">plugin_name</code> field specifies the text (which overrides <code class="literal">PLUGIN.wanted_name</code>) to be added to the Edit ▸ Plugins menu. It is possible to assign several names—and therefore several menu items—to a single plug-in. Underscore characters in the <code class="literal">plugin_name</code> field are replaced with space characters before the name is added to the Edit ▸ Plugins menu.</p><p>The <code class="literal">plugin_file</code> field specifies the name of the compiled plug-in module file to which the current configuration line applies. If a full path is specified, IDA loads the plug-in from the specified path. If no path is specified, IDA looks for the plug-in in <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>. If no file extension is specified, then IDA assumes a default plug-in extension for the current platform. If a file extension is specified, IDA searches for an exact match to the plug-in filename.</p><p>The <code class="literal">hotkey</code> field specifies the hotkey that should be used to activate the plug-in. This field overrides the value of <code class="literal">PLUGIN.wanted_hotkey</code> and can be used to resolve conflicting hotkey assignments when two plug-ins have been built that use the same hotkey for activation. Alternatively, assigning more than one hotkey to a plug-in offers the ability to activate a plug-in in more than one way. In such cases, it is useful to specify unique integer arguments for <code class="literal">PLUGIN.run</code> depending on which hotkey was used to activate a plug-in. When you pass different integer values to <code class="literal">PLUGIN.run</code>, IDA makes it possible for a plug-in to determine exactly how it was activated. This capability is useful when a plug-in implements more than one behavior and each behavior is selected based on how the plug-in is activated. In the preceding configuration example, IDA passes the integer value 2 to <code class="literal">idabook_plugin</code>’s <code class="literal">PLUGIN.run</code> function whenever the plug-in is activated via the <span class="keycap">alt</span>-F3 hotkey sequence.<a class="indexterm" id="IDX-CHP-17-0084"/><a class="indexterm" id="IDX-CHP-17-0085"/><a class="indexterm" id="IDX-CHP-17-0086"/><a class="indexterm" id="IDX-CHP-17-0087"/><a class="indexterm" id="IDX-CHP-17-0088"/><a class="indexterm" id="IDX-CHP-17-0089"/><a class="indexterm" id="IDX-CHP-17-0090"/></p></div>
<div class="sect1" title="Extending IDC"><div class="titlepage"><div><div><h1 class="title"><a id="extending_idc"/>Extending IDC</h1></div></div></div><p>So far we have presented plug-ins designed primarily to manipulate or extract information from a database. In this section, we present an example of extending the capabilities of the IDC scripting language.<sup>[<a class="footnote" href="#ftn.CHP-17-FN-1" id="CHP-17-FN-1">117</a>]</sup> As mentioned in <a class="xref" href="ch16.html" title="Chapter 16. The IDA Software Development Kit">Chapter 16</a>, IDC is implemented on top of the IDA API, so it should come as no surprise that the API can be used to enhance IDC when the need arises.</p><p>In <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a> and <a class="xref" href="ch16.html" title="Chapter 16. The IDA Software Development Kit">Chapter 16</a>, you learned that IDC global arrays are actually a somewhat restricted abstraction of netnodes. Recall that in IDC you create global arrays by supplying a name and receiving an array ID in return. Internally your name gets prefixed with the string “$ idc_array ”, and the array ID that you receive is actually a netnode index value. How could we go about extending IDC in order to enable access to any netnode in an IDA database? We can already access any netnode whose index we happen to know by using the index as the array ID in IDC, so what we need is the ability to access any netnode whose name we happen to know. IDC currently prevents us from doing this because it prepends “$ idc_array ” to every netnode name we supply. Enter the SDK and the <code class="literal">set_idc_func_ex</code> function.<a class="indexterm" id="IDX-CHP-17-0091"/><a class="indexterm" id="IDX-CHP-17-0092"/></p><p>Defined in <span class="emphasis"><em>expr.hpp</em></span>, <code class="literal">set_idc_func_ex</code> may be used to create a new IDC function and map its behavior to C++ implementation. The prototype for <code class="literal">set_idc_func_ex</code> is shown here:</p><a id="I_programlisting3_d1e26851"/><pre class="programlisting">typedef error_t (idaapi *idc_func_t)(idc_value_t *argv, idc_value_t *res);
bool set_idc_func_ex(const char *idc_name, idc_func_t idc_impl,
                     const char *args, int extfunc_flags);</pre><p>Note that we have introduced the <code class="literal">idc_func_t</code> datatype here in order to simplify the code somewhat. This datatype is not defined within the SDK. The arguments to <code class="literal">set_idc_func_ex</code> specify the name of the new IDC function that we are introducing (<code class="literal">idc_name</code>), a pointer to the C++ function that implements our new IDC behavior (<code class="literal">idc_impl</code>), a null-terminated array of characters that specify the argument types and sequence for the new IDC function (<code class="literal">args</code>), and flags (<code class="literal">extfunc_flags</code>) indicating whether an open database is required or whether the function never returns.<a class="indexterm" id="IDX-CHP-17-0093"/><a class="indexterm" id="IDX-CHP-17-0094"/><a class="indexterm" id="IDX-CHP-17-0095"/><a class="indexterm" id="IDX-CHP-17-0096"/></p><p>The following function, used as the initialization function for a plug-in, completes the process by creating the new IDC function we are designing:</p><a id="I_programlisting3_d1e26888"/><pre class="programlisting">int idaapi init(void) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>    static const char idc_str_args[] = { VT_STR2, 0 };
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    set_idc_func_ex("CreateNetnode", idc_create_netnode, idc_str_args, 0);
      return PLUGIN_KEEP;
  }</pre><p>This function creates the new IDC function <code class="literal">CreateNetnode</code> and maps it to our implementation function <code class="literal">idc_create_netnode</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e26910"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. The arguments to the new IDC function are specified as being a single parameter of type string (<code class="literal">VT_STR2</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e26919"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>.</p><p>The function that actually implements the behavior of <code class="literal">CreateNetnode</code> is shown here:</p><a id="I_programlisting3_d1e26930"/><pre class="programlisting">/*
   * native implementation of CreateNetnode.  Returns the id of the new netnode
   * this id can be used with all of the existing IDC Array functions.
   */
  static error_t idaapi idc_create_netnode(idc_value_t *argv, idc_value_t *res) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>   res-&gt;vtype = VT_LONG;           //result type is a netnode index
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>   if (argv[0].vtype == VT_STR2) {  //verify we have the proper input type
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>      netnode n(argv[0].c_str(), 0, true);  //create the netnode
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>      res-&gt;num = (nodeidx_t)n;          //set the result value
     }
     else {
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>      res-&gt;num = −1;         //If the user supplies a bad argument we fail
     }
     return eOk;
  }</pre><p>The two arguments to this function represent the input argument array (<code class="literal">argv</code>) containing all of the parameters to <code class="literal">CreateNetnode</code> (there should be only one in this case) and an output parameter (<code class="literal">res</code>) used to receive the result of the IDC function we are implementing. The SDK datatype <code class="literal">idc_value_t</code> represents a single IDC value. Fields within this datatype indicate the current type of data represented by the value and the current contents of the value. The function begins by specifying that <code class="literal">CreateNetnode</code> returns a long (<code class="literal">VT_LONG</code>) value <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e26984"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. Since IDC variables are untyped, we must indicate internally what type of value the variable is holding at any given moment. Next, the function verifies that the caller of <code class="literal">CreateNetnode</code> has supplied an argument of type string (<code class="literal">VT_STR2</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e26996"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. If a valid argument has been supplied, a netnode is created with the supplied name <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e27002"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The resulting netnode index number is returned to the caller as the result of the <code class="literal">CreateNetnode</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e27012"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>. In this example, the result type is an integer value, so the result is stored into the <code class="literal">res-&gt;num</code> field. Had the result type been a string, we would have needed to call <code class="literal">res-&gt;set_string</code> to set the string value of the result. If the user fails to supply a string argument, the function fails and returns the invalid netnode index <code class="literal">−1</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e27027"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>.<a class="indexterm" id="IDX-CHP-17-0097"/><a class="indexterm" id="IDX-CHP-17-0098"/><a class="indexterm" id="IDX-CHP-17-0099"/><a class="indexterm" id="IDX-CHP-17-0100"/></p><p>We complete the plug-in with the following functions and <code class="literal">PLUGIN</code> structure:</p><a id="I_programlisting3_d1e27055"/><pre class="programlisting">void idaapi term(void) {}   //nothing to do on termination
  void idaapi run(int arg) {} //nothing to do and no way to activate

  plugin_t PLUGIN = {
    IDP_INTERFACE_VERSION,
    //this plugin loads at IDA startup, does not get listed on the Edit&gt;Plugins menu
    //and modifies the database
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>   PLUGIN_FIX | PLUGIN_HIDE | PLUGIN_MOD,  // plugin flags
    init,                 // initialize
    term,                 // terminate. this pointer may be NULL.
    run,                  // invoke plugin
    "",                   // long comment about the plugin
    "",                   // multiline help about the plugin
    "",                   // the preferred short name of the plugin
    ""                    // the preferred hotkey to run the plugin
  };</pre><p>The trick to this plug-in is that it loads on IDA startup (<code class="literal">PLUGIN_FIX</code>) and remains hidden from the user because it is not added to the Edit ▸ Plugins menu (<code class="literal">PLUGIN_HIDE</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e27071"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. The plug-in is kept in memory for all databases, and all of the initialization takes place in the plug-in’s <code class="literal">init</code> function. As a result, the plug-in has nothing to do in its <code class="literal">run</code> method.</p><p>Once this plug-in is installed, an IDC programmer may access any named netnode in an IDA database using the netnode’s name, as in the following example:</p><a id="I_programlisting3_d1e27085"/><pre class="programlisting">auto n, val;
n = CreateNetnode("$ imports");       //no $ idc_array prefix will be added
val = GetArrayElement(AR_STR, n, 0);  //get element zero</pre><p>More information for using the SDK to interact with IDC is contained in the <span class="emphasis"><em>expr.hpp</em></span> header file.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-1" id="ftn.CHP-17-FN-1">117</a>] </sup>Note that there is currently no way to programmatically extend the IDAPython API from within a compiled plug-in.</p></div></div></div>
<div class="sect1" title="Plug-in User Interface Options"><div class="titlepage"><div><div><h1 class="title"><a id="plug-in_user_interface_options"/>Plug-in User Interface Options</h1></div></div></div><p>This book makes no pretense at being a user interface development guide. However, there are many occasions in which a plug-in will need to interact with an IDA user to request or display information. In addition to the API’s <code class="literal">ask</code><em class="replaceable"><code>XXX</code></em> functions mentioned in <a class="xref" href="ch16.html" title="Chapter 16. The IDA Software Development Kit">Chapter 16</a>, a few more complex functions are available for user interaction via the IDA API. For more adventurous plug-in authors, it is worth remembering that plug-ins developed for GUI versions of IDA also have full access to the user interface functions that are available in various GUI libraries (Qt or Windows Native). Through the use of these functions it is possible to use virtually any type of graphical interface element within your plug-ins.</p><p>Beyond the SDK’s <code class="literal">ask</code><em class="replaceable"><code>XXX</code></em> interface functions, things get a little more challenging when using the SDK to build user interface elements. One of the reasons for this is that the SDK attempts to provide a generic programming interface to accomplish the fairly complex task of displaying a GUI element to a user and accepting the user’s input.<a class="indexterm" id="IDX-CHP-17-0101"/><a class="indexterm" id="IDX-CHP-17-0102"/><a class="indexterm" id="IDX-CHP-17-0103"/><a class="indexterm" id="IDX-CHP-17-0104"/><a class="indexterm" id="IDX-CHP-17-0105"/><a class="indexterm" id="IDX-CHP-17-0106"/><a class="indexterm" id="IDX-CHP-17-0107"/><a class="indexterm" id="IDX-CHP-17-0108"/></p><div class="sect2" title="Using the SDK’s Chooser Dialogs"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_sdkas_chooser_dialogs"/>Using the SDK’s Chooser Dialogs</h2></div></div></div><p>The first two functions that we will discuss are called <code class="literal">choose</code> and <code class="literal">choose2</code>. Each of these functions, along with various constants used to control its behavior, is declared in <span class="emphasis"><em>kernwin.hpp</em></span>. The purpose of each function is to display a list of data elements to the user and ask the user to select one or more items from the list. The <code class="literal">choose</code> functions are capable of displaying virtually any type of data by virtue of the fact that they require you to specify formatting functions that are called to generate each line of text displayed in the chooser window. The two functions differ in that <code class="literal">choose</code> displays a single-column list, while <code class="literal">choose2</code> is capable of displaying a multicolumn list. In the following examples we demonstrate the simplest forms of these functions, which rely on many default parameters. If you want to explore the full range of capabilities of <code class="literal">choose</code> and <code class="literal">choose2</code>, please consult <span class="emphasis"><em>kernwin.hpp</em></span>.</p><p>For displaying a single column of information to a user, the simplest form of the <code class="literal">choose</code> function boils down to the following, once default parameters are omitted:</p><a id="I_programlisting3_d1e27182"/><pre class="programlisting">ulong choose(void *obj,
             int width,
             ulong (idaapi *sizer)(void *obj),
             char *(idaapi *getline)(void *obj, ulong n, char *buf),
             const char *title);</pre><p>Here, the <code class="literal">obj</code> parameter is a pointer to the block of data to be displayed, and <code class="literal">width</code> is the desired column width to be used in the chooser window. The <code class="literal">sizer</code> parameter is a pointer to a function that is capable of parsing the data pointed to by <code class="literal">obj</code> and returning the number of lines required to display that data. The <code class="literal">getline</code> parameter is a pointer to a function that can generate the character string representation of a single item selected from <code class="literal">obj</code>. Note that the <code class="literal">obj</code> pointer can point to any type of data as long as the <code class="literal">sizer</code> function can parse the data to determine the number of lines required to display the data and as long as the <code class="literal">getline</code> function can locate a specific data item using an integer index and generate a character string representation of that data item. The <code class="literal">title</code> parameter specifies the title string used in the generated chooser dialog. The <code class="literal">choose</code> function returns the index number (1..<span class="emphasis"><em>n</em></span>) of the user-selected item or zero if the dialog was canceled by the user. The code in <a class="xref" href="ch17s06.html#example_use_of_the_choose_function" title="Example 17-2. Example use of the choose function">Example 17-2</a>, while not terribly exciting, is extracted from a plug-in that demonstrates the use of the <code class="literal">choose</code> function.</p><div class="example"><a id="example_use_of_the_choose_function"/><p class="title">Example 17-2. Example use of the <code class="literal">choose</code> function</p><div class="example-contents"><pre class="programlisting">#include &lt;kernwin.hpp&gt;

//The sample data to be displayed
int data[] = {0xdeafbeef, 0xcafebabe, 0xfeedface, 0};

//this example expects obj to point to a zero
//terminated array of non-zero integers.
ulong idaapi idabook_sizer(void *obj) {
   int *p = (int*)obj;
   int count = 0;
   while (*p++) count++;
   return count;
}

/*
 * obj In this example obj is expected to point to an array of integers
 * n indicates which line (1..n) of the display is being formatted.
 *   if n is zero, the header line is being requested.
 * buf is a pointer to the output buffer for the formatted data. IDA will
 *     call this with a buffer of size MAXSTR (1024).
 */
char * idaapi idabook_getline(void *obj, ulong n, char *buf) {
   int *p = (int*)obj;
   if (n == 0) { //This is the header case
      qstrncpy(buf, "Value", strlen("Value") + 1);
   }
   else { //This is the data case
      qsnprintf(buf, 32, "0x%08.8x", p[n - 1]);
   }
   return buf;
}

void idaapi run(int arg) {
   int choice = choose(data, 16, idabook_sizer, idabook_getline,
                      "Idabook Choose");
   msg("The user's choice was %d\n", choice);
}</pre></div></div><p>Activating the plug-in from <a class="xref" href="ch17s06.html#example_use_of_the_choose_function" title="Example 17-2. Example use of the choose function">Example 17-2</a> results in the chooser dialog shown in <a class="xref" href="ch17s06.html#example_of_the_chooser_dialog" title="Figure 17-4. Example of the chooser dialog">Figure 17-4</a>.<a class="indexterm" id="IDX-CHP-17-0109"/></p><div class="figure"><a id="example_of_the_chooser_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27249"/><img alt="Example of the chooser dialog" src="httpatomoreillycomsourcenostarchimages854286.png.jpg"/></div></div><p class="title">Figure 17-4. Example of the chooser dialog</p></div><p>The <code class="literal">choose2</code> function offers a multicolumn variation of the chooser dialog. Again, we look at the simplest version of the function, accepting all possible default arguments, which boils down to the following:<a class="indexterm" id="IDX-CHP-17-0110"/><a class="indexterm" id="IDX-CHP-17-0111"/><a class="indexterm" id="IDX-CHP-17-0112"/></p><a id="I_programlisting3_d1e27268"/><pre class="programlisting">ulong choose2(void *obj,
              int ncol,
              const int *widths,
              ulong (idaapi *sizer)(void *obj),
              void (idaapi *getline)(void *obj, ulong n, char* const *cells),
              const char *title);</pre><p>We can observe a few differences between <code class="literal">choose2</code> and the <code class="literal">choose</code> function we saw earlier. First, the <code class="literal">ncol</code> parameter specifies the number of columns to be displayed, while the <code class="literal">widths</code> parameter is an array of integers that specify the width of each column. The format of the <code class="literal">getline</code> function changes somewhat in <code class="literal">choose2</code>. Since the <code class="literal">choose2</code> dialog can contain several columns, the <code class="literal">get-line</code> function must provide data for each column within a single line. The example code in <a class="xref" href="ch17s06.html#example_use_of_the_choose2_function" title="Example 17-3. Example use of the choose2 function">Example 17-3</a> shows the use of <code class="literal">choose2</code> in a demonstration plug-in.</p><div class="example"><a id="example_use_of_the_choose2_function"/><p class="title">Example 17-3. Example use of the <code class="literal">choose2</code> function</p><div class="example-contents"><pre class="programlisting">#include &lt;kernwin.hpp&gt;

//The sample data to be displayed
int data[] = {0xdeafbeef, 0xcafebabe, 0xfeedface, 0};
//The width of each column
int widths[] = {16, 16, 16};
//The headers for each column
char *headers[] = {"Decimal", "Hexadecimal", "Octal"};
//The format strings for each column
char *formats[] = {"%d", "0x%x", "0%o"};

//this function expects obj to point to a zero terminated array
//of non-zero integers.
ulong idaapi idabook_sizer(void *obj) {
   int *p = (int*)obj;
   int count = 0;
   while (*p++) count++;
   return count;
}

/*
 * obj In this function obj is expected to point to an array of integers
 * n indicates which line (1..n) of the display is being formatted.
 *   if n is zero, the header line is being requested.
 * cells is a pointer to an array of character pointers. This array
 *       contains one pointer for each column in the chooser.  The output
 *       for each column should not exceed MAXSTR (1024) characters.*/
void idaapi idabook_getline_2(void *obj, ulong n, char* const *cells) {
   int *p = (int*)obj;
   if (n == 0) {
      for (int i = 0; i &lt; 3; i++) {
         qstrncpy(cells[i], headers[i], widths[i]);
      }
   }
   else {
      for (int i = 0; i &lt; 3; i++) {
         qsnprintf(cells[i], widths[i], formats[i], p[n - 1]);
      }
   }
}

void run(int arg) {
   int choice = choose2(data, 3, widths, idabook_sizer, idabook_getline_2,
                        "Idabook Choose2");
   msg("The choice was %d\n", choice);
}</pre></div></div><p>The multicolumn chooser dialog generated using the code from <a class="xref" href="ch17s06.html#example_use_of_the_choose2_function" title="Example 17-3. Example use of the choose2 function">Example 17-3</a> is shown in <a class="xref" href="ch17s06.html#example_of_the_choose2_dialog" title="Figure 17-5. Example of the choose2 dialog">Figure 17-5</a>.<a class="indexterm" id="IDX-CHP-17-0113"/><a class="indexterm" id="IDX-CHP-17-0114"/><a class="indexterm" id="IDX-CHP-17-0115"/><a class="indexterm" id="IDX-CHP-17-0116"/></p><div class="figure"><a id="example_of_the_choose2_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27343"/><img alt="Example of the choose2 dialog" src="httpatomoreillycomsourcenostarchimages854289.png.jpg"/></div></div><p class="title">Figure 17-5. Example of the <code class="literal">choose2</code> dialog</p></div><p>Far more complex uses of both the <code class="literal">choose</code> and the <code class="literal">choose2</code> functions are possible. Each function is capable of creating either modal <sup>[<a class="footnote" href="#ftn.CHP-17-FN-2" id="CHP-17-FN-2">118</a>]</sup> or nonmodal dialogs, and each function can generate dialogs that allow for selection of multiple items. Also, each function accepts several additional parameters that allow you to be notified when various events take place within the dialog. When these functions are used to create nonmodal dialogs, the result is a new tabbed window displayed alongside the tabs of other IDA display windows, such as the Imports window. In fact, IDA’s Imports window is implemented using the <code class="literal">choose2</code> interface. For more information on the capabilities of <code class="literal">choose</code> and <code class="literal">choose2</code>, please refer to <span class="emphasis"><em>kernwin.hpp</em></span>.<a class="indexterm" id="IDX-CHP-17-0117"/><a class="indexterm" id="IDX-CHP-17-0118"/><a class="indexterm" id="IDX-CHP-17-0119"/></p></div><div class="sect2" title="Creating Customized Forms with the SDK"><div class="titlepage"><div><div><h2 class="title"><a id="creating_customized_forms_with_the_sdk"/>Creating Customized Forms with the SDK</h2></div></div></div><p>For creating more complex user interface elements, the SDK provides the <code class="literal">AskUsingForm_c</code> function. The prototype for this function is shown here:</p><a id="I_programlisting3_d1e27393"/><pre class="programlisting">int AskUsingForm_c(const char *form,...);</pre><p>The function seems simple enough, yet it is among the more complex user interface functions available in the SDK. This complexity is due to the nature of the <code class="literal">form</code> argument, which is used to specify the layout of various user interface elements within the custom dialog. <code class="literal">AskUsingForm_c</code> is similar to <code class="literal">printf</code> in that the <code class="literal">form</code> argument is essentially a format string that describes the layout of various input elements. Where <code class="literal">printf</code> format strings utilize output format specifiers that are replaced with formatted data, <code class="literal">AskUsingForm_c</code> format strings are composed of both output specifiers and form field specifiers that are replaced with instances of input elements when the form is displayed. <code class="literal">AskUsingForm_c</code> recognizes a completely different set of output field specifiers than <code class="literal">printf</code>. These specifiers are detailed in <span class="emphasis"><em>kernwin.hpp</em></span> along with complete documentation on the use of <code class="literal">AskUsingForm_c</code>. The basic format of a form field specifier is shown here:<a class="indexterm" id="IDX-CHP-17-0120"/><a class="indexterm" id="IDX-CHP-17-0121"/><a class="indexterm" id="IDX-CHP-17-0122"/><a class="indexterm" id="IDX-CHP-17-0123"/><a class="indexterm" id="IDX-CHP-17-0124"/><a class="indexterm" id="IDX-CHP-17-0125"/><a class="indexterm" id="IDX-CHP-17-0126"/><a class="indexterm" id="IDX-CHP-17-0127"/></p><a id="I_programlisting3_d1e27453"/><pre class="programlisting">&lt;#hint text#label:type:width:swidth:@hlp[]&gt;</pre><p>The individual components of a form field specifier are described in the following list:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>#hint text#</code></strong> This element is optional. If present, the hint text, excluding the# characters, is displayed as a tool tip when the mouse hovers over the associated input field.</td></tr><tr><td><strong class="userinput"><code>label</code></strong> Static text displayed as a label to the left of the associated input field. In the case of button fields, this is the button text.</td></tr><tr><td><strong class="userinput"><code>type</code></strong> A single character indicates the type of form field being specified. Form field types are described following this list.</td></tr><tr><td><strong class="userinput"><code>width</code></strong> The maximum number of input characters accepted by the associated input field. In the case of button fields, this field specifies an integer button identification code used to distinguish one button from another.</td></tr><tr><td><strong class="userinput"><code>swidth</code></strong> The display width of the input field.</td></tr><tr><td><strong class="userinput"><code>@hlp[]</code></strong> This field is described in <span class="emphasis"><em>kernwin.hpp</em></span> as “the number of help screen from the <span class="emphasis"><em>IDA.HLP</em></span> file.” Since the content of this file is dictated by Hex-Rays, it seems unlikely that this field will be of use in the majority of cases. Substitute a colon for this field in order to ignore it.</td></tr></table><p>The characters used for the <code class="literal">type</code> field specify what type of input field will be generated when the dialog is realized at runtime. Each type of form field requires an associated parameter in the variable arguments portion of the <code class="literal">AskUsingForm_c</code> parameter list. Form field type specifiers and their associated parameter type are shown here (as taken from <span class="emphasis"><em>kernwin.hpp</em></span>):</p><a id="I_programlisting3_d1e27499"/><pre class="programlisting">Input field types                       va_list parameter
  -----------------                       -----------------

  A - ascii string                        char* at least MAXSTR size
  S - segment                             sel_t*
  N - hex number, C notation              uval_t*
  n - signed hex number, C notation       sval_t*
  L - default base (usually hex) number,  ulonglong*
      C notation
  l - default base (usually hex) number,  longlong*
      signed C notation
  M - hex number, no "0x" prefix          uval_t*
  D - decimal number                      sval_t*
  O - octal number, C notation            sval_t*
  Y - binary number, "0b" prefix          sval_t*
  H - char value, C notation              sval_t*
  $ - address                             ea_t*
  I - ident                               char* at least MAXNAMELEN size
  B - button                              formcb_t button callback function
  K - color button                        bgcolor_t*
  C - checkbox                            ushort* bit mask of checked boxes
  R - radiobutton                         ushort* number of selected radiobutton</pre><p>All numeric fields interpret the user-supplied input as an IDC expression that is parsed and evaluated when the user clicks the dialog’s OK button. All fields require a pointer argument that is used for both input and output. When the form is first generated, initial values for all form fields are taken by dereferencing the associated pointers. Upon return, the user-supplied form field values are written into the associated memory locations. The pointer argument associated with a button (<code class="literal">B</code>) field is the address of a function that will be called if the associated button is pressed. The <code class="literal">formcb_t</code> function is defined as follows.<a class="indexterm" id="IDX-CHP-17-0128"/><a class="indexterm" id="IDX-CHP-17-0129"/><a class="indexterm" id="IDX-CHP-17-0130"/><a class="indexterm" id="IDX-CHP-17-0131"/></p><a id="I_programlisting3_d1e27521"/><pre class="programlisting">// callback for buttons
typedef void (idaapi *formcb_t)(TView *fields[],int code);</pre><p>The <code class="literal">code</code> argument to the button callback represents the code (width) value associated with the button that was clicked. By using a switch statement to test this code, you can use a single function to process many different buttons.</p><p>The syntax for specifying radio button and checkbox controls differs slightly from the format of other types of form fields. These fields utilize the following format:</p><a id="I_programlisting3_d1e27531"/><pre class="programlisting">&lt;#item hint#label:type&gt;</pre><p>Radio buttons and checkboxes may be grouped by listing their specifiers in order and denoting the end of the list using the following special format (note the extra <code class="literal">&gt;</code> at the end).<a class="indexterm" id="IDX-CHP-17-0132"/></p><a id="I_programlisting3_d1e27541"/><pre class="programlisting">&lt;#item hint#label:type&gt;&gt;</pre><p>A radio button (or checkbox) group will be boxed to highlight the group. You can give the box a title by utilizing a special format when specifying the first element in the group, as shown here:<a class="indexterm" id="IDX-CHP-17-0133"/><a class="indexterm" id="IDX-CHP-17-0134"/></p><a id="I_programlisting3_d1e27551"/><pre class="programlisting">&lt;#item hint#title#box hint#label:type&gt;</pre><p>If you want to have a box title but do not want to use any hints, the hints may be omitted, leaving the following format specifier:</p><a id="I_programlisting3_d1e27555"/><pre class="programlisting">&lt;##title##label:type&gt;</pre><p>At this point let’s look at an example of a dialog constructed using <code class="literal">AskUsingForm_c</code>. <a class="xref" href="ch17s06.html#sample_askusingform_underscore_c_dialog" title="Figure 17-6. Sample AskUsingForm_c dialog">Figure 17-6</a> shows a dialog that we will refer to throughout this discussion.</p><div class="figure"><a id="sample_askusingform_underscore_c_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e27570"/><img alt="Sample AskUsingForm_c dialog" src="httpatomoreillycomsourcenostarchimages854292.png.jpg"/></div></div><p class="title">Figure 17-6. Sample <code class="literal">AskUsingForm_c</code> dialog</p></div><p>Format strings used to create <code class="literal">AskUsingForm_c</code> dialogs are made up of individual lines that specify each aspect of the desired dialog. In addition to form field specifiers, the format string may contain static text that is displayed, verbatim, in the resulting dialog. Finally, the format string may contain a dialog title (which must be followed by two carriage returns) and one or more behavior directives (such as <code class="literal">STARTITEM</code>, which specifies the index of the form field that is initially active when the dialog is first displayed). The format string used to create the dialog in <a class="xref" href="ch17s06.html#sample_askusingform_underscore_c_dialog" title="Figure 17-6. Sample AskUsingForm_c dialog">Figure 17-6</a> is shown here:</p><a id="I_programlisting3_d1e27586"/><pre class="programlisting">char *dialog =
 "STARTITEM 0\n"          //The first item gets the input focus
 "This is the title\n\n"  //followed by 2 new lines
 "This is static text\n"
 "&lt;String:A:32:32::&gt;\n"   //An ASCII input field, need char[MAXSTR]
 "&lt;Decimal:D:10:10::&gt;\n"  //A decimal input field, sval_t*
 "&lt;#No leading 0x#Hex:M:8:10::&gt;\n"  //A Hex input field with hint, uval_t*
 "&lt;Button:B::::&gt;\n"                 //A button field with no code, formcb_t
 "&lt;##Radio Buttons##Radio 1:R&gt;\n"   //A radio button with box title
 "&lt;Radio 2:R&gt;&gt;\n"                   //Last radio button in group
                                    //ushort* number of selected radio
 "&lt;##Check Boxes##Check 1:C&gt;\n"     //A checkbox field with a box title
 "&lt;Check 2:C&gt;&gt;\n";                  //Last checkbox in group
                                    //ushort* bitmask of checks</pre><p>By formatting the dialog specification as we have, one element per line, we are attempting to make it easier to map each field specifier to its corresponding field in <a class="xref" href="ch17s06.html#sample_askusingform_underscore_c_dialog" title="Figure 17-6. Sample AskUsingForm_c dialog">Figure 17-6</a>. You may notice that in <a class="xref" href="ch17s06.html#sample_askusingform_underscore_c_dialog" title="Figure 17-6. Sample AskUsingForm_c dialog">Figure 17-6</a>, all of the text and numeric input fields appear as drop-down list controls. In an effort to save you time, IDA populates each list with recently entered values whose type matches the type of the associated input field. The following plug-in code may be used to display the example dialog and process any results:<a class="indexterm" id="IDX-CHP-17-0135"/><a class="indexterm" id="IDX-CHP-17-0136"/><a class="indexterm" id="IDX-CHP-17-0137"/></p><a id="I_programlisting3_d1e27611"/><pre class="programlisting">void idaapi button_func(TView *fields[], int code) {
   msg("The button was pressed!\n");
}

void idaapi run(int arg) {
   char input[MAXSTR];
   sval_t dec = 0;
   uval_t hex = 0xdeadbeef;
   ushort radio = 1;      //select button 1 initially
   ushort checkmask = 3;  //select both checkboxes initially
   qstrncpy(input, "initial value", sizeof(input));
   if (AskUsingForm_c(dialog, input, &amp;dec, &amp;hex,
                      button_func, &amp;radio, &amp;checkmask) == 1) {
      msg("The input string was: %s\n", input);
      msg("Decimal: %d, Hex %x\n", dec, hex);
      msg("Radio button %d is selected\n", radio);
      for (int n = 0; checkmask; n++) {
         if (checkmask &amp; 1) {
            msg("Checkbox %d is checked\n", n);
         }
         checkmask &gt;&gt;= 1;
      }
   }
}</pre><p>Note that when processing radio button and checkbox results, the first button in each group is considered button zero.</p><p>The <code class="literal">AskUsingForm_c</code> function provides a considerable amount of power for designing user interface elements for your plug-ins. The example here touches on many of the capabilities of this function, but many more are detailed in <span class="emphasis"><em>kernwin.hpp</em></span>. Please refer to this file for more information on the <code class="literal">AskUsingForm_c</code> function and its capabilities.</p></div><div class="sect2" title="Windows-Only User Interface–Generation Techniques"><div class="titlepage"><div><div><h2 class="title"><a id="windows-only_user_interfacengeneration_t"/>Windows-Only User Interface–Generation Techniques</h2></div></div></div><p>Many developers have wrestled with the problem of creating user interfaces for their plug-ins. Plug-ins targeting the Windows-only GUI version of IDA (<span class="emphasis"><em>idag.exe</em></span>) have the entire Windows graphical API at their disposal. The author of the mIDA<sup>[<a class="footnote" href="#ftn.CHP-17-FN-3" id="CHP-17-FN-3">119</a>]</sup> plug-in from Tenable Security developed an alternate approach for creating the MDI<sup>[<a class="footnote" href="#ftn.CHP-17-FN-4" id="CHP-17-FN-4">120</a>]</sup> client windows used in the mIDA plug-in. A lengthy thread<sup>[<a class="footnote" href="#ftn.CHP-17-FN-5" id="CHP-17-FN-5">121</a>]</sup> on the challenges faced by the mIDA developers can be found in the IDA support forums. The thread also contains example code that demonstrates their solution to the problem.<a class="indexterm" id="IDX-CHP-17-0138"/><a class="indexterm" id="IDX-CHP-17-0139"/><a class="indexterm" id="IDX-CHP-17-0140"/><a class="indexterm" id="IDX-CHP-17-0141"/><a class="indexterm" id="IDX-CHP-17-0142"/><a class="indexterm" id="IDX-CHP-17-0143"/></p><p>The ida-x86emu<sup>[<a class="footnote" href="#ftn.CHP-17-FN-6" id="CHP-17-FN-6">122</a>]</sup> plug-in takes a slightly different approach in its user interface. This plug-in relies on the fact that a handle to IDA’s main window can be obtained using the following SDK code:</p><a id="I_programlisting3_d1e27686"/><pre class="programlisting">HWND mainWindow = (HWND)callui(ui_get_hwnd).vptr;</pre><p>Using the main IDA window as a parent, ida-x86emu currently makes no attempt to integrate into the IDA workspace. All of the plug-in’s dialog interfaces are generated using a Windows resource editor, and all user interactions are handled using direct calls to Windows API functions. The use of a graphical dialog editor in conjunction with direct calls to native Windows API functions provides the most powerful user interface–generation capability at the expense of added complexity and the additional knowledge required to process Windows messages and work with lower-level interface functions.</p></div><div class="sect2" title="User Interface Generation with Qt"><div class="titlepage"><div><div><h2 class="title"><a id="user_interface_generation_with_qt"/>User Interface Generation with Qt</h2></div></div></div><p>The Qt user interface introduced in IDA 6.0 offers plug-in developers the chance to create plug-ins with complex user interfaces capable of being used on all IDA platforms. Hex-Rays’ Daniel Pistelli<sup>[<a class="footnote" href="#ftn.CHP-17-FN-7" id="CHP-17-FN-7">123</a>]</sup> discusses some of the requirements for using Qt in your plug-ins in a blog post on the Hex-Rays blog. See <sup>[<a class="footnote" href="#ftn.CHP-17-FN-8" id="CHP-17-FN-8">124</a>]</sup> In this section we will reiterate some of the important points that Daniel makes as well as point out some additional useful information.</p><p>If you wish to make use of any Qt functionality in your plug-ins, you must begin by properly configuring a Qt development environment. IDA 6.1 ships with its own versions of the Qt 4.7.2 libraries.<sup>[<a class="footnote" href="#ftn.CHP-17-FN-9" id="CHP-17-FN-9">125</a>]</sup> When Hex-Rays builds its Qt libraries, it wraps the libraries in a C++ namespace named <code class="literal">QT</code>. To configure your development environment, obtain the appropriate Qt sources from Nokia. The Windows version of <span class="emphasis"><em>idaq</em></span> is built with Visual Studio 2008,<sup>[<a class="footnote" href="#ftn.CHP-17-FN-10" id="CHP-17-FN-10">126</a>]</sup> and the Linux and OS X versions use g++. The appropriate sources for Windows may be found here:</p><a id="I_programlisting3_d1e27719"/><pre class="programlisting"><em class="replaceable"><code>ftp://ftp.qt.nokia.com/qt/source/qt-win-opensource-4.7.2-vs2008.exe</code></em></pre><p>Sources for Linux and OS X can be found here:<a class="indexterm" id="IDX-CHP-17-0144"/><a class="indexterm" id="IDX-CHP-17-0145"/><a class="indexterm" id="IDX-CHP-17-0146"/></p><a id="I_programlisting3_d1e27733"/><pre class="programlisting"><em class="replaceable"><code>ftp://ftp.qt.nokia.com/qt/source/qt-everywhere-opensource-src-4.7.2.tar.gz</code></em></pre><p>See Daniel’s blog post for specific commands to configure your sources. The key to proper configuration is the following command-line parameter:</p><a id="I_programlisting3_d1e27738"/><pre class="programlisting">-qtnamespace QT</pre><p>This parameter causes the Qt sources to be wrapped in the <code class="literal">QT</code> name-space. In order to build any Qt-related plug-ins on Windows, you will need link libraries (<span class="emphasis"><em>.lib</em></span> files) for each Qt library that you utilize in your plug-in. While IDA ships with a number of dynamic link libraries for Qt (see <span class="emphasis"><em>&lt;IDADIR&gt;</em></span> for a complete list), the SDK ships with a very limited number of Qt link libraries for Windows (notably QtCore4 and QtGui), which may be found in <span class="emphasis"><em>&lt;SDKDIR&gt;/lib/x86_win_qt</em></span>. If you need additional link libraries, you will need to link against the libraries that you build yourself from the Qt sources. On Linux and OS X, you can link directly with the Qt libraries that ship with IDA. On Linux, these can be found in <span class="emphasis"><em>&lt;IDADIR&gt;</em></span>; on OS X these can be found in <span class="emphasis"><em>&lt;IDADIR&gt;/idaq.app/Contents/Frameworks</em></span>. Note that linking against Qt libraries that don’t ship with IDA will make your plug-in somewhat less portable, unless you also distribute those libraries along with your plug-in.<a class="indexterm" id="IDX-CHP-17-0147"/></p><p>When configuring your Qt plug-in projects, make sure that your <code class="literal">qmake</code> project file contains the following configuration directive:</p><a id="I_programlisting3_d1e27769"/><pre class="programlisting">QT_NAMESPACE = QT</pre><p>IDA defines a number of functions for safer string handling within the SDK. These include functions such as <code class="literal">qstrlen</code> and <code class="literal">qsnprintf</code>, which have long been part of the SDK. With the move to a Qt-based GUI, this leads to problems because Qt also defines several functions named the same as those provided by IDA. The IDA functions reside in the global namespace, while the Qt functions reside in the <code class="literal">QT</code> namespace. The IDA versions of such functions can be called by explicitly referencing the global namespace as shown here:</p><a id="I_programlisting3_d1e27783"/><pre class="programlisting">unsigned int len = ::qstrlen(myString);</pre><p>Should you need a parent widget for any widgets that you are creating in your plug-in, the following statement will obtain a pointer to <span class="emphasis"><em>idaq</em></span>’s top-level application window:</p><a id="I_programlisting3_d1e27790"/><pre class="programlisting">QWidget *mainWindow = QApplication::activeWindow();</pre><p>This invokes a static method within Qt’s <code class="literal">QApplication</code> class that returns the widget pointer for the sole <code class="literal">QApplication</code> object in any Qt application.</p><p>For more information on configuring your plug-ins to use Qt, refer to Daniel’s blog post. Additionally, the qwindow plug-in sample that ships with IDA’s SDK provides an example of a plug-in that makes use of Qt. Specifically it contains example code that creates an empty widget (using <code class="literal">create_tform</code>), uses callbacks to receive notification that the form is being made visible, obtains a QWidget pointer to the newly created form, and finally populates the form with a Qt button object. The collabREate and ida-x86emu plug-ins to be discussed in <a class="xref" href="ch23.html" title="Chapter 23. Real-World IDA Plug-ins">Chapter 23</a> also make use of Qt GUI elements to allow these plug-ins to be used on all IDA capable platforms.<a class="indexterm" id="IDX-CHP-17-0148"/><a class="indexterm" id="IDX-CHP-17-0149"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-2" id="ftn.CHP-17-FN-2">118</a>] </sup>A <span class="emphasis"><em>modal dialog</em></span> must be closed before the user is allowed to continue interacting with the dialog’s parent application. File open and save dialogs are common examples of modal dialogs. Modal dialogs are typically used when an application requires information from a user before the application can continue execution. On the other hand, nonmodal or modeless dialogs allow the user to continue interacting with the parent application while the dialog remains open.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-3" id="ftn.CHP-17-FN-3">119</a>] </sup>See <a class="ulink" href="http://cgi.tenablesecurity.com/tenable/mida.php">http://cgi.tenablesecurity.com/tenable/mida.php</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-4" id="ftn.CHP-17-FN-4">120</a>] </sup>The Windows <span class="emphasis"><em>Multiple Document Interface (MDI)</em></span> allows multiple child (client) windows to be contained within a single container window.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-5" id="ftn.CHP-17-FN-5">121</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/forum/viewtopic.php?f=8&amp;t=1660&amp;p=6752">http://www.hex-rays.com/forum/viewtopic.php?f=8&amp;t=1660&amp;p=6752</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-6" id="ftn.CHP-17-FN-6">122</a>] </sup>See <a class="ulink" href="http://www.idabook.com/ida-x86emu">http://www.idabook.com/ida-x86emu</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-7" id="ftn.CHP-17-FN-7">123</a>] </sup>Daniel led the Hex-Rays effort to migrate IDA’s GUI to Qt.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-8" id="ftn.CHP-17-FN-8">124</a>] </sup><a class="ulink" href="http://www.hexblog.com/?p=250">http://www.hexblog.com/?p=250</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-9" id="ftn.CHP-17-FN-9">125</a>] </sup>IDA 6.0 utilized Qt 4.6.3.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-10" id="ftn.CHP-17-FN-10">126</a>] </sup>As a consequence, if you are building a Qt-related plug-in on Windows, you must use Visual Studio to build your plug-in.</p></div></div></div>
<div class="sect1" title="Scripted Plug-ins"><div class="titlepage"><div><div><h1 class="title"><a id="scripted_plug-ins"/>Scripted Plug-ins</h1></div></div></div><p>IDA 5.6 introduced support for scripted loader modules. In IDA 5.7, support was added for scripted plug-ins <sup>[<a class="footnote" href="#ftn.CHP-17-FN-11" id="CHP-17-FN-11">127</a>]</sup> and processor modules. While this does not necessarily allow for the development of more powerful plug-ins, it does somewhat lower the barrier to entry for potential plug-in developers and allows for a somewhat faster development cycle because the complex build process is eliminated.<a class="indexterm" id="IDX-CHP-17-0150"/><a class="indexterm" id="IDX-CHP-17-0151"/></p><p>Although scripted plug-ins can be created using either IDC or Python, Python is probably the most appropriate choice given that it exposes so much of IDA’s SDK. Given this fact, there is no reason why Python plug-ins can’t be just as powerful as compiled C++ plug-ins.</p><p>Creating a Python plug-in is a straightforward process. The primary requirement is to define a function named <code class="literal">PLUGIN_ENTRY</code> that returns an instance of <code class="literal">plugin_t</code> (defined in module <code class="literal">idaapi</code>). The <code class="literal">plugin_t</code> class contains members that mirror the members of the SDK’s C++ <code class="literal">plugin_t</code> class. <a class="xref" href="ch17s07.html#a_minimal_python_plug-in" title="Example 17-4. A minimal Python plug-in">Example 17-4</a> shows a simple Python plug-in that defines a class named <code class="literal">idabook_plugin_t</code>, which inherits from <code class="literal">plugin_t</code>; initializes all required members; and defines <code class="literal">init</code>, <code class="literal">term</code>, and <code class="literal">run</code> functions that implement the plug-in behavior.</p><div class="example"><a id="a_minimal_python_plug-in"/><p class="title">Example 17-4. A minimal Python plug-in</p><div class="example-contents"><pre class="programlisting">from idaapi import *

class idabook_plugin_t(plugin_t):
   flags = 0
   wanted_name = "IdaBook Python Plugin"
   wanted_hotkey = "Alt-8"
   comment = "IdaBook Python Plugin"
   help = "Something helpful"

   def init(self):
      msg("IdaBook plugin init called.\n")
      return PLUGIN_OK

   def term(self):
      msg("IdaBook plugin term called.\n")

   def run(self, arg):
      warning("IdaBook plugin run(%d) called.\n" % arg)

   def PLUGIN_ENTRY():
      return idabook_plugin_t()</pre></div></div><p>Installation of the plug-in script is accomplished by copying the script to <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>.</p><p>The same plug-in written in IDC appears in <a class="xref" href="ch17s07.html#a_minimal_idc_plug-in" title="Example 17-5. A minimal IDC plug-in">Example 17-5</a>. Since IDC does not define a plug-in–related base class, our obligation is to create a class that defines all the elements expected of a plug-in, ensuring that we name each element properly.</p><div class="example"><a id="a_minimal_idc_plug-in"/><p class="title">Example 17-5. A minimal IDC plug-in</p><div class="example-contents"><pre class="programlisting">#include &lt;idc.idc&gt;

class idabook_plugin_t {

   idabook_plugin_t() {
      this.flags = 0;
      this.wanted_name = "IdaBook IDC Plugin";
      this.wanted_hotkey = "Alt-9";
      this.comment = "IdaBook IDC Plugin";
      this.help = "Something helpful";
   }

   init() {
      Message("IdaBook plugin init called.\n");
      return PLUGIN_OK;
   }

   term() {
      Message("IdaBook plugin term called.\n");
   }

   run(arg) {
      Warning("IdaBook plugin run(%d) called.\n", arg);
   }
}

static PLUGIN_ENTRY() {
   return idabook_plugin_t();
}</pre></div></div><p>As with the Python example, the <code class="literal">PLUGIN_ENTRY</code> function serves to create and return an instance of our plug-in class. Installation, once again, involves copying the <span class="emphasis"><em>.idc</em></span> file to <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-17-FN-11" id="ftn.CHP-17-FN-11">127</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=120">http://www.hexblog.com/?p=120</a></p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id16"/>Summary</h1></div></div></div><p>IDA plug-ins are the logical next step when scripting fails to meet your needs for extending IDA’s capabilities, though with the advent of scripted plug-ins, you may find yourself resisting the urge to dive into the SDK. Additionally, unless you are faced with the challenge of reverse engineering a file format that is unknown to IDA or a machine language for which IDA has no processor module, plug-ins may be the only type of IDA extension that you ever feel the need to explore. Nonetheless, in the next two chapters, we continue to explore the capabilities offered by IDA’s SDK by looking at the other types of modules that can be constructed for use with IDA: loaders and processor modules.</p></div>
<div class="chapter" title="Chapter&#xA0;18.&#xA0;Binary Files and IDA Loader Modules"><div class="titlepage"><div><div><h1 class="title"><a id="binary_files_and_ida_loader_modules"/>Chapter 18. Binary Files and IDA Loader Modules</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id17"/><div class="mediaobject"><a id="I_mediaobject4_d1e27910"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>One day word will get out that you have become the resident IDA geek. You may relish the fact that you have hit the big time, or you may bemoan the fact that from that day forward, people will be interrupting you with questions about what some file does. Eventually, either as a result of one such question or simply because you enjoy using IDA to open virtually every file you can find, you may be confronted with the dialog shown in <a class="xref" href="ch18.html#loading_a_binary_file" title="Figure 18-1. Loading a binary file">Figure 18-1</a>.<a class="indexterm" id="IDX-CHP-18-0001"/></p><p>This is IDA’s standard file-loading dialog with a minor problem (from the user’s perspective). The short list of recognized file types contains only one entry, Binary file, indicating that none of IDA’s installed loader modules recognize the format of the file you want to load. Hopefully you will at least know what machine language you are dealing with (you do at least know where the file came from, right?) and can make an intelligent choice for the processor type, because that is about all you can do in such cases.</p><div class="figure"><a id="loading_a_binary_file"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e27927"/><img alt="Loading a binary file" src="httpatomoreillycomsourcenostarchimages854295.png.jpg"/></div></div><p class="title">Figure 18-1. Loading a binary file</p></div><p>In this chapter we will discuss IDA’s capabilities for helping you make sense of unrecognized file types, beginning with manual analysis of binary file formats and then using that as motivation for the development of your own IDA loader modules.<a class="indexterm" id="IDX-CHP-18-0002"/></p><div class="sect1" title="Unknown File Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="unknown_file_analysis"/>Unknown File Analysis</h1></div></div></div><p>An infinite number of file formats exist for storing executable code. IDA ships with loader modules to recognize many of the more common file formats, but there is no way that IDA can accommodate the ever-increasing number of formats in existence. Binary images may contain executable files formatted for use with specific operating systems, ROM images extracted from embedded systems, firmware images extracted from flash updates, or simply raw blocks of machine language, perhaps extracted from network packet captures. The format of these images may be dictated by the operating system (executable files), the target processor and system architecture (ROM images), or nothing at all (exploit shellcode embedded in application layer data).<a class="indexterm" id="IDX-CHP-18-0003"/></p><p>Assuming that a processor module is available to disassemble the code contained in the unknown binary, it will be your job to properly arrange the file image within an IDA database before informing IDA which portions of the binary represent code and which portions of the binary represent data. For most processor types, the result of loading a file using the binary format is simply a list of the contents of the file piled into a single segment beginning at address zero, as shown in <a class="xref" href="ch18.html#initial_lines_of_a_pe_file_loaded_in_bin" title="Example 18-1. Initial lines of a PE file loaded in binary mode">Example 18-1</a>.<a class="indexterm" id="IDX-CHP-18-0004"/><a class="indexterm" id="IDX-CHP-18-0005"/><a class="indexterm" id="IDX-CHP-18-0006"/></p><div class="example"><a id="initial_lines_of_a_pe_file_loaded_in_bin"/><p class="title">Example 18-1. Initial lines of a PE file loaded in binary mode</p><div class="example-contents"><pre class="programlisting">seg000:00000000                 db  4Dh ; M
seg000:00000001                 db  5Ah ; Z
seg000:00000002                 db  90h ; É
seg000:00000003                 db    0
seg000:00000004                 db    3
seg000:00000005                 db    0
seg000:00000006                 db    0
seg000:00000007                 db    0</pre></div></div><p>In some cases, depending on the sophistication of the selected processor module, some disassembly may take place. This may be the case when a selected processor is an embedded microcontroller that can make specific assumptions about the memory layout of ROM images. For those interested in such applications, Andy Whittaker has created an excellent walk-through<sup>[<a class="footnote" href="#ftn.CHP-18-FN-1" id="CHP-18-FN-1">128</a>]</sup> of reverse engineering a binary image for a Siemens C166 microcontroller application.<a class="indexterm" id="IDX-CHP-18-0007"/></p><p>When faced with binary files, you will almost certainly need to arm yourself with as many resources related to the file as you can get your hands on. Such resources might include CPU references, operating system references, system design documentation, and any memory layout information obtained through debugging or hardware-assisted (such as via logic analyzers) analysis.</p><p>In the following section, for the sake of example we assume that IDA does not recognize the Windows PE file format. PE is a well-known file format that many readers may be familiar with. More important, documents detailing the structure of PE files are widely available, which makes dissecting an arbitrary PE file a relatively simple task.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-18-FN-1" id="ftn.CHP-18-FN-1">128</a>] </sup>See <a class="ulink" href="http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx">http://www.andywhittaker.com/ECU/DisassemblingaBoschME755/tabid/96/Default.aspx</a>.</p></div></div></div>
<div class="sect1" title="Manually Loading a Windows PE File"><div class="titlepage"><div><div><h1 class="title"><a id="manually_loading_a_windows_pe_file"/>Manually Loading a Windows PE File</h1></div></div></div><p>When you can find documentation on the format utilized by a particular file, your life will be significantly easier as you attempt to map the file into an IDA database. <a class="xref" href="ch18.html#initial_lines_of_a_pe_file_loaded_in_bin" title="Example 18-1. Initial lines of a PE file loaded in binary mode">Example 18-1</a> shows the first few lines of a PE file loaded into IDA as a binary file. With no help from IDA, we turn to the PE specification,<sup>[<a class="footnote" href="#ftn.CHP-18-FN-2" id="CHP-18-FN-2">129</a>]</sup> which states that a valid PE file will begin with a valid MS-DOS header structure. A valid MS-DOS header structure in turn begins with the 2-byte signature <code class="literal">4Dh 5Ah</code> (<code class="literal">MZ</code>), which we see in the first two lines of <a class="xref" href="ch18.html#initial_lines_of_a_pe_file_loaded_in_bin" title="Example 18-1. Initial lines of a PE file loaded in binary mode">Example 18-1</a>.</p><p>At this point an understanding of the layout of an MS-DOS header is required. The PE specification would tell us that the 4-byte value located at offset <code class="literal">0x3C</code> in the file indicates the offset to the next header we need to find—the PE header. Two strategies for breaking down the fields of the MS-DOS header are (1) to define appropriately sized data values for each field in the MS-DOS header or (2) to use IDA’s structure-creation facilities to define and apply an <code class="literal">IMAGE_DOS_HEADER</code> structure in accordance with the PE file specification.<sup>[<a class="footnote" href="#ftn.CHP-18-FN-3" id="CHP-18-FN-3">130</a>]</sup> Using the latter approach would yield the following modified display:<a class="indexterm" id="IDX-CHP-18-0008"/><a class="indexterm" id="IDX-CHP-18-0009"/><a class="indexterm" id="IDX-CHP-18-0010"/></p><a id="I_programlisting4_d1e28028"/><pre class="programlisting">seg000:00000000                 dw 5A4Dh                ; e_magic
seg000:00000000                 dw 90h                  ; e_cblp
seg000:00000000                 dw 3                    ; e_cp
seg000:00000000                 dw 0                    ; e_crlc
seg000:00000000                 dw 4                    ; e_cparhdr
seg000:00000000                 dw 0                    ; e_minalloc
seg000:00000000                 dw 0FFFFh               ; e_maxalloc
seg000:00000000                 dw 0                    ; e_ss
seg000:00000000                 dw 0B8h                 ; e_sp
seg000:00000000                 dw 0                    ; e_csum
seg000:00000000                 dw 0                    ; e_ip
seg000:00000000                 dw 0                    ; e_cs
seg000:00000000                 dw 40h                  ; e_lfarlc
seg000:00000000                 dw 0                    ; e_ovno
seg000:00000000                 dw 4 dup(0)             ; e_res
seg000:00000000                 dw 0                    ; e_oemid
seg000:00000000                 dw 0                    ; e_oeminfo
seg000:00000000                 dw 0Ah dup(0)           ; e_res2
seg000:00000000                 dd 80h                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>; e_lfanew</pre><p>The <code class="literal">e_lfanew</code> field <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28041"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> has a value of <code class="literal">80h</code>, indicating that a PE header should be found at offset <code class="literal">80h</code> (128 bytes) into the database. Examining the bytes at offset <code class="literal">80h</code> should reveal the magic number for a PE header, <code class="literal">50h 45h</code> (<code class="literal">PE</code>), and allow us to build (based on our reading of the PE specification) and apply an <code class="literal">IMAGE_NT_HEADERS</code> structure at offset <code class="literal">80h</code> into the database. A portion of the resulting IDA listing might look like the following:</p><a id="I_programlisting4_d1e28069"/><pre class="programlisting">seg000:00000080        dd 4550h        ; Signature
seg000:00000080        dw 14Ch       <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>; FileHeader.Machine
seg000:00000080        dw 4          <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>; FileHeader.NumberOfSections
seg000:00000080        dd 47826AB4h    ; FileHeader.TimeDateStamp
seg000:00000080        dd 0E00h        ; FileHeader.PointerToSymbolTable
seg000:00000080        dd 0FBh         ; FileHeader.NumberOfSymbols
seg000:00000080        dw 0E0h         ; FileHeader.SizeOfOptionalHeader
seg000:00000080        dw 307h         ; FileHeader.Characteristics
seg000:00000080        dw 10Bh         ; OptionalHeader.Magic
seg000:00000080        db 2            ; OptionalHeader.MajorLinkerVersion
seg000:00000080        db 38h          ; OptionalHeader.MinorLinkerVersion
seg000:00000080        dd 600h         ; OptionalHeader.SizeOfCode
seg000:00000080        dd 400h         ; OptionalHeader.SizeOfInitializedData
seg000:00000080        dd 200h         ; OptionalHeader.SizeOfUninitializedData
seg000:00000080        dd 1000h      <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>; OptionalHeader.AddressOfEntryPoint
seg000:00000080        dd 1000h        ; OptionalHeader.BaseOfCode
seg000:00000080        dd 0            ; OptionalHeader.BaseOfData
seg000:00000080        dd 400000h    <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>; OptionalHeader.ImageBase
seg000:00000080        dd 1000h      <img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>; OptionalHeader.SectionAlignment
seg000:00000080        dd 200h       <img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>; OptionalHeader.FileAlignment</pre><p>The preceding listings and discussion bear many similarities to the exploration of MS-DOS and PE header structures conducted in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>. In this case, however, the file has been loaded into IDA without the benefit of the PE loader, and rather than being a curiosity as they were in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>, the header structures are essential to a successful understanding of the remainder of the database.<a class="indexterm" id="IDX-CHP-18-0011"/><a class="indexterm" id="IDX-CHP-18-0012"/><a class="indexterm" id="IDX-CHP-18-0013"/><a class="indexterm" id="IDX-CHP-18-0014"/><a class="indexterm" id="IDX-CHP-18-0015"/></p><p>At this point, we have revealed a number of interesting pieces of information that will help us to further refine our database layout. First, the <code class="literal">Machine</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28134"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> field in a PE header indicates the target CPU type for which the file was built. In this example the value <code class="literal">14Ch</code> indicates that the file is for use with x86 processor types. Had the machine type been something else, such as <code class="literal">1C0h</code> (ARM), we would actually need to close the database and restart our analysis, making certain that we select the correct processor type in the initial loading dialog. Once a database has been loaded, it is not possible to change the processor type in use with that database.</p><p>The <code class="literal">ImageBase</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28151"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> field indicates the base virtual address for the loaded file image. Using this information, we can finally begin to incorporate some virtual address information into the database. Using the Edit ▸ Segments ▸ Rebase Program menu option, we can specify a new base address for the first segment of the program, as shown in <a class="xref" href="ch18s02.html#specifying_a_new_base_address_for_a_prog" title="Figure 18-2. Specifying a new base address for a program">Figure 18-2</a>.<a class="indexterm" id="IDX-CHP-18-0016"/></p><div class="figure"><a id="specifying_a_new_base_address_for_a_prog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e28165"/><img alt="Specifying a new base address for a program" src="httpatomoreillycomsourcenostarchimages854298.png.jpg"/></div></div><p class="title">Figure 18-2. Specifying a new base address for a program</p></div><p>In the current example, only one segment exists, because IDA creates only one segment to hold the entire file when a file is loaded in binary mode. The two checkbox options shown in the dialog determine how IDA handles relocation entries when segments are moved and whether IDA should move every segment present in the database, respectively. For a file loaded in binary mode, IDA will not be aware of any relocation information. Similarly, with only one segment present in the program, the entire image will be rebased by default.</p><p>The <code class="literal">AddressOfEntryPoint</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28178"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> field specifies the relative virtual address (RVA) of the program entry point. An RVA is a relative offset from the program’s base virtual address, while the program entry point represents the address of the first instruction within the program that will be executed. In this case an entry point RVA of <code class="literal">1000h</code> indicates that the program will begin execution at virtual address <code class="literal">401000h</code> (<code class="literal">400000h + 1000h</code>). This is an important piece of information, because it is our first indication of where we should begin looking for code within the database. Before we can do that, however, we need to properly map the remainder of the database to appropriate virtual addresses.<a class="indexterm" id="IDX-CHP-18-0017"/><a class="indexterm" id="IDX-CHP-18-0018"/><a class="indexterm" id="IDX-CHP-18-0019"/><a class="indexterm" id="IDX-CHP-18-0020"/><a class="indexterm" id="IDX-CHP-18-0021"/><a class="indexterm" id="IDX-CHP-18-0022"/><a class="indexterm" id="IDX-CHP-18-0023"/><a class="indexterm" id="IDX-CHP-18-0024"/></p><p>The PE format makes use of sections to describe the mapping of file content to memory ranges. By parsing the section headers for each section in the file, we can complete the basic virtual memory layout of the database. The <code class="literal">NumberOfSections</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28223"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> field indicates the number of sections contained in a PE file; in this case there are four. Referring once again to the PE specification, we would learn that an array of section header structures immediately follows the <code class="literal">IMAGE_NT_HEADERS</code> structure. Individual elements in the array are <code class="literal">IMAGE_SECTION_HEADER</code> structures, which we could define in IDA’s Structures window and apply (four times in this case) to the bytes following the <code class="literal">IMAGE_NT_HEADERS</code> structure.</p><p>Before we discuss segment creation, two additional fields worth pointing out are <code class="literal">FileAlignment</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28243"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> and <code class="literal">SectionAlignment</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28252"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span>. These fields indicate how the data for each section is aligned<sup>[<a class="footnote" href="#ftn.CHP-18-FN-4" id="CHP-18-FN-4">131</a>]</sup> within the file and how that same data will be aligned when mapped into memory, respectively. In our example, each section is aligned to a <code class="literal">200h</code> byte offset within the file; however, when loaded into memory, those same sections will be aligned on addresses that are multiples of <code class="literal">1000h</code>. The smaller <code class="literal">FileAlignment</code> value offers a means of saving space when an executable image is stored in a file, while the larger <code class="literal">SectionAlignment</code> value typically corresponds to the operating system’s virtual memory page size. Understanding how sections are aligned can help us avoid errors when we manually create sections within our database.<a class="indexterm" id="IDX-CHP-18-0025"/></p><p>After structuring each of the section headers, we finally have enough information to begin creating additional segments within the database. Applying an <code class="literal">IMAGE_SECTION_HEADER</code> template to the bytes immediately following the <code class="literal">IMAGE_NT_HEADERS</code> structure yields the first section header and results in the following data displayed in our example database:</p><a id="I_programlisting4_d1e28295"/><pre class="programlisting">seg000:00400178                 db '.text',0,0,0      <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>; Name
seg000:00400178                 dd 440h                 ; VirtualSize
seg000:00400178                 dd 1000h              <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>; VirtualAddress
seg000:00400178                 dd 600h               <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>; SizeOfRawData
seg000:00400178                 dd 400h               <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>; PointerToRawData
seg000:00400178                 dd 0                    ; PointerToRelocations
seg000:00400178                 dd 0                    ; PointerToLinenumbers
seg000:00400178                 dw 0                    ; NumberOfRelocations
seg000:00400178                 dw 0                    ; NumberOfLinenumbers
seg000:00400178                 dd 60000020h            ; Characteristics</pre><p>The <code class="literal">Name</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28326"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> field informs us that this header describes the <code class="literal">.text</code> section. All of the remaining fields are potentially useful in formatting the database, but we will focus on the three that describe the layout of the section. The <code class="literal">PointerToRawData</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28338"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> field (<code class="literal">400h</code>) indicates the file offset at which the content of the section can be found. Note that this value is a multiple of the file alignment value, <code class="literal">200h</code>. Sections within a PE file are arranged in increasing file offset (and virtual address) order. Since this section begins at file offset <code class="literal">400h</code>, we can conclude that the first <code class="literal">400h</code> bytes of the file contain file header data. Therefore, even though they do not, strictly speaking, constitute a section, we can highlight the fact that they are logically related by grouping them into a section in the database.<a class="indexterm" id="IDX-CHP-18-0026"/><a class="indexterm" id="IDX-CHP-18-0027"/><a class="indexterm" id="IDX-CHP-18-0028"/><a class="indexterm" id="IDX-CHP-18-0029"/></p><p>The Edit ▸ Segments ▸ Create Segment command is used to manually create segments in a database. <a class="xref" href="ch18s02.html#the_segment-creation_dialog" title="Figure 18-3. The segment-creation dialog">Figure 18-3</a> shows the segment-creation dialog.<a class="indexterm" id="IDX-CHP-18-0030"/><a class="indexterm" id="IDX-CHP-18-0031"/></p><div class="figure"><a id="the_segment-creation_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e28383"/><img alt="The segment-creation dialog" src="httpatomoreillycomsourcenostarchimages854301.png.jpg"/></div></div><p class="title">Figure 18-3. The segment-creation dialog</p></div><p>When creating a segment, you may specify any name you wish. Here we choose .<code class="literal">headers</code>, because it is unlikely to be used as an actual section name in the file and it adequately describes the section’s content. You may manually enter the section’s start (inclusive) and end (exclusive) addresses, or they will be filled in automatically if you have highlighted the range of addresses that make up the section prior to opening the dialog. The section base value is described in the SDK’s <span class="emphasis"><em>segment.hpp</em></span> file. In a nutshell, for x86 binaries, IDA computes the virtual address of a byte by shifting the segment base left four bits and adding the offset to the byte (<code class="literal">virtual = (base &lt;&lt; 4) + offset</code>). A base value of zero should be used when segmentation is not used. The segment class can be used to describe the content of the segment. Several predefined class names such as <code class="literal">CODE</code>, <code class="literal">DATA</code>, and <code class="literal">BSS</code> are recognized. Predefined segment classes are also described in <span class="emphasis"><em>segment.hpp</em></span>.</p><p>An unfortunate side effect of creating a new segment is that any data that had been defined within the bounds of the segment (such as the headers that we previously formatted) will be undefined. After reapplying all of the header structures discussed previously, we return to the header for the <code class="literal">.text</code> section to note that the <code class="literal">VirtualAddress</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28420"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> field (<code class="literal">1000h</code>) is an RVA that specifies the memory address at which the section content should be loaded and the <code class="literal">SizeOfRawData</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28433"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> field (<code class="literal">600h</code>) indicates how many bytes of data are present in the file. In other words, this particular section header tells us that the <code class="literal">.text</code> section is created by mapping the <code class="literal">600h</code> bytes from file offsets <code class="literal">400h-9FFh</code> to virtual addresses <code class="literal">401000h-4015FFh</code>.<a class="indexterm" id="IDX-CHP-18-0032"/><a class="indexterm" id="IDX-CHP-18-0033"/></p><p>Because our example file was loaded in binary mode, all of the bytes of the <code class="literal">.text</code> section are present in the database; we simply need to shift them into their proper locations. Following creation of the <code class="literal">.headers</code> section, we might have a display similar to the following at the end of the <code class="literal">.headers</code> section:</p><a id="I_programlisting4_d1e28473"/><pre class="programlisting">.headers:004003FF                 db    0
.headers:004003FF _headers        ends
.headers:004003FF
seg001:00400400 ; ===========================================================
seg001:00400400
seg001:00400400 ; Segment type: Pure code
seg001:00400400 seg001          segment byte public 'CODE' use32
seg001:00400400                 assume cs:seg001
seg001:00400400                 ;org 400400h
seg001:00400400                 assume es:_headers, ss:_headers, ds:_headers
seg001:00400400                 db  55h ; U</pre><p>When the <code class="literal">.headers</code> section was created, IDA split the original <code class="literal">seg000</code> to form the <code class="literal">.headers</code> section as we specified and a new <code class="literal">seg001</code> to hold the remaining bytes from <code class="literal">seg000</code>. The content for the <code class="literal">.text</code> section is resident in the database as the first <code class="literal">600h</code> bytes of <code class="literal">seg001</code>. We simply need to move the section to the proper location and size the <code class="literal">.text</code> section correctly.</p><p>The first step in creating the <code class="literal">.text</code> section involves moving <code class="literal">seg001</code> to virtual address <code class="literal">401000h</code>. Using the Edit ▸ Segments ▸ Move Current Segment command, we specify a new start address for <code class="literal">seg001</code>, as shown in <a class="xref" href="ch18s02.html#moving_a_segment" title="Figure 18-4. Moving a segment">Figure 18-4</a>.<a class="indexterm" id="IDX-CHP-18-0034"/></p><div class="figure"><a id="moving_a_segment"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e28528"/><img alt="Moving a segment" src="httpatomoreillycomsourcenostarchimages854304.png.jpg"/></div></div><p class="title">Figure 18-4. Moving a segment</p></div><p>The next step is to carve the <code class="literal">.text</code> section from the first <code class="literal">600h</code> bytes of the newly moved <code class="literal">seg001</code> using Edit ▸ Segments ▸ Create Segment. <a class="xref" href="ch18s02.html#manual_creation_of_the_.text_section" title="Figure 18-5. Manual creation of the .text section">Figure 18-5</a> shows the parameters, derived from the section header values, used to create the new section.</p><p>Keep in mind that the end address is exclusive. Creation of the <code class="literal">.text</code> section splits <code class="literal">seg001</code> into the new <code class="literal">.text</code> section and all remaining bytes of the original file into a new section named <code class="literal">seg002</code>, which immediately follows the <code class="literal">.text</code> section.<a class="indexterm" id="IDX-CHP-18-0035"/><a class="indexterm" id="IDX-CHP-18-0036"/><a class="indexterm" id="IDX-CHP-18-0037"/></p><div class="figure"><a id="manual_creation_of_the_.text_section"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e28579"/><img alt="Manual creation of the .text section" src="httpatomoreillycomsourcenostarchimages854307.png.jpg"/></div></div><p class="title">Figure 18-5. Manual creation of the <code class="literal">.text</code> section</p></div><p>Returning to the section headers, we now look at the second section, which appears as follows once it has been structured as an <code class="literal">IMAGE_SECTION_HEADER</code>:</p><a id="I_programlisting4_d1e28589"/><pre class="programlisting">.headers:004001A0                 db '.rdata',0,0         ; Name
.headers:004001A0                 dd 60h                  ; VirtualSize
.headers:004001A0                 dd 2000h                ; VirtualAddress
.headers:004001A0                 dd 200h                 ; SizeOfRawData
.headers:004001A0                 dd 0A00h                ; PointerToRawData
.headers:004001A0                 dd 0                    ; PointerToRelocations
.headers:004001A0                 dd 0                    ; PointerToLinenumbers
.headers:004001A0                 dw 0                    ; NumberOfRelocations
.headers:004001A0                 dw 0                    ; NumberOfLinenumbers
.headers:004001A0                 dd 40000040h            ; Characteristics</pre><p>Using the same data fields we examined for the <code class="literal">.text</code> section, we note that this section is named <code class="literal">.rdata</code>, occupies <code class="literal">200h</code> bytes in the file beginning at file offset <code class="literal">0A00h</code>, and maps to RVA <code class="literal">2000h</code> (virtual address <code class="literal">402000h</code>). It is important to note at this point that since we moved the <code class="literal">.text</code> segment, we can no longer easily map the <code class="literal">PointerToRawData</code> field to an offset within the database. Instead, we rely on the fact that the content for the <code class="literal">.rdata</code> section immediately follows the content for the <code class="literal">.text</code> section. In other words, the <code class="literal">.rdata</code> section currently resides in the first <code class="literal">200h</code> bytes of <code class="literal">seg002</code>. An alternative approach would be to create the sections in reverse order, beginning with the last section defined in the headers and working our way backwards until we finally create the <code class="literal">.text</code> section. This approach leaves sections positioned at their proper file offsets until they are moved to their corresponding virtual addresses.</p><p>The creation of the <code class="literal">.rdata</code> section proceeds in a manner similar to the creation of the <code class="literal">.text</code> section. In the first step, <code class="literal">seg002</code> is moved to <code class="literal">402000h</code>, and in the second step, the actual <code class="literal">.rdata</code> section is created to span the address range <code class="literal">402000h-402200h</code>.</p><p>The next section defined in this particular binary is called the <code class="literal">.bss</code> section. A <code class="literal">.bss</code> section is typically generated by compilers as a place to group all statically allocated variables (such as globals) that need to be initialized to zero when the program starts. Static variables with nonzero initial values are typically allocated in a <code class="literal">.data</code> (nonconstant) or <code class="literal">.rdata</code> (constant) section. The advantage of a <code class="literal">.bss</code> section is that it typically requires zero space in the disk image, with space being allocated for the section when the memory image of the executable is created by the operating system loader. In this example, the <code class="literal">.bss</code> section is specified as follows:<a class="indexterm" id="IDX-CHP-18-0038"/></p><a id="I_programlisting4_d1e28683"/><pre class="programlisting">.headers:004001C8                 db '.bss',0,0,0      ; Name
.headers:004001C8                 dd 40h             <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>; VirtualSize
.headers:004001C8                 dd 3000h             ; VirtualAddress
.headers:004001C8                 dd 0               <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>; SizeOfRawData
.headers:004001C8                 dd 0                 ; PointerToRawData
.headers:004001C8                 dd 0                 ; PointerToRelocations
.headers:004001C8                 dd 0                 ; PointerToLinenumbers
.headers:004001C8                 dw 0                 ; NumberOfRelocations
.headers:004001C8                 dw 0                 ; NumberOfLinenumbers
.headers:004001C8                 dd 0C0000080h        ; Characteristics</pre><p>Here the section header indicates that the size of the section within the file, <code class="literal">SizeOfRawData</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28702"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, is zero, while the <code class="literal">VirtualSize</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e28711"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> of the section is <code class="literal">0x40</code> (<code class="literal">64</code>) bytes. In order to create this section in IDA, it is first necessary to create a gap (because we have no file content to populate the section) in the address space beginning at address <code class="literal">0x403000</code> and then define the <code class="literal">.bss</code> section to consume this gap. The easiest way to create this gap is to move the remaining sections of the binary into their proper places. When this task is complete, we might end up with a Segments window listing similar to the following:</p><a id="I_programlisting4_d1e28730"/><pre class="programlisting">Name     Start    End      R W X D L Align Base Type   Class
.headers 00400000 00400400 ? ? ? . . byte  0000 public DATA   ...
.text    00401000 00401600 ? ? ? . . byte  0000 public CODE   ...
.rdata   00402000 00402200 ? ? ? . . byte  0000 public DATA   ...
.bss     00403000 00403040 ? ? ? . . byte  0000 public BSS    ...
.idata   00404000 00404200 ? ? ? . . byte  0000 public IMPORT ...
seg005   00404200 004058DE ? ? ? . L byte  0001 public CODE   ...</pre><p>The right-hand portion of the listing has been truncated for the sake of brevity. You may notice that the segment end addresses are not adjacent to their subsequent segment start addresses. This is a result of creating the segments using their file sizes rather than taking into account their virtual sizes and any required section alignment. In order to have our segments reflect the true layout of the executable image, we could edit each end address to consume any gaps between segments.</p><p>The question marks in the segments list represent unknown values for the permission bits on each section. For PE files, these values are specified via bits in the <code class="literal">Characteristics</code> field of each section header. There is no way to specify permissions for manually created sections other than by programmatically using a script or a plug-in. The following IDC statement sets the execute permission on the <code class="literal">.text</code> section in the previous listing:<a class="indexterm" id="IDX-CHP-18-0039"/><a class="indexterm" id="IDX-CHP-18-0040"/></p><a id="I_programlisting4_d1e28748"/><pre class="programlisting">SetSegmentAttr(0x401000, SEGATTR_PERM, 1);</pre><p>Unfortunately, IDC does not define symbolic constants for each of the allowable permissions. Unix users may find it easy to remember that the section permission bits happen to correspond to the permission bits used in Unix file systems; thus read is 4, write is 2, and execute is 1. You may combine the values using a bitwise <code class="literal">OR</code> to set more than one permission in a single operation.</p><p>The last step that we will cover in the manual loading process is to finally get the x86 processor module to do some work for us. Once the binary has been properly mapped into various IDA sections, we can return to the program entry point that we found in the headers (RVA <code class="literal">1000h</code>, or virtual address <code class="literal">401000h</code>) and ask IDA to convert the bytes at that location to code. If we wish to have IDA list the address as an entry point in the Exports window, we must programmatically designate it as such. Here is a Python one-liner to do this:</p><a id="I_programlisting4_d1e28763"/><pre class="programlisting">AddEntryPoint(0x401000, 0x401000, 'start', 1);</pre><p>Called in this manner, IDA will name the entry point <code class="literal">'start'</code>, add it as an exported symbol, and create code at the specified address, initiating a recursive descent to disassemble as much related code as possible. Please refer to IDA’s built-in help for more information on the <code class="literal">AddEntryPoint</code> function.</p><p>When a file is loaded in binary mode, IDA performs no automatic analysis of the file content. Among other things, no attempt is made to identify the compiler used to create the binary, no attempt is made to determine what libraries and functions the binary imports, and no type library or signature information is automatically loaded into the database. In all likelihood, we will need to do a substantial amount of work to produce a disassembly comparable to those we have seen IDA generate automatically. In fact, we have not even touched on other aspects of the PE headers and how we might incorporate such additional information into our manual loading process.</p><p>In rounding out our discussion of manual loading, consider that you would need to repeat each of the steps covered in this section every time you open a binary with the same format, one unknown to IDA. Along the way, you might choose to automate some of your actions by writing IDC scripts that perform some of the header parsing and segment creation for you. This is exactly the motivation behind and the purpose for IDA loader modules, which are covered in the next section.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-18-FN-2" id="ftn.CHP-18-FN-2">129</a>] </sup>See <a class="ulink" href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx">http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx</a> (EULA acceptance required).</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-18-FN-3" id="ftn.CHP-18-FN-3">130</a>] </sup>Refer to <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a> in <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a> for a discussion on adding these structure types in IDA.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-18-FN-4" id="ftn.CHP-18-FN-4">131</a>] </sup>Alignment describes the starting address or offset of a block of data. The address or offset must be an even multiple of the alignment value. For example, when data is aligned to a <code class="literal">200h-</code> (<code class="literal">512-</code>) byte boundary, it must begin at an address (or offset) that is evenly divisible by <code class="literal">200h</code>.</p></div></div></div>
<div class="sect1" title="IDA Loader Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ida_loader_modules"/>IDA Loader Modules</h1></div></div></div><p>IDA relies on loader modules to perform the grunt work of creating the initial layout of new databases. Loaders are utilized when a user chooses to open a new file, and the loader’s job is to read the input file into the newly created database, create sections according to the structure of the input file, and generally organize the layout of the database prior to passing control to the processor module, whose job it is to perform any disassembly-related tasks. Once a database has been created, IDA may invoke special functions in the original loader in order to handle the movement of database segments and in order to produce an EXE file (File ▸ Produce File ▸ Create EXE File).<a class="indexterm" id="IDX-CHP-18-0041"/><a class="indexterm" id="IDX-CHP-18-0042"/><a class="indexterm" id="IDX-CHP-18-0043"/><a class="indexterm" id="IDX-CHP-18-0044"/><a class="indexterm" id="IDX-CHP-18-0045"/><a class="indexterm" id="IDX-CHP-18-0046"/><a class="indexterm" id="IDX-CHP-18-0047"/><a class="indexterm" id="IDX-CHP-18-0048"/><a class="indexterm" id="IDX-CHP-18-0049"/></p><p>The loading process begins when a user chooses to open a new file (loaders are not used to load existing databases). Like plug-ins, loaders may be built as shared library components using the IDA SDK. Loaders were the first of IDA’s extension modules capable of being implemented using scripts (introduced in IDA 5.6).<a class="indexterm" id="IDX-CHP-18-0050"/></p><p>Once a new binary has been selected, IDA loads, in a dynamic library sense, each loader module in the <span class="emphasis"><em>&lt;IDADIR&gt;/loaders</em></span> directory and asks each module to examine the binary. All loaders that recognize the format of the new file are listed in the file-loading dialog, and it is up to the user to decide which loader should be used to load the file.<a class="indexterm" id="IDX-CHP-18-0051"/></p></div>
<div class="sect1" title="Writing an IDA Loader Using the SDK"><div class="titlepage"><div><div><h1 class="title"><a id="writing_an_ida_loader_using_the_sdk"/>Writing an IDA Loader Using the SDK</h1></div></div></div><p>IDA’s principle interface to any loader module takes place via a global <code class="literal">loader_t</code> object that each loader must declare and export. The <code class="literal">loader_t</code> struct is analogous to the <code class="literal">plugin_t</code> class used in plug-in modules. The following listing shows the layout of the <code class="literal">loader_t</code> struct as defined in <span class="emphasis"><em>loader.hpp</em></span>.</p><a id="I_programlisting4_d1e28859"/><pre class="programlisting">struct loader_t {
  ulong version;        // api version, should be IDP_INTERFACE_VERSION
  ulong flags;          // loader flags

//check input file format. if recognized,
  int (idaapi *accept_file)(linput_t *li,
                            char fileformatname[MAX_FILE_FORMAT_NAME],
                            int n);
//load file into the database.
  void (idaapi *load_file)(linput_t *li, ushort neflags,
                           const char *fileformatname);

//create output file from the database, this function may be absent.
  int (idaapi *save_file)(FILE *fp, const char *fileformatname);

//take care of a moved segment (fix up relocations, for example)
//this function may be absent.
  int (idaapi *move_segm)(ea_t from, ea_t to, asize_t size,
                          const char *fileformatname);

//initialize user configurable options based on the input file.
//Called only when loading is done via File-&gt;New, not File-&gt;Open
//this function may be absent.
  bool (idaapi *init_loader_options)(linput_t *li);
};</pre><p>As with the <code class="literal">plugin_t</code> class, the behavior of a <code class="literal">loader_t</code> object is defined by the functions (created by the loader’s author) to which its members point. Every loader must export a <code class="literal">loader_t</code> object named <code class="literal">LDSC</code> (<span class="emphasis"><em>loader description</em></span>). Exporting your <code class="literal">LDSC</code> object is handled by <span class="emphasis"><em>loader.hpp</em></span>, which leaves you responsible only for declaring and initializing the actual object. Note that several of the functions accept an input parameter of type <code class="literal">linput_t</code> (<span class="emphasis"><em>loader input type</em></span>). An <code class="literal">linput_t</code> is an internal SDK class that provides a compiler-independent wrapper around the C standard <code class="literal">FILE</code> type. Functions implementing standard input operations for <code class="literal">linput_t</code> are declared in <span class="emphasis"><em>diskio.hpp</em></span>.<a class="indexterm" id="IDX-CHP-18-0052"/><a class="indexterm" id="IDX-CHP-18-0053"/><a class="indexterm" id="IDX-CHP-18-0054"/><a class="indexterm" id="IDX-CHP-18-0055"/><a class="indexterm" id="IDX-CHP-18-0056"/><a class="indexterm" id="IDX-CHP-18-0057"/><a class="indexterm" id="IDX-CHP-18-0058"/><a class="indexterm" id="IDX-CHP-18-0059"/><a class="indexterm" id="IDX-CHP-18-0060"/><a class="indexterm" id="IDX-CHP-18-0061"/><a class="indexterm" id="IDX-CHP-18-0062"/><a class="indexterm" id="IDX-CHP-18-0063"/><a class="indexterm" id="IDX-CHP-18-0064"/><a class="indexterm" id="IDX-CHP-18-0065"/><a class="indexterm" id="IDX-CHP-18-0066"/><a class="indexterm" id="IDX-CHP-18-0067"/><a class="indexterm" id="IDX-CHP-18-0068"/></p><p>Since successful loader creation relies on properly initializing the <code class="literal">LDSC</code> object, the purpose of each member is described here:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>version</code></strong></span></dt><dd><p>This member serves the same purpose as the <code class="literal">version</code> member of the <code class="literal">plugin_t</code> class. Please refer to its description in <a class="xref" href="ch17.html" title="Chapter 17. The IDA Plug-in Architecture">Chapter 17</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>flags</code></strong></span></dt><dd><p>The only flag recognized for loaders is <code class="literal">LDRF_RELOAD</code>, defined in <span class="emphasis"><em>loader.hpp</em></span>. For many loaders assigning zero to this field will be sufficient.</p></dd><dt><span class="term"><strong class="userinput"><code>accept_file</code></strong></span></dt><dd><p>The purpose of this function is to provide basic recognition of a newly selected input file. This function should utilize the provided <code class="literal">linput_t</code> object to read enough information from a file to determine whether the loader can parse the given file. If the file is recognized, the loader should copy the file format name into the <code class="literal">fileformatname</code> output buffer. The function should return 0 if the file format is not recognized or nonzero if the format is recognized. <code class="literal">OR</code>ing the return value with the <code class="literal">ACCEPT_FIRST</code> flag requests that IDA list this loader first in the load-file dialog. When several loaders indicate <code class="literal">ACCEPT_FIRST</code>, the last loader queried will be listed first.</p></dd><dt><span class="term"><strong class="userinput"><code>load_file</code></strong></span></dt><dd><p>This member is another function pointer. IDA calls the associated function if the user chooses your loader to load the newly selected file. The function receives an <code class="literal">linput_t</code> object that should be used to read the selected file. The <code class="literal">neflags</code> parameter contains a bitwise <code class="literal">OR</code> of various <code class="literal">NEF_</code><em class="replaceable"><code>XXX</code></em> flags defined in <span class="emphasis"><em>loader.hpp</em></span>. Several of these flags reflect the state of various checkbox settings from the load-file dialog. The <code class="literal">load_file</code> function is responsible for any required parsing of the input file content and loading and mapping some or all of the file content into the newly created database. If an unrecoverable error condition is recognized, <code class="literal">load_file</code> should call <code class="literal">loader_failure</code> to terminate the loading process.</p></dd><dt><span class="term"><strong class="userinput"><code>save_file</code></strong></span></dt><dd><p>This member optionally points to a function capable of producing an executable file in response to the File ▸ Produce File ▸ Create EXE File command. Strictly speaking, the use of EXE here is a bit of a misnomer, because your <code class="literal">save_file</code> implementation could choose to generate any type of file that you wish. Since the loader is responsible for mapping a file into a database, it may also have the capability to map the database back into a file. In practice, the loader may not have loaded enough information from the original input file to be able to generate a valid output file based on database content alone. For example, the PE file loader supplied with IDA cannot regenerate an EXE file from a database file. If your loader is not capable of generating an output file, then you should set the <code class="literal">save_file</code> member to NULL.<a class="indexterm" id="IDX-CHP-18-0069"/><a class="indexterm" id="IDX-CHP-18-0070"/><a class="indexterm" id="IDX-CHP-18-0071"/><a class="indexterm" id="IDX-CHP-18-0072"/></p></dd><dt><span class="term"><strong class="userinput"><code>move_segm</code></strong></span></dt><dd><p>This member is a pointer to a function that is called when a user attempts to move a segment within a database that was loaded with this loader. Since the loader may be aware of relocation information contained in the original binary, this function may be able to take relocation information into account as the segment is moved. This function is optional, and the pointer should be set to NULL if the function is not required (for example, when there are no relocated or fixed-up addresses in this file format).</p></dd><dt><span class="term"><strong class="userinput"><code>init_loader_options</code></strong></span></dt><dd><p>This member is a pointer to a function whose purpose is to set user-specified options via the wizard base-loading process available via File ▸ New. This function is useful only in the Windows native GUI version of IDA (idag) because this is the only version of IDA that offers these wizards. This function is called once a user has chosen a loader, prior to calling <code class="literal">load_file</code>. If the loader requires no configuration prior to the call to <code class="literal">load_file</code>, this member pointer may be set safely to NULL.</p></dd></dl></div><p>The <code class="literal">init_loader_options</code> function deserves additional explanation. It is important to understand that if File ▸ Open is used to open a file, this function will never be called. In more sophisticated loaders, such as IDA’s PE loader, this function is used to initialize XML-based wizards that step the user through the loading process. The XML templates for several wizards are stored in <span class="emphasis"><em>&lt;IDADIR&gt;/cfg</em></span>; however, other than the existing templates, no documentation exists for creating your own wizard templates.<a class="indexterm" id="IDX-CHP-18-0073"/></p><p>In the remainder of this chapter, we will develop two example loaders in order to review some commonly used loader operations.</p><div class="sect2" title="The Simpleton Loader"><div class="titlepage"><div><div><h2 class="title"><a id="the_simpleton_loader"/>The Simpleton Loader</h2></div></div></div><p>In order to demonstrate the basic operation of an IDA loader, we introduce the completely fictitious <span class="emphasis"><em>simpleton</em></span> file format as defined by the following C struct (all values are little-endian):<a class="indexterm" id="IDX-CHP-18-0074"/><a class="indexterm" id="IDX-CHP-18-0075"/><a class="indexterm" id="IDX-CHP-18-0076"/></p><a id="I_programlisting4_d1e29127"/><pre class="programlisting">struct simpleton {
   uint32_t magic; //simpleton magic number: 0x1DAB00C
   uint32_t size;  //size of the code array
   uint32_t base;  //base virtual address and entry point
   uint8_t code[size]; //the actual program code
};</pre><p>The file format is very straightforward: a magic number file identifier and two integers describing the structure of the file, followed by all of the code contained in the file. Execution of the file begins with the first byte in the <code class="literal">code</code> block.</p><p>A hexdump of a small simpleton file might look like this:</p><a id="I_programlisting4_d1e29136"/><pre class="programlisting">0000000: 0cb0 da01 4900 0000 0040 0000 31c0 5050  ....I....@..1.PP
0000010: 89e7 6a10 5457 50b0 f350 cd91 5859 4151  ..j.TWP..P..XYAQ
0000020: 50cd 9166 817f 0213 8875 f16a 3e6a 025b  P..f.....u.j&gt;j.[
0000030: 5853 6a09 516a 3ecd 914b 79f4 5068 6e2f  XSj.Qj&gt;..Ky.Ph//
0000040: 7368 682f 2f62 6989 e350 5389 e150 5153  shh/bin..PS..PQS
0000050: b03b 50cd 91                             .;P..</pre><p>Several sample loaders are included with the SDK and may be found in the <span class="emphasis"><em>&lt;SDKDIR&gt;/ldr</em></span> directory. We elect to build our loaders in individual subdirectories alongside the example loaders. In this case we are working in <span class="emphasis"><em>&lt;SDKDIR&gt;/ldr/simpleton</em></span>. Our loader begins with the following setup:</p><a id="I_programlisting4_d1e29146"/><pre class="programlisting">#include "../idaldr.h"
#define SIMPLETON_MAGIC 0x1DAB00C

struct simpleton {
   uint32_t magic; //simpleton magic number: 0x1DAB00C
   uint32_t size;  //size of the code array
   uint32_t base;  //base virtual address and entry point
};</pre><p>The <span class="emphasis"><em>idaldr.h</em></span> header file is a convenience file, included with the SDK (<span class="emphasis"><em>&lt;SDKDIR&gt;/ldr/idaldr.h</em></span>), which includes several other header files and defines several macros, all of which are commonly used in loader modules.</p><p>The next order of business is to declare the required <code class="literal">LDSC</code> object, which points to the various functions that implement our loader’s behavior:<a class="indexterm" id="IDX-CHP-18-0077"/><a class="indexterm" id="IDX-CHP-18-0078"/><a class="indexterm" id="IDX-CHP-18-0079"/><a class="indexterm" id="IDX-CHP-18-0080"/><a class="indexterm" id="IDX-CHP-18-0081"/><a class="indexterm" id="IDX-CHP-18-0082"/></p><a id="I_programlisting4_d1e29179"/><pre class="programlisting">int idaapi accept_simpleton_file(linput_t *, char[MAX_FILE_FORMAT_NAME], int);
void idaapi load_simpleton_file(linput_t *, ushort, const char *);
int idaapi save_simpleton_file(FILE *, const char *);

loader_t LDSC = {
  IDP_INTERFACE_VERSION,
  0,                      // loader flags
  accept_simpleton_file,  // test simpleton format.
  load_simpleton_file,    // load file into the database.
  save_simpleton_file,    // simpleton is an easy format to save
  NULL,                   // no special handling for moved segments
  NULL,                   // no special handling for File-&gt;New
};</pre><p>The functions used in this loader are described in the order in which they might be invoked, beginning with the <code class="literal">accept_simpleton_loader</code> function shown here:</p><a id="I_programlisting4_d1e29187"/><pre class="programlisting">int idaapi accept_simpleton_file(linput_t *li,
                              char fileformatname[MAX_FILE_FORMAT_NAME], int n) {
   uint32 magic;
   if (n || lread4bytes(li, &amp;magic, false)) return 0;
   if (magic != SIMPLETON_MAGIC) return 0;   //bad magic number found
   qsnprintf(fileformatname, MAX_FILE_FORMAT_NAME, "Simpleton Executable");
   return 1;  //simpleton format recognized
}</pre><p>The entire purpose of this function is to determine whether the file being opened appears to be a simpleton file. The <code class="literal">n</code> parameter is a counter that indicates the number of times that our <code class="literal">accept_file</code> function has been called during the current loading process. The intent of this parameter is to allow a loader to recognize multiple related file formats. IDA will invoke your <code class="literal">accept_file</code> function with increasing values of <code class="literal">n</code> until your function returns 0. For each unique format that your loader recognizes, you should fill in the <code class="literal">fileformatname</code> array and return nonzero. In this case, we elect to ignore anything other than the first call (when <code class="literal">n</code> is zero) by immediately returning 0. The <code class="literal">lread4bytes</code> function, defined in <span class="emphasis"><em>diskio.hpp</em></span>, is used to read the 4-byte magic number, and it returns 0 if the read completed successfully. A useful feature of <code class="literal">lread4bytes</code> is its ability to read bytes in either big-endian or little-endian format, depending on the value of its Boolean third parameter (<code class="literal">false</code> reads little-endian; <code class="literal">true</code> reads big-endian). This feature can help reduce the number of calls to byte-swapping functions required during the loading process. If the required magic number is located, the final step in <code class="literal">accept_simpleton_file</code> is to copy the name of the file format into the <code class="literal">fileformatname</code> output parameter prior to returning 1 to indicate that the file format was recognized.</p><p>For the simpleton loader, no special processing is required if a user chooses to load a simpleton file using File ▸ New rather than File ▸ Open, so no <code class="literal">init_loader_options</code> function is required. Therefore, the next function called in the loading sequence will be <code class="literal">load_simpleton_file</code>, which is shown here:<a class="indexterm" id="IDX-CHP-18-0083"/><a class="indexterm" id="IDX-CHP-18-0084"/><a class="indexterm" id="IDX-CHP-18-0085"/><a class="indexterm" id="IDX-CHP-18-0086"/><a class="indexterm" id="IDX-CHP-18-0087"/><a class="indexterm" id="IDX-CHP-18-0088"/></p><a id="I_programlisting4_d1e29258"/><pre class="programlisting">void idaapi load_simpleton_file(linput_t *li, ushort neflags, const char *) {
   simpleton hdr;
   //read the program header from the input file
   lread(li, &amp;hdr, sizeof(simpleton));
   //load file content into the database
   file2base(li, sizeof(simpleton), hdr.base, hdr.base + hdr.size,
             FILEREG_PATCHABLE);
   //create a segment around the file's code section
   if (!add_segm(0, hdr.base, hdr.base + hdr.size, NAME_CODE, CLASS_CODE)) {
      loader_failure();
   }
   //retrieve a handle to the new segment
   segment_t *s = getseg(hdr.base);
   //so that we can set 32 bit addressing mode on (x86 has 16 or 32 bit modes)
   set_segm_addressing(s, 1);  //set 32 bit addressing
   //tell IDA to create the file header comment for us.  Do this
   //only once. This comment contains license, MD5,
   // and original input file name information.
   create_filename_cmt();
   //Add an entry point so that the processor module knows at least one
   //address that contains code.  This is the root of the recursive descent
   //disassembly process
   add_entry(hdr.base, hdr.base, "_start", true);
}</pre><p>The bulk of the loading process takes place in a loader’s <code class="literal">load_file</code> function. Our simple loader performs the following tasks:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Read the simpleton header from the file using <code class="literal">lread</code> from <span class="emphasis"><em>diskio.hpp</em></span>. The <code class="literal">lread</code> function is very similar to the POSIX <code class="literal">read</code> function.</p></li><li class="listitem"><p>Load the code section from the file into the proper address space within the database using <code class="literal">file2base</code> from <span class="emphasis"><em>loader.hpp</em></span>.</p></li><li class="listitem"><p>Create a new database segment containing the newly loaded bytes using <code class="literal">add_segm</code> from <span class="emphasis"><em>segment.hpp</em></span>.</p></li><li class="listitem"><p>Specify 32-bit addressing on our new code segment by calling <code class="literal">getseg</code> and <code class="literal">set_segm_addressing</code> from <span class="emphasis"><em>segment.hpp</em></span>.</p></li><li class="listitem"><p>Generate a database header comment using <code class="literal">create_filename_cmt</code> from <span class="emphasis"><em>loader.hpp</em></span>.</p></li><li class="listitem"><p>Add a program entry point using <code class="literal">add_entry</code>, from <span class="emphasis"><em>entry.hpp</em></span>, to provide the processor module with a starting point for the disassembly process.</p></li></ol></div><p>The <code class="literal">file2base</code> function is a workhorse function for loaders. Its prototype appears here:<a class="indexterm" id="IDX-CHP-18-0089"/><a class="indexterm" id="IDX-CHP-18-0090"/><a class="indexterm" id="IDX-CHP-18-0091"/><a class="indexterm" id="IDX-CHP-18-0092"/><a class="indexterm" id="IDX-CHP-18-0093"/><a class="indexterm" id="IDX-CHP-18-0094"/></p><a id="I_programlisting4_d1e29352"/><pre class="programlisting">int ida_export file2base(linput_t *li, long pos, ea_t ea1, ea_t ea2, int patchable);</pre><p>This function reads bytes from the provided <code class="literal">linput_t</code> beginning at the file position specified by <code class="literal">pos</code>. The bytes are loaded into the database beginning at address <code class="literal">ea1</code>, up to but not including <code class="literal">ea2</code>. The total number of bytes read is calculated as <code class="literal">ea2-ea1</code>. The <code class="literal">patchable</code> parameter indicates whether IDA should maintain an internal mapping of file offsets to their corresponding locations in the database. To maintain such a mapping, this parameter should be set to <code class="literal">FILEREG_PATCHABLE</code>, which allows for the generation of IDA DIF files, as discussed in <a class="xref" href="ch14.html" title="Chapter 14. Patching Binaries and Other IDA Limitations">Chapter 14</a>.<a class="indexterm" id="IDX-CHP-18-0095"/></p><p>The <code class="literal">add_entry</code> function is another important function in the loading process. The disassembly process can begin only with addresses known to contain instructions. For a recursive descent disassembler, such addresses are generally obtained by parsing a file for entry points (such as exported functions). The prototype for <code class="literal">add_entry</code> appears here:</p><a id="I_programlisting4_d1e29392"/><pre class="programlisting">bool ida_export add_entry(uval_t ord, ea_t ea, const char *name, bool makecode);</pre><p>The <code class="literal">ord</code> parameter is useful for exported functions that may be exported by ordinal number in addition to function name. If the entry point has no associated ordinal number, <code class="literal">ord</code> should be set to the same value as the <code class="literal">ea</code> parameter. The <code class="literal">ea</code> parameter specifies the effective address of the entry point, while the <code class="literal">name</code> parameter specifies the name associated with the entry point. The symbolic name <code class="literal">_start</code> is often applied to a program’s initial execution address. The boolean <code class="literal">makecode</code> parameter specifies whether the specified address is to be treated as code (true) or not (false). Exported data items, such as <code class="literal">LDSC</code> within a loader module, are examples of noncode entry points.</p><p>The final function that we have implemented in the simpleton loader, <code class="literal">save_simpleton_file</code>, is used to create a simpleton file from the database contents. Our implementation is shown here:</p><a id="I_programlisting4_d1e29426"/><pre class="programlisting">int idaapi save_simpleton_file(FILE *fp, const char *fileformatname) {
   uint32 magic = SIMPLETON_MAGIC;
   if (fp == NULL) return 1;   //special case, success means we can save files
   segment_t *s = getnseg(0);  //get segment zero, the one and only segment
   if (s) {
      uint32 sz = s-&gt;endEA - s-&gt;startEA;    //compute the segment size
      qfwrite(fp, &amp;magic, sizeof(uint32));  //write the magic value
      qfwrite(fp, &amp;sz, sizeof(uint32));     //write the segment size
      qfwrite(fp, &amp;s-&gt;startEA, sizeof(uint32));  //write the base address
      base2file(fp, sizeof(simpleton), s-&gt;startEA, s-&gt;endEA); //dump the segment
      return 1;  //return success
   }
else {
      return 0;  //return failure
   }
}</pre><p>A <code class="literal">loader_t</code>’s <code class="literal">save_file</code> function receives a <code class="literal">FILE</code> stream pointer, <code class="literal">fp</code>, to which the function should write its output. The <code class="literal">fileformatname</code> parameter is the same name filled in by the loader’s <code class="literal">accept_file</code> function. As mentioned earlier, the <code class="literal">save_file</code> function is called in response to IDA’s File ▸ Produce File ▸ Create EXE File command. In response to this command, IDA initially calls <code class="literal">save_file</code> with <code class="literal">fp</code> set to NULL. When called in this manner, <code class="literal">save_file</code> is being queried as to whether it can produce an output file of the type specified by <code class="literal">fileformatname</code>, in which case <code class="literal">save_file</code> should return 0 if it cannot create the specified file type or 1 if it can create the specified file. For example, the loader may be able to create a valid output file only if specific information is present within the database.<a class="indexterm" id="IDX-CHP-18-0096"/><a class="indexterm" id="IDX-CHP-18-0097"/><a class="indexterm" id="IDX-CHP-18-0098"/><a class="indexterm" id="IDX-CHP-18-0099"/><a class="indexterm" id="IDX-CHP-18-0100"/><a class="indexterm" id="IDX-CHP-18-0101"/></p><p>When called with a valid (non-NULL) <code class="literal">FILE</code> pointer, <code class="literal">save_file</code> should write a valid output file representation to the provided <code class="literal">FILE</code> stream. In such cases, IDA creates the <code class="literal">FILE</code> stream after presenting the user with a File Save dialog.<a class="indexterm" id="IDX-CHP-18-0102"/></p><div class="sidebar"><a id="ida_and_file_pointers"/><p class="title">IDA AND FILE POINTERS</p><p>If you develop modules for Windows versions of IDA, a very important aspect of the behavior of an IDA <code class="literal">FILE</code> stream is noted in <span class="emphasis"><em>fpro.h</em></span> and results from the fact that IDA’s core DLL, <span class="emphasis"><em>ida_wll.dll</em></span>, is built using Borland tools. In short, Borland <code class="literal">FILE</code> pointers may not be shared between program modules, and any attempt to do so is likely to result in an access violation, potentially crashing IDA. To work around this problem, IDA offers a complete set of wrapper functions in the form of <code class="literal">qfxxx</code> (such as qfprintf declared in <span class="emphasis"><em>fpro.h</em></span>) alternatives to the standard C-style <code class="literal">FILE</code> manipulation routines (such as <code class="literal">fprintf</code>). A word of caution when using these functions, however, is that the <code class="literal">qfxxx</code> functions do not always utilize the same parameters as their C-style counterparts (<code class="literal">qfwrite</code> and <code class="literal">fwrite</code>, for example). If you wish to use the C-style <code class="literal">FILE</code> manipulation functions, you must remember the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You must define the <code class="literal">USE_STANDARD_FILE_FUNCTIONS</code> macro prior to including <span class="emphasis"><em>fpro.h</em></span> in your module.</p></li><li class="listitem"><p>You must not mix IDA-provided <code class="literal">FILE</code> pointers with the C library <code class="literal">FILE</code> functions.</p></li><li class="listitem"><p>You must not mix <code class="literal">FILE</code> pointers obtained from the C library functions with IDA’s <code class="literal">qfxxx</code> functions.</p></li></ul></div></div><p>Returning to the <code class="literal">save_simpleton_file</code> function, the only truly interesting function used in implementing our <code class="literal">save_file</code> capability is the <code class="literal">base2file</code> function, which is the output counterpart to the <code class="literal">file2base</code> function used in <code class="literal">load_simpleton_file</code>. The <code class="literal">base2file</code> function simply writes a range of database values to a specified position within a supplied <code class="literal">FILE</code> stream.</p><p>While the simpleton file format borders on useless, it does serve one purpose, namely that it has allowed us to demonstrate the core functionality of IDA loader modules. The source code for the simpleton loader may be found on the book’s website.<a class="indexterm" id="IDX-CHP-18-0103"/><a class="indexterm" id="IDX-CHP-18-0104"/><a class="indexterm" id="IDX-CHP-18-0105"/><a class="indexterm" id="IDX-CHP-18-0106"/><a class="indexterm" id="IDX-CHP-18-0107"/><a class="indexterm" id="IDX-CHP-18-0108"/><a class="indexterm" id="IDX-CHP-18-0109"/></p></div><div class="sect2" title="Building an IDA Loader Module"><div class="titlepage"><div><div><h2 class="title"><a id="building_an_ida_loader_module"/>Building an IDA Loader Module</h2></div></div></div><p>The process for building and installing an IDA loader module is virtually identical to the process for building an IDA plug-in module as discussed in <a class="xref" href="ch17.html" title="Chapter 17. The IDA Plug-in Architecture">Chapter 17</a>, with only a few minor differences. First, the file extensions used for loaders are <span class="emphasis"><em>.ldw/.l64</em></span> on Windows, <span class="emphasis"><em>.llx/.llx64</em></span> on Linux platforms, and <span class="emphasis"><em>.lmc/.lmc64</em></span> on OS X. Second, this is a matter of personal preference, but when we build loaders, we store the newly created loader binaries into <span class="emphasis"><em>&lt;SDKDIR&gt;/bin/loaders</em></span>. Third, loader modules are installed by copying the compiled loader binary to <span class="emphasis"><em>&lt;IDADIR&gt;/loaders</em></span>. The plug-in makefile presented in <a class="xref" href="ch17s02.html#a_sample_makefile_for_ida_plug-ins" title="Example 17-1. A sample makefile for IDA plug-ins">Example 17-1</a> is easily adapted to build the simpleton loader by changing the <code class="literal">PLUGIN_EXT</code> variable to a <code class="literal">LOADER_EXT</code> variable that reflects the proper loader file extensions for each IDA platform, changing all references to <code class="literal">idabook_plugin</code> to <code class="literal">simpleton</code>, and changing the <code class="literal">OUTDIR</code> variable to point to <code class="literal">$(IDA)/bin/loaders</code>.</p></div><div class="sect2" title="A pcap Loader for IDA"><div class="titlepage"><div><div><h2 class="title"><a id="a_pcap_loader_for_ida"/>A pcap Loader for IDA</h2></div></div></div><p>Granted, the majority of network packets do not contain code that can be disassembled. However, if the packets happen to contain evidence of an exploit, the packets may contain binary code that might require disassembly for proper analysis. In order to demonstrate that IDA loaders can be used for many purposes, we now describe the construction of a loader capable of loading a pcap<sup>[<a class="footnote" href="#ftn.CHP-18-FN-5" id="CHP-18-FN-5">132</a>]</sup> format packet-capture file into an IDA database. While this may be somewhat over the top, along the way we will demonstrate several more capabilities of IDA’s SDK. No attempt is made here to match the capabilities of tools such as Wireshark<sup>[<a class="footnote" href="#ftn.CHP-18-FN-6" id="CHP-18-FN-6">133</a>]</sup> in any way.<a class="indexterm" id="IDX-CHP-18-0110"/></p><p>The development process for such a loader requires some research into the pcap file format, which reveals that a pcap file is structured with the following rough syntax:<a class="indexterm" id="IDX-CHP-18-0111"/></p><a id="I_programlisting4_d1e29696"/><pre class="programlisting">pcap_file: pcap_file_header (pcap_packet)*
pcap_packet: pcap_packet_header pcap_content
pcap_content: (byte)+</pre><p>A <code class="literal">pcap_file_header</code> contains a 32-bit magic number field, as well as other fields describing the content of the file, including the type of packets contained in the file. For the sake of simplification, we assume here that we are dealing only with <code class="literal">DLT_EN10MB</code> (10Mb Ethernet packets). In developing the pcap loader, one of our goals is to identify as much header data as possible in order to help users focus on packet content, particularly at the application layer. Our approach for accomplishing this goal is (1) to separate the file header from the packet data by creating a separate segment for each and (2) to identify as many header structures as possible with the packets segment so that the user does not need to manually parse the file content. The discussion that follows focuses only on the <code class="literal">load_file</code> component of the pcap loader, because the <code class="literal">accept_file</code> function is a simple adaptation of the <code class="literal">accept_simpleton_file</code> function changed to recognize the pcap magic number.<a class="indexterm" id="IDX-CHP-18-0112"/><a class="indexterm" id="IDX-CHP-18-0113"/><a class="indexterm" id="IDX-CHP-18-0114"/><a class="indexterm" id="IDX-CHP-18-0115"/><a class="indexterm" id="IDX-CHP-18-0116"/><a class="indexterm" id="IDX-CHP-18-0117"/></p><p>In order to highlight header structures, we will need to have some commonly used structures defined in the IDA Structures window during the loading phase. This allows the loader to automatically format groups of bytes as structures when the datatype for those bytes is known. Pcap header structures and various networking-related structures describing Ethernet, IP, TCP, and UDP headers are defined in IDA’s GNU C++ Unix type library; however, in versions of IDA prior to 5.3, the definition for the IP header struct (<code class="literal">iphdr</code>) is incorrect. The first step that <code class="literal">load_pcap_file</code> takes is to call a helper function we have written named <code class="literal">add_types</code> to take care of importing structures into the new database. We examine two possible versions of <code class="literal">add_types</code>, one that makes use of the types declared in IDA’s GNU C++ Unix type library and another version in which <code class="literal">add_types</code> takes care of all required structure declarations by itself.</p><p>The first version loads the GNU C++ Unix type library and then pulls type identifiers from the newly loaded type library. This version of <code class="literal">add_types</code> is shown here:</p><a id="I_programlisting4_d1e29756"/><pre class="programlisting">void add_types() {
#ifdef ADDTIL_DEFAULT
   add_til2("gnuunx.til", ADDTIL_SILENT);
#else
   add_til("gnuunx.til");
#endif
   pcap_hdr_struct = til2idb(-1, "pcap_file_header");
   pkthdr_struct = til2idb(-1, "pcap_pkthdr");
   ether_struct = til2idb(-1, "ether_header");
   ip_struct = til2idb(-1, "iphdr");
   tcp_struct = til2idb(-1, "tcphdr");
   udp_struct = til2idb(-1, "udphdr");
}</pre><p>The <code class="literal">add_til</code> functions defined in <span class="emphasis"><em>typinf.hpp</em></span> are used to load an existing type library file into a database. The <code class="literal">add_til</code> function was deprecated in favor of <code class="literal">add_til2</code> with the introduction of IDA version 5.1. These functions are the SDK equivalent of loading a <span class="emphasis"><em>.til</em></span> file using the Types window discussed in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>. Once a type library has been loaded, the <code class="literal">til2idb</code> function may be utilized to import individual types into the current database. This is the programmatic equivalent of adding a standard structure to the Structures window, which was also described in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>. The <code class="literal">til2idb</code> function returns a type identifier that is required whenever we want to convert a range of bytes into a specific structured datatype. We have chosen to save these type identifiers into global variables (each of type <code class="literal">tid_t</code>) in order to provide faster access to types later in the loading process.<a class="indexterm" id="IDX-CHP-18-0118"/><a class="indexterm" id="IDX-CHP-18-0119"/><a class="indexterm" id="IDX-CHP-18-0120"/></p><p>Two drawbacks to this first version of <code class="literal">add_types</code> are the fact that we need to import an entire type library just to gain access to six datatypes and, as mentioned previously, the built-in IDA definition of a structure may be incorrect, which would lead to problems when we attempt to apply these structures later in the loading process.</p><p>The second version of <code class="literal">add_types</code> demonstrates the process of building a type library on the fly by parsing actual C-style structure declarations. This version is shown here:</p><a id="I_programlisting4_d1e29810"/><pre class="programlisting">void add_types() {
   til_t *t = new_til("pcap.til", "pcap header types"); //empty type library
   parse_decls(t, pcap_types, NULL, HTI_PAK1); //parse C declarations into library
   sort_til(t);                                //required after til is modified
   pcap_hdr_struct = import_type(t, −1, "pcap_file_header");
   pkthdr_struct = import_type(t, −1, "pcap_pkthdr");
   ether_struct = import_type(t, −1, "ether_header");
   ip_struct = import_type(t, −1, "iphdr");
   tcp_struct = import_type(t, −1, "tcphdr");
   udp_struct = import_type(t, −1, "udphdr");
   free_til(t);                                  //free the temporary library
}</pre><p>In this case, a temporary, empty type library is created using the <code class="literal">new_til</code> function. The new type library is populated by parsing a string (<code class="literal">pcap_types</code>) that contains valid C structure definitions for the types required by the loader. The first few lines of the <code class="literal">pcap_types</code> string are shown here:</p><a id="I_programlisting4_d1e29823"/><pre class="programlisting">char *pcap_types =
   "struct pcap_file_header {\n"
        "int magic;\n"
        "short version_major;\n"
        "short version_minor;\n"
        "int thiszone;\n"
        "int sigfigs;\n"
        "int snaplen;\n"
        "int linktype;\n"
   "};\n"
   ...</pre><p>The declaration of <code class="literal">pcap_types</code> continues and includes structure definitions for all of the structures required by the pcap loader. In order to simplify the parsing process, we elected to change all data declarations used within the structure definitions to make use of standard C datatypes.</p><p>The <code class="literal">HTI_PAK1</code> constant is defined in <span class="emphasis"><em>typeinf.hpp</em></span> and is one of many <code class="literal">HTI_</code><em class="replaceable"><code>XXX</code></em> values that may be used to control the behavior of the internal C parser. In this case, structure packing on a 1-byte boundary is being requested. Following modification, a type library is expected to be sorted using <code class="literal">sort_til</code>, at which point it is ready to use. The <code class="literal">import_type</code> function pulls the requested structure type from the specified type library into the database in a manner similar to <code class="literal">til2idb</code>. In this version, again we save the returned type identifier into global variables for use later in the loading process. The function completes by deleting the temporary type library using the <code class="literal">free_til</code> function to release the memory consumed by the type library. In this version of <code class="literal">add_types</code>, unlike the first version, we have complete control over the datatypes that we choose to import into the database, and we have no need to import entire libraries of structures that we have no intention of using.<a class="indexterm" id="IDX-CHP-18-0121"/><a class="indexterm" id="IDX-CHP-18-0122"/><a class="indexterm" id="IDX-CHP-18-0123"/><a class="indexterm" id="IDX-CHP-18-0124"/><a class="indexterm" id="IDX-CHP-18-0125"/><a class="indexterm" id="IDX-CHP-18-0126"/><a class="indexterm" id="IDX-CHP-18-0127"/></p><p>As an aside, it is also possible to save the temporary type library file to disk using the <code class="literal">store_til</code> function (which should be preceded by a call to <code class="literal">compact_til</code>). With so few types to construct, this has little benefit in this case, because it is just as easy to build the structures each time the loader is executed as it is to build and distribute a special-purpose type library that must be properly installed and in the end does not save a significant amount of time.</p><p>Turning our attention to the <code class="literal">load_pcap_file</code> function, we see the call to <code class="literal">add_types</code> to initialize the datatypes, as discussed previously; the creation of a file comment; followed by loading the pcap file header into the database, creating a section around the header bytes, and transforming the header bytes into a <code class="literal">pcap_file_header</code> structure:</p><a id="I_programlisting4_d1e29900"/><pre class="programlisting">void idaapi load_pcap_file(linput_t *li, ushort, const char *) {
   ssize_t len;
   pcap_pkthdr pkt;

   add_types();              //add structure templates to database
   create_filename_cmt();    //create the main file header comment
   //load the pcap file header from the database into the file
   file2base(li, 0, 0, sizeof(pcap_file_header), FILEREG_PATCHABLE);
   //try to add a new data segment to contain the file header bytes
   if (!add_segm(0, 0, sizeof(pcap_file_header), ".file_header", CLASS_DATA)) {
      loader_failure();
   }
   //convert the file header bytes into a pcap_file_header
   doStruct(0, sizeof(pcap_file_header), pcap_hdr_struct);
   //... continues</pre><p>Once again, we see the use of <code class="literal">file2base</code> to load content from the newly opened disk file into the database. Once the pcap file header content has been loaded, it gets its own section in the database, and the <code class="literal">pcap_file_header</code> structure is applied to all of the header bytes using the <code class="literal">doStruct</code> function, declared in <span class="emphasis"><em>bytes.hpp</em></span>, which is the SDK equivalent of using Edit ▸ Struct Var to convert a contiguous block of bytes into a structure. The <code class="literal">doStruct</code> function expects an address, a size, and a type identifier, and it converts size bytes at the given address into the given type.</p><p>The <code class="literal">load_pcap_file</code> function continues by reading all of the packet content and creating a single <code class="literal">.packets</code> section around the packet content, as shown here:<a class="indexterm" id="IDX-CHP-18-0128"/></p><a id="I_programlisting4_d1e29930"/><pre class="programlisting">//...continuation of load_pcap_file
   uint32 pos = sizeof(pcap_file_header);    //file position tracker
   while ((len = qlread(li, &amp;pkt, sizeof(pkt))) == sizeof(pkt)) {
      mem2base(&amp;pkt, pos, pos + sizeof(pkt), pos);  //transfer header to database
      pos += sizeof(pkt);       //update position pointer point to packet content
      //now read packet content based on number of bytes of packet that are
      //present
      file2base(li, pos, pos, pos + pkt.caplen, FILEREG_PATCHABLE);
      pos += pkt.caplen;        //update position pointer to point to next header
   }
   //create a new section around the packet content.  This section begins where
   //the pcap file header ended.
   if (!add_segm(0, sizeof(pcap_file_header), pos, ".packets", CLASS_DATA)) {
      loader_failure();
   }
   //retrieve a handle to the new segment
   segment_t *s = getseg(sizeof(pcap_file_header));
   //so that we can set 32 bit addressing mode on
   set_segm_addressing(s, 1);  //set 32 bit addressing
   //...continues</pre><p>In the preceding code, the <code class="literal">mem2base</code> function is new and utilized to transfer content that has already been loaded into memory into the database.</p><p>The <code class="literal">load_pcap_file</code> function concludes by applying structure templates wherever possible throughout the database. We must apply structure templates after creating the segment; otherwise the act of creating the segment will remove all applied structure templates, negating all of our hard work. The third and final portion of the function is shown here:</p><a id="I_programlisting4_d1e29943"/><pre class="programlisting">//...continuation of load_pcap_file
   //apply headers structs for each packet in the database
   for (uint32 ea = s-&gt;startEA; ea &lt; pos;) {
      uint32 pcap = ea;       //start of packet
      //apply pcap packet header struct
      doStruct(pcap, sizeof(pcap_pkthdr), pkthdr_struct);
      uint32 eth = pcap + sizeof(pcap_pkthdr);
      //apply Ethernet header struct
      doStruct(eth, sizeof(ether_header), ether_struct);
      //Test Ethernet type field
      uint16 etype = get_word(eth + 12);
      etype = (etype &gt;&gt; 8) | (etype &lt;&lt; 8);  //htons

      if (etype == ETHER_TYPE_IP) {
         uint32 ip = eth + sizeof(ether_header);
         //Apply IP header struct
         doStruct(ip, sizeof(iphdr), ip_struct);
         //Test IP protocol
         uint8 proto = get_byte(ip + 9);
         //compute IP header length
         uint32 iphl = (get_byte(ip) &amp; 0xF) * 4;
         if (proto == IP_PROTO_TCP) {
            doStruct(ip + iphl, sizeof(tcphdr), tcp_struct);
         }
         else if (proto == IP_PROTO_UDP) {
            doStruct(ip + iphl, sizeof(udphdr), udp_struct);
         }
      }
      //point to start of next pcak_pkthdr
      ea += get_long(pcap + 8) + sizeof(pcap_pkthdr);
   }
}</pre><p>The preceding code simply steps through the database, one packet at a time, and examines a few fields within each packet header in order to determine both the type of structure to be applied and the location of the start of that structure. The following output represents the first few lines of a pcap file that has been loaded into a database using the pcap loader:</p><a id="I_programlisting4_d1e29947"/><pre class="programlisting">.file_header:0000 _file_header    segment byte public 'DATA' use16
.file_header:0000         assume cs:_file_header
.file_header:0000         pcap_file_header &lt;0A1B2C3D4h, 2, 4, 0, 0, 0FFFFh, 1&gt;
.file_header:0000 _file_header    ends
.file_header:0000
.packets:00000018 ; =========================================================
.packets:00000018
.packets:00000018 ; Segment type: Pure data
.packets:00000018 _packets  segment byte public 'DATA' use32
.packets:00000018            assume cs:_packets
.packets:00000018            ;org 18h
.packets:00000018            pcap_pkthdr &lt;&lt;47DF275Fh, 1218Ah&gt;, 19Ch, 19Ch&gt;
.packets:00000028            db 0, 18h, 0E7h, 1, 32h, 0F5h; ether_dhost
.packets:00000028            db 0, 50h, 0BAh, 0B8h, 8Bh, 0BDh; ether_shost
.packets:00000028            dw 8                    ; ether_type
.packets:00000036            iphdr &lt;45h, 0, 8E01h, 0EE4h, 40h, 80h, 6, 9E93h,
                                    200A8C0h, 6A00A8C0h&gt;
.packets:0000004A            tcphdr &lt;901Fh, 2505h, 0C201E522h, 6CE04CCBh, 50h,
                                     18h, 0E01Ah, 3D83h, 0&gt;
.packets:0000005E            db  48h ; H
.packets:0000005F            db  54h ; T
.packets:00000060            db  54h ; T
.packets:00000061            db  50h ; P
.packets:00000062            db  2Fh ; /
.packets:00000063            db  31h ; 1
.packets:00000064            db  2Eh ; .
.packets:00000065            db  30h ; 0</pre><p>Applying structure templates in this manner, we can expand and collapse any header to show or hide its individual member fields. As displayed, it is fairly easy to observe that the byte at address <code class="literal">0000005E</code> is the first byte of an HTTP response packet.<a class="indexterm" id="IDX-CHP-18-0129"/></p><p>Having a basic loading capability for pcap files lays the groundwork for developing plug-ins that perform more sophisticated tasks, such as TCP stream reassembly and various other forms of data extraction. Additional work could go into formatting various networking-related structures in a more user-friendly manner, such as displaying readable versions of an IP address and hosting byte-ordered displays for other fields within each header. Such improvements are left as challenges to the reader.<a class="indexterm" id="IDX-CHP-18-0130"/><a class="indexterm" id="IDX-CHP-18-0131"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-18-FN-5" id="ftn.CHP-18-FN-5">132</a>] </sup>See <a class="ulink" href="http://www.tcpdump.org/">http://www.tcpdump.org/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-18-FN-6" id="ftn.CHP-18-FN-6">133</a>] </sup>See <a class="ulink" href="http://www.wireshark.org/">http://www.wireshark.org/</a>.</p></div></div></div>
<div class="sect1" title="Alternative Loader Strategies"><div class="titlepage"><div><div><h1 class="title"><a id="alternative_loader_strategies"/>Alternative Loader Strategies</h1></div></div></div><p>If you spend some time browsing the example loaders included with the SDK, you will find several different styles of loaders. One loader worth pointing out is the Java loader (<span class="emphasis"><em>&lt;SDKDIR&gt;/ldr/javaldr</em></span>). For some file formats, the coupling between the loader and the processor module is very loose. Once the loader makes note of entry points into the code, the processor module needs no additional information in order to properly disassemble the code. Some processor modules may require substantially more information about the original input file and may be required to perform much of the same parsing that was previously completed by the loader. In order to avoid such duplication of effort, a loader and a processor may be paired in a much more tightly coupled manner. In fact, the approach taken in the Java loader is essentially to push all loading tasks (those that would usually take place in the loader’s <code class="literal">load_file</code> function) into the processor module using code similar to the following:<a class="indexterm" id="IDX-CHP-18-0132"/></p><a id="I_programlisting4_d1e29981"/><pre class="programlisting">static void load_file(linput_t *li, ushort neflag, const char *) {
  if (ph.id != PLFM_JAVA) {
    set_processor_type("java", SETPROC_ALL | SETPROC_FATAL);
  }
  if (ph.notify(ph.loader, li, (bool)(neflag &amp; NEF_LOPT))) {
    error("Internal error in loader&lt;-&gt;module link");
  }
}</pre><p>In the Java loader, the only work that takes place is to verify that the processor type is set to the Java processor, at which point the loader sends a <code class="literal">ph.loader</code> (defined in <span class="emphasis"><em>idp.hpp</em></span>) notification message to the processor module to inform the processor that the loading phase has been initiated. Upon receipt of the notification, the Java processor takes over the responsibility for loading, and in the process it derives a significant amount of internal state information that will be reused when the processor is directed to perform its disassembly tasks.</p><p>Whether this strategy makes sense for you depends entirely on if you are developing both a loader and an associated processor module and if you feel that the processor would benefit from access to the information traditionally derived within the loader (segmentation, file header fields, debugging information, and so on).</p><p>Another means to pass state information from the loader to the processor module involves the use of database netnodes. During the loading phase, the loader may choose to populate specific netnodes with information that can later be retrieved by the processor module during the disassembly phase. Note that frequently accessing the database to retrieve information stored in this manner may be somewhat slower than utilizing available C++ datatypes.</p></div>
<div class="sect1" title="Writing a Scripted Loader"><div class="titlepage"><div><div><h1 class="title"><a id="writing_a_scripted_loader"/>Writing a Scripted Loader</h1></div></div></div><p>In IDA 5.6 Hex-Rays introduced the capability to implement loaders using Python or IDC scripts. In the Hex Blog posting announcing this new capability,<sup>[<a class="footnote" href="#ftn.CHP-18-FN-7" id="CHP-18-FN-7">134</a>]</sup> Elias Bachaalany of Hex-Rays describes a loader, implemented in Python, used to load a particular type of malicious <span class="emphasis"><em>.pdf</em></span> file containing shellcode. The nature of malicious <span class="emphasis"><em>.pdf</em></span> files is such that the loader does not generalize across all <span class="emphasis"><em>.pdf</em></span> files, but the loader is an excellent example of how to load unsupported file formats in IDA.<a class="indexterm" id="IDX-CHP-18-0133"/></p><p>Scripted loaders may be implemented in either IDC or Python and require at least two functions, <code class="literal">accept_file</code> and <code class="literal">load_file</code>, which perform functions similar to those previously described for SDK-based loaders. An IDC-based loader for the Simpleton file format is shown here:<a class="indexterm" id="IDX-CHP-18-0134"/><a class="indexterm" id="IDX-CHP-18-0135"/><a class="indexterm" id="IDX-CHP-18-0136"/></p><a id="I_programlisting4_d1e30040"/><pre class="programlisting">#include &lt;idc.idc&gt;

#define SIMPLETON_MAGIC 0x1DAB00C

//Verify the input file format
//   li - loader_input_t object. See IDA help file for more information
//   n  - How many times we have been called
//Returns:
//   0 - file unrecognized
//   Name of file type - if file is recognized
static accept_file(li, n) {
   auto magic;
   if (n) return 0;
   li.readbytes(&amp;magic, 4, 0);
   if (magic != SIMPLETON_MAGIC) {
      return 0;
   }
   return "IDC Simpleton Loader";
}

//Load the file
//   li - loader_input_t object
//   neflags - refer to loader.hpp for valid flags
//   format  - The file format selected nby the user
//Returns:
//   1 - success
//   0 - failure
static load_file(li, neflags, format) {
   auto magic, size, base;
   li.seek(0, 0);
   li.readbytes(&amp;magic, 4, 0);
   li.readbytes(&amp;size, 4, 0);
   li.readbytes(&amp;base, 4, 0);
   // copy bytes to the database
   loadfile(li, 12, base, size);
   // create a segment
   AddSeg(base, base + size, 0, 1, saRelPara, scPub);
   // add the initial entry point
   AddEntryPoint(base, base, "_start", 1);
   return 1;
}</pre><p>Other than the use of IDC functions in place of SDK functions, the similarities between the IDC version of the simpleton loader and the C++ version presented earlier should be fairly obvious. Loader scripts are installed by copying them to <span class="emphasis"><em>&lt;IDADIR&gt;/loaders</em></span>.</p><p>Python may also be used to develop loaders and allows for more robust development because it offers much greater access to IDA’s underlying SDK. Implemented in Python, the simpleton loader might look something like this.</p><a id="I_programlisting4_d1e30049"/><pre class="programlisting">#Verify the input file format
#   li - loader_input_t object. See IDA help file for more information
#   n  - How many times we have been called
#Returns:
#   0 - file unrecognized
#   Name of file type - if file is recognized
def accept_file(li, n):
   if (n):
      return 0
   li.seek(0)
   magic = struct.unpack("&lt;I", li.read(4))[0]
   if magic != 0x1DAB00C:
      return 0
   return "Python Simpleton Loader"

#Load the file
#   li - loader_input_t object
#   neflags - refer to loader.hpp for valid flags
#   format  - The file format selected nby the user
#Returns:
#   1 - success
#   0 - failure
def load_file(li, neflags, format):
   li.seek(0)
   (magic, size, base) = struct.unpack("&lt;III", li.read(12))
   # copy bytes to the database
   li.file2base(12, base, base + size, 1)
   # create a segment
   add_segm(0, base, base + size, ".text", "CODE")
   # add the initial entry point
   add_entry(base, base, "_start", 1)
   return 1;</pre><p>One of the greatest strengths of scripting loaders (and plug-ins for that matter) is that they allow for rapid prototyping of modules that might eventually be implemented using the SDK.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-18-FN-7" id="ftn.CHP-18-FN-7">134</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=110">http://www.hexblog.com/?p=110</a>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id17"/>Summary</h1></div></div></div><p>Once you have developed an understanding of how loaders fit into IDA’s modular architecture, you should find that loader modules are no more difficult to create than plug-in modules. Loaders clearly have their own particular subset of the SDK that they rely heavily on, the majority of which resides in <span class="emphasis"><em>loader.hpp</em></span>, <span class="emphasis"><em>segment.hpp</em></span>, <span class="emphasis"><em>entry.hpp</em></span>, and <span class="emphasis"><em>diskio.hpp</em></span>. Finally, since loaders execute before the processor module has a chance to analyze the newly loaded code, loaders should never bother themselves with any disassembly tasks, such as dealing with functions or disassembled instructions.</p><p>In the next chapter, we round out our discussion of IDA modules with an introduction to processor modules, the components most responsible for the overall formatting of a disassembled binary.</p></div>
<div class="chapter" title="Chapter&#xA0;19.&#xA0;IDA Processor Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ida_processor_modules"/>Chapter 19. IDA Processor Modules</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id18"/><div class="mediaobject"><a id="I_mediaobject5_d1e30076"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>The last type of IDA modules that can be built with the SDK are processor modules, which are by far the most complex of IDA’s module types. Processor modules are responsible for all of the disassembly operations that take place within IDA. Beyond the obvious conversion of machine language opcodes into their assembly language equivalents, processor modules are also responsible for tasks such as creating functions, generating cross-references, and tracking the behavior of the stack pointer. As it has done with plug-ins and loaders, Hex-Rays has made it possible (beginning with IDA 5.7) to author processor modules using one of IDA’s scripting languages.</p><p>The obvious case that would require development of a processor module is reverse engineering a binary for which no processor module exists. Among other things, such a binary might represent firmware images for embedded microcontrollers or executable images pulled from handheld devices. A less-obvious use for a processor module might be to disassemble the instructions of a custom virtual machine embedded within an obfuscated executable. In such cases, an existing IDA processor module such as the <code class="literal">pc</code> module for x86 would help you understand only the virtual machine itself; it would offer no help at all in disassembling the virtual machine’s underlying byte code. Rolf Rolles demonstrated just such an application of a processor module in a paper posted to <a class="ulink" href="http://openrce.org">OpenRCE.org</a>.<sup>[<a class="footnote" href="#ftn.CHP-19-FN-1" id="CHP-19-FN-1">135</a>]</sup> In <a class="xref" href="apb.html" title="Appendix B. IDC/SDK Cross-Reference">Appendix B</a> of his paper, Rolf also shares his thoughts on creating IDA processor modules; this is one of the few documents available on the subject.<a class="indexterm" id="IDX-CHP-19-0001"/><a class="indexterm" id="IDX-CHP-19-0002"/><a class="indexterm" id="IDX-CHP-19-0003"/><a class="indexterm" id="IDX-CHP-19-0004"/><a class="indexterm" id="IDX-CHP-19-0005"/></p><p>In the world of IDA modules, there are an infinite number of conceivable uses for plug-ins, and after scripts, plug-ins are by far the most commonly available third-party add-ons for IDA. The need for custom loader modules is far smaller than the need for plug-ins. This is not unexpected, as the number of binary file formats (and hence the need for loaders) tends to be much smaller than the number of conceivable uses for plug-ins. A natural consequence is that outside of modules donated to and distributed with IDA, there tend to be relatively few third-party loader modules published. Smaller still is the need for processor modules, as the number of instruction sets requiring decoding is smaller than the number of file formats that make use of those instruction sets. Here again, this leads to an almost complete lack of third-party processor modules other than the few distributed with IDA and its SDK. Judging by the subjects of posts to the Hex-Rays forums, it is clear that people are working on processor modules; these modules are simply not being released to the public.</p><p>In this chapter, we hope to shed additional light on the topic of creating IDA processor modules and help to demystify (at least somewhat) the last of IDA’s modular components. As a running example, we will develop a processor module to disassemble Python byte code. Since the components of a processor module can be lengthy, it will not be possible to include complete listings of every piece of the module. The complete source code for the Python processor module is available on the book’s companion website. It is important to understand that without the benefit of a Python loader module, it will not be possible to perform fully automated disassembly of compiled <span class="emphasis"><em>.pyc</em></span> files. Lacking such a loader, you will need to load <span class="emphasis"><em>.pyc</em></span> files in binary mode, select the Python processor module, identify a likely starting point for a function, and then convert the displayed bytes to Python instructions using Edit ▸ Code.</p><div class="sect1" title="Python Byte Code"><div class="titlepage"><div><div><h1 class="title"><a id="python_byte_code"/>Python Byte Code</h1></div></div></div><p>Python<sup>[<a class="footnote" href="#ftn.CHP-19-FN-2" id="CHP-19-FN-2">136</a>]</sup> is an object-oriented, interpreted programming language. Python is often used for scripting tasks in a manner similar to Perl. Python source files are commonly saved with a <span class="emphasis"><em>.py</em></span> extension. Whenever a Python script is executed, the Python interpreter compiles the source code to an internal representation known as <span class="emphasis"><em>Python byte code</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-19-FN-3" id="CHP-19-FN-3">137</a>]</sup> This byte code is ultimately interpreted by a virtual machine. This entire process is somewhat analogous to the manner in which Java source is compiled to Java byte code, which is ultimately executed by a Java virtual machine. The primary difference is that Java users must explicitly compile their Java source into Java byte code, while Python source code is implicitly converted to byte code every time a user elects to execute a Python script.<a class="indexterm" id="IDX-CHP-19-0006"/><a class="indexterm" id="IDX-CHP-19-0007"/><a class="indexterm" id="IDX-CHP-19-0008"/></p><p>In order to avoid repeated translations from Python source to Python byte code, the Python interpreter may save the byte code representation of a Python source file in a <span class="emphasis"><em>.pyc</em></span> file that may be loaded directly on subsequent execution, eliminating the time spent in translating the Python source. Users typically do not explicitly create <span class="emphasis"><em>.pyc</em></span> files. Instead, the Python interpreter automatically creates <span class="emphasis"><em>.pyc</em></span> files for any Python source module that is imported by another Python source module. The theory is that modules tend to get reused frequently, and you can save time if the byte code form of the module is readily available. Python byte code (<span class="emphasis"><em>.pyc</em></span>) files are the rough equivalent of Java <span class="emphasis"><em>.class</em></span> files.<a class="indexterm" id="IDX-CHP-19-0009"/></p><p>Given that the Python interpreter does not require source code when a corresponding byte code file is available, it may be possible to distribute some portions of a Python project as byte code rather than as source. In such cases, it might be useful to reverse engineer the byte code files in order to understand what they do, just as we might do with any other binary software distribution. This is the intended purpose of our example Python processor module—to provide a tool that can assist in reverse engineering Python byte code.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-19-FN-1" id="ftn.CHP-19-FN-1">135</a>] </sup>See “Defeating HyperUnpackMe2 With an IDA Processor Module” at <a class="ulink" href="http://www.openrce.org/articles/full_view/28">http://www.openrce.org/articles/full_view/28</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-19-FN-2" id="ftn.CHP-19-FN-2">136</a>] </sup>See <a class="ulink" href="http://www.python.org/">http://www.python.org/</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-19-FN-3" id="ftn.CHP-19-FN-3">137</a>] </sup>See <a class="ulink" href="http://docs.python.org/library/dis.html#bytecodes">http://docs.python.org/library/dis.html#bytecodes</a> for a complete list of Python byte code instructions and their meanings. Also see <span class="emphasis"><em>opcode.h</em></span> in the Python source distribution for a mapping of byte code mnemonics to their equivalent opcodes.</p></div></div></div>
<div class="sect1" title="The Python Interpreter"><div class="titlepage"><div><div><h1 class="title"><a id="the_python_interpreter"/>The Python Interpreter</h1></div></div></div><p>A little background on the Python interpreter may be useful as we develop the Python processor module. The Python interpreter implements a stack-based virtual machine that is capable of executing Python byte code. By <span class="emphasis"><em>stack-based</em></span>, we mean that the virtual machine has no registers other than an instruction pointer and a stack pointer. The majority of Python byte code instructions manipulate the stack in some way by reading, writing, or examining stack content. The <code class="literal">BINARY_ADD</code> byte code instruction, for example, removes two items from the interpreter’s stack, adds those two items together, and places the single result value back on the top of the interpreter’s stack.</p><p>In terms of instruction set layout, Python bytes codes are relatively simple to understand. All Python instructions consist of a single-byte opcode and either zero or two operand bytes. The processor example presented in this chapter does not require that you have any prior knowledge of Python byte code. In the few instances where specific knowledge is required, we will take the time to explain the byte code sufficiently. The primary goal of this chapter is to provide a basic understanding of IDA processor modules and some of the considerations that go into creating them. Python byte code is merely used as a means to facilitate this goal.</p></div>
<div class="sect1" title="Writing a Processor Module Using the SDK"><div class="titlepage"><div><div><h1 class="title"><a id="writing_a_processor_module_using_the_sdk"/>Writing a Processor Module Using the SDK</h1></div></div></div><p>It wouldn’t be proper to begin a discussion of creating a processor module without including the standard disclaimer that documentation concerning processor modules is scarce. Other than reading through SDK include files and the source of processor modules included with the SDK, you will find that the SDK’s <span class="emphasis"><em>readme.txt</em></span> file is the only other file that sheds any light on how to create a processor module, with a few notes under the heading “Description of processor modules.”<a class="indexterm" id="IDX-CHP-19-0010"/><a class="indexterm" id="IDX-CHP-19-0011"/><a class="indexterm" id="IDX-CHP-19-0012"/><a class="indexterm" id="IDX-CHP-19-0013"/><a class="indexterm" id="IDX-CHP-19-0014"/><a class="indexterm" id="IDX-CHP-19-0015"/><a class="indexterm" id="IDX-CHP-19-0016"/><a class="indexterm" id="IDX-CHP-19-0017"/><a class="indexterm" id="IDX-CHP-19-0018"/></p><p>It is worth clarifying that while the README file references specific filenames within a processor module as if those filenames are set in stone, in fact they are not. They do, however, tend to be the filenames that are used in the included SDK examples, and they are also the filenames referenced in the build scripts included with those examples. Feel free to create your processor modules using any filenames you like, as long as you update your build scripts accordingly.</p><p>The general intent of referring to specific processor files is to convey the idea that a processor module consists of three logical components: an <span class="emphasis"><em>analyzer</em></span>, an <span class="emphasis"><em>instruction emulator</em></span>, and an <span class="emphasis"><em>output generator</em></span>. We will cover the purpose of each of these functional components as we work our way through the creation of our Python processor module.<a class="indexterm" id="IDX-CHP-19-0019"/><a class="indexterm" id="IDX-CHP-19-0020"/></p><p>Several example processors can be found in <span class="emphasis"><em>&lt;SDKDIR&gt;/module</em></span>. One of the simpler processors to read through (if there is such a thing) is the z8 processor. Other processor modules vary in complexity based on their instruction sets and whether they take on any of the loading responsibilities. If you are thinking about writing your own processor module, one approach for getting started (recommended by Ilfak in the README file) is to copy an existing processor module and modify it to suit your needs. In such cases, you will want to find the processor module that most closely resembles the logical structure (not necessarily the processor architecture) that you envision for your module.</p><div class="sect2" title="The processor_t Struct"><div class="titlepage"><div><div><h2 class="title"><a id="the_processor_underscore_t_struct"/>The processor_t Struct</h2></div></div></div><p>As with plug-ins and loaders, processor modules export exactly one thing. For processors, that one thing is a <code class="literal">processor_t</code> struct that must be named <code class="literal">LPH</code>. This struct is exported automatically if you include <span class="emphasis"><em>&lt;SDKDIR&gt;/module/idaidp.hpp</em></span>, which in turn includes many other SDK header files commonly required by processor modules. One of the reasons why writing a processor module is so challenging is that the <code class="literal">processor_t</code> struct contains 56 fields that must be initialized, and 26 of those fields are function pointers, while 1 of the fields is a pointer to an array of one or more struct pointers that each point to a different type of struct (<code class="literal">asm_t</code>) that contains 59 fields requiring initialization. Easy enough, right? One of the principle inconveniences in building processor modules revolves around initializing all of the required static data, a proccess that can be error prone because of the large number of fields within each data structure. This is one of the reasons why Ilfak recommends using an existing processor as the basis for any new processors you develop.<a class="indexterm" id="IDX-CHP-19-0021"/><a class="indexterm" id="IDX-CHP-19-0022"/><a class="indexterm" id="IDX-CHP-19-0023"/><a class="indexterm" id="IDX-CHP-19-0024"/><a class="indexterm" id="IDX-CHP-19-0025"/><a class="indexterm" id="IDX-CHP-19-0026"/><a class="indexterm" id="IDX-CHP-19-0027"/><a class="indexterm" id="IDX-CHP-19-0028"/><a class="indexterm" id="IDX-CHP-19-0029"/><a class="indexterm" id="IDX-CHP-19-0030"/></p><p>Because of the complexity of these data structures, we will not attempt to enumerate every possible field and its uses. Instead, we will highlight the major fields and refer you to <span class="emphasis"><em>idp.hpp</em></span> for further details on these and other fields within each structure. The order in which we cover various <code class="literal">processor_t</code> fields bears no resemblance to the order in which those fields are declared within <code class="literal">processor_t</code>.</p></div><div class="sect2" title="Basic Initialization of the LPH Structure"><div class="titlepage"><div><div><h2 class="title"><a id="basic_initialization_of_the_lph_structur"/>Basic Initialization of the LPH Structure</h2></div></div></div><p>Before diving into the behavioral aspects of your processor module, there are some static data requirements that you should take care of. As you build a disassembly module, you need to create a list of every assembly language mnemonic that you intend to recognize for your target processor. This list is created in the form of an array of <code class="literal">instruc_t</code> (defined in <span class="emphasis"><em>idp.hpp</em></span>) structures and is commonly placed in a file named <span class="emphasis"><em>ins.cpp</em></span>. As shown here, <code class="literal">instruc_t</code> is a simple structure whose purpose is twofold. First, it provides a table lookup for instruction mnemonics. Second, it describes some basic characteristics of each instruction.</p><a id="I_programlisting5_d1e30358"/><pre class="programlisting">struct instruc_t {
  const char *name;  //instruction mnemonic
  ulong feature;     //bitwise OR of CF_xxx flags defined in idp.hpp
};</pre><p>The <code class="literal">feature</code> field is used to indicate behaviors such as whether the instruction reads or writes any of its operands and how execution continues once the instruction is executed (default, jump, call). The <code class="literal">CF</code> in <code class="literal">CF_</code><em class="replaceable"><code>xxx</code></em> stands for <span class="emphasis"><em>canonical feature</em></span>. The <code class="literal">feature</code> field basically drives the concepts of control flow and cross-references. A few of the more interesting canonical feature flags are described here:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>CF_STOP</code></strong> The instruction does not pass control to the following instruction. Examples might include absolute jumps or function-return instructions.</td></tr><tr><td><strong class="userinput"><code>CF_CHGn</code></strong> The instruction modifies operand <code class="literal">n</code>, where <code class="literal">n</code> is in the range 1..6.</td></tr><tr><td><strong class="userinput"><code>CF_USEn</code></strong> The instruction uses operand <code class="literal">n</code>, where <code class="literal">n</code> is in the range 1..6, and <span class="emphasis"><em>uses</em></span> means “reads” or “refers to” (but does not modify; see <code class="literal">CF_CHGn</code>) a memory location.</td></tr><tr><td><strong class="userinput"><code>CF_CALL</code></strong> The instruction calls a function.</td></tr></table><p>Instructions need not be listed in any particular order. In particular, there is no need to order instructions according to their associated binary opcodes, nor is there any requirement to have a one-to-one correspondence between the instructions in this array and valid binary opcodes. The first and last few lines of our example instruction array are shown here:<a class="indexterm" id="IDX-CHP-19-0031"/></p><a id="I_programlisting5_d1e30419"/><pre class="programlisting">instruc_t Instructions[] = {
     {"STOP_CODE", CF_STOP},   /* 0 */
     {"POP_TOP", 0},           /* 1 */
     {"ROT_TWO", 0},           /* 2 */
     {"ROT_THREE", 0},         /* 3 */
     {"DUP_TOP", 0},           /* 4 */
     {"ROT_FOUR", 0},          /* 5 */
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    {NULL, 0},                /* 6 */
     ...
     {"CALL_FUNCTION_VAR_KW", CF_CALL}, /* 142 */
     {"SETUP_WITH", 0},                 /* 143 */
     {"EXTENDED_ARG", 0},               /* 145 */
     {"SET_ADD", 0},                    /* 146 */
     {"MAP_ADD", 0}                     /* 147 */
  };</pre><p>In our example, because Python byte code is so simple, we will be maintaining a one-to-one correspondence between instructions and byte codes. Note that in order to do so, some instruction records must act as filler when an opcode is not defined, such as opcode 6 <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e30429"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> in this case.</p><p>An associated set of enumerated constants is typically defined in <span class="emphasis"><em>ins.hpp</em></span> to provide a mapping from integers to instructions, as shown here:</p><a id="I_programlisting5_d1e30440"/><pre class="programlisting">enum python_opcodes {
   STOP_CODE = 0,
   POP_TOP = 1,    //remove top item on stack
   ROT_TWO = 2,    //exchange top two items on stack
   ROT_THREE = 3,  //move top item below the 2nd and 3rd items
   DUP_TOP = 4,    //duplicate the top item on the stack
   ROT_FOUR = 5,   //move top item below the 2nd, 3rd, and 4th items
   NOP = 9,        //no operation
   ...
   CALL_FUNCTION_VAR_KW = 142,
   SETUP_WITH = 143,
   EXTENDED_ARG = 145,
   SET_ADD = 146,
   MAP_ADD = 147,
   PYTHON_LAST = 148
};</pre><p>Here we have elected to explicitly assign a value to each enum, both for clarity’s sake and because there are gaps in our sequence because we have elected to use the actual Python opcodes as our instruction indexes. An additional constant has also been added (<code class="literal">PYTHON_LAST</code>) to provide easy reference to the end of the list. With a list of instructions and associated integer mapping in hand, we have sufficient information to initialize three fields of <code class="literal">LPH</code> (our global <code class="literal">processor_t</code>). These three fields are described here:<a class="indexterm" id="IDX-CHP-19-0032"/><a class="indexterm" id="IDX-CHP-19-0033"/><a class="indexterm" id="IDX-CHP-19-0034"/><a class="indexterm" id="IDX-CHP-19-0035"/><a class="indexterm" id="IDX-CHP-19-0036"/></p><a id="I_programlisting5_d1e30470"/><pre class="programlisting">int instruc_start;   // integer code of the first instruction
  int instruc_end;     // integer code of the last instruction + 1
  instruc_t *instruc;  // array of instructions</pre><p>We must initialize these fields with <code class="literal">STOP_CODE</code>, <code class="literal">PYTHON_LAST</code>, and <code class="literal">Instructions</code>, respectively. Together these fields enable a processor module to quickly look up the mnemonic for any instruction in the disassembly.</p><p>For most processor modules, we also need to define a set of register names and an associated set of enumerated constants for referring to them. If we were writing an x86 processor module, we might begin with something like the following, where for the sake of brevity we restrict ourselves to the basic x86 register set:</p><a id="I_programlisting5_d1e30485"/><pre class="programlisting">static char *RegNames[] = {
   "eax", "ebx", "ecx", "edx", "edi", "esi", "ebp", "esp",
   "ax", "bx", "cx", "dx", "di", "si", "bp", "sp",
   "al", "ah", "bl", "bh",  "cl", "ch", "dl", "dh",
   "cs", "ds", "es", "fs", "gs"
};</pre><p>The <code class="literal">RegNames</code> array is often declared in a file named <span class="emphasis"><em>reg.cpp</em></span>. This file is also where the sample processor modules declare <code class="literal">LPH</code>, which enables <code class="literal">RegNames</code> to be declared statically. The associated register enumeration would be declared in a header file, usually named after the processor (perhaps <span class="emphasis"><em>x86.hpp</em></span> in this case), as follows:</p><a id="I_programlisting5_d1e30504"/><pre class="programlisting">enum x86_regs {
   r_eax, r_ebx, r_ecx, r_edx, r_edi, r_esi, r_ebp, r_esp,
   r_ax, r_bx, r_cx, r_dx, r_di, r_si, r_bp, r_sp,
   r_al, r_ah, r_bl, r_bh,  r_cl, r_ch, r_dl, r_dh,
   r_cs, r_ds, r_es, r_fs, r_gs
};</pre><p>Make certain that you maintain the proper correspondence between the register name array and its associated set of constants. Together the register name array and the enumerated register constants allow a processor module to quickly look up register names when formatting instruction operands. These two data declarations are used to initialize additional fields in <code class="literal">LPH</code>:</p><a id="I_programlisting5_d1e30511"/><pre class="programlisting">int   regsNum;            // total number of registers
  char  **regNames;         // array of register names</pre><p>These two fields are often initialized with <code class="literal">qnumber(RegNames)</code> and <code class="literal">RegNames</code>, respectively, where <code class="literal">qnumber</code> is a macro, defined in <span class="emphasis"><em>pro.h</em></span>, that computes the number of elements in a statically allocated array.</p><p>An IDA processor module is always required to specify information about segment registers regardless of whether the actual processor uses segment registers or not. Since the x86 utilizes segment registers, the preceding example is fairly straightforward to configure. Segment registers are configured in the following fields within a <code class="literal">processor_t</code>:</p><a id="I_programlisting5_d1e30532"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> // Segment register information (use virtual CS and DS registers if
  // your processor doesn't have segment registers):
    int   regFirstSreg;        // number of first segment register
    int   regLastSreg;         // number of last segment register
    int   segreg_size;         // size of a segment register in bytes

<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> // If your processor does not use segment registers, You should define
  // 2 virtual segment registers for CS and DS.
  // Let's call them rVcs and rVds.
    int   regCodeSreg;         // number of CS register
    int   regDataSreg;         // number of DS register</pre><p>To initialize our hypothetical x86 processor module, the previous five fields would be initialized, in order, as follows:</p><a id="I_programlisting5_d1e30548"/><pre class="programlisting">r_cs, r_gs, 2, r_cs, r_ds</pre><p>Note the comments, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e30552"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e30558"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, regarding segment registers. IDA always wants information about segment registers, even if your processor does not use them. Returning to our Python example, we don’t have nearly as much work to do in setting up register mappings, since the Python interpreter is a stack-based architecture and there are no registers, but we do need to deal with the segment register issue. The typical approach for doing so is to make up names and enumerated values to represent a minimal set of segment registers (code and data). Basically, we are faking the existence of segment registers for no other reason than because IDA expects them. However, even though IDA expects them, we are by no means obligated to use them, so we simply ignore them in our processor module. For our Python processor, we do the following:</p><a id="I_programlisting5_d1e30564"/><pre class="programlisting">//in reg.cpp
static char *RegNames = { "cs", "ds" };

//in python.hpp
enum py_registers { rVcs, rVds };</pre><p>With these declarations in place, we can return to initialize the appropriate fields within <code class="literal">LPH</code> using the following sequence of values:</p><a id="I_programlisting5_d1e30571"/><pre class="programlisting">rVcs, rVds, 0, rVcs, rVds</pre><p>Before moving on to the implementation of any behavior in the Python processor, we take some time to knock off some remaining low-hanging fruit where initialization of the <code class="literal">LPH</code> structure is concerned. The first five fields of a <code class="literal">processor_t</code> are described here:<a class="indexterm" id="IDX-CHP-19-0037"/><a class="indexterm" id="IDX-CHP-19-0038"/><a class="indexterm" id="IDX-CHP-19-0039"/><a class="indexterm" id="IDX-CHP-19-0040"/><a class="indexterm" id="IDX-CHP-19-0041"/><a class="indexterm" id="IDX-CHP-19-0042"/><a class="indexterm" id="IDX-CHP-19-0043"/><a class="indexterm" id="IDX-CHP-19-0044"/><a class="indexterm" id="IDX-CHP-19-0045"/><a class="indexterm" id="IDX-CHP-19-0046"/><a class="indexterm" id="IDX-CHP-19-0047"/><a class="indexterm" id="IDX-CHP-19-0048"/><a class="indexterm" id="IDX-CHP-19-0049"/><a class="indexterm" id="IDX-CHP-19-0050"/><a class="indexterm" id="IDX-CHP-19-0051"/></p><a id="I_programlisting5_d1e30635"/><pre class="programlisting">int version; // should be IDP_INTERFACE_VERSION
int id;     // IDP id, a PLFM_xxx value or self assigned &gt; 0x8000
ulong flag; // Processor features, bitwise OR of PR_xxx values
int cnbits; // Number of bits in a byte for code segments (usually 8)
int dnbits; // Number of bits in a byte for data segments (usually 8)</pre><p>The <code class="literal">version</code> field should look familiar, as it is also required in plug-in and loader modules. For custom processor modules, the <code class="literal">id</code> field should be a self-assigned value greater than 0x8000. The <code class="literal">flag</code> field describes various characteristics of the processor module as a combination of <code class="literal">PR_</code><em class="replaceable"><code>xxx</code></em> flags defined in <span class="emphasis"><em>idp.hpp</em></span>. For the Python processor, we choose to specify only <code class="literal">PR_RNAMESOK</code>, which allows register names to be used as location names (which is okay since we have no registers), and <code class="literal">PRN_DEC</code>, which sets the default number display format to decimal. The remaining two fields, <code class="literal">cnbits</code> and <code class="literal">dnbits</code>, are each set to 8.</p></div><div class="sect2" title="The Analyzer"><div class="titlepage"><div><div><h2 class="title"><a id="the_analyzer"/>The Analyzer</h2></div></div></div><p>At this point we have filled in enough of the <code class="literal">LPH</code> structure that we can begin thinking about the first portion of a processor module that will execute—the analyzer. In the example processor modules, the analyzer is typically implemented by a function named <code class="literal">ana</code> (you may name it anything you like) in a file named <span class="emphasis"><em>ana.cpp</em></span>. The prototype for this function is very simple, as shown here:</p><a id="I_programlisting5_d1e30683"/><pre class="programlisting">int idaapi ana(void); //analyze one instruction and return the instruction length</pre><p>You must initialize the <code class="literal">u_ana</code> member of the <code class="literal">LPH</code> object with a pointer to your analyzer function. The analyzer’s job is to analyze a single instruction, populate the global variable <code class="literal">cmd</code> with information about the instruction, and return the length of the instruction. The analyzer should not make any changes to the database.</p><p>The <code class="literal">cmd</code> variable is a global instance of an <code class="literal">insn_t</code> object. The <code class="literal">insn_t</code> class, defined in <span class="emphasis"><em>ua.hpp</em></span>, is used to describe a single instruction in the database. Its declaration is shown here:</p><a id="I_programlisting5_d1e30710"/><pre class="programlisting">class insn_t {
  public:
    ea_t cs; // Current segment base paragraph. Set by kernel
    ea_t ip; // Virtual address of instruction (within segment). Set by kernel
    ea_t ea; // Linear address of the instruction. Set by kernel
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>   uint16
 itype; // instruction enum value (not opcode!). Proc sets this in ana
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>   uint16 size;  // Size of instruction in bytes. Proc sets this in ana
    union {       // processor dependent field. Proc may set this
      uint16 auxpref;
      struct {
        uchar low;
          uchar high;
      } auxpref_chars;
    };
    char segpref;     // processor dependent field.  Proc may set this
    char insnpref;    // processor dependent field.  Proc may set this
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>   op_t Operands[6]; // instruction operand info.  Proc sets this in ana
    char flags;       // instruction flags.  Proc may set this
  };</pre><p>Prior to calling your analyzer function, the IDA kernel (the core of IDA) fills in the first three fields of the <code class="literal">cmd</code> object with the segmented and linear address of the instruction. After that, it is the analyzer’s job to fill in the rest. The essential fields for the analyzer to fill in are <code class="literal">itype</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e30738"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, <code class="literal">size</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e30747"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and <code class="literal">Operands</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e30757"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The <code class="literal">itype</code> field must be set to one of the enumerated instruction type values discussed previously. The <code class="literal">size</code> field must be set to the total size of the instruction (in bytes) and should be used as the return value of the instruction. If the instruction cannot be parsed, the analyzer should return a size of zero. Finally, an instruction may have up to six operands, and the analyzer should fill in information about each operand used by the instruction.<a class="indexterm" id="IDX-CHP-19-0052"/><a class="indexterm" id="IDX-CHP-19-0053"/><a class="indexterm" id="IDX-CHP-19-0054"/><a class="indexterm" id="IDX-CHP-19-0055"/></p><p>The analyzer function is often implemented using a switch statement. The first step in the analyzer is typically to request one or more (depending on the processor) bytes from the instruction stream and use those bytes as the switch test variable. The SDK offers special functions for use in the analyzer for the purpose of retrieving bytes from the instruction stream. These functions are shown here:</p><a id="I_programlisting5_d1e30784"/><pre class="programlisting">//read one byte from current instruction location
uchar ua_next_byte(void);
//read two bytes from current instruction location
ushort ua_next_word(void);
//read four bytes from current instruction location
ulong ua_next_long(void);
//read eight bytes from current instruction location
ulonglong ua_next_qword(void);</pre><p>The <code class="literal">current instruction location</code> is initially the same value contained in <span class="emphasis"><em>cmd.ip</em></span>. Each call to one of the <code class="literal">ua_next_</code><em class="replaceable"><code>xxx</code></em> functions has the side effect of incrementing <code class="literal">cmd.size</code> according to the number of bytes requested by the <code class="literal">ua_next_</code><em class="replaceable"><code>xxx</code></em> function being called (1, 2, 4, or 8). The retrieved bytes must be decoded enough to assign the appropriate instruction type enumerated value into the <code class="literal">itype</code> field, determine the number and type of any operands required by the instruction, and then determine the overall length of the instruction. As the decoding process progresses, additional instruction bytes may be required until a complete instruction has been retrieved from the instruction stream. As long as you utilize the <code class="literal">ua_next_</code><em class="replaceable"><code>xxx</code></em> function, <code class="literal">cmd.size</code> will be updated automatically for you, eliminating the need to keep track of the number of bytes you have requested for a given instruction. From a high-level perspective, the analyzer somewhat mimics the instruction fetch and instruction decode phases employed in real CPUs. Mirroring real life, instruction decoding tends to be easier for processors with fixed instruction sizes, as is often the case with RISC-style architectures, while instruction decoding tends to be more complicated for processors that use variable-length instructions, such as the x86.<a class="indexterm" id="IDX-CHP-19-0056"/><a class="indexterm" id="IDX-CHP-19-0057"/><a class="indexterm" id="IDX-CHP-19-0058"/><a class="indexterm" id="IDX-CHP-19-0059"/></p><p>Using the retrieved bytes, the analyzer must initialize one element in the <code class="literal">cmd.Operands</code> array for each operand used by the instruction. Instruction operands are represented using instances of the <code class="literal">op_t</code> class, which is defined in <span class="emphasis"><em>ua.hpp</em></span> and summarized here:</p><a id="I_programlisting5_d1e30846"/><pre class="programlisting">class op_t {
public:
  char n;  // number of operand (0,1,2).  Kernel sets this do not change!
  optype_t type; // type of operand.  Set in ana, See ua.hpp for values

  // offset of operand relative to instruction start
  char offb;  //Proc sets this in ana, set to 0 if unknown
  // offset to second part of operand (if present) relative to instruction start

  char offo;  //Proc sets this in ana, set to 0 if unknown
  uchar flags; //Proc sets this in ana.  See ua.hpp for possible values

  char dtyp; // Specifies operand datatype. Set in ana. See ua.hpp for values

  // The following unions keep other information about the operand
  union {
    uint16 reg;    // number of register for type o_reg
    uint16 phrase; // number of register phrase for types o_phrase and o_displ
                   // define numbers of phrases as you like
  };

  union {          // value of operand for type o_imm or
    uval_t value;  // outer displacement (o_displ+OF_OUTER_DISP)
    struct {       // Convenience access to halves of value
        uint16 low;
        uint16 high;
    } value_shorts;
  };

  union {   // virtual address pointed or used by the operand
    ea_t addr;  // for types (o_mem,o_displ,o_far,o_near)
    struct {    // Convenience access to halves of addr
        uint16 low;
        uint16 high;
    } addr_shorts;
  };

  //Processor dependent fields, use them as you like.  Set in ana
  union {
    ea_t specval;
    struct {
        uint16 low;
        uint16 high;
    } specval_shorts;
  };
  char specflag1, specflag2, specflag3, specflag4;
};</pre><p>Configuring an operand begins with setting the operand’s <code class="literal">type</code> field to one of the enumerated <code class="literal">optype_t</code> constants defined in <span class="emphasis"><em>ua.hpp</em></span>. An operand’s <code class="literal">type</code> describes the source or destination of the operand data. In other words, the <code class="literal">type</code> field roughly describes the addressing mode employed to access the operand. Examples of operand types include <code class="literal">o_reg</code>, which means that the operand is the content of a register; <code class="literal">o_mem</code>, which means the operand is a memory address known at compile time; and <code class="literal">o_imm</code>, which means that the operand is immediate data contained within the instruction.<a class="indexterm" id="IDX-CHP-19-0060"/><a class="indexterm" id="IDX-CHP-19-0061"/><a class="indexterm" id="IDX-CHP-19-0062"/></p><p>The <code class="literal">dtype</code> field specifies the size of the operand data. This field should be set to one of the <code class="literal">dt_</code><em class="replaceable"><code>xxx</code></em> values specified in <span class="emphasis"><em>ua.hpp</em></span>. Example values include <code class="literal">dt_byte</code> for 8-bit data, <code class="literal">dt_word</code> for 16-bit data, and <code class="literal">dt_dword</code> for 32-bit data.</p><p>The following x86 instructions demonstrate the correspondence of some of the primary operand datatypes to commonly used operands:</p><a id="I_programlisting5_d1e30909"/><pre class="programlisting">mov  eax, 0x31337          ; o_reg(dt_dword), o_imm(dt_dword)
push word ptr [ebp - 12]   ; o_displ(dt_word)
mov [0x08049130], bl       ; o_mem(dt_byte), o_reg(dt_byte)
movzx eax, ax              ; o_reg(dt_dword), o_reg(dt_word)
ret                        ; o_void(dt_void)</pre><p>The manner in which the various unions within an <code class="literal">op_t</code> are used is dictated by the value of the <code class="literal">type</code> field. For example, when an operand is type <code class="literal">o_imm</code>, the immediate data value should be stored into the <code class="literal">value</code> field, and when the operand type is <code class="literal">o_reg</code>, the register number (from the enumerated set of register constants) should be stored into the <code class="literal">reg</code> field. Complete details on where to store each piece of an instruction are contained in <span class="emphasis"><em>ua.hpp</em></span>.</p><p>Note that none of the fields within an <code class="literal">op_t</code> describe whether the operand is being used as a source or a destination for data. In fact, it is not the analyzer’s job to determine such things. The canonical flags specified in the instruction names array are used in a later stage in the processor to determine exactly how an operand is being used.</p><p>Several of the fields within both the <code class="literal">insn_t</code> class and the <code class="literal">op_t</code> class are described as <span class="emphasis"><em>processor dependent</em></span>, which means that you may use those fields for any purpose you wish. Such fields are often used for storing information that does not fit neatly into one of the other fields within these classes. The processor-dependent fields are also a convenient mechanism for passing information along to later stages of the processor so that those stages do not need to replicate the work of the analyzer.</p><p>With all of the ground rules for an analyzer covered, we can take a stab at crafting a minimal analyzer for Python byte code. Python byte code is very straightforward. Python opcodes are 1 byte long. Opcodes less than 90 have no operands, while opcodes greater than or equal to 90 each have a 2-byte operand. Our basic analyzer is shown here:<a class="indexterm" id="IDX-CHP-19-0063"/><a class="indexterm" id="IDX-CHP-19-0064"/><a class="indexterm" id="IDX-CHP-19-0065"/></p><a id="I_programlisting5_d1e30962"/><pre class="programlisting">#define HAVE_ARGUMENT 90
int idaapi py_ana(void) {
   cmd.itype = ua_next_byte();    //opcodes ARE itypes for us (updates cmd.size)
   if (cmd.itype &gt;= PYTHON_LAST) return 0;             //invalid instruction
   if (Instructions[cmd.itype].name == NULL) return 0; //invalid instruction
   if (cmd.itype &lt; HAVE_ARGUMENT) { //no operands
      cmd.Op1.type = o_void;      //Op1 is a macro for Operand[0] (see ua.hpp)
      cmd.Op1.dtyp = dt_void;
   }
   else {   //instruction must have two bytes worth of operand data
      if (flags[cmd.itype] &amp; (HAS_JREL | HAS_JABS)) {
         cmd.Op1.type = o_near;  //operand refers to a code location
      }
      else {
         cmd.Op1.type = o_mem;   //operand refers to memory (sort of)
      }
      cmd.Op1.offb = 1;          //operand offset is 1 byte into instruction
      cmd.Op1.dtyp = dt_dword;   //No sizes in python so we just pick something

      cmd.Op1.value = ua_next_word(); //fetch the operand word (updates cmd.size)
      cmd.auxpref = flags[cmd.itype]; //save flags for later stages

      if (flags[cmd.itype] &amp; HAS_JREL) {
         //compute relative jump target
         cmd.Op1.addr = cmd.ea + cmd.size + cmd.Op1.value;
      }
      else if (flags[cmd.itype] &amp; HAS_JABS) {
         cmd.Op1.addr = cmd.Op1.value;  //save absolute address
      }
      else if (flags[cmd.itype] &amp; HAS_CALL) {
         //target of call is on the stack in Python, the operand indicates
         //how many arguments are on the stack, save these for later stages
         cmd.Op1.specflag1 = cmd.Op1.value &amp; 0xFF;         //positional parms
         cmd.Op1.specflag2 = (cmd.Op1.value &gt;&gt; 8) &amp; 0xFF;  //keyword parms
      }
   }
   return cmd.size;
}</pre><p>For the Python processor module, we have elected to create an additional array of flags, one per instruction, used to supplement (and in some cases replicate) the canonical features of each instruction. The <code class="literal">HAS_JREL</code>, <code class="literal">HAS_JABS</code>, and <code class="literal">HAS_CALL</code> flags were defined for use in our <code class="literal">flags</code> array. We use these flags to indicate whether an instruction operand represents a relative jump offset, an absolute jump target, or the description of a function call stack, respectively. Explaining every detail of the analysis phase is difficult without descending into the operation of the Python interpreter, so we summarize the analyzer here and through comments in the preceding code, remembering that the analyzer’s job is to dissect a single instruction:<a class="indexterm" id="IDX-CHP-19-0066"/><a class="indexterm" id="IDX-CHP-19-0067"/><a class="indexterm" id="IDX-CHP-19-0068"/><a class="indexterm" id="IDX-CHP-19-0069"/><a class="indexterm" id="IDX-CHP-19-0070"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The analyzer gets the next instruction byte from the instruction stream and determines whether the byte is a valid Python opcode.</p></li><li class="listitem"><p>If the instruction has no operands, <code class="literal">cmd.Operand[0]</code> (<code class="literal">cmd.Op1</code>) is initialized to <code class="literal">o_void</code>.</p></li><li class="listitem"><p>If the command has an operand, <code class="literal">cmd.Operand[0]</code> is initialized to reflect the type of the operand. Several processor-specific fields are used to carry information forward to later stages in the processor module.</p></li><li class="listitem"><p>The length of the instruction is returned to the caller.</p></li></ol></div><p>More sophisticated instruction sets are almost certain to require more complex analyzer stages. Overall, however, any analyzer’s behavior may be generalized as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Read enough bytes from the instruction stream to determine whether the instruction is valid and to map the instruction to one of the enumerated instruction type constants, which is then saved in <code class="literal">cmd.itype</code>. This operation is often performed using a large switch statement to categorize instruction opcodes.</p></li><li class="listitem"><p>Read any additional bytes required to properly determine the number of operands required by the instruction, the addressing modes in use by those operands, and the individual components of each operand (registers and immediate data). This data is used to populate elements of the <code class="literal">cmd.Operands</code> array. This operation may be factored into a separate operand-decoding function.</p></li><li class="listitem"><p>Return the total length of the instruction and its operands.</p></li></ol></div><p>Strictly speaking, once an instruction has been dissected, IDA has enough information to generate an assembly language representation of that instruction. In order to generate cross-references, facilitate the recursive descent process, and monitor the behavior of the program stack pointer, IDA must obtain additional details about the behavior of each instruction. This is the job of the emulator stage of an IDA processor module.</p></div><div class="sect2" title="The Emulator"><div class="titlepage"><div><div><h2 class="title"><a id="the_emulator"/>The Emulator</h2></div></div></div><p>Whereas the analyzer stage is concerned with the structure of a single instruction, the emulator stage is concerned with the behavior of a single instruction. In IDA example processor modules, the emulator is typically implemented by a function named <code class="literal">emu</code> (you may name it anything you like) in a file named <span class="emphasis"><em>emu.cpp</em></span>. Like the <code class="literal">ana</code> function, the prototype for this function is very simple, as shown here:<a class="indexterm" id="IDX-CHP-19-0071"/><a class="indexterm" id="IDX-CHP-19-0072"/><a class="indexterm" id="IDX-CHP-19-0073"/><a class="indexterm" id="IDX-CHP-19-0074"/></p><a id="I_programlisting5_d1e31074"/><pre class="programlisting">int idaapi emu(void); //emulate one instruction</pre><p>According to <span class="emphasis"><em>idp.hpp</em></span>, the <code class="literal">emu</code> function is supposed to return the length of the instruction that was emulated; however, the majority of sample emulators seem to return the value 1.</p><p>You must initialize the <code class="literal">u_emu</code> member of the <code class="literal">LPH</code> object with a pointer to your emulator function. By the time <code class="literal">emu</code> is called, <code class="literal">cmd</code> has been initialized by the analyzer. The emulator’s primary purpose is to create code and data cross-references based on the behavior of the instruction described by <code class="literal">cmd</code>. The emulator is also the place to keep track of any changes to the stack pointer and create local variables based on observed access to a function’s stack frame. Unlike the analyzer, the emulator may change the database.</p><p>Determining whether an instruction results in the creation of any cross-references is typically done by examining the instruction’s canonical features in conjunction with the <code class="literal">type</code> field of the instruction’s operands. A very basic emulator function for an instruction set whose instructions may take up to two operands, which is representative of many of the SDK examples, is shown here:</p><a id="I_programlisting5_d1e31106"/><pre class="programlisting">void TouchArg(op_t &amp;op, int isRead);  //Processor author writes this

int idaapi emu() {
   ulong feature = cmd.get_canon_feature(); //get the instruction's CF_xxx flags

   if (feature &amp; CF_USE1) TouchArg(cmd.Op1, 1);
   if (feature &amp; CF_USE2) TouchArg(cmd.Op2, 1);

   if (feature &amp; CF_CHG1) TouchArg(cmd.Op1, 0);
   if (feature &amp; CF_CHG2) TouchArg(cmd.Op2, 0);

   if ((feature &amp; CF_STOP) == 0) { //instruction doesn't stop
      //add code cross ref to next sequential instruction
      ua_add_cref(0, cmd.ea + cmd.size, fl_F);
   }
   return 1;
}</pre><p>For each instruction operand, the preceding function examines the instruction’s canonical features to determine whether a cross-reference of any kind should be generated. In this example, a function named <code class="literal">TouchArg</code> examines a single operand to determine what type of cross-reference should be generated and handles the details of generating the correct cross-reference. When generating cross-references from your emulator, you should use the cross-reference-creation functions declared in <span class="emphasis"><em>ua.hpp</em></span> rather than in <span class="emphasis"><em>xref.hpp</em></span>. The following rough guidelines may be used in determining what type of cross-references to generate.<a class="indexterm" id="IDX-CHP-19-0075"/><a class="indexterm" id="IDX-CHP-19-0076"/><a class="indexterm" id="IDX-CHP-19-0077"/><a class="indexterm" id="IDX-CHP-19-0078"/><a class="indexterm" id="IDX-CHP-19-0079"/><a class="indexterm" id="IDX-CHP-19-0080"/><a class="indexterm" id="IDX-CHP-19-0081"/><a class="indexterm" id="IDX-CHP-19-0082"/><a class="indexterm" id="IDX-CHP-19-0083"/><a class="indexterm" id="IDX-CHP-19-0084"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the operand type is <code class="literal">o_imm</code>, the operation is a read (<code class="literal">isRead</code> is true), and the operand value is a pointer, create an offset reference. Determine whether an operand is a pointer by calling the <code class="literal">isOff</code> function, for example, <code class="literal">isOff(uFlag, op.n)</code>. Add an offset cross-reference using <code class="literal">ua_add_off_drefs</code>, for example, <code class="literal">ua_add_off_drefs(op, dr_O);</code>.</p></li><li class="listitem"><p>If the operand type is <code class="literal">o_displ</code> and the operand value is a pointer, create an offset cross-reference with a read or write cross-reference type as appropriate, for example, <code class="literal">ua_add_off_drefs(op, isRead ? dr_R : dr_W);</code>.</p></li><li class="listitem"><p>If the operand type is <code class="literal">o_mem</code>, add a data cross-reference with a read or write cross-reference type as appropriate using <code class="literal">ua_add_dref</code>, for example, <code class="literal">ua_add_dref(op.offb, op.addr, isRead ? dr_R : dr_W);</code>.</p></li><li class="listitem"><p>If the operand type is <code class="literal">o_near</code>, add a code cross-reference with a jump or call cross-reference type as appropriate using <code class="literal">ua_add_cref</code>, for example, <code class="literal">ua_add_cref(op.offb, op.addr, feature &amp; CF_CALL ? fl_CN : fl_JN);</code>.</p></li></ul></div><p>The emulator is also responsible for reporting on the behavior of the stack pointer register. The emulator should use the <code class="literal">add_auto_stkpnt2</code> function to inform IDA that an instruction changed the value of the stack pointer. The prototype for <code class="literal">add_auto_stkpnt2</code> is shown here:</p><a id="I_programlisting5_d1e31214"/><pre class="programlisting">bool add_auto_stkpnt2(func_t *pfn, ea_t ea, sval_t delta);</pre><p>The <code class="literal">pfn</code> pointer should point to the function that contains the address being emulated. If <code class="literal">pfn</code> is NULL, it will be automatically determined by IDA. The <code class="literal">ea</code> parameter should specify the end address (typically <code class="literal">cmd.ea + cmd.size</code>) for the instruction that changes the stack pointer. The <code class="literal">delta</code> parameter is used to specify the number of bytes by which the stack pointer grows or shrinks. Use negative deltas when the stack is growing (such as after a <code class="literal">push</code> instruction) and positive deltas when the stack is shrinking (such as after a <code class="literal">pop</code> instruction). A simple 4-byte adjustment to the stack pointer in conjunction with a <code class="literal">push</code> operation might be emulated as follows:<a class="indexterm" id="IDX-CHP-19-0085"/><a class="indexterm" id="IDX-CHP-19-0086"/><a class="indexterm" id="IDX-CHP-19-0087"/></p><a id="I_programlisting5_d1e31253"/><pre class="programlisting">if (cmd.itype == X86_push) {
   add_auto_stkpnt2(NULL, cmd.ea + cmd.size, −4);
}</pre><p>In order to maintain an accurate record of stack pointer behavior, the emulator should be able to recognize and emulate all instructions that change the stack pointer, not just the simple <code class="literal">push</code> and <code class="literal">pop</code> cases. A more complex example of tracking the stack pointer occurs when a function allocates its local variables by subtracting a constant value from the stack pointer. This case is illustrated here:<a class="indexterm" id="IDX-CHP-19-0088"/></p><a id="I_programlisting5_d1e31266"/><pre class="programlisting">//handle cases such as:  sub  esp, 48h
if (cmd.itype == X86_sub &amp;&amp; cmd.Op1.type == o_reg
    &amp;&amp; cmd.Op1.reg == r_esp &amp;&amp; cmd.Op2.type == o_imm) {
   add_auto_stkpnt2(NULL, cmd.ea + cmd.size, -cmd.Op2.value);
}</pre><p>Because CPU architectures vary significantly from one CPU to another, it is not possible for IDA (or any other program for that matter) to account for every possible way that an operand may be formed or every way that an instruction may reference other instructions or data. As a result, there is no precise cookbook recipe for building your emulator module. Reading through existing processor module source code along with a lot of trial and error may be required before your emulator does everything you want it to do.</p><p>The emulator for our example Python processor is shown here:</p><a id="I_programlisting5_d1e31272"/><pre class="programlisting">int idaapi py_emu(void) {
   //We can only resolve target addresses for relative jumps
   if (cmd.auxpref &amp; HAS_JREL) { //test the flags set by the analyzer
      ua_add_cref(cmd.Op1.offb, cmd.Op1.addr, fl_JN);
   }
   //Add the sequential flow as long as CF_STOP is not set
   if((cmd.get_canon_feature() &amp; CF_STOP) == 0) {
      //cmd.ea + cmd.size computes the address of the next instruction
      ua_add_cref(0, cmd.ea + cmd.size, fl_F);
   }
   return 1;
}</pre><p>Again, owing to the architecture of the Python interpreter, we are severely limited in the types of cross-references that we can generate. In Python byte code, there is no concept of a memory address for data items, and the absolute address of each instruction can be determined only by parsing metainformation contained in the compiled Python (<span class="emphasis"><em>.pyc</em></span>) file. Data items are either stored in tables and referenced by index values or they are stored on the program stack, where they cannot be directly referenced. Here again, while we can directly read data item index values from instruction operands, we cannot know the structure of the tables that hold the data unless we have parsed additional metainformation contained in the <span class="emphasis"><em>.pyc</em></span> file. In our processor, we can compute only the target of relative jump instructions and the address of the next instruction because they are located relative to the current instruction address. The fact that our processor can provide a better disassembly only if it has a more detailed understanding of the file structure is a limitation that we discuss in <a class="xref" href="ch19s06.html" title="Processor Module Architecture">Processor Module Architecture</a> in <a class="xref" href="ch19s06.html" title="Processor Module Architecture">Processor Module Architecture</a>.</p><p>For similar reasons, we have elected not to track the stack pointer’s behavior in our Python processor. This is primarily because IDA treats stack pointer changes as relevant only when those changes are made within the confines of a function and we have no means at present for recognizing function boundaries within Python code. If we were to implement stack-pointer tracking, it would be wise to remember that, as a stack-based architecture, virtually every Python instruction modifies the stack in some way. In this case, to simplify the process of determining how much the stack pointer is changed by each instruction, it might be easier to define an array of values, one per Python instruction, that contains the amount by which each instruction modifies the stack. These amounts would then be used in calls to <code class="literal">add_auto_stkpnt2</code> each time an instruction is emulated.<a class="indexterm" id="IDX-CHP-19-0089"/><a class="indexterm" id="IDX-CHP-19-0090"/><a class="indexterm" id="IDX-CHP-19-0091"/><a class="indexterm" id="IDX-CHP-19-0092"/><a class="indexterm" id="IDX-CHP-19-0093"/><a class="indexterm" id="IDX-CHP-19-0094"/><a class="indexterm" id="IDX-CHP-19-0095"/><a class="indexterm" id="IDX-CHP-19-0096"/><a class="indexterm" id="IDX-CHP-19-0097"/><a class="indexterm" id="IDX-CHP-19-0098"/><a class="indexterm" id="IDX-CHP-19-0099"/><a class="indexterm" id="IDX-CHP-19-0100"/></p><p>Once the emulator has added all of the cross-references that it can and made any other modifications to the database that it deems necessary, you are ready to start generating output. In the following section, we discuss the role of the outputter in generating IDA’s disassembly display.</p></div><div class="sect2" title="The Outputter"><div class="titlepage"><div><div><h2 class="title"><a id="the_outputter"/>The Outputter</h2></div></div></div><p>The purpose of the outputter is to output a single disassembled instruction, as specified by the <code class="literal">cmd</code> global variable, to the IDA display. In IDA processor modules, the outputter is typically implemented by a function named <code class="literal">out</code> (you may name it anything you like) in a file named <span class="emphasis"><em>out.cpp</em></span>. Like the <code class="literal">ana</code> and <code class="literal">emu</code> functions, the prototype for this function is very simple, as shown here:</p><a id="I_programlisting5_d1e31358"/><pre class="programlisting">void idaapi out(void); //output a single disassembled instruction</pre><p>You must initialize the <code class="literal">u_out</code> member of the <code class="literal">LPH</code> object with a pointer to your output function. By the time <code class="literal">out</code> is called, <code class="literal">cmd</code> has been initialized by the analyzer. Your output function should not make any changes to the database. You are also required to create a helper function whose sole purpose is to format and output a single instruction operand. This function is typically named <code class="literal">outop</code> and is pointed to by the <code class="literal">u_outop</code> member of <code class="literal">LPH</code>. Your <code class="literal">out</code> function should not call <code class="literal">outop</code> directly. Instead, you should call <code class="literal">out_one_operand</code> each time you need to print an operand portion of your disassembly lines. Data output operations are handled by a separate function typically named <em class="replaceable"><code>cpu</code></em><code class="literal">_data</code> and specified by the <code class="literal">d_out</code> member field of the <code class="literal">LPH</code> object. In our Python processor, this function is named <code class="literal">python_data</code>.</p><p>Output lines in a disassembly listing are composed of several components, such as a prefix, a name label, a mnemonic, operands, and possibly a comment. The IDA kernel retains responsibility for rendering some of these components (such as prefixes, comments, and cross-references), while others are the responsibility of the processor’s outputter. Several useful functions for generating pieces of an output line are declared in <span class="emphasis"><em>ua.hpp</em></span> under the following heading:</p><a id="I_programlisting5_d1e31413"/><pre class="programlisting">//--------------------------------------------------------------------------
//      I D P   H E L P E R   F U N C T I O N S  -  O U T P U T
//--------------------------------------------------------------------------</pre><p>Colorizing portions of each output line is possible through the use of functions that insert special color tags into your output buffers. Additional functions for generating output lines may be found in <span class="emphasis"><em>lines.hpp</em></span>.<a class="indexterm" id="IDX-CHP-19-0101"/><a class="indexterm" id="IDX-CHP-19-0102"/><a class="indexterm" id="IDX-CHP-19-0103"/><a class="indexterm" id="IDX-CHP-19-0104"/><a class="indexterm" id="IDX-CHP-19-0105"/><a class="indexterm" id="IDX-CHP-19-0106"/><a class="indexterm" id="IDX-CHP-19-0107"/><a class="indexterm" id="IDX-CHP-19-0108"/></p><p>Rather than use a console-style output model in which you write content directly to the IDA display, IDA utilizes a buffer-based output scheme in which you must write a single line of display text into a character buffer and then ask IDA to display your buffer. The basic process for generating an output line follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Call <code class="literal">init_output_buffer(char *buf, size_t bufsize)</code> (declared in <span class="emphasis"><em>ua.hpp</em></span>) to initialize your output buffer.</p></li><li class="listitem"><p>Utilize the buffer output functions in <span class="emphasis"><em>ua.hpp</em></span> to generate a single line of content by adding to the initialized buffer. Most of these functions automatically write to the destination buffer specified in the previous step, so there is often no need to explicitly pass a buffer into these functions. These functions are typically named <code class="literal">out_</code><em class="replaceable"><code>xxx</code></em> or <code class="literal">Out</code><em class="replaceable"><code>Xxx</code></em>.</p></li><li class="listitem"><p>Call <code class="literal">term_output_buffer()</code> to finalize your output buffer, making it ready to send to the IDA kernel for display.</p></li><li class="listitem"><p>Send the output buffer to the kernel using either <code class="literal">MakeLine</code> or <code class="literal">printf_line</code> (both declared in <span class="emphasis"><em>lines.hpp</em></span>).</p></li></ol></div><p>Note that <code class="literal">init_output_buffer</code>, <code class="literal">term_output_buffer</code>, and <code class="literal">MakeLine</code> are usually called only within your <code class="literal">out</code> function. Your <code class="literal">outop</code> function typically makes use of the current output buffer as initialized by <code class="literal">out</code> and usually has no need to initialize its own output buffers.</p><p>Strictly speaking, you can skip all of the buffer manipulation described in the first four steps of the preceding list and go straight to calling <code class="literal">MakeLine</code> as long as you don’t mind taking complete control of the buffer-generation process and passing up the convenience functions offered in <span class="emphasis"><em>ua.hpp</em></span>. In addition to assuming a default destination for generated output (as specified via <code class="literal">init_out_buffer</code>), many of the convenience functions automatically work with the current contents of the <code class="literal">cmd</code> variable. Some of the more useful convenience functions from <span class="emphasis"><em>ua.hpp</em></span> are described here:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>OutMnem(int width, char *suffix)</code></strong></span></dt><dd><p>Outputs the mnemonic that corresponds to <code class="literal">cmd.itype</code> in a field of at least <code class="literal">width</code> characters, appending the specified suffix. At least one space is printed after the mnemonic. The default width is 8, and the default suffix is NULL. An example of the use of the suffix value might be for operand size modifiers, as in the following x86 mnemonics: <code class="literal">movsb</code>, <code class="literal">movsw</code>, <code class="literal">movsd</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>out_one_operand(int n)</code></strong></span></dt><dd><p>Invokes your processor’s <code class="literal">outop</code> function to print <code class="literal">cmd.Operands[n]</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>out_snprintf(const char *format, ...)</code></strong></span></dt><dd><p>Appends formatted text to the current output buffer.</p></dd><dt><span class="term"><strong class="userinput"><code>OutValue(op_t &amp;op, int outflags)</code></strong></span></dt><dd><p>Outputs constant fields of an operand. This function outputs <code class="literal">op.value</code> or <code class="literal">op.addr</code>, depending on the value of <code class="literal">outflags</code>. See <span class="emphasis"><em>ua.hpp</em></span> for the meaning of <code class="literal">outflags</code>, which defaults to 0. This function is meant to be called from within <code class="literal">outop</code>.<a class="indexterm" id="IDX-CHP-19-0109"/><a class="indexterm" id="IDX-CHP-19-0110"/><a class="indexterm" id="IDX-CHP-19-0111"/><a class="indexterm" id="IDX-CHP-19-0112"/><a class="indexterm" id="IDX-CHP-19-0113"/><a class="indexterm" id="IDX-CHP-19-0114"/><a class="indexterm" id="IDX-CHP-19-0115"/><a class="indexterm" id="IDX-CHP-19-0116"/><a class="indexterm" id="IDX-CHP-19-0117"/><a class="indexterm" id="IDX-CHP-19-0118"/></p></dd><dt><span class="term"><strong class="userinput"><code>out_symbol(char c)</code></strong></span></dt><dd><p>Outputs the given character using the current color for punctuation (<code class="literal">COLOR_SYMBOL</code> as defined in <span class="emphasis"><em>lines.hpp</em></span>). This function is primarily used for outputting the syntactic elements within operands (thus called from <code class="literal">outop</code>), such as commas and brackets.</p></dd><dt><span class="term"><strong class="userinput"><code>out_line(char *str, color_t color)</code></strong></span></dt><dd><p>Appends the given string, in the given <code class="literal">color</code>, to the current output buffer. Colors are defined in <span class="emphasis"><em>lines.hpp</em></span>. Note that this function does not output a line at all. A better name for this function might be <code class="literal">out_str</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>OutLine(char *str)</code></strong></span></dt><dd><p>Same as <code class="literal">out_line</code> but without the use of color.</p></dd><dt><span class="term"><strong class="userinput"><code>out_register(char *str)</code></strong></span></dt><dd><p>Outputs the given string using the current color for registers (<code class="literal">COLOR_REG</code>).</p></dd><dt><span class="term"><strong class="userinput"><code>out_tagon(color_t tag)</code></strong></span></dt><dd><p>Inserts a <span class="emphasis"><em>turn color on</em></span> tag into the output buffer. Subsequent output to the buffer will be displayed in the given color until a <span class="emphasis"><em>turn color off</em></span> tag is encountered.</p></dd><dt><span class="term"><strong class="userinput"><code>out_tagoff(color_t tag)</code></strong></span></dt><dd><p>Inserts a <span class="emphasis"><em>turn color off</em></span> tag into the output buffer.</p></dd></dl></div><p>Please refer to <span class="emphasis"><em>ua.hpp</em></span> for additional output functions that may be of use in building your outputter.</p><p>One output capability that is missing from <span class="emphasis"><em>ua.hpp</em></span> is the ability to easily output a register name. During the analysis phase, register numbers are stored into an operand’s <code class="literal">reg</code> or <code class="literal">phrase</code> field, depending on the addressing mode used for that operand. Since many operands make use of registers, it would be nice to have a function that quickly outputs a register string given a register number. The following function provides a minimal capability to do so:</p><a id="I_programlisting5_d1e31720"/><pre class="programlisting">//with the following we can do things like: OutReg(op.reg);
void OutReg(int regnum) {
   out_register(ph.regNames[regnum]);  //use regnum to index register names array
}</pre><p>IDA calls your <code class="literal">out</code> function only as needed, when an address comes into view in one of the IDA displays or when portions of a line are reformatted. Each time <code class="literal">out</code> is called, it is expected to output as many lines as are necessary to represent the instruction described in the <code class="literal">cmd</code> global variable. In order to do this, <code class="literal">out</code> will generally make one or more calls to <code class="literal">MakeLine</code> (or <code class="literal">printf_line</code>). In most cases one line (and hence one call to <code class="literal">MakeLine</code>) will be sufficient. When more than one line is required to describe an instruction, you should never add carriage returns to your output buffers in an attempt to generate several lines at once. Instead, you should make multiple calls to <code class="literal">MakeLine</code> to output each individual line. The prototype for <code class="literal">MakeLine</code> is shown here:<a class="indexterm" id="IDX-CHP-19-0119"/><a class="indexterm" id="IDX-CHP-19-0120"/><a class="indexterm" id="IDX-CHP-19-0121"/><a class="indexterm" id="IDX-CHP-19-0122"/><a class="indexterm" id="IDX-CHP-19-0123"/></p><a id="I_programlisting5_d1e31768"/><pre class="programlisting">bool MakeLine(const char *contents, int indent = −1);</pre><p>An <code class="literal">indent</code> value of −1 requests default indentation, which is the current value of <code class="literal">inf.indent</code> as specified in the Disassembly section of the Options ▸ General dialog. The <code class="literal">indent</code> parameter has additional meaning when an instruction (or data) spans several lines in the disassembly. In a multiline instruction, an indent of −1 designates a line as the most important line for that instruction. Please refer to the comments for the <code class="literal">printf_line</code> function in <span class="emphasis"><em>lines.hpp</em></span> for more information on using <code class="literal">indent</code> in this manner.</p><p>Up to this point, we have avoided discussion of comments. Like names and cross-references, comments are handled by the IDA kernel. However, you are afforded some control over which line of a multiline instruction the comment is displayed on. The display of comments is controlled to some extent by a global variable named <code class="literal">gl_comm</code>, which is declared in <span class="emphasis"><em>lines.hpp</em></span>. The most important thing to understand about <code class="literal">gl_comm</code> is that comments cannot be displayed at all unless <code class="literal">gl_comm</code> is set to 1. If <code class="literal">gl_comm</code> is 0, then a comment will not be displayed at the end of the output you have generated, even if the user has entered one and comments are enabled in the Options ▸ General settings. The trouble is, <code class="literal">gl_comm</code> defaults to 0, so you need to make sure that you set it to 1 at some point if you ever expect users to see comments while using your processor module. When your <code class="literal">out</code> function generates multiple lines, you need to control <code class="literal">gl_comm</code> if you want any user-entered comments to be displayed on anything other than your first line of output.</p><p>With the highlights of building an outputter under our belts, here is the <code class="literal">out</code> function for our example Python processor:</p><a id="I_programlisting5_d1e31823"/><pre class="programlisting">void py_out(void) {
   char str[MAXSTR];  //MAXSTR is an IDA define from pro.h
   init_output_buffer(str, sizeof(str));
   OutMnem(12);       //first we output the mnemonic
   if(cmd.Op1.type != o_void) {  //then there is an argument to print
      out_one_operand(0);
   }
   term_output_buffer();
   gl_comm = 1;      //we want comments!
   MakeLine(str);    //output the line with default indentation
}</pre><p>The function works its way through the components of a disassembled line in a very simple fashion. If Python instructions could take two operands, we might use <code class="literal">out_symbol</code> to output a comma and then call <code class="literal">out_one_operand</code> a second time to output the second operand. In most cases, your <code class="literal">outop</code> function will be somewhat more complex than your <code class="literal">out</code> function, as the structure of an operand is generally more complex than the high-level structure of an instruction. A typical approach for implementing the <code class="literal">outop</code> function is to use a switch statement to test the value of the operand’s <code class="literal">type</code> field and format the operand accordingly.<a class="indexterm" id="IDX-CHP-19-0124"/><a class="indexterm" id="IDX-CHP-19-0125"/><a class="indexterm" id="IDX-CHP-19-0126"/></p><p>In our Python example, we are forced to use a very simple <code class="literal">outop</code> function, because in most cases we lack the information required to translate the integer operands into anything more intelligible. Our implementation is shown here, with special handling for comparisons and relative jumps only:</p><a id="I_programlisting5_d1e31861"/><pre class="programlisting">char *compare_ops[] = {
    "&lt;", "&lt;=", "==", "!=", "&gt;", "&gt;=",
    "in", "not in", "is", "is not", "exception match"
};

bool idaapi py_outop(op_t&amp; x) {
   if (cmd.itype == COMPARE_OP) {
      //For comparisons, the argument indicates the type of comparison to be
      //performed.  Print a symbolic representation of the comparison rather
      //than a number.
      if (x.value &lt; qnumber(compare_ops)) {
         OutLine(compare_ops[x.value]);
      }
      else {
         OutLine("BAD OPERAND");
      }
   }
   else if (cmd.auxpref &amp; HAS_JREL) {
      //we don't test for x.type == o_near here because we need to distinguish
      //between relative jumps and absolute jumps.  In our case, HAS_JREL
      //implies o_near
      out_name_expr(x, x.addr, x.addr);
   }
   else {  //otherwise just print the operand value
      OutValue(x);
   }
   return true;
}</pre><p>In addition to disassembled instructions, a disassembly listing usually contains bytes that should be represented as data. In the output stage, data display is handled by the <code class="literal">d_out</code> member of the <code class="literal">LPH</code> object. The kernel calls the <code class="literal">d_out</code> function to display any bytes that are not part of an instruction, whether the datatype of those bytes is unknown or whether the bytes have been formatted as data by the user or the emulator. The prototype for <code class="literal">d_out</code> is shown here:</p><a id="I_programlisting5_d1e31877"/><pre class="programlisting">void idaapi d_out(ea_t ea);   //format data at the specified address</pre><p>The <code class="literal">d_out</code> function should examine the flags associated with the address specified by the <code class="literal">ea</code> parameter and generate an appropriate representation of the data in the style of the assembly language being generated. This function must be specified for all processor modules. A bare-bones implementation is offered by the SDK in the form of the <code class="literal">intel_data</code> function, but it is unlikely to meet your specific needs. In our Python example, we actually have very little need to format static data because we don’t have the means to locate it. For the sake of example, we make use of the function shown here:<a class="indexterm" id="IDX-CHP-19-0127"/><a class="indexterm" id="IDX-CHP-19-0128"/><a class="indexterm" id="IDX-CHP-19-0129"/><a class="indexterm" id="IDX-CHP-19-0130"/><a class="indexterm" id="IDX-CHP-19-0131"/></p><a id="I_programlisting5_d1e31906"/><pre class="programlisting">void idaapi python_data(ea_t ea) {
   char obuf[256];
   init_output_buffer(obuf, sizeof(obuf));
   flags_t flags = get_flags_novalue(ea);  //get the flags for address ea
   if (isWord(flags)) {  //output a word declaration
      out_snprintf("%s %xh", ash.a_word ? ash.a_word : "", get_word(ea));
   }
   else if (isDwrd(flags)) {  //output a dword declaration
      out_snprintf("%s %xh", ash.a_dword ? ash.a_dword : "", get_long(ea));
   }
   else { //we default to byte declarations in all other cases
      int val = get_byte(ea);
      char ch = ' ';
      if (val &gt;= 0x20 &amp;&amp; val &lt;= 0x7E) {
         ch = val;
      }
      out_snprintf("%s %02xh   ; %c", ash.a_byte ? ash.a_byte : "", val, ch);
   }
   term_output_buffer();
   gl_comm = 1;
   MakeLine(obuf);
}</pre><p>Functions for accessing and testing the flags associated with any address in the database are available in <span class="emphasis"><em>bytes.hpp</em></span>. In this example, the flags are tested to determine whether the address represents word or dword data, and appropriate output is generated using the appropriate data declaration keyword from the current assembler module. The global variable <code class="literal">ash</code> is an instance of an <code class="literal">asm_t</code> struct that describes characteristics of the assembler syntax that is being utilized in the disassembly. We would need significantly more logic in order to generate more complex data displays, such as arrays.</p></div><div class="sect2" title="Processor Notifications"><div class="titlepage"><div><div><h2 class="title"><a id="processor_notifications"/>Processor Notifications</h2></div></div></div><p>In <a class="xref" href="ch17.html" title="Chapter 17. The IDA Plug-in Architecture">Chapter 17</a>, we discussed the ability of plug-ins to hook various notification messages using the <code class="literal">hook_to_notification_point</code> function. By hooking notifications, plug-ins could be informed of various actions taking place within the database. The concept of notification messages exists for processor modules as well, but processor notifications are implemented in a slightly different manner than plug-in notifications.<a class="indexterm" id="IDX-CHP-19-0132"/><a class="indexterm" id="IDX-CHP-19-0133"/></p><p>All processor modules should set a pointer to a notification function in the <code class="literal">LPH</code> object’s <code class="literal">notify</code> field. The prototype for <code class="literal">notify</code> is shown here:</p><a id="I_programlisting5_d1e31954"/><pre class="programlisting">int idaapi notify(idp_notify msgid, ...);  //notify processor with a given msg</pre><p>The <code class="literal">notify</code> function is a variable-arguments function that receives a notification code and a variable list of arguments specific to that notification code. The complete list of available processor notification codes may be found in <span class="emphasis"><em>idp.hpp</em></span>. Notification messages exist for simple actions such as loading (<code class="literal">init</code>) and unloading (<code class="literal">term</code>) the processor to more complex notifications that code or data is being created, functions are being added or deleted, or segments are being added or deleted. The list of parameters supplied with each notification code is also specified in <span class="emphasis"><em>idp.hpp</em></span>. Before looking at an example of a <code class="literal">notify</code> function, it is worth noting the following comments found only in some of the SDK’s sample processor modules:<a class="indexterm" id="IDX-CHP-19-0134"/><a class="indexterm" id="IDX-CHP-19-0135"/><a class="indexterm" id="IDX-CHP-19-0136"/><a class="indexterm" id="IDX-CHP-19-0137"/></p><a id="I_programlisting5_d1e31989"/><pre class="programlisting">// A well-behaving processor module should call invoke_callbacks()
// in its notify() function. If invoke_callbacks function returns 0,
// then the processor module should process the notification itself.
// Otherwise the code should be returned to the caller.</pre><p>In order to ensure that all modules that have hooked processor notifications are properly notified, the <code class="literal">invoke_callbacks</code> function should be called. This causes the kernel to propagate the given notification message to all registered callbacks. The <code class="literal">notify</code> function used in our Python processor is shown here:</p><a id="I_programlisting5_d1e31999"/><pre class="programlisting">static int idaapi notify(processor_t::idp_notify msgid, ...) {
   va_list va;
   va_start(va, msgid);   //setup args list
   int result = invoke_callbacks(HT_IDP, msgid, va);
   if (result == 0) {
      result = 1;             //default success
      switch(msgid) {
         case processor_t::init:
            inf.mf = 0;       //ensure little endian!
            break;
         case processor_t::make_data: {
            ea_t ea = va_arg(va, ea_t);
            flags_t flags = va_arg(va, flags_t);
            tid_t tid = va_arg(va, tid_t);
            asize_t len = va_arg(va, asize_t);
            if (len &gt; 4) { //our d_out can only handle byte, word, dword
               result = 0; //disallow big data
            }
            break;
         }
      }
   }
   va_end(va);
   return result;
}</pre><p>This <code class="literal">notify</code> function handles only two notification codes: <code class="literal">init</code> and <code class="literal">make_data</code>. The <code class="literal">init</code> notification is handled in order to explicitly force the kernel to treat data as little-endian. The <code class="literal">inf.mf</code> (most first) flag indicates the endianness value in use by the kernel (0 for little and 1 for big). The <code class="literal">make_data</code> notification is sent whenever an attempt is made to convert bytes to data. In our case, the <code class="literal">d_out</code> function is capable of dealing with only byte, word, and dword data, so the function tests the size of the data being created and disallows anything larger than 4 bytes.<a class="indexterm" id="IDX-CHP-19-0138"/><a class="indexterm" id="IDX-CHP-19-0139"/><a class="indexterm" id="IDX-CHP-19-0140"/><a class="indexterm" id="IDX-CHP-19-0141"/><a class="indexterm" id="IDX-CHP-19-0142"/><a class="indexterm" id="IDX-CHP-19-0143"/><a class="indexterm" id="IDX-CHP-19-0144"/><a class="indexterm" id="IDX-CHP-19-0145"/><a class="indexterm" id="IDX-CHP-19-0146"/><a class="indexterm" id="IDX-CHP-19-0147"/><a class="indexterm" id="IDX-CHP-19-0148"/><a class="indexterm" id="IDX-CHP-19-0149"/><a class="indexterm" id="IDX-CHP-19-0150"/><a class="indexterm" id="IDX-CHP-19-0151"/><a class="indexterm" id="IDX-CHP-19-0152"/><a class="indexterm" id="IDX-CHP-19-0153"/><a class="indexterm" id="IDX-CHP-19-0154"/><a class="indexterm" id="IDX-CHP-19-0155"/><a class="indexterm" id="IDX-CHP-19-0156"/></p></div><div class="sect2" title="Other processor_t Members"><div class="titlepage"><div><div><h2 class="title"><a id="other_processor_underscore_t_members"/>Other processor_t Members</h2></div></div></div><p>In order to wind up the discussion on creating processor modules, we need to at least touch on several additional fields in the <code class="literal">LPH</code> object. As mentioned previously, there are a tremendous number of function pointers within this structure. If you read through the definition of the <code class="literal">processor_t</code> struct in <span class="emphasis"><em>idp.hpp</em></span>, it is clear in some cases that you can safely set some function pointers to NULL, and the kernel will not call them. It seems reasonable to assume that you are required to provide implementations for all of the other functions required by <code class="literal">processor_t</code>. As a general rule of thumb, you can often get away with an empty stub function when you are at a loss as to what you should do. In our Python processor, where it was not clear that NULL was a valid value, we initialized function pointers as follows (refer to <span class="emphasis"><em>idp.hpp</em></span> for the behavior of each function):</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>header</code></strong> Points to empty function in example.</td></tr><tr><td><strong class="userinput"><code>footer</code></strong> Points to empty function in example.</td></tr><tr><td><strong class="userinput"><code>segstart</code></strong> Points to empty function in example.</td></tr><tr><td><strong class="userinput"><code>segend</code></strong> Points to empty function in example.</td></tr><tr><td><strong class="userinput"><code>is_far_jump</code></strong> Is set to NULL in example.</td></tr><tr><td><strong class="userinput"><code>translate</code></strong> Is set to NULL in example.</td></tr><tr><td><strong class="userinput"><code>realcvt</code></strong> Points to <code class="literal">ieee_realcvt</code> from <span class="emphasis"><em>ieee.h</em></span>.</td></tr><tr><td><strong class="userinput"><code>is_switch</code></strong> Is set to NULL in example.</td></tr><tr><td><strong class="userinput"><code>extract_address</code></strong> Points to a function that returns (BADADDR−1) in example.</td></tr><tr><td><strong class="userinput"><code>is_sp_based</code></strong> Is set to NULL in example.</td></tr><tr><td><strong class="userinput"><code>create_func_frame</code></strong> Is set to NULL in example.</td></tr><tr><td><strong class="userinput"><code>get_frame_retsize</code></strong> Is set to NULL in example.</td></tr><tr><td><strong class="userinput"><code>u_outspec</code></strong> Is set to NULL in example.</td></tr><tr><td><strong class="userinput"><code>set_idp_options</code></strong> Is set to NULL in example.</td></tr></table><p>In addition to these function pointers, the following three data members are worth mentioning:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>shnames</code></strong> A NULL-terminated array of character pointers that point to short names (fewer than nine characters) associated with the processor (such as <span class="emphasis"><em>python</em></span>). Terminate this array with a NULL pointer.</td></tr><tr><td><strong class="userinput"><code>lnames</code></strong> A NULL-terminated array of character pointers that point to long names associated with the processor (such as <span class="emphasis"><em>Python 2.4 byte code</em></span>). This array should contain the same number of elements as the <code class="literal">shnames</code> array.</td></tr><tr><td><strong class="userinput"><code>asms</code></strong> NULL-terminated array of pointers to target assembler (<code class="literal">asm_t</code>) structs.</td></tr></table><p>The <code class="literal">shnames</code> and <code class="literal">lnames</code> arrays specify the names of all processor types that can be handled by the current processor module. Users may select alternate processors on the Analysis tab of the Options ▸ General dialog, as shown in <a class="xref" href="ch19s03.html#selecting_alternate_processors_and_assem" title="Figure 19-1. Selecting alternate processors and assemblers">Figure 19-1</a>.<a class="indexterm" id="IDX-CHP-19-0157"/><a class="indexterm" id="IDX-CHP-19-0158"/><a class="indexterm" id="IDX-CHP-19-0159"/><a class="indexterm" id="IDX-CHP-19-0160"/></p><p>Processor modules that support multiple processors should process the <code class="literal">processor_t.newprc</code> notification in order to be informed of processor changes.</p><div class="figure"><a id="selecting_alternate_processors_and_assem"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e32236"/><img alt="Selecting alternate processors and assemblers" src="httpatomoreillycomsourcenostarchimages854310.png.jpg"/></div></div><p class="title">Figure 19-1. Selecting alternate processors and assemblers</p></div><p>The <code class="literal">asm_t</code> structure is used to describe some of the syntactic elements of an assembly language, such as the format of hexadecimal numbers, strings, and character delimiters, as well as various keywords commonly used in assembly languages. The intent of the <code class="literal">asms</code> field is to allow several different styles of assembly language to be generated by a single processor module. Processor modules that support multiple assemblers should process the <code class="literal">processor_t.newasm</code> notification in order to be notified of processor changes.<a class="indexterm" id="IDX-CHP-19-0161"/><a class="indexterm" id="IDX-CHP-19-0162"/></p><p>Ultimately, the completed version of our simple Python processor is capable of generating code such as the following:</p><a id="I_programlisting5_d1e32262"/><pre class="programlisting">ROM:00156                 LOAD_CONST 12
ROM:00159                 COMPARE_OP ==
ROM:00162                 JUMP_IF_FALSE loc_182
ROM:00165                 POP_TOP
ROM:00166                 LOAD_NAME 4
ROM:00169                 LOAD_ATTR 10
ROM:00172                 LOAD_NAME 5
ROM:00175                 CALL_FUNCTION 1
ROM:00178                 POP_TOP
ROM:00179                 JUMP_FORWARD loc_183
ROM:00182 # ----------------------------------------------------------
ROM:00182 loc_182:                           # CODE XREF: ROM:00162j
ROM:00182                 POP_TOP
ROM:00183
ROM:00183 loc_183:                           # CODE XREF: ROM:00179j
ROM:00183                 LOAD_CONST 0
ROM:00186                 RETURN_VALUE</pre><p>While it is possible to generate Python disassemblies that reveal far more information than this, they require far greater knowledge of the <span class="emphasis"><em>.pyc</em></span> file format than was assumed for this example. A somewhat more fully featured Python processor module is available on the book’s website.<a class="indexterm" id="IDX-CHP-19-0163"/><a class="indexterm" id="IDX-CHP-19-0164"/><a class="indexterm" id="IDX-CHP-19-0165"/></p></div></div>
<div class="sect1" title="Building Processor Modules"><div class="titlepage"><div><div><h1 class="title"><a id="building_processor_modules"/>Building Processor Modules</h1></div></div></div><p>The process for building and installing an IDA processor module is very similar to the process for building plug-ins and loaders, with one major difference that, if not followed, can result in the inability of IDA to utilize your processor. Some minor differences in the build process include these:<a class="indexterm" id="IDX-CHP-19-0166"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>File extensions for processors are <span class="emphasis"><em>.w32/.w64</em></span> on Windows, <span class="emphasis"><em>.ilx/ilx64</em></span> on Linux, and <em class="replaceable"><code>.imc/.imc64</code></em> on OS X platforms.</p></li><li class="listitem"><p>The build scripts for the SDK’s example processors (as well as our own) store newly created processor binaries into <span class="emphasis"><em>&lt;SDKDIR&gt;/bin/procs</em></span>.</p></li><li class="listitem"><p>Processor modules are installed by copying the compiled processor binary to <span class="emphasis"><em>&lt;IDADIR&gt;/procs</em></span>.</p></li><li class="listitem"><p>Windows processor modules are required to use a customized MS-DOS stub<sup>[<a class="footnote" href="#ftn.CHP-19-FN-4" id="CHP-19-FN-4">138</a>]</sup> supplied with the SDK.<a class="indexterm" id="IDX-CHP-19-0167"/></p></li><li class="listitem"><p>Windows-based processor modules require a custom postprocessing step not required by plug-ins and loaders. The purpose of this step is to insert a processor description string into a specific location in the compiled processor binary. The description string is displayed in the processor drop-down list portion of IDA’s load-file dialog.</p></li></ol></div><p>When you build a Windows-based processor module, you are expected to utilize a custom MS-DOS stub supplied with the SDK (<span class="emphasis"><em>&lt;SDKDIR&gt;/module/stub</em></span>). In order to use a custom MS-DOS stub, you must instruct your linker to use your stub rather than the default stub it would otherwise include. When using Windows-specific compilers, it is occasionally possible to specify alternate stubs through the use of module definition (<span class="emphasis"><em>.def</em></span> ) files. Borland build tools (used by Hex-Rays) support the specification of alternate stubs using <span class="emphasis"><em>.def</em></span> files. The SDK includes <span class="emphasis"><em>&lt;SDKDIR&gt;/module/idp.def</em></span> for your use if you happen to be using Borland tools. The GNU and Microsoft linkers both support <span class="emphasis"><em>.def</em></span> files (albeit with a slightly different syntax); however, neither supports the specification of alternate MS-DOS stubs, which clearly poses a problem if you are using one of these compilers.<a class="indexterm" id="IDX-CHP-19-0168"/><a class="indexterm" id="IDX-CHP-19-0169"/><a class="indexterm" id="IDX-CHP-19-0170"/><a class="indexterm" id="IDX-CHP-19-0171"/><a class="indexterm" id="IDX-CHP-19-0172"/><a class="indexterm" id="IDX-CHP-19-0173"/></p><p>Assuming for a moment that you do manage to build your processor module with the SDK-supplied custom MS-DOS stub, you must still insert the processor description comment into the processor binary. This is the purpose of the <span class="emphasis"><em>&lt;SDKDIR&gt;/bin/mkidp.exe</em></span> utility. You may add a description to a processor using the following syntax to invoke <code class="literal">mkidp</code>:</p><a id="I_programlisting5_d1e32373"/><pre class="programlisting">$ mkidp <em class="replaceable"><code>module description</code></em></pre><p>Here, <em class="replaceable"><code>module</code></em> is the path to your processor module, while <em class="replaceable"><code>description</code></em> is a textual description of your module in the following form:</p><a id="I_programlisting5_d1e32385"/><pre class="programlisting">Long module name:short module name</pre><p>To add a description to our Python processor module, we might use the following command line:</p><a id="I_programlisting5_d1e32389"/><pre class="programlisting">$ ./mkidp procs/python.w32 "Python Bytecode:python"</pre><p>The <code class="literal">mkidp</code> utility attempts to insert the supplied description into the named module at an offset of 128 bytes into the file, in space that lies between the MS-DOS stub and the PE header, assuming such space exists. If there is not enough space because the PE header is too close to the end of the MS-DOS stub, you will receive the following error message:</p><a id="I_programlisting5_d1e32397"/><pre class="programlisting">mkidp: too long processor description</pre><p>Things become more dependent on your tools at this point, because processors built with the Microsoft linker will have enough space available to insert a description, while processors built using the GNU linker will not.<a class="indexterm" id="IDX-CHP-19-0174"/></p><p>In order to clear up the confusion in our minds and allow us to use either Microsoft or GNU tools, we developed a utility that we call <code class="literal">fix_proc</code>, which is available in the <a class="xref" href="ch19.html" title="Chapter 19. IDA Processor Modules">Chapter 19</a> section of the book’s website. The <code class="literal">fix_proc</code> utility uses the same command-line syntax as <code class="literal">mkidp</code>, but it provides additional behavior that allows it to insert a processor description into processor modules built with most compilers. When <code class="literal">fix_proc</code> is executed, it replaces a processor’s existing MS-DOS stub with the stub supplied with the SDK (thus eliminating the need to use <span class="emphasis"><em>.def</em></span> files in the build process). At the same time, <code class="literal">fix_proc</code> performs the necessary actions to relocate the processor’s PE headers to create sufficient space to hold the processor-description string, before ultimately inserting the description string into the proper location within the processor binary. We use <code class="literal">fix_proc</code> as a replacement for <code class="literal">mkidp</code> in performing the required postprocessing steps on processor modules.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Strictly speaking, use of the SDK’s MS-DOS stub for processor modules is not required. IDA is happy with a processor module as long as it finds a description string 128 bytes into the processor module. In <code class="literal">fix_proc</code>, we replace the existing MS-DOS stub with the SDK stub simply to avoid any possible conflicts over the space dedicated to the description string.</p></div><p><a class="xref" href="ch19s04.html#postprocessing_ida_processor_modules" title="Table 19-1. Postprocessing IDA Processor Modules (by Compiler)">Table 19-1</a> describes the features of processors based on the tools used to build them.</p><p>Only processors that have valid descriptions will be listed in the file-loading dialog. In other words, without a valid description field, it is not possible to select a processor module.</p><div class="table"><a id="postprocessing_ida_processor_modules"/><p class="title">Table 19-1. Postprocessing IDA Processor Modules (by Compiler)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Postprocessing IDA Processor Modules (by Compiler)"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>Initial Build</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>After mkidp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>After fix_proc</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>Tool</p></td><td style="text-align: left" valign="top"><p>Uses .def?</p></td><td style="text-align: left" valign="top"><p>Has stub?</p></td><td style="text-align: left" valign="top"><p>Has stub?</p></td><td style="text-align: left" valign="top"><p>Has Description?</p></td><td style="text-align: left" valign="top"><p>Has stub?</p></td><td style="text-align: left" valign="top"><p>Has Description?</p></td></tr><tr><td style="text-align: left" valign="top"><p>Borland</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td></tr><tr><td style="text-align: left" valign="top"><p>Microsoft</p></td><td style="text-align: left" valign="top"><p>No</p></td><td style="text-align: left" valign="top"><p>No</p></td><td style="text-align: left" valign="top"><p>No</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td></tr><tr><td style="text-align: left" valign="top"><p>GNU</p></td><td style="text-align: left" valign="top"><p>No</p></td><td style="text-align: left" valign="top"><p>No</p></td><td style="text-align: left" valign="top"><p>No</p></td><td style="text-align: left" valign="top"><p>No</p></td><td style="text-align: left" valign="top"><p>Yes</p></td><td style="text-align: left" valign="top"><p>Yes</p></td></tr></tbody></table></div></div><p>All of these differences in the build process require a few more modifications to the makefile presented in <a class="xref" href="ch17s02.html#a_sample_makefile_for_ida_plug-ins" title="Example 17-1. A sample makefile for IDA plug-ins">Example 17-1</a> than were required to build loader modules. <a class="xref" href="ch19s04.html#a_makefile_for_the_python_processor_modu" title="Example 19-1. A makefile for the Python processor module">Example 19-1</a> shows a makefile modified to build our example Python processor.</p><div class="example"><a id="a_makefile_for_the_python_processor_modu"/><p class="title">Example 19-1. A makefile for the Python processor module</p><div class="example-contents"><pre class="programlisting">#Set this variable to point to your SDK directory
  IDA_SDK=../../

  PLATFORM=$(shell uname | cut -f 1 -d _)

  ifneq "$(PLATFORM)" "MINGW32"
  IDA=$(HOME)/ida
  endif

  #Set this variable to the desired name of your compiled processor
  PROC=python

  #Specify a description string for your processor, this is required
  #The syntax is &lt;long name&gt;:&lt;short name&gt;
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> DESCRIPTION=Python Bytecode:python

  ifeq "$(PLATFORM)" "MINGW32"
  PLATFORM_CFLAGS=-D__NT__ -D__IDP__ -DWIN32 -Os -fno-rtti
  PLATFORM_LDFLAGS=-shared -s
  LIBDIR=$(shell find ../../ -type d | grep -E "(lib|lib/)gcc.w32")
  ifeq ($(strip $(LIBDIR)),)
  LIBDIR=../../lib/x86_win_gcc_32
  endif
  IDALIB=$(LIBDIR)/ida.a
  PROC_EXT=.w32

  else ifeq "$(PLATFORM)" "Linux"
  PLATFORM_CFLAGS=-D__LINUX__
  PLATFORM_LDFLAGS=-shared -s
  IDALIB=-lida
  IDADIR=-L$(IDA)
  PROC_EXT=.ilx

    else ifeq "$(PLATFORM)" "Darwin"
  PLATFORM_CFLAGS=-D__MAC__
  PLATFORM_LDFLAGS=-dynamiclib
  IDALIB=-lida
  IDADIR=-L$(IDA)/idaq.app/Contents/MacOs
  PROC_EXT=.imc
  endif

  #Platform specific compiler flags
  CFLAGS=-Wextra $(PLATFORM_CFLAGS)

  #Platform specific ld flags
  LDFLAGS=$(PLATFORM_LDFLAGS)

  #specify any additional libraries that you may need
  EXTRALIBS=

  # Destination directory for compiled plugins
  OUTDIR=$(IDA_SDK)bin/procs/

  # Postprocessing tool to add processor comment
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> MKIDP=$(IDA_SDK)bin/fix_proc
  #MKIDP=$(IDA)bin/mkidp

  #list out the object files in your project here
  OBJS=     ana.o emu.o ins.o out.o reg.o

  BINARY=$(OUTDIR)$(PROC)$(PROC_EXT)

  all: $(OUTDIR) $(BINARY)

  clean:
          -@rm *.o
          -@rm $(BINARY)

  $(OUTDIR):
          -@mkdir -p $(OUTDIR)

  CC=g++
  INC=-I$(IDA_SDK)include/

  %.o: %.cpp
          $(CC) -c $(CFLAGS) $(INC) $&lt; -o $@

  LD=g++
    ifeq "$(PLATFORM)" "MINGW32"
  #Windows processor's require post processing
  $(BINARY): $(OBJS)
          $(LD) $(LDFLAGS) -o $@ $(OBJS) $(IDALIB) $(EXTRALIBS)
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>       $(MKIDP) $(BINARY) "$(DESCRIPTION)"
  else
  $(BINARY): $(OBJS)
         $(LD) $(LDFLAGS) -o $@ $(OBJS) $(IDALIB) $(EXTRALIBS)
  endif

  #change python below to the name of your processor, make sure to add any
  #additional files that your processor is dependent on
  python.o: python.cpp
  ana.o: ana.cpp
  emu.o: emu.cpp
  ins.o: ins.cpp
  out.o: out.cpp
  reg.o: reg.cpp</pre></div></div><p>In addition to the minor changes to account for different suffixes and default file locations for processors, the primary differences are the definition of a description string <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32589"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, the specification of a utility to insert description strings <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32595"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and the addition of a build step to insert the description string in Windows processor modules <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32601"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-19-FN-4" id="ftn.CHP-19-FN-4">138</a>] </sup>An MS-DOS header stub includes an MS-DOS file header as well as code to warn users that a Windows program cannot be executed in MS-DOS mode.</p></div></div></div>
<div class="sect1" title="Customizing Existing Processors"><div class="titlepage"><div><div><h1 class="title"><a id="customizing_existing_processors"/>Customizing Existing Processors</h1></div></div></div><p>Perhaps you are considering developing a processor module, but you notice that an existing processor module does almost everything that you need. If you have the source code for the processor module, then you might easily modify it to suit your needs. On the other hand, if you don’t have the source code, you might feel that you are out of luck. Fortunately, IDA offers a mechanism for customizing existing processors through the use of plug-ins. By hooking the appropriate processor notifications, a plug-in module can intercept calls to one or more of an existing processor’s analyzer, emulator, and outputter stages. Potential applications for customizing a processor include the following:<a class="indexterm" id="IDX-CHP-19-0175"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Extending the capabilities of an existing processor to recognize additional instructions</p></li><li class="listitem"><p>Correcting broken behavior in an existing processor module (though it is probably faster just to let Ilfak know you found a bug)</p></li><li class="listitem"><p>Customizing the output of an existing processor module to suit your particular needs</p></li></ul></div><p>The following notification codes, declared in <code class="literal">processor_t</code> and discussed in <span class="emphasis"><em>idp.hpp</em></span>, may be hooked by plug-ins that want to intercept calls to various stages of a processor:<a class="indexterm" id="IDX-CHP-19-0176"/><a class="indexterm" id="IDX-CHP-19-0177"/><a class="indexterm" id="IDX-CHP-19-0178"/><a class="indexterm" id="IDX-CHP-19-0179"/><a class="indexterm" id="IDX-CHP-19-0180"/><a class="indexterm" id="IDX-CHP-19-0181"/><a class="indexterm" id="IDX-CHP-19-0182"/></p><table border="0" class="simplelist" summary="Simple list"><tr><td><strong class="userinput"><code>custom_ana</code></strong> Behaves as <code class="literal">u_ana</code>; however, any new instructions must use a <code class="literal">cmd.itype</code> value of 0x8000 or higher.</td></tr><tr><td><strong class="userinput"><code>custom_emu</code></strong> Provides emulation for custom instruction types. You may call <code class="literal">(*ph.u_emu)()</code> if you wish to invoke the processor’s existing emulator.</td></tr><tr><td><strong class="userinput"><code>custom_out</code></strong> Generates output for custom instructions or provides custom output for existing instructions. You may call <code class="literal">(*ph.u_out)()</code> if you wish to invoke the processor’s <code class="literal">out</code> function.</td></tr><tr><td><strong class="userinput"><code>custom_outop</code></strong> Outputs a single custom operand. You may call <code class="literal">(*ph.u_outop)(op)</code> if you wish to invoke the processor’s existing <code class="literal">outop</code> function.</td></tr><tr><td><strong class="userinput"><code>custom_mnem</code></strong> Generates the mnemonic for a custom instruction.</td></tr></table><p>The following code excerpts are from a plug-in that modifies the output of the x86 processor module to replace the <code class="literal">leave</code> instruction with a <code class="literal">cya</code> instruction and to swap the display order for instructions that have two operands (similar to the AT&amp;T-style syntax):</p><a id="I_programlisting5_d1e32707"/><pre class="programlisting">int idaapi init(void) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    if (ph.id != PLFM_386) return PLUGIN_SKIP;
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>    hook_to_notification_point(HT_IDP, hook, NULL);
     return PLUGIN_KEEP;
  }

  int idaapi hook(void *user_data, int notification_code, va_list va) {
     switch (notification_code) {
        case processor_t::custom_out: {
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>         if (cmd.itype == NN_leave) {  //intercept the leave instruction
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>            MakeLine(SCOLOR_ON SCOLOR_INSN "cya" SCOLOR_OFF);
              return 2;
           }
           else if (cmd.Op2.type != o_void) {
              //intercept 2 operand instructions
              op_t op1 = cmd.Op1;
              op_t op2 = cmd.Op2;
              cmd.Op1 = op2;
              cmd.Op2 = op1;
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>               (*ph.u_out)();
              cmd.Op1 = op1;
              cmd.Op2 = op2;
              return 2;
           }
        }
     }
     return 0;
  }
    plugin_t PLUGIN = {
    IDP_INTERFACE_VERSION,
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>   PLUGIN_PROC | PLUGIN_HIDE | PLUGIN_MOD,  // plugin flags
    init,                 // initialize
    term,                 // terminate. this pointer may be NULL.
    run,                  // invoke plugin
    comment,              // long comment about the plugin
    help,                 // multiline help about the plugin
    wanted_name,          // the preferred short name of the plugin
    wanted_hotkey         // the preferred hotkey to run the plugin
  };</pre><p>The plug-in’s <code class="literal">init</code> function verifies that the current processor is the x86 processor <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32751"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and then hooks processor notifications <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32757"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. In the callback <code class="literal">hook</code> function, the plug-in processes the <code class="literal">custom_out</code> notification to recognize the <code class="literal">leave</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32773"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> and generates an alternative output line <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32779"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>. For two operand instructions, the <code class="literal">hook</code> function temporarily saves the operands associated with the current command, before swapping them within the command just prior to invoking the x86 processor’s <code class="literal">u_out</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32791"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> to handle all of the details of printing the line. Upon return, the command’s operands are swapped back to their original order. Finally, the plug-in’s flags <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32798"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> specify that the plug-in should be loaded when a processor is loaded, should not be listed on the Edit ▸ Plugins menu, and modifies the database. The following output shows the effects of the customizations performed by the plug-in:<a class="indexterm" id="IDX-CHP-19-0183"/><a class="indexterm" id="IDX-CHP-19-0184"/><a class="indexterm" id="IDX-CHP-19-0185"/><a class="indexterm" id="IDX-CHP-19-0186"/></p><a id="I_programlisting5_d1e32820"/><pre class="programlisting">.text:00401350            push    ebp
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> .text:00401351            mov     400000h, edx
  .text:00401356            mov     esp, ebp
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> .text:00401358            mov     offset unk_402060, eax
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> .text:0040135D            sub     0Ch, esp
  .text:00401360            mov     edx, [esp+8]
  .text:00401364            mov     eax, [esp+4]
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> .text:00401368            mov     offset unk_402060, [esp]
  .text:0040136F            call    sub_401320
<img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/> .text:00401374            cya
  .text:00401375            retn</pre><p>You can observe the plug-in’s effects by noting that constants appear as the first operand in four instructions <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32854"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> and that the <code class="literal">cya</code> instruction is used in place of the <code class="literal">leave</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e32866"/><img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/></span>.</p><p>In <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>, we will look at using a custom processor plug-in to aid in the analysis of certain types of obfuscated binaries.</p></div>
<div class="sect1" title="Processor Module Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="processor_module_architecture"/>Processor Module Architecture</h1></div></div></div><p>As you set about designing processor modules, one of the things you will need to consider is whether the processor will be closely coupled with a specific loader or can be decoupled from all loaders. For example, consider the x86 processor module. This module makes no assumptions about the type of file that is being disassembled. Therefore, it is easily incorporated and used in conjunction with a wide variety of loaders such as the PE, ELF, and Mach-O loaders.<a class="indexterm" id="IDX-CHP-19-0187"/><a class="indexterm" id="IDX-CHP-19-0188"/><a class="indexterm" id="IDX-CHP-19-0189"/><a class="indexterm" id="IDX-CHP-19-0190"/><a class="indexterm" id="IDX-CHP-19-0191"/></p><p>In a similar manner, loaders show versatility when they are capable of handling a file format independently of the processor used with the file. For example, the PE loader works equally well whether it contains x86 code or ARM code; the ELF loader works equally well whether it contains x86, MIPS, or SPARC code; and the Mach-O loader works fine whether it contains PPC or x86 code.<a class="indexterm" id="IDX-CHP-19-0192"/><a class="indexterm" id="IDX-CHP-19-0193"/><a class="indexterm" id="IDX-CHP-19-0194"/></p><p>Real-world CPUs lend themselves to the creation of processor modules that do not rely on a specific input file format. Virtual machine languages, on the other hand, pose a much larger challenge. Whereas a wide variety of loaders (such as ELF, a.out, and PE) may be used to load code for execution on native hardware, a virtual machine typically acts as both a loader and a CPU. The net result is that, for virtual machines, both the file format and the underlying byte code are intimately related. One cannot exist without the other. We bumped up against this limitation several times in the development of the Python processor module. In many cases, it simply was not possible to generate more readable output without a deeper understanding of the structure of the file being disassembled.</p><p>In order for the Python processor to have access to the additional information that it requires, we could build a Python loader that configures the database in a manner very specific to the Python processor so that the Python processor knows exactly where to find the information it needs. In this scenario, a significant amount of loader state data would need to pass from the loader to the processor. One approach is to store such data in database netnodes, where that data could later be retrieved by the processor module.</p><p>An alternative approach is to build a loader that does nothing other than recognize <span class="emphasis"><em>.pyc</em></span> files and then tells the processor module that it should handle all of the other loading tasks, in which case the processor will surely know how to locate all of the information needed for disassembling the <span class="emphasis"><em>.pyc</em></span> file.</p><p>IDA facilitates the construction of tightly coupled loaders and processor modules by allowing a loader to defer all loading operations to an associated processor module. This is how the SDK’s included Java loader and Java processor are constructed. In order for a loader to defer loading to the processor module, the loader should first accept a file by returning a file type of <code class="literal">f_LOADER</code> (defined in <span class="emphasis"><em>ida.hpp</em></span>). If the loader is selected by the user, the loader’s <code class="literal">load_file</code> function should ensure that the proper processor type has been specified by calling <code class="literal">set_processor_type</code> (<span class="emphasis"><em>idp.hpp</em></span>) if necessary before sending a loader-notification message to the processor. To build a tightly coupled Python loader/processor combination, we might build a loader with the following <code class="literal">load_file</code> function:</p><a id="I_programlisting5_d1e32941"/><pre class="programlisting">void idaapi load_file(linput_t *li, ushort neflag, const char *) {
   if (ph.id != PLFM_PYTHON) {  //shared processor ID
      set_processor_type("python", SETPROC_ALL|SETPROC_FATAL);
   }
   //tell the python processor module to do the loading for us
   //by sending the processor_t::loader notification message
   if (ph.notify(processor_t::loader, li, neflag)) {
      error("Python processor/loader failed");
   }
}</pre><p>When the processor module receives the <code class="literal">loader</code> notification, it takes responsibility for mapping the input file into the database and making sure that it has access to any information that will be required in any of the <code class="literal">ana</code>, <code class="literal">emu</code>, and <code class="literal">out</code> stages. A Python loader and processor combination that operates in this manner is available on the book’s companion website.<a class="indexterm" id="IDX-CHP-19-0195"/><a class="indexterm" id="IDX-CHP-19-0196"/></p></div>
<div class="sect1" title="Scripting a Processor Module"><div class="titlepage"><div><div><h1 class="title"><a id="scripting_a_processor_module"/>Scripting a Processor Module</h1></div></div></div><p>Introduced in IDA 5.7, the capability to create processor modules using one of IDA’s scripting languages somewhat simplifies the creation of processor modules. If nothing else, it completely eliminates the build phase of module creation. Elias Bachaalany of Hex-Rays introduced scripted processor modules in a post on Hex Blog<sup>[<a class="footnote" href="#ftn.CHP-19-FN-5" id="CHP-19-FN-5">139</a>]</sup> and IDA’s EFI bytecode processor module is implemented as a Python script (see <span class="emphasis"><em>&lt;IDADIR&gt;/procs/ebc.py</em></span>). Note that while the Hex Blog post serves as useful background, the actual API used for scripting processor modules seems to have evolved. The best place for you to start development of your own processor module script is with the template module that ships with the SDK (see <span class="emphasis"><em>&lt;SDKDIR&gt;/module/script/proctemplate.py</em></span>). Among other things, this template enumerates all of the fields required in a Python processor module.<a class="indexterm" id="IDX-CHP-19-0197"/><a class="indexterm" id="IDX-CHP-19-0198"/><a class="indexterm" id="IDX-CHP-19-0199"/><a class="indexterm" id="IDX-CHP-19-0200"/></p><p>Scripted processor modules make use of nearly all elements discussed previously. Understanding these elements will ease your transition to scripted modules. Additionally, the three Python processor modules that currently ship with IDA (as of IDA 6.1) serve as excellent examples from which to begin your own module development. The structure of these two modules is a bit easier to understand than the C++ examples that ship with the SDK, which span several files and require you to correctly configure a build environment.</p><p>From a very high level, two things are required to implement a processor module in Python:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Define a subclass <code class="literal">idaapi.processor_t</code>, providing implementations for all required processor module functions such as <code class="literal">emu</code>, <code class="literal">ana</code>, <code class="literal">out</code>, and <code class="literal">outop</code>.</p></li><li class="listitem"><p>Define a <code class="literal">PROCESSOR_ENTRY</code> function (not a member of your subclass) that returns an instance of your processor class.</p></li></ul></div><p>The following listing begins to outline some of the required elements:</p><a id="I_programlisting5_d1e33027"/><pre class="programlisting">from idaapi import *

class demo_processor_t(idaapi.processor_t):
   # Initialize required processor data fields including id and
   # assembler and many others. The assembler field is a dictionary
   # containing keys for all of the fields of an asm_t. A list of
   # instructions named <em class="replaceable"><code>instruc</code></em> is also required. Each item in the list
   # is a two-element dictionary containing <em class="replaceable"><code>name</code></em> and <em class="replaceable"><code>feature</code></em> keys.

   # Also define functions required by processor_t such as those below.

   def ana(self):
      # analyzer behavior

   def emu(self):
      # emulator behavior

   def out(self):
      # outputter behavior

   def outop(self):
      # outop behavior

# define the processor entry point function which instantiates
# and returns an instance of processor_t
def PROCESSOR_ENTRY():
    return demo_processor_t()</pre><p>A valid Python processor module contains far more fields and functions than shown above, essentially mirroring the fields required in any processor module implemented in C++. Once your script is complete, installation of your module is accomplished by copying your script to <span class="emphasis"><em>&lt;IDADIR&gt;/procs</em></span>.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-19-FN-5" id="ftn.CHP-19-FN-5">139</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=116">http://www.hexblog.com/?p=116</a>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id18"/>Summary</h1></div></div></div><p>As the most complex of IDA’s modular extensions, processor modules take time to learn and even more time to create, although the use of scripting can ease this pain to some extent. However, if you are in a niche reverse engineering market, or you simply like to be on the leading edge of the reverse engineering community, you will almost certainly find yourself with the need to develop a processor module at some point. We cannot emphasize enough the role that patience and trial and error play in any processor-development situation. The hard work more than pays off when you are able to reuse your processor module with each new binary you collect.</p><p>With the end of this chapter, we conclude our discussion of IDA’s extensibility features. Over the course of the next several chapters, we will discuss many of the ways IDA is used in real-world scenarios and look at how users have leveraged IDA extensions to perform a variety of interesting analysis tasks.</p></div></body></html>