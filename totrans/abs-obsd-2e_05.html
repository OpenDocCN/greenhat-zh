<html><head></head><body><section class="chapter" epub:type="chapter" id="the_boot_process" title="Chapter&#xA0;5.&#xA0;The Boot Process"><div class="titlepage"><div><div><h2 class="title">Chapter 5. The Boot Process</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Single-user mode</em></span><br/>
<span class="emphasis"><em>unscheduled in the nighttime?</em></span><br/>
<span class="emphasis"><em>Something just went “boom”!</em></span></p></div></div><p><a class="indexterm" id="idx0157"/><a class="indexterm" id="idx0166"/><span class="inlinemediaobject"><a id="inline_id00006"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> In order to properly manage any computing platform, you must understand the boot process. Many systems administration tasks cannot be done while the system is running. OpenBSD specifically requires that certain tasks be done before the boot process has completed. And, of course, on any operating system, sometimes a process starting up prevents the system from completing its boot. The only way to fix these problems is to interrupt the boot partway through.</p><p>First, we’ll look at the key to OpenBSD’s booting process: the boot loader. Then we’ll move on to single-user mode, and finally multiuser startup. You can perform useful work at any of these stages.</p><p>I recommend playing with the OpenBSD boot process on a test machine <span class="emphasis"><em>before</em></span> one of your machines won’t boot. That way, when something breaks in the wee hours of the morning, you can spend your time fixing the problem instead of fumbling around with unfamiliar commands.</p><div class="sect1" title="Power-On and the Boot Loader"><div class="titlepage"><div><div><h2 class="title" id="power-on_and_the_boot_loader" style="clear: both">Power-On and the Boot Loader</h2></div></div></div><p><a class="indexterm" id="idx0117"/><a class="indexterm" id="idx0139"/><a class="indexterm" id="idx0156"/><a class="indexterm" id="idx0158"/><a class="indexterm" id="idx0161"/><a class="indexterm" id="idx0170"/><a class="indexterm" id="idx0174"/><a class="indexterm" id="idx0178"/><a class="indexterm" id="idx0267"/><a class="indexterm" id="idx0964"/><a class="indexterm" id="idx1032"/><a class="indexterm" id="idx1138"/><a class="indexterm" id="idx1746"/><a class="indexterm" id="idx1881"/><a class="indexterm" id="idx2102"/><a class="indexterm" id="idx2428"/>In general, when a PC-style computer first boots, it starts the BIOS. The BIOS is a small piece of software that figures out things like which drives are attached and what they’re attached to, what sort of CPU is installed, and how much memory is available. After getting that information, the BIOS loads a minimal boot loader from some kind of storage device.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id369126" id="id369126">11</a>]</sup></p><p>The <span class="emphasis"><em>boot loader</em></span> is a small program that handles initial system configuration and boots the kernel. It finds and starts the kernel, which in turn detects hardware, attaches device drivers, and performs other core setup. Finally, the kernel calls <code class="literal">init(8)</code>, which starts processes and enables user programs, network interfaces, server software, and so on.</p><p>While most of this process cannot be managed—no one actually configures <code class="literal">init</code>!—there’s plenty you can do before the system finishes booting and dumps you at the login screen.</p><p>The OpenBSD boot loader lets you interrupt the boot process, configure the system before it boots, adjust kernel settings, and even boot an alternate kernel.</p><p>When the hardware hands control of the boot process over to the OpenBSD partition, you’ll see the boot loader prompt, which looks something like this:</p><a id="I_programlisting5_id435236"/><pre class="programlisting">&gt;&gt; OpenBSD/amd64 BOOT 3.18
boot&gt;</pre><p>The boot loader’s main purpose is to find the kernel, load it into memory, and start it. Because it runs before the kernel starts, the boot loader can pass instructions to the kernel itself.</p><p>Here are some of the things you can do before booting is complete:</p><div class="blockquote" title="Use built-in help"><blockquote class="blockquote" title="Use built-in help"><div class="blockquote-title">Use built-in help</div><p>Use the <code class="literal">help</code> function to print a brief list of commands that the boot loader supports.</p><pre class="programlisting">boot&gt; <span class="strong"><strong>help</strong></span>
commands: # boot echo env help ls machine reboot set stty time
machine: boot diskinfo memory</pre></blockquote></div><div class="blockquote" title="Delay the boot process"><blockquote class="blockquote" title="Delay the boot process"><div class="blockquote-title">Delay the boot process</div><p>By default, the loader waits five seconds for instructions, and then boots the kernel. To pause the boot at the prompt, press the spacebar.</p></blockquote></div><div class="blockquote" title="Set the boot timeout"><blockquote class="blockquote" title="Set the boot timeout"><div class="blockquote-title">Set the boot timeout</div><p>To set a new boot idle timeout, specify a number of seconds with the <code class="literal">set timeout</code> command.</p><pre class="programlisting">boot&gt; <span class="strong"><strong>set timeout 10</strong></span></pre><p><a class="indexterm" id="idx0182"/><a class="indexterm" id="idx0460"/><a class="indexterm" id="idx0845"/><a class="indexterm" id="idx0888"/><a class="indexterm" id="idx1399"/><a class="indexterm" id="idx2144"/><a class="indexterm" id="idx2145"/><a class="indexterm" id="idx2462"/>After the boot prompt is idle for 10 seconds, the system should boot.</p></blockquote></div><div class="blockquote" title="Boot the system"><blockquote class="blockquote" title="Boot the system"><div class="blockquote-title">Boot the system</div><p>If you’ve paused the boot process, the system won’t boot until you tell it to. When you’re ready to boot, use the <code class="literal">boot</code> command:</p><pre class="programlisting">&gt; <span class="strong"><strong>boot</strong></span></pre></blockquote></div><p>We’ll use various permutations of <code class="literal">boot</code> to configure the kernel, boot single-user mode, and so on. I’ll cover other boot commands in the appropriate sections. For full details on what you can do at the boot loader prompt, read the <code class="literal">boot(8)</code> man page.</p></div><div class="sect1" title="Booting in Single-User Mode"><div class="titlepage"><div><div><h2 class="title" id="booting_in_single-user_mode" style="clear: both">Booting in Single-User Mode</h2></div></div></div><p>Single-user mode is the earliest point when OpenBSD can give you a Unix-style shell prompt. At this point, the kernel has probed all the hardware, attached drivers to all the hardware that it’s going to acknowledge, and started <code class="literal">init</code>. The system hasn’t mounted any filesystems except for the root partition, which is mounted in read-only mode. The network isn’t started, no services are running, security is not implemented, and filesystem permissions are ignored.</p><p>To boot OpenBSD in single-user mode, enter <span class="strong"><strong><code class="literal">boot -s</code></strong></span> at the loader prompt.</p><a id="I_programlisting5_id435451"/><pre class="programlisting">boot&gt; <span class="strong"><strong>boot -s</strong></span></pre><p>Why would you want to boot into single-user mode? If your computer has a problem that is preventing it from booting, you should be able to access single-user mode and fix the problem. Suppose a failed disk is preventing the system from booting during a multiuser boot, or you changed your terminal settings in <span class="emphasis"><em>/etc/ttys</em></span> and now you can’t log on to the system. Or maybe you put a daft setting in <span class="emphasis"><em>rc.conf.local</em></span>, and the boot process hangs because it’s trying to do something impossible. At times like these, single-user mode is your best friend.</p><p>Also, some system administration tasks, such as clearing filesystem flags (see <a class="xref" href="ch08.html" title="Chapter 8. Disks and Filesystems">Chapter 8</a>), can be done only in single-user mode.</p><div class="sect2" title="Mounting Disks in Single-User Mode"><div class="titlepage"><div><div><h3 class="title" id="mounting_disks_in_single-user_mode">Mounting Disks in Single-User Mode</h3></div></div></div><p>Usually, you should have a fully functional filesystem before doing anything in single-user mode. If your system crashed, be sure to check the integrity of your filesystems before mounting them:</p><a id="I_programlisting5_id435498"/><pre class="programlisting"># <span class="strong"><strong>fsck -p</strong></span>
/dev/sd0a (e4bf0318329fe596.a): file system is clean; not checking
/dev/sd0h (e4bf0318329fe596.h): file system is clean; not checking
…
# <span class="strong"><strong>mount -a</strong></span></pre><p><a class="indexterm" id="idx0168"/><a class="indexterm" id="idx1142"/><a class="indexterm" id="idx1419"/><a class="indexterm" id="idx1519"/><a class="indexterm" id="idx2148"/><a class="indexterm" id="idx2502"/><code class="literal">fsck</code> and <code class="literal">mount</code> have many more options. We’ll cover them in more detail in <a class="xref" href="ch08.html" title="Chapter 8. Disks and Filesystems">Chapter 8</a>.</p><p>Once you’ve mounted all of your filesystems, all usual command-line software should be available. You should be able to edit configuration files, start and stop programs, and generally do whatever you like to the system (including destroy it).</p></div><div class="sect2" title="Starting the Network in Single-User Mode"><div class="titlepage"><div><div><h3 class="title" id="starting_the_network_in_single-user_mode">Starting the Network in Single-User Mode</h3></div></div></div><p>Use the shell script <span class="emphasis"><em>/etc/netstart</em></span> to configure the network while in singleuser mode. (You could run all the appropriate commands by hand, but <span class="emphasis"><em>/etc/netstart</em></span> will read your system’s configuration files and do the grunt work for you.) You must explicitly run this script through <code class="literal">sh</code>:</p><a id="I_programlisting5_id435604"/><pre class="programlisting"># <span class="strong"><strong>sh /etc/netstart</strong></span></pre><p>If you’re booting into single-user mode because of network problems, this script will conveniently reproduce the issue for you.</p></div></div><div class="sect1" title="Booting an Alternate Kernel"><div class="titlepage"><div><div><h2 class="title" id="booting_an_alternate_kernel" style="clear: both">Booting an Alternate Kernel</h2></div></div></div><p>As we’ll cover in tedious detail in <a class="xref" href="ch18.html" title="Chapter 18. Kernel Configuration">Chapter 18</a>, you <span class="emphasis"><em>can</em></span> configure the OpenBSD kernel, but before you do so, be sure that you can boot alternate kernels. You’ll need to be able to boot a different kernel if, say, you hose your filesystem so badly that it won’t even boot to single-user mode, and you need to recover using the installation kernel.</p><div class="sect2" title="Booting a Different Kernel File"><div class="titlepage"><div><div><h3 class="title" id="booting_a_different_kernel_file">Booting a Different Kernel File</h3></div></div></div><p>An OpenBSD installation includes three kernels out of the box: the single-processor kernel <span class="emphasis"><em>/bsd</em></span>, the multiprocessor kernel <span class="emphasis"><em>/bsd.mp</em></span>, and the upgrade and install kernel <span class="emphasis"><em>/bsd.rd</em></span>. (If your machine has multiple processors, the installer renames <span class="emphasis"><em>/bsd</em></span> to <span class="emphasis"><em>/bsd.sp</em></span> and <span class="emphasis"><em>/bsd.mp</em></span> to <span class="emphasis"><em>/bsd</em></span>.)</p><p>To boot a nonstandard kernel, first reboot and interrupt the boot process at the boot loader prompt. Run <code class="literal">boot</code>, and give the full path to the kernel you want to boot:</p><a id="I_programlisting5_id435691"/><pre class="programlisting">boot&gt; <span class="strong"><strong>boot /bsd.rd</strong></span></pre><p>This will start the system using your chosen kernel. You can use other boot options as well, such as booting the alternate kernel in single-user mode:</p><a id="I_programlisting5_id435705"/><pre class="programlisting">boot&gt; <span class="strong"><strong>boot -s /bsd.sp</strong></span></pre><p><a class="indexterm" id="idx0045"/><a class="indexterm" id="idx0159"/><a class="indexterm" id="idx0167"/><a class="indexterm" id="idx0437"/><a class="indexterm" id="idx0872"/><a class="indexterm" id="idx0941"/><a class="indexterm" id="idx0942"/><a class="indexterm" id="idx1260"/><a class="indexterm" id="idx1705"/><a class="indexterm" id="idx1721"/>This will let you recover from a bad kernel, try a new kernel, or anything in between.</p></div><div class="sect2" title="Booting from an Alternate Hard Disk"><div class="titlepage"><div><div><h3 class="title" id="booting_from_an_alternate_hard_disk">Booting from an Alternate Hard Disk</h3></div></div></div><p>Suppose you’ve really fouled everything up beyond all recognition, and you don’t have a usable kernel on your root partition. Fortunately, if you have a usable kernel on a different hard drive, you can boot from that. (Usually, this kernel lives on an alternate root partition, <span class="emphasis"><em>/altroot</em></span>, as discussed in <a class="xref" href="ch08.html" title="Chapter 8. Disks and Filesystems">Chapter 8</a>.) In this section, I’ll break the task of booting from that alternate kernel into a few steps: finding the hard disk with the partition, finding the partition with the file, and booting the right file on that partition.</p><div class="sect3" title="Finding the Disk"><div class="titlepage"><div><div><h4 class="title" id="finding_the_disk">Finding the Disk</h4></div></div></div><p>Once you’re familiar with OpenBSD, you may begin to think of the hard drives in your system by their device names, such as <span class="emphasis"><em>/dev/sd0</em></span>, <span class="emphasis"><em>/dev/wd1</em></span>, and so on. Unfortunately, those are the kernel’s names for the disks; the boot loader recognizes only the BIOS’s disk names.</p><p>To ask the boot loader about disks, use the <code class="literal">machine diskinfo</code> command:</p><a id="I_programlisting5_id435856"/><pre class="programlisting">boot&gt; <span class="strong"><strong>machine diskinfo</strong></span>
Disk    BIOS#   Type    Cyls    Heads   Secs    Flags   Checksum
fd0     0x0     *none*  80      2       18      0x4     0x0
hd0     0x80    label   1024    255     63      0x2     0x51db843d
hd1     0x81    label   1024    255     63      0x2     0x9329b723
hd2     0x82    label   1024    255     63      0x2     0xcfadb343
boot&gt;</pre><p>Here, the boot loader has found four disk devices. The first, <code class="literal">fd0</code>, is a floppy disk drive. This drive might or might not have a disk in it, but whatever it has, it’s almost certainly not your alternate kernel. (It might be an installation disk, though, so don’t automatically rule out using it for disaster recovery.)</p><p>The other three devices—<code class="literal">hd0</code>, <code class="literal">hd1</code>, and <code class="literal">hd2</code>—are hard disks. The first, <code class="literal">hd0</code>, is the default system boot disk. If you can’t boot from that disk, you need to find the hard disk that contains your kernel.</p></div><div class="sect3" title="Finding the Partition"><div class="titlepage"><div><div><h4 class="title" id="finding_the_partition">Finding the Partition</h4></div></div></div><p>Vague stirrings of memory in this output lead me to think that <code class="literal">hd2</code> might be the disk that holds my backup root partition. To try it, tell the loader that disk partition <code class="literal">hd2a</code> is the new root partition:</p><a id="I_programlisting5_id435920"/><pre class="programlisting">boot&gt; set device hd2a</pre><p>Before trying to boot from this partition, look at its contents:</p><a id="I_programlisting5_id435927"/><pre class="programlisting">boot&gt; <span class="strong"><strong>ls</strong></span>
stat(hd2a:/.): Invalid argument
boot&gt;</pre><p><a class="indexterm" id="idx0160"/><a class="indexterm" id="idx0175"/><a class="indexterm" id="idx0572"/><a class="indexterm" id="idx1141"/><a class="indexterm" id="idx2431"/>Apparently, disk <code class="literal">hd2</code> has no partition <code class="literal">a</code>. After service is restored, I’ll take this disk out behind my garage and beat its weakness out of it. For now, let’s try the only remaining disk, <code class="literal">hd1</code>.</p><a id="I_programlisting5_id435996"/><pre class="programlisting">boot&gt; <span class="strong"><strong>set device hd1a</strong></span>
boot&gt; <span class="strong"><strong>ls</strong></span>
drwxr-xr-x 0,0  512     .
drwxr-xr-x 0,0  512     ..
drwxr-xr-x 0,0  512     altroot
drwxr-xr-x 0,0  512     home
drwxr-xr-x 0,0  512     tmp
…</pre><p>This looks like an actual root partition (<code class="literal">altroot</code> offers a hint).</p></div><div class="sect3" title="Booting the Kernel"><div class="titlepage"><div><div><h4 class="title" id="booting_the_kernel">Booting the Kernel</h4></div></div></div><p>At this point, we could boot a different kernel, but we’ll just boot the <span class="emphasis"><em>/bsd</em></span> kernel on this partition in single-user mode, because the filesystem table would have the incorrect entry for the root filesystem, which would mess up all sorts of stuff.</p><a id="I_programlisting5_id436039"/><pre class="programlisting">boot&gt; <span class="strong"><strong>boot -s</strong></span>
booting hd1a:/bsd: 5669864+1601484+935608+0+617568 [89+499848+323884]=0xd351b8
…</pre><p>Alternatively, you could give the device name at the boot prompt:</p><a id="I_programlisting5_id436052"/><pre class="programlisting">boot&gt; <span class="strong"><strong>boot -s hd1a:/bsd</strong></span></pre><p>As a general rule, you should mount the actual root partition on <span class="emphasis"><em>/mnt</em></span>, make the necessary changes for normal operation, and reboot into the proper root partition. You could also boot the <span class="emphasis"><em>/bsd.rd</em></span> kernel, giving you a cleaner boot at the cost of having fewer tools available.</p></div></div></div><div class="sect1" title="Making Boot Loader Settings Permanent"><div class="titlepage"><div><div><h2 class="title" id="making_boot_loader_settings_permanent" style="clear: both">Making Boot Loader Settings Permanent</h2></div></div></div><p>To make boot loader options permanent, edit <span class="emphasis"><em>/etc/boot.conf</em></span>. The boot loader reads and runs entries from this file before giving you the <code class="literal">boot&gt;</code> prompt, which means you can use it to automatically run boot loader commands every time your computer boots. (Although if you would rather sit at your computer and enter your settings every time you reboot, don’t let me stop you.)</p><p>Any command you might give at the loader prompt is a valid <span class="emphasis"><em>boot.conf</em></span> entry. For example, if the default boot speed is too slow for your liking, you can set your boot timeout to two seconds by adding this line to <span class="emphasis"><em>boot.conf</em></span>:</p><a id="I_programlisting5_id436111"/><pre class="programlisting">set timeout 2</pre><p><a class="indexterm" id="idx0179"/><a class="indexterm" id="idx0957"/><a class="indexterm" id="idx1169"/><a class="indexterm" id="idx1179"/><a class="indexterm" id="idx1561"/><a class="indexterm" id="idx2087"/><a class="indexterm" id="idx2189"/>You can also tell the system to boot a different kernel with the correct <span class="emphasis"><em>boot.conf</em></span> command.</p><a id="I_programlisting5_id436165"/><pre class="programlisting">set image /bsd.mp</pre><p>By far, <span class="emphasis"><em>boot.conf</em></span> is most often used to configure a serial console.</p></div><div class="sect1" title="Serial Consoles"><div class="titlepage"><div><div><h2 class="title" id="serial_consoles" style="clear: both">Serial Consoles</h2></div></div></div><p>All of these nifty boot functions let you do useful stuff when your system is in trouble, but how can you use them when your computer isn’t right in front of you? If your computer is in a data center on the other side of the country, or sitting in the basement behind the last decade of payroll records, a serial console will make your life far more pleasant.</p><p>A hardware serial console allows you to run a serial cable between a computer and a terminal server (on another computer) to access BIOS messages and operating system boot and startup messages which simplifies managing remote systems. Serial consoles are invaluable when debugging system crashes, too; error messages come over the serial port, where you can easily capture them.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id418996" id="id418996">12</a>]</sup></p><p>True UNIX hardware has serial console capabilities, as does most server-grade i386 and amd64 hardware. Most desktop-grade hardware, however, does not. But fortunately, even if you don’t have a hardware serial console, you can access all of OpenBSD’s startup messages with a serial port and a software serial console. While OpenBSD’s software serial console won’t give you access to the hardware BIOS, it will let you interface with the boot loader and remotely access the system console, even when the network is down.</p><div class="sect2" title="Other Platform Serial Consoles"><div class="titlepage"><div><div><h3 class="title" id="other_platform_serial_consoles">Other Platform Serial Consoles</h3></div></div></div><p>Every hardware platform has its own standards for serial consoles. If you’re running a less common platform, check your hardware’s documentation.</p><p>If your hardware supports a real serial console, you should usually configure it in the BIOS. OpenBSD supports whatever the hardware supports, so your Sparc64 hardware will support OpenBSD’s serial console just as well as it supports any other operating system’s serial console.</p></div><div class="sect2" title="Serial Console Physical Setup"><div class="titlepage"><div><div><h3 class="title" id="serial_console_physical_setup">Serial Console Physical Setup</h3></div></div></div><p>A serial console requires a null modem cable, which you should be able to get from any computer store or an online vendor. While gold-plated cables aren’t worth the money, don’t buy the cheapest cable you can find either. If you have an emergency and need the serial console right <span class="emphasis"><em>now</em></span>, you won’t be in the mood to deal with a defective cable.</p><p><a class="indexterm" id="idx0227"/><a class="indexterm" id="idx0258"/><a class="indexterm" id="idx0373"/><a class="indexterm" id="idx0729"/><a class="indexterm" id="idx1896"/><a class="indexterm" id="idx2400"/><a class="indexterm" id="idx2435"/>Plug one end of the null modem cable into your OpenBSD machine’s first serial port. (The serial console is supported on only the first serial port, or <code class="literal">com0</code> on i386 and amd64 hardware.) Plug the null modem cable’s other end into an open serial port on another system. (For simplicity’s sake, use either another OpenBSD or Unix-like system.)</p><p>If you have two OpenBSD machines at a remote location and you want to use serial consoles on both, you can have each machine act as the console client for the other. Attach the first serial port on each server to the second serial port on the other. If you have three machines, you can daisy-chain them in a loop. If you have four or more machines, pick up a used terminal server from your favorite auction site.</p><p>You can also use two DB9-to-RJ45 converters, one standard and one crossover, which will allow you to run your console connections over a standard CAT5 cable. If you have a lights-out data center where human beings are forbidden unless they are installing or removing equipment, you can stretch your serial console cables about 12 meters, which should reach into your warm room. (Most modern data facilities are better equipped to handle CAT5 cables than serial cables.)</p></div><div class="sect2" title="Serial Console Configuration"><div class="titlepage"><div><div><h3 class="title" id="serial_console_configuration">Serial Console Configuration</h3></div></div></div><p>Now that you have the console physically ready, the next step is to configure your client to access the serial console. Then you can set up the serial console.</p><div class="sect3" title="Configuring the Serial Console Client"><div class="titlepage"><div><div><h4 class="title" id="configuring_the_serial_console_client">Configuring the Serial Console Client</h4></div></div></div><p>The following are the default settings for an OpenBSD i386 or amd64 system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>9600 baud</p></li><li class="listitem"><p>8 bits</p></li><li class="listitem"><p>No parity</p></li><li class="listitem"><p>1 stop bit</p></li></ul></div><p>Enter these values into any terminal emulator on the client computer, and the serial console should Just Work. You can find terminal emulators for Microsoft platforms (I recommend PuTTY), OS X, and just about any other operating system.</p><p>OpenBSD includes the terminal emulator <code class="literal">tip(1)</code>, which reads its configuration from <span class="emphasis"><em>/etc/remote</em></span>. The configuration <code class="literal">tty00</code> in <span class="emphasis"><em>/etc/remote</em></span> matches the default OpenBSD serial console configuration for i386 and amd64 systems (as well as several other platforms). If you’ve attached your null modem cable to the first serial port on the client, connect with this command:</p><a id="I_programlisting5_id436409"/><pre class="programlisting"># <span class="strong"><strong>tip tty00</strong></span>
connected</pre><p><a class="indexterm" id="idx2090"/><a class="indexterm" id="idx2091"/><a class="indexterm" id="idx2409"/>If it doesn’t say <code class="literal">connected</code>, your serial client is misconfigured. Fix your client before enabling your serial console on the server. You want your serial client ready before configuring the console.</p></div><div class="sect3" title="Setting Up the Serial Console"><div class="titlepage"><div><div><h4 class="title" id="setting_up_the_serial_console">Setting Up the Serial Console</h4></div></div></div><p>OpenBSD normally uses the local physical keyboard, video, and mouse as the console, but it can also use the first serial port as a serial console.</p><p>To set the console, use the boot loader. You must know the loader’s device name for your preferred console: <code class="literal">com0</code> for the first serial port or <code class="literal">pc0</code> for the physically attached video and keyboard.</p><p>The first time you try to use a serial console, use a local test machine. Set up your client beforehand and start your terminal emulator, and then boot your test machine. At the boot loader prompt, enter this command:</p><a id="I_programlisting5_id436486"/><pre class="programlisting">boot&gt; <span class="strong"><strong>set tty com0</strong></span></pre><p>Your server’s monitor and keyboard should stop responding, and if you’ve set up everything correctly, you should see the boot loader prompt in your terminal emulator.</p><p>To switch back to the physical console, tell the boot loader to use the <code class="literal">pc0</code> device:</p><a id="I_programlisting5_id436507"/><pre class="programlisting">boot&gt; <span class="strong"><strong>set tty pc0</strong></span></pre><p>Poof! The server’s keyboard and monitor should work again.</p><p>To have your machine use the serial console at every boot, add this statement in <span class="emphasis"><em>/etc/boot.conf</em></span>:</p><a id="I_programlisting5_id436527"/><pre class="programlisting">set tty com0</pre><p>Be sure to test your serial console after the machine is installed in its permanent location, and always screw the serial cables to the server. A loose serial cable provides only a comforting illusion that betrays you when it will hurt the most.</p></div><div class="sect3" title="Testing the Serial Configuration"><div class="titlepage"><div><div><h4 class="title" id="testing_the_serial_configuration">Testing the Serial Configuration</h4></div></div></div><p>After configuring your serial console, return to your serial client and press <span class="smallcaps">ENTER</span>. You should see something like this:</p><a id="I_programlisting5_id436555"/><pre class="programlisting">OpenBSD/amd64 (caddis.blackhelicopters.org) (tty00)
login:</pre></div></div><div class="sect2" title="Changing the Serial Console Speed"><div class="titlepage"><div><div><h3 class="title" id="changing_the_serial_console_speed">Changing the Serial Console Speed</h3></div></div></div><p>Newer serial ports (meaning anything made within the past 10 years) can run at speeds far above 9600 baud. I have servers with serial consoles that run only at 115,200 baud. The BIOS messages display at 115,200 baud, but then the OpenBSD console runs at 9600 baud. My client displays one or the other as gibberish. (A lot of OpenBSD folks think that anything that won’t do serial at 9600 baud is broken, but you won’t always have control over the hardware you work with.)</p><p><a class="indexterm" id="idx0003"/><a class="indexterm" id="idx0101"/><a class="indexterm" id="idx0259"/><a class="indexterm" id="idx0730"/><a class="indexterm" id="idx2088"/><a class="indexterm" id="idx2399"/>To use these ports, I can either change my connection speed in my serial console client when switching between the BIOS messages and the OpenBSD messages, or change the speed of my OpenBSD console to match the hardware.</p><p>At the boot loader, tell the serial console to run at 115,200 baud:</p><a id="I_programlisting5_id436640"/><pre class="programlisting">boot&gt; <span class="strong"><strong>stty com0 115200</strong></span>
boot&gt; <span class="strong"><strong>set tty com0</strong></span></pre><p>If these settings work, copy them to <span class="emphasis"><em>/etc/boot.conf</em></span>.</p><p>Now configure your serial client. Modify <code class="literal">tip</code> to use the higher speed. First, find the entry for <code class="literal">tty00</code> in <span class="emphasis"><em>/etc/remote</em></span>:</p><a id="I_programlisting5_id436678"/><pre class="programlisting">tty00|For hp300,i386,mac68k,macppc,vax:\
        :dv=/dev/tty00:tc=direct:tc=unixhost:</pre><p>But don’t modify this entry! We’ll use it to illustrate the style of <span class="emphasis"><em>/etc/remote</em></span> entries.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note01"/>Note</h3><p><span class="emphasis"><em>/etc/remote</em></span> is designed much like a <code class="literal">termcap(5)</code> database. If you ever need to write your own <span class="emphasis"><em><code class="literal">termcap</code></em></span> entries from scratch, you’re living your life wrong. But you can recognize the contents and modify existing entries without much pain. If you really want to learn everything about these entries, read the <span class="emphasis"><em><code class="literal">remote(5)</code></em></span> man page.</p></div><p>Backslashes (<code class="literal">\</code>) in this entry mean “continued on the next line.” Colons separate fields. Each line after the first must start with a colon, and each field is a key/value pair.</p><p>Now, to create a console entry that runs at 115,200 baud, use the following:</p><a id="I_programlisting5_id436730"/><pre class="programlisting">console:br#115200:tc=tty00:</pre><p>The first field in an <span class="emphasis"><em>/etc/remote</em></span> entry is the name, and every entry must have a unique name. I named this entry <code class="literal">console</code>. The second field is the <code class="literal">br</code> value. According to <code class="literal">remote(5)</code>, <code class="literal">br</code> stands for bit rate. I’ve set the bit rate to 115,200 baud. The third field is <code class="literal">tc</code>, for “table continues,” which is equal to <code class="literal">tty00</code>. This means that the description of this entry continues in entry <code class="literal">tty00</code>.</p><p>Taken as a whole, this entry means “copy the <code class="literal">tty00</code> entry, and add a bit rate of 115,200.”</p></div><div class="sect2" title="Changing the Client Serial Port"><div class="titlepage"><div><div><h3 class="title" id="changing_the_client_serial_port">Changing the Client Serial Port</h3></div></div></div><p>If you have two OpenBSD machines, each sending its serial console out its first serial port to the other machine’s second serial port, you must tell <code class="literal">tip</code> to connect to the second serial port. The command <code class="literal">tip tty00</code> doesn’t actually connect to the serial port named <code class="literal">tty00</code>—it connects to a port defined by the <span class="emphasis"><em>/etc/remote</em></span> entry named <code class="literal">tty00</code>. That means that you can’t run, say, <code class="literal">tip tty03</code> and connect to serial port tty03 unless you have an <span class="emphasis"><em>/etc/remote</em></span> entry named <code class="literal">tty03</code>. By default, there isn’t one, but you can define one easily, as follows:</p><a id="I_programlisting5_id436822"/><pre class="programlisting">tty03:dv=/dev/tty03:tc=tty00:</pre><p><a class="indexterm" id="idx0177"/><a class="indexterm" id="idx0707"/><a class="indexterm" id="idx0916"/><a class="indexterm" id="idx1233"/><a class="indexterm" id="idx1421"/><a class="indexterm" id="idx2089"/><a class="indexterm" id="idx2230"/><a class="indexterm" id="idx2403"/>This entry is named <code class="literal">tty01</code>. The <code class="literal">dv</code> setting tells <span class="emphasis"><em>/etc/remote</em></span> the physical device to use. Other than this, all settings are copied from the entry called <code class="literal">tty00</code>.</p><p>With these examples, you should be able to use OpenBSD’s <code class="literal">tip</code> to connect to almost any serial console.</p></div><div class="sect2" title="Serial Logins"><div class="titlepage"><div><div><h3 class="title" id="serial_logins">Serial Logins</h3></div></div></div><p>The serial console lets you interact with the boot process. Once your machine is fully multiuser, however, a default serial console will not let you actually log in to OpenBSD. In multiuser mode, OpenBSD uses <code class="literal">getty(8)</code> to initialize terminals and handle logins, and in order to log in to your machine over a serial port, you will need to tell <code class="literal">getty</code> to take charge of the serial line by configuring <span class="emphasis"><em>/etc/ttys</em></span>.</p><p>We’ll discuss <span class="emphasis"><em>/etc/ttys</em></span> further in <a class="xref" href="ch14.html" title="Chapter 14. Everything /etc">Chapter 14</a>, but for now, here’s how to allow logins over the first serial port. Find the entry for <code class="literal">tty00</code>, which should look like this:</p><a id="I_programlisting5_id436960"/><pre class="programlisting">tty00   "/usr/libexec/getty std.9600"   unknown off</pre><p>Remove the last two words, and replace them to match the following:</p><a id="I_programlisting5_id436968"/><pre class="programlisting">tty00   "/usr/libexec/getty std.9600"   <span class="strong"><strong>vt220    on secure</strong></span></pre><p>Now run <code class="literal">kill -1 1</code>, and you should get a login prompt over your serial line.</p></div></div><div class="sect1" title="Multiuser Startup"><div class="titlepage"><div><div><h2 class="title" id="multiuser_startup" style="clear: both">Multiuser Startup</h2></div></div></div><p>When the kernel finishes its core setup and hands control over to userland, <code class="literal">init(8)</code> runs the shell script <span class="emphasis"><em>/etc/rc</em></span>. This script handles all system setup, including mounting filesystems, configuring device nodes, identifying shared libraries, and any other task required to make the system usable. Some tasks are delegated to separate scripts; for example, <span class="emphasis"><em>/etc/netstart</em></span> is used to configure the network.</p><p>In this section, we’ll cover how <span class="emphasis"><em>/etc/rc</em></span> and other startup scripts function, and the flow of the startup process. Armed with this understanding, you should be able to easily configure your OpenBSD machine to start exactly what you need—no more, no less.</p><div class="sect2" title="Startup System Scripts"><div class="titlepage"><div><div><h3 class="title" id="startup_system_scripts">Startup System Scripts</h3></div></div></div><p><a class="indexterm" id="idx0708"/><a class="indexterm" id="idx0712"/><a class="indexterm" id="idx0716"/><a class="indexterm" id="idx0917"/><a class="indexterm" id="idx2031"/><a class="indexterm" id="idx2231"/>The startup system includes the scripts <span class="emphasis"><em>/etc/rc</em></span>, <span class="emphasis"><em>/etc/rc.conf</em></span>, <span class="emphasis"><em>/etc/rc.conf.local</em></span>, <span class="emphasis"><em>/etc/netstart</em></span>, <span class="emphasis"><em>/etc/rc.securelevel</em></span>, <span class="emphasis"><em>/etc/rc.local</em></span>, <span class="emphasis"><em>/etc/rc.shutdown</em></span>, <span class="emphasis"><em>/etc/rc.firsttime</em></span>, <span class="emphasis"><em>/etc/fastboot</em></span>, and the contents of the <span class="emphasis"><em>/etc/rc.d</em></span> directory.</p><div class="sect3" title="The /etc/rc Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_script">The /etc/rc Script</h4></div></div></div><p>On OpenBSD, everything outside the kernel is configured with a shell command, from setting the hostname to starting server daemons. The master script is <span class="emphasis"><em>/etc/rc</em></span>, and it runs all of these commands in the correct order, ensuring that the system is configured exactly the same way at every boot. As a final step, <span class="emphasis"><em>/etc/rc</em></span> runs <code class="literal">getty(8)</code> to present login prompts on all the appropriate terminals.</p><p>Never edit <span class="emphasis"><em>/etc/rc</em></span> unless you’re a very experienced systems administrator with truly unique needs. This is one of the several files in <span class="emphasis"><em>/etc</em></span> that is technically editable, but mere mortals are well advised to <span class="emphasis"><em>treat as binary</em></span>. Instead, whenever you need to disable functions, deactivate them in <span class="emphasis"><em>/etc/rc.conf.local</em></span>. To add new functionality to the startup process, use the shell scripts <span class="emphasis"><em>/etc/rc.securelevel</em></span> and <span class="emphasis"><em>/etc/rc.local,</em></span> or write a shell script for <span class="emphasis"><em>/etc/rc.d</em></span>.</p></div><div class="sect3" title="The /etc/rc.conf Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_conf_script">The /etc/rc.conf Script</h4></div></div></div><p>The <span class="emphasis"><em>/etc/rc.conf</em></span> file contains nothing but the default values for all other startup scripts. Read this file to see the configuration options for different system services. Here’s a small snippet of what you’ll find in <span class="emphasis"><em>rc.conf</em></span>:</p><a id="I_programlisting5_id437201"/><pre class="programlisting">…
bgpd_flags=NO           # for normal use: ""
rarpd_flags=NO          # for normal use: "-a"
bootparamd_flags=NO     # for normal use: ""
rbootd_flags=NO         # for normal use: ""
sshd_flags=""           # for normal use: ""
named_flags=NO          # for normal use: ""
…</pre><p>If a variable is set to <code class="literal">NO</code>, the associated service is disabled by default.</p><p>As you can see, OpenBSD turns off almost everything by default, with one exception: the SSH daemon. Setting the variable to a pair of quotes, as shown after each entry in the preceding snippet, is enough to enable most daemons, and most daemons will run just fine without any command-line flags. However, if a daemon requires a command-line argument in order to run, that argument will be shown as it is in the <code class="literal">-a</code> attached to <code class="literal">rarpd_flags</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch05note02"/>Note</h3><p>At the risk of beating my dead server senseless, never edit <span class="emphasis"><em>/etc/rc.conf</em></span> (treat as binary—remember?). It will be replaced wholesale during a system upgrade. Instead, place your local values in <span class="emphasis"><em>/etc/rc.conf.local</em></span>.</p></div></div><div class="sect3" title="The /etc/rc.conf.local Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_conf_local_script">The /etc/rc.conf.local Script</h4></div></div></div><p><a class="indexterm" id="idx0674"/><a class="indexterm" id="idx0714"/><a class="indexterm" id="idx0724"/><a class="indexterm" id="idx0725"/><a class="indexterm" id="idx2059"/>I’ve mentioned this before, but I’m going to beat you over the head with it: Place your changes to <span class="emphasis"><em>rc.conf</em></span> in <span class="emphasis"><em>rc.conf.local</em></span>. Entries in <span class="emphasis"><em>rc.conf.local</em></span> override the defaults in <span class="emphasis"><em>rc.conf</em></span>.</p><p>For example, say that on a particular machine, you want to run <code class="literal">sshd(8)</code> with extra debugging, and you also want to run <code class="literal">named(8)</code>. Additionally, you want to run the time server <code class="literal">ntpd(8)</code>, and have it correct the time at boot by using the <code class="literal">-s</code> flag. After consulting the documentation for those programs, you add the following lines to <span class="emphasis"><em>rc.conf.local</em></span>:</p><a id="I_programlisting5_id437347"/><pre class="programlisting">sshd_flags="-D"
ntpd_flags="-s"
named_flags=""</pre><p>OpenBSD will start the programs with the flags specified here. If you specify invalid, incorrect, or incompatible flags, the daemon will print error messages to the console.</p></div><div class="sect3" title="The /etc/netstart Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_netstart_script">The /etc/netstart Script</h4></div></div></div><p>While its name differs from the other scripts, <span class="emphasis"><em>/etc/netstart</em></span> is definitely a system startup script. It reads <span class="emphasis"><em>/etc/mygate</em></span>, <span class="emphasis"><em>/etc/myname</em></span>, and all the <span class="emphasis"><em>/etc/hostname.if</em></span> files, and uses the information in them to configure all network interfaces, bridges, routing, and so forth. The file <span class="emphasis"><em>/etc/rc</em></span> runs this script before starting any server daemons, network filesystems, and so on. In single-user mode, you’ll run this script by hand to bring up the network.</p></div><div class="sect3" title="The /etc/rc.securelevel Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_securelevel_script">The /etc/rc.securelevel Script</h4></div></div></div><p>The <span class="emphasis"><em>/etc/rc.securelevel</em></span> shell script runs early in the boot process, before <span class="emphasis"><em>/etc/rc</em></span> raises the system securelevel, but after starting the network. Many programs, particularly those that touch the kernel or intimately affect the filesystem, will not run once the securelevel is raised. If you run such a program, you can add the command to start it to this script. If your local program doesn’t need to run before the system securelevel is raised, you’re better off starting it from <span class="emphasis"><em>rc.local</em></span> or writing a proper <span class="emphasis"><em>rc.d</em></span> script for it.</p><p>One important entry in <span class="emphasis"><em>rc.securelevel</em></span> is the definition of the system securelevel. We’ll discuss securelevels in <a class="xref" href="ch10.html" title="Chapter 10. Securing Your System">Chapter 10</a>. For now, don’t touch the line that sets the securelevel unless you’re already familiar with BSD-based systems and know exactly which toe you’re shooting off.</p></div><div class="sect3" title="The /etc/rc.local Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_local_script">The /etc/rc.local Script</h4></div></div></div><p>After <span class="emphasis"><em>/etc/rc</em></span> does just about everything else, it runs <span class="emphasis"><em>/etc/rc.local</em></span>. You can put commands to start local daemons in <span class="emphasis"><em>rc.local</em></span>, but you’re better off writing an <span class="emphasis"><em>rc.d</em></span> script to start local daemons so you can easily and consistently restart them later. Of course, if you’re lazy, you can get by with <span class="emphasis"><em>rc.local</em></span>.</p></div><div class="sect3" title="The /etc/rc.shutdown Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_shutdown_script">The /etc/rc.shutdown Script</h4></div></div></div><p><a class="indexterm" id="idx0600"/><a class="indexterm" id="idx0722"/><a class="indexterm" id="idx0723"/><a class="indexterm" id="idx0727"/><a class="indexterm" id="idx1924"/><a class="indexterm" id="idx2055"/><a class="indexterm" id="idx2137"/><a class="indexterm" id="idx2187"/><a class="indexterm" id="idx2210"/><a class="indexterm" id="idx2233"/>Whenever you use <code class="literal">reboot(8)</code> or <code class="literal">halt(8)</code>, OpenBSD runs the <span class="emphasis"><em>/etc/rc.shutdown</em></span> script, which you can count on to run extra commands needed to safely shut down your server. Most server software shuts down cleanly without any special intervention, but software that requires data integrity (like databases) may need help shutting down without losing data. Again, if at all possible, write an <span class="emphasis"><em>rc.d</em></span> script to manage your software.</p></div><div class="sect3" title="The /etc/rc.firsttime Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_firsttime_script">The /etc/rc.firsttime Script</h4></div></div></div><p><span class="emphasis"><em>/etc/rc</em></span> runs the script <span class="emphasis"><em>/etc/rc.firsttime</em></span> once, mails the output to root, and deletes <span class="emphasis"><em>rc.firsttime</em></span>. The installer uses <span class="emphasis"><em>rc.firsttime</em></span> for tasks such as fetching firmware that can’t be legally redistributed. While you won’t normally use <span class="emphasis"><em>rc.firsttime</em></span>, you should know that it exists and that you can use it to perform one-time tasks when a machine boots.</p></div><div class="sect3" title="The /etc/fastboot Script"><div class="titlepage"><div><div><h4 class="title" id="the_etc_fastboot_script">The /etc/fastboot Script</h4></div></div></div><p>If the <span class="emphasis"><em>/etc/fastboot</em></span> file exists, OpenBSD assumes that all filesystems are clean (see <a class="xref" href="ch08.html" title="Chapter 8. Disks and Filesystems">Chapter 8</a>), and the boot process skips checking filesystem integrity.</p></div><div class="sect3" title="The /etc/rc.d Directory"><div class="titlepage"><div><div><h4 class="title" id="the_etc_rc_d_directory">The /etc/rc.d Directory</h4></div></div></div><p>The <span class="emphasis"><em>/etc/rc.d</em></span> directory contains shell scripts for managing software, as discussed in the next section. While the system comes with scripts for software included in OpenBSD, add-on packages can provide their own scripts (see <a class="xref" href="ch13.html" title="Chapter 13. Software Management">Chapter 13</a>).</p></div></div><div class="sect2" title="Software Startup Scripts"><div class="titlepage"><div><div><h3 class="title" id="software_startup_scripts">Software Startup Scripts</h3></div></div></div><p>OpenBSD uses shell scripts to start, stop, restart, check, and reconfigure server software. These scripts are found in the directory <span class="emphasis"><em>/etc/rc.d</em></span>. Every piece of server software that comes with OpenBSD has a script in this directory, as do most ports and packages that need scripts for proper startup and shutdown. Use these scripts to manage integrated software without rebooting the server.</p><p>The <span class="emphasis"><em>rc.d</em></span> scripts read their configuration from <span class="emphasis"><em>rc.conf</em></span> and <span class="emphasis"><em>rc.conf.local</em></span>. Most servers run the SSH daemon <code class="literal">sshd</code>, which can be enabled by adding the line <code class="literal">sshd_enable=""</code> to <span class="emphasis"><em>rc.conf.local</em></span>. Look in <span class="emphasis"><em>/etc/rc.d</em></span>, and you’ll find the shell script <span class="emphasis"><em>sshd</em></span>.</p><p>If you change your <code class="literal">sshd</code> configuration, you must restart the daemon. Use the shell script to do this consistently.</p><a id="I_programlisting5_id437731"/><pre class="programlisting"># <span class="strong"><strong>cd /etc/rc.d/</strong></span>
# <span class="strong"><strong>./sshd restart</strong></span>
sshd(ok)
sshd(ok)</pre><p>Of course, you could do the same thing without the shell script simply by identifying the currently running <code class="literal">sshd(8)</code> process, reading the man page to see how to shut it down properly, and then restarting it with the same command-line flags. In the case of <code class="literal">sshd</code>, that’s easy: Running <code class="literal">pkill -1 sshd</code> would tell the daemon to reread its configuration file. But restarting a daemon that requires all sorts of flags <span class="emphasis"><em>is</em></span> a big deal. Automating these system administration tasks ensures that your daemons run consistently.</p><p><a class="indexterm" id="idx0244"/><a class="indexterm" id="idx0357"/><a class="indexterm" id="idx0358"/><a class="indexterm" id="idx0879"/><a class="indexterm" id="idx1812"/><a class="indexterm" id="idx1925"/><a class="indexterm" id="idx2181"/><a class="indexterm" id="idx2253"/><a class="indexterm" id="idx2417"/>To see if a daemon is running, use the <code class="literal">check</code> command to check your shell for the return value. The script will return a <code class="literal">0</code> if the daemon is running and a <code class="literal">1</code> if it isn’t, as shown here:</p><a id="I_programlisting5_id437859"/><pre class="programlisting"># <span class="strong"><strong>./nfsd check</strong></span>
# <span class="strong"><strong>echo $?</strong></span>
1</pre><p>As you can see by the <code class="literal">1</code>, <code class="literal">nfsd</code> is not running.</p><p>The most common use for <code class="literal">check</code> is in shell scripts. You can start the daemon with the argument <code class="literal">start</code> and terminate it with <code class="literal">stop</code>. Use the <code class="literal">restart</code> argument to tell the daemon to reload its configuration.</p><p>In OpenBSD, <span class="emphasis"><em>rc.d</em></span> scripts run when the system boots and again when it shuts down. (Something needs to unmount all those hard drives, shut down daemons, and clean up.) At shutdown, every script in the <span class="emphasis"><em>/etc/rc.d</em></span> folder is called with the <code class="literal">stop</code> argument.</p></div><div class="sect2" title="Third-Party rc.d Scripts"><div class="titlepage"><div><div><h3 class="title" id="third-party_rc_d_scripts">Third-Party rc.d Scripts</h3></div></div></div><p>OpenBSD packages for third-party software include <span class="emphasis"><em>rc.d</em></span> scripts as necessary. For example, the popular database server MySQL <code class="literal">mysql-server</code> package installs the script <span class="emphasis"><em>/etc/rc.d/mysqld</em></span>. To use the package, you must enable it in <span class="emphasis"><em>rc.conf.local</em></span>:</p><a id="I_programlisting5_id437950"/><pre class="programlisting">mysqld_flags=""</pre><p>Once the package is enabled, you can manage your MySQL server just like any other OpenBSD daemon. However, packaged software will still not start automatically at boot, so you must tell OpenBSD to run this particular <span class="emphasis"><em>rc.d</em></span> script at boot and shut down with the <code class="literal">pkg_scripts</code> variable in <span class="emphasis"><em>rc.conf.local</em></span>:</p><a id="I_programlisting5_id437970"/><pre class="programlisting">pkg_scripts="mysqld"</pre><p>The startup process runs the scripts in this variable, in the order given, at boot. The order is important for certain daemons. For example, if you have a database-driven website, you should start the database before the web server. At shutdown, it runs these scripts in reverse order.</p></div><div class="sect2" title="Force-Starting Software"><div class="titlepage"><div><div><h3 class="title" id="force-starting_software">Force-Starting Software</h3></div></div></div><p>Sometimes you don’t want to enable software globally; you just want to run a certain daemon for a short time or to address a specific situation. You can use <span class="emphasis"><em>rc.d</em></span> scripts to manage this software using the <code class="literal">-f</code> flag to force the software to run.</p><p>Now for a real-life example. I previously ran PostgreSQL on my server, but someone kidnapped my pet rats and blackmailed me into using MySQL in exchange for their safe return. I needed to check some data in the old database, however, so I force-started the disabled PostgreSQL server:</p><a id="I_programlisting5_id438009"/><pre class="programlisting"># <span class="strong"><strong>./postgresql -f start</strong></span>
postgresql(ok)</pre><p>If you package or install your own software, I strongly recommend writing your own <span class="emphasis"><em>rc.d</em></span> script. A few minutes spent reading the existing scripts will tell you most of what you need to know. For the rest, read the <code class="literal">rc.d(8)</code> and <code class="literal">rc.subr(8)</code> man pages.</p><p>Now that you can start OpenBSD, let’s set up some user accounts.</p></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id369126"><p><sup>[<a class="para" href="#id369126">11</a>] </sup>On i386 and amd64 systems, this is where the MBR comes in.</p></div><div class="footnote" epub:type="footnote" id="ftn.id418996"><p><sup>[<a class="para" href="#id418996">12</a>] </sup>Granted, a remote keyboard-video-mouse (KVM) system can give you all of this, but very few KVM applications let you copy and paste text from the remote console. That means you’ll need to copy error messages by hand.</p></div></div></section></body></html>