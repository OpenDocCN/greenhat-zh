<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Solving Problems with Classes"><div class="titlepage"><div><div><h1 class="title"><a id="solving_problems_with_classes"/>Chapter 5. Solving Problems with Classes</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id5"/><div class="mediaobject"><a id="I_mediaobject5_d1e8267"/><img src="httpatomoreillycomsourcenostarchimages1273151.png.jpg" alt="image with no caption"/></div></div><p>In this chapter, we’re going to discuss classes and object-oriented programming. As before, the assumption is that you’ve seen the <code class="literal">class</code> declaration in C++ and understand the basic syntax of creating a class, invoking the methods of a class, and so on. We’ll have a quick review in the next section, but we’ll mostly discuss the problem-solving aspects of classes.</p><p>This is another situation in which I think C++ has an advantage over other languages. Because C++ is a hybrid language, the C++ programmer can create classes where appropriate but never has to. By contrast, in a language like Java or C#, all code must appear within the confines of a class declaration. In the hands of expert programmers, this causes no undue harm, but in the hands of novices, it can lead to bad habits. To a Java or C# programmer, everything is an object. While all the code written in these languages must be encapsulated into objects, the result doesn’t always reflect sensible object-oriented design. An object should be a meaningful, closely knit collection of data and code that operates on that data. It shouldn’t be an arbitrary grab bag of leftovers.<a id="IDX-CHP-5-0001" class="indexterm"/></p><p>Because we are programming in C++ and therefore have the choice between procedural and object-oriented programming, we’ll talk about good class design, as well as when classes should and should not be used. Recognizing a situation in which a class would be useful is essential to reaching the higher levels of programming style, but it’s equally important to recognize situations in which a class is going to make things worse.<a id="IDX-CHP-5-0002" class="indexterm"/></p><div class="sect1" title="Review of Class Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="review_of_class_fundamentals"/>Review of Class Fundamentals</h1></div></div></div><p>As always, this book assumes you have previous contact with fundamentals and references for C++ syntax, but let’s review the fundamentals of class syntax so we are on the same page with terminology. A <span class="emphasis"><em>class</em></span> is a blueprint for constructing a particular package of code and data; each variable created according to a class’s blueprint is known as an <span class="emphasis"><em>object</em></span> of that class. Code outside of a class that creates and uses an object of that class is known as a <span class="emphasis"><em>client</em></span> of the class. A <span class="emphasis"><em>class declaration</em></span> names the class and lists all of the <span class="emphasis"><em>members</em></span>, or items inside that class. Each item is either a <span class="emphasis"><em>data member</em></span>—a variable declared within the class—or a <span class="emphasis"><em>method</em></span> (also known as a <span class="emphasis"><em>member function</em></span>), which is a function declared within the class. Member functions can include a special type called a <span class="emphasis"><em>constructor</em></span>, which has the same name as the class and is invoked implicitly when an object of the class is declared. In addition to the normal attributes of a variable or function declaration (such as type, and for functions, the parameter list), each member also has an <span class="emphasis"><em>access specifier</em></span>, which indicates what functions can access the member. A <span class="emphasis"><em>public member</em></span> can be accessed by any code using the object: code inside the class, a client of the class, or code in a <span class="emphasis"><em>subclass</em></span>, which is a class that “inherits” all the code and data of an existing class. A <span class="emphasis"><em>private member</em></span> can be accessed only by the code inside the class. <span class="emphasis"><em>Protected members</em></span>, which we’ll see briefly in this chapter, are similar to private members, except that methods in subclasses can also reference them. Both private and protected members, though, are inaccessible from client code.<a id="IDX-CHP-5-0003" class="indexterm"/><a id="IDX-CHP-5-0004" class="indexterm"/><a id="IDX-CHP-5-0005" class="indexterm"/><a id="IDX-CHP-5-0006" class="indexterm"/><a id="IDX-CHP-5-0007" class="indexterm"/><a id="IDX-CHP-5-0008" class="indexterm"/><a id="IDX-CHP-5-0009" class="indexterm"/><a id="IDX-CHP-5-0010" class="indexterm"/><a id="IDX-CHP-5-0011" class="indexterm"/><a id="IDX-CHP-5-0012" class="indexterm"/><a id="IDX-CHP-5-0013" class="indexterm"/><a id="IDX-CHP-5-0014" class="indexterm"/><a id="IDX-CHP-5-0015" class="indexterm"/><a id="IDX-CHP-5-0016" class="indexterm"/><a id="IDX-CHP-5-0017" class="indexterm"/><a id="IDX-CHP-5-0018" class="indexterm"/><a id="IDX-CHP-5-0019" class="indexterm"/></p><p>Unlike attributes such as the return type, the access specifier inside the class declaration holds until replaced by a different specifier. Thus, each specifier usually appears only once, with the members grouped together by access. This leads programmers to refer to “the public section” or “the private section” of a class, as in, “We should put this method in the private section.”</p><p>Let’s look at a tiny example class declaration:</p><a id="I_programlisting5_d1e8413"/><pre class="programlisting">class <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>sample {
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> public:
      <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>sample();
      <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>sample(int num);
      <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>int doesSomething(double param);
  private:
      <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>int intData;
  }<img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>;</pre><p>This declaration starts by naming the class <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8460"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, so afterward <code class="literal">sample</code> becomes a type name. The declaration begins with a <code class="literal">public</code> access specifier <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8472"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, so until we reach the <code class="literal">private</code> specifier <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8482"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>, everything that follows is public. Many programmers include the public declarations first, expecting the public interface to be of most interest to other readers. The public declarations here are two constructors (<span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8488"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8494"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>) named <code class="literal">sample</code> and another method, <code class="literal">doesSomething</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8506"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. The constructors are implicitly invoked when objects of this class are declared.<a id="IDX-CHP-5-0020" class="indexterm"/></p><a id="I_programlisting5_d1e8518"/><pre class="programlisting">sample object1;
sample object2(15);</pre><p>Here, <code class="literal">object1</code> would invoke the first constructor <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8525"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, known as the <span class="emphasis"><em>default constructor</em></span>, which has no parameters, while <code class="literal">object2</code> would invoke the second constructor <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8537"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> because it specifies a single integer value and thus matches the parameter signature of the second constructor.<a id="IDX-CHP-5-0021" class="indexterm"/><a id="IDX-CHP-5-0022" class="indexterm"/></p><p>The declaration concludes with a private data member, <code class="literal">intData</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8557"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>. Remember that a class declaration ends with a closing brace and a semicolon <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8563"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. This semicolon may look a little mysterious because we don’t conclude functions, <code class="literal">if</code> statement blocks, or any other closing braces with semicolons. The semi-colon’s presence actually indicates that class declarations are also, optionally, object declarations; we could put identifiers in between the closing brace and semicolon and make objects as we make our classes. This isn’t too common in C++, though, especially considering that many programmers put their class definitions in separate files from the programs that use them. The mysterious semicolon appears after the closing brace of a <code class="literal">struct</code>, as well.</p><p>Speaking of <code class="literal">struct</code>, you should know that in C++, <code class="literal">struct</code> and <code class="literal">class</code> denote nearly the same thing. The only difference between the two involves members (data or methods) declared before the first access specifier. In a <code class="literal">struct</code>, these members would be public, while in a <code class="literal">class</code>, they would be private. Good programmers, though, use the two structures in different ways. This is analogous to how any <code class="literal">for</code> loop could be written as a <code class="literal">while</code> loop, but a good programmer can make code more readable by using <code class="literal">for</code> loops in more straightforward counting loops. Most programmers reserve <code class="literal">struct</code> for simpler structures, either those with no data members beyond constructors or those intended for use as parameters to methods of a larger class.</p></div><div class="sect1" title="Goals of Class Use"><div class="titlepage"><div><div><h1 class="title"><a id="goals_of_class_use"/>Goals of Class Use</h1></div></div></div><p>In order to recognize the right and wrong situations for class use and the right and wrong way to build a class, we have to decide what our goals are for using classes in the first place. In considering this, we should remember that classes are always optional. That is, classes do not give us new capabilities in the way that an array or a pointer-based structure does. If you take a program that uses an array to sort 10,000 records, it won’t be possible to write that same program without the array. If you have a program that depends on a linked list’s ability to grow and shrink over time, you won’t be able to create the same effects with the same efficiency without using a linked list or similar pointer-based structure. If you take away the classes from an object-oriented program, though, and rewrite it, the program will look different, but the capabilities and efficiency of the program will not be diminished. Indeed, early C++ compilers worked as preprocessors. The C++ compiler would read C++ source code and output new source on the fly that was legal C syntax. This modified source code would then be sent to a C compiler. What this tells us is that the major additions that C++ made to the C language were not about the functional capabilities of the language but about how the source code reads to the programmer.<a id="IDX-CHP-5-0023" class="indexterm"/></p><p>Therefore, in choosing our general class design goals, we are choosing goals to help us, as programmers, accomplish our tasks. In particular, because this book is about problem solving, we should think about how classes help us solve problems.</p><div class="sect2" title="Encapsulation"><div class="titlepage"><div><div><h2 class="title"><a id="encapsulation"/>Encapsulation</h2></div></div></div><p>The word <span class="emphasis"><em>encapsulation</em></span> is a fancy way of saying that classes put multiple pieces of data and code together into a single package. If you’ve ever seen a gelatin medicine capsule filled with little spheres, that’s a good analogy: The patient takes one capsule and swallows all the individual ingredient spheres inside.<a id="IDX-CHP-5-0024" class="indexterm"/><a id="IDX-CHP-5-0025" class="indexterm"/></p><p>Encapsulation is the mechanism that allows many of the other goals we list below to succeed, but it is also a benefit in itself because it organizes our code. In a long program listing of purely procedural code (in C++, this would mean code with functions but no classes), it can be difficult to find a good order for our functions and compiler directives that allows us to easily remember their locations. Instead, we’re forced to rely on our development environment to find our functions for us. Encapsulation keeps stuff together that goes together. If you’re working on a class method and you realize you need to look at or modify other code, it’s likely that other code appears in another method of the same class and is therefore nearby.</p></div><div class="sect2" title="Code Reuse"><div class="titlepage"><div><div><h2 class="title"><a id="code_reuse"/>Code Reuse</h2></div></div></div><p>From a problem-solving standpoint, encapsulation allows us to more easily reuse the code from previous problems to solve current problems. Often, even though we have worked on a problem similar to our current project, reusing what we learned before still takes a lot of work. A fully encapsulated class can work like an external USB drive; you just plug it in and it works. For this to happen, though, we must design the class correctly to make sure that the code and data is truly encapsulated and as independent as possible from anything outside of the class. For example, a class that references a global variable can’t be copied into a new project without copying the global variable, as well.</p><p>Beyond reusing classes from one program to the next, classes offer the potential for a more immediate form of code reuse: inheritance. Recall that, back in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, we talked about using helper functions to “factor out” the code common to two or more functions. Inheritance takes this idea to a larger scale. Using inheritance, we create parent classes with methods common to two or more child classes, thereby “factoring out” not just a few lines of code but whole methods. Inheritance is a large subject unto itself, and we’ll explore this form of code reuse later in the chapter.</p></div><div class="sect2" title="Dividing the Problem"><div class="titlepage"><div><div><h2 class="title"><a id="dividing_the_problem"/>Dividing the Problem</h2></div></div></div><p>One technique we’ve returned to again and again is dividing a complex problem into smaller, more manageable pieces. Classes are great at dividing programs up into functional units. Encapsulation not only holds data and code together in a reusable package; it also cordons off that data and code from the rest of the program, allowing us to work on that class, and everything else separately. The more classes we make in a program, the greater the problem-dividing effect.<a id="IDX-CHP-5-0026" class="indexterm"/></p><p>So, where possible, we should let the class be our method of dividing complex problems. If the classes are well designed, this will enforce functional separation, and the problem will be easier to solve. As a secondary effect, we may find that classes we created for one problem are reusable in other problems, even if we didn’t fully consider that possibility when we created them.</p></div><div class="sect2" title="Information Hiding"><div class="titlepage"><div><div><h2 class="title"><a id="information_hiding"/>Information Hiding</h2></div></div></div><p>Some people use the terms <span class="emphasis"><em>information hiding</em></span> and <span class="emphasis"><em>encapsulation</em></span> interchangeably, but we’ll separate the ideas here. As described previously in this chapter, encapsulation is packaging data and code together. Information hiding means separating the interface of a data structure—the definition of the operations and their parameters—from the implementation of a data structure, or the code inside the functions. If a class has been written with information hiding as a goal, then it’s possible to change the implementation of the methods without requiring any changes in the client code (the code that uses the class). Again, we have to be clear on the term <span class="emphasis"><em>interface</em></span>; this means not only the name of the methods and their parameter list but also the explanation (perhaps expressed in code documentation) of what the different methods do. When we talk about changing the implementation without changing the interface, we mean that we change <span class="emphasis"><em>how</em></span> the class methods work but not <span class="emphasis"><em>what</em></span> they do. Some programming authors have referred to this as a kind of implicit contract between the class and the client: The class agrees never to change the effects of existing operations, and the client agrees to use the class strictly on the basis of its interface and to ignore any implementation details. Think of having a universal remote that can control any television, whether that’s an old tube model or one that uses an LCD or plasma screen. You press 2, then 5, then Enter, and any of the screens will display channel 25, even though the mechanism to make that happen is vastly different depending on the underlying technology.<a id="IDX-CHP-5-0027" class="indexterm"/><a id="IDX-CHP-5-0028" class="indexterm"/><a id="IDX-CHP-5-0029" class="indexterm"/></p><p>There is no way to have information hiding without encapsulation, but as we have defined the terms, it’s possible to have encapsulation without information hiding. The most obvious way this can happen is if a class’s data members are declared <code class="literal">public</code>. In such a case, the class is still an encapsulation, in that it’s a package of code and data that belong together. However, the client code now has access to an important class implementation detail: the variables and types the class uses to store its data. Even if the client code doesn’t modify the class data directly and only inspects it, the client code then requires that particular class implementation. Any change to the class that changes the name or type of any of the variables accessed by the client code requires changes to the client code, as well.<a id="IDX-CHP-5-0030" class="indexterm"/></p><p>Your first thought might be that information hiding is assured so long as all data is made private and we spend enough time designing the list of member functions and their parameter lists so that they never need to change. While all of that is required for information hiding, it’s not sufficient because information-hiding problems can be more subtle. Remember that the class is agreeing not to change what any of the methods do, regardless of the situation. In previous chapters, we’ve had to decide the smallest case a function will handle or what to do with an anomalous case, like finding the average of an array when the parameter that stores the size of the array is zero. Changing the result of a method even for an oddball case represents a change of the interface and should be avoided. This is another reason why explicitly considering special cases is so important in programming. Many a program has blown up when its underlying technology or application programming interface (API) has been updated, and some system call that used to reliably return a −1 when one of the parameters was erroneous now returns a seemingly random, but still negative, number. One of the best ways to avoid this problem is to state special case results in the class or method documentation. If your own documentation says that you return a −1 error code when a certain situation occurs, you’ll think twice about having your method return anything else.</p><p>So how does information hiding affect problem solving? The principle of information hiding tells the programmer to put aside class implementation details when working on the client code, or more broadly, to be concerned about a particular class’s implementation only when working inside that class. When you can put implementation details out of your mind, you can eliminate distracting thoughts and concentrate on solving the problem at hand.</p><p>We should be aware, however, of the limitations of information hiding as it relates to problem solving. Sometimes implementation details do matter to the client. In previous chapters, we’ve seen the strengths and weaknesses of some array-based and pointer-based data structures. Array-based structures allow random access but cannot easily grow or shrink, while pointer-based structures offer only sequential access but can have pieces added or removed without having to re-create the entire structure. Therefore, a class built with an array-based structure as a foundation will have qualities different from one based on a pointer-based structure.</p><p>In computer science, we often talk about the concept of an <span class="emphasis"><em>abstract data type</em></span>, which is information hiding in its purest form: a data type defined only by its operations. In <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, we discussed the concept of a stack and described how a program’s stack is a contiguous block of memory. But as an abstract data type, a stack is any data type where you can add and remove individual items, and the items are removed in the opposite order that they were added. This is known as last-in first-out ordering, or LIFO. Nothing requires a stack to be a contiguous block of memory, and we could make a stack using a linked list. Because a contiguous block of memory and a linked list have different properties, a stack that uses one implementation or the other will also have different properties, and these may make a big difference to the client using the stack.<a id="IDX-CHP-5-0031" class="indexterm"/><a id="IDX-CHP-5-0032" class="indexterm"/><a id="IDX-CHP-5-0033" class="indexterm"/><a id="IDX-CHP-5-0034" class="indexterm"/></p><p>The point of all this is that information hiding will be a useful goal for us as problem solvers, to the extent it allows us to divide problems and work on different parts of a program separately. We cannot, however, allow ourselves to ignore implementation details entirely.</p></div><div class="sect2" title="Readability"><div class="titlepage"><div><div><h2 class="title"><a id="readability"/>Readability</h2></div></div></div><p>A good class enhances the readability of the program in which it appears. Objects can correspond to how we look at the real world, and therefore method calls often have an English-like readability. Also, the relationship between objects is often clearer than the relationship between simple variables. Enhancing readability enhances our ability to solve problems, because we can understand our own code more easily while it is in development and because reuse is enhanced when old code is easy to follow.<a id="IDX-CHP-5-0035" class="indexterm"/></p><p>To maximize the readability benefit of classes, we need to think about how the methods of our class will be used in practice. Method names should be chosen with care to reflect the most specific meaning of the method’s effects. For example, consider a class representing a financial investment that contains a method for computing the future value. The name <code class="literal">compute</code> doesn’t convey nearly as much information as <code class="literal">computeFutureValue</code>. Even choosing the right part of speech for the name can be helpful. The name <code class="literal">computeFutureValue</code> is a verb, while <code class="literal">futureValue</code> is a noun. Look at how the names are used in the code samples that follow:</p><a id="I_programlisting5_d1e8753"/><pre class="programlisting">double FV;
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> investment.computeFutureValue(FV, 2050);

<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> if (investment.futureValue(2050) &gt; 10000) { ...</pre><p>If you think about it, the former makes more sense for a call that would stand alone, that is, a <code class="literal">void</code> function in which the future value is sent back to the caller via a reference parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8772"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. The latter makes better sense for a call that would be used in an expression, that is, the future value comes back as the value of the function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e8778"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>.</p><p>We’ll see specific examples later in the chapter, but the guiding principle for maximizing readability is to always think about the client code when you are writing any part of the class interface.</p></div><div class="sect2" title="Expressiveness"><div class="titlepage"><div><div><h2 class="title"><a id="expressiveness"/>Expressiveness</h2></div></div></div><p>A final goal of a well-designed class is expressiveness, or what might be broadly called writability—the ease with which code can be written. A good class, once written, makes the rest of the code simpler to write in the same way that a good function makes code simpler to write. Classes effectively extend the language, becoming high-level counterparts to basic low-level features such as loops, <code class="literal">if</code> statements, and so forth. In C++, even central functionality like input and output is not an inherent part of the language syntax but is provided as a set of classes that must be explicitly included in the program that uses it. With classes, programming actions that previously took many steps can be done in just a few steps or just one. As problem solvers, we should make this goal a special priority. We should always be thinking, “How is this class going to make the rest of this program, and future programs that may use this class, easier to write?”</p></div></div><div class="sect1" title="Building a Simple Class"><div class="titlepage"><div><div><h1 class="title"><a id="building_a_simple_class"/>Building a Simple Class</h1></div></div></div><p>Now that we know what goals our classes should aim for, it’s time to put theory into practice and build some classes. First, we’ll develop our class in stages for use in the following problem.</p><div class="sidebar"><a id="problem_colon_class_roster"/><p class="title">Problem: Class Roster</p><p>Design a class or set of classes for use in a program that maintains a class roster. For each student, store the student’s name, ID, and final grade score in the range 0–100. The program will allow student records to be added or removed; display the record of a particular student, identified by ID, with the grade displayed as a number and as a letter; and display the average score for the class. The appropriate letter grade for a particular score is shown in <a class="xref" href="ch05.html#letter_grades" title="Table 5-1. Letter Grades">Table 5-1</a>.</p></div><div class="table"><a id="letter_grades"/><p class="title">Table 5-1. Letter Grades</p><div class="table-contents"><table summary="Letter Grades" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Score Range</p></th><th style="text-align: left" valign="bottom"><p>Letter Grade</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>93–100</p></td><td style="text-align: left" valign="top"><p>A</p></td></tr><tr><td style="text-align: left" valign="top"><p>90–92</p></td><td style="text-align: left" valign="top"><p>A–</p></td></tr><tr><td style="text-align: left" valign="top"><p>87–89</p></td><td style="text-align: left" valign="top"><p>B+</p></td></tr><tr><td style="text-align: left" valign="top"><p>83–86</p></td><td style="text-align: left" valign="top"><p>B</p></td></tr><tr><td style="text-align: left" valign="top"><p>80–82</p></td><td style="text-align: left" valign="top"><p>B–</p></td></tr><tr><td style="text-align: left" valign="top"><p>77–79</p></td><td style="text-align: left" valign="top"><p>C+</p></td></tr><tr><td style="text-align: left" valign="top"><p>73–76</p></td><td style="text-align: left" valign="top"><p>C</p></td></tr><tr><td style="text-align: left" valign="top"><p>70–72</p></td><td style="text-align: left" valign="top"><p>C–</p></td></tr><tr><td style="text-align: left" valign="top"><p>67–69</p></td><td style="text-align: left" valign="top"><p>D+</p></td></tr><tr><td style="text-align: left" valign="top"><p>60–66</p></td><td style="text-align: left" valign="top"><p>D</p></td></tr><tr><td style="text-align: left" valign="top"><p>0–59</p></td><td style="text-align: left" valign="top"><p>F</p></td></tr></tbody></table></div></div><p>We’ll start by looking at a basic class framework that forms the foundation of the majority of classes. Then we’ll look at ways in which the basic framework is expanded.</p><div class="sect2" title="The Basic Class Framework"><div class="titlepage"><div><div><h2 class="title"><a id="the_basic_class_framework"/>The Basic Class Framework</h2></div></div></div><p>The best way to explore the basic class framework is through a sample class. For this example, we’re going to start from the student <code class="literal">struct</code> from <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a> and build it into a full class. For ease of reference, here’s the original <code class="literal">struct</code>:<a id="IDX-CHP-5-0036" class="indexterm"/><a id="IDX-CHP-5-0037" class="indexterm"/><a id="IDX-CHP-5-0038" class="indexterm"/><a id="IDX-CHP-5-0039" class="indexterm"/><a id="IDX-CHP-5-0040" class="indexterm"/><a id="IDX-CHP-5-0041" class="indexterm"/><a id="IDX-CHP-5-0042" class="indexterm"/><a id="IDX-CHP-5-0043" class="indexterm"/><a id="IDX-CHP-5-0044" class="indexterm"/><a id="IDX-CHP-5-0045" class="indexterm"/></p><a id="I_programlisting5_d1e8954"/><pre class="programlisting">struct student {
    int grade;
    int studentID;
    string name;
};</pre><p>Even with a simple <code class="literal">struct</code> in this form, we at least get encapsulation. Remember that in <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a> we built an array of student data with this <code class="literal">struct</code>, and without using the <code class="literal">struct</code>, we would have had to build three parallel arrays, one each for the grades, IDs, and names—ugly! What we definitely don’t get with this <code class="literal">struct</code>, though, is information hiding. The basic class framework gives us information hiding by declaring all the data as private and then adding public methods to allow client code to indirectly access, or change, this data.</p><a id="I_programlisting5_d1e8972"/><pre class="programlisting">class studentRecord {
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> public:
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentRecord();
      studentRecord(int newGrade, int newID, string newName);
    <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>int grade();
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>void setGrade(int newGrade);
      int studentID();
      void setStudentID(int newID);
      string name();
      void setName(string newName);
<img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/> private:
    <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>int _grade;
      int _studentID;
      string _name;
  };</pre><p>As promised, this class declaration is separated into a public section with member functions <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9013"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and a private section <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9019"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>, which contains the same data as the original <code class="literal">struct</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9028"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. There are eight member functions: two constructors <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9034"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> and then a pair of member functions for each data member. For example, the <code class="literal">_grade</code> data member has two associated member functions, <code class="literal">grade</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9047"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> and <code class="literal">setGrade</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9056"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. The first of these methods will be used by client code to retrieve the grade of a particular <code class="literal">studentRecord</code>, while the second of these methods is used to store a new grade for this particular <code class="literal">studentRecord</code>.<a id="IDX-CHP-5-0046" class="indexterm"/><a id="IDX-CHP-5-0047" class="indexterm"/><a id="IDX-CHP-5-0048" class="indexterm"/></p><p>Retrieval and store methods associated with a data member are so common that they are typically referred to by the shorthand terms <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>set</em></span>. As you can see, I incorporated the word <span class="emphasis"><em>set</em></span> into the methods that store new values into the data members. Many programmers would have also incorporated <span class="emphasis"><em>get</em></span> into the other names, for example, <code class="literal">getGrade</code> instead of <code class="literal">grade</code>. Why didn’t I do this? Because then I would have been using a verb name for a function that is used as a noun. Some would argue, though, that the <span class="emphasis"><em>get</em></span> term is so universally understood, and its meaning therefore so clear, that its use overrides the other concern. Ultimately, that’s a matter of personal style.<a id="IDX-CHP-5-0049" class="indexterm"/><a id="IDX-CHP-5-0050" class="indexterm"/><a id="IDX-CHP-5-0051" class="indexterm"/></p><p>Although I’ve been quick in this book to point out the advantages C++ has over other languages, I must admit that more recent languages, like C#, have C++ beat when it comes to <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>set</em></span> methods. C# has a built-in mechanism called a property that acts as both a <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>set</em></span> method. Once defined, the client code can access the property as though it were a data member rather than a function call. This is a great enhancement to readability and expressiveness. In C++, without a built-in mechanism, it’s important that we decide on some naming convention for our methods and use it consistently.</p><p>Note that my naming convention extends to the data members, which, unlike the original <code class="literal">struct</code>, all begin with underscores. This allows me to name the <span class="emphasis"><em>get</em></span> functions with (almost) the same name as the data members they retrieve. This also allows easy recognition of data member references in code, enhancing readability. Some programmers use the keyword <code class="literal">this</code> for all data member references instead of using an underscore prefix. So instead of a statement such as:</p><a id="I_programlisting5_d1e9140"/><pre class="programlisting">return _grade;</pre><p>they would have:</p><a id="I_programlisting5_d1e9145"/><pre class="programlisting">return this.grade;</pre><p>If you haven’t seen the keyword <code class="literal">this</code> before, it’s a reference to the object in which it appears. So if the statement above appeared in a class method and that method also declared a local variable with the name <code class="literal">grade</code>, the expression <code class="literal">this.grade</code> would refer to the data member <code class="literal">grade</code>, not the local variable with the same name. Employing the keyword in this way has an advantage in a development environment with automatic syntax completion: The programmer can just type <strong class="userinput"><code>this</code></strong>, press the period key, and select the data member from a list, avoiding extra typing and potential misspellings. Either technique highlights data member references, though, which is what’s important.</p><p>Now that we’ve seen the class declaration, let’s look at the implementation of the methods. We’ll start with the first <span class="emphasis"><em>get/set</em></span> pair.</p><a id="I_programlisting5_d1e9169"/><pre class="programlisting">int studentRecord::grade() {
   <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>return _grade;
}
void studentRecord::setGrade(int newGrade) {
   <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>_grade = newGrade;
}</pre><p>This is the most basic form of the <span class="emphasis"><em>get/set</em></span> pair. The first method, <code class="literal">grade</code>, returns the current value of the associated data member, <code class="literal">_grade</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9194"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. The second method, <code class="literal">setGrade</code>, assigns the value of the parameter <code class="literal">newGrade</code> to the data member <code class="literal">_grade</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9210"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. If this were all we did with our class, however, we wouldn’t have accomplished anything. Although this code provides information hiding because it passes data in both directions without any consideration or modification, it’s only better than having <code class="literal">_grade</code> declared public because it reserves us the right to change the data member’s name or type. The <code class="literal">setGrade</code> method should at least perform some rudimentary validation; it should prevent values of <code class="literal">newGrade</code> that don’t make sense as a grade from being assigned to the <code class="literal">_grade</code> data member. We have to be careful to follow problem specifications, though, and not to make assumptions about data based on our own experiences, without consideration of the user. It might be reasonable to limit grades to the range 0–100, but it might not, for example, if a school allows extra credit to push a score above 100 or uses a grade of −1 as a code for a class withdrawal. In this case, because we are given some guidance by the problem description, we can incorporate that knowledge into validation.<a id="IDX-CHP-5-0052" class="indexterm"/><a id="IDX-CHP-5-0053" class="indexterm"/></p><a id="I_programlisting5_d1e9239"/><pre class="programlisting">void studentRecord::setGrade(int newGrade) {
    if ((newGrade &gt;= 0) &amp;&amp; (newGrade &lt;= 100))
        _grade = newGrade;
}</pre><p>Here, the validation is just a gatekeeper. Depending upon the definition of the problem, however, it might make sense for the method to produce an error message, write to an error log, or otherwise handle the error.</p><p>The other <span class="emphasis"><em>get/set</em></span> pairs would work exactly the same way. There are undoubtedly rules about the construction of student ID numbers at a particular school that could be used for validation. With a student name, however, the best we can do is reject strings with oddball characters, like <code class="literal">%</code> or <code class="literal">@</code>, and these days perhaps even that wouldn’t be possible.</p><p>The last step in completing our class is writing the constructors. In the basic framework, we include two constructors: a default constructor, which has no parameters and sets the data members to reasonable default values, and a constructor with parameters for every data member. The second constructor form is important for our <span class="emphasis"><em>expressiveness</em></span> goal, as it allows us to create an object of our class and initialize the values inside in one step. Once you have written the code for the other methods, this second constructor almost writes itself.<a id="IDX-CHP-5-0054" class="indexterm"/><a id="IDX-CHP-5-0055" class="indexterm"/><a id="IDX-CHP-5-0056" class="indexterm"/><a id="IDX-CHP-5-0057" class="indexterm"/></p><a id="I_programlisting5_d1e9277"/><pre class="programlisting">studentRecord::studentRecord(int newGrade, int newID, string newName) {
    setGrade(newGrade);
    setStudentID(newID);
    setName(newName);
}</pre><p>As you can see, the constructor merely calls the appropriate <span class="emphasis"><em>set</em></span> methods for each of the parameters. In most cases, this is the correct approach because it avoids duplicating code and ensures that the constructor will take advantage of any validation code in the <span class="emphasis"><em>set</em></span> methods.</p><p>The default constructor is sometimes a little tricky, not because the code is complicated but because there is not always an obvious default value. When choosing default values for data members, keep in mind the situations in which an object created with the default constructor would be used and, in particular, whether there is a legitimate default object for that class. This will tell you whether you should fill the data members with useful default values or with values that signal that the object is not properly initialized. For example, consider a class representing a collection of values that encapsulates a linked list. There <span class="emphasis"><em>is</em></span> a meaningful default linked list, and that’s an empty linked list, so we would set our data members to create a legitimate, but conceptually empty, list. But with our sample basic class, there’s no meaningful definition of a default student; we wouldn’t want to give a valid ID number to a default <code class="literal">studentRecord</code> object because that could potentially cause confusion with a legitimate <code class="literal">studentRecord</code>. Therefore, we should choose a default value for the <code class="literal">_studentID</code> field that is obviously illegitimate, such as −1:<a id="IDX-CHP-5-0058" class="indexterm"/><a id="IDX-CHP-5-0059" class="indexterm"/><a id="IDX-CHP-5-0060" class="indexterm"/></p><a id="I_programlisting5_d1e9314"/><pre class="programlisting">studentRecord::studentRecord() {
    setGrade(0);
    setStudentID(-1);
    setName("");
}</pre><p>We assign the grade with <code class="literal">setGrade</code>, which validates its parameter. This means we have to assign a valid grade, in this case, 0. Because the ID is set to an invalid value, the record as a whole can be easily identified as illegitimate. Therefore, the valid grade shouldn’t be an issue. If that were a concern, we could assign an invalid value directly to the <code class="literal">_grade</code> data member.</p><p>This completes the basic class framework. We have a group of private data members that reference attributes of the same logical object, in this case, a student’s class record; we have member functions to retrieve or alter the object’s data, with validation as appropriate; and we have a useful set of constructors. We have a good class foundation. The question is, do we need to do more?</p></div><div class="sect2" title="Support Methods"><div class="titlepage"><div><div><h2 class="title"><a id="support_methods"/>Support Methods</h2></div></div></div><p>A <span class="emphasis"><em>support method</em></span> is a method in a class that does not merely retrieve or store data. Some programmers may refer to these as helper methods, auxiliary methods, or something else, but whatever they are called, they are what take a class beyond the basic class framework. A well-designed set of support methods is often what makes a class truly useful.<a id="IDX-CHP-5-0061" class="indexterm"/><a id="IDX-CHP-5-0062" class="indexterm"/></p><p>To determine possible support methods, consider how the class will be used. Are there common activities we would expect client code to perform on our class’s data? In this case, we’re told that the program for which we are initially designing our class will display students’ grades not only as numerical scores but also as letters. So let’s create a support method that returns a student’s grade as a letter. First, we’ll add the method declaration to the public section of our class declaration.</p><a id="I_programlisting5_d1e9344"/><pre class="programlisting">string letterGrade();</pre><p>Now we need to implement this method. The function will convert the numerical value stored in <code class="literal">_grade</code> to the appropriate <code class="literal">string</code> based on the grade table shown in the problem. We could accomplish this with a series of <code class="literal">if</code> statements, but is there a cleaner, more elegant way? If you just thought, “Hey, this sounds a lot like how we converted incomes into business license categories back in <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a>,” congratulations—you’ve spotted an apt programming analogy. We can adapt that code, with parallel <code class="literal">const</code> arrays to store the letter grades and the lowest numerical scores associated with those grades, to convert the numerical score with a loop.<a id="IDX-CHP-5-0063" class="indexterm"/><a id="IDX-CHP-5-0064" class="indexterm"/><a id="IDX-CHP-5-0065" class="indexterm"/><a id="IDX-CHP-5-0066" class="indexterm"/><a id="IDX-CHP-5-0067" class="indexterm"/><a id="IDX-CHP-5-0068" class="indexterm"/></p><a id="I_programlisting5_d1e9387"/><pre class="programlisting">string studentRecord::letterGrade() {
    const int NUMBER_CATEGORIES = 11;
    const string GRADE_LETTER[] = {"F", "D", "D+", "C-",
 "C", "C+", "B-", "B", "B+", "A-", "A"};
    const int LOWEST_GRADE_SCORE[] = {0, 60, 67, 70, 73, 77, 80, 83, 87, 90, 93};
    int category = 0;
    while (category &lt; NUMBER_CATEGORIES &amp;&amp; LOWEST_GRADE_SCORE[category] &lt;= _grade)
        category++;
    return GRADE_LETTER[category - 1];
}</pre><p>This method is a direct adaptation of the function from <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a>, so there’s nothing new to explain about how the code works. However, its adaptation for a class method does introduce some design decisions. The first thing to note is that we have not created a new data member to store the letter grade but instead to compute the appropriate letter grade on the fly for every request. The alternative approach would be to have a <code class="literal">_letterGrade</code> data member and rewrite the <code class="literal">setGrade</code> method to update <code class="literal">_letterGrade</code> alongside <code class="literal">_grade</code>. Then this <code class="literal">letterGrade</code> method would become a simple <span class="emphasis"><em>get</em></span> method, returning the value of the already-computed data member.</p><p>The issue with this approach is <span class="emphasis"><em>data redundancy</em></span>, a term describing a situation in which data is stored that is either a literal duplicate of other data or can be directly determined from other data. This issue is most commonly seen with databases, and database designers follow elaborate processes to avoid creating redundant data in their tables. Data redundancy can occur in any program, however, if we are unwary. To see the danger, consider a medical records program that stores age and date of birth for each of a set of patients. The date of birth gives us information the age does not. The two data items are therefore not equal, but the age does not tell us anything we can’t already tell from the birth date. And what if the two values are not in agreement (which will happen eventually, unless the age is automatically updated)? Which value do we trust? I’m reminded of the famous (though possibly apocryphal) proclamation of the Caliph Omar when he ordered the burning of the Library of Alexandria. He proclaimed that if the books in the library agreed with the Koran, they were redundant and need not be preserved, but if they disagreed with the Koran, they were pernicious and should be destroyed. Redundant data is trouble waiting to happen. The only justification would be performance, if we thought updates to <code class="literal">_grade</code> would be seldom and calls to <code class="literal">letterGrade</code> would be frequent, but it’s hard to imagine a significant overall performance boost to the program.<a id="IDX-CHP-5-0069" class="indexterm"/><a id="IDX-CHP-5-0070" class="indexterm"/><a id="IDX-CHP-5-0071" class="indexterm"/></p><p>However, this method could be improved. In testing this method, I noticed a problem. Although the method produces correct results for valid values of <code class="literal">_grade</code>, the method crashes when <code class="literal">_grade</code> is a negative value. When the <code class="literal">while</code> loop is reached, the negative value of <code class="literal">_grade</code> causes the loop test to immediately fail; therefore, <code class="literal">category</code> remains zero and the <code class="literal">return</code> statement attempts to reference <code class="literal">GRADE_L</code><code class="literal">ETT</code><code class="literal">ER[-1]</code>. We could avoid this problem by initializing <code class="literal">category</code> to one instead of zero, but that would mean that a negative grade would be assigned “F” when it really shouldn’t be assigned any string at all because, as an invalid grade value, it doesn’t fit into any category.<a id="IDX-CHP-5-0072" class="indexterm"/></p><p>Instead, we could validate <code class="literal">_grade</code> before converting it to a letter grade. We’re already validating grade values in the <code class="literal">setGrade</code> method, so instead of adding new validation code to the <code class="literal">letterGrade</code> method, we should “factor out” what would be the common code in these methods to make a third method. (You might wonder how, if we’re validating grades as they are assigned, we could ever have an invalid grade, but remember that our default constructor assigns −1 to signal that no legitimate grade has been assigned yet.) This is another kind of support method, which is the class equivalent of the general helper function concept introduced in previous chapters. Let’s implement this method and modify our other methods to use it:<a id="IDX-CHP-5-0073" class="indexterm"/></p><a id="I_programlisting5_d1e9488"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> bool studentRecord::<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>isValidGrade(<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>int grade) {
      if ((grade &gt;= 0) &amp;&amp; (grade &lt;= 100))
          return true;
      else
          return false;
  }
  void studentRecord::setGrade(int newGrade) {
      if (<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>isValidGrade(newGrade))
          _grade = newGrade;
  }
  string studentRecord::letterGrade() {
      if (<img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>!isValidGrade(_grade)) return "ERROR";
      const int NUMBER_CATEGORIES = 11;
      const string GRADE_LETTER[] = {"F", "D", "D+",
 "C-", "C", "C+", "B-", "B", "B+", "A-", "A"};
      const int LOWEST_GRADE_SCORE[] = {0, 60, 67, 70, 73, 77, 80, 83, 87, 90, 93};
      int category = 0;
      while (category &lt; NUMBER_CATEGORIES &amp;&amp; LOWEST_GRADE_SCORE[category] &lt;= _grade)
          category++;
      return GRADE_LETTER[category - 1];
  }</pre><p>The new grade validation method is of type <code class="literal">bool</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9525"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, and since this is a yes-or-no issue I’ve chosen the name <code class="literal">isValidGrade</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9534"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. This gives the most English-like reading to calls to this method, such as those in the <code class="literal">setGrade</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9544"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> and <code class="literal">letterGrade</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9553"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span> methods. Also, note that the method takes the grade to validate as a parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9559"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Although <code class="literal">letterGrade</code> is validating the value already in the <code class="literal">_grade</code> data member, <code class="literal">setGrade</code> is validating the value that we may or may not assign the data member. So <code class="literal">isValidGrade</code> needs to take the grade as a parameter to be useful to both of the other methods.<a id="IDX-CHP-5-0074" class="indexterm"/><a id="IDX-CHP-5-0075" class="indexterm"/><a id="IDX-CHP-5-0076" class="indexterm"/><a id="IDX-CHP-5-0077" class="indexterm"/><a id="IDX-CHP-5-0078" class="indexterm"/></p><p>Although the <code class="literal">isValidGrade</code> method is implemented, one decision regarding it remains: What access level should we assign to it? That is, should we place it in the public section of the class or the private section? Unlike the <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>set</em></span> methods of the basic class framework, which always go in the public section, support methods may be public or private depending on their use. What are the effects of making <code class="literal">isValidGrade</code> public? Most obviously, client code can access the method. Because having more public methods appears to make a class more useful, many novice programmers make every method public that could possibly be used by the client. This, however, ignores the other effect of the public access designation. Remember that the public section defines the interface of our class, and we should be reluctant to change the method once our class is integrated into one or more programs because such a change is likely to cascade and require changes in all the client code. Placing a method in the public section, therefore, locks the method’s interface and its effects. In this case, suppose that some client code, based on the original formulation of <code class="literal">isValidGrade</code>, relies upon it as a 0–100 range checker, but later, the rules for acceptable grades get more complicated. The client code could fail. To avoid that, we might have to instead create a second grade validation method inside the class and leave the first one alone.<a id="IDX-CHP-5-0079" class="indexterm"/></p><p>Let’s suppose that we expect <code class="literal">isValidGrade</code> to be of limited use to the client and have decided not to make it public. We could make the method private, but that’s not the only choice. Because the function does not directly reference any data member or any other method of the class, we could declare the function outside of the class altogether. This, however, not only creates the same problem public access has on modifiability but also lowers encapsulation because now this function, which is required by the class, is no longer part of it. We could also leave the method in the class but make it <span class="emphasis"><em>protected</em></span> instead of private. The difference would be seen in any subclasses. If <code class="literal">isValidGrade</code> is protected, the method can be called by methods in subclasses; if <code class="literal">isValidGrade</code> is private, it can be used only by other methods in the <code class="literal">studentRecord</code> class. This is the same quandary as public versus private on a smaller scale. Do we expect methods in subclasses to get much use from our method, and do we expect that the method’s effect or its interface could change in the future? In many cases, the safest thing to do is make all helper methods private and make public only those support methods that were written to benefit the client.</p></div></div><div class="sect1" title="Classes with Dynamic Data"><div class="titlepage"><div><div><h1 class="title"><a id="classes_with_dynamic_data"/>Classes with Dynamic Data</h1></div></div></div><p>One of the best reasons to create a class is to encapsulate dynamic data structures. As we discussed back in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, programmers face a real chore keeping track of dynamic allocations, pointer assignments, and deallocations so that we avoid memory leaks, dangling references, and illegal memory references. Putting all of the pointer references into a class doesn’t eliminate the difficult work, but it does mean that once we’ve got it right, we can safely drop that code into other projects. It also means that any problems with our dynamic data structure are isolated to the code within the class itself, simplifying debugging.<a id="IDX-CHP-5-0080" class="indexterm"/><a id="IDX-CHP-5-0081" class="indexterm"/><a id="IDX-CHP-5-0082" class="indexterm"/><a id="IDX-CHP-5-0083" class="indexterm"/></p><p>Let’s build a class with dynamic data to see how this works. For our sample problem, we’re going to use a modified version of the major problem from <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>.</p><div class="sidebar"><a id="problem_colon_tracking_an_unknown_qu"/><p class="title">Problem: Tracking an Unknown Quantity of Student Records</p><p>In this problem, you will write a class with methods to store and manipulate a collection of student records. A student record contains a student number and a grade, both integers, and a string for the student name. The following functions are to be implemented:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>addRecord</code></strong></span></dt><dd><p>This method takes a student number, name, and grade and adds a new record with this data to the collection.</p></dd><dt><span class="term"><strong class="userinput"><code>recordWithNumber</code></strong></span></dt><dd><p>This function takes a student number and retrieves the record with that student number from the collection.</p></dd><dt><span class="term"><strong class="userinput"><code>removeRecord</code></strong></span></dt><dd><p>This function takes a student number and removes the record with that student number from the collection.</p></dd></dl></div><p>The collection can be of any size. The <em class="replaceable"><code>addRecord</code></em> operation is expected to be called frequently, so it must be implemented efficiently.</p></div><p>The main differences between this description and the original version are that we’ve added a new operation, <code class="literal">recordWithNumber</code>, and also that none of the operations make any reference to a pointer parameter. This is the key benefit of using a class to encapsulate a linked list. The client may be aware that the class implements the student record collection as a linked list and may even be counting on that (remember our prior discussion about the limitations of information hiding). The client code, however, will have no direct interaction with the linked list or any pointer in the class.</p><p>Because this problem is storing the same information per student as the previous problem, we have an opportunity for class reuse here. In our linked list node type, instead of separate fields for each of the three pieces of student data, we’ll have one <code class="literal">studentRecord</code> object. Using an object of one class as a data type in a second class is known as <span class="emphasis"><em>composition</em></span>.<a id="IDX-CHP-5-0084" class="indexterm"/><a id="IDX-CHP-5-0085" class="indexterm"/></p><p>We have enough information now to make a preliminary class declaration:</p><a id="I_programlisting5_d1e9719"/><pre class="programlisting">class studentCollection {
  private:
    <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>struct studentNode {
        <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentRecord studentData;
          studentNode * next;
      };
<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/> public:
      studentCollection();
      void addRecord(studentRecord newStudent);
      studentRecord recordWithNumber(int idNum);
      void removeRecord(int idNum);
  private:
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>typedef studentNode * studentList;
    <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>studentList _listHead;
  };</pre><p>Previously, I said programmers tend to start classes with public declarations, but here we have to make an exception. We begin with a private declaration of the node <code class="literal">struct</code>, <code class="literal">studentNode</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9759"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which we’ll use to make our linked list. This declaration has to come before the public section because several of our public member functions reference this type. Unlike our node type in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, this node doesn’t have individual fields for the payload data but rather includes a member of the <code class="literal">studentRecord struct</code> type <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9771"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. The public member functions <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9777"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> follow directly from the problem description; plus, as always, we have a constructor. In the second private section, we declare a <code class="literal">typedef</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9786"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> for a pointer to our node type for clarity, just as we did in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>. Then we declare our list head pointer, cleverly called <code class="literal">_listHead</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9798"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>.<a id="IDX-CHP-5-0086" class="indexterm"/><a id="IDX-CHP-5-0087" class="indexterm"/><a id="IDX-CHP-5-0088" class="indexterm"/><a id="IDX-CHP-5-0089" class="indexterm"/><a id="IDX-CHP-5-0090" class="indexterm"/><a id="IDX-CHP-5-0091" class="indexterm"/><a id="IDX-CHP-5-0092" class="indexterm"/></p><p>This class declares two private types. Classes can declare types as well as member functions and data members. As with other members, types appearing in the class can be declared with any access specifier. As with data members, though, you should think of type definitions as private by default, and only make them less restrictive if you have a clear reason to do so. Type declarations are typically at the heart of how a class operates behind the scenes, and as such, they are critical to information hiding. Furthermore, in most cases, client code has no use for the types you will declare in your class. An exception occurs when a type defined in the class is used as the return type of a public method or as the type of a parameter to a public method. In this case, the type has to be public or the public method can’t be used by client code. Class <code class="literal">studentCollection</code> assumes that the <code class="literal">struct</code> type <code class="literal">studentRecord</code> will be separately declared, but we could make it part of the class as well. If we did, we would have to declare it in the <code class="literal">public</code> section.<a id="IDX-CHP-5-0093" class="indexterm"/><a id="IDX-CHP-5-0094" class="indexterm"/></p><p>Now we are ready to implement our class methods, starting with the constructor. Unlike our previous example, we have only the default constructor here, not a constructor that takes a parameter to initialize our data member. The whole point of our class is to hide the details of our linked list, so we don’t want the client even thinking about our <code class="literal">_listHead</code>, let alone manipulating it. All we need to do in our default constructor is set the head pointer to <code class="literal">NULL</code>:</p><a id="I_programlisting5_d1e9864"/><pre class="programlisting">studentCollection::studentCollection() {
    _listHead = NULL;
}</pre><div class="sect2" title="Adding a Node"><div class="titlepage"><div><div><h2 class="title"><a id="adding_a_node"/>Adding a Node</h2></div></div></div><p>We move on to <code class="literal">addRecord</code>. Because nothing in the problem description requires us to keep student records in any particular order, we can directly adapt the <code class="literal">addRecord</code> function from <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a> for use here.<a id="IDX-CHP-5-0095" class="indexterm"/><a id="IDX-CHP-5-0096" class="indexterm"/><a id="IDX-CHP-5-0097" class="indexterm"/><a id="IDX-CHP-5-0098" class="indexterm"/><a id="IDX-CHP-5-0099" class="indexterm"/><a id="IDX-CHP-5-0100" class="indexterm"/><a id="IDX-CHP-5-0101" class="indexterm"/><a id="IDX-CHP-5-0102" class="indexterm"/></p><a id="I_programlisting5_d1e9914"/><pre class="programlisting">void studentCollection::addRecord(<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>studentRecord newStudent) {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentNode * newNode = new studentNode;
    <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>newNode-&gt;studentData = newStudent;
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>newNode-&gt;next = _listHead;
    <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>_listHead = newNode;
}</pre><p>There are only two differences between this code and our blueprint function. Here, we need only one parameter in our parameter list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9948"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which is the <code class="literal">studentRecord</code> object we’re going to add to our collection. This encapsulates all of the data for a student, which reduces the number of parameters needed. We also don’t need to pass a list head pointer because that is already stored in our class as <code class="literal">_listHead</code> and is referenced directly when needed. As with the <code class="literal">addRecord</code> function from <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, we create a new node <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9966"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, copy the new student data into the new node <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9972"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, point the next field of the new node at the previous first node in the list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9978"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>, and finally point <code class="literal">_listHead</code> at the new node <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9987"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. Normally I recommend drawing a diagram for all pointer manipulations, but since this is the same manipulation we were already doing, we can reference our previously drawn diagram.</p><p>Now we can turn our attention to the last of the three member functions, <code class="literal">recordWithNumber</code>. That name is a bit of a mouthful, and some programmers might have chosen <span class="emphasis"><em>retrieveRecord</em></span> or something similar. Following my previously stated naming rules, however, I decided to use a noun because this method returns a value. This method will be similar to <code class="literal">averageRecord</code> in that it needs to traverse the list; the difference in this case is that we can stop once we find the matching student record.</p><a id="I_programlisting5_d1e10004"/><pre class="programlisting">studentRecord studentCollection::recordWithNumber(int idNum) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>studentNode * loopPtr = _listHead;
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>while (loopPtr-&gt;studentData.studentID() != idNum) {
        loopPtr = loopPtr-&gt;next;
    }
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>return loopPtr-&gt;studentData;
}</pre><p>In this function, we initialize our loop pointer to the head of the list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10026"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and traverse the list as long as we haven’t seen the desired ID number <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10032"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Finally, arriving at the desired node, we return the entire matching record as the value of the function <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10038"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. This code looks good, but as always, we have to consider potential special cases. The case we always consider when dealing with linked lists is an initially <code class="literal">NULL</code> head pointer. Here, that definitely causes a problem, as we are not checking for that and the code will blow up when we try to dereference <code class="literal">loopPtr</code> upon first entering the loop. More generally, though, we have to consider the possibility that the ID number provided by the client code doesn’t actually match any of the records in our collection. In that case, even if <code class="literal">_listHead</code> is not <code class="literal">NULL</code>, <code class="literal">loopPtr</code> will eventually become <code class="literal">NULL</code> when we reach the end of the list.<a id="IDX-CHP-5-0103" class="indexterm"/><a id="IDX-CHP-5-0104" class="indexterm"/><a id="IDX-CHP-5-0105" class="indexterm"/><a id="IDX-CHP-5-0106" class="indexterm"/><a id="IDX-CHP-5-0107" class="indexterm"/><a id="IDX-CHP-5-0108" class="indexterm"/><a id="IDX-CHP-5-0109" class="indexterm"/></p><p>So the general issue is that we need to stop the loop if <code class="literal">loopPtr</code> becomes <code class="literal">NULL</code>. That’s not difficult, but then, what do we return in this situation? We certainly can’t return <code class="literal">loopPtr-&gt;studentData</code> because <code class="literal">loopPtr</code> will be <code class="literal">NULL</code>. Instead, we can build and return a dummy <code class="literal">studentRecord</code> with obvious invalid values inside.</p><a id="I_programlisting5_d1e10118"/><pre class="programlisting">studentRecord studentCollection::recordWithNumber(int idNum) {
    studentNode * loopPtr = _listHead;
    while (<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>loopPtr != NULL &amp;&amp; loopPtr-&gt;studentData.studentID() != idNum) {
        loopPtr = loopPtr-&gt;next;
    }
    if (<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>loopPtr == NULL) {
      <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>studentRecord dummyRecord(−1, −1, "");
        return dummyRecord;
    } else {
        return loopPtr-&gt;studentData;
    }
}</pre><p>In this version of the method, if our loop pointer is <code class="literal">NULL</code> when the loop is over <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10143"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, we create a dummy record with a null string for a name and −1 values for the grade and student ID <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10149"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> and return that. Back in the loop, we are checking for that <code class="literal">NULL loopPtr</code> condition, which again can happen either because there is no list to traverse or because we have traversed it with no success. One key point here is that the loop’s conditional expression <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10158"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> is a compound expression with <code class="literal">loopPtr != NULL</code> first. This is absolutely required. C++ uses a mechanism for evaluating compound Boolean expressions known as <span class="emphasis"><em>short-circuit evaluation</em></span>; put simply, it doesn’t evaluate the right half of a compound Boolean expression when the overall value of the expression is already known. Because <code class="literal">&amp;&amp;</code> represents a logical Boolean <span class="emphasis"><em>and</em></span>, if the left side of an <code class="literal">&amp;&amp;</code> expression evaluates to false, the overall expression must also be false, regardless of the right-side evaluation. For efficiency, C++ takes advantage of this fact, skipping the evaluation of the right side of an <code class="literal">&amp;&amp;</code> expression when the left side is false (for an <code class="literal">||</code>, logical <span class="emphasis"><em>or</em></span>, the right side is not evaluated when the left side is true, for the same reason). Therefore, when <code class="literal">loopPtr</code> is <code class="literal">NULL</code>, the expression <code class="literal">loopPtr != NULL</code> evaluates to false, and the right side of the <code class="literal">&amp;&amp;</code> is never evaluated. Without short-circuit evaluation, the right side <span class="emphasis"><em>would</em></span> be evaluated, and we would be dereferencing a <code class="literal">NULL</code> pointer, crashing the program.<a id="IDX-CHP-5-0110" class="indexterm"/></p><p>The implementation avoids the potential crash of the first version, but we need to be aware that it places a good deal of trust in the client code. That is, the function that calls this method is responsible for checking the <code class="literal">studentRecord</code> that comes back and making sure it’s not the dummy record before further processing. If you’re like me, this makes you a little uneasy.</p><div class="sidebar"><a id="exceptions"/><p class="title">EXCEPTIONS</p><p>There is another option. C++, as well as many other programming languages, offers a mechanism known as an <span class="emphasis"><em>exception</em></span>, which allows a function, either a method or a general function, to unambiguously signal an error status back to the caller. It’s designed for the kind of situation we have in this method, where there isn’t a good answer for what to return when the input is bad. Exception syntax is more than we can get into here, and unfortunately, the way exceptions are implemented in C++, they don’t solve the trust problem explained in the previous paragraph.<a id="IDX-CHP-5-0111" class="indexterm"/><a id="IDX-CHP-5-0112" class="indexterm"/><a id="IDX-CHP-5-0113" class="indexterm"/><a id="IDX-CHP-5-0114" class="indexterm"/></p></div></div><div class="sect2" title="Rearranging the List"><div class="titlepage"><div><div><h2 class="title"><a id="rearranging_the_list"/>Rearranging the List</h2></div></div></div><p>The <code class="literal">removeRecord</code> method is similar to <code class="literal">recordWithNumber</code> in that we must traverse the list to find the node we’re going to remove from the list, but there’s a lot more to it. Removing a node from a list requires care to keep the remaining nodes in the list linked. The simplest way to sew up the hole we will have created is to link the node that came before the removed node to the node that came after. We don’t need a function outline because we already have a function prototype in the class declaration, so we just need a test case:</p><a id="I_programlisting5_d1e10255"/><pre class="programlisting">studentCollection s;
  studentRecord stu3(84, 1152, "Sue");
  studentRecord stu2(75, 4875, "Ed");
  studentRecord stu1(98, 2938, "Todd");
  s.addRecord(stu3);
  s.addRecord(stu2);
  s.addRecord(stu1);
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> s.removeRecord(4875);</pre><p>Here we’ve created a <code class="literal">studentCollection</code> object <code class="literal">s</code>, as well as three <code class="literal">studentRecor</code><code class="literal">d</code> objects, each of which is added to our collection. Note that we could reuse the same record, changing the values between the calls to <code class="literal">addRecord</code>, but doing it this way simplifies our test code. The last line in the test is the call to <code class="literal">removeRecord</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10283"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which in this case is going to remove the second record, the one for the student named “Ed.” Using the same style of pointer diagrams used in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, <a class="xref" href="ch05.html#lbeforer_and_lafterr_states_for_the_remo" title="Figure 5-1. “Before” and “after” states for the removeRecord test case">Figure 5-1</a> shows the state of memory before and after this call.</p><p>In <a class="xref" href="ch05.html#lbeforer_and_lafterr_states_for_the_remo" title="Figure 5-1. “Before” and “after” states for the removeRecord test case">Figure 5-1</a> (a), we see the linked list that was created by our test code. Note that because we’re using a class, our diagram conventions are a little skewed. On the left side of our stack/heap division, we have <code class="literal">_listHead</code>, which is the private data member inside our <code class="literal">studentCollection</code> object <code class="literal">s</code>, and <code class="literal">idNum</code>, which is the parameter to <code class="literal">removeRecord</code>. On the right side is the list itself, out in the heap. Remember that <code class="literal">addRecord</code> puts the new record at the beginning of the list, so the records are in the opposite order from how they were added in the test code. The middle node, <code class="literal">"Ed"</code>, has the ID number that matches the parameter, <code class="literal">4875</code>, so it will be removed from the list. <a class="xref" href="ch05.html#lbeforer_and_lafterr_states_for_the_remo" title="Figure 5-1. “Before” and “after” states for the removeRecord test case">Figure 5-1</a> (b) shows the result of the call. The first node in the list, that of <code class="literal">"Todd"</code>, now points to what was the third node in the list, that of <code class="literal">"Sue"</code>. The <code class="literal">"Ed"</code> node is no longer linked into the larger list and has been deleted.</p><div class="figure"><a id="lbeforer_and_lafterr_states_for_the_remo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10340"/><img src="httpatomoreillycomsourcenostarchimages1273241.png.jpg" alt="“Before” and “after” states for the removeRecord test case"/></div></div><p class="title">Figure 5-1. “Before” and “after” states for the <code class="literal">removeRecord</code> test case</p></div><p>Now that we know what effect the code should have, we can start to write it. Since we know we need to find the node with the matching ID number, we could start with the <code class="literal">while</code> loop from <code class="literal">recordWithNumber</code>. When that loop is complete, we would have a pointer to the node we needed to remove. Unfortunately, we need more than that to complete the removal. Look at <a class="xref" href="ch05.html#lbeforer_and_lafterr_states_for_the_remo" title="Figure 5-1. “Before” and “after” states for the removeRecord test case">Figure 5-1</a>; in order to close the hole and maintain the linked list, we need to change the <code class="literal">next</code> field of the <code class="literal">"Todd"</code> node. If all we have is a pointer to the <code class="literal">"Ed"</code> node, there is no way to reference the <code class="literal">"Todd"</code> node because each node in the linked list references its successor, not its predecessor. (Because of situations like this, some linked lists link in both directions; these are known as <span class="emphasis"><em>doubly linked lists</em></span>, but they are rarely needed.) So in addition to a pointer to the node to be removed (which will be called <code class="literal">loopPtr</code> if we adapt the code from the previous function), we need a pointer to the node immediately previous: Let’s call this pointer <code class="literal">trailing</code>. <a class="xref" href="ch05.html#the_pointers_required_to_remove_the_node" title="Figure 5-2. The pointers required to remove the node specified by idNum">Figure 5-2</a> shows this concept applied to our sample case.<a id="IDX-CHP-5-0115" class="indexterm"/><a id="IDX-CHP-5-0116" class="indexterm"/></p><div class="figure"><a id="the_pointers_required_to_remove_the_node"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10393"/><img src="httpatomoreillycomsourcenostarchimages1273243.png.jpg" alt="The pointers required to remove the node specified by idNum"/></div></div><p class="title">Figure 5-2. The pointers required to remove the node specified by <code class="literal">idNum</code></p></div><p>With <code class="literal">loopPtr</code> referencing the node we’re removing and <code class="literal">trailing</code> referencing the previous node, we can remove the desired node and keep the list together.<a id="IDX-CHP-5-0117" class="indexterm"/><a id="IDX-CHP-5-0118" class="indexterm"/><a id="IDX-CHP-5-0119" class="indexterm"/><a id="IDX-CHP-5-0120" class="indexterm"/><a id="IDX-CHP-5-0121" class="indexterm"/><a id="IDX-CHP-5-0122" class="indexterm"/></p><a id="I_programlisting5_d1e10438"/><pre class="programlisting">void studentCollection::removeRecord(int idNum) {
    studentNode * loopPtr = _listHead;
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>studentNode * trailing = NULL;
    while (loopPtr != NULL &amp;&amp; loopPtr-&gt;studentData.studentID() != idNum) {
       <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>trailing = loopPtr;
        loopPtr = loopPtr-&gt;next;
    }
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>if (loopPtr == NULL) return;
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>trailing-&gt;next = loopPtr-&gt;next;
  <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>delete loopPtr;
}</pre><p>The first part of this function is like that of <code class="literal">recordWithNumber</code>, except that we declare our <code class="literal">trailing</code> pointer <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10478"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and, inside the loop, we assign the old value of <code class="literal">loopPtr</code> to <code class="literal">trailing</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10491"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> before advancing <code class="literal">loopPtr</code> to the next node. In this way, <code class="literal">trailing</code> is always one node behind <code class="literal">loopPtr</code>. Because of our work with the previous function, we are already on guard against one special case. Therefore, when the loop is over, we check to see whether <code class="literal">loopPtr</code> is <code class="literal">NULL</code>. If so, it means we never found a node with the desired ID number, and we immediately <code class="literal">return</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10516"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. I call a <code class="literal">return</code> statement that appears in the middle of a function “getting out of Dodge.” Some programmers object to this because functions with multiple exit points can be more difficult to read. The alternative in this case, though, is another level of nesting for the <code class="literal">if</code> statements that follow, and I would rather just get out of Dodge.</p><p>Having determined that there is a node to remove, it’s time to remove it. From our diagram, we see that we need to set the <code class="literal">next</code> field of the <code class="literal">trailing</code> node to point to the node currently pointed to by the <code class="literal">next</code> field of the <code class="literal">loopPtr</code> node <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10543"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. Then we can safely <code class="literal">delete</code> the node pointed to by <code class="literal">loopPtr</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10556"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>.</p><p>That works for our test case, but as always, we need to check for potential special cases. We’ve already handled the possibility that <code class="literal">idNum</code> doesn’t appear in any of the records in our collection, but is there another possible issue? Looking at our test case, would anything change if we tried to delete the first or third node rather than the middle node? Testing and hand-checking shows no issues with the third (last) node. The first node, however, does cause trouble because in this situation, there is no previous node for <code class="literal">trailing</code> to point to. Instead, we must manipulate <code class="literal">_listHead</code> itself. <a class="xref" href="ch05.html#the_situation_prior_to_removing_the_firs" title="Figure 5-3. The situation prior to removing the first node in the list">Figure 5-3</a> shows the situation after the <code class="literal">while</code> loop ends.<a id="IDX-CHP-5-0123" class="indexterm"/><a id="IDX-CHP-5-0124" class="indexterm"/><a id="IDX-CHP-5-0125" class="indexterm"/><a id="IDX-CHP-5-0126" class="indexterm"/><a id="IDX-CHP-5-0127" class="indexterm"/><a id="IDX-CHP-5-0128" class="indexterm"/><a id="IDX-CHP-5-0129" class="indexterm"/></p><div class="figure"><a id="the_situation_prior_to_removing_the_firs"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10615"/><img src="httpatomoreillycomsourcenostarchimages1273245.png.jpg" alt="The situation prior to removing the first node in the list"/></div></div><p class="title">Figure 5-3. The situation prior to removing the first node in the list</p></div><p>In this situation, we need to repoint <code class="literal">_listHead</code> to the former second node in the list, the one for <code class="literal">"Ed"</code>. Let’s rewrite our method to handle the special case.</p><a id="I_programlisting5_d1e10628"/><pre class="programlisting">void studentCollection::removeRecord(int idNum) {
    studentNode * loopPtr = _listHead;
    studentNode * trailing = NULL;
    while (loopPtr != NULL &amp;&amp; loopPtr-&gt;studentData.studentID() != idNum) {
        trailing = loopPtr;
        loopPtr = loopPtr-&gt;next;
    }
    if (loopPtr == NULL) return;
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (trailing == NULL) {
      <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>_listHead = _listHead-&gt;next;
    } else {
        trailing-&gt;next = loopPtr-&gt;next;
    }
    delete loopPtr;
}</pre><p>As you can see, both the conditional test <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10644"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and the code to handle the special case <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10650"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> are straightforward because we have carefully analyzed the situation before writing the code.</p></div><div class="sect2" title="Destructor"><div class="titlepage"><div><div><h2 class="title"><a id="destructor"/>Destructor</h2></div></div></div><p>With the three methods specified by the problem implemented, we might think that our <code class="literal">studentCollection</code> class is complete. However, as it stands, it has serious problems. The first is that the class lacks a <span class="emphasis"><em>destructor</em></span>. This is a special method that is called when the object goes out of scope (when the function that declared the object completes). When a class has no dynamic data, it typically doesn’t need a destructor, but if you have the former, you definitely need the latter. Remember that we have to <code class="literal">delete</code> everything we have allocated with <code class="literal">new</code> to avoid memory leaks. If an object of our <code class="literal">studentCollection</code> class has three nodes, each of those nodes needs to be deallocated. Fortunately, this is not too difficult. We just need to traverse our linked list, deleting as we go. Instead of doing this directly, though, let’s write a helper method that deletes all the nodes in a <code class="literal">studentList</code>. In the private section of our class, we add the declaration:<a id="IDX-CHP-5-0130" class="indexterm"/><a id="IDX-CHP-5-0131" class="indexterm"/><a id="IDX-CHP-5-0132" class="indexterm"/></p><a id="I_programlisting5_d1e10691"/><pre class="programlisting">void deleteList(studentList &amp;listPtr);</pre><p>The code for the method itself would be:</p><a id="I_programlisting5_d1e10695"/><pre class="programlisting">void studentCollection::deleteList(studentList &amp;listPtr) {
    while (listPtr != NULL) {
        <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>studentNode * temp = listPtr;
        <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>listPtr = listPtr-&gt;next;
        <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>delete temp;
    }
}</pre><p>The traversal copies the pointer to the current node to a temporary variable <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10717"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, advances the current node pointer <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10723"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, and then deletes the node pointed to by the temporary variable <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10729"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. With this code in place, we can code the destructor very simply. First, we add the destructor to the public section of our class declaration:</p><a id="I_programlisting5_d1e10735"/><pre class="programlisting">˜studentCollection();</pre><p>Note that like a constructor, the destructor is specified using the name of the class, and there is no return type. The tilde before the name distinguishes the destructor from the constructors. The implementation is as follows:</p><a id="I_programlisting5_d1e10739"/><pre class="programlisting">studentCollection::˜studentCollection() {
    deleteList(_listHead);
}</pre><p>The code in these methods is straightforward, but it’s important to test the destructor. Although a poorly written destructor could crash your program, many destructor problems don’t result in crashes, only memory leaks, or worse, inexplicable program behavior. Therefore, it’s important to test the destructor using your development environment’s debugger so that you can see that the destructor is actually calling <code class="literal">delete</code> on each node.</p></div><div class="sect2" title="Deep Copy"><div class="titlepage"><div><div><h2 class="title"><a id="deep_copy"/>Deep Copy</h2></div></div></div><p>Another serious problem remains. Back in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, we briefly discussed the concept of cross-linking, where two pointer variables had the same value. Even though the variables themselves were distinct, they pointed to the same data structure; therefore, modifying the structure of one variable modified them both. This problem can easily occur with classes that incorporate dynamically allocated memory. To see why this can be such a problem, consider the following elementary C++ code sequence:</p><a id="I_programlisting5_d1e10753"/><pre class="programlisting">int x = 10;
  int y = 15;
  x = y;
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> x = 5;</pre><p>Suppose I asked you what effect the last statement <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10763"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> had on the value of the variable <code class="literal">y</code>. You would probably wonder whether I had misspoken. The last statement wouldn’t have any effect on <code class="literal">y</code> at all, only <code class="literal">x</code>. But now consider this:</p><a id="I_programlisting5_d1e10778"/><pre class="programlisting">studentCollection s1;
  studentCollection s2;
  studentRecord r1(85, 99837, "John");
  s2.addRecord(r1);
  studentRecord r2(77, 4765, "Elsie");
  s2.addRecord(r2);
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> s1 = s2;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> s2.removeRecord(99837);</pre><p>Suppose I ask you what effect the last statement <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10794"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> had on <code class="literal">s1</code>. Unfortunately, it does have an effect. Although <code class="literal">s1</code> and <code class="literal">s2</code> are two different objects, they are no longer entirely separate objects. By default, when one object is assigned to another, as we assign <code class="literal">s2</code> to <code class="literal">s1</code> here <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10816"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, C++ performs what is known as a <span class="emphasis"><em>shallow copy</em></span>. In a shallow copy, each data member of one object is directly assigned to the other. So if <code class="literal">_listHead</code>, our only data member, were public, <code class="literal">s1 = s2</code> would be the same as <code class="literal">s1._listHead = s2._listHead</code>. This leaves the <code class="literal">_listHead</code> data member of both objects pointing at the same place in memory: the node for <code class="literal">"Elsie"</code>, which points at the other node, the one for <code class="literal">"John"</code>. Therefore, when the node for <code class="literal">"John"</code> is removed, it’s apparently removed from two lists because there is actually only one list. <a class="xref" href="ch05.html#shallow_copy_results_in_cross-linking_se" title="Figure 5-4. Shallow copy results in cross-linking; deleting &quot;John&quot; node from one list deletes from both.">Figure 5-4</a> shows the situation at the end of the code.<a id="IDX-CHP-5-0133" class="indexterm"/><a id="IDX-CHP-5-0134" class="indexterm"/></p><div class="figure"><a id="shallow_copy_results_in_cross-linking_se"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10864"/><img src="httpatomoreillycomsourcenostarchimages1273247.png.jpg" alt="Shallow copy results in cross-linking; deleting &quot;John&quot; node from one list deletes from both."/></div></div><p class="title">Figure 5-4. Shallow copy results in cross-linking; deleting <code class="literal">"John"</code> node from one list deletes from both.</p></div><p>As quirky as that is, though, it could actually have been much worse. What if the last line of the code had removed the first record, the <code class="literal">"Elsie"</code> node? In that case, the <code class="literal">_listHead</code> inside <code class="literal">s2</code> would have been updated to point to <code class="literal">"John"</code>, and the <code class="literal">"Elsie"</code> node would have been deleted. The <code class="literal">_listHead</code> inside <code class="literal">s1</code>, however, would still point to the deleted <code class="literal">"Elsie"</code> node, a dangerous dangling reference, as shown in <a class="xref" href="ch05.html#removal_from_s2_causing_a_dangling_refer" title="Figure 5-5. Removal from s2 causing a dangling reference in s1">Figure 5-5</a>.<a id="IDX-CHP-5-0135" class="indexterm"/></p><div class="figure"><a id="removal_from_s2_causing_a_dangling_refer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10911"/><img src="httpatomoreillycomsourcenostarchimages1273249.png.jpg" alt="Removal from s2 causing a dangling reference in s1"/></div></div><p class="title">Figure 5-5. Removal from <code class="literal">s2</code> causing a dangling reference in <code class="literal">s1</code></p></div><p>The solution to this issue is a <span class="emphasis"><em>deep copy</em></span>, which means we don’t just copy the pointer to the structure but rather make copies of everything in the structure. In this case, it means copying all of the nodes in the list to make a true list copy. As before, let’s start by making a private helper method, in this case, one that copies a <code class="literal">studentList</code>. The declaration in the class’s private section looks like this:</p><a id="I_programlisting5_d1e10924"/><pre class="programlisting">studentList copiedList(const studentList original);</pre><p>As before, I’ve chosen a noun for a method that returns a value. The implementation for the method is as follows:</p><a id="I_programlisting5_d1e10929"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> studentCollection::studentList
 studentCollection::copiedList(const studentList original) {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>if (original == NULL) {
          return NULL;
      }
      studentList newList = new studentNode;
    <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>newList-&gt;studentData = original-&gt;studentData;
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>studentNode * oldLoopPtr = original-&gt;next;
    <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>studentNode * newLoopPtr = newList;
      while (oldLoopPtr != NULL) {
        <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>newLoopPtr-&gt;next = new studentNode;
          newLoopPtr = newLoopPtr-&gt;next;
          newLoopPtr-&gt;studentData = oldLoopPtr-&gt;studentData;
          oldLoopPtr = oldLoopPtr-&gt;next;
      }
    <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>newLoopPtr-&gt;next = NULL;
    <img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/>return newList;
  }</pre><p>There’s a lot going on in this method, so let’s take it step by step. On a syntax note, when specifying the return type in the implementation, we have to prefix the name of the class <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10981"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Otherwise, the compiler won’t know what type we are talking about. (Inside the method, that’s not necessary because the compiler already knows what class the method is a part of—a bit confusing!) We check to see whether the incoming list is empty. If so, we get out of Dodge <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10987"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Once we know there is a list to be copied, we copy the first node’s data prior to the loop <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10993"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> because for that node we have to modify our new list’s head pointer.<a id="IDX-CHP-5-0136" class="indexterm"/><a id="IDX-CHP-5-0137" class="indexterm"/><a id="IDX-CHP-5-0138" class="indexterm"/><a id="IDX-CHP-5-0139" class="indexterm"/><a id="IDX-CHP-5-0140" class="indexterm"/><a id="IDX-CHP-5-0141" class="indexterm"/><a id="IDX-CHP-5-0142" class="indexterm"/><a id="IDX-CHP-5-0143" class="indexterm"/></p><p>We then set up two pointers for tracking through the two lists. The <code class="literal">old-LoopPtr</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11033"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> traverses the incoming list; it’s always going to point to the node we are about to copy. The <code class="literal">newLoopPtr</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11042"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span> traverses the new, copied list, and it always points to the last node we created, which is the node prior to where we’ll add the next node. Just as in the <code class="literal">removeRecord</code> method, we need a kind of trailing pointer here. Inside the loop <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11052"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>, we create a new node, advance <code class="literal">newLoopPtr</code> to point to it, copy the data from the old node to the new, and advance <code class="literal">oldLoopPtr</code>. After the loop, we terminate the new list by assigning <code class="literal">NULL</code> to the <code class="literal">next</code> field of the last node <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11070"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span> and <code class="literal">return</code> the pointer to the new list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11080"/><img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/></span>.</p><p>So how does this helper method solve the issue we saw previously? By itself, it doesn’t. But with this code in place, we can now overload the assignment operator. <span class="emphasis"><em>Operator overloading</em></span> is a feature of C++ that allows us to change what the built-in operators do with certain types. In this case, we want to overload the assignment operator (<code class="literal">=</code>), so that instead of the default shallow copy, it calls our <code class="literal">copiedList</code> method to perform a deep copy. In the public section of our class, we add:<a id="IDX-CHP-5-0144" class="indexterm"/><a id="IDX-CHP-5-0145" class="indexterm"/><a id="IDX-CHP-5-0146" class="indexterm"/></p><a id="I_programlisting5_d1e11110"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> studentCollection&amp; <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>operator=(<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>const studentCollection &amp;
 <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>rhs);</pre><p>The operator we are overloading is specified by naming the method using the keyword <code class="literal">operator</code> followed by the operator we want to overload <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11140"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. The name I’ve chosen for the parameter (<code class="literal">rhs</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11149"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>) is a common choice for operator overloads because it stands for <span class="emphasis"><em>right-hand side</em></span>. This helps the programmer keep things straight. So in the assignment statement that started this discussion, <code class="literal">s2 = s1</code>, the object <code class="literal">s1</code> would be the right-hand side of the assignment operation, and <code class="literal">s2</code> would be the left-hand side. We reference the right-hand side through the parameter, and we reference the left-hand side by directly accessing class members, the way we would with any other method of the class. So our task in this case is to create a list pointed to by <code class="literal">_listHead</code> that is a copy of the list pointed to by the <code class="literal">_listHead</code> of <code class="literal">rhs</code>. This will have the effect in the call <code class="literal">s2 = s1</code> of making <code class="literal">s2</code> a true copy of <code class="literal">s1</code>.<a id="IDX-CHP-5-0147" class="indexterm"/><a id="IDX-CHP-5-0148" class="indexterm"/></p><p>The type of the parameter is always a constant reference to the class in question <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11195"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>; the return type is always a reference to the class <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11201"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. You’ll see why the parameter is a reference shortly. You might wonder why the method returns anything, since we are manipulating the data member directly in the method. It’s because C++ allows chained assignments, like <code class="literal">s3 = s2 = s1</code>, in which the return value of one assignment becomes the parameter of the next.</p><p>Once all of the syntax is understood, the code for the assignment operator is quite direct:<a id="IDX-CHP-5-0149" class="indexterm"/><a id="IDX-CHP-5-0150" class="indexterm"/><a id="IDX-CHP-5-0151" class="indexterm"/></p><a id="I_programlisting5_d1e11225"/><pre class="programlisting">studentCollection&amp; studentCollection::operator=(const studentCollection &amp;rhs) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (this != &amp;rhs) {
       <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>deleteList(_listHead);
       <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>_listHead = copiedList(rhs._listHead);
    }
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>return *this;
}</pre><p>To avoid a memory leak, we must first remove all of the nodes from the left-hand side list <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11253"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. (It is for this purpose that we write <code class="literal">deleteList</code> as a helper method rather than including its code directly in the destructor.) With the previous left-hand list deleted, we copy the right-hand list using our other helper method <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11262"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Before performing either of these steps, though, we check that the object on the right-hand side is different from the object on the left-hand side (that is, it’s not something like <code class="literal">s1 = s1</code>) by checking whether the pointers are different <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11271"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. If the pointers are identical, there’s no need to do anything, but this is not just a matter of efficiency. If we performed the deep copy on identical pointers, when we delete the nodes currently in the left-hand side list, we would also be deleting the nodes in the right-hand side list. Finally, we return a pointer to the left-hand side object <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11278"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>; this happens whether we actually copied anything or not because although a statement like <code class="literal">s2 = s1 = s1</code> is screwy, we still would like it to work if someone tries it.</p><p>As long as we have our list-copying helper method, we should also create a <span class="emphasis"><em>copy constructor</em></span>. This is a constructor that takes another object of the same class as an object. The copy constructor can be invoked explicitly whenever we need to create a duplicate of an existing <code class="literal">studentCollection</code>, but copy constructors are also invoked implicitly whenever an object of that class is passed as a value parameter to a function. Because of this, you should consider passing object parameters as <code class="literal">const</code> references instead of value parameters unless the function receiving the object needs to modify the copy. Otherwise, your code could be doing a lot of work unnecessarily. Consider a student collection of 10,000 records, for example. The collection could be passed as a reference, a single pointer. Alternatively, it could invoke the copy constructor for a long traversal and 10,000 memory allocations, and this local copy would then invoke the destructor at the end of the function with another long traversal and 10,000 deallocations. This is why the right-hand side parameter to the assignment operator overload uses a <code class="literal">const</code> reference parameter.<a id="IDX-CHP-5-0152" class="indexterm"/><a id="IDX-CHP-5-0153" class="indexterm"/></p><p>To add the copy constructor to our class, first we add its declaration to our class declaration in the public section.</p><a id="I_programlisting5_d1e11312"/><pre class="programlisting">studentCollection(const studentCollection &amp;original);</pre><p>As with all constructors, there is no return type, and as with the overloaded assignment operator, the parameter is a <code class="literal">const</code> reference to our class. The implementation is easy because we already have the helper method.</p><a id="I_programlisting5_d1e11319"/><pre class="programlisting">studentCollection::studentCollection(const studentCollection &amp;original) {
    _listHead = copiedList(original._listHead);
}</pre><p>Now we can make a declaration like this:</p><a id="I_programlisting5_d1e11323"/><pre class="programlisting">studentCollection s2(s1);</pre><p>This declaration has the effect of declaring <code class="literal">s2</code> and copying the nodes of <code class="literal">s1</code> into it.</p></div><div class="sect2" title="The Big Picture for Classes with Dynamic Memory"><div class="titlepage"><div><div><h2 class="title"><a id="the_big_picture_for_classes_with_dynamic"/>The Big Picture for Classes with Dynamic Memory</h2></div></div></div><p>We’ve really done a lot to this class since completing the methods specified by the problem description, so let’s take a moment to review. Here’s what our class declaration looks like now.</p><a id="I_programlisting5_d1e11338"/><pre class="programlisting">class studentCollection {
private:
    struct studentNode {
        studentRecord studentData;
        studentNode * next;
    };
public:
    studentCollection();
    ˜studentCollection();
    studentCollection(const studentCollection &amp;original);
    studentCollection&amp; operator=(const studentCollection &amp;rhs);
    void addRecord(studentRecord newStudent);
    studentRecord recordWithNumber(int idNum);
    void removeRecord(int idNum);
private:
    typedef studentNode * studentList;
    studentList _listHead;
    void deleteList(studentList &amp;listPtr);
    studentList copiedList(const studentList original);
};</pre><p>The lesson here is that new pieces are required when creating a class with dynamic memory. In addition to the features of our basic class framework—private data, a default constructor, and methods to send data in and out of the object—we have to add additional methods to handle the allocation and cleanup of dynamic memory. At a minimum, we should add a copy constructor and a destructor and also overload the assignment operator if there’s any chance someone would use it. The creation of these additional methods can often be facilitated by creating helper methods to copy or delete the underlying dynamic data structure.</p><p>This may seem like a lot of work, and it can be, but it’s important to note that everything you are adding to the class is something you need to deal with anyway. In other words, if we didn’t have a class for our linked-list collection of student records, we’re still responsible for deleting the nodes in the list when we we’re through with them. We would still have to be wary of cross-linking, still have to traverse through a list and copy node by node if we wanted a true copy of the original list, and so on. Putting everything into the class structure is only a little more work up front, and once everything works, the client code can ignore all the memory allocation details. In the end, encapsulation and information hiding make dynamic data structures much easier to work with.</p></div></div><div class="sect1" title="Mistakes to Avoid"><div class="titlepage"><div><div><h1 class="title"><a id="mistakes_to_avoid"/>Mistakes to Avoid</h1></div></div></div><p>We’ve talked about how to create a good class in C++, so let’s round off the discussion by talking about a couple of common pitfalls you should avoid.</p><div class="sect2" title="The Fake Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_fake_class"/>The Fake Class</h2></div></div></div><p>As I mentioned at the beginning of this chapter, I think that C++, as a hybrid language that includes both the procedural and the object-oriented paradigms, is a great language for learning object-oriented programming because the creation of a class is always a positive choice on the part of the programmer. In a language like Java, the question is never, “Should I make a class?” but rather, “How am I going to put this into a class?” The requirement to put everything into a class structure results in what I call a <span class="emphasis"><em>fake class</em></span>, a class without a coherent design that is correct syntactically but has no real meaning. The word <span class="emphasis"><em>class</em></span> as it is used in programming is derived from the sense of the English word meaning a group of things with common attributes, and a good C++ class meets this definition.<a id="IDX-CHP-5-0154" class="indexterm"/><a id="IDX-CHP-5-0155" class="indexterm"/></p><p>Fake classes can happen for several reasons. One type occurs because the programmer really wants to use global variables, not for any defensible reason (such reasons are rare, though they do exist) but out of laziness—just to avoid passing parameters from function to function. While the programmer knows that widespread use of global variables is considered terrible style, he or she thinks the loophole has been found. All or most of the functions of the program are shoveled into a class, and the variables that would have been global are now data members of the class. The main function of the program simply creates one object of the fake class and invokes some “master” method in the class. Technically, the program uses no global variables, but the fake class means that the program has all of the same defects as one that does.</p><p>Another type of fake class occurs because the programmer just assumes that object-oriented programming is always “better” and forces it into situations where it doesn’t apply. In these cases, the programmer often creates a class that encapsulates very specific functionality that only makes sense in the context of the original program for which it is written. There are two ways to test whether you are writing this type of fake class. The first is by asking, “Can I give the class a specific and reasonably short name?” If you find yourself with a name like <span class="emphasis"><em>PayrollReportManagerAndPrintSpooler</em></span>, you might have a problem. The other test asks, “If I were to write another program with similar functionality, can I imagine how the class could be reused, with only small modifications? Or would it have to be dramatically rewritten?”</p><p>Even in C++, a certain number of fake classes are inevitable, for example, because we have to encapsulate data for use in collection classes. Such classes, however, are usually small and basic. If we can avoid elaborate fake classes, our code will improve.</p></div><div class="sect2" title="Single-Taskers"><div class="titlepage"><div><div><h2 class="title"><a id="single-taskers"/>Single-Taskers</h2></div></div></div><p>If you’ve ever seen the television show <span class="emphasis"><em>Good Eats</em></span>, you know that host Alton Brown spends a lot of time discussing how you should outfit your kitchen for maximum efficiency. He often rails against kitchen gadgets he calls <span class="emphasis"><em>single-taskers</em></span>, by which he means tools that do one task well but don’t do anything else. In writing our classes, we should strive to make them as general as possible, consistent with including all the specific functionality required for our program.<a id="IDX-CHP-5-0156" class="indexterm"/><a id="IDX-CHP-5-0157" class="indexterm"/></p><p>One way of doing this is with template classes. This is an advanced subject with a somewhat arcane syntax, but it allows us to make classes where one or more of the data members has a type that is specified when an object of the class is created. Template classes allow us to “factor out” general functionality. For example, our <code class="literal">studentCollection</code> class contains a lot of code that is common to any class that encapsulates a linked list. We could instead make a template class for a general linked list, such that the type of data within the list nodes is specified when the object of the template class is created, rather than being hardwired as a <code class="literal">studentRecord</code>. Then our <code class="literal">studentCollection</code> class would have an object of the template linked list class as a data member, rather than a list head pointer, and would no longer manipulate the linked list directly.<a id="IDX-CHP-5-0158" class="indexterm"/><a id="IDX-CHP-5-0159" class="indexterm"/></p><p>Template classes are beyond the scope of this book, but as you develop your abilities as a class designer, you should always strive to make classes that are multitaskers. It’s a great feeling when you discover a current problem can be solved using a class you wrote previously, long before you knew the current problem existed.</p></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id5"/>Exercises</h1></div></div></div><p>You know what I’m about to say, don’t you? Go ahead and try some!</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Let’s try implementing a class using the basic framework. Consider a class to store the data for an automobile. We’ll have three pieces of data: a manufacturer name and model name, both strings, and a model year, an integer. Create a class with <span class="emphasis"><em>get</em></span>/<span class="emphasis"><em>set</em></span> methods for each data member. Make sure you make good decisions concerning details like member names. It’s not important that you follow my particular naming convention. What’s important is that you think about the choices you make and are consistent in your decisions.</p></li><li class="listitem"><p>For our automobile class from the previous exercise, add a support method that returns a complete description of the automobile object as a formatted string, such as, <code class="literal">"1957 Chevrolet Impala"</code>. Add a second support method that returns the age of the automobile in years.</p></li><li class="listitem"><p>Take the variable-length string functions from <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a> (<code class="literal">append</code>, <code class="literal">concatenate</code>, and <code class="literal">characterAt</code>) and use them to create a class for variable-length strings, making sure to implement all necessary constructors, a destructor, and an overloaded assignment operator.</p></li><li class="listitem"><p>For the variable-length string class of the previous exercise, replace the <code class="literal">characterAt</code> method with an overloaded <code class="literal">[]</code> operator. For example, if <code class="literal">myString</code> is an object of our class, then <code class="literal">myString[1]</code> should return the same result as <code class="literal">myString.characterAt(1)</code>.</p></li><li class="listitem"><p>For the variable-length string class of the previous exercises, add a <code class="literal">remove</code> method that takes a starting position and a number of characters and removes that many characters from the middle of the string. So <code class="literal">myString.remove(5,3)</code> would remove three characters starting at the fifth position. Make sure your method behaves when the value of either of the parameters is invalid.</p></li><li class="listitem"><p>Review your variable-length string class for possible refactoring. For example, is there any common functionality that can be separated into a private support method?</p></li><li class="listitem"><p>Take the student record functions from <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a> (<code class="literal">addRecord</code> and <code class="literal">averageRec</code><code class="literal">ord</code>) and use them to create a class representing a collection of student records, as before, making sure to implement all necessary constructors, a destructor, and an overloaded assignment operator.</p></li><li class="listitem"><p>For the student record collection class of the previous exercise, add a method <code class="literal">RecordsWithinRange</code> that takes a low grade and a high grade as parameters and returns a new collection consisting of the records in that range (the original collection is unaffected). For example, <code class="literal">myCollection.RecordsWithinRange(75, 80)</code> would return a collection of all records with grades in the range 75–80 inclusive.</p></li></ol></div></div></div></body></html>