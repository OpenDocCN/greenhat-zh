- en: Part II-1. TCP/IP NETWORK INTERFACE LAYER PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP/IP LOWER-LAYER CORE PROTOCOLS
  prefs: []
  type: TYPE_NORMAL
- en: 'The TCP/IP protocol suite is largely defined in terms of the protocols that
    constitute it, and several dozen are covered in this book. Most of the critical
    protocols of the suite function at the lower layers of the OSI Reference Model
    (covered in [Part I-2](pt02.html "Part I-2. THE OPEN SYSTEMS INTERCONNECTION (OSI)
    REFERENCE MODEL")): layers 2, 3 and 4, which correspond to the network interface,
    Internet, and transport layers in the TCP/IP model architecture (described in
    [Part I-3](pt03.html "Part I-3. TCP/IP PROTOCOL SUITE AND ARCHITECTURE")). Included
    here are the all-important Internet Protocol (IP) at layer 3 and Transmission
    Control Protocol (TCP) at layer 4, which combine to give TCP/IP its name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the importance of these and other TCP/IP protocols at the lower layers,
    this is the largest of the three sections of this book. It contains eight parts.
    The first describes the two TCP/IP protocols that reside at the network interface
    layer (layer 2 of the OSI Reference Model): the Point-to-Point Protocol (PPP)
    and the Serial Line Interface Protocol (SLIP). The second part describes a couple
    of special protocols that reside architecturally between layers 2 and 3: the Address
    Resolution Protocol (ARP) and the Reverse Address Resolution Protocol (RARP).
    The third and fourth parts describe the IP versions 4 and 6 (IPv4 and IPv6). The
    fifth and sixth parts discuss IP-related feature and support protocols, and the
    seventh part describes IP routing protocols. Finally, the eighth part covers the
    two TCP/IP transport layer protocols, the Transmission Control Protocol (TCP)
    and the User Datagram Protocol (UDP), and related topics such as the use of TCP/IP
    ports.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. TCP/IP SERIAL LINE INTERNET PROTOCOL (SLIP)
    AND POINT-TO-POINT PROTOCOL (PPP) OVERVIEW AND FUNDAMENTALS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL, NETWORK
    CONTROL, AND AUTHENTICATION")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. PPP PROTOCOL FRAME FORMATS")'
  prefs: []
  type: TYPE_NORMAL
- en: The lowest layer of the OSI Reference Model is the physical layer, which is
    responsible for the nitty-gritty details of transmitting information from one
    place to another on a network. The layer just above the physical layer is the
    *data link layer*, called the *network interface layer*, or just the *link layer*,
    in the TCP/IP architectural model. Its primary jobs are to implement networks
    at the local level and to interface between the hardware-oriented physical layer
    and the more abstract, software-oriented functions of the network layer and the
    layers above it.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of TCP/IP, the Internet Protocol (IP) is the main protocol at layer
    3, and it serves as the foundation of the whole TCP/IP protocol suite. IP is designed
    to be layered on top of any number of layer 2 technologies. However, some types
    of connections do not include a layer 2 protocol over which IP can run. To enable
    TCP/IP to operate on these kinds of links, two special TCP/IP protocols operate
    at the network interface layer, connecting IP to the physical layer below.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, I provide a description of the two protocols that reside at the
    data link, or network interface layer, in the TCP/IP protocol suite. These are
    the older, simple Serial Line Interface Protocol (SLIP) and the newer, more capable
    Point-to-Point Protocol (PPP). I begin with a chapter that provides a brief overview
    of SLIP and PPP, showing how they fit into the TCP/IP protocol suite as a whole
    and describing them in general terms.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this part contains three chapters that describe the more important
    of the two protocols, PPP, in more detail. The first of these three explains the
    core protocols that are responsible for setting up PPP links and basic operation.
    The second covers the protocols used to implement various special features in
    PPP, such as compression and encryption. The last chapter on PPP provides detailed
    information about the various frame formats used by PPP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. TCP/IP SERIAL LINE INTERNET PROTOCOL (SLIP) AND POINT-TO-POINT PROTOCOL
    (PPP) OVERVIEW AND FUNDAMENTALS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'TCP/IP''s core protocols operate at layers 3 and 4 of the OSI model, corresponding
    to the Internet layer and host-to-host transport layer of the TCP/IP architectural
    model (introduced in [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND
    ARCHITECTURE")). That model also defines the network interface layer, which corresponds
    to the data link layer. However, in most network implementations, TCP/IP doesn''t
    define any protocols operating at this layer. Instead, TCP/IP assumes that layer
    2 functionality is provided by a wide area network (WAN) or local area network
    (LAN) technology like Ethernet, Token Ring, or IEEE 802.11\. These technologies
    are responsible for the classic layer 2 functions: physical layer addressing,
    media access control, and especially, layer 2 framing of datagrams received from
    layer 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a problem with the assumption that Internet Protocol (IP) can run
    on top of an existing layer 2 protocol because sometimes there isn''t one. Certain
    technologies, such as a simple serial connection between two devices, establish
    only a basic, low-level connection at the physical layer. And, of course, one
    type of serial connection is still *very* popular: serial dial-up networking.
    When you connect with a dial-up modem to your ISP, the modems negotiate a connection
    that architecturally exists only at the physical layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Since IP assumes certain services will be provided at layer 2, there is no way
    to make it operate directly over a serial line or other physical layer connection.
    At a minimum, the most important layer 2 function that is required is some mechanism
    for framing the IP datagram for transmission; that is, a mechanism that provides
    the necessary data packaging to let datagrams be transmitted over the physical
    layer network. Without this, IP datagrams cannot be sent over the link.
  prefs: []
  type: TYPE_NORMAL
- en: SLIP versus PPP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fill the gap between IP at layer 3 and the physical connection at layer 1,
    two protocols operate at layer 2 and provide the services that IP requires to
    function. One protocol is *Serial Line Internet Protocol* (SLIP), a very simple
    layer 2 protocol that provides only basic framing for IP. The other is *Point-to-Point
    Protocol* (PPP), a more complex, full-featured data link layer protocol that provides
    framing as well as many additional features that improve security and performance.
  prefs: []
  type: TYPE_NORMAL
- en: SLIP is extremely simple and easy to implement but lacks certain features of
    PPP (like authentication, compression, and error detection), which is full featured
    but more complicated. To draw an analogy, SLIP is a mostly sturdy, ten-year-old
    compact sedan, while PPP is a shiny, new luxury SUV. Both will get you from here
    to grandma's house, but the SUV is going to be safer, more comfortable, and better
    able to deal with problems that might crop up on the road. If they cost the same
    to buy and operate, you'd probably choose the SUV. Both SLIP and PPP cost about
    the same, and unlike an SUV, PPP causes no air pollution and doesn't guzzle gas.
    For this reason, PPP is the choice of most serial line connections today and has
    all but replaced SLIP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *SLIP* and *PPP* provide layer 2 connectivity for TCP/IP implementations
    that run directly over a physical layer link without a layer 2 technology. While
    SLIP is simpler, PPP is favored due to its many features and capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both SLIP and PPP are designed for connections between just two devices; thus,
    the name point-to-point protocol. Since there are only two devices, A and B, communication
    is straightforward: A sends to B and B sends to A, and since both deal only with
    simple two-device connections, they do not have to manage complexities like media
    access control, collisions, and unique addressing schemes in the way that technologies
    like Ethernet must.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some people don''t consider SLIP and PPP to be part of the true TCP/IP protocol
    suite. They argue that TCP/IP is defined at layers 3 and higher on the OSI model,
    that IP is the basis of TCP/IP at layer 3, and that SLIP and PPP are just extra
    protocols that can be used under TCP/IP. To support their argument, they note
    that PPP can be used for protocols other than IP, which is true*.'
  prefs: []
  type: TYPE_NORMAL
- en: Serial Line Internet Protocol (SLIP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The need for a data link layer protocol to allow IP to operate over serial links
    was identified very early on in the development of TCP/IP. Engineers working on
    IP needed a way to send IP datagrams over serial links. To solve the problem,
    they created the very simple protocol SLIP to frame IP messages for transmission
    across the serial line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike most TCP/IP protocols, SLIP has never been defined as a formalized standard.
    It was created informally in the early 1980s, and it became the de facto standard
    before it was ever described in a Request for Comment (RFC). When it was published
    in 1988 (RFC 1055, "A Nonstandard for Transmission of IP Datagrams over Serial
    Lines: SLIP"), the decision was made to designate it a "nonstandard protocol."'
  prefs: []
  type: TYPE_NORMAL
- en: SLIP was designated nonstandard because it was developed as a very rudimentary,
    stopgap measure to provide layer 2 framing when needed. SLIP is so simple that
    there really isn't much to standardize. Too, it has so many deficiencies that
    the Internet Engineering Task Force (IETF) apparently didn't want to formalize
    it as a standard. RFC 1055 specifically mentions various problems with SLIP (as
    I'll discuss later in this chapter) and the fact that work was already under way
    to define PPP as a more capable successor to SLIP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** SLIP provides a *layer 2 framing service* for IP datagrams
    but no other features or capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: SLIP Data Framing Method and General Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SLIP performs only one function: the framing of data for transmission. Here''s
    how SLIP framing works. An IP datagram is passed down to SLIP, which breaks it
    into bytes and sends those bytes one at a time over the link. After the last byte
    of the datagram is sent, a special byte value is sent that tells the receiving
    device that the datagram has ended. This is called the SLIP *END character*, and
    it has a byte value of 192 in decimal numbers (C0 in hexadecimal and 11000000
    binary). That''s basically SLIP framing in a nutshell: Take the whole datagram,
    send it one byte at a time, and then send the byte 192 to delimit the end of the
    datagram.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One minor enhancement to SLIP''s basic operation is to *precede* the datagram
    with an *END* character as well, thus clearly separating the start of the datagram
    from anything that precedes it. To see why this might be needed, you can imagine
    that at a particular time you have only one datagram to send: datagram 1\. You
    send 1, and then send the *END* character to delimit it. Now, suppose there is
    a pause before the next datagram shows up. During that time, you aren''t transmitting,
    but if there is line noise, the other device might pick up spurious bytes here
    and there. If you later receive datagram 2 and just start sending it, the receiving
    device might think the noise bytes were part of datagram 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting datagram 2 off with an *END* character tells the recipient that anything
    received between this *END* character and the previous one is a separate datagram.
    If that's just noise, then this "noise datagram" is just gibberish that will be
    rejected at the IP layer. Meanwhile, it doesn't corrupt the real datagram you
    wish to send. If no noise occurred on the line between datagrams, then the recipient
    will just see the *END* at the start of datagram 2 right after the one at the
    end of datagram 1 and will ignore the "null datagram" between the two.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the *END* character is 192 in decimal numbers; what happens if the
    byte value 192 appears in the datagram itself? Transmitting it as is would fool
    the recipient into thinking that the datagram ended prematurely. To avoid this,
    an *Escape character* (*ESC*) is defined, which has a decimal value of 219 (DB
    in hex, 11011011 in binary). This symbol means that "this byte and the next are
    special." When a value of 192 appears in the datagram, the sending device replaces
    it with the ESC character followed by the value 220 decimal. Thus, a single 192
    becomes 219 220 (or DB DC in hexadecimal). The recipient translates back from
    219 220 to 192.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The SLIP* ESC *character is not the same as the ASCII* ESC *character. They
    both perform an "escaping" operation but are otherwise unrelated. If the ESC character
    itself is in the original datagram—that is, if there''s a byte value of 219 in
    the IP datagram to be sent—the device uses 219 221 instead of just 219*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, SLIP does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaks an IP datagram into bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends the *END* character (value 192) after the last byte of the datagram; in
    better implementations, it sends the *END* character before the first byte as
    well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaces any byte to be sent in the datagram that is 192 with 219 220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaces any byte to be sent that is 219 with 219 221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 9-1](ch09s02.html#operation_of_the_serial_line_internet_pr "Figure 9-1. Operation
    of the Serial Line Internet Protocol (SLIP) SLIP''s only function is to frame
    data from layer 3 (usually IP datagrams) by surrounding them with END characters
    and replacing special characters as needed.") shows an example of how this is
    done with a sample IP datagram. IP datagrams are passed down to the SLIP software
    at layer 2 (a simplified one with only five bytes is shown here). There, they
    are framed by surrounding them with *END* characters (hexadecimal value C0h, shown
    with diagonal hatching). Special characters with hexadecimal values DBh and C0h
    are replaced by two-byte sequences. Note that the presence of the bracketing *END*
    characters forces the receiving device to see the noise byte (03h, in black) as
    a separate IP datagram, rather than part of either of the real ones. It will be
    rejected when passed up to the IP layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Problems and Limitations of SLIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SLIP''s simplicity does not come without costs. SLIP simply doesn''t provide
    many of the features and capabilities you really need on modern serial links.
    SLIP is most deficient in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standardized Datagram Size Specification** SLIP''s maximum supported datagram
    size is not standardized and depends on each implementation. The usual default
    is 1,006 bytes, which becomes the maximum transmission unit (MTU) for the link
    (see [Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY,
    AND ROUTING")). If a different size is used, you must program this into the IP
    layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operation of the Serial Line Internet Protocol (SLIP) SLIP''s only function
    is to frame data from layer 3 (usually IP datagrams) by surrounding them with
    END characters and replacing special characters as needed.](httpatomoreillycomsourcenostarchimages287725.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1. Operation of the Serial Line Internet Protocol (SLIP) SLIP's only
    function is to frame data from layer 3 (usually IP datagrams) by surrounding them
    with END characters and replacing special characters as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error Detection and Correction Mechanism** SLIP doesn''t provide any way
    of detecting or correcting errors in transmissions. While such protection is provided
    at higher layers through IP header checksums and other mechanisms, it is a job
    traditionally also done at layer 2\. The reason is that relying on those higher
    layers means that errors are detected only after an entire datagram has been sent
    and passed back up the stack at the recipient. Error correction can come only
    in the form of resending any datagrams that were corrupted. This is inefficient,
    especially because serial links are generally much slower than normal LAN links.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Messaging** SLIP offers no way for the two devices to communicate
    control information that may be required to manage the link.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Identification** Since SLIP includes no headers of its own, it is not
    possible to identify that SLIP is being used. While developed for IP, there is
    no reason why other layer 3 protocols could not be sent using SLIP (if you were
    running more than one internetworking protocol at the higher layers). However,
    without type identification, there is no way to mix datagrams from two or more
    layer 3 protocols on the same link.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Discovery Method** Addressing isn''t needed at layer 2 because there
    are only two devices in a point-to-point connection, so each device is obviously
    only sending to the other one. However, devices do need some way of learning each
    other''s IP addresses for routing at layer 3\. SLIP provides no method for this.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Support for Compression** Compression would improve performance over serial
    lines that are otherwise slow compared to other technologies. SLIP provides no
    compression features. (Note, however, that modems usually do support compression
    at layer 1 for serial connections that use them.) A variant on SLIP called *Compressed
    SLIP* or *CSLIP* was created in the late 1980s, but it was not as widely deployed
    as regular SLIP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Features** SLIP lacks even basic security features, with no means
    for authenticating connections or encrypting data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SLIP''s many shortcomings have led most implementations to move from SLIP to
    the PPP, which is a much richer data link protocol for direct connections that
    resolves SLIP''s problems. SLIP is now outdated. Still, SLIP continues to be used
    in many places. Simplicity is attractive, and people are famous for their inertia:
    If something is implemented and is working well, many will refuse to change unless
    they are forced to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-Point Protocol (PPP) Overview and Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even as SLIP was being documented, work was underway on a newer protocol that
    would provide full-featured IP transmission over direct links between pairs of
    devices. The result is *PPP*, which defines a complete method for robust data
    link connectivity between devices using serial lines or other physical layers.
    It includes numerous capabilities and features, including error detection, compression,
    authentication, and encryption.
  prefs: []
  type: TYPE_NORMAL
- en: The proliferation of serial links, especially for dial-up Internet access, has
    led to the widespread use of PPP. PPP is now one of the most popular layer 2 WAN
    technologies in the networking world, and has replaced SLIP as the standard for
    serial connections on all but legacy implementations. While most often associated
    with dial-up modem use, PPP can run across any similar type of physical layer
    link. For example, it is often used to provide layer 2 functionality on Integrated
    Services Digital Network (ISDN).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Although PPP is called a protocol and is usually considered part of TCP/IP,
    it is really more a protocol suite, since its operation is based on procedures
    defined in many individual protocols. Alternatively, its components can be viewed
    as subprotocols within PPP, even though they are not usually called that in the
    standards*.'
  prefs: []
  type: TYPE_NORMAL
- en: Development and Standardization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike SLIP, PPP was developed to be a complete protocol suite that would enable
    fully functional layer 2 connectivity to support not just IP, but the transmission
    of other network layer protocols as well.
  prefs: []
  type: TYPE_NORMAL
- en: PPP's history goes back to the late 1980s, when SLIP was the de facto standard
    for serial IP implementations. The first formal IETF document related to PPP was
    RFC 1134 (1989). This RFC was not the standard itself, but a proposal for what
    would eventually be defined as the first main PPP standard, RFC 1171 (1990). RFC
    1171 was revised several times, and several other documents were added to it to
    define the various protocols that compose the entire PPP suite.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Rather than try to develop PPP from scratch, the IETF decided to base it on
    the ISO High-Level Data Link Control (HDLC) protocol, which was initially developed
    by IBM. HDLC is a derivative of the Synchronous Data Link Control (SDLC) Protocol.
    PPP''s developers adapted its framing structure and some of its general operation
    from HDLC*.'
  prefs: []
  type: TYPE_NORMAL
- en: Function and Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PPP is a connection-oriented protocol that enables layer 2 links over a variety
    of different physical layer connections. It is supported on both synchronous and
    asynchronous lines and can operate in half-duplex or full-duplex mode. It was
    designed to carry IP traffic, but is general enough to allow any type of network
    layer datagram to be sent over a PPP connection. As its name implies, PPP is designed
    for point-to-point connections between two devices, and it assumes that frames
    are sent and received in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: PPP fits into TCP/IP in the network interface layer (link layer), as shown in
    [Figure 9-2](ch09s03.html#ppp_location_in_the_tcpip_architecture_p "Figure 9-2. PPP
    location in the TCP/IP architecture PPP is the interface between the IP and a
    physical link such as a serial line or dial-up networking connection. This corresponds
    to layer 2 in the OSI Reference Model."). PPP's operation follows a specific sequence,
    including a multistep Link Establishment phase that may include optional authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP location in the TCP/IP architecture PPP is the interface between the
    IP and a physical link such as a serial line or dial-up networking connection.
    This corresponds to layer 2 in the OSI Reference Model.](httpatomoreillycomsourcenostarchimages287727.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2. PPP location in the TCP/IP architecture PPP is the interface between
    the IP and a physical link such as a serial line or dial-up networking connection.
    This corresponds to layer 2 in the OSI Reference Model.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A list of PPP''s strengths reads very much like a list of SLIP''s weaknesses,
    as explained earlier in this chapter. Some of PPP''s specific benefits include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A more comprehensive framing mechanism compared to the single *END* character
    in SLIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specification of the encapsulated protocol to allow multiple layer 3 protocols
    to be multiplexed on a single link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error detection for each transmitted frame through the use of a cyclic redundancy
    check (CRC) code in each frame header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A robust mechanism for negotiating link parameters, including the maximum frame
    size permitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method for testing links before datagram transmission takes place and for
    monitoring link quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for authentication of the connection using multiple authentication protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for additional optional features, including compression, encryption,
    and link aggregation (allowing two devices to use multiple physical links as if
    they were a single, higher-performance link)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proliferation of serial links, especially for dial-up Internet access, has
    led to widespread use of PPP. It is now one of the most popular layer 2 WAN technologies
    in the networking world, and it has replaced SLIP as the standard for serial connections
    on all but legacy implementations. While most often associated with dial-up modem
    use, PPP can run across any similar type of physical layer link. For example,
    it is often used to provide layer 2 functionality on ISDN.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** PPP is a complete link layer protocol suite for devices using
    TCP/IP. It provides framing, encapsulation, authentication, quality monitoring,
    and other features that enable robust operation of TCP/IP over a variety of physical
    layer connections.'
  prefs: []
  type: TYPE_NORMAL
- en: One key advantage of PPP is that it is *extensible*. Over the years, new protocols
    have been added to the suite in order to provide additional features or capabilities.
    For example, PPP is designed not to use just a single authentication protocol,
    but to allow a choice.
  prefs: []
  type: TYPE_NORMAL
- en: PPP's success has even led to the development of derivative protocols like PPP
    over Ethernet (PPPoE) and PPP over ATM (PPPoA). These derivatives actually layer
    PPP over existing data link layer technologies, which demonstrates how valued
    PPP's features are. Even when a layer 2 technology is already in use, you can
    apply PPP on top to provide authentication and management benefits for services
    like Digital Subscriber Line (DSL).
  prefs: []
  type: TYPE_NORMAL
- en: PPP Main Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the highest level, PPP''s functions can be broken down into several components.
    Each encompasses a general class of PPP functionality and is represented by either
    one protocol in the suite or a set of protocols. The PPP standard describes three
    main components of PPP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PPP Encapsulation Method** The primary job of PPP is to take higher-layer
    messages, such as IP datagrams, and encapsulate them for transmission over the
    underlying physical layer link. To this end, PPP defines a special frame format
    for encapsulating data for transmission, based on the framing used in HDLC. The
    PPP frame was designed to be small and contain only simple fields in order to
    maximize bandwidth efficiency and speed in processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Control Protocol (LCP)** LCP is responsible for setting up, maintaining,
    and terminating the link between devices. It is a flexible, extensible protocol
    that allows many configuration parameters to be exchanged to ensure that both
    devices agree on how the link will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Control Protocols (NCPs)** PPP supports the encapsulation of many
    different layer 3 datagram types. Some of these require additional setup before
    the link can be activated. Once the general link setup is completed with LCP,
    control is passed to the NCP that is specific to the layer 3 protocol being carried
    on the PPP link. For example, when IP is carried over PPP, the NCP used is the
    PPP Internet Protocol Control Protocol (IPCP). Other NCPs are defined for supporting
    the Internetworking Packet Exchange (IPX) protocol, the NetBIOS Frames (NBF) protocol,
    and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: The PPP encapsulation method and LCP are defined in the main PPP standard and
    some support standards; the NCPs are described in separate standard documents,
    one per NCP.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Functional Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While PPP''s main components constitute much of the total package, I would
    add two additional functional groups. These represent some of the many extra protocols
    that have been added to the suite over time to support or enhance its basic operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LCP Support Protocols** Several protocols in the PPP suite are used during
    the link negotiation process, either to manage it or to configure options. Examples
    include the authentication protocols Challenge Handshake Authentication Protocol
    (CHAP) and Password Authentication Protocol (PAP), which are used by LCP during
    the optional Authentication phase. These are discussed in [Chapter 10](ch10.html
    "Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION").'
  prefs: []
  type: TYPE_NORMAL
- en: '**LCP Optional Feature Protocols** A number of protocols have been added to
    the basic PPP suite over the years to enhance its operation once a link has been
    set up and datagrams are being passed between devices. For example, the PPP Compression
    Control Protocol (CCP) allows compression of PPP data; the PPP Encryption Control
    Protocol (ECP) enables datagrams to be encrypted for security; and the PPP Multilink
    Protocol (PPP MP) allows a single PPP link to be operated over multiple physical
    links. These protocols often also require additional setup during link negotiation,
    so many of them define extensions (such as extra configuration options) that are
    negotiated as part of LCP.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Each optional protocol is defined by a specific standards document, as you
    will see later in this chapter*.'
  prefs: []
  type: TYPE_NORMAL
- en: General Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the PPP suite includes dozens of protocols, its general operation
    is really quite straightforward. Essentially, PPP involves the following three
    basic steps (see [Figure 9-3](ch09s03.html#overview_of_ppp_operation_in_simplest_te
    "Figure 9-3. Overview of PPP operation In simplest terms, PPP consists of only
    three basic steps: link setup, link operation, and link termination.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Setup and Configuration** Before the two devices can exchange information,
    they must make contact and set up a link between them. During link setup, the
    devices agree on all the parameters needed to manage the operation of the link.
    LCP begins this process and invokes the help of support protocols as needed, for
    options like authentication. Once the link is set up, in order to complete link
    setup, the appropriate NCP is called for whatever layer 3 technology is being
    carried on the link.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link Operation** The devices use the link to send datagrams. Each device
    transmits by encapsulating layer 3 datagrams and sending them down to layer 1
    to be transmitted. Each device receives by taking PPP frames sent up from its
    own physical layer, stripping off the PPP header and passing the datagram up to
    layer 3\. Where appropriate, optional protocols are used at this stage to offer
    features such as compression (CCP).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link Termination** When either device decides that it no longer wants to
    communicate, it terminates the link.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Overview of PPP operation In simplest terms, PPP consists of only three basic
    steps: link setup, link operation, and link termination.](httpatomoreillycomsourcenostarchimages287729.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3. Overview of PPP operation In simplest terms, PPP consists of only
    three basic steps: link setup, link operation, and link termination.'
  prefs: []
  type: TYPE_NORMAL
- en: Link setup is by far the most complicated of these general steps, because it
    involves several substeps used to negotiate link parameters and options.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Link Setup and Phases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before data can be exchanged on a PPP connection, a link must be set up between
    the two devices. As part of this setup task, a configuration process is undertaken
    whereby the devices configure the link and agree on the parameters for how data
    should be passed between them. Only when this is completed can frames actually
    pass over the link.
  prefs: []
  type: TYPE_NORMAL
- en: LCP is generally in charge of setting up and maintaining PPP links. LCP may
    invoke an authentication protocol (PAP or CHAP) when PPP is configured to use
    authentication. Once an LCP link has been opened, PPP invokes one or more NCPs
    for the layer 3 protocol being carried on the link. These perform any network-layer-specific
    configuration needed before the link can carry that particular network layer protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operation of a PPP link can be described as having a life of sorts: A PPP
    link is established, configured, used, and eventually terminated. The process
    of setting up, using, and closing a PPP link is described in the PPP standard
    as a series of *phases* or *states*. This is a type of *finite state machine (FSM)*,
    which is a tool used to explain the operation of protocols. The general concept
    behind an FSM is described in the section discussing the finite state machine
    of the Transmission Control Protocol (TCP), in [Chapter 47](ch47.html "Chapter 47. TCP
    BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION").'
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how PPP works, let's look at these phases and how the transition
    is made from one to the next during the lifetime of the link. For the sake of
    clarity, this description is based on an example for which Device A is a PC connecting
    via dial-up networking to Remote Host B (see [Figure 9-4](ch09s03.html#ppp_phases_a_ppp_connection_follows_a_ma
    "Figure 9-4. PPP phases A PPP connection follows a mainly linear sequence of transitions
    from the Link Dead Phase through the Link Open Phase.")).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*When we talk about a PPP link overall, we are talking about the status of
    the LCP connection between the two devices. Once an LCP link has been opened,
    each of the NCPs used on the link can be opened or closed independently of the
    overall PPP (LCP) link. You''ll see how this works momentarily*.'
  prefs: []
  type: TYPE_NORMAL
- en: Link Dead Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By design, the PPP link always begins and ends in the *Link Dead* phase. This
    phase represents the situation in which there is no physical layer link established
    between the two devices. The link remains here until the physical layer link is
    set up, at which point it proceeds to the *Link Establishment* phase.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, when Device A is first turned on, there is no physical layer
    connection (modem connection) between it and Device B. Once the connection is
    made, the link can proceed to phase 2.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In a direct connection, such as a serial cable linking two PCs, the link may
    stay in the Link Dead phase for only a fraction of a second, until the physical
    layer connection is detected*.'
  prefs: []
  type: TYPE_NORMAL
- en: Link Establishment Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The physical layer is now connected and LCP performs the basic setup of the
    link. Device A sends an LCP configuration request message to Device B over the
    physical link, specifying the parameters it wishes to use. If Device B agrees,
    it replies with an acknowledgment. If Device B doesn''t agree, it returns a negative
    acknowledgment or rejection, telling Device A what it won''t accept. Device A
    can then try a different configuration request with new parameters that Device
    B may accept. (This process is described in more detail in [Chapter 10](ch10.html
    "Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION").)'
  prefs: []
  type: TYPE_NORMAL
- en: If Device A and Device B eventually come to agreement, the link status is considered
    *LCP open* and will proceed to the *Authentication* phase. If they cannot agree,
    the physical link is terminated, and it returns to the Link Dead phase.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, a device may require authentication before it will permit another
    device to connect. (This is usually the case when PPP is used for dial-up.) Authentication
    is not mandatory in PPP, however. When it is used, the appropriate authentication
    protocol (CHAP or PAP) is employed.
  prefs: []
  type: TYPE_NORMAL
- en: After successful authentication, the link proceeds to the *Network Layer Protocol*
    phase. If authentication is not successful, the link fails and transitions to
    the *Link Termination* phase.
  prefs: []
  type: TYPE_NORMAL
- en: Network Layer Protocol Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the basic link has been configured and authentication has completed, the
    general setup of the LCP link is complete. Now, the specific configuration of
    the appropriate network layer protocol is performed by invoking the appropriate
    NCP, such as IPCP, IPXCP, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Each particular network layer protocol whose NCP is successfully configured
    is considered to be open on the LCP link. More than one NCP can be open on a particular
    PPP link, and each can be closed independently when it is no longer needed. Once
    all necessary NCPs have been invoked, the link proceeds to the *Link Open* state,
    even if none of the NCPs were successfully opened.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some PPP features require the negotiation of additional options between the
    two devices, which may perform their own link establishment process during the*
    Network Layer Protocol *phase. The PPP Compression Control Protocol (CCP) sets
    up data compression in this manner*.'
  prefs: []
  type: TYPE_NORMAL
- en: Link Open Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Link Open state, the LCP link and one or more NCP links are open and
    operational. Data can be passed for each NCP that has been successfully set up.
  prefs: []
  type: TYPE_NORMAL
- en: The link can be terminated at any time by either device for a variety of reasons.
    These may include a user request (you click Disconnect when you want to log off
    your dial-up session); link quality problems (the modem hangs up on you due to
    line noise); or some other cause (you spend too much time in the bathroom and
    your ISP's idle timer logs you out). When any of these occur, the LCP link is
    broken, and the link transitions to the *Link Termination* phase.
  prefs: []
  type: TYPE_NORMAL
- en: Link Termination Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The device terminating the link sends a special LCP termination frame, and the
    other device acknowledges it. The link then returns to the Link Dead phase. If
    the termination was by request and the physical layer connection is still active,
    the PPP implementation should specifically signal the physical layer to terminate
    the layer 1 connection.
  prefs: []
  type: TYPE_NORMAL
- en: You should remember that the basic link is established by LCP, and NCP links
    are set up within the LCP link. Closing an NCP link does not cause the LCP link
    to be closed. Even if all NCPs are closed, the LCP link remains open. (Of course,
    no data can be passed until an appropriate NCP link is reestablished; a device
    is required to discard frames received that contain any layer 3 protocol that
    does not have an open NCP.) To terminate a PPP connection, only the LCP link needs
    to be terminated in the *Link Termination* phase; the NCPs do not need to be explicitly
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-4](ch09s03.html#ppp_phases_a_ppp_connection_follows_a_ma "Figure 9-4. PPP
    phases A PPP connection follows a mainly linear sequence of transitions from the
    Link Dead Phase through the Link Open Phase.") shows the PPP phases and the circumstances
    under which transitions occur between them. The PPP connection between two devices
    begins in the Link Dead state and proceeds through three intermediate phases until
    the link is fully opened. It remains in the stable Link Open phase until terminated.
    The lighter boxes show the corresponding change in the status of the PPP link
    as transitions are made between phases.'
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP phases A PPP connection follows a mainly linear sequence of transitions
    from the Link Dead Phase through the Link Open Phase.](httpatomoreillycomsourcenostarchimages287731.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4. PPP phases A PPP connection follows a mainly linear sequence of
    transitions from the Link Dead Phase through the Link Open Phase.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09s03.html#ppp_phases "Table 9-1. PPP Phases") summarizes the
    PPP phases; the LCP Link Status and NCP Link Status columns show the status of
    the link as the phase starts.'
  prefs: []
  type: TYPE_NORMAL
- en: PPP Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it makes sense for different parts of PPP to be covered in different standards,
    this does make it much harder to learn how PPP works. Also, literally *dozens*
    of RFCs cover PPP's main operation, its various protocols, and other related issues.
    You can find most of them by consulting a master list of RFCs and searching for
    the string "PPP," but you will find them in numerical (RFC number) order, which
    isn't very meaningful in terms of how the protocols are used. You also have to
    differentiate between the ones that are current and those that are obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1. PPP Phases
  prefs: []
  type: TYPE_NORMAL
- en: '| Phase/State | Phase Summary | LCP Link Status Upon Entry to Phase | NCP Link
    Status Upon Entry to Phase | Transition Requirement | Transition to Phase |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Link Dead | Default state; physical layer not connected. | Closed | Closed
    | Successful physical layer connection | Link establishment |'
  prefs: []
  type: TYPE_TB
- en: '| Link Establishment | Physical layer connected, basic configuration of link
    performed by LCP. | Closed | Closed | Successful negotiation | Authentication
    |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   | Unsuccessful negotiation | Link dead |'
  prefs: []
  type: TYPE_TB
- en: '| Authentication | Basic link is now opened, and optional authentication of
    device is performed. | Open | Closed | Successful authentication or no authentication
    required | Network layer protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   | Unsuccessful authentication | Link termination |'
  prefs: []
  type: TYPE_TB
- en: '| Network Layer Protocol | One or more NCPs open an NCP link within the LCP
    link. | Open | Closed | All NCPs opened | Link open |'
  prefs: []
  type: TYPE_TB
- en: '| Link Open | Link is open and operating normally. | Open | Open | Link failure
    or close request | Link termination |'
  prefs: []
  type: TYPE_TB
- en: '| Link Termination | LCP link is shut down. | Open | Open |   | Link dead |'
  prefs: []
  type: TYPE_TB
- en: '[Table 9-2](ch09s03.html#ppp_standards-id001 "Table 9-2. PPP Standards") lists
    the most important and interesting PPP-related RFCs. To make it easier to see
    what the RFCs are about, I have organized them into five groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core** These are PPP''s main documents. They cover the basic operation of
    PPP including the PPP LCP and encapsulation of datagrams.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LCP Support** These protocols support the basic operation of LCP. I''ve only
    included the ones that provide authentication services during link startup.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NCPs** These protocols negotiate parameters specific to various layer 3 protocols
    carried over PPP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Features** These protocols define optional features used with PPP, such as
    compression and encryption.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applications and Miscellaneous** These are the protocols that describe how
    PPP can be adapted to run over particular types of links or that don''t really
    fit into any of the previous groups.'
  prefs: []
  type: TYPE_NORMAL
- en: Within each group, the RFCs are listed in numerical order, which is also date
    order. Only the most recent RFC is listed, not earlier ones that were made obsolete
    (with the exception of RFC 1334, which, despite being made obsolete, is still
    important).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2. PPP Standards
  prefs: []
  type: TYPE_NORMAL
- en: '| Group | RFC Number | Standard Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Core | 1570 | PPP LCP Extensions | Defines two features for LCP that allow
    devices to identify each other and for each device to tell the other how much
    time remains in the current session. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1661 | The Point-to-Point Protocol (PPP) | Base standard for PPP. Describes
    PPP architecture, general operation (including the process of link establishment,
    maintenance, and termination), and details of LCP. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1662 | PPP in HDLC-like Framing | Defines the specific framing method
    for PPP frames, based on that used in HDLC. This standard can be considered a
    companion to the main PPP standard, RFC 1661. |'
  prefs: []
  type: TYPE_TB
- en: '| LCP Support | 1334 | PPP Authentication Protocols | Defines the two PPP authentication
    protocols: PAP and CHAP. Note that RFC 1994 obsoletes RFC 1334, but does not discuss
    the PAP. (That tells you that the IETF doesn''t think highly of PAP; see [Chapter 10](ch10.html
    "Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION")
    for more on this.) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1994 | PPP Challenge Handshake Authentication Protocol (CHAP) | Updates
    the information about CHAP provided in RFC 1334. |'
  prefs: []
  type: TYPE_TB
- en: '| NCPs | 1332 | The PPP Internet Protocol Control Protocol (IPCP) | The NCP
    for IP. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1377 | The PPP OSI Network Layer Control Protocol (OSINLCP) | The NCP
    for OSI protocol suite network layer protocols, such as CNLP, ES-IS, and IS-IS.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1378 | The PPP AppleTalk Control Protocol (ATCP) | The NCP for the AppleTalk
    protocol. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1552 | The PPP Internetworking Packet Exchange Control Protocol (IPXCP)
    | The NCP for the Novell IPX protocol. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2043 | The PPP SNA Control Protocol (SNACP) | The NCP for IBM''s Systems
    Network Architecture (SNA). |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2097 | The PPP NetBIOS Frames Control Protocol (NBFCP) | The NCP for
    NetBIOS Frames (NBF, also commonly called NetBEUI). |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2472 | IP Version 6 over PPP | The NCP for IPv6: the IPv6 Control Protocol
    (IPv6CP). |'
  prefs: []
  type: TYPE_TB
- en: '| Features | 1962 | The PPP Compression Control Protocol (CCP) | Defines a
    mechanism for compressing data sent over PPP links to improve performance. This
    standard describes how compression is negotiated between two devices on a PPP
    link. It is used in conjunction with several compression algorithms that actually
    do the compression of data. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1968 | The PPP Encryption Control Protocol (ECP) | Defines a mechanism
    for encrypting data sent over PPP links to improve performance. This standard
    describes how encryption is negotiated between two devices. It is used with several
    encryption algorithms. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1989 | PPP Link Quality Monitoring | Defines a protocol that lets PPP
    devices generate reports to each other about the quality of the link. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1990 | The PPP Multilink Protocol (MP) | Defines a method for running
    PPP over a set of aggregated links, thereby allowing two devices to use multiple
    low-bandwidth links as a single, high-bandwidth virtual link. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2125 | The PPP Bandwidth Allocation Protocol (BAP)/The PPP Bandwidth
    Allocation Control Protocol (BACP) | Defines two support protocols that manage
    the allocation of bandwidth in links aggregated using PPP MP. |'
  prefs: []
  type: TYPE_TB
- en: '| Applications and Miscellaneous | 1618 | PPP over ISDN | Describes application
    particulars for running PPP over ISDN links. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1973 | PPP in Frame Relay | Describes how PPP may be modified to run
    over Frame Relay at layer 2. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2290 | Mobile-IPv4 Configuration Option for PPP IPCP | Defines changes
    to the PPP Internet Protocol Control Protocol (IPCP) to support Mobile IP. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2364 | PPP over AAL5 | Defines a method for sending PPP frames over AAL5
    (ATM), commonly called PPPoA. |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2516 | A Method for Transmitting PPP over Ethernet (PPPoE) | Defines
    a technique for encapsulating PPP frames over Ethernet (PPPoE). |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2615 | PPP over SONET/SDH | Discusses how to encapsulate PPP frames over
    SONET/SDH links. |'
  prefs: []
  type: TYPE_TB
- en: 'Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter describes the protocols responsible for PPP link setup and basic
    operation, including Link Control Protocol (LCP) and the Network Control Protocols
    (NCPs) used to configure PPP for different layer 3 protocols. I also discuss the
    two PPP authentication protocols, Password Authentication Protocol (PAP) and Challenge
    Handshake Authentication Protocol (CHAP), which are used to provide authentication
    during link setup.
  prefs: []
  type: TYPE_NORMAL
- en: Link Control Protocol (LCP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of all the PPP suite protocols, LCP is the most important. It is responsible
    for PPP''s overall successful operation, and plays a key role in each PPP link
    stage: configuration, maintenance, and termination (as discussed in [Chapter 9](ch09.html
    "Chapter 9. TCP/IP SERIAL LINE INTERNET PROTOCOL (SLIP) AND POINT-TO-POINT PROTOCOL
    (PPP) OVERVIEW AND FUNDAMENTALS")). Link configuration is performed during the
    initial link establishment phase; link maintenance occurs while the link is open,
    and link termination happens in the link termination phase.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-1](ch10.html#ppp_link_control_protocol_lcp_message_ex "Figure 10-1. PPP
    Link Control Protocol (LCP) message exchanges This diagram shows the different
    message exchanges performed by LCP during link configuration, maintenance, and
    termination.") provides an overview of many of the message exchanges performed
    by LCP during different phases of a PPP connection. Link configuration is shown
    here as a simple exchange of a Configure-Request and Configure-Ack. After subsequent
    exchanges using other PPP protocols to authenticate and configure one or more
    NCPs, the link enters the link open phase. In this example, Echo-Request and Echo-Reply
    messages are first used to test the link, followed by the sending and receiving
    of data by both devices. One Data message is shown being rejected due to an invalid
    Code field. Finally, the link is terminated using Terminate-Request and Terminate-Ack
    messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP Link Control Protocol (LCP) message exchanges This diagram shows the
    different message exchanges performed by LCP during link configuration, maintenance,
    and termination.](httpatomoreillycomsourcenostarchimages287733.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. PPP Link Control Protocol (LCP) message exchanges This diagram
    shows the different message exchanges performed by LCP during link configuration,
    maintenance, and termination.
  prefs: []
  type: TYPE_NORMAL
- en: LCP Packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Devices use LCP to control the PPP link by sending LCP messages across the physical
    link between them. These messages are called both *LCP packets* and *LCP frames*.
    Although the standard uses *packet*, the term *frame* is preferred because layer
    2 messages are normally called frames. The main PPP document defines 11 different
    LCP frames, which are divided into three groups that correspond to the three link
    stages. Four LCP frame types are used for link configuration, five for maintenance,
    and two for termination.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section I'll discuss each of the three major functions of LCP
    and how the frames are used in each. ([Chapter 12](ch12.html "Chapter 12. PPP
    PROTOCOL FRAME FORMATS") describes the frame formats for the packets themselves.)
  prefs: []
  type: TYPE_NORMAL
- en: LCP Link Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Link configuration is arguably LCP's most important job in PPP. During the link
    establishment phase, the two physically connected devices exchange LCP frames
    that help them negotiate the conditions under which the link will operate. [Figure 10-2](ch10.html#ppp_lcp_link_configuration_process_the_n
    "Figure 10-2. PPP LCP link configuration process The negotiation process undertaken
    to configure the link by LCP. This process begins when the PPP link enters the
    link establishment phase. After successful configuration, the connection transitions
    to the authentication phase.") shows the entire procedure.
  prefs: []
  type: TYPE_NORMAL
- en: The process begins with the initiating device (Device A) creating a Configure-Request
    frame that contains a variable number of configuration options that it wants to
    see set up on the link. This is basically Device A's "wish list" for how it wants
    the link created.
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP LCP link configuration process The negotiation process undertaken to
    configure the link by LCP. This process begins when the PPP link enters the link
    establishment phase. After successful configuration, the connection transitions
    to the authentication phase.](httpatomoreillycomsourcenostarchimages287735.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2. PPP LCP link configuration process The negotiation process undertaken
    to configure the link by LCP. This process begins when the PPP link enters the
    link establishment phase. After successful configuration, the connection transitions
    to the authentication phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 1661, the main PPP document, defines a number of different configuration
    options that the initiator can specify in this request. Any one of these can be
    included and if so, filled in with the value corresponding to what Device A wants
    for that option. If absent, Device A isn''t requesting that option. The six options
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maximum Receive Unit (MRU)** Lets Device *A* specify the maximum size datagram
    it wants the link to be able to carry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication Protocol** Device *A* can indicate the type of authentication
    protocol it wishes to use (if any).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quality Protocol** If Device *A* wants to enable quality monitoring on the
    link, what quality monitoring protocol to use (though there is only one currently
    defined: LQR).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Magic Number** Used to detect looped-back links or other anomalies in the
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol Field Compression** Allows Device *A* to specify that it wants to
    use "compressed" (8-bit) Protocol fields in PPP data frames instead of the normal
    16-bit Protocol field. This provides a small (one byte) but free savings on each
    PPP frame. (Note that this has nothing to do with the compression feature offered
    by Compression Control Protocol, or CCP; see the PPP general frame format discussion
    in [Chapter 12](ch12.html "Chapter 12. PPP PROTOCOL FRAME FORMATS") for more on
    this feature.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address and Control Field Compression (ACFC)** The same as Protocol Field
    Compression, but used to compress the Address and Control fields for small bandwidth
    savings. (See the PPP general frame format topic in [Chapter 12](ch12.html "Chapter 12. PPP
    PROTOCOL FRAME FORMATS") for more.)'
  prefs: []
  type: TYPE_NORMAL
- en: Other options may also be added to this list by optional feature protocols.
    For example, Multilink PPP ([Chapter 11](ch11.html "Chapter 11. PPP FEATURE PROTOCOLS"))
    adds several options that must be negotiated during link setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other device (Device B) receives the Configure-Request and processes it.
    It then has the following three choices of how to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: If every option in it is acceptable, Device B sends back a Configure-Ack (acknowledge)
    frame. The negotiation is complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Device B recognizes all the options that Device A sent as valid and is capable
    of negotiating, but it doesn't accept the values, Device B returns a Configure-Nak
    (negative acknowledge) frame. This message includes a copy of each configuration
    option that Device B found unacceptable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of the options that Device A sent were either unrecognized by Device
    B or represent ways of using the link that Device B considers not only unacceptable,
    but not even subject to negotiation, it returns a Configure-Reject containing
    each of the objectionable options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a Configure-Nak and a Configure-Reject is that the former
    is like Device B saying, "I don't accept your terms, but I'll discuss," while
    the latter is Device B basically saying, "No way Jose!" For example, if Device
    A tries to request PAP as the authentication protocol, but Device B wants to use
    CHAP, it will send a Configure-Nak. If Device B doesn't support authentication
    at all, it will send a Configure-Reject.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Even after receiving a rejection, Device A can retry the negotiation with
    a new Configure-Request*.'
  prefs: []
  type: TYPE_NORMAL
- en: LCP Link Maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the link has been negotiated, LCP passes control to the appropriate authentication
    and NCP protocols (as discussed below). Eventually the link setup will complete
    and go into the open state, at which point, LCP messages can then be used by either
    device to manage or debug the link, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code-Reject and Protocol-Reject** These frame types are used to provide feedback
    when one device receives an invalid frame due to either an unrecognized LCP code
    (LCP frame type) or a bad protocol identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Echo-Request, Echo-Reply, and Discard-Request** These frames can be used
    for testing the link.'
  prefs: []
  type: TYPE_NORMAL
- en: LCP Link Termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the link is ready to be shut down, LCP terminates it. The device initiating
    the shutdown (which may not be the one that initiated the link in the first place)
    sends a Terminate-Request message. The other device replies with a Terminate-Ack
    message. A termination request indicates that the device sending it needs to close
    the link. This is a request that cannot be denied.
  prefs: []
  type: TYPE_NORMAL
- en: Other LCP Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard RFC 1570, "PPP LCP Extensions," also defines two new LCP message
    types. The Identification message is used to allow a device to identify itself
    to its peer on the link. The Time-Remaining message lets one device tell the other
    how much time remains in the current session.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the other protocols used in PPP are modeled after LCP. They use the
    same basic techniques for establishing protocol connections, and send and receive
    a subset of LCP message types. They also exchange configuration options in a similar
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: The Network Control Protocols (IPCP, IPXCP, NBFCP, and Others)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although PPP was originally created to carry IP datagrams, its designers realized
    that it could easily carry data from many types of network layer protocols, and
    that, on some networks, it might even be advantageous to let it carry datagrams
    from different layer 3 protocols simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing PPP to support multiple network layer protocols would require it to
    have knowledge of each one's idiosyncrasies. If you used only LCP for link configuration,
    the device would need to know all the unique requirements of each layer 3 protocol.
    This would also require you to update LCP constantly as new layer 3 protocols
    were defined and as new parameters were defined for existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate this potential issue, PPP takes a modular approach to link establishment.
    LCP performs the basic link setup, and after (optional) authentication, invokes
    an *NCP* that is specific to each layer 3 protocol that is to be carried over
    the link. The NCP negotiates any parameters that are unique to the particular
    network layer protocol, and more than one NCP can be run for each LCP link (see
    the discussion of PPP link setup and phases in [Chapter 9](ch09.html "Chapter 9. TCP/IP
    SERIAL LINE INTERNET PROTOCOL (SLIP) AND POINT-TO-POINT PROTOCOL (PPP) OVERVIEW
    AND FUNDAMENTALS")).
  prefs: []
  type: TYPE_NORMAL
- en: Each of the common network layer technologies has a PPP NCP defined for it in
    a separate RFC. The most common ones, "The PPP Internet Protocol Control Protocol
    (IPCP)," "The PPP Internetworking Packet Exchange Control Protocol (IPXCP)," and
    "The PPP NetBIOS Frames Control Protocol (NBFCP)," are NCPs for IP, IPX, and NBF
    (also called NetBEUI), respectively. A separate NCP is also defined for IP version
    6, the "PPP IP Version 6 Control Protocol (IPv6CP)."
  prefs: []
  type: TYPE_NORMAL
- en: Operation of NCPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each NCP operates very much like a light version of LCP, as you can see in
    [Figure 10-3](ch10s02.html#ppp_ip_control_protocol_ipcp_message_exc "Figure 10-3. PPP
    IP Control Protocol (IPCP) message exchanges The message exchanges, performed
    to configure and terminate IPCP, are quite similar to those used for LCP."). (To
    see the similarities, you should compare [Figure 10-3](ch10s02.html#ppp_ip_control_protocol_ipcp_message_exc
    "Figure 10-3. PPP IP Control Protocol (IPCP) message exchanges The message exchanges,
    performed to configure and terminate IPCP, are quite similar to those used for
    LCP.") to [Figure 10-1](ch10.html#ppp_link_control_protocol_lcp_message_ex "Figure 10-1. PPP
    Link Control Protocol (LCP) message exchanges This diagram shows the different
    message exchanges performed by LCP during link configuration, maintenance, and
    termination."), which shows the messaging for LCP.) Like LCP, each NCP performs
    functions for link setup, maintenance, and termination, except that it deals only
    with its particular type of NCP link and not the overall LCP link. Each NCP uses
    a subset of the following seven of the message types defined in LCP in very much
    the same way that LCP uses each message type of the same name, as shown for each
    of these three main link activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Configuration** The process of setting up and negotiating the parameters
    of a particular NCP link (once an LCP link is established) is accomplished using
    Configure-Request, Configure-Ack, Configure-Nak, and Configure-Reject messages
    as discussed for LCP (except that these are particular to each NCP). The configuration
    options are the network layer protocol parameters being negotiated.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Maintenance** Code-Reject messages can be sent to indicate invalid code
    values (NCP frame types).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Termination** An NCP link can be terminated using Terminate-Request
    and Terminate-Ack messages. But remember that NCP links are set up within an LCP
    link, and that there can be more than one NCP link open. Closing NCP links doesn''t
    terminate the LCP link. (NCP links do not need to be closed when an LCP link is
    terminated.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-3](ch10s02.html#ppp_ip_control_protocol_ipcp_message_exc "Figure 10-3. PPP
    IP Control Protocol (IPCP) message exchanges The message exchanges, performed
    to configure and terminate IPCP, are quite similar to those used for LCP.") shows
    how the overall operation of the NCPs, such as IPCP, is very similar to that of
    LCP. Once LCP configuration (including authentication) is complete, IPCP Configure-Request
    and Configure-Ack messages are used to establish an IPCP link. IP data can then
    be sent over the link. If the IPCP connection is no longer needed, it may be terminated,
    after which the LCP link remains open for other types of data to be transmitted.
    It is not necessary, however, to explicitly terminate the IPCP link before terminating
    the LCP connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP IP Control Protocol (IPCP) message exchanges The message exchanges, performed
    to configure and terminate IPCP, are quite similar to those used for LCP.](httpatomoreillycomsourcenostarchimages287737.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3. PPP IP Control Protocol (IPCP) message exchanges The message exchanges,
    performed to configure and terminate IPCP, are quite similar to those used for
    LCP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Once the primary PPP link is established using LCP, each network
    layer protocol to be carried over the link requires the establishment of the appropriate
    NCP link. The most important of these is the *PPP Internet Protocol Control Protocol
    (IPCP)*, which allows IP datagrams to be carried over PPP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Internet Protocol Control Protocol (IPCP): An Example NCP'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the NCP for IP: IPCP. When PPP is set up to carry IP datagrams,
    IPCP is invoked in the network layer protocol phase to set up an IP NCP link between
    the two devices. The setup is carried out using the four Configure- messages.
    For IP, two configuration options can be specified in an IPCP Configure-Request
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP Compression Protocol** Allows devices to negotiate the use of Van Jacobson
    TCP/IP header compression, which shrinks the size of TCP and IP headers to save
    bandwidth. This is similar in concept to the Protocol-Field-Compression and ACFC
    options in LCP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP Address** Allows the device sending the Configure-Request message either
    to specify an IP address it wants to use for routing IP over the PPP link or to
    request that the other device supply it with one. This is most commonly used for
    dial-up networking links.'
  prefs: []
  type: TYPE_NORMAL
- en: Once configuration is complete, data can be sent for the layer 3 protocol corresponding
    to the NCP negotiated. This is indicated by using the appropriate value for the
    Protocol field in PPP data frames containing that layer 3 data.
  prefs: []
  type: TYPE_NORMAL
- en: 'PPP Authentication Protocols: PAP and CHAP'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PPP was designed to provide layer 2 connectivity over a variety of serial links
    and other physical layer technologies, some of which introduce more security concerns
    than others. For example, suppose you connect two machines in your office with
    a serial cable and want to run PPP between them. When one of these initiates a
    PPP link with the other, you don't really need to worry about who's calling. On
    the other hand, consider an Internet service provider (ISP) using PPP for remote
    dial-in users. They generally want to allow only their customers to connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PPP protocol suite allows for the use of an optional authentication protocol
    when devices negotiate the basic link setup. The PPP suite initially defined two
    such protocols: PAP and CHAP. Once an LCP link is set up between two devices,
    a series of authentication messages are sent using these protocols to verify the
    identity of the device initiating the link. Only if authentication is successful
    can the link configuration proceed.'
  prefs: []
  type: TYPE_NORMAL
- en: PAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PAP is a very straightforward authentication scheme, consisting of only two
    basic steps, as shown in [Figure 10-4](ch10s03.html#pap_authentication_pap_uses_a_simple_exc
    "Figure 10-4. PAP authentication PAP uses a simple exchange of a request containing
    name and password information and a reply indicating whether or not authentication
    was successful.").
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication Request** The initiating device sends an Authenticate-Request
    message that contains a name and a password.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication Reply** The responding device looks at the name and password
    and decides whether to accept the initiating device and continue setting up the
    link. If so, it sends back an Authenticate-Ack message. Otherwise, it sends an
    Authenticate-Nak message.'
  prefs: []
  type: TYPE_NORMAL
- en: PAP is another example of something that is just too simple for its own good.
    Chief among its flaws is that it transmits the user name and password in clear
    text across the link. This is a big "no-no" because eavesdroppers can get the
    password.
  prefs: []
  type: TYPE_NORMAL
- en: PAP also provides no protection against various security attacks. For example,
    an unauthorized user could try different passwords indefinitely until he discovered
    the correct one. PAP also puts control of the authentication squarely on the shoulders
    of the initiating device (usually a client machine), which is not considered desirable,
    because this is normally a server function that administrators prefer to manage.
  prefs: []
  type: TYPE_NORMAL
- en: '![PAP authentication PAP uses a simple exchange of a request containing name
    and password information and a reply indicating whether or not authentication
    was successful.](httpatomoreillycomsourcenostarchimages287739.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4. PAP authentication PAP uses a simple exchange of a request containing
    name and password information and a reply indicating whether or not authentication
    was successful.
  prefs: []
  type: TYPE_NORMAL
- en: CHAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important difference between PAP and CHAP is that CHAP doesn't transmit
    the password across the link. When using PAP, the initiator (calling client) sends
    the authenticator (generally the server that is deciding whether to grant authentication)
    a message saying essentially, "Here's the password I know; see if it matches yours."
    Each device uses the password to perform a cryptographic computation, and then
    checks to see if it gets the same result. If so, they know they have the same
    password.
  prefs: []
  type: TYPE_NORMAL
- en: In CHAP, a basic LCP link is first set up between the initiator and authenticator.
    The authenticator then takes charge of the authentication process, using a technique
    called a *three-way handshake*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Three-way handshakes are a fairly common general authentication procedure.
    The same basic technique is used, for example, in shared key authentication on
    IEEE 802.11 wireless networking*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three-way handshake steps are as follows (see [Figure 10-5](ch10s03.html#ppp_challenge_handshake_authentication_p
    "Figure 10-5. PPP Challenge Handshake Authentication Protocol (CHAP) authentication
    CHAP uses a three-way handshake beginning with a Challenge from the authenticating
    device. This message is encrypted and returned to the authenticating device, which
    checks to see if the device trying to authenticate used the correct password (or
    other shared secret).")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge** The authenticator generates a frame called a Challenge and sends
    it to the initiator. This frame contains a simple text message (sometimes called
    the *challenge text*). The message has no inherent special meaning, so it doesn''t
    matter if anyone intercepts it. The important thing is that after receipt of the
    Challenge, both devices have the same Challenge message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response** The initiator uses its password (or some other shared secret that
    the authenticators also know) to encrypt the challenge text. It then sends the
    encrypted challenge text as a Response back to the authenticator.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Success or Failure** The authenticator performs the same encryption on the
    challenge text that the initiator did. If the authenticator gets the same result
    that the initiator sent it in the Response, it knows that the initiator had the
    right password when it did its encryption, so the authenticator returns a Success
    message. Otherwise, it sends a Failure message.'
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP Challenge Handshake Authentication Protocol (CHAP) authentication CHAP
    uses a three-way handshake beginning with a Challenge from the authenticating
    device. This message is encrypted and returned to the authenticating device, which
    checks to see if the device trying to authenticate used the correct password (or
    other shared secret).](httpatomoreillycomsourcenostarchimages287741.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5. PPP Challenge Handshake Authentication Protocol (CHAP) authentication
    CHAP uses a three-way handshake beginning with a Challenge from the authenticating
    device. This message is encrypted and returned to the authenticating device, which
    checks to see if the device trying to authenticate used the correct password (or
    other shared secret).
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this is that it verifies that the two devices have the same shared
    secret, but it doesn't require them to send the secret over the link. The Response
    is calculated based on the password, but the content of the Response is encrypted,
    and thus it's much harder to derive the password from. CHAP also provides protection
    against replay attacks, whereby an unauthorized user captures a message and tries
    to send it again later on. This is done by changing an identifier in each message
    and varying the challenge text. Also, in CHAP, the server controls the authentication
    process, not the client that is initiating the link.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** PPP supports two authentication protocols: *PAP* and *CHAP*.
    PAP is a simple request-and-reply authentication protocol that is widely considered
    to be inadequate because it sends the user name and password in clear text and
    provides little protection against many security concerns. CHAP uses a three-way
    handshake procedure and is preferred over PAP in most implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: CHAP is not perfect, but it's much better than PAP. In fact, the IETF made a
    rather strong statement in this regard when it revised the original RFC that described
    PAP and CHAP to include only CHAP in the new standard. Despite this, PAP is still
    used in some applications because it is simple. PAP can suffice in situations
    where security is not a big deal, but CHAP is a much better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Incidentally, in addition to PAP and CHAP, it is possible to use proprietary
    authentication schemes. This requires that the appropriate configuration option
    values be programmed into LCP for placement in the Authentication Protocol configuration
    option*.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11. PPP FEATURE PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Point-to-Point Protocol (PPP) is the standard for data link layer connectivity
    over serial links because its core protocols provide a solid operational foundation,
    as you saw in [Chapter 10](ch10.html "Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL,
    NETWORK CONTROL, AND AUTHENTICATION"). However, PPP''s popularity is based not
    just on its highly capable link establishment and management features, but it
    also has a number of very useful features that provide important security and
    performance benefits to network users.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe the protocols that implement several of the most
    common extra features in PPP. I begin with a discussion of PPP link quality monitoring.
    I describe the sets of protocols used to configure and implement data compression
    and data encryption. I then discuss the PPP Multilink Protocol (MP, MLPPP), which
    allows PPP to bundle multiple low-speed links into a single high-speed link. I
    also cover the *Bandwidth Allocation Protocol (BAP)* and *Bandwidth Allocation
    Control Protocol (BACP)*, which are used to manage the operation of MLPPP.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Link Quality Monitoring and Reporting (LQM, LQR)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PPP includes optional authentication in recognition of the varying *security*
    needs of the many different kinds of links over which PPP may operate. These links
    also differ greatly in terms of their *quality*. Just as you don't need to worry
    about authentication much when two machines are linked with a short cable, you
    also can feel pretty confident that data sent between them is going to arrive
    intact. Now contrast that with a PPP session established over a long-distance
    telephone call. For that matter, how about PPP over a dial-up call using an analog
    cellular phone?
  prefs: []
  type: TYPE_NORMAL
- en: PPP includes in its basic package a provision for detecting errors in sent frames,
    and higher-layer protocols like TCP also include methods of providing robustness
    on noisy lines. These techniques allow a link to tolerate problems, but provide
    little in the way of useful information about what the status of the link is.
    In some situations, devices may want to be able to keep track of how well the
    link is working, and perhaps take action on it. For example, a device experiencing
    too many errors on a dial-up connection might want to cut off and retry a new
    call. In some cases, a device might want to try an alternate method of attachment
    if the current physical link is not working well.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing this need, the PPP suite includes a feature that allows devices
    to analyze the quality of the link between them. This is called *PPP Link Quality
    Monitoring* or *LQM*. PPP is set up generically to allow any number of different
    monitoring functions to be used, but at present, there is only one, called *Link
    Quality Reporting (LQR)*. LQR allows a device to request that its peer (the other
    device on the link) keep track of statistics about the link and send periodic
    reports about them.
  prefs: []
  type: TYPE_NORMAL
- en: LQR Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before LQR can be used, it must be set up, which is done by LCP as part of
    the negotiation of basic link parameters in the Link Establishment phase (see
    [Chapter 10](ch10.html "Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL, NETWORK
    CONTROL, AND AUTHENTICATION")). The device opening the link requests link monitoring
    by including the Quality Protocol configuration option in its Configure-Request
    frame. The configuration option also specifies a *reporting period* that indicates
    the longest period of time that the requesting device wants to go between receiving
    reports.'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the negotiation is successful, LQR will be enabled. A number of
    counters are set up that keep track of various link statistics, and a timer is
    used to regulate the sending of quality reports over the link. Each time the timer
    expires, a link quality report is generated and sent in a PPP frame over the link
    using the special PPP Protocol field hexadecimal value 0xC025.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each counter holds information about a different statistic regarding the use
    of the link. Each counter is reset to zero when LQR is set up and then incremented
    each time a transmission is made or an event occurs that is relevant to the counter.
    The statistics tracked include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of frames sent or received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of octets (bytes) in all frames sent or received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of errors that have occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of frames that had to be discarded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of link quality reports generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These counters are reset only at the start of the link, so they contain figures
    that are kept cumulatively over the life of the connection. The counters can be
    used in the absolute sense, meaning that the counter value itself is reported.
    Alternatively, they can be expressed as relative (or *delta*) values, which represent
    the change since the last report. This is done when a report is received, simply
    by subtracting the previous report's numbers from the ones in the current report.
  prefs: []
  type: TYPE_NORMAL
- en: Using Link Quality Reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LQR specifies the quality reporting mechanism, but not specific standards for
    link quality, since these are so implementation-dependent. Based on the numbers
    in these reports, a device can decide for itself what conclusions to draw about
    link quality and what action to take, if any. Here are some possible behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: Some devices might decide to shut down a link if the absolute number of errors
    seen in any report reaches a certain threshold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some might look at the trend in successive reporting periods and take action
    if they detect certain trends, such as an increase in the rate of discarded frames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some devices might just log the information and take no action at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*LQR aggregates its statistics for all higher-layer protocols transmitted over
    a particular link. It doesn''t keep track of statistics for different higher-layer
    protocols separately, which makes sense, since the quality of the link shouldn''t
    vary from one higher-layer protocol to the next*.'
  prefs: []
  type: TYPE_NORMAL
- en: PPP Compression Control Protocol (CCP) and Compression Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PPP is primarily used to provide data link layer connectivity to physical serial
    links. One of the biggest problems with serial links compared to many other types
    of layer 1 connections is that they are relatively slow. Consider that while 10
    Mbps regular Ethernet is considered sluggish by modern LAN standards, it is actually
    much faster than most serial lines used for WAN connectivity, which can be ten,
    one hundred, or even one thousand times slower.
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve performance over serial links is to compress the data sent
    over the line. Depending on the data transferred, this can double the performance
    compared to uncompressed transmissions, and can, in some cases, do even better
    than that. For this reason, many hardware devices include the ability to compress
    the data stream at the physical layer. The best example of this is probably the
    set of compression protocols used on analog modems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some physical links don''t provide any compression capabilities, but could
    still benefit from it. To this end, an optional compression feature was created
    for PPP. It is implemented using the following two distinct protocol components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PPP Compression Control Protocol (CCP)** This protocol is responsible for
    negotiating and managing the use of compression on a PPP link.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PPP Compression Algorithms** A set of compression algorithms that perform
    the actual compression and decompression of data. Several of these are defined
    in RFCs. In addition, it is possible for two devices to negotiate the use of a
    proprietary compression method if they want to use one that isn''t defined by
    a public standard.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** PPP includes an optional compression feature that can improve
    performance over slow physical links. A variety of different compression algorithms
    are supported. To enable compression, both devices on a PPP link use the *PPP
    Compression Control Protocol (CCP)* to negotiate a compression algorithm to use.
    The compression algorithm is then used to compress and decompress PPP data frames.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CCP Operation: Compression Setup'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When most people talk about compression in PPP, they mention CCP, which is considered
    "the" compression protocol for PPP. However, CCP is actually used only to configure
    and control the use of compression; in fact, the algorithms do the real work of
    compressing and decompressing. This separation of powers provides flexibility,
    because it allows each implementation to choose what type of compression it wants
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: CCP is analogous to the Network Control Protocols (NCPs) that negotiate parameters
    specific to a network layer protocol sent on the link. An NCP lets two devices
    decide how they will carry layer 3 traffic, such as how Internet Protocol Control
    Protocol (IPCP) lets the devices determine how to carry IP. CCP lets two devices
    decide how they will compress data, in the same basic way.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, just as each NCP is like a "light" version of LCP, CCP is like a
    light version of LCP. It is used to set up a compression connection called a *CCP
    link* within an LCP link between two devices. Once established, compressed frames
    can be sent between the two devices. CCP also provides messaging capabilities
    for managing and eventually terminating a CCP link. Again, this is very similar
    to how each network layer protocol sets up an NCP link within LCP. A CCP link
    is maintained independently of any NCP links.
  prefs: []
  type: TYPE_NORMAL
- en: 'CCP uses the same subset of seven LCP message types that the NCPs use, and
    it adds two additional ones. The use of these messages for each of the life stages
    of a CCP link is as follows (this should look familiar if you''ve read about how
    the NCPs and LCP work in [Chapter 10](ch10.html "Chapter 10. PPP CORE PROTOCOLS:
    LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Configuration** Like the NCPs, compression configuration is done once
    CCP reaches the *network layer protocol* phase. The process of setting up compression
    and negotiating parameters is accomplished using Configure-Request, Configure-Ack,
    Configure-Nak, and Configure-Reject messages, just as it is for LCP, except the
    configuration options are particular to CCP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Maintenance** Code-Reject messages can be sent to indicate invalid code
    values in CCP frames. The two new message types are Reset-Request and Reset-Ack,
    which are used to reset the compression (the CCP link) in the event of a detected
    failure in decompression.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Termination** A CCP link can be terminated using Terminate-Request and
    Terminate-Ack. Again, remember that, like the NCP links, the CCP link is set up
    within an LCP link, and closing it doesn''t terminate the LCP link, which controls
    PPP overall.'
  prefs: []
  type: TYPE_NORMAL
- en: CCP Configuration Options and Compression Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CCP configuration options are used only to negotiate the type of compression
    to be used by the two devices, and to acquire the specifics of how that algorithm
    is to be employed. The device initiating the negotiation sends a Configure-Request
    with one option for each of the compression algorithms it supports. The other
    device compares this list of options to the algorithms it understands. It also
    checks for any specific details relevant to the option to see if it agrees on
    how that algorithm should be used. It then sends back the appropriate reply (Ack,
    Nak, or Reject), and a negotiation ensues until the two devices come up with a
    common algorithm that both understand. If so, compression is turned on; otherwise,
    it is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: The CCP configuration options begin with a Type value that indicates the compression
    algorithm. When the Type value is 0, this indicates that the option contains information
    about a special, proprietary compression algorithm that isn't covered by any RFC
    standards. This information can be used if both devices understand it. Values
    from 1 to 254 indicate compression algorithms that have been defined for use with
    CCP. [Table 11-1](ch11s02.html#ppp_compression_control_protocol_ccp_com "Table 11-1. PPP
    Compression Control Protocol (CCP) Compression Algorithms") shows the most common
    values of the Type field, including the compression algorithm each corresponds
    to and the number of the RFC that defines it.
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-1. PPP Compression Control Protocol (CCP) Compression Algorithms
  prefs: []
  type: TYPE_NORMAL
- en: '| CCP Option Type Value | Defining RFC | Compression Algorithm (As Given in
    RFC Title) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | — | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| 1 and 2 | 1978 | PPP Predictor Compression Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | 1974 | PPP Stac LZS Compression Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 2118 | Microsoft Point-to-Point Compression (MPPC) Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | 1993 | PPP Gandalf FZA Compression Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | 1977 | PPP BSD Compression Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | 1967 | PPP LZS-DCP Compression Protocol (LZS-DCP) |'
  prefs: []
  type: TYPE_TB
- en: '| 26 | 1979 | PPP Deflate Protocol |'
  prefs: []
  type: TYPE_TB
- en: 'Compression Algorithm Operation: Compressing and Decompressing Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once an algorithm has been successfully negotiated, the compression algorithm
    is used to compress data before transmission and to decompress it once received.
    To compress, the transmitting device takes the data that would normally be put
    in the Information field of an uncompressed PPP frame and runs it through the
    compression algorithm. To indicate that a frame has been compressed, the special
    value 0x00FD (hexadecimal) is placed in the PPP Protocol field. When compression
    is used with multiple links and the links are compressed independently, a different
    value is used: 0x00FB.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll recall that in a regular uncompressed frame, the Protocol field indicates
    which layer 3 protocol the data comes from. Since you still need to know this,
    the original Protocol value is actually prepended to the data before compression.
    When the data is decompressed, this value is used to restore the original Protocol
    field, so the receiving device knows to which higher layer the data belongs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you use IPCP to encapsulate IP data in PPP, the uncompressed
    frame would have a value of 0x8021 in the Protocol field. This value (0x8021)
    would be placed at the start of the data to be compressed. The compressed data
    would be put in a PPP frame with a Protocol value of 0x00FD. The receiving device
    would see the value 0x00FD in the Protocol field, recognize the frame as compressed,
    decompress it, and restore the original frame with 0x8021 as the Protocol value.
    The discussion of the PPP general frame format in [Chapter 12](ch12.html "Chapter 12. PPP
    PROTOCOL FRAME FORMATS") covers this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, a compression algorithm can put more than one PPP data frame into
    a compressed PPP data frame. Despite this, many, if not most, of the algorithms
    maintain a one-to-one correspondence, putting each PPP data frame into one compressed
    frame. Note that LCP frames are not compressed, nor are the control frames used
    for other protocols. For example, a data frame carrying IP traffic would be compressed,
    but a control frame for IPCP (the NCP for IP) would not be.
  prefs: []
  type: TYPE_NORMAL
- en: Compression can be combined with encryption. In this case, compression is done
    before encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The compression performed by CCP has nothing to do with the header compression
    options that can be negotiated as part of LCP. That type of compression doesn''t
    involve compressing a data stream using a compression algorithm, but rather a
    simple way of saving space in headers when both ends of a link agree to do so*.'
  prefs: []
  type: TYPE_NORMAL
- en: PPP Encryption Control Protocol (ECP) and Encryption Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PPP authentication protocols Password Authentication Protocol (PAP) and
    Challenge Handshake Authentication Protocol (CHAP) can be used to ensure that
    only authorized devices can establish a PPP connection. Once that is done, PPP
    normally provides no other security to the data being transmitted. In particular,
    all data is normally sent in the clear (unencrypted), thereby making it easy for
    someone who intercepts it to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'For important data that must be kept secure, encryption prior to transmission
    is a good idea. This can be done at higher layers using something like IPsec,
    but PPP also provides an optional feature that allows data to be encrypted and
    decrypted at the data link layer itself using two protocol components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PPP Encryption Control Protocol (ECP)** This protocol is responsible for
    negotiating and managing the use of encryption on a PPP link.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PPP Encryption Algorithms** A family of encryption algorithms that perform
    the actual encryption and decryption of data. Several of these are defined in
    RFCs, and two devices can also negotiate a proprietary encryption method if they
    want to use one that isn''t defined by a public standard.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** PPP includes an optional encryption feature that provides privacy
    for data transported over PPP. A number of encryption algorithms are supported.
    To enable encryption, both devices on a PPP link use the *PPP Encryption Control
    Protocol (ECP)* to negotiate which algorithm to use. The selected algorithm is
    then used to encrypt and decrypt PPP data frames.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ECP Operation: Encryption Setup'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECP is usually the only part mentioned when encryption in PPP is discussed,
    but it is actually used only to configure and control the use of encryption; the
    algorithms do the real work. This technique allows each implementation to choose
    which type of encryption it wishes to use.
  prefs: []
  type: TYPE_NORMAL
- en: The original ECP defined only a single encryption method, and a couple of others
    have since been added. Like CCP, ECP is analogous to the NCPs that negotiate parameters
    specific to a network layer protocol sent on the link, but it deals with how devices
    encrypt data, rather than how they transport layer 3 traffic. This also means
    that like the NCPs, ECP is a light version of LCP and works in the same basic
    way. Once an ECP link is negotiated, devices can send encrypted frames between
    each other. When no longer needed, the ECP link can be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECP uses the same subset of seven LCP message types that the NCPs use, and
    it adds two more. The use of these messages for each of the life stages of an
    ECP link is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Configuration** Like the NCPs (and also like CCP, of course), encryption
    configuration is done once ECP reaches the *network layer protocol* phase. The
    process of setting up encryption and negotiating parameters is accomplished using
    Configure-Request, Configure-Ack, Configure-Nak, and Configure-Reject messages,
    as I explained in the description of LCP in [Chapter 10](ch10.html "Chapter 10. PPP
    CORE PROTOCOLS: LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION"), except the
    configuration options are particular to ECP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Maintenance** Code-Reject messages can be sent to indicate invalid code
    values in ECP frames. The two new message types are Reset-Request and Reset-Ack,
    which are used to reset the encryption (the ECP link) in the event of a detected
    failure in decryption.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Termination** An ECP link can be terminated using Terminate-Request
    and Terminate-Ack. Again, remember that like the NCP links, the ECP link is set
    up within an LCP link, so closing it doesn''t terminate the LCP link.'
  prefs: []
  type: TYPE_NORMAL
- en: ECP Configuration Options and Encryption Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECP configuration options are used solely to negotiate the type of encryption
    algorithm that will be used by the two devices and the specifics of how that algorithm
    will be employed. The device initiating the negotiation sends a Configure-Request
    with one option for each of the encryption algorithms it supports. The other device
    compares this list of options to the algorithms it understands. It also checks
    for any details relevant to the option to see if it agrees on how that algorithm
    should be used. It then sends back the appropriate reply (Ack, Nak, or Reject),
    and a negotiation ensues until the two devices come up with a common algorithm
    that they both understand. If so, encryption is enabled; otherwise, it is turned
    off.
  prefs: []
  type: TYPE_NORMAL
- en: The ECP configuration options begin with a Type value that indicates the encryption
    algorithm. When the Type value is 0, this indicates that the option contains information
    about a special, proprietary encryption method that isn't covered by any RFC standards,
    which can be used if both devices understand it. Values in the range from 1 to
    254 indicate encryption algorithms that have been defined for use with ECP; at
    present, only two are defined. [Table 11-2](ch11s03.html#ppp_encryption_control_protocol_ecp_comp
    "Table 11-2. PPP Encryption Control Protocol (ECP) Compression Algorithms") shows
    the values of the Type field, including the encryption algorithm each corresponds
    to and the number of the RFC that defines it.
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-2. PPP Encryption Control Protocol (ECP) Compression Algorithms
  prefs: []
  type: TYPE_NORMAL
- en: '| ECP Option Type Value | Defining RFC | Encryption Algorithm (As Given in
    RFC Title) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | — | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2420 | The PPP Triple-DES Encryption Protocol (3DESE) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2419 | The PPP DES Encryption Protocol, Version 2 (DESE-bis) |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Type value 1 was for the original DES algorithm, which was defined in RFC
    1969\. It was superseded by DES version 2 in RFC 2419*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encryption Algorithm Operation: Encrypting and Decrypting Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once an encryption algorithm has been successfully negotiated, it is used to
    encrypt data before transmission and to decrypt data that has been received. To
    encrypt, the transmitting device takes the data that would normally be put in
    the Information field of an unencrypted PPP frame and runs it through the encryption
    algorithm. To indicate that a frame has been encrypted, the special value 0x0053
    (hexadecimal) is placed in the PPP Protocol field. When encryption is used with
    multiple links and the links are encrypted independently, a different value is
    used: 0x0055.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll recall that in a regular unencrypted frame, the Protocol field indicates
    which layer 3 protocol the data comes from. Since you still need to know this,
    the original Protocol value is actually prepended to the data before encryption.
    When the data is decrypted, this value is used to restore the original Protocol
    field, so the receiving device knows which higher layer the data belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you use IPCP to encapsulate IP data in PPP, the unencrypted
    frame would have a value of 0x8021 (hex) in the Protocol field. This value (0x8021)
    would be placed at the start of the data to be encrypted. The encrypted data would
    be put in a PPP frame with a Protocol value of 0x0053\. The receiving device would
    see the value 0x0053 in the Protocol field, recognize the frame as encrypted,
    decrypt it, and restore the original frame with 0x8021 as the Protocol value.
    The discussion of the PPP general frame format in [Chapter 12](ch12.html "Chapter 12. PPP
    PROTOCOL FRAME FORMATS") covers this more completely.
  prefs: []
  type: TYPE_NORMAL
- en: Each encrypted PPP data frame carries exactly one PPP data frame. Note that,
    unlike what you saw in compression, LCP frames and the control frames used for
    other protocols *can* be encrypted. Compression can be combined with encryption;
    in this case, compression is done before encryption.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Multilink Protocol (MP, MLP, MLPPP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, there is only a single physical layer link between two devices.
    However, there are some situations for which there may actually be two layer 1
    connections between the same pair of devices. This may seem strange. Why would
    there be more than one link between any pair of machines?
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of situations in which this can occur. A common one is when
    two links are intentionally placed between a pair of devices. This is often done
    to increase performance by widening the pipe between two devices, without going
    to a newer, more expensive technology. For example, if two machines are connected
    to each other using a regular analog modem that's too slow, a relatively simple
    solution is to use two analog modem pairs connecting the machines to double bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly different situation occurs when multiplexing creates the equivalent
    of several physical layer channels between two devices, even if they have only
    one hardware link between them. Consider ISDN, for example. The most common form
    of ISDN service (ISDN basic rate interface or BRI) creates two 64,000 bps *B channels*
    between a pair of devices. These B channels are time division multiplexed and
    carried along with a D channel on a single pair of copper wire, but to the devices,
    they appear *as if* there were two physical layer links between devices, each
    of which carries 64 Kbps of data. And the ISDN primary rate interface (PRI) actually
    creates 23 or more channels, all between the same pair of hardware devices.
  prefs: []
  type: TYPE_NORMAL
- en: In a situation where you have multiple links, you could just establish PPP over
    each connection independently. However, this is far from an ideal solution, because
    you would then have to manually distribute the traffic over the two (or more)
    channels or links that connect them. If you wanted to connect to the Internet,
    you would need to make separate connections and then choose which one to use for
    each action. That isn't exactly a recipe for fun, and what's worse is that you
    could never use all the bandwidth for a single purpose, such as downloading the
    latest 100 MB Microsoft security patch.
  prefs: []
  type: TYPE_NORMAL
- en: What you really want is a solution that will let you combine multiple links
    and use them as if they were one high-performance link. Some hardware devices
    actually allow thisto be done at the hardware level itself. In ISDN, this technology
    is sometimes called *bonding* when done at layer 1\. For those hardware units
    that don't provide this capability, PPP makes it available in the form of the
    PPP Multilink Protocol (MP). This protocol was originally described in RFC 1717
    and was updated in RFC 1990.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The PPP Multilink Protocol is properly abbreviated MP, but it is common to
    see any of a multitude of other abbreviations used for it. Many of these are actually
    derived from changing the order of the words in the name into Multilink PPP, so
    you will frequently see this called ML PPP, MLPPP, MPPP, MLP, and so forth. These
    are technically incorrect, but widely used, especially MLPPP. I use the correct
    abbreviation in this book*.'
  prefs: []
  type: TYPE_NORMAL
- en: PPP Multilink Protocol Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MP is an optional feature of PPP, so it must be designed to integrate seamlessly
    into regular PPP operation. To accomplish this, MP is implemented as a new architectural
    sublayer within PPP. In essence, an MP sublayer is inserted between the regular
    PPP mechanism and any network layer protocols using PPP, as shown in [Figure 11-1](ch11s04.html#multilink_ppp_architecture_when_multilin
    "Figure 11-1. Multilink PPP architecture When Multilink PPP is used to combine
    two or more physical links, it sits architecturally above the PPP layers that
    operate on each physical link."). This allows MP to take all network layer data
    to be sent over the PPP link and spread it over multiple physical connections,
    without causing either the normal PPP mechanisms or the network layer protocol
    interfaces to PPP to break.
  prefs: []
  type: TYPE_NORMAL
- en: The column on the left in [Figure 11-1](ch11s04.html#multilink_ppp_architecture_when_multilin
    "Figure 11-1. Multilink PPP architecture When Multilink PPP is used to combine
    two or more physical links, it sits architecturally above the PPP layers that
    operate on each physical link.") shows the TCP/IP model architecture with corresponding
    OSI Reference Model layer numbers. The center column shows the normal PPP layer
    architecture. When MP is used, there are separate PPP implementations running
    over each of two or more physical links. MP sits, architecturally, between these
    links and any network layer protocols that will be transported over those links.
    (In this diagram, only IP is shown because it is most common, but MP can work
    with multiple network layer protocols, each of which are being sent over each
    physical link.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Multilink PPP architecture When Multilink PPP is used to combine two or more
    physical links, it sits architecturally above the PPP layers that operate on each
    physical link.](httpatomoreillycomsourcenostarchimages287743.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1. Multilink PPP architecture When Multilink PPP is used to combine
    two or more physical links, it sits architecturally above the PPP layers that
    operate on each physical link.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *PPP Multilink Protocol (MP)* allows PPP to bundle multiple
    physical links and use them like a single, high-capacity link. It must be enabled
    during link configuration. Once operational, it works by fragmenting whole PPP
    frames and sending the fragments over different physical links.'
  prefs: []
  type: TYPE_NORMAL
- en: PPP Multilink Protocol Setup and Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use MP, both devices must have it implemented as part of their PPP software
    and must negotiate its use. This is done by LCP as part of the negotiation of
    basic link parameters in the *link establishment* phase (just like LQR, as described
    earlier in this chapter). Three new configuration options are defined to be negotiated
    to enable MP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multilink Maximum Received Reconstructed Unit** Provides the basic indication
    that the device starting the negotiation supports MP and wants to use it. The
    option contains a value specifying the maximum size of the PPP frame it supports.
    If the device receiving this option does not support MP, it must respond with
    a Configure-Reject LCP message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multilink Short Sequence Number Header Format** Allows devices to negotiate
    the use of a shorter sequence number field for MP frames, for efficiency. (See
    the section on MP frames in [Chapter 12](ch12.html "Chapter 12. PPP PROTOCOL FRAME
    FORMATS") for a full discussion.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Endpoint Discriminator** Uniquely identifies the system. It is used to allow
    devices to determine which links go to which other devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Before MP can be used, a successful negotiation of at least the Multilink Maximum
    Received Reconstructed Unit option must be performed on each of the links between
    the two devices. Once this is done and an LCP link exists for each of the physical
    links, a virtual *bundle* is made of the LCP links, and MP is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Multilink Protocol Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, MP basically sits between the network layer and the
    regular PPP links and acts as a middleman. Here is what it does for each direction
    of communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transmission** MP accepts datagrams received from any of the network layer
    protocols configured using appropriate NCPs. It first encapsulates them into a
    modified version of the regular PPP frame, and then takes that frame and decides
    how to transmit it over the multiple physical links. Typically, this is done by
    dividing the frame into *fragments* that are evenly spread out over the set of
    links. These are then encapsulated and sent over the physical links. However,
    you can also implement an alternative strategy as well, such as alternating full-sized
    frames between the links. Also, smaller frames typically aren''t fragmented, and
    neither are control frames such as the ones used for link configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reception** MP takes the fragments received from all physical links and reassembles
    them into the original PPP frame. That frame is then processed like any PPP frame
    by looking at its Protocol field and passing it to the appropriate network layer
    protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: The fragments used in MP are similar in concept to IP fragments, but of course
    these are different protocols running at different layers. To PPP or MP, an IP
    fragment is just an IP datagram like any other.
  prefs: []
  type: TYPE_NORMAL
- en: The fragmenting of data in MP introduces a number of complexities that the protocol
    must handle. For example, since fragments are being sent roughly concurrently,
    you need to identify them with a sequence number to facilitate reassembly. You
    also need some control information to identify the first and last fragments. A
    special frame format is used for MP fragments to carry this extra information.
    I describe this in [Chapter 12](ch12.html "Chapter 12. PPP PROTOCOL FRAME FORMATS"),
    which also contains more information about how fragmenting is accomplished, as
    well as an illustration that demonstrates how it works.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Bandwidth Allocation Protocol (BAP) and Bandwidth Allocation Control Protocol
    (BACP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PPP MP allows multiple links between a pair of devices, whether physical
    or in the form of virtual channels, to be combined into a fat pipe (high-capacity
    channel). This offers tremendous advantages to many PPP users, because it lets
    them make optimal use of all their bandwidth, especially for applications such
    as Internet connectivity. It's no surprise, then, that MP has become one of the
    most popular features of PPP.
  prefs: []
  type: TYPE_NORMAL
- en: The original standard defining MP basically assumed that multiple links would
    be combined into a single bundle. For example, if you had two modem links, they
    would both be connected and then combined, or two B channels in an ISDN link would
    be combined. After MP was set up, the bundle would be available for either device
    to use in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one drawback to this system: The fat pipe is always enabled, and in
    many cases, it is expensive to have this set up all the time. It often costs more
    to connect two or more layer 1 links than a single one, and it''s not always needed.
    For example, some ISDN services charge per minute for calls on either of the B
    channels. In the case of modem dial-up, there are per-minute charges in some parts
    of the world. Even where regular phone calls are free, there is a cost in the
    form of tying up a phone line. Consider that in many applications, the amount
    of bandwidth needed varies over time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be better if you could set up MP so that it could dynamically add
    links to the bundle when needed (such as when you decided to download some large
    files), and then automatically drop them when no longer required. This enhancement
    to the basic MP package was provided in the form of a pair of new protocols described
    in RFC 2125:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bandwidth Allocation Protocol (BAP)** Describes a mechanism where either
    device communicating over an MP bundle of layer 1 links may request that a link
    be added to the bundle or removed from it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bandwidth Allocation Control Protocol (BACP)** Allows devices to configure
    how they want to use BAP.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *BAP* and *BACP* are used to provide dynamic control over how
    PPP MP functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'BACP Operation: Configuring the Use of BAP'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with BACP, since it is the protocol used for the initial setup of
    the feature. BACP is very similar conceptually to all those other PPP protocols
    with "Control" in their names, such as LCP, the NCP family, CCP, and ECP, but
    is actually even simpler. It is used only during link configuration to set up
    BAP. This is done using Configure-Request, Configure-Ack, Configure-Nak, and Configure-Reject
    messages, just as described in the LCP topic.
  prefs: []
  type: TYPE_NORMAL
- en: The only configuration option that is negotiated in BACP is one called Favored-Peer,
    which is used to ensure that a problem does not occur if the two devices on the
    link try to send the same request at the same time. If both devices support BAP,
    then the BACP negotiation will succeed and BAP will be activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'BAP Operation: Adding and Removing Links'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BAP defines a set of messages that can be sent between devices to add or drop
    links to and from the current PPP bundle. What's particularly interesting about
    BAP is that it includes the tools necessary to have a device actually initiate
    different types of physical layer connections (such as dialing a modem for bundled
    analog links or enabling an extra ISDN channel) when more bandwidth is required.
    It then shuts them down when they're no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a brief description of the BAP message types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Call-Request and Call-Response** When one device on the link wants to add
    a link to the bundle and initiate the new physical layer link itself, it sends
    a Call-Request frame to tell the other device, which replies with a Call-Response.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Callback-Request and Callback-Response** These are just like the two previous
    message types, except that they''re used when a device wants its peer (the other
    device on the link) to initiate the call to add a new link. So, if Device A says,
    "I need more bandwidth but I want you to call me, instead of me calling you,"
    it sends Device B a Callback-Request.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Call-Status-Indication and Call-Status-Response** After a device attempts
    to add a new link to the bundle (after sending a Call-Request or receiving a Callback-Request),
    it reports the status of the new link using the Call-Status-Indication frame.
    The other device then replies with a Call-Status-Response.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link-Drop-Query-Request and Link-Drop-Query-Response** One device uses these
    messages to request that a link be dropped, and the other uses them to respond
    to that request.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the decision of when to add or remove links is not made by these protocols.
    It is left up to the particular implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12. PPP PROTOCOL FRAME FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Point-to-Point Protocol (PPP) protocol suite includes a number of different
    protocols used to send both data and control information in different ways. Each
    of these packages information into messages called *frames*, each of which follows
    a particular *frame format*. PPP starts with a general frame format that encompasses
    all frames sent on the link and then includes more specific formats for different
    purposes. Understanding these formats not only makes diagnosing PPP issues easier,
    but also helps make more clear how the key PPP protocols function.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I illustrate the most common frame formats used for sending
    both data and control information over PPP. I begin with an explanation of the
    overall format used for all PPP frames. I also describe the general format used
    for the various control protocols and the option format that most of them use.
    (One of the nice things about PPP is that so many of the protocols use control
    frames with a common format.)
  prefs: []
  type: TYPE_NORMAL
- en: I then specifically list the frames used for Link Control Protocol (LCP) and
    the authentication protocols (PAP and CHAP). I also describe the special format
    used by the PPP Multilink Protocol (MP) to transport fragments of data over bundled
    links.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Due to the sheer number of different protocols in PPP (dozens) and the fact
    that many have their own unique options, I won''t describe all the specific frame
    formats and option formats for every protocol in detail here. Please refer to
    the appropriate RFCs (listed in [Chapter 9](ch09.html "Chapter 9. TCP/IP SERIAL
    LINE INTERNET PROTOCOL (SLIP) AND POINT-TO-POINT PROTOCOL (PPP) OVERVIEW AND FUNDAMENTALS")
    for more detail).*'
  prefs: []
  type: TYPE_NORMAL
- en: PPP General Frame Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All messages sent using PPP can be considered either *data* or *control information*.
    The word *data* describes the higher-layer datagrams you are trying to transport
    here at layer 2\. This is what our "customers" are giving us to send. Control
    information is used to manage the operation of the various protocols within PPP
    itself. Even though different protocols in the PPP suite use many types of frames,
    at the highest level, they all fit into a single, *general* frame format.
  prefs: []
  type: TYPE_NORMAL
- en: You'll recall that the basic operation of the PPP suite is based on the ISO
    High-Level Data Link Control (HDLC) protocol. This becomes very apparent when
    you look at the structure of PPP frames overall—they use the same basic format
    as HDLC, even to the point of including certain fields that aren't strictly necessary
    for PPP itself. The only major change is the addition of a new field to specify
    the protocol of the encapsulated data. The general structure of PPP frames is
    defined in RFC 1662, a companion to the main PPP standard RFC 1661.
  prefs: []
  type: TYPE_NORMAL
- en: The general frame format for PPP, showing how the HDLC framing is applied to
    PPP, is described in [Table 12-1](ch12.html#ppp_general_frame_format-id001 "Table 12-1. PPP
    General Frame Format") and illustrated in [Figure 12-1](ch12.html#ppp_general_frame_format-id002
    "Figure 12-1. PPP general frame format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1. PPP General Frame Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Flag | 1 | Indicates the start of a PPP frame. Always has the value 01111110
    binary (0x7E hexadecimal, or 126 decimal). |'
  prefs: []
  type: TYPE_TB
- en: '| Address | 1 | In HDLC this is the address of the destination of the frame.
    But in PPP you are dealing with a direct link between two devices, so this field
    has no real meaning. It is thus always set to 11111111 (0xFF or 255 decimal),
    which is equivalent to a broadcast (it means "all stations"). |'
  prefs: []
  type: TYPE_TB
- en: '| Control | 1 | This field is used in HDLC for various control purposes, but
    in PPP it is set to 00000011 (3 decimal). |'
  prefs: []
  type: TYPE_TB
- en: '| Protocol | 2 | Identifies the protocol of the datagram encapsulated in the
    Information field of the frame. See the "Protocol Field Ranges" section for more
    information on the Protocol field. |'
  prefs: []
  type: TYPE_TB
- en: '| Information | Variable | Zero or more bytes of payload that contain either
    data or control information, depending on the frame type. For regular PPP data
    frames, the network layer datagram is encapsulated here. For control frames, the
    control information fields are placed here instead. |'
  prefs: []
  type: TYPE_TB
- en: '| Padding | Variable | In some cases, additional dummy bytes may be added to
    pad out the size of the PPP frame. |'
  prefs: []
  type: TYPE_TB
- en: '| Frame Check Sequence | 2 (or 4) | A checksum computed over the frame to provide
    basic protection against errors in transmission. This is a CRC similar to the
    one used for other layer 2 protocol error-protection schemes such as the one used
    in Ethernet. It can be either 16 bits or 32 bits in size (the default is 16 bits).
    The FCS is calculated over the Address, Control, Protocol, Information, and Padding
    fields. |'
  prefs: []
  type: TYPE_TB
- en: '| Flag | 1 | Indicates the end of a PPP frame. Always has the value 01111110
    binary (0x7E hexadecimal, or 126 decimal). |'
  prefs: []
  type: TYPE_TB
- en: '![PPP general frame format](httpatomoreillycomsourcenostarchimages287745.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1. PPP general frame format
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Field Ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Protocol field is the main frame type indicator for the device receiving
    the frame. For data frames, this is normally the network layer protocol that created
    the datagram; for control frames, it is usually the PPP protocol that created
    the control message. In the case of protocols that modify data such as when compression
    (CCP) or encryption (ECP) are used (as explained in the previous chapter), this
    field identifies the data as being either compressed or encrypted, and the original
    Protocol value is extracted after the Information field is decompressed/decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: All PPP frames are built on the general format shown in [Figure 12-1](ch12.html#ppp_general_frame_format-id002
    "Figure 12-1. PPP general frame format"). The first three bytes are fixed in value,
    followed by a two-byte Protocol field that indicates the frame type. The variable-length
    Information field is formatted in a variety of ways, depending on the PPP frame
    type. Padding may be applied to the frame, which concludes with an FCS field of
    either two or four bytes (two bytes shown here) and a trailing Flag value of 0x7E.
    (See [Figure 12-2](ch12.html#sample_ppp_data_frame_an_example_of_a_pp "Figure 12-2. Sample
    PPP data frame An example of a PPP data frame containing an abbreviated 23-byte
    IP datagram.") for an example of how this format is applied.)
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of network layer protocols and PPP control protocols, and a
    correspondingly large number of Protocol values. The main PPP standard defines
    four ranges for organizing these values, as shown in [Table 12-2](ch12.html#ppp_protocol_field_ranges
    "Table 12-2. PPP Protocol Field Ranges").
  prefs: []
  type: TYPE_NORMAL
- en: The standard also specifies that the Protocol value must be assigned so that
    the first octet is even and the second octet is odd. So, for example, 0x0021 is
    a valid value, but 0x0121 and 0x0120 are not. (The reason for this will become
    apparent shortly.) There are also certain blocks that are reserved and not used.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-2](ch12.html#sample_ppp_data_frame_an_example_of_a_pp "Figure 12-2. Sample
    PPP data frame An example of a PPP data frame containing an abbreviated 23-byte
    IP datagram.") shows one common application of the PPP general frame format: carrying
    data. The value 0x0021 in the *Protocol* field marks this as an IPv4 datagram.
    This sample has 1 byte of *Padding* and a 2-byte *FCS* as well. (Obviously real
    IP datagrams are longer than the 23 bytes shown here! These bytes are arbitrary
    and don''t represent a real datagram.) See [Figure 12-12](ch12s05.html#ppp_mp_fragmentation_this_diagram_shows_
    "Figure 12-12. PPP MP fragmentation This diagram shows how a single PPP frame
    is fragmented into three smaller ones.") for an illustration of how this same
    data frame is formatted and then fragmented for transmission over multiple links
    using the PPP Multilink Protocol (MP).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-2. PPP Protocol Field Ranges
  prefs: []
  type: TYPE_NORMAL
- en: '| Protocol Field Range (Hexadecimal) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0000–3FFF** | Encapsulated network layer datagrams that have an associated
    NCP (see [Chapter 10](ch10.html "Chapter 10. PPP CORE PROTOCOLS: LINK CONTROL,
    NETWORK CONTROL, AND AUTHENTICATION")). In this case, control frames from the
    corresponding NCP use a Protocol field value that is computed by adding 8 to the
    first octet of the network layer Protocol value. For example, for IP the Protocol
    value is 0021, and control frames from the IP Control Protocol (IPCP) use Protocol
    value 8021\. This range also includes several values used for specially processed
    encapsulated datagrams, such as when compression or encryption is employed. |'
  prefs: []
  type: TYPE_TB
- en: '| **4000–7FFF** | Encapsulated datagrams from "low-volume" protocols. These
    are protocols that do not have an associated NCP. |'
  prefs: []
  type: TYPE_TB
- en: '| **8000–BFFF** | NCP control frames that correspond to the network layer Protocol
    values in the 0000–3FFF range. |'
  prefs: []
  type: TYPE_TB
- en: '| **C000–FFFF** | Control frames used by LCP and LCP support protocols such
    as PAP and CHAP. Some miscellaneous protocol values are included here as well.
    |'
  prefs: []
  type: TYPE_TB
- en: '![Sample PPP data frame An example of a PPP data frame containing an abbreviated
    23-byte IP datagram.](httpatomoreillycomsourcenostarchimages287747.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2. Sample PPP data frame An example of a PPP data frame containing
    an abbreviated 23-byte IP datagram.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Field Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The full list of PPP Protocol values is maintained by the Internet Assigned
    Numbers Authority (IANA), along with all the other different reserved numbers
    for Internet standards. [Table 12-3](ch12.html#common_protocols_carried_in_ppp_frames_a
    "Table 12-3. Common Protocols Carried in PPP Frames and Protocol Field Values")
    shows some of the more common values.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-3. Common Protocols Carried in PPP Frames and Protocol Field Values
  prefs: []
  type: TYPE_NORMAL
- en: '| Protocol Type | Protocol Field Value (Hex) | Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Encapsulated Network Layer Datagrams | 0021 | Internet Protocol version 4
    (IPv4) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 0023 | OSI Network Layer |'
  prefs: []
  type: TYPE_TB
- en: '|   | 0029 | AppleTalk |'
  prefs: []
  type: TYPE_TB
- en: '|   | 002B | Novell Internetworking Packet Exchange (IPX) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 003D | PPP Multilink Protocol (MP) fragment |'
  prefs: []
  type: TYPE_TB
- en: '|   | 003F | NetBIOS Frames (NBF/NetBEUI) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 004D | IBM Systems Network Architecture (SNA) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 0053 | Encrypted Data (using ECP and a PPP encryption algorithm) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 0055 | Individual Link Encrypted Data under PPP Multilink |'
  prefs: []
  type: TYPE_TB
- en: '|   | 0057 | Internet Protocol version 6 (IPv6) |'
  prefs: []
  type: TYPE_TB
- en: '|   | 00FB | Individual Link Compressed Data under PPP Multilink |'
  prefs: []
  type: TYPE_TB
- en: '|   | 00FD | Compressed Data (using CCP and a PPP compression algorithm) |'
  prefs: []
  type: TYPE_TB
- en: '| Low-Volume Encapsulated Protocols | 4003 | CDPD Mobile Network Registration
    Protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   | 4025 | Fibre Channel |'
  prefs: []
  type: TYPE_TB
- en: '| Network Control Protocol (NCP) Control Frames | 8021 | PPP Internet Protocol
    Control Protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   | 8023 | PPP OSI Network Layer Control Protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   | 8029 | PPP AppleTalk Control Protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   | 802B | PPP IPX Control Protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   | 803F | PPP NetBIOS Frames Control Protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   | 804D | PPP SNA Control Protocol |'
  prefs: []
  type: TYPE_TB
- en: '|   | 8057 | PPP IPv6 Control Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| LCP and Other Control Frames | C021 | PPP Link Control Protocol (LCP) |'
  prefs: []
  type: TYPE_TB
- en: '|   | C023 | PPP Password Authentication Protocol (PAP) |'
  prefs: []
  type: TYPE_TB
- en: '|   | C025 | PPP Link Quality Report (LQR) |'
  prefs: []
  type: TYPE_TB
- en: '|   | C02B | PPP Bandwidth Allocation Control Protocol (BACP) |'
  prefs: []
  type: TYPE_TB
- en: '|   | C02D | PPP Bandwidth Allocation Protocol (BAP) |'
  prefs: []
  type: TYPE_TB
- en: '|   | C223 | PPP Challenge Handshake Authentication Protocol (CHAP) |'
  prefs: []
  type: TYPE_TB
- en: PPP Field Compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PPP uses the HDLC basic framing structure, which includes two fields that are
    needed in HDLC but aren't in PPP due to how the latter operates. The fields are
    the Address and Control fields. Why bother sending two bytes that have the same
    value for every frame and aren't used for anything? Originally, they were maintained
    for compatibility, but this reduces efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid wasting two bytes in every frame, it is possible during initial link
    setup using the Link Control Protocol (LCP) for the two devices on the link to
    negotiate a feature called *Address and Control Field Compression (ACFC)* using
    the LCP option by that same name. When enabled, this feature simply causes these
    two fields not to be sent for most PPP frames (but not for LCP control frames).
    In fact, the feature would be better named *Address and Control Field Suppression*,
    because the fields are just suppressed and compressed down to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Even when devices agree to use field compression, they must still be capable
    of receiving both compressed and uncompressed frames. They differentiate one from
    the other by looking at the first two bytes after the initial Flag field. If they
    contain the value 0xFF03, they must be the Address and Control fields; otherwise,
    those fields were suppressed. (The value 0xFF03 is not a valid Protocol field
    value, so there is no chance of ambiguity.)
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, it is also possible for the two devices on the link to negotiate
    compression of the Protocol field, so it takes only one byte instead of two. This
    is done generally by dropping the first byte if it is zero, a process called *Protocol
    Field Compression (PFC)*. Recall that the first byte must be even and the second
    odd. Thus, a receiving device examines the evenness of the first byte of the Protocol
    field in each frame. If it is odd, this means that a leading byte of zeros in
    the Protocol field has been suppressed, because the first byte of a full two-byte
    Protocol value must be even.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This field compression (really suppression) has nothing to do with data compression
    using PPP''s Compression Control Protocol (CCP) and compression algorithms.*'
  prefs: []
  type: TYPE_NORMAL
- en: PPP General Control Protocol Frame Format and Option Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general frame format you just saw is used for all of the many frame types
    defined in the PPP protocol suite. Within that format, the Information field carries
    either encapsulated layer 3 user data or encapsulated control messages. These
    control messages contain specific information that is used to configure, manage,
    and discontinue PPP links, and to implement the various features that comprise
    PPP.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different PPP control protocols that usually can be distinguished
    by the word *Control* appearing their names. These include the main PPP Link Control
    Protocol (LCP); a family of Network Control Protocols (NCPs) such as IPCP, IPXCP,
    and so forth; and also control protocols for implementing features, such as the
    Compression Control Protocol (CCP) and the Encryption Control Protocol (ECP).
    The authentication protocols Password Authentication Protocol (PAP) and Challenge
    Handshake Authentication Protocol (CHAP) lack Control in the name but also fall
    into this category.
  prefs: []
  type: TYPE_NORMAL
- en: The control protocols each use control messages in a slightly different way,
    but there is also a great deal of commonality between the messages. This is because,
    as I explained in my discussions of the PPP protocols, most of the control protocols—such
    as the NCP family, CCP, and ECP—are implemented as subsets of the functionality
    of the LCP. They perform many of the same functions, so the PPP designers wisely
    adapted the LCP messaging system for these other control protocols.
  prefs: []
  type: TYPE_NORMAL
- en: This all means that control protocol frames have a common format that fits within
    the overall general frame format in PPP. Even protocols like PAP and CHAP, which
    aren't based on LCP, use this general control frame format, which is described
    in [Table 12-4](ch12s02.html#ppp_control_message_format "Table 12-4. PPP Control
    Message Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-4. PPP Control Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Code (Type) | 1 | A single byte value that indicates what type of control
    message is in this control frame. It is sometimes instead called Type in certain
    PPP standards. |'
  prefs: []
  type: TYPE_TB
- en: '| Identifier | 1 | This is a label field that''s used to match up requests
    with replies. When a request is sent, a new Identifier is generated. When a reply
    is created, the value from the Identifier field in the request that prompted the
    reply is used for the reply''s Identifier field. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 2 | Specifies the length of the control frame. This is needed because
    the Data field is variable in length. The Length field is specified in bytes and
    includes all the fields in the control frame including the Code, Identifier, Length,
    and Data fields. |'
  prefs: []
  type: TYPE_TB
- en: '| Data | Variable | Contains information specific to the message type. The
    different uses of this field are described later in this chapter. |'
  prefs: []
  type: TYPE_TB
- en: This entire structure becomes the payload of a PPP frame, meaning that it fits
    into the Information field of a PPP frame, as shown in [Figure 12-3](ch12s02.html#ppp_control_message_format-id001
    "Figure 12-3. PPP control message format"). The four fields of the PPP control
    message format fit within the Information field of the PPP general frame format.
    The Data field is subsequently filled in with data specific to the control message
    type. Thus, the Length field is equal in size to that of the Information field
    in the PPP frame. The Protocol field of a control frame is set to match the protocol
    that generated the control frame. For example, it would be 0xC021 for an LCP frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP control message format](httpatomoreillycomsourcenostarchimages287749.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3. PPP control message format
  prefs: []
  type: TYPE_NORMAL
- en: PPP Control Messages and Code Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Code field indicates the type of control frame within the particular control
    protocol. Some protocols have a unique set of codes used only by that particular
    protocol; examples include the authentication protocols (PAP and CHAP) and the
    Bandwidth Allocation Protocol (BAP). Since the NCPs and many of the feature control
    protocols like CCP and ECP are based on LCP, they use a common set of message
    codes and types. [Table 12-5](ch12s02.html#ppp_control_messages_code_values_and_ppp
    "Table 12-5. PPP Control Messages, Code Values, and PPP Protocol Usage") shows
    these common message codes and indicates which control protocols use them.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-5. PPP Control Messages, Code Values, and PPP Protocol Usage
  prefs: []
  type: TYPE_NORMAL
- en: '| Code Value | Control Message | LCP | NCPs | CCP and ECP |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Configure-Request | ⅳ | ⅳ | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Configure-Ack | ⅳ | ⅳ | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Configure-Nak | ⅳ | ⅳ | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Configure-Reject | ⅳ | ⅳ | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | Terminate-Request | ⅳ | ⅳ | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **6** | Terminate-Ack | ⅳ | ⅳ | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Code-Reject | ⅳ | ⅳ | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Protocol-Reject | ⅳ |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | Echo-Request | ⅳ |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **10** | Echo-Reply | ⅳ |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **11** | Discard-Request | ⅳ |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **12** | Identification | ⅳ |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **13** | Time-Remaining | ⅳ |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| **14** | Reset-Request |   |   | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: '| **15** | Reset-Ack |   |   | ⅳ |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*I describe the specific ways these frame types are used in the individual
    topics on LCP, the NCPs, CCP, and ECP in Chapters [Chapter 10](ch10.html "Chapter 10. PPP
    CORE PROTOCOLS: LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION") and [Chapter 11](ch11.html
    "Chapter 11. PPP FEATURE PROTOCOLS").*'
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the Data field depend entirely on the type of control message.
    In some cases, no extra data needs to be sent at all, in which case the Data field
    may be omitted. In other control messages, it carries information relevant to
    the message type. For example, a *Code-Reject* message carries in the Data field
    a copy of the frame that was rejected.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Control Message Option Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The various *Configure*- messages are used to negotiate configuration options
    in LCP and the other control protocols. In their Data fields, they carry one or
    more options that are, again, specific to the protocol using them. For example,
    LCP uses one set of configuration options for the link as a whole, CCP uses options
    to negotiate a compression algorithm, MP uses it to set up multilink bundles,
    and so on. [Figure 12-4](ch12s02.html#ppp_control_message_carrying_options "Figure 12-4. PPP
    control message carrying options") shows how these options, which can vary in
    length, are placed in the Data field of a PPP control message (which is nested
    inside the general PPP frame format). This diagram shows a sample PPP control
    message carrying options in its Data field. Any number of options can be included
    and mixed with other data, depending on the needs of the message.
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP control message carrying options](httpatomoreillycomsourcenostarchimages287751.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4. PPP control message carrying options
  prefs: []
  type: TYPE_NORMAL
- en: Again, there is commonality here. While every option is different, they all
    use the same basic format. Each option that appears in any of the many PPP control
    message types consists of the triplet of Type, Length, and Data, as shown in [Table 12-6](ch12s02.html#ppp_control_message_option_format-id001
    "Table 12-6. PPP Control Message Option Format") and illustrated in [Figure 12-5](ch12s02.html#ppp_control_message_option_format-id002
    "Figure 12-5. PPP control message option format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-6. PPP Control Message Option Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Type** | 1 | A type value that indicates the option type. The set of Type
    values is unique to each protocol. So, for example, LCP has one set of Type values
    corresponding to its configuration options, each NCP has a different set, CCP
    has its own set, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| **Length** | 1 | Specifies the length of the option in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| **Data** | Variable | Contains the specific data for the configuration option.
    |'
  prefs: []
  type: TYPE_TB
- en: The configuration options are described briefly in the individual protocol topics.
    I am not showing the specific contents of each option because there are just too
    many of them. These are in the RFCs.
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP control message option format](httpatomoreillycomsourcenostarchimages287753.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5. PPP control message option format
  prefs: []
  type: TYPE_NORMAL
- en: Summary of PPP Control Message Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'My intention here has been to show you the general format used for the different
    control protocols because they are so similar and I don''t have the time or space
    to describe each protocol''s frames individually. Here''s a quick summary:'
  prefs: []
  type: TYPE_NORMAL
- en: The PPP general frame format is used for all frames, including all control frames.
    Its Information field contains the payload, which carries the entire control message
    within it for control frames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control frame is structured using the general format I gave at the start
    of this topic. The Code value indicates the type of control frame for each control
    protocol. The Data field is variable in length, and contains data for that control
    frame, which in some cases may include one or more configuration options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For configuration control frames like *Configure-Request* and *Configure-Ack*,
    the Data field contains an encapsulated set of options using the general structure
    in the second table in this topic. Each option has its own Data subfield that
    contains data specific to that option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help make this more clear, the next two sections provide more specific examples
    of frame formats for LCP and the authentication protocols.
  prefs: []
  type: TYPE_NORMAL
- en: PPP Link Control Protocol (LCP) Frame Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You just explored the general format used by the various protocols in PPP that
    exchange control messages. Of the many control protocols in PPP, LCP is the most
    important, because it is responsible for basic PPP link setup and operation. It
    is also the protocol used as a template for many of the other control protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is so central to PPP, and since many of the other protocols use a similar
    messaging system, let's make the general frame format (shown in [Figure 12-5](ch12s02.html#ppp_control_message_option_format-id002
    "Figure 12-5. PPP control message option format")) more concrete by showing the
    specific frame formats used for each of the LCP control frames. There are 13 different
    frame formats, however, and since they have many fields in common I've combined
    them into a single large summary table. [Table 12-7](ch12s03.html#ppp_link_control_protocol_lcp_frame_type
    "Table 12-7. PPP Link Control Protocol (LCP) Frame Types and Fields") shows the
    contents and meaning for each of the fields in the 13 LCP frame types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*LCP frame types 5, 6, 9, 10, 11, 12, and 13 allow an additional amount of
    data to be included in the Data field in a manner not strictly described by the
    protocol. The PPP standard says that there may be zero or more octets that "contain
    uninterpreted data for use by the sender" and "may consist of any binary value"
    (RFC 1661). The inclusion of this uninterpreted data is left as an implementation-dependent
    option.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'All LCP control frames are encapsulated into a PPP frame by placing the frame
    structure into its Information field, as you saw earlier. The Protocol field is
    set to 0xC021 for LCP. (For an explanation of how the frames are used, see the
    operational description of LCP in [Chapter 10](ch10.html "Chapter 10. PPP CORE
    PROTOCOLS: LINK CONTROL, NETWORK CONTROL, AND AUTHENTICATION").)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-7. PPP Link Control Protocol (LCP) Frame Types and Fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Frame Type | Code Field | Identifier Field | Length Field | Data Field |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Configure-Request | 1 | New value generated for each frame | 4 + length of
    all included configuration options | Configuration options to be negotiated by
    the two peers on a link. (The previous section in this chapter describes the general
    format of configuration options.) |'
  prefs: []
  type: TYPE_TB
- en: '| Configure-Ack | 2 | Copied from the Identifier field of the Configure-Request
    frame for which this Configure-Ack is a reply | 4 + length of all included configuration
    options | Configuration options being positively acknowledged (accepted during
    negotiation of the link). |'
  prefs: []
  type: TYPE_TB
- en: '| Configure-Nak | 3 | Copied from the Identifier field of the Configure-Request
    frame for which this Configure-Nak is a reply | 4 + length of all included configuration
    options | Configuration options being negatively acknowledged (renegotiation requested).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Configure-Reject | 4 | Copied from the Identifier field of the Configure-Request
    frame for which this Configure-Reject is a reply | 4 + length of all included
    configuration options | Configuration options being rejected (since the device
    cannot negotiate them). |'
  prefs: []
  type: TYPE_TB
- en: '| Terminate-Request | 5 | New value generated for each frame | 4 (or more if
    extra data is included) | Not required. See note preceding this table. |'
  prefs: []
  type: TYPE_TB
- en: '| Terminate-Ack | 6 | Copied from the Identifier field of the matching Terminate-Request
    | 4 (or more if extra data is included) | Not required. See note preceding this
    table. |'
  prefs: []
  type: TYPE_TB
- en: '| Code-Reject | 7 | New value generated for each frame | 4 + length of rejected
    frame | A copy of the LCP frame that was rejected. This is not the complete PPP
    frame, just the LCP control portion from its Information field. |'
  prefs: []
  type: TYPE_TB
- en: '| Protocol-Reject | 8 | New value generated for each frame | 6 + length of
    rejected frame | The first two bytes contain the Protocol value of the frame rejected.
    The rest contains a copy of the Information field from the frame rejected. |'
  prefs: []
  type: TYPE_TB
- en: '| Echo-Request | 9 | New value generated for each frame | 8 (or more if extra
    data is included) | Contains a four-byte "magic number" used to detect looped-back
    links, if the appropriate configuration option has been negotiated; otherwise,
    set to zero. May also contain additional uninterpreted data; see note preceding
    this table. |'
  prefs: []
  type: TYPE_TB
- en: '| Echo-Reply | 10 | Copied from the Identifier field of the matching Echo-Request
    | 8 (or more if extra data is included) | Contains a four-byte "magic number"
    used to detect looped-back links, if the appropriate configuration option has
    been negotiated; otherwise, set to zero. May also contain additional uninterpreted
    data; see note preceding this table. |'
  prefs: []
  type: TYPE_TB
- en: '| Discard-Request | 11 | New value generated for each frame | 8 (or more if
    extra data is included) | Contains a four-byte "magic number" used to detect looped-back
    links, if the appropriate configuration option has been negotiated; otherwise,
    set to zero. May also contain additional uninterpreted data; see note preceding
    this table. |'
  prefs: []
  type: TYPE_TB
- en: '| Identification | 12 | New value generated for each frame | 8 (or more if
    extra data is included) | Contains a four-byte "magic number" used to detect looped-back
    links, if the appropriate configuration option has been negotiated; otherwise,
    set to zero. May also contain additional uninterpreted data; see note preceding
    this table. |'
  prefs: []
  type: TYPE_TB
- en: '| Time-Remaining | 13 | New value generated for each frame | 12 (or more if
    extra data is included) | Contains a four-byte "magic number" used to detect looped-back
    links, if the appropriate configuration option has been negotiated; otherwise,
    set to zero. Also contains a four-byte value indicating the number of seconds
    remaining in the current session. A value of all ones in this field is interpreted
    as forever, meaning the session will not expire. May also contain additional uninterpreted
    data; see note preceding this table. |'
  prefs: []
  type: TYPE_TB
- en: PAP and CHAP Frame Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For links where security is important, PPP provides two optional authentication
    protocols, PAP and CHAP. These are used during initial link setup by the LCP to
    deny PPP connections to unauthorized devices.
  prefs: []
  type: TYPE_NORMAL
- en: PAP and CHAP are control protocols and thus use the same basic control protocol
    frame format described earlier in this section. However, since they have a very
    different purpose than LCP and many of the other control protocols, they use a
    distinct set of frames with their own unique set of Code values. PAP uses three
    different control frame types, and CHAP uses four. Let's look at how PAP and CHAP
    frames are constructed.
  prefs: []
  type: TYPE_NORMAL
- en: PPP PAP Control Frame Formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PAP's three control frames are constructed as shown in Tables [Table 12-8](ch12s04.html#ppp_password_authentication_protocol_pap
    "Table 12-8. PPP Password Authentication Protocol (PAP) Frame Formats") and [Table 12-9](ch12s04.html#ppp_pap_authenticate-request_frame_subfi
    "Table 12-9. PPP PAP Authenticate-Request Frame Subfields"). The *Authenticate-Request*
    uses one format, as illustrated in [Figure 12-6](ch12s04.html#ppp_pap_authenticate-request_frame_forma
    "Figure 12-6. PPP PAP Authenticate-Request frame format"), while the other two
    frame types use a different format, as shown in [Figure 12-7](ch12s04.html#ppp_pap_authenticate-ack_and_authenticat
    "Figure 12-7. PPP PAP Authenticate-Ack and Authenticate-Nak frame format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-8. PPP Password Authentication Protocol (PAP) Frame Formats
  prefs: []
  type: TYPE_NORMAL
- en: '| Frame Type | Code Field | Identifier Field | Length Field | Data Field |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Authenticate-Request | 1 | New value generated for each frame | 6 + length
    of Peer-ID + length of password | Contains the user name and password for authentication.
    This is carried in four subfields and arranged as shown in [Table 12-9](ch12s04.html#ppp_pap_authenticate-request_frame_subfi
    "Table 12-9. PPP PAP Authenticate-Request Frame Subfields"). |'
  prefs: []
  type: TYPE_TB
- en: '| Authenticate-Ack | 2 | Copied from the Identifier field of the Authenticate-Request
    frame for which this is a reply | 5 + length of included Message | Contains a
    one-byte Msg-Length subfield that specifies the length of the Message subfield
    that follows it. The Message subfield contains an arbitrary string of data whose
    use is implementation- dependent. It may be used to provide an indication of authentication
    success or failure to the user. If not used, the Msg-Length field is still included,
    but its value is set to zero. |'
  prefs: []
  type: TYPE_TB
- en: '| Authenticate-Nak | 3 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '![PPP PAP Authenticate-Request frame format](httpatomoreillycomsourcenostarchimages287755.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-6. PPP PAP Authenticate-Request frame format
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP PAP Authenticate-Ack and Authenticate-Nak frame format](httpatomoreillycomsourcenostarchimages287757.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-7. PPP PAP Authenticate-Ack and Authenticate-Nak frame format
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-9. PPP PAP Authenticate-Request Frame Subfields
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Peer-ID Length | 1 | Length of the Peer-ID field, in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Peer-ID | Variable | Name of the device to be authenticated; equivalent in
    concept to a user name |'
  prefs: []
  type: TYPE_TB
- en: '| Passwd-Length | 1 | Length of the Password field, in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Password | Variable | Password corresponding to the name being authenticated
    |'
  prefs: []
  type: TYPE_TB
- en: PPP CHAP Control Frame Formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The four CHAP frame types are formatted as shown in Tables [Table 12-10](ch12s04.html#ppp_challenge_handshake_authentica-id001
    "Table 12-10. PPP Challenge Handshake Authentication Protocol (CHAP) Formats")
    and [Table 12-11](ch12s04.html#chap_challenge_and_response_frame_subfie "Table 12-11. CHAP
    Challenge and Response Frame Subfields"). The Challenge and Response frames use
    one message format, as illustrated in [Figure 12-8](ch12s04.html#ppp_chap_challenge_and_response_frame_fo
    "Figure 12-8. PPP CHAP Challenge and Response frame format"), while the Success
    and Failure frames use a different one, as shown in [Figure 12-9](ch12s04.html#ppp_chap_success_and_failure_frame_forma
    "Figure 12-9. PPP CHAP Success and Failure frame format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-10. PPP Challenge Handshake Authentication Protocol (CHAP) Formats
  prefs: []
  type: TYPE_NORMAL
- en: '| Frame Type | Code Field | Identifier Field | Length Field | Data Field |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Challenge | 1 | New value generated for each frame | 5 + length of challenge
    text + length of Name | Carries the challenge text or response text and a system
    identifier. This information is carried in three subfields, as shown in [Table 12-11](ch12s04.html#chap_challenge_and_response_frame_subfie
    "Table 12-11. CHAP Challenge and Response Frame Subfields"). |'
  prefs: []
  type: TYPE_TB
- en: '| Response | 2 | Copied from the Identifier field of the Challenge frame for
    which this is a reply | 5 + length of Value + length of Name |   |'
  prefs: []
  type: TYPE_TB
- en: '| Success | 3 | Copied from the Identifier field of the Response frame for
    which this is a reply | 4 (or more if extra data is included) | May contain an
    arbitrary, implementation-dependent Message field to indicate to the user whether
    authentication was successful or failed. |'
  prefs: []
  type: TYPE_TB
- en: '| Failure | 4 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: Table 12-11. CHAP Challenge and Response Frame Subfields
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Value-Size | 1 | Length of the Value subfield that follows, in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Value | Variable | For a Challenge frame, contains the challenge text used
    in the initial challenge; for a Response frame, contains the encrypted challenge
    text being returned to the authenticator |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Variable | One or more bytes of text used to identify the device that
    sent the frame |'
  prefs: []
  type: TYPE_TB
- en: '![PPP CHAP Challenge and Response frame format](httpatomoreillycomsourcenostarchimages287759.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-8. PPP CHAP Challenge and Response frame format
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP CHAP Success and Failure frame format](httpatomoreillycomsourcenostarchimages287761.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-9. PPP CHAP Success and Failure frame format
  prefs: []
  type: TYPE_NORMAL
- en: PPP Multilink Protocol (MP) Frame Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some devices are connected not by a single physical layer link but by two or
    more. These may be either multiple physical connections, such as two connected
    pairs of modems, or multiplexed virtual layer 1 connections like ISDN B channels.
    In either case, PPP MP can be used to aggregate the bandwidth of these physical
    links to create a single, high-speed *bundle*. I describe how this is done in
    [Chapter 11](ch11.html "Chapter 11. PPP FEATURE PROTOCOLS").
  prefs: []
  type: TYPE_NORMAL
- en: After MP is configured and starts working, it operates by employing a strategy
    for dividing up regular PPP frames among the many individual physical links that
    compose the MP bundle. This is usually accomplished by chopping up the PPP frames
    into pieces called *fragments* and spreading them across the physical links. This
    allows the traffic on the physical links to be easily balanced.
  prefs: []
  type: TYPE_NORMAL
- en: PPP MP Frame Fragmentation Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish this fragmentation process, the device must follow this three-step
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Original PPP Frame Creation** The data or other information to be sent is
    first formatted as a whole PPP frame, but in a modified form, as we will see momentarily.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fragmentation** The full-sized PPP frame is chopped into fragments by MP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Encapsulation** Each fragment is encapsulated in the Information field of
    a new PPP MP fragment frame, along with control information that allows the fragments
    to be reassembled by the recipient.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Several of the fields that normally appear in a whole PPP frame aren''t needed
    if that frame is going to then be divided and placed into other PPP MP frames,
    so when fragmentation is to occur, they are omitted when the original PPP frame
    is constructed for efficiency''s sake. These are fields that are not used when
    MP is employed:'
  prefs: []
  type: TYPE_NORMAL
- en: The Flag fields at the start and end are used only for framing for transmission
    and aren't needed in the logical frame being fragmented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FCS field is not needed, because each fragment has its own FCS field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special compression options that are possible for any PPP frame are used
    when creating this original frame—that is, the Address and Control Field Compression
    (APCP) and Protocol Field Compression (PFC). This means that there are no Address
    or Control fields in the frame, and the Protocol field is only one byte in size.
    Note that this inherently restricts fragments to carrying only certain types of
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The PPP Multilink Protocol (MP) normally divides data among
    physical links by creating an original PPP frame with unnecessary headers removed,
    and then dividing it into fragment frames. Each fragment includes special headers
    that allow for the reassembly of the original frame by the recipient device.'
  prefs: []
  type: TYPE_NORMAL
- en: These changes save a full eight bytes on each PPP frame that will be fragmented.
    As a result, the original PPP frame has a very small header, consisting of only
    a one-byte Protocol field. The Protocol value of each fragment is set to 0x003D
    to indicate a MP fragment, while the Protocol field of the original frame becomes
    the first byte of data in the first fragment.
  prefs: []
  type: TYPE_NORMAL
- en: PPP MP Fragment Frame Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Information field of each fragment uses a substructure that contains a four-field
    *MP header* along with one fragment of the original PPP frame, as shown in [Table 12-12](ch12s05.html#ppp_multilink_protocol_fragment_frame_fo
    "Table 12-12. PPP Multilink Protocol Fragment Frame Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-12. PPP Multilink Protocol Fragment Frame Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | 1/8 (1 bit) | Beginning Fragment Flag: When set to 1, flags this fragment
    as the first of the split-up PPP frame. It is set to 0 for other fragments. |'
  prefs: []
  type: TYPE_TB
- en: '| E | 1/8 (1 bit) | Ending Fragment Flag: When set to 1, flags this fragment
    as the last of the split-up PPP frame. It is set to 0 for other fragments. |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 2/8 (2 bits) or 6/8 (6 bits) | Not used; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence Number | 1 1/2 (12 bits) or 3 (24 bits) | When a frame is split
    up, the fragments are given consecutive sequence numbers so the receiving device
    can properly reassemble them. |'
  prefs: []
  type: TYPE_TB
- en: '| Fragment Data | Variable | The actual fragment from the original PPP frame.
    |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see, the MP frame format comes in two versions: the long format
    uses a four-byte header, while the short format requires only four bytes. The
    default MP header format uses a 24-bit Sequence Number and has 6 reserved bits,
    as shown in [Figure 12-10](ch12s05.html#ppp_mp_long_fragment_frame_format_the_lo
    "Figure 12-10. PPP MP long fragment frame format The long PPP MP frame format
    uses a full byte for flags and a 24-bit Sequence Number."). When MP is set up,
    it is possible for devices to negotiate the Multilink Short Sequence Number Header
    Format configuration option. If this is done successfully, shorter 12-bit Sequence
    Numbers are used instead. Four of the reserved bits are also truncated, to save
    two bytes on each frame, as illustrated in [Figure 12-11](ch12s05.html#ppp_mp_short_fragment_frame_format_the_s
    "Figure 12-11. PPP MP short fragment frame format The short version of the PPP
    MP format uses 4 bits for flags and a 12-bit Sequence Number."). (Considering
    that 12 bits still allows for over 4,000 fragments per PPP frame, this is usually
    more than enough!)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP MP long fragment frame format The long PPP MP frame format uses a full
    byte for flags and a 24-bit Sequence Number.](httpatomoreillycomsourcenostarchimages287763.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-10. PPP MP long fragment frame format The long PPP MP frame format
    uses a full byte for flags and a 24-bit Sequence Number.
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP MP short fragment frame format The short version of the PPP MP format
    uses 4 bits for flags and a 12-bit Sequence Number.](httpatomoreillycomsourcenostarchimages287765.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-11. PPP MP short fragment frame format The short version of the PPP
    MP format uses 4 bits for flags and a 12-bit Sequence Number.
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment Data field contains the actual fragment to be sent. Since the original
    PPP header (including the Protocol field) is at the start of the original PPP
    frame, this will appear at the start of the first fragment. The remaining fragments
    will have just portions of the Information field of the original PPP frame. The
    last fragment will end with the last bytes of the original PPP frame.
  prefs: []
  type: TYPE_NORMAL
- en: The receiving device will collect all the fragments for each PPP frame and extract
    the fragment data and MP headers from each. It will use the Sequence Numbers to
    reassemble the fragments and then process the resulting PPP frame.
  prefs: []
  type: TYPE_NORMAL
- en: PPP MP Fragmentation Demonstration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 12-12](ch12s05.html#ppp_mp_fragmentation_this_diagram_shows_ "Figure 12-12. PPP
    MP fragmentation This diagram shows how a single PPP frame is fragmented into
    three smaller ones.") shows a demonstration of fragmenting a PPP data frame. At
    the top is the same PPP data frame shown in [Figure 12-2](ch12.html#sample_ppp_data_frame_an_example_of_a_pp
    "Figure 12-2. Sample PPP data frame An example of a PPP data frame containing
    an abbreviated 23-byte IP datagram.") earlier in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The eight grayed-out bytes are the ones not used when a frame is to be fragmented.
    Thus, the PPP frame used for MP is 24 bytes long. This frame is split into eight-byte
    chunks, each of which is carried in the Fragment Data fields of an MP fragment.
    Note the consecutive Sequence Number values in the fragment frames. Also note
    that the Beginning Fragment field is set only for the first fragment, and the
    Ending Fragment is set only for the last one.
  prefs: []
  type: TYPE_NORMAL
- en: '![PPP MP fragmentation This diagram shows how a single PPP frame is fragmented
    into three smaller ones.](httpatomoreillycomsourcenostarchimages287767.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-12. PPP MP fragmentation This diagram shows how a single PPP frame
    is fragmented into three smaller ones.
  prefs: []
  type: TYPE_NORMAL
