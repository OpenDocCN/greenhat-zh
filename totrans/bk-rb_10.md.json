["```\n3.times do |i|\n    puts( i )\nend\n```", "```\n3.times { |i|\n    puts( i )\n}\n```", "```\n3.times do |i|\n    puts( i )\nend\n\n3.times { |i|\n    puts( i )\n}\n```", "```\n3.times\ndo |i|\n    puts( i )\nend\n\n3.times\n{ |i|\n    puts( i )\n}\n```", "```\n{ |i|\n    puts( i )\n}\n```", "```\ndef aMethod( i )\n   puts( i )\nend\n```", "```\nfor i in 0..2\n   aMethod( i )\nend\n```", "```\n3.times { |i|\n    puts( i )\n}\n```", "```\n3.times{ |i| }\n```", "```\nfor i in 0..2\n    aMethod( i )\nend\n```", "```\n(1..3).each do |i|\n    puts(i)\nend\n```", "```\narr = ['one','two','three','four']\narr.each do |s|\n    puts(s)\nend\n```", "```\ni=0\nloop {\n    puts(arr[i])\n    i+=1\n    if (i == arr.length) then\n        break\n    end\n}\n```", "```\nb3 = [1,2,3].collect{|x| x*2}\n```", "```\n[2,4,6]\n```", "```\nb4 = [\"hello\",\"good day\",\"how do you do\"].collect{|x| x.capitalize }\n```", "```\n[\"Hello\", \"Good day\", \"How do you do\"]\n```", "```\nb5 = [\"hello\",\"good day\",\"how do you do\"].each{|x| x.capitalize }\n```", "```\n[\"hello\", \"good day\", \"how do you do\"]\n```", "```\nb6 = [\"hello\",\"good day\", \"how do you do\"].each{|x| x.capitalize! }\n```", "```\n[\"Hello\", \"Good day\", \"How do you do\"]\n```", "```\n\"hello world\".split(//)\n```", "```\na = \"hello world\".split(//).each{ |x| newstr << x.capitalize }\n```", "```\nH\nHE\nHEL\nHELL\nHELLO\nHELLO\nHELLO W\nHELLO WO\nHELLO WOR\nHELLO WORL\nHELLO WORLD\n```", "```\na = \"hello world\".each_byte{|x| newstr << (x.chr).capitalize }\n```", "```\n{|x| x = x*10; puts(x)}        # This is not allowed!\n```", "```\nputs({1=>2}.class)\n```", "```\nputs({|i| puts(i)}.class) #<= error!\n```", "```\nputs( {1=>2}.class )     #<= Hash\n```", "```\nputs( {}.class )         #<= Hash\n```", "```\nputs{}.class\n```", "```\nprint{}.class\n```", "```\nprint( {}.class )    #<= Hash\n```", "```\na = Proc.new{|x| x = x*10; puts(x) }    #=> Proc\nb = lambda{|x| x = x*10; puts(x) }      #=> Proc\nc = proc{|x| x.capitalize! }            #=> Proc\n```", "```\na = Proc.new{|x| x = x*10; puts(x)}\n```", "```\na.call(100)        #=> 1000\n```", "```\nb = lambda{|x| x = x*10; puts(x) }\nb.call(100)            #=> 1000\n\nc = proc{|x| x.capitalize! }\nc1 = c.call( \"hello\" )\nputs( c1 )             #=> Hello\n```", "```\nd = lambda{|x| x.capitalize! }\nd1 = [\"hello\",\"good day\",\"how do you do\"].each{ |s| d.call(s)}\nputs(d1.inspect)        #=> [\"Hello\", \"Good day\", \"How do you do\"]\n```", "```\na = Proc.new{|x,y,z| x = y*z; puts(x) }\na.call(2,5,10,100)        # This is not an error\n\nb = lambda{|x,y,z| x = y*z; puts(x) }\nb.call(2,5,10,100)        # This is an error\n\nputs('---Block #2---' )\nc = proc{|x,y,z| x = y*z; puts(x) }\nc.call(2,5,10,100)        # This is an error in Ruby 1.8\n                          # Not an error in Ruby 1.9\n```", "```\nx = \"hello world\"\n\nablock = Proc.new { puts( x ) }\n\ndef aMethod( aBlockArg )\n    x = \"goodbye\"\n    aBlockArg.call\nend\n\nputs( x )\nablock.call\naMethod( ablock )\nablock.call\nputs( x )\n```", "```\ndef aMethod\n    yield\nend\n```", "```\naMethod{ puts( \"Good morning\" ) }\n```", "```\naMethod(  { puts( \"Good morning\" ) }  )     # This won't work!\n```", "```\ndef caps( anarg )\n    yield( anarg )\nend\n\ncaps( \"a lowercase string\" ){ |x| x.capitalize! ; puts( x ) }\n```", "```\n[\"hello\",\"good day\",\"how do you do\"].each{\n    |s|\n    caps( s ){ |x| x.capitalize!\n        puts( x )\n    }\n}\n```", "```\nHello\nGood day\nHow do you do\n```", "```\ndef abc( a, b, c )\n    a.call\n    b.call\n    c.call\n    yield\nend\n```", "```\na = lambda{ puts \"one\" }\nb = lambda{ puts \"two\" }\nc = proc{ puts \"three\" }\nabc(a, b, c ){ puts \"four\" }\n```", "```\na.call    #=> one\nb.call    #=> two\nc.call    #=> three\nyield     #=> four\n```", "```\ndef abc2( &d )\n    d.call\nend\n```", "```\nabc2{ puts \"four\" }\n```", "```\nabc2( 10 )    # This won't work!\n```", "```\ndef abc3( a, b, c, &d)\n```", "```\ndef abc3( a, b, c, &d)\n    a.call\n    b.call\n    c.call\n    d.call        # first call block &d\n    yield         # then yield block &d\nend\n```", "```\nabc3(a, b, c){ puts \"five\" }\n```", "```\none\ntwo\nthree\nfive\nfive\n```", "```\nmyproc = proc{ puts(\"my proc\") }\nabc3(a, b, c, &myproc )\n```", "```\nxyz{ |a,b,c| puts(a+b+c) }\nxyz( &myproc )\n```", "```\na = lambda{ puts \"one\" }\nb = lambda{ puts \"two\" }\nc = proc{ puts \"three\" }\nxyz{ |a,b,c| puts(a+b+c) }\n```", "```\n{ |a,b,c| puts(a+b+c) }\n```", "```\ndef xyz\n    x = 1\n    y = 2\n    z = 3\n    yield( x, y, z )   # 1,2,3 assigned to block parameters a,b,c\nend\n```", "```\nxyz{ |a,b,c| puts(a+b+c) }\nputs( a, b, c )\n```", "```\n1\n2\n3\n```", "```\n#<Proc:0x2b65828@C:/bookofruby/ch10/5blocks.rb:36 (lambda)>\n#<Proc:0x2b65810@C:/bookofruby/ch10/5blocks.rb:37 (lambda)>\n#<Proc:0x2b657f8@C:/bookofruby/ch10/5blocks.rb:38>\n```", "```\na = \"hello world\"\n\ndef foo\n    yield 100\nend\n\nputs( a )\nfoo{ |a| puts( a ) }\n\nputs( a )\n```", "```\nhello world\n100\n100\n```", "```\nhello world\n100\nhello world\n```", "```\nfoo{ |b| puts( b ) }    # the name 'b' is not used elsewhere\n```", "```\nhello world\n100\nhello world\n```", "```\nfoo bar do |s| puts( s ) end\nfoo bar{ |s| puts(s) }\n```", "```\ndef foo( b )\n    puts(\"---in foo---\")\n    a = 'foo'\n    if block_given?\n        puts( \"(Block passed to foo)\" )\n        yield( a )\n    else\n        puts( \"(no block passed to foo)\" )\n    end\n    puts( \"in foo, arg b = #{b}\" )\n    return \"returned by \" << a\nend\n\ndef bar\n    puts(\"---in bar---\")\n    a = 'bar'\n    if block_given?\n        puts( \"(Block passed to bar)\" )\n        yield( a )\n    else\n        puts( \"(no block passed to bar)\" )\n    end\n    return \"returned by \" << a\nend\n\nfoo bar do |s| puts( s ) end       # 1) do..end block\nfoo bar{ |s| puts(s) }             # 2) {..} block\n```", "```\nfoo bar do |s| puts( s ) end\nfoo( bar ) do |s| puts( s ) end\n```", "```\nfoo bar{ |s| puts(s) }\nfoo( bar{ |s| puts(s) } )\n```", "```\n3.times{ |i| puts( i ) }\n[1,2,3].each{|i| puts(i) }\n```", "```\ndef timesRepeat( aNum )\n    for i in 1..aNum do\n        yield i\n    end\nend\n```", "```\ntimesRepeat( 3 ){  |i| puts(\"[#{i}] hello world\") }\n```", "```\n[1] hello world\n[2] hello world\n[3] hello world\n```", "```\ndef timesRepeat2( aNum, anArray )\n    anArray.each{ |anitem|\n        yield( anitem )\n    }\nend\n```", "```\ntimesRepeat2( 3, [\"hello\",\"good day\",\"how do you do\"] ){ |x| puts(x) }\n```", "```\nhello\ngood day\nhow do you do\n```", "```\nclass MyArray < Array\n```", "```\ndef initialize( anArray )\n    super( anArray )\nend\n```", "```\nclass MyArray < Array\n    def initialize( anArray )\n        super( anArray )\n    end\n\n    def timesRepeat( aNum )\n        aNum.times{           # start block 1...\n             | num |\n             self.each{       # start block 2...\n                  | anitem |\n                  yield( \"[#{num}] :: '#{anitem}'\" )\n             }                # ...end block 2\n        }                     # ...end block 1\n    end\nend\n```", "```\nnumarr = MyArray.new( [1,2,3] )\nnumarr.timesRepeat( 2  ){ |x| puts(x) }\n```", "```\n[0] :: '1'\n[0] :: '2'\n[0] :: '3'\n[1] :: '1'\n[1] :: '2'\n[1] :: '3'\n```", "```\nmultiarr =\n[ ['one','two','three','four'],\n  [1,    2,    3,      4     ],\n  [:a,   :b,   :c,    :d     ]\n]\n```", "```\nmultiarr[0].length.times{|i|\n    puts(multiarr[0][i], multiarr[1][i])\n}\n```", "```\nmultiarr.each{ |arr|\n    multiarr[0].length.times{|i|\n        puts(arr[i])\n    }\n}\n```", "```\nmultiarr[0].length.times{|i|\n    multiarr.each{ |arr|\n        puts(arr[i])\n    }\n}\n```", "```\nx = \"hello world\"\nablock = Proc.new { puts( x ) }\n```", "```\ndef aMethod( aBlockArg )\n    x = \"goodbye\"\n    aBlockArg.call            #=> \"hello world\"\nend\n```", "```\ndef calcTax( taxRate )\n    return lambda{\n        |subtotal|\n            subtotal * taxRate\n    }\nend\n\nsalesTax = calcTax( 0.10 )\nvat = calcTax( 0.175 )\n\nprint( \"Tax due on book = \")\nprint( salesTax.call( 10 ) )       #=> 1.0\n\nprint( \"\\nVat due on DVD = \")\nprint( vat.call( 10 ) )            #=> 1.75\n```", "```\naClos = lambda{\n    @hello << \" yikes!\"\n}\n```", "```\ndef aFunc( aClosure )\n    @hello = \"hello world\"\n    aClosure.call\nend\n```", "```\naFunc(aClos)      #<= @hello = \"hello world yikes!\"\naClos.call        #<= @hello = \"hello world yikes! yikes!\"\naClos.call        #<= @hello = \"hello world yikes! yikes! yikes!\"\naClos.call        # ...and so on\n```", "```\naClos = lambda{\n    @hello << \" yikes!\"\n    puts(\"in #{self} object of class #{self.class}, @hello = #{@hello}\")\n}\n```", "```\nclass X\n    def y( b )\n        @hello = \"I say, I say, I say!!!\"\n        puts( \"   [In X.y]\" )\n        puts(\"in #{self} object of class #{self.class}, @hello = #{@hello}\")\n        puts( \"   [In X.y] when block is called...\" )\n        b.call\n    end\nend\n\nx = X.new\n```", "```\nx.y( aClos )\n```", "```\n[In X.y]\nin #<X:0x32a6e64> object of class X, @hello = I say, I say, I say!!!\n    [In X.y] when block is called...\nin main object of class Object, @hello = hello world yikes! yikes! yikes!\n yikes! yikes! yikes!\n```", "```\nx = 3000\n```", "```\nc1 = proc{\n    x + 100\n}\n```", "```\nreturn x + 1\n```", "```\nsomeval=1000\nsomeval=c1.call(someval); puts(someval)    #<= someval is now 3100\nsomeval=c1.call(someval); puts(someval)    #<= someval is now 3100\n```", "```\n2.times{ someval=c1.call(someval); puts(someval) }\n```", "```\nc2 = proc{\n    |z|\n    z + 100\n}\n```", "```\nsomeval=1000\nsomeval=c2.call(someval); puts(someval)      #<= someval is now 1100\nsomeval=c2.call(someval); puts(someval)      #<= someval is now 1200\n```", "```\nc3 = proc{\n    |x|\n    x + 100\n}\n```", "```\nx = 3000\nsomeval=1000\nsomeval=c3.call(someval); puts(someval)    #=> 1100\nsomeval=c3.call(someval); puts(someval)    #=> 1200\nputs( x ) # Ruby 1.8, x = 1100\\. Ruby 1.9, x = 3000\n```", "```\nprint(\"x=[#{defined?(x)}],z=[#{defined?(z)}]\")\n```", "```\nx=[local-variable], z=[]\n```", "```\ndef foo\n    a = 100\n    [1,2,3].each do |b|\n        c = b\n        a = b\n        print(\"a=#{a}, b=#{b}, c=#{c}\\n\")\n    end\n    print(\"Outside block: a=#{a}\\n\")    # Can't print #{b} and #{c} here!!!\nend\n```", "```\ndef foo2\n    a = 100\n    for b in [1,2,3] do\n        c = b\n        a = b\n        print(\"a=#{a}, b=#{b}, c=#{c}\\n\")\n    end\n    print(\"Outside block: a=#{a}, b=#{b}, c=#{b}\\n\")\nend\n```"]