- en: Part III. A Glimpse of Things to Come
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following nearly a decade of stagnation, the world of browsers is once more
    a raging battlefield. In a manner all too reminiscent of the First Browser Wars
    in the late 1990s, vendors compete by bringing new features to market monthly.
    The main difference is that security is now seen as a clear selling point.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, objectively measuring the robustness of any sufficiently complex
    piece of software is an unsolved problem in computing, doubly so if your codebase
    happens to carry almost two decades worth of bloat. Therefore, much of the competitive
    effort goes into inventing and then rapidly deploying new security-themed additions,
    often with little consideration for how well they actually solve the problem they
    were supposed to address.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, standards bodies, mindful of their earlier misadventures, have
    ditched much of their academic rigor in favor of just letting a dedicated group
    of contributors tweak the specifications as they see fit. There is talk of making
    HTML5 the last numbered version of the standard and transitioning to a living
    document that changes every day—often radically. The relaxation of the requirement
    has helped keep ongoing much of the work around W3C and WHATWG, but it has also
    undermined some of the benefits of having a central organization to begin with.
    Many recent proposals gravitate toward quick, narrowly scoped hacks that do not
    even try to form a consistent and well-integrated framework. When this happens,
    no robust feedback mechanism is in place to allow external experts to review reasonably
    stable specifications and voice concerns before any implementation work takes
    place. The only way to stay on top of the changes is to immerse oneself in the
    day-to-day dynamics of the working group.
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to say if this new approach to standardization is a bad thing.
    In fact, its benefits may easily outweigh any of the speculative risks; for one,
    we now have a chance at a standard that is reasonably close to what browsers actually
    do. Nevertheless, the results of this frantic and largely unsupervised process
    can be unpredictable, and they require the security community to be very alert.
  prefs: []
  type: TYPE_NORMAL
- en: In this spirit, the last part of the book will explore some of the more plausible
    and advanced proposals that may shape the future of the Web . . . or that may
    just as likely end up in the dustbin of history a few years from now.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16. New and Upcoming Security Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will soon find out that there is little rhyme and reason to how all the
    new browser features mesh, but we still need to organize the discussion in some
    way. Perhaps the best approach is to look at their intended purposes and begin
    with all the mechanisms created specifically to tweak the Web’s security model
    for a well-defined gain.
  prefs: []
  type: TYPE_NORMAL
- en: The dream of inventing a brand-new browser security model is strong within the
    community, but it is always followed by the realization that it would require
    rebuilding the entire Web. Therefore, much of the practical work focuses on more
    humble extensions to the existing approach, necessarily increasing the complexity
    of the security-critical sections of the browser codebase. This complexity is
    unwelcome, but its proponents invariably see it as justified, whether because
    they aim to mitigate a class of vulnerabilities, build a stopgap for some other
    hard problem that nobody wants to tackle right now,^([[77](#ftn.CHP-16-FN-1)])
    or simply enable new types of applications to be built in the future. All these
    benefits usually trump the vague risk.
  prefs: []
  type: TYPE_NORMAL
- en: Security Model Extension Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the most successful security enhancements proposed in the past few years
    boil down to adding flexibility to the original constraints imposed by the same-origin
    policy and its friends. For example, one formerly experimental proposal that has
    now crossed into the mainstream is the *postMessage(...)* API for communicating
    across origins, discussed in [Chapter 9](ch09.html "Chapter 9. Content Isolation
    Logic"). Surprisingly, the act of relaxing SOP checks in certain carefully chosen
    scenarios is more intuitive and less likely to cause problems than locking the
    policy down. So, to begin on a lighter note, we’ll focus on this class of frameworks
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Domain Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the original constraints of the same-origin policy, scripts associated
    with one origin have no clean and secure way to communicate with client-side scripts
    executing in any other origin and no safe way to retrieve potentially useful data
    from a willing third-party server.
  prefs: []
  type: TYPE_NORMAL
- en: Web developers have long complained about these constraints, and in recent years,
    browser vendors have begun to listen to their demands. As you recall, the more
    pressing task of arranging client-side communications between scripts was solved
    with *postMessage(...)*. The client-to-server scenario was found to be less urgent
    and still awaits a canonical solution, but there has been some progress to report.
  prefs: []
  type: TYPE_NORMAL
- en: The most successful attempt to create a method for retrieving documents from
    non-same-origin servers began in 2005\. Under the auspices of W3C, several developers
    working on VoiceXML, an obscure document format for building Interactive Voice
    Response (IVR) systems, drafted a proposal for *Cross-Origin Resource Sharing
    (CORS)*.^([[240](pr03.html#ftn.CHP-16-FT-1)]) Between 2007 and 2009, their awkward,
    XML-based design gradually morphed into a much simpler and more widely useful
    scheme, which relied on HTTP header-level signaling to communicate consent to
    cross-origin content retrieval using a natural extension of the *XMLHttpRequest*
    API.
  prefs: []
  type: TYPE_NORMAL
- en: CORS Request Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As specified today, CORS relies on differentiating between two types of calls
    to the *XMLHttpRequest* API. When the site attempts to load a cross-origin document
    through the API, the browser first needs to distinguish between *simple requests*,
    where the resulting HTTP traffic is deemed close enough to what can be generated
    through other, existing methods of navigation, and *non-simple requests*, which
    encompass everything else. The operation of these two classes of requests vary
    significantly, as we’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current specification says that simple requests must have a method of GET,
    POST, or HEAD. Additionally, if any custom headers are specified by the caller,
    they must belong to the following set:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cache-Control*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Content-Language*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Content-Type*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Expires*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Last-Modified*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pragma*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, browsers that support CORS simply do not allow methods other than GET,
    POST, and HEAD. At the same time, they ignore the recommended whitelist of headers,
    unconditionally demoting any requests with custom header values to non-simple
    status. The implementation in WebKit also considers any payload-bearing requests
    to be non-simple. (It is not clear whether this is an intentional design decision
    or a bug.)
  prefs: []
  type: TYPE_NORMAL
- en: Security Checks for Simple Requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CORS specification allows simple requests to be submitted to the destination
    server immediately, without attempting to confirm whether the destination is willing
    to engage in cross-domain communications to begin with. This decision is based
    on the fact that the attacker may initiate fairly similar cookie-authenticated
    traffic by other means (for example, by automatically submitting a form) and,
    therefore, that there is no point in introducing an additional handshake specifically
    for CORS.^([[78](#ftn.CHP-16-FN-2)])
  prefs: []
  type: TYPE_NORMAL
- en: 'The crucial security check is carried out only after the response is retrieved
    from the server: The data is revealed to the caller through the *XMLHttpRequest*
    API only if the response includes a suitable, well-formed *Access-Control-Allow-Origin*
    header. To assist the server, the original request will include a mandatory *Origin*
    header, specifying the origin associated with the calling script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this behavior, consider the following cross-domain *XMLHttpRequest*
    call performed from [http://www.bunnyoutlet.com/](http://www.bunnyoutlet.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be an HTTP request that looks roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To indicate that the response should be readable across domains, the server
    needs to respond with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to use a wildcard (“*”) in *Access-Control-Allow-Origin*, but
    do so with care. It is certainly unwise to indiscriminately set *Access-Control-Allow-Origin:
    ** on all HTTP responses, because this step largely eliminates any assurances
    of the same-origin policy in CORS-compliant browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Non-simple Requests and Preflight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the early drafts of the CORS protocol, almost all requests were meant to
    be submitted without first checking to see if the server was actually willing
    to accept them. Unfortunately, this design undermined an interesting property
    leveraged by some web applications to prevent cross-site request forgery: Prior
    to CORS, attackers could not inject arbitrary HTTP headers into cross-domain requests,
    so the presence of a custom header often served as a proof that the request came
    from the same origin as the destination and was issued through *XMLHttpRequest*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Later CORS revisions corrected this problem by requiring a more complicated
    two-step handshake for requests that did not meet the strict “simple request”
    criteria outlined in [CORS Request Types](ch16.html#cors_request_types "CORS Request
    Types") in [Security Model Extension Frameworks](ch16.html#security_model_extension_frameworks
    "Security Model Extension Frameworks"). The handshake for non-simple requests
    aims to confirm that the destination server is CORS compliant and that it wants
    to receive nonstandard traffic from that particular caller. The handshake is implemented
    by sending a vanilla OPTIONS request (“preflight”) to the target URL containing
    an outline of the parameters of the underlying *XMLHttpRequest* call. The most
    important information is conveyed to the server in three self-explanatory headers:
    *Origin*, *Access-Control-Request-Method*, and *Access-Control-Request-Headers*.'
  prefs: []
  type: TYPE_NORMAL
- en: This handshake is considered successful only if these parameters are properly
    acknowledged in the response through the use of *Access-Control-Allow-Origin*,
    *Access-Control-Allow-Method*, and *Access-Control-Allow-Headers*. Following a
    correct handshake, the actual request is made. For performance reasons, the result
    of the preflight check for a particular URL may be cached by the client for a
    set period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Current Status of CORS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of this writing, CORS is available only in Firefox and WebKit-based browsers
    and is notably absent in Opera or Internet Explorer. The most important factor
    hindering its adoption may be simply that the API is not as critical as *postMessage(...)*,
    its client-side counterpart, because it can be often replaced by a content-fetching
    proxy on the server side. But the scheme is also facing three principal, if weak,
    criticisms, some of which come directly from one of the vendors. Obviously, these
    criticisms don’t help matters.
  prefs: []
  type: TYPE_NORMAL
- en: The first complaint, voiced chiefly by Microsoft developers and echoed by some
    academics, is that the scheme needlessly abuses ambient authority. They argue
    that there are very few cases where data shared across domains would need to be
    tailored based on the credentials available for the destination site. The critics
    believe that the risks of accidentally leaking sensitive information far outweigh
    any benefits and that a scheme permitting only nonauthenticated requests to be
    made would be preferable. In their view, any sites that need a form of authentication
    should instead rely on explicitly exchanged authentication tokens.^([[79](#ftn.CHP-16-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: 'The other, more pragmatic criticism of CORS is that the scheme is needlessly
    complicated: It extends an already problematic and error-prone API without clearly
    explaining the benefits of some of the tweaks. In particular, it is not clear
    if the added complexity of preflight requests is worth the peripheral benefit
    of being able to issue cross-domain requests with unorthodox methods or random
    headers.'
  prefs: []
  type: TYPE_NORMAL
- en: The last of the weak complaints hinges on the fact that CORS is susceptible
    to header injection. Unlike some other recently proposed browser features, such
    as WebSockets ([Chapter 17](ch17.html "Chapter 17. Other Browser Mechanisms of
    Note")), CORS does not require the server to echo back an unpredictable challenge
    string to complete the handshake. Particularly in conjunction with preflight caching,
    this may worsen the impact of certain header-splitting vulnerabilities in the
    server-side code.
  prefs: []
  type: TYPE_NORMAL
- en: XDomainRequest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft’s objection to CORS appears to stem from the aforementioned concerns
    over the use of ambient authority, but it also bears subtle overtones of their
    dissatisfaction with interactions with W3C. In 2008, Sunava Dutta, a program manager
    at Microsoft, offered this somewhat cryptic insight:^([[241](pr03.html#ftn.CHP-16-FT-2)])
  prefs: []
  type: TYPE_NORMAL
- en: During the [Internet Explorer 8] Beta 1 timeframe there were many security based
    concerns raised for cross domain access of third party data using cross site XMLHttpRequest
    and the Access Control framework. Since Beta 1, we had the chance to work with
    other browsers and attendees at a W3C face-to-face meeting to improve the server-side
    experience and security of the W3C’s Access Control framework.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead of embracing the CORS extensions to *XMLHttpRequest*, Microsoft decided
    to implement a counterproposal, dubbed *XDomainRequest*.^([[242](pr03.html#ftn.CHP-16-FT-3)])
    This remarkably simple, new API differs from the variant available in other browsers
    in that the resulting requests are always anonymous (that is, devoid of any browser-managed
    credentials) and that it does not allow for any custom HTTP headers or methods
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of Microsoft’s API is otherwise very similar to *XMLHttpRequest*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Borrowing from W3C’s proposal, the resulting request will bear an *Origin* header,
    and the response data will be revealed to the caller only if a matching *Access-Control-Allow-Origin*
    header is present in the response.^([[80](#ftn.CHP-16-FN-4)]) Preflight requests
    and permission caching are not a part of the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all intents and purposes, Microsoft’s solution is far more reasonable than
    CORS: It is simpler, safer, and probably just as functional in all the plausible
    uses. That said, it is also unpopular. It is supported only in Internet Explorer
    8 and up, and owing to W3C backing CORS, others have no reason to embrace *XDomainRequest*
    anytime soon.'
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, a separate group of researchers have proposed a third solution,
    again acting under the auspices of W3C. Their design, known as Uniform Messaging
    Policy (complete with a corresponding *UniformRequest* API),^([[243](pr03.html#ftn.CHP-16-FT-4)])
    embraces an approach nearly identical to Microsoft’s. It is not supported in any
    existing browser, but there is some talk of unifying it with CORS.
  prefs: []
  type: TYPE_NORMAL
- en: Other Uses of the Origin Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Origin* header is an essential part of CORS, *XDomainRequest*, and UMP,
    but it actually evolved somewhat independently with other uses in mind. In their
    2008 paper, Adam Barth, Collin Jackson, and John C. Mitchell^([[244](pr03.html#ftn.CHP-16-FT-5)])
    advocated the introduction of a new HTTP header that would offer a more reliable
    and privacy-conscious alternative to *Referer*. It would also serve as a way to
    prevent cross-site request vulnerabilities by providing the server with the information
    needed to identify the SOP-level origin of a request, without disclosing the potentially
    more sensitive path or query data.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it was unclear whether the subtle improvement between *Referer* and
    its proposed successor would actually make a difference for the small but nonnegligible
    population of users who block that first header on privacy grounds. The proposal
    consequently ended up in a virtual limbo, not being deployed in any existing browsers
    but also discouraging others from pursuing other solutions such as XSRF or XSSI.^([[245](pr03.html#ftn.CHP-16-FT-6)])
    (To be fair, the concept was very recently revived under the new name of *From-Origin*
    and may not be completely dead yet.)^([[246](pr03.html#ftn.CHP-16-FT-7)])
  prefs: []
  type: TYPE_NORMAL
- en: 'The fate of the original idea aside, the utility of the *Origin* header in
    specialized cases such as CORS was pretty clear. Around 2009, this led to Barth
    submitting an IETF draft specifying the syntax of the header,^([[247](pr03.html#ftn.CHP-16-FT-8)])
    while shying away from making any statements about when the header should be sent,
    or what specific security problems it might solve:'
  prefs: []
  type: TYPE_NORMAL
- en: The user agent MAY include an Origin header in any HTTP request.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[...]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whenever a user agent issues an HTTP request from a “privacy-sensitive” context,
    the user agent MUST send the value “null” in the Origin header.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'NOTE: This document does not define the notion of a privacy-sensitive context.
    Applications that generate HTTP requests can designate contexts as privacy-sensitive
    to impose restrictions on how user agents generate Origin headers.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The bottom line of this specification is that whatever the decision process
    is, once the client chooses to provide the header, the value is required to accurately
    represent the SOP origin from which the request is being made. For example, when
    a particular operation takes place from [http://www.bunnyoutlet.com:1234/bunny_reports.php](http://www.bunnyoutlet.com:1234/bunny_reports.php),
    the transmitted value should be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For origins that do not meaningfully map to a protocol-host-port tuple, the
    browser must send the value of *null* instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite all of these plans, as of this writing only one browser includes the
    *Origin* header on non-CORS navigation: WebKit-based implementations send it when
    submitting HTML forms. Firefox seems to be considering a different approach, but
    nothing specific seems to have been implemented yet.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[77](#CHP-16-FN-1)]) Malicious URL blacklists, a feature supported by (and
    usually enabled in) all modern browsers, are a prime example of this trend. The
    blacklist is a lightweight, crude substitute for an antivirus, which is, in turn,
    a poor substitute for up-to-date and well-designed software. Antimalware features
    do not make individual attacks any more difficult; they are simply meant to stop
    the large-scale distribution of unsophisticated malware, based on the assumption
    that most users are not interesting enough to be specifically targeted or attacked
    with something clever.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[78](#CHP-16-FN-2)]) That assumption is not completely correct. For example,
    prior to the introduction of this scheme, attackers would not have been able to
    initiate a cross-domain request completely indistinguishable from the submission
    of a file upload form, but under CORS, such forgery is possible.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[79](#CHP-16-FN-3)]) The same claim can be made about the use of HTTP cookies
    in any other setting and seems equally futile. It is true that ambient credentials
    cause problems more frequently than some other forms of explicit authentication
    would, but they are also a lot more convenient to use and are simply not going
    away.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[80](#CHP-16-FN-4)]) The reason for this check, even if the response is not
    authenticated, is to prevent the use of the browser as a proxy (for example, to
    crawl internal networks or send out spam).
  prefs: []
  type: TYPE_NORMAL
- en: Security Model Restriction Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designs that extend the bounds of the same-origin policy are fairly simple to
    understand and typically fail securely. If the proposed change is not accounted
    for in one of the possible code paths, or is simply not supported in a particular
    browser, the previously implemented, more restrictive logic will kick in. Compared
    with this, it is far more dangerous to try to erect new boundaries on top of the
    existing browser security model. That’s because every security-sensitive code
    path must be tweaked to recognize the new scheme and every browser must comply
    right away, or unexpected problems will arise.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a quick look at some of the more accomplished
    attempts to take this dangerous but potentially rewarding path—and explore where
    they come apart.
  prefs: []
  type: TYPE_NORMAL
- en: Content Security Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Content Security Policy* (*CSP*) is an unusually comprehensive security framework
    first proposed by Brandon Sterne of Mozilla in 2008.^([[248](pr03.html#ftn.CHP-16-FT-9)])
    The framework was originally envisioned as an all-encompassing way to mitigate
    the impact of common web vulnerabilities, from XSRF to XSS, and as a tool for
    website owners to perform a variety of non-security content-policing tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: In the years that followed, CSP evolved rapidly, and on several occasions, its
    scope changed in major ways. (For example, the author quickly abandoned the plan
    to address XSRF vulnerabilities, delegating the job to the yet unrealized extensions
    of the *Origin* header.) In fact, as of this writing, the canonical Mozilla specification
    is being rewritten as a W3C draft,^([[249](pr03.html#ftn.CHP-16-FT-10)]) resulting
    in substantial differences in the implementation shipped in Firefox and the partial
    support implemented in WebKit by Adam Barth. (Internet Explorer and Opera do not
    support CSP and have not announced any specific plans to embrace it.)
  prefs: []
  type: TYPE_NORMAL
- en: Primary CSP Directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At its core, Sterne’s design permits site owners to specify per-document policies
    that constrain the ability of the subject document to perform actions that would
    normally be permitted under the same-origin policy. For example, CSP may prevent
    a page from loading any external subresources except for images and restrict image
    sources to only a set of trusted origins, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As should be evident from this example, the policies may be encoded in an HTTP
    header. Under the W3C draft, it is also possible to embed them in the document
    itself (using *<meta>* tags) or host the policy at an external URL and point to
    it with *policy-uri*.
  prefs: []
  type: TYPE_NORMAL
- en: For every content source directive, the author of the policy may specify any
    number of fully qualified origins or wildcard expressions that match multiple
    hosts, protocols, or ports. Three special keywords (*none*, *self*, and *data:*)
    correspond to an empty set, the origin associated with the policy-bearing page,
    or all inline *data:* URLs, in corresponding order.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of today, the following behaviors can be controlled with CSP directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Script execution** A *script-src* directive can be used to specify the protocol,
    host, and port for permissible *<script src=...>* URLs. Normally, the CSP disables
    the ability to embed scripts inline in the document (whether through standalone
    *<script>* blocks or via event handlers) and of existing scripts to carelessly
    pass strings to functions such as *eval(...)*, *setTimeout(...)*, *setInterval(...)*,
    and so on. Because of this, the *script-src* directive is useful for limiting
    the impact of XSS vulnerabilities: Any markup injected by the attacker will be
    limited to loading scripts legitimately hosted in one of the approved origins.^([[81](#ftn.CHP-16-FN-5)])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plug-in content** This is controlled through *object-src*. Because plug-ins
    such as Java or Flash may have unconstrained access to the embedding page, the
    directive should be considered largely analogous to *script-src*, and the two
    directives must be restricted in a comparable way to achieve any security benefits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stylesheets and fonts** This is controlled by *style-src* and *font-src*.
    Unlike its handling of scripts, CSP originally did not prevent inline *<style>*
    blocks or *style=* parameters from appearing on the page. Therefore, any attacker
    exploiting an XSS flaw could dramatically alter the appearance and function of
    the vulnerable page (or worse),^([[82](#ftn.CHP-16-FN-6)]) and these two directives
    only served nonsecurity goals, with the possible exception of limiting mixed-content
    bugs. Only moments before the publication of the book, the specifications have
    been amended to include a more robust approach to CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passive multimedia** Directives such as *img-src* or *media-src* control
    the ability to embed multimedia content from specific origins. As with the original
    design of CSS controls, this could not have been considered a security feature.
    For example, in the case of an XSS bug, CSP would not have prevented the attacker
    from leveraging stylesheets to draw arbitrary shapes on the vulnerable page or
    even animating them to some extent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subframes** The *frame-src* directive specifies the acceptable destinations
    for any *<iframe>* tags encountered on the page; the policy of the parent page
    is not inherited by the framed document. To preserve the value of other XSS mitigations,
    steps must be taken not to allow *data:* URLs here (see [Chapter 10](ch10.html
    "Chapter 10. Origin Inheritance")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default policy** Known as *default-src* in the W3C draft, and under a more
    cryptic name (*allow*) in Mozilla documentation, the directive specifies fallback
    behavior for any content not covered by a more specific directive. The directive
    is required, even in cases where it is technically unnecessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may be unfortunate that CSP directives are selected to map very closely
    to individual HTML tags, instead of grouping functionally similar behaviors. Because
    of this, it is difficult to appreciate the tricky interactions among settings
    such as *script-src*, *frame-src*, and *object-src*. Also, the approach is simply
    not very future-safe: There already are some peripheral classes of subresources
    (such as “favicons”) that are excluded from CSP altogether, and that list will
    probably unintentionally grow.'
  prefs: []
  type: TYPE_NORMAL
- en: In an unusual departure from the subresource-driven model outlined thus far,
    CSP also features an oddball directive called *frame-ancestors*. This parameter
    is meant to mitigate the impact of clickjacking by specifying the allowed ancestors
    for the current document in a manner similar to the better-established *X-Frame-Options*
    header (outlined in [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin
    Rules")). The *frame-ancestors* logic is completely independent of *default-src*
    or any other parts of CSP; its default value is “*”.
  prefs: []
  type: TYPE_NORMAL
- en: Many other possible extensions of the policy are being discussed as of this
    writing. These include a *script-nonce* directive that could be used to more securely
    embed inline scripts (every script block must begin with a policy-specified, unpredictable
    token, often making XSS exploitation harder) and a *sandbox* directive, which
    offers an alternative interface to another security mechanism, discussed in [Sandboxed
    Frames](ch16s02.html#sandboxed_frames "Sandboxed Frames") in [Sandboxed Frames](ch16s02.html#sandboxed_frames
    "Sandboxed Frames").
  prefs: []
  type: TYPE_NORMAL
- en: Policy Violations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The policy specified according to these rules constrains the behavior of the
    underlying document. Violations normally result in a failed subresource load,
    the failure to execute an inline script, or the inhibition of page rendering (in
    the special case of *frame-ancestors*).
  prefs: []
  type: TYPE_NORMAL
- en: Because CSP controls a wide range of content behaviors, and because the default
    failure mode is fairly brutal, the authors perceived a need to ease the worries
    of webmasters. To make CSP more user-friendly, and perhaps also in a naïve attempt
    to offer exploit detection, an optional feature of CSP allows the browser to report
    all policy violations immediately back to the owner of the site. This feature
    can be enabled through the *report-uri* keyword in the policy. To further simplify
    deployment, it is also possible to roll out any policy—or part thereof—in a “soft”
    mode, where violations result only in an HTTP notification but do not actually
    break the page. This is achieved by specifying the policy inside a header named
    *X-Content-Security-Policy-Report-Only*.^([[83](#ftn.CHP-16-FN-7)])
  prefs: []
  type: TYPE_NORMAL
- en: Criticisms of CSP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSP is a remarkably sensible and consistent design compared to most of the one-off
    security features proposed or deployed in the browser world. Nevertheless, from
    its inception, the proposal has been haunted by recurring design and implementation
    concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most prosaic complaint about CSP is a nonsecurity one: In order
    to benefit from the XSS defenses offered by the framework, webmasters have to
    move all inline scripts on the page (often hundreds of individual snippets of
    code) to a separately requested document; in the new drafts of CSP, the same will
    be required for all stylesheets. The complexity of retrofitting existing pages
    to work with CSP and the performance penalty of an additional HTTP request are
    often prohibitive. (It may be possible to resolve this problem with the *script-nonce*
    extension proposed in the most recent drafts.)'
  prefs: []
  type: TYPE_NORMAL
- en: A more fundamental concern with the design of CSP is that the currently envisioned
    origin-level granularity of the rulesets may not offer a sufficiently robust defense
    against XSS. Consider the fact that any complex, real-life domain may well host
    a dozen largely separate web applications, each consisting of hundreds of possibly
    unrelated static scripts and JavaScript APIs. Attackers exploiting an XSS vulnerability
    in a CSP-protected site are prevented from directly executing a malicious script,
    but they may be able to put the application into an inconsistent and possibly
    dangerous state by loading the existing scripts in the wrong context or in an
    incorrect sequence. The history of vulnerabilities in nonweb software suggests
    that such state corruption conditions are exploitable more often than we may think.
  prefs: []
  type: TYPE_NORMAL
- en: 'An even more troubling prospect is that an attacker can load a subresource
    that is not truly a script but that might be mistaken for one. An extreme example
    of this may be a browser supporting E4X (see [Chapter 6](ch06.html "Chapter 6. Browser-Side
    Scripts")): Any valid XHTML document in which the attacker can place a nominally
    harmless string—say, *{alert("Hi mom!")}*—may result in code execution when loaded
    via *<script src=...>*. Recognizing this problem, the developers decided to require
    whitelisted *Content-Type* values for any scripts loaded under CSP, but even this
    approach is often insufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what may go wrong, consider the exceedingly common practice of
    hosting public JSONP APIs in which the client can specify the name of the callback
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Such an API anywhere within a CSP-permitted origin may be leveraged by an attacker
    to call arbitrary existing functions in the client-side code, perhaps together
    with attacker-controlled parameters. And if the *callback* string is not constrained
    to alphanumerics (and why should it be?), specifying *callback=alert(1);//* will
    lead to straightforward code injection.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with granularity aside, CSP deserves some gentle criticism for its sometimes
    puzzling and detrimental lack of focus. On one hand, through the inclusion of
    directives such as *frame-descendants* or *sandbox*, it seems to be flirting with
    the idea of building a single, unifying browser security framework—only to unexpectedly
    exclude XSRF flaws from its scope without offering a viable alternative beyond
    a vague mention of *Origin*. On the other hand, the proposal often aspires to
    be just a “Content Policy,” with no special attention paid to offering sufficiently
    robust and intuitive security properties. The ease of creating dangerous script
    policies, coupled with the originally ineffective policing of stylesheets and
    images, is a testament to this trend.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxed Frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sandboxed frames^([[250](pr03.html#ftn.CHP-16-FT-11)]) are an extension of the
    normal *<iframe>* behavior. They allow the owner of the top-level page to place
    certain additional restrictions on the embedded document along with any of that
    document’s subframes. The goal is to make it safer for web applications to embed
    potentially untrusted advertisements, gadgets, or preformatted HTML documents
    on an otherwise sensitive site. The refinement of the design and the initial implementation
    of this feature in WebKit (which is currently the only engine supporting it) was
    driven by Adam Barth.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Curiously, sandboxed frames are not exactly a novel idea: Microsoft came up
    with a similar proposal almost a decade earlier. Since version 6, Internet Explorer
    has supported a proprietary *security=restricted* parameter, which forces the
    target frame to be rendered in the Restricted Zone, effectively removing its ability
    to execute scripts, navigate to other locations, and so on. However, no one seemed
    interested in using this feature for anything other than bypassing certain client-side
    JavaScript security mechanisms (most notably, anticlickjacking checks). We will
    soon know whether the HTML5 successor fares any better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of sandboxed frames is fairly simple: Any frame embedded in a document
    may be constrained by specifying the *sandbox* parameter on the appropriate *<iframe>*
    tag. By default, the document subject to this restriction is prevented from executing
    scripts and performing certain types of navigations. The permissions may be fine-tuned
    with one or more whitespace-delimited keywords, specified as a value for the *sandbox*
    parameter itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow-scripts In the absence of this keyword, the document displayed inside
    the frame will be unable to execute JavaScript code. The primary function of this
    feature is to prevent the embedded document from performing DoS attacks, opening
    browser dialogs, or employing any other complex automation of the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow-forms When this keyword is absent, any HTML forms encountered in the embedded
    document will not work. This mechanism is designed to prevent the framed content
    from exploiting its placement on a trusted website to phish for sensitive information.
    (Note that with *allow-scripts* enabled, there is little or no point in *allow-forms*.
    Scripts may easily construct form-like controls and automatically relay the collected
    information to another site without the need for a functioning *<form>* tag.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow-top-navigation This keyword re-enables the ability of the embedded page
    to navigate the top-level window. This type of navigation is normally permitted
    as one of the exceptions to the same-origin policy (see [Chapter 11](ch11.html
    "Chapter 11. Life Outside Same-Origin Rules")), and it may be abused simply to
    prevent the user from interacting with the embedding site or to carry out phishing
    attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow-same-origin Without this flag, the content inside a sandboxed frame is
    assigned a unique, randomly selected, synthetic origin. This prevents the page
    from accessing any origin-bound content that would normally be available to scripts
    executing in the domain it is nominally hosted in. The inclusion of *allow-same-origin*
    removes the synthetic origin and permits same-origin data access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting, Forms, and Navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first three restrictions available to sandboxed frames—scripting, forms,
    and navigation—are fairly intuitive and safe to use. Their value is diminished
    only by the need to also disable all plug-ins whenever the *sandbox* attribute
    is used, because frameworks such as Flash or Java do not honor the extension and
    would allow any embedded applets to bypass the newly added browser checks. Unfortunately,
    the three most obvious use cases for sandboxed frames—embedded advertisements,
    videos, and games—rely heavily on Flash, thus rendering this security mechanism
    much less useful than it might otherwise be.
  prefs: []
  type: TYPE_NORMAL
- en: Synthetic Origins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last mechanism on the list, synthetic origins, is far more problematic and
    is likely misguided. It is envisioned primarily as a way to make it possible for
    untrusted documents (such as incoming HTML-based emails in a webmail interface)
    to be served as is, along with the rest of the application, while preventing these
    untrusted documents from accessing sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the concept of synthetic origins creates more problems than it
    solves. For one, unless the URL of the embedded document is unpredictable, the
    attacker may simply navigate to it directly in a new browser window, in which
    case the browser will not see the *sandbox* attribute at all.
  prefs: []
  type: TYPE_NORMAL
- en: As an attempt to work around this problem, the authors of the specification
    eventually proposed the use of a specialized MIME type (*text/html-sandboxed*)
    for content meant to be shown only in a sandboxed frame. Their reasoning is that
    browsers will normally not recognize this MIME type and will not display it inline
    and that a special case may be created in the *<iframe>* handling code. Of course,
    as should be clear from [Chapter 13](ch13.html "Chapter 13. Content Recognition
    Mechanisms"), such a defense is inadequate, because some browsers and plug-ins
    will render *text/html-sandboxed* responses inline or interpret the returned data
    in other troubling ways (say, as *crossdomain.xml*).
  prefs: []
  type: TYPE_NORMAL
- en: The concept of synthetic origins is also highly problematic given the fragmentation
    of origin- or domain-level security mechanisms in a typical browser. For example,
    dangerous interactions are possible with password managers, which must be explicitly
    prevented from autocompleting login forms in the sandboxed documents. Also, special
    logic must be added to security prompts, such as the one associated with the geolocation
    API.
  prefs: []
  type: TYPE_NORMAL
- en: After some trial and error, the implementation currently available in WebKit
    resolved many of these issues on a case-by-case basis. That said, future implementations
    are likely to fall for this trap repeatedly, especially since the HTML5 specification
    considers the behavior of these features to be out of scope and does not specify
    the required behavior in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Removing synthetic origins leads to trouble, too: If the user clicks on a same-site
    link in a sandboxed advertisement and that link opens in a new window, the browser
    probably should prevent the unrestricted scripts in the new window from traversing
    the *opener* object to perform actions that its parent is prohibited from performing
    on its own.'
  prefs: []
  type: TYPE_NORMAL
- en: Strict Transport Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most significant weaknesses in the design of HTTPS is that users
    often begin navigation by typing in a protocol-less URL in the address bar (such
    as [bankofamerica.com](http://bankofamerica.com) rather than [https://www.bankofamerica.com](https://www.bankofamerica.com)),
    in which case the browser will presume HTTP and send the initial request in plaintext.
    Even if the site immediately redirects this traffic to HTTPS, any active attacker
    on the victim’s network may intercept and modify that initial response, preventing
    the user from ever upgrading to a secure protocol. In such case, the absence of
    a tiny lock icon in the browser UI will be very easy to miss.
  prefs: []
  type: TYPE_NORMAL
- en: This problem, as well as several peripheral issues related to mixed content
    and cookie scoping, prompted Jeff Hodges and several other researchers to draft
    a proposal for HTTP Strict Transport Security (HSTS, or STS for short).^([[251](pr03.html#ftn.CHP-16-FT-12)])
    Their approach (currently supported in WebKit and Firefox) allows any site on
    the Internet to instruct the browser that all future requests made to a particular
    hostname or domain should always use HTTPS and that any HTTP traffic should be
    automatically upgraded and submitted only over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: The reasoning behind the design of HSTS is that the user’s first interaction
    with a particular domain is unlikely to occur over a connection that is being
    actively tampered with—but that, over time, as the user roams on open wireless
    networks, the chances of encountering an attacker increase rapidly. HSTS is, therefore,
    an imperfect defense, but in practice it is usually good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HSTS opt-in header may appear in HTTPS responses, looking something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For HSTS to offer reasonable protection, *max-age* (the number of seconds that
    the STS record may be stored in the browser) must be set to a value substantially
    higher than the usual worst-case time between visits to the site. Because there
    is no easy way to disable or override HSTS when something goes wrong with the
    HTTPS site, website owners will be tempted to choose a value small enough to minimize
    disruption when they mess something up and have to revert. It is not clear whether
    this conflict of interests will lead web programmers to make optimal choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The negative security consequences of this design are fairly unremarkable:
    There is a slightly elevated risk of DoS attacks, because an attacker could inject
    this response header into a domain that is not fully HTTPS enabled. There is also
    the possibility of using a unique combination of HSTS settings for several decoy
    hostnames to tag a particular instance of a browser, offering yet another alternative
    to cookie-based user tracking. Neither of these concerns is particularly pronounced,
    however.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, as with other restriction-adding frameworks discussed in this
    section of the book, the mechanism sounds great in principle, but it’s difficult
    to fully account for how it may interact with other legacy code. In particular,
    unless the *includeSubDomains* flag is used, HSTS offers unexpectedly little protection
    for HTTP cookies: Cookies not marked as *secure* may still be intercepted simply
    by inventing a nonexistent subdomain and intercepting the HTTP request made to
    that destination.^([[84](#ftn.CHP-16-FN-8)]) (Even *secure* cookies could be clobbered
    in a similar fashion, just not read back.)'
  prefs: []
  type: TYPE_NORMAL
- en: In a similar vein, the enforcement of HSTS on requests originating from plug-in-based
    content is unlikely to work well.
  prefs: []
  type: TYPE_NORMAL
- en: Private Browsing Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Private browsing, colloquially known as the “porn mode,” is a nonstandardized
    feature available in most up-to-date browsers. It is meant to create a nonpersistent
    browsing sandbox, isolated from the main browser session, which is completely
    discarded as soon as the last private browsing window is closed. In a sense, this
    mechanism can be considered a form of content isolation added on top of the existing
    browser security paradigms, so it seems fitting to briefly mention it now.
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of Chrome, most browser vendors do not accurately explain
    the security assurances associated with private browsing. Unfortunately, the intuitive
    understanding of the term is quite different from what browsers can actually deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, the most straightforward interpretation of the feature is that a private
    browsing session should be perfectly anonymous and that no data about the user’s
    activity will persist on the system. These two assumptions are already partly
    undermined by the constraints imposed by the networking stacks and the memory
    management practices of modern operating systems. But even within the browser
    itself, the goal of reasonable anonymity is nearly impossible to achieve. Almost
    every stateful browser mechanism, from geolocation or pop-up permissions to Strict
    Transport Security to form autocompletion to plug-in-based persistent data storage,
    must be modified in order to properly account for the distinction between the
    two browsing modes, and for each vendor, achieving that goal is an uphill battle.
    Perhaps more frustratingly, anonymity is also undermined by the ability of scripts
    to uniquely fingerprint any given system simply by examining its characteristics—such
    as the set of installed plug-ins, fonts, screen resolutions, window sizes, clock
    drift, or even the behavior of noncryptographically secure PRNGs.^([[252](pr03.html#ftn.CHP-16-FT-13)])
  prefs: []
  type: TYPE_NORMAL
- en: In the end, despite appearances to the contrary, private browsing mode is suitable
    only for preventing casual data disclosure to other nontechnical users of the
    same machine, and even that goal is sometimes difficult to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[81](#CHP-16-FN-5)]) CSP offers several ways to shoot yourself in the foot
    here. For one, it is possible to re-enable script execution with settings such
    as *inline-script* (Mozilla’s naming, changed to *disable-xss-protection* in W3C
    draft) or *eval-script*. Perhaps less obviously, it is also possible to make the
    mistake of permitting *data:* or *** as a permissible origin or allowing an HTTP
    origin on an HTTPS site.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[82](#CHP-16-FN-6)]) Remember advanced selectors in CSS3? By cleverly leveraging
    them in injected stylesheets, some information about the strings appearing on
    the page may be conveniently relayed to a third-party server without the use of
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[83](#CHP-16-FN-7)]) As a side note, this feature is useful not only for
    short-term experiments but also for detecting noncritical issues on an ongoing
    basis. For example, the owner of a site may leverage it to detect mixed-content
    issues by creating a report-only policy for HTTPS pages that will be violated
    by any HTTP scripts.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[84](#CHP-16-FN-8)]) Recall from [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic") that host-scoped cookies are fairly tricky to create in some
    browsers and outright impossible to have in Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Other Developments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The security features discussed previously in this chapter aim to shift the
    boundaries between web applications and change the way sites interact with each
    other. Another group of proposed mechanisms escapes this simple classification
    yet is important or mature enough to briefly mention here. We’ll review some of
    them now.
  prefs: []
  type: TYPE_NORMAL
- en: In-Browser HTML Sanitizers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XSS vulnerabilities are by far the most common security issue encountered in
    modern web applications. It must be surprising, then, that so few of the proposed
    security frameworks aim to address the problem in a comprehensive way. True, CSP
    is a strong contender, but it requires a radical change in how web applications
    are written, and it can’t be deployed particularly gradually or selectively. Sandboxed
    frames, on the other hand, are probably too resource-intensive and too awkward
    to use for the most common task of displaying hundreds of individual, short snippets
    of user-supplied data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the best solution to many XSS woes would be a method for web frameworks
    to provide the browser with a parsed, unambiguous, binary DOM tree. Such a solution
    would eliminate many of the issues associated with template escaping and HTML
    sanitization. A more down-to-earth alternative might be to equip web developers
    with a robust tool to mark the boundaries of an attacker-supplied string and restrict
    the behavior or appearance of the embedded payload without having to escape or
    sanitize it. One might think of syntax such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Were such a tool to be used, the attacker would be unable to escape such a sandbox
    and remove the restriction on scripting without guessing the correct value of
    the randomly generated *token* boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, such a proposal is unlikely to become a part of HTML5 or to ship in any
    browser, because this serialization is fundamentally incompatible with XML, and
    revising XML itself to allow an obscure use case in HTML is a difficult act to
    pull off. Depressingly, XML already offers a similar method of encapsulating arbitrary
    data inside a *<![CDATA[...]]>* block, but absent a token-based guard, this sandbox
    can be escaped easily when exploiting XSS.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, it is considerably easier to restrict the privileges of any
    HTML generated by scripts on the client side. Beginning with Internet Explorer
    8, Microsoft offers a simple and somewhat inflexible *toStaticHTML(...)* API,^([[253](pr03.html#ftn.CHP-16-FT-14)])
    which promises to remove JavaScript from any fully qualified bit of HTML passed
    to it as a parameter. The output of this method is designed to be safe to assign
    to the *innerHTML* property somewhere in the existing DOM.^([[85](#ftn.CHP-16-FN-9)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft’s proposal is fine, but it dances around the most common and problematic
    task of safely displaying server-supplied documents. And its API has a minor but
    entirely unnecessary weakness: It makes it unexpectedly dangerous to trim or concatenate
    the sanitized *toStaticHTML(...)* output after the call but before the *innerHTML*
    assignment, a practice that many web developers will probably attempt. A more
    sensible approach would be to allow content sanitization only upon assignment
    to *innerHTML*. In fact, WebKit engineers briefly discussed a proposal for such
    an API (alternately named *innerStaticHTML* or *safeInnerHTML*), but the effort
    seems to have fizzled out long ago.'
  prefs: []
  type: TYPE_NORMAL
- en: XSS Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reducing the incidence of cross-site vulnerabilities is difficult, and so is
    limiting their impact. Because of this, some researchers have concluded that detecting
    and stopping the exploitation of such flaws may be a better choice. And so, around
    2008, David Ross of Microsoft announced the inclusion of XSS-detection logic in
    the upcoming release of Internet Explorer 8;^([[254](pr03.html#ftn.CHP-16-FT-15)])
    several months later, Adam Barth implemented a similar feature in WebKit. The
    implementations compare portions of the current URL with any strings appearing
    on the retrieved page or passed to APIs such as *document.write(...)* and *innerHTML*.
    If that comparison reveals that a portion of JavaScript present on the page may
    have originated with an improperly escaped URL parameter, the relevant portion
    of the page may be substituted with a harmless string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, this seemingly elegant idea is known to cause serious problems. Accidental
    false positives aside (users of Internet Explorer 8 will have unexpected trouble
    visiting *http://www.google.com/search?q=<script>*), the filter may also be tripped
    for ill purposes by appending a legitimate portion of the page as a nonfunctional
    parameter in the URL. In one extreme and now resolved case, this behavior was
    leveraged to create XSS vectors where none had existed before, simply by tricking
    the browser into haphazardly rearranging the markup.^([[255](pr03.html#ftn.CHP-16-FT-16)])
    But more fundamentally, it’s risky for any complex web application to selectively
    disable attacker-selected script blocks, even if the structure of the page is
    otherwise correctly preserved, and such a tweak may easily put the client-side
    code in an inconsistent or dangerous state. For example, consider an online document
    editor that implements each of the following in a separate *<script>* block:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializes the internal state of the editor and creates the UI with an empty
    starting document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loads the current version of the document requested by the user in a URL parameter
    with error checking to catch any potential network problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no errors are detected, enters an interactive editing mode and automatically
    saves the current state of the document every 30 seconds under the URL-derived
    ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this not entirely unreasonable design, the ability to remove step two can
    be disastrous because the next step could overwrite the existing, server-stored
    document with a blank copy. D’oh.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem could have been avoided by using much simpler design whereby any
    suspected XSS attacks would result in the browser simply refusing to render the
    document. Alas, the relatively high incidence of accidental false positives prevented
    the authors from taking this route. Only after some debate did Microsoft decide
    to offer a “strict” blocking mode on an opt-in basis, toggled by a response header
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the risk of false positives, XSS filters are also prone to false
    negatives, a situation that probably can’t be improved by much. By design, these
    filters will never be able to detect the arguably more dangerous stored XSS vulnerabilities,
    where incorrectly escaped data comes from a source other than the followed link.
    But even beyond that, the multitude of (often implicit) input escaping schemes
    and the growing use of *location.hash* or *pushState* ([Chapter 17](ch17.html
    "Chapter 17. Other Browser Mechanisms of Note")) as a method to store application
    state make it difficult to formulate an accurate connection between what the browser
    sees in the address bar and what the application makes of the received URL.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: Approach experimental browser security features with care, particularly when
    dealing with mechanisms that create finer-grained security boundaries. Ensure
    that any application leveraging these mechanisms will degrade safely in a noncompliant
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-domain XMLHttpRequest (CORS): Fairly safe, but easy to misuse. Avoid
    non-simple requests and do not permit arbitrary headers or methods. If you have
    control over the server-side application framework, consider automatically stripping
    *Cookie* headers on incoming CORS requests with nonwhitelisted *Origin* values
    to minimize the risk of accidentally sharing user-specific data. To minimize the
    incidence of mixed-content bugs, consider rejecting HTTPS *Origin* values on any
    requests received over plain HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be wary of *Access-Control-Allow-Origin: **, and if you need to use it, make
    sure it is only returned for the location you intend to share.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'XDomainRequest: This is safe to use. As with *XMLHttpRequest*, restricting
    access to HTTP APIs from HTTPS origins may be a good way to stamp out mixed-content
    bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content Security Policy:** This is safe to use as defense in depth. Review
    the caveats related to the interactions among *script-src*, *object-src*, and
    so on, and the dangers of permitting *data:* origins. Do not accidentally allow
    mixed content: Always specify protocols in the rulesets and make sure they match
    the protocol the requesting page is served over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sandboxed frames:** This is safe to use as a way to embed gadgets from other
    origins, but the mechanism will fail dramatically in noncompliant browsers. You
    should not sandbox same-origin documents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strict Transport Security:** This is safe to use as defense in depth. Be
    sure to mark all relevant cookies as *secure* and be prepared for the possibility
    of cookie injection via spoofed, non-STS locations in your domain. Use *includeSubDomains*
    where feasible to mitigate this risk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'toStaticHTML(...): This is safe to use where available, but it is difficult
    to substitute on the client side in noncompliant browsers. Bypass vulnerabilities
    have an above-average chance of recurring in the API due to the design of the
    filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private browsing:** Do not rely on this mechanism for security purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XSS filtering:** Do not rely on this mechanism for security purposes. Always
    explicitly specify *XSS-Protection: 1; mode=block* or *XSS-Protection: 0* in HTTP
    responses. The default is fairly unsafe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[85](#CHP-16-FN-9)]) Amusingly, the HTML parser in Internet Explorer is apparently
    so obtuse that even the authors of *toStaticHTML(...)* had some trouble following
    it. Since its introduction, the API has suffered from a fair number of bypass
    vulnerabilities, most frequently related to the handling of CSS data.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17. Other Browser Mechanisms of Note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To conclude the third part of the book, we briefly enumerate some of the recently
    implemented or simply planned APIs that, although not designed for security purposes,
    may substantially change the security landscape in the coming years. For example,
    some change the types of data that web applications have access to or alter the
    way the browser communicates with the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list is necessarily incomplete: New, reasonably plausible designs
    are drafted every week, and old approaches are scrapped at a moment’s notice,
    often long before shipping in an actual browser. Still, this chapter should serve
    as an interesting snapshot of what the future may bring.'
  prefs: []
  type: TYPE_NORMAL
- en: URL- and Protocol-Level Proposals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These features seek to change the processes surrounding the behavior of links,
    the address bar, and the exchange of data over the wire.
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol registration**'
  prefs: []
  type: TYPE_NORMAL
- en: Web applications commonly assume the handling of URL schemes previously reserved
    for “real” desktop software. One prime example of this may be the *mailto:* protocol,
    which was originally meant to instantiate a stand-alone mail application but which
    is often more sensibly routed to webmail interfaces today. To this end, Mozilla
    proposed and WebKit embraced a simple *navigator.registerProtocolHandler(...)*
    API.^([[256](pr03.html#ftn.CHP-17-FT-1)]) When this API is invoked, the user is
    presented with a simple security prompt, and if the action is approved, a URL-based
    handler is associated with a particular scheme. As of today, the associated prompts
    are vulnerable to the race conditions outlined in [Chapter 14](ch14.html "Chapter 14. Dealing
    with Rogue Scripts"), and they seem to be lacking in other ways, as shown in [Figure 17-1](ch17.html#a_seriously_confusing_prompt_in_firefox
    "Figure 17-1. A seriously confusing prompt in Firefox. The prompt shown in the
    upper area of the browser window was generated by the browser in response to a
    call to the registerProtocolHandler(...) API, with the protocol name set to “doing
    really awesome stuff” and application name set to “Firefox (mozilla.org)”. This
    particular example is harmless, but more sinister abuse is within reach.").
  prefs: []
  type: TYPE_NORMAL
- en: '![A seriously confusing prompt in Firefox. The prompt shown in the upper area
    of the browser window was generated by the browser in response to a call to the
    registerProtocolHandler(...) API, with the protocol name set to “doing really
    awesome stuff” and application name set to “Firefox (mozilla.org)”. This particular
    example is harmless, but more sinister abuse is within reach.](httpatomoreillycomsourcenostarchimages950045.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1. A seriously confusing prompt in Firefox. The prompt shown in the
    upper area of the browser window was generated by the browser in response to a
    call to the *registerProtocolHandler(...)* API, with the protocol name set to
    “doing really awesome stuff” and application name set to “Firefox (mozilla.org)”.
    This particular example is harmless, but more sinister abuse is within reach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Address bar manipulation**'
  prefs: []
  type: TYPE_NORMAL
- en: The newly introduced HTML5 *history.pushState(...)* API,^([[257](pr03.html#ftn.CHP-17-FT-2)])
    supported by Firefox, WebKit, and Opera, permits the currently displayed document
    to change the contents of the address bar to any other same-origin URL, without
    actually triggering a page transition normally associated with this step. The
    API offers a superior alternative to the widespread abuse of *location.hash* to
    store application state. Interestingly, despite its simplicity, it has already
    led to a fair number of interesting security bugs. For example, some implementations
    briefly allowed not only the top-level document but also any dodgy third-party
    frames to change the top-level URL shown in the address bar, and they permitted
    origins such as *about:blank* to put largely unconstrained gibberish in the URL
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary HTTP**'
  prefs: []
  type: TYPE_NORMAL
- en: SPDY^([[258](pr03.html#ftn.CHP-17-FT-3)]) (“Speedy”) is a simple, encrypted
    drop-in replacement for HTTP that preserves the protocol’s key design principles
    (including the layout and function of most headers). At the same time, it mini-
    mizes the overhead associated with delivering concurrent requests or with the
    parsing of text-based requests and response data. The protocol is currently supported
    only in Chrome, and other than select Google services, it is not commonly encountered
    on the Web. It may be coming to Firefox soon, too, however.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP-less networking**'
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket^([[259](pr03.html#ftn.CHP-17-FT-4)]) is a still-evolving API designed
    for negotiating largely unconstrained, bidirectional TCP streams for when the
    transactional nature of TCP gets in the way (e.g., in the case of a low-latency
    chat application). The protocol is bootstrapped using a keyed challenge-response
    handshake, which looks sort of like HTTP and which is (quite remarkably) impossible
    to spoof by merely exploiting a header-splitting flaw in the destination site.
    Following a successful handshake, raw data may be exchanged bidirectionally within
    the resulting long-lived TCP connection, with each message enveloped inside a
    simple protocol frame. The mechanism is supported in WebKit and is probably coming
    soon to Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: '**P2P networking**'
  prefs: []
  type: TYPE_NORMAL
- en: WebRTC^([[260](pr03.html#ftn.CHP-17-FT-5)]) is a proposed set of APIs and network
    protocols designed to facilitate the discovery of and communication with other
    browsers without the need for a centralized server infrastructure. The primary
    use case for such a protocol is the implementation of IP telephony and video-conferencing
    features within web apps. No stable browser support is available yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Offline applications**'
  prefs: []
  type: TYPE_NORMAL
- en: Cache manifests^([[261](pr03.html#ftn.CHP-17-FT-6)]) are a relatively simple
    way for a web server to instruct the browser that copies of certain documents
    should be stored indefinitely and reused whenever the client appears to have no
    network connectivity. In conjunction with client-side storage mechanisms such
    as *localStorage* ([Chapter 9](ch09.html "Chapter 9. Content Isolation Logic")),
    this allows certain self-sufficient JavaScript applications to be used in offline
    mode. Offline operation is supported in Firefox, the WebKit browser, and Opera.
    As with *localStorage*, the persistent nature of this mechanism could exacerbate
    the long-term consequences of visiting an untrusted network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better cookies**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cake*^([[262](pr03.html#ftn.CHP-17-FT-7)]) is a now-expired proposal drafted
    by Adam Barth that aims to create a more lightweight and secure alternative to
    HTTP cookies: one origin-bound, browser-generated nonce for every destination
    site. A more current but incomplete proposal appears to flirt with normal but
    origin-based cookies as an alternative. Neither approach is available in any browser
    today.'
  prefs: []
  type: TYPE_NORMAL
- en: Content-Level Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proposals outlined in this section aim to enable new classes of web applications
    to be built on top of HTML and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-side databases**'
  prefs: []
  type: TYPE_NORMAL
- en: Several APIs for creating and manipulating locally stored databases have been
    proposed over the years, including the notorious *WebSQL* API,^([[263](pr03.html#ftn.CHP-17-FT-8)])
    which would have brought the famously dangerous SQL syntax to client-side JavaScript.
    The WebSQL proposal was ditched in favor of a more sensible *IndexedDB* design,^([[264](pr03.html#ftn.CHP-17-FT-9)])
    which offers a clean API without serialized queries and has a security model comparable
    to that of *localStorage*—but not until WebSQL support had shipped in a couple
    of browsers. Meanwhile, the new API has shipped in Chrome and is expected to appear
    in Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: '**Background processes**'
  prefs: []
  type: TYPE_NORMAL
- en: The *Worker* API,^([[265](pr03.html#ftn.CHP-17-FT-10)]) available in Firefox,
    WebKit, and Opera, permits the creation of background JavaScript processes to
    perform computationally expensive tasks without having to worry about blocking
    the browser UI. Each worker runs in an isolated environment that lacks the usual
    *window* or *document* DOM and may communicate with its creator asynchronously
    through the *postMessage(...)* API. *Dedicated workers* are directly reachable
    only by their creator, while *shared workers* may be “attached” to several different
    sites at any given time. (*Persistent workers*, which would run independently
    of any sustained demand for their services, were proposed early on but then dropped.)
    The concept of worker threads raises some peripheral DoS concerns but otherwise
    poses no apparent security risks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Geolocation discovery**'
  prefs: []
  type: TYPE_NORMAL
- en: The *navigator.geolocation.getCurrentPosition(...)* API^([[266](pr03.html#ftn.CHP-17-FT-11)])
    permits any website to request information about the physical location of the
    client device, subject to a user’s (largely hijackable) consent. The computed
    geolocation data may be derived from GPS information on a system with a suitable
    hardware module, or it may be looked up based on the names of nearby wireless
    access points, cell towers, and so forth. The API is supported in all major browsers
    except for Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Device orientation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A nonrestricted event-driven *DeviceOrientation* API^([[267](pr03.html#ftn.CHP-17-FT-12)])
    allows websites to read back the orientation of the device, based on accelerometer
    data. This API, which is probably geared toward mobile gaming, is available in
    Firefox, WebKit, and Opera on systems equipped with the appropriate hardware.
    Two researchers at the University of California, Davis have recently demonstrated
    a fatal flaw: On smartphones, minute movements of the device may be used to reliably
    reconstruct on-screen keyboard input, including passwords entered on unrelated
    websites.^([[268](pr03.html#ftn.CHP-17-FT-13)])'
  prefs: []
  type: TYPE_NORMAL
- en: '**Page prerendering**'
  prefs: []
  type: TYPE_NORMAL
- en: This experimental feature in Chrome allows pages to be prefetched in anticipation
    of the user following a particular link, and it permits the entire HTML document
    to be prerendered in a hidden tab^([[269](pr03.html#ftn.CHP-17-FT-14)]) and momentarily
    revealed once the predicted navigation action takes place. The mechanism has some
    interesting browser security consequences if the prerendered page turns out to
    be malicious. The implementation in Chrome is careful to defer any disruptive
    actions until the tab is revealed, but mistakes will be very easy to make across
    all browser codebases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigation timing**'
  prefs: []
  type: TYPE_NORMAL
- en: Several complementary APIs, currently available only in Chrome, permit certain
    types of navigation, including cross-domain page loads, to be very accurately
    benchmarked from client-side JavaScript.^([[270](pr03.html#ftn.CHP-17-FT-15)])
    This interface is designed to allow site owners to identify obvious performance
    bottlenecks, as experienced by a typical visitor. The API allows some privacy-related
    information to be collected by profiling the time needed to load certain third-party
    content, but because the same attack is possible in many other ways (for example
    with *onload* handlers on subresources), that probably does not matter much.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The features listed below offer new input and output capabilities to web-based
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '**UI notifications**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notification* and *window.notifications*^([[271](pr03.html#ftn.CHP-17-FT-16)])
    APIs allow the creation of text-only or HTML-based, always-on-top pop-ups in the
    corner of the screen, allowing select web applications to gently notify users
    of important developments (such as a new mail message). User consent to receiving
    notifications is required on a per-site basis, limiting the risk of abuse. Nevertheless,
    care must be taken to properly communicate the origin of the tiny notification
    window and any dialogs or prompts it subsequently creates, an aspect that took
    some time to refine. The API is available only in WebKit today.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full-screen mode**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several proposals have been circulated to allow JavaScript to maximize the
    current browser window and hide all the browser chrome. This functionality is
    essential to tasks such as viewing presentations or watching movies, but it is
    obviously very dangerous from the security standpoint: Once in control of the
    entire screen, any malicious page may draw a fake browser window with a fake address
    bar. So far, no specific implementation seems to be available for review. An early-stage
    proposal for mouse cursor locking is being discussed, too.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Media capture**'
  prefs: []
  type: TYPE_NORMAL
- en: A proposed suite of *navigator.device.capture* APIs^([[272](pr03.html#ftn.CHP-17-FT-17)])
    has been postulated for giving websites access to webcam and microphone data.
    Obvious security and privacy concerns arise around this mechanism, especially
    around the resilience of any associated security prompts with respect to race
    condition attacks. The API has no stable browser support today.
  prefs: []
  type: TYPE_NORMAL
