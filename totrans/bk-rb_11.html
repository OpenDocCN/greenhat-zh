<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Symbols"><div class="titlepage"><div><div><h1 class="title"><a id="symbols"/>Chapter 11. Symbols</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id13"/><div class="mediaobject"><a id="I_mediaobject11_d1e13396"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>Many newcomers to Ruby are confused by symbols. A symbol is an identifier whose first character is a colon (<code class="literal">:</code>), so <code class="literal">:this</code> is a symbol and so is <code class="literal">:that</code>. Symbols are, in fact, not at all complicated—and, in certain circumstances, they may be extremely useful, as you will see shortly.<a id="IDX-CHP-11-0001" class="indexterm"/><a id="IDX-CHP-11-0002" class="indexterm"/><a id="IDX-CHP-11-0003" class="indexterm"/><a id="IDX-CHP-11-0004" class="indexterm"/></p><p>Let’s first be clear about what a symbol is <span class="emphasis"><em>not</em></span>: It is not a string, it is not a constant, and it is not a variable. A symbol is, quite simply, an identifier with no intrinsic meaning other than its own name. Whereas you might assign a value to a variable like this . . .</p><a id="I_programlisting11_d1e13435"/><pre class="programlisting">name = "Fred"</pre><p>you would <span class="emphasis"><em>not</em></span> assign a value to a symbol:</p><a id="I_programlisting11_d1e13442"/><pre class="programlisting">:name = "Fred"    # Error!</pre><p>The value of a symbol is itself. So, the value of a symbol called <code class="literal">:name</code>is <code class="literal">:name</code>.<a id="IDX-CHP-11-0005" class="indexterm"/><a id="IDX-CHP-11-0006" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>For a more technical account of what a symbol is, refer to <a class="xref" href="ch11s03.html#digging_deeper-id10" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch11s03.html#digging_deeper-id10" title="Digging Deeper">Digging Deeper</a>.</p></div><p>You have, of course, used symbols before. In <a class="xref" href="ch02.html" title="Chapter 2. Class Hierarchies, Attributes, and Class Variables">Chapter 2</a>, for instance, you created attribute readers and writers by passing symbols to the <code class="literal">attr_reader</code> and <code class="literal">attr_writer</code> methods, like this:<a id="IDX-CHP-11-0007" class="indexterm"/><a id="IDX-CHP-11-0008" class="indexterm"/></p><a id="I_programlisting11_d1e13485"/><pre class="programlisting">attr_reader( :description )
attr_writer( :description )</pre><p>You may recall that the previous code causes Ruby to create a <code class="literal">@description</code> instance variable plus a pair of getter (reader) and setter (writer) methods called <code class="literal">description</code>. Ruby takes the value of a symbol literally. The <code class="literal">attr_reader</code> and <code class="literal">attr_writer</code> methods create, from that name, variables and methods with matching names.</p><div class="sect1" title="Symbols and Strings"><div class="titlepage"><div><div><h1 class="title"><a id="symbols_and_strings"/>Symbols and Strings</h1></div></div></div><p>It is a common misconception that a symbol is a type of string. After all, isn’t the symbol <code class="literal">:hello</code> pretty similar to the string <code class="literal">"hello"</code>? In fact, symbols are quite unlike strings. For one thing, each string is different—so, as far as Ruby is concerned, <code class="literal">"hello"</code>, <code class="literal">"hello"</code>, and <code class="literal">"hello"</code> are three separate objects with three separate <code class="literal">object_id</code>s.</p><p><span class="emphasis"><em>symbol_ids.rb</em></span></p><a id="I_programlisting11_d1e13529"/><pre class="programlisting"># These 3 strings have 3 different object_ids
puts( "hello".object_id ) #=&gt; 16589436
puts( "hello".object_id ) #=&gt; 16589388
puts( "hello".object_id ) #=&gt; 16589340</pre><p>But a symbol is unique, so <code class="literal">:hello</code>, <code class="literal">:hello</code>, and <code class="literal">:hello</code> all refer to the same object with the same <code class="literal">object_id</code>.</p><a id="I_programlisting11_d1e13545"/><pre class="programlisting"># These 3 symbols have the same object_id
puts( :hello.object_id ) #=&gt; 208712
puts( :hello.object_id ) #=&gt; 208712
puts( :hello.object_id ) #=&gt; 208712</pre><p>In this respect, a symbol has more in common with an integer than with a string. Each occurrence of a given integer value, you may recall, refers to the same object, so <code class="literal">10</code>, <code class="literal">10</code>, and <code class="literal">10</code> may be considered to be the same object, and they have the same <code class="literal">object_id</code>. Remember that the actual IDs assigned to objects will change each time you run a program. The number itself is not significant. The important thing to note is that each separate object always has a unique ID, so when an ID is repeated, it indicates repeated references to the same object.</p><p><span class="emphasis"><em>ints_and_symbols.rb</em></span></p><a id="I_programlisting11_d1e13564"/><pre class="programlisting"># These three symbols have the same object_id
puts( :ten.object_id )  #=&gt; 20712
puts( :ten.object_id )  #=&gt; 20712
puts( :ten.object_id )  #=&gt; 20712

# These three integers have the same object_id
puts( 10.object_id )    #=&gt; 21
puts( 10.object_id )    #=&gt; 21
puts( 10.object_id )    #=&gt; 21</pre><p>You can also test for equality using the <code class="literal">equal?</code> method:<a id="IDX-CHP-11-0009" class="indexterm"/></p><p><span class="emphasis"><em>symbols_strings.rb</em></span></p><a id="I_programlisting11_d1e13578"/><pre class="programlisting">puts( :helloworld.equal?( :helloworld ) )     #=&gt; true
puts( "helloworld".equal?( "helloworld" ) )   #=&gt; false
puts( 1.equal?( 1 ) )                         #=&gt; true</pre><p>Being unique, a symbol provides an unambiguous identifier. You can pass symbols as arguments to methods, like this:</p><a id="I_programlisting11_d1e13582"/><pre class="programlisting">amethod( :deletefiles )</pre><p>A method might contain code to test the value of the incoming argument:</p><p><span class="emphasis"><em>symbols_1.rb</em></span></p><a id="I_programlisting11_d1e13589"/><pre class="programlisting">def amethod( doThis )
    if (doThis == :deletefiles) then
       puts( 'Now deleting files...')
    elsif (doThis == :formatdisk) then
       puts( 'Now formatting disk...')
    else
        puts( "Sorry, command not understood." )
    end
end</pre><p>Symbols can also be used in <code class="literal">case</code> statements where they provide both the readability of strings and the uniqueness of integers:</p><a id="I_programlisting11_d1e13596"/><pre class="programlisting">case doThis
    when :deletefiles then puts( 'Now deleting files...')
    when :formatdisk then puts( 'Now formatting disk...')
    else  puts( "Sorry, command not understood." )
end</pre><p>The scope in which a symbol is declared does not affect its uniqueness. Consider the following:<a id="IDX-CHP-11-0010" class="indexterm"/><a id="IDX-CHP-11-0011" class="indexterm"/><a id="IDX-CHP-11-0012" class="indexterm"/></p><p><span class="emphasis"><em>symbol_ref.rb</em></span></p><a id="I_programlisting11_d1e13616"/><pre class="programlisting">module One
     class Fred
     end
     $f1 = :Fred
end

module Two
     Fred = 1
     $f2 = :Fred
end

def Fred()
end

$f3 = :Fred</pre><p>Here, the variables <code class="literal">$f1</code>, <code class="literal">$f2</code>, and <code class="literal">$f3</code> are assigned the symbol <code class="literal">:Fred</code> in three different scopes: module <code class="literal">One</code>, module <code class="literal">Two</code>, and the “main” scope. Variables starting with <code class="literal">$</code> are global, so once created, they can be referenced anywhere. I’ll have more to say on modules in <a class="xref" href="ch12.html" title="Chapter 12. Modules and Mixins">Chapter 12</a>. For now, just think of them as “namespaces” that define different scopes. And yet each variable refers to the same symbol, <code class="literal">:Fred</code>, and has the same <code class="literal">object_id</code>.</p><a id="I_programlisting11_d1e13651"/><pre class="programlisting"># All three display the same id!
puts( $f1.object_id )  #=&gt; 208868
puts( $f2.object_id )  #=&gt; 208868
puts( $f3.object_id )  #=&gt; 208868</pre><p>Even so, the “meaning” of the symbol changes according to its scope. In module <code class="literal">One</code>, <code class="literal">:Fred</code> refers to the class <code class="literal">Fred</code>; in module <code class="literal">Two</code>, it refers to the constant <code class="literal">Fred = 1</code>; and in the main scope, it refers to the method <code class="literal">Fred</code>.</p><p>A rewritten version of the previous program demonstrates this:</p><p><span class="emphasis"><em>symbol_ref2.rb</em></span></p><a id="I_programlisting11_d1e13679"/><pre class="programlisting">module One
    class Fred
    end
    $f1 = :Fred
    def self.evalFred( aSymbol )
        puts( eval( aSymbol.id2name ) )
    end
end

module Two
    Fred = 1
    $f2 = :Fred
    def self.evalFred( aSymbol )
        puts( eval( aSymbol.id2name ) )
    end
end

def Fred()
    puts( "hello from the Fred method" )
end

$f3 = :Fred</pre><p>First I access the <code class="literal">evalFred</code> method inside the module named <code class="literal">One</code> using two colons (<code class="literal">::</code>), which is the Ruby “scope resolution operator.” I then pass <code class="literal">$f1</code> to that method:<a id="IDX-CHP-11-0013" class="indexterm"/><a id="IDX-CHP-11-0014" class="indexterm"/><a id="IDX-CHP-11-0015" class="indexterm"/><a id="IDX-CHP-11-0016" class="indexterm"/></p><a id="I_programlisting11_d1e13710"/><pre class="programlisting">One::evalFred( $f1 )</pre><p>In this context, <code class="literal">Fred</code> is the name of a class defined inside module <code class="literal">One</code>, so when the <code class="literal">:Fred</code> symbol is evaluated, the module and class names are displayed:</p><a id="I_programlisting11_d1e13723"/><pre class="programlisting">One::Fred</pre><p>Next I pass <code class="literal">$f2</code> to the <code class="literal">evalFred</code> method of module <code class="literal">Two</code>:</p><a id="I_programlisting11_d1e13737"/><pre class="programlisting">Two::evalFred( $f2 )</pre><p>In this context, <code class="literal">Fred</code> is the name of a constant that is assigned the integer 1, so that is what is displayed: <code class="literal">1</code>. And finally, I call a special method called simply <code class="literal">method</code>. This is a method of Object. It tries to find a method with the same name as the symbol passed to it as an argument and, if found, returns that method as an object that can then be called:</p><a id="I_programlisting11_d1e13750"/><pre class="programlisting">method($f3).call</pre><p>The <code class="literal">Fred</code> method exists in the main scope, and when called, its output is this string:</p><a id="I_programlisting11_d1e13757"/><pre class="programlisting">"hello from the Fred method"</pre><p>Naturally, since the variables <code class="literal">$f1</code>, <code class="literal">$f2</code>, and <code class="literal">$f3</code> reference the same symbol, it doesn’t matter which variable you use at any given point. Any variable to which a symbol is assigned, or, indeed, the symbol itself, will produce the same results. The following are equivalent:</p><a id="I_programlisting11_d1e13770"/><pre class="programlisting">One::evalFred( $f1 )    #=&gt; One::Fred
Two::evalFred( $f2 )    #=&gt; 1
method($f3).call        #=&gt; hello from the Fred method

One::evalFred( $f3 )    #=&gt; One::Fred
Two::evalFred( $f1 )    #=&gt; 1
method($f2).call        #=&gt; hello from the Fred method

One::evalFred( :Fred )  #=&gt; One::Fred
Two::evalFred( :Fred )  #=&gt; 1
method(:Fred).call      #=&gt; hello from the Fred method</pre></div></div>
<div class="sect1" title="Symbols and Variables"><div class="titlepage"><div><div><h1 class="title"><a id="symbols_and_variables"/>Symbols and Variables</h1></div></div></div><p>To understand the relationship between a symbol and an identifier such as a variable name, take a look at the <span class="emphasis"><em>symbols_2.rb</em></span> program. It begins by assigning the value 1 to a local variable, <code class="literal">x</code>. It then assigns the symbol <code class="literal">:x</code> to a local variable, <code class="literal">xsymbol</code>:<a id="IDX-CHP-11-0017" class="indexterm"/><a id="IDX-CHP-11-0018" class="indexterm"/><a id="IDX-CHP-11-0019" class="indexterm"/><a id="IDX-CHP-11-0020" class="indexterm"/></p><p><span class="emphasis"><em>symbols_2.rb</em></span></p><a id="I_programlisting11_d1e13809"/><pre class="programlisting">x = 1
xsymbol = :x</pre><p>At this point, there is no obvious connection between the variable <code class="literal">x</code> and the symbol <code class="literal">:x</code>. I have declared a method that simply takes some incoming argument and inspects and displays it using the <code class="literal">p</code> method. I can call this method with the variable and the symbol:</p><a id="I_programlisting11_d1e13822"/><pre class="programlisting">def amethod( somearg )
    p( somearg )
end

# Test 1
amethod( x )
amethod( :x )</pre><p>This is the data that the method prints as a result:</p><a id="I_programlisting11_d1e13826"/><pre class="programlisting">1
:x</pre><p>In other words, the value of the <code class="literal">x</code> variable is 1, since that’s the value assigned to it and the value of <code class="literal">:x</code> is <code class="literal">:x</code>. But the interesting question that arises is this: If the value of <code class="literal">:x</code> is <code class="literal">:x</code> and this is also the symbolic name of the variable <code class="literal">x</code>, would it be possible to use the symbol <code class="literal">:x</code> to find the value of the variable <code class="literal">x</code>? Confused? I hope the next line of code will make this clearer:</p><a id="I_programlisting11_d1e13855"/><pre class="programlisting"># Test 2
amethod( eval(:x.id2name))</pre><p>Here, <code class="literal">id2name</code> is a method of the Symbol class. It returns the name or string corresponding to the symbol (the <code class="literal">to_s</code> method would perform the same function); the end result is that, when given the symbol <code class="literal">:x</code> as an argument, <code class="literal">id2name</code> returns the string “x.” Ruby’s <code class="literal">eval</code> method (which is defined in the Kernel class) is able to evaluate expressions within strings. In the present case, that means it finds the string “x” and tries to evaluate it as though it were executable code. It finds that <code class="literal">x</code> is the name of a variable and that the value of <code class="literal">x</code> is 1. So, the value 1 is passed to <code class="literal">amethod</code>. You can verify this by running <span class="emphasis"><em>symbols2.rb</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Evaluating data as code is explained in more detail in <a class="xref" href="ch20.html" title="Chapter 20. Dynamic Programming">Chapter 20</a>.</p></div><p>Things can get even trickier. Remember that the variable <code class="literal">xsymbol</code> has been assigned the symbol <code class="literal">:x</code>.</p><a id="I_programlisting11_d1e13901"/><pre class="programlisting">x = 1
xsymbol = :x</pre><p>That means that if you eval <code class="literal">:xsymbol</code>, you can obtain the name assigned to it—that is, the symbol <code class="literal">:x</code>. Having obtained <code class="literal">:x</code>, you can go on to evaluate this also, giving the value of <code class="literal">x</code>, namely, 1:</p><a id="I_programlisting11_d1e13917"/><pre class="programlisting"># Test 3
amethod( xsymbol )                                      #=&gt; :x
amethod( :xsymbol )                                     #=&gt; :xsymbol
amethod( eval(:xsymbol.id2name))                        #=&gt; :x
amethod( eval( ( eval(:xsymbol.id2name)).id2name ) )    #=&gt; 1</pre><p>As you’ve seen, when used to create attribute accessors, symbols can refer to method names. You can make use of this by passing a method name as a symbol to the <code class="literal">method</code> method and then calling the specified method using the <code class="literal">call</code> method:<a id="IDX-CHP-11-0021" class="indexterm"/><a id="IDX-CHP-11-0022" class="indexterm"/></p><a id="I_programlisting11_d1e13933"/><pre class="programlisting">#Test 4
method(:amethod).call("")</pre><p>The <code class="literal">call</code> method lets you pass arguments, so, just for the heck of it, you could pass an argument by evaluating a symbol:</p><a id="I_programlisting11_d1e13940"/><pre class="programlisting">method(:amethod).call(eval(:x.id2name))</pre><p>If this seems complicated, take a look at a simpler example in <span class="emphasis"><em>symbols_3.rb</em></span>. This begins with this assignment:</p><p><span class="emphasis"><em>symbols_3.rb</em></span></p><a id="I_programlisting11_d1e13951"/><pre class="programlisting">def mymethod( somearg )
   print( "I say: " &lt;&lt; somearg )
end

this_is_a_method_name = method(:mymethod)</pre><p>Here <code class="literal">method(:mymethod)</code> looks for a method with the name specified by the symbol passed as an argument (<code class="literal">:mymethod</code>), and if one is found, it returns the Method object with the corresponding name. In my code I have a method called <code class="literal">mymethod</code>, and this is now assigned to the variable <code class="literal">this_is_a_method_name</code>.<a id="IDX-CHP-11-0023" class="indexterm"/><a id="IDX-CHP-11-0024" class="indexterm"/><a id="IDX-CHP-11-0025" class="indexterm"/><a id="IDX-CHP-11-0026" class="indexterm"/><a id="IDX-CHP-11-0027" class="indexterm"/></p><p>When you run this program, you will see that the first line of output prints the value of the variable:</p><a id="I_programlisting11_d1e13993"/><pre class="programlisting">puts( this_is_a_method_name )  #=&gt; #&lt;Method: Object#mymethod&gt;</pre><p>This shows that the variable <code class="literal">this_is_a_method_name</code> has been assigned the method, <code class="literal">mymethod</code>, which is bound to the Object class (as are all methods that are entered as “freestanding” functions). To double-check that the variable really is an instance of the Method class, the next line of code prints out its class:</p><a id="I_programlisting11_d1e14003"/><pre class="programlisting">puts( "#{this_is_a_method_name.class}" )  #=&gt; Method</pre><p>Okay, so if it’s really and truly a method, then you should be able to call it, shouldn’t you? To do that, you need to use the <code class="literal">call</code> method. That is what the last line of code does:</p><a id="I_programlisting11_d1e14010"/><pre class="programlisting">this_is_a_method_name.call( "hello world" )  #=&gt;I say: hello world</pre></div>
<div class="sect1" title="Why Use Symbols?"><div class="titlepage"><div><div><h1 class="title"><a id="why_use_symbols_question"/>Why Use Symbols?</h1></div></div></div><p>Some methods in the Ruby class library specify symbols as arguments. Naturally, if you need to call those methods, you are obliged to pass symbols to them. Other than in those cases, however, there is no absolute requirement to use symbols in your own programming. For many Ruby programmers, the “conventional” data types such as strings and integers are perfectly sufficient. However, many Ruby programmers do like to use symbols as the keys into hashes. When you look at the Rails framework in <a class="xref" href="ch19.html" title="Chapter 19. Ruby on Rails">Chapter 19</a>, for example, you will see examples similar to the following:</p><a id="I_programlisting11_d1e14019"/><pre class="programlisting">{ :text =&gt; "Hello world" }</pre><p>Symbols do have a special place in “dynamic” programming, however. For example, a Ruby program is able to create a new method at runtime by calling, within the scope of a certain class, <code class="literal">define_method</code> with a symbol representing the method to be defined and a block representing the code of the method:<a id="IDX-CHP-11-0028" class="indexterm"/></p><p><span class="emphasis"><em>add_method.rb</em></span></p><a id="I_programlisting11_d1e14032"/><pre class="programlisting">class Array
    define_method( :aNewMethod, lambda{
        |*args| puts( args.inspect)
    } )
end</pre><p>After the previous code executes, the Array class will have gained a method named <code class="literal">aNewMethod</code>. You can verify this by calling <code class="literal">method_defined?</code> with a symbol representing the method name:<a id="IDX-CHP-11-0029" class="indexterm"/></p><a id="I_programlisting11_d1e14045"/><pre class="programlisting">Array.method_defined?( :aNewMethod )   #=&gt; true</pre><p>And, of course, you can call the method itself:</p><a id="I_programlisting11_d1e14049"/><pre class="programlisting">[].aNewMethod( 1,2,3     #=&gt; [1,2,3]</pre><p>You can remove an existing method at runtime in a similar way by calling <code class="literal">remove_method</code> inside a class with a symbol providing the name of the method to be removed:<a id="IDX-CHP-11-0030" class="indexterm"/></p><a id="I_programlisting11_d1e14060"/><pre class="programlisting">class Array
    remove_method( :aNewMethod )
end</pre><p>Dynamic programming is invaluable in applications that need to modify the behavior of the Ruby program while that program is still executing. Dynamic programming is widely used in the Rails framework, for example, and it is discussed in depth in the final chapter of this book.</p><div class="sidebar"><a id="digging_deeper-id10"/><p class="title">Digging Deeper</p><p>Symbols are fundamental to Ruby. Here you will learn why that is so and how you can display all the symbols available.<a id="IDX-CHP-11-0031" class="indexterm"/><a id="IDX-CHP-11-0032" class="indexterm"/><a id="IDX-CHP-11-0033" class="indexterm"/><a id="IDX-CHP-11-0034" class="indexterm"/><a id="IDX-CHP-11-0035" class="indexterm"/></p><p><span class="bolditalic">What Is a Symbol?</span></p><p>Previously, I said that a symbol is an identifier whose value is itself. That describes, in a broad sense, the way that symbols behave from the point of view of the Ruby programmer. But it doesn’t tell you what symbols are <span class="emphasis"><em>literally</em></span> from the point of view of the Ruby interpreter. A symbol is, in fact, a pointer into the symbol table. The symbol table is Ruby’s internal list of known identifiers—such as variable and method names.</p><p>If you want to take a peek deep inside Ruby, you can display all the symbols that Ruby knows about like this:</p><p><span class="emphasis"><em>allsymbols.rb</em></span></p><a id="I_programlisting11_d1e14105"/><pre class="programlisting">p( Symbol.all_symbols )</pre><p>This will shows thousands of symbols including method names such as <code class="literal">:to_s</code> and <code class="literal">:reverse</code>, global variables such as <code class="literal">:$/</code> and <code class="literal">:$DEBUG</code>, and class names such as <code class="literal">:Array</code> and <code class="literal">:Symbol</code>. You may restrict the number of symbols displayed using array indexes like this:</p><a id="I_programlisting11_d1e14128"/><pre class="programlisting">p( Symbol.all_symbols[0,10] )</pre><p>In Ruby 1.8, you can’t sort symbols since symbols are not considered to be inherently sequential. In Ruby 1.9, sorting is possible, and the symbol characters are sorted as though they were strings:</p><a id="I_programlisting11_d1e14132"/><pre class="programlisting"># In Ruby 1.9
p [:a,:c,:b].sort       #=&gt; [:a,:b,:c]

# In Ruby 1.8
p [:a,:c,:b].sort       #=&gt; 'sort': undefined method '&lt;=&gt;' for :a:Symbol</pre><p>The easiest way to display a sorted list of symbols in a way that avoids incompatibility problems related to Ruby versions is to convert the symbols to strings and sort those. In the following code, I pass all the symbols known to Ruby into a block, convert each symbol to a string, and collect the strings into a new array that is assigned to the <code class="literal">str_array</code> variable. Now I can sort this array and display the results:<a id="IDX-CHP-11-0036" class="indexterm"/></p><a id="I_programlisting11_d1e14145"/><pre class="programlisting">str_arr = Symbol.all_symbols.collect{ |s| s.to_s }
puts( str_arr.sort )</pre></div></div></body></html>