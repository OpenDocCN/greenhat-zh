- en: Chapter 16. Network Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working behind scenes,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*taking care of vital things,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the daemon is here.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) The OpenBSD base system
    includes several servers to support a network. This chapter covers the following
    network servers:'
  prefs: []
  type: TYPE_NORMAL
- en: Small-server handler `inetd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printer daemon `lpd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHCP daemon `dhcpd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TFTP daemon `tftpd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMP agent `snmpd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH server `sshd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This miscellany of small daemons supports the features covered in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The inetd Small-Server Handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inetd(8)` “super-server” handles incoming network requests for network
    services that aren’t used very often. After all, many systems don’t have a steady
    stream of incoming FTP requests, so why have an FTP daemon running constantly?
    Instead, `inetd` listens for incoming network requests, and when an FTP request
    arrives, it starts the FTP server and feeds it the request. Other common services
    that frequently (but not always) run through `inetd` include ident, finger, and
    TFTP. Many of these services can also run standalone, if the application usage
    warrants it.
  prefs: []
  type: TYPE_NORMAL
- en: '`inetd` also handles functions so small and rarely used that they’re easier
    to implement within `inetd` itself, rather than by calling a separate program.
    These functions include `discard` (which dumps any data received into the bottomless
    pit of */dev/null*), `chargen` (which pours out a stream of characters), and `echo`
    (which repeats whatever you send to it). Most of these services are not needed
    on the modern Internet and are disabled by default, but you have access to them
    if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring inetd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You configure `inetd` in */etc/inetd.conf*. Here’s the default `inetd` configuration
    for OpenBSD’s FTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you’ll notice is that these entries are commented out. OpenBSD’s
    default `inetd` offers only the identity server `identd(8)` and two time services
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: The first field is the service name (`ftp` in this case) **1**. The name in
    this field must match a name in */etc/services*. The `inetd` program uses the
    *services* file to perform a service lookup to identify which ports it must listen
    on. To change the TCP/IP port that your FTP server runs on, change the port for
    FTP in */etc/services*. (You could also change the first field to use the name
    of the service that usually runs on the desired port, but I find starting my FTP
    server entry with the wrong name just gives me a headache.)
  prefs: []
  type: TYPE_NORMAL
- en: The second field is the socket type (`stream` in this case) **2**. This field
    dictates what sort of connection this is. All TCP connections are of type `stream`,
    and UDP connections are of type `dgram`. The `inetd` program does support other
    types of connections, but they’re rarely used. If you’re considering using them,
    either you’re reading the documentation for a piece of software that needs that
    type of connection or you’re wrong (probably the latter).
  prefs: []
  type: TYPE_NORMAL
- en: The third field is the layer 4 network protocol, usually `tcp` **3**, `udp`,
    `tcp6`, or `udp6`. If you want to offer a service over both IPv4 and IPv6, you
    need a separate entry for each. That’s why there are two otherwise identical configurations
    for the FTP server. The `inetd` program also supports RPC services, which have
    type `rpc/udp` or `rpc/tcp`.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth field (`nowait` in this case) **4** indicates whether `inetd` should
    wait for the server program to close the connection or just start the program
    and go away. As a general rule, TCP-based daemons use `nowait`, and UDP-based
    daemons use `wait`. (There are rare exceptions.)
  prefs: []
  type: TYPE_NORMAL
- en: The fifth field (`root` in this case) **5** names the user that the server daemon
    runs as. Many `inetd`-using programs must run as root, as they can affect multiple
    users or accept more specific logins, but some smaller programs have dedicated
    unprivileged users.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth field is the full path to the server program `inetd` runs when a connection
    request arrives **6**. Services implemented within `inetd` have a path of `internal`.
    The FTP server is at */usr/libexec/ftpd*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last field gives the command to start the server program, including
    any command-line arguments you want. This configuration runs the FTP server with
    the arguments `-US` **7**.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting Incoming Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Script kiddies occasionally try to knock a server off the Internet by sending
    it more connection requests than it can handle. The `inetd` program accepts up
    to 256 connections per minute per service. If a service receives too many connection
    requests, `inetd` logs the issue and stops answering requests for that service
    for 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IPv4 and IPv6 versions are limited separately, so you could accept 512 FTP
    connections per second if the requests are evenly divided between protocol families.
    You can override this globally with a command-line flag when starting `inetd`,
    or you can configure this on a per-service basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-R` flag controls how many connections per minute and per service that
    `inetd` accepts. For example, to accept 1000 requests per minute, you would set
    the following in */etc/rc.conf.local*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set per-service limits by editing the `wait/nowait` field in the service’s
    *inetd.conf* entry. Add a dot to the `wait` or `nowait` entry, followed by the
    number of times per minute you want to allow the service to be called. For example,
    if you have an FTP server that should be used by only a few of your friends, you
    could limit the server to 10 requests per minute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, if more than 10 connection requests arrive in one minute, `inetd` stops
    servicing FTP requests for ten minutes. An attacker could still use this to knock
    your FTP service offline, but not to knock the entire server offline. At least
    this way you get to choose your failure mode and when you reach it.
  prefs: []
  type: TYPE_NORMAL
- en: The lpd Printing Daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenBSD includes the `lpd(8)` printing daemon common on Unix-like operating
    systems. The `lpd` daemon has options to support thousands of different printers,
    but getting the right mix of options to support any one specific printer can be
    a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to use a printer on OpenBSD is through a PostScript server,
    and that’s the method I’ll cover here. Many modern printers, particularly the
    popular multifunction fax/scanner/printer combinations, support PostScript, and
    you’ll find that every office print server does, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every printer your system knows about needs an entry in */etc/printcap*, the
    printer capability database. This is another `termcap(5)`-style configuration
    file. You don’t need to know everything about the printer to change settings here.
    This entry just needs the hostname or IP address of the print server and the print
    server’s name for the printer you want to access. Then use the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line gives the printer’s names. Every printer can have any number
    of names, separated by the pipe (`|`) symbol. The default printer on a Unix-like
    system is named `lp`, so be sure that one of the printers has that name attached
    to it. Another name should be the one used by the print server for this printer
    (such as `Billing`). (Microsoft print servers frequently share one printer under
    several different names, and each name prints differently, so be sure to use the
    name that represents the PostScript facility.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The other lines list attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `lpd` precedes each print job with a page giving the job name, number,
    host, and other identifying information. This used to be important when people
    paid for printing by the page, but unless you’re in an environment with a single,
    massive printer, this probably wastes paper. The `:sh:=\` entry suppresses this
    page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:rm=` attribute gives the hostname or IP address of the print server. You
    must be able to ping the print server by this name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing works best if each printer has a unique spool directory, given by the
    `:sd=` attribute. The printer daemon stores documents en route to the print server
    here. This directory must be owned by the user root and the group daemon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several printers can share a common log file, shown by the `:lf=` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, specify the remote printer name with the `:rp=` attribute. This last
    attribute is the only one that doesn’t end with a backslash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always end */etc/printcap* with a newline. I usually use an entire blank line,
    just to be certain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a printer configuration, you start `lpd` at boot with this
    *rc.conf.local* entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Restart `lpd` with `/etc/rc.d/lpd restart` any time you edit */etc/printcap*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, view the print queue with `lpq(1)`, and watch */var/log/lpd-errs* for
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: The DHCP Server dhcpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DHCP is the standard method for dynamically configuring clients on an IP network.
    You might know DHCP as a way to give computers basic IP information, but it can
    also hand out configuration files for embedded devices such as routers and phones,
    point diskless machines to their kernel and userland, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes a heavily modified ISC DHCP server, `dhcpd(8)`. Here, we’ll
    cover the basics of using `dhcpd` for configuring dynamic clients in a shared
    Ethernet system. In [Chapter 23](ch23.html "Chapter 23. Customizing OpenBSD"),
    we’ll discuss the details of using DHCP to configure diskless workstations.
  prefs: []
  type: TYPE_NORMAL
- en: How DHCP Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A client seeking DHCP information broadcasts a request across the local network
    asking for someone—*anyone*—to give it a network configuration. If your DHCP server
    is on that Ethernet segment, it answers directly. If it’s on another network segment,
    the router for that network segment can forward the DHCP request to your server,
    which will then offer a configuration to the client, maintaining a list of which
    clients have been assigned which unique configuration values (such as IP addresses).
    A configuration issued to a client is called a *lease*. Like all leases, DHCP
    leases expire and must be renewed in order to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: Clients can request certain DHCP features to support their operations. For example,
    Microsoft clients request the IP addresses of the network Windows Internet Name
    Service (WINS) servers, Voice over IP (VoIP) desktop phones request their configuration
    file, and diskless systems (discussed in [Chapter 23](ch23.html "Chapter 23. Customizing
    OpenBSD")) ask where to find their kernel and userland. The DHCP server can offer
    this information, or not.
  prefs: []
  type: TYPE_NORMAL
- en: The DHCP server uniquely identifies each client by the MAC address of the network
    card it uses to connect to the network. To find out what information a client
    received from the DHCP server, get the client’s MAC address and search for it
    in the */var/db/dhcpd.lease* file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dhcpd(8)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configure `dhcpd` in */etc/dhcpd.conf*. The default *dhcpd.conf* file includes
    a sample configuration suitable for a small office environment, as well as a diskless
    client sample configuration.
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to assume that you’re running a single DHCP server on your network,
    and that this server is authoritative for DHCP services. (OpenBSD’s DHCP server
    also supports clustering for fault tolerance.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before configuring `dhcpd` to configure clients dynamically, you’ll need a
    few facts about your network:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP network and netmask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range of IP addresses in the network used for DHCP clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have this information, you can assemble a brief *dhcpd.conf*. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All hosts that get their configuration from this host are told that their domain
    name is *blackhelicopters.org* **1**, and that they should use the name servers
    192.0.2.5 and 192.0.2.10 **2**. The client can be configured to ignore or override
    this DHCP configuration, but you can’t prevent local sysadmins from hanging themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Each subnet needs its own configuration. Even if you have only one subnet, you
    must still have a `subnet` statement defining the IP network for that subnet so
    that `dhcpd` can determine which clients get which configuration. This example
    defines the configuration for clients on the network at 198.51.100.0/24 **3**.
    Everything inside the brackets that follow applies only to hosts on this subnet.
  prefs: []
  type: TYPE_NORMAL
- en: The `routers` option at **4** identifies the default gateway for this network.
    Because the `dhcpd` server won’t let you define additional static routes to feed
    to clients, your local network router must have proper routes to reach the destination.
    If you have multiple gateways on your local network, your default router should
    send an ICMP redirect to the DHCP client to correct its routing. (You don’t unilaterally
    block ICMP from your firewalls, do you?)
  prefs: []
  type: TYPE_NORMAL
- en: The `range` keyword gives the IP addresses that the DHCP server can assign to
    clients. In this example, the DHCP server controls the addresses 198.51.100.51
    to 198.51.100.100, inclusive **5**. If 52 dynamic clients connect simultaneously,
    the last client won’t get an address.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration should get your clients on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Static IP Address Assignments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can tell your DHCP server to assign a specific address to specific hosts
    by specifying the Ethernet address of the client in the configuration and using
    a stanza within the `subnet` statement. Here’s the earlier DHCP configuration
    with a static entry added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I’ve found the MAC address of my workstation, and used it to assign a static
    IP address to that machine. This client machine inherits the default router from
    the subnet definition, as well as any default DHCP information.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling dhcpd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enable `dhcpd` in *rc.conf.local*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have only one network-facing interface, `dhcpd` will automatically listen
    for DHCP requests on that interface. If you have multiple interfaces, give the
    interface name as an argument. For example, here’s how to tell `dhcpd` to listen
    for requests only on the interface `fxp1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The interface name must be the last `dhcpd` argument in *rc.conf.local*. If
    `dhcpd` needs to handle several interfaces, the list of interfaces must come after
    any other arguments in `dhcpd_flags`.
  prefs: []
  type: TYPE_NORMAL
- en: dhcpd and Firewalls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OpenBSD packet filtering system includes *tables*, which are lists of IP
    addresses that the packet filter applies rules to. Traffic from IP addresses in
    tables can be blocked, have its bandwidth throttled or prioritized, or be allowed
    to pass. Each table has a unique name.
  prefs: []
  type: TYPE_NORMAL
- en: The `dhcpd` server can add addresses to packet filter tables, thereby dynamically
    changing the firewall rules depending on whether an IP address is leased. Here,
    we’ll look at configuring `dhcpd` to give addresses to the packet filter tables.
    [Chapter 21](ch21.html "Chapter 21. Packet Filtering") discusses how to configure
    the packet filter to handle addresses from `dhcpd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'DHCP considers IP addresses in its address pool to be in one of three states:
    leased, abandoned, or changed. *Leased* addresses are addresses assigned to a
    host attached to the network. Use `-L` to give `dhcpd` the name of the packet
    filter table for leased addresses, and then configure the packet filter to allow
    or deny those addresses access to the rest of the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Abandoned* addresses are ones that have been assigned to a host, but that
    are not currently in use. In practice, that means that if you shut down your laptop,
    the DHCP server will consider the IP address assigned to it abandoned. The problem
    with that is that unauthorized users might try to get on the network by taking
    an unused address from the address pool, without going through the DHCP server.
    To address this problem, give the packet filter the list of addresses not in use,
    and give illicit network hosts their own special packet filter rules. Use the
    `-A` argument to tell `dhcpd` the name of the packet filter table for abandoned
    addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: If a host changes its address despite the DHCP server’s configuration instructions,
    the DHCP server considers the address *changed*, and `dhcpd` can add its new address
    to the changed address table. Use the `-C` argument to tell `dhcpd` the name of
    the changed address table. (In [Chapter 21](ch21.html "Chapter 21. Packet Filtering"),
    we’ll do something interesting with these tables.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static IP address assignments do not go into tables. If you assign a static
    address to a host, you must manually configure firewall rules for that address.
  prefs: []
  type: TYPE_NORMAL
- en: The TFTP Daemon tftpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Trivial File Transfer Protocol (TFTP) is used to transfer files across a
    network. Unlike FTP, TFTP doesn’t include authentication. Anyone who can access
    the TFTP server can upload or download files from it.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP is an inflexible protocol. It doesn’t work through network address translation
    without a proxy or some kind of intelligence within the translation device, and
    there’s no interactive session as there is with FTP and SFTP. TFTP is most commonly
    used to copy configuration files and operating system images for embedded devices
    such as routers.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD uses TFTP to bootstrap diskless systems, as discussed in [Chapter 23](ch23.html
    "Chapter 23. Customizing OpenBSD").
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a tftpd Directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD’s `tftpd(8)` serves files from a directory, much like a web server.
    Traditionally, this directory is */tftpboot*, but don’t follow tradition in this
    case (you don’t want a TFTP user filling your server’s root partition!). If you
    use */tftpboot* on your root partition, make sure that your TFTP clients can’t
    write to the directory. (You could create a */tftpboot* partition.) Normally,
    I create */var/tftpboot* and tell `tftpd` to use that as its root directory. If
    your fingers are used to typing `/tftpboot`, create a symlink.
  prefs: []
  type: TYPE_NORMAL
- en: To enable `tftpd`, set `tftpd_flags` in *rc.conf.local* to the TFTP root directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`tftpd` `chroot`s to the directory you specify, so `tftpd` cannot access files
    outside this directory.'
  prefs: []
  type: TYPE_NORMAL
- en: tftpd and Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TFTP uses file permissions as an access control method. Because all files on
    the TFTP server can be read by anyone who can access the server port, TFTP will
    let clients read files in its root directory only if they are world-readable.
    To make them world-readable, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `tftpd` will not allow anyone to upload a file unless a file of that
    name already exists and is world-writable. This means that anyone who knows a
    file’s name can overwrite it, so make vital files read-only. If an attacker can’t
    write files, he can’t fill your hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: To create files via TFTP, so that you can upload files that don’t already exist,
    run `tftpd` with the `-c` option.
  prefs: []
  type: TYPE_NORMAL
- en: '`tftpd` starts as root in order to bind UDP port 69, but it then drops privileges
    and runs as the unprivileged user `_tftpd`. Any files `tftpd` created will be
    owned by its user. As a general rule, the files in the TFTP root directory should
    not be owned by `_tftpd`, in order to make sure that the server cannot affect
    the files it serves.'
  prefs: []
  type: TYPE_NORMAL
- en: tftpd Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should log your TFTP transfers. Use the `-v` flag to send the transaction
    log to `syslogd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`tftpd` logs uses the FTP facility to log messages to */var/log/daemon*.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the TFTP Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `tftp(1)` to test your TFTP server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You won’t see any friendly hash marks as you download the file, and you can’t
    change to another directory or list the contents of the TFTP server. Once the
    test is complete, use `quit` to end your TFTP session.
  prefs: []
  type: TYPE_NORMAL
- en: After you have a TFTP client and server set up, you’ll be ready to serve diskless
    OpenBSD machines, router operating system images, or anything else you need.
  prefs: []
  type: TYPE_NORMAL
- en: The SNMP Agent snmpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SNMP is the de facto standard for gathering information from network devices.
    Many different devices from many different vendors support SNMP as a management
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes an SNMP agent, `snmpd(8)`, which supports all of the usual
    SNMP functions, and also offers visibility into OpenBSD-specific features such
    as packet filtering.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP works according to the standard client/server model. The SNMP client (usually
    a server performing network management or monitoring) queries the SNMP server
    (or *agent*) running on a network device. The SNMP agent, `snmpd`, gathers information
    from the local system and returns it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional SNMP, an SNMP client with the correct privileges can also request
    that the SNMP agent modify its device. Most Unix-like operating systems are designed
    to be configured at the command line and generally don’t accept write requests
    from SNMP. OpenBSD follows this trend, and we will focus specifically on read-only
    SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to having an SNMP agent answer requests from an SNMP client, the
    agent can transmit SNMP traps to a *trap receiver* somewhere on the network. SNMP
    traps are much like `syslogd(8)` messages, except that they follow a specific
    format required by SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD does not include an SNMP trap receiver. If you need one, check out `snmptrapd`
    in the `net-snmp` package.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP MIBs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SNMP manages information via a Management Information Base (MIB), which is a
    tree-like structure that contains hierarchical information in ASN.1 format. Each
    SNMP agent has a list of information it can extract from the local system, arranged
    in a hierarchical SNMP MIB with very general main categories, such as network,
    physical, programs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the MIB tree as a well-organized filing cabinet, where individual drawers
    hold specific information, and files within drawers hold particular facts. Similarly,
    the uppermost MIB contains a list of MIBs beneath it.
  prefs: []
  type: TYPE_NORMAL
- en: MIB References
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MIBs can be referred to by name or number. For example, here’s a MIB pulled
    from an OpenBSD test machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first term in this MIB, `interfaces`, tells us that we’re looking at this
    machine’s network interfaces. If this machine had no interfaces, this category
    would not even exist (although an OpenBSD machine will always have at least a
    loopback interface). The `ifTable` is the *interface table*, which is a list of
    all network interfaces on the system. The field `ifEntry` shows one particular
    entry, and `ifDescr` means that we’re looking at a description of this interface.
    This MIB could be expressed as “Interface number 1 on this machine is called `em0`.”
  prefs: []
  type: TYPE_NORMAL
- en: 'MIBs can also be expressed as numbers, and most SNMP clients do their work
    natively in numerical MIBs. Your management tool should be able to translate between
    numbers and names, but just so you’re not terribly surprised, here’s the earlier
    example in numerical form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Expressed in words, this MIB has five parts separated by dots. Expressed in
    numbers, the MIB has 11 parts. Aren’t they supposed to be the same thing? Well,
    the numerical MIB is longer because it includes the default address .1.3.6.1.2.1,
    which translates to *.iso.org.dod.internet.mgmt.mib-2*, the standard subset of
    MIBs used on the Internet. Most SNMP MIBs start with this string, so the management
    tools no longer bother printing out this name.
  prefs: []
  type: TYPE_NORMAL
- en: MIB Definitions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'OpenBSD supports two groups of MIBs:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard host MIBs, which every network management system understands. This
    information includes network and disk space utilization, software running on the
    system, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIBs for OpenBSD-specific functions, such as the packet filter, network failover,
    bridging, and so on. Most network management systems will not understand the OpenBSD-specific
    MIBs out of the box, so you’ll want to teach your management system about OpenBSD’s
    MIBs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIBs are defined according to a very strict syntax documented in MIB files.
    For example, `snmpd` includes MIB files for the OpenBSD-specific functions in
    */usr/share/snmp/mibs*. These files are written in plaintext, in the very stilted
    and formal ASN.1 syntax. While you can read and interpret them with nothing more
    than your brain, I highly recommend copying them to your network management workstation
    and using an SNMP client to examine them.
  prefs: []
  type: TYPE_NORMAL
- en: MIB browsers interpret MIB files and present them in their full tree-like splendor,
    complete with definitions of each part of the tree and descriptions of each MIB,
    taken from the MIB files. Generally speaking, you enter a MIB in the MIB browser,
    which displays its numerical and word descriptions, and offers the ability to
    query an SNMP agent for that MIB.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t already have a MIB browser on your OpenBSD workstation, use the
    `mbrowse` package. If you don’t want a graphical interface, use the `net-snmp`
    package for a full assortment of command-line SNMP client tools, but be prepared
    to type some long command lines.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common alternate acronym for SNMP is “Security? Not My Problem!” This
    is unkind, but true. You should use SNMP only behind firewalls or on trusted networks.
    If you must use SNMP on the naked Internet, employ packet filtering to keep the
    public from querying your SNMP service. SNMP agents run on UDP port 161, so allow
    your management hosts access to that port on only your SNMP hosts.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP provides basic security through *communities*. If you read the SNMP documentation,
    you’ll see all kinds of explanations of why a community is not the same as a password,
    but as far as a sysadmin is concerned, a community is a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most SNMP agents have two communities by default: `public` (read-only access)
    and `private` (read-write access). OpenBSD’s `snmpd` daemon supports both of these
    communities by default. One of your first tasks will be to change these community
    names to something that the whole world doesn’t know. Just like passwords, community
    names should be hard for intruders to guess and easy for you to remember.'
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, there have been various versions of SNMP. Version 1 was
    the first attempt. Version 2c (SNMPv2c) is the more commonly deployed update.
    Version 3 (SNMPv3) uses encryption to protect data on the wire, and it includes
    strong authentication. In practice, few vendors actually use it because it’s very
    complicated. The `snmpd` daemon has partial support for SNMPv3\. Here, we’ll focus
    on the completely supported SNMPv2c.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring snmpd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configure `snmpd` in */etc/snmpd.conf*. The configuration format is a series
    of text statements. Defining new community strings overrides the defaults of `public`
    and `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining new read-only and read-write community strings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In general, most `snmpd` configuration statements look like these two. The `snmpd.conf(5)`
    man page lists all valid *snmpd.conf* configuration statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every SNMP system is expected to list a contact, a description, and a location,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Many network management systems will automatically pull in this information
    to populate the database. Here, I’ve defined these values for my system. Make
    similar entries for your system.
  prefs: []
  type: TYPE_NORMAL
- en: The default *snmpd.conf* listens to only the localhost IP address, 127.0.0.1,
    so outside hosts cannot contact the SNMP daemon. If you want to listen on all
    available addresses, comment out the lines, like the following, that specify an
    address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can give an interface IP address to have `snmpd` listen to
    a specific external IP address for those machines with many addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, `snmpd` can provide information about your system.
    Enable it in */etc/rc.conf.local*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will start `snmpd` at boot, or you can run */etc/rc.d/snmpd*.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging snmpd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SNMP can be an annoying protocol to debug. For one, because it’s UDP, there’s
    no easy way to test connectivity to the agent. Also, it runs fairly silently,
    in that it doesn’t log queries.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that queries from your network management system are reaching your
    server, try running `snmpd` in verbose mode and with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When an SNMP query reaches your server, you should see the server parse the
    requests. By the same token, `snmpd` is very good about telling you why it can’t
    provide an answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Errors, like the following, that arise from requests for a nonexistent MIB are
    a little more difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the MIB request is trying to find the object identifier (OID) `iso.org.dod.internet.private.enterprises.2041`,
    but OpenBSD’s `snmpd` does not support that. (It does support `20`*`2`*`1`, part
    of the Net-SNMP MIB.) The SNMP client is requesting an invalid MIB.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows a successful request and the MIB that `snmpd` sends in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By reading the output carefully, you should be able to see why `snmpd` is not
    answering requests as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting snmpd Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most important feature of SNMP is that it lets you read statistics from
    the operating system and/or software. In addition to the usual features supported
    by SNMP, such as resource utilization and processes, `snmpd` lets you grab OpenBSD-specific
    system information. You can get information about the packet filter, sensor data,
    interface memory, and Command Address Redundancy Protocol (CARP). All of this
    appears under the .1.3.6.1.4.1.30155 MIB, OpenBSD’s private (enterprise) MIB tree.
  prefs: []
  type: TYPE_NORMAL
- en: The PF SNMP MIB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The OpenBSD packet filtering feature keeps a lot of statistics, and everything
    I’ve ever wanted is available through the PF MIB. You’ll find information such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether PF is on, and how long has it been running (in hundredths of a second)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of packets that have matched filter rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of fragments and reassembled packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of packets dropped because of memory problems, internal packet-filtering
    problems, overfilling the state tables, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of states added and removed from the state table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of timeouts of various protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of traffic blocked on each interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet filtering table usage, number of addresses in each table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there’s more. The PF SNMP MIB gives you more useful visibility into packet
    filtering. Point your MIB browser at the .1.3.6.1.4.1.30155.1 MIB to see everything.
  prefs: []
  type: TYPE_NORMAL
- en: Sensors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can view the same kernel values processed by `sensorsd(8)` (see [Chapter 15](ch15.html
    "Chapter 15. System Maintenance")) via `snmpd`, including a list of sensors on
    this device, the value reported by the sensor, and whether each sensor is in an
    alarm state. This means you can use `snmpd` instead of `sensorsd` to monitor your
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: To view sensor data via SNMP, examine the MIB tree .1.3.6.1.4.1.30155.2.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can view the amount of memory used by an interface, and how often (if ever)
    an interface was starved for memory as a result of system load. View the MIB tree
    .1.3.6.1.4.1.30155.5 to see these values.
  prefs: []
  type: TYPE_NORMAL
- en: CARP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'CARP is an OpenBSD invention for sharing one address between two or more machines.
    It was designed to provide highly available IP services. The `snmpd` daemon exposes
    CARP’s innards, including these items:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of each CARP interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CARP configuration values (preemption, `advskew`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of IPv4 and IPv6 packets received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of packets discarded for various reasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of times the host has become master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see the CARP MIB tree, view .1.3.6.1.4.1.30155.6.
  prefs: []
  type: TYPE_NORMAL
- en: Other MIBs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `snmpd` daemon is constantly being expanded. According to the MIB files,
    they’ve reserved space for IPsec and `relayd(8)`. Check */usr/share/snmp/mibs*
    for additional MIB files, and use your MIB browser to see what your specific version
    of OpenBSD supports. The OpenBSD team adds MIBs as they’re needed and as code
    is contributed. If you need IPsec MIBs, feel free to write and submit the code.
  prefs: []
  type: TYPE_NORMAL
- en: The SSH Server sshd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secure Shell (SSH) is a protocol for building encrypted tunnels between hosts.
    SSH is most commonly used for remote command-line access to a system, but you
    can use it as a generic wrapper around other protocols or even to build virtual
    private networks. One common use for SSH is to support secure file transfer protocol
    service, or SFTP, which doesn’t give you a shell prompt but does encrypt files
    and authentication information as they cross the network.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenBSD project supports OpenSSH, a freely licensed client and server. OpenSSH
    is the most widely deployed SSH server in the world, with roughly 97 percent market
    share, and is generally considered the standard SSH server. Entire books have
    been written about OpenSSH, including mine (*SSH Mastery,* Tilted Windmill Press,
    2012).
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes the OpenSSH server `sshd(8)`, the OpenSSH command-line client
    `ssh(1)`, and the SFTP client `sftp(1)`. We’ll focus on `sshd` here, since you
    can use any number of SSH clients. The ones I use most commonly are `ssh` (for
    Unix-like systems) and PuTTY (for Windows). For SFTP, I commonly use `sftp` (for
    Unix-like systems) and WinSCP (for Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Disabling sshd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless you specified otherwise during installation, OpenBSD starts `sshd` by
    default. If you don’t want `sshd` to run, disable it in */etc/rc.conf.local*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: SSH Host Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first time you start `sshd`, OpenBSD creates *host keys* in */etc/ssh*.
    These are sets of public and private keys that uniquely identify an SSH server.
    Each key file includes the word *key* in its name. When your client first connects
    to the SSH server, it presents a fingerprint summary of the server’s host key.
    If you tell the client to accept the key, the client will cache the server’s host
    key. If this key ever changes, the client warns the user that the server’s unique
    identity has changed, and that the user might be offering his login credentials
    to a different server. (Anyone who gets copies of the host keys can have another
    server masquerade as yours.) Be sure to back up your host keys, and protect them
    from theft.
  prefs: []
  type: TYPE_NORMAL
- en: sshd Network Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could change `sshd`’s behavior by adding command-line flags, but the most
    common way to reconfigure `sshd` is to edit the files in */etc/ssh*.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSH has many configuration options. The ones that are most commonly changed
    involve the network settings. You can control the port, IP address, and version
    of IP `sshd` listens to by editing the configuration file */etc/ssh/sshd_config*.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `Port` keyword specifies the TCP/IP port that `sshd` attaches to. The default
    is TCP port 22.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some people recommend using a port other than 22 to avoid password-guessing
    worms. Far better ways to protect your SSH server are to allow only public-key
    authentication or use a packet filter to allow logins from only selected hosts
    or networks.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddressFamily` keyword specifies the version of IP that `sshd` uses. The
    default is to use both IPv4 and IPv6, but you can restrict it to a specific protocol
    with the `inet` (IPv4) or `inet6` (IPv6) keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you can attach `sshd` to a specific IP address with the `ListenAddress`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: chrooting Users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Organizations commonly need to confine users to a particular directory or subset
    of directories. For example, many websites allow users command-line access over
    SSH so that they can edit their files and debug problems more easily, or even
    just SFTP access to their files. Those users should have access to their own directories,
    but not to other users’ files, or any other part of the system. One solution is
    to `chroot` the user in his home directory. If you have several users who need
    to access a shared directory, you can `chroot` all of them in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locking users in a directory involves three steps: choosing the directory to
    lock users into, populating that directory, and configuring `sshd` to `chroot`
    those users. To demonstrate, we’ll walk through an example of `chroot`ing the
    user `lasnyder` in his home directory, and give him command-line access, so he
    will be able to access only the programs in his `chroot`.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, specify the `chroot` directory with the `ChrootDirectory` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This works well if all of your users need to be locked into the same directory,
    but if you want users to have their own private directory, or if you want to specify
    a directory elsewhere on the filesystem, things get more complex.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH supports the `%%`, `%h`, and `%u` macros to represent home directories.
    If your `chroot` directory includes a literal `%`, use the `%%` macro to represent
    it. The server in this example has home directories on */disk%3/home*, so the
    `%%` macro is needed to escape the percent sign.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%u` macro expands to the user’s username. You could use this to give users
    a `chroot` some place other than their home directory (though I don’t know why
    you wouldn’t just give them a home directory in the desired location). Here, each
    user has a directory under */var/www*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you could lock each user in his home directory with the `%h` macro.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Wherever you lock a user, you must give that directory everything the user needs
    to function, since the user won’t be able to leave that directory to get a tool
    that he might need.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the chroot
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most programs, such as a shell, require at least a few device nodes, and the
    user must have a shell program to be able to run one. If a user has only SFTP
    access, you don’t need to do any special preparation of the `chroot`. OpenSSH’s
    SFTP server includes everything it needs. But if users have shell access, they
    need basic device nodes and a shell program.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, to give `lasnyder` what he needs, go to the `chroot` directory,
    create a *dev* directory, and then make the standard device nodes using `/dev/MAKEDEV`.
    You can remove the `console`, `klog`, `kmem`, `ksyms`, `mem`, and `xf86` devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to get the user a shell. Since programs running inside the shell
    cannot access any files outside the `chroot`, including shared libraries, any
    shell copied into a `chroot` must be statically linked. The included system shells
    are statically linked, and most shells in the ports tree can be built in static
    flavors.
  prefs: []
  type: TYPE_NORMAL
- en: Verify that a shell is statically linked with `file(1)`, and then create a *bin*
    directory inside the `chroot` and copy the shell there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, although a `chroot`ed user should not have write access to his own root
    directory, he needs a real home directory. The user’s home directory in */etc/passwd*
    is relative to the `chroot`; in other words, if a user’s home directory in */etc/passwd*
    is */home/lasnyder*, and the user is `chroot`ed to */home/lasnyder*, his personal
    files and dotfiles actually go in */home/lasnyder/home/lasnyder*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The user now has a command-line friendly jail cell on the system. Now we need
    to tell `sshd` to lock the user in it.
  prefs: []
  type: TYPE_NORMAL
- en: chrooting Specific Users
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Applying this `chroot` strategy to all of your users probably isn’t advisable—if
    nothing else, your sysadmins need unfettered system access to perform maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: To tell `sshd` to `chroot` specific users, either by name or by group, use the
    `Match` keyword at the end of *sshd_config*. Match lets you change `sshd`’s default
    behavior based on factors such as user and client IP address. (`Match` has many
    more functions; see `sshd_config(5)` for examples.)
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted to `chroot` only the user `lasnyder`, you could use
    `Match` to specify his username. Early in the configuration, you would have a
    `ChrootDirectory` statement that turns off `chroot` for most users. Then, at the
    end of the configuration, you would change the setting based on matching that
    username.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You could also `chroot` all users in a group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you have multiple `Match` terms, separate them with commas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Or, if most of your users are `chroot`ed, reverse the default and specifically
    de`chroot` your sysadmins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With careful configuration, you can restrict access to only the desired users.
  prefs: []
  type: TYPE_NORMAL
- en: SSH can do a whole lot more, such as securely eliminate passwords from your
    network. It’s worth your time to fully master this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD’s built-in services can help you hold your network together, and they
    provide all kinds of useful support infrastructure. Now that you know how to configure
    some of these built-in programs, let’s see how to use OpenBSD as a desktop.
  prefs: []
  type: TYPE_NORMAL
