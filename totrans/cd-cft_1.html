<html><head></head><body><div class="part" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_secret_life_of_code"/>Part II. THE SECRET LIFE OF CODE</h1></div></div></div><div class="partintro" xml:lang="en"><div/><p>This section investigates the art and craft of developing code—the daily activities of programming life. Although these topics aren't closely guarded secrets, you rarely hear expert discussion or see much written about them. Even so, mastering each practice is crucial if you want to write good programs; the code craftsman has a thorough understanding of all of these subjects.</p><p>We'll look at:</p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch07.html" title="Chapter 7. THE PROGRAMMER'S TOOLBOX">Chapter 7</a></span></dt><dd><p>A survey of the tools of our trade and how you should use them.</p></dd><dt><span class="term"><a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a></span></dt><dd><p>No code is complete until it has been proved fit for purpose; until it has been tested. Here we look at the techniques for doing so.</p></dd><dt><span class="term"><a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a></span></dt><dd><p>Dealing with the inevitable: How to find and remove bugs in your code.</p></dd><dt><span class="term"><a class="xref" href="ch10.html" title="Chapter 10. THE CODE THAT JACK BUILT">Chapter 10</a></span></dt><dd><p>"Building" code: The process of converting source code into executable programs.</p></dd><dt><span class="term"><a class="xref" href="ch11.html" title="Chapter 11. THE NEED FOR SPEED">Chapter 11</a></span></dt><dd><p>A look at the gory details of code optimization. What, why, when, and how.</p></dd><dt><span class="term"><a class="xref" href="ch12.html" title="Chapter 12. AN INSECURITY COMPLEX">Chapter 12</a></span></dt><dd><p>The thorny topic of software security—how to protect your code from willful abuse and malicious attack.</p></dd></dl></div><p>These are fundamental aspects of code construction. With the pressures and time constraints of the software factory, they are more than essential skills—they're survival tactics. With experience, they become second nature, so you can spend your precious time focusing on more pressing concerns: the architecture of your next system, the customer's changing requirements, and who's going to fetch your next cup of espresso.</p></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_programmer_apostrophy_s_toolbox"/>Chapter 7. THE PROGRAMMER'S TOOLBOX</h1></div><div><h3 class="subtitle"><i>Using Tools to Construct Software</i></h3></div></div></div><div class="epigraph"><p>Perilous to us all are the devices of an art deeper than we possess ourselves.</p><div class="attribution"><span>--<span class="attribution">J.R.R. Tolkien</span></span></div></div><p>To be a productive craftsman, you need a good set of tools. The contents of a plumber's toolbox will support him in whatever task he encounters, or else you wouldn't call him the next time your taps explode.</p><p>Not only the <span class="emphasis"><em>existence</em></span> but also the <span class="emphasis"><em>quality</em></span> of these tools is vital; a good craftsman can be let down by poor tools. If the compression valves are bad, there will be water everywhere, no matter how good your plumber is.</p><p>Of course, it's your <span class="emphasis"><em>use</em></span> of these tools that sets you apart as a master craftsman. The tools, by themselves, will achieve nothing. Before power tools, carpenters were perfectly able to craft exquisite furniture. The tools were more basic, but their skill with them produced things of beauty.</p><p>The same is true of programming. To do a good job, you need to be supported by an appropriate kit of tools; tools that you have confidence in, know how to use, and are fit for the jobs you'll encounter. It takes a skilled craftsman, good tools, <span class="emphasis"><em>and</em></span> mastery of those tools to craft great code.</p><p>This is serious stuff. How you use your tools can set you apart as a truly productive programmer. In extreme cases, these tools could provide the shortcut that determines your project's success or failure. The relentless pace of the software factory means that you should cling tightly to anything that will help you produce better code and produce it more quickly and reliably.</p><p>Other chapters cover issues that relate to particular tools. Here we'll broach the subject of <span class="emphasis"><em>software tools</em></span> as a whole. Programming is a discipline that simply can't do without tools. From day to day, we use tools without much of a thought, taking the compiler for granted in much the same way you'd take a can opener for granted—it's fine while it works, but as soon as it goes wrong (or you need to open an oddly shaped can) you're stuck, no matter how fancy the can opener is. A cheap, basic can opener that works is better than some pretentious contraption that doesn't.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_software_tool_exclamation"/>What Is a Software Tool?</h1></div></div></div><p>We use a wide range of tools to construct software; they are <span class="emphasis"><em>programs that build programs</em></span>—if that isn't too philosophical. Everything we use to create software is a tool of some form. Some tools help you write code. Some help you write <span class="emphasis"><em>good</em></span> code. Some help sort out the mess of code you just created.<a class="indexterm" id="IDX-CHP-7-0460"/><a class="indexterm" id="IDX-CHP-7-0461"/></p><p>They come in all shapes and sizes and work in different ways. Obviously, the platform and environment they inhabit is a factor, but they also differ in:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Complexity</strong></span></span></dt><dd><p>Some tools are elaborate environments with many, many features and incredible configurability. Some are minuscule utilities for a single task. Each approach has its pros and cons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A feature-rich tool is cool, when you've <span class="emphasis"><em>finally</em></span> learned how to get it to make coffee and bring you doughnuts at the same time. If the many magical features make it hard to use, then it's less helpful.</p></li><li class="listitem"><p>Simple tools are easier to learn; it's obvious what they do. You just end up with a lot of them, one for each task. But if you string them together, there are a lot of interface points, so they don't always work together seamlessly.</p></li></ul></div><p>Different tools have different scopes, performing everything from very specific tasks (searching files for text strings) to entire projects (a collaborative project management environment).</p></dd><dt><span class="term"><span class="strong"><strong>Frequency of use</strong></span></span></dt><dd><p>Some tools are used constantly; we can't live without them. Others are only dusted off once in a blue moon, but they're invaluable when you need them.</p></dd><dt><span class="term"><span class="strong"><strong>Interface</strong></span></span></dt><dd><p>Some tools have pretty <span class="emphasis"><em>graphical user interfaces (GUIs)</em></span>. Some are more basic, driven by a <span class="emphasis"><em>command-line interface (CLI)</em></span> and directing their output to a file. Which you prefer depends on how your brain is wired and what you're used to.<a class="indexterm" id="IDX-CHP-7-0462"/><a class="indexterm" id="IDX-CHP-7-0463"/><a class="indexterm" id="IDX-CHP-7-0464"/></p><p>Windows utilities tend to be graphical with no command-line access. The standard Unix utilities are the opposite, which makes them easier to automate and integrate into larger tools using scripts. The interface alters the way you harness a tool's power.</p></dd><dt><span class="term"><span class="strong"><strong>Integration</strong></span></span></dt><dd><p>Some tools fit into a larger toolchain, often subsumed in a graphical <span class="emphasis"><em>integrated development environment (IDE)</em></span>. Stand-alone command-line utilities tend to generate plaintext output in a format suitable as input to other tools, acting primarily as data filters.<a class="indexterm" id="IDX-CHP-7-0465"/><a class="indexterm" id="IDX-CHP-7-0466"/></p><p>Monolithic GUI interfaces can be very comfortable to use, and the integration can make you incredibly productive. On the other hand, they take time to set up just as you'd like them, and they seldom offer the full power of more manual command-line tools. But although they are incredibly powerful, the discrete Unix tools all have different cryptic interfaces that make them hard to use.</p></dd><dt><span class="term"><span class="strong"><strong>Cost</strong></span></span></dt><dd><p>There are many excellent free tools.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-1" id="CHP-7-FN-1">1</a>]</sup> However, you often get what you pay for. Free tools tend to have have poorer documentation, less support, or a smaller feature set. This doesn't always hold true, though. Some free tools are far superior to their commercial counterparts.</p><p>You can pay as much as you want for any type of tool, but a higher price tag doesn't guarantee a better product. I've worked with some fantastically expensive tools that were spectacularly poor. Which leads on to . . .</p></dd><dt><span class="term"><span class="strong"><strong>Quality</strong></span></span></dt><dd><p>Some tools are really good. Some tools are really bad. I have a couple of critical tools that I'd gladly never see again; they do the job, but only barely, and are permanently on the brink of a crash. But without them, I can't produce the code I get paid for. How often have I been tempted to rewrite them myself ? I can keep on dreaming.</p></dd></dl></div><p>You'll pick tools based on these characteristics, making appropriate compromises. Although it's important to get accustomed to your usual tool set, to learn it and to be productive with it, avoid the temptation to become religious about it. Most Windows users despise Unix-style development, while Unix hackers look down on Windows coders because they can't handle the command line. Get over it.<a class="indexterm" id="IDX-CHP-7-0467"/></p><p>I challenge you to try working in a different environment on a reasonably large project. It will help you fully understand what makes a good toolchain and help you gain a real "world view" of software tools.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-1" id="ftn.CHP-7-FN-1">1</a>] </sup><span class="emphasis"><em>Free</em></span> has two meanings in the software world: free as in <span class="emphasis"><em>beer</em></span> (the tool won't cost you anything to obtain) and free as in <span class="emphasis"><em>speech</em></span> (open source software whose code you can view and modify). Which <span class="emphasis"><em>free</em></span> is more important depends on how much of an idealist you are. See "<a class="xref" href="ch18s06.html#licenses" title="LICENSES">LICENSES</a>" on page 361.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="why_worry_about_tools_question"/>Why Worry About Tools?</h1></div></div></div><p>It's impossible to create programs without a core set of software tools; you'd be stuck without an editor or compiler. There are other tools that you <span class="emphasis"><em>can</em></span> get by without, but that are still genuinely useful. In order to improve your productivity, code quality, and craftsmanship, it's good to pay a little attention to the tools you're currently using and find out what they can really do.<a class="indexterm" id="IDX-CHP-7-0468"/></p><p>When you understand how your tools work and which tool to use for which job, you are better able to produce code that works properly—and produce it more quickly. Smarter tool use will make you a smarter programmer.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Know your common tools inside out. A little time invested to become proficient with them will quickly pay off</em></span>.</p></dd></dl></div><p>Let's be clear about why we actually use tools: Tools don't do our work <span class="emphasis"><em>for us</em></span>—they <span class="emphasis"><em>enable</em></span> us to do our work. The quality of software is always determined by the competence of its programmer. Remind yourself of that the next time your compiler spits out pages of error messages. You wrote the code, dimwit!</p><p>Programmers have wildly varying attitudes with regard to selecting and using tools. There's probably some deep psychological reasoning behind it all—something to do with whether you're an Evil Genius or not. On encountering a new lengthy task:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Some programmers laboriously complete it by hand.</p></li><li class="listitem"><p>Others write a tool in a scripting language to do the job automatically.</p></li><li class="listitem"><p>Others spend hours searching for a pre-written tool to do the job for them.</p></li></ul></div><p>Given a tool that <span class="emphasis"><em>might</em></span> solve the problem:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Some programmers fiddle with it until they get something near enough to what they want.</p></li><li class="listitem"><p>Others carefully read the documentation to find out exactly what can be done and <span class="emphasis"><em>then</em></span> start to use it.</p></li></ul></div><p>Which the right approach? Well, it depends. Part of becoming a mature programmer is understanding how different situations require different solutions and applying the right tools for the right job. Everyone is different and everyone works differently—your colleagues may be most productive using different tools than the ones that are your favorites. But if you saw someone converting his C code into assembly by hand on a day-to-day basis, you'd question his sanity.</p><p>Invest your time and money in tools practically. Think about how you're going to use a tool. Search for or write a new tool only when the time it will take to do so <span class="emphasis"><em>will</em></span> pay off. Don't spend a week writing a tool that will only save you one hour every month. Do spend a week writing a tool that will save you one hour every day.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Adopt a pragmatic approach to software tools—use them only when they'll make your life easier</em></span>.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="power_tools"/>Power Tools</h1></div></div></div><p>Since programming and tools go hand in hand, in order to be a super-programmer, you need to be a super-tool user. What does that mean?<a class="indexterm" id="IDX-CHP-7-0469"/></p><p>First, it's important to have a good understanding of which tools are around. In the next section, we will run down a list of the common tools that every programmer should have on hand. You don't need to know every tool on the market; it makes for incredibly dull dinner party conversation, anyway. Just knowing the general categories of tools that exist, rather than specific products, is the important step forward. That will help you choose between finding a tool for a particular task, writing the tool yourself, or doing the task by hand.</p><p>Take the time to get informed. Check out where you can obtain some of these tools—there are shops that specialize in selling software tools and plenty of download sites on the Internet. Maybe you already have some installed but never needed them, or you didn't appreciate how useful they were. Learn what you can expect tools to do for you; it will prepare you for good tool usage.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Know the sorts of tools that are available. Make sure you know where to get them, even if you don't need them right now</em></span>.</p></dd></dl></div><p>Be prepared to try a new tool and to take time to learn it; this is a healthy attitude. You may be forced to find new tools if you start a new project, move to a new platform, encounter a new kind of problem, or find that your old tools have become deprecated. But don't wait to be pushed—make sure that right now, you're using the best tools you can get your hands on.</p><p>Devote a portion of your time to honing your tools skills—just as you'd spend time reading a techie book or magazine or taking a professional training course. This stuff is important, so invest in it accordingly.</p><p>Here are a few simple steps to become a tool power user. For each weapon in your software construction arsenal . . .</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="understand_what_it_can_do"/>Understand What It Can Do</h2></div></div></div><p>Find out the feature set—what it can <span class="emphasis"><em>really</em></span> do, not what you think it <span class="emphasis"><em>should be able</em></span> to do. Even if you don't know how to wring out every last drop of goodness (maybe you'd have to look up the more esoteric command-line parameters), knowing what it's capable of will be helpful.</p><p>Are there particular things the tool <span class="emphasis"><em>can't</em></span> do? Perhaps it doesn't support some facilities provided by its counterparts. Understand these limitations, so you know when to shop around for something better.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="learn_how_to_drive_it"/>Learn How to Drive it</h2></div></div></div><p>Just because you've run the tool without generating an error doesn't mean it has done <span class="emphasis"><em>exactly</em></span> what you wanted it to do. You must know how to use it properly and be confident that you can make it do your bidding.</p><p>How does the tool fit into the whole toolchain? This will affect how you use it. For example, Unix tools can be used as sequential filters by <span class="emphasis"><em>piping</em></span> them together—splicing small individual tools into a larger utility.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-2" id="CHP-7-FN-2">2</a>]</sup> Understanding how to harness the power of each tool and learning about how they inter-operate lifts your tool usage a notch.</p><p>Figure out the best way to use each tool—it might not be by calling it directly or by clicking somewhere in the GUI interface. Can it be triggered automatically? A compiler is often invoked through a build system, rather than manually.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="know_what_tasks_its_good_for"/>Know What Tasks It's Good For</h2></div></div></div><p>Know how each tool fits in the context of the other available tools. For example, I can set up keystroke recording macros, which allow me to save time on repetitive actions, in my text editor. Some of these alterations could also be done using a magic sed invocation.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-3" id="CHP-7-FN-3">3</a>]</sup> However, it's better to use the keystroke macros in this context—I'm already using the editor and so it's quicker to fire them off.</p><p>You might not know how to use yacc,<sup>[<a class="footnote" href="#ftn.CHP-7-FN-4" id="CHP-7-FN-4">4</a>]</sup> but if you ever need to write a parser, you'll save yourself loads of effort knowing it's there.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Use the right tool for the right task. Don't crack a walnut with a sledgehammer</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="check_that_it_apostrophy_s_working"/>Check That It's Working</h2></div></div></div><p>Everyone becomes the victim of bad tools at some point. Your code doesn't work, but no matter how long you search for the errant behavior, there's no explanation. In desperation, you'll test random things—checking that the wind is blowing in the right direction and the light fittings have been secured correctly. Several hours later, you'll find a flaky tool doing something peculiar.</p><p>Compilers can produce faulty code. Build systems can get dependencies wrong. Libraries harbor bugs. Learn how to check for obvious failures before you rip out too much of your own hair.</p><p>Having access to the source code for your tools can be instrumental in diagnosing any problems you encounter, allowing you to work out exactly what a tool is doing. This might be a deciding factor in your choice of tool set.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="have_a_clear_route_to_find_out_more"/>Have a Clear Route to Find Out More</h2></div></div></div><p>You don't have to know it all. The trick is to know someone who does!<a class="indexterm" id="IDX-CHP-7-0471"/><a class="indexterm" id="IDX-CHP-7-0472"/></p><p>Find out where the tool's documentation is. Who provides support? How do you get more information? Look for manuals, release notes, online resources, internal help files, and man pages. Know where they are and how to access them on demand. Do the online versions have useful search tools and good indexing?</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="find_out_when_new_versions_appear"/>Find Out When New Versions Appear</h2></div></div></div><p>Tools seem to develop at an incredible rate—in this industry, technology changes fast. Some tools develop much faster than others. You've barely installed the latest widgetizer when the authors release a newer version with a longer red stripe down the side.</p><p>It's important to stay informed about the tools you use so that you don't get out of date and end up with a potentially buggy and unsupported tool kit. But this should be done cautiously; don't blindly chase the latest version. The bleeding edge can be painful!</p><p>New versions may have new bugs and new higher prices. Adopt upgrades if they provide significant fixes and have been proven stable. Test first—sanity check the new tool on your old code to make sure that it behaves itself.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Keep up to date with the latest developments in your tools, but don't upgrade carelessly</em></span>.</p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-2" id="ftn.CHP-7-FN-2">2</a>] </sup>If you don't know much about this, I urge you to read up on it. The Unix command <code class="literal">man bash</code> is a good place to start; search the man pages for <span class="emphasis"><em>pipelines</em></span>.<a class="indexterm" id="IDX-CHP-7-0470"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-3" id="ftn.CHP-7-FN-3">3</a>] </sup>sed is a stream editor command-line utility, explained in the next section.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-4" id="ftn.CHP-7-FN-4">4</a>] </sup>A parser generator. Don't worry—it's explained later too.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="which_tools_question"/>Which Tools?</h1></div></div></div><p>There's a staggering array of software development tools. Over the years they have been developed to scratch particular itches, the needs that often crop up. When a task has been done many times, you can bet that someone has written a tool for it.</p><p>Exactly what comprises your tool kit will depend on your line of work. The available tools for embedded platforms are rarely as rich as those for desktop applications. We'll consider the common components below. Some are really obvious; others are less so.</p><p>While we'll look individually at each class of tool, don't forget that modern IDEs collect these disparate programs into a single, streamlined interface. This is undoubtedly convenient, but it's important to understand how each tool stands on its own, for these reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You'll know how to get the best from each feature that's available.</p></li><li class="listitem"><p>You'll know what useful features your IDE lacks.</p></li></ul></div><p>Most IDEs are modular—you can substitute one component with a better alternative and plug in facilities that are not available right out of the box. Learn what tool varieties are around, and you'll improve your IDE experience.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="source_editing_tools"/>Source Editing Tools</h2></div></div></div><p>A potter's medium is clay; a sculptor's, stone; and a programmer's, code. This is the fundamental thing we work with, so it's important to pick excellent tools to help us write, edit, and investigate source code.<a class="indexterm" id="IDX-CHP-7-0473"/></p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="source_code_editor"/>Source Code Editor</h3></div></div></div><p>The editor is probably your most important tool, even more important than a compiler. The compiler faces the computer, whereas the editor faces <span class="emphasis"><em>you</em></span>. And you're the one driving. This is where you'll spend most of your programming life, so pick a good editor and learn to use it <span class="emphasis"><em>really</em></span> well. Being productive with your text editor will dramatically improve how you write code.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Your choice of code editor is vital: It has a huge impact on how you write code</em></span>.</p></dd></dl></div><p>The One True Source Editor is an age-old debate that doesn't need to be stirred here, but you should select an editor that you are comfortable with and does what you require. Just because an editor is embedded in your visual IDE does not mean that it is the best editor for you. On the other hand, you may find that having it integrated is an incredible boon. For source code editing, I require at least the following from my editor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Comprehensive syntax coloring (with support for <span class="emphasis"><em>many</em></span> languages—since I use many languages)</p></li><li class="listitem"><p>Simple syntax checking (e.g., highlighting mismatched brackets)</p></li><li class="listitem"><p>Good <span class="emphasis"><em>incremental search</em></span> facilities (an interactive form of find that searches as you type)</p></li><li class="listitem"><p>Keyboard macro recording</p></li><li class="listitem"><p>Highly configurable</p></li><li class="listitem"><p>Works across every platform that I use</p></li></ul></div><p>My requirements and choice of editor may not be the same as yours, but that seems like a fair list of the most important facilities. I don't mind spending a little time learning how to get the best out of all these features. It's worth it if it makes me productive.</p><p>Depending on the type of work you're doing, you may find other types of editors useful. There are binary file editors (usually displaying file contents in hexadecimal; they're commonly called <span class="emphasis"><em>hex editors</em></span>) and editors devoted to specific file formats, for example XML file editors.<a class="indexterm" id="IDX-CHP-7-0474"/></p><p>Vim and Emacs are the infamous Unix-land editors, available now on pretty much any platform (probably even your electric toaster). These contrast with the default editors bundled with IDEs.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="source_manipulation_tools"/>Source Manipulation Tools</h3></div></div></div><p>The Unix philosophy is characterized by a large collection of small command-line tools. GUI environments have their counterparts for each tool, but they are rarely as powerful or easy to string together. The GUI versions are far simpler to learn, though.</p><p>The following Unix commands provide powerful mechanisms to investigate and modify source code:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>diff</code></strong></span></dt><dd><p>Compares two files and highlights the differences between them. Basic diff spits output to the console, but more sophisticated graphical versions exist. There are even editors that allow you to work on the diffed files, displaying them side by side and updating the differences as you type. Exotic diffs can compare three files at once.</p></dd><dt><span class="term"><strong class="userinput"><code>sed</code></strong></span></dt><dd><p>Stands for <span class="emphasis"><em>stream editor</em></span>. Sed reads files a line at a time, applying a specified conversion rule. Sed can be used to reorder items, as a global search and replace tool, or to insert patterns into lines.</p></dd><dt><span class="term"><strong class="userinput"><code>awk</code></strong></span></dt><dd><p>Imagine sed on steroids. Awk is another pattern-matching program that can process text files. It implements a full programming language for this task, so you can write quite advanced awk scripts to perform involved manipulation.</p></dd><dt><span class="term"><strong class="userinput"><code>grep</code></strong></span></dt><dd><p>Searches for patterns of characters in a file. These patterns are described by <span class="emphasis"><em>regular expressions</em></span>, a form of mini-language allowing wildcard characters and flexible match criteria.</p></dd><dt><span class="term"><strong class="userinput"><code>find</code></strong>/<strong class="userinput"><code>locate</code></strong></span></dt><dd><p>These tools help to find files in the filesystem. They can hunt them down by name, date, or a number of other criteria.</p></dd></dl></div><p>These are only the tip of the iceberg, and there are many other tools. <code class="literal">wc</code>, for example, performs word/character counting. For more gems, look into <code class="literal">sort</code>, <code class="literal">paste</code>, <code class="literal">join</code>, and <code class="literal">cut</code>.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="source_navigation_tools"/>Source Navigation Tools</h3></div></div></div><p>Really large projects have codebases like cities. Not even the town planners intimately know each and every back street. A few taxi drivers know the best routes around. Normal citizens know their own neighborhoods fairly well. Tourists get lost as soon as they step off a bus.<a class="indexterm" id="IDX-CHP-7-0475"/><a class="indexterm" id="IDX-CHP-7-0476"/><a class="indexterm" id="IDX-CHP-7-0477"/><a class="indexterm" id="IDX-CHP-7-0478"/><a class="indexterm" id="IDX-CHP-7-0479"/><a class="indexterm" id="IDX-CHP-7-0480"/></p><p>There is a breed of tool to help you delve into and understand code, map it out, and perform easy searches, navigation, and cross-referencing. Some tools produce call-graph trees so you can see how control flows around the system. They may produce a graphical map or integrate with your editor to provide auto-completion, function call help, and more. This can be invaluable on large codebases or when entering a project that is well established.</p><p>Good examples of freely available tools are LXR, Doxygen, and the venerable ctags.<a class="indexterm" id="IDX-CHP-7-0481"/></p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="revision_control"/>Revision Control</h3></div></div></div><p>We won't dwell on source control tools here, since we cover them in "<a class="xref" href="ch18s02.html" title="Source Control">Source Control</a>" on page 351. Suffice to say: you <span class="emphasis"><em>must</em></span> use one, or else have a limb forcibly amputated.<a class="indexterm" id="IDX-CHP-7-0482"/><a class="indexterm" id="IDX-CHP-7-0483"/><a class="indexterm" id="IDX-CHP-7-0484"/><a class="indexterm" id="IDX-CHP-7-0485"/><a class="indexterm" id="IDX-CHP-7-0486"/><a class="indexterm" id="IDX-CHP-7-0487"/><a class="indexterm" id="IDX-CHP-7-0488"/><a class="indexterm" id="IDX-CHP-7-0489"/></p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="source_generation"/>Source Generation</h3></div></div></div><p>A number of tools automatically generate source code. Some are good; some frighten me.</p><p>One example is yacc, an LALR(1)<sup>[<a class="footnote" href="#ftn.CHP-7-FN-5" id="CHP-7-FN-5">5</a>]</sup> parser generator. You define the input grammar rules, then use it to generate programs that can parse well-formed input matching those rules. It spits out a C code parser with hooks for you to add functionality when items are parsed. Bison is a similar tool.</p><p>There is a class of code-generating tools that helps you to design user interfaces, spitting out the workhorse back-end code. These are especially used for complex GUI tool kits like MFC. If a library requires a tool to do <span class="emphasis"><em>this much</em></span> legwork, then it implies that the library is too complex (or fundamentally broken) in the first place. Tread with caution!</p><p>Wizards that write reams of scaffolding code that you must later revise and modify should also be treated with caution. You must honestly understand the generated code before you begin to attack it, or you'll be bitten by your own ignorance. If you rerun the wizard after modifying any generated code, all your hand-edits will be silently overwriten. Ouch.</p><p>You can even write your own scripts to spit out repetitive sections of code. Sometimes this is an indicator that your code could have been designed better. Sometimes it <span class="emphasis"><em>is</em></span> the right technical approach. In the past, I have written Perl scripts to generate code for me automatically. Having written the generator, I trusted the code it generated. Another programmer might look at it distrustfully, like any other code wizard.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="source_beautifiers"/>Source Beautifiers</h3></div></div></div><p>These tools homogenize source code formatting, creating a uniform <span class="emphasis"><em>lowest common denominator</em></span> layout. I honestly think they are more hassle than they're worth—they can destroy as much important and helpful formatting as they fix.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="code_construction_tools"/>Code Construction Tools</h2></div></div></div><p>We don't want to stare at pretty source code all day. The fun bit is making it do something. We do this so often that we take the following tools for granted, assuming they all work, without thinking about what's going on behind the curtain.</p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="compiler"/>Compiler</h3></div></div></div><p>Besides a source editor, this is the most used software tool. Compilers convert your source code into an executable so you can marvel at the ways your program fails to work. Since this tool is used so often, it's important that you can drive it properly. Do you really know all the options and facilities that it has? Many companies have a specific <span class="emphasis"><em>buildmaster</em></span> who ensures that the build tools are used correctly, but this isn't an excuse to be ignorant of your compiler.<a class="indexterm" id="IDX-CHP-7-0490"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Do you understand what level of optimization to employ and how that might affect the generated code? It's important—among other things, it will determine how surprisingly the code runs in the debugger, and even which compiler bugs you enable!</p></li><li class="listitem"><p>Do you compile with all warnings switched on? There really is no excuse not to (perhaps only if you're maintaining legacy code that is already riddled with warnings). The warnings highlight potential errors, and their absence gives you extra confidence in the code.<a class="indexterm" id="IDX-CHP-7-0491"/><a class="indexterm" id="IDX-CHP-7-0492"/></p></li><li class="listitem"><p>Is the compiler standards-compliant by default? The C++ ISO standard is, (ISO 98) the 1999 C standard is, (ISO 99) the Java language is defined by, (Gosling et al. 00) and C# by the ISO standard. (ISO 05) Does the compiler have any nonstandard extensions; if so, do you know what they are and how to avoid them?<a class="indexterm" id="IDX-CHP-7-0493"/><a class="indexterm" id="IDX-CHP-7-0494"/><a class="indexterm" id="IDX-CHP-7-0495"/><a class="indexterm" id="IDX-CHP-7-0496"/></p></li><li class="listitem"><p>Is it generating code for the correct CPU instruction set? You may be churning out 386-compatible code when you'll only ever run it on the latest Intel whiz-bang chip. Get your compiler to spit out the most appropriate code possible.</p></li></ul></div><div class="sidebar"><a id="i_need_a_tool_._._."/><p class="title"><b>I NEED A TOOL . . .</b></p><p>You need to perform a task. It's a dull task. It's repetitive. It's the kind of thing that <span class="emphasis"><em>must</em></span> be better for a computer to do; it would be less error prone, less tedious, and far quicker. That's what computers were invented for! How do you find out if there's something to do the job for you?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If it's mentioned in this list, you'll know already that a tool is available.</p></li><li class="listitem"><p>If it's not in the list, but you're sure that you're not the first person to have this kind of problem, there's probably a tool out there <span class="emphasis"><em>somewhere</em></span> that will help. You'd be surprised at some of the random programs a quick web search brings up.</p></li><li class="listitem"><p>If your problem seems unique, you might have to write your own program for it. See "<a class="xref" href="ch07s04.html#rolling_your_own" title="ROLLING YOUR OWN">ROLLING YOUR OWN</a>" on page 126 for more on this.</p></li></ul></div><p>When looking for a tool, get as much advice as you can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ask others on your team if they have any experience.</p></li><li class="listitem"><p>Search the web, and read appropriate newsgroups.</p></li><li class="listitem"><p>Go to tools vendors.</p></li></ul></div><p>Given the selection of available tools, you'll need to make an informed choice based on the criteria we saw in the first section. To make this decision, you must establish your requirements. Is it important that the tool is free? Or is it more important that you can get it now? Should it be easy to use for everyone on the team? How often will you use it—will it justify the expense?</p></div><p>A <span class="emphasis"><em>cross compiler</em></span> targets a different platform from the development machine. This is primarily used when writing embedded software (after all, it's hard to run Visual C++ on a dishwasher).</p><p>The compiler is a single part of a larger toolchain, including the linker, assembler, debugger, profiler, and other object-file manipulators.</p><p>Some popular compilers include gcc, Microsoft's Visual C++, and Borland's C++ builder.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="linker"/>Linker</h3></div></div></div><p>The linker is closely allied with the compiler. It takes all the intermediate <span class="emphasis"><em>object files</em></span> that a compiler spits out and glues them together into a single executable lump of code. The C and C++ linkers are so closely bound to the compiler that sometimes the same executable does both tasks. For Java and C# the linker is tied to the run-time environment.<a class="indexterm" id="IDX-CHP-7-0497"/><a class="indexterm" id="IDX-CHP-7-0498"/><a class="indexterm" id="IDX-CHP-7-0499"/></p><p>When using your linker, make sure you know:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Does it <span class="emphasis"><em>strip</em></span> the binary? That is, does it remove debugging symbols like the names of variables and functions? These can be used by a debugger to show useful diagnostic information, but they can also significantly bloat executables and make them slow to load.</p></li><li class="listitem"><p>Does it eliminate replicated code sections?</p></li><li class="listitem"><p>Can you make it spit out library objects rather than executables? What control do you have over the library—can you make it <span class="emphasis"><em>statically</em></span> or <span class="emphasis"><em>dynamically</em></span> loaded?</p></li></ul></div></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="build_environment"/>Build Environment</h3></div></div></div><p>The entire build environment is more than just a compiler and linker. The kind of build tools that we use are the Unix make program or the build portions of your IDE. They automate the compilation process. Many open source Unix projects use the autoconf and automake tools to simplify building.<a class="indexterm" id="IDX-CHP-7-0500"/></p><p>Learn how to get the most out of your integrated build environment, but not at the expense of knowing how to use each individual construction tool. We'll investigate these topics in more detail in <a class="xref" href="ch10.html" title="Chapter 10. THE CODE THAT JACK BUILT">Chapter 10</a>.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="testing_toolchain"/>Testing Toolchain</h3></div></div></div><p>Note that this is a code construction tool, <span class="emphasis"><em>not</em></span> a debugging tool! Appropriate testing is vital to the production of reliable, high-quality software. It is often neglected—perhaps because it's seen as too much work, distracting attention away from the important task of writing code. This is one of the biggest threats to good software. You cannot construct a reliable piece code unless you can prove that it works correctly, and the only way to do this is to construct tests for it as you write.</p><p>There are tools that help automate unit testing, offering a skeleton into which you can place your test code. These tools can be easily integrated into your build system, so testing becomes a central part of the code construction process.<a class="indexterm" id="IDX-CHP-7-0501"/></p><p>As well as automated unit testing, there are tools that generate test data and formulate test cases. There are also tools that simulate a target platform, perhaps with the ability to model particular error conditions (low memory, high load, etc.).</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="debugging_and_investigative_tools"/>Debugging and Investigative Tools</h2></div></div></div><p>These tools characterize running code and help to track down problems—both things we have seen going wrong and potential disasters waiting to pounce. We'll look at them in greater detail in "<a class="xref" href="ch09s07.html" title="Wasp Spray, Slug Repellent, Fly Paper . . .">Wasp Spray, Slug Repellent, Fly Paper . . .</a>" on page 169.<a class="indexterm" id="IDX-CHP-7-0502"/><a class="indexterm" id="IDX-CHP-7-0503"/><a class="indexterm" id="IDX-CHP-7-0504"/><a class="indexterm" id="IDX-CHP-7-0505"/><a class="indexterm" id="IDX-CHP-7-0506"/></p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="debugger"/>Debugger</h3></div></div></div><p>Having a quality debugger and understanding how to use it can save you hours of development time chasing surprising behavior. It allows you to investigate paths of execution in your program, break into it, investigate variable values, set breakpoints, and generally dissect your running code. It's an order of magnitude more sophisticated than peppering programs with <code class="literal">printf</code> logging statements!</p><p><code class="literal">gdb</code> is GNU's open source debugger; it has been ported to almost every conceivable platform. <code class="literal">ddd</code> is an accomplished graphical interface for it. Every IDE and toolchain has its own debugger.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="profiler"/>Profiler</h3></div></div></div><p>This tool is used when your code runs unacceptably slowly. The profiler times sections of running code and identifies the bottlenecks. It is used to find targets for <span class="emphasis"><em>sensible</em></span> optimization; armed with its results, you won't waste effort speeding up code that is rarely executed.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="code_validators"/>Code Validators</h3></div></div></div><p>Code validators come in two varieties: <span class="emphasis"><em>static</em></span> and <span class="emphasis"><em>dynamic</em></span>. The former digest code in a similar way to a compiler, inspecting your source files to identify possible problem areas and flawed language use. <code class="literal">lint</code> is a well-known example; it performs static checks for a series of common coding errors in C. Much of its functionality is built into modern compilers, but there are still separate tools available for extra checking.<a class="indexterm" id="IDX-CHP-7-0507"/></p><p>Dynamic validators modify and instrument the code as it is compiled and then perform checking at run time. Memory allocation/bounds checkers are a good example—they ensure that all dynamically allocated memory is freed appropriately and that array accesses do not occur out of bounds.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-6" id="CHP-7-FN-6">6</a>]</sup> These tools can save hours of legwork looking for obscure bugs. They are <span class="emphasis"><em>much</em></span> more useful than a debugger in most situations, since they act like prevention mechanisms rather than cures: They'll find faults before they have a chance to break your program.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="metrics_tools"/>Metrics Tools</h3></div></div></div><p>These tools perform code inspection and are usually a form of static analyzer (although dynamic metric tools do exist). They produce statistical assessments of the quality of your code. While statistics can easily mislead, these tools can powerfully highlight the most brittle areas. This information can help you pick specific targets for code reviews.<a class="indexterm" id="IDX-CHP-7-0508"/></p><p>Metrics are usually gathered on a per-function basis. The most basic metric is <span class="emphasis"><em>number of lines of code</em></span>, followed by the ratio of <span class="emphasis"><em>comments to code</em></span>. Neither really tell you anything particularly useful, but there are plenty of more interesting metrics. <span class="emphasis"><em>Cyclomatic complexity</em></span> is a measure of the complexity of code, considering the number of decision points and potential flows of control. A high cyclomatic complexity implies unintelligible code, which is more likely to be brittle and harbor faults.<a class="indexterm" id="IDX-CHP-7-0509"/><a class="indexterm" id="IDX-CHP-7-0510"/></p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="disassembler"/>Disassembler</h3></div></div></div><p>This peers into executables, allowing you to inspect the machine code. Debuggers do contain this kind of support, but advanced disassemblers can attempt to reconstruct code where no symbols exist, generating a high-level language reinterpretation of the binary program file.<a class="indexterm" id="IDX-CHP-7-0511"/><a class="indexterm" id="IDX-CHP-7-0512"/></p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="fault_tracking"/>Fault Tracking</h3></div></div></div><p>A good fault-tracking system provides a shared database that keeps track of the bugs found in your system. It allows colleagues to report faults, query, assign, or comment on them, and eventually mark faults as fixed. It's an essential tool to ensure the quality of a product—you need to manage faults systematically, or they'll slip through your fingers, and you'll release a flawed product. Capturing and storing this information is also useful when looking back over the project history.<a class="indexterm" id="IDX-CHP-7-0513"/></p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="language_support_tools"/>Language Support Tools</h2></div></div></div><p>To write in a high-level language, you need a lot of support. The language implementation provides everything you need to make coding possible, making it easier than wallowing in a swamp of machine code.</p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="the_language"/>The Language</h3></div></div></div><p>The language itself <span class="emphasis"><em>is</em></span> a tool. Some languages provide facilities absent in others. These gaps may be filled by separate tools you can run over the program source. For example, C's much maligned preprocessor can be remarkably useful, and text-processing packages exist for other languages. Generic code facilities (like C++'s templates), and pre- and postcondition checking are other similarly useful language tools.<a class="indexterm" id="IDX-CHP-7-0514"/></p><p>It's valuable to have a selection of languages under your belt. Understand how they differ, what tasks they lend themselves to, and what their weak points are. Then you can select the best language for any given task.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Learn several languages; each will teach you different ways to approach problems. Consider them tools, and select the most appropriate language for each task</em></span>.</p></dd></dl></div></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="run_time_and_interpreter"/>Run Time and Interpreter</h3></div></div></div><p>Most languages can't be used without the requisite run-time support. Interpreted languages rely on their interpreter (or <span class="emphasis"><em>virtual machine</em></span>), but directly compiled languages still lean on their support libraries. These libraries are often intimately entwined with the language itself, so the two can't be separated.<a class="indexterm" id="IDX-CHP-7-0516"/><a class="indexterm" id="IDX-CHP-7-0515"/><a class="indexterm" id="IDX-CHP-7-0517"/></p><p>Just as you can pick a different compiler, you may be able to select a different language run time, with different characteristics.</p><p>Java's JVM (<span class="emphasis"><em>The Java Virtual Machine</em></span>) is a common language interpreter. The C++ standard library supports the language, providing the default handlers for some core language features. Similarly, the C# language rests upon the run-time support of the .NET environment.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="components_and_libraries"/>Components and Libraries</h3></div></div></div><p>Yes, these are tools too! Reusing software components and finding libraries that do what you need avoids reinventing the wheel. A good library can increase productivity as much as any other software tool.<a class="indexterm" id="IDX-CHP-7-0518"/></p><p>The scopes of these libraries vary—some are vast abstraction layers for an entire OS, while some do a very simple job, providing a humble <span class="emphasis"><em>date</em></span> class. They look after their details and hide the complexity away so that you don't have to worry about it. You don't have to spend time writing, testing, and debugging your own versions.</p><p>All languages these days come with some level of library support. The C++ STL is a wonderful example of a powerful extensible library. The Java language and .NET environment ship with more standard libraries than you can shake a stick at. Many, many third-party libraries exist, both commercial and free.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="miscellaneous_tools"/>Miscellaneous Tools</h2></div></div></div><p>The story doesn't end here. You will come across plenty more tools. "<a class="xref" href="ch06s08.html" title="See Also">See Also</a>" on page 127 points out other places where we'll discuss software tools.</p><p>The following are some other interesting tool varieties.</p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="documentation_tools-id1"/>Documentation Tools</h3></div></div></div><p>Good documentation is invaluable; it's a key part of well-engineered code. Various tools help you to write it, both in the source code itself and separately (I describe some in "<a class="xref" href="ch04s03.html" title="Practical Self-Documentation Methodologies">Practical Self-Documentation Methodologies</a>" on page 66). Never underestimate how important a good word processor is.<a class="indexterm" id="IDX-CHP-7-0519"/></p><p>Documentation needs to be read as well as written. Good online help systems (backed up by a quality bookshelf) are critical.</p><div class="sidebar"><a id="rolling_your_own"/><p class="title"><b>ROLLING YOUR OWN</b></p><p>What happens when you can't find a tool for a job and it'll take forever to do by hand? There's nothing wrong with "<a class="xref" href="ch07s04.html#rolling_your_own" title="ROLLING YOUR OWN">ROLLING YOUR OWN</a>" tools. Indeed, if this task is going to crop up repeatedly, a short tool development may save you hours in the long run.</p><p>Some tasks are naturally more tool-able than others. Make sure you're attempting something realistic, and check that the effort will be a cost-effective investment.</p><p>These are the common ways to create a tool:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Combine existing tools in a new ways, commonly using the Unix piping mechanism, perhaps writing a little connecting glue. You can put complex command-line incantations into a <span class="emphasis"><em>shell script</em></span> (or <span class="emphasis"><em>batch file</em></span> in Windows-land) so you don't have to type them in every time.<a class="indexterm" id="IDX-CHP-7-0520"/></p></li><li class="listitem"><p>Use a <span class="emphasis"><em>scripting language</em></span>. Most small homegrown tools are written in some form of scripting language, often Perl. They're quick and easy to work with, yet powerful enough to provide the kind of support you need to write tools.<a class="indexterm" id="IDX-CHP-7-0521"/><a class="indexterm" id="IDX-CHP-7-0522"/></p></li><li class="listitem"><p>Create a full-blown program from scratch. You only really want to do this if it's a serious tool that you'll be using over and over again. Otherwise, the effort probably isn't justified.</p></li></ul></div><p>When writing the tool, consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The audience—how polished does the tool have to be? Are a few rough edges acceptable? If it's only you and one other techie using it, you can cope. If other, more delicate souls may one day need it, perhaps you should upholster it tastefully.</p></li><li class="listitem"><p>Can you extend an existing tool (wrap its command up, or perhaps create a plugin for it)?</p></li></ul></div></div></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="project_management"/>Project Management</h3></div></div></div><p>Management and work collaboration tools allow you to report and track work against a schedule, manage faults, and monitor team performance. Depending on the scope of the management tool, humble programmers may not need to go near it. But more exotic systems may become the central hub of project activity, drawing in all users.<a class="indexterm" id="IDX-CHP-7-0523"/><a class="indexterm" id="IDX-CHP-7-0524"/><a class="indexterm" id="IDX-CHP-7-0525"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-5" id="ftn.CHP-7-FN-5">5</a>] </sup>A cryptic techie (and dull) way of saying <span class="emphasis"><em>reasonably complex grammar</em></span>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-6" id="ftn.CHP-7-FN-6">6</a>] </sup>More socially responsible languages, like Java, avoid this kind of problem in the language design.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id6"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Give us the tools and we will finish the job.</p><div class="attribution"><span>--<span class="attribution">Sir Winston Churchill</span></span></div></div><p>Tools make software development possible. Good tools make it much easier.</p><p>Make a point of evaluating the set of tools you use. Do you really know how to use them all properly? Are there any missing tools you should have? Are you getting the most from the ones you do have?</p><p>A tool is only ever as good as its user. The proverb <span class="emphasis"><em>A bad workman blames his tools</em></span> contains a lot of truth. Poor programmers create poor code, no matter how many tools they use. In fact, tools can help produce spectacularly worse code. Fostering a professional, responsible attitude toward your toolbox will make you a better programmer.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Would rather learn <span class="emphasis"><em>once</em></span> how to use an appropriate tool, rather than repeat a tedious job over <span class="emphasis"><em>and over and over</em></span> again</p></li><li class="listitem"><p>Understand different toolchain models and are comfortable with each</p></li><li class="listitem"><p>Use tools to make their lives easier but don't become slaves to them<a class="indexterm" id="IDX-CHP-7-0526"/></p></li><li class="listitem"><p>See everything they use as a tool, a replaceable utility</p></li><li class="listitem"><p>Are productive, because the use of their tools is second nature</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Know how to use a few tools and look at every problem in terms of them</p></li><li class="listitem"><p>Are afraid of taking the time to learn new tools</p></li><li class="listitem"><p>Started using one development environment and now use it religiously, never trying out or even investigating alternatives</p></li><li class="listitem"><p>Don't add to their toolboxes when they come across a valuable new tool</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id6"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch10.html" title="Chapter 10. THE CODE THAT JACK BUILT">Chapter 10</a></span></dt><dd><p>The software build process is driven by tools. Just imagine compiling code by hand!</p></dd><dt><span class="term"><a class="xref" href="ch13.html" title="Chapter 13. GRAND DESIGNS">Chapter 13</a></span></dt><dd><p>Contains a section discussing specific <span class="emphasis"><em>design tools</em></span>.</p></dd><dt><span class="term"><a class="xref" href="ch18.html" title="Chapter 18. PRACTICING SAFE SOURCE">Chapter 18</a></span></dt><dd><p>A chapter devoted to the use of <span class="emphasis"><em>revision control tools</em></span>.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e10074"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207462.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id7"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 491.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id6"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Is it more important for everyone in a development team to use the same IDE, or for each person to pick the one that suits him or her best? What are the implications of different people using different tools?</p></li><li class="listitem"><p>What is the minimum set of tools that any programmer should have at his or her disposal?</p></li><li class="listitem"><p>Which are more powerful: command-line or GUI-based tools?</p></li><li class="listitem"><p>Are there construction tools that aren't programs?</p></li><li class="listitem"><p>What's most important for a tool?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Interoperability</p></li><li class="listitem"><p>Flexibility</p></li><li class="listitem"><p>Customization</p></li><li class="listitem"><p>Power</p></li><li class="listitem"><p>Ease of use and learning</p></li></ol></div></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id6"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What are the common tools in your toolbox? Which do you use every day? Which do you use a few times a week? Which do you only call on occasionally?<a class="indexterm" id="IDX-CHP-7-0527"/><a class="indexterm" id="IDX-CHP-7-0528"/><a class="indexterm" id="IDX-CHP-7-0529"/><a class="indexterm" id="IDX-CHP-7-0530"/><a class="indexterm" id="IDX-CHP-7-0531"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How well do you know how to use them?</p></li><li class="listitem"><p>Are you getting the most from every tool?</p></li><li class="listitem"><p>How did you learn to use them? Did you ever spend any time improving your skill with them?</p></li><li class="listitem"><p>Are these the <span class="emphasis"><em>best</em></span> tools you could be using?</p></li></ol></div></li><li class="listitem"><p>How up to date are your tools? Does it matter if they're not the latest cutting-edge versions?</p></li><li class="listitem"><p>Do you favor an integrated tool set (like a visual development environment) or a discrete toolchain? What are the advantages of the <span class="emphasis"><em>other</em></span> approach? How much experience do you have with <span class="emphasis"><em>both</em></span> ways of working?</p></li><li class="listitem"><p>Are you a <span class="emphasis"><em>Default Dan</em></span> or a <span class="emphasis"><em>Tweaker Tom</em></span>? Do you accept the default settings in your editor, or do you customize them to within an inch of their lives? Which is the "better" approach?</p></li><li class="listitem"><p>How do you determine your budget for software tools? How do you know whether a tool is worth its cost?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="testing_times"/>Chapter 8. TESTING TIMES</h1></div><div><h3 class="subtitle"><i>The Black Art of Testing Code</i></h3></div></div></div><div class="epigraph"><p>Test everything. Keep what is good.</p><div class="attribution"><span>--<span class="attribution">1 Thessalonians 5:21</span></span></div></div><p>Write as much code as you like—there's one thing you can be sure of: It won't work perfectly the first time. It doesn't matter how long you took to carefully design it; software faults have a creepy ability to work their way into any program. The more code you write, the more faults you'll introduce. The faster you write, the more you'll introduce. I've yet to meet a really prolific programmer who created anything near bug-free code.</p><p>What do we do about this? We <span class="emphasis"><em>test</em></span> our code. We do this to find any problems that exist, and once we've fixed them, we use the tests to maintain confidence in the quality of the code as we continue to modify it. It's suicide to release untested software, no matter how good a programmer you think you are. Untested software is <span class="emphasis"><em>bound</em></span> to fail; testing is an essential part of our craft. Too many software factories underestimate the importance of thorough testing or try to squeeze it into a last-minute dash before the software ships. It shows.</p><p>Testing is not something relegated to the end of the development process, used to prove that your final program is okay. If that's all you ever try to do, you'll produce very poor code, indeed. Testing is a central construction technique. It's only by testing that you can prove that each bit of code works, which then tells you when you've finished it. How could you tell, otherwise? How do so many software factories think they can get away without decent testing?</p><div class="sidebar"><a id="terms_and_conditions"/><p class="title"><b>TERMS AND CONDITIONS</b></p><p>The term <span class="emphasis"><em>bug</em></span> is remarkably evocative and incredibly imprecise. It's easy to throw words around without really understanding what they mean. Using more specific terminology helps us to define what we're doing. These definitions are inspired by IEEE literature (IEEE 84):</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Error</strong></span></span></dt><dd><p>An <span class="emphasis"><em>error</em></span> is something that <span class="emphasis"><em>you</em></span> do wrong. It is a specific human action that results in software containing a <span class="emphasis"><em>fault</em></span>. For example: Forgetting to check a condition in your code (like the size of a C array before indexing into it) is an error.</p></dd><dt><span class="term"><span class="strong"><strong>Fault</strong></span></span></dt><dd><p>A <span class="emphasis"><em>fault</em></span> is the consequence of an error, embodied in the software. I made an error, and this resulted in a fault in the code. At first, this is a <span class="emphasis"><em>latent</em></span> problem. If the code I've just written is never executed, then this fault will never have a chance to cause problems. If execution often passes through the faulty code, but never in the particular way that triggers the fault, we'll never notice that there is a fault at all.</p><p>This subtle point is what makes debugging notoriously difficult. A faulty line of code may seem fine for years, and then one day it causes the most bizarre system tantrum you've ever seen; you won't suspect the aged code since it's been reliable for so long.</p><p>You might discover a fault in a code review, but you can't identify a fault from a running program.</p></dd><dt><span class="term"><span class="strong"><strong>Failure</strong></span></span></dt><dd><p>When encountered, a fault may cause a <span class="emphasis"><em>failure</em></span>. It may not. The failure, the manifestation of the fault, is what we really care about. It's probably the only thing we'll take notice of. A failure is the departure of your program's operation from its requirements, from its expected behavior. This is where we verge on philosophy. If a tree falls over in a forest, does it make a sound? If the running program doesn't exercise a bug, is the mistake still a fault? These definitions help to answer this.</p></dd><dt><span class="term"><span class="strong"><strong>Bug</strong></span></span></dt><dd><p>The term <span class="emphasis"><em>bug</em></span> is a colloquialism, often used as a synonym for fault. According to folklore, the first computer bug was an <span class="emphasis"><em>actual</em></span> bug. It was discovered by Admiral Grace Hopper in 1947 at Harvard. A moth trapped between two electrical relays of the Mark II Aiken Relay Calculator caused the whole machine to shut down.</p></dd></dl></div></div><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="reality_check"/>Reality Check</h1></div></div></div><p>The two simple questions <span class="emphasis"><em>What is testing?</em></span> and <span class="emphasis"><em>Why do you test?</em></span> seem painfully obvious. Yet all too often, adequate software testing is not performed—or it is not performed at the appropriate stage of production. Good testing is a skill. Actually <span class="emphasis"><em>doing</em></span> some testing is more than many programmers achieve; the mere mention of testing is enough to make most of them break out in a cold sweat. "The single most important rule of testing is to do it." (Kernighan Pike 99)<a class="indexterm" id="IDX-CHP-8-0538"/><a class="indexterm" id="IDX-CHP-8-0533"/><a class="indexterm" id="IDX-CHP-8-0534"/><a class="indexterm" id="IDX-CHP-8-0535"/><a class="indexterm" id="IDX-CHP-8-0536"/><a class="indexterm" id="IDX-CHP-8-0537"/></p><p>Testing is a distinct and separate activity from debugging, although their boundaries blur, and the two often get mixed up together. <span class="emphasis"><em>Testing</em></span> is a methodical process of proving the existence, or lack thereof, of faults in your software. <span class="emphasis"><em>Debugging</em></span> is the act of tracking down the cause of this faulty behavior. Testing leads to debugging, which leads to repair, which leads to more testing (we test again to prove that the fix worked).</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Testing is not debugging. Don't get the two confused. They require different skills. Make sure you know when you're testing and when you're debugging</em></span>.</p></dd></dl></div><p>If you're programming well, you'll do a <span class="emphasis"><em>lot</em></span> more testing than debugging. That's why this chapter comes before the debugging chapter.</p><p>Throughout the software development process, various things are tested:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A large number of <span class="emphasis"><em>documents</em></span> will go through a testing stage (more commonly known as a <span class="emphasis"><em>review</em></span> process). Doing this ensures, for example, that the requirements specification correctly models the customer's needs, the functional specification implements the requirements specification, the various subsystem specifications are complete enough to fulfill the functional specification, and so on.</p></li><li class="listitem"><p>Naturally, then, the implementation <span class="emphasis"><em>code</em></span> is tested on the developer's machine. It is tested at several levels, ranging from line-by-line testing of each function as it's written, to the testing of individual modules, to integration tests when sections of code are glued together.</p></li><li class="listitem"><p>Finally, the end <span class="emphasis"><em>product</em></span> is tested. While this level of testing will (or <span class="emphasis"><em>should</em></span>) indirectly test all the code components that have been developed, that is not the focus of these tests. Here we worry about whether or not the program, as a whole, is working as specified.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-1" id="CHP-8-FN-1">1</a>]</sup></p><p>Product tests may be concerned with a number of things. Most importantly, they check that the system functions as intended. They also check that it installs correctly (if it's shrink-wrapped PC software) and that it's usable.</p><p>This is the kind of testing performed by the QA department. It is this department's job to understand how the product should work and to ensure that it does, while also meeting any quality criteria that have been established for it.</p></li></ul></div><p>In this chapter, we'll focus on the middle point—how we test our code as software developers. The other testing activities are large and separate topics, which are outside the scope of this book.</p><div class="sidebar"><a id="quality_assurance"/><p class="title"><b>QUALITY ASSURANCE</b></p><p>QA: <span class="emphasis"><em>quality assurance</em></span>. Sounds painful, doesn't it? But just <span class="emphasis"><em>who</em></span> or <span class="emphasis"><em>what</em></span> is it? This name is given both to a tribe of software factory inhabitants and a development practice. To understand QA properly, it's important to separate colloquialisms and misconceptions from the real definiton.<a class="indexterm" id="IDX-CHP-8-0539"/></p><p>People mistakenly bundle QA with <span class="emphasis"><em>testing</em></span>, but the two differ significantly. Testing aims to detect erroneous behavior, where software diverges from its specification; it is effectively <span class="emphasis"><em>detection</em></span>. Real QA is <span class="emphasis"><em>prevention</em></span>. It ensures that our processes and development practices will result in high-quality software. Testing is a small part of QA—software quality includes more than just a low bug count. It means software that is delivered on time, to budget, and meeting all requirements and expectations (these two are not necessarily the same). Sadly, there still isn't a lot of high-quality software coming out of today's software factories.</p><p>Who's responsible for software quality? An organization's test department (often known as the QA department) is the group of people dedicated to <span class="emphasis"><em>product</em></span> testing. They have the final say as to whether your program is good enough to release. This is an important piece of the quality jigsaw, but not the whole picture. Everyone in the development process is involved in producing quality software—it's not something you can tack on once the code is complete.<a class="indexterm" id="IDX-CHP-8-0540"/></p><p>The responsibility for monitoring software quality often rests with the same group of people performing product testing. Otherwise, overall QA is the responsibility of project managers, while the testers are left to test.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-1" id="ftn.CHP-8-FN-1">1</a>] </sup>Because, obviously, the correct behavior has been carefully specified beforehand, hasn't it?</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="who_comma_what_comma_when_comma_and_why_question"/>Who, What, When, and Why?</h1></div></div></div><p>For our software testing to be effective, we need to understand <span class="emphasis"><em>why</em></span> we test, <span class="emphasis"><em>who</em></span> does it, <span class="emphasis"><em>what</em></span> it entails, and <span class="emphasis"><em>when</em></span> it is done.<a class="indexterm" id="IDX-CHP-8-0541"/><a class="indexterm" id="IDX-CHP-8-0542"/><a class="indexterm" id="IDX-CHP-8-0543"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="why_we_test"/>Why We Test</h2></div></div></div><p>As software developers, our testing procedure exists for a few reasons: to help us to find faults and fix them, and to ensure the same faults don't reappear in later versions.</p><p>Note that testing can never reveal the absence of faults, only their existence. If your tests don't find any bugs, it doesn't necessarily mean they aren't there; it just means you haven't found them yet.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Testing can only discover the</em></span> presence <span class="emphasis"><em>of faults. It can't prove the</em></span> absence <span class="emphasis"><em>of faults. Don't be led into a false sense of security by code that passes a suite of inadequate tests</em></span>.</p></dd></dl></div><p>Software testing at the end of a development cycle may have another motivation. As well as <span class="emphasis"><em>verifying</em></span> that a software component is correct and contains no faults, you may need to <span class="emphasis"><em>validate</em></span> it—ensure that it fulfills the requirements originally established—to prove that it is good enough for release. Validation is one form of an acceptance test.<a class="indexterm" id="IDX-CHP-8-0544"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="who_tests"/>Who Tests</h2></div></div></div><p>It is a <span class="emphasis"><em>programmer's</em></span> responsibility to test the source code he or she writes. Tattoo that sentence backward across your forehead and stare in the mirror for 10 minutes every morning.<a class="indexterm" id="IDX-CHP-8-0545"/><a class="indexterm" id="IDX-CHP-8-0546"/><a class="indexterm" id="IDX-CHP-8-0547"/></p><p>Too many developers, disillusioned by the trials of the software factory, crank out code and release it thoughtlessly to QA without having tested it themselves. This is irresponsible and unprofessional. In the long run, it'll cost you <span class="emphasis"><em>more</em></span> time and effort than testing properly. It's plain stupid to release untested code in a product and almost as bad to supply untested code to the QA department. Its job <span class="emphasis"><em>is</em></span> testing, but testing the product, not your new lines of code. It is likely to find the silly coding errors that you left behind, probably manifesting themselves in obscure and seemingly unrelated ways; but its job is to look for more fundamental errors that couldn't have been caught any earlier, not mop up after sloppy programmers.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>You must test every piece of code you write. Don't expect anyone else to do it for you</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="what_testing_involves"/>What Testing Involves</h2></div></div></div><p>When writing software, we create individual functions, data structures, and classes and glue them together into a working system. Our main testing strategy is to exercise all this code and validate its behavior by writing more code—<span class="emphasis"><em>test code</em></span>. This forms a harness around the test subject that prods, pokes, and drives it, provoking it to respond and checking that its response is correct.<a class="indexterm" id="IDX-CHP-8-0548"/></p><p>We write test code for each level of the system, testing each important class and function, through to the superstructures composed of these smaller parts. For each test, you must be clear about the following:<a class="indexterm" id="IDX-CHP-8-0549"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Exactly which piece of code you're testing. Clear modules with well-defined boundaries help here; the interfaces are your test points. Vague or complex interfaces make testing vague and complex.</p></li><li class="listitem"><p>The method you're using to test (see "<a class="xref" href="ch08s04.html" title="The Types of Test">The Types of Test</a>" on page 138).</p></li><li class="listitem"><p>When you will be finished. This is one of the hardest and most important questions to answer—you could go on forever. When can you say that you've run enough test cases?</p></li></ul></div><p>Another common testing strategy is to <span class="emphasis"><em>inspect</em></span> the code in order to prove its correctness. Inasmuch as this is a human activity, it is prone to failure, and it also relies upon the requirements being well defined. <span class="emphasis"><em>Code reviews</em></span> are a common inspection technique (see <a class="xref" href="ch20.html" title="Chapter 20. A REVIEW TO A KILL">Chapter 20</a>). Code inspection tools help, but they cannot magically perform all the tests for you. Too often, inspection is ad hoc and haphazard; it's so very easy to overlook faults. Prefer to use programmatic tests; they bring many benefits, which we'll see throughout this chapter. A combination of the two is most effective.<a class="indexterm" id="IDX-CHP-8-0550"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="when_we_test"/>When We Test</h2></div></div></div><p>Test your code <span class="emphasis"><em>as it's written</em></span>, catching coding errors at the earliest possible opportunity. It's at this time when errors are easiest to fix, affect fewest people, and cause the least havoc. Testing early and thoroughly is the most effective way to ensure software quality.<a class="indexterm" id="IDX-CHP-8-0551"/></p><p>The cost of a bug escalates as it works through the development process,<sup>[<a class="footnote" href="#ftn.CHP-8-FN-2" id="CHP-8-FN-2">2</a>]</sup> so it's essential to start testing code as soon as possible—during (or perhaps before) serious software development. The <span class="emphasis"><em>test-driven development</em></span> approach, popularized by agile programmers, advocates testing as a central construction technique; you write test code <span class="emphasis"><em>before</em></span> the code being tested!</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Effective code testing starts early, so you catch bugs when they're least harmful. You</em></span> can <span class="emphasis"><em>write tests before writing code!</em></span></p></dd></dl></div><p>This is an essential point, and it is vitally important to absorb into your programming routine. For each piece of code you write, <span class="emphasis"><em>immediately</em></span> write a test. Or write the test first. Prove that your code works, so you know that it's safe to move on. If you don't write a test at this point, you'll leave unproven, potentially buggy code behind. This destroys the stability of your codebase: When you hit a bug, you won't know which bit of code (in the mass you've accumulated since you last wrote a test) is causing the problem. So you end up in the debugger, which is a massive waste of time.</p><p>Writing the test later means you will test from a distance—either too late, when you've forgotten what the code is supposed to do, or as a consequence of testing a separate code module. This will not be an effective test. You're also far more likely to forget to write the test at all.</p><p>This testing strategy has profound implications: When you start to think about writing some code, you must simultaneously think about testing it. This will shape the way you design that code, for the better; we'll see why in "<a class="xref" href="ch08s06.html" title="Design for Test">Design for Test</a>" on page 144.</p><p>Every time you find a fault that managed to slip past your existing tests, you must add a new test to your test suite (after scolding yourself for missing it in the first place). The new test will help to prove that your bug fix is correct. It will also catch any later reappearance of the same bug; bugs can rise unexpectedly from the dead—this often happens when your code is modified later.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Write a test for every fault you find</em></span>.</p></dd></dl></div><p>So we write tests as early as possible, but how often do we run them? As often as humanly possible, if not more often (using computer support). The more often we run the tests, the more likely we are to detect problems. This is embodied in a <span class="emphasis"><em>continuous integration</em></span> strategy (see "<a class="xref" href="ch10s05.html#automated_builds" title="Automated Builds">Automated Builds</a>" on page 190), and begins to show why programatic tests (which are easy to run repeatedly) are so powerful.<a class="indexterm" id="IDX-CHP-8-0552"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Run your tests as often as you can</em></span>.</p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-2" id="ftn.CHP-8-FN-2">2</a>] </sup>See "<a class="xref" href="ch09s02.html#the_economics_of_failure" title="THE ECONOMICS OF FAILURE">THE ECONOMICS OF FAILURE</a>" on page 157 for more on the cost of bugs.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="testing_isnt_hard_._._."/>Testing Isn't Hard . . .</h1></div></div></div><p>Unless you do it badly, and then it's <span class="emphasis"><em>really</em></span> hard. It does take thoughtful effort, though. To test whether a particular piece of code works, you need a test harness that demonstrates that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The correct output is generated for all valid inputs.</p></li><li class="listitem"><p>The appropriate failure behavior is generated for all invalid inputs.</p></li></ul></div><p>That sounds innocuous enough, yet for all but the simplest of functions, it is just not practical to exhaustively perform this testing. The set of valid inputs is usually very large, and it's impossible to test each input individually. You'll have to pick a smaller set of representative input values. The set of invalid inputs is almost always <span class="emphasis"><em>much</em></span> larger than the set of valid inputs, so you have to pick a number of representative bad values, as well.</p><p>To illustrate this, here are two examples. This first function is easy to test:</p><a id="I_programlisting2_d1e10665"/><pre class="programlisting">
bool logical_not(bool b)
{
    if (b)
        return false;
    else
        return true;
}
</pre><p>The set of valid inputs is of size two, and there are no invalid inputs. This means that the function's test harness is simple. It might look like this:</p><a id="I_programlisting2_d1e10669"/><pre class="programlisting">
void test_logical_not()
{
    assert(logical_not(true)  == false);
    assert(logical_not(false) == true);
}
</pre><p>The function doesn't do anything particularly exciting, though. Now consider the following function (let's not critique its elegance at the moment). How much harder is it to test?<a class="indexterm" id="IDX-CHP-8-0553"/></p><a id="I_programlisting2_d1e10676"/><pre class="programlisting">
int greatest_common_divisor(int a, int b)
{
    int low  = min(a, b);
    int high = max(a, b);

    int gcd = 0;
    for (int div = low; div &gt; 0; --div)
    {
        if ((low % div == 0) &amp;&amp; (high % div == 0))
            if (gcd &lt; div)
                gcd = div;
    }
    return gcd;
}
</pre><p>It's still a small snippet of code, but testing it is far more difficult for these reasons:<a class="indexterm" id="IDX-CHP-8-0554"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Although there are only two parameters, the set of valid input is extremely large. You can't conceivably test every possible combination of values; it would take a <span class="emphasis"><em>very</em></span> long time.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-3" id="CHP-8-FN-3">3</a>]</sup> Adding more parameters to a function extends this problem exponentially.</p></li><li class="listitem"><p>It contains a loop. Any form of branch (including a <code class="literal">for</code> loop) adds complexity and more potential for failure.</p></li><li class="listitem"><p>There are several conditional statements. You now have to arrange to exercise the code running through each combination of conditions to check that each side works.</p></li></ul></div><p>And that's just for a single small function. There's <span class="emphasis"><em>already</em></span> a fault in there, did you notice it? Can you find it? Ten points and a gold star if you can.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-4" id="CHP-8-FN-4">4</a>]</sup></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>It's very easy to trust the code you read and to believe that it's correct. When you've just written some code, you'll read what you</em></span> intended <span class="emphasis"><em>to write, not what you actually wrote. Learn to look twice—read</em></span> all <span class="emphasis"><em>code cynically</em></span>.</p></dd></dl></div><p>Those three problems aren't the only reasons software gets harder to test. There are plenty of other ways to increase test complexity.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Code size</strong></span></span></dt><dd><p>The more code there is, the more room for potential faults, and the more individual paths of execution that must be traced through to check validity.</p></dd><dt><span class="term"><span class="strong"><strong>Dependencies</strong></span></span></dt><dd><p>Testing one small piece of code should be easy. But if the test harness has to attach the rest of the codebase before it will do anything, then it becomes too painful (and too time consuming) to write any tests. In this case, either testing doesn't happen, or the tests aren't comprehensive enough, since it's too hard to orchestrate all of the attached code components. This is an example of <span class="emphasis"><em>untestable design</em></span>. We'll look at remedies for this later (in "<a class="xref" href="ch08s06.html" title="Design for Test">Design for Test</a>" on page 143).</p><p>The next two sections are also examples of kinds of inter-code dependency.</p></dd><dt><span class="term"><span class="strong"><strong>External inputs</strong></span></span></dt><dd><p>Any reliance on the state of an external part of the system is essentially another input. Unlike function parameters, it's not easy to arrange for these external inputs to take on certain test values. A shared global variable can't be set to an arbitrary value without compromising other parts of the running program.<a class="indexterm" id="IDX-CHP-8-0555"/></p></dd><dt><span class="term"><span class="strong"><strong>External stimuli</strong></span></span></dt><dd><p>The code may react to stimuli other than function calls. It's particularly troublesome when they may occur asynchronously (at any time), and with any frequency.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A class can act on callbacks from other parts of the system, which may crop up at any time.</p></li><li class="listitem"><p>Hardware interface code reacts to changes in physical device state.</p></li><li class="listitem"><p>Communication with other systems may take any length of time. Physical connections are prone to interference, so they may degrade, and network connections can be unreliable.</p></li><li class="listitem"><p>User interface code is driven by the user's mouse gestures. It's hard to physically automate a GUI in test conditions.</p></li></ul></div><p>These conditions are hard to simulate in an artificial test environment, and they may be particularly timing sensitive (for example, the speed of mouse double clicks or the frequency of hardware-generated interrupts).<a class="indexterm" id="IDX-CHP-8-0556"/></p><p>Some outside influences are unplanned: memory may run low, disk space may become exhausted, and network connections may fail. You have to ensure that your code is robust in <span class="emphasis"><em>all</em></span> prevailing environmental conditions.</p></dd><dt><span class="term"><span class="strong"><strong>Threads</strong></span></span></dt><dd><p>Multiple threads of control make testing more complex, since the concurrent code may intertwine in any arbitrary sequence. The complex interplay of execution paths means that any given test run may never be repeatable. Thread faults leading to deadlock or starvation may be hard to trigger, but they cause serious problems when they do crop up.<a class="indexterm" id="IDX-CHP-8-0557"/><a class="indexterm" id="IDX-CHP-8-0558"/><a class="indexterm" id="IDX-CHP-8-0559"/></p><p>The program's threaded behavior will be different on truly parallel multiprocessor systems to the behavior exhibited under simulated concurrency on single-processor time-slicing environments.</p></dd><dt><span class="term"><span class="strong"><strong>Evolution</strong></span></span></dt><dd><p>Software evolves. This evolution tends to break tests. If the requirements are not pinned down, your early tests will probably be invalid by the time you come to deliver because the APIs will have changed, the functionality will be completely different, and a full set of tests will not have been created because development never stood still long enough.<a class="indexterm" id="IDX-CHP-8-0560"/></p><p>We require stable interfaces both in our own code and any external code we rely on. In the Real World, this is an impractical ideal—the code will never stand still—so we must craft small, malleable tests that can be easily modified alongside the code.</p></dd><dt><span class="term"><span class="strong"><strong>Hardware faults</strong></span></span></dt><dd><p>Faults exist in hardware as well as in software. Work in an embedded environment is generally more likely to run into hardware errors, because you're closer to the metal. Hardware faults can be an order of magnitude more difficult to diagnose and fix; they are seldom repeatable, and you'll naturally distrust your software first.</p></dd><dt><span class="term"><span class="strong"><strong>Nasty failure modes</strong></span></span></dt><dd><p>Code can fall over in a multitude of exciting and bizarre ways. Program faults don't just lead to <span class="emphasis"><em>incorrect output</em></span>—there's more to contend with: infinite loops, deadlock, starvation, program crashes, OS lock-ups, and other potential failures raise their ugly heads to make testing a varied and exciting thing. A pathological software failure may even lead to physical damage to hardware!<sup>[<a class="footnote" href="#ftn.CHP-8-FN-5" id="CHP-8-FN-5">5</a>]</sup> Write a test harness to check for <span class="emphasis"><em>that</em></span>.</p></dd></dl></div><p>Writing a test harness is no small feat. When components get glued together and start relying on each other, the complexity of software expands exponentially. All of these problems gang up to make your life very complicated. This is when it becomes not just difficult, but technically infeasible to write harnesses that test the software <span class="emphasis"><em>exhaustively</em></span>. The time and resources do not exist to generate all the test data necessary, and to run the software over all sets of inputs and stimuli. The brute-force method rapidly becomes impractical, and it seems more convenient to ignore testing and just hope that there aren't any bugs.</p><p>No matter how hard you test, you still can't produce fault-free software—writing test code is as hard and requires as much skill as writing regular code. Some errors will invariably slip through even the most rigorous testing (studies show that the most carefully tested software still contains 0.5 to 3 errors per 1,000 lines of code). (Myers 86) Testing in the Real World rarely proves that software is bulletproof—merely that it is <span class="emphasis"><em>adequate</em></span>.<a class="indexterm" id="IDX-CHP-8-0562"/></p><p>With this in mind, we need to focus on the key tests that are likely to capture the majority of software defects for the most effective testing. We'll see how to choose these later.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-3" id="ftn.CHP-8-FN-3">3</a>] </sup>The higher your input values, the longer the <code class="literal">for</code> loop will take. Assuming an <code class="literal">int</code> is a 32-bit value (meaning there are 264 input combinations) and you have a nice, fast machine (let's say that every function call will take one millisecond—<span class="emphasis"><em>that's one hell of a processor cache</em></span>), a brute-force test would take almost 600 million years! And that's without printing out any test results. . . .</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-4" id="ftn.CHP-8-FN-4">4</a>] </sup>Look at the answer to this chapter's first "<a class="xref" href="ch08s12.html#mull_it_over-id7" title="Mull It Over">Mull It Over</a>" question (page 494) to find out what it is.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-5" id="ftn.CHP-8-FN-5">5</a>] </sup>This is no joke. The 68000 processor had an undocumented <span class="emphasis"><em>stop and catch fire</em></span> instruction—a bus test operation that rapidly cycled the address lines, causing the circuit board to overheat and catch on fire.<a class="indexterm" id="IDX-CHP-8-0561"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_types_of_test"/>The Types of Test</h1></div></div></div><p>There are many different kinds of software tests, and no one is better than any other. Each method approaches the code from a different direction and will catch a different class of faults. All are needed.<a class="indexterm" id="IDX-CHP-8-0563"/><a class="indexterm" id="IDX-CHP-8-0564"/><a class="indexterm" id="IDX-CHP-8-0565"/><a class="indexterm" id="IDX-CHP-8-0566"/><a class="indexterm" id="IDX-CHP-8-0567"/><a class="indexterm" id="IDX-CHP-8-0568"/><a class="indexterm" id="IDX-CHP-8-0569"/><a class="indexterm" id="IDX-CHP-8-0570"/><a class="indexterm" id="IDX-CHP-8-0571"/><a class="indexterm" id="IDX-CHP-8-0572"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Unit testing</strong></span></span></dt><dd><p>The term <span class="emphasis"><em>unit test</em></span> is commonly used to mean testing a <span class="emphasis"><em>module</em></span> of code (say a library, device driver, or protocol stack layer), but it really describes the testing of atomic units: each class or function.</p><p>Unit testing is performed in strict isolation. Any untrusted external code with which the unit interfaces is replaced with a stub or simulator—this ensures that you only trap bugs in <span class="emphasis"><em>this</em></span> unit, not bugs caused by outside influences.</p></dd><dt><span class="term"><span class="strong"><strong>Component testing</strong></span></span></dt><dd><p>A step up from unit testing, this validates the combination of one or more units into a full component. Often this is what people mean by <span class="emphasis"><em>unit test</em></span>.</p></dd><dt><span class="term"><span class="strong"><strong>Integration testing</strong></span></span></dt><dd><p>This tests the combination of components as they are brought together in the system, ensuring that they interconnect properly.<a class="indexterm" id="IDX-CHP-8-0573"/></p></dd><dt><span class="term"><span class="strong"><strong>Regression testing</strong></span></span></dt><dd><p>This is retesting after fixes or modifications are made to the software or to its environment. You run regression tests to ensure that the software works as it did before and that your modification hasn't broken anything along the way. When you work with brittle software, a change in one place can cause strange faults to appear elsewhere. Regression testing helps to guard against this.</p><p>It can be difficult to determine how much retesting is needed, especially near the end of the development cycle. Automated test tools are especially useful for this type of testing. I'll discuss this in detail in "<a class="xref" href="ch08s07.html" title="Look! No Hands!">Look! No Hands!</a>" on page 144.</p></dd><dt><span class="term"><span class="strong"><strong>Load testing</strong></span></span></dt><dd><p>You perform load tests to ensure that your code can handle the expected volume of data being thrown at it. It's simple to write code that generates a good answer, but doing so in a timely manner is another thing. This can unearth problems related to the efficiency of a system, perhaps due to incorrect buffer sizes, bad memory usage, or inadequate database design. Load testing checks that the program "scales up" as expected.</p></dd><dt><span class="term"><span class="strong"><strong>Stress testing</strong></span></span></dt><dd><p>Stress testing throws a <span class="emphasis"><em>huge</em></span> amount of data at the code within a short space of time to see what it does. It's similar to load testing, often used for high-availability systems. Stress tests check the characteristics of the system: how tolerant it is to overloading. Load testing is performed to prove that the code can meet its <span class="emphasis"><em>expected</em></span> demands; stress testing makes sure that it won't just crumple in a heap if it receives a real battering. The code doesn't have to keep working perfectly; it just has to fail gracefully and recover well.<a class="indexterm" id="IDX-CHP-8-0574"/><a class="indexterm" id="IDX-CHP-8-0575"/></p><p>Stress testing helps determine the capacity of the software—how hard you can push before it falls over. It is especially pertinent in threaded or real-time systems.</p></dd><dt><span class="term"><span class="strong"><strong>Soak testing</strong></span></span></dt><dd><p>Soak testing is similar to stress testing. The focus is on running at a high load for a prolonged period of time—several days, weeks, or even months—to identify any performance problems that appear after a large number of operations have been executed. Soak testing reveals faults that might otherwise go undetected: small memory leaks that eventually crash the program or performance degradation as internal data structures slowly become fragmented.</p></dd><dt><span class="term"><span class="strong"><strong>Usability testing</strong></span></span></dt><dd><p>Ensures that your software can be used easily by a shortsighted gerbil. There are various forms of end-user tests, often performed in <span class="emphasis"><em>usability labs</em></span> under very controlled and scripted conditions. We also test software in <span class="emphasis"><em>field trials</em></span>, putting it in a Real World setting to see what users think.<a class="indexterm" id="IDX-CHP-8-0576"/></p><div class="sidebar"><a id="alpha_comma_beta_comma_gamma_._._."/><p class="title"><b>ALPHA, BETA, GAMMA . . .</b></p><p>What about <span class="emphasis"><em>alpha</em></span> and <span class="emphasis"><em>beta</em></span> testing? They are common terms, but not quite in the same league as the other tests we've looked at here. They are more focused on final <span class="emphasis"><em>product</em></span> testing than on the implementation of particular bits of <span class="emphasis"><em>code</em></span>. Nevertheless, they deserve some explanation.<a class="indexterm" id="IDX-CHP-8-0577"/><a class="indexterm" id="IDX-CHP-8-0578"/></p><p>Happily, the terms have no formal definition. Each company will have its own idea of what software in an <span class="emphasis"><em>alpha</em></span> or <span class="emphasis"><em>beta</em></span> state is. For all you know, alpha software might be made of lemon jelly and explode on exposure to light. Alpha or beta software is often released externally, as an advance customer preview—an early chance to elicit feedback and garner confidence.<a class="indexterm" id="IDX-CHP-8-0579"/><a class="indexterm" id="IDX-CHP-8-0580"/></p><p>These are common interpretations of the terms:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Alpha software</strong></span></span></dt><dd><p>The first "code complete" stage. It may still have many, many bugs, and be completely unreliable. Alpha software provides a good representation of what the final product will be like, if you can look past the obvious flaws.</p></dd><dt><span class="term"><span class="strong"><strong>Beta software</strong></span></span></dt><dd><p>Well past the alpha stage, beta software is <span class="emphasis"><em>mostly</em></span> bug free; there are very few remaining problems. It's not too far from a final product. Beta testing (that is, testing <span class="emphasis"><em>beta</em></span> software) is used in the run up to final release candidates to nail the remaining issues. Beta testing usually involves Real World field trials.</p></dd><dt><span class="term"><span class="strong"><strong>Release candidate</strong></span></span></dt><dd><p>This is the final stage before a formal software release. Candidate builds go through verification and <span class="emphasis"><em>assurance testing</em></span> (validation) prior to the production release. Release candidates are internal builds, usually going to the test department only.<a class="indexterm" id="IDX-CHP-8-0581"/></p></dd></dl></div><p>If alpha and beta releases venture to the outside world, they may have some form of crippling (time-limited operation, for example). The release candidates are "pure" builds, without any of these limitations.</p></div><p>When we write unit and component tests, there are two main approaches to devising the test cases: <span class="emphasis"><em>black box</em></span> and <span class="emphasis"><em>white box</em></span> testing.</p></dd><dt><span class="term"><span class="strong"><strong>Black box testing</strong></span></span></dt><dd><p>This is also known as <span class="emphasis"><em>functional testing</em></span>. Black box testing compares actual functionality against intended functionality. The internal workings of the code are not known by the tester; it is seen as a <span class="emphasis"><em>black box</em></span>. The designer and tester can be independent of each other.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-6" id="CHP-8-FN-6">6</a>]</sup></p><p>Black box testing is not concerned that every line of code is tested, only that it meets the software's specification—that if you put the right things into one end of the box, the right things come out the other. Therefore, without clear specifications and documented APIs, it is very hard to devise black box tests.</p><p>Black box test cases can be designed as soon as the software specification is complete. They rely on the specification being correct in the first place and on it not being radically altered after the tests have been devised.</p></dd><dt><span class="term"><span class="strong"><strong>White box testing</strong></span></span></dt><dd><p>This is also known as <span class="emphasis"><em>structural testing</em></span>. It is a code-coverage-based approach. Each line of code is scrutinized systematically to ensure correctness. Where you couldn't see into the black box beforehand, you now can and do. For this reason, white box testing is sometimes called <span class="emphasis"><em>glass box</em></span> testing. It is really only concerned with testing the lines of code produced, and it doesn't guarantee that they meet their specifications.<a class="indexterm" id="IDX-CHP-8-0582"/><a class="indexterm" id="IDX-CHP-8-0583"/></p><p>There are <span class="emphasis"><em>static</em></span> and <span class="emphasis"><em>dynamic</em></span> methods of white box testing. Static tests do not run the code; instead, it is inspected and walked through to ensure that it represents a valid solution. Dynamic tests run the code and are concerned with path and branch testing—trying to visit every line of code and execute every decision. This may require some modification of the code to force control down certain paths. Such modification can be easier than trying to engineer test cases for all behavioral combinations.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-7" id="CHP-8-FN-7">7</a>]</sup></p><p>White box testing is laborious and much more expensive than black box; consequently, it is done a lot less. The completed code is needed before white box tests can even be planned. Black box testing is typically done before white box testing starts. The consequence of a failure at this stage is much more expensive. You'd have to code a fix, black box test again, then devise and run new white box tests.</p><p>Tools exist to instrument your code and measure the test coverage. Without tool support, white box testing could make your head explode.</p></dd></dl></div><p>Black box testing is concerned with faults of <span class="emphasis"><em>omission</em></span> (where the software misses out some of the specified behavior), while white box testing discovers faults of <span class="emphasis"><em>commission</em></span> (where parts of the implementation are faulty). In order to fully test a software unit, both black and white box testing is required.</p><div class="sidebar"><a id="test_time"/><p class="title"><b>TEST TIME</b></p><p>Each of these test methods is employed at different points in the development process. The following table illustrates this, showing which tests are most important at each point.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Stage of Development</p></th><th style="text-align: left" valign="bottom"><p>Is Black or White Box Appropriate?</p></th><th style="text-align: left" valign="bottom"><p>Common Testing Approaches at This Stage of Development</p></th><th style="text-align: left" valign="bottom"><p>Who Performs the Test?</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Requirements gathering</p></td><td style="text-align: left" valign="top"><p>Black</p></td><td style="text-align: left" valign="top"><p>Black box tests devised</p></td><td style="text-align: left" valign="top"><p>Developers, QA</p></td></tr><tr><td style="text-align: left" valign="top"><p>Code design</p></td><td style="text-align: left" valign="top"><p>Black</p></td><td style="text-align: left" valign="top"><p>Black box tests devised</p></td><td style="text-align: left" valign="top"><p>Developers, QA</p></td></tr><tr><td style="text-align: left" valign="top"><p>Code construction</p></td><td style="text-align: left" valign="top"><p>Black, white</p></td><td style="text-align: left" valign="top"><p>Unit, component, regression</p></td><td style="text-align: left" valign="top"><p>Developers</p></td></tr><tr><td style="text-align: left" valign="top"><p>Code integration</p></td><td style="text-align: left" valign="top"><p>Black, white</p></td><td style="text-align: left" valign="top"><p>Component, integration, regression</p></td><td style="text-align: left" valign="top"><p>Developers</p></td></tr><tr><td style="text-align: left" valign="top"><p>Alpha status</p></td><td style="text-align: left" valign="top"><p>Black, white</p></td><td style="text-align: left" valign="top"><p>Regression, load, stress, soak, usability</p></td><td style="text-align: left" valign="top"><p>Developers, QA</p></td></tr><tr><td style="text-align: left" valign="top"><p>Beta status</p></td><td style="text-align: left" valign="top"><p>Black, white</p></td><td style="text-align: left" valign="top"><p>Regression, load, stress, soak, usability</p></td><td style="text-align: left" valign="top"><p>QA</p></td></tr><tr><td style="text-align: left" valign="top"><p>Release candidate</p></td><td style="text-align: left" valign="top"><p>Black, white</p></td><td style="text-align: left" valign="top"><p>Regression, load, stress, soak</p></td><td style="text-align: left" valign="top"><p>QA</p></td></tr><tr><td style="text-align: left" valign="top"><p>Release</p></td><td style="text-align: left" valign="top"><p>Black, white</p></td><td style="text-align: left" valign="top"><p>It's too late by now . . .</p></td><td style="text-align: left" valign="top"><p>Users (good luck)</p></td></tr></tbody></table></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-6" id="ftn.CHP-8-FN-6">6</a>] </sup>However, this isn't necessarily a good idea—a programmer is usually the best person to write the unit test for the code he or she creates.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-7" id="ftn.CHP-8-FN-7">7</a>] </sup>If you do modify the source code, then you're not actually testing the final executable, which is concerning.<a class="indexterm" id="IDX-CHP-8-0584"/><a class="indexterm" id="IDX-CHP-8-0585"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="choosing_unit_test_cases"/>Choosing Unit Test Cases</h1></div></div></div><p>If testing is essential but exhaustive testing is impossible, you must judiciously choose the set of most effective tests. To do this, you need a thoughtful and methodical plan. You could take a <span class="emphasis"><em>scattergun</em></span> approach—just prop the code up on a wall and then fire everything that comes to hand at it. . . .<a class="indexterm" id="IDX-CHP-8-0586"/><a class="indexterm" id="IDX-CHP-8-0587"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e11341"/><img alt="Choosing Unit Test Cases" src="tagoreillycom20080909nostarchimages207464.png.jpg"/></div></div><p>That way you <span class="emphasis"><em>might</em></span> find some flaws. But without a sensible, staged testing approach, you'll never have the quality tests that will give you proper confidence in your code. Instead of the scattergun, you should pick up a rifle with an accurate sight and aim careful shots at the code, hitting well-judged marks, to see how well it stands up.</p><p>Where do you aim? How do you determine the volley of test data to launch? Since you can't try every possible value, you need to select a handful of pertinent inputs. You must pick the tests that are most likely to disclose the software's faults, rather than run tests that just show the same few problems repeatedly.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Write a comprehensive suite of tests, each one exercising a different aspect of the code. Fifteen tests that demonstrate the same fault over and over are less useful than fifteen tests that show fifteen different faults</em></span>.</p></dd></dl></div><p>To do this, you must understand the requirements for your piece of code. You can't write an accurate test case unless you know what it's supposed to do. It might be doing the wrong thing very well.</p><p>When black box testing, some test cases will be:<a class="indexterm" id="IDX-CHP-8-0588"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Some good input</strong></span></span></dt><dd><p>Select a number of well-chosen <span class="emphasis"><em>good</em></span> inputs to ensure that the software works properly in the normal cases.</p><p>Cover the whole range of valid input values; include some middle of the road values, some values from around the lower bounds of acceptable input, and some from the upper bounds.</p></dd><dt><span class="term"><span class="strong"><strong>Some bad input</strong></span></span></dt><dd><p>Just as important are a certain number of well-chosen <span class="emphasis"><em>bad</em></span> inputs. This ensures that the software is robust and doesn't give misleading answers to invalid input.<a class="indexterm" id="IDX-CHP-8-0589"/></p><p>You must consider all sorts of bad data, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Values that are numerically far too large or far too small (handling negative values is often overlooked)</p></li><li class="listitem"><p>Input that is too long or too short (string lengths are a classic example—try sending an empty string to see what happens, or try different-sized arrays and lists)</p></li><li class="listitem"><p>Data values that are internally inconsistent (what this means will depend on the contract of the function; perhaps it expects values in a certain order)</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Boundary values</strong></span></span></dt><dd><p>Test <span class="emphasis"><em>all</em></span> the boundary cases—they are a rich source of error. Identify the highest and lowest inputs that are valid, or wherever the natural input boundaries are (perhaps where behavior changes). For each of these positions, test the code's behavior at:<a class="indexterm" id="IDX-CHP-8-0590"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The boundary value itself</p></li><li class="listitem"><p>The values just above it</p></li><li class="listitem"><p>The values just below it</p></li></ul></div><p>This ensures that your software works correctly right into the corners, and that it then gives up exactly when expected.</p><p>Boundary tests catch the all-too-easy mistakes, like typing <code class="literal">&gt;</code> instead of <code class="literal">&gt;=</code>, or getting loop count bases wrong (did you start counting from zero or one?). All three boundary tests are needed to check for these kinds of mistakes.<a class="indexterm" id="IDX-CHP-8-0591"/></p></dd><dt><span class="term"><span class="strong"><strong>Random data</strong></span></span></dt><dd><p>Test randomly generated sets of input data to avoid guesswork. This is a surprisingly effective test strategy. If you can write an automated test harness that repeatedly generates and applies random data, you stand a good chance of picking up subtle errors that you would have never thought of otherwise.</p></dd><dt><span class="term"><span class="strong"><strong>Zero</strong></span></span></dt><dd><p>If the input is numeric, always test for the zero case. For some reason, programmers fail to think properly about zero, a blind spot in their reasoning.</p><p>C/C++ pointers are often given a zero value to mean <span class="emphasis"><em>unset</em></span> or <span class="emphasis"><em>undefined</em></span>. Try throwing zero pointers at your code to see if it reacts correctly. In Java, you can send <code class="literal">null</code> object references for a similar effect.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="design_for_test"/>Design for Test</h1></div></div></div><p>The quality of unit test you can write is determined largely by the quality of the interface you have to test. Testing is easier when your code is written thoughtfully and specifically designed to accommodate inspection and verification. You achieve this by crafting clear APIs, reducing reliance on other bits of code, and breaking any hard-coded links to other components. This way, it's easy to place a component into its test environment and stimulate it. If, instead, it's grafted intimately into other sections of code, you have to drag all of that code into the test environment and arrange for it to interact with your unit appropriately. This is not always easy, and often impossible, limiting your scope for possible tests.<a class="indexterm" id="IDX-CHP-8-0592"/><a class="indexterm" id="IDX-CHP-8-0593"/><a class="indexterm" id="IDX-CHP-8-0594"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Design your code for easy testing</em></span>.</p></dd></dl></div><p>There's a helpful side effect of this rule: When you structure code for testability, you will be structuring it in a sensible, understandable, and maintainable way. You'll reduce component coupling and increase cohesion. You'll make it more flexible, easy to use, and easier to wire up in different configurations. Your code will be better.<a class="indexterm" id="IDX-CHP-8-0595"/><a class="indexterm" id="IDX-CHP-8-0596"/></p><p>And since you've tested it well, the code is more likely to be correct.</p><p>You must design for tests up front. You can't easily return to an old component and bolt a "testable" interface onto it. If a lot of other code relies on the existing interface, then such modifications are hard. Remember: You're most likely to design geniunely testable code if you write unit tests alongside the code.<a class="indexterm" id="IDX-CHP-8-0597"/></p><p>A few simple design rules lead to highly testable code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Make each section of code self-contained, without undocumented and tenuous dependencies on the outside world. Don't hard-code links to other parts of the system; rely on abstract interfaces that could be implemented by system components or by test simulators.</p></li><li class="listitem"><p>Don't rely on global variables (or <span class="emphasis"><em>singleton</em></span> objects, which are thin veneers for globals). Gather such states in a shared structure passed as an argument.<a class="indexterm" id="IDX-CHP-8-0598"/><a class="indexterm" id="IDX-CHP-8-0599"/></p></li><li class="listitem"><p>Limit the complexity of your code; break it into small, comprehensible, bite-sized chunks that can be individually tested.</p></li><li class="listitem"><p>Make the code observable, so you can see what it's doing, query internal state, and ensure that it's operating as expected.</p></li></ul></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="look_exclamation_no_hands_exclamation"/>Look! No Hands!</h1></div></div></div><p>You can't hang around all day turning the handle on your test machinery. Manually invoking test after test isn't my idea of a great day's programming. Repeated regression testing would rapidly get boring. It wouldn't just be boring, but also slow, inefficient, and prone to human error. The golden testing rule is simple: <span class="emphasis"><em>Automate</em></span>.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Automate your code testing as much as possible. It's quicker and easier than running tests by hand, and it's far safer: The tests are more likely to be run regularly</em></span>.</p></dd></dl></div><p>If the tests run without any intervention, they can be triggered as a validation phase of your build procedure. Before you play with some freshly built software, you'll know the unit tests have automatically run and passed; you're assured that there are no silly programming errors and that any new work hasn't broken old code.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Run unit tests automatically as a part of your build process</em></span>.</p></dd></dl></div><p>You can gather your individual pieces of test code together in an automated scaffold that marshals the test execution and gathers the results of the testing in a single place. This harness monitors which tests have been done; the more complex test harnesses maintain a history of test results over time. There are many such popular tools, like JUnit, a common Java unit test framework.<a class="indexterm" id="IDX-CHP-8-0600"/></p><p>A high level of automation comes into its own during regression testing. If you make a modification to the code and want to ensure that you haven't accidentally broken anything, you can run the whole set of tests automatically; out of the end pops a <span class="emphasis"><em>yes</em></span> or <span class="emphasis"><em>no</em></span> answer. Of course, the regression test result is only ever as good as the tests put into the harness.<a class="indexterm" id="IDX-CHP-8-0601"/></p><p>Automation really is a fundamental concept for solid code development. If you don't currently have an automated suite of unit tests, acting as a continual regression test of your codebase, then get one. Your work will quickly improve in quality.</p><p>Sadly, not all tests <span class="emphasis"><em>can</em></span> be automated. Unit testing library functions is relatively easy; automatically testing user interfaces is very hard. How do you emulate mouse clicks, check the Urdu translation of a text string, or ensure that the correct sound clip is playing?</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_face_of_failure"/>The Face of Failure</h1></div></div></div><div class="epigraph"><p><span class="emphasis"><em>Our greatest glory is not in never falling, but in rising every time we fall</em></span>.<a class="indexterm" id="IDX-CHP-8-0602"/></p><div class="attribution"><span>--<span class="attribution">Confucius</span></span></div></div><p>What do you do when your testing finds a program failure? Before you rush in headlong to debug it, step back and characterize the problem. This is especially important when you don't intend (or have no time) to repair it right away. Follow these steps to pin down the nature of the fault so that you, or any other developer, can come back later and attempt to sort it out.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Note what you were trying to do at the time and which actions triggered the failure.</p></li><li class="listitem"><p>Try it again. Discover whether the problem is repeatable, how frequently it crops up, and whether it coincides with any other activities going on at the same time.</p></li><li class="listitem"><p>Describe the fault. Fully. Be very specific. Include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The context of problem</p></li><li class="listitem"><p>The simplest steps that can replicate it</p></li><li class="listitem"><p>Information about repeatability and frequency of occurrence</p></li><li class="listitem"><p>The version of the software, exact build number, and hardware used</p></li><li class="listitem"><p>Anything else that might conceivably relate</p></li></ul></div></li><li class="listitem"><p>Record it. Don't lose it! Put this information in your fault-tracking system, even if it's a simple coding error that you intend to fix yourself (see "<a class="xref" href="ch08s09.html" title="Can You Manage It?">Can You Manage It?</a>" next).</p></li><li class="listitem"><p>Write the simplest test harness that will demonstrate the failure, and add it to the suite of automatic tests. This will ensure that the fault cannot be lost or ignored and, once it's eventually fixed, won't reoccur later in development.</p></li></ol></div><p>Remember, testing is <span class="emphasis"><em>not</em></span> debugging—and these steps are <span class="emphasis"><em>not</em></span> debugging! You've not tried to unveil the cause of the failure, or peek into the code, just to establish enough information to describe the problem to another developer.</p><p>Our favorite kind of fault is a repeatable fault. Really—we like code that falls over repeatedly: It's easy to replicate the problem; therefore it's easy to track down the fault and easy to prove that you've fixed it. Nasty failures are irregular, even random, and consequently hard to characterize. Failures that take an eon to manifest and depend upon the wind speed are a nightmare.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="can_you_manage_it_question"/>Can You Manage It?</h1></div></div></div><p>You must be methodical and systematic in order to <span class="emphasis"><em>find</em></span> faults. You must also be methodical and systematic in your management and handling of them. Before releasing code (or checking it into source control), you are the only person who'd be bitten by its gremlins. But as soon as it leaves your care, code takes on a life of its own. It's no longer just <span class="emphasis"><em>you</em></span> who is concerned with its faults. The rules change as more players join the game:<a class="indexterm" id="IDX-CHP-8-0603"/><a class="indexterm" id="IDX-CHP-8-0604"/><a class="indexterm" id="IDX-CHP-8-0605"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A programmer will find problems at the codeface—in his own code and in other people's.</p></li><li class="listitem"><p>The code integrator will find errors as components are glued together.</p></li><li class="listitem"><p>The QA department will find faults in the product as it tests.</p></li></ul></div><p>With so many people finding so many problems while others are simultaneously trying to make fixes, there had better be a good procedure for managing it all. Otherwise, the result will be a mess, and development will come crashing down around everyone's heads.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="fault-tracking_system"/>Fault-Tracking System</h2></div></div></div><p>Our key weapon in managing faults is a <span class="emphasis"><em>fault-tracking system</em></span>. This tool is a specialized database with interfaces visible to everyone who has a hand in the testing process.<a class="indexterm" id="IDX-CHP-8-0606"/><a class="indexterm" id="IDX-CHP-8-0608"/><a class="indexterm" id="IDX-CHP-8-0609"/><a class="indexterm" id="IDX-CHP-8-0607"/></p><p>As bugs are discovered and dealt with, this database is updated to reflect the status of the software. In doing so, the fault-tracking tool becomes an integral part of the project's <span class="emphasis"><em>fault-management procedure</em></span>. The general actions performed are:<a class="indexterm" id="IDX-CHP-8-0610"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Report a failure</strong></span></span></dt><dd><p>When you find a bug, make a new entry for it in the database by creating a <span class="emphasis"><em>fault report</em></span>. It becomes a fully paid-up member of the fault club, with its own personal membership number. This reference number uniquely identifies it for future use. The bug now cannot be overlooked. It <span class="emphasis"><em>must</em></span> be addressed before the software is shipped.<a class="indexterm" id="IDX-CHP-8-0611"/></p><p>Creating a report also alerts others in the team that this fault has been found; they don't need to enter the same information when they run into it.</p></dd><dt><span class="term"><span class="strong"><strong>Assign responsibility</strong></span></span></dt><dd><p>This marks a fault report for a particular person's attention. It defines who is responsible for fixing (or making sure that someone fixes) each problem. Without this idea of ownership, every programmer will think that someone else is going to fix the fault, while the bug works its way through the cracks.<a class="indexterm" id="IDX-CHP-8-0613"/><a class="indexterm" id="IDX-CHP-8-0612"/></p></dd><dt><span class="term"><span class="strong"><strong>Prioritize reports</strong></span></span></dt><dd><p>The fault-tracking system allows you to mark which faults are the most important. A repeatable startup crash is clearly more serious than a button that's occasionally shifted one pixel to the right.<a class="indexterm" id="IDX-CHP-8-0614"/></p><p>By differentiating the show-stopping faults from little annoyances, developers can plan their work and choose which faults need to be fixed first. There may be various levels of severity supported by the tool—from critical faults, though medium-to-low priority issues, to feature requests.</p></dd><dt><span class="term"><span class="strong"><strong>Mark as fixed</strong></span></span></dt><dd><p>A developer will do this once a repair has been made. It doesn't close the fault report but places it on a pile ready for verification. The person who submits the report is responsible for testing that the fix is correct, although he can delegate this task. A fix certainly shouldn't be verified by the person who made it, for obvious reasons.</p></dd><dt><span class="term"><span class="strong"><strong>Close a report</strong></span></span></dt><dd><p>Once verified, a report can be closed, becoming nothing more than a distant memory (and perhaps a project statistic).</p><p>There may be other scenarios leading to report closure—the issue may not have been a fault at all, perhaps just a characteristic of the system, or even perfectly valid behavior. Testers are fallible too.</p><p>Instead of closing a report you don't intend to deal with, you can <span class="emphasis"><em>defer</em></span> it, marking the fault to be fixed in a later software revision.</p></dd><dt><span class="term"><span class="strong"><strong>Query the database</strong></span></span></dt><dd><p>You can query the fault-tracking system for information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Naturally, you can produce a list of all the pending fault reports, ordering them by software version, assignee, priority, or whatever.</p></li><li class="listitem"><p>You can discover which faults have been assigned to you.</p></li><li class="listitem"><p>You can produce a report on which faults have been fixed in each software version. This is helpful for preparing <span class="emphasis"><em>release notes</em></span>.</p></li><li class="listitem"><p>You can also view project statistics—how many faults have been reported during development, how many have been fixed, and the rate of closure versus generation. Presented graphically, this can give a good impression of how well the software is progressing.</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Modify an entry</strong></span></span></dt><dd><p>You can open a report and alter the information it contains. This includes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Adding comments for any new information you've found</p></li><li class="listitem"><p>Attaching log files, containing example output, to illustrate the problem</p></li><li class="listitem"><p>Marking a report as a duplicate of another fault, to prevent later confusion</p></li></ul></div><p>There are plenty of fault-tracking tools available, both commercial and freely available versions, like the popular Bugzilla system developed as a part of the Mozilla project.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="bug_reviews"/>Bug Reviews</h2></div></div></div><p>Toward the end of product development, as release deadlines inch ever nearer, <span class="emphasis"><em>bug review</em></span> meetings become a part of life, occurring about once a week. These reviews are scheduled once functionality is complete but before all the bugs are ironed out—the long home stretch of the development process. They provide an overview of the project's progress to all interested parties, help plan the remaining repair work, and shepherd the software toward release.<a class="indexterm" id="IDX-CHP-8-0615"/><a class="indexterm" id="IDX-CHP-8-0616"/><a class="indexterm" id="IDX-CHP-8-0617"/><a class="indexterm" id="IDX-CHP-8-0618"/></p><p>These meetings are attended by an eclectic bunch of people:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The software developers responsible for the product. (They'll be doing the fixing, after all.)</p></li><li class="listitem"><p>Representatives from the test team, who will explain the context of faults and ensure the bug review is steering in the correct direction. (More often than not, it's their responsibility to convene the meeting.)</p></li><li class="listitem"><p>Product managers, who will gain an overview of the progress and will make <span class="emphasis"><em>the buck stops here</em></span> decisions.</p></li><li class="listitem"><p>Commercial and marketing team members, who are the people that will have to sell this bug-ridden product. (Their viewpoint on the importance of each fault helps to decide which ones to fix and which to sweep under the digital carpet.)</p></li></ul></div><p>A list of outstanding fault reports is generated from the fault tracking tool, and each fault is discussed in turn during the meeting. Test or development team members may present additional information, if required, and then commercial decisions on the importance of the problem are made. Nasty lingering faults are discussed, with a progress report of the repair. If work is struggling, a decision to apply additional resources might be made.</p><p>With such a large range of people, the meeting can rapidly get off track, and it takes a strong-willed chairman to keep discussion focused and to the point. The topic is fault reports and how to deal with them, not specific code fixes. Programmers love to talk technical and try to solve every issue in the meeting. This is not the place for it.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-8" id="CHP-8-FN-8">8</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-8" id="ftn.CHP-8-FN-8">8</a>] </sup>Tactics for successful meetings are described in "<a class="xref" href="ch17s07.html#meeting_your_fate" title="MEETING YOUR FATE">MEETING YOUR FATE</a>" on page 340.<a class="indexterm" id="IDX-CHP-8-0619"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id7"/>In a Nutshell</h1></div></div></div><p>Testing is critical to producing good software. In general, the more testing, the better—although the <span class="emphasis"><em>quality</em></span> of the tests will be reflected in the quality of the final product. Poor tests will catch few faults, and the result will be a defective software release.<a class="indexterm" id="IDX-CHP-8-0620"/></p><p>We test at various levels of development, from individual functions, through component integration, to the final assembled program. At each stage, you must adopt a methodical approach to finding and managing software faults.</p><p>It is each programmer's responsibility to test his or her code. The QA department has enough problems to deal with apart from your buggy code. You can't perform testing and then add in software quality at end of development—it must be designed in from the start, with tests being developed and run alongside the code.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Write tests for all their code (possibly even <span class="emphasis"><em>before</em></span> they write the code)</p></li><li class="listitem"><p>Test at the <span class="emphasis"><em>micro</em></span> level, so <span class="emphasis"><em>macro</em></span>-level testing is not hindered by stupid coding mistakes</p></li><li class="listitem"><p>Care about product quality and take responsibility for it, playing their parts in the total testing effort</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don't consider testing to be an important and integral part of software development—<span class="emphasis"><em>it's someone else's job</em></span></p></li><li class="listitem"><p>Release untested code to the QA department and look surprised when testing uncovers faulty behavior</p></li><li class="listitem"><p>Make their lives more complicated by discovering problems too late—not testing early enough and then being hit by a slew of hard-to-locate faults</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id7"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a></span></dt><dd><p>What to do when you find a fault—the process of locating and fixing bugs.<a class="indexterm" id="IDX-CHP-8-0621"/><a class="indexterm" id="IDX-CHP-8-0622"/></p></dd><dt><span class="term"><a class="xref" href="ch20.html" title="Chapter 20. A REVIEW TO A KILL">Chapter 20</a></span></dt><dd><p><span class="emphasis"><em>Code reviews</em></span> are a testing technique—a manual form of static code analysis.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e12008"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207466.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id8"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 494.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id7"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Write a test harness for the <code class="literal">greatest_common_divisor</code> code example earlier in this chapter. Make it as exhaustive as you can. How many individual test cases have you included?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How many of these passed?</p></li><li class="listitem"><p>How many failed?</p></li><li class="listitem"><p>Using these tests, identify any faults and repair the code.</p></li></ol></div></li><li class="listitem"><p>How should the testing of a spreadsheet application and an automatic aircraft pilot differ?</p></li><li class="listitem"><p>Should you test all of the <span class="emphasis"><em>test code</em></span> that you write?</p></li><li class="listitem"><p>How does a programmer's testing differ from a QA department member's testing?</p></li><li class="listitem"><p>Is it necessary to write a test harness for every single function?</p></li><li class="listitem"><p><span class="emphasis"><em>Test-driven development</em></span> encourages you to write tests first, before any code. What sort of tests should you write?</p></li><li class="listitem"><p>Should you write C/C++ tests to check for the handling of <code class="literal">NULL</code> (zero) pointer parameters? What's the value of such a test?</p></li><li class="listitem"><p>Your early code tests might not be on the final platform—you may not yet have access to it. Is it safest to defer testing until you <span class="emphasis"><em>do</em></span> have a target test platform, or to steam ahead now?</p><p>If the code is intended to run in a different environment (perhaps on a high-capacity server, or some embedded device), how can you be sure that your tests are representative and adequate?</p></li><li class="listitem"><p>How do you know when you've finished and can stop testing? How much is <span class="emphasis"><em>enough</em></span>?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id7"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>For what percentage of your code do you write tests? Are you happy with this? Are your tests an automated part of the build process? What sort of testing do you give the remaining code? Is this adequate? What will you do about it?<a class="indexterm" id="IDX-CHP-8-0623"/><a class="indexterm" id="IDX-CHP-8-0624"/><a class="indexterm" id="IDX-CHP-8-0625"/><a class="indexterm" id="IDX-CHP-8-0626"/><a class="indexterm" id="IDX-CHP-8-0627"/></p></li><li class="listitem"><p>How good is your relationship with the people in your QA department? What personal reputation do you think you have with them?</p></li><li class="listitem"><p>What's your usual response to finding an error in your code?</p></li><li class="listitem"><p>Do you file a fault report for every code problem you uncover?</p></li><li class="listitem"><p>How much testing are the project engineers expected to do?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="finding_fault"/>Chapter 9. FINDING FAULT</h1></div><div><h3 class="subtitle"><i>Debugging: What to Do When Things Go Wrong</i></h3></div></div></div><div class="epigraph"><p>I have not failed. I've just found 10,000 ways that won't work.</p><div class="attribution"><span>--<span class="attribution">Thomas Edison</span></span></div></div><p>Nobody's perfect. Well, except for me. All day, I have to sit down and work through tedious problems in other people's code. The test department discovers that our software falls over when it does <span class="emphasis"><em>such-and-such</em></span>. So I trawl through the system to find what Programmer Fred did wrong three years ago, patch it up, and send it back for them to break again.</p><p>Of course, you wouldn't find <span class="emphasis"><em>me</em></span> making those sorts of elementary mistakes—not a chance. My code is watertight. Faultless. Low fat and cholesterol free. I never write a line without meticulous planning, I won't complete a code statement without considering all the special cases that might occur, and I type so carefully that I've never once misplaced <code class="literal">=</code> for <code class="literal">==</code> in an <code class="literal">if</code> statement.</p><p>Totally fault free, me. Really.</p><p>Well, perhaps not quite.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_facts_of_life"/>The Facts of Life</h1></div></div></div><p>I don't think anyone sits trainee programmers down and explains the facts of life to them. <span class="emphasis"><em>It's like this, son. There are the birds and the bees. Oh, and the bugs</em></span>. Bugs are the inevitable dark side of constructing software, a simple fact of life. Sad, but true. Whole departments, and even industries, exist to manage them.</p><p>We're all aware of the proliferation of faults in released software. How do bugs appear with such frightening regularity and in such great magnitude? It all comes down to human nature. Programs are written by humans. Humans make mistakes. They make mistakes for a number of reasons (or excuses). They make mistakes because they don't understand the system they're working on well enough or because they don't correctly understand what they are implementing, but more often than not, they make mistakes because they just don't pay enough attention to what they're doing. Most bugs are due to mindlessness. I once saw a wonderfully simple illustration of this; play along at home:<a class="indexterm" id="IDX-CHP-9-0629"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The tree that grows from an acorn is called an . . .</p></li><li class="listitem"><p>The noise a frog makes is a . . .</p></li><li class="listitem"><p>The vapor that rises from fire is called . . .</p></li><li class="listitem"><p>The white of an egg is called the . . .</p></li></ul></div><p>The <span class="emphasis"><em>yolk</em></span>, right? Think about it. If you didn't fall for that one, then you were probably only paying attention because I'd just warned you. (Give yourself a brownie point anyway.) But tell me, who warns you every time you're about to write a potentially flawed line of code? If that person existed, he'd deserve a lifetime supply of brownie points.</p><p>As programmers, we're all to blame for the bad state of software. We're all guilty. Do we learn to live with the guilt, or do we do something about it? There are two types of responses. The first is the <span class="emphasis"><em>It's not a fault, it's a feature</em></span> school: Just make up an excuse and ignore it. A fault turns up, and we respond in the words of the great philosopher Bart Simpson: "I didn't do it. Nobody saw me do it. You can't prove anything!" (Simpsons 91) We blame compiler quirks, OS flaws, random climate changes, and computers with minds of their own. Or as I alluded to in the opening paragraphs, we blame other people. A Teflon raincoat is a handy programming tool.</p><p>However, we should really subscribe to the second school, the school that concedes that software errors are <span class="emphasis"><em>not</em></span> entirely inevitable. Many mindless mistakes can be picked up or even prevented, and as responsible programmers, we should be taking steps to do so. Defensive programming and sensible testing are our main weapons. In this chapter, we'll look at good debugging techniques to employ when bugs do slip through the net.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="nature_of_the_beast"/>Nature of the Beast</h1></div></div></div><p>Contrary to popular belief, the term <span class="emphasis"><em>bug</em></span> was in use before the advent of computers. In the 1870s, Thomas Edison talked about bugs in electrical circuits. The story of the Harvard University Mark II Aiken Relay Calculator tells of the first recorded computer bug. In 1945, the early days of computers when they took up whole rooms, a moth flew in and managed to lodge itself in some circuits, causing a system failure. They taped it into the logbook and wrote, <span class="emphasis"><em>First actual case of bug being found</em></span>. For posterity's sake, it has been preserved in the Smithsonian Institute.<a class="indexterm" id="IDX-CHP-9-0630"/><a class="indexterm" id="IDX-CHP-9-0631"/><a class="indexterm" id="IDX-CHP-9-0632"/><a class="indexterm" id="IDX-CHP-9-0633"/><a class="indexterm" id="IDX-CHP-9-0634"/><a class="indexterm" id="IDX-CHP-9-0635"/><a class="indexterm" id="IDX-CHP-9-0636"/></p><p>Bugs are bad news. But what are they, really? We outlined the correct nomenclature for these things in "<a class="xref" href="ch08.html#terms_and_conditions" title="TERMS AND CONDITIONS">TERMS AND CONDITIONS</a>" on page 130. It's worth identifying the varieties of bugs we encounter and understanding how they are born, how they survive, and how they can be exterminated.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_view_from_1_comma_000_feet"/>The View from 1,000 Feet</h2></div></div></div><p>Software bugs fall into a few broad categories, and understanding these will help us to reason about them. Some bugs are naturally harder to find than others, and this is related to their categories. Stepping back and squinting from a distance, these three classes of bugs emerge:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Failure to compile</strong></span></span></dt><dd><p>It's really annoying when the code you've spent ages writing fails to compile. It means that you'll have to go back and fix a tedious little typo or a parameter type mismatch, and then wait for the compiler to run again before you can get to the real job of testing your handiwork. Surprisingly, this is the best type of error you can get. Why? Simply because it's the easiest to detect and fix. It's the most immediate and the most obvious.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-1" id="CHP-9-FN-1">1</a>]</sup></p><p>The longer it takes to detect faults, the more it will cost to fix them; this is demonstrated in "<a class="xref" href="ch09s02.html#the_economics_of_failure" title="THE ECONOMICS OF FAILURE">THE ECONOMICS OF FAILURE</a>" on page 157. The sooner you catch and fix each fault, the sooner you can move on and the less fuss and cost they can incur. Compilation failures are very easy to notice (or rather, they are hard to ignore) and usually easy to fix. You can't run the program until you have taken care of them.</p><p>Most of the time, a compilation failure will be a silly syntactic mistake or a simple oversight, like calling a function with the wrong number or type of parameters. The failure might be due to a fault in a makefile, it might be a link stage error (perhaps a missing function implementation), or even a build server running out of disk space.</p></dd><dt><span class="term"><span class="strong"><strong>Run-time crash</strong></span></span></dt><dd><p>After you fix the compilation errors, an executable pops out and you happily run it. Then it crashes. You'll probably swear and mutter something about random cosmic rays. After the 60th crash, you're threatening to throw your computer out the window. These kinds of errors are much harder to deal with than compilation errors, but they're still reasonably simple.</p><p>That's because, like compilation errors, they are blindingly obvious. You can't argue with a dead program. You can't pretend a crash is a "feature." When it has kicked the bucket and shuffled off its mortal coil, you can step back and begin to figure out where your program went wrong. You'll have some clues (which input sequence preceded the crash and what it did before crashing), and you can employ tools to discover more information (more on this later).</p></dd><dt><span class="term"><span class="strong"><strong>Unexpected behavior</strong></span></span></dt><dd><p>This is the really nasty one—when your program isn't pushing up the daisies, just pining for the fjords. Suddenly it does the wrong thing. You expected a blue square, and out popped a yellow triangle. The code continues to meander on its happy way with total disregard for your frustration. What caused the yellow triangle to appear? Has the program been overthrown by a militant army of guerrilla COM objects? It will almost certainly be a minute logic problem in the bowels of the code that executed over half and hour ago. Good luck finding it.</p><p>A failure may manifest itself because of defective single line of code, or it may only show up when several interconnecting modules whose assumptions don't quite match up are finally glued together.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_view_from_the_ground"/>The View from the Ground</h2></div></div></div><p>If we move in a bit and take a closer look at run-time errors, more groupings of faults become clear. Here they are ranked in order of pain, from splinter to decapitation.<a class="indexterm" id="IDX-CHP-9-0637"/><a class="indexterm" id="IDX-CHP-9-0638"/><a class="indexterm" id="IDX-CHP-9-0639"/><a class="indexterm" id="IDX-CHP-9-0640"/><a class="indexterm" id="IDX-CHP-9-0641"/><a class="indexterm" id="IDX-CHP-9-0642"/><a class="indexterm" id="IDX-CHP-9-0643"/><a class="indexterm" id="IDX-CHP-9-0644"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Syntactic errors</strong></span></span></dt><dd><p>While these <span class="emphasis"><em>are</em></span> mostly caught by the compiler at build time, sometimes language grammar errors slip through undetected. They generate weird and unexpected behavior. In C-like languages, the syntax error will often be one of these:<a class="indexterm" id="IDX-CHP-9-0645"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Mistaking <code class="literal">==</code> for <code class="literal">=</code> or <code class="literal">&amp;&amp;</code> for <code class="literal">&amp;</code> in a conditional expression</p></li><li class="listitem"><p>Forgetting a semicolon or adding one in the wrong place (the classic location is after a <code class="literal">for</code> statement)</p></li><li class="listitem"><p>Forgetting to enclose a set of loop statements in braces<a class="indexterm" id="IDX-CHP-9-0646"/></p></li><li class="listitem"><p>Mismatching parentheses</p></li></ul></div></dd></dl></div><p>The simplest way to avoid being tripped up by these sorts of errors is to keep all compiler warnings switched on; modern compilers moan about of lot of these problems.<a class="indexterm" id="IDX-CHP-9-0647"/><a class="indexterm" id="IDX-CHP-9-0648"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Build your code with all compiler warnings switched on. It will highlight potential problems before they can bite</em></span>.</p></dd></dl></div><div class="sidebar"><a id="the_economics_of_failure"/><p class="title"><b>THE ECONOMICS OF FAILURE</b></p><p>The art of debugging is intimately bound to the topic of the previous chapter—<span class="emphasis"><em>testing</em></span> your code. Testing will expose faults that need to be debugged. I've covered these topics in two separate chapters because they <span class="emphasis"><em>are</em></span> different disciplines. However, the two in tandem are fundamental to reliable software development.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e12395"/><img alt="THE ECONOMICS OF FAILURE" src="tagoreillycom20080909nostarchimages207468.png"/></div></div><p>The frantic pace of the software factory demands code that's produced quickly and cheaply. This haste leads to software projects that are riddled with bugs and are consequently delivered incredibly late. Late software is a huge problem—it's not just embarrassing and inconvenient; it could spell disaster for any company.</p><p>In fact, the longer you ignore testing and allow bugs to remain, the worse it gets— this graph illustrates the escalating impact of bugs as they wriggle through the development process. It shows the average cost of finding and fixing an error relative to the phase of production in which it is discovered. (Boehm 81)</p><p>As you can see, the cost rises dramatically with time (note that the cost axis is a logarithmic scale). To make matters worse, the nearer we get to a project deadline, the less time we have to perform thorough testing. The added pressure of impending deadlines makes debugging that much harder—with the pressure on, you're even more likely to introduce fresh faults with each repair.</p><p>To save your skin and prevent a lot of debugging stress, test your code early and thoroughly. Eradicate any bugs you find as soon as possible, before they have a chance to cause major grief. There are established methodologies for this—look at test-driven development, one of the components of agile software development.<a class="indexterm" id="IDX-CHP-9-0649"/></p></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Build errors</strong></span></span></dt><dd><p>While not a run-time fault <span class="emphasis"><em>per se</em></span>, a build error may only manifest itself at run time. Be on the lookout and always distrust your build system, no matter how good you think it is. In these enlightened times, you're unlikely to come across a compiler bug. However, you may not always be running the code you thought you built.</p><p>I've been hit by this several times: The build system failed to rebuild a program or shared library (perhaps because the makefiles didn't contain adequate dependency information or the old executable had a bad timestamp). Every time I tested my modifications, I was still unknowingly running the old buggy code. There are a number of ways to confuse a build system, but the worst is when you don't notice it failing—like a leprous limb.</p><p>It can take quite some time to figure this out. For this reason, when you feel at all wary of what's going on, it's sensible to do a total cleanout of your project and rebuild it from scratch. This should flush out any potential build system problems.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-2" id="CHP-9-FN-2">2</a>]</sup></p></dd><dt><span class="term"><span class="strong"><strong>Basic semantic bugs</strong></span></span></dt><dd><p>The majority of run-time faults are due to very simple errors causing incorrect behavior. Using uninitialized variables is a classic example and can be quite hard to track; the program's behavior will depend on the garbage value previously in the memory location used by the variable. One time the program will work fine; another time it may fail. Other basic semantic faults are:<a class="indexterm" id="IDX-CHP-9-0650"/><a class="indexterm" id="IDX-CHP-9-0651"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Comparing floating-point variables for (in)equality<sup>[<a class="footnote" href="#ftn.CHP-9-FN-3" id="CHP-9-FN-3">3</a>]</sup></p></li><li class="listitem"><p>Writing calculations that don't handle numerical overflow</p></li><li class="listitem"><p>Rounding errors from implicit type conversions (losing the sign of a <code class="literal">char</code> is common)</p></li><li class="listitem"><p>Declaring an <code class="literal">unsigned int foo</code>, later writing <code class="literal">if (foo &lt; 0)</code>—oops!</p></li></ul></div><p>This type of semantic fault is often caught with static analysis tools.</p></dd><dt><span class="term"><span class="strong"><strong>Semantic bugs</strong></span></span></dt><dd><p>These insidious errors that won't be caught by inspection tools are much harder to identify. A semantic bug might be a low-level error, like the wrong variable being used in the wrong place, not validating a function's input parameters, or getting a loop wrong. It may be a higher-level piece of wrong-headedness: calling an API incorrectly or not keeping an object's state internally consistent. Many memory-related errors fall into this category—they can be devilishly hard to find due to their ability to warp and corrupt your running code so that it behaves in totally unpredictable and unreasonable ways.</p></dd></dl></div><p>Programs often behave strangely. The only consolation is that they're doing exactly what we told them to.</p><p>The best kind of run-time failures are the repeatable ones. If they're reproducible, they are much easier to write tests for and track down the cause of. The failures that don't always occur tend to be memory corruptions.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_view_from_the_trenches"/>The View from the Trenches</h2></div></div></div><p>Now that we've arranged things into neat little boxes, let's zoom right in and take a look at some of the common types of semantic faults:<a class="indexterm" id="IDX-CHP-9-0652"/><a class="indexterm" id="IDX-CHP-9-0653"/><a class="indexterm" id="IDX-CHP-9-0654"/><a class="indexterm" id="IDX-CHP-9-0655"/><a class="indexterm" id="IDX-CHP-9-0656"/><a class="indexterm" id="IDX-CHP-9-0657"/><a class="indexterm" id="IDX-CHP-9-0658"/><a class="indexterm" id="IDX-CHP-9-0659"/><a class="indexterm" id="IDX-CHP-9-0660"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Segmentation faults</strong></span></span></dt><dd><p>Also known as <span class="emphasis"><em>protection faults</em></span>, segmentation faults come from accessing memory locations that have not been allocated for the program's use. They result in the operating system aborting your application and producing some form of error message, usually with helpful diagnostic information.<a class="indexterm" id="IDX-CHP-9-0661"/></p><p>This can be triggered far too easily by typing errors involving pointers or by poor pointer arithmetic. A common C typo causing a <span class="emphasis"><em>segfault</em></span> is <code class="literal">scanf("%d", number);</code>. The missing <code class="literal">&amp;</code> before <code class="literal">number</code> makes <code class="literal">scanf</code> try to write into the memory location referenced by the (garbage) contents of <code class="literal">number</code>, and <span class="emphasis"><em>poof</em></span>—the program disappears in a wisp of smoke. If you're really unlucky, though, <code class="literal">number</code> happens to hold a value that equates to a valid memory address. Now your code will continue as if nothing is wrong, until the memory you just wrote over is used and your fate is in the lap of the gods.<a class="indexterm" id="IDX-CHP-9-0662"/><a class="indexterm" id="IDX-CHP-9-0663"/><a class="indexterm" id="IDX-CHP-9-0664"/></p></dd><dt><span class="term"><span class="strong"><strong>Memory overruns</strong></span></span></dt><dd><p>These are caused by writing past memory that has been allocated for your data structure, be it an array, a vector, or some other custom construct. When writing values into the wide blue yonder, you'll probably clobber the data in some other part your program. If you're running on an unprotected operating system (more common in embedded environments), you may even tamper with data from another process or the OS itself. Ouch.</p><p>Memory overrun is a common problem and difficult to detect; usually the symptom is random unexpected behavior manifesting at a much later point than the overrun, possibly many thousands of instructions later. If you're lucky, the memory overrun hits an invalid memory address and you get a segfault, which is hard to ignore. Use safe data structures wherever possible to insulate yourself from the possibility of such disaster.<a class="indexterm" id="IDX-CHP-9-0665"/></p></dd><dt><span class="term"><span class="strong"><strong>Memory leaks</strong></span></span></dt><dd><p>These are constant threats in languages that do not have garbage collection.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-4" id="CHP-9-FN-4">4</a>]</sup> When you want some memory, you have to ask the run time for it nicely (using <code class="literal">malloc</code> in C or <code class="literal">new</code> in C++). Then you have to be polite and give it back when you're done (using <code class="literal">free</code> and <code class="literal">delete</code>, respectively). If you rudely forget to release memory, your program slowly consumes more and more of the computer's scarce resources. You may not notice it at first, but your computer's response will gradually degrade as memory pages thrash to and from the disk.</p><p>Two other classes of error relate to this: freeing a memory block <span class="emphasis"><em>too many</em></span> times, causing unpredictable environmental failures, and not managing other scarce resources carefully, such as file handles or network connections. (Remember: Anything you manually acquire must be manually released.)</p></dd><dt><span class="term"><span class="strong"><strong>Running out of memory</strong></span></span></dt><dd><p>This is always a possibility, as is running out of file handles or any other managed resource. It might be rare (modern computers have so much memory, how could this possibly happen?), but that's no excuse to ignore the potential for failure. Only sloppy code fails to make appropriate checks, and it will consequently perform in a very brittle manner when run in constrained situations. For this reason, you should always validate the return status of a memory allocation or filesystem call.</p><p>Some operating systems <span class="emphasis"><em>never</em></span> return failure from a memory allocation call—every allocation returns a pointer to a reserved but unallocated memory page. When the program eventually tries to access this page, an OS mechanism traps the access and then really allocates memory to the page, resuming normal program operation. This all works nicely until the available memory is finally exhausted. Your program will then be sent error signals—a long time after the relevant allocation occurred.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-5" id="CHP-9-FN-5">5</a>]</sup></p></dd><dt><span class="term"><span class="strong"><strong>Math errors</strong></span></span></dt><dd><p>These errors come in a number of guises: floating-point exceptions, incorrect mathematical constructions, overflow/underflow, or expressions that may fail (for example, divide by zero). Even trying to output a <code class="literal">float</code> but passing an <code class="literal">int</code> through <code class="literal">printf("%f")</code> can cause your program to bomb with a maths error.<a class="indexterm" id="IDX-CHP-9-0669"/><a class="indexterm" id="IDX-CHP-9-0668"/></p></dd><dt><span class="term"><span class="strong"><strong>Program hangs</strong></span></span></dt><dd><p>These are usually caused by bad program logic; infinite loops with badly crafted terminal cases are the most common. We also see deadlock and race conditions in threaded code, and event-driven code waiting on events that will never occur. However, it is usually fairly easy to interrupt the running program, see where the code has stalled, and determine the cause of the hang.<a class="indexterm" id="IDX-CHP-9-0670"/><a class="indexterm" id="IDX-CHP-9-0671"/><a class="indexterm" id="IDX-CHP-9-0672"/><a class="indexterm" id="IDX-CHP-9-0673"/></p></dd></dl></div><p>Different OSes, languages, and environments report these errors in different ways, using different terminology. Some languages avoid whole classes of errors by not providing features you can shoot yourself in the foot with. Java, for example, has no pointers, and it automatically checks every memory access you make.<a class="indexterm" id="IDX-CHP-9-0674"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-1" id="ftn.CHP-9-FN-1">1</a>] </sup>Provided you have a sane build environment that stops when it encounters an error and provides some reasonable diagnostic messages.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-2" id="ftn.CHP-9-FN-2">2</a>] </sup>This presumes that you trust your <code class="literal">build clean</code> facility. To be really thorough, delete the entire project and check it back out again afresh. Alternatively, manually remove all intermediate object files, libraries, and executables. For large projects, both options are extremely tedious. <span class="emphasis"><em>C'est la vie</em></span>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-3" id="ftn.CHP-9-FN-3">3</a>] </sup>You can't do this meaningfully; floating point arithmetic is too approximate to offer an exact comparison that indicates anything.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-4" id="ftn.CHP-9-FN-4">4</a>] </sup>It is also possible to leak memory in a language with garbage collection. Hand two object references to one another, and then let go of them both. Unless you have an advanced garbage collector, they will never be swept up.<a class="indexterm" id="IDX-CHP-9-0666"/><a class="indexterm" id="IDX-CHP-9-0667"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-5" id="ftn.CHP-9-FN-5">5</a>] </sup>This is certainly the case for Linux, at least until you exhaust the virtual memory address space. At this point, <code class="literal">malloc</code> may return 0, but the system would probably have keeled over before you got a chance to notice.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="pest_extermination"/>Pest Extermination</h1></div></div></div><p>Weeding out bugs in your software is hard. You have to discover a bug, diagnose the problem, eradicate all traces of the unwanted behavior, make sure the bug hasn't bred elsewhere, and try not to break the code while you're doing all of it. The first step alone, finding a fault, is a major hassle: Humans make mistakes when writing, but they make just as many mistakes when reading. When looking over my prose or my code, I'll naturally read what I <span class="emphasis"><em>meant</em></span> to write and not what I <span class="emphasis"><em>really</em></span> wrote. Faulty code isn't obvious. The compiler isn't much help; in fact it's really quite pedantic. It can only produce <span class="emphasis"><em>exactly</em></span> what you asked, not what you were hoping for.<a class="indexterm" id="IDX-CHP-9-0675"/><a class="indexterm" id="IDX-CHP-9-0676"/><a class="indexterm" id="IDX-CHP-9-0677"/><a class="indexterm" id="IDX-CHP-9-0678"/><a class="indexterm" id="IDX-CHP-9-0679"/><a class="indexterm" id="IDX-CHP-9-0680"/></p><p>Some programmers introduce far fewer faults than their peers (up to 60 percent less), can find and fix faults quicker (in as little as 35 percent of the time), and introduce fewer faults as they do so. (Gould 75) How do they do it? They are naturally able to pay more attention to the task and can focus on the microscopic level of the code they're writing, while still keeping the broader picture in mind.</p><p>This is the <span class="emphasis"><em>art</em></span> of debugging; it's very much a skill to be learned. Experience teaches you how to become an effective debugger. And this is something that we <span class="emphasis"><em>will</em></span> all get plenty of experience doing.</p><p>The single most important rule when debugging is this: <span class="emphasis"><em>Use your brain</em></span>. Think. Consider what you're doing. Don't flail around, thoughtlessly hacking at bits of code until something appears to work.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Always follow the golden rule of debugging:Use your brain</em></span>.<a class="indexterm" id="IDX-CHP-9-0681"/><a class="indexterm" id="IDX-CHP-9-0682"/></p></dd></dl></div><p>There are two paths to pest extermination: the quicky-and-dirty <span class="emphasis"><em>low road</em></span> and the theologically correct <span class="emphasis"><em>high road</em></span>. We must be aware of them both; sometimes the low road looks like a good shortcut but will actually be slower, and sometimes the high road takes more effort to follow than is genuinely required.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_low_road"/>The Low Road</h2></div></div></div><p>The bug is really simple. The cause is obvious. You don't need to think too much about it, do you? Sometimes a quick tweak <span class="emphasis"><em>will</em></span> achieve results; a few simple tests can pinpoint a problem quickly. So is it a justifiable thing to do? Perhaps, but don't fall into the trap of believing it will work every time. Too many programmers try to fix faults by tinkering, fiddling, poking, and prodding the code without any real thought about what they're doing. What happens is rarely anything useful—they just mask the original problem behind a myriad of other faults.<a class="indexterm" id="IDX-CHP-9-0683"/></p><p>If you do make the conscious decision to do some quick-and-dirty stabbing around, set yourself a firm time limit to do it in. Don't spend an entire morning with the "just one more try" approach. After your time limit is up, follow the more methodical approach laid out here.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Set a reasonable time limit for "unstructured" debugging, and then resort to more methodical approaches if you don't find success</em></span>.</p></dd></dl></div><p>If your guesswork turns up trumps and you do find the fault, reengage your thinking gear. Look at "<a class="xref" href="ch09s05.html" title="How to Fix Faults">How to Fix Faults</a>" on page 167, and make the change carefully and thoughtfully. Even if the fault was easy to find, the fix isn't necessarily as obvious.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_high_road"/>The High Road</h2></div></div></div><p>A better debugging technique is more methodical and considered. It recognizes that there are two distinct facets to removing a bug: <span class="emphasis"><em>finding</em></span> the fault that caused it and <span class="emphasis"><em>fixing</em></span> that fault.</p><p>Each presents its own challenges to overcome and problems to solve. It's very easy to forget the latter part and to presume that once you've found a fault, it will be easy and obvious to fix. Don't believe it. I'll cover both aspects in depth in later sections, and I'll outline a sensible approach to the task. But first, a few key principles govern the debugging game:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>How difficult a fault is to find depends on how well you know the code it's lurking in. It's hard to jump into some random source and make any kind of judgment about it without knowing the structure and how it's supposed to work. For this reason, if you have to debug some new code, take time to learn about it first.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>key-concept</strong></span></span></dt><dd><p>Learn the code you're debugging—you can't expect to find errors in code you don't understand.</p></dd></dl></div></li><li class="listitem"><p>Ease of debugging is also dependent on the control you have over the execution environment—how much you can play around with the running program and inspect its state. In an embedded world, debugging can be much harder because the tool support is more sparse. You're also probably running in an environment that is providing a lot less insulation from your own stupidity; little mistakes can have much bigger consequences.</p></li><li class="listitem"><p>One of the most potent weapons in our debugging arsenal is a distrust of anyone's code mixed with a healthy dose of cynicism. The cause of your errant behavior could be absolutely anything, and in the act of diagnosis, you should start by eliminating even the most unlikely of candidates.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>When you look for a fault, suspect everything. Eliminate even the unlikeliest of causes first, rather than presume they have nothing to do with it. Assume nothing</em></span>.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="bug_hunting"/>Bug Hunting</h1></div></div></div><p>How do you find bugs? If there was a simple three-step process, we'd all have learned it, and our programs would be perfect by now. As it is, there isn't, and they aren't. Let's try to distill the available bug-hunting wisdom.<a class="indexterm" id="IDX-CHP-9-0684"/><a class="indexterm" id="IDX-CHP-9-0685"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="compile-time_errors"/>Compile-Time Errors</h2></div></div></div><p>We'll look at these first, since they are comparatively easy to deal with. When your compiler comes across something unpleasant, it will not normally just complain once, but will take the opportunity to sound off about life in general, spitting out a barrage of subsequent error messages. It's been told to do this; upon encountering any error, the compiler tries to pick itself back up and carry on parsing away. It rarely manages very well, but with code like yours, who could blame it?<a class="indexterm" id="IDX-CHP-9-0686"/></p><p>The upshot is that the later compiler messages can be quite random and irrelevant. You only need to look at the very <span class="emphasis"><em>first</em></span> error reported and sort out that problem. Have a glance farther down the list by all means; there may be some other useful errors there, but often there aren't.</p><div class="sidebar"><a id="case_study_number_symble_1_colon_picture_this"/><p class="title"><b>CASE STUDY #1: PICTURE THIS</b></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The program</strong></span></span></dt><dd><p>A reasonably small utility with graphical interface.</p></dd><dt><span class="term"><span class="strong"><strong>The problem</strong></span></span></dt><dd><p>The program was redesigned with an updated "look and feel"—new icons and a new layout. The old interface was intended to remain available as a configurable option. During redevelopment, everything worked fine until just before release, when someone tried to use the legacy interface. The program crashed just as a window was appearing but before you had a chance to see it fully.</p></dd><dt><span class="term"><span class="strong"><strong>The story</strong></span></span></dt><dd><p>Thankfully, this was a nicely repeatable problem. The program was fired up in a debugger, and the point of failure was determined to be deep within the UI library in some image-rendering code.</p><p>On investigation, it seemed the failure was due to an invalid graphic being used. The program was trying to display an icon at memory location zero; a null pointer was causing the crash. We traced back up the call stack to see which graphic should have appeared. Armed with this information, a brief look at the legacy graphics directory showed that this particular icon was missing.</p><p>The icon load operation in the window's constructor had obviously failed, returning a zero pointer value to signify "No icon loaded." This return value was never checked—the author assumed that the graphic would always be present. The fix would be twofold:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Check the return values of all icon load routines so they deal with any other missing graphics more gracefully.</p></li><li class="listitem"><p>Place the missing graphic in the correct directory.</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Time to fix</strong></span></span></dt><dd><p>A few hours to trace the problem, fix the fault, and verify the repair.</p></dd><dt><span class="term"><span class="strong"><strong>Lessons learned</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Check <span class="emphasis"><em>all</em></span> function return codes, even the ones you don't think will fail.</p></li><li class="listitem"><p>Test all program functionality as soon as possible, especially the rare conditions that won't be used very often.</p></li></ul></div></dd></dl></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>When your build fails, look at the</em></span> first <span class="emphasis"><em>compiler error. Trust this far more than the subsequent messages</em></span>.</p></dd></dl></div><p>Even this first compiler error may be cryptic or misleading, depending on the quality of the compiler (if you're really stumped by what an error means, try using another compiler). Hardcore C++ template code can provoke quite inspired errors from some compilers—listing reams and reams of mystical template incantations.<a class="indexterm" id="IDX-CHP-9-0687"/></p><p>The syntax error usually <span class="emphasis"><em>is</em></span> on the line that the compiler reports, but sometimes it may actually be on the <span class="emphasis"><em>preceding</em></span> line—a syntax error there causes the following line to be nonsensical; this is what the compiler notices and moans about.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-6" id="CHP-9-FN-6">6</a>]</sup></p><p>Linker errors, on the whole, are far less cryptic. The linker will tell you that it's missing a function or a library, so you'd better scurry off and find it (or write it). Sometimes the linker may complain about arcane v-table related C++ problems; this is usually a symptom of a missing destructor implementation or something similar.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="run-time_errors"/>Run-Time Errors</h2></div></div></div><p>Run-time errors require more of a game plan. If your program contains a bug, then it's likely that a condition somewhere in the code that you believed to be true isn't. Finding the bug is a process of confirming what you think is correct until you find the place where that condition doesn't hold. You have to develop a model of how the code really works and compare this with how you'd intended it to work. Doing this methodically is the only sensible way.<a class="indexterm" id="IDX-CHP-9-0688"/><a class="indexterm" id="IDX-CHP-9-0689"/><a class="indexterm" id="IDX-CHP-9-0690"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Debugging is a methodical activity, slowly closing in on the location of a fault. Don't treat it like a simple guessing game</em></span>.<a class="indexterm" id="IDX-CHP-9-0691"/></p></dd></dl></div><p>The <span class="emphasis"><em>scientific method</em></span> is the process scientists use to develop an accurate representation of the world. That sounds akin to what we are trying to do, right? There are four steps to the scientific method:<a class="indexterm" id="IDX-CHP-9-0692"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Observe a phenomenon.</p></li><li class="listitem"><p>Form a hypothesis to explain it.</p></li><li class="listitem"><p>Use this hypothesis to predict the results of further observations.</p></li><li class="listitem"><p>Perform experiments to test these predications.</p></li></ol></div><p>Although we're trying to <span class="emphasis"><em>get rid of</em></span> the errant phenomenon rather than build a model of it, we need to understand a fault to truly fix it. The scientific method is a good debugging backbone, and you'll see it reflected in the steps below.</p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="identify_a_failure"/>Identify a Failure</h3></div></div></div><p>It all starts here, when you notice that the program doesn't do what it's supposed to do. It may crash or it may produce a yellow triangle instead of a blue square, but you know something's up, and you've got to fix it. The first thing to do is put a fault report into the fault database (see "<a class="xref" href="ch08s09.html#fault-tracking_system" title="Fault-Tracking System">Fault-Tracking System</a>" on page 147). This is particularly valuable if you're in the middle of tracking some other bug or don't have time to handle the fault right away. Making a record ensures that the fault won't get lost. Don't just make a mental note to come back to a problem later—you'll forget.</p><p>Before you rush on and try to find a bug you've stumbled across, identify the nature of the errant behavior. Characterize the problem as completely as possible by answering questions like: Is it timing sensitive? and Does it depend on input, system load, or program state? If you don't understand the bug before you try to fix it, you'll just be changing code until the symptom disappears. You may only have masked a cause, so the same fault will crop up elsewhere.</p><p>Did the code work before? Skip back through your revision control system to find the last working version, and compare that working code with this faulty revision.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="reproduce_it"/>Reproduce It</h3></div></div></div><p>This goes alongside characterizing the failure. Work out the set of steps you must take to reliably trigger the problem. If there is more than one way, then document them all.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>The first step to locating a fault is finding out how to reproduce it reliably</em></span>.</p></dd></dl></div><p>You have a problem if the bug doesn't seem reproducible; the best you can do is set up mousetraps and see what information you can find out when it does occur. For these unreliable failures, keep careful notes of the information you collect; it may be a while until you see the problem crop up again.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="locate_the_fault"/>Locate the Fault</h3></div></div></div><p>This is the big one. You've got the scent; now you need to use what you've learned to track the beast and pinpoint its location. That is far more easily said than done. This is a process of eliminating all the things that don't contribute to the failure or can be shown to work correctly, Sherlock Holmes style. As you progress, you will find that you need to gather more and more information—the more answers you get, the more questions that arise. You may need to draft some new tests. You may need to poke around in the seedy underbelly of the code.</p><p>Analyze what you have learned about the failure. Without jumping to conclusions, draw up a list of code suspects. See if you can spot patterns of events that hint at causes. If possible, keep a record of the inputs and outputs that demonstrate the problem.</p><p>A good starting point for the investigation is where the error <span class="emphasis"><em>manifests</em></span> itself—although this is rarely the actual habitat of the fault. Remember: Just because a failure exhibits itself in one module, it doesn't necessarily mean <span class="emphasis"><em>that</em></span> module is to blame. Determining this location is easy if the program crashed; a debugger will tell you the line of code that failed, the value of all variables at that point, and who called this function. In the absence of a crash, start from a point you know exhibits incorrect behavior. Work backward from there, following the flow of control, checking that the code is doing what you expect it to at each point.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Start from what you know—the point of a program crash, for example. Then work back from there to the cause of the failure</em></span>.</p></dd></dl></div><p>There are a few common bug-hunting strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The worst thing to do is randomly change things to see if the failure goes away. This is an immature approach. (A professional will at least try to make it look scientific!)</p></li><li class="listitem"><p>A far better strategy is to <span class="emphasis"><em>divide and conquer</em></span>. Say you have the fault pinned down to a single function that consists of 20 steps. After the 10th step, print out the intermediate result, or set a breakpoint and investigate it in your debugger. If the value is good, then the fault lies in the instructions after this; otherwise, it's in the instructions before. Concentrate on those instructions and repeat until you've cornered the fault.</p></li><li class="listitem"><p>Another technique is the <span class="emphasis"><em>dry run</em></span> method. Rather than relying on intuition to locate the error, you play the role of the computer, tracing program execution through a trial run, calculating all intermediate values to get the final result. If your result and reality don't match, then you know a fault lies in the code—it's not doing what you expect it to. Although it is time consuming, this can be very effective because it highlights your bad assumptions.</p></li></ul></div></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="understand_the_problem"/>Understand the Problem</h3></div></div></div><p>Once you've found out where the fault is lurking, you've got to understand the <span class="emphasis"><em>real</em></span> problem. If it's a simple syntactic error, such as using <code class="literal">=</code> instead of <code class="literal">==</code> (<span class="emphasis"><em>d'oh!</em></span>), then the implications aren't too nasty. For more complex semantic problems, make sure you really know what the problem is and all the ways that it may manifest itself before you move on—you may have only found a part of the problem.<a class="indexterm" id="IDX-CHP-9-0693"/><a class="indexterm" id="IDX-CHP-9-0694"/></p><p>Often the fault is very subtle: The code will be doing exactly what it should do <span class="emphasis"><em>and</em></span> what you thought it was supposed to do when you wrote it! The problem is a flawed assumption (remember how evil these are?). A function's writer and caller can easily presume that different behavior is acceptable in particular strange cases. Trace back and understand exactly what the cause of the problem is and whether or not any other bits of code may contain the same mistake.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Once you think you've found the cause of a bug, investigate it thoroughly to prove that you are right. Don't blindly accept your first hypothesis</em></span>.</p></dd></dl></div><p>This is a key principle in the fight against bugs. Otherwise, you'll join the ranks of the programmers who introduce <span class="emphasis"><em>more</em></span> faults than they fix with every bit of repair work.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="create_a_test"/>Create a Test</h3></div></div></div><p>Write a test case to demonstrate the failure. You may have done this in the "Reproduce It" step if you were clever. If you didn't, then you really want to write one now. With your new understanding, make sure the test is rigorous.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="fix_the_fault"/>Fix the Fault</h3></div></div></div><p>And now the easy part: You've just got to fix the darned thing! This <span class="emphasis"><em>should</em></span> actually be the easy part—you understand exactly why the faliure occurs, and you've got a reproducible way to excerise it. Given that depth of information, the fix is usually child's play. Most programmers find bug fixing hard because they skip the first two steps.<a class="indexterm" id="IDX-CHP-9-0695"/></p><p>We'll look at fixing faults in more detail in the following section.</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="prove_youve_fixed_it"/>Prove You've Fixed It</h3></div></div></div><p>Now you know why you wrote a test case. Run it again, and prove the world is a better place. The test case can be added to your regression test suite to ensure that the fault is never reintroduced at a later point.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>You haven't finished debugging until you've proved that the problem's been fixed and has gone away for good</em></span>.</p></dd></dl></div><p>That's it! Game over—mission accomplished. Well done. However . . .</p></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="if_all_else_fails"/>If All Else Fails</h3></div></div></div><p>Sometimes you try all of this but it just doesn't work; you're left wailing and gnashing your teeth, with a sore head from banging it against a brick wall for too long. When things get this bad, I always find it helps to explain the whole problem to someone else. Somewhere in the description, everything seems to slip into place and I see the one key piece of information I had been missing all along. Try it and see. This is one reason why <span class="emphasis"><em>pair programming</em></span> is such a successful strategy.<a class="indexterm" id="IDX-CHP-9-0696"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-6" id="ftn.CHP-9-FN-6">6</a>] </sup>C++ has a great party trick here: The preceeding line might be in a different file! If you forget the <code class="literal">;</code> at the end of your class declaration in a header file, the first line of the implementation file makes no sense. The compiler gives you a very crytpic error.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="how_to_fix_faults"/>How to Fix Faults</h1></div></div></div><p>You'll notice that this section is much smaller than the preceding one. Funny. Usually the whole problem is <span class="emphasis"><em>finding</em></span> the darned fault. Once you've worked out where it is, then the fix is obvious.</p><p>But don't let that lure you into a false sense of security. Don't stop thinking once you've diagnosed the source of your errant behavior. It's very important not to break anything else as you make the fix—it's surprisingly easy to trample over something in the flower bed as you stroll over to pluck out a weed.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Fix bugs with the utmost care. Don't risk breaking anything else with your modification</em></span>.</p></dd></dl></div><p>As you modify code, always ask yourself, <span class="emphasis"><em>What are the consequences of this change?</em></span> Be aware of whether the fix is isolated to a single statement or if it affects other surrounding bits of code. Might the effect of your change ripple out to any code that calls this function; does it subtly alter the behavior of the function?</p><div class="sidebar"><a id="case_study_number_symble_2_colon_hung_comma_drawn"/><p class="title"><b>CASE STUDY #2: HUNG, DRAWN, AND QUARTERED</b></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The program</strong></span></span></dt><dd><p>Embedded software controlling a consumer electronics device.</p></dd><dt><span class="term"><span class="strong"><strong>The problem</strong></span></span></dt><dd><p>A random lockup, occurring after about a week's continuous operation. It resulted in the total death of the device; there was no UI response, no network connectivity, not even an interrupt being handled—the processor was completely stalled. This was <span class="emphasis"><em>particularly</em></span> nasty, leaving no easy way to find out the cause.</p></dd><dt><span class="term"><span class="strong"><strong>The story</strong></span></span></dt><dd><p>The lockup happened so rarely that it was remarkably hard to track. In an attempt to pinpoint the cause, we tried a number of tests, leaving each to run for the weeklong gestation period. First we tried different usage patterns to see if we could make the fault happen sooner and thereby determine what was causing it. These tests made no difference whatsoever.</p><p>The nature of the lockup seemed to imply that it was a gnarly hardware problem. We tried running the software on different versions of the mainboard with different peripheral components and different CPU versions. Weeks of testing later, we were still no nearer to figuring out the problem, but we did have less hair (and what remained was graying). No matter what configuration we used, the software still ran for about a week and then locked up.</p><p>Next we tried removing different sections of code from the system. After a lot of iterative testing, we tracked the problem down to a single component: Its presence in the build heralded a lockup; its absence prevented it. Finally, progress!</p><p>Working out <span class="emphasis"><em>why</em></span> this software component caused such problems wasn't straightforward. It was layered on top of a third-party library, which itself was built against a core OS library. We discovered that this core OS library had been upgraded to a more recent version, but the third-party library had not been rebuilt. We'd been continually linking against an inappropriate piece of code. While theoretically, this shouldn't have made a difference—the OS library change was supposedly <span class="emphasis"><em>binary compatible</em></span>—a rebuild of the third-party library fixed the problem for good.</p></dd><dt><span class="term"><span class="strong"><strong>Time to fix</strong></span></span></dt><dd><p>The total process took about four months, elapsed time. It involved many people on and off over that period, consumed lots of test resources, tied up many bits of hardware, and caused more review meetings than you'd believe were possible. As bugs go, this one had a nasty sting, and caused the company a lot of pain (not to mention expense).</p></dd><dt><span class="term"><span class="strong"><strong>Lesson learned</strong></span></span></dt><dd><p>Rebuild the <span class="emphasis"><em>whole</em></span> software platform whenever <span class="emphasis"><em>any</em></span> component changes to prevent subtle version mismatches.</p></dd></dl></div></div><p>Convince yourself that you have really found the root <span class="emphasis"><em>cause</em></span> of the problem, and you're not just hiding another <span class="emphasis"><em>symptom</em></span>. Then you can feel confident that you've put a fix in the right place. Consider whether similar mistakes may have been made elsewhere in any related modules; go and fix them if necessary.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-7" id="CHP-9-FN-7">7</a>]</sup></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>When you fix a bug, check to see if the same mistake is lurking in related sections of code. Exterminate the bug once and for all: Fix all occurences of the fault now</em></span>.</p></dd></dl></div><p>Finally, try to learn from your mistake. We must learn, or else we will be doomed to repeat the same errors for all eternity. Is it a simple programming error you keep making or something more fundamental, like the incorrect application of an algorithm?</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>With each fault you fix, learn the lessons. How could you have prevented it? How could you have discovered it more quickly?</em></span></p></dd></dl></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-7" id="ftn.CHP-9-FN-7">7</a>] </sup>This is why copy and paste programming—duplicating code, perhaps with minor modifications—is bad. It's dangerous; you'll mindlessly duplicate bugs, and then you won't be able to fix them in a single place.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="prevention"/>Prevention</h1></div></div></div><p>Anyone will tell you that "an ounce of prevention is worth a pound of cure." The best way to manage the population of bugs is to not introduce them. Sadly I don't think that we'll ever completely reach this ideal. For as long as programming involves problem solving, it will always be difficult—not only do you have to solve the problem correctly, you have to understand the whole problem <span class="emphasis"><em>fully</em></span> in the first place. Despite this, careful defensive programming can avoid many problems. Good programming is about discipline and attention to detail. Thorough testing will prevent faults from leaking out in your software releases.<a class="indexterm" id="IDX-CHP-9-0697"/><a class="indexterm" id="IDX-CHP-9-0698"/><a class="indexterm" id="IDX-CHP-9-0699"/></p><p>This section could be enormous, but all prevention advice boils down to that one simple statement: <span class="emphasis"><em>Use your brain</em></span>. Enough said.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="wasp_spray_comma_slug_repellent_comma_fly_paper_._._."/>Wasp Spray, Slug Repellent, Fly Paper . . .</h1></div></div></div><p>Many useful debugging tools exist, and you'd be stupid not to take advantage of them. Some are <span class="emphasis"><em>interactive</em></span>, allowing you to inspect the code while it is running. Others are <span class="emphasis"><em>noninteractive</em></span>, often running as a code filter or parser spitting out information about the program following analysis. Learn how they work to immesurably reduce your debugging time.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="debugger-id1"/>Debugger</h2></div></div></div><p>This is the best known debugging tool; the name belies its purpose. A debugger is an interactive tool that allows you to view the internals of your running program and poke around with it. You can follow the flow of control, inspect the contents of variables, set <span class="emphasis"><em>breakpoints</em></span> in the code for later interruption, and even run arbitrary sections of code at will.</p><p>Debuggers come in many shapes and sizes; some are command-line tools, and others are graphical applications. There will be at least one available for your particular development platform (although the ubiquitous gdb seems to be ported to every conceivable platform these days).</p><p>A debugger relies on <span class="emphasis"><em>symbols</em></span> being left in your executable (these are elements of the compiler's internal information that are normally stripped out at the final link stage)—it uses these to provide you with information about function and variable names and the location of the source files.</p><p>Although debuggers are rich and powerful tools, I believe that they are often misused or overused, and can actually <span class="emphasis"><em>inhibit</em></span> good debugging. Programmers easily become wrapped up chasing what the program is doing, getting sidetracked by observing the wrong variable values, stepping into the wrong functions, and they forget to step back and <span class="emphasis"><em>think</em></span> about the problem they are trying to solve. A little more thought about a failure may pinpoint the specific fault far more quickly than it would take to hunt it down in a debugger.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Use debuggers sparingly, when you encounter behavior you can't explain. Don't reach for them routinely to use as an alternative to</em></span> understanding <span class="emphasis"><em>how your code works</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="memory_access_validator"/>Memory Access Validator</h2></div></div></div><p>This interactive tool inspects your running program for memory leaks and overruns. It can be remarkably useful, revealing reams of memory release errors you never knew existed.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="system_call_tracing"/>System Call Tracing</h2></div></div></div><p>System call trace utilities, like Linux's strace, show all the system calls issued by an application. This is a good way to see how a program is interacting with its environment and is particularly useful when it appears to be stalled on some external activity that is not happening.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="core_dump"/>Core Dump</h2></div></div></div><p>This is a Unix term for the OS-generated snapshot of a program that is produced when it exits abnormally. The term derives from archaic machines with <span class="emphasis"><em>ferrite core</em></span> memory; the dump file is still called <span class="emphasis"><em>core</em></span> today. It contains a copy of the program's memory when it died, the state of the CPU registers, and the function call stack. The core dump can be loaded into an analyzer (which is often the debugger) to reveal a great deal of useful information.<a class="indexterm" id="IDX-CHP-9-0700"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="logging"/>Logging</h2></div></div></div><p>Logging facilities allow you to programmatically generate information about your application as it runs. Rich logging systems allow you to assign priorities to the output (e.g., debug, warning, fatal) and then filter out a particular message level at run time. The program's log gives a history of activity that can help pinpoint the circumstances that triggered a failure.<a class="indexterm" id="IDX-CHP-9-0701"/></p><p>Even without a good logging facility (either as part of the operating environment or from a third-party library), you can achieve the same effect by peppering your code with basic print statements on an ad hoc basis. However, these printouts may interfere with normal program output, and they all must be carefully removed in the production code release.</p><p>Sometimes even lowly print instructions aren't available. Once, when bringing up a new piece of hardware, the only diagnostic output I had was a single eight-segment LED display and a scope attached to a spare system bus. It's impressive how much information you can shoehorn into a few lights when you try!</p><p>There are downsides to logging: It can slow down program execution, bloat the executable size, and even introduce bugs of its own. Some logging systems, in which the crash destroys the buffer containing log messages, are useless for trapping a program crash. Be sure you know how well your logging mechanism behaves, and always send diagnostic print statements to an unbuffered output stream.<a class="indexterm" id="IDX-CHP-9-0702"/></p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="static_analyzer"/>Static Analyzer</h3></div></div></div><p>This is a noninteractive tool that inspects your source code for potential problems. Many compilers perform basic static analysis when set to their maximum warning level, but good analysis tools go far beyond this. Products exist to detect problem code and any usage of undefined behavior or non portable constructs, to identify dangerous programming practices, to provide code metrics, to enforce coding standards, and to create automatic test harnesses.</p><p>Use of a static analysis tool can eradicate many errors before they have a chance to bite—a handy safety net. It's a pragmatic idea to use a static analyzer from a different company than your compiler manufacturer—two companies are less likely to have made the same set of assumptions or mistakes.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id8"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>I can remember the exact instant when I realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs.</p><div class="attribution"><span>--<span class="attribution">Maurice Wilkes</span></span></div></div><p>Like death and taxes, no matter how hard we try to avoid them, bugs happen. Sure, you might be able to mitigate the effects of the first two by using every sort of antiwrinkle cream available and manipulating your money in cunning ways, but if you don't know how to deal with faults when they stare you in the face, your code is doomed.</p><p>Debugging is a skill you develop. It doesn't rely on guesswork, but on methodical detection and thoughtful repair.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don't cultivate bugs; they write code carefully to prevent introducing them in the first place</p></li><li class="listitem"><p>Understand what their code does and write careful tests to ensure that it won't be broken easily</p></li><li class="listitem"><p>Hunt for bugs methodically and carefully, rather than rush in headfirst without a battle plan</p></li><li class="listitem"><p>Know their limitations and will ask others to help find a fault when they're stuck</p></li><li class="listitem"><p>Change code carefully, even when making a "simple" repair</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don't debug; they flail around, sinking in a sea of bad code</p></li><li class="listitem"><p>Spend most of their life in a debugger, figuring out what their code is doing</p></li><li class="listitem"><p>Encounter a failure and try to hide it—they actively avoid debugging<a class="indexterm" id="IDX-CHP-9-0703"/></p></li><li class="listitem"><p>Have unrealistic expectations of the quality of their code and of their ability to fix faults</p></li><li class="listitem"><p>"Fix" bugs by masking symptoms rather than tracing the problem back to its real cause</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id8"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch01.html" title="Chapter 1. ON THE DEFENSIVE">Chapter 1</a></span></dt><dd><p>How to prevent bugs from ever gaining a foothold in your code.</p></dd><dt><span class="term"><a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a></span></dt><dd><p>You can't fix a fault until you know it exists. Thorough testing is a prevention mechanism that stops faults from leaking out into your software releases.</p></dd><dt><span class="term"><a class="xref" href="ch20.html" title="Chapter 20. A REVIEW TO A KILL">Chapter 20</a></span></dt><dd><p><span class="emphasis"><em>Code reviews</em></span> help to pinpoint and eradicate bugs and can identify problem areas that would otherwise go undetected.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e13535"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207470.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id9"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 500.<a class="indexterm" id="IDX-CHP-9-0704"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id8"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Is it best for faults to be fixed by the original programmer who wrote the code? Or is the programmer who discovered the problem better placed to make a fix?</p></li><li class="listitem"><p>How can you tell when to use a debugger and when to use your brain?</p></li><li class="listitem"><p>You should learn unfamiliar code before you start trying to find and fix faults in it. But the time pressures of the software factory often dictate that you can't spend any serious time studying and understanding the program you're repairing. What's the best way forward?</p></li><li class="listitem"><p>Describe good techniques to avoid memory-leak bugs.<a class="indexterm" id="IDX-CHP-9-0705"/></p></li><li class="listitem"><p>When is it justifiable to have a quick stab at finding and fixing a fault, rather than adopting a more methodical approach?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id8"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How many debugging techniques/tools do you routinely use? What others have you seen that you might find useful?</p></li><li class="listitem"><p>What are the common problems and pitfalls in your language(s) of choice? How do you guard against these kinds of bugs in your own code?</p></li><li class="listitem"><p>Are most of the bugs that occur in your code sloppy programming errors, or are they more subtle issues?</p></li><li class="listitem"><p>Do you know how to use a debugger on your platform? How routinely do you use it? Describe how to do the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Produce a backtrace</p></li><li class="listitem"><p>Inspect variable values</p></li><li class="listitem"><p>Inspect value of fields within a structure</p></li><li class="listitem"><p>Run an arbitrary function</p></li><li class="listitem"><p>Swap thread contexts</p></li></ol></div></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_code_that_jack_built"/>Chapter 10. THE CODE THAT JACK BUILT</h1></div><div><h3 class="subtitle"><i>Mechanisms to Turn Source Code into Executable Code</i></h3></div></div></div><div class="epigraph"><p>What you spend years building may be destroyed overnight. Build anyway.<a class="indexterm" id="IDX-CHP-10-0706"/></p><div class="attribution"><span>--<span class="attribution">Mother Teresa</span></span></div></div><p>The programmer (<span class="emphasis"><em>Geekus maximus</em></span>) is usually found in its natural habitat, hunched in the ethereal glow of a monitor, entering profound combinations of punctuation characters into a text editor. Occasionally, this timid beast will leave the confines of its lair to forage for coffee or pizza. Quickly it returns to safety, continuing its ritual at the keyboard.</p><p>If typing language constructs was all there was to programming, then our job would be a great deal easier, although we'd risk being replaced by the proverbial infinite number of monkeys with their infinite number of text editors. Instead, we must run our source code through a compiler (or interpreter) to obtain something that might just function as we intend it to. Invariably, it doesn't. Rinse and repeat.</p><p>The task of converting carefully honed, high-level language into an executable that can be distributed is commonly referred to as <span class="emphasis"><em>building</em></span> code (although you'll find that this term is used pretty interchangeably with <span class="emphasis"><em>making</em></span> and <span class="emphasis"><em>compiling</em></span> in most contexts).</p><p>This act of building is a fundamental part of what we do—we can't develop code without performing a build. It's important, then, to understand what's involved and how your project's build system works in order to have any confidence in the code that's generated. There are a lot of subtle issues at play here, especially when a codebase reaches a reasonable size. Interestingly, almost all programming textbooks will gloss over this kind of topic; they present single-file example programs that don't show any real build complexity.</p><p>Many developers rely on their IDE's build system, but this doesn't remove the burden of understanding how it works. It's very convenient to hit a button and have all your code generated, but if you don't know which options are being passed to the C compiler or which level of instrumentation is left in your object files, then you're not really in control. The same holds true if you type a single <span class="emphasis"><em>build</em></span> instruction at a command prompt. You must understand what's going on under the hood to be able to repeatably perform reliable builds.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="language_barriers"/>Language Barriers</h1></div></div></div><p>There are several varieties of programming languages, each with its own mechanical process of constructing an executable program from source code. Some construction models are more complex than others, and each has its strong and weak points.<a class="indexterm" id="IDX-CHP-10-0707"/><a class="indexterm" id="IDX-CHP-10-0708"/><a class="indexterm" id="IDX-CHP-10-0709"/><a class="indexterm" id="IDX-CHP-10-0710"/><a class="indexterm" id="IDX-CHP-10-0711"/><a class="indexterm" id="IDX-CHP-10-0712"/></p><p>There are three main mechanisms: <span class="emphasis"><em>interpreted</em></span> languages, <span class="emphasis"><em>compiled</em></span> languages, and <span class="emphasis"><em>byte-compiled</em></span> languages. These are shown in <a class="xref" href="ch10.html#programing_language_build_and_execution_methods" title="Figure 10-1. Programing language build and execution methods">Figure 10-1</a>.</p><div class="figure"><a id="programing_language_build_and_execution_methods"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e13685"/><img alt="Programing language build and execution methods" src="tagoreillycom20080909nostarchimages207472.png"/></div></div><p class="title"><b>Figure 10-1. Programing language build and execution methods</b></p></div><br class="figure-break"/><div class="sidebar"><a id="do_we_really_build_software_question"/><p class="title"><b>DO WE REALLY <span class="emphasis"><em>BUILD</em></span> SOFTWARE?</b></p><p><span class="emphasis"><em>Building</em></span> is often used as a metaphor for programming, equating what we do to the "traditional" building industry. There are many striking parallels, since both are construction processes. We have, in fact, seen some sort of overlap and collaboration between the two disciplines, as the software patterns movement (see "<a class="xref" href="ch13s05.html#design_patterns" title="DESIGN PATTERNS">DESIGN PATTERNS</a>" on page 255) learned from Christopher Alexander's architectural work.(Alexander 79)</p><p>It's valuable to understand how far this metaphor stretches and how useful it really is. No metaphor is perfect, after all. Although philosophical and a bit of an aside, it <span class="emphasis"><em>does</em></span> matter because the comparison will inevitably prejudice our approach to development. The metaphor is helpful in places; elsewhere it's less than perfect (even potentially harmful).</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The good</strong></span></span></dt><dd><p>Like the physical construction process of a house, we start from nothing and buildby placing one layer of structure atop another. Before the construction begins, a process of gathering requirements and careful design and architecture should have been performed. While you can probably build a garden shed without much planning, you'd be crazy to hope an unplanned skyscraper had a chance of standing up; you need serious design and planning up front. This neatly parallels our software construction.</p></dd><dt><span class="term"><span class="strong"><strong>The bad</strong></span></span></dt><dd><p>The metaphor stretches thin in other areas, though. We can modify the foundational layers of our software constructions more easily than the foundations of a house. It's far cheaper to tear down a software edifice than a physical one. This means that the software world offers the opportunity to prototype and explore more often than the physical world does.</p><p>Real World building mandates sound engineering principles; this is enshrined in statute and enforced by public liability. Many software firms wouldn't know an engineering principle if it slapped them in the face.</p></dd><dt><span class="term"><span class="strong"><strong>The ugly</strong></span></span></dt><dd><p>Our entire development procedure <span class="emphasis"><em>is</em></span> akin to a physical construction process, comprising system conception, design, implementation, and testing. But what we're actually thinking about in this chapter is subtly different—it revolves around <span class="emphasis"><em>compilation</em></span> and the procedures involved in <span class="emphasis"><em>this kind</em></span> of building task. The metaphor's a bit out of kilter here too. Each time you take a fresh copy of some source code, you "build" it, creating an executable program; <span class="emphasis"><em>that</em></span> is what we're looking at here. Be clear about these two different uses of the term "build."</p><p>The software build process follows its own rules—if you modify a function, you must then perform a system rebuild. In contrast, you don't have to rebuild the walls in your house every time you paint the doors.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="interpreted_languages"/>Interpreted Languages</h2></div></div></div><p>Code written in interpreted languages does not need to go through a specific build phase. After writing some code, you need only tell the interpreter where it is; it parses and acts on the instructions in real time. Common interpreted languages are Perl, Python, and JavaScript. The majority of OO languages are interpreted, largely because they have been developed more recently as computers have become better able to run interpreters at reasonable speeds.<a class="indexterm" id="IDX-CHP-10-0713"/><a class="indexterm" id="IDX-CHP-10-0714"/><a class="indexterm" id="IDX-CHP-10-0715"/><a class="indexterm" id="IDX-CHP-10-0716"/><a class="indexterm" id="IDX-CHP-10-0717"/><a class="indexterm" id="IDX-CHP-10-0718"/><a class="indexterm" id="IDX-CHP-10-0719"/><a class="indexterm" id="IDX-CHP-10-0720"/><a class="indexterm" id="IDX-CHP-10-0721"/><a class="indexterm" id="IDX-CHP-10-0722"/></p><p>The main advantage of interpreted languages is their speed of development; with no intermediate <span class="emphasis"><em>compile</em></span> stage; you can test each change very quickly. You also gain platform independence—popular language interpreters run on many different platforms. Your program will work wherever the interpreter has been ported.</p><p>But interpreted programs have some disadvantages: They execute more slowly than a compiled equivalent since the language run time has to read, parse, interpret, and act on each individual code statement. That's a lot of work. Modern machines are so fast that this is only a problem for the most computing-intensive applications. There are various interpreter technologies that improve code performance: Some languages precompile the source file before execution (slowing down startup time) or employ <span class="emphasis"><em>Just-In-Time ( JIT)</em></span> compilation, compiling each function as it's about to be run (slowing down each function's first call). For most programs, this isn't an appreciable overhead, and JIT-compiled performance is indistinguishable from native compiled code.<a class="indexterm" id="IDX-CHP-10-0723"/></p><p><span class="emphasis"><em>Scripting languages</em></span> are often interpreted. These languages support a very fast development cycle by being very forgiving to questionable code (with lax language rules and weak typing) and by avoiding complex features. Scripting languages are often used as glue to invoke other utilities in more convenient ways. Unix shell scripts, Windows batch files, and Tcl are examples of scripting languages.<a class="indexterm" id="IDX-CHP-10-0724"/><a class="indexterm" id="IDX-CHP-10-0725"/><a class="indexterm" id="IDX-CHP-10-0726"/><a class="indexterm" id="IDX-CHP-10-0727"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="compiled_languages"/>Compiled Languages</h2></div></div></div><p>Compiled languages employ a build toolchain to convert your source code files into machine instructions that will execute natively on the target platform. The target execution platform is usually the same as the development platform, but embedded developers often build on a PC and target very different machines, using a <span class="emphasis"><em>cross compiler</em></span>. Large projects are compiled in several stages; each individual source file is compiled into an intermediate <span class="emphasis"><em>object file</em></span>, and then these objects are linked into a final executable. This build model is illustrated by the cake-baking metaphor, shown in <a class="xref" href="ch10.html#compilation_confectionary" title="Figure 10-2. Compilation confectionary">Figure 10-2</a>, where individual ingredients (source files) are mixed (compiled) and finally baked together (linked).<a class="indexterm" id="IDX-CHP-10-0732"/><a class="indexterm" id="IDX-CHP-10-0728"/><a class="indexterm" id="IDX-CHP-10-0729"/><a class="indexterm" id="IDX-CHP-10-0730"/><a class="indexterm" id="IDX-CHP-10-0731"/></p><p>C and C++ are the most popular compiled languages, although most structured languages are compiled. By its very nature, a compiled application will run faster than its interpreted counterpart (at least, without JIT compilation), although in practice, you won't notice this—most applications are not computing-intensive; they spend most of their time stalled and waiting for user, disk, or network input.<a class="indexterm" id="IDX-CHP-10-0733"/></p><p>The compiled language build procedure is more complex than an interpreter, so there are more possible points of failure. An application has to be recompiled for each target platform you want to run it on.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-1" id="CHP-10-FN-1">1</a>]</sup></p><div class="figure"><a id="compilation_confectionary"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e13869"/><img alt="Compilation confectionary" src="tagoreillycom20080909nostarchimages207474.png"/></div></div><p class="title"><b>Figure 10-2. Compilation confectionary</b></p></div><br class="figure-break"/></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="byte-compiled_languages"/>Byte-Compiled Languages</h2></div></div></div><p>Byte-compiled languages sit halfway between interpreted and compiled languages. They involve a compilation step but don't produce a native executable program. Instead, the product is a file of <span class="emphasis"><em>byte code</em></span>; a pseudo machine language that can be executed by a <span class="emphasis"><em>virtual machine</em></span>. Java and C# are common byte-compiled languages.<a class="indexterm" id="IDX-CHP-10-0735"/><a class="indexterm" id="IDX-CHP-10-0734"/><a class="indexterm" id="IDX-CHP-10-0736"/><a class="indexterm" id="IDX-CHP-10-0737"/><a class="indexterm" id="IDX-CHP-10-0738"/><a class="indexterm" id="IDX-CHP-10-0739"/><a class="indexterm" id="IDX-CHP-10-0740"/></p><p>A common misconception is that executing byte code is <span class="emphasis"><em>necessarily</em></span> slower than executing an equivalent compiled binary. This is not always so. A JIT optimizer can make intelligent decisions about the code that may make it particularly fast (for example, tailoring itself to the exact hardware the program is executing on).</p><p>As a compromise, byte compilers inherit some of the advantages and disadvantages of the previous approaches. Byte code can be executed on any platform the virtual machine has been ported to, so you gain portability (although some language run times are more widely ported than others).<a class="indexterm" id="IDX-CHP-10-0741"/><a class="indexterm" id="IDX-CHP-10-0742"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-1" id="ftn.CHP-10-FN-1">1</a>] </sup>Target platforms are distinguished by their processor types and the host operating systems. Other factors, like the available peripheral hardware, may be important.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="making_mountains_out_of_molehills"/>Making Mountains out of Molehills</h1></div></div></div><p>The compiled (and byte-compiled) build models are the hardest to reason about, so let's investigate what compiling software entails. It's shocking how few newly trained programmers really understand this, so we'll start from first principles. If you already know this stuff, feel free to skip ahead.<a class="indexterm" id="IDX-CHP-10-0743"/><a class="indexterm" id="IDX-CHP-10-0744"/></p><p>For a good understanding, it's best to think about each manual step rather than rely on your IDE to do all the rebuilding work for you. This five-part story of a simple program's development will explain:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>You're starting a new project, coded in C. It will solve all the ills of the software development world and will usher in a new era of world peace. However all you have at first is a single file containing <code class="literal">main</code>. You've got to start somewhere.</p><p>It's easy to build and run this single-file program—you just type <code class="literal">compiler main.c</code>,<sup>[<a class="footnote" href="#ftn.CHP-10-FN-2" id="CHP-10-FN-2">2</a>]</sup> and out pops an executable for you to run and test. Simple.</p></li><li class="listitem"><p>The program grows. To help organize the parts, you split it into multiple files, one per functional block. The build is still a simple process. Now you type <code class="literal">compiler main.c func1.c func2.c</code>. The same executable program pops out, leaving you to carry on testing as before. No sweat.</p></li><li class="listitem"><p>Soon, you recognize that some sections of the code are really individual components with isolated concerns, almost like stand-alone libraries. It would be easier to reason about these sections of code by placing them in their own directories—grouping the similar sections of code together. Now the project is beginning to spread out. The simple way to build this new file structure is to compile each individual source file by hand, using a compiler call that doesn't build an executable, just intermediate object files. Afterward, <code class="literal">main.c</code> is compiled and linked with all the intermediate object files. To do this, you may also have to point the compiler at some other directories' include files. Now things are getting a little more complex.</p><p>Whenever you change some code in one of the new directories, you have to fire off the compile command in <span class="emphasis"><em>that</em></span> directory and then issue the final "link everything" command once more. Quite manual. Additionally, if you change a header file that other directories use, all of <span class="emphasis"><em>those</em></span> directories have to be rebuilt too. If you forget, the linker will probably generate a slew of cryptic complaints.<a class="indexterm" id="IDX-CHP-10-0745"/></p><p>To eliminate this huge command-line burden, you can write a <span class="emphasis"><em>shell script</em></span> (or <span class="emphasis"><em>batch file</em></span> in Windows) that walks around each directory and fires off the requisite build commands. Having hidden all that messy work and the tedious compiler parameters, you can get back to the serious business of code development with the peace of mind that you don't have to memorize unnecessary build fluff.</p></li><li class="listitem"><p>Later on, these subdirectories become real stand-alone libraries; they are also used in other projects. You tidy up the code so it's a little friendlier to use, add some good user-facing documentation, and then alter the build commands to generate <span class="emphasis"><em>shared libraries</em></span> rather than object files. This requires some more changes to your build script, but it's a relatively hidden change and isn't too painful.</p></li><li class="listitem"><p>Development carries on like this for some time. Code is added rapidly. Many new subdirectories and sub-subdirectories are created. Although the file structure seems pretty neat, build times become a problem—each time you fire up the build script, it recompiles every source file, even those that haven't changed. The temptation here is to track all changes yourself and to issue subdirectory builds by hand again (perhaps by creating individual directory build scripts as a halfway house). The project is now so large that it would be very easy to miss some dependencies. This would lead to hard to resolve build errors, or even subtler problems (e.g., you may encounter flaws that don't stop the link from working, but that do make the program behave in incorrect ways).<a class="indexterm" id="IDX-CHP-10-0746"/></p><p>Now your development is on the brink. You can't trust the system being used to build the code. It's not safe. You can only really trust the executable if you've done a complete cleanout and rebuilt from scratch.</p></li></ol></div><p>Enter the tool for just this occasion. The classic solution is a command-line program imaginatively called make. (Feldman 78) It deals with all of the intermediate object files and compilation rules for you and, most importantly, tracks which files depend on which other files. You tell it what to do by writing makefiles that provide the necessary build rules. It looks at the source file timestamps to check what has changed since you last performed a make, and then it recompiles just those files, along with anything dependent on them. It's a more intelligent version of the scripts we wrote above, specifically tailored to the task of compiling and recompiling software.<a class="indexterm" id="IDX-CHP-10-0747"/></p><p>Over the years, many variants of the humble make have appeared, these days many with pretty GUI façades. GNU Make is one of the most widely used tools (it's free and very flexible). If you haven't been initiated into the Cult of Make, "<a class="xref" href="ch10s03.html#make_colon_a_tourist_apos_s_guide" title="MAKE: A TOURIST'S GUIDE">MAKE: A TOURIST'S GUIDE</a>" on page 183 explains its basic operation.<a class="indexterm" id="IDX-CHP-10-0748"/></p><p>There are many other build systems in common use. Look at SCons, Ant, Nant, and Jam for examples. They are each tailored to a specific kind of build environment (for example, Nant is used to build .NET projects) or for a particular quality (many aim to simplfy the syntax of make, which is quite baroque!).</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-2" id="ftn.CHP-10-FN-2">2</a>] </sup>Obviously, you would replace <code class="literal">compiler</code> with the command to prod your C compiler—this is a hypothetical example.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="building_builds"/>Building Builds</h1></div></div></div><p>In that sinking morass of software construction, we've seen some of the main issues of a build procedure. Essentially, any software build process takes one or more source files as input, and it spits some executable program out the other end. It may even produce an entire release distribution, including an executable, help files, an installer, and so on, all packaged neatly and ready to be burned onto CD.<a class="indexterm" id="IDX-CHP-10-0749"/><a class="indexterm" id="IDX-CHP-10-0750"/><a class="indexterm" id="IDX-CHP-10-0751"/></p><div class="sidebar"><a id="terms_and_conditions-id1"/><p class="title"><b>TERMS AND CONDITIONS</b></p><p>These terms comprise the main software construction terminology:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code</strong></span></span></dt><dd><p>Source code is physically contained in the files that you write, and it usually occursin a high-level language. These language constructs can be converted into a functioning program with the appropriate tools.<a class="indexterm" id="IDX-CHP-10-0752"/></p></dd><dt><span class="term"><span class="strong"><strong>Compilation</strong></span></span></dt><dd><p>Source code is converted into an executable in one of two ways. One is to <span class="emphasis"><em>compile</em></span> it into an executable program. The alternative is to <span class="emphasis"><em>interpret</em></span> the source code in real time—a language run time parses and acts on the source code as the program is run.<a class="indexterm" id="IDX-CHP-10-0753"/></p></dd><dt><span class="term"><span class="strong"><strong>Build</strong></span></span></dt><dd><p>This is a vague term, often used as a synonym for <span class="emphasis"><em>compile</em></span>. Compilation is a single construction step, whereas a build describes the entire construction process. The term <span class="emphasis"><em>make</em></span> is used in a similarly vague fashion; even worse, it is also the name of a common software build tool.</p></dd><dt><span class="term"><span class="strong"><strong>Object code</strong></span></span></dt><dd><p>Object code is held in an <span class="emphasis"><em>object file</em></span>. It represents the compiled version of a file of source code. Object code is not directly executable; it relies on other files of code (most programs are made of more than one source file). An object file must be <span class="emphasis"><em>linked</em></span> with other objects to create an <span class="emphasis"><em>executable</em></span>.<a class="indexterm" id="IDX-CHP-10-0754"/></p></dd><dt><span class="term"><span class="strong"><strong>Library</strong></span></span></dt><dd><p>A code <span class="emphasis"><em>library</em></span> is akin to an object file—it is a collection of compiled code and not itself a whole program. A library contains a cohesive collection of useful functionality that can be incorporated into any program. A library can be <span class="emphasis"><em>static</em></span> or <span class="emphasis"><em>dynamic</em></span>. The former is linked like an object file, whereas the latter is dynamically loaded by the application when it is run.</p></dd><dt><span class="term"><span class="strong"><strong>Machine code</strong></span></span></dt><dd><p>Some compilation steps produce <span class="emphasis"><em>machine code</em></span> rather than object files. This is a form of source code that represents the exact CPU instructions for a program. Machine code is converted into real CPU instructions by an <span class="emphasis"><em>assembler</em></span>, which is why it's also known as <span class="emphasis"><em>assembly code</em></span>.<a class="indexterm" id="IDX-CHP-10-0755"/></p><p>Some low-level OS libraries and embedded programs are written in assembly language, but we generally work in high-level languages and leave assembly to the internal workings of the compiler.<a class="indexterm" id="IDX-CHP-10-0756"/></p></dd><dt><span class="term"><span class="strong"><strong>Linking</strong></span></span></dt><dd><p>The <span class="emphasis"><em>linker</em></span> combines one or more <span class="emphasis"><em>object files</em></span> (and perhaps libraries) into a final executable or into a partially linked code <span class="emphasis"><em>library</em></span>.</p></dd><dt><span class="term"><span class="strong"><strong>Executable</strong></span></span></dt><dd><p>The outcome of a compile or link step. This is a self-contained program that can be run directly on your computer.</p></dd></dl></div></div><p>Like the cumulative story from which I shamelessly pilfered this chapter's title, as our software develops and matures, the build process develops and matures with it. Maybe yours didn't start in as basic a state as the example above, but build scaffolding tends to start simple and grow alongside the code it builds. A large project often has a bewildering build process that requires (but doesn't necessarily always have) adequate documentation. We can see that the act of compiling a single source file is at the lowest level of the build food chain, and we will raise a tower of extra work upon this simple act.</p><p>A build process is not <span class="emphasis"><em>just</em></span> about compiling source files. It may also involve preparing some text registration files from templates, creating internationalized strings for the UI, or converting graphics files from their source resolution to some destination format. Practically all such activities can hang off a build system and be run in the normal course of a build. This does presume that all the tools are scriptable—that they can be run by some other program (e.g., by make).<a class="indexterm" id="IDX-CHP-10-0757"/></p><p>It's important to consider your build system a part of the entire source tree, not something separate. Makefiles are kept under revision control alongside other source files, are maintained alongside the source, and are as much a part of the program as any other source file. They're essential—you can't create the application without them.<a class="indexterm" id="IDX-CHP-10-0758"/><a class="indexterm" id="IDX-CHP-10-0759"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Consider the build system a part of the source tree, and maintain the two together. They are intimately entwined</em></span>.</p></dd></dl></div><div class="sidebar"><a id="make_colon_a_tourist_apos_s_guide"/><p class="title"><b>MAKE: A TOURIST'S GUIDE</b></p><p>Make is one of the most widely used build systems in the programming world. Here is a whirlwind tour of what it is and what it can do.</p><p>Make is driven by <span class="emphasis"><em>makefiles</em></span>, which usually reside in directories beside the source code they build. These makefiles contain <span class="emphasis"><em>rules</em></span> describing how to build the application. Each rule describes a <span class="emphasis"><em>target</em></span> (that is, a program or intermediate library to build), details what it depends on, and how to create it. Comments in the file are prefixed by <code class="literal">#</code>. Here's a short example (using the hypothetical <code class="literal">compiler</code> program to build source):<a class="indexterm" id="IDX-CHP-10-0760"/></p><a id="I_programlisting4_d1e14230"/><pre class="programlisting">
# This first rule says ".o files can be built from
# .c files and here's the command to do it." $&lt; and
# $@ are magic names for the source and destination
# file. Yes, make's syntax can be a little cryptic...
%.o: %.c
compiler -object $@ $&lt;
# This rule says "the program myapp is built from these
# three .o files, and here's how to link them together"
myapp: main.o func1.o func2.o
linker -output $@ main.o func1.o func2.o
</pre><p>That's the general idea. If you save this with the magic filename <code class="literal">Makefile</code> and then issue the make <code class="literal">myapp</code> command, it will be loaded and parsed. Since <code class="literal">myapp</code> depends on some .<code class="literal">o</code> files, these will first be built from their respective .<code class="literal">c</code> files using the rule provided. Then the linker command will be run to create the application. There are many ways to neaten this up so that it's more manageable. For example, makefiles can define variables; the <code class="literal">myapp</code> rule looks nicer like this:</p><a id="I_programlisting4_d1e14253"/><pre class="programlisting">
OBJECT_FILES=main.o func1.o func2.o
myapp: $(OBJECT_FILES)
linker -output $@ $(OBJECT_FILES)
</pre><p>A deeper description of the nuts and bolts of make usage is outside the scope of this book, but it's something every developer ought to know. There are many more useful features available. GUI build tools are essentially wrappers around this kind of functionality, hiding the detail of writing makefiles. They are generally easier to set up, but can be a hindrance when you want to do some advanced build configuration.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_makes_a_good_build_system_question"/>What Makes a Good Build System?</h1></div></div></div><p>Following are a few important qualities of a good build system.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="simplicity"/>Simplicity</h2></div></div></div><p>The build system must be accessible to <span class="emphasis"><em>all</em></span> programmers, not just the build gurus. Every developer must be able to perform a build, or he can't get any work done. If a build system is too complicated, it's practically useless. It must be:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Simple to learn</strong></span></span></dt><dd><p>That is, a new developer should be able to join the team and quickly understand how to build software. He won't be productive until he's mastered the build procedure. I've worked in companies where it was considered a <span class="emphasis"><em>rite of passage</em></span> to figure out how the build works and to perform one. That is not just an unhelpful attitude, it is dangerous—what happens when everyone who really knows how to build the code leaves?</p><p>As software grows, it becomes larger and harder to understand. As the build system grows alongside it, it becomes larger and harder to understand. Builds tend to become more clever and more cryptic as new facilities are introduced. Resist complexity.</p></dd><dt><span class="term"><span class="strong"><strong>Simple to set up</strong></span></span></dt><dd><p>Setting up a build means:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Taking a clean PC (with just a fresh copy of the host OS)</p></li><li class="listitem"><p>Installing all the necessary software (compilers, translators, source control, installers, plus patches/service packs)</p></li><li class="listitem"><p>Installing all the necessary libraries (noting the correct versions)</p></li><li class="listitem"><p>Creating the correct environment to perform a build in (this may involve setting up directory structures, assigning environment variables, getting the correct tool licenses, and so on)</p><p>Without clear instructions for setup, how can you be sure that your build is a repeatable procedure?</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Unsurprising</strong></span></span></dt><dd><p>It's best to use common, well-known build tools. They are what people expect and know how to use, so the learning curve is less steep. Complex build tools that do things no one really understands are worrying.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-3" id="CHP-10-FN-3">3</a>]</sup></p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="uniformity"/>Uniformity</h2></div></div></div><p>It's essential that everyone uses the same build system. Otherwise they're not building the same software. Different build mechanisms may seem equivalent—<span class="emphasis"><em>I use my IDE while he uses makefiles</em></span>—but you're increasing the maintenanc effort and the potential for error. Subtle differences can creep in—for example, compiler options may not be the same, resulting in a different executable.</p><p>This dovetails with the requirement to maintain the build system alongside the source tree. If the build system physically <span class="emphasis"><em>is</em></span> a part of the code, then it can't be ignored or avoided.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Every programmer on a project must use the same build environment. Otherwise you're not all building the same software</em></span></p></dd></dl></div><p>This may seem blindingly obvious, but it's incredibly easy to get wrong. Even if you <span class="emphasis"><em>are</em></span> all happily sharing makefiles, other differences can slip past unnoticed—mismatched versions of libraries, tools, or the build scripts can all lead to a different program being built.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="repeatable_and_reliable"/>Repeatable and Reliable</h2></div></div></div><p>Builds must be deterministic and reliable. You should be able to determine the set of input files easily before performing the build. Performing two separate builds on the same set of files should give you exactly the same executable both times—the build should be <span class="emphasis"><em>repeatable</em></span>.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>A good build system allows you to repeatedly create physically identical binary files</em></span>.</p></dd></dl></div><p>You can then mark this set of source files in the revision control system as a particular version of the software (or archive the files to a backup store), and perform many identical builds at any time in the future.<a class="indexterm" id="IDX-CHP-10-0761"/></p><p>This is crucial—an important customer may find a significant bug in an old revision of software, and if you can't get back to that version and generate the exact same program, you may never be able to reproduce the failure, let alone find the fault.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>You must be able to pull out a source tree from three years ago and rebuild it correctly</em></span>.</p></dd></dl></div><p>A build process that spits out an unreproducible binary is worrying. If what comes out of a build depends on the lunar cycle, the world becomes a hard place to reason about. This means that gratuitous use of C's <code class="literal">__DATE__</code> or other potentially changeable information should be kept to an absolute minimum in the source files.</p><p>The build must work perfectly all the time—it must be <span class="emphasis"><em>reliable</em></span>. If it falls over every other day or occasionally produces a broken binary, then it is worse than useless—it's dangerous. How can you be sure that you're testing a good binary? How can you be sure that your company is releasing an acceptable product? Problems with the build system really hamper development.</p><p>The build should be almost invisible; the only thing you need to worry about is how to turn the handle, and you should be assured that the right things will come out at the end.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="atomic"/>Atomic</h2></div></div></div><p>The ideal build system takes undoctored <span class="emphasis"><em>virgin source</em></span> and compiles it all at once, with no human intervention. There should be no special steps you have to go through to perform the build. You should not have to fire up another application halfway through and prod a file. You shouldn't even need to run more than one command to perform the build. This ensures that no information is locked away in your head, just waiting to be lost. All the build magic is documented in a reliable place—the build script itself. The build is always repeatable. It's safe.<a class="indexterm" id="IDX-CHP-10-0762"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>A good build is presented as a single step. You need only push a button or issue one command</em></span>.</p></dd></dl></div><p>If you can't reach this ideal (and it's not <span class="emphasis"><em>at all</em></span> unreasonable), then the less manual a build is, the better. All of the manual steps need full documentation. It is acceptable (in fact, it's advisable) to break the procedure up into these separate parts:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Obtain the virgin source.</p></li><li class="listitem"><p>Build it.</p></li><li class="listitem"><p>Create the release distribution from this.</p></li></ol></div><p>See how the notion of <span class="emphasis"><em>building</em></span> the code is separate from <span class="emphasis"><em>obtaining</em></span> it—the same build instruction could potentially create any version of the software, depending on the version of source you start with. <span class="emphasis"><em>Packaging</em></span> the program is also a separate step; for development work, you don't always want to waste time creating a full install package.</p><div class="sidebar"><a id="a_war_story-id2"/><p class="title"><b>A WAR STORY</b></p><p>Repeatable builds are essential; you must be able to regenerate any released version of your software. You'll get into trouble otherwise. I once worked for a company that struggled with this exact problem.</p><p>They had made a live change to the code on a customer's site and did not replicate the change in their master copy under version control. The customer was no longer running an "official" software release. Later on, when the customer found a critical bug, the programmers couldn't reproduce it. But of course no one could figure out why, because the on-site tweak had been long forgotten.</p><p>Why did they do this? Because it was much, much easier to make a quick-anddirty change than to do it properly (i.e., fix the bug in the main codebase, test it, make an official software release, ship it to the customer, and then get the appropriate approval and sign-off before installation). When your client's business depends on your software and its entire production line is waiting for you to fix a bug, the pressure for a dirty hack is enormous.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="coping_with_errors"/>Coping with Errors</h2></div></div></div><p>At the end of development, when the dust settles over finished code, there will be <span class="emphasis"><em>no</em></span> build errors. But during development you'll be breaking things all over the place. The build system has to cope with this and should lend a hand to deal with it.<a class="indexterm" id="IDX-CHP-10-0763"/><a class="indexterm" id="IDX-CHP-10-0764"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your build system should not continue after an error. It should stop and leave you with no doubt about what broke and where it can be fixed. If the build process continues, other problems will almost certainly result as a consequence of that first skipped error. These will be very hard to understand. For your own sanity, don't break this rule!</p></li><li class="listitem"><p>The build system should remove any incomplete objects when a build step fails. Otherwise the next time you run a build, it will assume that file is actually intact and pick up after it. This will cause much pain later on; errors that magically hide themselves are great fun.<a class="indexterm" id="IDX-CHP-10-0765"/></p></li><li class="listitem"><p>Builds should not be <span class="emphasis"><em>noisy</em></span>. This isn't determined so much by the build process as the source code that you've written.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-4" id="CHP-10-FN-4">4</a>]</sup> If your code generates compiler warnings, then there is something in it that you should be looking into. Persuade the compiler to be quiet by writing better code. Copious silly warnings can cloak the more insidious messages that you <span class="emphasis"><em>should</em></span> be reading.</p><p>For maximum peace of mind, build with all compiler warnings enabled—switching them off does not fix the problem; it hides it.</p><p>The only real way to follow this advice is from the very start: Think about the build process at the beginning of your project. Trying to add the flag that says <span class="emphasis"><em>all warnings enabled</em></span> when you've already written a lot of code will result in an instant flood of warnings. The overwhelmingly likely response is to quickly turn the flag off again and pretend it never happened. Anything for an easy life. You really have to start as you mean to go on.</p></li></ul></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-3" id="ftn.CHP-10-FN-3">3</a>] </sup>I have an built-in distrust of anything more clever than GNU Make, but that probably says more about me than the other clever make tools. GNU Make is <span class="emphasis"><em>quite</em></span> clever enough, thank you!</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-4" id="ftn.CHP-10-FN-4">4</a>] </sup>Actually, it could be—you can disable compiler warnings to remove the noise. This is the <span class="emphasis"><em>wrong</em></span> way to solve the problem.<a class="indexterm" id="IDX-CHP-10-0766"/><a class="indexterm" id="IDX-CHP-10-0767"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_mechanics"/>The Mechanics</h1></div></div></div><p>Beyond those quality concerns are the practicalities of a build system. To discuss this in concrete terms, we'll talk about make, a specific build system, and makefiles a lot—don't worry too much; barring syntactic differences, other build systems follow similar conventions (even the pretty graphical ones).</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="choice_of_targets"/>Choice of Targets</h2></div></div></div><p>Makefiles define <span class="emphasis"><em>rules</em></span> that describe how to build <span class="emphasis"><em>targets</em></span>. (Remember: Other build systems work in a very similar manner, even if the terminology is subtly different.) The system is clever enough to infer all intermediate targets and build those along the way. A single makefile can contain multiple targets. This allows you to use one build system to generate several different outputs, such as:<a class="indexterm" id="IDX-CHP-10-0768"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Distinct programs (commonly seen when two programs have some common code components and so live in the build source tree)</p></li><li class="listitem"><p>Different target platforms to build your application for (say a Windows/Apple/Linux version, or a desktop/PDA release)</p></li><li class="listitem"><p>Product variants (the full <span class="emphasis"><em>release build</em></span> or a <span class="emphasis"><em>demo</em></span> version with save/print disabled)<a class="indexterm" id="IDX-CHP-10-0769"/></p></li><li class="listitem"><p>The development build (with debugging support enabled, logging switched on, and assertions made fatal</p></li><li class="listitem"><p>Differing <span class="emphasis"><em>levels</em></span> of build (build just the internal libraries, build the application, build an entire distribution)</p></li></ul></div><p>You might even require some combination of these targets, say a "demonstration PDA" build.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-5" id="CHP-10-FN-5">5</a>]</sup> You can design your source tree so that each of these targets can be built from the same place. Rather than type just <code class="literal">make</code>, you might type <code class="literal">make desktop</code> or <code class="literal">make pda</code>, and an appropriate executable will come out the other end. (The name following <code class="literal">make</code> is the rule it should attempt to build.)</p><p>There is a huge benefit in doing this rather than having separate source trees for each target. Maintaining several source trees across which most of the code is identical would be an intense and error-prone task. You could easily forget to apply one of your modifications to all copies of the code.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-6" id="CHP-10-FN-6">6</a>]</sup></p><p>So how do these target rules differ? The actual differences can boil down to a number of things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Different files being built (e.g., <code class="literal">save_release.c</code> or <code class="literal">save_demo.c</code>)</p></li><li class="listitem"><p>Different macro definitions being passed through to the compiler (e.g., the compiler predefines a <code class="literal">DEMO_VERSION</code> macro to select appropriate <code class="literal">#ifdef</code>ed code in <code class="literal">save.c</code>)</p></li><li class="listitem"><p>Different compiler options being used (e.g., to enable debugging support)</p></li><li class="listitem"><p>Different tool sets or environments being selected for building (e.g., using the correct compiler for the target platform)</p></li></ul></div><p>While you could have any number of targets for all sorts of minor differences, it opens the possibility of making your build system complex and unwieldy. Some selections can be moved to build configuration options. Some configuration can actually be done at code install time, or even at run time. This is preferable if it reduces the number of different builds that exist and require testing.</p><div class="sidebar"><a id="life_after_make"/><p class="title"><b>LIFE AFTER MAKE</b></p><p>A lot of the issues we're investigating here are quite specific to the C-style development cycle, where a compiler generates object code and libraries from source files, and these are linked into a final executable. Some languages follow a different model. Java simplifies the build process greatly; the javac compiler takes over the role of make, performing dependency checks automatically. It locks you down more, enforcing a particular build tree structure, but makes your life easier by doing so.<a class="indexterm" id="IDX-CHP-10-0770"/><a class="indexterm" id="IDX-CHP-10-0771"/></p><p>Simple Java programs don't need an elaborate build system; one <code class="literal">javac</code> command can safely rebuild the world. However, a reasonably large Java project often <span class="emphasis"><em>will</em></span> employ make. We've seen that there is more to a build than just compiling source. You need a mechanism to prepare supporting files, to run automated tests, and to create the final distribution. Make is a good framework for this to hang off of, so it isn't entirely redundant.<a class="indexterm" id="IDX-CHP-10-0772"/></p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="housekeeping"/>Housekeeping</h2></div></div></div><p>For every target rule you define, there should be a corresponding <span class="emphasis"><em>clean</em></span> rule that undoes all the build operations—removing the program executable, intermediate library, object files, and any other files created during the build. The source tree should revert to its original virgin state—it's relatively easy to verify that it does.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-7" id="CHP-10-FN-7">7</a>]</sup></p><p>This implies that a build system that physically alters the source files is nasty—how can you easily revert from these changes? You should instead use the original files as templates, and send modifications to a different output file.<a class="indexterm" id="IDX-CHP-10-0774"/></p><p>Clean rules are a good housekeeping convention. They allow you to easily sweep everything away and rebuild from scratch when you think that a build gremlin is catching up to you.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>For every build rule, have a corresponding clean rule that undoes the action</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="dependencies"/>Dependencies</h2></div></div></div><p>How does a build system know which files depend on which others? Short of ESP, it's a difficult task, and so we will elicit help from the people who do know.<a class="indexterm" id="IDX-CHP-10-0775"/></p><p><span class="emphasis"><em>You</em></span> provide dependency information in your makefile rules: a recipe in make's preferred format. Make can build and follow the tree of dependencies, inspect each file's timestamp, and work out which parts need to be rebuilt after any modification.</p><p>This is simple enough for an executable build rule—you just need to specify which object files and libraries comprise it. You don't, however, want to laboriously specify dependency information for every single source file; no doubt there are many <code class="literal">#include</code>d files, which themselves <code class="literal">#include</code> many others. Quite a list. It would be really easy to type incorrectly at first and very likely to become out of date; you could easily add a new <code class="literal">#include</code> and forget to alter the makefile correspondingly.</p><p>Who <span class="emphasis"><em>does</em></span> know about all this dependency information? The compiler does—it's the one component in the build system that actually traces all source file dependencies. Helpfully, all good compilers have an option that causes them to spit out dependency information. The trick is to write a make rule that gathers this dependency information, places it in an appropriately formatted file, and then includes <span class="emphasis"><em>that</em></span> in the dependency tree.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="automated_builds"/>Automated Builds</h2></div></div></div><p>If your build procedure is atomic, a simple matter of firing off one command, you can easily set up overnight builds of the entire source tree.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-8" id="CHP-10-FN-8">8</a>]</sup> A regular overnight build takes the code that has been produced during the day and applies the full build procedure to it. This is a remarkably helpful practice with many benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Every morning there's a fresh copy of the state of the art. Developers often spend the day in their own little worlds, forgetting to synchronize their code with colleagues' check-ins. This technique provides a painless integration test, checking that everything knits together properly.</p></li><li class="listitem"><p>It identifies build problems early on, with no extra work on your part. When you sit down at your desk in the morning, coffee in hand, you can see whether the source tree is in a buildable state. You'll know immediately where to start fixing, rather than wait for your own build to complete.</p></li><li class="listitem"><p>You can add automated regression and stress tests to the overnight build. This is a good way to sanity-test code before anyone ever tries to use it. During the day, you may not have time to run the full test suite with every build—this ensures that it never gets overlooked. It's a potent validation mechanism.</p></li><li class="listitem"><p>The overnight build can be used as a yardstick of project progress. Publish the overnight test results and, as more and more tests pass, the developers gain a sense of achievement.</p></li><li class="listitem"><p>You can make actual product releases from the overnight build. You'll trust this build to have not suffered from command-typing mistakes, misconfiguration, or other human errors.</p></li><li class="listitem"><p>It proves that you really know how to build the software and that the build procedure really <span class="emphasis"><em>is</em></span> atomic. Without running automatic builds, how do you know that your build process doesn't rely on some other activity, like one of the developers cleaning away the old build tree first?</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Establish an automatic build of your software. Use it to ensure that your codebase is in a consistent state</em></span>.</p></dd></dl></div><p>Automated builds are especially good for big systems (where a build of <span class="emphasis"><em>everything</em></span> may take hours and hours) or for systems with many people working alongside one another (where each developer may not have a copy of the absolute latest system source at any given point).</p><p>A good practice with nightly builds is to capture the <span class="emphasis"><em>build log</em></span> (the output of the build procedure) and make it publicly accessible. Perhaps even email the results around when the build fails, to highlight the problem. It's important to know what happened each time a build ran, especially when something goes wrong.<a class="indexterm" id="IDX-CHP-10-0782"/></p><p>The overnight build becomes a central heartbeat of project development. The code is developing healthfully and happily if the builds are successful. A great rule enforced on many projects is: <span class="emphasis"><em>Don't break anything in the source tree</em></span>—checking in code that breaks during the nightly build is punishable by something extremely painful and unpleasant (preferably involving public humiliation). A second rule is this: <span class="emphasis"><em>If the build breaks, it's everyone's problem</em></span>. If the overnight build fails, all developers must put down their down tools until it works again.</p><p>You can take this automatic build procedure to the extreme, and use tools that perform a build whenever the source repository is altered. This is known as continuous integration and is a powerful way to check that your code is consistent and buildable at any point in time.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="build_configuration"/>Build Configuration</h2></div></div></div><p>A good build system allows you to configure certain aspects on a per-build basis. This could be via options in your IDE, but makefiles usually achieve this by defining <span class="emphasis"><em>variables</em></span>. Variables can be picked up from a number of places:<a class="indexterm" id="IDX-CHP-10-0783"/><a class="indexterm" id="IDX-CHP-10-0784"/><a class="indexterm" id="IDX-CHP-10-0785"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Inherited from the calling environment</p></li><li class="listitem"><p>Set on make's command line</p></li><li class="listitem"><p>Defined explicitly within a makefile</p></li></ul></div><p>Configuration variables are commonly used in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <code class="literal">PROJECT_ROOT</code> variable is defined, pointing to the root of the build tree. This allows the build system to know where to look for other files—for example, to establish paths for header files. You really don't want to hard-code the location of the build tree on your development machine. If you did, you could never move it around, and you wouldn't be able to manage two build trees at the same time.</p></li><li class="listitem"><p>Other variables may specify where to find each external library (so you can point the build at different versions for testing purposes).</p></li><li class="listitem"><p>They may specify the kind of build to produce (<span class="emphasis"><em>development</em></span> or <span class="emphasis"><em>release</em></span>, for example).</p></li><li class="listitem"><p>The command to invoke each build tool (compiler, linker, etc.) can be placed into a variable. This makes it easy to test a different set of command-line parameters, or to employ a different vendor's tool.</p></li></ul></div><p>You can put default values into the makefile. This serves two purposes: it documents all the available options and means you don't <span class="emphasis"><em>have</em></span> to provide values for every config option all the time.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="recursive_make"/>Recursive Make</h2></div></div></div><p>Source code naturally nests into directories. If all the files in a large project got dumped into one directory, things would rapidly become unmanageable. Since the source tree nests, the build system has to nest too. Far from making life more complex, accommodating this nesting can make the build system more flexible.<a class="indexterm" id="IDX-CHP-10-0786"/><a class="indexterm" id="IDX-CHP-10-0787"/></p><p>A makefile in one directory can invoke the makefiles in subordinate directories by firing off another <code class="literal">make</code> command, just as it would invoke a compiler. This is a common technique known as <span class="emphasis"><em>recursive make</em></span>; the build system that recurses into each subdirectory builds the components in there and returns to build the components in this directory. In this way, you can type <code class="literal">make</code> from the project root directory to build the whole codebase, or within a subcomponent's directory for a partial build. Whatever you want to be built is built.<a class="indexterm" id="IDX-CHP-10-0788"/><a class="indexterm" id="IDX-CHP-10-0789"/></p><p>Recursive make helps to compartmentalize and manage build components, but introduces some problems of its own. It is slow (as it fires off many child processes to traverse into subdirectories), and since each child-make only sees its portion of the entire build tree, it can get dependency information incorrect. Be wary of recursive make if you see it—prefer to make non-recursive build systems. (For more on this, see the answer to this chapter's "<a class="xref" href="ch09s10.html#mull_it_over-id8" title="Mull It Over">Mull It Over</a>" question 7 on page 506.)<a class="indexterm" id="IDX-CHP-10-0790"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-5" id="ftn.CHP-10-FN-5">5</a>] </sup>In this case, the mechanism changes: You can only build one target at a time, so the "demo-ness" would become a build configuration rather than a target. A later section discusses configurations.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-6" id="ftn.CHP-10-FN-6">6</a>] </sup>Note how this dangerous approach is different from maintaining multiple <span class="emphasis"><em>branches</em></span> of a project in a revision control system. Revision control systems provide a mechanism to <span class="emphasis"><em>merge</em></span> changes across branches and to easily compare branches for differences.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-7" id="ftn.CHP-10-FN-7">7</a>] </sup>Just do a build, do a clean, and then check the tree for differences from the start state.<a class="indexterm" id="IDX-CHP-10-0773"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-8" id="ftn.CHP-10-FN-8">8</a>] </sup>Time-delayed commands can be set up in Unix using the cron utility or in Windows using the Scheduled Tasks facility.<a class="indexterm" id="IDX-CHP-10-0776"/><a class="indexterm" id="IDX-CHP-10-0777"/><a class="indexterm" id="IDX-CHP-10-0778"/><a class="indexterm" id="IDX-CHP-10-0779"/><a class="indexterm" id="IDX-CHP-10-0780"/><a class="indexterm" id="IDX-CHP-10-0781"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="please_release_me"/>Please Release Me</h1></div></div></div><p>Some builds are particularly important and require more care in their preparation. These are <span class="emphasis"><em>release builds</em></span>, builds that are made with a special purpose, rather than in the course of code development. A release could be one of a number of exciting events: a beta version, the first official product release, or a maintenance release. It may also be an internal development milestone or an interim release to the test department; these builds won't leave the company but are held in as high regard as external releases, almost a fire drill for an official release.<a class="indexterm" id="IDX-CHP-10-0795"/><a class="indexterm" id="IDX-CHP-10-0791"/><a class="indexterm" id="IDX-CHP-10-0792"/><a class="indexterm" id="IDX-CHP-10-0793"/><a class="indexterm" id="IDX-CHP-10-0794"/></p><p>If the build system is carefully crafted, there shouldn't be any extra preparation needed for a release build. However, these important builds must be handled thoughtfully, so we need to make sure that no build issues compromise the final executable. The key concerns with release builds are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Release builds should always come from a virgin source tree, not from someone's half-built development tree. Start from scratch. We need to know the exact state of the source files being built. Do not trust the files on Joe's computer to be in a "good enough" state.</p></li><li class="listitem"><p>Prior to the build itself, a specific step identifies which source code and which particular file versions to include in this release. It then marks them in some manner, usually by tagging or labeling them in the source control system. The release's file set is now retrievable at any later point.</p><div class="sidebar"><a id="the_openparenthesis_source_closeparenthesisx_tree_of_knowledge"/><p class="title"><b>THE (SOURCE) TREE OF KNOWLEDGE</b></p><p>All code lives in a <span class="emphasis"><em>source tree</em></span>; a file structure housing directories and source files. The structure of this tree affects how easy the code is to work with. A messy glob of files is far harder to understand than a neatly arranged hierarchy. We can use the source file structure to our advantage, making development easier. This tree structure goes hand-in-hand with the build system, since the build system physically is a part of the source tree (hence the term <span class="emphasis"><em>build tree</em></span> is used interchangeably with <span class="emphasis"><em>source tree</em></span>). A modification to one requires meddling with the other.<a class="indexterm" id="IDX-CHP-10-0796"/><a class="indexterm" id="IDX-CHP-10-0797"/><a class="indexterm" id="IDX-CHP-10-0798"/><a class="indexterm" id="IDX-CHP-10-0799"/><a class="indexterm" id="IDX-CHP-10-0800"/></p><p>We divide code into separate modules, libraries, and applications. A good source tree reflects that structure. The code composition should map neatly into files, using directories as a logical grouping mechanism. This helps to manage development with multiple programmers—each person will probably be working in his own self-contained directory, removed from other people's work by a reasonably safe distance.<a class="indexterm" id="IDX-CHP-10-0801"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Libraries</strong></span></span></dt><dd><p>Place each library in its own self-contained directory. Use the tree structure to differentiate the library <span class="emphasis"><em>interface</em></span> (the public header files) from private <span class="emphasis"><em>implementation</em></span> details. It is a good idea to place the public API within a directory on the compiler's lookup path and keep any private headers out of the way.</p></dd><dt><span class="term"><span class="strong"><strong>Applications</strong></span></span></dt><dd><p>Structuring is easier; there are no public files as such, just a collection of source files that link to libraries. Even so, wrap each application in its own directory to make its bounds clear. If the application is large enough to have distinct constituent parts, they should be separated into subdirectories, or even libraries, and built separately. Make the build tree reflect the program structure.</p></dd><dt><span class="term"><span class="strong"><strong>Third-party code</strong></span></span></dt><dd><p>The source tree should clearly mark <span class="emphasis"><em>your own</em></span> code from third-party work. Projects increasingly rely on others' code; common libraries are brought in from outside (from commercial vendors, free software projects, or even other parts of the company). These external files should be kept separate.<a class="indexterm" id="IDX-CHP-10-0802"/></p></dd><dt><span class="term"><span class="strong"><strong>Other stuff</strong></span></span></dt><dd><p>Program documentation can live in the source tree. Put it in directories beside the code it refers to. The same holds for graphics and any other supporting files.</p></dd></dl></div></div></li><li class="listitem"><p>Each release build has a particular name you identify it by, sometimes a cool code name, sometimes just a build number. This should tally with the source control label the code was marked with. If you and I agree that we're talking about "build five" when investigating a fault, then we're working in harmony. If you are working with build five, but I found a fault in build six, how do we know we'll see the same issues?</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Release builds are always made from virgin source. Ensure that these pristine sources can always be retrieved from source control or a backup archive in the future</em></span>.</p></dd></dl></div></li><li class="listitem"><p>There may be some extra packaging stage after the code has been built, like preparing a CD, adding documentation, integrating licensing information, or whatever. This step should also be automated.</p></li><li class="listitem"><p>Each release should be archived and stored for future reference. Obviously you store a copy of the final built executable in whatever form it ships to the user (the exact shipped Zip file, self-extracting EXE, or whatever). You should also capture the final state of the build tree if possible, but often this will be enormous and impractical.</p></li><li class="listitem"><p>At the very least, the <span class="emphasis"><em>build log</em></span>, the exact sequence of commands issued and the response generated, should be retained. These logs allow you to look back over old builds and see which compiler errors were overlooked or exactly what happened during the build. Sometimes this can give a clue into a fault reported in a years-old version of product that has long since been discontinued.</p></li><li class="listitem"><p>Each release has a <span class="emphasis"><em>release note</em></span> that describes what has changed. It may or may not be a customer-facing document, depending on exactly what you're building. These notes should also be archived. Usually the release note describes the changes since the last release and contains updates subsequent to the printing of the official documentation, any known issues, upgrade instructions, and so on. It is an important part of the release procedure and shouldn't be overlooked.<a class="indexterm" id="IDX-CHP-10-0803"/></p></li><li class="listitem"><p>When performing release builds, you must select the correct set of compiler switches—they might differ from those used in development builds. Debugging support gets switched off, for example. You also need to choose what level of code optimization is appropriate. Optimization may be disabled for development builds since the optimizer often takes a particularly long time to execute. This can become unbearable on very large build trees. However, ramping the optimizer up to warp speed nine may expose compiler bugs that break your code; you have to carefully choose (and test) a level.<a class="indexterm" id="IDX-CHP-10-0804"/><a class="indexterm" id="IDX-CHP-10-0805"/></p><p>If you use different sets of compiler options for development and release builds, beware. You <span class="emphasis"><em>must</em></span> test the release builds regularly, long before a deadline approaches. Aim to minimize the differences between release and development builds.<a class="indexterm" id="IDX-CHP-10-0806"/></p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Ensure that you test the release configuration of your application, not just the development builds. Subtle differences may adversely affect the code's behavior</em></span>.</p></dd></dl></div><p>Since creating a release build is a relatively involved task and is so important to get right, responsibility is usually delegated to a nominated team member (perhaps one of the coders, perhaps someone in QA). That person produces all the release builds for the project to make sure that each build is of the same high quality. Release builds are as much about procedure as they are about the build system.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="jack-of-all-trades_comma_buildmaster_of_question"/>Jack-of-All-Trades, Buildmaster Of?</h1></div></div></div><p>Many organizations employ a specific person to fulfill a <span class="emphasis"><em>build engineer</em></span> role, often known as the <span class="emphasis"><em>buildmaster</em></span>. This person's job is to maintain the build system. The role may also involve planning and managing release schedules, or it may be purely technical. The buildmaster knows the build system intimately. He or she probably sets it up, adds new targets as required, maintains the overnight build scripts, and so on. The buildmaster also owns the build system documentation, and probably administers the source control system.<a class="indexterm" id="IDX-CHP-10-0807"/></p><p>The buildmaster performs the release builds, and for this reason is often heavily involved with tracking component stability. He or she is charged with ensuring the reliability and safety of the release process.</p><p>The buildmaster is not always a specific full-time position; sometimes a programmer will double in this task.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id9"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>It is easier to pull down than to build up</p><div class="attribution"><span>--<span class="attribution">Latin proverb</span></span></div></div><p>On the face of it, building software is easy if you have the right tools. But you have to know how to use the tools properly. The quality of your build system is paramount; without a safe, reliable build process, you can't realistically develop solid code. Producing trustworthy release builds for production is an even more involved matter—it requires a thorough approach and a well-defined procedure. It is important to have an understanding of what's going on when you fire off a build, even if you don't have to alter the build system every day.<a class="indexterm" id="IDX-CHP-10-0808"/></p><p>Performing good builds is not a straightforward task; our jobs are safe from the proverbial infinite number of monkeys. They're too busy arguing about which of their infinite number of text editors is the better one, anyway.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Understand how their build system works, how to use it, and how to extend it</p></li><li class="listitem"><p>Craft simple, atomic build systems, and maintain them alongside the source code</p></li><li class="listitem"><p>Automate as many build activities as possible</p></li><li class="listitem"><p>Use overnight builds to catch integration problems</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ignore build system mechanics, then get caught by silly build problems</p></li><li class="listitem"><p>Don't care how unsafe and unreliable their build system is</p></li><li class="listitem"><p>Expect newcomers to pick up their baroque build procedure in an almost adversarial manner</p></li><li class="listitem"><p>Create thrown-together release builds without following a defined release procedure</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id9"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a></span></dt><dd><p>Describes how to deal with build errors.</p></dd><dt><span class="term"><a class="xref" href="ch18.html" title="Chapter 18. PRACTICING SAFE SOURCE">Chapter 18</a></span></dt><dd><p>The build tree is held in a source control system, and the two are intimately linked.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e15191"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207476.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id10"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 502.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id9"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Why should people with nice integrated development environments worry about using a command-line make utility, when they can just hit a single button to build their project?</p></li><li class="listitem"><p>Why is it important to treat the extraction of source code as a separate step from building it?</p></li><li class="listitem"><p>Where should the intermediate files from construction steps (e.g., object files) be put?</p></li><li class="listitem"><p>If you add an automated test suite to the build system, should it run automatically after the software is built, or must you fire a separate command to invoke the tests?</p></li><li class="listitem"><p>Should the overnight build be a <span class="emphasis"><em>debug</em></span> or <span class="emphasis"><em>release</em></span> build?</p></li><li class="listitem"><p>Write a make rule to automatically generate dependency information from your compiler. Show how to use this information in the makefile.</p></li><li class="listitem"><p>Recursive make is a popular method of creating a modular build system spanning several directories. However, it is fundamentally flawed. Describe its problems and suggest alternatives.</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id9"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Do you know how to perform different types of compilation using your build system? How can you build a debug or release version of the application from the same sources, with the same makefiles?<a class="indexterm" id="IDX-CHP-10-0809"/></p></li><li class="listitem"><p>How good is your current project's build process? Does it rate well against the characteristics in this chapter? How could you improve it? How easy is it to:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Add a new file to a library?</p></li><li class="listitem"><p>Add a new directory of code?</p></li><li class="listitem"><p>Move or rename a file of code?</p></li><li class="listitem"><p>Add a different build configuration (say, a demo build)?</p></li><li class="listitem"><p>Build two configurations in one copy of the source tree without doing a clean in between?</p></li></ol></div></li><li class="listitem"><p>Have you ever created a build system from scratch? What drove you to its particular design?</p></li><li class="listitem"><p>Everyone suffers from flaws in a build system from time to time. When programming a build script, you're as likely to introduce bugs as you are when programming real code.</p><p>What kinds of build errors have you been bitten by, and how could you fix, or even prevent, them?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_need_for_speed"/>Chapter 11. THE NEED FOR SPEED</h1></div><div><h3 class="subtitle"><i>Optimizing Programs and Writing Efficient Code</i></h3></div></div></div><div class="epigraph"><p>There is more to life than increasing its speed.</p><div class="attribution"><span>--<span class="attribution">Mahatma Gandhi</span></span></div></div><p>We live in a fast food culture. Not only must our dinner arrive yesterday; our car should be fast and our entertainment instant. Our code should also run like lightning. I want my result. And I want it <span class="emphasis"><em>now</em></span>.</p><p>Ironically, writing fast programs takes a long time.</p><p>Optimization is a spectre hanging over software development, as renowned computer scientist W.A. Wulf observed: "More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity." (Wulf 72)<a class="indexterm" id="IDX-CHP-11-0811"/></p><p>Optimization is a well-worn subject, on which everyone has offered their two cents' worth, and the same advice has been served time and time again. But despite this, a lot of code is <span class="emphasis"><em>still</em></span> not developed sensibly. Optimization seems like a good idea, but programmers get it wrong all too often: They get sidetracked by the lure of efficiency, they write bad code in the name of performance, they optimize when it's really not necessary, or they apply the wrong kind of optimizations.</p><p>In this chapter, we'll address this. We'll tread the familiar ground, but look out for some new views on the way. Don't worry—if the subject is optimization, it shouldn't take too long. . . .</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_optimization_question"/>What Is Optimization?</h1></div></div></div><p>The word <span class="emphasis"><em>optimization</em></span> purely means to make something better, to improve it. In our world, it's generally taken to mean "making code run faster," measuring a program's performance against the clock. But this is only a part of the picture. Different programs have different requirements; what's "better" for one may not be "better" for another. Software optimization may actually mean any of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Speeding up program execution</p></li><li class="listitem"><p>Decreasing executable size</p></li><li class="listitem"><p>Improving code quality</p></li><li class="listitem"><p>Increasing output accuracy<a class="indexterm" id="IDX-CHP-11-0812"/></p></li><li class="listitem"><p>Minimizing startup time</p></li><li class="listitem"><p>Increasing data throughput (<span class="emphasis"><em>not necessarily</em></span> the same as execution speed)</p></li><li class="listitem"><p>Decreasing storage overhead (i.e., database size)</p></li></ul></div><p>Conventional optimization wisdom is summed up by M.A. Jackson's infamous laws of optimization:<a class="indexterm" id="IDX-CHP-11-0813"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Don't do it.</p></li><li class="listitem"><p><span class="emphasis"><em>(For experts only)</em></span> Don't do it yet.</p></li></ol></div><p>That is, you should avoid optimization at all costs. Ignore it at first, and only consider it at the end of development when your code is not running fast enough. This is a simplistic viewpoint—accurate to a point, but potentially misleading and harmful. Performance is really a valid consideration right from the humble beginnings of development, before a single line of code has been written.</p><p>Code performance is determined by a number of factors, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The execution platform</p></li><li class="listitem"><p>The deployment or installation configuration</p></li><li class="listitem"><p>Architectural software decisions</p></li><li class="listitem"><p>Low-level module design</p></li><li class="listitem"><p>Legacy artifacts (like the need to interoperate with older parts of the system)</p></li><li class="listitem"><p>The quality of each line of source code</p></li></ul></div><p>Some of these are fundamental to the software system as a whole, and an efficiency problem there won't be easy to rectify once the program has been written. Notice how little impact individual lines of code have; there is so much more that affects performance. We must manage performance issues at every step of the development process and deal with any problems as they arise. In a sense, optimization (while not a specific scheduled activity) is an ongoing concern through all stages of development.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p>Think about the performance of your program from the very start—do not ignore it, hoping to make quick fixes at the end of development.</p></dd></dl></div><p>But don't use this as an excuse to write tortured code based on your notion of what is fast or not. Programmers' gut feelings for where bottlenecks lie are seldom right, no matter how experienced they are. In the following sections, we'll see practical solutions to this code-writing dilemma.</p><p>But first, the golden rule. Before you consider a stint of code optimization, you must bear this advice in mind:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Correct</em></span> code is far more important than <span class="emphasis"><em>fast</em></span> code. There's no point in arriving quickly at the wrong answer.</p></dd></dl></div><p>You should spend more time and effort proving that your code is correct than making it fast. Any later optimization must not break this correctness.</p><div class="sidebar"><a id="a_war_story-id3"/><p class="title"><b>A WAR STORY</b></p><p>I once discovered that a module I'd written was running unbelievably slowly. I profiled it and tracked the problem down to a single line of code. It was called frequently and appended a single element to a buffer.</p><p>Upon inspection, the buffer (which I was given and hadn't written) was expanding itself by a <span class="emphasis"><em>single element</em></span> each time it got full! In other words: Every single append was allocating, copying, and deallocating the entire buffer. Ouch. Needless to say, I was not expecting this behavior.</p><p>This helps to show how we get suboptimal programs: by growth. Few people willfully attempt to write an ambling program. As we glue software components into a larger system, we can easily make assumptions about the performance characteristics of the code and end up with a nasty shock.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_makes_code_suboptimal_question"/>What Makes Code Suboptimal?</h1></div></div></div><p>In order to improve our code, we have to know the things that will slow it down, bloat it, or degrade its performance. Later on, this will help us to determine some code optimization techniques. At this stage, it's helpful to appreciate what we're fighting against.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Complexity</strong></span></span></dt><dd><p>Unnecessary complexity is a killer. The more work there is to do, the more slowly the code will run. Reducing the amount of work or breaking it up into a different set of simpler, faster tasks can greatly enhance performance.<a class="indexterm" id="IDX-CHP-11-0814"/></p></dd><dt><span class="term"><span class="strong"><strong>Indirection</strong></span></span></dt><dd><p>This is touted as the solution to all known programming problems, summarized by the infamous programmer maxim: <span class="emphasis"><em>Every problem can be solved by an extra level of indirection</em></span>. But indirection is also blamed for a lot of slow code. This criticism is often leveled by old-school procedural programmers, aimed at modern OO designs.<a class="indexterm" id="IDX-CHP-11-0815"/></p></dd><dt><span class="term"><span class="strong"><strong>Repetition</strong></span></span></dt><dd><p>Repetition can often be avoided and will inevitably ruin code performance. Repetition can often be avoided and will inevitably ruin code performance. It comes in many guises—for example, failing to cache the results of expensive calculations or of remote procedure calls. Every time you recompute, you waste precious efficiency. Repeated code sections unnecessarily extend executable size.</p></dd><dt><span class="term"><span class="strong"><strong>Bad design</strong></span></span></dt><dd><p>It's inevitable: Bad design will lead to bad code. For example, placing related units far away from each other (across module boundaries, for example) will make their interaction slow. Bad design can lead to the most fundamental, the most subtle, and the most difficult performance problems.<a class="indexterm" id="IDX-CHP-11-0816"/></p></dd><dt><span class="term"><span class="strong"><strong>I/O</strong></span></span></dt><dd><p>A program's communication with the outside world—its input and output—is a remarkably common bottleneck. A program whose execution is blocked waiting for input or output (to and from the user, the disk, or a network connection) is bound to perform badly.</p><p>This list is nowhere near exhaustive, but it gives us a good idea of what to think about as we investigate how to write optimal code.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="why_not_optimize_question"/>Why Not Optimize?</h1></div></div></div><p>Historically, optimization was a crucial skill, since early computers ran very, very slowly. Getting a program to complete in anything like reasonable time required a lot of skill and the hand-honing of individual machine instructions. That skill is not so important these days; the personal computer revolution has changed the face of software development. We often have a surplus of computational power, quite the reverse of the days of yore. It might seem that optimization doesn't really matter anymore.<a class="indexterm" id="IDX-CHP-11-0817"/><a class="indexterm" id="IDX-CHP-11-0818"/><a class="indexterm" id="IDX-CHP-11-0819"/><a class="indexterm" id="IDX-CHP-11-0820"/><a class="indexterm" id="IDX-CHP-11-0821"/><a class="indexterm" id="IDX-CHP-11-0822"/><a class="indexterm" id="IDX-CHP-11-0823"/></p><p>Well, not quite. The software factory still throws us situations requiring high-performance code, and if you're not careful, you'll need a mad optimization dash at the last minute. But it is preferable to avoid optimizing code if at all possible. Optimization has a <span class="emphasis"><em>lot</em></span> of downsides.</p><p>There's always a price to pay for more speed. Optimizing code is the act of trading one desirable quality for another. Some aspect of the code will suffer. Done well, the (correctly identified) more desirable quality is enhanced. These trade-offs are the top reasons to avoid optimizing code:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Loss of readability</strong></span></span></dt><dd><p>It's rare for optimized code to read as clearly as its slower counterpart. By its very nature, the optimized version is not as direct an implementation of the logic or as straightforward. You sacrifice readability and neat code design for performance. Most "optimized" code is ugly and hard to follow.</p></dd><dt><span class="term"><span class="strong"><strong>Increase in complexity</strong></span></span></dt><dd><p>A more clever implementation—perhaps exploiting special backdoors (thereby increasing module coupling) or taking advantage of platform-specific knowledge—will add complexity. Complexity is the enemy of good code.<a class="indexterm" id="IDX-CHP-11-0824"/></p></dd><dt><span class="term"><span class="strong"><strong>Hard to maintain/extend</strong></span></span></dt><dd><p>As a consequence of increased complexity and a lack of readability, the code will be harder to maintain. If an algorithm is not clearly presented, the code can hide bugs more easily. Optimization is a surefire way to add subtle new faults—these will be difficult to find because the code is more contrived and harder to follow. Optimization leads to dangerous code.</p><p>It also stunts the extensibility of your code. Optimizations often come from making more assumptions, limiting generality and future growth.<a class="indexterm" id="IDX-CHP-11-0825"/></p></dd><dt><span class="term"><span class="strong"><strong>Introducing conflicts</strong></span></span></dt><dd><p>Often an optimization will be quite platform specific. It might make certain operations faster on one system, at the expense of another platform. Picking optimal data types for one processor type may lead to slower execution on others.</p></dd><dt><span class="term"><span class="strong"><strong>More effort</strong></span></span></dt><dd><p>Optimization is another job that needs to be done. We have quite enough to do already, thank you. If the code is working adequately, then we should focus our attentions on more pressing concerns.</p><p>Optimizing code takes a long time, and it's hard to target the real causes. If you optimized the wrong thing, you've wasted a lot of precious energy.</p></dd></dl></div><p>For these reasons, optimization should be quite a way down on your list of concerns. Balance the need to optimize your code against the requirement to fix faults, to add new features, or to ship a product. Often optimization is not worthwhile or is uneconomical. If you take care to write efficient code in the first place, you're less likely to need to optimize anyway.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="alternatives"/>Alternatives</h2></div></div></div><p>Often code optimization is performed when it's not actually necessary. There are a number of alternative approaches that we can employ without altering our exisiting good-quality code. Consider these solutions <span class="emphasis"><em>before</em></span> you get too focused on optimization:<a class="indexterm" id="IDX-CHP-11-0826"/><a class="indexterm" id="IDX-CHP-11-0827"/><a class="indexterm" id="IDX-CHP-11-0828"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Can you put up with this level of performance—is it really <span class="emphasis"><em>that</em></span> disastrous?</p></li><li class="listitem"><p>Run the program on a faster machine. This seems laughably obvious, but if you have enough control over the execution platform, it might be more economical to specify a faster computer than spend time tinkering with code. Given the average project duration, you are guaranteed that by the time you reach completion, processors will be considerably faster. If they're not much faster, then they'll have double the number of CPU cores embedded in the same physical space.</p><p>Not all problems can be fixed by a faster CPU, especially if the bottleneck is not execution speed—a slow storage system, for example. Sometimes a faster CPU can cause drastically <span class="emphasis"><em>worse</em></span> performance; faster execution can exacerbate thread-locking problems.</p></li><li class="listitem"><p>Look for hardware solutions: Add a dedicated floating-point unit to speed up calculations; add a bigger processor cache, more memory, a better network connection, or a wider-bandwidth disk controller.</p></li><li class="listitem"><p>Reconfigure the target platform to reduce the CPU load on it. Disable background tasks or any unnecessary pieces of hardware. Avoid processes that consume huge amounts of memory.</p></li><li class="listitem"><p>Run slow code asynchronously, in a background thread. Adding threads at the last minute is a road to disaster if you don't know what you're doing, but careful thread design can accommodate slow operations quite acceptably.<a class="indexterm" id="IDX-CHP-11-0829"/></p></li><li class="listitem"><p>Work on user interface elements that affect the user's perception of speed. Ensure that GUI buttons change immediately, even if their code takes over a second to execute. Implement a progress meter for slow tasks; a program that hangs during a long operation appears to have crashed. Visual feedback of an operation's progress conveys a better impression of the quality of performance.</p></li><li class="listitem"><p>Design the system for unattended operation so that no one notices the speed of execution. Create a batch-processing program with a neat UI that allows you to queue work.</p></li><li class="listitem"><p>Try a newer compiler with a more aggressive optimizer, or target your code for the most specific processor variant (with all extra instructions and extensions enabled) to take advantage of all performance features.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Look for alternatives to optimizing code—can you increase your program's performance in any other way?</em></span><a class="indexterm" id="IDX-CHP-11-0830"/></p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="why_optimize_question"/>Why Optimize?</h1></div></div></div><p>Having seen the dangers of code optimization, should you now give up any foolish notion of ever optimizing your code? Well, no: You should still avoid optimization wherever possible, but there are plenty of situations where optimization is important. And contrary to popular belief, some areas are <span class="emphasis"><em>guaranteed</em></span> to require optimization.<a class="indexterm" id="IDX-CHP-11-0831"/><a class="indexterm" id="IDX-CHP-11-0832"/><a class="indexterm" id="IDX-CHP-11-0833"/><a class="indexterm" id="IDX-CHP-11-0834"/><a class="indexterm" id="IDX-CHP-11-0835"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Games programming always needs well-honed code. Despite the huge advances in PC power, the market demands more realistic graphics and more impressive artificial intelligence algorithms. This can only be delivered by stretching the execution environment to its very limits. It's an incredibly challenging field of work; as each new piece of faster hardware is released, games programmers still have to wring every last drop of performance out.<a class="indexterm" id="IDX-CHP-11-0836"/></p></li><li class="listitem"><p><span class="emphasis"><em>Digital signal processing (DSP)</em></span> programming is all about high performance. Digital signal processors are dedicated devices specifically optimized to perform fast digital filtering on large amounts of data. If speed didn't matter, you wouldn't be using them. DSP programming generally relies less on an optimizing compiler, since you want to have a high degree of control over what the processor is doing at all times. DSP programmers are skilled at driving these devices at their maximum performance.</p></li><li class="listitem"><p>Resource constrained environments, such as deeply embedded platforms, can struggle to achieve reasonable performance with the available hardware. You'll have to hone the code for acceptable quality of service or work hard to fit it into the device's tight memory.</p></li><li class="listitem"><p><span class="emphasis"><em>Real-time</em></span> systems rely on timely execution, on being able to complete operations within well-specified quanta. Algorithms have to be carefully honed and proven to execute in fixed time limits.</p></li><li class="listitem"><p>Numerical programming—in the financial sector, or for scientific research—demands high performance. These huge systems are run on very large computers with dedicated numerical support, providing vector operations and parallel calculations.</p></li></ul></div><p>Perhaps optimization is not a serious consideration for general-purpose programming, but there are plenty of cases where optimization <span class="emphasis"><em>is</em></span> a crucial skill. Performance is seldom specified in a requirements document, yet the customer will complain if your program runs unacceptably slowly. If there are no alternatives, and the code doesn't perform adequately, then you have to optimize it.</p><p>There is a shorter list of reasons to optimize than not to. Unless you have a specific need to optimize, you should avoid doing so. But if you do need to optimize, make sure you know how to do it well.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Understand when you</em></span> do <span class="emphasis"><em>need to optimize code, but prefer to write efficient</em></span> high-quality <span class="emphasis"><em>code in the first place</em></span>.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_nuts_and_bolts-id1"/>The Nuts and Bolts</h1></div></div></div><p>So how do you optimize? Rather than learn a list of specific code optimizations, it's far more important to understand the correct <span class="emphasis"><em>approach</em></span> to optimizing. Don't panic; we will see some programming techniques later, but they must be read in the context of this wider optimization process.<a class="indexterm" id="IDX-CHP-11-0837"/></p><p>The six steps for speeding up a program are:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Determine that it's too slow, and prove you do need to optimize.</p></li><li class="listitem"><p>Identify the slowest code. Target this point.</p></li><li class="listitem"><p>Test the performance of the optimization target.</p></li><li class="listitem"><p>Optimize the code.</p></li><li class="listitem"><p>Test that the optimized code still works (very important).</p></li><li class="listitem"><p>Test the speed increase, and decide what to do next.</p></li></ol></div><p>This sounds like a lot of work, but without it you'll actually waste time and effort and end up with crippled code that runs no faster. If you're not trying to improve execution speed, adjust this process accordingly; for example, tackle memory consumption problems by identifying which data structures are consuming all the memory and target those.</p><p>It's important to begin optimization with a clear goal in sight—the more optimization you perform, the less readable the code becomes. Know the level of performance you require, and stop when it's sufficiently fast. It's tempting to keep going, continually trying to squeeze out a little extra performance.</p><p>To stand any chance of optimizing correctly, you must take great care to prevent external factors from changing the way your code works. When the world is changing under your feet, you can't compare measurements realistically. There are two essential techniques that help here:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Optimize your code separately from any other work, so the outcome of one task doesn't cloud the other</em></span>.</p></dd></dl></div><p>. . . and . . .</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Optimize release builds of your program, not development builds</em></span>.<a class="indexterm" id="IDX-CHP-11-0838"/></p></dd></dl></div><p>The development builds may run very differently from release builds, due to the inclusion of debugging trace information, object file symbols, and so on.</p><p>Now we'll look at each of these optimization steps in more detail.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="prove_you_need_to_optimize"/>Prove You Need to Optimize</h2></div></div></div><p>The first thing to do is make sure you really <span class="emphasis"><em>do</em></span> need to optimize. If the code's performance is acceptable, then there's no point in tinkering with it. Knuth said (himself quoting C.A.R. Hoare): "We should forget about small efficiencies, say about 97 percent of the time: Premature optimization is the root of all evil." There are so many compelling reasons <span class="emphasis"><em>not</em></span> to optimize that the quickest and safest optimization technique is to prove that you don't need to do it.</p><p>You make this decision based on program requirements or usability studies. With this information you can determine whether optimization takes priority over adding new features and fixing bugs.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="identify_the_slowest_code"/>Identify the Slowest Code</h2></div></div></div><p>This is the part that most programmers get wrong. If you're going to spend time optimizing, you need to target the places where it will make a difference. Investigations show that the average program spends more than 80 percent of its time in less than 20 percent of the code. (Boehm 87) This is known as the <span class="emphasis"><em>80/20 rule</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-1" id="CHP-11-FN-1">1</a>]</sup> That's a relatively small target that is very easy to miss, which means you might waste effort optimizing code that's rarely run.</p><p>You might notice that a part of your program has some relatively easy optimizations, but if that part is seldom executed, then there's no point in optimizing—in this situation, clear code is better than faster code.</p><p>How do you figure out where to focus your attention? The most effective technique is to use a <span class="emphasis"><em>profiler</em></span>. This tool times the flow of control around your program. It shows where that 80 percent of execution time is going, so you know where to concentrate your effort.</p><p>A profiler <span class="emphasis"><em>doesn't</em></span> tell you which parts of the code are slowest; this is a common misconception. It actually tells you where the CPU spends most of its time. This is subtly different.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-2" id="CHP-11-FN-2">2</a>]</sup> You have to interpret these results and use your brain. The program might spend most of its execution time in a few perfectly valid functions which cannot be improved at all. You can't always optimize; sometimes the laws of physics win.</p><p>There are plenty of benchmarking programs around—many excellent commercial programs and a number of freely available tools. It's worth spending money on a decent profiler: Optimization can easily eat into your time; this is also an expensive commodity. If you don't have a profiler available, there are a few other timing techniques you can try:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Put manual timing tests throughout your code. Make sure you use an accurate clock source and that the time taken to read the clock will not affect program performance too much.</p></li><li class="listitem"><p>Count how often each function is called (some debug libraries provide support for this kind of activity).</p></li><li class="listitem"><p>Exploit compiler-supplied hooks to insert your own accounting code when each function is entered or exited. Many compilers provide a means to do this; some profilers are implemented using such a mechanism.<a class="indexterm" id="IDX-CHP-11-0842"/></p></li><li class="listitem"><p>Sample the program counter; interrupt your program periodically in a debugger to see where control is. This is harder in multithreaded programs and is a very slow, manual approach. If you have control over the execution environment, you can write scaffolding to automate this kind of test—effectively writing your own form of profiler.</p></li><li class="listitem"><p>Test an individual function's impact on the total program execution time by making it slower. If you suspect that a particular function is causing a slowdown, try replacing its call with two calls in succession, and measure how it affects execution time.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-3" id="CHP-11-FN-3">3</a>]</sup> If the program takes 10 percent longer to run, then the function consumes approximately 10 percent of execution time. Use this as a very basic timing test.</p></li></ul></div><p>When profiling, make sure that you use realistic input data, simulating Real World events. The way your code executes may be drastically affected by the kind of input you feed it or by the way it is driven, so make sure that you provide true representative input sets. If possible, capture a set of real input data from a live system.</p><p>Try profiling several different data sets, to see what difference this makes. Select a very basic set, a heavy use set, and a number of general use sets. This will prevent you from optimizing for the particular quirks of one input data set.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Select profiling test data carefully to represent Real World program use. Otherwise, you might optimize parts of the program that are not normally run</em></span>.</p></dd></dl></div><p>While a profiler (or equivalent) is a good starting point to choose optimization targets, you can easily miss quite fundamental problems. The profiler only shows how the code in the current design executes—and encourages you to perform code-level improvement only. Look at larger design issues too. The lack of performance may not be due to a single function, but rather a more pervasive design flaw. If it is, then you'll have to work harder to remedy the problem. This shows how important it is to get the initial code design right, with knowledge of established performance requirements.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Don't rely solely on a profiler to find the causes of program inefficiency; you might miss important problems</em></span>.</p></dd></dl></div><p>Having completed this step, you've found the areas of your code where a performance improvement will have the most benefit. Now it's time to attack them.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="testing_the_code"/>Testing the Code</h2></div></div></div><p>We recognized three testing phases in the optimization procedure. For each piece of code targeted, we test its performance before optimization, confirm that the code still works correctly once optimized, and test its performance after optimization.<a class="indexterm" id="IDX-CHP-11-0843"/></p><p>Programmers often forget the second check: that the optimized code still works correctly in <span class="emphasis"><em>all</em></span> possible situations. It's easy to check the normal mode of operation, but it's not in our nature to test each and every rare case. This can be the cause of weird bugs late in the day, so be very rigorous about this.</p><p>You <span class="emphasis"><em>must</em></span> measure the code's performance before and after modification to make sure that you have made a real difference—and to make sure that it is a change for the better; sometimes an "optimization" can be an unwitting <span class="emphasis"><em>pessimization</em></span>. You can perform these timing tests with your profiler or by inserting timing instrumentation by hand.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p>Never <span class="emphasis"><em>try to optimize code without performing some kind of before and after measurement</em></span>.</p></dd></dl></div><p>These are some very important things to think about when running your timing tests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Run both the before and after tests with exactly the same set of input data so that you're testing exactly the same thing. Otherwise, your tests are meaningless; you're not comparing apples to apples. An automated test suite is best (see "<a class="xref" href="ch08s07.html" title="Look! No Hands!">Look! No Hands!</a>" on page 144)—with the same kind of live representative data we used in the profiling step.</p></li><li class="listitem"><p>Run all tests under identical prevailing conditions, so that factors like the CPU load or amount of free memory don't affect your measurements.</p></li><li class="listitem"><p>Ensure that your tests don't rely on user input. Humans can cause timings to fluctuate wildly. Automate every possible aspect of the test procedure.</p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_the_code"/>Optimizing the Code</h2></div></div></div><p>We'll investigate some specific optimization techniques later. Speed-ups vary from the simple refactoring of small sections of code to more serious design-level alterations. The trick is to optimize without totally destroying the code.<a class="indexterm" id="IDX-CHP-11-0844"/></p><p>Determine how many different ways exist to optimize the identified code, and pick the best. Only perform one change at a time; it's less risky, and you'll have a better idea of what improved performance the most. Sometimes it's the least expected things that have the most significant optimization effects.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="after_optimization"/>After Optimization</h2></div></div></div><p>Don't forget to benchmark the optimized code to prove that you've made a successful modification. If an optimization is unsuccessful, remove it. Back out your changes. This is where a source control system is useful, helping you to revert to the previous code version.</p><p>Also remove the <span class="emphasis"><em>slightly</em></span> successful optimizations. Prefer clear code to modest optimizations (unless you're absolutely desperate for an improvement, and there are no other avenues to explore).</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-1" id="ftn.CHP-11-FN-1">1</a>] </sup>Some go so far as to claim this should be the <span class="emphasis"><em>90/10 rule</em></span>.<a class="indexterm" id="IDX-CHP-11-0841"/><a class="indexterm" id="IDX-CHP-11-0839"/><a class="indexterm" id="IDX-CHP-11-0840"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-2" id="ftn.CHP-11-FN-2">2</a>] </sup>All code runs at a fixed rate, based on the speed of the CPU clock, the number of other processes being juggled by the OS, and the thread's priority.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-3" id="ftn.CHP-11-FN-3">3</a>] </sup>This won't <span class="emphasis"><em>necessarily</em></span> make the function run twice as slowly. Filesystem buffers or CPU memory caches can enhance the performance of repeated code sections. Treat this as a very rough guide—more qualitative than quantitative.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="optimization_techniques"/>Optimization Techniques</h1></div></div></div><p>We've avoided this for long enough; now it's time to look at the really gory details. Having followed the optimization procedure outlined above, you've proved that your program performs badly and have found the worst code culprit. Now you need to whip it into shape. What can you do?<a class="indexterm" id="IDX-CHP-11-0845"/><a class="indexterm" id="IDX-CHP-11-0846"/><a class="indexterm" id="IDX-CHP-11-0847"/></p><p>There's a palette of optimizations to choose from. Which is the most appropriate will depend on the exact cause of the problem, what you're trying to achieve (e.g., increased execution speed or reduced code size), and how much of an improvement is required.</p><p>These optimizations fall into two broad categories: <span class="emphasis"><em>design</em></span> changes and <span class="emphasis"><em>code</em></span> changes. A change at the design level will usually have a more profound effect on performance than a code-level tweak. An inefficient design can strangle efficiency more than a few bad lines of source code, so a design fix—while more difficult—will have a bigger payoff.</p><p>Most often, our goal is to increase execution speed. The speed-based optimization strategies are to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Speed up slow things</p></li><li class="listitem"><p>Do slow things less often</p></li><li class="listitem"><p>Defer slow things until you really need them</p></li></ul></div><p>The other common optimization goals are to reduce memory consumption (mainly by changing the data representation, by tweaking the pattern of memory consumption, or by reducing the amount of data accessed at once), or to reduce executable size (by removing functionality or by exploiting commonality). As we'll see, these goals often conflict: Most speed increases come at the expense of memory consumption, and vice versa.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="design_changes"/>Design Changes</h2></div></div></div><p>These are the <span class="emphasis"><em>macro</em></span> optimizations, the fixes on a large scale that improve the internal design of your software. Bad design is hard to fix. The nearer a project is to a release deadline, the less likely you are to perform design changes; the risk is too great.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-4" id="CHP-11-FN-4">4</a>]</sup> We end up plastering over the cracks by employing small, code-level fixes instead.</p><p>When brave enough, the kinds of design optimization we can perform include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Adding layers of caching or buffering to enhance slow data access or prevent lengthy recalculations. Precompute values that you know will be needed, and store them for immediate access.</p></li><li class="listitem"><p>Creating a pool of resources to reduce the overhead of allocating objects. For example, preallocate memory, or hold a selection of files open rather than repeatedly opening and then closing them. This technique is often used to speed up memory allocation; older OS memory allocation routines were designed for simple non-threaded use. Their locks stall multithreaded applications, leading to horrible performance.<a class="indexterm" id="IDX-CHP-11-0852"/></p></li><li class="listitem"><p>Sacrificing accuracy for speed if you can get away with it. Dropping floating-point precision is the obvious example. Many devices have no <span class="emphasis"><em>floating-point unit (FPU)</em></span> hardware and employ slower FPU emulation software instead. You can switch to fixed-point arithmetic libraries to bypass a slow emulator, at the expense of numeric resolution. This is particularly easy in C++ by taking advantage of its abstract data type facilities.<a class="indexterm" id="IDX-CHP-11-0853"/></p><p>Accuracy is not solely due to your choice of data types; this tactic can run far deeper to your use of algorithms or the quality of your output. Perhaps you can let users make this decision—allow them to select <span class="emphasis"><em>slow but accurate</em></span> or <span class="emphasis"><em>fast but approximate</em></span> operation modes.</p></li><li class="listitem"><p>Changing the data storage format or its on-disk representation to something more suited to high-speed operation. For example, speed up text file parsing by using a binary format. Transmit or store compressed files to reduce network bandwidth.</p></li><li class="listitem"><p>Exploiting parallelization and using threading to prevent one action from being serialized after another. As advances in processor speeds tail off, CPU manufacturers are increasingly introducing multi-core, multi-pipeline processors. To use these effectively, your code <span class="emphasis"><em>must</em></span> be designed with a threaded model at its heart. The front line of the optimization battle is rapidly moving in this direction.</p></li><li class="listitem"><p>Threading efficiently: Avoiding or removing excessive locking. It inhibits concurrency, generates overhead, and often leads to deadlock. Employ static checking to prove which locks are necessary and which aren't.<a class="indexterm" id="IDX-CHP-11-0854"/></p></li><li class="listitem"><p>Avoiding overuse of exceptions. They can inhibit compiler optimizations<sup>[<a class="footnote" href="#ftn.CHP-11-FN-5" id="CHP-11-FN-5">5</a>]</sup> and will hamper timely operation when used too frequently.</p></li><li class="listitem"><p>Forgoing certain language facilities if it will save code space. Some C++ compilers allow you to disable RTTI and exceptions, consequently reducing executable size.<a class="indexterm" id="IDX-CHP-11-0856"/></p></li><li class="listitem"><p>Removing functionality: The quickest code is code that doesn't run at all. A function will be slow if it is doing too many things, some of which are unnecessary. Cut out the superfluous stuff. Move it elsewhere in the program. Defer all work until it's really necessary.</p></li><li class="listitem"><p>Compromising design quality to gain speed. For example, reducing indirection and increasing coupling. You can do this by breaking encapsulation: leaking a class's private implementation through its public interface. Knocking down module barriers will cause irreparable damage to the design. If possible, try a less disruptive optimization mechanism first.<a class="indexterm" id="IDX-CHP-11-0857"/><a class="indexterm" id="IDX-CHP-11-0858"/><a class="indexterm" id="IDX-CHP-11-0859"/></p></li></ul></div><div class="sidebar"><a id="complexity_notation"/><p class="title"><b>COMPLEXITY NOTATION</b></p><p><span class="emphasis"><em>Algorithmic complexity</em></span> is a measure of how well an algorithm scales—how long it takes in proportion to the size of input. It's a <span class="emphasis"><em>qualitative</em></span> mathematical model, allowing you to quickly compare the performance characteristics of different implementation approaches. It doesn't measure exact execution time (this is highly dependent on CPU speed, OS configuration, etc.).<a class="indexterm" id="IDX-CHP-11-0860"/><a class="indexterm" id="IDX-CHP-11-0861"/></p><p>Complexity is determined by the amount of work an algorithm must perform: the number of basic operations it executes. A basic operation is something like an arithmetic operation, an assignment, a test, or a data read/write. Algorithmic complexity doesn't count the exact number of operations performed, just how this value relates to the problem size. We are usually interested in the worst case performance of an algorithm, the most work that will ever need to be done. A good comparison looks at the best case and average time complexity as well.</p><p>Algorithmic complexity is expressed using <span class="emphasis"><em>Big O</em></span> notation, invented by the German number theorist Edmund Landau. For a problem with input size <span class="emphasis"><em>n</em></span>, it might have a complexity of:<a class="indexterm" id="IDX-CHP-11-0862"/></p><div class="variablelist"><dl><dt><span class="term"><code class="literal">O(1)</code><span class="strong"><strong>: Order 1</strong></span></span></dt><dd><p>This is a <span class="emphasis"><em>constant time</em></span> algorithm. No matter how large the input set, it always takes the same amount of time to complete the task. This is the best performance characteristic possible.</p></dd><dt><span class="term"><code class="literal">O(n)</code><span class="strong"><strong>: Order n</strong></span></span></dt><dd><p>A <span class="emphasis"><em>linear time</em></span> algorithm's complexity rises in line with the input size. Searching a linked list will involve visiting more nodes as the list size grows; the number of operations is directly related to the size of the list.<a class="indexterm" id="IDX-CHP-11-0863"/></p></dd><dt><span class="term"><code class="literal">O(n2)</code><span class="strong"><strong>: Order n squared</strong></span></span></dt><dd><p>This is where performance really begins to get bad: Complexity is increasing faster than the rate of input growth. A <span class="emphasis"><em>quadratic time</em></span> algorithm may seem fine when you give it a small set of data, but large data sets take a seriously long time. The bubblesort algorithm is <code class="literal">O(n2)</code>.<a class="indexterm" id="IDX-CHP-11-0864"/><a class="indexterm" id="IDX-CHP-11-0865"/></p></dd></dl></div><p>Of course, complexity may be of any order; the quicksort algorithm averages <code class="literal">O(n log n)</code>. This is worse than <code class="literal">O(n)</code>, but far better than <code class="literal">O(n2)</code>. A simple optimization route for a slow bubblesort algorithm is to replace it with a quicksort algorithm, especially since there are plenty of freely available quicksort implementations.<a class="indexterm" id="IDX-CHP-11-0866"/></p><p>These Big O expressions don't include constants or low-order terms. You'll rarely see any talk about a complexity of <code class="literal">O(2n+6)</code>. When n gets large enough, these constants and low-order terms dwarf into insignificance.</p></div><p>The major design-level optimizations involve improvements in <span class="emphasis"><em>algorithms</em></span> or <span class="emphasis"><em>data structures</em></span>. Most speed degradation or memory consumption comes down to a bad choice of one or both, and a subsequent change will rectify this.<a class="indexterm" id="IDX-CHP-11-0867"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Algorithms</strong></span></span></dt><dd><p>Algorithms have a profound impact on the speed of execution. A function that works acceptably in a small local test may not scale up when Real World data gets thrown at it. If profiling shows that your code spends most of its time running a certain routine, you must make it run faster. One approach is at the code level, chipping small improvements from each instruction. A better approach is to replace the entire algorithm with a more efficient version.</p></dd></dl></div><p>Consider this realistic example: A particular algorithm runs a loop 1,000 times. Each iteration takes 5 milliseconds (ms) to execute. The operation therefore completes in around 5 seconds. By tweaking the code inside the loop, you can shave 1 ms from each iteration—that's a saving of 1 second. Not bad. But instead, you can plug in a different algorithm, where an iteration takes 7 ms, although it only iterates 100 times. That's a saving of almost 4 and a half seconds—significantly better.</p><p>For this reason, prefer to look at optimizations that change fundamental algorithms, not that tweak specific lines of code. There are many algorithms to chose from in the computer science world, and unless your code is particularly dire, you'll always gain the most significant performance improvements by selecting a better algorithm.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Prefer to replace a slow algorithm with a faster variant than to tinker with the algorithm's implementation</em></span>.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Data structures</strong></span></span></dt><dd><p>Data structures are intimately related to your choice of algorithms; some algorithms require certain data structures, and vice versa. If your program is consuming far too much memory, changing the data storage format may improve matters, although often at the expense of execution speed. If you need to quickly search a list of 1,000 items, don't store them in a linear array with <code class="literal">O(</code> <em class="replaceable"><code>n</code></em><code class="literal">)</code> search time; use a (larger) binary tree with <code class="literal">O(log</code> <em class="replaceable"><code>n</code></em><code class="literal">)</code> performance.<a class="indexterm" id="IDX-CHP-11-0868"/></p><p>Selecting a different data structure seldom requires you to implement the new representation yourself. Most languages come with library support for all common data structures.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="code_changes"/>Code Changes</h2></div></div></div><p>And so now we creep anxiously on to the really disgusting stuff: the <span class="emphasis"><em>micro</em></span>-level, small-scale, shortsighted, code-tweaking optimizations. There are many ways to molest source code for the sake of performance. You must experiment to see what works best in each situation: Some changes will work well; others will have little, or even negative effect. Some may prevent the compiler's optimizer from performing its task, producing startlingly worse results.<a class="indexterm" id="IDX-CHP-11-0869"/><a class="indexterm" id="IDX-CHP-11-0870"/><a class="indexterm" id="IDX-CHP-11-0871"/><a class="indexterm" id="IDX-CHP-11-0872"/><a class="indexterm" id="IDX-CHP-11-0873"/><a class="indexterm" id="IDX-CHP-11-0874"/><a class="indexterm" id="IDX-CHP-11-0875"/><a class="indexterm" id="IDX-CHP-11-0876"/><a class="indexterm" id="IDX-CHP-11-0877"/><a class="indexterm" id="IDX-CHP-11-0878"/><a class="indexterm" id="IDX-CHP-11-0879"/><a class="indexterm" id="IDX-CHP-11-0880"/></p><p>The first task is easy: Turn on compiler optimization or increase the optimization level. It often gets disabled for development builds since the optimizer can take a very long time to run, increasing the build time of large projects by an order of magnitude.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-6" id="CHP-11-FN-6">6</a>]</sup> Try configuring the optimizer, and test what affect this has. Many compilers allow you to bias optimization toward extra speed or reduced code size.</p><p>There are a few very low-level optimizations that you should know about but should generally avoid. These are the kind of changes that a compiler is able to perform for you. If you've switched the optimizer on, it'll be looking in these areas already—enable optimization and make the most of its help. You will rarely need to apply these by hand, which is good: They butcher your code's readability, since they warp its fundamental logic out of shape. Only consider using one of these optimizations if you can <span class="emphasis"><em>prove</em></span> that it's really required, that your optimizer hasn't already done it, and that there are no better alternatives.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Loop unrolling</strong></span></span></dt><dd><p>For loops with very short bodies, the loop scaffolding may be more expensive than the looped operation itself. Remove this overhead by flattening it out—turn your 10-iteration loop into 10 consecutive individual statements.<a class="indexterm" id="IDX-CHP-11-0881"/></p><p>Loop unrolling can be done partially; this makes more sense for large loops. You can insert four operations per iteration, and increment the loop counter by four each time. But this tactic gets nasty if the loop doesn't always iterate over a whole number of unrolls.</p></dd><dt><span class="term"><span class="strong"><strong>Code inlining</strong></span></span></dt><dd><p>For small operations, the overhead of calling a function might be prohibitive. Splitting code into functions brings significant benefits: clearer code, consistency through reuse, and the ability to isolate areas of change. However, this can be removed to increase performance, by merging the caller(s) and the callee.</p><p>There are a number of ways to do this. With language support, you can request it in the source code (in C/C++ using the <code class="literal">inline</code> keyword); this method preserves a lot of the code's readability. Otherwise, you have to merge the code yourself, either by duplicating the function over and over again or using a preprocessor to do the work for you.<a class="indexterm" id="IDX-CHP-11-0882"/><a class="indexterm" id="IDX-CHP-11-0883"/></p><p>It's hard to inline recursive function calls—how would you know when to stop inlining? Try to find alternative algorithms to replace recursion.<a class="indexterm" id="IDX-CHP-11-0884"/></p><p>Inlining often opens the way for further code-level optimizations (that were not previously possible across a function boundary) to be performed.</p></dd><dt><span class="term"><span class="strong"><strong>Constant folding</strong></span></span></dt><dd><p>Calculations involving constant values can be computed at compile time to reduce the amount of work done at run time. The simple expression <code class="literal">return 6+4;</code> can be reduced to <code class="literal">return 10;</code>. Carefully ordering the terms of a large calculation might bring two constants together, enabling them to be reduced into a simpler subexpression.<a class="indexterm" id="IDX-CHP-11-0885"/></p><p>It's unusual for a programmer to write something as obvious as <code class="literal">return 6+4;</code>. However, these sorts of expressions are common after macro expansion.</p></dd><dt><span class="term"><span class="strong"><strong>Move to compile time</strong></span></span></dt><dd><p>There is more you can do at compile time than just constant folding. Many conditional tests can be proved statically and removed from the code. Some kinds of tests can be avoided altogether; for example, remove tests for negative numbers by using unsigned data types.</p></dd><dt><span class="term"><span class="strong"><strong>Strength reduction</strong></span></span></dt><dd><p>This is the act of replacing one operation with an equivalent that executes faster. This is most important on CPUs with poor arithmetic support. For example, replace integer multiplication and division with constant shifts or adds; <code class="literal">x/4</code> can be converted to <code class="literal">x&gt;&gt;2</code> if it's faster on your processor.</p></dd><dt><span class="term"><span class="strong"><strong>Subexpressions</strong></span></span></dt><dd><p><span class="emphasis"><em>Common subexpression elimination</em></span> avoids the recalculation of expressions whose values have not changed. In code like this:</p><a id="I_programlisting5_d1e16427"/><pre class="programlisting">
int first  = (a * b) + 10;
int second = (a * b) / c;
</pre><p>the expression <code class="literal">(a * b)</code> is evaluated twice. Once is enough. You can factor out the common subexpression, and replace it with</p><a id="I_programlisting5_d1e16434"/><pre class="programlisting">
<strong class="userinput"><code>int temp   = a * b;</code></strong>
int first  = <strong class="userinput"><code>temp</code></strong> + 10;
int second = <strong class="userinput"><code>temp</code></strong> / c;
</pre></dd><dt><span class="term"><span class="strong"><strong>Dead code elimination</strong></span></span></dt><dd><p>Don't write needless code; prune anything that's not strictly necessary to the program. Static analysis will show you the functions that are never used or the sections of code that will never execute. Remove them.</p></dd></dl></div><p>While those are particularly distasteful code optimizations, the following ones are slightly more socially acceptable. They focus on increasing program execution speed.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If you find that you're repeatedly calling a slow function, then don't call it so often. Cache its result and reuse this value. This might lead to less clear code, but the program will run faster.</p></li><li class="listitem"><p>Reimplement the function in another language. For example, rewrite a critical Java function in C using the Java Native Interface ( JNI) facility. Conventional compilers still beat JIT code interpreters for execution speed.</p><p>Don't naïvely assume that one language is faster than another—many programmers have been surprised by how little difference using JNI makes. It has been commonly claimed that OO languages are far slower than their procedural counterparts. This is a lie. Bad OO code <span class="emphasis"><em>can</em></span> be slow, but so can bad procedural code. If you write OO-style code in C, it is likely to be <span class="emphasis"><em>slower</em></span> than good C++; the C++ compiler will generate better-tuned method dispatch code than your attempts.</p></li><li class="listitem"><p>Reorder the code for improved performance.</p><p><span class="strong"><strong>Defer work until it's absolutely necessary</strong></span>. Don't open a file until you're about to use it. Don't calculate a value if you might not need it; wait until it's wanted. Don't call a function yet if the code will work without it.</p><p><span class="strong"><strong>Hoist checking further up the function to avoid needless work</strong></span>. If a test leading to an early return can be placed at the top of a function or halfway though it, prefer to place it at the top. Make the check sooner to avoid delays.</p><p><span class="strong"><strong>Move invariant calculations out of a loop</strong></span>. The most subtle source of this problem is a loop condition. If you write <code class="literal">for (int n = 0; n &lt; tree.appleCount(); ++n)</code>, but <code class="literal">appleCount()</code> manually counts 1,000 items on every call, you'll have a very slow loop. Move the count operation before the loop:</p><a id="I_programlisting5_d1e16490"/><pre class="programlisting">
<strong class="userinput"><code>int appleCount</code></strong> = <strong class="userinput"><code>tree.appleCount();</code></strong>
for (int n = 0; n &lt; <strong class="userinput"><code>appleCount;</code></strong> ++n)
{
    ... do something ...
}
</pre><p>However, don't forget to profile first to prove that the loop truly is a problem. This is a great example of how optimizations are local to a particular execution environment: In C#, the new version could well be <span class="emphasis"><em>slower</em></span> because the unoptimized code is a pattern the JIT compiler understands and can optimize away itself.</p></li><li class="listitem"><p>Use <span class="emphasis"><em>lookup tables</em></span> for complex calculations, trading time for space. For example, rather than write a set of trigonometric functions that individually calculate their values, precalculate the return values and store them in an array. Map input values to the closest index into this array.<a class="indexterm" id="IDX-CHP-11-0886"/></p></li><li class="listitem"><p>Exploit <span class="emphasis"><em>short-circuit evaluation</em></span>. Make sure that the tests likely to fail are placed first to save time. If you write a conditional expression <code class="literal">if (condition_one &amp;&amp; condition_two)</code>, make sure that <code class="literal">condition_one</code> is statistically more likely to fail than <code class="literal">condition_two</code> (unless, of course, <code class="literal">condition_one</code> acts as a guard for <code class="literal">condition_two</code>'s validity).</p></li><li class="listitem"><p>Don't reinvent the wheel—reuse standard routines that have already been performance tuned. Library writers will have already carefully honed their code. But be aware that a library may have been optimized for different goals than yours; perhaps an embedded product was profiled for memory consumption, not for speed.</p></li></ul></div><p>Size-focused, code-level optimizations include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Producing compressed executables that unpack their code before running. This doesn't necessarily affect the size of the running program, but it reduces the storage space required.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-7" id="CHP-11-FN-7">7</a>]</sup> This might be important if your program is stored in limited flash memory.</p></li><li class="listitem"><p>Factoring common code into a shared function to avoid duplication.</p></li><li class="listitem"><p>Moving seldom-used functions out of the way. Put them into a dynamically loaded library or into a separate program.</p></li></ul></div><p>Of course, the ultimate hard-core optimization technique is to reimplement a section of code in assembly—the one environment where you have <span class="emphasis"><em>full</em></span> control over the CPU and can do exactly what you want (including shooting yourself in the foot). This is always a last resort and is almost certainly unnecessary. These days, compilers produce perfectly acceptable code, and the lost time spent writing, debugging, and maintaining "optimized" sections of machine code far outweighs the advantages gained.<a class="indexterm" id="IDX-CHP-11-0887"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-4" id="ftn.CHP-11-FN-4">4</a>] </sup>Sadly, it's often only near project deadlines that anyone notices that performance isn't good enough.<a class="indexterm" id="IDX-CHP-11-0848"/><a class="indexterm" id="IDX-CHP-11-0849"/><a class="indexterm" id="IDX-CHP-11-0850"/><a class="indexterm" id="IDX-CHP-11-0851"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-5" id="ftn.CHP-11-FN-5">5</a>] </sup>Like functions, <code class="literal">try/catch</code> blocks act as barriers to an optimizer. It's not possible to look through the barrier to perform optimization, so some potential speed-ups will be lost.<a class="indexterm" id="IDX-CHP-11-0855"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-6" id="ftn.CHP-11-FN-6">6</a>] </sup>It has to do complex inspection of the parsed code to determine the set of possible speed-ups and select the most appropriate ones.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-7" id="ftn.CHP-11-FN-7">7</a>] </sup>This may have the pleasant side effect of decreasing program startup time: A compressed executable will load from disk much faster.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="writing_efficient_code"/>Writing Efficient Code</h1></div></div></div><p>If the best approach is <span class="emphasis"><em>not</em></span> to optimize, how can we avoid any need to improve code performance? The answer is to <span class="emphasis"><em>design for performance</em></span>, planning to provide adequate quality of service from the outset, rather than trying to whittle it out at the last minute.<a class="indexterm" id="IDX-CHP-11-0893"/><a class="indexterm" id="IDX-CHP-11-0888"/><a class="indexterm" id="IDX-CHP-11-0889"/><a class="indexterm" id="IDX-CHP-11-0890"/><a class="indexterm" id="IDX-CHP-11-0891"/><a class="indexterm" id="IDX-CHP-11-0892"/></p><p>Some argue that this is a dangerous road to follow. Indeed, there are potential hazards for the unwary. If you try to optimize as you go along, then you'll write at a lower level than needed; you'll end up with nasty, hacky code full of low-level performance enhancements and back-door interfaces.</p><p>How do we reconcile these seemingly opposing views? It isn't hard, because they're not actually at odds. There are two complementary strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Write efficient code.</p></li><li class="listitem"><p>Optimize code later.</p></li></ul></div><p>If you make a point of writing clear, good, efficient code <span class="emphasis"><em>now</em></span>, you will not need to perform heavy optimizations later. Some claim that you don't know whether any optimization is necessary at first, so you should write everything <span class="emphasis"><em>as simply as possible</em></span>, and only optimize when profiling proves that there is a bottleneck.</p><p>This approach has obvious flaws. If you know that you need a data structure with good search performance (because your program must perform fast searches), pick a binary tree over an array.<sup>[<a class="footnote" href="#ftn.CHP-11-FN-8" id="CHP-11-FN-8">8</a>]</sup> If you're not aware of any such requirement, <span class="emphasis"><em>then</em></span> go for the most appropriate thing that will work. This still might not be the simplest—a raw C array is a hard data structure to manage.</p><p>As you design each module, don't blindly chase performance—only spend the effort when necessary. Understand the mandated performance requirements and justify how your choices will meet these requirements at each stage. When you know what level of performance is required, it's easier to design for appropriate efficiency. It also helps you to write explicit tests that prove you do achieve these performance goals.</p><p>Some simple design choices that will increase efficiency and aid later optimization are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Minimizing your reliance on functions that might be implemented on remote machines or that will access the network or a slow data storage system</p></li><li class="listitem"><p>Understanding the target deployment and how the program is expected to be run so you can design it to work well in these situations</p></li><li class="listitem"><p>Writing <span class="emphasis"><em>modular</em></span> code so it's easy to speed up one section without having to rewrite other sections too</p></li></ul></div><div class="sidebar"><a id="pessimizations"/><p class="title"><b>PESSIMIZATIONS</b></p><p>Without careful measurement, you can easily end up writing optimizations that are not at all optimal. A perfectly good optimization for one situation might turn out to be a performance disaster in another. Here's a case study. Exhibit A: The copy-onwrite string optimization.<a class="indexterm" id="IDX-CHP-11-0894"/></p><p>This was a common optimization applied to C++ standard library implementations around 1990. Programs that performed intensive string manipulation experienced a massive overhead when copying long strings, both in terms of execution speed and memory consumption. Copying large strings means duplicating and shoveling around large quantities of data. Many string copies are automatically generated, temporary objects that are created and then thrown away shortly after—they are never actually modified. The expensive copy operation is an unnecessary cost.</p><p>The copy-on-write (COW) optimization turns the <code class="literal">string</code> data type into a form of <span class="emphasis"><em>smart pointer</em></span>; the actual string data is held in a (hidden) shared representation. The <code class="literal">string</code> copy operation now only has to perform an inexpensive smart pointer copy (attaching a new smart pointer to the shared representation), rather than duplicate the entire string contents. Only when you make a modification to a shared string is the internal representation copied and the smart pointer remapped. This optimization avoids a large number of unnecessary copy operations.<a class="indexterm" id="IDX-CHP-11-0895"/></p><p>COW worked well in single-threaded programs; it was shown to greatly speed up performance. However, a problem became apparent when multithreaded programs used COW strings. (Indeed, this problem also manifests in single-threaded programs if the COW string class is built with multithreading support). The implementation requires very conservative thread locking around the copy operations— these locks become a <span class="emphasis"><em>major</em></span> bottleneck. Suddenly, a lightning-fast program slowed down to a crawl. The COW optimization proved to be a serious pessimization.</p><p>Far better multithreaded performance was achieved by reverting to classic <code class="literal">string</code> implementations and writing more careful code that reduced automatic string copying. Thankfully, C++ library vendors now provide more intelligent versions of the <code class="literal">string</code> class, which are both thread safe and fast.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-8" id="ftn.CHP-11-FN-8">8</a>] </sup>But, as always, it's not necessarily that simple. Arrays often provide better cache coherence (since binary tree nodes can easily become scattered across memory). An array that is kept sorted (you amortize time when inserting) would be a worthy consideration. Measure, measure, measure.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id10"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Technological progress has merely provided us with more efficient means for going backwards.</p><div class="attribution"><span>--<span class="attribution">Aldous Huxley</span></span></div></div><p>High-performance code is not as important as some people think. Although you sometimes <span class="emphasis"><em>do</em></span> have to roll your sleeves up and tinker with code, optimization is a task you should actively avoid. To do this, make sure that you know the software's performance requirements before you start working on it. At each level of design, ensure that you provide this quality of service. Then optimization will be unnecessary.<a class="indexterm" id="IDX-CHP-11-0896"/></p><p>When you do optimize, be very methodical and measured in your approach. Have a clear goal, and prove that each step is getting you closer to it. Be guided by solid data, not your hunches. As you write code, ensure that your designs are efficient, but don't compromise on quality. Worry about code-level performance only when it proves to be a problem.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid optimizing unless it proves to be absolutely necessary</p></li><li class="listitem"><p>Attempt optimization methodically, taking a considered and measured approach</p></li><li class="listitem"><p><span class="emphasis"><em>Look for alternatives and investigate design improvements before ever resorting to code-level optimizations</em></span></p></li><li class="listitem"><p>Prefer optimizations that won't destroy the code's quality</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Start optimizing before the code proves to be inadequate</p></li><li class="listitem"><p>Dive in feet first, attacking the pieces of code they think are bottlenecks without measuring or investigating</p></li><li class="listitem"><p>Never consider the wider picture: what the full implications of their optimization are in other code areas and usage patterns</p></li><li class="listitem"><p>Think speed is more important than code quality</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id10"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch01.html" title="Chapter 1. ON THE DEFENSIVE">Chapter 1</a></span></dt><dd><p>Optimizations that remove "unnecessary" code often clash with any extra defensive code.</p></dd><dt><span class="term"><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></span></dt><dd><p>The needs of optimized code are often at odds with self-documenting code.</p></dd><dt><span class="term"><a class="xref" href="ch13.html" title="Chapter 13. GRAND DESIGNS">Chapter 13</a></span></dt><dd><p>Efficiency must be <span class="emphasis"><em>designed</em></span> into the codebase from the start of a project.</p></dd><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>Performance requirements must be carefully specified before construction begins so you know how much optimization is necessary.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e16780"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207478.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id11"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 510.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id10"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Optimization is a process of making trade-offs—sacrificing one quality of code for another desirable quality. Describe the kinds of trade-offs that lead to a performance increase.</p></li><li class="listitem"><p>Look at each of the optimization alternatives listed in "<a class="xref" href="ch11s03.html" title="Why Not Optimize?">Why Not Optimize?</a>" on page 202. Describe what trade-offs are being made, if any.</p></li><li class="listitem"><p>Explain these terms and their exact relationship:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Performance</p></li><li class="listitem"><p>Efficiency</p></li><li class="listitem"><p>Optimized</p></li></ul></div></li><li class="listitem"><p>What are the likely bottlenecks in a slow program?</p></li><li class="listitem"><p>How can you avoid the need to optimize? What methods will prevent you from writing inefficient code?</p></li><li class="listitem"><p>How does the presence of multiple threads affect optimization?</p></li><li class="listitem"><p>Why <span class="emphasis"><em>don't</em></span> we write efficient code? What stops us from using high-performance algorithms in the first place?</p></li><li class="listitem"><p>A <code class="literal">List</code> data type is implemented using an array. What is the worst case algorithmic complexity of each of the following <code class="literal">List</code> methods?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The constructor</p></li><li class="listitem"><p><code class="literal">append</code>—places a new item on the end of the list</p></li><li class="listitem"><p><code class="literal">insert</code>—slides a new item in between two existing list items, at a given position</p></li><li class="listitem"><p><code class="literal">isEmpty</code>—returns <code class="literal">true</code> if the list contains no items</p></li><li class="listitem"><p><code class="literal">contains</code>—returns <code class="literal">true</code> if the list contains a specified item</p></li><li class="listitem"><p><code class="literal">get</code>—returns the item with a given index</p></li></ol></div></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id10"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How important (honestly) is code performance in your current project? What is the motivator for this performance requirement?<a class="indexterm" id="IDX-CHP-11-0897"/></p></li><li class="listitem"><p>In your last optimization attempt:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Did you use a profiler?</p></li><li class="listitem"><p>If yes, how much improvement did you measure?</p></li><li class="listitem"><p>If no, how did you know whether you made any kind of improvement?</p></li><li class="listitem"><p>Did you test that the code still worked after optimizing?</p></li><li class="listitem"><p>If yes, how thoroughly did you test?</p></li><li class="listitem"><p>If no, why not? How could you be sure the code still worked properly for <span class="emphasis"><em>all</em></span> cases?</p></li></ol></div></li><li class="listitem"><p>If you've not yet attempted to optimize the code you're currently working on, take a guess at which parts are the slowest and which bits consume the most memory. Now run it through a profiler—how accurate were you?</p></li><li class="listitem"><p>How well specified are your program's performance requirements? Do you have a concrete plan to test that you meet these criteria?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="an_insecurity_complex"/>Chapter 12. AN INSECURITY COMPLEX</h1></div><div><h3 class="subtitle"><i>Writing Secure Programs</i></h3></div></div></div><div class="epigraph"><p>Security is mostly a superstition. It does not exist in nature. . . . Life is either a daring adventure or nothing.</p><div class="attribution"><span>--<span class="attribution">Helen Keller</span></span></div></div><p>Not so long ago, computer access was a scarce commodity. The world contained only a handful of machines, owned by a few organizations and accessed by small teams of highly trained personnel. In those days, computer security meant wearing the right lab coat and pass card to get past the guard on the door.</p><p>Fast-forward to today. We carry more computational power in our pockets than those operators ever dreamed of. Computers are plentiful and, more pertinently, highly connected.</p><p>The volume of data carried by computer systems is growing at a fantastic rate. We write programs to store, manipulate, interpret, and transfer this data. Our software must guard against information going astray: into the hands of malicious attackers, past the eyes of accidental observers, or even disappearing into the ether. This is critical; a leak of top-secret company information could spell financial ruin. You don't want sensitive personal information (your bank account or credit card details, for example) leaking out for anyone to use. Most software systems require some level of security.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-1" id="CHP-12-FN-1">1</a>]</sup></p><p>Whose responsibility is it to build secure software? Here's the bad news: It's <span class="emphasis"><em>our</em></span> headache. If we don't consider the security of our handiwork carefully, we will inevitably write insecure, leaky programs and reap the rewards.</p><p>Software security is a really big deal, but generally we're very bad at it. Nearly every day you'll hear of a new security vulnerability in a popular product or see the results of viruses compromising system integrity.</p><p>This is an enormous topic, far larger than we have scope to go into here. It's a highly specialized field, requiring much training and experience. However, even the basics are not adequately addressed by modern software engineering teaching. The aim of this chapter is to highlight security issues, explore the problems, and learn some basic techniques to protect our code.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_risks"/>The Risks</h1></div></div></div><div class="epigraph"><p>Better be despised for too anxious apprehensions, than ruined by too confident security.<a class="indexterm" id="IDX-CHP-12-0900"/><a class="indexterm" id="IDX-CHP-12-0901"/><a class="indexterm" id="IDX-CHP-12-0902"/></p><div class="attribution"><span>--<span class="attribution">Edmund Burke</span></span></div></div><p>Why would anyone bother to attack your system? It's usually because you've got something that they want. This could be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your processing power</p></li><li class="listitem"><p>Your ability to send data (e.g., spam)<a class="indexterm" id="IDX-CHP-12-0903"/></p></li><li class="listitem"><p>Your privately stored information</p></li><li class="listitem"><p>Your capabilities—perhaps the specific software you have installed</p></li><li class="listitem"><p>Your connection to more interesting remote systems</p></li></ul></div><p>People might even attack you for the sheer fun of it or because they dislike you and want to cause harm by disrupting your computer resources. While malicious people <span class="emphasis"><em>are</em></span> lurking around looking for easy, insecure prey, a security vulnerability might also be caused by a program that accidentally releases information to the wrong audience. A lucky user might exploit the leak and cause you harm.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Know what important assets you possess. Do you have particularly sensitive information or specific capabilities that an attacker might want? Guard them</em></span>.</p></dd></dl></div><p>To understand the kinds of attack you might suffer, it's important to differentiate protecting an entire computer <span class="emphasis"><em>system</em></span> (comprising of several computers, a network, and a number of collaborating applications) from writing a single secure <span class="emphasis"><em>program</em></span>. Both are important aspects of computer security; they blur together since both are necessary. The latter is a subset of the former. It takes just one insecure program to render an entire computer system (or network) insecure.</p><p>These are the common security risks and compromises of a live, running computer system:<a class="indexterm" id="IDX-CHP-12-0904"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A thief who acquires a laptop or PDA can read any unsecured sensitive data. The stolen device might be configured to automatically dial into a private network, allowing a simple route straight through all your company's defences. This is a serious security threat and one that you can't easily guard against in code! What we can do is write systems that aren't immediately accessible to computer thieves.</p></li><li class="listitem"><p>Flawed input routines can be exploited, leading to many types of compromise—even to the attacker gaining access to the whole machine (we'll see this in "<a class="xref" href="ch12s04.html#buffer_overrun" title="Buffer Overrun">Buffer Overrun</a>" on page 229).</p><p>Break-ins through an unsecured public network interface are particularly worrying. While vulnerbilities in a GUI interface can only be exploited by people actually <span class="emphasis"><em>using</em></span> that UI, an insecure system running on a public network could lead to the whole world trying to break down your door.</p></li><li class="listitem"><p><span class="emphasis"><em>Privilege escalation</em></span> occurs when a user with limited access rights tricks the system to gain a higher security level. The attacker could be an authentic user or someone who has just broken into the system. His or her ultimate aim is to achieve <span class="emphasis"><em>root</em></span> or <span class="emphasis"><em>administrator</em></span> privilege, where the attacker has total control of the machine.</p></li><li class="listitem"><p>If communication is unencrypted and traverses an insecure medium (e.g., the Internet), then any computer en route can syphon off and read data, like a phone tap. A variant of this is known as a <span class="emphasis"><em>man-in-the-middle attack</em></span>: An attacker's machine pretends to be the other communicant and sits between both senders, snooping on their data.<a class="indexterm" id="IDX-CHP-12-0905"/></p></li><li class="listitem"><p>Any system has a small set of trusted users. Malicious authorized users can wreak havoc by copying and sharing data they're not supposed to or entering bad data to compromise the quality of your computer system.</p><p>It's hard to guard against this. You have to trust that each user is responsible enough to handle the level of system access he or she has been designated. If the user isn't trustworthy, you can't write a program to fix it. This shows that security is as much about administration and policy as it is about writing code.</p></li><li class="listitem"><p>Careless users (or careless administrators) can leave a system unnecessarily open and vulnerable. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>People forget to log off; if there is no session timeout, anyone can pick up your program later and start using it.</p></li><li class="listitem"><p>Many attackers use dictionary-based password-cracking tools that fire off many login attempts until one works. Users choose easy-to-memorize passwords that are also easy to guess. Any system that allows weak, easy-to-guess passwords is vulnerable. More secure systems suspend a user's account after a few unsuccessful logins.<a class="indexterm" id="IDX-CHP-12-0906"/></p></li><li class="listitem"><p><span class="emphasis"><em>Social engineering</em></span>—the art of acquiring important information from people, items in an office, or even the outgoing trash—is usually a lot easier (and often quicker) than worming a way into your computer system. People are easier to con than computers, and attackers know this.</p></li><li class="listitem"><p>Out-of-date software installations permit many compromises. Many vendors issue security warnings (or <span class="emphasis"><em>bulletins</em></span>) and software patches. An administrator can easily fall behind the cutting edge, leaving the system open to attack.</p></li></ul></div></li><li class="listitem"><p>Setting lax permissions will allow users access to sensitive parts of your system—for example, letting casual viewers read everyone's salary details. The cure could be as basic as setting correct access permissions on the database files.</p></li><li class="listitem"><p>Virus attacks (self-replicating malicious programs, commonly spread by email attachment), Trojans (hidden malicious payloads in seemingly benign software), and spyware (a form of Trojan that spies on what you are doing, the web pages you visit, etc.) infect machines and can cause all sorts of mayhem. They can capture even the most complex password with keystroke loggers, for example.<a class="indexterm" id="IDX-CHP-12-0907"/><a class="indexterm" id="IDX-CHP-12-0908"/></p></li><li class="listitem"><p>Storing data "in the clear" (unencrypted)—even in memory—is dangerous. Memory is not as safe as many programmers think; a virus or Trojan can scan computer memory and pull out a lot of interesting tidbits for an attacker to exploit.<a class="indexterm" id="IDX-CHP-12-0909"/><a class="indexterm" id="IDX-CHP-12-0910"/></p></li></ul></div><p>The risks increase as the number of routes into a system grows, with more input methods (web-access, command-line, or GUI interfaces), more individual inputs (different windows, prompts, web forms, or XML feeds), and more users (there is a better chance of someone discovering a password). With more outputs, there are more chances for bugs to manifest in the display code, leaking out the wrong information.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>The more complicated a computer system is, the more likely it is to contain security vulnerabilities. Therefore, write the simplest software possible!</em></span></p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-1" id="ftn.CHP-12-FN-1">1</a>] </sup>As we'll see, this is true whether they handle sensitive data or not. If a noncritical component has a public interface, then it poses a security risk to the system as a whole.<a class="indexterm" id="IDX-CHP-12-0899"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_opposition"/>The Opposition</h1></div></div></div><p>It's probably difficult to believe that anyone would take the time and effort to hack your application. But these people exist. They're talented, motivated, and very, very patient. In the battle to write secure software, it's important to know who you're fighting against. Understand exactly what they're doing, how they do it, the tools they're using, and their objectives. Only then can you formulate a strategy to cope.<a class="indexterm" id="IDX-CHP-12-0911"/><a class="indexterm" id="IDX-CHP-12-0912"/><a class="indexterm" id="IDX-CHP-12-0913"/><a class="indexterm" id="IDX-CHP-12-0914"/><a class="indexterm" id="IDX-CHP-12-0915"/><a class="indexterm" id="IDX-CHP-12-0916"/></p><div class="sidebar"><a id="secure_in_the_knowledge"/><p class="title"><b>SECURE IN THE KNOWLEDGE</b></p><p>These important terms help us to reason about security problems:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Flaw</strong></span></span></dt><dd><p>A security flaw is an unintended problem in an application. It is a program fault (see "<a class="xref" href="ch10s03.html#terms_and_conditions-id1" title="TERMS AND CONDITIONS">TERMS AND CONDITIONS</a>" on page 130). Not all flaws are security problems.<a class="indexterm" id="IDX-CHP-12-0917"/></p></dd><dt><span class="term"><span class="strong"><strong>Vulnerability</strong></span></span></dt><dd><p>A vulnerability exists when a flaw opens the possibility for a program to be insecure.<a class="indexterm" id="IDX-CHP-12-0918"/></p></dd><dt><span class="term"><span class="strong"><strong>Exploit</strong></span></span></dt><dd><p>This is an automated tool (or a manual method) that employs a program vulnerability to force unintended—and insecure—behavior. Not all vulnerabilities are found and exploited (that's called <span class="emphasis"><em>luck</em></span>).<a class="indexterm" id="IDX-CHP-12-0919"/></p></dd></dl></div></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Who</strong></span></span></dt><dd><p>Your attacker might be a common crook, a talented cracker, a <span class="emphasis"><em>script kiddie</em></span> (a derogatory name for crackers who run automated cracker scripts—they exploit well-known vulnerabilities with little skill themselves), a dishonest employee cheating the company, or a disgruntled ex-employee seeking revenge for unfair dismissal.<a class="indexterm" id="IDX-CHP-12-0920"/></p><p>Crackers are well informed. There is a cracker subculture where knowledge is passed on and easy-to-use cracker tools are distributed. Not knowing about this doesn't make you innocent and pure, just naïve and open to the simplest attack.</p></dd><dt><span class="term"><span class="strong"><strong>Where</strong></span></span></dt><dd><p>Thanks to pervasive networking, attackers could be anywhere, on any continent, using any type of computer. When working over the Internet, attackers are very hard to locate; many are skilled at covering their tracks. Often they crack easy machines to use as covers for more audacious attacks.</p></dd><dt><span class="term"><span class="strong"><strong>When</strong></span></span></dt><dd><p>They could attack at any time, day or night. Across continents, one person's day is another's night. You need to run secure programs around the clock, not just during business hours.</p></dd><dt><span class="term"><span class="strong"><strong>Why</strong></span></span></dt><dd><p>With such a large bunch of potential attackers, the motives for an attack are diverse. It might be malicious (a political activist wants to ruin your company or a thief wants to access your bank account), or it might be for fun (a college prankster wants to post a comical banner on your website). It might be inquisitive (a hacker just wants to see what your network infrastructure looks like or practice his cracking skills) or opportunist (a user stumbles over data he shouldn't see and works out how to use it to his advantage).</p></dd></dl></div><p>In a networked world, you usually won't know who your enemies actually are until after they have struck. You might not even find out who they are then; your forensic skills might not be able to work back from a smouldering pile of digital debris. But like any good boy scout: <span class="emphasis"><em>Be prepared</em></span>. Don't ignore vulnerabilities and assume no one is interested in attacking your systems—someone out there <span class="emphasis"><em>is</em></span> interested.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Don't ignore vulnerabilities and pretend that you're invincible. Someone, somewhere wants to exploit your code, guaranteed</em></span>.</p></dd></dl></div><div class="sidebar"><a id="cracker_vs._hacker"/><p class="title"><b>CRACKER VS. HACKER</b></p><p>These two terms often get confused and used inappropriately. Their correct definitions are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Cracker</strong></span></span></dt><dd><p>Someone who purposefully exploits vulnerabilities in computer systems to gain unauthorized access.</p></dd><dt><span class="term"><span class="strong"><strong>Hacker</strong></span></span></dt><dd><p>Often used incorrectly to mean <span class="emphasis"><em>cracker</em></span>, a <span class="emphasis"><em>hacker</em></span> is really someone who hacks at—works on—code. This is a 1970s term used with pride by a particular breed of programming geek. A hacker is a computer expert or enthusiast.</p><p>You might also see these two hacker terms in use:</p></dd><dt><span class="term"><span class="strong"><strong>White hat</strong></span></span></dt><dd><p>White hat hackers consider the consequences of their work, scorning the actions of crackers and unethical computer users. They believe that their work is for the good of society.<a class="indexterm" id="IDX-CHP-12-0921"/><a class="indexterm" id="IDX-CHP-12-0922"/></p></dd><dt><span class="term"><span class="strong"><strong>Black hat</strong></span></span></dt><dd><p>This is a programmer from the dark side who enjoys abusing computer systems. Black hats are crackers who actively seek to use systems dishonestly. They have no regard for other people's property or privacy.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="excuses_comma_excuses"/>Excuses, Excuses</h1></div></div></div><p>How do attackers manage to break into code so often? They're armed with weapons we don't have or (due to lack of education) know nothing about. Tools, knowledge, skills: These all work in their favor. However, they have one key advantage that makes all the difference—time. In the heat of the software factory, programmers are pressed to deliver as much code as humanly possible (probably a little bit more) and to do so on time, or else. This code has to meet all requirements (for functionality, usability, reliability, etc.), leaving us precious little time to focus on other "peripheral" concerns, like security. Attackers don't share this burden; they have plenty of time to learn the intricacies of your system, and they have learned to attack from many different angles.<a class="indexterm" id="IDX-CHP-12-0923"/><a class="indexterm" id="IDX-CHP-12-0924"/></p><p>The game is stacked heavily in their favor. As software developers, we must defend all possible points of the system; an attacker can pick the weakest point and focus there. We can only defend against the known exploits; attackers can take their time to find any number of unknown vulnerabilities. We must be constantly on the lookout for attacks; attackers can strike at will. We have to write good, clean software that works nicely with the rest of the world; attackers can play as dirty as they like.<a class="indexterm" id="IDX-CHP-12-0925"/></p><p>Software security presents a myriad of extra—but important—problems and challenges for the poor, overworked programmer. What does this tell us? Simply that we <span class="emphasis"><em>must</em></span> do better. We must be better informed, better armed, more aware of our enemies, and more conscious of the way we write code. We must design in security from the outset and put it into our development processes and schedules.<a class="indexterm" id="IDX-CHP-12-0926"/><a class="indexterm" id="IDX-CHP-12-0927"/></p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="feeling_vulnerable"/>Feeling Vulnerable</h1></div></div></div><p>The programmer's role in this mess is to write secure code, so let's survey the weak points in our software to determine where we must focus our effort. These are specific types of code vulnerabilities, holes that can be compromised by an attacker.<a class="indexterm" id="IDX-CHP-12-0928"/><a class="indexterm" id="IDX-CHP-12-0929"/><a class="indexterm" id="IDX-CHP-12-0930"/><a class="indexterm" id="IDX-CHP-12-0931"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="insecure_design_and_architecture"/>Insecure Design and Architecture</h2></div></div></div><p>This is the most fundamental flaw, and consequently the hardest to fix. Failure to consider security at the architectural level will lead to committing security sins everywhere: sending unencrypted data over public networks, storing it on easily accessible media, and running software services that have known security flaws.</p><p>Security should appear on the radar as soon as development starts. Every system component must be considered for security holes; a computer system is only as safe as its least secure part, which may not even be the code you're writing. For example, a Java program can be no more secure than the JVM executing it.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="buffer_overrun"/>Buffer Overrun</h2></div></div></div><p>Most applications are public facing, listening on an open network port or handling input from a web browser or GUI interface. These input routines are prime sites for security failure.</p><p>C code programs often use the standard library function <code class="literal">sscanf</code> to parse input. Although it's part of C's standard library and appears in C code regularly, <code class="literal">sscanf</code> unashamedly provides subtle ways to write insecure code.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-2" id="CHP-12-FN-2">2</a>]</sup></p><p>You might see code like this:</p><a id="I_programlisting6_d1e17373"/><pre class="programlisting">
void parse_user_input(const char *input)
{
      <strong class="userinput"><code>/* first parse the input string */</code></strong>
      int my_number;
      char my_string[100];
      sscanf(input, "%d %s", &amp;my_number, my_string);
      <strong class="userinput"><code>... now use it ...</code></strong>
}
</pre><p>Can you see the glaring problem? An ill-formed <code class="literal">input</code> string—anything over 100 characters—will overrun the <code class="literal">my_string</code> buffer and smear arbitrary data across invalid memory addresses.<a class="indexterm" id="IDX-CHP-12-0932"/></p><p>The results depend on what memory is trashed. Sometimes the program will carry on unaffected; you've been very, very lucky.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-3" id="CHP-12-FN-3">3</a>]</sup> Sometimes the program continues, but its behavior is subtly altered—this can be hard to spot and confusing to debug. Sometimes the program will crash as a consequence, perhaps taking other critical system components down with it. But the worst case is when the spilt data gets written somewhere in the CPU's execution path. This isn't actually hard to do and allows an attacker to execute arbitrary code on your machine, potentially gaining complete access to it.</p><p>Overrun is easiest to exploit when the buffer is located on the stack, as in the example above. Here it's possible to direct CPU behavior by overwriting the stack-stored return address of a function call. However, buffer overrun exploits can abuse heap-based buffers too.<a class="indexterm" id="IDX-CHP-12-0933"/><a class="indexterm" id="IDX-CHP-12-0934"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="embedded_query_strings"/>Embedded Query Strings</h2></div></div></div><p>This breed of attack can be used to crash programs, execute arbitrary code, or fish for unauthorized data. Like buffer overrun, it relies on a failure to parse input, but rather than burst buffer boundaries, these attacks exploit what the program subsequently does with the unfiltered input.<a class="indexterm" id="IDX-CHP-12-0935"/></p><p><span class="emphasis"><em>Format string attacks</em></span> are a classic example of this problem in C programs. A common culprit is the <code class="literal">printf</code> function (and its variants), used as follows:<a class="indexterm" id="IDX-CHP-12-0936"/></p><a id="I_programlisting6_d1e17428"/><pre class="programlisting">
void parse_user_input(const char *input)
{
     printf(input);
}
</pre><p>A malicious user could provide an input string containing <code class="literal">printf</code> format tokens (like <code class="literal">%s</code> and <code class="literal">%x</code>) and coerce the program to print data from the stack or even from locations in memory, depending on the exact form of the <code class="literal">printf</code> call. An attacker can also write arbitrary data to memory locations using a similar ploy (exploiting the <code class="literal">%n</code> format token).</p><p>Solutions to this problem aren't hard to find. Writing <code class="literal">printf("%s", input)</code> will avoid the problem by ensuring that <code class="literal">input</code> is not interpreted as a format string.</p><p>There are many other situations where an embedded query can maliciously exploit a program. SQL statements can be surreptitiously fed into database applications to force them to perform arbitrary database lookups for an attacker.<a class="indexterm" id="IDX-CHP-12-0937"/></p><p>Another variant exhibited by lax web-based applications is known as a <span class="emphasis"><em>cross-site scripting</em></span> exploit, due to the way the attack works across the system: from an attacker's input, through the web application, finally manifesting on a victim's browser. An attacker's bogus comment on a web-based messaging system will be rendered by all browsers viewing the page. If the message contains hidden JavaScript code, the browsers will execute it without their users realizing it.<a class="indexterm" id="IDX-CHP-12-0938"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="race_conditions"/>Race Conditions</h2></div></div></div><p>It is possible to exploit systems that rely on the subtle ordering of events, to provoke unintended behavior or crash the code. This is generally exhibited in systems with complex threading models or that are comprised of many collaborating processes.<a class="indexterm" id="IDX-CHP-12-0939"/><a class="indexterm" id="IDX-CHP-12-0940"/><a class="indexterm" id="IDX-CHP-12-0941"/><a class="indexterm" id="IDX-CHP-12-0942"/><a class="indexterm" id="IDX-CHP-12-0943"/></p><p>A threaded program might share its memory pool between two worker threads. Without adequate guarding, one thread might read information in the buffer that the writer thread did not intend to release yet—part of a privileged transaction or a different user's information.<a class="indexterm" id="IDX-CHP-12-0944"/></p><p>This problem isn't restricted to threaded applications, though. Consider the following fragment of Unix C code. It intends to dump some output to a file and then change file permissions on it.</p><a id="I_programlisting6_d1e17500"/><pre class="programlisting">
fd = open("filename");            <strong class="userinput"><code>/* create a new file */
/* point A (see later) */</code></strong>
write(fd, some_data, data_size);   <strong class="userinput"><code>/* write some data */</code></strong>
close(fd);                         <strong class="userinput"><code>/* close the file */</code></strong>
chmod("filename", 0777);           <strong class="userinput"><code>/* give it special privileges */</code></strong>
</pre><p>There is a race here that an attacker can exploit. By removing the file at point <code class="literal">A</code> and replacing it with a link to his own file, the attacker gains a specially privileged file. This can be used to further exploit the system.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="integer_overflow"/>Integer Overflow</h2></div></div></div><p>Careless use of mathematical constructs can cause a program to cede control in unusual ways. Integer overflow will occur when a variable type is too small to represent the result of an arithmetic operation. The unsigned 8-bit data type (<code class="literal">uint8_t</code>) renders this C calculation erroneous:<a class="indexterm" id="IDX-CHP-12-0945"/></p><a id="I_programlisting6_d1e17530"/><pre class="programlisting">
uint8_t a = 254 + 2;
</pre><p>The contents of <code class="literal">a</code> will be 0, not the 256 you'd expect; 8 bits can only count up to 255. An attacker can supply very large numeric input values to provoke overflow and generate unintended program results. It's not hard to see this causing significant problems; the following C code contains a heap overrun waiting to happen, thanks to integer overflow:</p><a id="I_programlisting6_d1e17537"/><pre class="programlisting">
void parse_user_input(const char* input)
{
    uint8_t length = strlen(input) + 11; <strong class="userinput"><code>/* a uint8_t might overflow */</code></strong>
    char *copy = malloc(length);         <strong class="userinput"><code>/* so this might be too small */</code></strong>
    if (copy)
    {
        sprintf(copy, "Input is: %s", input);
        <strong class="userinput"><code>/* oh dear, we might have overrun the buffer */</code></strong>

    }
}
</pre><p>It's true that <code class="literal">uint8_t</code> is an unlikely candidate for the string length variable, but the exact same problem manifests itself with larger data types. It's less likely in normal operation, but just as exploitable.</p><p>This kind of problem also occurs with subtraction operations (where it's called integer <span class="emphasis"><em>underflow</em></span>), mixed signed and unsigned assignments, bad type casting, and multiplication or division.<a class="indexterm" id="IDX-CHP-12-0946"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-2" id="ftn.CHP-12-FN-2">2</a>] </sup>This example is written in C and is common in C code, but remember that this exploit is far from a C-only problem.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-3" id="ftn.CHP-12-FN-3">3</a>] </sup>Or, to look at it another way, you've been very unlucky. You didn't spot the flaw when testing; it will enter production code, just waiting for a cracker to exploit it.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="protection_racket"/>Protection Racket</h1></div></div></div><div class="epigraph"><p>The more you seek security, the less of it you have.<a class="indexterm" id="IDX-CHP-12-0947"/></p><div class="attribution"><span>--<span class="attribution">Brian Tracy</span></span></div></div><p>We've seen how software construction is like building a house (see "<a class="xref" href="ch10.html#do_we_really_build_software_question" title="DO WE REALLY BUILD SOFTWARE?">DO WE REALLY BUILD SOFTWARE?</a>" on page 177, and Chapter 14). We must learn to secure our programs just like we'd protect a house, locking all doors and windows, employing a sentry, and adding security mechanisms (like a burglar alarm, electronic pass cards, identity badges, etc.). But you must still be constantly vigilant: A door can be left ajar regardless of any fancy lock devices, and a burglar alarm can be left unset.</p><p>Our software security strategies apply at different levels:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The system</strong></span> <span class="bolditalic">installation</span></span></dt><dd><p>The exact OS configuration, network infrastructure, and version numbers of all running applications have important security implications.</p></dd><dt><span class="term"><span class="strong"><strong>The software system</strong></span> <span class="bolditalic">design</span></span></dt><dd><p>We need to address design issues like whether the user can remain logged in for indefinite periods, how each subsystem communicates, and which protocols are used.</p></dd><dt><span class="term"><span class="strong"><strong>The program</strong></span> <span class="bolditalic">implementation</span></span></dt><dd><p>It must be flaw-free. Buggy code leads to security vulnerabilities.</p></dd><dt><span class="term"><span class="strong"><strong>The system's usage</strong></span> <span class="bolditalic">procedure</span></span></dt><dd><p>If it is routinely used incorrectly, any software system can be compromised. We should prevent this as much as possible with sound design, but users must be taught not to cause problems. How many people write down their username and password on paper beside their terminals?</p></dd></dl></div><p>Creating a secure system is never easy. It will always require a security/functionality compromise. The more secure a system is, the less useful it becomes. The safest system has no inputs and no outputs; there's nowhere for anyone to attack. It won't do much, though. The easiest system has no authentication and allows everyone full access to everything; it's just terribly insecure. We need to pick a balance. This depends on the nature of the application, its sensitivity, and the perceived threat of attack. To write appropriately secure code, we must be very clear about such <span class="emphasis"><em>security requirements</em></span>.<a class="indexterm" id="IDX-CHP-12-0948"/><a class="indexterm" id="IDX-CHP-12-0949"/><a class="indexterm" id="IDX-CHP-12-0950"/></p><p>Just as you would take steps to secure a building, the following techniques will protect your software from malicious attackers.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="system_installation_techniques"/>System Installation Techniques</h2></div></div></div><p>No matter how good your application is, if the target system is insecure, your program is vulnerable. Even the most secure application must run in its operating environment: under a particular OS, on a specific piece of hardware, on a network, and with a certain set of users. An attacker is just as likely to compromise one of these as your actual code.<a class="indexterm" id="IDX-CHP-12-0951"/><a class="indexterm" id="IDX-CHP-12-0952"/><a class="indexterm" id="IDX-CHP-12-0953"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don't run any untrusted, potentially insecure program on your computer system.</p><p>This raises the question: What makes you trust a piece of software? You can audit open source software to prove that it's correct (if you have the inclination). You can opt for the same software that everyone else uses, thinking that there's safety in numbers. (However, if a vulnerability is found in that software, you, and many other people, must update.) Or you can pick a supplier based on their reputation, hoping that it's a worthwhile indicator.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Only run trusted software on your computer system. Have a clear policy to decide who you trust</em></span>.</p></dd></dl></div></li><li class="listitem"><p>Employ security technologies like firewalls and spam and virus filters. Don't let crackers in through a back door.<a class="indexterm" id="IDX-CHP-12-0954"/></p></li><li class="listitem"><p>Prepare for malicious authorized users by logging every operation, recording who did what and when. Back up all data stores periodically so that bogus modifications don't lose all of your good work.<a class="indexterm" id="IDX-CHP-12-0955"/></p></li><li class="listitem"><p>Minimize the access routes into the system, give each user a minimal set of permissions, and reduce the pool of users if you can.</p></li><li class="listitem"><p>Set up the system correctly. Certain OSes default to very lax security, practically inviting a cracker to walk straight in. If you're setting up such a system, then it's vital to learn how to protect it fully.</p></li><li class="listitem"><p>Install a <span class="emphasis"><em>honeypot</em></span>: a decoy machine that attackers will find more easily than your real systems. If it looks plausible enough, then they'll waste their energy breaking into it, while your critical machines continue unaffected. Hopefully you'll notice a compromise of the honeypot and repel the attacker long before he gets near your valuable data.<a class="indexterm" id="IDX-CHP-12-0956"/></p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="software_design_techniques"/>Software Design Techniques</h2></div></div></div><p>This is the essential place to get your security story straight. You can try to shoehorn security into code at the end of a development cycle, and you'll fail. It must be a fundamental part of your system's architecture and design.<a class="indexterm" id="IDX-CHP-12-0957"/><a class="indexterm" id="IDX-CHP-12-0958"/><a class="indexterm" id="IDX-CHP-12-0959"/><a class="indexterm" id="IDX-CHP-12-0960"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Security is an essential aspect of every software architecture. It's a mistake to gloss over it during early development work</em></span>.</p></dd></dl></div><p>The simplest software design has the fewest points of attack and is consequently the easiest to secure. More complex designs naturally lead to more interactions between constituent parts, and so provide more places for a cracker to attack. If you're one of the 99.9 percent of programmers who can't run your program in a sealed box in an underground bunker in an undisclosed location in the middle of a desert, then you need to consider how to make your design as simple as possible.</p><p>As you design the code, think about how to actively prevent anyone from abusing it. Here are the winning strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Limit the number of inputs in your design, and route all communication through one portion of the system. This way, an attacker can't get all over your code—only through a single (secured) bottleneck. His influence is limited to a secluded corner, and you can focus your security efforts there.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-4" id="CHP-12-FN-4">4</a>]</sup></p></li><li class="listitem"><p>Run every program at the most restrictive privilege level possible. Don't run a program as the system superuser unless it's absolutely necessary, and then take <span class="emphasis"><em>even more</em></span> care than usual. This is especially important for Unix programs that run setuid—these can be run by any user but are given special system privileges when they start.</p></li><li class="listitem"><p>Avoid any features that you don't really need. It will not only save you development time, but also reduce the chance of bugs getting into the program—there's less software for them to inhabit. The less complicated your code, the less likely it is to be insecure.</p></li><li class="listitem"><p>Don't rely on insecure libraries. An insecure library is anything you don't <span class="emphasis"><em>know</em></span> to be secure. For example, most GUI libraries aren't designed for security, so don't use them in a program run as the superuser.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Only rely on known, secure third-party components in your program design</em></span>.</p></dd></dl></div></li><li class="listitem"><p>Tailor your code to an execution environment that manages security issues. The .NET run time offers offers a <span class="emphasis"><em>code access security</em></span> infrastructure that allows you to assert, for example, that the calling code has been signed by a trusted third party. This doesn't remove all potential problems (the company's private key could always go astray), and you must learn how to use it correctly, but it does help to manage security problems.</p></li><li class="listitem"><p>Avoid storing sensitive data. If you must, encrypt it so that prying eyes can't easily read it. When you handle secrets, be very wary of where you put them; lock memory pages containing sensitive information so that your OS's virtual memory manager can't swap it onto the hard disk, leaving it available for an attacker to read.<a class="indexterm" id="IDX-CHP-12-0961"/></p></li><li class="listitem"><p>Obtain secrets from the user carefully. Don't display passwords.<a class="indexterm" id="IDX-CHP-12-0962"/></p></li></ul></div><p>The least impressive security strategy is known as <span class="emphasis"><em>security through obscurity</em></span>, yet this is really the most prevalent. It merely hides all software design and implementation behind a wall so that no one can see how the code works and figure out how to abuse it. Obscurity means that you don't advertise your critical computer systems in the hope that no attacker will find them.<a class="indexterm" id="IDX-CHP-12-0963"/></p><p>It's a flawed plan. Your system <span class="emphasis"><em>will</em></span> one day be found, and it <span class="emphasis"><em>will</em></span> one day be attacked.</p><p>It's not always a conscious decision, and this technique works very conveniently when you forget to consider security in the system design at all—that is, it's convenient until someone <span class="emphasis"><em>does</em></span> compromise your system. Then it's a different matter.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Expect your software to be attacked, and design each part with this in mind</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="code_implementation_techniques"/>Code Implementation Techniques</h2></div></div></div><p>With a bulletproof system design, your software is unbreakable, right? Sadly, it is not. We've already seen how security exploits can capitalize on flaws in code to wreak their particular brand of chaos.<a class="indexterm" id="IDX-CHP-12-0964"/><a class="indexterm" id="IDX-CHP-12-0965"/></p><p>Our code is the front line, the most common route an attacker will try to enter through and the place our battles are fought. Without a good system design, even the best code is vulnerable to attack; but upon the foundation of a well-thought-out architecture, we must build strong walls of defense with secure code. Correct code is not necessarily secure code.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Defensive programming is the main technique to achieve sound code. Its central tenet—<span class="emphasis"><em>assume nothing</em></span>—is exactly what secure programming is about. Paranoia is a virtue, and you can never assume that users will employ your program as you expect or intend them to.</p><p>Simple defensive rules like "check <span class="emphasis"><em>every</em></span> input" (including user input, startup commands, and environment variables), and "validate <span class="emphasis"><em>every</em></span> calculation" will remove countless security vulnerabilities from your code.</p></li><li class="listitem"><p>Perform <span class="emphasis"><em>security audits</em></span>. These are careful reviews of the source code by security experts. Normal testing won't find many security flaws; they are generally caused by bizarre combinations of use that ordinary testers wouldn't think of (for example, very long input sequences that provoke buffer overrun).<a class="indexterm" id="IDX-CHP-12-0966"/></p></li><li class="listitem"><p>Spawn child processes very carefully. If an attacker can redirect the sub-task, then he can gain control of arbitrary facilities. Don't use C's <code class="literal">system</code> function unless there's no other solution.</p></li><li class="listitem"><p>Test and debug mercilessly. Squash bugs as rigorously as you can. Don't write code that can crash; its use could bring down a running system instantly.</p></li><li class="listitem"><p>Wrap all operations in atomic transactions so attackers can't exploit race conditions to their advantage. You could fix the <code class="literal">chmod</code> example in "<a class="xref" href="ch12s04.html#race_conditions" title="Race Conditions">Race Conditions</a>" on page 231 by using <code class="literal">fchmod</code> on the open file handle, rather than <code class="literal">chmod</code>ing the file by name: It doesn't matter if the attacker replaces the file, you know exactly which file is being altered.<a class="indexterm" id="IDX-CHP-12-0967"/></p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="procedural_techniques"/>Procedural Techniques</h2></div></div></div><p>This is largely a matter of training and education, although it helps to select users who aren't totally inept (if you have that luxury).<a class="indexterm" id="IDX-CHP-12-0968"/><a class="indexterm" id="IDX-CHP-12-0969"/><a class="indexterm" id="IDX-CHP-12-0970"/></p><p>Users must be taught safe working practices: not to tell anyone their password, not to install random software on a critical PC, and to use their systems only as prescribed. However, even the most diligent people will make mistakes. We design to minimize the risk of these mistakes, and we hope that the consequences are never too severe.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-4" id="ftn.CHP-12-FN-4">4</a>] </sup>Of course, it's never quite that simple. A buffer overrun could occur anywhere in your code, and you must be constantly vigilant. However, most security vulnerabilities exist at, or near, the sites of program input.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id11"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Security is a kind of death.</p><div class="attribution"><span>--<span class="attribution">Tennessee Williams</span></span></div></div><p>Programming is war.</p><p>Security is a real issue in modern software development; you can't stick your head in the sand and hide from it. Ostriches write poor code. We can prevent most security breaches by better design, better system architecture, and greater awareness of the problems. The benefits of a secure system are compelling, since the risks are so serious.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Understand the security requirements for each project they work on</p></li><li class="listitem"><p>Instinctively write code that avoids common security vulnerabilities</p></li><li class="listitem"><p>Design security into each system; they don't patch it in at the end</p></li><li class="listitem"><p>Have a security test strategy</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Dismiss security as an unimportant concern</p></li><li class="listitem"><p>Consider themselves security experts (very few people are security experts)</p></li><li class="listitem"><p>Only think about security flaws in their programs when vulnerabilities are discovered, or worse, when their code is compromised</p></li><li class="listitem"><p>Focus on security when writing code and ignore it at the design and architectural levels</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id11"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch01.html" title="Chapter 1. ON THE DEFENSIVE">Chapter 1</a></span></dt><dd><p><span class="emphasis"><em>Defensive programing</em></span> is an important technique for writing secure code.</p></dd><dt><span class="term"><a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a></span></dt><dd><p>We must rigorously test our software for security issues.</p></dd><dt><span class="term"><a class="xref" href="ch13.html" title="Chapter 13. GRAND DESIGNS">Chapter 13</a></span></dt><dd><p>Security is similarly essential to the design of each section of code.</p></dd><dt><span class="term"><a class="xref" href="ch14.html" title="Chapter 14. SOFTWARE ARCHITECTURE">Chapter 14</a></span></dt><dd><p>Security is one of the fundamental architectural concerns of a computer system. It must be designed in from the outset.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e18005"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207480.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id12"/>Get Thinking</h1></div></div></div><p>A detailed discussion of the following questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 515.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id11"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What is a "secure" program?</p></li><li class="listitem"><p>What input must be validated in a secure program? What sort of validation is required?</p></li><li class="listitem"><p>How can you guard against attacks from the pool of trusted users?</p></li><li class="listitem"><p>Where can an exploitable buffer overrun occur? What functions are particularly prone to buffer overrun?</p></li><li class="listitem"><p>Can you avoid buffer overruns altogether?</p></li><li class="listitem"><p>How can you secure the memory in use by your application?</p></li><li class="listitem"><p>Are C and C++ inherently less secure than alternative languages?<a class="indexterm" id="IDX-CHP-12-0971"/></p></li><li class="listitem"><p>Has the experience of C led to C++ being a better, more securely designed language?</p></li><li class="listitem"><p>How do you know when your program has been compromised?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id11"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What are the security requirements for your current project? How were these requirements established? Who knows about them? Where are they documented?<a class="indexterm" id="IDX-CHP-12-0972"/><a class="indexterm" id="IDX-CHP-12-0973"/></p></li><li class="listitem"><p>What's the worst security bug in one of your shipped applications?</p></li><li class="listitem"><p>How many security bulletins have been posted against your application?</p></li><li class="listitem"><p>Have you ever run a <span class="emphasis"><em>security audit</em></span>? What kinds of flaws did it reveal?</p></li><li class="listitem"><p>What kind of person is most likely to attack your current system? How is this influenced by</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your company</p></li><li class="listitem"><p>The type of user</p></li><li class="listitem"><p>The type of product</p></li><li class="listitem"><p>The popularity of the product</p></li><li class="listitem"><p>The competition</p></li><li class="listitem"><p>The platform you run on</p></li><li class="listitem"><p>The connectedness and public visibility of the system</p></li></ul></div></li></ol></div></div></div></body></html>