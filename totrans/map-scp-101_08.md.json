["```\n❶ ?xml version=\"1.0\" encoding=\"UTF-8\"?>\n❷ root>\n    <child ❸name=\"first\">\n      ❹<grandchild>text could go here</grandchild>\n    </child>\n    <child name=\"second\" ❺/>\n  </root>\n```", "```\n<html>\n  <head>\n  <script>\n❶   var xmltxt = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n        xmltxt += \"<root>\\n\";\n        xmltxt += \" <child name=\\\"first\\\" />\\n\";\n        xmltxt += \" <child name=\\\"second\\\">\\n\";\n        xmltxt += \" <grandchild>text goes here</grandchild>\\n\";\n        xmltxt += \" </child>\\n\";\n        xmltxt += \"</root>\\n\";\n    var x = null;\n    var output = \"\";\n\n❷   if (window.ActiveXObject) { // Internet Explorer\n      x = new ActiveXObject(\"Microsoft.XMLDOM\");\n      x.async = false;\n      x.loadXML(xmltxt);\n    }\n❸   else if (window.DOMParser) { // Other browsers\n      var p = new DOMParser();\n      x = p.parseFromString(xmltxt, \"text/xml\");\n    }\n    else {\n        // Can't load XML\n    }\n\n    if (x) {\n❹     `var children = x.getElementsByTagName(\"child\");`\n❺     `for (i=0; i<children.length; i++) {`\n❻       `output += children[i].getAttribute(\"name\") + \"\\n\";`\n      `}`\n    }\n    alert(output);\n  </script>\n  </head>\n  <body></body>\n  </html>\n```", "```\n<html>\n  <head>\n❶   <script src=\"http://ajax.googleapis.com/ajax/libs/\njquery/1.3/jquery.min.js\"></script>\n  <script>\n    var output = \"\";\n❷   $.get(\"example.xml\", {}, ❸function(xml) {\n❹     $(\"child\", xml).❺each(function(i) {\n        output += ❻this.getAttribute(\"name\") + \"\\n\";\n    });\n    alert(output);\n  });\n  </script>\n  </head>\n  <body></body>\n  </html>\n```", "```\n<?\n❶ $xmltxt = join(\"\\n\", file(\"example.xml\"));\n❷ $xmlobj = simplexml_load_string($xmltxt);\n  foreach (❸$xmlobj->child as $childobj) {\n    print($childobj->❹attributes()->name . \"\\n\");\n  }\n  ?>\n```", "```\nSimpleXMLElement Object (\n❶   [child] => Array (\n      [0] => SimpleXMLElement Object (\n❷       [@attributes] => Array (\n          [name] => first\n        )\n      )\n      [1] => SimpleXMLElement Object\n        [@attributes] => Array (\n          [name] => second\n        )\n❸       [grandchild] => text goes here\n      )\n    )\n  )\n```", "```\n$xmlobj->xpath(\"/root/child/grandchild\")\n```", "```\n$xmlobj->xpath(\"//grandchild\")\n```", "```\n$xmlobj->xpath(\"//child/grandchild\")\n```", "```\n❶ {\"child\": [\n❷   {\"attributes\": {\"name\": \"first\"}},\n❸   {\"attributes\": {\"name\": \"second\"}, \"grandchild\": \"text goes here\"}\n  ]}\n```", "```\n`var obj =` {\"child\": [\n  {\"attributes\": {\"name\": \"first\"}},\n  {\"attributes\": {\"name\": \"second\"}, \"grandchild\": \"text goes here\"}\n]}`;`\n`alert(obj.child[0].attributes.name);`\n```", "```\n<html>\n  <head>\n❶ <script src=\"http://ajax.googleapis.com/ajax/libs/\njquery/1.3/jquery.min.js\"></script>\n  <script>\n  $.getJSON(❷\"example.json\", ❸function(jobj) {\n      alert(❹jobj.child[0].attributes.name);\n    });\n  </script>\n  </head>\n  <body>\n  </body>\n  </html>\n```", "```\n<?\n$obj = array(\"child\" => array(\n  array(\"attributes\" => array(\"name\" => \"first\")),\n  array(\n  \"attributes\" => array(\"name\" => \"second\"),\n  \"grandchild\" => \"text goes here\")\n));\n?>\n```", "```\n<?\n$jtxt = \"{\\\"child\\\":[\" .\n        \"{\\\"attributes\\\":{\\\"name\\\":\\\"first\\\"}},\" .\n        \"{\\\"attributes\\\":{\\\"name\\\":\\\"second\\\"},\" .\n        \"\\\"grandchild\\\":\\\"text goes here\\\"}]}\";\n$jobj = ❶json_decode($jtxt);\nprint ($jobj->❷child[0]->attributes->name);\n?>\n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rss version=\"2.0\" >\n  <channel>\n    <link>http://mapscripting.com</link>\n    <title>Feed Title</title>\n    <description>Feed Description</description>\n    <item>\n      <pubDate>Thu, 01 Jan 2010 00:01:23 +0000</pubDate>\n      <title>Item Title</title>\n      <description>Item Description</description>\n      <author>Item Author</author>\n      **`<georss:point>45.256 −71.92</georss:point>`**\n    </item>\n    ...\n  </channel>\n</rss>\n```", "```\n<georss:line>45.256 −110.45 46.46 −109.48 43.84 −109.86</georss:line>\n<georss:polygon>\n  45.256 −110.45 46.46 −109.48 43.84 −109.86 45.256 −110.45\n</georss:polygon>\n```", "```\n<georss:box>42.943 −71.032 43.039 −69.856</georss:box>\n```", "```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<feed \n      ``>   <title>Feed Title</title>   <updated>2010-01-01T00:01:23Z</updated>   <author>     <name>Feed Author</name>     <email>feedemail@example.com</email>   </author>   <id>tag:mapscripting.com,2009-01-01:feedid</id>   <entry>     <title>Entry title</title>     <link href=\"http://example.org/entry_link\"/>     <updated>2010-01-01T00:01:23Z</updated>     <summary>Entry summary</summary>     **`<georss:point>45.256 −71.92</georss:point>`**   </entry>   ... </feed>``\n```", "```\n`<georss:where>   <gml:Point>     <gml:pos>45.256 −71.92</gml:pos>   </gml:Point> </georss:where>`\n```", "``` ``The data communicated with these tags is the same as the simple GeoRSS example. The additional tags are not extraneous, but included because GML allows for more specific uses. For example, the `<gml:Point>` tag is where you would declare another coordinate system.`` ```", "``` ``GML equivalents of the geometric objects used in the simple GeoRSS are available. The method for polygons, lines, and boxes is similar to points. The GML code is wrapped in `<georss:where>` tags. You can find out more about all the options at [http://www.georss.org/gml](http://www.georss.org/gml).`` ```", "``` ``Add this code inside the root tag of your XML. For RSS, the root is `<rss>`, and for Atom, it is `<feed>`. Both are necessary because the GML version of GeoRSS uses `georss:` and `gml:` tags.`` ```", "```\n`<geo:lat>55.701</geo:lat> <geo:long>12.552</geo:long>`\n```", "``` ``The biggest difference between the W3C geo-tags and the ones shown earlier is that the latitude and longitude is declared separately. Because this encoding is popular, this method is yet another allowed to write GeoRSS. You'll need a different namespace to be able to use the `geo:` tags, however:`` ```", "```\n`` `Now that you know about the many encodings of GeoRSS, let's see how to use GeoRSS directly with your map.` ``\n```", "```\n``<html >     <head>       <title>Example GeoRSS Map</title>       <script src=\"*`http://maps.google.com/maps/api/js?`* *`sensor=false`*\" type=\"text/javascript\"></script>       <script src=\"mxn.js?(googlev3)\"></script>       <style>       div#mymap {         width: 550px;         height: 450px;       }       </style>       <script type=\"text/javascript\">       var mapstraction;       function create_map() {         mapstraction = new Mapstraction('mymap', 'google');         **`mapstraction.addOverlay(`** ❶         **`\"http://mapscripting.com/example-georss.xml\", ❷true);`**       }       </script>     </head>     <body onload=\"create_map()\">       <div id=\"mymap\"></div>     </body>   </html>``\n```", "``` ``Most of this is standard map code; the important lines are in bold. You can see we use Mapstraction's `addOverlay` function. The first argument is the GeoRSS URL ❶. This address must be available on the public Web, not on your local computer or a password-protected development server. The reason the feed has to be accessible is the underlying mapping provider will make an Ajax call to load the feed. The mapping provider can't make the call if it can't access the URL. If you don't have your own feed, you can use my example from the companion website.`` ```", "``` ``The second argument ❷ is optional. This argument is a boolean, meaning the value is either `true` or `false`. It controls whether the map is auto-centered and zoomed in to show only the GeoRSS content.`` ```", "````` ````# #55: Use KML    Google Earth, a three-dimensional geographic browser, popularized KML as a language to share geo-data. The acronym *KML* stands for *Keyhole Markup Language*, named after the company (acquired by Google) who invented it. Nevertheless, KML is an open standard based on XML. KML stores single locations, lists of points, and polygon shapes, among other features. The biggest factor that separates KML from other geographic data formats is that KML can also include styling information, so you can stipulate the color of lines or use custom marker icons.    KML has a special schema, meaning elements are declared in a specific way.    Here's a very basic KML file, containing one location, called a *Placemark*:    ``` ❶ <?xml version=\"1.0\" encoding=\"UTF-8\"?> ❷ <kml >   <Document> ❸   <Placemark> ❹     <name>Eiffel Tower</name> ❺     <description>The most recognizable place in Paris</description>       <Point> ❻       <coordinates>2.29293460923931,48.85819570061303,0</coordinates>       </Point>     </Placemark>   </Document>   </kml> ```    As you put your KML files together, you can view them in Google Earth or on the Google Maps website, as long as the KML is accessible on the web. Try viewing this example at [http://maps.google.com/?q=http%3A//mapscripting.com/example.kml](http://maps.google.com/?q=http%3A//mapscripting.com/example.kml).    Now let's examine what's inside that example KML file. As with every XML file, a KML file starts with the XML declaration ❶. Then the file points to the KML namespace ❷ to clearly specify we're speaking a particular XML language. With those technical bits out of the way, we can dive into the actual KML content.    The geographic data in a KML file all falls within the `<Document>` tag. Inside that, I add a `Placemark` ❸, which will contain location and other data for a single place. Each Placemark has a name ❹, which is essentially the equivalent of a title in GeoRSS. Similarly, each Placemark also has a description ❺, which can be plain text (as shown) or HTML (with `<` and `>` brackets written as `&lt;` and `&gt;`).    Arguably the most important piece of data for a Placemark is the actual geographic point. To declare this, we use a `<Point>` tag and then include the coordinates ❻ within it. Note we include three numbers, as opposed to the usual two. The last number represents altitude and is actually optional. We could increase the number, for example, if we wanted our Placemark to declare the top of the Eiffel Tower.    One final, important note about the first two coordinates: Unlike most other geographic data formats, *KML lists longitude before latitude*. This setup is easy to recognize in examples like this and in North America, where longitudes are always negative. But you definitely want to make sure you get these numbers in the right order.    A document generally contains multiple Placemarks, but in this simple example, I only use one. Adding another is easy—just include an additional pair of `<Placemark>` tags.    Now that you've seen a simple location, let's look at some other ways KML marks up geographic data.    ## Lines in KML    The single point is the basic feature of geographic data—and that holds for KML, as well. Sometimes a point isn't the best way to describe a place. What single point represents a country or a city? A single point can't; you need many points. This is where lines and polygons become useful.    Rather than use a different tag, KML declares both lines and polygons as Placemarks. Unlike the ones shown previously, these Placemarks do not contain a `<Point>` tag because we're actually declaring multiple points at once to represent a single place.    Consider this example, which shows the path of the Golden Gate Bridge in San Francisco:    ``` <Placemark>     <name>Golden Gate Bridge</name>     <description>A San Francisco landmark, for sure.</description> ❶   <LineString> ❷     <coordinates> ❸       −122.479485,37.827675,0         −122.477562,37.811028,0       </coordinates>     </LineString>   </Placemark> ```    I've omitted the tags that declare this a KML document and instead focused on the Placemark. I include a name and description, just as in the single point example. To describe the bridge, we first add some KML to say this Placemark is a line ❶, and then we insert a series of coordinates ❷ to describe the line.    Of course, a bridge has two ends, so the line is a very simple one using two points. If this were a more advanced line, such as describing a trail or the route of a race, we would just continue adding coordinates in an order such that they could later be connected by line segments.    As in the single point example, we declare three coordinates ❸, listed in longitude, latitude, and altitude order. The altitude is optional, but this coordinate may provide interesting data in some cases, showing the gradient of a trail, for example. This data is hard to show on a two-dimensional web map, but remember KML data is used in other ways, such as in Google Earth.    ## Polygons in KML    You may recall that in GeoRSS, as well as Mapstraction, a polygon is simply a line that ends at the same point where it begins. The same is true in KML, though the definition can also get a little more advanced with its description of a shape.    Let's stick with something simple here and continue with the world landmark theme. Consider this bit of KML that describes the outer edges of the Parthenon in Greece:    ``` <Placemark>     <name>Parthenon</name>     <description>A symbol of ancient Greece.</description> ❶   <Polygon> ❷     <outerBoundaryIs> ❸       <LinearRing>         <coordinates>           23.726295,37.971539,0           23.726376,37.971287,0           23.727116,37.971420,0           23.727024,37.971672,0           23.726295,37.971539,0         </coordinates>       </LinearRing>     </outerBoundaryIs>   </Polygon> </Placemark> ```    Notice that inside the polygon declaration ❶ I've include several levels of tags before getting to the familiar coordinates list. The reason for those additional levels is that KML's polygons are much more powerful than this example can communicate.    For example, here I've declared an outer boundary ❷ for the Parthenon, meaning I'm describing the outside walls. If I also use an inner boundary, I can create a rectangular donut to show just the columns of the Parthenon.    Inside a boundary, I use a linear ring ❸ to tell KML that I am creating a line that ends at its starting point. Here KML's polygon begins to look similar to GeoRSS, but with different syntax.    As with the simple line example, the coordinates are a list of longitude, latitude, and altitude (optional) values. We have four corners of the Parthenon to connect, which requires five points. Why not four? The first and the last must be identical—to complete the ring.    Now that you understand basic Placemarks, including lines and polygons, let's see where KML diverges from other geographic data formats: let's get stylish.    ## Style KML    Describing points, lines, and shapes is a basic building block of communicating geography. You can put these three types of data together and get plenty of information about a place. KML also lets you describe how you want the data to look, which separates it from other formats. Read on to learn how to style your KML.    If you know how HTML and CSS interact, KML styles will seem familiar. As with HTML, you can create styles inline or reference them globally with declarations at the top of your KML file.    A style tag is available for each of the three types of geographic data we've seen so far: `<IconStyle>`, `<LineStyle>`, and `<PolyStyle>`. Within the tag, you can declare an icon graphic, color, line width, and opacity. Here's an example of styles added inside the Eiffel Tower Placemark:    ``` <Style>   <IconStyle>     <Icon>       <href>http://mapscripting.com/icons/modernmonument.png</href>     </Icon>   </IconStyle> </Style> ```    This code is the KML equivalent of [#5: Create a Custom Icon Marker](ch02s05.html \"#5: Create a Custom Icon Marker\") in [#4: Show and Hide Message Boxes Without Clicking the Marker](ch02s04.html \"#4: Show and Hide Message Boxes Without Clicking the Marker\"). However, if you have a document with many points, you could end up with a lot of redundancy if most points share the same marker graphic, which makes declaring styles at the top of the code useful.    You can move the entire `<Style>` block up, as an immediate child of the `<Document>` tag. Then, if you give the tag an `id` attribute, you can reference it below. For example, here is the Parthenon example filled in with white:    ``` <?xml version=\"1.0\" encoding=\"UTF-8\"?>   <kml >   <Document>     `<Style id=\"stoneBuilding\">`       `<LineStyle>` ❶       `<color>cccccc</color>`       `</LineStyle>`       `<PolyStyle>`         `<color>ffffff</color>`         `<fill>1</fill>` ❷       `<outline>1</outline>`       `</PolyStyle>`     `</Style>`     <Placemark>       <name>Parthenon</name>       <description>A symbol of ancient Greece.</description> ❸     `<styleUrl>#stoneBuilding</styleUrl>`       <Polygon>         <outerBoundaryIs>           <LinearRing>             <coordinates>               23.726295,37.971539,0               23.726376,37.971287,0               23.727116,37.971420,0               23.727024,37.971672,0               23.726295,37.971539,0             </coordinates>           </LinearRing>         </outerBoundaryIs>       </Polygon>     </Placemark>   </Document>   </kml> ```    The portion of the KML that produces the style is in bold. As you can see, most of the styling is already declared by the time we get to the Placemark. Along with the white-shaded polygon, I add a `LineStyle` to give it a light gray outline ❶. Then, I also make sure the `PolyStyle` has outlines turned on ❷ via the boolean (`1` is on; `0` is off).    Finally, we reference the styles ❸ from the Placemark itself. This reference is created much like a reference to an `id` within CSS, by prepending a `#` in front of the style `id`.    ## Display KML on a Map    With your KML file on the Web, you can display it on a map in many ways. Earlier, I showed how you can use the Google Maps website to show KML. You can also open it in Google Earth. In this section, we'll see instead how to layer a KML file into your embedded map using Mapstraction.    Start with a brand-new HTML file and add the following code:    ``` <html >     <head>       <title>Example KML Map</title>       <script src=\"*`http://maps.google.com/maps/api/js?sensor=false`*\"  type=\"text/javascript\"></script>       <script src=\"mxn.js?(googlev3)\"></script>       <style>       div#mymap {         width: 550px;         height: 450px;       }       </style>       <script type=\"text/javascript\">       var mapstraction;       function create_map() {         mapstraction = new Mapstraction('mymap', 'google');         `mapstraction.addOverlay(` ❶         `\"http://mapscripting.com/example.kml\",` ❷`true`);       }       </script>     </head>     <body onload=\"create_map()\">       <div id=\"mymap\"></div>     </body>   </html> ```    Most of this is a pretty basic map. The part that loads the KML file is in bold. Just like for the GeoRSS, we use Mapstraction's `addOverlay` function. The first argument is the KML URL ❶. As I've mentioned, this address needs to be available on the public Web, not on your local computer or a password-protected development server. The reason the feed has to be accessible is the underlying mapping provider will make an Ajax call to load the feed. This call won't work if the provider can't access the URL. If you don't have your own feed, you can use my example from the companion website.    The second argument ❷, which is optional, is a boolean, meaning the value is either `true` or `false`. This controls whether the map is auto-centered and zoomed in to show only the KML content.    Load this HTML into your browser and you should see the KML content on your map. If you're using my example, you'll see a polyline surrounding the Parthenon.    # #56: Use GPX    Are you a hiker, a runner, or a mountain biker? You could use the GPS exchange format, GPX, to track your favorite trails and routes. Most modern GPS devices, which use satellites to triangulate their location, can store this data and output it in GPX format. Even if the data did not originate on a GPS device, this format is useful for sharing any sequence of latitude and longitude points.    GPX really is just another way to store *polylines*, a series of coordinates to connect on a map. Where the format is different is that it also contains useful metadata to make more sense of the dozens of points.    GPX is separated into three types of data:     | **Tracks** A record of a particular trip, including the time at each step | | **Routes** A suggested trip meant to be shared with others, which does not include time information | | **Waypoints** A single point, often used for landmarks or other points of interest |    From a technical standpoint, GPX is just XML. Its schema is special, however, and elements are declared in a specific way. Here is an example GPX file:    ``` ❶ <?xml version=\"1.0\" encoding=\"UTF-8\"?> ❷ <gpx version=\"1.0\" xmlns:xsi=\"http://www.w3.org/2001 /XMLSchema-instance\" xmlns=\"http://   www.topografix.com/GPX/1/0\" xsi:schemaLocation=\"http://www.to pografix.com/GPX/1/0 http://www   .topografix.com/GPX/1/0/gpx.xsd\">      <trk>       <name>Dog Walk</name> ❸     <trkseg> ❹       <trkpt lat=\"45.521270\" lon=\"-122.626111\"> ❺         <ele>7.125</ele> ❻         <time>2010-09-06T00:14:34Z</time>         </trkpt>         <trkpt lat=\"45.521292\" lon=\"-122.625950\">           <ele>6.831</ele>           <time>2010-09-06T00:14:37Z</time>         </trkpt>         ...       </trkseg>     </trk>    </gpx> ```    Most XML files begin in a similar way ❶ to show they contain XML. Then the code points to the GPX schema ❷. With the formalities out of the way, let's dive into the actual data.    This example is showing a track, so we begin by wrapping everything in a `<trk>` tag. A track has at least one segment ❸, which contains the individual track points ❹. The latitude and longitude are stored as attributes of the `<trkpt>` tag, with the elevation ❺ and timestamp ❻ as subelements.    A program going through the track points uses differences in the latitude and longitude to determine the distance between points. Similarly, the number of seconds or minutes between timestamps can be used to determine the approximate speed. The elevation numbers can determine the trail's grade. We can learn a lot from the metadata.    ## Examples of GPX    In addition to trail enthusiasts plotting and sharing their escapades, GPX has other even more useful applications. GPX is bringing geographic data that wasn't included before to rich content like photos and video. A world of volunteer cartographers also use it to map streets and cities.    Walking around snapping shots is something most photographers do with regularity, whether hiking through nature or walking urban streets. By synchronizing the internal times on a GPS and camera, you can get latitude and longitude coordinates for your photos.    Digital cameras usually timestamp each photo. If you have a record of a path, like the one stored in a GPX file, cross-referencing the two is straightforward. Just find the track point with a timestamp closest to the photo's. Update the photo metadata to include the coordinates, and you have now geo-tagged the photo. You can install many programs on your computer that will do this for you.    OpenStreetMap uses GPX to map the world. It sends volunteers to walk the streets with GPS units. Then, the track points, along with other information like street names, are used to create maps that are available for anyone—without licensing fees.    In many countries, such as the United States, much of this street data is already available. OpenStreetMap volunteers, in these cases, are checking accuracy and filling in what's missing. In some places, OpenStreetMap is all there is, so the GPX tracks become incredibly important to the project.    ## Display GPX Tracks on a Map    Once you have a GPX file, you'll want to do something with it, like show it on a map. Getting at the track points requires parsing the XML and then \"connecting the dots\" with polylines in Mapstraction.    XML parsing can be painful. I discussed it in detail in the earlier in this chapter. We'll use the jQuery method here, which is as easy as it gets, but it does require a small JavaScript library.    To start, let's lay the groundwork for the GPX map by preparing the basic HTML, CSS, and JavaScript to display a simple map. Put this code into a new HTML file:    ``` <html >   <head>     <title>GPX on a Map</title>     <script src=\"*`http://maps.google.com/maps/api/js?sensor=false`*\"  type=\"text/javascript\"></script> ❶   <script src=\"http://ajax.googleapis.com/ajax/libs/ jquery/1.3/jquery.min.js\"></script>     <script src=\"mxn.js?(googlev3)\"></script>     <style>       div#mymap {         width: 600px;         height: 450px;       }     </style>     <script type=\"text/javascript\">     var mapstraction;     function create_map() {       mapstraction = new Mapstraction('mymap', 'google'); ❷     mapstraction.setCenterAndZoom(new LatLonPoint(0,0), 2);       mapstraction.addControls({\"zoom\": \"large\"}); ❸     parse_gpx(\"gpxfile.gpx\");     }     </script>   </head>   <body onload=\"create_map()\">     <div id=\"mymap\"></div>   </body>   </html> ```    We haven't quite parsed the GPX yet. This code just prepares a basic map. Make sure you include your Google Maps API key. Otherwise, everything is ready to go. Before moving on, however, I'd like to point out a few bits.    First, I've included the jQuery JavaScript framework ❶. We'll use it for the Ajax call that will download the GPX file. Also, jQuery makes XML parsing easier, so we'll use it to get at the GPX data.    The eventual location for the map will be determined by the latitude and longitude values inside the GPX file. Because we don't know what those are yet, I centered the map in the middle of the globe ❷. Assuming we're able to load data, that location will only stay for a short time. If you know what city the data will be in, a good practice is to use the coordinates of the city center.    Finally, I make a call to the `parse_gpx` function ❸, passing a filename. Make sure *gpxfile.gpx* exists in the same directory and has some GPX data. You can find example files at [http://mapscripting.com/gpx-files](http://mapscripting.com/gpx-files).    But wait . . . where is the `parse_gpx` function? We haven't added it yet, so let's write it! Add these lines below the `create_map` function:    ``` function parse_gpx(filename) { ❶   jQuery.get(filename, {}, function(xmltxt) {       var pdata = {\"color\": \"blue\"};       var pts = []; ❷     jQuery(\"trkpt\", xmltxt).each(function(i) {         var lat = ❸parseFloat($(this).attr(\"lat\"));         var lon = parseFloat($(this).attr(\"lon\")); ❹       var thispt = new LatLonPoint(lat, lon); ❺       pts.push(thispt);       }); ❻     mapstraction.addPolylineWithData(new Polyline(pts, pdata)); ❼     mapstraction.autoCenterAndZoom();     });   } ```    The `parse_gpx` function is really just a wrapper for the jQuery Ajax call ❶. It grabs the passed filename and returns the XML results to an anonymous, inline function. This is where the real stuff happens. You can see how one of my GPX files looks when added to the map in [Figure 8-1](ch08s05.html#example_gpx_tracks_from_a_walk_in_the_pa \"Figure 8-1. Example GPX tracks from a walk in the park\").  ![Example GPX tracks from a walk in the park](httpatomoreillycomsourcenostarchimages672079.png.jpg)  Figure 8-1. Example GPX tracks from a walk in the park    After creating a few variables, the function uses jQuery to look for every `<trkpt>` in the GPX file ❷. For each track point, it calls yet another anonymous function, which is sort of equivalent to a `for` loop. Each time through the loop, the function parses the latitude and longitude of the current track point.    The `parseFloat` JavaScript function ❸ takes the text from the GPX file and turns it into the decimal number (also called a *floating point number*) needed. Again, the function uses jQuery to parse the GPX, but it uses the shorthand dollar sign method.    Before we draw the track on the map, we need to have all the data points to pass to Mapstraction at the same time, as shown in [#16: Draw Lines on a Map](ch04.html#number_symble_16_colon_draw_lines_on \"#16: Draw Lines on a Map\") in [#16: Draw Lines on a Map](ch04.html#number_symble_16_colon_draw_lines_on \"#16: Draw Lines on a Map\"). We'll use an array to collect the points. Once we have the latitude and longitude of the current track point, we create a `LatLonPoint` with the two values ❹. Then we add the point to the `pts` array ❺.    Once we're outside the loop, we pass our data to draw the Polyline ❻ and then zoom the map automatically to show our entire Polyline ❼. Now we have, in the case of most tracks, a tight view of the GPX data.    # #57: Convert from XML to JSON    As I've mentioned, XML is not always the easiest format to use with JavaScript. Yet, as this chapter has shown, most of the formats you'll be working with are flavors of XML. By now you probably prefer JSON, right? To make things easier on the JavaScript, we'll need to do a little extra work and convert from XML to JSON.    A number of ways are available for getting our data from XML to JSON. And really, the conversion is not that difficult an operation. For example, once we load either XML or JSON into PHP, the data is very similar. In this section, I'll show how you can convert on your own server and also introduce you to a nifty service from Yahoo! called Pipes.    ## Convert Using PHP    Most Unix or Linux servers have a copy of PHP already running, which makes it a great server-side language to learn. We'll use PHP to read in and parse some XML and then turn around and encode it into JSON. The whole process takes just a few lines, thanks to helper functions included in PHP 5.    Even if you don't have a server, or PHP is not accessible, you can likely install it on your own machine. For a more in-depth discussion of PHP, you'll want to check out [Chapter 9](ch09.html \"Chapter 9. GO SERVER-SIDE\").    To start converting, create a new PHP file and add these lines:    ``` <?   $xmltxt = ❶get_url(\"http://mapscripting.com/example.xml\"); ❷ $xmlobj = simplexml_load_string($xmltxt);   $jtxt = ❸json_encode($xmlobj);   print $jtxt;   ?> ```    Like I said, this code isn't very complicated, is it? To get the XML text, I use a helper function ❶ I wrote, which is explained in [#61: Retrieve a Web Page](ch09s03.html \"#61: Retrieve a Web Page\") in [#61: Retrieve a Web Page](ch09s03.html \"#61: Retrieve a Web Page\"). You could also read in the file directly, as we did when parsing XML with PHP.    Once we have the XML text, we convert it first to a PHP object ❷. This parses the hierarchy of the XML file into a format PHP can understand directly. Because JSON is so close to data structures found within PHP, a simple call ❸ is all that's needed to encode the JSON. Then we print it and voilà —we have converted data formats.    ## Convert Using Yahoo! Pipes    Don't have server-side chops, or just don't want to deal with additional code? Many folks are turning to a service from Yahoo! called Pipes. Pipes reads in various data formats, lets you massage the data if you want, and then outputs it as either XML or JSON.    Why use Yahoo! Pipes instead of your own server? For one, the conversion process is even easier than using PHP. Plus, no code is required because Pipes has a graphical, drag-and-drop interface. You also get the benefit of Yahoo!'s infrastructure. Yahoo! decides how often to check for new content and deals with caching the most recent copy—something we didn't do at all in the PHP example.    The downside to relying on Pipes? It introduces another point of failure. Even if your server is humming along, your map might not work if Pipes crashes. Although you can likely count on Yahoo! for uptime, what if the company decides the Pipes product isn't worth keeping around? You'd be hung out to dry.    To me, the ease of using Pipes outweighs the detractions. Let's see just how easy converting from XML to JSON with Pipes is.    You'll need a Yahoo! account to store your Pipes. Log in at [http://pipes.yahoo.com/pipes](http://pipes.yahoo.com/pipes) and click **Create a Pipe** to go to a blank canvas, with options on the left. First, Pipes requires a data source, so drag a Fetch Feed source on to the canvas. Paste your feed URL into the box, or use [http://mapscripting.com/example.xml](http://mapscripting.com/example.xml).    Now a second box called Pipe Output should also appear at the bottom of the workspace. Drag the circle at the bottom of the Fetch Feed box to the circle at the top of the Pipe Output. This connects the elements to create a complete Pipe, as shown in [Figure 8-2](ch08s06.html#yahoo_exclamation_pipes_feed_connected \"Figure 8-2. Yahoo! Pipes feed connected\"). Go ahead and try it and you should see sample output in the debugger at the bottom of the workspace.  ![Yahoo! Pipes feed connected](httpatomoreillycomsourcenostarchimages672081.png.jpg)  Figure 8-2. Yahoo! Pipes feed connected    Here's where things get really interesting: *You're done*. Save the Pipe, and then click **Run Pipe**. You should see your content within the Pipes interface. At the top of your content, you'll see a Get as JSON link. That's the URL to your converted data run through Yahoo!'s servers. Now you can order new business cards because you're a certified data plumber!    # #58: Filter, Merge, and Sort Data with Yahoo Pipes!    APIs and RSS feeds are becoming commonplace. So much of the Web's content is now available in a format that programmers are quickly able to use, which is great. The downside is that another problem has been created: Getting at just the right information can be tough.    Sometimes a feed is a fire hose when a garden variety hose would do. Other times you have to combine multiple sources before you get the information you really need. Yahoo! Pipes has an easy interface for solving both issues—by filtering and merging data.    Much of this data-munging is stuff programmers have been doing manually using server-side scripts. Sometimes that will still be necessary, but Yahoo! Pipes is able to solve the common scenarios. Plus, for reasons described in the previous project, offloading some of this work onto Yahoo!'s servers provides some major benefits.    Before you create a Pipe, you'll need at least one data source. This source is often an RSS feed and, for map-related projects, may be GeoRSS. A Pipe is a way to transform data sources. The data comes in the Pipe, some stuff happens, and then the data flows out of the Pipe. If you have a data source, then let's start working on that \"stuff\" part. You can begin by editing the Pipe we created in the previous section.    ## Filter Your Feed's Content    Rather than simply running our feed through Pipes, let's try filtering out certain content. To do this, we'll need to drag a Filter box from the Operators menu. You can place the box anywhere in the workspace, but placing it between the Fetch box and the Output box may make the most sense.    Next, you'll need to connect the feed to the filter. Drag the circle at the bottom of the Fetch box to the top of the Filter box. Then connect the Filter box to the Pipe Output by dragging the filter's bottom circle to the output's top circle.    Of course, the filter isn't useful unless it's actually filtering some content. You can do this two ways with Pipes: You can filter *in* or filter *out*. At the top of the Filter box, you can select **Block** to filter out and **Allow** to filter in.    Pipes can filter based on any fields in the feed. A common choice is the title, which, for RSS, is *item.title*. Click the arrow next to the first text area in the filter box (see [Figure 8-3](ch08s07.html#filtering_out_items_with_map_in_the_titl \"Figure 8-3. Filtering out items with map in the title\")) and you'll see a list of available fields. Then you can type the words you want to filter in the second text field. The drop-down box lets you perform some basic types of filtering on the field, including greater-than/less-than for numbers.  ![Filtering out items with map in the title](httpatomoreillycomsourcenostarchimages672083.png.jpg)  Figure 8-3. Filtering out items with *map* in the title    If you want additional filters, just click the plus sign next to Rules. Otherwise, your Pipe is complete. Save it, and then click **Run Pipe**. Your filtered feed will be shown within the Pipes interface. To get this new feed, choose **Get as RSS** or **Get as JSON**. If you are reading the feed in to use with JavaScript, JSON is probably your best choice.    ## Merge Two or More Feeds    What if you have two similar feeds that you want to combine? Pipes is very good at this! Create a new Pipe and drag two Fetch Feed boxes to the canvas (see [Figure 8-4](ch08s07.html#merging_and_sorting_two_feeds_with_yahoo \"Figure 8-4. Merging and sorting two feeds with Yahoo! Pipes\")). Choose two feeds (if you're short of examples, you should be able to find an RSS feed from your favorite blogs or websites) and insert their URLs into the Fetch Feed boxes.  ![Merging and sorting two feeds with Yahoo! Pipes](httpatomoreillycomsourcenostarchimages672085.png.jpg)  Figure 8-4. Merging and sorting two feeds with Yahoo! Pipes    If the feeds are of the same variety and you don't plan to filter anything, you can actually use a single Fetch Feed box. Just click the plus sign next to URL. In many cases, you'll want to have the option to perform more advanced operations, so I recommend using a Fetch Feed for each individual feed.    To combine the two feeds, we'll need a Union box from the Operators menu. Drag the Union box to the canvas below the two Fetch Feed boxes. Drag the circle below each feed to one of the five circles at the top of the Union box. Finally, drag the circle at the bottom of the Union box to the Pipe Output.    Your feeds are combined in the order they were added to the Union box (left to right). In other words, the second feed's content is only seen after the entire contents of the first feed. This arrangement is not ideal. Most likely, you usually want to see the content in the order it was published. Pipes can do the sorting for you.    Drag a Sort operator to the canvas. Connect the bottom circle of the Union box to the top of the Sort box. Then connect the bottom of the Sort box to the Pipe Output. You'll need to choose a field to sort by clicking the arrow next to the text field within the Sort box. To use the date, select **item.pubDate**. Now save the Pipe and you're done.    You've now filtered, merged, and sorted with Yahoo! Pipes. You can transform data into whatever you want it to be. In fact, if you dig through the documentation a bit ([http://pipes.yahoo.com/pipes/](http://pipes.yahoo.com/pipes/)), you'll realize Pipes is even more powerful than the few examples I've shown. You can load feeds dynamically, use web services, and even extract location from text. Best of all, when you're done, the data is in a format that is easy to read in and plot on a map.```` `````"]