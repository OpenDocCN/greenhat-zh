- en: Part III. THE SHAPE OF CODE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分。代码的形状
- en: Unlike a fine wine, your code is not likely to get any better the longer you
    leave it. If it starts like a small pile of something that the dog produced, then
    it will no doubt end up like a large pile of something an elephant produced.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与美酒不同，你的代码不太可能随着时间的推移而变得更好。如果它开始像狗产下的一小堆东西，那么它无疑会变成大象产下的一大堆东西。
- en: 'This is no secret, yet software factories continually churn out elephantine
    creations and then suffer the consequences. Their products are neither adaptable,
    extensible, or malleable enough to suit their future requirements, nor easy enough
    to develop: They fail to deliver on time and to budget. As programmers, this hurts
    our pride—but it hurts managers'' wallets, hard.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是秘密，然而软件工厂不断地生产出庞大的作品，然后承受后果。他们的产品既不适应，也不可扩展，也不够灵活，以满足未来的需求，也不容易开发：他们无法按时按预算交付。作为程序员，这伤害了我们的自尊——但它伤害了管理者的钱包，更严重。
- en: The answer? One solution is to never attempt code development in the first place,
    but that's hardly practical. The other is to develop code with a view to the entire
    system's structure. Good code doesn't happen by accident; it is the product of
    careful crafting, with much emphasis placed on prior planning and design. But
    it also stems from a nimble development approach, from being agile enough to cope
    with the inevitable problems and changes that you'll encounter en route.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 答案？一个解决方案是根本不尝试代码开发，但这几乎不切实际。另一个解决方案是以整个系统的结构为视角来开发代码。优秀的代码不是偶然出现的；它是精心制作的结果，强调前期规划和设计。但这也源于灵活的开发方法，足够敏捷以应对途中不可避免的困难和变化。
- en: 'This section explores this process. We''ll look at:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了这一过程。我们将查看：
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。宏伟设计")'
- en: 'Code micro design: low-level construction tips for individual code modules.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代码微观设计：针对单个代码模块的低级构建技巧。
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。软件架构")'
- en: Larger-scale system design—the first construction stage of any software development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大规模系统设计——任何软件开发的第一步构建阶段。
- en: '[Chapter 15](ch15.html "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章](ch15.html "第15章。软件进化或软件革命？")'
- en: A look at how software grows and expands over time, with some practical suggestions
    for grafting new work into an old codebase.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看软件随着时间的推移如何增长和扩展，以及一些将新工作整合到旧代码库中的实用建议。
- en: These are not optional extras or nice-to-haves. They are essential stages of
    our craft and are therefore crucial to the production of quality software. Ignore
    this stuff at your peril.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是可选的额外内容或美好的愿望。它们是我们工艺的必要阶段，因此对于高质量软件的生产至关重要。忽视这些内容将带来危险。
- en: Chapter 13. GRAND DESIGNS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。宏伟设计
- en: '*How to Produce Good Software Designs*'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*如何制作优秀的软件设计*'
- en: A camel is a horse designed by committee.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 骆驼是委员会设计的马。
- en: --Sir Alec Issigonis
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: --艾略特·艾萨克尼斯爵士
- en: Some code just makes you sigh.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有些代码只会让你叹息。
- en: I once had to write a device driver for an embedded product. The driver's interface
    to the OS was quite complex. The interface to the hardware I was using was also
    complex. To keep myself sane, I split the code into two sections. The first was
    an internal library that accessed the hardware, performed some data buffering,
    and provided a simple API to access that buffered data. Then I wrote a second,
    distinct layer that implemented the finicky OS driver interface in terms of this
    internal library. The structure of the device driver looked like [Figure 13-1](ch13.html#petes_sane_software_design
    "Figure 13-1. Pete's sane software design").
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经不得不为嵌入式产品编写一个设备驱动程序。该驱动程序与操作系统的接口相当复杂。我使用的硬件接口也很复杂。为了保持理智，我将代码分为两个部分。第一部分是一个内部库，它访问硬件，执行一些数据缓冲，并提供一个简单的API来访问这些缓冲数据。然后我编写了第二个，独立的层，它根据这个内部库实现了挑剔的操作系统的驱动程序接口。设备驱动程序的结构看起来像[图13-1](ch13.html#petes_sane_software_design
    "图13-1。皮特的理智软件设计")。
- en: Later, the manufacturer of the hardware sent me a sample implementation of the
    same device driver. The author of this code had clearly not thought it out at
    all. The code was a sprawling mess, tightly intermingling the complex OS interface
    with the hardware logic in a completely incomprehensible manner. An approximation
    of its structure is shown in [Figure 13-2](ch13.html#how_not_to_design_software
    "Figure 13-2. How not to design software").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，硬件制造商给我发送了同一设备驱动程序的样本实现。这段代码的作者显然没有仔细思考。代码混乱不堪，将复杂的操作系统接口与硬件逻辑以完全无法理解的方式紧密交织在一起。其结构近似如图[图13-2](ch13.html#how_not_to_design_software
    "图13-2. 如何不设计软件")所示。
- en: '![Pete''s sane software design](tagoreillycom20080909nostarchimages207482.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![皮特的理智软件设计](tagoreillycom20080909nostarchimages207482.png)'
- en: '**Figure 13-1. Pete''s sane software design**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13-1. 皮特的理智软件设计**'
- en: '![How not to design software](tagoreillycom20080909nostarchimages207484.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何不设计软件](tagoreillycom20080909nostarchimages207484.png)'
- en: '**Figure 13-2. How not to design software**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13-2. 如何不设计软件**'
- en: Now, I'm not trying to toot my own horn (any more than is necessary, anyway).
    The point of this illustration is clear. The first design is better. It is easier
    to understand because it's so straightforward, it is easier to implement, and
    consequently it is easier to maintain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我并不是在吹嘘自己（至少不是过分吹嘘）。这个例子的目的是明确的。第一个设计更好。它更容易理解，因为它非常直接，它更容易实现，因此也更容易维护。
- en: 'C.A.R. Hoare wrote, "There are two ways of constructing a software design:
    One way is to make it so simple that there are *obviously* no deficiencies, and
    the other way is to make it so complicated that there are no *obvious* deficiencies.
    The first method is far more difficult." (Hoare 81)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: C.A.R. Hoare写道：“构建软件设计有两种方法：一种方法是将它做得如此简单，以至于显然没有缺陷，另一种方法是将它做得如此复杂，以至于没有明显的缺陷。第一种方法要困难得多。”（霍尔81页）
- en: One of the signs of a mature programmer is the design quality of his or her
    code. In this chapter, we'll look at what constitutes a good design and investigate
    how to craft high-quality software designs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟程序员的标志之一是其代码的设计质量。在本章中，我们将探讨构成良好设计的内容，并研究如何制作高质量的软件设计。
- en: Programming as Design
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程即设计
- en: It's a popular belief that "design" is a stage you complete before moving on
    to writing code. Its product is some form of *design specification*, which is
    sufficient for a generic code monkey to implement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍认为，“设计”是在编写代码之前完成的一个阶段。它的产品是某种形式的**设计规范**，这对于一个通用的代码猴子来说足够了。
- en: The truth is very different. Programming—the act of writing code—is a *design
    activity*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实却大相径庭。编程——编写代码的行为——是一种**设计活动**。
- en: Even the most detailed specification has holes, or else it would *be* the code—you
    can't describe every minuscule detail in a design document. The act of programming
    verifies the initial design decisions and performs the remaining design work.
    It exposes holes, inconsistencies, and errors and allows you to find a route around
    them. "Some programmers don't think they're doing design when they program, but
    whenever you write code, you're always doing design, either explicitly or implicitly."
    (Page Jones 96)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最详细的规范也有漏洞，否则它就会**是**代码——你无法在设计文档中描述每一个微小的细节。编程行为验证了最初的设计决策，并执行剩余的设计工作。它揭示了漏洞、不一致性和错误，并允许你找到绕过它们的方法。“有些程序员在编程时认为自己没有在做设计，但无论何时你编写代码，你总是在做设计，无论是明确还是隐含。”（琼斯96页）
- en: '**KEY CONCEPT**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Programming is a design activity. It''s a creative and artistic act, not mechanical
    code generation*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程是一种设计活动。它是一种创造性和艺术性的行为，而不是机械的代码生成*。'
- en: 'A good development process recognizes this and doesn''t shy away from writing
    code when it''s appropriate. Practitioners of Extreme Programming advocate that
    design *is* the code. (Beck 99) There is no separate design activity; there is
    no team of designers. It''s the programmers who constantly refine and extend the
    design by refining and extending the code. This is enshrined in their *test-driven
    design* approach: Code tests are written before any code, as a design verification
    tool. This is a wise idea.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的开发过程会认识到这一点，并在适当的时候不会回避编写代码。极限编程的实践者主张**设计就是代码**。没有独立的设计活动；没有设计团队。是程序员通过不断优化和扩展代码来不断优化和扩展设计。这在他们的**测试驱动设计**方法中得到体现：在编写任何代码之前，编写代码测试作为设计验证工具。这是一个明智的想法。
- en: Does this mean that you don't need to think before starting to hack at code?
    Not at all! Deep inside a text editor is not the place to plan what you're writing.
    That's like trying to drive from Berlin to Rome without deciding a route first.
    You'll end up in Moscow before you've worked out which way is north. By definition,
    design is something you do *first*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着在开始编写代码之前不需要思考？当然不是！在文本编辑器的深处不是规划你要写什么的地方。这就像在没有决定路线的情况下试图从柏林开车去罗马。在你确定哪个方向是北方之前，你可能会到达莫斯科。按照定义，设计是你首先做的事情。
- en: '**KEY CONCEPT**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Think before you type; establish a coherent design. Otherwise you''ll end
    up with chaotic code*.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*在输入之前先思考；建立一个连贯的设计。否则，你最终会得到混乱的代码*。'
- en: What Do We Design?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要设计什么？
- en: Programmers design code structures, obviously. But this means different things
    at different stages of the development process. At each stage, design is a process
    of decomposing the task into its constituent parts and figuring out how each part
    works.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员设计代码结构，这是显而易见的。但在开发过程的各个阶段，这意味着不同的事情。在每一个阶段，设计都是一个将任务分解为其组成部分的过程，并弄清楚每个部分如何工作。
- en: 'These levels of software design are:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些软件设计的级别包括：
- en: '**The system architecture**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统架构**'
- en: Here we look at the system as a whole, identify the main subsystems, and work
    out how they communicate. The architectural design has the most influence on the
    performance and characteristics of the system *as a whole* and the least impact
    on specific lines of code. It is the most important design act and is covered
    in the next chapter. In this chapter, we're concerned with the internal design
    of code, which involves the subsequent design levels.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将系统作为一个整体来审视，识别主要子系统，并确定它们如何进行通信。架构设计对系统的整体性能和特性影响最大，对特定代码行的影响最小。这是最重要的设计活动，将在下一章中介绍。在这一章中，我们关注代码的内部设计，这涉及到后续的设计级别。
- en: '**Modules/components**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块/组件**'
- en: The architectural subsystems are usually too large to directly implement in
    code, so the next step is to break each one down into comprehensible modules.
    It's very easy to be vague about design at the module level. In some ways, a "module"
    does not really exist. *Module* may mean something different depending on the
    design approach; it might be a logical clump of code, perhaps some physical unit
    like a Java package, C++/C# namespace, or a reusable library. It might be a class
    hierarchy or maybe even a free-standing executable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 架构子系统通常太大，无法直接在代码中实现，因此下一步是将每个子系统分解成可理解的模块。在模块级别进行设计时，很容易变得模糊不清。在某种程度上，“模块”实际上并不存在。“模块”可能根据设计方法的不同而具有不同的含义；它可能是一团逻辑代码，可能是一些物理单元，如Java包、C++/C#命名空间或可重用库。它可能是一个类层次结构，甚至可能是一个独立的可执行文件。
- en: This design stage often produces published interfaces. These can't be easily
    changed later on, since they form strict contracts between code modules and between
    the teams of programmers writing them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计阶段通常会生成已发布的接口。这些接口在以后很难更改，因为它们在代码模块和编写它们的程序员团队之间形成了严格的契约。
- en: '**Classes and data types**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**类和数据类型**'
- en: Next, we break a module into bite-sized chunks. Interface design tends to be
    less formal and easier to change behind the module. The tendency is to do this
    micro design at the keyboard. This urge should be resisted, or else you'll write
    the first code that comes into your head, not the best code for the problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将模块分解成小块。界面设计通常较为非正式，并且更容易在模块之后进行更改。这种在键盘上进行的微观设计趋势应该被抵制，否则你可能会写下头脑中第一个出现的代码，而不是最适合该问题的代码。
- en: '**Functions**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: 'This may be the lowest design level in the food chain, but it''s of no less
    importance. A program is built from routines: If the routines are poorly designed,
    then the entire system will suffer. After having established exactly which functions
    are required, we design how they work internally, how the flow of control is routed,
    and which algorithms are used.^([[1](#ftn.CHP-13-FN-1)]) This is usually a mental
    exercise rather than a documented procedure, but a diligent design is essential.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是食物链中的最低设计级别，但它的作用并不小。程序是由例程构建的：如果例程设计得不好，那么整个系统都会受到影响。在确切地确定了需要哪些函数之后，我们设计它们内部的工作方式，控制流的路由方式，以及使用的算法。[1](#ftn.CHP-13-FN-1)]
    这通常是一种心理练习，而不是一种记录的程序，但勤奋的设计是必不可少的。
- en: '* * *'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-13-FN-1)]) Key algorithms will often span multiple functions; they'll
    be determined at the module design stage.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-13-FN-1)]) 关键算法通常会跨越多个函数；它们将在模块设计阶段确定。
- en: What's All the Fuss About?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You won't find anyone arguing *for* bad design, but nonetheless, there's a lot
    of badly designed code out there. After a few years on the front line, any developer
    has the scars to prove it. (Battle-hardened veterans are already nodding their
    heads and mentally rehearsing their war stories.) But why is this the case?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Sloppy design can be the product of inexperienced programmers, but more often
    it is caused by the commercial pressures of the software factory squeezing out
    any time that might have been spent on good design. No one listens to the poor,
    protesting coders. Programming in the Real World is necessarily bound by the drive
    to ship software—any software—on time. The irony is that in almost every case,
    a lack of a good design ultimately costs more than doing it properly would have.
    As they say, "There's never time to do it right, but there's always time to do
    it twice."
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Getting design right is really *very* important. The design of your code is
    the foundation upon which it is built. If it's wrong, then the code will be unstable,
    unsafe, and not fit for purpose—dangerous. A bad design foundation leads to the
    software equivalent of the Leaning Tower of Pisa. While novel that it manages
    to stand up under the strain of real use, it will never be as good as it ought
    to be, and in time this inevitably shows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'A sound design makes code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Easier to write (there's a well-defined plan of attack, and it's clear how it's
    all going to fit together)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to understand
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to fix (you can identify the location of problems)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less likely to harbor bugs (program errors are not hidden behind mystifying
    design problems)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More resilient to change (the design will encourage extensions and accommodate
    modification)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good Software Design
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any programming problem, there will be *many* potential code designs. Your
    job is to find one. The best one. Or at least a sufficiently good one. It's not
    an easy task. . . .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: How do you know that your design will work? After completing a bulletproof plan
    of attack, you confidently begin implementing it. Later, an unexpected problem
    will show its ugly head. Back to the drawing board.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you know when your design is finished? You can't know until you've actually
    implemented it and found that it works. Many issues can't be fore-guessed; you
    have to step out, implement the design, and see whether or not it's complete.
    It's only by attempting a solution that you even *begin* to understand the original
    problem. Armed with this new knowledge, you can then try to solve it again properly.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you know it's the *best* design solution for the problem? You can't tell
    unless you try out every possibility. This isn't practical. Instead, how do you
    know it's good *enough*? If performance is a requirement, you won't really know
    until the system *is* performing.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best design approaches address these problems. They are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Avoid too many nasty surprises by doing a small amount of design, implementing
    it, assessing the implications, and feeding this into to the next design round.
    This incremental construction approach is very powerful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行少量设计、实施它、评估其影响，并将这些反馈到下一轮设计中，可以避免太多令人不快的惊喜。这种增量构建方法非常强大。
- en: '**Cautious**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**谨慎**'
- en: Don't try to design too much at once. If something fails, it might be because
    of any number of design decisions. Limit the room for failure, and you'll find
    it easier to progress. Small, sure design steps are more likely to succeed than
    large, clumsy ones.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图一次性设计太多。如果某件事失败了，可能是因为任何数量的设计决策。限制失败的空间，你会发现更容易进步。小而确定的设计步骤比大而笨拙的步骤更有可能成功。
- en: '**Realistic**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**现实**'
- en: A prescriptive design process will not work all of the time, every time. The
    outcome depends on the quality of the requirements established, the experience
    of the team, and the rigor with which the process is applied. A pragmatic approach
    takes the best of all methodologies and admits that it relies on the programmers'
    gut feeling—experience has a lot to do with shaping good design.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 指令性的设计流程并不总是每次都有效。结果取决于建立的要求的质量、团队的经验以及流程应用的严谨性。实用方法结合了所有方法的优点，并承认它依赖于程序员的直觉——经验在很大程度上塑造了良好的设计。
- en: '**Informed**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息**'
- en: You must fully understand all requirements and motivating principles to be clear
    about the problem you're solving, and also about the important qualities of the
    right solution. If you don't, you'll solve the wrong problem. You need this information
    to get early design decisions right, and some are hard to reverse.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须完全理解所有需求和激励原则，以便清楚地了解您正在解决的问题，以及正确解决方案的重要品质。如果您不这样做，您可能会解决错误的问题。您需要这些信息来做出早期设计决策，其中一些很难逆转。
- en: Your design approach is inevitably affected by the overall development methodology
    in use (see "[Programming Styles](ch22.html#programming_styles "Programming Styles")"
    on page 420 for a description of these). A good design *process* is a step towards
    creating a good design, but no guarantee. It still comes down to the quality of
    the design *decisions* you make. Different trade-offs lead to different designs.
    A design for speed will differ from design for extensibility, for example. Ultimately,
    there is no *right* or *wrong* design. At best, there are *good* designs and *bad*
    designs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您的设计方法不可避免地会受到正在使用的整体开发方法的影响（有关这些方法的描述，请参阅第420页的“[编程风格](ch22.html#programming_styles
    "编程风格")”）。良好的设计**过程**是创造良好设计的一步，但并非保证。这最终还是取决于你所做出的设计**决策**的质量。不同的权衡会导致不同的设计。例如，针对速度的设计将与针对可扩展性的设计不同。最终，没有**正确**或**错误**的设计。最好的情况是，有**好**的设计和**坏**的设计。
- en: Good designs have a number of attractive characteristics, whose opposites are
    sure indicators of bad design. We'll discuss these next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的设计具有许多吸引人的特征，其对立面是坏设计的明确指标。我们将在下面讨论这些。
- en: Simplicity
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性
- en: This is the single most important characteristic of well-designed code. A simple
    design is easy to understand, has no unnecessary warts or blemishes, and is easy
    to implement. It is coherent and consistent.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是良好设计代码最重要的特征。简单的设计易于理解，没有不必要的瑕疵，易于实现。它是连贯和一致的。
- en: 'Simple code is as small as possible but no smaller. This takes some doing,
    as the mathematician Blaise Pascal appreciated: "I am sorry for the length of
    my letter, but I had not the time to write a short one." Carefully work out how
    *little* code is needed, and then write just that. Remember, you can always add
    more code later for extra functionality, but you can rarely remove something that
    has become intimately entwined.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的代码尽可能小，但不要更小。这需要一些努力，正如数学家布莱士·帕斯卡所欣赏的：“我为信件的长度感到抱歉，但我没有时间写一封简短的信。”仔细计算出所需的代码**最少**是多少，然后只写那么多。记住，您总是可以稍后添加更多代码以实现额外功能，但您很少能移除已经紧密相连的东西。
- en: '**MAKING A TRADE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**做出权衡**'
- en: Software design is a process of making decisions—of decomposing the system into
    its constituent parts, but also balancing the contending forces that pull in different
    directions. There are trade-offs to be made that shape the final design.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计是一个做决策的过程——将系统分解为其组成部分，但也是平衡不同方向拉扯的对抗力量。需要做出权衡，这些权衡塑造了最终的设计。
- en: 'These are common examples of such tightropes and games of tug-of-war:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是此类走钢丝和拔河游戏的常见例子：
- en: '**Extensibility vs. simplicity**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展性与简单性**'
- en: A design for extensibility provides plenty of interface points for future code
    to be plugged into and ensures the scaffolding is sufficiently general to support
    any later requirements. Simplicity avoids the complication of extra levels of
    indirection and needless generality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性的设计提供了足够的接口点，以便未来的代码可以插入，并确保脚手架足够通用，以支持任何后续需求。简单性避免了额外间接层次和不需要的普遍性。
- en: '**Efficiency vs. safety**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**效率与安全**'
- en: Gains in performance often come by sacrificing purity of design—putting in special
    back doors for certain important operations or adding lots of coupling to prevent
    too much indirect access. Highly optimized systems are generally less clear and
    more brittle in the face of change.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 性能的提升通常是通过牺牲设计的纯粹性来实现的——为某些重要操作设置特殊的后门，或者添加大量的耦合以防止过多的间接访问。高度优化的系统通常在面对变化时不太清晰且更脆弱。
- en: Not all efficient designs are bad, though; many good designs naturally perform
    well *because* of their simplicity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有高效的设计都是不好的；许多好的设计自然表现良好，*正是因为*它们的简单性。
- en: '**Features vs. development effort**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能与开发工作量**'
- en: At project initiation, there are a thousand desired features and a reasonable
    idea of when they should be delivered by (tomorrow, if not sooner). Without an
    infinite number of monkeys and their infinite number of PCs, you'll never get
    it all done.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目启动时，有一千个期望的功能和合理的想法，即它们应该在何时交付（如果不在明天，那就更早）。没有无限数量的猴子和他们无限的电脑，你永远无法全部完成。
- en: More features take more time to implement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的功能需要更多的时间来实现。
- en: Which of these characteristics is most important depends on the project requirements.
    That's why it's so important to be clear about them up front.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性中哪一个最重要取决于项目需求。这就是为什么一开始就弄清楚它们如此重要的原因。
- en: Laziness *can* pay off. Work your design so you can defer as much work as possible,
    and only concentrate on the immediate problems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰*可以*带来回报。设计你的设计，以便尽可能推迟工作，并只专注于当前的问题。
- en: '**KEY CONCEPT**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: Less is more. *Strive for simple code that does a lot with a little*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 少即是多。*追求简单但功能强大的代码*。
- en: A simple design is not necessarily easy to create. It takes time. For all but
    the most basic programs, a great deal of information must be sifted through to
    reach a final solution. Well-designed code *looks* obvious, but it probably took
    an awful lot of thought (and a lot of refactoring) to make it that simple.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的设计不一定容易创建。它需要时间。对于除了最基本程序之外的所有程序，必须筛选大量信息才能达到最终解决方案。设计良好的代码*看起来*很明显，但可能需要大量的思考（以及大量的重构）才能使其如此简单。
- en: '**KEY CONCEPT**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*It''s a complicated job to make something simple. If a code structure looks
    obvious, don''t assume that it was easy to design*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*使事物简单是一项复杂的工作。如果一个代码结构看起来很明显，不要假设它设计起来很容易*。'
- en: There are many ways to make a design unnecessarily complex, including incorrect
    component decomposition, the thoughtless proliferation of threads, inappropriate
    choice of algorithms, complex naming schemes, and excessive or inappropriate module
    dependencies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以使设计变得不必要地复杂，包括错误的组件分解、无思考地增加线程、不恰当的算法选择、复杂的命名方案以及过度或不适当的模块依赖。
- en: Elegance
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅
- en: 'Elegance embodies the aesthetic aspects of design and often goes hand in hand
    with simplicity. It means that your code isn''t baroque, confusingly clever, or
    overly complex. Well-designed code has a beauty in its structure. These are desirable
    characteristics:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅体现了设计的审美方面，通常与简单性相辅相成。这意味着你的代码不是巴洛克式的、令人困惑的聪明或过于复杂。设计良好的代码在其结构中具有美感。这些是可取的特性：
- en: Control flowing gracefully around the system. A single operation doesn't pass
    through every module, converting the format of its parameter between 16 different
    representations, before finally ignoring it.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制优雅地环绕系统。一个操作不会通过每个模块，在16种不同的表示形式之间转换其参数格式，最终忽略它。
- en: Each part complements the others, adding something distinct and valuable.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部分都补充了其他部分，增加了独特且有价值的东西。
- en: The design is not riddled with special cases.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计没有充斥着特殊情况。
- en: It associates similar things.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将类似的事物关联起来。
- en: No nasty surprises lurk around the corner.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有令人讨厌的惊喜潜伏在角落里。
- en: 'There is a small locality of change: A single, simple change in one place doesn''t
    lead to modifications of the code in many other places.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个小的变化局部性：在一个地方的单个简单改变不会导致代码在许多其他地方的修改。
- en: Good design has a lot to do with balance and aesthetics. I won't go so far as
    to say programming is art, although some could argue a convincing case for this.
    Elegance and simplicity underpin most of the remaining characteristics in this
    list.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好的设计与平衡和美学有很大关系。我不会走得那么远，以至于说编程是艺术，尽管有些人可能会为这一点提出有说服力的论据。优雅和简单是支撑本列表中大多数剩余特性的基础。
- en: Modularity
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化
- en: As we attack a design problem, we naturally divide it into parts called *modules*
    or *components*. We decompose into subsystems, libraries, packages, classes, and
    so on. Each part is less complex than the original problem, but put together,
    they form a complete solution. The quality of this decomposition is paramount.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解决设计问题时，我们会自然地将它分解成称为*模块*或*组件*的部分。我们将它们分解成子系统、库、包、类等等。每个部分比原始问题更简单，但组合起来，它们形成了一个完整的解决方案。这种分解的质量至关重要。
- en: 'Key qualities of modularity are *cohesion* and *coupling*. We aim for modules
    with:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的关键特性是*内聚*和*耦合*。我们追求具有以下特性的模块：
- en: '**Strong cohesion**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**强内聚**'
- en: '*Cohesion* is a measure of how related functionality is gathered together and
    how well the parts *inside* a module work as a whole. Cohesion is the glue holding
    a module together.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*内聚*是衡量相关功能如何聚集在一起以及模块内部的各个部分如何作为一个整体工作的指标。内聚是使模块粘合在一起的胶水。'
- en: Weakly cohesive modules are a sign of bad decomposition. Each module must have
    a clearly defined role and not be a grab bag of unrelated functionality (like
    the pitifully common `utils` namespace—why *do* people write these things?).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 弱内聚的模块是分解不良的迹象。每个模块都必须有一个明确定义的角色，并且不能是无关功能的杂乱组合（就像可怜的`utils`命名空间那样——人们为什么要写这些？）。
- en: '**Low coupling**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**低耦合**'
- en: '*Coupling* is a measure of the interdependency *between* modules—the amount
    of wiring to and from them. In the simplest designs, modules have little coupling
    and so are less reliant on one another. Obviously, modules can''t be totally decoupled,
    or they wouldn''t be working together at all!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*耦合*是衡量模块之间相互依赖程度的指标——即与它们连接的线路数量。在最简单的设计中，模块之间的耦合很小，因此它们相互依赖性较低。显然，模块不能完全解耦，否则它们根本无法一起工作！'
- en: Modules interconnect in many ways—some direct, some indirect. A module can call
    functions on other modules or be called by other modules. It may use another module's
    data types or share some data (perhaps variables or files). Good software design
    limits the lines of communication to only those absolutely necessary. These communication
    lines are part of what determines the code design.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模块以多种方式相互连接——有些是直接的，有些是间接的。一个模块可以调用其他模块的函数或被其他模块调用。它可能使用另一个模块的数据类型或共享一些数据（可能是变量或文件）。良好的软件设计将通信线路限制在绝对必要的范围内。这些通信线路是决定代码设计的一部分。
- en: 'Once identified, each module can be worked on in isolation and tested separately.
    This is an advantage of modularity; it allows you to split tasks between programmers.
    Take care, though; Conway''s Law warns that software structure may follow team
    structure: "If you have four teams working together to build a compiler, it will
    become a four-pass compiler" (see "[Organization and Code Structure](ch17s02.html#organization_and_code_structure
    "Organization and Code Structure")" on page 320). Make sure the decomposition
    is sensible and based on the problem, not the team organization.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别出来，每个模块都可以独立工作并单独测试。这是模块化的一个优点；它允许你将任务分配给程序员。不过要小心；康威定律警告说软件结构可能会遵循团队结构：“如果你有四个团队一起构建一个编译器，它将变成一个四遍编译器”（参见第320页的“[组织和代码结构](ch17s02.html#organization_and_code_structure
    "组织和代码结构")”）。确保分解是合理的，并且基于问题，而不是团队组织。
- en: '**KEY CONCEPT**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Design modules that are internally cohesive with minimal coupling. The decomposition
    must represent a valid partition of the problem space*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计内部内聚且耦合度最小的模块。分解必须代表问题空间的有效划分*。'
- en: Good Interfaces
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的接口
- en: Modules help us separate concerns and partition the problem. Each module defines
    an *interface*, the public façade behind which it hides an internal implementation.
    This set of available operations is often called an *application programming interface
    (API)*. It is the sole route to a module's functionality, and its quality determines
    the quality of that module, at least as seen from the outside.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模块帮助我们分离关注点并划分问题。每个模块定义了一个*接口*，这是它隐藏内部实现的公共外观。这个可用的操作集通常被称为*应用程序编程接口（API）*。它是访问模块功能的主要途径，其质量决定了该模块的质量，至少从外部看是这样。
- en: '**KEY CONCEPT**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Draw lines in the sand that people don''t need to cross: Identify clear APIs
    and interfaces*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*划出人们不需要跨越的界限：识别清晰的API和接口*。'
- en: To create a good interface, follow these steps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个良好的接口，请遵循以下步骤。
- en: Identify the client and what it *wants* to do.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别客户端及其*想要*做什么。
- en: Identify the supplier and what it's *able* to do.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别供应商及其*能够*做什么。
- en: You can only successfully separate the user and implementer with an interface
    if both parties have been correctly identified and their individual needs are
    understood. Once you're clear about this, you stand a chance of creating an interface
    that will satisfy its users and is actually implementable.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有在正确识别了双方并理解了他们的个别需求后，才能通过接口成功地将用户和实现者分开。一旦你对此有了明确的认识，你就有机会创建一个既能满足用户需求又实际可实现的接口。
- en: Bad design puts operations in the wrong place, making it a nightmare to follow
    the application logic and difficult to extend the design. It leads to increased
    module coupling and reduced cohesion.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 恶劣的设计将操作放在错误的位置，使得跟踪应用程序逻辑成为噩梦，并且难以扩展设计。它导致模块耦合增加和内聚度降低。
- en: Infer the type of interface required.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断所需的接口类型。
- en: Is it a function, a class, a network protocol, or something else? This is probably
    dictated by who supplies the functionality, but an interface may also be wrapped
    up to present it in different ways. For example, wrapping a CORBA object around
    a library publishes its functionality to a network of collaborating computers.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是一个函数、一个类、一个网络协议，还是其他什么？这通常由提供功能的人决定，但也可以将接口封装起来，以不同的方式呈现。例如，将CORBA对象封装在库中，可以将其功能发布到一组协作计算机的网络中。
- en: Determine the nature of operation.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定操作的性质。
- en: What functionality *really* needs to be provided—is it more general than this
    client's specific requirement? Inside every function, there is often a more useful
    operation waiting to get out.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真正需要提供的功能——这是否比这个客户端的具体需求更通用？在每一个函数中，通常都有一个更有用的操作等待被提取出来。
- en: 'There are a few key principles that help us to reason about the nature and
    quality of our interfaces. As illustrated in [Figure 13-3](ch13s04.html#the_interfaces_provided_by_a_house
    "Figure 13-3. The interfaces provided by a house"), these are:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个关键原则有助于我们推理接口的性质和质量。如图[图13-3](ch13s04.html#the_interfaces_provided_by_a_house
    "图13-3. 房子提供的接口")所示，这些原则是：
- en: '**Partitioning**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**分区**'
- en: An interface forms a point of contact, but also a line of separation between
    client and implementer. They can only communicate in the defined manner, not in
    any other ad hoc way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接口形成了一个接触点，但也是客户端和实现者之间的分隔线。他们只能以定义的方式沟通，而不能以任何其他临时方式。
- en: Well-designed code clearly defines *roles and responsibilities*. Knowing who
    the main actors are in a system and what they are all supposed to do ensures that
    interfaces are crisp and effective.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的代码清晰地定义了*角色和责任*。了解系统中的主要演员是谁以及他们应该做什么，确保接口清晰有效。
- en: 'A good example is my house: Its main interface is the front door. The door
    partitions occupants from visitors and determines where they meet. There are a
    number of other interfaces for other operations: windows, telephones, the chimney,
    and so on.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是我的房子：它的主要接口是前门。门将居住者与访客分开，并确定他们相遇的地方。还有许多其他接口用于其他操作：窗户、电话、烟囱等等。
- en: '**Abstraction**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**'
- en: An abstraction allows the viewer to concentrate on important decisions, selectively
    ignoring certain details. It neatly organizes reality behind a simpler representation,
    helping us to cope with complexity. It's a particularly important concept in OO
    design. When designing an interface, you create an abstraction by carefully choosing
    exactly what is important for the user and what can be usefully hidden from them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象允许观察者集中精力做出重要决策，有选择地忽略某些细节。它将现实背后的复杂性以更简单的形式组织起来，帮助我们应对复杂性。在面向对象设计中，这是一个特别重要的概念。在设计接口时，你通过仔细选择对用户重要以及对他们有用地隐藏的内容来创建一个抽象。
- en: Given a bowl of fruit, you can happily say, "*Eat* the item on top," and then
    "*Eat* the next one," without worrying exactly what that entails; a grapefruit
    needs to be peeled, while rhubarb needs to be boiled and smothered in sugar. These
    details are hidden behind the abstraction *eat*; you only care that the fruit
    *was* eaten, not how.^([[2](#ftn.CHP-13-FN-2)])
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 给你一碗水果，你可以高兴地说，“*吃*掉上面的那个东西，”然后“*吃*掉下一个，”而不必担心这具体意味着什么；葡萄柚需要剥皮，而大黄需要煮熟并裹上糖。这些细节都隐藏在抽象的“*吃*”背后；你只关心水果*已经被吃掉*了，而不是如何吃掉它.^([[2](#ftn.CHP-13-FN-2)])
- en: '![The interfaces provided by a house](tagoreillycom20080909nostarchimages207486.png.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![房屋提供的界面](tagoreillycom20080909nostarchimages207486.png.jpg)'
- en: '**Figure 13-3. The interfaces provided by a house**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13-3. 房屋提供的界面**'
- en: 'Abstractions can form a hierarchy. You can view my house at different *levels
    of abstraction*, depending on whether you''re a builder, a particle physicist,
    or a bank manager. It can be considered:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象可以形成层次结构。你可以从不同的*抽象层次*来看我的房子，取决于你是一个建筑师、一个粒子物理学家，还是一个银行经理。它可以被视为：
- en: A collection of rooms
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房间集合
- en: An arrangement of walls, floors, and ceilings
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 墙、地板和天花板的布局
- en: A construction of bricks and timber
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 砖木结构的建筑
- en: A collection of molecules, or even atoms
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分子集合，甚至原子集合
- en: A mortgage that needs to be paid
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要支付的抵押贷款
- en: '**Compression**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩**'
- en: This is the ability of an interface to represent a large operation with something
    simpler. Compression is often the result of making good abstractions, but bad
    abstractions can lead to more verbose code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接口用更简单的东西来表示大型操作的能力。压缩通常是良好抽象的结果，但糟糕的抽象可能导致更冗长的代码。
- en: '**Substitutability**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**可替换性**'
- en: 'You can substitute one implementation of an interface with another, if it meets
    the same contract. If you define a sort interface in your program, then any algorithm
    can sit behind it: It could be a quicksort, a heapsort, or (heaven forbid) a bubblesort.
    You can change it at any point, as long as the visible behavior through the interface
    is the same.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个接口的实现满足相同的契约，你可以用另一个实现来替换它。如果你在程序中定义了一个排序接口，那么任何算法都可以放在它后面：它可以是快速排序、堆排序，或者（天哪）冒泡排序。你可以在任何时刻更改它，只要通过接口可见的行为保持不变。
- en: In class inheritance hierarchies, any object can be substituted for its supertype.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在类继承层次结构中，任何对象都可以被其超类型所替代。
- en: If you want me to open my front door, you'll ring the doorbell. It used to be
    a wired switch that ran to the bell mechanism, but I've just invested in a new-fangled
    wireless doorbell. This doesn't affect you at all, in fact you won't even know
    I've changed it; you push a button, and I appear.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望我打开前门，你会按门铃。过去这是一个连接到铃铛机构的有线开关，但我刚投资了一个新式的无线门铃。这对你没有任何影响，实际上你甚至不会知道我已经更换了它；你按一个按钮，我就出现了。
- en: '**ABOUT FACE**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象**'
- en: Most of computer science is built around defining interfaces and organizing
    complexity around them. The infamous maxim is, "Any problem can be solved by adding
    an extra level of indirection"—that is, hiding new complexity behind another interface.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的大部分内容都是围绕定义接口和组织围绕它们的复杂性来构建的。那句著名的格言是，“任何问题都可以通过添加一个额外的间接层来解决”——也就是说，通过另一个接口隐藏新的复杂性。
- en: There are many types of interfaces. They all present some *public* face to their
    clients and hide the gory implementation details behind this façade.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的接口。它们都向客户端展示一些*公共*的面孔，并在这一面纱背后隐藏了血腥的实现细节。
- en: 'Common forms of interfaces that you''ll create are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建的常见接口形式是：
- en: Libraries
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库
- en: Classes
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Functions
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Data structures (particularly more exotic ones with additional behavior, like
    semaphores)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构（尤其是具有额外行为的外来结构，如信号量）
- en: OS interfaces
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统接口
- en: Protocols (network communications, for example)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议（例如网络通信）
- en: Extensibility
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Well-designed code allows extra functionality to be slotted in at appropriate
    places, when necessary. The danger is that this may lead to over-engineered code,
    trying to cope with any potential future modification.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的代码允许在必要时在适当的位置插入额外的功能。危险在于这可能导致过度设计的代码，试图应对任何潜在的未来修改。
- en: 'Extensibility can be accommodated through software scaffolding: dynamically
    loaded plug-ins, carefully chosen class hierarchies with abstract interfaces at
    the top, the provision of useful callback functions, and even a fundamentally
    logical and malleable code structure.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性可以通过软件脚手架来实现：动态加载的插件、精心选择的具有顶部抽象接口的类层次结构、提供有用的回调函数，甚至是一个基本合理且可塑的代码结构。
- en: '**KEY CONCEPT**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Design for extensibility, but don''t be hopelessly general—you''ll end up
    writing an OS, not a program*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计以扩展性为目标，但不要过于泛化——你最终会写出一个操作系统，而不是一个程序*。'
- en: A good designer thinks carefully about how his or her software will be extended.
    Randomly sprinkling code with hooks for extensibility may actually degrade quality.
    You should balance the functionality needed now, what will definitely need to
    be added later, and what might be needed to determine how extensible the design
    should be.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的设计师会仔细思考他的软件将如何扩展。随意在代码中添加扩展钩子实际上可能会降低质量。你应该平衡现在需要的功能、肯定需要添加的功能以及可能需要的功能，以确定设计应该有多大的可扩展性。
- en: Avoid Duplication
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免重复
- en: 'Well-designed code contains no duplication; it never has to repeat itself.
    Duplication is the enemy of elegant and simple design. Unnecessary redundant code
    leads to a brittle program: Given two similar pieces of code that differ only
    in minor details, you may find and fix a bug in one and then forget to fix the
    same bug in the other. This clearly compromises code safety.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的代码不包含重复；它永远不需要重复自己。重复是优雅和简单设计的敌人。不必要的冗余代码会导致程序脆弱：给定两个只有细微差别相似的代码片段，你可能会在其中一个中找到并修复一个错误，然后忘记在另一个中修复相同的错误。这显然会损害代码的安全性。
- en: Most duplication comes through *cut-and-paste programming*—copying code in the
    editor. It can arise more subtly through the reinvention of wheels by programmers
    who don't understand the whole system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数重复是通过*剪切和粘贴编程*——在编辑器中复制代码——产生的。它也可能通过程序员通过重新发明轮子（不理解整个系统）而更加微妙地产生。
- en: If you see strikingly similar things being done by separate sections of code,
    generalize it in a function with appropriate parameters. There's now a single
    place to fix any faults. This has the benefit of making the code's intent clearer
    with a descriptive function name.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你看到不同的代码部分执行着惊人的相似操作，请将其概括为一个具有适当参数的函数。现在有一个地方可以修复任何错误。这有助于通过描述性的函数名使代码的意图更清晰。
- en: Classes that are strikingly similar indicate that some functionality could be
    pushed up to a superclass or that there's a missing interface to describe the
    common behavior.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似度极高的类表明某些功能可能需要提升到超类中，或者可能缺少一个接口来描述共同的行为。
- en: '**KEY CONCEPT**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Do it once. Do it well. Avoid duplication*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*一次做好。避免重复*。'
- en: Portability
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性
- en: A good design is not *necessarily* portable; it depends on the code's requirements.
    A lot *can* be done to prevent platform dependence, but compromising code for
    unnecessary portability is bad design. A good design is *appropriately* portable
    and manages portability concerns when they are an issue.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的设计并不一定是可移植的；这取决于代码的需求。可以采取很多措施来防止平台依赖，但为了不必要的可移植性而牺牲代码质量是糟糕的设计。良好的设计应该是适当地可移植的，并在出现问题时管理可移植性关注点。
- en: 'The story is familiar: Your code was never intended to run in any other environment,
    so it wasn''t designed to cope. Later development unexpectedly required a new
    runtime platform; it was simpler to adapt the old program than write a new one.
    The code didn''t lend itself to portability, and there wasn''t enough time to
    refactor or redesign for cross-platform support. The result? A tangled mess of
    code, whose design has been irreparably warped, riddled with `#ifdef NEW_PLATFORM`
    constructions. It has not been programmed by an engineer; it has been plumbed
    by a philosopher.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事很熟悉：你的代码从未打算在任何其他环境中运行，因此它没有被设计成能够应对。后来的开发意外地需要一个新的运行时平台；适应旧程序比编写一个新程序要简单。代码不利于可移植性，而且没有足够的时间重构或重新设计以支持跨平台。结果呢？一个混乱的代码团，其设计已被不可修复地扭曲，充满了`#ifdef
    NEW_PLATFORM`结构。这不是由工程师编写的；它是由哲学家管道工编写的。
- en: Make careful choices about the structure of your OS-dependent or hardware-dependent
    sections of code. It will pay dividends in the future, and need not affect performance
    or clarity (sometimes it may even improve clarity). It's important to think about
    this as early in the design as possible; it is expensive to rework old assumptions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计早期就仔细选择你的操作系统依赖或硬件依赖代码的结构。这将在未来带来回报，并且不需要影响性能或清晰度（有时甚至可能提高清晰度）。尽早考虑这一点很重要；重新工作旧假设是昂贵的。
- en: The common approach is to create a platform abstraction layer (which may be
    a simple veneer over a few OS interface functions). You can implement this layer
    differently on each platform.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的方法是创建一个平台抽象层（这可能是几个操作系统接口函数的简单覆盖）。你可以在每个平台上以不同的方式实现这个层。
- en: '**KEY CONCEPT**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Manage the portability of your code in its design, rather than hacking it
    in as an afterthought*.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*在设计代码时，管理其可移植性，而不是将其作为事后考虑的修补*。'
- en: Idiomatic
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惯用语
- en: A good design naturally employs best practices, fitting in with both the design
    methodology (see "[Programming Styles](ch22.html#programming_styles "Programming
    Styles")" on page 420) and the implementation language's idioms. This allows other
    programmers to immediately understand the code's structure.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的设计自然采用最佳实践，与设计方法（见第420页的“编程风格”（[Programming Styles](ch22.html#programming_styles
    "Programming Styles")））和实现语言的惯用语相匹配。这允许其他程序员立即理解代码的结构。
- en: Given the implementation language (which may be fixed or may be part of the
    design domain) you must understand how to use it *well*. C++, for example, has
    idioms like *Resource Acquisition Is Initialization (RAII)* and operator overloading,
    which make a big difference to how you design code. Learn them. Understand them.
    Use them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 针对实现语言（可能是固定的，也可能是设计领域的一部分），你必须理解如何**很好地**使用它。例如，C++有像*资源获取即初始化（RAII）*和操作符重载这样的惯用语，这对你设计代码的方式有很大影响。学习它们。理解它们。使用它们。
- en: Well-Documented
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档齐全
- en: Last, but by no means least, a good design should be documented. Don't leave
    readers to infer the structure by themselves. This is particularly important at
    the higher levels of design. The documentation should be small because the design
    is so simple.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，一个好的设计应该有文档。不要让读者自己去推断结构。这在设计的高层次尤其重要。文档应该很小，因为设计本身很简单。
- en: At one end of the spectrum, architectural designs are documented in a specification.
    At the other end, functions employ self-documenting code. In the middle, you'll
    probably use literate programming for API documentation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的一端，架构设计以规范的形式进行文档化。在另一端，函数使用自文档化的代码。在中间，你可能使用文献编程来编写API文档。
- en: '* * *'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-13-FN-2)]) This ability to hide multiple physical behaviors behind
    a single logical abstraction is known as *polymorphism* and is described in "Polymorphism"
    on page 423 .
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-13-FN-2)]) 这种在单个逻辑抽象背后隐藏多个物理行为的能力被称为*多态性*，在“多态性”一节中描述，见第423页。
- en: How to Design Code
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何设计代码
- en: Always design a thing by considering it in its next larger context—a chair in
    a room, a room in a house, a house in an environment, an environment in a city
    plan.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 总是考虑事物在其更大的上下文中进行设计——一把椅子在一个房间里，一个房间在一所房子里，一所房子在一个环境中，一个环境在一个城市规划中。
- en: --Eliel Saarinen
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: --Eliel Saarinen
- en: How do you learn to design well? Are good designers born or made? Can design
    be taught or caught? Some programmers have a natural flair for good design; it
    fits the way their brains work. They naturally appreciate aesthetics and can comprehend
    enough of a problem to make balanced judgments. Nevertheless, you *can* learn
    to design more effectively.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何学会设计得很好？优秀的设计师是天生的还是后天培养的？设计可以教授或习得吗？一些程序员天生具有优秀设计的天赋；这与他们的大脑工作方式相契合。他们自然欣赏美学，并能理解足够的问题以做出平衡的判断。然而，你**可以**学会更有效地设计。
- en: When I was born, I wasn't very good at pottery. (I've never met anyone who was.)
    I'm still terrible now, but I took some lessons once. I understand the mechanics
    and can produce (almost recognizable) pots. I'd probably be much better if I practiced
    a little, but I'll never become a master artisan.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我出生时，我并不擅长陶艺。（我从未遇到过任何人擅长。）我现在仍然很糟糕，但我曾经上过一些课程。我理解了技巧并能制作（几乎可辨认的）陶器。如果我稍微练习一下，可能会更好，但我永远不会成为大师级工匠。
- en: 'Similarly, no one is born able to design code: We learn. We are taught design
    methodologies and good engineering practice. These aim to make design a repeatable
    process, but they are no substitute for *craftsmanship*. The creative thought
    process and construction of innovative designs is much harder to convey; there
    will always be better designers who grasp this.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，没有人天生就会设计代码：我们学习。我们被教导设计方法和良好的工程实践。这些旨在使设计成为一个可重复的过程，但它们不能替代**工艺**。创造性思维过程和创新设计的构建要难得多；总会有人更好地掌握这一点。
- en: 'Good software design is aesthetic; to create this digital art requires skill,
    experience, and practice. This chapter cannot attempt a paint-by-numbers description
    of how to design software. A shame: If I could bottle good design, I''d be a millionaire.
    To be a good designer, you must understand what constitutes a good design and
    learn to avoid the characteristics of bad design. Then practice. For a long time.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的软件设计是审美的；要创造这种数字艺术需要技能、经验和实践。本章无法尝试提供一个按数字描述如何设计软件的步骤。真遗憾：如果我能把好的设计装瓶，我将成为百万富翁。要成为一名优秀的设计师，你必须了解构成良好设计的东西，并学会避免不良设计的特征。然后是练习。很长时间。
- en: Apart from personal ability, there are design methods and tools that promise
    much to the programmer. We'll conclude by investigating how they can (or can't)
    help us.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了个人能力之外，还有设计方法和工具可以为程序员带来很多帮助。我们将通过调查它们如何（或不能）帮助我们来结束讨论。
- en: Design Methods and Processes
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计方法和过程
- en: There are many software design methodologies. Some emphasize a notation, others
    the process. A systematic approach is better than *seat of your pants* design;
    which method you use is usually dictated by company practice and culture. I'm
    always wary of getting too bogged down in a *particular* process—satisfying its
    minuscule details tends to stifle creativity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计方法有很多。有些强调符号，有些强调过程。系统化的方法比“凭直觉”设计要好；你使用哪种方法通常由公司的实践和文化决定。我总是小心翼翼地避免陷入*特定*过程的泥潭——满足其微小的细节往往扼杀创造力。
- en: 'Modern design methods fall into two main families, the fundamental design philosophies
    upon which they are based:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现代设计方法分为两大类，它们基于的基本设计哲学：
- en: '**Structured design**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化设计**'
- en: This is primarily about *functional decomposition*, breaking up the functionality
    of the system into a series of smaller operations. Routines are the main structuring
    devices; the design is composed of a hierarchy of routines. Structured design
    is characterized by the *divide-and-conquer* approach, splitting a problem into
    successively smaller procedures until each piece can be decomposed no more.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是关于*功能分解*，将系统的功能分解成一系列较小的操作。例程是主要的结构化工具；设计由例程的层次结构组成。结构化设计以*分而治之*的方法为特征，将问题分解成越来越小的过程，直到每个部分不能再分解。
- en: 'There are two main lines of attack: *top-down* and *bottom-up*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有两条主要攻击线：*自顶向下*和*自底向上*。
- en: Not surprisingly, a top-down approach starts with the entire problem and breaks
    it down to smaller activities. These, in turn, are designed as self-contained
    units, until no more division is necessary.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毫不奇怪，自顶向下的方法从整个问题开始，将其分解成更小的活动。然后，这些活动被设计成自包含的单元，直到不再需要进一步分解。
- en: In contrast, bottom-up design starts with the smallest units of functionality,
    the simple things you know the system *must* do. It then stitches these functions
    together until it arrives at an entire solution.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比之下，自下而上的设计从功能的最小单元开始，即你知道系统*必须*执行的最简单的事情。然后它将这些功能拼接在一起，直到得到一个完整的解决方案。
- en: In practice, these are used in tandem, and the design process ends where they
    meet, somewhere in the middle.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这些方法通常是协同使用的，设计过程在它们交汇的地方结束，通常是在中间某个位置。
- en: '**Object-oriented design**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象的设计**'
- en: Whereas structured design focuses on representing the operations a system must
    perform, OO design focuses on the data within that system. It models the software
    as an interacting set of individual units, known as *objects*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与结构化设计侧重于表示系统必须执行的操作相比，面向对象的设计侧重于系统中的数据。它将软件建模为一系列相互作用的单个单元，称为*对象*。
- en: An OO design identifies the primary objects in the problem domain and determines
    what their characteristics are. The behavior of these objects is established,
    including the operations they provide and which other objects they each relate
    to. The objects are weaved into a design, incorporating any implementation domain
    objects needed. Design is complete when all object behavior and interaction is
    determined.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的设计确定了问题域中的主要对象，并确定了它们的特征。这些对象的行为被建立，包括它们提供的操作以及它们各自关联的其他对象。这些对象被编织到设计中，包括任何实现域所需的对象。当所有对象的行为和交互都被确定时，设计就完成了。
- en: Object-oriented programming was hailed as the savior of the software design
    world, a new paradigm to usher in world peace, so much so that people are often
    embarrassed to not be performing OO design. But it has largely lived up to the
    hype, allowing software designs to manage the complexity of far bigger problems.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程被誉为软件设计世界的救世主，一种新的范式，将引领世界和平，以至于人们常常因为不进行OO设计而感到尴尬。但它在很大程度上实现了炒作，使软件设计能够管理远比更大的问题的复杂性。
- en: See "[Programming Styles](ch22.html#programming_styles "Programming Styles")"
    on page 420 for a more detailed description of design methods and processes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第420页的“[编程风格](ch22.html#programming_styles "编程风格")”，以获取对设计方法和过程的更详细描述。
- en: '**DESIGN PATTERNS**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**'
- en: '*Patterns* have become a buzzword in the OO programming community over the
    last few years. Popularized by the book *Design Patterns: Elements of Reusable
    Software* (Gamma et al. 94) by the authors affectionately known as the "Gang of
    Four" (hence it''s often known as the *GoF* book), design patterns are the software
    version of Christopher Alexander''s architectural work. (Alexander 99)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式*在过去的几年中已经成为面向对象编程社区的流行词汇。由被称为“四人帮”的作者（Gamma等人94）所著的《设计模式：可复用软件元素》（Design
    Patterns: Elements of Reusable Software）一书（因此它通常被称为*GoF*书籍）普及开来，设计模式是克里斯托弗·亚历山大（Christopher
    Alexander）建筑作品的软件版本。（亚历山大99）'
- en: Patterns establish a vocabulary of proven design solutions, and each pattern
    describes a recognizable structure of collaborating objects. These aren't clever
    invented designs, but recurring patterns found in *real code* that have been shown
    to work. *Pattern languages* collate a catalog of design patterns, showing how
    they relate to and complement one another. Each pattern in a language follows
    a common form, describing the *context*, the *problem*, and the *solution*. This
    information allows you to apply the pattern appropriately in your designs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模式建立了一套经过验证的设计解决方案的词汇表，每个模式描述了一个可识别的协作对象结构。这些不是聪明的创新设计，而是在*真实代码*中发现的重复出现的模式，并且已被证明是有效的。*模式语言*汇集了一系列设计模式，展示了它们如何相互关联和补充。语言中的每个模式都遵循一个共同的形式，描述了*上下文*、*问题*和*解决方案*。这些信息允许你适当地在你的设计中应用模式。
- en: Patterns crop up at several levels in a software system. Architectural patterns
    have a profound influence on the organization of a system. Design patterns are
    midlevel collaborations of software components. Language-level patterns are specific
    code techniques, known more commonly as language *idioms*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 模式在软件系统的几个层面上出现。架构模式对系统的组织有深远的影响。设计模式是软件组件的中级协作。语言级别的模式是特定的代码技术，更常见地被称为语言的*习语*。
- en: The names of design patterns have entered common parlance, a testament to their
    usefulness. You'll hear programmers happily talking about *adaptors*, *observers*,
    *factories*, and *singletons*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的名称已经进入日常用语，这是它们有用性的证明。你将听到程序员愉快地谈论*适配器*、*观察者*、*工厂*和*单例*。
- en: There is far more to design patterns than this quick description can do justice.
    They are a genuinely useful concept, and it's worth devoting some time to learn
    about them. Read the GoF book and material beyond it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式远不止这个简短的描述所能做到的。它们是一个真正有用的概念，值得花些时间来了解它们。阅读GoF书籍及其相关材料。
- en: Design Tools
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计工具
- en: Our designs are ultimately expressed in code, but it can often be helpful to
    work at a more abstract level. Tools help us to reason about a design, help us
    produce more effective designs, and help us to communicate those designs to other
    programmers—documenting what we *intend* to produce and what we have *already*
    created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计最终以代码的形式表达，但经常在更抽象的层面上工作可能会有所帮助。工具帮助我们推理设计，帮助我们产生更有效的设计，并帮助我们向其他程序员传达这些设计——记录我们*打算*生产和我们已经*已经*创建的内容。
- en: In a sense, methodologies are tools, but there's a broad range of other design
    aids that complement them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，方法论是工具，但还有广泛的其他设计辅助工具与之相辅相成。
- en: '**Notations**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号**'
- en: Pretty pictures are worth their weight in words. Many graphical notations exist
    to help us express our designs pictorially. Most became fleetingly fashionable
    and then quietly slunk out of the limelight to be replaced by an even sexier way
    of drawing boxes and lines. The *Unified Modeling Language (UML)* is currently
    the most popular and well-specified notation. It provides a standard way to model
    and document practically every artifact generated by the software development
    process. In fact, it has grown so comprehensive that you can use it to visualize
    far more than just software; it has been used to model hardware, business processes,
    and even organizational structures.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Notations provide a medium to help you express, think about, and discuss your
    software design. They serve two purposes:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: They allow you to scrawl quick "back of an envelope" designs and share thoughts
    around a whiteboard.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow you to formally document designs.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To maintain your sanity in the latter case, diagram creation must be automated
    with a dedicated drawing tool. Otherwise, diagrams will be hard to update and
    will diverge from reality as you develop the code. Spend your time doing something
    useful, not drawing boxes and lines.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to not be bogged down by overly formal use of a notation, happily using
    it as a method of communicating the essential elements of a design. Knowing enough
    to be able to communicate is good enough for me; I don't want to get too concerned
    about what *every* diamond and dotted line means in *every* type of picture.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**Design patterns**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: A powerful design tool providing a vocabulary of proven design techniques, and
    showing how to apply them in practice. "[DESIGN PATTERNS](ch13s05.html#design_patterns
    "DESIGN PATTERNS")" on page 255 discusses design patterns in more depth.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Flowcharts**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: A particular kind of graphical notation, used to visualize algorithms. They're
    good for giving a high-level overview but are less precise than code and become
    another thing to be kept in sync with code changes. For this reason, it's best
    to use them sparingly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Pseudocode**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode helps you draft function implementations. It's one of the most curious
    inventions in software design—halfway between a natural language and a programming
    language, a sort of pidgin English. Its advantage is the freedom from any particular
    language's syntax and semantics. You can concentrate on what needs to be done,
    not on language mechanics, and you can include arbitrary amounts of descriptive
    prose for clarity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: These aren't incredible benefits compared to the downsides. The pseudocode will
    require translation into an implementation language. You could have started to
    write in *that* language anyway and saved yourself some effort. If pseudocode
    is being used as design documentation, then you'll have to keep it in sync with
    code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '*Program Design Language (PDL)* is an even more absurd invention—a formalized
    pseudocode. I guess it made sense to somebody at the time. I''d love to have seen
    their pseudocode compiler.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序设计语言（PDL）* 是一种更加荒谬的发明——一种形式化的伪代码。我想当时对某个人来说是有意义的。我很想看看他们的伪代码编译器。'
- en: '**Design in code**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码设计**'
- en: This is a useful informal approach to code design. During the initial design
    stages, you capture all APIs and the lower-level interfaces in code, but without
    implementing any of them—you just write stubs that return plausible values, putting
    comments inside each describing what should be done. When you have reached a sufficiently
    mature design, the system already has a lot of code written.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种有用的非正式的代码设计方法。在初始设计阶段，你将所有API和底层接口以代码的形式捕捉，但并不实现它们——你只是编写返回合理值的占位符，并在每个占位符内部添加注释，描述应该做什么。当你达到足够成熟的设计时，系统已经编写了大量的代码。
- en: This can be a mixed blessing, as it can lead to less fluid designs. The more
    you change the design, the more stubbed code you have to alter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一把双刃剑，因为它可能导致设计不够流畅。你改变设计的次数越多，你需要修改的代码就越冗长。
- en: '**CASE tools**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**CASE工具**'
- en: '*Computer-aided software engineering (CASE)* tools assist in all or part of
    the design process, automating tedious jobs and managing the workflow. Most are
    capable of generating code (of variable quality) from your pretty pictures. Some
    even update the pictures when you modify the code; this is known as *round-trip
    engineering* (or *round-tripping*). Many CASE tools support collaborative work,
    allowing teams of programmers to contribute to a single large-scale design.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机辅助软件工程（CASE）* 工具协助设计过程中的所有或部分工作，自动化繁琐的任务并管理工作流程。大多数工具能够从你的漂亮图片中生成代码（质量可变）。一些甚至在你修改代码时更新图片；这被称为
    *往返工程*（或 *往返*）。许多CASE工具支持协作工作，允许程序员团队为单一的大型设计做出贡献。'
- en: 'A breed of CASE tool worthy of mention is *Rapid Application Development (RAD)*
    tools: environments for quickly building applications. They tend to work well
    in their specific domain (usually simple UI-focused applications) but aren''t
    good general-purpose software design models.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一种CASE工具是 *快速应用开发（RAD）* 工具：快速构建应用程序的环境。它们通常在其特定领域（通常是简单UI聚焦的应用程序）中表现良好，但不是好的通用软件设计模型。
- en: '**KEY CONCEPT**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Take a pragmatic approach to design tools and methodologies—use them when
    they are genuinely helpful—but don''t become a slave to them*.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*对设计工具和方法论采取实用主义的态度——当它们真正有用时使用它们——但不要成为它们的奴隶*。'
- en: In a Nutshell
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Out of intense complexities, intense simplicities emerge.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的背后，出现了简单的元素。
- en: --Winston Churchill
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: -- 温斯顿·丘吉尔
- en: Good code is well designed. It has a certain aesthetic appeal that makes it
    *feel good*. You must plan a design before beginning to write code, or you'll
    end up with an unpleasant mess. Consider things like clean structure, possible
    future extensions, correct interfaces, appropriate abstractions, and portability
    requirements. Aim for simplicity and elegance.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码是精心设计的。它具有某种美学吸引力，让人感觉 *很好*。在开始编写代码之前，你必须计划设计，否则你最终会得到一个令人不快的混乱。考虑像清洁结构、可能的未来扩展、正确的接口、适当的抽象和可移植性要求等因素。追求简单和优雅。
- en: Design involves a strong element of craftsmanship. The best designs come from
    experienced and skilled hands. Ultimately, a good designer is what makes a good
    design. Mediocre programmers do not produce excellent designs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 设计涉及强烈的工艺元素。最好的设计来自经验丰富和技艺精湛的手。最终，一个好的设计师是好的设计的关键。平庸的程序员不会产生优秀的设计。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 精通编程的人 . . . | 不擅长编程的人 . . . |'
- en: '| --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Want to leave anything they touch in a good state
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望他们接触的任何事物都处于良好的状态
- en: Think of programming as a creative process and weave an element of artistry
    into their work
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编程视为一个创造性的过程，并将艺术元素融入他们的工作中
- en: Think about the structure of code before they start working on it
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始工作之前，考虑代码的结构
- en: Feel the need to tidy up and refactor messy code before they do any extra work
    on it
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始任何额外工作之前，感觉有必要整理和重构混乱的代码
- en: Constantly learn about the design of other software, building up knowledge of
    successes and failures
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不断学习其他软件的设计，积累成功和失败的知识
- en: '|'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Keep knitting more and more code into a tight ball until they think they've
    done enough and then complain about the result
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续将越来越多的代码编织成一个紧密的球，直到他们认为已经足够，然后对结果抱怨
- en: Don't notice a bad design or feel any distaste when working with dense code
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理密集的代码时，不会注意到糟糕的设计或感到任何厌恶
- en: Are happy to hack quickly and run away, leaving someone else to clean up the
    mess
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否愿意快速黑客攻击并逃离，留下别人来清理混乱
- en: Don't appreciate or respect the internal design of code they're working on;
    they trample over it in an unsympathetic manner
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不欣赏或尊重他们正在工作的代码的内部设计；他们以一种不友好的方式践踏它
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。测试时代")'
- en: Describes how to *design code for testing*—making it easier to prove that your
    code works properly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 描述了如何*为测试设计代码*—使证明你的代码正常工作更容易。
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。软件架构")'
- en: The highest level of software design is known as *software architecture*. It
    provides its own specific problems and is dealt with in this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计的最高级别被称为*软件架构*。它提供了自己的特定问题，并在本章中处理。
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章。具体化")'
- en: Software designs are often captured in a specification document.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计通常被记录在规范文档中。
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章。程序配方")'
- en: Design fits into the overall software development process.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设计融入了整个软件开发过程。
- en: '[Chapter 23](ch23.html "Chapter 23. THE OUTER LIMITS")'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[第23章](ch23.html "第23章。外层空间")'
- en: The type of system you're building has an inevitable influence on the software's
    internal design.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在构建的系统类型不可避免地会影响软件的内部设计。
- en: '![See Also](tagoreillycom20080909nostarchimages207488.png.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207488.png.jpg)'
- en: Get Thinking
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开动脑筋
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 519.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的详细讨论可以在第519页的"[附录A](apa.html "附录A. 答案和讨论")"部分找到。
- en: Mull It Over
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: How does project size affect your software design and the work involved in creating
    it?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目大小如何影响你的软件设计和创建它的工作？
- en: Is a well-documented bad design better than an undocumented good one?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个文档齐全的糟糕设计是否比一个未文档化的优秀设计要好？
- en: How can you measure the design quality of a piece of code? How can you quantify
    its simplicity, elegance, modularity, and so on?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何衡量一段代码的设计质量？你如何量化其简洁性、优雅性、模块化等等？
- en: Is design a team activity? How important are teamworking skills in creating
    a good design?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计是团队活动吗？团队合作技能在创造良好设计方面有多重要？
- en: Are different methodologies more suitable to different projects?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同的方法论是否更适合不同的项目？
- en: In what ways can you determine whether a design is highly cohesive or weakly
    coupled?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过哪些方式确定一个设计是否高度内聚或松散耦合？
- en: If you've solved a similar design problem in the past, how good an indicator
    is it of how difficult *this* problem will be?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你以前解决过类似的设计问题，这对你判断*这个问题*的难度有多大的指示作用？
- en: Is there a place for experimentation in design?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计中是否有实验的余地？
- en: Getting Personal
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人感悟
- en: Look back and think about how you learned to design code. How could you convey
    the knowledge you've gained to a total novice?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾并思考你是如何学习设计代码的。你如何将你获得的知识传达给一个完全的初学者？
- en: What experience do you have with using particular design methodologies? Were
    these good or bad experiences? What was the resulting code like? What might have
    worked better?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在使用特定的设计方法论方面有什么经验？这些是好的还是坏的经验？结果代码是什么样的？什么可能做得更好？
- en: Do you find it important to stick rigidly to the methodology you're using?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为坚持你正在使用的方法论很重要吗？
- en: What was the best designed code you've ever seen? What was the worst designed?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你见过的最佳设计代码是什么？最差的设计代码是什么？
- en: A programming language is essentially a tool to implement your design, not a
    religion to argue about. How important is it *really* to know language idioms?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程语言本质上是你实现设计的工具，而不是争论的宗教。真正了解语言惯用法的意义有多大？
- en: Do you think programming is an *engineering discipline*, a *craft*, or an *art*?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为编程是*工程学科*、*手艺*还是*艺术*？
- en: Chapter 14. SOFTWARE ARCHITECTURE
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。软件架构
- en: '*Laying the Foundations of Software Design*'
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*软件设计的基础*'
- en: Architecture is the art of how to waste space.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是浪费空间的艺术。
- en: --Philip Johnson
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: --菲利普·约翰逊
- en: Go into a city. Stand in the middle of it. Look around. Unless you've picked
    an unusual place, you will be surrounded by a large number of buildings of varying
    ages and styles of construction. Some fit into their surroundings sympathetically.
    Others look totally out of place. Some are aesthetically pleasing and seem well
    proportioned. Others are downright ugly. Some will still be there in 100 years'
    time. Many will not.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 去一个城市。站在它的中间。四处看看。除非你选了一个不寻常的地方，否则你将被大量不同年龄和建筑风格的建筑所包围。有些与周围环境和谐相处。有些看起来格格不入。有些看起来美观，比例协调。有些则非常丑陋。有些可能会在未来100年里仍然存在。许多则不会。
- en: 'The architects who designed these buildings took a lot into consideration before
    they put pencil to paper. During the process of design, they worked carefully
    and methodically to ensure that the building was feasible to fabricate, and they
    balanced all the contending forces: user requirements, construction methods, maintainability,
    aesthetics, and so on.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 设计这些大楼的建筑师在动笔之前考虑了很多因素。在设计过程中，他们小心翼翼、有条不紊地工作，以确保建筑可以制造，并平衡所有竞争力量：用户需求、建造方法、可维护性、美学等等。
- en: Software is not made of bricks and mortar, but the same careful thought is requiredto
    ensure that a system meets similar sets of requirements. We have been erecting
    buildings far longer than we've been writing software, and it shows. We're still
    learning about what makes goodsoftware architecture.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 软件不是由砖石和灰泥构成的，但同样需要仔细思考以确保系统满足类似的集合要求。我们在建造建筑方面比编写软件的历史要长得多，这很明显。我们仍在学习什么构成了好的软件架构。
- en: In this little foray into the world of software architecture, we'll investigate
    some common architectural patterns and look at what software architecture really
    is, what itreally isn't, and what it's used for.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对软件架构世界的短暂探索中，我们将研究一些常见的架构模式，并探讨软件架构的真正含义，它真正不是什么，以及它的用途。
- en: '**UNDERGROUND MOVEMENT**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**地下运动**'
- en: I joined a project that had produced a large amount of undocumented software,
    erected without plan or purpose, with no architect to guide the construction process.
    Naturally, it had become an unsightly carbuncle. The time came when we needed
    to understand how it all *really* worked, and an architectural diagram of the
    system was drawn up. There were so many different components (many largely redundant),
    inappropriate interconnections, and different methods of communication that the
    diagram was an intense jumble of tightly woven lines in many interpretive colors—almost
    as if a spider had fallen into a few different cans of paint and then spun psychedelic
    webs across the office.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我加入了一个项目，该项目产生了大量未文档化的软件，这些软件没有计划或目的，没有建筑师来指导建造过程。自然地，它变成了一颗难看的疖子。当我们需要真正理解它是如何运作的时候，系统架构图就被绘制出来了。有如此多的不同组件（许多很大程度上是冗余的），不恰当的连接，以及不同的通信方式，使得图表成为了一团混乱的紧密交织的线条，许多线条呈现出多种解释色彩——几乎就像一只蜘蛛掉进了几罐不同的油漆里，然后在办公室里织出了迷幻的网。
- en: Then it struck me. We had all but drawn a map of the London Underground. Our
    systembore such a striking resemblance, it was uncanny—it was practically incomprehensible
    to an outsider, with many routes to achieve the same end, and the plan was still
    a gross simplification of reality. This was the kind of system that would vex
    a traveling salesman.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我意识到。我们几乎绘制了一张伦敦地铁的地图。我们的系统与它如此相似，令人毛骨悚然——对于局外人来说几乎无法理解，有众多路线可以达到相同的目的，而计划仍然是对现实的粗略简化。这是一个会让旅行推销员感到烦恼的系统。
- en: The lack of architectural vision had clearly made its mark on the software.
    It was hard to work with and hard to understand, with bits of functionality strewn
    across completely random modules. It had gotten to the point where the only useful
    thing you could do with it was throw it away.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏架构视野在软件上留下了明显的印记。它难以使用和理解，功能片段散布在完全随机的模块中。它已经到了这种地步，你唯一能做的有用的事情就是把它扔掉。
- en: In software construction, as in building construction, the *architecture really
    matters*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，就像在建筑建造中一样，*架构至关重要*。
- en: What Is Software Architecture?
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是软件架构？
- en: Is this just another term that stretches the *building* metaphor a little thinner
    (see "[DO WE REALLY BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question
    "DO WE REALLY BUILD SOFTWARE?")" on page 177)? Maybe so, but it is a genuinely
    useful concept. Software architecture is sometimes known as *high-level design*;
    regardless of the terms used, the meaning is the same. Architecture is a more
    evocative description of the concept.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是另一个稍微拉伸了*建筑*隐喻的术语吗（参见第177页的"[我们真的在构建软件吗？](ch10.html#do_we_really_build_software_question
    "我们真的在构建软件吗？")"）？可能吧，但它确实是一个真正有用的概念。软件架构有时也被称为*高级设计*；无论使用什么术语，其含义都是相同的。架构是对该概念更富有表现力的描述。
- en: Software Blueprints
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件蓝图
- en: As an architect prepares his blueprint for a building, the software architect
    prepares a blueprint for the software system. However, while a building's blueprint
    is a rigorously detailed plan with all the important features included, our software
    architecture is a top-level definition, an overview of the system that specifically
    avoids too much detail. It is macro, not micro.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当建筑师为建筑物准备蓝图时，软件架构师为软件系统准备蓝图。然而，尽管建筑物的蓝图是一个严格详细的计划，包含了所有重要特征，但我们的软件架构是一个顶层定义，是对系统的概述，特别避免过多细节。它是宏观的，而不是微观的。
- en: 'In this high-level view, all implementation details are hidden; we just see
    the essential internal structure of the software and its fundamental behavioral
    characteristics. The architectural view does the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个高级视图中，所有实现细节都被隐藏了；我们只看到软件的基本内部结构和其基本行为特征。架构视图执行以下操作：
- en: Identifies the key software modules (or components, or libraries; at this point
    call them what you like—*blobs*)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定关键软件模块（或组件、或库；在这个阶段，你可以随意称呼它们——*块*）
- en: Identifies which components communicate with each other
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定哪些组件相互通信
- en: Helps to identify and determine the nature of all the important interfaces in
    the system, clarifying the correct *roles and responsibilities* of the various
    subsystems
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助识别和确定系统中所有重要接口的性质，明确各种子系统的正确*角色和责任*。
- en: This information allows us to reason about the system as a whole without having
    to understand how every individual part will work. The architecture provides a
    framework into which the later development fits. It shows how work can be split
    between teams and allows you to weigh different implementation strategies.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息使我们能够对整个系统进行推理，而无需了解每个单独的部分将如何工作。架构提供了一个框架，后续的开发可以适应其中。它展示了工作如何在不同团队之间分配，并允许你权衡不同的实现策略。
- en: Not only does the architecture give a picture of how the system is composed,
    it also shows how it should be extended over time. In large teams, a program will
    develop more elegantly when there's a clear, unified vision of how the software
    should be adapted, of what should be put in each module, and of how modules connect.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅架构描绘了系统是如何组成的，它还展示了系统应该如何随着时间的推移而扩展。在大型团队中，当有一个清晰的、统一的软件应该如何适应、每个模块应该包含什么以及模块如何连接的愿景时，程序将更加优雅地发展。
- en: '**KEY CONCEPT**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*The architecture is the single largest influence on the design and future
    growth of a software system. It is therefore* essential *to get it right in the
    early stages of development*.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*架构是影响软件系统设计和未来增长的最大因素。因此，在开发的早期阶段将其做正确是至关重要的*。'
- en: As an up-front activity, the architecture is our first chance to map the *problem
    domain* (the Real World problem we are solving) to a *solutiondomain*. There isn't
    always a simple one-to-one mapping of objects and activities between the two,
    so the architecture shows how to think about one in terms of the other.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项前期活动，架构是我们第一次将*问题域*（我们正在解决的现实世界问题）映射到*解决方案域*的机会。两个域之间并不总是存在简单的对象和活动的一对一映射，因此架构展示了如何从另一个角度思考。
- en: 'Exactly what needs to be addressed by the software architecture will differ
    from project to project. The target platform is not important at this stage; it
    may be possible to implement the architecture on a number of different machines
    using different languagesand technologies. However:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构需要解决的问题将因项目而异。目标平台在这个阶段并不重要；可能可以在使用不同语言和技术的大量不同机器上实现架构。然而：
- en: For certain projects, it may be important to specify particular hardware components,
    most likely for embedded designs.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于某些项目，可能需要指定特定的硬件组件，这很可能是为了嵌入式设计。
- en: For a distributed system, the number of machines and processors and the split
    of work between them might be an architectural issue. Minimum and average system
    configurations should be considered.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于分布式系统，机器和处理器数量以及它们之间的工作分配可能是一个架构问题。应考虑最小和平均的系统配置。
- en: The architecture may also describe specific algorithms or data structures if
    they are fundamental to the overall design (although this is far less likely).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特定的算法或数据结构对整体设计至关重要，架构也可能描述它们（尽管这种情况很少发生）。
- en: There is always a trade-off. The more information that is set in stone at the
    architectural level, the less room for maneuverability there is at a later design
    or implementation stage.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存在权衡。在架构级别确定的信息越多，在后续的设计或实施阶段就越少有操作空间。
- en: Points of View
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视角
- en: 'In physical architecture, we use a number of different drawings or views of
    the same building: one for the physical structure, one for the wiring, one for
    the plumbing, andso on. Similarly, we develop different software views in the
    architectural process. Four views are commonly recognized:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理架构中，我们使用许多不同的图纸或同一座建筑的视图：一个用于物理结构，一个用于布线，一个用于管道，等等。同样，我们在架构过程中开发不同的软件视图。常见的四种视图如下：
- en: '**The conceptual view**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念视图**'
- en: Sometimes called the *logical view*, this shows the major parts of the system
    and their interconnections.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有时被称为*逻辑视图*，它展示了系统的主要部分及其相互连接。
- en: '**The implementation view**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现视图**'
- en: This view is seen in terms of the real implementation modules, which may have
    to differ from the neat conceptual model.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观点是从实际实施模块的角度来看的，这些模块可能需要与整洁的概念模型有所不同。
- en: '**The process view**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程视图**'
- en: Designed to show the dynamic structure in terms of tasks, processes, and communication,
    this view is best used when there's a high degree of concurrency involved.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 设计用于展示任务、流程和通信方面的动态结构，当涉及高度并发时，此视图最为适用。
- en: '**The deployment view**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署视图**'
- en: Use this view to show the allocation of tasks to physical nodes, in a distributed
    system. For example, you may split functionality between a database server and
    afarm of web interface gateways.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此视图来展示在分布式系统中任务分配给物理节点的情况。例如，你可以在数据库服务器和一系列网络接口网关之间分割功能。
- en: You don't start with all of these. Particular views arise as development work
    progresses. The main result of the initial architectural phase is the *conceptual
    view*, and that's what we're concentrating on here.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会一开始就拥有所有这些。特定的视图随着开发工作的进展而出现。初始架构阶段的主要结果是*概念视图*，这是我们在这里关注的重点。
- en: '**FOR WHAT IT''S WORTH**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**值此机会**'
- en: Software architecture has wide-ranging implications—far beyond the initial structure
    of the code, right into the heart of the software factory. The architecture will
    be a lasting legacy, both in the technological and practical realms. Architecture
    affects how the code will grow and how teams of people will work together to extend
    it;software designaffects workflow. With a three-tiered architecture, you'll end
    up with *three* teams of people working on the separate parts. There will probably
    be *three* sets of admin staff too, and *three* management reporting lines. Someone's
    early design decision will affect which desk you sit at.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构具有广泛的影响——远远超出代码的初始结构，深入到软件工厂的核心。架构将是一个持久的遗产，在技术和实践领域都是如此。架构影响代码如何增长以及团队如何协作来扩展它；软件设计影响工作流程。采用三层架构，你最终会拥有*三个*团队分别处理不同的部分。可能还会有*三*套管理团队，以及*三*条管理汇报线。某个人的早期设计决策将影响你坐在哪个办公桌前。
- en: Since the architecture determines how malleable the software is and how well
    the codebase can accommodate future requirements, it ultimately influences the
    commercial success of your company. A bad architecture is more than just inconvenient—it
    could cost you your livelihood. Serious stuff.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于架构决定了软件的灵活性和代码库如何适应未来的需求，它最终会影响你公司的商业成功。糟糕的架构不仅仅是麻烦——它可能会让你失去生计。这是严肃的事情。
- en: As programmers, it affects us most directly—it will affect how fun our work
    will be. No one wants to labor intensely to add a minuscule feature that would
    have taken two seconds with a correct initial design. At conception, check that
    the architecture supports what you think it should, not just what the architects
    believe.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，这直接影响我们——它将影响我们的工作有多有趣。没有人愿意辛勤劳作来添加一个微不足道的特性，而这个特性如果有一个正确的设计，只需两秒钟就能完成。在构思阶段，要检查架构是否支持你认为应该支持的内容，而不仅仅是建筑师所相信的内容。
- en: Where and When Do You Do It?
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时何地进行？
- en: The architecture is captured in a high-level document called something imaginative
    like the *architecture specification*. This specification explains the system's
    structure and shows how it fulfills the requirements, including important issues
    like the strategy to reach any performance requirements and how acceptable fault
    tolerance will be achieved.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 架构被记录在一个高级文档中，可能被称为*架构规范*这样的富有创意的名字。这个规范解释了系统的结构，并展示了它是如何满足需求的，包括达到任何性能要求的策略以及如何实现可接受的容错性。
- en: '**KEY CONCEPT**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Capture system architecture in a known place; a document accessible to everyone
    involved—programmers, maintainers, installers, managers (perhaps even customers)*.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*在已知的地方捕获系统架构；一个对所有相关人员——程序员、维护者、安装人员、经理（甚至可能是客户）——都易于访问的文档*。'
- en: The architecture is the initial system design. It is therefore the *first* developmental
    step after the requirements have been agreed upon. It's important to generate
    a specification up front because it provides a first chance to review and validate
    the design decisions that will have the most significant impact on the project.
    It will expose weaknesses and potential problems. Reversing a bad decision this
    early on will save a lot of time, effort, and money. It's expensive to changethe
    foundation of a system once a lot of code has been built upon it.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是初始的系统设计。因此，它是需求确定后的*第一步*开发步骤。提前生成规范很重要，因为它提供了第一次审查和验证将对项目产生最大影响的决策的机会。它将暴露出弱点和潜在问题。在早期就纠正一个糟糕的决定将节省大量时间、精力和金钱。一旦在系统之上构建了大量代码，改变系统的根基就会变得非常昂贵。
- en: Architectural work is a form of design, but it is separate from the module design
    phase, and distinct from low-level code design, although it certainly overlaps
    somewhat. Later work on detailed design may feed changes back up to the system
    architecture. This isnatural and healthy.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 架构工作是一种设计形式，但它与模块设计阶段是分开的，并且与低级代码设计不同，尽管它确实有一些重叠。详细设计的工作可能会将变化反馈到系统架构中。这是自然且健康的。
- en: '**WHOSE JOB?**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁的职责？**'
- en: We've seen that software architecture affects *everyone* on the project—not
    just the programmers. In contrast, the architecture is determined by a far smaller
    group of people. What a responsibility.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，软件架构影响着项目中的每个人——而不仅仅是程序员。相比之下，架构是由一个远小得多的群体决定的。这是一个多么重大的责任。
- en: The architecture designer is called a *software architect*. This is a grandiose
    titleand, like *engineer*, somewhat contentious. "Real" architects must study,
    qualify, and reach levels of professional excellence to even be called architects.
    There are no such requirements in the software world.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计师被称为*软件架构师*。这是一个宏伟的头衔，就像*工程师*一样，有些争议。真正的建筑师必须学习、取得资格并达到专业卓越的水平，才能被称为建筑师。在软件世界中没有这样的要求。
- en: Software architects are among the project initiators, working right at the beginning
    of the development cycle. As development ramps up, programmers will join the effort
    to implement this established architecture.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师是项目发起者之一，他们在开发周期的初期就开始工作。随着开发活动的增加，程序员将加入努力，实施这个既定的架构。
- en: However, on smaller projects requiring less specialized architectural experience,
    the programmers themselves will devise the architecture. No big guns are drafted
    in. Be ready to contribute to architectural design.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在需要较少专业架构经验的小项目中，程序员自己将设计架构。不需要请来大炮。准备好为架构设计做出贡献。
- en: What Is It Used For?
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它有什么用途？
- en: 'Architecture is the initial system design. But its uses stretch even further.
    We use the system architecture to:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是初始的系统设计。但它的用途甚至更广泛。我们使用系统架构来做：
- en: '**Validate**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证**'
- en: The architecture is our first chance to validate what is going to be built.
    With it, we can mentally check that the system will meet all requirements. We
    can check that it really is feasible to build. We can ensure that the design is
    internally consistent and hangs together well with no special cases or gratuitous
    hacks. Nasty blemishes in the high-level design will only lead to more dangerous
    hacks at lower levels.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The architecture helps to ensure that there is no duplication of work, wasted
    effort, or redundancy. We use it to check that there are no gaps in the strategy,
    that we haveincluded all the necessary pieces. We ensure that there will be no
    mismatches as separatesections are brought together.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**Communicate**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: We use the architecture specification to communicate the design to all interested
    parties. These may be system designers, implementers, maintainers, testers, customers,
    or managers. It's the primary route to understand the system and is an important
    piece of documentation that should *always* be kept up to date as changes are
    made.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '*An architecture specification is an essential device to communicate the shape
    of your system. Ensure that you keep it in sync with the software*.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The architecture conveys the vision of your system, mapping the problem domain
    to the solution domain. It should neatly identify how future extensions fit in,
    helping to maintain the system's *conceptual integrity*. (Brooks 95) It implicitly
    provides a set of conventions and contains an element of style. For example, it's
    clear that you shouldn't introduce a new component with custom socket-based communication
    if the rest of the design uses a CORBA infrastructure.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The architecture provides a natural route into the next level of design without
    being too prescriptive.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '**Discriminate**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: We use the architecture to help us make decisions. For example, it identifies
    build versus buy decisions, determines whether a database is required, and clarifiesthe
    error-handling strategy. It will flag problem areas, areas of particular risk
    on the project, and help us plan to minimize this risk. Just as an architect's
    primary goal is to ensure his building stays up when it's built—under all expected
    conditions (and some unusual conditions too)—so should we ensure the resillience
    of our software structure. A little wind or extra load shouldn't topple the thing
    over.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: We need this systemwide perspective to make the appropriate trade-offs, ensuring
    that the design meets its required properties. These important issues are considered
    at thebeginning rather than grafted in toward the end of development.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '*Make all software design decisions in the context of the architecture. Always
    check that you''re working in line with the system vision and strategy. Don''t
    create a little wart on the side that doesn''t complement anything else*.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Of Components and Connections
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Architecture mostly concerns itself with *components* and *connections*. It
    determines the number and type of each.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑学主要关注**组件**和**连接**。它决定了每种组件的数量和类型。
- en: Components
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: Architecture captures information about each component, whatever *component*
    means inthe architecture's context. It could be an object, a process, a library,
    a database, or athird party product. Each of the system's components is identified
    as a clear and logicalunit. Each performs one task and does it well. No component
    includes a kitchen sink unless there's a specific kitchen-sink module.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 架构捕捉了关于每个组件的信息，无论在架构的上下文中“组件”意味着什么。它可能是一个对象、一个过程、一个库、一个数据库或第三方产品。系统的每个组件都被识别为一个清晰且逻辑的单位。每个组件执行一项任务，并且做得很好。除非有特定的厨房水槽模块，否则没有任何组件包含厨房水槽。
- en: 'While it won''t dwell on component implementation issues, the architecture
    will describe all exposed facilities and perhaps the important externally visible
    interfaces. It defines the *visibility* of the component: what it can see and
    what it can''t, and what can see it and what can''t. Different architectural styles
    imply differentvisibility rules, as we''ll see later.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然架构不会过多关注组件实现问题，但它将描述所有公开的设施，也许还有重要的外部可见接口。它定义了组件的**可见性**：它能看到什么，不能看到什么，以及什么能看到它，什么不能。不同的架构风格意味着不同的可见性规则，我们稍后会看到。
- en: '**ARCHITECTS VS. MARKETERS**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**架构师与市场营销人员**'
- en: An architecture is inadequate if it doesn't fulfill the product requirements
    for initial deployment or any future development; design quality is about more
    than just technical excellence. Technical issues must be addressed alongside product
    management and marketing considerations.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果架构不能满足初始部署或任何未来发展的产品需求，那么它是不充分的；设计质量不仅仅是技术卓越的问题。技术问题必须与产品管理和市场营销考虑因素一起解决。
- en: There is no point in developing a product that no one wants; it would obviously
    be a huge waste of time. But you can miss vital business opportunities by omitting
    marketingrequirements from technical consideration. The marketing department identifies
    core business objectives including sales strategies (do you charge a one-off fee
    or employ a licensing/billing model?), the product's position in the marketplace
    (is it a high-end, feature-packed, high-cost product or a cheap, mass-produced
    item?), and the importance of a uniquebrand running through the system.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 开发没有人想要的产品的意义不大；这显然是巨大的时间浪费。但是，如果你从技术考虑中省略了市场营销要求，你可能会错过重要的商业机会。市场营销部门确定核心商业目标，包括销售策略（你是收取一次性费用还是采用许可/计费模式？），产品在市场中的定位（它是一个高端、功能丰富、高成本的产品，还是一个便宜的大众化产品？），以及贯穿整个系统的独特品牌的重要性。
- en: In some situations, visibly good architecture may be a *unique selling point*
    and mayprovide a strong competitive advantage. Other markets care less about the
    internal systemstructure, but an architecture that anticipates and handles future
    customer requirements is still essential to establish and maintain a strong market
    position.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，明显的良好架构可能是一个**独特的卖点**，并可能提供强大的竞争优势。其他市场可能不太关注内部系统结构，但能够预见并处理未来客户需求的架构对于建立和维持强大的市场地位仍然是至关重要的。
- en: Technical architects must work closely with the marketing decision makers to
    understand how new software will fit into the company's overall strategy and what
    the customer requires for a truly exceptional solution. The software architecture
    will address marketing issues such as usability, reliability, upgradeablity, and
    extensibility. Each of these has a real influence on the software design. Support
    for different charging methods alonemay have a huge impact on the profitability
    of the project—the inclusion of rich logging support will pave the way for per-transaction
    billing, which may lead to increased product revenue. However, it may mandate
    the inclusion of additional security and fraud-prevention measures in the architectural
    planning.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 技术架构师必须与市场营销决策者紧密合作，了解新软件如何融入公司的整体战略以及客户对真正卓越解决方案的需求。软件架构将解决诸如可用性、可靠性、可升级性和可扩展性等市场营销问题。这些因素都对软件设计有实际影响。仅支持不同的收费方式就可能对项目的盈利能力产生巨大影响——包含丰富的日志支持将为按交易计费铺平道路，这可能导致产品收入增加。然而，这也可能要求在架构规划中包含额外的安全和欺诈预防措施。
- en: Marketing requirements feed into the technical architecture. Technical considerations
    will also feed back to the marketing strategy. A truly great architecture is born
    when technical and strategic visions meet to create a product that stands out
    from its competitors.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 市场需求输入到技术架构中。技术考虑也会反馈到市场策略中。当技术和战略愿景相遇，创造出与众不同的产品时，真正的伟大架构就诞生了。
- en: Connections
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: The architecture identifies all the inter-component connections and describes
    the connection properties. A connection may be a simple function call or data
    flow through a pipe. It may be an event handler or a message passing through some
    OS or network mechanism. A connection can be *synchronous* (blocking the caller
    until the implementation has completed the request) or *asynchronous* (returning
    control to the caller immediately and arranging for a reply to be posted back
    at a later date). This is important, since it affects the flow of control around
    the system.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 架构确定了所有组件间的连接，并描述了连接属性。连接可能是一个简单的函数调用或通过管道的数据流。它可能是一个事件处理器或通过某些操作系统或网络机制传递的消息。连接可以是*同步的*（阻塞调用者直到实现完成请求）或*异步的*（立即将控制权返回给调用者，并安排在稍后日期回复）。这是重要的，因为它影响系统周围的控制流。
- en: 'Some communication is indirect (and consequently quite subtle). For example,
    components can share certain resources and talk through them—rather like posting
    messageson a shared whiteboard. Examples of shared communication channels are:
    a subordinate component, a shared memory region, or something as basic as the
    contents of a file.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一些通信是间接的（因此相当微妙）。例如，组件可以共享某些资源并通过它们进行交流——就像在共享的白板上发布消息。共享通信渠道的例子包括：一个从属组件、共享内存区域，或者像文件内容这样基本的东西。
- en: What Is Good Architecture?
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是好的建筑？
- en: The key to good architecture is *simplicity*. A few well-chosen modules and
    sensible communication paths are the aim. It also needs to be *comprehensible*,
    which often means visually represented. We all know that *a picture speaks a thousand
    words*.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 好的架构的关键是*简单性*。几个精心选择的模块和合理的通信路径是目标。它还需要是*可理解的*，这通常意味着视觉表示。我们都知道*一张图胜过千言万语*。
- en: '**KEY CONCEPT**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Good system architecture is* simple. *It can be described in a single paragraph
    and summarized in one elegant diagram*.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*好的系统架构是*简单的。*它可以被描述在一句话中，并总结在一个优雅的图表中*。'
- en: In a well-designed system, there should be neither too few nor too many components.
    This criterion scales with the size of the problem. For a small program, the architecturemay
    fit on (or even be done on) the back of an envelope, with just a few modules and
    somesimple interconnections. A large system naturally requires more effort and
    more envelopes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个设计良好的系统中，组件既不应太少也不应太多。这个标准随着问题的大小而变化。对于一个小程序，架构可能适合（甚至可以在信封背面完成），只有几个模块和一些简单的互连。一个大型系统自然需要更多的努力和更多的信封。
- en: '*Too many* fine-grained components lead to an architecture that is bewildering
    and hard to work with. It implies that the architect has gone into too much detail.
    *Too few* components means that each module is doing far too much work; this makes
    the structure unclear, hard to maintain, and hard to extend. The correct balance
    is somewhere between the two.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*过多的*细粒度组件会导致架构变得令人困惑且难以操作。这暗示着建筑师过于深入细节。*过少的*组件意味着每个模块要做的工作太多；这使得结构不清晰，难以维护和扩展。正确的平衡在两者之间。'
- en: The architecture does not dictate the inner workings of each module—that's what
    module design is for. The goal is that each module should know very little about
    the other parts of the system. We aim for low coupling and high cohesion (see
    "[Modularity](ch13s04.html#modularity "Modularity")" on page 247) at this level
    of design, as with all others.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑并不规定每个模块的内部运作——这是模块设计的作用。目标是每个模块对系统的其他部分了解得非常少。我们在这个设计层面上追求低耦合和高内聚（参见第247页的"[模块化](ch13s04.html#modularity
    "模块化")"），就像在其他所有层面上一样。
- en: '**KEY CONCEPT**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Architecture* identifies *the key components of the system and how they interact.
    It doesn''t define* how *they work*.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*架构*确定了系统的关键组件以及它们如何交互。它并不定义*它们如何工作*。'
- en: 'The architecture specification lists the design decisions made and makes it
    clear why this approach is being favored over any alternative strategies. It doesn''t
    need to labor these other approaches, but should justify the chosen architecture
    and prove that some serious thought went into it. It must have correctly identified
    the primary goal of the system: For example, *extensibility* is a different game
    from *performance* and will lead to different architectural design decisions.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 架构规范列出了做出的设计决策，并清楚地说明了为什么这种方法被优先考虑而不是任何其他替代策略。它不需要详细说明这些其他方法，但应该证明所选架构是合理的，并证明对其进行了认真思考。它必须正确地确定了系统的首要目标：例如，*可扩展性*与*性能*是不同的游戏，将导致不同的架构设计决策。
- en: A good architecture leaves room for maneuverability; it allows you to change
    your mind. It may specify that we wrap third party components with abstract interfaces
    so we can swap one version out for another. It may suggest technologies that make
    it easy to select different implementations during deployment. As a project gains
    momentum, the correct implementation choices become clear—they aren't always obvious
    at first. A successful architecture is flexible, providing a mechanism for nimble
    design during these initial uncertainties. The architecture is the first pivot
    on which to balance contending forces; it will show how we trade one quality for
    another.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的架构留有操作空间；它允许你改变主意。它可能指定我们用抽象接口包装第三方组件，这样我们就可以用另一个版本替换掉一个版本。它可能建议在部署期间选择不同实现的技术。随着项目的发展，正确的实现选择变得清晰——它们一开始并不总是显而易见的。一个成功的架构是灵活的，在初始的不确定性期间提供了一种敏捷设计的机制。架构是平衡相互竞争力量的第一个支点；它将展示我们如何权衡一个质量以换取另一个质量。
- en: '**KEY CONCEPT**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*A good architecture leaves space for maneuverability, extension, and modification.
    But it isn''t hopelessly general*.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*好的架构留有操作空间、扩展和修改的空间。但它并不是毫无希望的通用*。'
- en: The architecture must be clear and unambiguous. Preexisting, well-known architectural
    styles or well-known frameworks are best (see the next section for more on these).
    Architecture must be easy to understand and work with.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 架构必须清晰且无歧义。现有的、众所周知的架构风格或众所周知的框架是最好的（下一节将详细介绍这些内容）。架构必须易于理解和操作。
- en: Like a good design, good architecture has a certain aesthetic appeal that makes
    it *feel* right.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 好的设计和好的架构都有一种美学吸引力，让人感觉*正确*。
- en: Architectural Styles
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构风格
- en: '*Form ever follows function*.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*形式永远追随功能*。'
- en: --Louis Henry Sullivan
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: --路易斯·亨利·苏利文
- en: 'Just as an immense gothic cathedral and a quaint Victorian chapel, or an imposing
    tower block and a 1970s public lavatory employ different architectural styles,
    there are anumber of recognized software architectural styles that a system may
    be built upon. A style may be chosen for various reasons, good or bad—perhaps
    on sound technological grounds, or perhaps based on the architect''s prior experience,
    perhaps even by what style is currently in fashion. Each architecture has different
    characteristics:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 正如一座宏伟的哥特式大教堂和一座古老的维多利亚式小教堂，或者一座令人敬畏的摩天大楼和20世纪70年代的公共洗手间采用了不同的建筑风格一样，有许多公认的软件架构风格可以作为系统的基础。一个风格可能出于各种原因被选择，无论是好是坏——可能是基于坚实的技术基础，可能是基于建筑师以往的经验，甚至可能是基于当前流行的风格。每种架构都有不同的特点：
- en: Its resilience to changes in the data representation, algorithms, and required
    functionality
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对数据表示、算法和所需功能变化的适应性
- en: Its method of module separation and connection
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的模块分离和连接方法
- en: Its comprehensibility
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的可理解性
- en: Its accommodation of performance requirements
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对性能要求的适应
- en: Its consideration of component reusability
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对组件可重用性的考虑
- en: In practice, we might see a mixture of architectural styles in one system. Some
    data processing may progress through a pipe and filter process, while the rest
    of the systememploys a component-based architecture.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们可能会在一个系统中看到多种架构风格的混合。一些数据处理可能通过管道和过滤器过程进行，而系统其余部分则采用基于组件的架构。
- en: '**KEY CONCEPT**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Recognize the key architectural styles and appreciate their pros and cons.
    This will help you to sympathetically work with existing software and perform
    appropriate system design*.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*识别关键架构风格并欣赏它们的优缺点。这将帮助你同情地处理现有软件并执行适当的系统设计*。'
- en: The following sections describe some of the common architectural styles. And
    then compare them to pasta.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将描述一些常见的架构风格。然后将其与意大利面进行比较。
- en: No Architecture
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有架构
- en: A system always has an architecture, but like my London Underground project,
    it maynot have a *planned* architecture. Before long, this state of affairs becomes
    an albatross around the neck of your development team. The resulting software
    will be a mess.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 系统总是有一个架构，但就像我的伦敦地铁项目一样，它可能没有**计划**的架构。不久，这种状况就会成为你开发团队的负担。结果产生的软件将会一团糟。
- en: Defining an architecture is essential if you want to build good software. Not
    planning an architecture is a surefire way to doom development before you've even
    started.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要构建好的软件，定义一个架构是至关重要的。不规划架构是注定要使开发在开始之前就失败的。
- en: '![No Architecture](tagoreillycom20080909nostarchimages207490.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![无架构](tagoreillycom20080909nostarchimages207490.png)'
- en: Layered Architecture
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构
- en: This is probably the most commonly used architectural style in conceptual views.
    Itdescribes the system as a hierarchy of layers, with a building-block approach.
    It is a very simple model to comprehend; even a non-techie can quickly grasp what
    it's telling him.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是概念视图中最常用的架构风格。它将系统描述为一系列层级的层次结构，采用积木式方法。这是一个非常简单的模型，易于理解；即使是非技术人员也能迅速掌握它所传达的信息。
- en: '![Layered Architecture](tagoreillycom20080909nostarchimages207492.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![Layered Architecture](tagoreillycom20080909nostarchimages207492.png)'
- en: Each component is represented by a single block in the stack. The positions
    in the stack indicate what lives where, how the components relate to each other,
    and which components can "see" which other components. Blocks may be placed alongside
    each other on the same level and can even become tall enough to span two layers.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件在堆栈中由一个单独的块表示。堆栈中的位置表示什么在哪里，组件如何相互关联，以及哪些组件可以看到哪些其他组件。块可以放在同一层的旁边，甚至可以高到跨越两层。
- en: A famous example of this is the OSI seven-layer reference model for network
    communication systems. (ISO 84) A more interesting example is the Goodliffe seven-layer
    trifle reference model shown in [Figure 14-1](ch14s03.html#the_goodliffe_seven-layer_trifle_reference_model
    "Figure 14-1. The Goodliffe seven-layer trifle reference model").
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的一个著名例子是OSI七层参考模型，用于网络通信系统。（ISO 84）一个更有趣的例子是[图14-1](ch14s03.html#the_goodliffe_seven-layer_trifle_reference_model
    "图14-1. The Goodliffe七层三明治参考模型")中展示的Goodliffe七层三明治参考模型。
- en: '![The Goodliffe seven-layer trifle reference model](tagoreillycom20080909nostarchimages207494.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![The Goodliffe seven-layer trifle reference model](tagoreillycom20080909nostarchimages207494.png)'
- en: '**Figure 14-1. The Goodliffe seven-layer trifle reference model**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**图14-1. The Goodliffe七层三明治参考模型**'
- en: At the lowest level of the stack, we find the hardware interface, if the system
    does indeed interact with physical devices. Otherwise, this level is reserved
    for the most basic service, perhaps the OS or a middleware technology like CORBA.
    The highest level will likely be occupied by the fancy interface that the user
    interacts with. As you rise further up the stack, you move further away from the
    hardware, happily insulated by the layers in between in the same way that the
    roof of a house doesn't have to worry about the magma at the earth's core.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈的最低层，我们找到硬件接口，如果系统确实与物理设备交互。否则，这一层被保留用于最基本的服务，可能是操作系统或像CORBA这样的中间件技术。最高层很可能会被用户交互的华丽界面占据。随着你进一步向上移动堆栈，你将越来越远离硬件，中间的层为你提供了愉快的隔离，就像房子的屋顶不必担心地球核心的岩浆一样。
- en: 'At any point, you can brush out all the lower layers and slot in a new implementation
    of the layer below—the system will function as before. This is a key point: It
    means that you can run the same C++ code on any computing platform that supports
    your C++ environment. You can swap the hardware platform without touching your
    application code—relying on the OS layer (for example) to swallow the technical
    differences. Handy.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，你都可以清除所有底层，并插入该层以下的新实现——系统将像以前一样运行。这是一个关键点：这意味着你可以在支持你的C++环境的任何计算平台上运行相同的C++代码。你可以更换硬件平台，而不必触及你的应用程序代码——依赖于操作系统层（例如）来吞没技术差异。方便。
- en: Higher levels use the public interfaces of the layer directly below. Whether
    they can use the public interfaces of the lower levels depends of your definition
    of layering. Sometimes the diagram is fiddled to represent this, like the sherry
    brick in the trifle stack. Whether or not components on the same layer can interconnect
    is also not rigidly defined. You certainly can't use anything from ahigher level;
    if you break this edict, you no longer have a layered architecture, just a meaningless
    diagram drawn in stack form.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 高层直接使用下一层的公共接口。它们是否可以使用低层的公共接口取决于你对分层定义的理解。有时图表会被调整以表示这一点，就像特丽尔蛋糕中的雪莉酒砖。同一层上的组件是否可以互连也不是严格定义的。您当然不能使用来自更高层的东西；如果您违反这一规定，您就不再拥有分层架构，而只是一个以堆叠形式绘制的无意义图表。
- en: As you can see, most layer diagrams are informal. The relative size and position
    ofboxes gives a clue as to importance of a component, and that is generally sufficient
    as an overview. Component connections are implicit, and the methods of communication
    irrelevant. (However, this can be a key architectural concern for the efficiency
    of the system—you won't send gigabytes of data down an RS232 serial port.)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大多数层图都是非正式的。方框的相对大小和位置提供了关于组件重要性的线索，这通常足以作为一个概述。组件连接是隐含的，通信方式无关紧要。（然而，这可能是系统效率的关键架构问题——您不会通过RS232串行端口发送数GB的数据。）
- en: Pipe and Filter Architecture
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道和过滤器架构
- en: This architecture models the logical flow of data through the system. It is
    implemented as a string of sequential modules that each read some data, process
    it, and spit it out again. At the start of the chain is a data generator (maybe
    a user interface or perhaps some hardware harvesting logic). At the end is a data
    sink (perhaps the computer display or a log file). It's the old through-the-grapevine
    telephone game in digital form. Thedata flows down the pipe, encountering the
    various filters en route. The transformations are usually incremental; each filter
    does a single simple process and tends to have very little internal state.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构模拟了数据通过系统的逻辑流程。它通过一系列顺序模块实现，每个模块读取一些数据，处理它，然后再将其输出。链的起点是一个数据生成器（可能是用户界面或可能是某种硬件采集逻辑）。终点是一个数据接收器（可能是计算机显示器或日志文件）。这是数字形式的古老通过葡萄藤电话游戏。数据沿着管道流动，在途中遇到各种过滤器。转换通常是增量式的；每个过滤器执行一个简单的过程，并且通常具有非常小的内部状态。
- en: '![Pipe and Filter Architecture](tagoreillycom20080909nostarchimages207496.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![管道和过滤器架构](tagoreillycom20080909nostarchimages207496.png)'
- en: The pipe and filter architecture requires a well-defined data structure between
    each filter; it has the implicit overhead of repeatedly encoding the output data
    for transmission down the pipe and parsing it back again in each subsequent filter.
    For this reason, the data stream is usually very simple—just a plaintext format.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和过滤器架构要求在每个过滤器之间有一个定义良好的数据结构；它隐含了重复编码输出数据以通过管道传输，并在每个后续过滤器中再次解析的额外开销。因此，数据流通常非常简单——只是一个纯文本格式。
- en: This architecture makes it easy to add functionality by just plugging a new
    filter into the pipeline. Its main downside is error handling. It is hard to determine
    where an error originated in the pipeline by the time a problem manifests itself
    at the sink. It'scumbersome to pass error codes down the chain toward the output
    stage; they need extra encoding and are hard to handle uniformly over several
    separate modules. The filters may use a separate error channel (e.g., `stderr`),
    but error messages can get mixed up all too easily.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构通过只需将新的过滤器插入到管道中就可以轻松添加功能。其主要缺点是错误处理。当问题在接收器处显现时，很难确定错误在管道中的起源。将错误代码传递到输出阶段是繁琐的；它们需要额外的编码，并且在多个单独的模块中统一处理是困难的。过滤器可能使用单独的错误通道（例如，`stderr`），但错误消息很容易混淆。
- en: Client/Server Architecture
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器架构
- en: 'A typically network-based architecture, the client/server model separates functionality
    into two key pieces: the *client* and the *server*. It differs from the older
    *mainframe* style of networked design in the division of work between each part;
    a mainframe "client" is a dumb terminal—little more than a means to capture and
    transmit keypresses, with some output display.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一种典型的基于网络的架构，客户端/服务器模型将功能分为两个关键部分：*客户端*和*服务器*。它与较老的*主机*式网络设计在各个部分之间的工作分配上有所不同；主机“客户端”是一个哑终端——除了捕获和传输按键以及一些输出显示外，别无其他。
- en: '![Client/Server Architecture](tagoreillycom20080909nostarchimages207498.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![客户端/服务器架构](tagoreillycom20080909nostarchimages207498.png)'
- en: '**A SLAP IN THE INTERFACE**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口的打击**'
- en: A key software construction principle is *modularity*, designing systems from
    replaceable components. This is almost a "LEGO brick" approach to construction.
    Done correctly, you should be able to take out a square, blue brick and replace
    it with a slightly fancier red one. If the bricks are the same size and shape
    and have the same kinds of connector, they will fit into the same hole and do
    the same job.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的软件构建原则是*模块化*，即从可替换的组件设计系统。这几乎是一种“乐高积木”式的构建方法。如果做得正确，你应该能够取出一个蓝色方块积木，并用一个稍微花哨一点的红色积木替换它。如果积木大小和形状相同，并且具有相同的连接器，它们将能够放入相同的孔中并完成相同的工作。
- en: 'How do we implement this in software? We define *interfaces*; these are our
    connection points and component barriers. They define the size and shape of each
    component (as seen from the outside, at least) and determine what you have to
    do to provide a like-for-like replacement. Key types of interfaces are:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在软件中实现这一点？我们定义*接口*；这些是我们的连接点和组件障碍。它们定义了每个组件的大小和形状（至少从外部看是这样）并确定你提供类似替换所需做的事情。关键类型的接口包括：
- en: '**APIs**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**APIs**'
- en: '*Application programming interfaces (APIs)* are specified as collections offunctions
    in a physically linked application. To replace a component that implements a particular
    API, you just reimplement all the functions and relink the code.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用程序编程接口（APIs）*被指定为物理链接的应用程序中函数的集合。要替换实现特定API的组件，你只需重新实现所有函数并重新链接代码。'
- en: '**Class hierarchies**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**类层次结构**'
- en: You can design an abstract "interface" class (in Java and C#, you'd actually
    define an `interface`). Then provide any number of concrete implementations that
    derivefrom it and implement that interface.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设计一个抽象的“接口”类（在Java和C#中，你实际上会定义一个`interface`）。然后提供任何数量的具体实现，这些实现从它派生并实现该接口。
- en: '**Component technologies**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件技术**'
- en: Technologies such as COM and CORBA allow your program to determine the correct
    implementation component at run time. Typically, interfaces are defined in an
    abstract *Interface Definition Language (IDL)*. The beauty of this approach is
    that components can be written in any language. It requires middleware or OS support.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如COM和CORBA等技术允许你的程序在运行时确定正确的实现组件。通常，接口在抽象的*接口定义语言（IDL）*中定义。这种方法的优点是组件可以用任何语言编写。它需要中间件或操作系统支持。
- en: '**Data formats**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据格式**'
- en: These formats can form a connection point in designs focused on the movement
    of data rather than the flow of control. You can replace any component in the
    data chain with an analog that interacts with the same data types.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式可以在关注数据移动而不是控制流的设计中形成连接点。你可以用与相同数据类型交互的类似物替换数据链中的任何组件。
- en: As you can see, architecture—indeed, most of software design—is about crafting
    appropriate interfaces. Each of these interface techniques maps to a particular
    architecturalstyle. Pick an interface mechanism that complements the architecture.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，架构——实际上，大多数软件设计——是关于构建适当的接口。每种接口技术都映射到特定的架构风格。选择一种与架构相辅相成的接口机制。
- en: 'The clients of a client/server architecture are richer, more intelligent, and
    generally able to present data in an interactive, graphical manner. Here is a
    more detailed look at the role of the two elements:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端/服务器架构的客户端更加丰富、更加智能，通常能够以交互式、图形化的方式呈现数据。以下是对这两个元素角色的更详细分析：
- en: '**Server**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**'
- en: The server provides certain well-defined services to clients. It will generally
    be a powerful computer dedicated to providing specific functionality or to managing
    a resource (shared files, printers, a database, or pooled processing power).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器向客户端提供某些定义良好的服务。它通常是一台功能强大的计算机，专门用于提供特定功能或管理资源（共享文件、打印机、数据库或池化处理能力）。
- en: The server provides certain well-defined services to clients. It will generally
    be a powerful computer dedicated to providing specific functionality or to managing
    a resource (shared files, printers, a database, or pooled processing power).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器向客户端提供某些定义良好的服务。它通常是一台功能强大的计算机，专门用于提供特定功能或管理资源（共享文件、打印机、数据库或池化处理能力）。
- en: '**Client**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**'
- en: The client consumes a server's services. It sends off requests and processes
    the results that are returned. Some clients are dedicated terminals which only
    fulfill one role; other clients serve many functions (for example, a "client"
    application may run on a standard desktop PC that can also browse the web and
    view email).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端消费服务器的服务。它发送请求并处理返回的结果。一些客户端是专用终端，只履行一个角色；其他客户端提供许多功能（例如，“客户端”应用程序可能运行在标准的桌面PC上，该PC也可以浏览网页和查看电子邮件）。
- en: There can be many different types of clients using one server, all performing
    the same set of requests but in different ways. One client might be web based,
    one might have a GUI interface, while another might provide command line access.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有使用一个服务器但类型不同的许多不同类型的客户端，它们执行相同的一组请求，但方式不同。一个客户端可能是基于Web的，一个可能有一个GUI界面，而另一个可能提供命令行访问。
- en: This client/server approach is sometimes known as a *two-tier* architecture,
    for obvious reasons. It's very common and is seen throughout the software development
    world. The means of communication between client and server varies—it's simplest
    to use standard network protocols, but you may also see use of remote procedure
    calls (RPC), remote SQL database queries, or even proprietary application-specific
    protocols.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这种客户端/服务器方法有时被称为*两层*架构，原因很明显。它非常常见，在软件开发世界的各个方面都可以看到。客户端和服务器之间的通信方式多种多样——最简单的是使用标准网络协议，但你也可能看到使用远程过程调用（RPC）、远程SQL数据库查询，甚至专有的应用程序特定协议。
- en: There are various ways of splitting work between the two components. The main
    application logic (also known as *business logic*) may run on either the client
    or server, depending on how intelligent and specialized the client is supposed
    to be. As more application logic is pushed down to the client, the design becomes
    less flexible—separate clients have to reimplement similar features, negating
    the benefit of the central server. Clients are generally concerned with providing
    sensible human interfaces to the published server functionality.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个组件之间分配工作的方法有很多种。主要的应用逻辑（也称为*业务逻辑*）可能运行在客户端或服务器上，这取决于客户端被期望有多智能和专业化。随着越来越多的应用逻辑被推送到客户端，设计变得不那么灵活——单独的客户端需要重新实现类似的功能，从而抵消了中央服务器的优势。客户端通常关注提供对已发布服务器功能的合理的人机界面。
- en: We sometimes see an extension of this two-tier design, which introduces another
    layer (the *middle tier*). This component is explicitly designed to contain the
    business logic, separating it from both the client application (which is now most
    definitely only an interface) and the back-end data storage. This is a *three-tier*
    architecture.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会看到这种两层设计的扩展，它引入了另一层（*中间层*）。这个组件被明确设计用来包含业务逻辑，将其从客户端应用程序（现在是肯定只是一个界面）和后端数据存储中分离出来。这是一个*三层*架构。
- en: 'A client/server approach is different from a *peer-to-peer* architecture, where
    no network node has more capability or importance than any other. Peer-to-peer
    architectures are harder to deploy but more tolerant of faults. The client/server
    design is crippled when the server is unavailable (through some software fault
    or routine maintenance): No client will be able to operate until the server comes
    back to life. For this reason, client/server installations generally require a
    designated administrator to keep all systems running smoothly.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端/服务器方法与*对等网络*架构不同，在对等网络架构中，没有网络节点比其他节点有更多的能力或重要性。对等网络架构部署起来更困难，但更能容忍故障。当服务器不可用（由于某些软件故障或常规维护）时，客户端/服务器设计就会受损：没有客户端能够操作，直到服务器恢复运行。因此，客户端/服务器安装通常需要一个指定的管理员来确保所有系统运行顺畅。
- en: Component-Based Architecture
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件化架构
- en: This architecture decentralizes control and splits it into a number of separate
    collaborating *components* rather than a single monolithic structure. It is an
    object-oriented approach, but doesn't necessarily require implementation in an
    OO language. Each component's public interface is typically defined in an *Interface
    Definition Language (IDL)* and is separate from any implementation, although some
    component technologies (like .NET's built-in component support) can determine
    this from the implementation code itself.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构将控制权去中心化，并将其分割成多个独立的协作*组件*，而不是一个单一的整体结构。这是一个面向对象的方法，但并不一定需要用面向对象的语言实现。每个组件的公共接口通常在*接口定义语言（IDL）*中定义，并且与任何实现都分开，尽管一些组件技术（如.NET内置的组件支持）可以从实现代码本身确定这一点。
- en: '![Component-Based Architecture](tagoreillycom20080909nostarchimages207500.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![组件化架构](tagoreillycom20080909nostarchimages207500.png)'
- en: Component-based design arrived with the lure of assembling applications quickly
    out of prefabricated components, supposedly enabling plug-and-play solutions.
    It's still up for debate how much of a success this has been. Not all components
    are designed for reuse (it's hard work), and it's not always easy to find a component
    that does what you want it to do. It's easiest for UIs, where popular frameworks
    and established marketplaces exist.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的设计随着从预制组件快速组装应用程序的诱惑而来，据说可以实现即插即用的解决方案。关于这已经取得了多大的成功，仍然存在争议。并非所有组件都设计用于重用（这是一项艰苦的工作），而且并不总是容易找到一个能够完成你想要它完成的任务的组件。对于UIs来说，这是最容易的，因为存在流行的框架和成熟的市场。
- en: The core of a component-based architecture is a communication infrastructure,
    or *middleware*, which allows components to be plugged in, to broadcast their
    existence, and to advertise the services they provide. Components are used by
    looking up this information through a middleware mechanism, rather than by hardwiring
    a direct connection between two components. Common middleware platforms include
    CORBA, JavaBeans, and COM; each have different strengths and weaknesses.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的架构的核心是一个通信基础设施，或称*中间件*，它允许组件被插入、广播其存在，并宣传它们提供的服务。组件是通过中间件机制查找这些信息来使用的，而不是通过硬编码两个组件之间的直接连接。常见的中间件平台包括CORBA、JavaBeans和COM；每个都有其不同的优势和劣势。
- en: A component^([[1](#ftn.CHP-14-FN-1)]) is essentially an implementation unit.
    It honors one (maybe more) specific published IDL interfaces. This interface is
    how clients of the component interact with it. There are no back doors. The client
    is concerned with dealing with an instance of that interface, rather than in how
    the component is implemented.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件^([[1](#ftn.CHP-14-FN-1)])本质上是一个实现单元。它遵循一个（可能更多）特定的已发布IDL接口。这个接口是组件客户端与之交互的方式。没有后门。客户端关注的是处理该接口的一个实例，而不是组件的实现方式。
- en: Each component is an individual, independent piece of code. Behind its interface,
    it implements some logic (perhaps business logic or user interface activity) and
    contains some data, which may just be local or may be published (say a filestore
    or database component). Components don't need to know much about one another.
    If they *are* tightly coupled, then the architecture is just an obfuscated monolithic
    system.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都是一段独立的代码。在其接口背后，它实现了一些逻辑（可能是业务逻辑或用户界面活动）并包含了一些数据，这些数据可能是局部的，也可能是公开的（例如文件存储或数据库组件）。组件不需要了解彼此太多。如果它们*紧密耦合*，那么架构就是一个被混淆的单一系统。
- en: Component-based architectures can be deployed in a networked environment with
    components on different machines, but they can just as easily exist as a single
    machine installation. This may depend on the type of middleware in use.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的架构可以在网络环境中部署，组件分布在不同的机器上，但它们也可以作为单一机器的安装存在。这可能会取决于所使用的中间件类型。
- en: Frameworks
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: Instead of developing a new architecture for a specific project, it may be appropriate
    to use an existing *application framework* and add development into that skeleton.
    A framework is an extensible library of code (usually a set of co-operating classes)
    that forms a reusable design solution for a particular problem domain. Most of
    the work in a framework has been done for you, with the remaining pieces following
    a fill-in-the-blanks approach. Different frameworks follow different architectural
    models; by using a framework, you commit to its particular style.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在为特定项目开发新架构之前，使用现有的*应用程序框架*并将其添加到该框架结构中可能更为合适。框架是一组可扩展的代码库（通常是一组协作类），为特定问题域提供了一个可重用的设计解决方案。框架中的大部分工作已经为你完成，剩余的部分遵循填空法。不同的框架遵循不同的架构模型；使用框架，你承诺遵循其特定的风格。
- en: '![Frameworks](tagoreillycom20080909nostarchimages207502.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![框架](tagoreillycom20080909nostarchimages207502.png)'
- en: Frameworks differ from traditional libraries in the way they interact with your
    code. When using a library, you make explicit calls into the library components
    under your own thread of control. A framework turns this around; it is responsible
    for the structure and flow of control. It calls into your supplied code as and
    when necessary.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 框架与传统库在交互方式上有所不同。当使用库时，你会在自己的控制线程中明确调用库组件。框架则相反；它负责结构和控制流程。它根据需要调用你提供的代码。
- en: Sitting alongside off-the-shelf frameworks are architectural *design patterns*.
    While not an architectural style in their own right, patterns are small-scale
    architectural templates. They are micro-architectures for a few collaborating
    components, distilling a recurring structure of communication. Architectural patterns
    describe common component structures at the architectural design level, explaining
    how they fulfill the requirements of a given context. Patterns are a set of design
    best practices, described in the ubiquitous GoF book (Gamma et al. 94) and numerous
    subsequent publications (see "[DESIGN PATTERNS](ch13s05.html#design_patterns "DESIGN
    PATTERNS")" on page 255).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 与现成的框架并列的是架构 *设计模式*。虽然它们本身不是一种架构风格，但模式是小型架构模板。它们是为几个协作组件的微观架构，提炼出重复的结构通信。架构模式描述了在架构设计层面的常见组件结构，解释了它们如何满足特定上下文的要求。模式是一套设计最佳实践，在无处不在的GoF书中（Gamma等，94）和许多后续出版物中描述（参见第255页上的"[DESIGN
    PATTERNS](ch13s05.html#design_patterns "DESIGN PATTERNS")"）。
- en: '* * *'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-14-FN-1)]) We've already talked about components as modules, ephemeral
    implementation units. But this is a new definition for the word, quite specific
    to the world of component-based architecture. Sadly, the terms are overloaded
    with multiple meanings.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-14-FN-1)]) 我们已经讨论过组件作为模块、短暂的实现单元。但这是对这个词的新定义，非常具体地针对基于组件的架构世界。遗憾的是，这些术语被多重含义所淹没。
- en: In a Nutshell
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一瞥
- en: 'The Roman architect Vitruvius made a timeless statement of what constitutes
    good architectural design: strength (*firmitas*), utility (*utilitas*), and beauty
    (*venustas*). (Vitruvius) This holds true forour software architectures. Without
    a well-defined, well-communicated architecture, a software project will lack a
    cohesive internal structure. It will become brittle, unstable, and ugly. Eventually,
    it will reach a breaking point.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马建筑师维特鲁威对构成良好建筑设计的要素做出了永恒的声明：强度（*firmitas*）、实用性（*utilitas*）和美观（*venustas*）。（维特鲁威）这对我们的软件架构同样适用。如果没有一个定义良好、沟通良好的架构，软件项目将缺乏一致的内结构。它将变得脆弱、不稳定、丑陋。最终，它将达到破裂点。
- en: All this talk of pasta has made me hungry. I'm off to build a seven-layer reference
    trifle. . . .
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于意大利面的谈话让我饿了。我要去制作一个七层的参考甜点。 . . .
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 精通编程的程序员 . . . | 不擅长编程的程序员 . . . |'
- en: '| --- | --- |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand their software architecture and write new code within it
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解他们的软件架构，并在其中编写新代码
- en: Can apply the appropriate architecture to each design scenario
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将适当的架构应用于每个设计场景
- en: Create simple architectures that are beautiful and elegant—they appreciate the
    aesthetics of software design
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单、美丽、优雅的架构——他们欣赏软件设计的审美
- en: Capture the system architecture in a live document that is continuously updated
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个持续更新的活文档中捕捉系统架构
- en: Relay problems with the structure back to the system architects in an attempt
    to improve the design
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结构问题反馈给系统架构师，试图改进设计
- en: '|'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Write code regardless of any overall architectural vision—resultingin unsympathetic
    blemishes and unintegrated components
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不考虑任何整体架构愿景而编写代码——导致不和谐的瑕疵和未集成的组件
- en: Fail to perform any high-level design before ploughing into code, ignoring any
    architectural alternatives
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在投入代码编写之前未能进行任何高级设计，忽略任何架构替代方案
- en: Leave architectural information locked inaccessibly in people's heads or in
    a dangerously out-of-date specification
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将架构信息锁在人们的头脑中或在一个危险过时的规范中无法访问
- en: Put up with inadequate architectures, adding more badly designed code rather
    than fixing the underlying problems—they can't be bothered to open a larger canof
    worms
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忍受不完善的架构，添加更多设计糟糕的代码而不是修复根本问题——他们懒得打开更大的罐头
- en: '|'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![In a Nutshell](tagoreillycom20080909nostarchimages207504.png.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![一瞥](tagoreillycom20080909nostarchimages207504.png.jpg)'
- en: See Also
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。不安全感复杂")'
- en: Security concerns must be addressed by a system architecture.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 安全问题必须由系统架构来解决。
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。宏伟蓝图")'
- en: Code *design* is the subsequent level of code construction.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 *设计* 是代码构建的下一级。
- en: '[Chapter 15](ch15.html "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章](ch15.html "第15章。软件进化还是软件革命？")'
- en: Architecture is the start of your software's life, but it is by no means the
    only thing that steers its development.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是软件生命的起点，但绝不是唯一引导其发展的因素。
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章。程序配方")'
- en: Where architectural design fits into the software development process.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计在软件开发过程中的位置。
- en: Get Thinking
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 522.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些问题的详细讨论可以在第522页的"[附录A](apa.html "附录A. 答案与讨论")"部分找到。
- en: Mull It Over
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: Define where *architecture* ends and *software design* begins.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义*架构*结束和*软件设计*开始的地方。
- en: In what ways can a bad architecture affect a system? Are there parts thatwouldn't
    be affected by architectural flaws?
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 坏的架构以何种方式影响系统？有没有部分不会受到架构缺陷的影响？
- en: How easy is it to repair architectural deficiencies once they become apparent?
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦架构缺陷显现，修复起来有多容易？
- en: To what extent does architecture affect the following things?
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 架构在多大程度上影响以下事物？
- en: System configuration
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统配置
- en: Logging
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录
- en: Error handling
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Security
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全性
- en: What experience or qualifications are required to be called a *software architect*?
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成为一名*软件架构师*需要哪些经验或资格？
- en: Should sales strategy influence architecture? If so, how? If not, why?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销售策略应该影响架构吗？如果是，如何影响？如果不是，为什么？
- en: How would you architect for *extensibility*? How wouldyou architect for *performance*?
    How do these design goals affect the system, and how do they complement one another?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何为*可扩展性*进行架构设计？你将如何为*性能*进行架构设计？这些设计目标如何影响系统，以及它们是如何相互补充的？
- en: Getting Personal
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: How diverse is the range of architectural styles to which you are accustomed?
    What do you have the most experience with—how does it affect the software you
    write?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你习惯的架构风格范围有多广？你最有经验的是哪种——它如何影响你编写的软件？
- en: What personal experience do you have of architectures that succeeded or failed?
    What made them winning solutions or a hindrances?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在架构成功或失败的个人经验有哪些？是什么因素使它们成为成功的解决方案或障碍？
- en: Get every developer on your current project to draw a picture of the system
    architecture—individually (without talking to anyone) and without any reference
    to system documentation or the code. Compare the pictures. See what strikes you
    about each developer's efforts—aside from the relative artistic merit!
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让你的每个开发者为当前项目的系统架构画一张图——单独（不与任何人交谈）且不参考任何系统文档或代码。比较这些图。看看哪些地方让你印象深刻——除了相对的艺术价值之外！
- en: Do you have an architectural description that's commonly available for your
    current project? How up to date is it? Which kinds of view are you using? If you
    needed to explain the system to a newcomer or a potential customer, what would
    you really need to have documented?
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你当前项目是否有普遍可用的架构描述？它有多新？你使用的是哪种类型的视图？如果你需要向新来者或潜在客户解释系统，你真正需要记录下什么？
- en: How does your system's architecture compare to the architecture of your competitors
    in the marketplace? How has your architecture been defined to determine your project's
    success?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的系统架构与市场上竞争对手的架构相比如何？你的架构是如何定义的，以确定项目的成功？
- en: Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。软件进化还是软件革命？
- en: '*How Does Code Grow?*'
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*代码是如何成长的？*'
- en: I cannot say whether things will get better if we change; what I can say is
    they must change if they are to get better.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能说如果我们改变，事情是否会变得更好；我能说的是，如果它们要变得更好，它们必须改变。
- en: --G.C. Lichtenberg
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: --G.C. 李希滕贝格
- en: 'If only software grew like a plant. You''d put the seed of an idea into some
    fertile programming soil, add a little water, and wait. You''d tend it carefully:
    Fertilize it, keep it in good light, and cover it to keep the birds off. In time,
    a code seedling would sprout, and when the program plant was big enough, you could
    release it to the world. For extra functionality you''d keep watering and add
    some more fertilizer, and it would continue to develop. The trunk would strengthen
    in order to support the new branches and the program would stay in perfect balance.
    If it grew in a direction you didn''t like, a little pruning would soon set it
    straight.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件能像植物一样生长。你只需将一个想法的种子放入肥沃的编程土壤中，加一点水，然后等待。你会小心地照料它：施肥，保持良好的光照，并覆盖它以防止鸟儿啄食。随着时间的推移，代码幼苗会发芽，当程序植物足够大时，你就可以将它释放到世界上了。为了增加额外的功能，你会继续浇水并添加一些肥料，它就会继续发展。树干会变得更加强壮，以支撑新的分支，程序将保持完美的平衡。如果它向你不喜欢的方向发展，稍加修剪就能让它变得笔直。
- en: Unfortunately, the Real World does not work like this. Not by a long shot.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，现实世界并不像这样运作。根本不是这样。
- en: 'Software *is* a live entity. It''s not sentient or organic, but it has its
    own kind of life: It is conceived, develops steadily, and eventually reaches maturity.
    Then it''s sent out into the Big Wide World to make a living and hopefully garner
    respect and admiration. It may continue to develop, perhaps to the point where
    it gains a middle age spread and loses its youthful looks. Over time, it grows
    tired and old and is eventually retired, put out to pasture in a digital farmyard
    where it can gracefully die.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 软件确实是一个有生命的实体。它不是有感知或有生命的，但它有自己的生命形式：它是被构思出来的，稳步发展，最终达到成熟。然后它被送到广阔的世界中去谋生，并希望获得尊重和钦佩。它可能还会继续发展，也许会发展到中年期，失去年轻时的外观。随着时间的推移，它会变得疲惫和衰老，最终被退休，被安置在数字农场中，在那里它可以优雅地死去。
- en: This chapter looks at how we cultivate software, especially after the initial
    round of development. Programs require thoughtful tending and seldom receive the
    care and attention they really deserve. What can we do to prevent a slowly spreading
    code cancer that leads to early death?
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨我们如何培养软件，特别是在初始开发阶段之后。程序需要深思熟虑的照料，很少得到它们真正应得的关心和注意。我们怎样才能防止缓慢蔓延的代码癌症，导致过早死亡？
- en: To answer this, we'll work backward. We'll take a look at the symptoms of bad
    code growth, explore how we grow our code, and determine some strategies to develop
    healthier software.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们将从后往前看。我们将研究糟糕代码增长的症状，探讨我们如何增长我们的代码，并确定一些策略来开发更健康的软件。
- en: '**MORE METAPHORS FOR SOFTWARE CONSTRUCTION**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多关于软件构建的隐喻**'
- en: 'We''ve already examined the metaphor of *building* and discussed what it tells
    us about the software construction process (see "[DO WE REALLY BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question
    "DO WE REALLY BUILD SOFTWARE?")" on page 177 ). In this chapter, I''ll introduce
    some more metaphors. They provide different insights into our programming methods:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了“建造”的隐喻，并讨论了它告诉我们关于软件构建过程的内容（参见第177页的“[我们真的在建造软件吗？](ch10.html#do_we_really_build_software_question
    "我们真的在建造软件吗？")”）。在本章中，我将介绍一些更多的隐喻。它们为我们提供了对编程方法的不同的见解：
- en: '**Growing software**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件的成长**'
- en: 'This relates to how we extend existing software, usually by adding new features.
    Bug fixing isn''t growth: It is tending to diseased parts of the code.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们是怎样扩展现有软件的相关的，通常是通过添加新功能。修复错误不是增长：它是照料代码中的病态部分。
- en: 'Our code does grow as we add to it, but programming is not a perfect analog
    of plant growth—we have far more control and influence over code growth than over
    a seedling. Code grows more like an oyster making a pearl: slowly, by the progressive
    accretion of small extra parts.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向代码中添加内容时，代码确实会增长，但编程并不完全等同于植物生长——我们对代码增长的控制和影响力远大于对幼苗的控制。代码的增长更像是牡蛎形成珍珠的过程：缓慢地，通过逐渐积累小的额外部分。
- en: '**Evolving software**'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件的进化**'
- en: 'Another common construction metaphor is the *evolution* of software. We start
    with a single-celled code organism and gradually see it develop into a larger,
    more complex beast. This is an incremental process; the software develops through
    a number of evolutionary stages. However, there are a few key differences to biological
    evolution:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的构建隐喻是软件的“进化”。我们从一个单细胞代码生物体开始，逐渐看到它发展成为一个更大、更复杂的生物。这是一个渐进的过程；软件通过多个进化阶段发展。然而，与生物进化有几个关键的区别：
- en: We are the ones deliberately making changes; the software doesn't develop by
    itself.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是那些故意进行更改的人；软件不是自行发展的。
- en: We don't employ *natural selection* to choose the best design. We have neither
    the time nor the inclination to develop many different variants of the same program.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不使用**自然选择**来选择最佳的设计。我们既没有时间也没有意愿去开发同一程序的许多不同变体。
- en: We do have the opportunity to iteratively improve the quality of our code, mimicing
    evolutionary development somewhat. We can use experience gained from previous
    releases to adapt the code to its natural habitat, ensuring its longterm survival.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实有机会迭代地提高我们代码的质量，某种程度上模仿进化发展。我们可以使用从前一个版本中获得的经验来适应代码的自然栖息地，确保其长期生存。
- en: Software Rot
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件退化
- en: When you're green, you're growing. When you're ripe, you rot.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 当你年轻的时候，你在成长。当你成熟的时候，你在腐烂。
- en: --Ray Kroc
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: --Ray Kroc
- en: Bad things happen to good code. No matter how well you start, no matter how
    honorable your intentions, no matter how pure your design and how clean the first
    release's implementation, time will warp and twist your masterpiece. Never underestimate
    the ability of code to acquire warts and blemishes during its life.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码也会遇到坏事。无论你开始得多好，无论你的意图多么高尚，无论你的设计多么纯粹，第一版实现多么干净，时间都会扭曲和扭曲你的杰作。永远不要低估代码在其生命周期中获得瑕疵的能力。
- en: There is a misconception that software only develops during its initial stages
    of life. The *maintenance* phase of software development^([[1](#ftn.CHP-15-FN-1)])
    is always the longest. It's where most of the overall effort goes—even if this
    effort is not scrunched into a compact ball, like the initial design and development
    work. B.W. Boehm, a respected computer science professor, observed that 40 to
    80 percent of total development time is spent in maintenance. (Boehm 76)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种误解认为软件只在其生命周期的初期阶段发展。软件开发中的**维护**阶段总是最长的。[1](#ftn.CHP-15-FN-1) 它是大部分总体努力所在的地方——即使这种努力并没有像最初的设计和开发工作那样被压缩成一个紧凑的球。B.W.
    Boehm，一位受人尊敬的计算机科学教授，观察到40%到80%的总开发时间都花在了维护上。（Boehm 76）
- en: 'Software is never expected to stand still after a release. There will always
    be odd faults to fix, no matter how much testing went on. Customers demand new
    features. Requirements change under the development team''s feet. Assumptions
    that were made during development prove to be incorrect in the Real World and
    require adjustments. The upshot: More code is written *after* the project is considered
    complete.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 软件在发布后永远不会停滞不前。无论进行了多少测试，总会有些奇怪的错误需要修复。客户要求新功能。需求在开发团队脚下发生变化。在开发过程中做出的假设在现实世界中证明是错误的，需要调整。结果是：在项目被认为完成后，还会编写更多的代码。
- en: 'During the initial development stages, you can keep a firm grip on your code
    and play with it as much as you like within the available time constraints. After
    it has been released, you''re more restricted. These restrictions may be practical:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始开发阶段，你可以在可用的时间限制内牢牢掌握你的代码，随心所欲地玩弄它。一旦它发布后，你的限制就更多了。这些限制可能是实际的：
- en: Changes have to be minimized to reduce their impact on the carefully tested
    codebase.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更必须最小化，以减少它们对经过仔细测试的代码库的影响。
- en: Published APIs are already being used by clients, so they are harder to modify.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已发布的API已经被客户使用，因此它们更难修改。
- en: The UI is familiar to users and can't be changed gratuitously.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面对用户来说是熟悉的，不能随意更改。
- en: 'The restrictions may also be psychological, based on the developers'' (potentially
    erroneous) preconceptions:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 限制也可能是心理上的，基于开发者（可能错误的）先入之见：
- en: The code has always worked *this* way, so we can't change it like *that*.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码一直是这样工作的，所以我们不能像那样更改它。
- en: It's too hard to revise the architecture at this late stage.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段修改架构太难了。
- en: It's not worth the time or expense to make this modification properly now; the
    product won't be around for very much longer.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在花时间或费用来正确进行这种修改不值得；产品不会存在很长时间。
- en: The restriction might even be a simple lack of understanding—a maintenance programmer
    may not understand original author's mental model of the code; this leads to inappropriate
    modifications.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 限制甚至可能是一种简单的缺乏理解——维护程序员可能不理解原始作者的代码思维模型；这导致不适当的修改。
- en: There is a fine line between maintaining an existing product and developing
    the next version. Where it lies is a moot point. But whatever you're doing, the
    original codebase gets modified—sometimes by the original author, often by someone
    else. This is where the rot sets in. It's a *damned if you do, damned if you don't*
    scenario; whatever you do, the code will rot.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护现有产品和发展下一个版本之间有一条很细的界限。它在哪里是一个无足轻重的问题。但无论你做什么，原始代码库都会被修改——有时是原始作者，通常是其他人。这就是腐烂开始的地方。这是一个“做也受罪，不做也受罪”的场景；无论你做什么，代码都会腐烂。
- en: If you never touch the code again, if you don't keep it up to date with fixes
    and modifications, the program will degrade. In the worse case, it will stop working
    as the OS changes or its assumptions become outdated. The Y2K bug is a glorious
    example of this.^([[2](#ftn.CHP-15-FN-2)]) Or the program will putrefy as competing
    solutions develop more features and gain more popularity. Untouched code slowly
    rots away.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再也不碰代码，如果你不通过修复和修改来保持其更新，程序将会退化。在最坏的情况下，当操作系统发生变化或其假设变得过时时，程序将停止工作。Y2K错误就是这一点的光辉例子。[2](#ftn.CHP-15-FN-2)
    或者，随着竞争解决方案开发出更多功能和获得更多人气，程序可能会腐烂。未触及的代码会慢慢腐烂。
- en: 'If you do make extensions and fixes as the code grows, it might still rot.
    When fixing a fault, the programmer often introduces more faults as a side effect.
    Brooks found that as many as 40 percent of fixes introduced new faults. (Brooks
    95) "The Programmer''s Drinking Song" (sung to the tune of "99 Bottles of Beer
    on the Wall"), written by a minstrel unknown, sums this up neatly:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你随着代码的增长进行扩展和修复，代码仍然可能会腐烂。在修复一个故障时，程序员往往会作为副作用引入更多的错误。布鲁斯发现，高达40%的修复引入了新的错误。(布鲁斯95)
    由一位不知名的吟游诗人创作的《程序员饮酒歌》（以“墙上有99瓶啤酒”的曲调演唱），简洁地总结了这一点：
- en: 99 little bugs in the code, 99 bugs in the code,
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码中有99个小错误，代码中有99个小错误，
- en: ''
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fix one bug, compile it again, 101 little bugs in the code.
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修复一个错误，再次编译，代码中有101个小错误。
- en: ''
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Repeat until BUGS == 0)
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (重复直到BUGS == 0)
- en: 'Even bug-free modifications can cause code turmoil. Quick-and-dirty fixes pile
    atop one another, putting nail after nail into the original design''s coffin,
    making future maintenance harder. The plant analogy is useful here: If more heavy
    branches grow at the top and nothing is reinforcing the trunk, the entire codebase
    becomes less stable. Eventually, and inevitably, it totters over. Healthy plants
    don''t grow like that; why should we expect our code to?'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是没有任何错误的修改也可能导致代码混乱。草率且不彻底的修复层层叠加，一钉接一钉地钉进原始设计的棺材，使得未来的维护变得更加困难。植物类比在这里很有用：如果顶部生长出更多的重枝，而没有任何东西加固树干，整个代码库的稳定性就会降低。最终，不可避免地，它会摇摇欲坠。健康的植物不会这样生长；我们为什么期望我们的代码会这样呢？
- en: '**KEY CONCEPT**'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Be aware of how easily code degrades as it is modified. Don''t be satisfied
    with changes that leave the system in a worse state*.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意代码在修改过程中如何容易退化。不要满足于让系统处于更糟糕状态的变化*。'
- en: Does all this sound unduly pessimistic? Surely code won't rot if you're careful?
    Perhaps, but adequate care is not taken in today's software factories. It's a
    culture thing. Fixes must be quick and cheap. Programs have a habit of hanging
    around longer than they were ever intended to. Many quick hacks live on, well
    past their expected lifetimes.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来过于悲观了吗？如果你小心谨慎，代码不会腐烂？也许吧，但今天的软件工厂并没有采取足够的谨慎。这是一个文化问题。修复必须快速且便宜。程序有习惯于比预期更长时间地存在。许多快速修复的代码活过了它们的预期寿命。
- en: '* * *'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-15-FN-1)]) That is, work done after initial delivery that isn't
    considered a major new release.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-15-FN-1)]) 即，初始交付后所做的、不被视为重大新版本的工作。
- en: ^([[2](#CHP-15-FN-2)]) Many old programs were never expected to be operational
    in the year 2000, so programmers considered it safe to encode years in two digits—`76`
    rather than `1976`. As the digits rolled over to `00`, all their date calculations
    went awry.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-15-FN-2)]) 许多旧程序从未被期望在2000年运行，因此程序员认为用两位数字编码年份是安全的——`76`而不是`1976`。当数字翻转到`00`时，所有他们的日期计算都出了问题。
- en: The Warning Signs
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警示信号
- en: 'Switch on your code radar, and constantly look out for rotten code. Beware
    of the telltale signs: Rot sets in with any change that leads to a lack of clarity
    or that makes the system more complex. Unnecessary complexity comes in many guises.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的代码雷达，并持续寻找腐烂的代码。警惕这些明显的迹象：任何导致缺乏清晰度或使系统更复杂的变更都会导致腐烂。不必要的复杂性以多种形式出现。
- en: 'Here are some, the flashing red lights and Klaxon calls:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些，闪烁的红色灯光和警报声：
- en: The code is littered with many large classes and convoluted functions.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中充斥着许多大型类和复杂的函数。
- en: Function names are cryptic or misleading. Functions have suprising side effects
    not implied by their names.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称晦涩或误导。函数有与名称不符的意外副作用。
- en: 'There is no structure: It''s not clear where to look for a certain bit of functionality.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有结构：不清楚在哪里查找特定的功能。
- en: 'There is duplication: Many separate bits of code crop up to do the same thing.'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在重复：许多独立的代码片段执行相同的功能。
- en: 'There is high coupling: Complex module interconnections and dependencies mean
    that a small change in one place ripples out across the entire code, even into
    seemingly unrelated modules. (See "[Modularity](ch13s04.html#modularity "Modularity")"
    on page 247).'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在高耦合：复杂的模块互连和依赖关系意味着一处小的变化在整个代码中产生涟漪，甚至影响到看似无关的模块。（参见第247页的“[模块化](ch13s04.html#modularity
    "模块化")”）。
- en: As data flows through the system it is repeatedly converted between different
    representations (e.g., display data is transferred between `std::string`, `char*`,
    Unicode, UTF-8, and back again).
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据在系统中流动时，它被反复转换为不同的表示形式（例如，显示数据在`std::string`、`char*`、Unicode、UTF-8之间传输，然后再转换回来）。
- en: APIs become blurred; once neat interfaces are now far too broad in scope, with
    new features being thoughtlessly added.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API变得模糊；曾经整洁的接口现在范围过于广泛，新功能被不加思考地添加。
- en: APIs change rapidly between code revisions.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码版本之间API变化迅速。
- en: Bits of private implementation leak out of public APIs to enable other quick
    hacks.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有实现的部分泄露到公共API中，以实现其他快速修补。
- en: 'The code is littered with work-arounds: fixes for symptoms but not for causes.
    They hide the real problems. The edges of the system are cluttered with these,
    leaving faults lurking at the core.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中充斥着权宜之计：针对症状的修复，而不是针对原因。它们隐藏了真正的问题。系统的边缘充满了这些权宜之计，让错误潜伏在核心。
- en: There are functions with enormous parameter lists. Many don't use these parameters,
    passing them through to subordinate function calls.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在着参数列表巨大的函数。许多函数没有使用这些参数，只是将它们传递给下级函数调用。
- en: You find code that's too scary to even think about improving. You have no idea
    if you'll improve it, break it subtly, or make it even worse.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会发现代码太可怕，甚至不敢考虑改进。你不知道你会改进它，还是微妙地破坏它，或者让它变得更糟。
- en: New features are added with no supporting documentation; the existing documents
    are out of date.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新功能添加时没有相应的支持文档；现有文档已过时。
- en: The code compiles noisily, with many warnings generated.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编译时噪声很大，产生了许多警告。
- en: You find comments saying, *Don't touch this*. . . .
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会发现注释说，*不要碰这个*...。
- en: Many of these forms of rot are particularly visible in the code and can be seen
    with a quick inspection or using certain tools. However, there is a class of more
    subtle, invisible degradations that usually manifest at a higher level than syntactic
    gunk. Modifications that fudge the original code architecture or that subtly circumvent
    program conventions are much harder to spot until you're deeply immersed immersed
    in the system.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这些腐烂的形式在代码中特别明显，可以通过快速检查或使用某些工具来识别。然而，还存在一类更微妙、不可见的退化，它们通常在比语法垃圾更高的层面上表现出来。那些篡改原始代码架构或微妙地规避程序约定的修改很难被发现，直到你深入沉浸在系统中。
- en: '**KEY CONCEPT**'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Learn to detect putrid code. Know the warning signs and handle rotten code
    with the utmost care*.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '*学会检测恶臭代码。了解警示信号，并极其小心地处理烂代码*。'
- en: 'Why do we make such a big mess of code? The answer is simple: *complexity*.
    A program is a huge collection of information organized on many levels: the architecture,
    its component design, the interfaces, the implementation of each bit of code,
    and so on. That''s a lot to understand before you start work on a project. With
    tight deadlines, there isn''t enough time to work out how a few lines actually
    work, let alone how they fit into the overall picture. We haven''t yet learned
    to manage this vast complexity.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么把代码搞得这么乱？答案很简单：*复杂性*。一个程序是一个包含大量信息的大型集合，这些信息在多个层面上组织：架构、组件设计、接口、每个代码片段的实现，等等。在开始项目工作之前，你需要理解这些内容。在紧迫的截止日期下，没有足够的时间去弄清楚几行代码的实际工作方式，更不用说它们如何融入整体画面。我们还没有学会管理这种巨大的复杂性。
- en: How Does Code Grow?
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码是如何增长的？
- en: No code development ever follows the classic model of lock down all requirements,
    design completely, code completely, integrate, test, release. Unexpected modifications
    happen to an existing codebase. New pieces are grafted in somehow. It's an incremental
    development cycle toward ever shifting goalposts.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 没有代码开发会遵循经典的模型：锁定所有需求，完全设计，完全编码，集成，测试，发布。意外的修改发生在现有的代码库上。以某种方式嫁接了新的部分。这是一个朝着不断变化的终点线的增量开发周期。
- en: 'Code growth happens by one of the following mechanisms, loosely ranked in order
    of disgust:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 代码增长是通过以下机制之一发生的，按令人厌恶的程度大致排序：
- en: '**Luck**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**运气**'
- en: This is the most frightening way to make code, and far too common. Code that
    grows by luck never had any design. It was modified without thought. Its structure
    is down to happenstance, and it's a miracle it works at all.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这是制作代码最令人恐惧的方式，而且过于常见。通过运气增长的代码从未有任何设计。它是未经思考就修改的。其结构完全取决于偶然，它竟然能工作真是个奇迹。
- en: Even if your code originally *was* designed carefully, maintenance modifications
    can follow this happy-go-lucky approach. Hit-and-hope fixes may just mask the
    immediate problem and make the real fix harder later on.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的代码最初**确实**是精心设计的，维护修改也可能采取这种随遇而安的方法。击中并希望修复可能只是掩盖了立即的问题，并使后续的真正修复更加困难。
- en: '**Accretion**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**积累**'
- en: We need to add a new feature. Doing it properly would involve ripping up the
    interfaces between a few key modules and revising a lot of code. There's no time
    to do all this and, even if we did, it would probably still be too complicated.
    We'll just graft on another clump of code. It'll hang off one of the existing
    modules—well, perhaps a few of them—and use its own special back door interface
    to talk to them. We'll have something working really quickly.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个新功能。正确地做这会涉及撕毁几个关键模块之间的接口并修改大量代码。没有时间做所有这些，即使我们做了，这可能会仍然过于复杂。我们只是再嫁接一大块代码。它将悬挂在现有的一个模块上——好吧，也许几个模块上——并使用它自己的特殊后门接口与它们通信。我们将很快就有东西可以工作了。
- en: Okay, it's a monstrous kludge. Oh, and the performance will be awful. And the
    modules will no longer have clear roles and responsibilities. There won't be a
    neat design anymore, and maintaining it in the future will be a nightmare. But
    we'll get this version out quickly, and we don't have any time to do it the right
    way now, anyway.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个怪物般的混乱。哦，性能将会很糟糕。模块将不再有明确的角色和责任。将不再有整洁的设计，未来的维护将是一场噩梦。但我们将快速推出这个版本，而且我们现在没有时间正确地做这件事。
- en: Maybe we'll come back later and do it properly. . . .
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们稍后会回来把它做得更好……
- en: '**Rewrite**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**重写**'
- en: When you recognize that the code you're working on is truly awful—unintelligible,
    fragile, and inextensible—it needs a rewrite. Based on prior experience, a rewrite
    is often quicker and safer than hacking at the original mess. However, rewrites
    are rarely done. It takes courage and vision.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 当你意识到你正在工作的代码真的很糟糕——难以理解、脆弱且不可扩展时，它需要重写。根据以往的经验，重写通常比在原始混乱中修补更快、更安全。然而，重写很少进行。这需要勇气和远见。
- en: Rewrites get riskier as you attack more code at once. Rewriting a whole product
    is a different prospect from rewriting a troublesome function or class. Good modularity
    and separation of concerns means that you needn't rewrite the whole system, just
    the module you're working on, keeping its original interface. If the interface
    is terrible, or you need to rewrite because the system isn't actually modular
    enough, then a lot more work is involved.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你一次性攻击更多的代码，重写会变得更加危险。重写整个产品与重写一个麻烦的功能或类是不同的前景。良好的模块化和关注点分离意味着你不需要重写整个系统，只需重写你正在工作的模块，保持其原始接口。如果接口很糟糕，或者你需要重写因为系统实际上不够模块化，那么就需要做更多的工作。
- en: '**DOUBLING UP**'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**翻倍**'
- en: The software had reached a major crossroad. There wasn't much future in the
    existing codebase—it really needed to be rewritten. Finally the management accepted
    this fact, and a plan was formed. The developers were split into two teams. Some
    continued to hack away at the existing codebase to try and limp it along for just
    a bit longer. The rest of the programmers got to start the entire application
    again from scratch.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 软件已经达到了一个重要的十字路口。现有的代码库前景并不乐观——它真的需要重写。最终管理层接受了这个事实，并制定了一个计划。开发者被分成两个团队。一些继续在现有的代码库上修改，试图让它再坚持一段时间。其余的程序员则从头开始重新构建整个应用程序。
- en: 'One task was glamorous: devising a sleek new design with interesting implementation
    challenges and the chance to work on a fresh, cruft-free codebase. The other task
    was menial: patching up holes in a sinking ship until the new cruise liner was
    ready (at which time all the old work would be left for scrap). Which team would
    you rather have been on?'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务是光鲜亮丽的：设计一个新颖的设计，具有有趣的实现挑战，以及在一个新鲜、无冗余的代码库上工作的机会。另一个任务是枯燥的：修补一艘沉船的漏洞，直到新邮轮准备好（届时所有旧工作都将被废弃）。你更愿意加入哪个团队？
- en: Not surprisingly, this led to a build up of resentment and frustration and a
    rivalry between the teams. Many programmers relegated to the old application asked
    to change projects or left the company to seek greener pastures. The work on the
    old codebase was second rate, as it was the second-rate project.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这导致了怨恨和挫败感的积累，以及团队之间的竞争。许多被分配到旧应用的开发者要求更换项目或离开公司去寻找更广阔的天地。在旧代码库上的工作质量低下，因为这是一个低质量的项目。
- en: '**Refactor**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**'
- en: A formalized cousin of rewrite. If your code is mostly okay, but bits of it
    need some work, you can *refactor* these unpleasant parts. Refactoring is a process
    of making small changes to a body of code in order to improve its internal structure
    without changing its external behavior. It improves the design so that you can
    work with it more easily in the future. It's not about performance improvement,
    just design enhancement. Not as drastic as a complete rewrite, refactoring is
    a series of gentle massages of what you already have.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的一个正式化版本。如果你的代码大部分还可以，但其中一些部分需要一些工作，你可以*重构*这些不愉快的部分。重构是一个对代码体进行小幅度修改的过程，以改善其内部结构而不改变其外部行为。它改善了设计，以便你将来更容易与之工作。这并不是关于性能改进，而是设计增强。与完全重写相比，重构是对现有代码的一系列温和的按摩。
- en: This is a fancy name for particular kinds of code modification. Martin Fowler
    has formalized it, documenting a number of small, understandable code refinements.
    (Fowler 99)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特定类型的代码修改的华丽名称。马丁·福勒对其进行了正式化，记录了许多小而易于理解的代码改进。（福勒99）
- en: '**Design for growth**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**增长设计**'
- en: You'll often have an idea how your code will expand in the future; perhaps some
    features have been deferred until the next release. You can carefully design the
    system so that it's easy to make these future additions. Most of the time, this
    won't make the design work much harder.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会对你未来的代码扩展有一个想法；也许一些功能被推迟到下一个版本。你可以仔细设计系统，使其易于添加这些未来的功能。大多数时候，这不会使设计工作变得更困难。
- en: Even if you don't know the set of future additions, careful design affords room
    for growth. An extensible system provides hinge points for new functionality to
    be plugged in. Be careful that this isn't an exercise in chasing the wind, though,^([[3](#ftn.CHP-15-FN-3)])
    trying to guess the future when you don't have a clue how the system will expand.
    Extensibility comes at the cost of complexity. If you correctly guess where this
    complexity is needed, you win; if you guess incorrectly, then you'll make an unnecessarily
    complicated system. This is the danger of *over-design*, and it's especially likely
    when design occurs by committee.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道未来添加的功能集，仔细的设计也能为增长留出空间。一个可扩展的系统为新功能提供插入点。不过，要小心这不要变成一种追逐风的活动，当你不知道系统如何扩展时，试图猜测未来。可扩展性是以复杂性为代价的。如果你正确地猜测了这种复杂性所在的位置，你就赢了；如果你猜错了，那么你会创建一个不必要的复杂系统。这是*过度设计*的危险，而且当设计由委员会进行时，这种情况尤其可能。
- en: There is a school of thought, exemplified in Extreme Programming, that insists
    on the absolute simplest design that can possibly work in any given situation.
    This could be at odds with the design for growth mentality (depending on how malleable
    the initial simple design is). Exactly how much design for growth you should employ
    can be a hard—but important—balance to strike.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种思想流派，以极限编程为例，它坚持在任何特定情况下可能工作的绝对最简单的设计。这可能与增长设计思维（取决于初始简单设计的可塑性）相矛盾。确切地说，你应该采用多少增长设计可能是一个困难但重要的平衡点。
- en: '**CHAOS THEORY**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**混沌理论**'
- en: 'Code is obviously shaped by design, but the organization that built it and
    its life history also play a large role. Years ago, I joined a project with particularly
    disgusting user interface code. It worked (usually), but was unfathomable, an
    intense lump of intertwining logic with no discernible architecture and labyrinthine
    paths of execution. And it was like that for a reason: history.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显然受到设计的影响，但构建它的组织及其历史也起着重要作用。多年前，我加入了一个特别糟糕的用户界面代码项目。它通常能工作，但难以理解，是一团错综复杂的逻辑，没有明显的架构和错综复杂的执行路径。而且它之所以如此，是有原因的：历史。
- en: The code was initially created as a simple one-off television UI for a single
    customer, with minimal specifications. Successfully built, it served its purpose
    well. Sadly, the story didn't end there.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最初是为一个单一客户的简单一次性电视用户界面而创建的，规格最小化。成功构建后，它很好地完成了其任务。遗憾的是，故事并没有就此结束。
- en: 'It was then sold to a second customer, who wanted it to look different. A second
    skin (visual appearance) was hacked on. Then it was sold to another customer in
    a different country. Internationalization was bolted on, with another skin. Then
    it was sold to a third customer, who wanted some new UI facilities—these were
    shoehorned in. This story continued. For a long time. Today the UI is unrecognizable
    from its former self, and it''s now also unmaintainable: Each addition has been
    a quick hack since the whole thing was always a temporary system.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 它随后被卖给第二个客户，客户希望它看起来不同。于是给它添加了一个第二层皮肤（外观）。然后它又被卖到另一个不同国家的客户手中。为了国际化，又添加了另一层皮肤。接着它又被卖给第三个客户，客户希望有一些新的用户界面功能——这些功能被强行加入。这个故事就这样继续下去。持续了很长时间。如今，用户界面已经与其前身截然不同，而且现在它也难以维护：每一次的添加都是一个快速的修补，因为整个系统始终都是一个临时系统。
- en: If the initial design had incorporated all these features, then the code would
    still be lean and logical. However, it would have been far too much work up front,
    and the company would never have started the project. Pity the poor programmers
    that work under these Real World conditions.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最初的设计就包含了所有这些功能，那么代码仍然会保持简洁和逻辑性。然而，这会是一个前期工作量巨大的项目，公司可能永远不会开始这个项目。可怜那些在这些现实世界条件下工作的程序员们。
- en: '* * *'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-15-FN-3)]) Ecclesiastes 2:11
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-15-FN-3)]) 传道书 2:11
- en: Believe the Impossible
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相信不可能
- en: Perhaps the reason we see so much bad code and so many dirty hacks is the mistaken
    belief that it takes longer to do the job properly. When you factor in the time
    spent debugging and the ease of making later modifications, this proves to be
    a false assumption. You may be able to close a single fault report quickly by
    hacking out a fix, but it's not a good solution. True craftsmen take responsibility
    for what they do to code.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们之所以看到这么多糟糕的代码和如此多的脏乱修补，是因为错误地认为正确完成工作需要更长的时间。当你考虑到调试所花费的时间和后期修改的便利性时，这证明是一个错误的假设。你可能能够通过快速修补来迅速关闭一个故障报告，但这并不是一个好的解决方案。真正的工匠会对他们所做的代码负责。
- en: In the corporate world, there is often a management expectation of quick fixes.
    It's reasonably easy to show a manager that a five-ton block of concrete stuck
    on top of a flimsily erected flagpole won't stay up for verylong. It's harder
    to make him stand underneath the thing. And it's *much* harder to get the same
    message across when we're talking about software. Managers just don't get it.
    As far as they're concerned, programmers are magicians who practice dark mystical
    arts and have limitless powers. Tell them what to do, provide a deadline, and
    it will happen, however many all-night coding sessions are required.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业界，管理层常常期望快速修复。向管理者展示一个五吨重的混凝土块被堆放在一个摇摇欲坠的旗杆顶部，它不会持续很长时间，这是相对容易的。让他站在那个东西下面则更难。当我们谈论软件时，要让这个信息传达出去则更加困难。管理者们根本不理解。对他们来说，程序员就像是练习黑暗神秘艺术的魔术师，拥有无限的力量。告诉他们该做什么，提供一个截止日期，事情就会发生，无论需要多少个通宵的编码。
- en: Being gifted and dedicated, sometimes we meet these expectations. This actually
    makes matters worse, as management now expects that this tactic will always work.
    Worse, they assume that it's *our* fault when it doesn't. Sadly, there comes a
    time when hastily hacked software just cannot be made to expand any more, when
    it really just wants to keel over and find its final resting place in a quiet
    corner somewhere. Management will not be happy.^([[4](#ftn.CHP-15-FN-4)])
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 天赋和奉献精神有时使我们能够满足这些期望。这实际上使事情变得更糟，因为管理层现在期望这种策略总是有效。更糟糕的是，当它不起作用时，他们假设这是**我们的**过错。遗憾的是，总有那么一个时刻，匆忙编写的软件再也无法扩展，它只想倒下，安静地在一个角落里找到它的最终归宿。管理层是不会高兴的.^([[4](#ftn.CHP-15-FN-4)])
- en: Code growth is easier if the company's culture is to develop software in small
    incremental steps (see "Iterative" on page 245 and "[Iterative and Incremental
    Development](ch22s03.html#iterative_and_incremental_development "Iterative and
    Incremental Development")" on page 432). This way, evolution is built into the
    design strategy, and rewriting code to accommodate change is expected. The alternative,
    when you have to attack a monolithic code edifice with a small pickaxe in 20 seconds
    flat, is unreasonable—but not unusual.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司的文化是在小步骤中逐步开发软件（参见第245页的“迭代”（[Iterative](ch13s04.html#iterative "Iterative")）和第432页的“迭代和增量开发”（[Iterative
    and Incremental Development](ch22s03.html#iterative_and_incremental_development
    "Iterative and Incremental Development")）），代码增长就会更容易。这样，演变就内置到设计策略中，并且预期需要重写代码以适应变化。另一种选择，当你必须在20秒内用一把小镐头攻击一个庞大的代码建筑时，这是不合理的——但并不罕见。
- en: '* * *'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-15-FN-4)]) Of course this is a gross generalization, but not too
    inaccurate. Many managers used to be programmers themselves and understand the
    tensions. A good manager listens to the programmers' objections. A good programmer
    will make his or her boss listen. Too often, neither happens, and the software
    suffers.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-15-FN-4)]) 当然这是一个粗略的概括，但并不太不准确。许多管理者曾经是程序员，理解这些紧张关系。一个好的管理者会倾听程序员的反对意见。一个好的程序员会让他或她的老板倾听。太经常了，这两种情况都没有发生，软件就受到了影响。
- en: What Can We Do About This?
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们能做些什么？
- en: God grant me the serenity to accept the things I cannot change, the courage
    to change the things I can, and the wisdom to know the difference.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 上帝赐予我平静接受我不能改变的事情，勇气去改变我能改变的事情，以及智慧去知道两者的区别。
- en: --Reinhold Niebuhr
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: --雷因霍尔德·尼布尔
- en: Now that we've identified some of the problems of an evolving codebase, how
    do we manage the mess? What strategies can we adopt to avoid this?
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经识别了一些代码库演变的问题，我们如何管理混乱？我们可以采用哪些策略来避免这种情况？
- en: The first and most important step is to recognize the problem. Too many programmers
    hack away without thinking about the quality of their code. As long as they silence
    the users' screams in the shortest time possible, they don't care what state they
    leave the code in. Someone else can deal with it next time.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步和最重要的一步是认识到问题。太多的程序员在不考虑代码质量的情况下随意编写代码。只要他们能在最短的时间内平息用户的尖叫，他们就不在乎他们留下的代码状态。下次有人可以处理它。
- en: '**KEY CONCEPT**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Code conscientiously. Good programmers care more about how their code will
    look after a few years'' work than how much effort it takes to write now*.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '*有意识地编写代码。好的程序员更关心几年后他们的代码会是什么样子，而不是编写它需要多少努力*。'
- en: Writing New Code
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写新代码
- en: 'Before we think about how to work with *legacy* (existing) code, here are a
    few tactics for creating brand-new code that will greatly aid later maintenance:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑如何与*遗留*（现有）代码一起工作之前，这里有一些创建全新代码的策略，这将极大地帮助以后的维护：
- en: Consider the interconnection of modules, and reduce coupling as much as possible.
    Avoid having one central module that every other module depends on; a change there
    will affect every other module in the system.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑模块之间的相互连接，尽可能减少耦合。避免有一个中心模块，其他所有模块都依赖于它；那里的任何变化都会影响系统中的其他模块。
- en: Modularity and information hiding (see page "[Modularity](ch13s04.html#modularity
    "Modularity")" on page 247) are the cornerstones of modern software engineering.
    Isolate any likely changes to a small part of the system, making your system more
    viscous and therefore stable under change.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化和信息隐藏（参见第247页的“模块化”（[Modularity](ch13s04.html#modularity "Modularity")））是现代软件工程的基石。将任何可能的变化隔离到系统的一个小部分，使你的系统在变化下更加粘稠，因此更加稳定。
- en: Extension and malleability need to be designed in—but, as we've seen, not at
    the expense of complexity. Modern component/object based paradigms promise greater
    reuse and extensibility. They give clear interface points between code modules.
    However, if the interfaces don't support later extension, then the code can't
    grow. Think very carefully about your system interfaces as you create them.
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展性和灵活性需要被设计进去——但，正如我们所看到的，不能以复杂性的代价。现代基于组件/对象的范式承诺更大的重用和可扩展性。它们在代码模块之间提供了清晰的接口点。然而，如果接口不支持后续扩展，那么代码就不能增长。在创建系统接口时，要非常仔细地考虑这些问题。
- en: Write neat, clear code that can easily be understood and worked with, accompanied
    by good documentation and well-defined, clearly named APIs. Consider literate
    programming tools to document interfaces.
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写整洁、清晰、易于理解和工作的代码，并辅以良好的文档和定义明确、命名清晰的API。考虑使用文献编程工具来记录接口。
- en: '*KISS*. That is, *Keep It Simple, Stupid*. Don''t over-complicate; don''t over-engineer.
    Optimize an algorithm only when you *know* that there are performance issues,
    not just because you think you know a good way to make code run faster. Simplicity
    is nearly always more desirable than performance, and it certainly makes later
    maintenance easier.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*KISS*。也就是说，*保持简单，傻瓜*。不要过度复杂化；不要过度工程化。只有在你知道确实存在性能问题时，才优化算法，而不仅仅是因为你认为你知道一种让代码运行更快的好方法。简单性几乎总是比性能更可取，而且它确实使得后续维护更容易。'
- en: '**KEY CONCEPT**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Write new code with a view to its modifiability. Make it readable, extensible,
    and simple*.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '*编写新的代码时，要考虑到其可修改性。使其可读、可扩展和简单*。'
- en: Maintenance of Existing Code
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现有代码的维护
- en: Maintaining *good* code requires a different battle plan than maintaining *bad*
    code. With the former, you must carefully preserve the integrity of the design
    and ensure that you don't introduce anything out of place. With the latter, you
    must try to not make the mess any worse and, if possible, improve things on your
    way through. If you can't rewrite the offending code, a little refactoring will
    go a long way.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 维护*良好*的代码需要与维护*糟糕*的代码不同的战斗计划。在前者中，你必须仔细保持设计的完整性，并确保你不引入任何不合适的东西。在后者中，你必须努力不让混乱变得更糟，并在可能的情况下，在通过的过程中改进事物。如果你不能重写有问题的代码，一点重构就能走很长的路。
- en: 'Before you touch any code, these organizational issues should be considered:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在你接触任何代码之前，应该考虑以下组织问题：
- en: '*Prioritize* any changes that are needed. Balance the importance of each task
    against its complexity, and decide which should be done first. What early changes
    will have an impact on later work?'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先处理*任何需要的更改。权衡每个任务的重要性和复杂性，并决定哪个应该先做。哪些早期更改将对后续工作产生影响？'
- en: Only change what's necessary. *If it ain't broke, don't fix it*. Don't gratuitously
    "improve" bits of code because you think they need it—only make the changes that
    are really required. Refactor the bad code you need to work with. Give the rest
    a wide berth.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只改变必要的部分。*如果它没有坏，就不要修复它*。不要随意“改进”代码，因为你认为它们需要它——只做真正需要的更改。重构你需要与之工作的坏代码。给其他部分留出很大的空间。
- en: Monitor how many modifications are being made at once. Making several parallel
    modifications *yourself* is either incredibly clever or foolish; most likely the
    latter. Do one thing at a time. Carefully.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控一次进行的修改数量。自己进行多个并行修改要么非常聪明，要么愚蠢；很可能是后者。一次只做一件事。仔细地。
- en: If several people are working on the code at once, be aware of what's changing
    around you. There is a danger of too many separate hacks causing odd conflicts.
    Methodical change by a single developer gives clearest visibility of where the
    code is being stretched and where the most care is needed. Several simultaneous
    modifications might stretch the code thin without anyone understanding or noticing.
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果有几个人同时在工作，要注意你周围的变化。过多的独立修改可能会导致奇怪的冲突。一个开发者的有序更改可以最清晰地显示代码被拉伸的地方和最需要关注的地方。几个同时进行的修改可能会使代码变得薄弱，而没有人理解或注意到。
- en: '**KEY CONCEPT**'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Manage changes carefully. Make sure you know who else is trying to modify
    code near where you''re working*.'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*谨慎管理更改。确保你知道还有谁试图修改你正在工作的代码附近的代码*。'
- en: Just as the initial code should be reviewed during its development, subsequent
    changes should also be reviewed. Organize formal reviews, and try to include the
    code's original author and reviewers. It's very easy to introduce subtle new bugs
    with small code extensions; reviews will catch many of these errors.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如初始代码在其开发期间应进行审查一样，后续的更改也应进行审查。组织正式的审查，并尽量包括代码的原始作者和审阅者。很容易在小的代码扩展中引入微妙的新的错误；审查将捕捉到许多这些错误。
- en: '**KEY CONCEPT**'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Review sensitive changes, especially in the run-up to a release. Even the
    simplest change can break other code*.'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*审查敏感的更改，尤其是在发布前夕。即使是微小的更改也可能破坏其他代码*。'
- en: 'Once at the codeface, how do we tackle existing source? Here are practical
    suggestions:'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦到达代码层面，我们如何处理现有的源代码？以下是一些建议：
- en: 'To make good modifications, you must be informed about the code you''re working
    on. Before you modify a file or code module, understand:'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要进行良好的修改，你必须了解你正在工作的代码。在修改文件或代码模块之前，理解：
- en: Where it sits within the whole system
  id: totrans-657
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在整个系统中的位置
- en: What interdependencies it has (i.e., which components might be affected by your
    change)
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有哪些相互依赖性（即哪些组件可能会受到你的更改的影响）
- en: What assumptions were made when the code was created (hopefully documented in
    the code's specifications)
  id: totrans-659
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建代码时所做的假设（希望已在代码规范中记录）
- en: The history of modifications that have already been made
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经进行的修改历史
- en: Inspect the code's quality. This is surprisingly easy to do, and rapidly gives
    you a sense of how easy the code is going to be to work with. You may find it
    helpful to use tools that visualize the code and generate quality metrics; this
    will highlight where hidden gotchas could be lurking. Collate all relevant documentation.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查代码的质量。这出奇地容易做到，并且迅速让你对代码的可维护性有一个直观的感受。你可能发现使用可视化代码并生成质量指标的工具有帮助；这将突出隐藏的陷阱可能潜伏的地方。整理所有相关的文档。
- en: Adopt the correct attitude—avoid the *just one more hack* mentality. Don't dismiss
    code, thinking that it will be thrown away or rewritten in the future. It won't
    be.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用正确的态度——避免“再简单修改一下”的心态。不要轻视代码，认为它将被丢弃或重写。它不会。
- en: Be constantly aware of the warning signs cataloged in "[The Warning Signs](ch15s02.html
    "The Warning Signs")" on page 282\. If your modification moves the codebase nearer
    to one of those states, refactor the code to alleviate the problem. Take responsibility
    for these problems.
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 时刻关注第282页上列出的警告信号 "[警告信号](ch15s02.html "警告信号")"。如果你的修改使代码库接近这些状态之一，重构代码以减轻问题。对这些问题负责。
- en: 'Be prepared to do some redesign work. Don''t be afraid to unpick the code and
    perform major surgery when necessary. Sometimes a modification will be costly
    right now (in terms of your time and effort), but the investment will pay off
    later: Future work with the code will be much, much easier. For legacy code, this
    may be considered uneconomical. Sadly, it''s legacy code that makes cash and is
    unlikely to be phased out. If you know that you''ll be working on a section of
    code a lot in the future, make sure that the code structure will support future
    extension.'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备做一些重新设计的工作。不要害怕在必要时拆解代码并进行重大手术。有时修改可能会立即付出高昂的代价（就你的时间和精力而言），但投资将带来回报：未来的代码工作将容易得多。对于遗留代码，这可能被认为是不经济的。遗憾的是，正是遗留代码创造了现金，并且不太可能被淘汰。如果你知道你将在未来大量工作于某个代码部分，确保代码结构将支持未来的扩展。
- en: '**KEY CONCEPT**'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Don''t mindlessly fiddle with code. Step back and look at what you''re doing*.'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*不要无目的地摆弄代码。退后一步，看看你在做什么*。'
- en: Try not to introduce extra dependencies with newly added code. An increase in
    coupling makes code more complicated and harder to change next time.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量不要通过新添加的代码引入额外的依赖。耦合的增加会使代码更加复杂，下次更改更困难。
- en: When maintaining any code, retain the programming style of the source files
    you are working with, even if it's not your favorite style or the house style.
    A file with code in several formats is confusing and hard to work with. Apply
    presentation tidy-ups as you go if they're not too gratuitous, but be aware that
    source code diffs across versions will be harder if you do so. Maintain the comments
    around the code you're working on (see "[Maintenance and the Inane Comment](ch05s07.html#maintenance_and_the_inane_comment
    "Maintenance and the Inane Comment")" on page 86).
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在维护任何代码时，保留你正在工作的源文件的编程风格，即使它不是你最喜欢的风格或公司风格。包含多种格式的文件会让人困惑，难以工作。如果你不觉得过于随意，可以在进行过程中应用展示整理。但请注意，这样做的话，源代码的版本差异将会更难处理。维护你正在工作的代码周围的注释（参见第86页的“维护和无聊的注释”（[Maintenance
    and the Inane Comment](ch05s07.html#maintenance_and_the_inane_comment "Maintenance
    and the Inane Comment")））。
- en: Use the code's test suite to check that you don't break anything. Exhaustive
    regression testing is the only real way to have confidence in the changes you've
    made.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码的测试套件来检查你是否破坏了任何东西。彻底的回归测试是唯一真正能够让你对所做的更改有信心的方法。
- en: Ensure that you have an adequate test suite, and run it regularly.
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你有一个充分的测试套件，并且定期运行它。
- en: '**KEY CONCEPT**'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Carefully test any modification you make, no matter how simple. It''s really
    easy for silly faults to slip past unnoticed*.'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*仔细测试你做出的任何修改，无论多么简单。愚蠢的错误很容易被忽视*。'
- en: If you are fixing a fault, do you really understand the cause? Write a test
    harness to trigger it; this demonstrates your understanding and will prove that
    you have made the fix. Add it to the suite of regression tests.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在修复一个故障，你是否真的理解了原因？编写一个测试框架来触发它；这证明了你的理解，并将证明你已经修复了问题。将其添加到回归测试套件中。
- en: 'Once you have made a successful fix, look around the codebase for similar faults.
    This overlooked step can make a big difference: Many problems hang around in packs,
    and it''s much easier to defeat them in one crushing blow than to slowly chip
    away as they each individually manifest.'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你成功修复了问题，在代码库中寻找类似的问题。这个被忽视的步骤可以产生很大的影响：许多问题成群结队地出现，一次性击败它们比慢慢逐个解决它们要容易得多。
- en: If you make a bad change, back it out quickly. Don't litter code with unnecessary
    dead wood.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你做出了一个糟糕的更改，请迅速撤销。不要在代码中留下不必要的废弃代码。
- en: As a code craftsman, you should always shy away from the pressure to do a quick
    bodge job. Strive to make careful, considered changes. Unfortunately, we don't
    work in ivory towers, and compromise is sometimes required on the battle front;
    it's not always commercially feasible to complete a task in the theologically
    correct way.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名代码工匠，你应该始终避免快速修补的压力。努力做出谨慎、经过深思熟虑的更改。不幸的是，我们并不在象牙塔中工作，有时在战斗前线需要妥协；以神学正确的方式完成任务并不总是商业上可行的。
- en: This explains why so much code is brittle, flaky, and dangerous. But it also
    explains why there's any code out there at all. If there wasn't the commercial
    drive to get software shipped, programmers would spend forever tweaking their
    software to get it just right, writing and rewriting. The company would have collapsed
    around them long before they'd finished.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么如此多的代码是脆弱的、不可靠的和危险的。但它也解释了为什么有代码存在。如果没有推动软件发布的商业动力，程序员将永远调整他们的软件以使其完美，编写和重写。公司会在他们完成之前就崩溃了。
- en: However, don't introduce pragmatic (but distasteful) modifications without a
    plan to fix them at a later date. Place a tidy-up task on the development schedule.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要在没有计划在以后日期修复它们的情况下引入实用（但令人不快的）修改。在开发计划中放置一个整理任务。
- en: In a Nutshell
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Change in all things is sweet.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 万事万物都在变化中是美好的。
- en: --Aristotle
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: --亚里士多德
- en: I'm not sure that I agree with Aristotle. Change can be a real pain in the rear
    end. We should manage code changes carefully. Then a good program will evolve
    into something greater, rather than degrade into an unstable mess.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定我是否同意亚里士多德的观点。变化可能真的会让人头疼。我们应该谨慎管理代码更改。然后，一个好的程序将演变成更伟大的东西，而不是退化成一个不稳定的大杂烩。
- en: It's important to maintain software well and expand it correctly, preserving
    the code design and making sympathetic modifications. Don't expect maintenance
    to be easy. You may need to invest a lot of time to rewrite, redesign, or refactor.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 维护软件并正确扩展它非常重要，同时保留代码设计并进行同情的修改。不要期望维护工作会容易。你可能需要投入大量时间来重写、重新设计或重构。
- en: See Also
  id: totrans-684
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 17](ch17.html "Chapter 17. TOGETHER WE STAND")'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](ch17.html "第17章。团结就是力量")'
- en: We build and maintain software as a team. Team dynamics inevitably affect the
    final shape of your code.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: A history of your code's development is recorded in the *revision control system*.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'The software development lifecycle: the procedures we follow to create and
    grow software.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Write maintainable software with clean structure and logical layout
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize and are prepared to deal with bade code
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to understand as much of the code and the author's original mental model
    as possible, prior to working on it
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Care about the quality of code they're working on; they refuse to clumsily patch
    code
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Create complex code without thinking about the needs of maintenance programmers
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Avoid* maintaining old code, preferring to ignore problems rather than fix
    them'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Favor an easy patch over thinking about a good solution
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Litter code with quick and dirty hacks; they employ every shortcut they can
    find
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus attention in the wrong places, tinkering with code that didn't actually
    need to be fixed
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207506.png)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  id: totrans-706
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 527.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the best metaphor for software growth?
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Looking at a program''s development through the colorful lifetime metaphor
    I talked about in the introduction, what Real World events correspond to a program''s:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conception
  id: totrans-711
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Birth
  id: totrans-712
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Growth
  id: totrans-713
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming of age
  id: totrans-714
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending out into the Big Wide World
  id: totrans-715
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Middle age
  id: totrans-716
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Growing tired
  id: totrans-717
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retirement
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Death
  id: totrans-719
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a limit to software life—how long can you keep developing and working
    on a program before you have to start afresh?
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the size of a codebase correspond to the maturity of the project?
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How important is *backward compatibility* when maintaining code?
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is code likely to rot more quickly if you alter it or if you leave it alone?
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  id: totrans-724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is the majority of the code you write brand new or a modification of existing
    source?
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's brand-new code, do you create entirely new systems or new extensions
    to existing systems?
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Does this affect *how* you write? In what ways?
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do you have experience of working with preexisting codebases? If so:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How has it shaped your current skill set? What lessons did you learn?
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Was it predominantly good or bad code? What did you have to judge it against?
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Have you ever made changes that degraded the quality of code? Why?
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many revisions has your current project gone through?
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How much changed functionally between revisions? How did the code change?
  id: totrans-733
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Has it grown by *luck*, by *design*, or something between the two? How is this
    evident now?
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does your team safeguard code so that it can't be changed by more than one
    programmer at once?
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
