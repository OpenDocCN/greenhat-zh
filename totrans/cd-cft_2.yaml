- en: Part III. THE SHAPE OF CODE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike a fine wine, your code is not likely to get any better the longer you
    leave it. If it starts like a small pile of something that the dog produced, then
    it will no doubt end up like a large pile of something an elephant produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is no secret, yet software factories continually churn out elephantine
    creations and then suffer the consequences. Their products are neither adaptable,
    extensible, or malleable enough to suit their future requirements, nor easy enough
    to develop: They fail to deliver on time and to budget. As programmers, this hurts
    our pride—but it hurts managers'' wallets, hard.'
  prefs: []
  type: TYPE_NORMAL
- en: The answer? One solution is to never attempt code development in the first place,
    but that's hardly practical. The other is to develop code with a view to the entire
    system's structure. Good code doesn't happen by accident; it is the product of
    careful crafting, with much emphasis placed on prior planning and design. But
    it also stems from a nimble development approach, from being agile enough to cope
    with the inevitable problems and changes that you'll encounter en route.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section explores this process. We''ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code micro design: low-level construction tips for individual code modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  prefs: []
  type: TYPE_NORMAL
- en: Larger-scale system design—the first construction stage of any software development.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15](ch15.html "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")'
  prefs: []
  type: TYPE_NORMAL
- en: A look at how software grows and expands over time, with some practical suggestions
    for grafting new work into an old codebase.
  prefs: []
  type: TYPE_NORMAL
- en: These are not optional extras or nice-to-haves. They are essential stages of
    our craft and are therefore crucial to the production of quality software. Ignore
    this stuff at your peril.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13. GRAND DESIGNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*How to Produce Good Software Designs*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A camel is a horse designed by committee.
  prefs: []
  type: TYPE_NORMAL
- en: --Sir Alec Issigonis
  prefs: []
  type: TYPE_NORMAL
- en: Some code just makes you sigh.
  prefs: []
  type: TYPE_NORMAL
- en: I once had to write a device driver for an embedded product. The driver's interface
    to the OS was quite complex. The interface to the hardware I was using was also
    complex. To keep myself sane, I split the code into two sections. The first was
    an internal library that accessed the hardware, performed some data buffering,
    and provided a simple API to access that buffered data. Then I wrote a second,
    distinct layer that implemented the finicky OS driver interface in terms of this
    internal library. The structure of the device driver looked like [Figure 13-1](ch13.html#petes_sane_software_design
    "Figure 13-1. Pete's sane software design").
  prefs: []
  type: TYPE_NORMAL
- en: Later, the manufacturer of the hardware sent me a sample implementation of the
    same device driver. The author of this code had clearly not thought it out at
    all. The code was a sprawling mess, tightly intermingling the complex OS interface
    with the hardware logic in a completely incomprehensible manner. An approximation
    of its structure is shown in [Figure 13-2](ch13.html#how_not_to_design_software
    "Figure 13-2. How not to design software").
  prefs: []
  type: TYPE_NORMAL
- en: '![Pete''s sane software design](tagoreillycom20080909nostarchimages207482.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 13-1. Pete''s sane software design**'
  prefs: []
  type: TYPE_NORMAL
- en: '![How not to design software](tagoreillycom20080909nostarchimages207484.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 13-2. How not to design software**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, I'm not trying to toot my own horn (any more than is necessary, anyway).
    The point of this illustration is clear. The first design is better. It is easier
    to understand because it's so straightforward, it is easier to implement, and
    consequently it is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.A.R. Hoare wrote, "There are two ways of constructing a software design:
    One way is to make it so simple that there are *obviously* no deficiencies, and
    the other way is to make it so complicated that there are no *obvious* deficiencies.
    The first method is far more difficult." (Hoare 81)'
  prefs: []
  type: TYPE_NORMAL
- en: One of the signs of a mature programmer is the design quality of his or her
    code. In this chapter, we'll look at what constitutes a good design and investigate
    how to craft high-quality software designs.
  prefs: []
  type: TYPE_NORMAL
- en: Programming as Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a popular belief that "design" is a stage you complete before moving on
    to writing code. Its product is some form of *design specification*, which is
    sufficient for a generic code monkey to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The truth is very different. Programming—the act of writing code—is a *design
    activity*.
  prefs: []
  type: TYPE_NORMAL
- en: Even the most detailed specification has holes, or else it would *be* the code—you
    can't describe every minuscule detail in a design document. The act of programming
    verifies the initial design decisions and performs the remaining design work.
    It exposes holes, inconsistencies, and errors and allows you to find a route around
    them. "Some programmers don't think they're doing design when they program, but
    whenever you write code, you're always doing design, either explicitly or implicitly."
    (Page Jones 96)
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Programming is a design activity. It''s a creative and artistic act, not mechanical
    code generation*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A good development process recognizes this and doesn''t shy away from writing
    code when it''s appropriate. Practitioners of Extreme Programming advocate that
    design *is* the code. (Beck 99) There is no separate design activity; there is
    no team of designers. It''s the programmers who constantly refine and extend the
    design by refining and extending the code. This is enshrined in their *test-driven
    design* approach: Code tests are written before any code, as a design verification
    tool. This is a wise idea.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that you don't need to think before starting to hack at code?
    Not at all! Deep inside a text editor is not the place to plan what you're writing.
    That's like trying to drive from Berlin to Rome without deciding a route first.
    You'll end up in Moscow before you've worked out which way is north. By definition,
    design is something you do *first*.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Think before you type; establish a coherent design. Otherwise you''ll end
    up with chaotic code*.'
  prefs: []
  type: TYPE_NORMAL
- en: What Do We Design?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers design code structures, obviously. But this means different things
    at different stages of the development process. At each stage, design is a process
    of decomposing the task into its constituent parts and figuring out how each part
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'These levels of software design are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The system architecture**'
  prefs: []
  type: TYPE_NORMAL
- en: Here we look at the system as a whole, identify the main subsystems, and work
    out how they communicate. The architectural design has the most influence on the
    performance and characteristics of the system *as a whole* and the least impact
    on specific lines of code. It is the most important design act and is covered
    in the next chapter. In this chapter, we're concerned with the internal design
    of code, which involves the subsequent design levels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modules/components**'
  prefs: []
  type: TYPE_NORMAL
- en: The architectural subsystems are usually too large to directly implement in
    code, so the next step is to break each one down into comprehensible modules.
    It's very easy to be vague about design at the module level. In some ways, a "module"
    does not really exist. *Module* may mean something different depending on the
    design approach; it might be a logical clump of code, perhaps some physical unit
    like a Java package, C++/C# namespace, or a reusable library. It might be a class
    hierarchy or maybe even a free-standing executable.
  prefs: []
  type: TYPE_NORMAL
- en: This design stage often produces published interfaces. These can't be easily
    changed later on, since they form strict contracts between code modules and between
    the teams of programmers writing them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes and data types**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we break a module into bite-sized chunks. Interface design tends to be
    less formal and easier to change behind the module. The tendency is to do this
    micro design at the keyboard. This urge should be resisted, or else you'll write
    the first code that comes into your head, not the best code for the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This may be the lowest design level in the food chain, but it''s of no less
    importance. A program is built from routines: If the routines are poorly designed,
    then the entire system will suffer. After having established exactly which functions
    are required, we design how they work internally, how the flow of control is routed,
    and which algorithms are used.^([[1](#ftn.CHP-13-FN-1)]) This is usually a mental
    exercise rather than a documented procedure, but a diligent design is essential.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-13-FN-1)]) Key algorithms will often span multiple functions; they'll
    be determined at the module design stage.
  prefs: []
  type: TYPE_NORMAL
- en: What's All the Fuss About?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You won't find anyone arguing *for* bad design, but nonetheless, there's a lot
    of badly designed code out there. After a few years on the front line, any developer
    has the scars to prove it. (Battle-hardened veterans are already nodding their
    heads and mentally rehearsing their war stories.) But why is this the case?
  prefs: []
  type: TYPE_NORMAL
- en: Sloppy design can be the product of inexperienced programmers, but more often
    it is caused by the commercial pressures of the software factory squeezing out
    any time that might have been spent on good design. No one listens to the poor,
    protesting coders. Programming in the Real World is necessarily bound by the drive
    to ship software—any software—on time. The irony is that in almost every case,
    a lack of a good design ultimately costs more than doing it properly would have.
    As they say, "There's never time to do it right, but there's always time to do
    it twice."
  prefs: []
  type: TYPE_NORMAL
- en: Getting design right is really *very* important. The design of your code is
    the foundation upon which it is built. If it's wrong, then the code will be unstable,
    unsafe, and not fit for purpose—dangerous. A bad design foundation leads to the
    software equivalent of the Leaning Tower of Pisa. While novel that it manages
    to stand up under the strain of real use, it will never be as good as it ought
    to be, and in time this inevitably shows.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sound design makes code:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier to write (there's a well-defined plan of attack, and it's clear how it's
    all going to fit together)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to fix (you can identify the location of problems)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less likely to harbor bugs (program errors are not hidden behind mystifying
    design problems)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More resilient to change (the design will encourage extensions and accommodate
    modification)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good Software Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any programming problem, there will be *many* potential code designs. Your
    job is to find one. The best one. Or at least a sufficiently good one. It's not
    an easy task. . . .
  prefs: []
  type: TYPE_NORMAL
- en: How do you know that your design will work? After completing a bulletproof plan
    of attack, you confidently begin implementing it. Later, an unexpected problem
    will show its ugly head. Back to the drawing board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you know when your design is finished? You can't know until you've actually
    implemented it and found that it works. Many issues can't be fore-guessed; you
    have to step out, implement the design, and see whether or not it's complete.
    It's only by attempting a solution that you even *begin* to understand the original
    problem. Armed with this new knowledge, you can then try to solve it again properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you know it's the *best* design solution for the problem? You can't tell
    unless you try out every possibility. This isn't practical. Instead, how do you
    know it's good *enough*? If performance is a requirement, you won't really know
    until the system *is* performing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best design approaches address these problems. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative**'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid too many nasty surprises by doing a small amount of design, implementing
    it, assessing the implications, and feeding this into to the next design round.
    This incremental construction approach is very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cautious**'
  prefs: []
  type: TYPE_NORMAL
- en: Don't try to design too much at once. If something fails, it might be because
    of any number of design decisions. Limit the room for failure, and you'll find
    it easier to progress. Small, sure design steps are more likely to succeed than
    large, clumsy ones.
  prefs: []
  type: TYPE_NORMAL
- en: '**Realistic**'
  prefs: []
  type: TYPE_NORMAL
- en: A prescriptive design process will not work all of the time, every time. The
    outcome depends on the quality of the requirements established, the experience
    of the team, and the rigor with which the process is applied. A pragmatic approach
    takes the best of all methodologies and admits that it relies on the programmers'
    gut feeling—experience has a lot to do with shaping good design.
  prefs: []
  type: TYPE_NORMAL
- en: '**Informed**'
  prefs: []
  type: TYPE_NORMAL
- en: You must fully understand all requirements and motivating principles to be clear
    about the problem you're solving, and also about the important qualities of the
    right solution. If you don't, you'll solve the wrong problem. You need this information
    to get early design decisions right, and some are hard to reverse.
  prefs: []
  type: TYPE_NORMAL
- en: Your design approach is inevitably affected by the overall development methodology
    in use (see "[Programming Styles](ch22.html#programming_styles "Programming Styles")"
    on page 420 for a description of these). A good design *process* is a step towards
    creating a good design, but no guarantee. It still comes down to the quality of
    the design *decisions* you make. Different trade-offs lead to different designs.
    A design for speed will differ from design for extensibility, for example. Ultimately,
    there is no *right* or *wrong* design. At best, there are *good* designs and *bad*
    designs.
  prefs: []
  type: TYPE_NORMAL
- en: Good designs have a number of attractive characteristics, whose opposites are
    sure indicators of bad design. We'll discuss these next.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the single most important characteristic of well-designed code. A simple
    design is easy to understand, has no unnecessary warts or blemishes, and is easy
    to implement. It is coherent and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple code is as small as possible but no smaller. This takes some doing,
    as the mathematician Blaise Pascal appreciated: "I am sorry for the length of
    my letter, but I had not the time to write a short one." Carefully work out how
    *little* code is needed, and then write just that. Remember, you can always add
    more code later for extra functionality, but you can rarely remove something that
    has become intimately entwined.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING A TRADE**'
  prefs: []
  type: TYPE_NORMAL
- en: Software design is a process of making decisions—of decomposing the system into
    its constituent parts, but also balancing the contending forces that pull in different
    directions. There are trade-offs to be made that shape the final design.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are common examples of such tightropes and games of tug-of-war:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensibility vs. simplicity**'
  prefs: []
  type: TYPE_NORMAL
- en: A design for extensibility provides plenty of interface points for future code
    to be plugged into and ensures the scaffolding is sufficiently general to support
    any later requirements. Simplicity avoids the complication of extra levels of
    indirection and needless generality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiency vs. safety**'
  prefs: []
  type: TYPE_NORMAL
- en: Gains in performance often come by sacrificing purity of design—putting in special
    back doors for certain important operations or adding lots of coupling to prevent
    too much indirect access. Highly optimized systems are generally less clear and
    more brittle in the face of change.
  prefs: []
  type: TYPE_NORMAL
- en: Not all efficient designs are bad, though; many good designs naturally perform
    well *because* of their simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Features vs. development effort**'
  prefs: []
  type: TYPE_NORMAL
- en: At project initiation, there are a thousand desired features and a reasonable
    idea of when they should be delivered by (tomorrow, if not sooner). Without an
    infinite number of monkeys and their infinite number of PCs, you'll never get
    it all done.
  prefs: []
  type: TYPE_NORMAL
- en: More features take more time to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these characteristics is most important depends on the project requirements.
    That's why it's so important to be clear about them up front.
  prefs: []
  type: TYPE_NORMAL
- en: Laziness *can* pay off. Work your design so you can defer as much work as possible,
    and only concentrate on the immediate problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: Less is more. *Strive for simple code that does a lot with a little*.
  prefs: []
  type: TYPE_NORMAL
- en: A simple design is not necessarily easy to create. It takes time. For all but
    the most basic programs, a great deal of information must be sifted through to
    reach a final solution. Well-designed code *looks* obvious, but it probably took
    an awful lot of thought (and a lot of refactoring) to make it that simple.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It''s a complicated job to make something simple. If a code structure looks
    obvious, don''t assume that it was easy to design*.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to make a design unnecessarily complex, including incorrect
    component decomposition, the thoughtless proliferation of threads, inappropriate
    choice of algorithms, complex naming schemes, and excessive or inappropriate module
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Elegance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Elegance embodies the aesthetic aspects of design and often goes hand in hand
    with simplicity. It means that your code isn''t baroque, confusingly clever, or
    overly complex. Well-designed code has a beauty in its structure. These are desirable
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Control flowing gracefully around the system. A single operation doesn't pass
    through every module, converting the format of its parameter between 16 different
    representations, before finally ignoring it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each part complements the others, adding something distinct and valuable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design is not riddled with special cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It associates similar things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No nasty surprises lurk around the corner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a small locality of change: A single, simple change in one place doesn''t
    lead to modifications of the code in many other places.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good design has a lot to do with balance and aesthetics. I won't go so far as
    to say programming is art, although some could argue a convincing case for this.
    Elegance and simplicity underpin most of the remaining characteristics in this
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we attack a design problem, we naturally divide it into parts called *modules*
    or *components*. We decompose into subsystems, libraries, packages, classes, and
    so on. Each part is less complex than the original problem, but put together,
    they form a complete solution. The quality of this decomposition is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key qualities of modularity are *cohesion* and *coupling*. We aim for modules
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strong cohesion**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cohesion* is a measure of how related functionality is gathered together and
    how well the parts *inside* a module work as a whole. Cohesion is the glue holding
    a module together.'
  prefs: []
  type: TYPE_NORMAL
- en: Weakly cohesive modules are a sign of bad decomposition. Each module must have
    a clearly defined role and not be a grab bag of unrelated functionality (like
    the pitifully common `utils` namespace—why *do* people write these things?).
  prefs: []
  type: TYPE_NORMAL
- en: '**Low coupling**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Coupling* is a measure of the interdependency *between* modules—the amount
    of wiring to and from them. In the simplest designs, modules have little coupling
    and so are less reliant on one another. Obviously, modules can''t be totally decoupled,
    or they wouldn''t be working together at all!'
  prefs: []
  type: TYPE_NORMAL
- en: Modules interconnect in many ways—some direct, some indirect. A module can call
    functions on other modules or be called by other modules. It may use another module's
    data types or share some data (perhaps variables or files). Good software design
    limits the lines of communication to only those absolutely necessary. These communication
    lines are part of what determines the code design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once identified, each module can be worked on in isolation and tested separately.
    This is an advantage of modularity; it allows you to split tasks between programmers.
    Take care, though; Conway''s Law warns that software structure may follow team
    structure: "If you have four teams working together to build a compiler, it will
    become a four-pass compiler" (see "[Organization and Code Structure](ch17s02.html#organization_and_code_structure
    "Organization and Code Structure")" on page 320). Make sure the decomposition
    is sensible and based on the problem, not the team organization.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design modules that are internally cohesive with minimal coupling. The decomposition
    must represent a valid partition of the problem space*.'
  prefs: []
  type: TYPE_NORMAL
- en: Good Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules help us separate concerns and partition the problem. Each module defines
    an *interface*, the public façade behind which it hides an internal implementation.
    This set of available operations is often called an *application programming interface
    (API)*. It is the sole route to a module's functionality, and its quality determines
    the quality of that module, at least as seen from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Draw lines in the sand that people don''t need to cross: Identify clear APIs
    and interfaces*.'
  prefs: []
  type: TYPE_NORMAL
- en: To create a good interface, follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the client and what it *wants* to do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the supplier and what it's *able* to do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can only successfully separate the user and implementer with an interface
    if both parties have been correctly identified and their individual needs are
    understood. Once you're clear about this, you stand a chance of creating an interface
    that will satisfy its users and is actually implementable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bad design puts operations in the wrong place, making it a nightmare to follow
    the application logic and difficult to extend the design. It leads to increased
    module coupling and reduced cohesion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Infer the type of interface required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it a function, a class, a network protocol, or something else? This is probably
    dictated by who supplies the functionality, but an interface may also be wrapped
    up to present it in different ways. For example, wrapping a CORBA object around
    a library publishes its functionality to a network of collaborating computers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Determine the nature of operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functionality *really* needs to be provided—is it more general than this
    client's specific requirement? Inside every function, there is often a more useful
    operation waiting to get out.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are a few key principles that help us to reason about the nature and
    quality of our interfaces. As illustrated in [Figure 13-3](ch13s04.html#the_interfaces_provided_by_a_house
    "Figure 13-3. The interfaces provided by a house"), these are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partitioning**'
  prefs: []
  type: TYPE_NORMAL
- en: An interface forms a point of contact, but also a line of separation between
    client and implementer. They can only communicate in the defined manner, not in
    any other ad hoc way.
  prefs: []
  type: TYPE_NORMAL
- en: Well-designed code clearly defines *roles and responsibilities*. Knowing who
    the main actors are in a system and what they are all supposed to do ensures that
    interfaces are crisp and effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example is my house: Its main interface is the front door. The door
    partitions occupants from visitors and determines where they meet. There are a
    number of other interfaces for other operations: windows, telephones, the chimney,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction**'
  prefs: []
  type: TYPE_NORMAL
- en: An abstraction allows the viewer to concentrate on important decisions, selectively
    ignoring certain details. It neatly organizes reality behind a simpler representation,
    helping us to cope with complexity. It's a particularly important concept in OO
    design. When designing an interface, you create an abstraction by carefully choosing
    exactly what is important for the user and what can be usefully hidden from them.
  prefs: []
  type: TYPE_NORMAL
- en: Given a bowl of fruit, you can happily say, "*Eat* the item on top," and then
    "*Eat* the next one," without worrying exactly what that entails; a grapefruit
    needs to be peeled, while rhubarb needs to be boiled and smothered in sugar. These
    details are hidden behind the abstraction *eat*; you only care that the fruit
    *was* eaten, not how.^([[2](#ftn.CHP-13-FN-2)])
  prefs: []
  type: TYPE_NORMAL
- en: '![The interfaces provided by a house](tagoreillycom20080909nostarchimages207486.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 13-3. The interfaces provided by a house**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstractions can form a hierarchy. You can view my house at different *levels
    of abstraction*, depending on whether you''re a builder, a particle physicist,
    or a bank manager. It can be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of rooms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An arrangement of walls, floors, and ceilings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A construction of bricks and timber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of molecules, or even atoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mortgage that needs to be paid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compression**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the ability of an interface to represent a large operation with something
    simpler. Compression is often the result of making good abstractions, but bad
    abstractions can lead to more verbose code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Substitutability**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can substitute one implementation of an interface with another, if it meets
    the same contract. If you define a sort interface in your program, then any algorithm
    can sit behind it: It could be a quicksort, a heapsort, or (heaven forbid) a bubblesort.
    You can change it at any point, as long as the visible behavior through the interface
    is the same.'
  prefs: []
  type: TYPE_NORMAL
- en: In class inheritance hierarchies, any object can be substituted for its supertype.
  prefs: []
  type: TYPE_NORMAL
- en: If you want me to open my front door, you'll ring the doorbell. It used to be
    a wired switch that ran to the bell mechanism, but I've just invested in a new-fangled
    wireless doorbell. This doesn't affect you at all, in fact you won't even know
    I've changed it; you push a button, and I appear.
  prefs: []
  type: TYPE_NORMAL
- en: '**ABOUT FACE**'
  prefs: []
  type: TYPE_NORMAL
- en: Most of computer science is built around defining interfaces and organizing
    complexity around them. The infamous maxim is, "Any problem can be solved by adding
    an extra level of indirection"—that is, hiding new complexity behind another interface.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of interfaces. They all present some *public* face to their
    clients and hide the gory implementation details behind this façade.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common forms of interfaces that you''ll create are:'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures (particularly more exotic ones with additional behavior, like
    semaphores)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols (network communications, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well-designed code allows extra functionality to be slotted in at appropriate
    places, when necessary. The danger is that this may lead to over-engineered code,
    trying to cope with any potential future modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensibility can be accommodated through software scaffolding: dynamically
    loaded plug-ins, carefully chosen class hierarchies with abstract interfaces at
    the top, the provision of useful callback functions, and even a fundamentally
    logical and malleable code structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design for extensibility, but don''t be hopelessly general—you''ll end up
    writing an OS, not a program*.'
  prefs: []
  type: TYPE_NORMAL
- en: A good designer thinks carefully about how his or her software will be extended.
    Randomly sprinkling code with hooks for extensibility may actually degrade quality.
    You should balance the functionality needed now, what will definitely need to
    be added later, and what might be needed to determine how extensible the design
    should be.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Duplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Well-designed code contains no duplication; it never has to repeat itself.
    Duplication is the enemy of elegant and simple design. Unnecessary redundant code
    leads to a brittle program: Given two similar pieces of code that differ only
    in minor details, you may find and fix a bug in one and then forget to fix the
    same bug in the other. This clearly compromises code safety.'
  prefs: []
  type: TYPE_NORMAL
- en: Most duplication comes through *cut-and-paste programming*—copying code in the
    editor. It can arise more subtly through the reinvention of wheels by programmers
    who don't understand the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: If you see strikingly similar things being done by separate sections of code,
    generalize it in a function with appropriate parameters. There's now a single
    place to fix any faults. This has the benefit of making the code's intent clearer
    with a descriptive function name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that are strikingly similar indicate that some functionality could be
    pushed up to a superclass or that there's a missing interface to describe the
    common behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do it once. Do it well. Avoid duplication*.'
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good design is not *necessarily* portable; it depends on the code's requirements.
    A lot *can* be done to prevent platform dependence, but compromising code for
    unnecessary portability is bad design. A good design is *appropriately* portable
    and manages portability concerns when they are an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The story is familiar: Your code was never intended to run in any other environment,
    so it wasn''t designed to cope. Later development unexpectedly required a new
    runtime platform; it was simpler to adapt the old program than write a new one.
    The code didn''t lend itself to portability, and there wasn''t enough time to
    refactor or redesign for cross-platform support. The result? A tangled mess of
    code, whose design has been irreparably warped, riddled with `#ifdef NEW_PLATFORM`
    constructions. It has not been programmed by an engineer; it has been plumbed
    by a philosopher.'
  prefs: []
  type: TYPE_NORMAL
- en: Make careful choices about the structure of your OS-dependent or hardware-dependent
    sections of code. It will pay dividends in the future, and need not affect performance
    or clarity (sometimes it may even improve clarity). It's important to think about
    this as early in the design as possible; it is expensive to rework old assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: The common approach is to create a platform abstraction layer (which may be
    a simple veneer over a few OS interface functions). You can implement this layer
    differently on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Manage the portability of your code in its design, rather than hacking it
    in as an afterthought*.'
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good design naturally employs best practices, fitting in with both the design
    methodology (see "[Programming Styles](ch22.html#programming_styles "Programming
    Styles")" on page 420) and the implementation language's idioms. This allows other
    programmers to immediately understand the code's structure.
  prefs: []
  type: TYPE_NORMAL
- en: Given the implementation language (which may be fixed or may be part of the
    design domain) you must understand how to use it *well*. C++, for example, has
    idioms like *Resource Acquisition Is Initialization (RAII)* and operator overloading,
    which make a big difference to how you design code. Learn them. Understand them.
    Use them.
  prefs: []
  type: TYPE_NORMAL
- en: Well-Documented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last, but by no means least, a good design should be documented. Don't leave
    readers to infer the structure by themselves. This is particularly important at
    the higher levels of design. The documentation should be small because the design
    is so simple.
  prefs: []
  type: TYPE_NORMAL
- en: At one end of the spectrum, architectural designs are documented in a specification.
    At the other end, functions employ self-documenting code. In the middle, you'll
    probably use literate programming for API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-13-FN-2)]) This ability to hide multiple physical behaviors behind
    a single logical abstraction is known as *polymorphism* and is described in "Polymorphism"
    on page 423 .
  prefs: []
  type: TYPE_NORMAL
- en: How to Design Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Always design a thing by considering it in its next larger context—a chair in
    a room, a room in a house, a house in an environment, an environment in a city
    plan.
  prefs: []
  type: TYPE_NORMAL
- en: --Eliel Saarinen
  prefs: []
  type: TYPE_NORMAL
- en: How do you learn to design well? Are good designers born or made? Can design
    be taught or caught? Some programmers have a natural flair for good design; it
    fits the way their brains work. They naturally appreciate aesthetics and can comprehend
    enough of a problem to make balanced judgments. Nevertheless, you *can* learn
    to design more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: When I was born, I wasn't very good at pottery. (I've never met anyone who was.)
    I'm still terrible now, but I took some lessons once. I understand the mechanics
    and can produce (almost recognizable) pots. I'd probably be much better if I practiced
    a little, but I'll never become a master artisan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, no one is born able to design code: We learn. We are taught design
    methodologies and good engineering practice. These aim to make design a repeatable
    process, but they are no substitute for *craftsmanship*. The creative thought
    process and construction of innovative designs is much harder to convey; there
    will always be better designers who grasp this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Good software design is aesthetic; to create this digital art requires skill,
    experience, and practice. This chapter cannot attempt a paint-by-numbers description
    of how to design software. A shame: If I could bottle good design, I''d be a millionaire.
    To be a good designer, you must understand what constitutes a good design and
    learn to avoid the characteristics of bad design. Then practice. For a long time.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from personal ability, there are design methods and tools that promise
    much to the programmer. We'll conclude by investigating how they can (or can't)
    help us.
  prefs: []
  type: TYPE_NORMAL
- en: Design Methods and Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many software design methodologies. Some emphasize a notation, others
    the process. A systematic approach is better than *seat of your pants* design;
    which method you use is usually dictated by company practice and culture. I'm
    always wary of getting too bogged down in a *particular* process—satisfying its
    minuscule details tends to stifle creativity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern design methods fall into two main families, the fundamental design philosophies
    upon which they are based:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured design**'
  prefs: []
  type: TYPE_NORMAL
- en: This is primarily about *functional decomposition*, breaking up the functionality
    of the system into a series of smaller operations. Routines are the main structuring
    devices; the design is composed of a hierarchy of routines. Structured design
    is characterized by the *divide-and-conquer* approach, splitting a problem into
    successively smaller procedures until each piece can be decomposed no more.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main lines of attack: *top-down* and *bottom-up*.'
  prefs: []
  type: TYPE_NORMAL
- en: Not surprisingly, a top-down approach starts with the entire problem and breaks
    it down to smaller activities. These, in turn, are designed as self-contained
    units, until no more division is necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, bottom-up design starts with the smallest units of functionality,
    the simple things you know the system *must* do. It then stitches these functions
    together until it arrives at an entire solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, these are used in tandem, and the design process ends where they
    meet, somewhere in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented design**'
  prefs: []
  type: TYPE_NORMAL
- en: Whereas structured design focuses on representing the operations a system must
    perform, OO design focuses on the data within that system. It models the software
    as an interacting set of individual units, known as *objects*.
  prefs: []
  type: TYPE_NORMAL
- en: An OO design identifies the primary objects in the problem domain and determines
    what their characteristics are. The behavior of these objects is established,
    including the operations they provide and which other objects they each relate
    to. The objects are weaved into a design, incorporating any implementation domain
    objects needed. Design is complete when all object behavior and interaction is
    determined.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming was hailed as the savior of the software design
    world, a new paradigm to usher in world peace, so much so that people are often
    embarrassed to not be performing OO design. But it has largely lived up to the
    hype, allowing software designs to manage the complexity of far bigger problems.
  prefs: []
  type: TYPE_NORMAL
- en: See "[Programming Styles](ch22.html#programming_styles "Programming Styles")"
    on page 420 for a more detailed description of design methods and processes.
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN PATTERNS**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Patterns* have become a buzzword in the OO programming community over the
    last few years. Popularized by the book *Design Patterns: Elements of Reusable
    Software* (Gamma et al. 94) by the authors affectionately known as the "Gang of
    Four" (hence it''s often known as the *GoF* book), design patterns are the software
    version of Christopher Alexander''s architectural work. (Alexander 99)'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns establish a vocabulary of proven design solutions, and each pattern
    describes a recognizable structure of collaborating objects. These aren't clever
    invented designs, but recurring patterns found in *real code* that have been shown
    to work. *Pattern languages* collate a catalog of design patterns, showing how
    they relate to and complement one another. Each pattern in a language follows
    a common form, describing the *context*, the *problem*, and the *solution*. This
    information allows you to apply the pattern appropriately in your designs.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns crop up at several levels in a software system. Architectural patterns
    have a profound influence on the organization of a system. Design patterns are
    midlevel collaborations of software components. Language-level patterns are specific
    code techniques, known more commonly as language *idioms*.
  prefs: []
  type: TYPE_NORMAL
- en: The names of design patterns have entered common parlance, a testament to their
    usefulness. You'll hear programmers happily talking about *adaptors*, *observers*,
    *factories*, and *singletons*.
  prefs: []
  type: TYPE_NORMAL
- en: There is far more to design patterns than this quick description can do justice.
    They are a genuinely useful concept, and it's worth devoting some time to learn
    about them. Read the GoF book and material beyond it.
  prefs: []
  type: TYPE_NORMAL
- en: Design Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our designs are ultimately expressed in code, but it can often be helpful to
    work at a more abstract level. Tools help us to reason about a design, help us
    produce more effective designs, and help us to communicate those designs to other
    programmers—documenting what we *intend* to produce and what we have *already*
    created.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, methodologies are tools, but there's a broad range of other design
    aids that complement them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Notations**'
  prefs: []
  type: TYPE_NORMAL
- en: Pretty pictures are worth their weight in words. Many graphical notations exist
    to help us express our designs pictorially. Most became fleetingly fashionable
    and then quietly slunk out of the limelight to be replaced by an even sexier way
    of drawing boxes and lines. The *Unified Modeling Language (UML)* is currently
    the most popular and well-specified notation. It provides a standard way to model
    and document practically every artifact generated by the software development
    process. In fact, it has grown so comprehensive that you can use it to visualize
    far more than just software; it has been used to model hardware, business processes,
    and even organizational structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notations provide a medium to help you express, think about, and discuss your
    software design. They serve two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: They allow you to scrawl quick "back of an envelope" designs and share thoughts
    around a whiteboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow you to formally document designs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To maintain your sanity in the latter case, diagram creation must be automated
    with a dedicated drawing tool. Otherwise, diagrams will be hard to update and
    will diverge from reality as you develop the code. Spend your time doing something
    useful, not drawing boxes and lines.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to not be bogged down by overly formal use of a notation, happily using
    it as a method of communicating the essential elements of a design. Knowing enough
    to be able to communicate is good enough for me; I don't want to get too concerned
    about what *every* diamond and dotted line means in *every* type of picture.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design patterns**'
  prefs: []
  type: TYPE_NORMAL
- en: A powerful design tool providing a vocabulary of proven design techniques, and
    showing how to apply them in practice. "[DESIGN PATTERNS](ch13s05.html#design_patterns
    "DESIGN PATTERNS")" on page 255 discusses design patterns in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flowcharts**'
  prefs: []
  type: TYPE_NORMAL
- en: A particular kind of graphical notation, used to visualize algorithms. They're
    good for giving a high-level overview but are less precise than code and become
    another thing to be kept in sync with code changes. For this reason, it's best
    to use them sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pseudocode**'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode helps you draft function implementations. It's one of the most curious
    inventions in software design—halfway between a natural language and a programming
    language, a sort of pidgin English. Its advantage is the freedom from any particular
    language's syntax and semantics. You can concentrate on what needs to be done,
    not on language mechanics, and you can include arbitrary amounts of descriptive
    prose for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: These aren't incredible benefits compared to the downsides. The pseudocode will
    require translation into an implementation language. You could have started to
    write in *that* language anyway and saved yourself some effort. If pseudocode
    is being used as design documentation, then you'll have to keep it in sync with
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Program Design Language (PDL)* is an even more absurd invention—a formalized
    pseudocode. I guess it made sense to somebody at the time. I''d love to have seen
    their pseudocode compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design in code**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a useful informal approach to code design. During the initial design
    stages, you capture all APIs and the lower-level interfaces in code, but without
    implementing any of them—you just write stubs that return plausible values, putting
    comments inside each describing what should be done. When you have reached a sufficiently
    mature design, the system already has a lot of code written.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a mixed blessing, as it can lead to less fluid designs. The more
    you change the design, the more stubbed code you have to alter.
  prefs: []
  type: TYPE_NORMAL
- en: '**CASE tools**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Computer-aided software engineering (CASE)* tools assist in all or part of
    the design process, automating tedious jobs and managing the workflow. Most are
    capable of generating code (of variable quality) from your pretty pictures. Some
    even update the pictures when you modify the code; this is known as *round-trip
    engineering* (or *round-tripping*). Many CASE tools support collaborative work,
    allowing teams of programmers to contribute to a single large-scale design.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A breed of CASE tool worthy of mention is *Rapid Application Development (RAD)*
    tools: environments for quickly building applications. They tend to work well
    in their specific domain (usually simple UI-focused applications) but aren''t
    good general-purpose software design models.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Take a pragmatic approach to design tools and methodologies—use them when
    they are genuinely helpful—but don''t become a slave to them*.'
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of intense complexities, intense simplicities emerge.
  prefs: []
  type: TYPE_NORMAL
- en: --Winston Churchill
  prefs: []
  type: TYPE_NORMAL
- en: Good code is well designed. It has a certain aesthetic appeal that makes it
    *feel good*. You must plan a design before beginning to write code, or you'll
    end up with an unpleasant mess. Consider things like clean structure, possible
    future extensions, correct interfaces, appropriate abstractions, and portability
    requirements. Aim for simplicity and elegance.
  prefs: []
  type: TYPE_NORMAL
- en: Design involves a strong element of craftsmanship. The best designs come from
    experienced and skilled hands. Ultimately, a good designer is what makes a good
    design. Mediocre programmers do not produce excellent designs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Want to leave anything they touch in a good state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of programming as a creative process and weave an element of artistry
    into their work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about the structure of code before they start working on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel the need to tidy up and refactor messy code before they do any extra work
    on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constantly learn about the design of other software, building up knowledge of
    successes and failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Keep knitting more and more code into a tight ball until they think they've
    done enough and then complain about the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't notice a bad design or feel any distaste when working with dense code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are happy to hack quickly and run away, leaving someone else to clean up the
    mess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't appreciate or respect the internal design of code they're working on;
    they trample over it in an unsympathetic manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  prefs: []
  type: TYPE_NORMAL
- en: Describes how to *design code for testing*—making it easier to prove that your
    code works properly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  prefs: []
  type: TYPE_NORMAL
- en: The highest level of software design is known as *software architecture*. It
    provides its own specific problems and is dealt with in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: Software designs are often captured in a specification document.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  prefs: []
  type: TYPE_NORMAL
- en: Design fits into the overall software development process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 23](ch23.html "Chapter 23. THE OUTER LIMITS")'
  prefs: []
  type: TYPE_NORMAL
- en: The type of system you're building has an inevitable influence on the software's
    internal design.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207488.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 519.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does project size affect your software design and the work involved in creating
    it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is a well-documented bad design better than an undocumented good one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you measure the design quality of a piece of code? How can you quantify
    its simplicity, elegance, modularity, and so on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is design a team activity? How important are teamworking skills in creating
    a good design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are different methodologies more suitable to different projects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what ways can you determine whether a design is highly cohesive or weakly
    coupled?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've solved a similar design problem in the past, how good an indicator
    is it of how difficult *this* problem will be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a place for experimentation in design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look back and think about how you learned to design code. How could you convey
    the knowledge you've gained to a total novice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What experience do you have with using particular design methodologies? Were
    these good or bad experiences? What was the resulting code like? What might have
    worked better?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you find it important to stick rigidly to the methodology you're using?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the best designed code you've ever seen? What was the worst designed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A programming language is essentially a tool to implement your design, not a
    religion to argue about. How important is it *really* to know language idioms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you think programming is an *engineering discipline*, a *craft*, or an *art*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14. SOFTWARE ARCHITECTURE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Laying the Foundations of Software Design*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Architecture is the art of how to waste space.
  prefs: []
  type: TYPE_NORMAL
- en: --Philip Johnson
  prefs: []
  type: TYPE_NORMAL
- en: Go into a city. Stand in the middle of it. Look around. Unless you've picked
    an unusual place, you will be surrounded by a large number of buildings of varying
    ages and styles of construction. Some fit into their surroundings sympathetically.
    Others look totally out of place. Some are aesthetically pleasing and seem well
    proportioned. Others are downright ugly. Some will still be there in 100 years'
    time. Many will not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architects who designed these buildings took a lot into consideration before
    they put pencil to paper. During the process of design, they worked carefully
    and methodically to ensure that the building was feasible to fabricate, and they
    balanced all the contending forces: user requirements, construction methods, maintainability,
    aesthetics, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Software is not made of bricks and mortar, but the same careful thought is requiredto
    ensure that a system meets similar sets of requirements. We have been erecting
    buildings far longer than we've been writing software, and it shows. We're still
    learning about what makes goodsoftware architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this little foray into the world of software architecture, we'll investigate
    some common architectural patterns and look at what software architecture really
    is, what itreally isn't, and what it's used for.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERGROUND MOVEMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: I joined a project that had produced a large amount of undocumented software,
    erected without plan or purpose, with no architect to guide the construction process.
    Naturally, it had become an unsightly carbuncle. The time came when we needed
    to understand how it all *really* worked, and an architectural diagram of the
    system was drawn up. There were so many different components (many largely redundant),
    inappropriate interconnections, and different methods of communication that the
    diagram was an intense jumble of tightly woven lines in many interpretive colors—almost
    as if a spider had fallen into a few different cans of paint and then spun psychedelic
    webs across the office.
  prefs: []
  type: TYPE_NORMAL
- en: Then it struck me. We had all but drawn a map of the London Underground. Our
    systembore such a striking resemblance, it was uncanny—it was practically incomprehensible
    to an outsider, with many routes to achieve the same end, and the plan was still
    a gross simplification of reality. This was the kind of system that would vex
    a traveling salesman.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of architectural vision had clearly made its mark on the software.
    It was hard to work with and hard to understand, with bits of functionality strewn
    across completely random modules. It had gotten to the point where the only useful
    thing you could do with it was throw it away.
  prefs: []
  type: TYPE_NORMAL
- en: In software construction, as in building construction, the *architecture really
    matters*.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Software Architecture?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is this just another term that stretches the *building* metaphor a little thinner
    (see "[DO WE REALLY BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question
    "DO WE REALLY BUILD SOFTWARE?")" on page 177)? Maybe so, but it is a genuinely
    useful concept. Software architecture is sometimes known as *high-level design*;
    regardless of the terms used, the meaning is the same. Architecture is a more
    evocative description of the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Software Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an architect prepares his blueprint for a building, the software architect
    prepares a blueprint for the software system. However, while a building's blueprint
    is a rigorously detailed plan with all the important features included, our software
    architecture is a top-level definition, an overview of the system that specifically
    avoids too much detail. It is macro, not micro.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this high-level view, all implementation details are hidden; we just see
    the essential internal structure of the software and its fundamental behavioral
    characteristics. The architectural view does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the key software modules (or components, or libraries; at this point
    call them what you like—*blobs*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifies which components communicate with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps to identify and determine the nature of all the important interfaces in
    the system, clarifying the correct *roles and responsibilities* of the various
    subsystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information allows us to reason about the system as a whole without having
    to understand how every individual part will work. The architecture provides a
    framework into which the later development fits. It shows how work can be split
    between teams and allows you to weigh different implementation strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the architecture give a picture of how the system is composed,
    it also shows how it should be extended over time. In large teams, a program will
    develop more elegantly when there's a clear, unified vision of how the software
    should be adapted, of what should be put in each module, and of how modules connect.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The architecture is the single largest influence on the design and future
    growth of a software system. It is therefore* essential *to get it right in the
    early stages of development*.'
  prefs: []
  type: TYPE_NORMAL
- en: As an up-front activity, the architecture is our first chance to map the *problem
    domain* (the Real World problem we are solving) to a *solutiondomain*. There isn't
    always a simple one-to-one mapping of objects and activities between the two,
    so the architecture shows how to think about one in terms of the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exactly what needs to be addressed by the software architecture will differ
    from project to project. The target platform is not important at this stage; it
    may be possible to implement the architecture on a number of different machines
    using different languagesand technologies. However:'
  prefs: []
  type: TYPE_NORMAL
- en: For certain projects, it may be important to specify particular hardware components,
    most likely for embedded designs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a distributed system, the number of machines and processors and the split
    of work between them might be an architectural issue. Minimum and average system
    configurations should be considered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture may also describe specific algorithms or data structures if
    they are fundamental to the overall design (although this is far less likely).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is always a trade-off. The more information that is set in stone at the
    architectural level, the less room for maneuverability there is at a later design
    or implementation stage.
  prefs: []
  type: TYPE_NORMAL
- en: Points of View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In physical architecture, we use a number of different drawings or views of
    the same building: one for the physical structure, one for the wiring, one for
    the plumbing, andso on. Similarly, we develop different software views in the
    architectural process. Four views are commonly recognized:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The conceptual view**'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes called the *logical view*, this shows the major parts of the system
    and their interconnections.
  prefs: []
  type: TYPE_NORMAL
- en: '**The implementation view**'
  prefs: []
  type: TYPE_NORMAL
- en: This view is seen in terms of the real implementation modules, which may have
    to differ from the neat conceptual model.
  prefs: []
  type: TYPE_NORMAL
- en: '**The process view**'
  prefs: []
  type: TYPE_NORMAL
- en: Designed to show the dynamic structure in terms of tasks, processes, and communication,
    this view is best used when there's a high degree of concurrency involved.
  prefs: []
  type: TYPE_NORMAL
- en: '**The deployment view**'
  prefs: []
  type: TYPE_NORMAL
- en: Use this view to show the allocation of tasks to physical nodes, in a distributed
    system. For example, you may split functionality between a database server and
    afarm of web interface gateways.
  prefs: []
  type: TYPE_NORMAL
- en: You don't start with all of these. Particular views arise as development work
    progresses. The main result of the initial architectural phase is the *conceptual
    view*, and that's what we're concentrating on here.
  prefs: []
  type: TYPE_NORMAL
- en: '**FOR WHAT IT''S WORTH**'
  prefs: []
  type: TYPE_NORMAL
- en: Software architecture has wide-ranging implications—far beyond the initial structure
    of the code, right into the heart of the software factory. The architecture will
    be a lasting legacy, both in the technological and practical realms. Architecture
    affects how the code will grow and how teams of people will work together to extend
    it;software designaffects workflow. With a three-tiered architecture, you'll end
    up with *three* teams of people working on the separate parts. There will probably
    be *three* sets of admin staff too, and *three* management reporting lines. Someone's
    early design decision will affect which desk you sit at.
  prefs: []
  type: TYPE_NORMAL
- en: Since the architecture determines how malleable the software is and how well
    the codebase can accommodate future requirements, it ultimately influences the
    commercial success of your company. A bad architecture is more than just inconvenient—it
    could cost you your livelihood. Serious stuff.
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, it affects us most directly—it will affect how fun our work
    will be. No one wants to labor intensely to add a minuscule feature that would
    have taken two seconds with a correct initial design. At conception, check that
    the architecture supports what you think it should, not just what the architects
    believe.
  prefs: []
  type: TYPE_NORMAL
- en: Where and When Do You Do It?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The architecture is captured in a high-level document called something imaginative
    like the *architecture specification*. This specification explains the system's
    structure and shows how it fulfills the requirements, including important issues
    like the strategy to reach any performance requirements and how acceptable fault
    tolerance will be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Capture system architecture in a known place; a document accessible to everyone
    involved—programmers, maintainers, installers, managers (perhaps even customers)*.'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture is the initial system design. It is therefore the *first* developmental
    step after the requirements have been agreed upon. It's important to generate
    a specification up front because it provides a first chance to review and validate
    the design decisions that will have the most significant impact on the project.
    It will expose weaknesses and potential problems. Reversing a bad decision this
    early on will save a lot of time, effort, and money. It's expensive to changethe
    foundation of a system once a lot of code has been built upon it.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural work is a form of design, but it is separate from the module design
    phase, and distinct from low-level code design, although it certainly overlaps
    somewhat. Later work on detailed design may feed changes back up to the system
    architecture. This isnatural and healthy.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHOSE JOB?**'
  prefs: []
  type: TYPE_NORMAL
- en: We've seen that software architecture affects *everyone* on the project—not
    just the programmers. In contrast, the architecture is determined by a far smaller
    group of people. What a responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture designer is called a *software architect*. This is a grandiose
    titleand, like *engineer*, somewhat contentious. "Real" architects must study,
    qualify, and reach levels of professional excellence to even be called architects.
    There are no such requirements in the software world.
  prefs: []
  type: TYPE_NORMAL
- en: Software architects are among the project initiators, working right at the beginning
    of the development cycle. As development ramps up, programmers will join the effort
    to implement this established architecture.
  prefs: []
  type: TYPE_NORMAL
- en: However, on smaller projects requiring less specialized architectural experience,
    the programmers themselves will devise the architecture. No big guns are drafted
    in. Be ready to contribute to architectural design.
  prefs: []
  type: TYPE_NORMAL
- en: What Is It Used For?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Architecture is the initial system design. But its uses stretch even further.
    We use the system architecture to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validate**'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture is our first chance to validate what is going to be built.
    With it, we can mentally check that the system will meet all requirements. We
    can check that it really is feasible to build. We can ensure that the design is
    internally consistent and hangs together well with no special cases or gratuitous
    hacks. Nasty blemishes in the high-level design will only lead to more dangerous
    hacks at lower levels.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture helps to ensure that there is no duplication of work, wasted
    effort, or redundancy. We use it to check that there are no gaps in the strategy,
    that we haveincluded all the necessary pieces. We ensure that there will be no
    mismatches as separatesections are brought together.
  prefs: []
  type: TYPE_NORMAL
- en: '**Communicate**'
  prefs: []
  type: TYPE_NORMAL
- en: We use the architecture specification to communicate the design to all interested
    parties. These may be system designers, implementers, maintainers, testers, customers,
    or managers. It's the primary route to understand the system and is an important
    piece of documentation that should *always* be kept up to date as changes are
    made.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An architecture specification is an essential device to communicate the shape
    of your system. Ensure that you keep it in sync with the software*.'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture conveys the vision of your system, mapping the problem domain
    to the solution domain. It should neatly identify how future extensions fit in,
    helping to maintain the system's *conceptual integrity*. (Brooks 95) It implicitly
    provides a set of conventions and contains an element of style. For example, it's
    clear that you shouldn't introduce a new component with custom socket-based communication
    if the rest of the design uses a CORBA infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture provides a natural route into the next level of design without
    being too prescriptive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discriminate**'
  prefs: []
  type: TYPE_NORMAL
- en: We use the architecture to help us make decisions. For example, it identifies
    build versus buy decisions, determines whether a database is required, and clarifiesthe
    error-handling strategy. It will flag problem areas, areas of particular risk
    on the project, and help us plan to minimize this risk. Just as an architect's
    primary goal is to ensure his building stays up when it's built—under all expected
    conditions (and some unusual conditions too)—so should we ensure the resillience
    of our software structure. A little wind or extra load shouldn't topple the thing
    over.
  prefs: []
  type: TYPE_NORMAL
- en: We need this systemwide perspective to make the appropriate trade-offs, ensuring
    that the design meets its required properties. These important issues are considered
    at thebeginning rather than grafted in toward the end of development.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Make all software design decisions in the context of the architecture. Always
    check that you''re working in line with the system vision and strategy. Don''t
    create a little wart on the side that doesn''t complement anything else*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of Components and Connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Architecture mostly concerns itself with *components* and *connections*. It
    determines the number and type of each.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Architecture captures information about each component, whatever *component*
    means inthe architecture's context. It could be an object, a process, a library,
    a database, or athird party product. Each of the system's components is identified
    as a clear and logicalunit. Each performs one task and does it well. No component
    includes a kitchen sink unless there's a specific kitchen-sink module.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it won''t dwell on component implementation issues, the architecture
    will describe all exposed facilities and perhaps the important externally visible
    interfaces. It defines the *visibility* of the component: what it can see and
    what it can''t, and what can see it and what can''t. Different architectural styles
    imply differentvisibility rules, as we''ll see later.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ARCHITECTS VS. MARKETERS**'
  prefs: []
  type: TYPE_NORMAL
- en: An architecture is inadequate if it doesn't fulfill the product requirements
    for initial deployment or any future development; design quality is about more
    than just technical excellence. Technical issues must be addressed alongside product
    management and marketing considerations.
  prefs: []
  type: TYPE_NORMAL
- en: There is no point in developing a product that no one wants; it would obviously
    be a huge waste of time. But you can miss vital business opportunities by omitting
    marketingrequirements from technical consideration. The marketing department identifies
    core business objectives including sales strategies (do you charge a one-off fee
    or employ a licensing/billing model?), the product's position in the marketplace
    (is it a high-end, feature-packed, high-cost product or a cheap, mass-produced
    item?), and the importance of a uniquebrand running through the system.
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, visibly good architecture may be a *unique selling point*
    and mayprovide a strong competitive advantage. Other markets care less about the
    internal systemstructure, but an architecture that anticipates and handles future
    customer requirements is still essential to establish and maintain a strong market
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Technical architects must work closely with the marketing decision makers to
    understand how new software will fit into the company's overall strategy and what
    the customer requires for a truly exceptional solution. The software architecture
    will address marketing issues such as usability, reliability, upgradeablity, and
    extensibility. Each of these has a real influence on the software design. Support
    for different charging methods alonemay have a huge impact on the profitability
    of the project—the inclusion of rich logging support will pave the way for per-transaction
    billing, which may lead to increased product revenue. However, it may mandate
    the inclusion of additional security and fraud-prevention measures in the architectural
    planning.
  prefs: []
  type: TYPE_NORMAL
- en: Marketing requirements feed into the technical architecture. Technical considerations
    will also feed back to the marketing strategy. A truly great architecture is born
    when technical and strategic visions meet to create a product that stands out
    from its competitors.
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The architecture identifies all the inter-component connections and describes
    the connection properties. A connection may be a simple function call or data
    flow through a pipe. It may be an event handler or a message passing through some
    OS or network mechanism. A connection can be *synchronous* (blocking the caller
    until the implementation has completed the request) or *asynchronous* (returning
    control to the caller immediately and arranging for a reply to be posted back
    at a later date). This is important, since it affects the flow of control around
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some communication is indirect (and consequently quite subtle). For example,
    components can share certain resources and talk through them—rather like posting
    messageson a shared whiteboard. Examples of shared communication channels are:
    a subordinate component, a shared memory region, or something as basic as the
    contents of a file.'
  prefs: []
  type: TYPE_NORMAL
- en: What Is Good Architecture?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to good architecture is *simplicity*. A few well-chosen modules and
    sensible communication paths are the aim. It also needs to be *comprehensible*,
    which often means visually represented. We all know that *a picture speaks a thousand
    words*.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Good system architecture is* simple. *It can be described in a single paragraph
    and summarized in one elegant diagram*.'
  prefs: []
  type: TYPE_NORMAL
- en: In a well-designed system, there should be neither too few nor too many components.
    This criterion scales with the size of the problem. For a small program, the architecturemay
    fit on (or even be done on) the back of an envelope, with just a few modules and
    somesimple interconnections. A large system naturally requires more effort and
    more envelopes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Too many* fine-grained components lead to an architecture that is bewildering
    and hard to work with. It implies that the architect has gone into too much detail.
    *Too few* components means that each module is doing far too much work; this makes
    the structure unclear, hard to maintain, and hard to extend. The correct balance
    is somewhere between the two.'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture does not dictate the inner workings of each module—that's what
    module design is for. The goal is that each module should know very little about
    the other parts of the system. We aim for low coupling and high cohesion (see
    "[Modularity](ch13s04.html#modularity "Modularity")" on page 247) at this level
    of design, as with all others.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Architecture* identifies *the key components of the system and how they interact.
    It doesn''t define* how *they work*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture specification lists the design decisions made and makes it
    clear why this approach is being favored over any alternative strategies. It doesn''t
    need to labor these other approaches, but should justify the chosen architecture
    and prove that some serious thought went into it. It must have correctly identified
    the primary goal of the system: For example, *extensibility* is a different game
    from *performance* and will lead to different architectural design decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: A good architecture leaves room for maneuverability; it allows you to change
    your mind. It may specify that we wrap third party components with abstract interfaces
    so we can swap one version out for another. It may suggest technologies that make
    it easy to select different implementations during deployment. As a project gains
    momentum, the correct implementation choices become clear—they aren't always obvious
    at first. A successful architecture is flexible, providing a mechanism for nimble
    design during these initial uncertainties. The architecture is the first pivot
    on which to balance contending forces; it will show how we trade one quality for
    another.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A good architecture leaves space for maneuverability, extension, and modification.
    But it isn''t hopelessly general*.'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture must be clear and unambiguous. Preexisting, well-known architectural
    styles or well-known frameworks are best (see the next section for more on these).
    Architecture must be easy to understand and work with.
  prefs: []
  type: TYPE_NORMAL
- en: Like a good design, good architecture has a certain aesthetic appeal that makes
    it *feel* right.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Form ever follows function*.'
  prefs: []
  type: TYPE_NORMAL
- en: --Louis Henry Sullivan
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as an immense gothic cathedral and a quaint Victorian chapel, or an imposing
    tower block and a 1970s public lavatory employ different architectural styles,
    there are anumber of recognized software architectural styles that a system may
    be built upon. A style may be chosen for various reasons, good or bad—perhaps
    on sound technological grounds, or perhaps based on the architect''s prior experience,
    perhaps even by what style is currently in fashion. Each architecture has different
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Its resilience to changes in the data representation, algorithms, and required
    functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its method of module separation and connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its comprehensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its accommodation of performance requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its consideration of component reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, we might see a mixture of architectural styles in one system. Some
    data processing may progress through a pipe and filter process, while the rest
    of the systememploys a component-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recognize the key architectural styles and appreciate their pros and cons.
    This will help you to sympathetically work with existing software and perform
    appropriate system design*.'
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe some of the common architectural styles. And
    then compare them to pasta.
  prefs: []
  type: TYPE_NORMAL
- en: No Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A system always has an architecture, but like my London Underground project,
    it maynot have a *planned* architecture. Before long, this state of affairs becomes
    an albatross around the neck of your development team. The resulting software
    will be a mess.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an architecture is essential if you want to build good software. Not
    planning an architecture is a surefire way to doom development before you've even
    started.
  prefs: []
  type: TYPE_NORMAL
- en: '![No Architecture](tagoreillycom20080909nostarchimages207490.png)'
  prefs: []
  type: TYPE_IMG
- en: Layered Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably the most commonly used architectural style in conceptual views.
    Itdescribes the system as a hierarchy of layers, with a building-block approach.
    It is a very simple model to comprehend; even a non-techie can quickly grasp what
    it's telling him.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layered Architecture](tagoreillycom20080909nostarchimages207492.png)'
  prefs: []
  type: TYPE_IMG
- en: Each component is represented by a single block in the stack. The positions
    in the stack indicate what lives where, how the components relate to each other,
    and which components can "see" which other components. Blocks may be placed alongside
    each other on the same level and can even become tall enough to span two layers.
  prefs: []
  type: TYPE_NORMAL
- en: A famous example of this is the OSI seven-layer reference model for network
    communication systems. (ISO 84) A more interesting example is the Goodliffe seven-layer
    trifle reference model shown in [Figure 14-1](ch14s03.html#the_goodliffe_seven-layer_trifle_reference_model
    "Figure 14-1. The Goodliffe seven-layer trifle reference model").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Goodliffe seven-layer trifle reference model](tagoreillycom20080909nostarchimages207494.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 14-1. The Goodliffe seven-layer trifle reference model**'
  prefs: []
  type: TYPE_NORMAL
- en: At the lowest level of the stack, we find the hardware interface, if the system
    does indeed interact with physical devices. Otherwise, this level is reserved
    for the most basic service, perhaps the OS or a middleware technology like CORBA.
    The highest level will likely be occupied by the fancy interface that the user
    interacts with. As you rise further up the stack, you move further away from the
    hardware, happily insulated by the layers in between in the same way that the
    roof of a house doesn't have to worry about the magma at the earth's core.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any point, you can brush out all the lower layers and slot in a new implementation
    of the layer below—the system will function as before. This is a key point: It
    means that you can run the same C++ code on any computing platform that supports
    your C++ environment. You can swap the hardware platform without touching your
    application code—relying on the OS layer (for example) to swallow the technical
    differences. Handy.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher levels use the public interfaces of the layer directly below. Whether
    they can use the public interfaces of the lower levels depends of your definition
    of layering. Sometimes the diagram is fiddled to represent this, like the sherry
    brick in the trifle stack. Whether or not components on the same layer can interconnect
    is also not rigidly defined. You certainly can't use anything from ahigher level;
    if you break this edict, you no longer have a layered architecture, just a meaningless
    diagram drawn in stack form.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, most layer diagrams are informal. The relative size and position
    ofboxes gives a clue as to importance of a component, and that is generally sufficient
    as an overview. Component connections are implicit, and the methods of communication
    irrelevant. (However, this can be a key architectural concern for the efficiency
    of the system—you won't send gigabytes of data down an RS232 serial port.)
  prefs: []
  type: TYPE_NORMAL
- en: Pipe and Filter Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This architecture models the logical flow of data through the system. It is
    implemented as a string of sequential modules that each read some data, process
    it, and spit it out again. At the start of the chain is a data generator (maybe
    a user interface or perhaps some hardware harvesting logic). At the end is a data
    sink (perhaps the computer display or a log file). It's the old through-the-grapevine
    telephone game in digital form. Thedata flows down the pipe, encountering the
    various filters en route. The transformations are usually incremental; each filter
    does a single simple process and tends to have very little internal state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipe and Filter Architecture](tagoreillycom20080909nostarchimages207496.png)'
  prefs: []
  type: TYPE_IMG
- en: The pipe and filter architecture requires a well-defined data structure between
    each filter; it has the implicit overhead of repeatedly encoding the output data
    for transmission down the pipe and parsing it back again in each subsequent filter.
    For this reason, the data stream is usually very simple—just a plaintext format.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture makes it easy to add functionality by just plugging a new
    filter into the pipeline. Its main downside is error handling. It is hard to determine
    where an error originated in the pipeline by the time a problem manifests itself
    at the sink. It'scumbersome to pass error codes down the chain toward the output
    stage; they need extra encoding and are hard to handle uniformly over several
    separate modules. The filters may use a separate error channel (e.g., `stderr`),
    but error messages can get mixed up all too easily.
  prefs: []
  type: TYPE_NORMAL
- en: Client/Server Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typically network-based architecture, the client/server model separates functionality
    into two key pieces: the *client* and the *server*. It differs from the older
    *mainframe* style of networked design in the division of work between each part;
    a mainframe "client" is a dumb terminal—little more than a means to capture and
    transmit keypresses, with some output display.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client/Server Architecture](tagoreillycom20080909nostarchimages207498.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A SLAP IN THE INTERFACE**'
  prefs: []
  type: TYPE_NORMAL
- en: A key software construction principle is *modularity*, designing systems from
    replaceable components. This is almost a "LEGO brick" approach to construction.
    Done correctly, you should be able to take out a square, blue brick and replace
    it with a slightly fancier red one. If the bricks are the same size and shape
    and have the same kinds of connector, they will fit into the same hole and do
    the same job.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we implement this in software? We define *interfaces*; these are our
    connection points and component barriers. They define the size and shape of each
    component (as seen from the outside, at least) and determine what you have to
    do to provide a like-for-like replacement. Key types of interfaces are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**APIs**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Application programming interfaces (APIs)* are specified as collections offunctions
    in a physically linked application. To replace a component that implements a particular
    API, you just reimplement all the functions and relink the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class hierarchies**'
  prefs: []
  type: TYPE_NORMAL
- en: You can design an abstract "interface" class (in Java and C#, you'd actually
    define an `interface`). Then provide any number of concrete implementations that
    derivefrom it and implement that interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Component technologies**'
  prefs: []
  type: TYPE_NORMAL
- en: Technologies such as COM and CORBA allow your program to determine the correct
    implementation component at run time. Typically, interfaces are defined in an
    abstract *Interface Definition Language (IDL)*. The beauty of this approach is
    that components can be written in any language. It requires middleware or OS support.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data formats**'
  prefs: []
  type: TYPE_NORMAL
- en: These formats can form a connection point in designs focused on the movement
    of data rather than the flow of control. You can replace any component in the
    data chain with an analog that interacts with the same data types.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, architecture—indeed, most of software design—is about crafting
    appropriate interfaces. Each of these interface techniques maps to a particular
    architecturalstyle. Pick an interface mechanism that complements the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The clients of a client/server architecture are richer, more intelligent, and
    generally able to present data in an interactive, graphical manner. Here is a
    more detailed look at the role of the two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**'
  prefs: []
  type: TYPE_NORMAL
- en: The server provides certain well-defined services to clients. It will generally
    be a powerful computer dedicated to providing specific functionality or to managing
    a resource (shared files, printers, a database, or pooled processing power).
  prefs: []
  type: TYPE_NORMAL
- en: The server provides certain well-defined services to clients. It will generally
    be a powerful computer dedicated to providing specific functionality or to managing
    a resource (shared files, printers, a database, or pooled processing power).
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**'
  prefs: []
  type: TYPE_NORMAL
- en: The client consumes a server's services. It sends off requests and processes
    the results that are returned. Some clients are dedicated terminals which only
    fulfill one role; other clients serve many functions (for example, a "client"
    application may run on a standard desktop PC that can also browse the web and
    view email).
  prefs: []
  type: TYPE_NORMAL
- en: There can be many different types of clients using one server, all performing
    the same set of requests but in different ways. One client might be web based,
    one might have a GUI interface, while another might provide command line access.
  prefs: []
  type: TYPE_NORMAL
- en: This client/server approach is sometimes known as a *two-tier* architecture,
    for obvious reasons. It's very common and is seen throughout the software development
    world. The means of communication between client and server varies—it's simplest
    to use standard network protocols, but you may also see use of remote procedure
    calls (RPC), remote SQL database queries, or even proprietary application-specific
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways of splitting work between the two components. The main
    application logic (also known as *business logic*) may run on either the client
    or server, depending on how intelligent and specialized the client is supposed
    to be. As more application logic is pushed down to the client, the design becomes
    less flexible—separate clients have to reimplement similar features, negating
    the benefit of the central server. Clients are generally concerned with providing
    sensible human interfaces to the published server functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We sometimes see an extension of this two-tier design, which introduces another
    layer (the *middle tier*). This component is explicitly designed to contain the
    business logic, separating it from both the client application (which is now most
    definitely only an interface) and the back-end data storage. This is a *three-tier*
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client/server approach is different from a *peer-to-peer* architecture, where
    no network node has more capability or importance than any other. Peer-to-peer
    architectures are harder to deploy but more tolerant of faults. The client/server
    design is crippled when the server is unavailable (through some software fault
    or routine maintenance): No client will be able to operate until the server comes
    back to life. For this reason, client/server installations generally require a
    designated administrator to keep all systems running smoothly.'
  prefs: []
  type: TYPE_NORMAL
- en: Component-Based Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This architecture decentralizes control and splits it into a number of separate
    collaborating *components* rather than a single monolithic structure. It is an
    object-oriented approach, but doesn't necessarily require implementation in an
    OO language. Each component's public interface is typically defined in an *Interface
    Definition Language (IDL)* and is separate from any implementation, although some
    component technologies (like .NET's built-in component support) can determine
    this from the implementation code itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![Component-Based Architecture](tagoreillycom20080909nostarchimages207500.png)'
  prefs: []
  type: TYPE_IMG
- en: Component-based design arrived with the lure of assembling applications quickly
    out of prefabricated components, supposedly enabling plug-and-play solutions.
    It's still up for debate how much of a success this has been. Not all components
    are designed for reuse (it's hard work), and it's not always easy to find a component
    that does what you want it to do. It's easiest for UIs, where popular frameworks
    and established marketplaces exist.
  prefs: []
  type: TYPE_NORMAL
- en: The core of a component-based architecture is a communication infrastructure,
    or *middleware*, which allows components to be plugged in, to broadcast their
    existence, and to advertise the services they provide. Components are used by
    looking up this information through a middleware mechanism, rather than by hardwiring
    a direct connection between two components. Common middleware platforms include
    CORBA, JavaBeans, and COM; each have different strengths and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: A component^([[1](#ftn.CHP-14-FN-1)]) is essentially an implementation unit.
    It honors one (maybe more) specific published IDL interfaces. This interface is
    how clients of the component interact with it. There are no back doors. The client
    is concerned with dealing with an instance of that interface, rather than in how
    the component is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Each component is an individual, independent piece of code. Behind its interface,
    it implements some logic (perhaps business logic or user interface activity) and
    contains some data, which may just be local or may be published (say a filestore
    or database component). Components don't need to know much about one another.
    If they *are* tightly coupled, then the architecture is just an obfuscated monolithic
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based architectures can be deployed in a networked environment with
    components on different machines, but they can just as easily exist as a single
    machine installation. This may depend on the type of middleware in use.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of developing a new architecture for a specific project, it may be appropriate
    to use an existing *application framework* and add development into that skeleton.
    A framework is an extensible library of code (usually a set of co-operating classes)
    that forms a reusable design solution for a particular problem domain. Most of
    the work in a framework has been done for you, with the remaining pieces following
    a fill-in-the-blanks approach. Different frameworks follow different architectural
    models; by using a framework, you commit to its particular style.
  prefs: []
  type: TYPE_NORMAL
- en: '![Frameworks](tagoreillycom20080909nostarchimages207502.png)'
  prefs: []
  type: TYPE_IMG
- en: Frameworks differ from traditional libraries in the way they interact with your
    code. When using a library, you make explicit calls into the library components
    under your own thread of control. A framework turns this around; it is responsible
    for the structure and flow of control. It calls into your supplied code as and
    when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Sitting alongside off-the-shelf frameworks are architectural *design patterns*.
    While not an architectural style in their own right, patterns are small-scale
    architectural templates. They are micro-architectures for a few collaborating
    components, distilling a recurring structure of communication. Architectural patterns
    describe common component structures at the architectural design level, explaining
    how they fulfill the requirements of a given context. Patterns are a set of design
    best practices, described in the ubiquitous GoF book (Gamma et al. 94) and numerous
    subsequent publications (see "[DESIGN PATTERNS](ch13s05.html#design_patterns "DESIGN
    PATTERNS")" on page 255).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-14-FN-1)]) We've already talked about components as modules, ephemeral
    implementation units. But this is a new definition for the word, quite specific
    to the world of component-based architecture. Sadly, the terms are overloaded
    with multiple meanings.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Roman architect Vitruvius made a timeless statement of what constitutes
    good architectural design: strength (*firmitas*), utility (*utilitas*), and beauty
    (*venustas*). (Vitruvius) This holds true forour software architectures. Without
    a well-defined, well-communicated architecture, a software project will lack a
    cohesive internal structure. It will become brittle, unstable, and ugly. Eventually,
    it will reach a breaking point.'
  prefs: []
  type: TYPE_NORMAL
- en: All this talk of pasta has made me hungry. I'm off to build a seven-layer reference
    trifle. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Understand their software architecture and write new code within it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can apply the appropriate architecture to each design scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create simple architectures that are beautiful and elegant—they appreciate the
    aesthetics of software design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture the system architecture in a live document that is continuously updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relay problems with the structure back to the system architects in an attempt
    to improve the design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Write code regardless of any overall architectural vision—resultingin unsympathetic
    blemishes and unintegrated components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fail to perform any high-level design before ploughing into code, ignoring any
    architectural alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave architectural information locked inaccessibly in people's heads or in
    a dangerously out-of-date specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put up with inadequate architectures, adding more badly designed code rather
    than fixing the underlying problems—they can't be bothered to open a larger canof
    worms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![In a Nutshell](tagoreillycom20080909nostarchimages207504.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  prefs: []
  type: TYPE_NORMAL
- en: Security concerns must be addressed by a system architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  prefs: []
  type: TYPE_NORMAL
- en: Code *design* is the subsequent level of code construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15](ch15.html "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture is the start of your software's life, but it is by no means the
    only thing that steers its development.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  prefs: []
  type: TYPE_NORMAL
- en: Where architectural design fits into the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 522.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define where *architecture* ends and *software design* begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what ways can a bad architecture affect a system? Are there parts thatwouldn't
    be affected by architectural flaws?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How easy is it to repair architectural deficiencies once they become apparent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To what extent does architecture affect the following things?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System configuration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What experience or qualifications are required to be called a *software architect*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should sales strategy influence architecture? If so, how? If not, why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you architect for *extensibility*? How wouldyou architect for *performance*?
    How do these design goals affect the system, and how do they complement one another?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How diverse is the range of architectural styles to which you are accustomed?
    What do you have the most experience with—how does it affect the software you
    write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What personal experience do you have of architectures that succeeded or failed?
    What made them winning solutions or a hindrances?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get every developer on your current project to draw a picture of the system
    architecture—individually (without talking to anyone) and without any reference
    to system documentation or the code. Compare the pictures. See what strikes you
    about each developer's efforts—aside from the relative artistic merit!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you have an architectural description that's commonly available for your
    current project? How up to date is it? Which kinds of view are you using? If you
    needed to explain the system to a newcomer or a potential customer, what would
    you really need to have documented?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does your system's architecture compare to the architecture of your competitors
    in the marketplace? How has your architecture been defined to determine your project's
    success?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*How Does Code Grow?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I cannot say whether things will get better if we change; what I can say is
    they must change if they are to get better.
  prefs: []
  type: TYPE_NORMAL
- en: --G.C. Lichtenberg
  prefs: []
  type: TYPE_NORMAL
- en: 'If only software grew like a plant. You''d put the seed of an idea into some
    fertile programming soil, add a little water, and wait. You''d tend it carefully:
    Fertilize it, keep it in good light, and cover it to keep the birds off. In time,
    a code seedling would sprout, and when the program plant was big enough, you could
    release it to the world. For extra functionality you''d keep watering and add
    some more fertilizer, and it would continue to develop. The trunk would strengthen
    in order to support the new branches and the program would stay in perfect balance.
    If it grew in a direction you didn''t like, a little pruning would soon set it
    straight.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the Real World does not work like this. Not by a long shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software *is* a live entity. It''s not sentient or organic, but it has its
    own kind of life: It is conceived, develops steadily, and eventually reaches maturity.
    Then it''s sent out into the Big Wide World to make a living and hopefully garner
    respect and admiration. It may continue to develop, perhaps to the point where
    it gains a middle age spread and loses its youthful looks. Over time, it grows
    tired and old and is eventually retired, put out to pasture in a digital farmyard
    where it can gracefully die.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter looks at how we cultivate software, especially after the initial
    round of development. Programs require thoughtful tending and seldom receive the
    care and attention they really deserve. What can we do to prevent a slowly spreading
    code cancer that leads to early death?
  prefs: []
  type: TYPE_NORMAL
- en: To answer this, we'll work backward. We'll take a look at the symptoms of bad
    code growth, explore how we grow our code, and determine some strategies to develop
    healthier software.
  prefs: []
  type: TYPE_NORMAL
- en: '**MORE METAPHORS FOR SOFTWARE CONSTRUCTION**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already examined the metaphor of *building* and discussed what it tells
    us about the software construction process (see "[DO WE REALLY BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question
    "DO WE REALLY BUILD SOFTWARE?")" on page 177 ). In this chapter, I''ll introduce
    some more metaphors. They provide different insights into our programming methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Growing software**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This relates to how we extend existing software, usually by adding new features.
    Bug fixing isn''t growth: It is tending to diseased parts of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code does grow as we add to it, but programming is not a perfect analog
    of plant growth—we have far more control and influence over code growth than over
    a seedling. Code grows more like an oyster making a pearl: slowly, by the progressive
    accretion of small extra parts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Evolving software**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common construction metaphor is the *evolution* of software. We start
    with a single-celled code organism and gradually see it develop into a larger,
    more complex beast. This is an incremental process; the software develops through
    a number of evolutionary stages. However, there are a few key differences to biological
    evolution:'
  prefs: []
  type: TYPE_NORMAL
- en: We are the ones deliberately making changes; the software doesn't develop by
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't employ *natural selection* to choose the best design. We have neither
    the time nor the inclination to develop many different variants of the same program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do have the opportunity to iteratively improve the quality of our code, mimicing
    evolutionary development somewhat. We can use experience gained from previous
    releases to adapt the code to its natural habitat, ensuring its longterm survival.
  prefs: []
  type: TYPE_NORMAL
- en: Software Rot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're green, you're growing. When you're ripe, you rot.
  prefs: []
  type: TYPE_NORMAL
- en: --Ray Kroc
  prefs: []
  type: TYPE_NORMAL
- en: Bad things happen to good code. No matter how well you start, no matter how
    honorable your intentions, no matter how pure your design and how clean the first
    release's implementation, time will warp and twist your masterpiece. Never underestimate
    the ability of code to acquire warts and blemishes during its life.
  prefs: []
  type: TYPE_NORMAL
- en: There is a misconception that software only develops during its initial stages
    of life. The *maintenance* phase of software development^([[1](#ftn.CHP-15-FN-1)])
    is always the longest. It's where most of the overall effort goes—even if this
    effort is not scrunched into a compact ball, like the initial design and development
    work. B.W. Boehm, a respected computer science professor, observed that 40 to
    80 percent of total development time is spent in maintenance. (Boehm 76)
  prefs: []
  type: TYPE_NORMAL
- en: 'Software is never expected to stand still after a release. There will always
    be odd faults to fix, no matter how much testing went on. Customers demand new
    features. Requirements change under the development team''s feet. Assumptions
    that were made during development prove to be incorrect in the Real World and
    require adjustments. The upshot: More code is written *after* the project is considered
    complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'During the initial development stages, you can keep a firm grip on your code
    and play with it as much as you like within the available time constraints. After
    it has been released, you''re more restricted. These restrictions may be practical:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes have to be minimized to reduce their impact on the carefully tested
    codebase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Published APIs are already being used by clients, so they are harder to modify.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI is familiar to users and can't be changed gratuitously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The restrictions may also be psychological, based on the developers'' (potentially
    erroneous) preconceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The code has always worked *this* way, so we can't change it like *that*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's too hard to revise the architecture at this late stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not worth the time or expense to make this modification properly now; the
    product won't be around for very much longer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The restriction might even be a simple lack of understanding—a maintenance programmer
    may not understand original author's mental model of the code; this leads to inappropriate
    modifications.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fine line between maintaining an existing product and developing
    the next version. Where it lies is a moot point. But whatever you're doing, the
    original codebase gets modified—sometimes by the original author, often by someone
    else. This is where the rot sets in. It's a *damned if you do, damned if you don't*
    scenario; whatever you do, the code will rot.
  prefs: []
  type: TYPE_NORMAL
- en: If you never touch the code again, if you don't keep it up to date with fixes
    and modifications, the program will degrade. In the worse case, it will stop working
    as the OS changes or its assumptions become outdated. The Y2K bug is a glorious
    example of this.^([[2](#ftn.CHP-15-FN-2)]) Or the program will putrefy as competing
    solutions develop more features and gain more popularity. Untouched code slowly
    rots away.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do make extensions and fixes as the code grows, it might still rot.
    When fixing a fault, the programmer often introduces more faults as a side effect.
    Brooks found that as many as 40 percent of fixes introduced new faults. (Brooks
    95) "The Programmer''s Drinking Song" (sung to the tune of "99 Bottles of Beer
    on the Wall"), written by a minstrel unknown, sums this up neatly:'
  prefs: []
  type: TYPE_NORMAL
- en: 99 little bugs in the code, 99 bugs in the code,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fix one bug, compile it again, 101 little bugs in the code.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Repeat until BUGS == 0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even bug-free modifications can cause code turmoil. Quick-and-dirty fixes pile
    atop one another, putting nail after nail into the original design''s coffin,
    making future maintenance harder. The plant analogy is useful here: If more heavy
    branches grow at the top and nothing is reinforcing the trunk, the entire codebase
    becomes less stable. Eventually, and inevitably, it totters over. Healthy plants
    don''t grow like that; why should we expect our code to?'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be aware of how easily code degrades as it is modified. Don''t be satisfied
    with changes that leave the system in a worse state*.'
  prefs: []
  type: TYPE_NORMAL
- en: Does all this sound unduly pessimistic? Surely code won't rot if you're careful?
    Perhaps, but adequate care is not taken in today's software factories. It's a
    culture thing. Fixes must be quick and cheap. Programs have a habit of hanging
    around longer than they were ever intended to. Many quick hacks live on, well
    past their expected lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-15-FN-1)]) That is, work done after initial delivery that isn't
    considered a major new release.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-15-FN-2)]) Many old programs were never expected to be operational
    in the year 2000, so programmers considered it safe to encode years in two digits—`76`
    rather than `1976`. As the digits rolled over to `00`, all their date calculations
    went awry.
  prefs: []
  type: TYPE_NORMAL
- en: The Warning Signs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Switch on your code radar, and constantly look out for rotten code. Beware
    of the telltale signs: Rot sets in with any change that leads to a lack of clarity
    or that makes the system more complex. Unnecessary complexity comes in many guises.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some, the flashing red lights and Klaxon calls:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is littered with many large classes and convoluted functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function names are cryptic or misleading. Functions have suprising side effects
    not implied by their names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no structure: It''s not clear where to look for a certain bit of functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is duplication: Many separate bits of code crop up to do the same thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is high coupling: Complex module interconnections and dependencies mean
    that a small change in one place ripples out across the entire code, even into
    seemingly unrelated modules. (See "[Modularity](ch13s04.html#modularity "Modularity")"
    on page 247).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As data flows through the system it is repeatedly converted between different
    representations (e.g., display data is transferred between `std::string`, `char*`,
    Unicode, UTF-8, and back again).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs become blurred; once neat interfaces are now far too broad in scope, with
    new features being thoughtlessly added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs change rapidly between code revisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bits of private implementation leak out of public APIs to enable other quick
    hacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is littered with work-arounds: fixes for symptoms but not for causes.
    They hide the real problems. The edges of the system are cluttered with these,
    leaving faults lurking at the core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are functions with enormous parameter lists. Many don't use these parameters,
    passing them through to subordinate function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You find code that's too scary to even think about improving. You have no idea
    if you'll improve it, break it subtly, or make it even worse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features are added with no supporting documentation; the existing documents
    are out of date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code compiles noisily, with many warnings generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You find comments saying, *Don't touch this*. . . .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these forms of rot are particularly visible in the code and can be seen
    with a quick inspection or using certain tools. However, there is a class of more
    subtle, invisible degradations that usually manifest at a higher level than syntactic
    gunk. Modifications that fudge the original code architecture or that subtly circumvent
    program conventions are much harder to spot until you're deeply immersed immersed
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learn to detect putrid code. Know the warning signs and handle rotten code
    with the utmost care*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we make such a big mess of code? The answer is simple: *complexity*.
    A program is a huge collection of information organized on many levels: the architecture,
    its component design, the interfaces, the implementation of each bit of code,
    and so on. That''s a lot to understand before you start work on a project. With
    tight deadlines, there isn''t enough time to work out how a few lines actually
    work, let alone how they fit into the overall picture. We haven''t yet learned
    to manage this vast complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: How Does Code Grow?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No code development ever follows the classic model of lock down all requirements,
    design completely, code completely, integrate, test, release. Unexpected modifications
    happen to an existing codebase. New pieces are grafted in somehow. It's an incremental
    development cycle toward ever shifting goalposts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code growth happens by one of the following mechanisms, loosely ranked in order
    of disgust:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Luck**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the most frightening way to make code, and far too common. Code that
    grows by luck never had any design. It was modified without thought. Its structure
    is down to happenstance, and it's a miracle it works at all.
  prefs: []
  type: TYPE_NORMAL
- en: Even if your code originally *was* designed carefully, maintenance modifications
    can follow this happy-go-lucky approach. Hit-and-hope fixes may just mask the
    immediate problem and make the real fix harder later on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accretion**'
  prefs: []
  type: TYPE_NORMAL
- en: We need to add a new feature. Doing it properly would involve ripping up the
    interfaces between a few key modules and revising a lot of code. There's no time
    to do all this and, even if we did, it would probably still be too complicated.
    We'll just graft on another clump of code. It'll hang off one of the existing
    modules—well, perhaps a few of them—and use its own special back door interface
    to talk to them. We'll have something working really quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, it's a monstrous kludge. Oh, and the performance will be awful. And the
    modules will no longer have clear roles and responsibilities. There won't be a
    neat design anymore, and maintaining it in the future will be a nightmare. But
    we'll get this version out quickly, and we don't have any time to do it the right
    way now, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe we'll come back later and do it properly. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**Rewrite**'
  prefs: []
  type: TYPE_NORMAL
- en: When you recognize that the code you're working on is truly awful—unintelligible,
    fragile, and inextensible—it needs a rewrite. Based on prior experience, a rewrite
    is often quicker and safer than hacking at the original mess. However, rewrites
    are rarely done. It takes courage and vision.
  prefs: []
  type: TYPE_NORMAL
- en: Rewrites get riskier as you attack more code at once. Rewriting a whole product
    is a different prospect from rewriting a troublesome function or class. Good modularity
    and separation of concerns means that you needn't rewrite the whole system, just
    the module you're working on, keeping its original interface. If the interface
    is terrible, or you need to rewrite because the system isn't actually modular
    enough, then a lot more work is involved.
  prefs: []
  type: TYPE_NORMAL
- en: '**DOUBLING UP**'
  prefs: []
  type: TYPE_NORMAL
- en: The software had reached a major crossroad. There wasn't much future in the
    existing codebase—it really needed to be rewritten. Finally the management accepted
    this fact, and a plan was formed. The developers were split into two teams. Some
    continued to hack away at the existing codebase to try and limp it along for just
    a bit longer. The rest of the programmers got to start the entire application
    again from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'One task was glamorous: devising a sleek new design with interesting implementation
    challenges and the chance to work on a fresh, cruft-free codebase. The other task
    was menial: patching up holes in a sinking ship until the new cruise liner was
    ready (at which time all the old work would be left for scrap). Which team would
    you rather have been on?'
  prefs: []
  type: TYPE_NORMAL
- en: Not surprisingly, this led to a build up of resentment and frustration and a
    rivalry between the teams. Many programmers relegated to the old application asked
    to change projects or left the company to seek greener pastures. The work on the
    old codebase was second rate, as it was the second-rate project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactor**'
  prefs: []
  type: TYPE_NORMAL
- en: A formalized cousin of rewrite. If your code is mostly okay, but bits of it
    need some work, you can *refactor* these unpleasant parts. Refactoring is a process
    of making small changes to a body of code in order to improve its internal structure
    without changing its external behavior. It improves the design so that you can
    work with it more easily in the future. It's not about performance improvement,
    just design enhancement. Not as drastic as a complete rewrite, refactoring is
    a series of gentle massages of what you already have.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fancy name for particular kinds of code modification. Martin Fowler
    has formalized it, documenting a number of small, understandable code refinements.
    (Fowler 99)
  prefs: []
  type: TYPE_NORMAL
- en: '**Design for growth**'
  prefs: []
  type: TYPE_NORMAL
- en: You'll often have an idea how your code will expand in the future; perhaps some
    features have been deferred until the next release. You can carefully design the
    system so that it's easy to make these future additions. Most of the time, this
    won't make the design work much harder.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don't know the set of future additions, careful design affords room
    for growth. An extensible system provides hinge points for new functionality to
    be plugged in. Be careful that this isn't an exercise in chasing the wind, though,^([[3](#ftn.CHP-15-FN-3)])
    trying to guess the future when you don't have a clue how the system will expand.
    Extensibility comes at the cost of complexity. If you correctly guess where this
    complexity is needed, you win; if you guess incorrectly, then you'll make an unnecessarily
    complicated system. This is the danger of *over-design*, and it's especially likely
    when design occurs by committee.
  prefs: []
  type: TYPE_NORMAL
- en: There is a school of thought, exemplified in Extreme Programming, that insists
    on the absolute simplest design that can possibly work in any given situation.
    This could be at odds with the design for growth mentality (depending on how malleable
    the initial simple design is). Exactly how much design for growth you should employ
    can be a hard—but important—balance to strike.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAOS THEORY**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code is obviously shaped by design, but the organization that built it and
    its life history also play a large role. Years ago, I joined a project with particularly
    disgusting user interface code. It worked (usually), but was unfathomable, an
    intense lump of intertwining logic with no discernible architecture and labyrinthine
    paths of execution. And it was like that for a reason: history.'
  prefs: []
  type: TYPE_NORMAL
- en: The code was initially created as a simple one-off television UI for a single
    customer, with minimal specifications. Successfully built, it served its purpose
    well. Sadly, the story didn't end there.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was then sold to a second customer, who wanted it to look different. A second
    skin (visual appearance) was hacked on. Then it was sold to another customer in
    a different country. Internationalization was bolted on, with another skin. Then
    it was sold to a third customer, who wanted some new UI facilities—these were
    shoehorned in. This story continued. For a long time. Today the UI is unrecognizable
    from its former self, and it''s now also unmaintainable: Each addition has been
    a quick hack since the whole thing was always a temporary system.'
  prefs: []
  type: TYPE_NORMAL
- en: If the initial design had incorporated all these features, then the code would
    still be lean and logical. However, it would have been far too much work up front,
    and the company would never have started the project. Pity the poor programmers
    that work under these Real World conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-15-FN-3)]) Ecclesiastes 2:11
  prefs: []
  type: TYPE_NORMAL
- en: Believe the Impossible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the reason we see so much bad code and so many dirty hacks is the mistaken
    belief that it takes longer to do the job properly. When you factor in the time
    spent debugging and the ease of making later modifications, this proves to be
    a false assumption. You may be able to close a single fault report quickly by
    hacking out a fix, but it's not a good solution. True craftsmen take responsibility
    for what they do to code.
  prefs: []
  type: TYPE_NORMAL
- en: In the corporate world, there is often a management expectation of quick fixes.
    It's reasonably easy to show a manager that a five-ton block of concrete stuck
    on top of a flimsily erected flagpole won't stay up for verylong. It's harder
    to make him stand underneath the thing. And it's *much* harder to get the same
    message across when we're talking about software. Managers just don't get it.
    As far as they're concerned, programmers are magicians who practice dark mystical
    arts and have limitless powers. Tell them what to do, provide a deadline, and
    it will happen, however many all-night coding sessions are required.
  prefs: []
  type: TYPE_NORMAL
- en: Being gifted and dedicated, sometimes we meet these expectations. This actually
    makes matters worse, as management now expects that this tactic will always work.
    Worse, they assume that it's *our* fault when it doesn't. Sadly, there comes a
    time when hastily hacked software just cannot be made to expand any more, when
    it really just wants to keel over and find its final resting place in a quiet
    corner somewhere. Management will not be happy.^([[4](#ftn.CHP-15-FN-4)])
  prefs: []
  type: TYPE_NORMAL
- en: Code growth is easier if the company's culture is to develop software in small
    incremental steps (see "Iterative" on page 245 and "[Iterative and Incremental
    Development](ch22s03.html#iterative_and_incremental_development "Iterative and
    Incremental Development")" on page 432). This way, evolution is built into the
    design strategy, and rewriting code to accommodate change is expected. The alternative,
    when you have to attack a monolithic code edifice with a small pickaxe in 20 seconds
    flat, is unreasonable—but not unusual.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-15-FN-4)]) Of course this is a gross generalization, but not too
    inaccurate. Many managers used to be programmers themselves and understand the
    tensions. A good manager listens to the programmers' objections. A good programmer
    will make his or her boss listen. Too often, neither happens, and the software
    suffers.
  prefs: []
  type: TYPE_NORMAL
- en: What Can We Do About This?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: God grant me the serenity to accept the things I cannot change, the courage
    to change the things I can, and the wisdom to know the difference.
  prefs: []
  type: TYPE_NORMAL
- en: --Reinhold Niebuhr
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've identified some of the problems of an evolving codebase, how
    do we manage the mess? What strategies can we adopt to avoid this?
  prefs: []
  type: TYPE_NORMAL
- en: The first and most important step is to recognize the problem. Too many programmers
    hack away without thinking about the quality of their code. As long as they silence
    the users' screams in the shortest time possible, they don't care what state they
    leave the code in. Someone else can deal with it next time.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code conscientiously. Good programmers care more about how their code will
    look after a few years'' work than how much effort it takes to write now*.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing New Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we think about how to work with *legacy* (existing) code, here are a
    few tactics for creating brand-new code that will greatly aid later maintenance:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the interconnection of modules, and reduce coupling as much as possible.
    Avoid having one central module that every other module depends on; a change there
    will affect every other module in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularity and information hiding (see page "[Modularity](ch13s04.html#modularity
    "Modularity")" on page 247) are the cornerstones of modern software engineering.
    Isolate any likely changes to a small part of the system, making your system more
    viscous and therefore stable under change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension and malleability need to be designed in—but, as we've seen, not at
    the expense of complexity. Modern component/object based paradigms promise greater
    reuse and extensibility. They give clear interface points between code modules.
    However, if the interfaces don't support later extension, then the code can't
    grow. Think very carefully about your system interfaces as you create them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write neat, clear code that can easily be understood and worked with, accompanied
    by good documentation and well-defined, clearly named APIs. Consider literate
    programming tools to document interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*KISS*. That is, *Keep It Simple, Stupid*. Don''t over-complicate; don''t over-engineer.
    Optimize an algorithm only when you *know* that there are performance issues,
    not just because you think you know a good way to make code run faster. Simplicity
    is nearly always more desirable than performance, and it certainly makes later
    maintenance easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write new code with a view to its modifiability. Make it readable, extensible,
    and simple*.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance of Existing Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maintaining *good* code requires a different battle plan than maintaining *bad*
    code. With the former, you must carefully preserve the integrity of the design
    and ensure that you don't introduce anything out of place. With the latter, you
    must try to not make the mess any worse and, if possible, improve things on your
    way through. If you can't rewrite the offending code, a little refactoring will
    go a long way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you touch any code, these organizational issues should be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Prioritize* any changes that are needed. Balance the importance of each task
    against its complexity, and decide which should be done first. What early changes
    will have an impact on later work?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only change what's necessary. *If it ain't broke, don't fix it*. Don't gratuitously
    "improve" bits of code because you think they need it—only make the changes that
    are really required. Refactor the bad code you need to work with. Give the rest
    a wide berth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor how many modifications are being made at once. Making several parallel
    modifications *yourself* is either incredibly clever or foolish; most likely the
    latter. Do one thing at a time. Carefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If several people are working on the code at once, be aware of what's changing
    around you. There is a danger of too many separate hacks causing odd conflicts.
    Methodical change by a single developer gives clearest visibility of where the
    code is being stretched and where the most care is needed. Several simultaneous
    modifications might stretch the code thin without anyone understanding or noticing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Manage changes carefully. Make sure you know who else is trying to modify
    code near where you''re working*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just as the initial code should be reviewed during its development, subsequent
    changes should also be reviewed. Organize formal reviews, and try to include the
    code's original author and reviewers. It's very easy to introduce subtle new bugs
    with small code extensions; reviews will catch many of these errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Review sensitive changes, especially in the run-up to a release. Even the
    simplest change can break other code*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once at the codeface, how do we tackle existing source? Here are practical
    suggestions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make good modifications, you must be informed about the code you''re working
    on. Before you modify a file or code module, understand:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where it sits within the whole system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What interdependencies it has (i.e., which components might be affected by your
    change)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What assumptions were made when the code was created (hopefully documented in
    the code's specifications)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The history of modifications that have already been made
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect the code's quality. This is surprisingly easy to do, and rapidly gives
    you a sense of how easy the code is going to be to work with. You may find it
    helpful to use tools that visualize the code and generate quality metrics; this
    will highlight where hidden gotchas could be lurking. Collate all relevant documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adopt the correct attitude—avoid the *just one more hack* mentality. Don't dismiss
    code, thinking that it will be thrown away or rewritten in the future. It won't
    be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be constantly aware of the warning signs cataloged in "[The Warning Signs](ch15s02.html
    "The Warning Signs")" on page 282\. If your modification moves the codebase nearer
    to one of those states, refactor the code to alleviate the problem. Take responsibility
    for these problems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Be prepared to do some redesign work. Don''t be afraid to unpick the code and
    perform major surgery when necessary. Sometimes a modification will be costly
    right now (in terms of your time and effort), but the investment will pay off
    later: Future work with the code will be much, much easier. For legacy code, this
    may be considered uneconomical. Sadly, it''s legacy code that makes cash and is
    unlikely to be phased out. If you know that you''ll be working on a section of
    code a lot in the future, make sure that the code structure will support future
    extension.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Don''t mindlessly fiddle with code. Step back and look at what you''re doing*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try not to introduce extra dependencies with newly added code. An increase in
    coupling makes code more complicated and harder to change next time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When maintaining any code, retain the programming style of the source files
    you are working with, even if it's not your favorite style or the house style.
    A file with code in several formats is confusing and hard to work with. Apply
    presentation tidy-ups as you go if they're not too gratuitous, but be aware that
    source code diffs across versions will be harder if you do so. Maintain the comments
    around the code you're working on (see "[Maintenance and the Inane Comment](ch05s07.html#maintenance_and_the_inane_comment
    "Maintenance and the Inane Comment")" on page 86).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the code's test suite to check that you don't break anything. Exhaustive
    regression testing is the only real way to have confidence in the changes you've
    made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you have an adequate test suite, and run it regularly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Carefully test any modification you make, no matter how simple. It''s really
    easy for silly faults to slip past unnoticed*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are fixing a fault, do you really understand the cause? Write a test
    harness to trigger it; this demonstrates your understanding and will prove that
    you have made the fix. Add it to the suite of regression tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have made a successful fix, look around the codebase for similar faults.
    This overlooked step can make a big difference: Many problems hang around in packs,
    and it''s much easier to defeat them in one crushing blow than to slowly chip
    away as they each individually manifest.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you make a bad change, back it out quickly. Don't litter code with unnecessary
    dead wood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a code craftsman, you should always shy away from the pressure to do a quick
    bodge job. Strive to make careful, considered changes. Unfortunately, we don't
    work in ivory towers, and compromise is sometimes required on the battle front;
    it's not always commercially feasible to complete a task in the theologically
    correct way.
  prefs: []
  type: TYPE_NORMAL
- en: This explains why so much code is brittle, flaky, and dangerous. But it also
    explains why there's any code out there at all. If there wasn't the commercial
    drive to get software shipped, programmers would spend forever tweaking their
    software to get it just right, writing and rewriting. The company would have collapsed
    around them long before they'd finished.
  prefs: []
  type: TYPE_NORMAL
- en: However, don't introduce pragmatic (but distasteful) modifications without a
    plan to fix them at a later date. Place a tidy-up task on the development schedule.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Change in all things is sweet.
  prefs: []
  type: TYPE_NORMAL
- en: --Aristotle
  prefs: []
  type: TYPE_NORMAL
- en: I'm not sure that I agree with Aristotle. Change can be a real pain in the rear
    end. We should manage code changes carefully. Then a good program will evolve
    into something greater, rather than degrade into an unstable mess.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to maintain software well and expand it correctly, preserving
    the code design and making sympathetic modifications. Don't expect maintenance
    to be easy. You may need to invest a lot of time to rewrite, redesign, or refactor.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 17](ch17.html "Chapter 17. TOGETHER WE STAND")'
  prefs: []
  type: TYPE_NORMAL
- en: We build and maintain software as a team. Team dynamics inevitably affect the
    final shape of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  prefs: []
  type: TYPE_NORMAL
- en: A history of your code's development is recorded in the *revision control system*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The software development lifecycle: the procedures we follow to create and
    grow software.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Write maintainable software with clean structure and logical layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize and are prepared to deal with bade code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to understand as much of the code and the author's original mental model
    as possible, prior to working on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Care about the quality of code they're working on; they refuse to clumsily patch
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Create complex code without thinking about the needs of maintenance programmers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Avoid* maintaining old code, preferring to ignore problems rather than fix
    them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Favor an easy patch over thinking about a good solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Litter code with quick and dirty hacks; they employ every shortcut they can
    find
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus attention in the wrong places, tinkering with code that didn't actually
    need to be fixed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207506.png)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 527.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the best metaphor for software growth?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Looking at a program''s development through the colorful lifetime metaphor
    I talked about in the introduction, what Real World events correspond to a program''s:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conception
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Birth
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Growth
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming of age
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending out into the Big Wide World
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Middle age
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Growing tired
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retirement
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Death
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a limit to software life—how long can you keep developing and working
    on a program before you have to start afresh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the size of a codebase correspond to the maturity of the project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How important is *backward compatibility* when maintaining code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is code likely to rot more quickly if you alter it or if you leave it alone?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is the majority of the code you write brand new or a modification of existing
    source?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's brand-new code, do you create entirely new systems or new extensions
    to existing systems?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Does this affect *how* you write? In what ways?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do you have experience of working with preexisting codebases? If so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How has it shaped your current skill set? What lessons did you learn?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Was it predominantly good or bad code? What did you have to judge it against?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Have you ever made changes that degraded the quality of code? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many revisions has your current project gone through?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How much changed functionally between revisions? How did the code change?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Has it grown by *luck*, by *design*, or something between the two? How is this
    evident now?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does your team safeguard code so that it can't be changed by more than one
    programmer at once?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
