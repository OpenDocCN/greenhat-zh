- en: Chapter 11. Overview of TCP/IP
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*IP version 6:*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*All the pain of version 4,*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*plus brand-new problems!*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Securing a computer
    is easy: Disconnect it from all networks, remove all input and output, and lock
    it in a bunker. Oh, wait—did you want the system to *do* something? Then you’ll
    probably want to connect your system to the Internet.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Many system administrators have a vague familiarity with the basics of networking,
    but to be a truly competent sysadmin, you need a real understanding of how everything
    fits together. You don’t need to know when to use rapid spanning trees, how to
    choose between BGP and OSPF, or even what those acronyms represent. But you must
    know what an IP address is, how a netmask works, how port numbers differ from
    protocol numbers, and why you cannot use `telnet(1)` to test UDP connectivity.
    Without this basic knowledge, you’ll fumble. Read this chapter and understand
    it, and you’ll have an easier time convincing your network administrator to give
    you what you need.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter offers an overview of TCP/IP, it doesn’t cover the innumerable
    details, caveats, annoyances, peccadilloes, and blatant outrages present in the
    protocol. If you find that you need to torture yourself with the finer points
    of TCP/IP, pick up one of the big, thick books on the subject. *The TCP/IP Guide*
    by Charles M. Kozierok (No Starch Press, 2005) is an excellent place to start.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers both TCP/IP version 4 (the Internet protocol widely used
    for the last 30-odd years) and the new version of the protocol, TCP/IP version
    6\. Despite the different version numbers, the two protocols are more similar
    than not.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the layers of the network and then delve into how the protocols
    work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Network Layers
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The network protocol is divided into several layers. Each layer handles a specific
    task and interacts only with the layers immediately above and below it. At first,
    you might laugh at the idea that this layer model simplifies the network process,
    but it really does. The important thing to remember right now is that each layer
    communicates with only the layer directly above it and the layer directly beneath
    it (theoretically, anyway).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic Open Systems Interconnection (OSI) network protocol stack represents
    the network as seven layers. It’s an exhaustively complete model and covers almost
    any situation using any network protocol and any application. Because the Internet
    is a very specific type of network, and because this isn’t a book about networking
    or networked applications in general, I’ll limit my discussion of TCP/IP to four
    specific layers of the network: physical, datalink, network, and transport. Don’t
    worry—these four layers cover the Internet and (almost) all corporate networks.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The Physical Layer
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether it’s copper or fiber-optic cable, or even radio waves, physical wire
    is a layer of the network. Without some physical media to run over, a network
    cannot function. Everything from the CAT5 cable plugged into your desktop to the
    fiber-optic cable connecting you to Asia is part of the physical layer. If it
    can be tripped over, backhoed, or interfered with, it’s part of the physical layer.
    For simplicity’s sake, I’ll refer to the physical layer as the *wire*, although
    it can take innumerable forms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: This is the easiest layer to understand. If your wire meets the requirements
    of the physical protocol, you’re in business. If not, your network won’t work.
    One of the functions of Internet routers is to connect one sort of physical layer
    to another—for example, converting local Ethernet into an OC3 fiber connection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The physical layer has no decision-making abilities of its own; everything that
    runs over it is dictated by the datalink layer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The Datalink Layer
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The datalink layer is the protocol that runs over the physical wire. It transforms
    information into the actual signals that are sent over the physical layer, using
    the appropriate encoding for that physical media, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Both Ethernet and Switched Multimegabit Data Service (SMDS) use Media Access
    Control (MAC) addresses and the Address Resolution Protocol (ARP).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 over Ethernet uses Neighbor Discovery (ND).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dial-up and wide area networks (WANs) use either the Point-to-Point Protocol
    (PPP) or High-Level Data Link Control (HDLC).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenBSD supports other common datalink protocols, such as PPP over Ethernet
    (PPPoE). If you have unusual network requirements, check the OpenBSD website,
    mailing lists, or man pages to see if those requirements are supported.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Some datalink layers have been implemented over many different physical layers.
    Ethernet, for example, has been implemented over twinax, coax, CAT3, CAT5, CAT6,
    CAT7, optical fiber, and radio waves. And for true device independence, we have
    seen TCP/IP implemented with a biological transport layer: carrier pigeon.^([[27](#ftn.id460204)])'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: With minor changes to the device drivers, the datalink layer can address any
    sort of physical layer. This is one of the ways in which layers simplify the network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. Connecting to the Network") discusses Ethernet
    in detail, as it’s the most common network type for OpenBSD systems. Once you
    understand how Ethernet works, you’ll have no difficulty adding new datalink protocols
    as needed.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The datalink layer exchanges information with the physical layer and the network
    layer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The Network Layer
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The network layer is the part that maps connectivity between network nodes,
    answering questions like “Where are other hosts?” and “Can I get there from here?”
    This logical protocol provides a consistent interface to programs that run over
    the network, no matter what the physical and datalink layers look like.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The network layer used on the Internet is the Internet Protocol, or IP. Both
    version 4 (IPv4) and version 6 (IPv6) provide each host with one or more unique
    *IP addresses*, so that any other host on the network can find it. Okay, IPv4
    network address translation munges the whole “unique address” rule, but your network
    still has a unique IP address somewhere.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The network layer talks to the datalink layer below it and the transport layer
    above it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The Transport Layer
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The transport layer is where actual data flows. The three most common transport
    layer protocols are the Internet Control Message Protocol (ICMP), Transmission
    Control Protocol (TCP), and User Datagram Protocol (UDP).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: ICMP passes basic connectivity messages between hosts with IP addresses. If
    IP provides a road and addresses, ICMP provides traffic lights and highway exit
    signs. Most of the time, ICMP runs silently in the background.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: UDP and TCP are the protocols that carry actual data between hosts, and they
    are so prevalent that the suite of Internet protocols is usually called TCP/IP.
    UDP is a bare-bones transport protocol, offering the minimum services needed to
    transfer data over the network. Its minimalism means that if you want to customize
    exactly how data flows in your application, you can build it out of valid UDP.
    TCP provides more sophisticated features, such as integrity checking and congestion
    control, but many of its settings are hard-coded.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these three, many other protocols run at the transport layer.
    The file */etc/protocols* contains a fairly comprehensive list of transport protocols
    built atop IP. While it lists many more protocols than you will ever actually
    deal with out in the wild, it doesn’t include non-IP protocols like IPX/SPX or
    Digital Equipment Company’s DECnet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s have a look at the first entry from */etc/protocols*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each */etc/protocols* entry has three key fields: an official name, a protocol
    number, and any aliases. The IP protocol, protocol 0, is known as IP and (*very*
    occasionally) as HOPOPT. Each protocol also has a comment giving it some context.
    Although some of the protocols in */etc/protocols* are long gone, some antediluvian
    devices out there might still speak them.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Note that ICMP, TCP, and UDP are slightly different when run over IPv4 versus
    IPv6\. Each protocol has clearly defined fields in the IP packet header, leaving
    specific numbers of bits for things like checksums, destination addresses, and
    so on. You can’t run a transport protocol over an incompatible network protocol—TCPv6
    over IPv4 just doesn’t work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer speaks to the network layer below and to the applications
    layer above it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications are definitely part of the network. Applications request network
    connectivity, send data over the network, receive data from the network, and process
    that data. Web browsers, email clients, JavaServer Pages (JSP) servers, and so
    on are examples of network-aware applications. Applications need to communicate
    with only the transport protocol and the user. The upper three layers of the OSI
    network model are inside applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序无疑是网络的一部分。应用程序请求网络连接，通过网络发送数据，从网络接收数据，并处理这些数据。网页浏览器、电子邮件客户端、JavaServer Pages
    (JSP) 服务器等都是网络感知应用程序的例子。应用程序只需要与传输协议和用户进行通信。OSI网络模型的顶层三层都在应用程序内部。
- en: Problems with the user layer are beyond the scope of this book, but I find that
    many of these issues can be solved with proper application of a large chainsaw.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用户层的问题超出了本书的范围，但我发现许多这些问题可以通过正确应用大型链锯来解决。
- en: The Life and Times of a Network Request
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络请求的生命周期
- en: So how do all these layers fit together in the real world? Let’s have a look
    at a hypothetical network request, and walk through how data traverses the layers
    and the network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在现实世界中，所有这些层是如何结合在一起的？让我们看看一个假设的网络请求，并逐步了解数据是如何穿越各层和网络。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of this discussion touches on topics covered later this chapter, so you
    might want to reread this section after finishing the chapter. Purists will notice
    that I skip a lot of parts of the process, but I’m trying to relay the basics
    of how TCP/IP works in practice, not model every painful detail of a real network
    transaction.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分讨论的一些内容涉及本章后面将要讨论的主题，因此您在完成本章后可能需要重新阅读本节。纯粹主义者会注意到我跳过了许多过程的部分，但我试图传达TCP/IP在实际中是如何工作的基本原理，而不是详细描述真实网络事务的每一个痛苦细节。
- en: Suppose a user connected to your network wants to look at a very important work-related
    website, such as Scott Meyer’s Basic Instructions (*[http://www.basicinstructions.net/](http://www.basicinstructions.net/)*).
    The user opens his browser, enters the URL, and presses ENTER. The browser application
    transforms the user’s request into the proper format and asks the transport layer
    for a TCP connection to a particular IP address on port 80.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个连接到您网络的用户想查看一个非常重要的与工作相关的网站，例如Scott Meyer的Basic Instructions (*[http://www.basicinstructions.net/](http://www.basicinstructions.net/)*)。用户打开浏览器，输入URL，然后按回车键。浏览器应用程序将用户的请求转换成正确的格式，并请求传输层与特定IP地址的80端口建立TCP连接。
- en: The transport layer inside your computer examines the browser’s request and
    allocates the appropriate resources for it. The request is broken up into digestible
    chunks, called *segments*, and handed down to the network layer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您计算机内的传输层会检查浏览器的请求，并为它分配适当的资源。请求被分解成可消化的数据块，称为*段*，然后传递给网络层。
- en: The network layer doesn’t care about the contents of the request; it’s only
    concern is where that data is going. The network layer takes the TCP data and
    attaches the proper addressing information to it. The resulting chunk of data
    is called a *packet*. The network layer checks the packet’s destination, chooses
    the interface closest to the gateway to that destination, and drops packets down
    into the datalink layer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层并不关心请求的内容；它只关心数据去向何方。网络层将TCP数据附加适当的寻址信息。由此产生的数据块称为*数据包*。网络层检查数据包的目的地，选择离该目的地最近的接口，并将数据包下放到数据链路层。
- en: The datalink layer doesn’t care about the contents of the packet, and it certainly
    doesn’t care about IP addresses or routing. It has been given a lump of zeros
    and ones, and its job is to transmit those zeros and ones to another network node.
    The datalink layer adds the appropriate header and/or footer information to the
    packet, creating a *frame* appropriate for the physical layer. The frame’s header
    and footer contain the addressing information for the physical layer. On most
    networks, the datalink layer prepares frames for the local Ethernet. Then the
    datalink layer hands off the frame to the physical layer for transmission.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层并不关心数据包的内容，当然也不关心IP地址或路由。它被赋予了一块零和一的数据，其任务是将这些零和一传输到另一个网络节点。数据链路层向数据包添加适当的头部和/或尾部信息，创建适合物理层的*帧*。帧的头部和尾部包含物理层的寻址信息。在大多数网络中，数据链路层为本地以太网准备帧，然后将帧传递给物理层进行传输。
- en: The physical layer has no intelligence at all (think carrier pigeons). The datalink
    layer hands the physical layer a frame, and the physical layer transmits that
    frame to another physical device. For a web browsing client, this is usually the
    default router for the local Ethernet. The physical layer doesn’t care about the
    upper-level protocols. Its only job is to make sure the frame gets to the destination
    without errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层完全没有智能（想想信鸽）。数据链路层将一个帧交给物理层，物理层将这个帧传输到另一个物理设备。对于Web浏览客户端来说，这通常是本地以太网的默认路由器。物理层不关心上层协议。它的唯一任务是确保帧无错误地到达目的地。
- en: When the client computer’s router receives the frame, it sends it up to the
    datalink layer. The datalink layer strips out the frame information and hands
    the resulting packet up to the network layer. The router’s network layer examines
    the packet, looks at its routing table, and decides which interface to send it
    out on. This might be another Ethernet interface, a T1, a DS3, an OC3, or whatever
    the router uses for upstream connectivity. Once the router chooses an interface,
    it hands the packet to the datalink layer for that interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端计算机的路由器接收到帧时，它将其发送到数据链路层。数据链路层移除帧信息，并将得到的包交给网络层。路由器的网络层检查包，查看其路由表，并决定通过哪个接口发送。这可能是一个以太网接口、T1、DS3、OC3或路由器用于上行连接的任何其他接口。一旦路由器选择了一个接口，它就将包交给该接口的数据链路层。
- en: The local router’s upstream connection probably goes through a whole series
    of routers. Each router decides where to send the request based on its routing
    table. The request probably traverses a variety of datalink layers as it travels.
    Thanks to layering and abstraction, neither you nor your computer needs to know
    anything about any of them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本地路由器的上行连接可能要通过一系列路由器。每个路由器根据其路由表决定将请求发送到哪里。请求在传输过程中可能穿越各种数据链路层。多亏了分层和抽象，你或你的计算机不需要了解任何关于它们的信息。
- en: When the request reaches its destination, the computer at the other end of the
    transaction accepts the frame and sends it all the way back up the protocol stack.
    The frame is stripped down to packets, which are stripped down to segments, which
    are reassembled into a data stream. The data stream is then handed to the application
    (in this case, a web server). The application processes the request and returns
    an answer, which goes back down through the protocol stack and travels across
    the network, bouncing up and down through various datalink layers on the way as
    necessary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达目的地时，交易另一端的计算机接受该帧并将其发送回整个协议栈的上层。该帧被分解成数据包，数据包再分解成段，然后重新组装成数据流。随后，数据流被交给应用程序（在这种情况下，是一个Web服务器）。应用程序处理请求并返回一个答案，该答案沿着协议栈向下传递并通过网络传输，在必要时在各个数据链路层上下弹跳。
- en: 'This example shows why the layer model is important: Each layer knows only
    what it absolutely must about the layers above and below it, making it possible
    to swap out layers if necessary. When a new datalink protocol is created, the
    other layers don’t need to change. The network layer just hands a packet to the
    datalink layer and lets the datalink do its thing. When you install a new network
    card, you need only a driver that interfaces with the datalink layer and the physical
    layer; you don’t need to change anything higher in the network stack.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了层模型的重要性：每一层只知道它绝对必须了解的上下层的信息，这使得在必要时可以更换层。当创建一个新的数据链路协议时，其他层不需要改变。网络层只需将包交给数据链路层，并让数据链路层完成其工作。当你安装一个新的网络卡时，你只需要一个与数据链路层和物理层接口的驱动程序；你不需要更改网络栈中的任何更高层。
- en: Network Stacks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络栈
- en: A network stack is the software that lets a host communicate with the network.
    A host can run with an IPv4-only network stack, an IPv6-only network stack, or
    a dual-stacked setup.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 网络栈是允许主机与网络通信的软件。主机可以运行IPv4-only网络栈、IPv6-only网络栈或双栈配置。
- en: You’re already familiar with an IPv4-only stack—it’s what most hosts ran for
    much of the past 30 years. An IPv4-only stack can communicate only over IPv4\.
    Today, an IPv4-only stack gets you access to the entire Internet, with a few deliberate
    exceptions. That will not be true in a few years.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了IPv4-only栈——这是过去30年中大多数主机运行的方式。IPv4-only栈只能在IPv4上通信。今天，IPv4-only栈可以让你访问整个互联网，但有少数故意排除的例外。这将在几年后不再成立。
- en: Likewise, an IPv6-only stack can communicate with only IPv6 hosts. Because most
    Internet sites don’t yet support IPv6, running an IPv6-only stack isn’t practical
    at this point. It is, however, an excellent way to test your IPv6 infrastructure
    and connectivity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The most common configuration these days is a dual-stack setup. Client hosts
    try to use both IPv4 and IPv6, preferring one over the other. I recommend configuring
    hosts with dual stacks, preferring the stack with better connectivity. (If you
    get IPv6 connectivity through a tunnel, it’s not as fast as your IPv4 connectivity.)
    If you have equal IPv4 and IPv6 connectivity, use whichever you prefer. IPv6 works
    well enough that I often don’t realize that I’m using it until I analyze my traffic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to do anything special to enable IPv6 on OpenBSD—an IPv6 address,
    a default router, and a DNS server, and away you go.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 Addresses and Subnets
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *IP address* is a unique 32-bit number assigned to a specific network node.
    Some IP addresses are more or less permanent, such as those assigned to vital
    servers; others change as required, such as those used by desktop clients. Individual
    machines on a shared network use IP addresses from a range of addresses assigned
    to that network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Rather than expressing that 32-bit address as a single number, an IP address
    is divided into four 8-bit numbers, usually expressed as decimals. While 192.0.2.1
    and 11000000.00000000.00000010.00000001 represent the same address, the first
    option is easier for our feeble little brains to grasp.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Internet service providers (ISPs) issue IP addresses in blocks. These blocks
    are the smallest allocation that they can get away with giving you—say, 16 or
    32 addresses. If your system is on a server farm, you might get only a few IP
    addresses out of a block of 256.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: A *netmask* indicates the size of the block of IP addresses assigned to your
    local network. The size of your IP block determines your netmask—or, your netmask
    determines how many IP addresses the network has.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: ISPs issue IP addresses by prefix length, commonly called a *slash*. You’ll
    see IP address blocks described in forms like 192.0.2.128/26\. Everyone who has
    worked with networking has seen the netmask 255.255.255.0, and most know that
    it’s associated with a block of 256 IP addresses. That netmask is also called
    a /24\. The number after the slash is the number of fixed bits in the netmask.
    Remember, an IPv4 address is a 32-bit number; on a /24 network, 24 of those bits
    will never change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a textbook on binary math, so I won’t quiz you on the conversions,
    but think of an IP address as a string of 32 binary digits. On your networks,
    you can change the bits on the far right, but not the bits on the far left. But
    where is the line that separates right from left?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Netmasks have traditionally been split on 8-bit boundaries, but there’s no
    hard rule that says they must be. A /25 network has 25 fixed bits—one more fixed
    bit than what used to be called a class C network—leaving you with 7 bits to play
    with. The netmask’s fixed bits are set to 1, and your network bits are set to
    0, as in the following example of a /25 netmask:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first three blocks are set to the binary 11111111, which is 255 in decimal.
    The last block is set to 1000000, which is 128\. Mash these together, and your
    resulting netmask is 255.255.255.128.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: If you reduce netmasks to binary, they’re simple to figure out. While you won’t
    need to work with this every day, if you don’t understand the underlying concepts,
    the decimal conversion looks like total gibberish. With a little practice, you’ll
    recognize certain decimal strings as legitimate netmasks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: So now that you know how netmasks work, what the heck does all this mean in
    the real world?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses are issued in multiples of 2\. If you have 4 bits to play with,
    you have 16 addresses (2⁴=16). If you have 8 bits to play with, you have 256 addresses
    (2⁸=256). If someone says that you have exactly 17 IP addresses, you’re either
    sharing a network with other people or they’re wrong.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to see a host’s IP with the netmask attached, such as 192.0.2.130/26\.
    This gives you everything you need to attach the host to the local network. (Finding
    the default gateway is a separate issue, but it’s usually the top or bottom address
    in the block.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a Decimal IPv4 Netmask
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting from binary to decimal to binary is error-prone and mildly annoying.
    Here’s how to calculate your netmask while remaining in decimal land.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Find how many IP addresses you have on your network. This will be a multiple
    of 2, almost certainly smaller than 256\. Subtract the number of IP addresses
    you have from 256\. This is the last number of your netmask. You still need to
    recognize legitimate network sizes, however. If your IP address is 192.0.2.251/26,
    you’ll need to know that a /26 is 26 fixed bits, or 64 IP addresses. Your netmask
    is 255.255.255.192 (256–64=192).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: And I should also mention that netmasks occasionally appear in hexadecimal.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you travel to my house to bludgeon me repeatedly with this book, [Table 11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions
    "Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions") shows netmasks,
    IP information, and related information for /24 and smaller networks.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '| Prefix | Binary Mask End | Decimal Mask | Hex Mask | Available IPs |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| /24 | 00000000 | 255.255.255.0 | 0xffffff00 | 256 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| /25 | 10000000 | 255.255.255.128 | 0xffffff80 | 128 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| /26 | 11000000 | 255.255.255.192 | 0xffffffc0 | 64 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| /27 | 11100000 | 255.255.255.224 | 0xffffffe0 | 32 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| /28 | 11110000 | 255.255.255.240 | 0xfffffff0 | 16 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| /29 | 11111000 | 255.255.255.248 | 0xfffffff8 | 8 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| /30 | 11111100 | 255.255.255.252 | 0xfffffffc | 4 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| /31 | 11111110 | 255.255.255.254 | 0xfffffffe | 2 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: 'When you don’t feel like doing the math, you can refer to [Table 11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions
    "Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions") or install
    the `ipcalc` package for quick netmask calculations. Don’t say I never take pity
    on my readers.^([[28](#ftn.id433870)])'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Viewing IPv4 Addresses
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Display IP addresses with `ifconfig(8)`. If you run `ifconfig` without any arguments,
    it displays all interfaces on the machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The lines starting with `inet` are IPv6 addresses. This interface has the primary
    IPv4 address of 192.0.2.226 and a secondary, or *alias*, address of 192.0.2.231\.
    You can also see the netmask of each of these addresses and the broadcast address
    for the subnet.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Unusable IPv4 Addresses
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every block of IPv4 addresses reserves the first and last IP addresses for
    use by the network:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The first IP address in a block is the *network address*, used for separating
    networks (and on primordial BSD systems, the broadcast address). On a /24 network,
    this would be an address ending in .0.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last IP address in the block is the *broadcast address*. On a /24 network,
    the broadcast address ends in .255.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to the IP specifications, every machine on a network is supposed
    to respond to a request to the broadcast address. Unfortunately, in the late 1990s,
    this feature was used as an attack technique: All you needed to do was ping the
    broadcast address on any given network, and you would have a list of all IP addresses
    currently in use. Consequently, this functionality is now disabled by default
    on most operating systems and network appliances.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: You cannot assign the first or the last IP address in a network to a device
    without risking network problems. Some systems fail gracefully, others fail painfully,
    and a rare few make it work. Although OpenBSD won’t object if you use the top
    and bottom network addresses, prepare for mayhem the first time you plug in a
    commodity printer or other embedded device. It takes only one inflexible device
    to ruin your whole day.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv4 Addresses
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quite a few blocks of IPv4 addresses are set aside for specific purposes. Although
    you don’t need to know all of them, there are two groups you’ll see pretty often.
    For a complete list of IPv4 subnets reserved for special purposes, read RFCs 5735
    and 6598.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Localhost
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The address range 127.0.0.1/8 is set aside for *localhost*, a machine’s address
    for itself. Every Unix-like system—and most other operating systems—attaches 127.0.0.1/8
    to a loopback interface. Everything knows that the localhost address is local
    to the specific machine. Packets to or from 127.0.0.0/8 should never cross the
    network; likewise, daemons bound only to 127.0.0.1 can be accessed on only the
    local machine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Private Networks
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Internet standard RFC 1918 sets aside three networks for use on private networks
    and behind network address translation (NAT) devices: 10.0.0.0/8, 172.16.0.0/12,
    and 192.168.0.0/16\. While public IP addresses must be issued by an ISP, anyone
    can use addresses within these three blocks as long as those hosts are not directly
    exposed to the public Internet. If you have a network where hosts do not have
    access to the Internet, or if you provide Internet access through a proxy server
    or NAT, you can use an RFC 1918 network.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 Addressing Pitfalls
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common wisdom dictates that each computer on a network is assigned a single
    IP address for each of its network interfaces. One computer, one network card,
    one IP address—simple, right?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Not always. Some special-purpose interfaces (such as those dedicated to packet
    sniffing) function as intended without an IP address, and many operating systems
    will allow you to assign multiple IP addresses to a single network interface through
    a process called *aliasing*. You can also bond multiple physical cards into a
    single network interface, giving the computer one large virtual interface. While
    you might not deal with these configurations every day, keep them in mind when
    troubleshooting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Addresses and Subnets
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a basic problem with IPv4: It provides only 4.29 billion addresses,
    and that’s just not enough. Without subnetting, that’s fewer than one address
    for every human being. Eventually, every person will have at least one IP-capable
    device.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Although IPv4 addresses haven’t run out yet, they’re becoming an increasingly
    scarce resource. Overly generous allocations in the early days, along with large
    chunks of address space reservations for special purposes, have accelerated exhaustion.
    The world is slowly grinding toward IPv4’s replacement: IPv6.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Some parts of the world already use IPv6 extensively. Even if your network doesn’t
    use IPv6 today, one day you’ll need it—probably without warning. Prepare yourself
    now, or one day you’ll discover that you needed it the week before.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Basics
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like IPv4, IPv6 is a network layer protocol. IPv4 uses 32-bit addresses, usually
    expressed as four groups of decimal numbers from 0 to 255 (for example, 192.0.2.13).
    IPv6 uses 128-bit addresses, expressed as six groups of four hexadecimal characters
    separated by colons (for example, 2001:db8:0:bad:c0de:cafe). A 128-bit address
    space gives enough IPv6 addresses for every atom in the Earth to have more than
    10 IP addresses. TCP, UDP, ICMP, and other protocols run atop it. IPv6 has its
    own layer 2 protocol, Neighbor Discovery, which replaces protocols such as Ethernet’s
    ARP.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you don’t need to relearn the basics of networking. Hosts
    still need an IP address and a default gateway, routers still use a routing table,
    and you can almost—*almost*—substitute an IPv6 address for an IPv4 address and
    watch everything work. A web server doesn’t care if it binds to port 80 on 192.0.2.13
    or on 2001:db8:a12a:bad:c0de:café. The server just accepts requests sent to it
    and responds appropriately. That said, software does need to change slightly,
    because our web server must be able to log connections from both IPv4 and IPv6
    addresses. These changes have wide-reaching repercussions, and we’ll be sorting
    out edge cases for the next decade. But, in general, once you understand the new
    rules for IPv6, all of your networking knowledge is applicable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IPv6 Addresses
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted, IPv6 addresses are 128 bits, expressed as six colon-delimited groups
    of four hexadecimal characters each. As with decimal IPv4 addresses, you don’t
    need to display leading zeros in each group. The address 2001:db8:0:bad:c0de:cafe
    could also be written as 2001:db8:0000:0bad:c0de:cafe, but just as we wouldn’t
    write 192.000.002.013, we strip out the leading zeros in an IPv6 address.^([[29](#ftn.id369078)])
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addresses often contain long strings of zeros. This had to do with subnetting,
    which I’ll describe later in this section. As of this writing, the IPv6 address
    of Sprint’s website is 2600:0:0:0:0:aaaa. When consecutive groups include only
    zeros, as in this address, they’re replaced with two colons (`::`). This IP address
    is usually displayed as 2600::aaaa. You can do this only once per address, however.
    You can’t, for example, have the address 2600::1::1, because it’s ambiguous. Does
    2600::1::1 represent 2600:0:0:1:0:1 or does it represent 2600:0:1:0:0:1? I don’t
    know, and neither does your server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: You’ve probably seen a port number added to an IPv4 address, such as 192.0.2.13:80\.
    Using a colon to glue a port number to an IPv6 address would be confusing. The
    IPv6 address 2001:db8::bad:c0de:cafe:80 isn’t ambiguous, but if you read it quickly,
    you might miss the double colon and think this is an IP address ending in 80\.
    If you’re adding a port number to an IPv6 address, enclose the address in square
    brackets, as in [2001:db8::bad:c0de:cafe]:80.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Viewing IPv6 Addresses
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `ifconfig(8)` to see all IPv6 addresses assigned on your machine. Here,
    I give `ifconfig` the name of my network card, `fxp0`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The lines starting with `inet6` are my IPv6 addresses. This interface has been
    assigned two IPv6 addresses: `fe80::bad:c0de:cafe%fxp0` and `2001:db8::bad:c0de:cafe`.
    (Wait … where did that `%fxp0` come from? You’ll find out in [Link Local Addresses](ch11.html#link_local_addresses
    "Link Local Addresses"). For now, just nod and smile, and keep reading.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Subnets
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike IPv4, where you can subnet at any bit, IPv6 is usually subnetted at colon
    boundaries. Colons appear every 16 bits, so the natural IPv6 subnets are /16,
    /32, /48, and /64\. Though IPv6 standards recommend using /64 as the smallest
    possible network, many carriers use /80, /96, and /112 networks for special purposes.
    (I’ve also seen people use subnets not divided at 16-bit boundaries. I won’t cover
    them, but don’t let your brain explode when you encounter a /51.) IPv6 subnets
    are always expressed as a slash, also known as a *prefix length*, so you won’t
    see a netmask of ffff:ffff:ffff:ffff::, as you might in IPv4.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: ISPs are usually issued a /32 or a /48 subnet and are expected to issue end-user
    networks, such as the typical home network, a /64 network. If ISPs do issue /64
    subnets to their users, an end-user network will provide 264 IP addresses, or
    18,446,744,073,709,551,616 IP addresses. (This will suffice for any number of
    televisions, phones, refrigerators, water faucets, vacuums, and network-enabled
    tacos.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When you subnet at 16-bit boundaries, each network has 65,536 subnets of the
    next smaller size. A /32 contains 65,536 /48 networks, and a /48 contains 65,536
    /64 networks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv6 Addresses
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like its predecessor, IPv6 reserves several blocks of addresses for special
    purposes. You don’t need to memorize all of these reserved addresses, but some
    will appear in daily use.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: localhost
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'IPv6’s localhost address, ::1/128, works much like 127.0.0.1 in IPv4: It always
    refers to the local machine. In OpenBSD, ::1/128 is always assigned to the `lo0`
    interface.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Link Local Addresses
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Addresses beginning with fe8*x*: (where *x* is variable) are local to their
    interface. Every link has such *link local* addresses that are valid only on a
    specific local network. Even if an IPv6 network has no router, the hosts on the
    local, directly attached network can find each other and communicate using these
    local addresses. These networks are always /64 subnets. You’ll see identical IPv6
    subnets on other interfaces and on networks completely disconnected from your
    network. That’s okay. These addresses are local to the link. For example, here’s
    a link local address on an OpenBSD machine:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The link local address of this interface is `fe80::bad:code:cafe`. The trailing
    `%fxp0` indicates that this address is local to the interface `fxp0` and isn’t
    usable on any other interface on the machine. If your machine has an interface
    `fxp1`, and a host on that network tries to reach the address fe80::bad:code:cafe,
    this machine will not respond. This particular address is valid only for the network
    attached to interface `fxp0`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: You might note that the link local address has a section in common with the
    public IPv6 address on this network. That’s because an autoconfigured IPv6 address
    is usually calculated from the interface’s physical address; it doesn’t matter
    whether that autoconfigured address is on a public address or a link local address.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Assigning IPv6 Addresses
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPv6 clients can usually use autoconfiguration through *router discovery*, anIPv6
    protocol where routers announce their presence on the network and the legitimate
    addresses to clients. Unfortunately, IPv6 autoconfiguration does not support common
    Dynamic Host Configuration Protocol (DHCP) options, such as assigning a Domain
    Name Service (DNS) server, let alone the options used for diskless configuration.
    If you have configured a DNS server—even IPv4 servers accessible on a dual-stacked
    host—autoconfiguration works just fine. If you run an IPv6-only network, you must
    either set up an IPv6 DHCP server to provide DNS server information to clients
    or configure DNS servers manually.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Servers should not use IPv6 autoconfiguration. A server usually needs a static
    IP address, even in IPv6\. Similarly, routers cannot use autoconfiguration. If
    a host can forward packets, it requires a static IPv6 address.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You can assign multiple IPv6 addresses to a single interface by using aliases,
    just as with IPv4.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In IPv6, a client on a /64 network can use autoconfiguration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 autoconfiguration resembles a stripped-down DHCP service. The router broadcasts
    subnet and gateway information, and the hosts configure themselves to use it.
    Hosts on a network smaller than /64 must be manually configured.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Remedial TCP/IP
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a simplified overview of how the IP system works, let’s look
    at a real network protocol in some depth. The dominant transport protocol on the
    Internet is the Transmission Control Protocol over Internet Protocol, or TCP/IP.
    Although TCP is a transport protocol and IP is a network protocol, the two are
    so tightly intertwined that they’re generally referred to as a single entity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with ICMP, and proceed to UDP and TCP.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: ICMP
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ICMP is used to transmit routing and availability messages across the network.
    Tools such as `ping(8)` and `traceroute(8)` use ICMP. ICMP includes all sorts
    of different protocols and tools.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: While some people claim that you need to block ICMP for security purposes, those
    people don’t understand that ICMP is just as diverse as the better-understood
    transport protocols TCP and UDP. Proper IPv4 network performance requires large
    chunks of ICMPv4\. If you must block ICMPv4 for security reasons, do so selectively.
    For example, blocking source quench messages breaks path maximum transmission
    unit (MTU) discovery, which will steer you directly into a world of hurt. If you
    don’t understand that last sentence, don’t block ICMPv4.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 dies without ICMPv6, as IPv6 doesn’t support packet fragmentation, so never
    block ICMPv6\. If you don’t know what packet fragmentation is, just trust me on
    this.^([[30](#ftn.id453475)])
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: UDP
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UDP is the most bare-bones data-transfer protocol that runs over IP. It offers
    no error handling, minimal integrity verification, and no defense whatsoever against
    data loss. The transport protocol considers each packet of UDP completely self-contained;
    there are no data-coherence checks at the protocol layer. Despite these drawbacks,
    UDP can be a good choice for particular sorts of data transfer, and many vital
    Internet services rely on it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This discussion covers both UDPv4 and UDPv6\. While each runs over only the
    corresponding network protocol, they behave identically otherwise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: UDP is also a datagram protocol, meaning that each network transmission is complete
    and self-contained, and received as a single integral unit. While the application
    might not consider a single UDP packet a complete request, the network does.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: When a host transmits data via UDP, it has no way of knowing if the data ever
    reaches its destination. Programs that receive UDP data just listen to the network
    and accept whatever happens to arrive. When a program receives data via UDP, it
    cannot verify the source of that data. Although each UDP packet does include a
    source address, this address is easily faked. Each UDP packet includes a checksum
    for the packet, but there’s no integrity checking for the data stream as a whole.
    This is why UDP is called *connectionless*, or *stateless*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: No integrity checking, no guard against data loss, the potential for faked packets—all
    this sounds pretty unreliable. So why use UDP at all?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: UDP-based applications often have their own error-correction methods or otherwise
    don’t mesh well with more reliable protocols, such as TCP. For example, simple
    client DNS queries must time out within just a few seconds or users will whine
    uncontrollably. TCP connections time out only after two minutes. DNS requires
    quick failures and only a single packet per transaction, which makes UDP a better
    choice than TCP for simple DNS queries. Real-time streaming services, such as
    video conferencing applications, also use UDP. (After all, if a few pixels go
    missing during a video conference, you don’t want those pixels a minute later.)
    Most other UDP-based applications use UDP for similar reasons.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Because the UDP protocol itself doesn’t return anything when you connect to
    a port, there’s no reliable way to remotely test if a UDP port is reachable (although
    tools such as `nmap` try to do so).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: If you want a protocol that responds at the network layer, look at TCP.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: TCP
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TCP includes nifty features, such as error correction and recovery. The receiver
    must acknowledge every packet it gets; otherwise, the sender retransmits any unacknowledged
    packets. Unlike UDP, applications that use TCP can expect reliable data transmission.
    This makes TCP a *connected*, or *stateful*, protocol.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This discussion covers both TCPv6 and TCPv4\. While they differ because of their
    underlying transport protocol, they behave in the same way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: TCP is also a *streaming protocol*, which means that a single request can be
    split among several network packets. While the sender might transmit several chunks
    of data one after the other, that data might arrive out of order or fragmented.
    The recipient must track these chunks and assemble them properly to complete the
    network transaction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: For hosts to exchange TCP data, they must set up a channel for that data to
    flow across. One host requests a connection, the other host responds to the request,
    and then the first host starts transmitting. This setup process is known as the
    *three-way handshake*. Similarly, once transmission is complete, the systems must
    do a certain amount of work to tear down the connections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: To test if a TCP port is open, you can use `telnet(1)` or `nc(1)` to connect
    to the port. Here, I see if I can connect to port 22 on the host `caddis`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I connect to the remote port and see information displayed by the port, use
    the telnet escape character **`^]`** (CTRL-]) to disconnect **1**, and enter **`c`**
    **2** to close telnet.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: TCP is commonly used by applications most suited to its fairly generic set of
    timeouts and transmission features, such as email programs, FTP clients, and web
    browsers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: How Protocols Fit Together
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can compare the network stack to sitting with your family at a holiday dinner.
    The datalink layer (ARP, in the case of Ethernet) lets you see everyone else at
    the table. IP gives every person at the table their own unique chair (except for
    the twins using piano bench NAT). ICMP provides basic, lower-layer information
    such as “The quickest way to the baked sweet potatoes is to get Uncle Mike to
    pass them”?^([[31](#ftn.id324463)]) or “Aunt Liz can’t lift the ham platter.”
    TCP is where you hand someone the butter and the other person must say “thanks”
    before you let it go. UDP is like tossing a roll at Grandma Lucas; she might catch
    it or it might bounce off her forehead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Transport Protocol Ports
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transport protocol ports permit one server to serve many different services
    over a single transport protocol, multiplexing connections between machines. When
    a network server starts, it attaches, or *binds*, to one or more logical ports.
    A logical port is just an arbitrary number ranging from 0 to 65536, although nothing
    uses port 0\. For example, Internet mail servers often bind to port 25.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Each TCP or UDP packet arriving at a system carries a field containing its desired
    destination port number. If an incoming packet asks for port 25, it is connected
    to the mail server running on that port. This means that other programs can run
    on other ports, clients can talk to those different ports, and no one gets confused
    except you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Note that port assignments are not some sort of physical constant, but rather
    are mutually agreed upon. There’s no reason that email services should run on
    port 25 other than the fact that everyone agrees that they should. If someone
    tries to send you email, their mail server will automatically connect to port
    25 on your server. If you run email on port 80 and have a web server on port 25,
    you’ll never get your email, and your web server won’t get much traffic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，端口分配并不是某种物理常数，而是相互协商的结果。除了每个人都同意电子邮件服务应该运行在端口 25 的原因之外，没有理由让电子邮件服务运行在端口 25。如果有人试图给你发送电子邮件，他们的邮件服务器会自动连接到你的服务器上的端口
    25。如果你在端口 80 上运行电子邮件并在端口 25 上有一个 Web 服务器，你将永远收不到你的电子邮件，你的 Web 服务器也不会获得太多流量。
- en: 'The file */etc/services* contains a list of port numbers and the associated
    services. The file has a very simple, five-column format, as shown in these two
    sample lines:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/services* 包含了一组端口号及其相关服务。该文件具有非常简单的五列格式，如下两行示例所示：
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first field is the name of the service assigned to this port. This entry
    is for the service `www`. Port 80 is assigned to `www`, both TCP and UDP. Then
    there’s a list of any other names assigned to this port. Port 80 is also known
    as `http`. Finally, there’s a comment that gives more detail about the service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是分配给此端口的服务的名称。此条目是为服务 `www`。端口 80 被分配给 `www`，既支持 TCP 也支持 UDP。然后是分配给此端口的任何其他名称。端口
    80 也被称为 `http`。最后，有一个注释，提供了更多关于服务的详细信息。
- en: 'The HTTP protocol used on the Web runs over TCP, so why is UDP port 80 also
    reserved for HTTP? The answer is pretty simple: Computer people are easily confused.
    Having two services share the same port number but run on different protocols
    confuses people—for example, the `syslog` service runs on port 514 via UDP, and
    the `lpr` printer protocol runs on port 514 over TCP.^([[32](#ftn.id322914)])'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上使用的 HTTP 协议运行在 TCP 上，那么为什么 UDP 端口 80 也被保留用于 HTTP 呢？答案相当简单：计算机人士很容易感到困惑。让两个服务共享相同的端口号但运行在不同的协议上会让人困惑——例如，`syslog`
    服务通过 UDP 在端口 514 上运行，而 `lpr` 打印机协议通过 TCP 在端口 514 上运行.^([[32](#ftn.id322914)])
- en: Some server programs read */etc/services* to learn which port to bind to on
    startup, and many client programs read */etc/services* to learn which port they
    should try to connect to. If you run servers on unusual ports, you might need
    to edit this file to get these programs to attach where needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器程序在启动时读取 */etc/services* 来了解应该绑定到哪个端口，而许多客户端程序也读取 */etc/services* 来了解它们应该尝试连接到哪个端口。如果你在非标准端口上运行服务器，你可能需要编辑此文件，以便这些程序在需要的地方附加。
- en: As with all standards, there are times you will want to break the rules. The
    SSH daemon `sshd` normally binds to port 22/TCP, but I’ve run it on ports 23 (`telnet`),
    80 (`www`), 443 (`https`), and others to evade naïve packet-filtering firewalls.
    You will find your own reasons to break the standards. That’s fine, as long as
    you understand what you’re doing and how it affects others.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有标准一样，有时你会想要打破规则。SSH 守护进程 `sshd` 通常绑定到端口 22/TCP，但我已经将它运行在端口 23 (`telnet`)、80
    (`www`)、443 (`https`) 等其他端口上，以规避简单的数据包过滤防火墙。你会发现你自己的理由去打破标准。这是可以的，只要你理解你在做什么以及它如何影响他人。
- en: Reserved Ports
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保留端口
- en: Ports below 1024 in both TCP and UDP can be opened only by the root user. These
    ports are assigned (mostly) to core Internet infrastructure protocols, such as
    DNS, SSH, HTTP, LDAP, and so on—services that only a few select hosts on each
    network should offer. Only programs with root-level privileges can bind to reserved
    ports. For example, a user can run a game server on a high-numbered port if the
    system policy allows, but that’s different from setting up a web page visible
    to the whole world that claims the machine’s official purpose is a game server.
    The port assignment for these core protocols is generally permanent, and if you
    want to interoperate with other sites, you won’t change them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TCP 和 UDP 中低于 1024 的端口只能由 root 用户打开。这些端口分配（主要是）给核心互联网基础设施协议，如 DNS、SSH、HTTP、LDAP
    等等——只有网络中少数选定的主机应该提供的服务。只有具有 root 级别权限的程序才能绑定到保留端口。例如，如果系统策略允许，用户可以在高编号端口上运行游戏服务器，但这与设置一个面向全世界的网页不同，该网页声称机器的官方目的是游戏服务器。这些核心协议的端口分配通常是永久的，如果你想要与其他站点互操作，你不会改变它们。
- en: OpenBSD software usually binds to a reserved port as root and then drops privileges,
    performing the rest of its functions as an unprivileged user. These unprivileged
    users, discussed in [Chapter 6](ch06.html "Chapter 6. User Management"), have
    even fewer privileges than a normal user account.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: If you must run a service that binds to a reserved port, and it can run only
    as root, consider carefully whether you actually need it. Try to find an alternative
    server that does privilege separation. If you can’t, at least install that service
    on a dedicated machine to reduce its threat to other services on your network.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Which Ports Are Open?
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, network services are made available via TCP or UDP ports. Programs bind
    to ports to offer network services. This brings up two obvious questions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Which ports are open?
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What programs are listening to each port?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can answer these questions with `netstat(1)` and `fstat(1)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using netstat
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `netstat(1)` program provides general visibility into the network stack.
    Use `netstat` to check your routing table, examine open sockets, see how many
    packets are traversing your interfaces, and so on. (I could write an entire book
    about `netstat`, but no one would buy it. Instead, I’ll sprinkle bits of `netstat`
    magic throughout this book.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: When looking at network information, I recommend turning off DNS lookups by
    using the `-n` flag. You can always rerun a check with DNS turned on, but adding
    DNS queries to the network sockets can sometimes skew the information you’re viewing,
    and almost always slows the command.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The `-f` argument lets you choose a protocol family to display. Use `-f inet`
    to see only IPv4 sockets, or `-f inet6` to see only IPv6\. Read `netstat(1)` for
    the full protocol list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `-a` tells `netstat` to show all sockets opened by any process, rather
    than just sockets owned by the user.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put all those options together and have a look at the output. Here, I
    show the open IPv4 sockets on my system:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The list starts with open TCP ports **1**. The `Recv-Q` and `Send-Q` columns
    **2** show the number of bytes that the system is in the process of receiving
    or trying to send.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The `Local Address` column shows the IP address attached to the local machine
    where this socket is listening. It’s possible—common, even—for a service to bind
    to a port on only a single address on a machine. If the port is part of an actual
    connection, as the first example **3** shows, the IP address is followed by the
    port number. This particular TCP connection is attached to port 22 at the address
    192.0.2.135\. Port 22 is reserved for SSH, so this is probably an SSH connection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If the local address is an asterisk followed by a port number **8**, this is
    a wildcard bind. A program has bound to this port, and has asked the kernel to
    figure out the IP address. It’s probably (but not necessarily) a listening socket.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The `Foreign Address` column **4** shows the IP address and port of the remote
    host involved in a connection. If there’s a foreign address shown, it always includes
    the port. If this column shows two asterisks **6**, that means the service is
    waiting for a connection on the local port.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The `(state)` column applies only to TCP connections. A live and working TCP
    connection is in the `ESTABLISHED` state **5**. Other states (`SYN_RCVD`, `ACK`,
    and `SYN+ACK`) are all normal parts of connection creation, while `LAST_ACK`,
    `FIN_WAIT_1`, and `FIN_WAIT_2` mean that the connection is closing. A state of
    `LISTEN` **7** means that this socket is waiting for an incoming connection.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: UDP ports are given their own section **9**. You might see remote hosts in the
    UDP section, especially for long-running protocols such as NFS and NTP, but remember
    that UDP is stateless, so you’ll never see state on a UDP connection.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in only TCP or UDP sockets, you can use the `-p` flag
    to show only a particular protocol. Here, I look at TCP sockets:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While this looks similar to the first output example, note that we see both
    IPv4 and IPv6 TCP connections and services. TCP runs over both IPv4 and IPv6,
    so choosing it shows both address families. It’s entirely possible to have a service
    running on one address family and not the other. Many of my systems listen for
    incoming SSH connections only on IPv6; doing so hides me from port scanners and
    worms (for now, anyway).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than listing every service waiting for an incoming connection, you can
    show only live connections by dropping the `-a` flag:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using fstat
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know which TCP and UDP ports are open, how can you tell which programs
    are listening on them? OpenBSD includes `fstat(1)`, a program that displays all
    open files and sockets on the system. Network connections are open sockets. Running
    `fstat` on an idle system can generate hundreds of lines of output—one entry for
    each file opened by any process. While that’s educational and useful, it’s not
    what we’re looking for. Specifically, we want to see which programs are holding
    network sockets open. The string `internet` indicates network sockets.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, you see an `sshd` process owned by the user `mwlucas`. That’s an unprivileged
    process, tied to a particular SSH session. Further down the list, you see an SSH
    daemon owned by root listening to the network. When a connection request arrives,
    the root-owned SSH daemon will hand it off to an unprivileged child process. You
    can also see that we have a variety of `sendmail` processes listening to the network.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: This system runs the expected SSH and email servers, and no one has bound anything
    to odd ports. My nasty paranoid suspicions were unfounded (this time, anyway).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Between `netstat` and `fstat`, you should be able to get a good idea of what
    your system is doing on your network at any given time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: IP Routing
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most sysadmins don’t need to understand much about IP routing, because most
    servers have only one network interface and one default gateway. The network administrator
    gives you an IPv4 address and a default route, you put them in the appropriate
    configuration files, and you’re routed. You don’t need even that for most IPv6
    hosts, as autoconfiguration makes things magically work. Servers will need a static
    IPv6 address and a manual default route.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Some servers have multiple interfaces, such as one to their default gateway
    and another to a group of related application or backup servers. OpenBSD systems
    frequently wind up in the network infrastructure, however, or sit in demilitarized
    zones (DMZs) where the server must make routing decisions. If you want to use
    OpenBSD in such an environment, or as a firewall, you must understand the basics
    of routing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '*Routing* is simply deciding where to send packets. If your system is attached
    to a network, it doesn’t need to make any decisions; it just sends the packet
    to that network. Your system on 192.0.2.0/24 already knows how to reach any IP
    address beginning with 192.0.2—it can just send everything out to the local Ethernet.
    Where does it send those packets?'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Most computers use a *default route*, which is an IP address on the local network
    where they send all packets bound for nonlocal IP addresses. This is very common
    where one router or firewall provides all network access. This device probably
    also has a default route that points to your ISP, which makes all the complicated
    routing decisions for you.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, you might have a dynamic routing protocol running on your network.
    If you’re using Open Shortest Path First (OSPF), Border Gateway Protocol (BGP),
    or Routing Information Protocol (RIP), OpenBSD has daemons specifically for integrating
    these protocols. There’s an introductory middle ground between full dynamic routing
    and simple default routes, however, and you should understand it before attempting
    full dynamic routing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover a simple case here using an IPv4 example. (IPv6 routing is exactly
    like IPv4 routing, but with a lot more colons.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 Routed Network Example
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a network has multiple gateways leading to different networks, hosts on
    the network must make routing decisions. Suppose your network has multiple routers
    attached to it, each going to a different network. Machines on your network decide
    where to send packets. Here’s an example of a common double-firewall situation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1616080.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: In this network design, hosts must transit a DMZ before entering either the
    Internet or the internal network. (Other designs exist, such as the hub-and-spoke
    model, but I’ve specifically chosen a design where routing is needed.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The external firewall provides one layer of protection. It permits only traffic
    specifically deemed necessary (we’ll go into the default deny stance in [Chapter 21](ch21.html
    "Chapter 21. Packet Filtering")). It does, however, permit incoming connections
    to hosts in your DMZ.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The hosts in the DMZ are to some extent vulnerable. They are not trusted enough
    to be on the internal network. Your intrusion-detection systems or your web servers
    might live here.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The internal firewall, like the external firewall, permits only traffic deemed
    necessary to organization purposes. It probably doesn’t allow any connections
    from the outside world, however, and it doesn’t trust the hosts on the DMZ.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Only highly trusted hosts are permitted on the internal network. This is where
    the organization keeps its most precious data, such as the financial records,
    customer databases, and movie collections.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Many of the hosts in this network need to make only very simple routing decisions.
    Anything on the internal network has just one way to reach anything, and any host
    on the Internet has only one way to reach the internal or DMZ networks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The external firewall is directly attached to the DMZ network, so it can send
    packets to those hosts. It needs a default route pointing to the Internet so it
    can reach the rest of the world. To reach the hosts on the internal network, it
    must send packets to the internal firewall’s external interface. If you don’t
    configure this on the external firewall, data will never reach the internal firewall.
    Because the external firewall is responsible for the internal network’s Internet
    access, losing this route would disconnect the internal network from the Internet;
    internal systems could send packets, but would never receive any. The external
    firewall needs routing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you could configure routing on each host inside the DMZ. In that
    case, ICMP redirects from the firewalls would provide routing for these hosts,
    but trusting ICMP redirects on a vulnerable network is unwise and messy because
    it assumes that every host on the DMZ and every firewall accepts and sends ICMP
    redirects. If you’re using OpenBSD, you want your server to be secure, so configure
    routing on your DMZ systems.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I configure routing for the external firewall. Configuring
    routing for the DMZ hosts is nearly identical to this example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Managing Routing with route(8)
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `route(8)` command manages all system routing. Like `netstat`, `route` has
    several subfunctions that allow you to view, edit, and monitor the system routing
    table. While the `route(8)` man page has complete details, the ability to view,
    add, and delete routes should be enough to get you started.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Routes
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenBSD, like any other network device, keeps routes in a routing table. To
    view the IPv4 and IPv6 routes, enter **`route show`**. Add **`-n`** to remove
    IP-address-to-name translations.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the IPv4 routing table:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The table shows the following information:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The `Destination` field lists the range of IP addresses this route applies to—destination
    addresses. The `default` entry indicates the default gateway, which is where the
    system sends all packets that have no specific route.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标`字段列出了此路由应用的IP地址范围——目标地址。`默认`条目表示默认网关，即系统发送所有没有特定路由的数据包的地方。'
- en: The `Gateway` field tells where packets for this route should be sent. A gateway
    could be a hostname, an IP address, or a network interface.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网关`字段说明了此路由的数据包应该发送到何处。网关可以是主机名、IP地址或网络接口。'
- en: The `Flags` field contains markers that indicate what sort of route this is
    and how it behaves. The next section covers the various route flags.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标志`字段包含指示此路由类型及其行为的标记。下一节将介绍各种路由标志。'
- en: The `Refs` field shows the number of references to the route in the kernel (also
    known as the *refcounter*). If the refcounter drops to zero, the route is removed.
    This has no practical use for system administration, because one reference is
    sufficient to keep the route in the routing table; additional references don’t
    change anything.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`引用`字段显示了内核中对该路由的引用次数（也称为*引用计数器*）。如果引用计数器降至零，则删除路由。这对于系统管理来说没有实际用途，因为一个引用就足以保持路由在路由表中；额外的引用不会改变任何事情。'
- en: The `Use` counter increments each time a packet uses that route.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`使用`计数器每次数据包使用该路由时都会增加。'
- en: The `Mtu` is the MTU—the largest frame size that can travel over this route.
    If the field contains a hyphen (`-`), OpenBSD uses the MTU of the underlying physical
    interface. The loopback interface, `lo0`, isn’t a physical interface, so OpenBSD
    explicitly sets the MTU very high. You might see a route with a lower MTU if Path
    MTU Discovery has kicked in.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mtu`是MTU——可以通过此路由传输的最大帧大小。如果字段包含连字符（`-`），OpenBSD将使用底层物理接口的MTU。回环接口`lo0`不是一个物理接口，因此OpenBSD明确地将MTU设置得非常高。您可能会看到具有较低MTU的路由，如果路径MTU发现已启动。'
- en: The `Prio` field gives the route priority. OpenBSD supports multiple routes
    to a single destination. Some routes are more desirable than others, and OpenBSD
    will use the route with the lowest priority number. Routes provided by dynamic
    routing protocols, such as BGP or OSPF, get higher priority numbers than static
    routes.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`优先级`字段给出了路由的优先级。OpenBSD支持到单个目的地的多个路由。一些路由比其他路由更受欢迎，OpenBSD将使用优先级编号最低的路由。由动态路由协议（如BGP或OSPF）提供的路由比静态路由具有更高的优先级编号。'
- en: The `Iface` field shows which interface this route uses.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`接口`字段显示了此路由使用的接口。'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenBSD also includes dynamic routing daemons such as `ospfd(8)` and `bgpd(8)`.
    I don’t cover them here, because that topic would fill a book on its own.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD还包括动态路由守护进程，如`ospfd(8)`和`bgpd(8)`。这里不涉及它们，因为这个主题本身就可以写一本书。
- en: Let’s see what’s interesting in the routes in this sample. The first entry at
    **1** is the system default route. If there is no more specific route, packets
    will be sent to the IP address 192.0.2.1.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个示例中路由中有什么有趣的。第一个条目**1**是系统默认路由。如果没有更具体的路由，数据包将被发送到IP地址192.0.2.1。
- en: To reach the network 127.0.0.0/8 at **2**, packets should go to the IP address
    127.0.0.1\. 127.0.0.0/8 is the address range reserved for loopback addresses,
    and 127.0.0.1 is always the local machine. Notice the high MTU; this is a software
    interface, so there’s no physical limit on the size of frames sent through it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达**2**处的网络127.0.0.0/8，数据包应发送到IP地址127.0.0.1。127.0.0.0/8是为回环地址保留的地址范围，127.0.0.1始终是本地机器。注意高MTU；这是一个软件接口，因此通过它的帧大小没有物理限制。
- en: To reach the IP address 127.0.0.1 at **3**, send the packets to the IP address
    127.0.0.1\. This might seem a bit pedantic, but it’s a valid route and needs to
    be in the table. Remember that 127.0.0.1 is always the loopback address of the
    local machine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达**3**处的IP地址127.0.0.1，请将数据包发送到IP地址127.0.0.1。这听起来可能有点繁琐，但这是一个有效的路由，需要包含在表中。请记住，127.0.0.1始终是本地机器的回环地址。
- en: To reach the IP address 192.0.2.0/24 at **4**, use a gateway of `link#1`. This
    is a local physical interface—in this case, our Ethernet interface. The interface
    named `link#1` is actually the interface with index `#1`, which isn’t really exposed
    to the system administrator anywhere else. These addresses are local to the machine,
    and you must figure out which interface this is by the IP address attached to
    the machine. Addresses local to the machine don’t actually need to be in the routing
    table, but no one has bothered to remove this historical nit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: To reach a specific IP address on the local network at **5**, you’ll get a route
    of the IP address and the physical media address. Because this host is connected
    via Ethernet, the gateway is a MAC address. Every local address that the system
    needs to find gets a route entry, and you should almost always show a specific
    route for the default gateway.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The last route at **6** is for the multicast address range 224/8\. If you’re
    not using multicast, it should go to the local host.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multicast is a complicated topic beyond the scope of this book (again). But
    if you’re interested, OpenBSD supports multicast just fine.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Route Flags
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Flags` column of the routing table indicates how routes are generated
    or used. `netstat(1)` contains a complete list of route flags. [Table 11-2](ch11.html#common_route_flags
    "Table 11-2. Table 11-2: Common Route Flags") lists the common ones.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-2. Table 11-2: Common Route Flags'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Description |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| `C` | This route was cloned. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| `c` | This is a protocol-specific route (such as to an Ethernet MAC address).
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| `D` | This route is dynamic. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| `G` | This route goes via a gateway. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| `H` | This route is for a specific host. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| `L` | This route is for the local link layer. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| `M` | This route was modified. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| `R` | This is a reject route. Packets are dropped, and an error is sent.
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| `B` | This is a blackhole route. Packets are dropped silently. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: These flags tell you where a route came from and how it’s used.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Adding Routes
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add routes with the `route add` command. You must know the destination network,
    its netmask, and the gateway.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our example network, the outer firewall needs a route to reach the private
    network, 192.0.2.128/25\. To route this network to the inner firewall at 192.0.2.2,
    run this command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Packets will use that route immediately. If you run `route show`, you’ll see
    that new route.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a default route, run `route add default` with the IP address of the
    default gateway, like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To add routes automatically at boot, put the `route` statement in the */etc/hostname.if*
    file that leads to the destination network. These routes appear when the interface
    is brought up, before */etc/rc.securelevel* runs or any local daemons start. You’ll
    see examples of using *hostname.if* for routes in the next chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To add a default route automatically at boot, put the default router IP address
    in */etc/mygate*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Routes
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To delete a routing table entry, use `route delete` with the network address
    and netmask.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To remove the route added in the previous example, run this command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should now have a decent idea of how routing works.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how things are supposed to fit together, let’s see how to
    configure Ethernet networks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: ^([[27](#id460204)]) You laugh, but the technical reviewer for this book was
    part of the first IP-over-carrier-pigeon implementation team that tackled the
    practical tests as specified in RFC 1149\. That’s how I knew he had the time to
    review this book in excruciating detail. (If that’s how he spends his time, he
    couldn’t very well claim he was too busy, now could he?)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: ^([[28](#id433870)]) I never do take pity on my readers; I just don’t want you
    to actually *say* so.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: ^([[29](#id369078)]) Some operating systems treat addresses containing numbers
    that begin with 0 as octal. Don’t actually use addresses like 192.000.002.013,
    or you might get a base-8 surprise.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#id453475)]) Or you can go look it up. Whatever—you not believing me
    won’t hurt my feelings.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: ^([[31](#id324463)]) For the record, Uncle Mike’s security policy prevents him
    from passing baked sweet potatoes. If you want them, you’re going to have to take
    them by force.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#id322914)]) I used to count how many people confused 514/tcp and 514/udp,
    but the number got so high that I got depressed, so I stopped.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
