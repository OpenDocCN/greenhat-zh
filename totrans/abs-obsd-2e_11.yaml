- en: Chapter 11. Overview of TCP/IP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*IP version 6:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the pain of version 4,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*plus brand-new problems!*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Securing a computer
    is easy: Disconnect it from all networks, remove all input and output, and lock
    it in a bunker. Oh, wait—did you want the system to *do* something? Then you’ll
    probably want to connect your system to the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: Many system administrators have a vague familiarity with the basics of networking,
    but to be a truly competent sysadmin, you need a real understanding of how everything
    fits together. You don’t need to know when to use rapid spanning trees, how to
    choose between BGP and OSPF, or even what those acronyms represent. But you must
    know what an IP address is, how a netmask works, how port numbers differ from
    protocol numbers, and why you cannot use `telnet(1)` to test UDP connectivity.
    Without this basic knowledge, you’ll fumble. Read this chapter and understand
    it, and you’ll have an easier time convincing your network administrator to give
    you what you need.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter offers an overview of TCP/IP, it doesn’t cover the innumerable
    details, caveats, annoyances, peccadilloes, and blatant outrages present in the
    protocol. If you find that you need to torture yourself with the finer points
    of TCP/IP, pick up one of the big, thick books on the subject. *The TCP/IP Guide*
    by Charles M. Kozierok (No Starch Press, 2005) is an excellent place to start.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers both TCP/IP version 4 (the Internet protocol widely used
    for the last 30-odd years) and the new version of the protocol, TCP/IP version
    6\. Despite the different version numbers, the two protocols are more similar
    than not.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the layers of the network and then delve into how the protocols
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Network Layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The network protocol is divided into several layers. Each layer handles a specific
    task and interacts only with the layers immediately above and below it. At first,
    you might laugh at the idea that this layer model simplifies the network process,
    but it really does. The important thing to remember right now is that each layer
    communicates with only the layer directly above it and the layer directly beneath
    it (theoretically, anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic Open Systems Interconnection (OSI) network protocol stack represents
    the network as seven layers. It’s an exhaustively complete model and covers almost
    any situation using any network protocol and any application. Because the Internet
    is a very specific type of network, and because this isn’t a book about networking
    or networked applications in general, I’ll limit my discussion of TCP/IP to four
    specific layers of the network: physical, datalink, network, and transport. Don’t
    worry—these four layers cover the Internet and (almost) all corporate networks.'
  prefs: []
  type: TYPE_NORMAL
- en: The Physical Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether it’s copper or fiber-optic cable, or even radio waves, physical wire
    is a layer of the network. Without some physical media to run over, a network
    cannot function. Everything from the CAT5 cable plugged into your desktop to the
    fiber-optic cable connecting you to Asia is part of the physical layer. If it
    can be tripped over, backhoed, or interfered with, it’s part of the physical layer.
    For simplicity’s sake, I’ll refer to the physical layer as the *wire*, although
    it can take innumerable forms.
  prefs: []
  type: TYPE_NORMAL
- en: This is the easiest layer to understand. If your wire meets the requirements
    of the physical protocol, you’re in business. If not, your network won’t work.
    One of the functions of Internet routers is to connect one sort of physical layer
    to another—for example, converting local Ethernet into an OC3 fiber connection.
  prefs: []
  type: TYPE_NORMAL
- en: The physical layer has no decision-making abilities of its own; everything that
    runs over it is dictated by the datalink layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Datalink Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The datalink layer is the protocol that runs over the physical wire. It transforms
    information into the actual signals that are sent over the physical layer, using
    the appropriate encoding for that physical media, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Both Ethernet and Switched Multimegabit Data Service (SMDS) use Media Access
    Control (MAC) addresses and the Address Resolution Protocol (ARP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 over Ethernet uses Neighbor Discovery (ND).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dial-up and wide area networks (WANs) use either the Point-to-Point Protocol
    (PPP) or High-Level Data Link Control (HDLC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenBSD supports other common datalink protocols, such as PPP over Ethernet
    (PPPoE). If you have unusual network requirements, check the OpenBSD website,
    mailing lists, or man pages to see if those requirements are supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some datalink layers have been implemented over many different physical layers.
    Ethernet, for example, has been implemented over twinax, coax, CAT3, CAT5, CAT6,
    CAT7, optical fiber, and radio waves. And for true device independence, we have
    seen TCP/IP implemented with a biological transport layer: carrier pigeon.^([[27](#ftn.id460204)])'
  prefs: []
  type: TYPE_NORMAL
- en: With minor changes to the device drivers, the datalink layer can address any
    sort of physical layer. This is one of the ways in which layers simplify the network.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. Connecting to the Network") discusses Ethernet
    in detail, as it’s the most common network type for OpenBSD systems. Once you
    understand how Ethernet works, you’ll have no difficulty adding new datalink protocols
    as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: The datalink layer exchanges information with the physical layer and the network
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Network Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The network layer is the part that maps connectivity between network nodes,
    answering questions like “Where are other hosts?” and “Can I get there from here?”
    This logical protocol provides a consistent interface to programs that run over
    the network, no matter what the physical and datalink layers look like.
  prefs: []
  type: TYPE_NORMAL
- en: The network layer used on the Internet is the Internet Protocol, or IP. Both
    version 4 (IPv4) and version 6 (IPv6) provide each host with one or more unique
    *IP addresses*, so that any other host on the network can find it. Okay, IPv4
    network address translation munges the whole “unique address” rule, but your network
    still has a unique IP address somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The network layer talks to the datalink layer below it and the transport layer
    above it.
  prefs: []
  type: TYPE_NORMAL
- en: The Transport Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The transport layer is where actual data flows. The three most common transport
    layer protocols are the Internet Control Message Protocol (ICMP), Transmission
    Control Protocol (TCP), and User Datagram Protocol (UDP).
  prefs: []
  type: TYPE_NORMAL
- en: ICMP passes basic connectivity messages between hosts with IP addresses. If
    IP provides a road and addresses, ICMP provides traffic lights and highway exit
    signs. Most of the time, ICMP runs silently in the background.
  prefs: []
  type: TYPE_NORMAL
- en: UDP and TCP are the protocols that carry actual data between hosts, and they
    are so prevalent that the suite of Internet protocols is usually called TCP/IP.
    UDP is a bare-bones transport protocol, offering the minimum services needed to
    transfer data over the network. Its minimalism means that if you want to customize
    exactly how data flows in your application, you can build it out of valid UDP.
    TCP provides more sophisticated features, such as integrity checking and congestion
    control, but many of its settings are hard-coded.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these three, many other protocols run at the transport layer.
    The file */etc/protocols* contains a fairly comprehensive list of transport protocols
    built atop IP. While it lists many more protocols than you will ever actually
    deal with out in the wild, it doesn’t include non-IP protocols like IPX/SPX or
    Digital Equipment Company’s DECnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s have a look at the first entry from */etc/protocols*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each */etc/protocols* entry has three key fields: an official name, a protocol
    number, and any aliases. The IP protocol, protocol 0, is known as IP and (*very*
    occasionally) as HOPOPT. Each protocol also has a comment giving it some context.
    Although some of the protocols in */etc/protocols* are long gone, some antediluvian
    devices out there might still speak them.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that ICMP, TCP, and UDP are slightly different when run over IPv4 versus
    IPv6\. Each protocol has clearly defined fields in the IP packet header, leaving
    specific numbers of bits for things like checksums, destination addresses, and
    so on. You can’t run a transport protocol over an incompatible network protocol—TCPv6
    over IPv4 just doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer speaks to the network layer below and to the applications
    layer above it.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications are definitely part of the network. Applications request network
    connectivity, send data over the network, receive data from the network, and process
    that data. Web browsers, email clients, JavaServer Pages (JSP) servers, and so
    on are examples of network-aware applications. Applications need to communicate
    with only the transport protocol and the user. The upper three layers of the OSI
    network model are inside applications.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with the user layer are beyond the scope of this book, but I find that
    many of these issues can be solved with proper application of a large chainsaw.
  prefs: []
  type: TYPE_NORMAL
- en: The Life and Times of a Network Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So how do all these layers fit together in the real world? Let’s have a look
    at a hypothetical network request, and walk through how data traverses the layers
    and the network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of this discussion touches on topics covered later this chapter, so you
    might want to reread this section after finishing the chapter. Purists will notice
    that I skip a lot of parts of the process, but I’m trying to relay the basics
    of how TCP/IP works in practice, not model every painful detail of a real network
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a user connected to your network wants to look at a very important work-related
    website, such as Scott Meyer’s Basic Instructions (*[http://www.basicinstructions.net/](http://www.basicinstructions.net/)*).
    The user opens his browser, enters the URL, and presses ENTER. The browser application
    transforms the user’s request into the proper format and asks the transport layer
    for a TCP connection to a particular IP address on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer inside your computer examines the browser’s request and
    allocates the appropriate resources for it. The request is broken up into digestible
    chunks, called *segments*, and handed down to the network layer.
  prefs: []
  type: TYPE_NORMAL
- en: The network layer doesn’t care about the contents of the request; it’s only
    concern is where that data is going. The network layer takes the TCP data and
    attaches the proper addressing information to it. The resulting chunk of data
    is called a *packet*. The network layer checks the packet’s destination, chooses
    the interface closest to the gateway to that destination, and drops packets down
    into the datalink layer.
  prefs: []
  type: TYPE_NORMAL
- en: The datalink layer doesn’t care about the contents of the packet, and it certainly
    doesn’t care about IP addresses or routing. It has been given a lump of zeros
    and ones, and its job is to transmit those zeros and ones to another network node.
    The datalink layer adds the appropriate header and/or footer information to the
    packet, creating a *frame* appropriate for the physical layer. The frame’s header
    and footer contain the addressing information for the physical layer. On most
    networks, the datalink layer prepares frames for the local Ethernet. Then the
    datalink layer hands off the frame to the physical layer for transmission.
  prefs: []
  type: TYPE_NORMAL
- en: The physical layer has no intelligence at all (think carrier pigeons). The datalink
    layer hands the physical layer a frame, and the physical layer transmits that
    frame to another physical device. For a web browsing client, this is usually the
    default router for the local Ethernet. The physical layer doesn’t care about the
    upper-level protocols. Its only job is to make sure the frame gets to the destination
    without errors.
  prefs: []
  type: TYPE_NORMAL
- en: When the client computer’s router receives the frame, it sends it up to the
    datalink layer. The datalink layer strips out the frame information and hands
    the resulting packet up to the network layer. The router’s network layer examines
    the packet, looks at its routing table, and decides which interface to send it
    out on. This might be another Ethernet interface, a T1, a DS3, an OC3, or whatever
    the router uses for upstream connectivity. Once the router chooses an interface,
    it hands the packet to the datalink layer for that interface.
  prefs: []
  type: TYPE_NORMAL
- en: The local router’s upstream connection probably goes through a whole series
    of routers. Each router decides where to send the request based on its routing
    table. The request probably traverses a variety of datalink layers as it travels.
    Thanks to layering and abstraction, neither you nor your computer needs to know
    anything about any of them.
  prefs: []
  type: TYPE_NORMAL
- en: When the request reaches its destination, the computer at the other end of the
    transaction accepts the frame and sends it all the way back up the protocol stack.
    The frame is stripped down to packets, which are stripped down to segments, which
    are reassembled into a data stream. The data stream is then handed to the application
    (in this case, a web server). The application processes the request and returns
    an answer, which goes back down through the protocol stack and travels across
    the network, bouncing up and down through various datalink layers on the way as
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows why the layer model is important: Each layer knows only
    what it absolutely must about the layers above and below it, making it possible
    to swap out layers if necessary. When a new datalink protocol is created, the
    other layers don’t need to change. The network layer just hands a packet to the
    datalink layer and lets the datalink do its thing. When you install a new network
    card, you need only a driver that interfaces with the datalink layer and the physical
    layer; you don’t need to change anything higher in the network stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Network Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network stack is the software that lets a host communicate with the network.
    A host can run with an IPv4-only network stack, an IPv6-only network stack, or
    a dual-stacked setup.
  prefs: []
  type: TYPE_NORMAL
- en: You’re already familiar with an IPv4-only stack—it’s what most hosts ran for
    much of the past 30 years. An IPv4-only stack can communicate only over IPv4\.
    Today, an IPv4-only stack gets you access to the entire Internet, with a few deliberate
    exceptions. That will not be true in a few years.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, an IPv6-only stack can communicate with only IPv6 hosts. Because most
    Internet sites don’t yet support IPv6, running an IPv6-only stack isn’t practical
    at this point. It is, however, an excellent way to test your IPv6 infrastructure
    and connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: The most common configuration these days is a dual-stack setup. Client hosts
    try to use both IPv4 and IPv6, preferring one over the other. I recommend configuring
    hosts with dual stacks, preferring the stack with better connectivity. (If you
    get IPv6 connectivity through a tunnel, it’s not as fast as your IPv4 connectivity.)
    If you have equal IPv4 and IPv6 connectivity, use whichever you prefer. IPv6 works
    well enough that I often don’t realize that I’m using it until I analyze my traffic.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to do anything special to enable IPv6 on OpenBSD—an IPv6 address,
    a default router, and a DNS server, and away you go.
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 Addresses and Subnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *IP address* is a unique 32-bit number assigned to a specific network node.
    Some IP addresses are more or less permanent, such as those assigned to vital
    servers; others change as required, such as those used by desktop clients. Individual
    machines on a shared network use IP addresses from a range of addresses assigned
    to that network.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than expressing that 32-bit address as a single number, an IP address
    is divided into four 8-bit numbers, usually expressed as decimals. While 192.0.2.1
    and 11000000.00000000.00000010.00000001 represent the same address, the first
    option is easier for our feeble little brains to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: Internet service providers (ISPs) issue IP addresses in blocks. These blocks
    are the smallest allocation that they can get away with giving you—say, 16 or
    32 addresses. If your system is on a server farm, you might get only a few IP
    addresses out of a block of 256.
  prefs: []
  type: TYPE_NORMAL
- en: A *netmask* indicates the size of the block of IP addresses assigned to your
    local network. The size of your IP block determines your netmask—or, your netmask
    determines how many IP addresses the network has.
  prefs: []
  type: TYPE_NORMAL
- en: ISPs issue IP addresses by prefix length, commonly called a *slash*. You’ll
    see IP address blocks described in forms like 192.0.2.128/26\. Everyone who has
    worked with networking has seen the netmask 255.255.255.0, and most know that
    it’s associated with a block of 256 IP addresses. That netmask is also called
    a /24\. The number after the slash is the number of fixed bits in the netmask.
    Remember, an IPv4 address is a 32-bit number; on a /24 network, 24 of those bits
    will never change.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a textbook on binary math, so I won’t quiz you on the conversions,
    but think of an IP address as a string of 32 binary digits. On your networks,
    you can change the bits on the far right, but not the bits on the far left. But
    where is the line that separates right from left?
  prefs: []
  type: TYPE_NORMAL
- en: 'Netmasks have traditionally been split on 8-bit boundaries, but there’s no
    hard rule that says they must be. A /25 network has 25 fixed bits—one more fixed
    bit than what used to be called a class C network—leaving you with 7 bits to play
    with. The netmask’s fixed bits are set to 1, and your network bits are set to
    0, as in the following example of a /25 netmask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first three blocks are set to the binary 11111111, which is 255 in decimal.
    The last block is set to 1000000, which is 128\. Mash these together, and your
    resulting netmask is 255.255.255.128.
  prefs: []
  type: TYPE_NORMAL
- en: If you reduce netmasks to binary, they’re simple to figure out. While you won’t
    need to work with this every day, if you don’t understand the underlying concepts,
    the decimal conversion looks like total gibberish. With a little practice, you’ll
    recognize certain decimal strings as legitimate netmasks.
  prefs: []
  type: TYPE_NORMAL
- en: So now that you know how netmasks work, what the heck does all this mean in
    the real world?
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses are issued in multiples of 2\. If you have 4 bits to play with,
    you have 16 addresses (2⁴=16). If you have 8 bits to play with, you have 256 addresses
    (2⁸=256). If someone says that you have exactly 17 IP addresses, you’re either
    sharing a network with other people or they’re wrong.
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to see a host’s IP with the netmask attached, such as 192.0.2.130/26\.
    This gives you everything you need to attach the host to the local network. (Finding
    the default gateway is a separate issue, but it’s usually the top or bottom address
    in the block.)
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a Decimal IPv4 Netmask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting from binary to decimal to binary is error-prone and mildly annoying.
    Here’s how to calculate your netmask while remaining in decimal land.
  prefs: []
  type: TYPE_NORMAL
- en: Find how many IP addresses you have on your network. This will be a multiple
    of 2, almost certainly smaller than 256\. Subtract the number of IP addresses
    you have from 256\. This is the last number of your netmask. You still need to
    recognize legitimate network sizes, however. If your IP address is 192.0.2.251/26,
    you’ll need to know that a /26 is 26 fixed bits, or 64 IP addresses. Your netmask
    is 255.255.255.192 (256–64=192).
  prefs: []
  type: TYPE_NORMAL
- en: And I should also mention that netmasks occasionally appear in hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you travel to my house to bludgeon me repeatedly with this book, [Table 11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions
    "Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions") shows netmasks,
    IP information, and related information for /24 and smaller networks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Prefix | Binary Mask End | Decimal Mask | Hex Mask | Available IPs |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| /24 | 00000000 | 255.255.255.0 | 0xffffff00 | 256 |'
  prefs: []
  type: TYPE_TB
- en: '| /25 | 10000000 | 255.255.255.128 | 0xffffff80 | 128 |'
  prefs: []
  type: TYPE_TB
- en: '| /26 | 11000000 | 255.255.255.192 | 0xffffffc0 | 64 |'
  prefs: []
  type: TYPE_TB
- en: '| /27 | 11100000 | 255.255.255.224 | 0xffffffe0 | 32 |'
  prefs: []
  type: TYPE_TB
- en: '| /28 | 11110000 | 255.255.255.240 | 0xfffffff0 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| /29 | 11111000 | 255.255.255.248 | 0xfffffff8 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| /30 | 11111100 | 255.255.255.252 | 0xfffffffc | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| /31 | 11111110 | 255.255.255.254 | 0xfffffffe | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'When you don’t feel like doing the math, you can refer to [Table 11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions
    "Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions") or install
    the `ipcalc` package for quick netmask calculations. Don’t say I never take pity
    on my readers.^([[28](#ftn.id433870)])'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing IPv4 Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Display IP addresses with `ifconfig(8)`. If you run `ifconfig` without any arguments,
    it displays all interfaces on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The lines starting with `inet` are IPv6 addresses. This interface has the primary
    IPv4 address of 192.0.2.226 and a secondary, or *alias*, address of 192.0.2.231\.
    You can also see the netmask of each of these addresses and the broadcast address
    for the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Unusable IPv4 Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every block of IPv4 addresses reserves the first and last IP addresses for
    use by the network:'
  prefs: []
  type: TYPE_NORMAL
- en: The first IP address in a block is the *network address*, used for separating
    networks (and on primordial BSD systems, the broadcast address). On a /24 network,
    this would be an address ending in .0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last IP address in the block is the *broadcast address*. On a /24 network,
    the broadcast address ends in .255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to the IP specifications, every machine on a network is supposed
    to respond to a request to the broadcast address. Unfortunately, in the late 1990s,
    this feature was used as an attack technique: All you needed to do was ping the
    broadcast address on any given network, and you would have a list of all IP addresses
    currently in use. Consequently, this functionality is now disabled by default
    on most operating systems and network appliances.'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot assign the first or the last IP address in a network to a device
    without risking network problems. Some systems fail gracefully, others fail painfully,
    and a rare few make it work. Although OpenBSD won’t object if you use the top
    and bottom network addresses, prepare for mayhem the first time you plug in a
    commodity printer or other embedded device. It takes only one inflexible device
    to ruin your whole day.
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv4 Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quite a few blocks of IPv4 addresses are set aside for specific purposes. Although
    you don’t need to know all of them, there are two groups you’ll see pretty often.
    For a complete list of IPv4 subnets reserved for special purposes, read RFCs 5735
    and 6598.
  prefs: []
  type: TYPE_NORMAL
- en: Localhost
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The address range 127.0.0.1/8 is set aside for *localhost*, a machine’s address
    for itself. Every Unix-like system—and most other operating systems—attaches 127.0.0.1/8
    to a loopback interface. Everything knows that the localhost address is local
    to the specific machine. Packets to or from 127.0.0.0/8 should never cross the
    network; likewise, daemons bound only to 127.0.0.1 can be accessed on only the
    local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Private Networks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Internet standard RFC 1918 sets aside three networks for use on private networks
    and behind network address translation (NAT) devices: 10.0.0.0/8, 172.16.0.0/12,
    and 192.168.0.0/16\. While public IP addresses must be issued by an ISP, anyone
    can use addresses within these three blocks as long as those hosts are not directly
    exposed to the public Internet. If you have a network where hosts do not have
    access to the Internet, or if you provide Internet access through a proxy server
    or NAT, you can use an RFC 1918 network.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 Addressing Pitfalls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common wisdom dictates that each computer on a network is assigned a single
    IP address for each of its network interfaces. One computer, one network card,
    one IP address—simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: Not always. Some special-purpose interfaces (such as those dedicated to packet
    sniffing) function as intended without an IP address, and many operating systems
    will allow you to assign multiple IP addresses to a single network interface through
    a process called *aliasing*. You can also bond multiple physical cards into a
    single network interface, giving the computer one large virtual interface. While
    you might not deal with these configurations every day, keep them in mind when
    troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Addresses and Subnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a basic problem with IPv4: It provides only 4.29 billion addresses,
    and that’s just not enough. Without subnetting, that’s fewer than one address
    for every human being. Eventually, every person will have at least one IP-capable
    device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although IPv4 addresses haven’t run out yet, they’re becoming an increasingly
    scarce resource. Overly generous allocations in the early days, along with large
    chunks of address space reservations for special purposes, have accelerated exhaustion.
    The world is slowly grinding toward IPv4’s replacement: IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: Some parts of the world already use IPv6 extensively. Even if your network doesn’t
    use IPv6 today, one day you’ll need it—probably without warning. Prepare yourself
    now, or one day you’ll discover that you needed it the week before.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like IPv4, IPv6 is a network layer protocol. IPv4 uses 32-bit addresses, usually
    expressed as four groups of decimal numbers from 0 to 255 (for example, 192.0.2.13).
    IPv6 uses 128-bit addresses, expressed as six groups of four hexadecimal characters
    separated by colons (for example, 2001:db8:0:bad:c0de:cafe). A 128-bit address
    space gives enough IPv6 addresses for every atom in the Earth to have more than
    10 IP addresses. TCP, UDP, ICMP, and other protocols run atop it. IPv6 has its
    own layer 2 protocol, Neighbor Discovery, which replaces protocols such as Ethernet’s
    ARP.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you don’t need to relearn the basics of networking. Hosts
    still need an IP address and a default gateway, routers still use a routing table,
    and you can almost—*almost*—substitute an IPv6 address for an IPv4 address and
    watch everything work. A web server doesn’t care if it binds to port 80 on 192.0.2.13
    or on 2001:db8:a12a:bad:c0de:café. The server just accepts requests sent to it
    and responds appropriately. That said, software does need to change slightly,
    because our web server must be able to log connections from both IPv4 and IPv6
    addresses. These changes have wide-reaching repercussions, and we’ll be sorting
    out edge cases for the next decade. But, in general, once you understand the new
    rules for IPv6, all of your networking knowledge is applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IPv6 Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted, IPv6 addresses are 128 bits, expressed as six colon-delimited groups
    of four hexadecimal characters each. As with decimal IPv4 addresses, you don’t
    need to display leading zeros in each group. The address 2001:db8:0:bad:c0de:cafe
    could also be written as 2001:db8:0000:0bad:c0de:cafe, but just as we wouldn’t
    write 192.000.002.013, we strip out the leading zeros in an IPv6 address.^([[29](#ftn.id369078)])
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addresses often contain long strings of zeros. This had to do with subnetting,
    which I’ll describe later in this section. As of this writing, the IPv6 address
    of Sprint’s website is 2600:0:0:0:0:aaaa. When consecutive groups include only
    zeros, as in this address, they’re replaced with two colons (`::`). This IP address
    is usually displayed as 2600::aaaa. You can do this only once per address, however.
    You can’t, for example, have the address 2600::1::1, because it’s ambiguous. Does
    2600::1::1 represent 2600:0:0:1:0:1 or does it represent 2600:0:1:0:0:1? I don’t
    know, and neither does your server.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve probably seen a port number added to an IPv4 address, such as 192.0.2.13:80\.
    Using a colon to glue a port number to an IPv6 address would be confusing. The
    IPv6 address 2001:db8::bad:c0de:cafe:80 isn’t ambiguous, but if you read it quickly,
    you might miss the double colon and think this is an IP address ending in 80\.
    If you’re adding a port number to an IPv6 address, enclose the address in square
    brackets, as in [2001:db8::bad:c0de:cafe]:80.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing IPv6 Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `ifconfig(8)` to see all IPv6 addresses assigned on your machine. Here,
    I give `ifconfig` the name of my network card, `fxp0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines starting with `inet6` are my IPv6 addresses. This interface has been
    assigned two IPv6 addresses: `fe80::bad:c0de:cafe%fxp0` and `2001:db8::bad:c0de:cafe`.
    (Wait … where did that `%fxp0` come from? You’ll find out in [Link Local Addresses](ch11.html#link_local_addresses
    "Link Local Addresses"). For now, just nod and smile, and keep reading.)'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Subnets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike IPv4, where you can subnet at any bit, IPv6 is usually subnetted at colon
    boundaries. Colons appear every 16 bits, so the natural IPv6 subnets are /16,
    /32, /48, and /64\. Though IPv6 standards recommend using /64 as the smallest
    possible network, many carriers use /80, /96, and /112 networks for special purposes.
    (I’ve also seen people use subnets not divided at 16-bit boundaries. I won’t cover
    them, but don’t let your brain explode when you encounter a /51.) IPv6 subnets
    are always expressed as a slash, also known as a *prefix length*, so you won’t
    see a netmask of ffff:ffff:ffff:ffff::, as you might in IPv4.
  prefs: []
  type: TYPE_NORMAL
- en: ISPs are usually issued a /32 or a /48 subnet and are expected to issue end-user
    networks, such as the typical home network, a /64 network. If ISPs do issue /64
    subnets to their users, an end-user network will provide 264 IP addresses, or
    18,446,744,073,709,551,616 IP addresses. (This will suffice for any number of
    televisions, phones, refrigerators, water faucets, vacuums, and network-enabled
    tacos.)
  prefs: []
  type: TYPE_NORMAL
- en: When you subnet at 16-bit boundaries, each network has 65,536 subnets of the
    next smaller size. A /32 contains 65,536 /48 networks, and a /48 contains 65,536
    /64 networks.
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv6 Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like its predecessor, IPv6 reserves several blocks of addresses for special
    purposes. You don’t need to memorize all of these reserved addresses, but some
    will appear in daily use.
  prefs: []
  type: TYPE_NORMAL
- en: localhost
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'IPv6’s localhost address, ::1/128, works much like 127.0.0.1 in IPv4: It always
    refers to the local machine. In OpenBSD, ::1/128 is always assigned to the `lo0`
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Link Local Addresses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Addresses beginning with fe8*x*: (where *x* is variable) are local to their
    interface. Every link has such *link local* addresses that are valid only on a
    specific local network. Even if an IPv6 network has no router, the hosts on the
    local, directly attached network can find each other and communicate using these
    local addresses. These networks are always /64 subnets. You’ll see identical IPv6
    subnets on other interfaces and on networks completely disconnected from your
    network. That’s okay. These addresses are local to the link. For example, here’s
    a link local address on an OpenBSD machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The link local address of this interface is `fe80::bad:code:cafe`. The trailing
    `%fxp0` indicates that this address is local to the interface `fxp0` and isn’t
    usable on any other interface on the machine. If your machine has an interface
    `fxp1`, and a host on that network tries to reach the address fe80::bad:code:cafe,
    this machine will not respond. This particular address is valid only for the network
    attached to interface `fxp0`.
  prefs: []
  type: TYPE_NORMAL
- en: You might note that the link local address has a section in common with the
    public IPv6 address on this network. That’s because an autoconfigured IPv6 address
    is usually calculated from the interface’s physical address; it doesn’t matter
    whether that autoconfigured address is on a public address or a link local address.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning IPv6 Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPv6 clients can usually use autoconfiguration through *router discovery*, anIPv6
    protocol where routers announce their presence on the network and the legitimate
    addresses to clients. Unfortunately, IPv6 autoconfiguration does not support common
    Dynamic Host Configuration Protocol (DHCP) options, such as assigning a Domain
    Name Service (DNS) server, let alone the options used for diskless configuration.
    If you have configured a DNS server—even IPv4 servers accessible on a dual-stacked
    host—autoconfiguration works just fine. If you run an IPv6-only network, you must
    either set up an IPv6 DHCP server to provide DNS server information to clients
    or configure DNS servers manually.
  prefs: []
  type: TYPE_NORMAL
- en: Servers should not use IPv6 autoconfiguration. A server usually needs a static
    IP address, even in IPv6\. Similarly, routers cannot use autoconfiguration. If
    a host can forward packets, it requires a static IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: You can assign multiple IPv6 addresses to a single interface by using aliases,
    just as with IPv4.
  prefs: []
  type: TYPE_NORMAL
- en: In IPv6, a client on a /64 network can use autoconfiguration.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 autoconfiguration resembles a stripped-down DHCP service. The router broadcasts
    subnet and gateway information, and the hosts configure themselves to use it.
    Hosts on a network smaller than /64 must be manually configured.
  prefs: []
  type: TYPE_NORMAL
- en: Remedial TCP/IP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a simplified overview of how the IP system works, let’s look
    at a real network protocol in some depth. The dominant transport protocol on the
    Internet is the Transmission Control Protocol over Internet Protocol, or TCP/IP.
    Although TCP is a transport protocol and IP is a network protocol, the two are
    so tightly intertwined that they’re generally referred to as a single entity.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with ICMP, and proceed to UDP and TCP.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ICMP is used to transmit routing and availability messages across the network.
    Tools such as `ping(8)` and `traceroute(8)` use ICMP. ICMP includes all sorts
    of different protocols and tools.
  prefs: []
  type: TYPE_NORMAL
- en: While some people claim that you need to block ICMP for security purposes, those
    people don’t understand that ICMP is just as diverse as the better-understood
    transport protocols TCP and UDP. Proper IPv4 network performance requires large
    chunks of ICMPv4\. If you must block ICMPv4 for security reasons, do so selectively.
    For example, blocking source quench messages breaks path maximum transmission
    unit (MTU) discovery, which will steer you directly into a world of hurt. If you
    don’t understand that last sentence, don’t block ICMPv4.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 dies without ICMPv6, as IPv6 doesn’t support packet fragmentation, so never
    block ICMPv6\. If you don’t know what packet fragmentation is, just trust me on
    this.^([[30](#ftn.id453475)])
  prefs: []
  type: TYPE_NORMAL
- en: UDP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UDP is the most bare-bones data-transfer protocol that runs over IP. It offers
    no error handling, minimal integrity verification, and no defense whatsoever against
    data loss. The transport protocol considers each packet of UDP completely self-contained;
    there are no data-coherence checks at the protocol layer. Despite these drawbacks,
    UDP can be a good choice for particular sorts of data transfer, and many vital
    Internet services rely on it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This discussion covers both UDPv4 and UDPv6\. While each runs over only the
    corresponding network protocol, they behave identically otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: UDP is also a datagram protocol, meaning that each network transmission is complete
    and self-contained, and received as a single integral unit. While the application
    might not consider a single UDP packet a complete request, the network does.
  prefs: []
  type: TYPE_NORMAL
- en: When a host transmits data via UDP, it has no way of knowing if the data ever
    reaches its destination. Programs that receive UDP data just listen to the network
    and accept whatever happens to arrive. When a program receives data via UDP, it
    cannot verify the source of that data. Although each UDP packet does include a
    source address, this address is easily faked. Each UDP packet includes a checksum
    for the packet, but there’s no integrity checking for the data stream as a whole.
    This is why UDP is called *connectionless*, or *stateless*.
  prefs: []
  type: TYPE_NORMAL
- en: No integrity checking, no guard against data loss, the potential for faked packets—all
    this sounds pretty unreliable. So why use UDP at all?
  prefs: []
  type: TYPE_NORMAL
- en: UDP-based applications often have their own error-correction methods or otherwise
    don’t mesh well with more reliable protocols, such as TCP. For example, simple
    client DNS queries must time out within just a few seconds or users will whine
    uncontrollably. TCP connections time out only after two minutes. DNS requires
    quick failures and only a single packet per transaction, which makes UDP a better
    choice than TCP for simple DNS queries. Real-time streaming services, such as
    video conferencing applications, also use UDP. (After all, if a few pixels go
    missing during a video conference, you don’t want those pixels a minute later.)
    Most other UDP-based applications use UDP for similar reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Because the UDP protocol itself doesn’t return anything when you connect to
    a port, there’s no reliable way to remotely test if a UDP port is reachable (although
    tools such as `nmap` try to do so).
  prefs: []
  type: TYPE_NORMAL
- en: If you want a protocol that responds at the network layer, look at TCP.
  prefs: []
  type: TYPE_NORMAL
- en: TCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TCP includes nifty features, such as error correction and recovery. The receiver
    must acknowledge every packet it gets; otherwise, the sender retransmits any unacknowledged
    packets. Unlike UDP, applications that use TCP can expect reliable data transmission.
    This makes TCP a *connected*, or *stateful*, protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This discussion covers both TCPv6 and TCPv4\. While they differ because of their
    underlying transport protocol, they behave in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: TCP is also a *streaming protocol*, which means that a single request can be
    split among several network packets. While the sender might transmit several chunks
    of data one after the other, that data might arrive out of order or fragmented.
    The recipient must track these chunks and assemble them properly to complete the
    network transaction.
  prefs: []
  type: TYPE_NORMAL
- en: For hosts to exchange TCP data, they must set up a channel for that data to
    flow across. One host requests a connection, the other host responds to the request,
    and then the first host starts transmitting. This setup process is known as the
    *three-way handshake*. Similarly, once transmission is complete, the systems must
    do a certain amount of work to tear down the connections.
  prefs: []
  type: TYPE_NORMAL
- en: To test if a TCP port is open, you can use `telnet(1)` or `nc(1)` to connect
    to the port. Here, I see if I can connect to port 22 on the host `caddis`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I connect to the remote port and see information displayed by the port, use
    the telnet escape character **`^]`** (CTRL-]) to disconnect **1**, and enter **`c`**
    **2** to close telnet.
  prefs: []
  type: TYPE_NORMAL
- en: TCP is commonly used by applications most suited to its fairly generic set of
    timeouts and transmission features, such as email programs, FTP clients, and web
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: How Protocols Fit Together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can compare the network stack to sitting with your family at a holiday dinner.
    The datalink layer (ARP, in the case of Ethernet) lets you see everyone else at
    the table. IP gives every person at the table their own unique chair (except for
    the twins using piano bench NAT). ICMP provides basic, lower-layer information
    such as “The quickest way to the baked sweet potatoes is to get Uncle Mike to
    pass them”?^([[31](#ftn.id324463)]) or “Aunt Liz can’t lift the ham platter.”
    TCP is where you hand someone the butter and the other person must say “thanks”
    before you let it go. UDP is like tossing a roll at Grandma Lucas; she might catch
    it or it might bounce off her forehead.
  prefs: []
  type: TYPE_NORMAL
- en: Transport Protocol Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transport protocol ports permit one server to serve many different services
    over a single transport protocol, multiplexing connections between machines. When
    a network server starts, it attaches, or *binds*, to one or more logical ports.
    A logical port is just an arbitrary number ranging from 0 to 65536, although nothing
    uses port 0\. For example, Internet mail servers often bind to port 25.
  prefs: []
  type: TYPE_NORMAL
- en: Each TCP or UDP packet arriving at a system carries a field containing its desired
    destination port number. If an incoming packet asks for port 25, it is connected
    to the mail server running on that port. This means that other programs can run
    on other ports, clients can talk to those different ports, and no one gets confused
    except you.
  prefs: []
  type: TYPE_NORMAL
- en: Note that port assignments are not some sort of physical constant, but rather
    are mutually agreed upon. There’s no reason that email services should run on
    port 25 other than the fact that everyone agrees that they should. If someone
    tries to send you email, their mail server will automatically connect to port
    25 on your server. If you run email on port 80 and have a web server on port 25,
    you’ll never get your email, and your web server won’t get much traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file */etc/services* contains a list of port numbers and the associated
    services. The file has a very simple, five-column format, as shown in these two
    sample lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first field is the name of the service assigned to this port. This entry
    is for the service `www`. Port 80 is assigned to `www`, both TCP and UDP. Then
    there’s a list of any other names assigned to this port. Port 80 is also known
    as `http`. Finally, there’s a comment that gives more detail about the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP protocol used on the Web runs over TCP, so why is UDP port 80 also
    reserved for HTTP? The answer is pretty simple: Computer people are easily confused.
    Having two services share the same port number but run on different protocols
    confuses people—for example, the `syslog` service runs on port 514 via UDP, and
    the `lpr` printer protocol runs on port 514 over TCP.^([[32](#ftn.id322914)])'
  prefs: []
  type: TYPE_NORMAL
- en: Some server programs read */etc/services* to learn which port to bind to on
    startup, and many client programs read */etc/services* to learn which port they
    should try to connect to. If you run servers on unusual ports, you might need
    to edit this file to get these programs to attach where needed.
  prefs: []
  type: TYPE_NORMAL
- en: As with all standards, there are times you will want to break the rules. The
    SSH daemon `sshd` normally binds to port 22/TCP, but I’ve run it on ports 23 (`telnet`),
    80 (`www`), 443 (`https`), and others to evade naïve packet-filtering firewalls.
    You will find your own reasons to break the standards. That’s fine, as long as
    you understand what you’re doing and how it affects others.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ports below 1024 in both TCP and UDP can be opened only by the root user. These
    ports are assigned (mostly) to core Internet infrastructure protocols, such as
    DNS, SSH, HTTP, LDAP, and so on—services that only a few select hosts on each
    network should offer. Only programs with root-level privileges can bind to reserved
    ports. For example, a user can run a game server on a high-numbered port if the
    system policy allows, but that’s different from setting up a web page visible
    to the whole world that claims the machine’s official purpose is a game server.
    The port assignment for these core protocols is generally permanent, and if you
    want to interoperate with other sites, you won’t change them.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD software usually binds to a reserved port as root and then drops privileges,
    performing the rest of its functions as an unprivileged user. These unprivileged
    users, discussed in [Chapter 6](ch06.html "Chapter 6. User Management"), have
    even fewer privileges than a normal user account.
  prefs: []
  type: TYPE_NORMAL
- en: If you must run a service that binds to a reserved port, and it can run only
    as root, consider carefully whether you actually need it. Try to find an alternative
    server that does privilege separation. If you can’t, at least install that service
    on a dedicated machine to reduce its threat to other services on your network.
  prefs: []
  type: TYPE_NORMAL
- en: Which Ports Are Open?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, network services are made available via TCP or UDP ports. Programs bind
    to ports to offer network services. This brings up two obvious questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which ports are open?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What programs are listening to each port?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can answer these questions with `netstat(1)` and `fstat(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Using netstat
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `netstat(1)` program provides general visibility into the network stack.
    Use `netstat` to check your routing table, examine open sockets, see how many
    packets are traversing your interfaces, and so on. (I could write an entire book
    about `netstat`, but no one would buy it. Instead, I’ll sprinkle bits of `netstat`
    magic throughout this book.)
  prefs: []
  type: TYPE_NORMAL
- en: When looking at network information, I recommend turning off DNS lookups by
    using the `-n` flag. You can always rerun a check with DNS turned on, but adding
    DNS queries to the network sockets can sometimes skew the information you’re viewing,
    and almost always slows the command.
  prefs: []
  type: TYPE_NORMAL
- en: The `-f` argument lets you choose a protocol family to display. Use `-f inet`
    to see only IPv4 sockets, or `-f inet6` to see only IPv6\. Read `netstat(1)` for
    the full protocol list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `-a` tells `netstat` to show all sockets opened by any process, rather
    than just sockets owned by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put all those options together and have a look at the output. Here, I
    show the open IPv4 sockets on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The list starts with open TCP ports **1**. The `Recv-Q` and `Send-Q` columns
    **2** show the number of bytes that the system is in the process of receiving
    or trying to send.
  prefs: []
  type: TYPE_NORMAL
- en: The `Local Address` column shows the IP address attached to the local machine
    where this socket is listening. It’s possible—common, even—for a service to bind
    to a port on only a single address on a machine. If the port is part of an actual
    connection, as the first example **3** shows, the IP address is followed by the
    port number. This particular TCP connection is attached to port 22 at the address
    192.0.2.135\. Port 22 is reserved for SSH, so this is probably an SSH connection.
  prefs: []
  type: TYPE_NORMAL
- en: If the local address is an asterisk followed by a port number **8**, this is
    a wildcard bind. A program has bound to this port, and has asked the kernel to
    figure out the IP address. It’s probably (but not necessarily) a listening socket.
  prefs: []
  type: TYPE_NORMAL
- en: The `Foreign Address` column **4** shows the IP address and port of the remote
    host involved in a connection. If there’s a foreign address shown, it always includes
    the port. If this column shows two asterisks **6**, that means the service is
    waiting for a connection on the local port.
  prefs: []
  type: TYPE_NORMAL
- en: The `(state)` column applies only to TCP connections. A live and working TCP
    connection is in the `ESTABLISHED` state **5**. Other states (`SYN_RCVD`, `ACK`,
    and `SYN+ACK`) are all normal parts of connection creation, while `LAST_ACK`,
    `FIN_WAIT_1`, and `FIN_WAIT_2` mean that the connection is closing. A state of
    `LISTEN` **7** means that this socket is waiting for an incoming connection.
  prefs: []
  type: TYPE_NORMAL
- en: UDP ports are given their own section **9**. You might see remote hosts in the
    UDP section, especially for long-running protocols such as NFS and NTP, but remember
    that UDP is stateless, so you’ll never see state on a UDP connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in only TCP or UDP sockets, you can use the `-p` flag
    to show only a particular protocol. Here, I look at TCP sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While this looks similar to the first output example, note that we see both
    IPv4 and IPv6 TCP connections and services. TCP runs over both IPv4 and IPv6,
    so choosing it shows both address families. It’s entirely possible to have a service
    running on one address family and not the other. Many of my systems listen for
    incoming SSH connections only on IPv6; doing so hides me from port scanners and
    worms (for now, anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than listing every service waiting for an incoming connection, you can
    show only live connections by dropping the `-a` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using fstat
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know which TCP and UDP ports are open, how can you tell which programs
    are listening on them? OpenBSD includes `fstat(1)`, a program that displays all
    open files and sockets on the system. Network connections are open sockets. Running
    `fstat` on an idle system can generate hundreds of lines of output—one entry for
    each file opened by any process. While that’s educational and useful, it’s not
    what we’re looking for. Specifically, we want to see which programs are holding
    network sockets open. The string `internet` indicates network sockets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, you see an `sshd` process owned by the user `mwlucas`. That’s an unprivileged
    process, tied to a particular SSH session. Further down the list, you see an SSH
    daemon owned by root listening to the network. When a connection request arrives,
    the root-owned SSH daemon will hand it off to an unprivileged child process. You
    can also see that we have a variety of `sendmail` processes listening to the network.
  prefs: []
  type: TYPE_NORMAL
- en: This system runs the expected SSH and email servers, and no one has bound anything
    to odd ports. My nasty paranoid suspicions were unfounded (this time, anyway).
  prefs: []
  type: TYPE_NORMAL
- en: Between `netstat` and `fstat`, you should be able to get a good idea of what
    your system is doing on your network at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: IP Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most sysadmins don’t need to understand much about IP routing, because most
    servers have only one network interface and one default gateway. The network administrator
    gives you an IPv4 address and a default route, you put them in the appropriate
    configuration files, and you’re routed. You don’t need even that for most IPv6
    hosts, as autoconfiguration makes things magically work. Servers will need a static
    IPv6 address and a manual default route.
  prefs: []
  type: TYPE_NORMAL
- en: Some servers have multiple interfaces, such as one to their default gateway
    and another to a group of related application or backup servers. OpenBSD systems
    frequently wind up in the network infrastructure, however, or sit in demilitarized
    zones (DMZs) where the server must make routing decisions. If you want to use
    OpenBSD in such an environment, or as a firewall, you must understand the basics
    of routing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Routing* is simply deciding where to send packets. If your system is attached
    to a network, it doesn’t need to make any decisions; it just sends the packet
    to that network. Your system on 192.0.2.0/24 already knows how to reach any IP
    address beginning with 192.0.2—it can just send everything out to the local Ethernet.
    Where does it send those packets?'
  prefs: []
  type: TYPE_NORMAL
- en: Most computers use a *default route*, which is an IP address on the local network
    where they send all packets bound for nonlocal IP addresses. This is very common
    where one router or firewall provides all network access. This device probably
    also has a default route that points to your ISP, which makes all the complicated
    routing decisions for you.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, you might have a dynamic routing protocol running on your network.
    If you’re using Open Shortest Path First (OSPF), Border Gateway Protocol (BGP),
    or Routing Information Protocol (RIP), OpenBSD has daemons specifically for integrating
    these protocols. There’s an introductory middle ground between full dynamic routing
    and simple default routes, however, and you should understand it before attempting
    full dynamic routing.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover a simple case here using an IPv4 example. (IPv6 routing is exactly
    like IPv4 routing, but with a lot more colons.)
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 Routed Network Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a network has multiple gateways leading to different networks, hosts on
    the network must make routing decisions. Suppose your network has multiple routers
    attached to it, each going to a different network. Machines on your network decide
    where to send packets. Here’s an example of a common double-firewall situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1616080.png)'
  prefs: []
  type: TYPE_IMG
- en: In this network design, hosts must transit a DMZ before entering either the
    Internet or the internal network. (Other designs exist, such as the hub-and-spoke
    model, but I’ve specifically chosen a design where routing is needed.)
  prefs: []
  type: TYPE_NORMAL
- en: The external firewall provides one layer of protection. It permits only traffic
    specifically deemed necessary (we’ll go into the default deny stance in [Chapter 21](ch21.html
    "Chapter 21. Packet Filtering")). It does, however, permit incoming connections
    to hosts in your DMZ.
  prefs: []
  type: TYPE_NORMAL
- en: The hosts in the DMZ are to some extent vulnerable. They are not trusted enough
    to be on the internal network. Your intrusion-detection systems or your web servers
    might live here.
  prefs: []
  type: TYPE_NORMAL
- en: The internal firewall, like the external firewall, permits only traffic deemed
    necessary to organization purposes. It probably doesn’t allow any connections
    from the outside world, however, and it doesn’t trust the hosts on the DMZ.
  prefs: []
  type: TYPE_NORMAL
- en: Only highly trusted hosts are permitted on the internal network. This is where
    the organization keeps its most precious data, such as the financial records,
    customer databases, and movie collections.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the hosts in this network need to make only very simple routing decisions.
    Anything on the internal network has just one way to reach anything, and any host
    on the Internet has only one way to reach the internal or DMZ networks.
  prefs: []
  type: TYPE_NORMAL
- en: The external firewall is directly attached to the DMZ network, so it can send
    packets to those hosts. It needs a default route pointing to the Internet so it
    can reach the rest of the world. To reach the hosts on the internal network, it
    must send packets to the internal firewall’s external interface. If you don’t
    configure this on the external firewall, data will never reach the internal firewall.
    Because the external firewall is responsible for the internal network’s Internet
    access, losing this route would disconnect the internal network from the Internet;
    internal systems could send packets, but would never receive any. The external
    firewall needs routing.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you could configure routing on each host inside the DMZ. In that
    case, ICMP redirects from the firewalls would provide routing for these hosts,
    but trusting ICMP redirects on a vulnerable network is unwise and messy because
    it assumes that every host on the DMZ and every firewall accepts and sends ICMP
    redirects. If you’re using OpenBSD, you want your server to be secure, so configure
    routing on your DMZ systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I configure routing for the external firewall. Configuring
    routing for the DMZ hosts is nearly identical to this example.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Routing with route(8)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `route(8)` command manages all system routing. Like `netstat`, `route` has
    several subfunctions that allow you to view, edit, and monitor the system routing
    table. While the `route(8)` man page has complete details, the ability to view,
    add, and delete routes should be enough to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Routes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenBSD, like any other network device, keeps routes in a routing table. To
    view the IPv4 and IPv6 routes, enter **`route show`**. Add **`-n`** to remove
    IP-address-to-name translations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the IPv4 routing table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The table shows the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Destination` field lists the range of IP addresses this route applies to—destination
    addresses. The `default` entry indicates the default gateway, which is where the
    system sends all packets that have no specific route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Gateway` field tells where packets for this route should be sent. A gateway
    could be a hostname, an IP address, or a network interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Flags` field contains markers that indicate what sort of route this is
    and how it behaves. The next section covers the various route flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Refs` field shows the number of references to the route in the kernel (also
    known as the *refcounter*). If the refcounter drops to zero, the route is removed.
    This has no practical use for system administration, because one reference is
    sufficient to keep the route in the routing table; additional references don’t
    change anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Use` counter increments each time a packet uses that route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mtu` is the MTU—the largest frame size that can travel over this route.
    If the field contains a hyphen (`-`), OpenBSD uses the MTU of the underlying physical
    interface. The loopback interface, `lo0`, isn’t a physical interface, so OpenBSD
    explicitly sets the MTU very high. You might see a route with a lower MTU if Path
    MTU Discovery has kicked in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Prio` field gives the route priority. OpenBSD supports multiple routes
    to a single destination. Some routes are more desirable than others, and OpenBSD
    will use the route with the lowest priority number. Routes provided by dynamic
    routing protocols, such as BGP or OSPF, get higher priority numbers than static
    routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Iface` field shows which interface this route uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD also includes dynamic routing daemons such as `ospfd(8)` and `bgpd(8)`.
    I don’t cover them here, because that topic would fill a book on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what’s interesting in the routes in this sample. The first entry at
    **1** is the system default route. If there is no more specific route, packets
    will be sent to the IP address 192.0.2.1.
  prefs: []
  type: TYPE_NORMAL
- en: To reach the network 127.0.0.0/8 at **2**, packets should go to the IP address
    127.0.0.1\. 127.0.0.0/8 is the address range reserved for loopback addresses,
    and 127.0.0.1 is always the local machine. Notice the high MTU; this is a software
    interface, so there’s no physical limit on the size of frames sent through it.
  prefs: []
  type: TYPE_NORMAL
- en: To reach the IP address 127.0.0.1 at **3**, send the packets to the IP address
    127.0.0.1\. This might seem a bit pedantic, but it’s a valid route and needs to
    be in the table. Remember that 127.0.0.1 is always the loopback address of the
    local machine.
  prefs: []
  type: TYPE_NORMAL
- en: To reach the IP address 192.0.2.0/24 at **4**, use a gateway of `link#1`. This
    is a local physical interface—in this case, our Ethernet interface. The interface
    named `link#1` is actually the interface with index `#1`, which isn’t really exposed
    to the system administrator anywhere else. These addresses are local to the machine,
    and you must figure out which interface this is by the IP address attached to
    the machine. Addresses local to the machine don’t actually need to be in the routing
    table, but no one has bothered to remove this historical nit.
  prefs: []
  type: TYPE_NORMAL
- en: To reach a specific IP address on the local network at **5**, you’ll get a route
    of the IP address and the physical media address. Because this host is connected
    via Ethernet, the gateway is a MAC address. Every local address that the system
    needs to find gets a route entry, and you should almost always show a specific
    route for the default gateway.
  prefs: []
  type: TYPE_NORMAL
- en: The last route at **6** is for the multicast address range 224/8\. If you’re
    not using multicast, it should go to the local host.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multicast is a complicated topic beyond the scope of this book (again). But
    if you’re interested, OpenBSD supports multicast just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Route Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Flags` column of the routing table indicates how routes are generated
    or used. `netstat(1)` contains a complete list of route flags. [Table 11-2](ch11.html#common_route_flags
    "Table 11-2. Table 11-2: Common Route Flags") lists the common ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11-2. Table 11-2: Common Route Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | This route was cloned. |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | This is a protocol-specific route (such as to an Ethernet MAC address).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | This route is dynamic. |'
  prefs: []
  type: TYPE_TB
- en: '| `G` | This route goes via a gateway. |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | This route is for a specific host. |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | This route is for the local link layer. |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | This route was modified. |'
  prefs: []
  type: TYPE_TB
- en: '| `R` | This is a reject route. Packets are dropped, and an error is sent.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | This is a blackhole route. Packets are dropped silently. |'
  prefs: []
  type: TYPE_TB
- en: These flags tell you where a route came from and how it’s used.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Routes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add routes with the `route add` command. You must know the destination network,
    its netmask, and the gateway.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example network, the outer firewall needs a route to reach the private
    network, 192.0.2.128/25\. To route this network to the inner firewall at 192.0.2.2,
    run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Packets will use that route immediately. If you run `route show`, you’ll see
    that new route.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a default route, run `route add default` with the IP address of the
    default gateway, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To add routes automatically at boot, put the `route` statement in the */etc/hostname.if*
    file that leads to the destination network. These routes appear when the interface
    is brought up, before */etc/rc.securelevel* runs or any local daemons start. You’ll
    see examples of using *hostname.if* for routes in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To add a default route automatically at boot, put the default router IP address
    in */etc/mygate*.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Routes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To delete a routing table entry, use `route delete` with the network address
    and netmask.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove the route added in the previous example, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You should now have a decent idea of how routing works.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how things are supposed to fit together, let’s see how to
    configure Ethernet networks.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[27](#id460204)]) You laugh, but the technical reviewer for this book was
    part of the first IP-over-carrier-pigeon implementation team that tackled the
    practical tests as specified in RFC 1149\. That’s how I knew he had the time to
    review this book in excruciating detail. (If that’s how he spends his time, he
    couldn’t very well claim he was too busy, now could he?)
  prefs: []
  type: TYPE_NORMAL
- en: ^([[28](#id433870)]) I never do take pity on my readers; I just don’t want you
    to actually *say* so.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[29](#id369078)]) Some operating systems treat addresses containing numbers
    that begin with 0 as octal. Don’t actually use addresses like 192.000.002.013,
    or you might get a base-8 surprise.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#id453475)]) Or you can go look it up. Whatever—you not believing me
    won’t hurt my feelings.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[31](#id324463)]) For the record, Uncle Mike’s security policy prevents him
    from passing baked sweet potatoes. If you want them, you’re going to have to take
    them by force.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#id322914)]) I used to count how many people confused 514/tcp and 514/udp,
    but the number got so high that I got depressed, so I stopped.
  prefs: []
  type: TYPE_NORMAL
