- en: Chapter 11. Overview of TCP/IP
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章. TCP/IP概述
- en: '*IP version 6:*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv6:*'
- en: '*All the pain of version 4,*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*版本4的所有痛苦，*'
- en: '*plus brand-new problems!*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*再加上全新的问题！*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Securing a computer
    is easy: Disconnect it from all networks, remove all input and output, and lock
    it in a bunker. Oh, wait—did you want the system to *do* something? Then you’ll
    probably want to connect your system to the Internet.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](httpatomoreillycomsourcenostarchimages1616079.png) 保护计算机很简单：将其从所有网络断开，移除所有输入和输出，并将其锁在地下掩体中。哦，等等——你想要系统*做*些什么吗？那么你可能想要将你的系统连接到互联网。'
- en: Many system administrators have a vague familiarity with the basics of networking,
    but to be a truly competent sysadmin, you need a real understanding of how everything
    fits together. You don’t need to know when to use rapid spanning trees, how to
    choose between BGP and OSPF, or even what those acronyms represent. But you must
    know what an IP address is, how a netmask works, how port numbers differ from
    protocol numbers, and why you cannot use `telnet(1)` to test UDP connectivity.
    Without this basic knowledge, you’ll fumble. Read this chapter and understand
    it, and you’ll have an easier time convincing your network administrator to give
    you what you need.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统管理员对网络的基本知识有模糊的了解，但要成为一个真正合格的系统管理员，你需要真正理解一切是如何相互关联的。你不需要知道何时使用快速生成树，如何选择BGP和OSPF之间的区别，甚至这些缩写代表什么。但你必须知道IP地址是什么，子网掩码是如何工作的，端口号与协议号有何不同，以及为什么不能使用`telnet(1)`来测试UDP连接性。没有这些基本知识，你会感到迷茫。阅读本章并理解它，你将更容易说服你的网络管理员给你你需要的东西。
- en: While this chapter offers an overview of TCP/IP, it doesn’t cover the innumerable
    details, caveats, annoyances, peccadilloes, and blatant outrages present in the
    protocol. If you find that you need to torture yourself with the finer points
    of TCP/IP, pick up one of the big, thick books on the subject. *The TCP/IP Guide*
    by Charles M. Kozierok (No Starch Press, 2005) is an excellent place to start.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章提供了TCP/IP的概述，但它并没有涵盖协议中存在的无数细节、警告、烦恼、小缺点和明显的冒犯。如果你发现自己需要深入研究TCP/IP的细微之处，可以挑选一本关于这个主题的大厚书。查尔斯·M·科齐罗克的《TCP/IP指南》（No
    Starch Press，2005年）是一个很好的起点。
- en: This chapter covers both TCP/IP version 4 (the Internet protocol widely used
    for the last 30-odd years) and the new version of the protocol, TCP/IP version
    6\. Despite the different version numbers, the two protocols are more similar
    than not.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了TCP/IP版本4（过去30多年广泛使用的互联网协议）和协议的新版本，TCP/IP版本6。尽管版本号不同，但这两个协议的相似之处更多。
- en: We’ll start with the layers of the network and then delve into how the protocols
    work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网络层开始，然后深入探讨协议是如何工作的。
- en: Network Layers
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络层
- en: The network protocol is divided into several layers. Each layer handles a specific
    task and interacts only with the layers immediately above and below it. At first,
    you might laugh at the idea that this layer model simplifies the network process,
    but it really does. The important thing to remember right now is that each layer
    communicates with only the layer directly above it and the layer directly beneath
    it (theoretically, anyway).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议被分为几个层次。每一层处理特定的任务，并且只与直接位于其上方和下方的层交互。一开始，你可能会嘲笑这种层模型简化了网络过程的想法，但事实确实如此。现在要记住的重要事情是，每一层只与直接位于其上方的层和直接位于其下方的层（理论上是这样）进行通信。
- en: 'The classic Open Systems Interconnection (OSI) network protocol stack represents
    the network as seven layers. It’s an exhaustively complete model and covers almost
    any situation using any network protocol and any application. Because the Internet
    is a very specific type of network, and because this isn’t a book about networking
    or networked applications in general, I’ll limit my discussion of TCP/IP to four
    specific layers of the network: physical, datalink, network, and transport. Don’t
    worry—these four layers cover the Internet and (almost) all corporate networks.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的开放式系统互联（OSI）网络协议栈将网络表示为七层。这是一个详尽的完整模型，涵盖了几乎任何使用任何网络协议和任何应用程序的情况。因为互联网是一种非常特定的网络类型，而且这本书不是关于网络或网络应用的通用书籍，所以我将把TCP/IP的讨论限制在网络的四个特定层次：物理层、数据链路层、网络层和传输层。不用担心——这四层涵盖了互联网和（几乎）所有企业网络。
- en: The Physical Layer
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理层
- en: Whether it’s copper or fiber-optic cable, or even radio waves, physical wire
    is a layer of the network. Without some physical media to run over, a network
    cannot function. Everything from the CAT5 cable plugged into your desktop to the
    fiber-optic cable connecting you to Asia is part of the physical layer. If it
    can be tripped over, backhoed, or interfered with, it’s part of the physical layer.
    For simplicity’s sake, I’ll refer to the physical layer as the *wire*, although
    it can take innumerable forms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是铜线还是光纤电缆，甚至是无线电波，物理线缆都是网络的一部分。如果没有某种物理媒体来运行，网络就无法工作。从插入你桌面的CAT5电缆到连接你到亚洲的光纤电缆，所有这些都属于物理层。如果可以被绊倒、被挖掘或受到干扰，那么它就是物理层的一部分。为了简化起见，我将物理层称为*线缆*，尽管它可以有无数的形式。
- en: This is the easiest layer to understand. If your wire meets the requirements
    of the physical protocol, you’re in business. If not, your network won’t work.
    One of the functions of Internet routers is to connect one sort of physical layer
    to another—for example, converting local Ethernet into an OC3 fiber connection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最容易理解的一层。如果你的线缆符合物理协议的要求，那么你的网络就可以正常工作。如果不满足，你的网络将无法工作。互联网路由器的一项功能是将一种物理层连接到另一种物理层——例如，将本地以太网转换为OC3光纤连接。
- en: The physical layer has no decision-making abilities of its own; everything that
    runs over it is dictated by the datalink layer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层本身没有决策能力；所有在其上运行的内容都由数据链路层决定。
- en: The Datalink Layer
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据链路层
- en: 'The datalink layer is the protocol that runs over the physical wire. It transforms
    information into the actual signals that are sent over the physical layer, using
    the appropriate encoding for that physical media, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层是在物理线路上运行的协议。它将信息转换成实际信号，这些信号通过物理层发送，使用适合该物理媒体的适当编码，如下所示：
- en: Both Ethernet and Switched Multimegabit Data Service (SMDS) use Media Access
    Control (MAC) addresses and the Address Resolution Protocol (ARP).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网和交换式多兆比特数据服务（SMDS）都使用媒体访问控制（MAC）地址和地址解析协议（ARP）。
- en: IPv6 over Ethernet uses Neighbor Discovery (ND).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网上的IPv6使用邻居发现（ND）。
- en: Dial-up and wide area networks (WANs) use either the Point-to-Point Protocol
    (PPP) or High-Level Data Link Control (HDLC).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拨号和广域网（WANs）使用点对点协议（PPP）或高级数据链路控制（HDLC）。
- en: OpenBSD supports other common datalink protocols, such as PPP over Ethernet
    (PPPoE). If you have unusual network requirements, check the OpenBSD website,
    mailing lists, or man pages to see if those requirements are supported.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD支持其他常见的链路层协议，如以太网上的PPP（PPPoE）。如果你有特殊的网络需求，请检查OpenBSD网站、邮件列表或man页面，看看这些需求是否得到支持。
- en: 'Some datalink layers have been implemented over many different physical layers.
    Ethernet, for example, has been implemented over twinax, coax, CAT3, CAT5, CAT6,
    CAT7, optical fiber, and radio waves. And for true device independence, we have
    seen TCP/IP implemented with a biological transport layer: carrier pigeon.^([[27](#ftn.id460204)])'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据链路层已经在许多不同的物理层上实现。例如，以太网已经在双绞线、同轴电缆、CAT3、CAT5、CAT6、CAT7、光纤和无线电波上实现。为了实现真正的设备独立性，我们已经看到TCP/IP与一个生物传输层一起实现：信鸽。[^([27](#ftn.id460204))]
- en: With minor changes to the device drivers, the datalink layer can address any
    sort of physical layer. This is one of the ways in which layers simplify the network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对设备驱动程序进行少量修改，数据链路层可以处理任何类型的物理层。这是层简化网络的一种方式。
- en: '[Chapter 12](ch12.html "Chapter 12. Connecting to the Network") discusses Ethernet
    in detail, as it’s the most common network type for OpenBSD systems. Once you
    understand how Ethernet works, you’ll have no difficulty adding new datalink protocols
    as needed.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。连接到网络")详细讨论了以太网，因为它是OpenBSD系统中最常见的网络类型。一旦你了解了以太网的工作原理，你将不会在需要时添加新的数据链路协议时遇到困难。'
- en: The datalink layer exchanges information with the physical layer and the network
    layer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层与物理层和网络层交换信息。
- en: The Network Layer
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络层
- en: The network layer is the part that maps connectivity between network nodes,
    answering questions like “Where are other hosts?” and “Can I get there from here?”
    This logical protocol provides a consistent interface to programs that run over
    the network, no matter what the physical and datalink layers look like.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层是映射网络节点之间连接的部分，回答诸如“其他主机在哪里？”和“我能从这里到达那里吗？”等问题。这种逻辑协议为在网络中运行的程序提供了一个一致的接口，无论物理和链路层看起来如何。
- en: The network layer used on the Internet is the Internet Protocol, or IP. Both
    version 4 (IPv4) and version 6 (IPv6) provide each host with one or more unique
    *IP addresses*, so that any other host on the network can find it. Okay, IPv4
    network address translation munges the whole “unique address” rule, but your network
    still has a unique IP address somewhere.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上使用的网络层协议是互联网协议，或IP。版本4（IPv4）和版本6（IPv6）为每个主机提供一个或多个唯一的 *IP地址*，以便网络上的任何其他主机都可以找到它。好吧，IPv4网络地址转换破坏了“唯一地址”规则，但你的网络仍然在某处有一个唯一的IP地址。
- en: The network layer talks to the datalink layer below it and the transport layer
    above it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层与其下方的链路层和上方的传输层进行通信。
- en: The Transport Layer
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: The transport layer is where actual data flows. The three most common transport
    layer protocols are the Internet Control Message Protocol (ICMP), Transmission
    Control Protocol (TCP), and User Datagram Protocol (UDP).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层是实际数据流动的地方。最常用的三种传输层协议是互联网控制消息协议（ICMP）、传输控制协议（TCP）和用户数据报协议（UDP）。
- en: ICMP passes basic connectivity messages between hosts with IP addresses. If
    IP provides a road and addresses, ICMP provides traffic lights and highway exit
    signs. Most of the time, ICMP runs silently in the background.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP在具有IP地址的主机之间传递基本的连通性消息。如果IP提供道路和地址，ICMP则提供交通灯和高速公路出口标志。大多数时候，ICMP在后台默默运行。
- en: UDP and TCP are the protocols that carry actual data between hosts, and they
    are so prevalent that the suite of Internet protocols is usually called TCP/IP.
    UDP is a bare-bones transport protocol, offering the minimum services needed to
    transfer data over the network. Its minimalism means that if you want to customize
    exactly how data flows in your application, you can build it out of valid UDP.
    TCP provides more sophisticated features, such as integrity checking and congestion
    control, but many of its settings are hard-coded.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: UDP和TCP是携带主机之间实际数据的协议，它们如此普遍，以至于整个互联网协议套件通常被称为TCP/IP。UDP是一个基本的传输协议，提供在网络上传输数据所需的最少服务。它的简约性意味着，如果你想精确地定制应用程序中数据的流动方式，你可以使用有效的UDP构建它。TCP提供了更复杂的功能，如完整性检查和拥塞控制，但许多设置都是硬编码的。
- en: In addition to these three, many other protocols run at the transport layer.
    The file */etc/protocols* contains a fairly comprehensive list of transport protocols
    built atop IP. While it lists many more protocols than you will ever actually
    deal with out in the wild, it doesn’t include non-IP protocols like IPX/SPX or
    Digital Equipment Company’s DECnet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个之外，还有许多其他协议在传输层运行。文件 */etc/protocols* 包含了一个相当全面的传输协议列表，这些协议建立在IP之上。虽然它列出了你实际上在野外可能遇到的许多更多协议，但它不包括IPX/SPX或数字设备公司的DECnet这样的非IP协议。
- en: 'As an example, let’s have a look at the first entry from */etc/protocols*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看 */etc/protocols* 文件中的第一个条目：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each */etc/protocols* entry has three key fields: an official name, a protocol
    number, and any aliases. The IP protocol, protocol 0, is known as IP and (*very*
    occasionally) as HOPOPT. Each protocol also has a comment giving it some context.
    Although some of the protocols in */etc/protocols* are long gone, some antediluvian
    devices out there might still speak them.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 */etc/protocols* 条目有三个关键字段：官方名称、协议号和任何别名。IP协议，协议号0，被称为IP，(*非常偶尔*)也称为HOPOPT。每个协议还有一个注释，提供一些上下文。尽管
    */etc/protocols* 中的一些协议已经消失，但一些古老的设备可能仍在使用它们。
- en: Note that ICMP, TCP, and UDP are slightly different when run over IPv4 versus
    IPv6\. Each protocol has clearly defined fields in the IP packet header, leaving
    specific numbers of bits for things like checksums, destination addresses, and
    so on. You can’t run a transport protocol over an incompatible network protocol—TCPv6
    over IPv4 just doesn’t work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在IPv4与IPv6上运行时，ICMP、TCP和UDP略有不同。每个协议在IP数据包头部都有明确定义的字段，为校验和、目标地址等留出特定的位数。你不能在不兼容的网络协议上运行传输协议——TCPv6在IPv4上根本无法工作。
- en: The transport layer speaks to the network layer below and to the applications
    layer above it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层与下方的网络层和上方的应用层进行通信。
- en: Applications
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序
- en: Applications are definitely part of the network. Applications request network
    connectivity, send data over the network, receive data from the network, and process
    that data. Web browsers, email clients, JavaServer Pages (JSP) servers, and so
    on are examples of network-aware applications. Applications need to communicate
    with only the transport protocol and the user. The upper three layers of the OSI
    network model are inside applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序无疑是网络的一部分。应用程序请求网络连接，通过网络发送数据，从网络接收数据，并处理这些数据。网页浏览器、电子邮件客户端、JavaServer Pages
    (JSP) 服务器等都是网络感知应用程序的例子。应用程序只需要与传输协议和用户进行通信。OSI网络模型的顶层三层都在应用程序内部。
- en: Problems with the user layer are beyond the scope of this book, but I find that
    many of these issues can be solved with proper application of a large chainsaw.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用户层的问题超出了本书的范围，但我发现许多这些问题可以通过正确应用大型链锯来解决。
- en: The Life and Times of a Network Request
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络请求的生命周期
- en: So how do all these layers fit together in the real world? Let’s have a look
    at a hypothetical network request, and walk through how data traverses the layers
    and the network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在现实世界中，所有这些层是如何结合在一起的？让我们看看一个假设的网络请求，并逐步了解数据是如何穿越各层和网络。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of this discussion touches on topics covered later this chapter, so you
    might want to reread this section after finishing the chapter. Purists will notice
    that I skip a lot of parts of the process, but I’m trying to relay the basics
    of how TCP/IP works in practice, not model every painful detail of a real network
    transaction.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分讨论的一些内容涉及本章后面将要讨论的主题，因此您在完成本章后可能需要重新阅读本节。纯粹主义者会注意到我跳过了许多过程的部分，但我试图传达TCP/IP在实际中是如何工作的基本原理，而不是详细描述真实网络事务的每一个痛苦细节。
- en: Suppose a user connected to your network wants to look at a very important work-related
    website, such as Scott Meyer’s Basic Instructions (*[http://www.basicinstructions.net/](http://www.basicinstructions.net/)*).
    The user opens his browser, enters the URL, and presses ENTER. The browser application
    transforms the user’s request into the proper format and asks the transport layer
    for a TCP connection to a particular IP address on port 80.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个连接到您网络的用户想查看一个非常重要的与工作相关的网站，例如Scott Meyer的Basic Instructions (*[http://www.basicinstructions.net/](http://www.basicinstructions.net/)*)。用户打开浏览器，输入URL，然后按回车键。浏览器应用程序将用户的请求转换成正确的格式，并请求传输层与特定IP地址的80端口建立TCP连接。
- en: The transport layer inside your computer examines the browser’s request and
    allocates the appropriate resources for it. The request is broken up into digestible
    chunks, called *segments*, and handed down to the network layer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您计算机内的传输层会检查浏览器的请求，并为它分配适当的资源。请求被分解成可消化的数据块，称为*段*，然后传递给网络层。
- en: The network layer doesn’t care about the contents of the request; it’s only
    concern is where that data is going. The network layer takes the TCP data and
    attaches the proper addressing information to it. The resulting chunk of data
    is called a *packet*. The network layer checks the packet’s destination, chooses
    the interface closest to the gateway to that destination, and drops packets down
    into the datalink layer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层并不关心请求的内容；它只关心数据去向何方。网络层将TCP数据附加适当的寻址信息。由此产生的数据块称为*数据包*。网络层检查数据包的目的地，选择离该目的地最近的接口，并将数据包下放到数据链路层。
- en: The datalink layer doesn’t care about the contents of the packet, and it certainly
    doesn’t care about IP addresses or routing. It has been given a lump of zeros
    and ones, and its job is to transmit those zeros and ones to another network node.
    The datalink layer adds the appropriate header and/or footer information to the
    packet, creating a *frame* appropriate for the physical layer. The frame’s header
    and footer contain the addressing information for the physical layer. On most
    networks, the datalink layer prepares frames for the local Ethernet. Then the
    datalink layer hands off the frame to the physical layer for transmission.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层并不关心数据包的内容，当然也不关心IP地址或路由。它被赋予了一块零和一的数据，其任务是将这些零和一传输到另一个网络节点。数据链路层向数据包添加适当的头部和/或尾部信息，创建适合物理层的*帧*。帧的头部和尾部包含物理层的寻址信息。在大多数网络中，数据链路层为本地以太网准备帧，然后将帧传递给物理层进行传输。
- en: The physical layer has no intelligence at all (think carrier pigeons). The datalink
    layer hands the physical layer a frame, and the physical layer transmits that
    frame to another physical device. For a web browsing client, this is usually the
    default router for the local Ethernet. The physical layer doesn’t care about the
    upper-level protocols. Its only job is to make sure the frame gets to the destination
    without errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层完全没有智能（想想信鸽）。数据链路层将一个帧交给物理层，物理层将这个帧传输到另一个物理设备。对于Web浏览客户端来说，这通常是本地以太网的默认路由器。物理层不关心上层协议。它的唯一任务是确保帧无错误地到达目的地。
- en: When the client computer’s router receives the frame, it sends it up to the
    datalink layer. The datalink layer strips out the frame information and hands
    the resulting packet up to the network layer. The router’s network layer examines
    the packet, looks at its routing table, and decides which interface to send it
    out on. This might be another Ethernet interface, a T1, a DS3, an OC3, or whatever
    the router uses for upstream connectivity. Once the router chooses an interface,
    it hands the packet to the datalink layer for that interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端计算机的路由器接收到帧时，它将其发送到数据链路层。数据链路层移除帧信息，并将得到的包交给网络层。路由器的网络层检查包，查看其路由表，并决定通过哪个接口发送。这可能是一个以太网接口、T1、DS3、OC3或路由器用于上行连接的任何其他接口。一旦路由器选择了一个接口，它就将包交给该接口的数据链路层。
- en: The local router’s upstream connection probably goes through a whole series
    of routers. Each router decides where to send the request based on its routing
    table. The request probably traverses a variety of datalink layers as it travels.
    Thanks to layering and abstraction, neither you nor your computer needs to know
    anything about any of them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本地路由器的上行连接可能要通过一系列路由器。每个路由器根据其路由表决定将请求发送到哪里。请求在传输过程中可能穿越各种数据链路层。多亏了分层和抽象，你或你的计算机不需要了解任何关于它们的信息。
- en: When the request reaches its destination, the computer at the other end of the
    transaction accepts the frame and sends it all the way back up the protocol stack.
    The frame is stripped down to packets, which are stripped down to segments, which
    are reassembled into a data stream. The data stream is then handed to the application
    (in this case, a web server). The application processes the request and returns
    an answer, which goes back down through the protocol stack and travels across
    the network, bouncing up and down through various datalink layers on the way as
    necessary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达目的地时，交易另一端的计算机接受该帧并将其发送回整个协议栈的上层。该帧被分解成数据包，数据包再分解成段，然后重新组装成数据流。随后，数据流被交给应用程序（在这种情况下，是一个Web服务器）。应用程序处理请求并返回一个答案，该答案沿着协议栈向下传递并通过网络传输，在必要时在各个数据链路层上下弹跳。
- en: 'This example shows why the layer model is important: Each layer knows only
    what it absolutely must about the layers above and below it, making it possible
    to swap out layers if necessary. When a new datalink protocol is created, the
    other layers don’t need to change. The network layer just hands a packet to the
    datalink layer and lets the datalink do its thing. When you install a new network
    card, you need only a driver that interfaces with the datalink layer and the physical
    layer; you don’t need to change anything higher in the network stack.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了层模型的重要性：每一层只知道它绝对必须了解的上下层的信息，这使得在必要时可以更换层。当创建一个新的数据链路协议时，其他层不需要改变。网络层只需将包交给数据链路层，并让数据链路层完成其工作。当你安装一个新的网络卡时，你只需要一个与数据链路层和物理层接口的驱动程序；你不需要更改网络栈中的任何更高层。
- en: Network Stacks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络栈
- en: A network stack is the software that lets a host communicate with the network.
    A host can run with an IPv4-only network stack, an IPv6-only network stack, or
    a dual-stacked setup.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 网络栈是允许主机与网络通信的软件。主机可以运行IPv4-only网络栈、IPv6-only网络栈或双栈配置。
- en: You’re already familiar with an IPv4-only stack—it’s what most hosts ran for
    much of the past 30 years. An IPv4-only stack can communicate only over IPv4\.
    Today, an IPv4-only stack gets you access to the entire Internet, with a few deliberate
    exceptions. That will not be true in a few years.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了IPv4-only栈——这是过去30年中大多数主机运行的方式。IPv4-only栈只能在IPv4上通信。今天，IPv4-only栈可以让你访问整个互联网，但有少数故意排除的例外。这将在几年后不再成立。
- en: Likewise, an IPv6-only stack can communicate with only IPv6 hosts. Because most
    Internet sites don’t yet support IPv6, running an IPv6-only stack isn’t practical
    at this point. It is, however, an excellent way to test your IPv6 infrastructure
    and connectivity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，仅 IPv6 栈可以与仅 IPv6 主机通信。由于大多数互联网站点尚未支持 IPv6，目前运行仅 IPv6 栈并不实用。然而，这是一个测试你的 IPv6
    基础设施和连接性的绝佳方式。
- en: The most common configuration these days is a dual-stack setup. Client hosts
    try to use both IPv4 and IPv6, preferring one over the other. I recommend configuring
    hosts with dual stacks, preferring the stack with better connectivity. (If you
    get IPv6 connectivity through a tunnel, it’s not as fast as your IPv4 connectivity.)
    If you have equal IPv4 and IPv6 connectivity, use whichever you prefer. IPv6 works
    well enough that I often don’t realize that I’m using it until I analyze my traffic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常见的配置是双栈设置。客户端主机尝试同时使用 IPv4 和 IPv6，优先选择其中一个。我建议配置双栈主机，优先选择连接性更好的栈。（如果你通过隧道获得
    IPv6 连接，它不如你的 IPv4 连接快。）如果你有相等的 IPv4 和 IPv6 连接，使用你喜欢的任意一个。IPv6 工作得足够好，以至于我经常在分析我的流量之前都没有意识到我在使用它。
- en: You don’t need to do anything special to enable IPv6 on OpenBSD—an IPv6 address,
    a default router, and a DNS server, and away you go.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 上启用 IPv6 不需要做任何特殊的事情——一个 IPv6 地址，一个默认路由器和一个 DNS 服务器，然后就可以使用了。
- en: IPv4 Addresses and Subnets
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv4 地址和子网
- en: An *IP address* is a unique 32-bit number assigned to a specific network node.
    Some IP addresses are more or less permanent, such as those assigned to vital
    servers; others change as required, such as those used by desktop clients. Individual
    machines on a shared network use IP addresses from a range of addresses assigned
    to that network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*IP 地址* 是分配给特定网络节点的唯一 32 位数字。一些 IP 地址更永久一些，例如分配给关键服务器；其他则根据需要更改，例如桌面客户端使用的地址。共享网络上的单个机器使用分配给该网络的地址范围内的
    IP 地址。'
- en: Rather than expressing that 32-bit address as a single number, an IP address
    is divided into four 8-bit numbers, usually expressed as decimals. While 192.0.2.1
    and 11000000.00000000.00000010.00000001 represent the same address, the first
    option is easier for our feeble little brains to grasp.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与将 32 位地址表示为单个数字相比，IP 地址被分为四个 8 位数字，通常以十进制表示。虽然 192.0.2.1 和 11000000.00000000.00000010.00000001
    代表相同的地址，但第一种选项更容易让我们这些脆弱的小脑理解。
- en: Internet service providers (ISPs) issue IP addresses in blocks. These blocks
    are the smallest allocation that they can get away with giving you—say, 16 or
    32 addresses. If your system is on a server farm, you might get only a few IP
    addresses out of a block of 256.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务提供商（ISP）以块的形式发行 IP 地址。这些块是它们可以给你提供的最小分配——比如 16 或 32 个地址。如果你的系统在服务器农场，你可能只能从
    256 个地址的块中获得几个 IP 地址。
- en: A *netmask* indicates the size of the block of IP addresses assigned to your
    local network. The size of your IP block determines your netmask—or, your netmask
    determines how many IP addresses the network has.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*子网掩码* 表示分配给本地网络的 IP 地址块的大小。你的 IP 块的大小决定了你的子网掩码——或者，你的子网掩码决定了网络有多少个 IP 地址。'
- en: ISPs issue IP addresses by prefix length, commonly called a *slash*. You’ll
    see IP address blocks described in forms like 192.0.2.128/26\. Everyone who has
    worked with networking has seen the netmask 255.255.255.0, and most know that
    it’s associated with a block of 256 IP addresses. That netmask is also called
    a /24\. The number after the slash is the number of fixed bits in the netmask.
    Remember, an IPv4 address is a 32-bit number; on a /24 network, 24 of those bits
    will never change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ISP 通过前缀长度发行 IP 地址，通常称为 *斜线*。你会看到 IP 地址块以如下形式描述：192.0.2.128/26。每个与网络工作过的人都已经见过子网掩码
    255.255.255.0，大多数人知道它与 256 个 IP 地址的块相关联。这个子网掩码也称为 /24。斜线后面的数字是子网掩码中固定位的数量。记住，IPv4
    地址是一个 32 位数字；在一个 /24 网络上，24 个这些位永远不会改变。
- en: This isn’t a textbook on binary math, so I won’t quiz you on the conversions,
    but think of an IP address as a string of 32 binary digits. On your networks,
    you can change the bits on the far right, but not the bits on the far left. But
    where is the line that separates right from left?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本二进制数学教科书，所以我不打算就转换进行测验，但请将 IP 地址视为一串 32 个二进制位。在你的网络上，你可以更改最右边的位，但不能更改最左边的位。但左右分界的线在哪里呢？
- en: 'Netmasks have traditionally been split on 8-bit boundaries, but there’s no
    hard rule that says they must be. A /25 network has 25 fixed bits—one more fixed
    bit than what used to be called a class C network—leaving you with 7 bits to play
    with. The netmask’s fixed bits are set to 1, and your network bits are set to
    0, as in the following example of a /25 netmask:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 子网掩码传统上是在8位边界上分割的，但并没有硬性规定它们必须这样。/25网络有25个固定位——比过去所说的C类网络多一个固定位——剩下7位可以操作。子网掩码的固定位设置为1，而你的网络位设置为0，如下面的/25子网掩码示例所示：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first three blocks are set to the binary 11111111, which is 255 in decimal.
    The last block is set to 1000000, which is 128\. Mash these together, and your
    resulting netmask is 255.255.255.128.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个块设置为二进制的11111111，即十进制的255。最后一个块设置为1000000，即128。将这些数字组合起来，你得到的子网掩码是255.255.255.128。
- en: If you reduce netmasks to binary, they’re simple to figure out. While you won’t
    need to work with this every day, if you don’t understand the underlying concepts,
    the decimal conversion looks like total gibberish. With a little practice, you’ll
    recognize certain decimal strings as legitimate netmasks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将子网掩码转换为二进制，它们就很容易理解。虽然你不必每天都处理这个问题，但如果你不理解其背后的概念，十进制转换看起来就像是一堆乱码。稍微练习一下，你就会识别出某些十进制字符串是合法的子网掩码。
- en: So now that you know how netmasks work, what the heck does all this mean in
    the real world?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你知道了子网掩码是如何工作的，这一切在现实世界中究竟意味着什么呢？
- en: IP addresses are issued in multiples of 2\. If you have 4 bits to play with,
    you have 16 addresses (2⁴=16). If you have 8 bits to play with, you have 256 addresses
    (2⁸=256). If someone says that you have exactly 17 IP addresses, you’re either
    sharing a network with other people or they’re wrong.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址以2的倍数发放。如果你有4位可以操作，你就有16个地址（2⁴=16）。如果你有8位可以操作，你就有256个地址（2⁸=256）。如果有人说你正好有17个IP地址，那么你要么与其他人共享网络，要么他们错了。
- en: It’s common to see a host’s IP with the netmask attached, such as 192.0.2.130/26\.
    This gives you everything you need to attach the host to the local network. (Finding
    the default gateway is a separate issue, but it’s usually the top or bottom address
    in the block.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以看到主机IP地址后面附有子网掩码，例如192.0.2.130/26。这为你提供了将主机连接到本地网络所需的一切。（查找默认网关是另一个问题，但通常它是该块中的顶部或底部地址。）
- en: Calculating a Decimal IPv4 Netmask
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算十进制IPv4子网掩码
- en: Converting from binary to decimal to binary is error-prone and mildly annoying.
    Here’s how to calculate your netmask while remaining in decimal land.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制到十进制再到二进制的转换容易出错且有些烦人。以下是如何在十进制领域计算你的子网掩码的方法。
- en: Find how many IP addresses you have on your network. This will be a multiple
    of 2, almost certainly smaller than 256\. Subtract the number of IP addresses
    you have from 256\. This is the last number of your netmask. You still need to
    recognize legitimate network sizes, however. If your IP address is 192.0.2.251/26,
    you’ll need to know that a /26 is 26 fixed bits, or 64 IP addresses. Your netmask
    is 255.255.255.192 (256–64=192).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查找你的网络上有多少IP地址。这将是2的倍数，几乎肯定小于256。从256中减去你拥有的IP地址数量。这是你的子网掩码的最后一位数。然而，你仍然需要识别合法的网络大小。如果你的IP地址是192.0.2.251/26，你需要知道/26是26个固定位，或64个IP地址。你的子网掩码是255.255.255.192（256–64=192）。
- en: And I should also mention that netmasks occasionally appear in hexadecimal.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到，子网掩码偶尔也会以十六进制形式出现。
- en: 'Before you travel to my house to bludgeon me repeatedly with this book, [Table 11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions
    "Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions") shows netmasks,
    IP information, and related information for /24 and smaller networks.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在你带着这本书来我家反复殴打我之前，[表11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions
    "表11-1. 表11-1：IPv4子网掩码和IP地址转换")显示了/24和更小网络的子网掩码、IP信息和相关信息。
- en: 'Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1. 表11-1：IPv4子网掩码和IP地址转换
- en: '| Prefix | Binary Mask End | Decimal Mask | Hex Mask | Available IPs |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 二进制掩码结束 | 十进制掩码 | 十六进制掩码 | 可用IP地址 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| /24 | 00000000 | 255.255.255.0 | 0xffffff00 | 256 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| /24 | 00000000 | 255.255.255.0 | 0xffffff00 | 256 |'
- en: '| /25 | 10000000 | 255.255.255.128 | 0xffffff80 | 128 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| /25 | 10000000 | 255.255.255.128 | 0xffffff80 | 128 |'
- en: '| /26 | 11000000 | 255.255.255.192 | 0xffffffc0 | 64 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| /26 | 11000000 | 255.255.255.192 | 0xffffffc0 | 64 |'
- en: '| /27 | 11100000 | 255.255.255.224 | 0xffffffe0 | 32 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| /27 | 11100000 | 255.255.255.224 | 0xffffffe0 | 32 |'
- en: '| /28 | 11110000 | 255.255.255.240 | 0xfffffff0 | 16 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| /28 | 11110000 | 255.255.255.240 | 0xfffffff0 | 16 |'
- en: '| /29 | 11111000 | 255.255.255.248 | 0xfffffff8 | 8 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| /29 | 11111000 | 255.255.255.248 | 0xfffffff8 | 8 |'
- en: '| /30 | 11111100 | 255.255.255.252 | 0xfffffffc | 4 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| /30 | 11111100 | 255.255.255.252 | 0xfffffffc | 4 |'
- en: '| /31 | 11111110 | 255.255.255.254 | 0xfffffffe | 2 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| /31 | 11111110 | 255.255.255.254 | 0xfffffffe | 2 |'
- en: 'When you don’t feel like doing the math, you can refer to [Table 11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions
    "Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions") or install
    the `ipcalc` package for quick netmask calculations. Don’t say I never take pity
    on my readers.^([[28](#ftn.id433870)])'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不想做数学题时，可以参考[表11-1](ch11.html#ipv4_netmasks_and_ip_address_conversions "表11-1.
    表11-1：IPv4子网掩码和IP地址转换")或安装`ipcalc`包进行快速子网掩码计算。不要说我从未同情过我的读者.^([[28](#ftn.id433870)])
- en: Viewing IPv4 Addresses
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看IPv4地址
- en: Display IP addresses with `ifconfig(8)`. If you run `ifconfig` without any arguments,
    it displays all interfaces on the machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ifconfig(8)`显示IP地址。如果您不带任何参数运行`ifconfig`，它将显示机器上的所有接口。
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The lines starting with `inet` are IPv6 addresses. This interface has the primary
    IPv4 address of 192.0.2.226 and a secondary, or *alias*, address of 192.0.2.231\.
    You can also see the netmask of each of these addresses and the broadcast address
    for the subnet.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以`inet`开头的行是IPv6地址。此接口的主要IPv4地址为192.0.2.226，次要的或*别名*地址为192.0.2.231。您还可以看到这些地址的子网掩码和子网的广播地址。
- en: Unusable IPv4 Addresses
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可用的IPv4地址
- en: 'Every block of IPv4 addresses reserves the first and last IP addresses for
    use by the network:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IPv4地址块都为网络预留了第一个和最后一个IP地址用于使用：
- en: The first IP address in a block is the *network address*, used for separating
    networks (and on primordial BSD systems, the broadcast address). On a /24 network,
    this would be an address ending in .0.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块中的第一个IP地址是*网络地址*，用于分隔网络（以及在原始BSD系统中，广播地址）。在/24网络中，这将是一个以.0结尾的地址。
- en: The last IP address in the block is the *broadcast address*. On a /24 network,
    the broadcast address ends in .255.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块中的最后一个IP地址是*广播地址*。在/24网络中，广播地址以.255结尾。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'According to the IP specifications, every machine on a network is supposed
    to respond to a request to the broadcast address. Unfortunately, in the late 1990s,
    this feature was used as an attack technique: All you needed to do was ping the
    broadcast address on any given network, and you would have a list of all IP addresses
    currently in use. Consequently, this functionality is now disabled by default
    on most operating systems and network appliances.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IP规范，网络上的每台机器都应该对广播地址的请求做出响应。不幸的是，在20世纪90年代末，这一特性被用作攻击技术：您只需在任何给定网络上ping广播地址，就会得到当前所有正在使用的IP地址列表。因此，现在大多数操作系统和网络设备默认禁用了这一功能。
- en: You cannot assign the first or the last IP address in a network to a device
    without risking network problems. Some systems fail gracefully, others fail painfully,
    and a rare few make it work. Although OpenBSD won’t object if you use the top
    and bottom network addresses, prepare for mayhem the first time you plug in a
    commodity printer or other embedded device. It takes only one inflexible device
    to ruin your whole day.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，您不能将第一个或最后一个IP地址分配给设备而不冒网络问题的风险。一些系统会优雅地失败，其他系统会痛苦地失败，而极少数系统能够正常工作。尽管OpenBSD不会反对您使用顶部和底部的网络地址，但第一次插入通用打印机或其他嵌入式设备时，请做好混乱的准备。只需一个不灵活的设备就能毁掉您一整天。
- en: Special IPv4 Addresses
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊IPv4地址
- en: Quite a few blocks of IPv4 addresses are set aside for specific purposes. Although
    you don’t need to know all of them, there are two groups you’ll see pretty often.
    For a complete list of IPv4 subnets reserved for special purposes, read RFCs 5735
    and 6598.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 许多IPv4地址块被预留用于特定目的。尽管您不需要了解所有这些，但您会经常看到两组。要获取为特殊目的预留的IPv4子网的完整列表，请阅读RFC 5735和RFC
    6598。
- en: Localhost
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 本地主机
- en: The address range 127.0.0.1/8 is set aside for *localhost*, a machine’s address
    for itself. Every Unix-like system—and most other operating systems—attaches 127.0.0.1/8
    to a loopback interface. Everything knows that the localhost address is local
    to the specific machine. Packets to or from 127.0.0.0/8 should never cross the
    network; likewise, daemons bound only to 127.0.0.1 can be accessed on only the
    local machine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 地址范围127.0.0.1/8被预留用于*本地主机*，即机器自己的地址。每个类Unix系统——以及大多数其他操作系统——都将127.0.0.1/8附加到回环接口。所有设备都知道localhost地址是特定机器的本地地址。发往或来自127.0.0.0/8的数据包永远不应该跨越网络；同样，仅绑定到127.0.0.1的守护进程只能在本地机器上访问。
- en: Private Networks
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 私有网络
- en: 'Internet standard RFC 1918 sets aside three networks for use on private networks
    and behind network address translation (NAT) devices: 10.0.0.0/8, 172.16.0.0/12,
    and 192.168.0.0/16\. While public IP addresses must be issued by an ISP, anyone
    can use addresses within these three blocks as long as those hosts are not directly
    exposed to the public Internet. If you have a network where hosts do not have
    access to the Internet, or if you provide Internet access through a proxy server
    or NAT, you can use an RFC 1918 network.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网标准RFC 1918为私有网络和位于网络地址转换（NAT）设备之后设置了三个网络：10.0.0.0/8、172.16.0.0/12和192.168.0.0/16。虽然公共IP地址必须由ISP颁发，但只要这些主机不直接暴露在公共互联网上，任何人都可以使用这三个块内的地址。如果你有一个主机无法访问互联网的网络，或者如果你通过代理服务器或NAT提供互联网接入，你可以使用RFC
    1918网络。
- en: IPv4 Addressing Pitfalls
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4地址分配的陷阱
- en: Common wisdom dictates that each computer on a network is assigned a single
    IP address for each of its network interfaces. One computer, one network card,
    one IP address—simple, right?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，网络中的每台计算机都会为其每个网络接口分配一个单独的IP地址。一台计算机，一块网卡，一个IP地址——简单，对吧？
- en: Not always. Some special-purpose interfaces (such as those dedicated to packet
    sniffing) function as intended without an IP address, and many operating systems
    will allow you to assign multiple IP addresses to a single network interface through
    a process called *aliasing*. You can also bond multiple physical cards into a
    single network interface, giving the computer one large virtual interface. While
    you might not deal with these configurations every day, keep them in mind when
    troubleshooting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是如此。一些专用接口（例如那些用于数据包嗅探的接口）在没有IP地址的情况下也能按预期工作，许多操作系统也允许你通过一个称为*别名*的过程为单个网络接口分配多个IP地址。你还可以将多个物理网卡绑定成一个单一的网络接口，为计算机提供一个大的虚拟接口。虽然你可能不会每天处理这些配置，但在故障排除时请记住这些。
- en: IPv6 Addresses and Subnets
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6地址和子网
- en: 'There’s a basic problem with IPv4: It provides only 4.29 billion addresses,
    and that’s just not enough. Without subnetting, that’s fewer than one address
    for every human being. Eventually, every person will have at least one IP-capable
    device.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4存在一个基本问题：它只提供了42.9亿个地址，这远远不够。没有子网划分，这意味着每个人不到一个地址。最终，每个人至少会有一台IP设备。
- en: 'Although IPv4 addresses haven’t run out yet, they’re becoming an increasingly
    scarce resource. Overly generous allocations in the early days, along with large
    chunks of address space reservations for special purposes, have accelerated exhaustion.
    The world is slowly grinding toward IPv4’s replacement: IPv6.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IPv4地址尚未耗尽，但它们正变得越来越稀缺。早期过于慷慨的分配，以及为特殊目的预留的大量地址空间，加速了地址的耗尽。世界正缓慢地走向IPv4的替代品：IPv6。
- en: Some parts of the world already use IPv6 extensively. Even if your network doesn’t
    use IPv6 today, one day you’ll need it—probably without warning. Prepare yourself
    now, or one day you’ll discover that you needed it the week before.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上的某些地区已经广泛使用IPv6。即使你的网络今天不使用IPv6，总有一天你会需要它——可能毫无预兆。现在做好准备，否则你可能会发现你在一周前就需要它了。
- en: IPv6 Basics
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6基础知识
- en: Like IPv4, IPv6 is a network layer protocol. IPv4 uses 32-bit addresses, usually
    expressed as four groups of decimal numbers from 0 to 255 (for example, 192.0.2.13).
    IPv6 uses 128-bit addresses, expressed as six groups of four hexadecimal characters
    separated by colons (for example, 2001:db8:0:bad:c0de:cafe). A 128-bit address
    space gives enough IPv6 addresses for every atom in the Earth to have more than
    10 IP addresses. TCP, UDP, ICMP, and other protocols run atop it. IPv6 has its
    own layer 2 protocol, Neighbor Discovery, which replaces protocols such as Ethernet’s
    ARP.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与IPv4一样，IPv6是一个网络层协议。IPv4使用32位地址，通常表示为四组从0到255的十进制数字（例如，192.0.2.13）。IPv6使用128位地址，表示为六组由冒号分隔的四位十六进制字符（例如，2001:db8:0:bad:c0de:cafe）。128位的地址空间为地球上的每个原子提供了超过10个IPv6地址。TCP、UDP、ICMP和其他协议在其之上运行。IPv6有自己的第二层协议，即邻居发现协议，它取代了如以太网的ARP协议。
- en: The good news is that you don’t need to relearn the basics of networking. Hosts
    still need an IP address and a default gateway, routers still use a routing table,
    and you can almost—*almost*—substitute an IPv6 address for an IPv4 address and
    watch everything work. A web server doesn’t care if it binds to port 80 on 192.0.2.13
    or on 2001:db8:a12a:bad:c0de:café. The server just accepts requests sent to it
    and responds appropriately. That said, software does need to change slightly,
    because our web server must be able to log connections from both IPv4 and IPv6
    addresses. These changes have wide-reaching repercussions, and we’ll be sorting
    out edge cases for the next decade. But, in general, once you understand the new
    rules for IPv6, all of your networking knowledge is applicable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你不需要重新学习网络的基础知识。主机仍然需要一个 IP 地址和一个默认网关，路由器仍然使用路由表，你几乎可以——*几乎可以*——用 IPv6
    地址替换 IPv4 地址并观察一切正常工作。Web 服务器不在乎它绑定到 192.0.2.13 上的 80 端口还是绑定到 2001:db8:a12a:bad:c0de:café
    上的 80 端口。服务器只是接受发送给它的请求并相应地做出响应。话虽如此，软件确实需要稍作改变，因为我们的 Web 服务器必须能够记录来自 IPv4 和 IPv6
    地址的连接。这些变化具有深远的影响，我们将在接下来的十年里解决边缘情况。但总的来说，一旦你了解了 IPv6 的新规则，你的所有网络知识都适用。
- en: Understanding IPv6 Addresses
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 IPv6 地址
- en: As noted, IPv6 addresses are 128 bits, expressed as six colon-delimited groups
    of four hexadecimal characters each. As with decimal IPv4 addresses, you don’t
    need to display leading zeros in each group. The address 2001:db8:0:bad:c0de:cafe
    could also be written as 2001:db8:0000:0bad:c0de:cafe, but just as we wouldn’t
    write 192.000.002.013, we strip out the leading zeros in an IPv6 address.^([[29](#ftn.id369078)])
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，IPv6 地址是 128 位，表示为六个由冒号分隔的四位十六进制字符组。与十进制 IPv4 地址一样，你不需要在每个组中显示前导零。地址 2001:db8:0:bad:c0de:cafe
    也可以写成 2001:db8:0000:0bad:c0de:cafe，但就像我们不会写 192.000.002.013 一样，我们在 IPv6 地址中省略了前导零。[29](#ftn.id369078)]
- en: IPv6 addresses often contain long strings of zeros. This had to do with subnetting,
    which I’ll describe later in this section. As of this writing, the IPv6 address
    of Sprint’s website is 2600:0:0:0:0:aaaa. When consecutive groups include only
    zeros, as in this address, they’re replaced with two colons (`::`). This IP address
    is usually displayed as 2600::aaaa. You can do this only once per address, however.
    You can’t, for example, have the address 2600::1::1, because it’s ambiguous. Does
    2600::1::1 represent 2600:0:0:1:0:1 or does it represent 2600:0:1:0:0:1? I don’t
    know, and neither does your server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址通常包含一长串零。这与子网划分有关，我将在本节后面描述。截至本文撰写时，Sprint 网站的 IPv6 地址是 2600:0:0:0:0:aaaa。当连续的组只包含零时，如这个地址，它们将被两个冒号（`::`）替换。这个
    IP 地址通常显示为 2600::aaaa。但是，每个地址只能这样做一次。例如，你不能有地址 2600::1::1，因为这会导致歧义。2600::1::1
    代表 2600:0:0:1:0:1 还是代表 2600:0:1:0:0:1？我不知道，你的服务器也不知道。
- en: You’ve probably seen a port number added to an IPv4 address, such as 192.0.2.13:80\.
    Using a colon to glue a port number to an IPv6 address would be confusing. The
    IPv6 address 2001:db8::bad:c0de:cafe:80 isn’t ambiguous, but if you read it quickly,
    you might miss the double colon and think this is an IP address ending in 80\.
    If you’re adding a port number to an IPv6 address, enclose the address in square
    brackets, as in [2001:db8::bad:c0de:cafe]:80.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过在 IPv4 地址中添加端口号，例如 192.0.2.13:80。使用冒号将端口号粘接到 IPv6 地址上可能会造成混淆。IPv6 地址 2001:db8::bad:c0de:cafe:80
    并没有歧义，但如果你快速阅读，可能会错过双冒号并认为这是一个以 80 结尾的 IP 地址。如果你要向 IPv6 地址添加端口号，请将地址用方括号括起来，例如
    [2001:db8::bad:c0de:cafe]:80。
- en: Viewing IPv6 Addresses
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看 IPv6 地址
- en: Use `ifconfig(8)` to see all IPv6 addresses assigned on your machine. Here,
    I give `ifconfig` the name of my network card, `fxp0`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ifconfig(8)` 查看你机器上分配的所有 IPv6 地址。在这里，我给 `ifconfig` 赋予了我的网卡名称，`fxp0`。
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The lines starting with `inet6` are my IPv6 addresses. This interface has been
    assigned two IPv6 addresses: `fe80::bad:c0de:cafe%fxp0` and `2001:db8::bad:c0de:cafe`.
    (Wait … where did that `%fxp0` come from? You’ll find out in [Link Local Addresses](ch11.html#link_local_addresses
    "Link Local Addresses"). For now, just nod and smile, and keep reading.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `inet6` 开头的行是我的 IPv6 地址。此接口已分配了两个 IPv6 地址：`fe80::bad:c0de:cafe%fxp0` 和 `2001:db8::bad:c0de:cafe`。（等等……那个
    `%fxp0` 是从哪里来的？你将在[链路本地地址](ch11.html#link_local_addresses "链路本地地址")中找到答案。现在，只需点头微笑，继续阅读。）
- en: IPv6 Subnets
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6 子网
- en: Unlike IPv4, where you can subnet at any bit, IPv6 is usually subnetted at colon
    boundaries. Colons appear every 16 bits, so the natural IPv6 subnets are /16,
    /32, /48, and /64\. Though IPv6 standards recommend using /64 as the smallest
    possible network, many carriers use /80, /96, and /112 networks for special purposes.
    (I’ve also seen people use subnets not divided at 16-bit boundaries. I won’t cover
    them, but don’t let your brain explode when you encounter a /51.) IPv6 subnets
    are always expressed as a slash, also known as a *prefix length*, so you won’t
    see a netmask of ffff:ffff:ffff:ffff::, as you might in IPv4.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与IPv4不同，IPv4可以在任何位进行子网划分，IPv6通常在冒号边界进行子网划分。冒号每16位出现一次，所以自然的IPv6子网是/16、/32、/48和/64。尽管IPv6标准建议使用/64作为可能的最小网络，但许多运营商为了特殊目的使用/80、/96和/112网络。
    (我也见过一些人使用不在16位边界划分的子网。我不会涉及这些，但当你遇到/51子网时，不要让你的大脑崩溃。) IPv6子网总是以斜杠表示，也称为*前缀长度*，所以你不会看到类似于IPv4中的ffff:ffff:ffff:ffff::的子网掩码。
- en: ISPs are usually issued a /32 or a /48 subnet and are expected to issue end-user
    networks, such as the typical home network, a /64 network. If ISPs do issue /64
    subnets to their users, an end-user network will provide 264 IP addresses, or
    18,446,744,073,709,551,616 IP addresses. (This will suffice for any number of
    televisions, phones, refrigerators, water faucets, vacuums, and network-enabled
    tacos.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务提供商通常被分配/32或/48子网，并预期向最终用户网络（如典型的家庭网络）分配/64网络。如果互联网服务提供商向用户分配/64子网，最终用户网络将提供2^64个IP地址，即18,446,744,073,709,551,616个IP地址。（这足以满足任何数量的电视、电话、冰箱、水龙头、吸尘器和网络化的玉米卷饼。）
- en: When you subnet at 16-bit boundaries, each network has 65,536 subnets of the
    next smaller size. A /32 contains 65,536 /48 networks, and a /48 contains 65,536
    /64 networks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在16位边界进行子网划分时，每个网络都有65,536个子网，其大小比下一个更小的子网小。一个/32包含65,536个/48网络，一个/48包含65,536个/64网络。
- en: Special IPv6 Addresses
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊IPv6地址
- en: Like its predecessor, IPv6 reserves several blocks of addresses for special
    purposes. You don’t need to memorize all of these reserved addresses, but some
    will appear in daily use.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与其前身类似，IPv6为特殊目的预留了几个地址块。你不需要记住所有这些预留地址，但其中一些会在日常使用中出现。
- en: localhost
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 本地主机
- en: 'IPv6’s localhost address, ::1/128, works much like 127.0.0.1 in IPv4: It always
    refers to the local machine. In OpenBSD, ::1/128 is always assigned to the `lo0`
    interface.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6的本地地址::1/128在IPv4中工作方式与127.0.0.1类似：它始终指向本地机器。在OpenBSD中，::1/128始终分配给`lo0`接口。
- en: Link Local Addresses
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链路本地地址
- en: 'Addresses beginning with fe8*x*: (where *x* is variable) are local to their
    interface. Every link has such *link local* addresses that are valid only on a
    specific local network. Even if an IPv6 network has no router, the hosts on the
    local, directly attached network can find each other and communicate using these
    local addresses. These networks are always /64 subnets. You’ll see identical IPv6
    subnets on other interfaces and on networks completely disconnected from your
    network. That’s okay. These addresses are local to the link. For example, here’s
    a link local address on an OpenBSD machine:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以fe8*x*:开头的地址（其中*x*是可变的）仅限于其接口。每个链路都有这样的*链路本地*地址，这些地址仅在特定的本地网络上有效。即使IPv6网络没有路由器，本地直接连接网络上的主机也可以使用这些本地地址找到彼此并进行通信。这些网络总是/64子网。你会在其他接口和与你的网络完全断开的网络上看到相同的IPv6子网。这是可以的。这些地址仅限于链路。例如，这是一个OpenBSD机器上的链路本地地址：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The link local address of this interface is `fe80::bad:code:cafe`. The trailing
    `%fxp0` indicates that this address is local to the interface `fxp0` and isn’t
    usable on any other interface on the machine. If your machine has an interface
    `fxp1`, and a host on that network tries to reach the address fe80::bad:code:cafe,
    this machine will not respond. This particular address is valid only for the network
    attached to interface `fxp0`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口的链路本地地址是`fe80::bad:code:cafe`。尾部的`%fxp0`表示此地址仅限于接口`fxp0`，并且不能在机器上的任何其他接口上使用。如果你的机器有一个`fxp1`接口，并且该网络上的主机尝试访问地址fe80::bad:code:cafe，这台机器将不会响应。这个特定的地址仅对连接到接口`fxp0`的网络有效。
- en: You might note that the link local address has a section in common with the
    public IPv6 address on this network. That’s because an autoconfigured IPv6 address
    is usually calculated from the interface’s physical address; it doesn’t matter
    whether that autoconfigured address is on a public address or a link local address.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，链路本地地址与该网络上的公共IPv6地址有一个共同的区域。这是因为自动配置的IPv6地址通常是从接口的物理地址计算出来的；无论这个自动配置的地址是公共地址还是链路本地地址，这都不重要。
- en: Assigning IPv6 Addresses
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配IPv6地址
- en: IPv6 clients can usually use autoconfiguration through *router discovery*, anIPv6
    protocol where routers announce their presence on the network and the legitimate
    addresses to clients. Unfortunately, IPv6 autoconfiguration does not support common
    Dynamic Host Configuration Protocol (DHCP) options, such as assigning a Domain
    Name Service (DNS) server, let alone the options used for diskless configuration.
    If you have configured a DNS server—even IPv4 servers accessible on a dual-stacked
    host—autoconfiguration works just fine. If you run an IPv6-only network, you must
    either set up an IPv6 DHCP server to provide DNS server information to clients
    or configure DNS servers manually.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6客户端通常可以通过*路由器发现*使用自动配置，这是一个IPv6协议，其中路由器向客户端宣布其在网络上的存在和合法地址。不幸的是，IPv6自动配置不支持常见的动态主机配置协议（DHCP）选项，例如分配域名系统（DNS）服务器，更不用说用于无盘配置的选项了。如果你已经配置了DNS服务器——即使是在双栈主机上可访问的IPv4服务器——自动配置也能正常工作。如果你运行一个仅IPv6的网络，你必须要么设置一个IPv6
    DHCP服务器向客户端提供DNS服务器信息，要么手动配置DNS服务器。
- en: Servers should not use IPv6 autoconfiguration. A server usually needs a static
    IP address, even in IPv6\. Similarly, routers cannot use autoconfiguration. If
    a host can forward packets, it requires a static IPv6 address.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不应使用IPv6自动配置。服务器通常需要一个静态IP地址，即使在IPv6中也是如此。同样，路由器也不能使用自动配置。如果一个主机可以转发数据包，它需要一个静态的IPv6地址。
- en: You can assign multiple IPv6 addresses to a single interface by using aliases,
    just as with IPv4.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用别名将多个IPv6地址分配给单个接口，就像在IPv4中一样。
- en: In IPv6, a client on a /64 network can use autoconfiguration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中，/64网络上的客户端可以使用自动配置。
- en: IPv6 autoconfiguration resembles a stripped-down DHCP service. The router broadcasts
    subnet and gateway information, and the hosts configure themselves to use it.
    Hosts on a network smaller than /64 must be manually configured.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6自动配置类似于简化的DHCP服务。路由器广播子网和网关信息，主机配置自己使用它。小于/64的网络上的主机必须手动配置。
- en: Remedial TCP/IP
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补救性TCP/IP
- en: Now that you have a simplified overview of how the IP system works, let’s look
    at a real network protocol in some depth. The dominant transport protocol on the
    Internet is the Transmission Control Protocol over Internet Protocol, or TCP/IP.
    Although TCP is a transport protocol and IP is a network protocol, the two are
    so tightly intertwined that they’re generally referred to as a single entity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对IP系统的工作原理有了简化的概述，让我们深入探讨一个真实的网络协议。互联网上占主导地位的传输协议是互联网协议上的传输控制协议，或TCP/IP。尽管TCP是一种传输协议，IP是一种网络协议，但这两个协议紧密交织在一起，通常被统称为一个实体。
- en: We’ll start with ICMP, and proceed to UDP and TCP.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从ICMP开始，然后继续到UDP和TCP。
- en: ICMP
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ICMP
- en: ICMP is used to transmit routing and availability messages across the network.
    Tools such as `ping(8)` and `traceroute(8)` use ICMP. ICMP includes all sorts
    of different protocols and tools.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP用于在网络中传输路由和可用性消息。工具如`ping(8)`和`traceroute(8)`使用ICMP。ICMP包括各种不同的协议和工具。
- en: While some people claim that you need to block ICMP for security purposes, those
    people don’t understand that ICMP is just as diverse as the better-understood
    transport protocols TCP and UDP. Proper IPv4 network performance requires large
    chunks of ICMPv4\. If you must block ICMPv4 for security reasons, do so selectively.
    For example, blocking source quench messages breaks path maximum transmission
    unit (MTU) discovery, which will steer you directly into a world of hurt. If you
    don’t understand that last sentence, don’t block ICMPv4.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些人声称出于安全目的需要阻止ICMP，但这些人并不理解ICMP与更为人熟知的传输协议TCP和UDP一样多样化。适当的IPv4网络性能需要大量的ICMPv4。如果你必须出于安全原因阻止ICMPv4，请选择性地进行。例如，阻止源抑制消息会破坏路径最大传输单元（MTU）发现，这会让你直接进入一个痛苦的世界。如果你不理解最后一句话，请不要阻止ICMPv4。
- en: IPv6 dies without ICMPv6, as IPv6 doesn’t support packet fragmentation, so never
    block ICMPv6\. If you don’t know what packet fragmentation is, just trust me on
    this.^([[30](#ftn.id453475)])
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ICMPv6，IPv6就无法工作，因为IPv6不支持数据包分片，所以永远不要阻止ICMPv6。如果你不知道数据包分片是什么，就相信我吧.^([[30](#ftn.id453475)])
- en: UDP
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDP
- en: UDP is the most bare-bones data-transfer protocol that runs over IP. It offers
    no error handling, minimal integrity verification, and no defense whatsoever against
    data loss. The transport protocol considers each packet of UDP completely self-contained;
    there are no data-coherence checks at the protocol layer. Despite these drawbacks,
    UDP can be a good choice for particular sorts of data transfer, and many vital
    Internet services rely on it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: UDP是在IP上运行的最为基础的传输协议。它不提供错误处理，最小化完整性验证，并且对数据丢失没有任何防御措施。传输协议认为UDP的每个数据包都是完全自包含的；在协议层没有数据一致性检查。尽管存在这些缺点，UDP对于某些类型的数据传输来说仍然是一个不错的选择，许多重要的互联网服务都依赖于它。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This discussion covers both UDPv4 and UDPv6\. While each runs over only the
    corresponding network protocol, they behave identically otherwise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论涵盖了UDPv4和UDPv6。尽管每个都只运行在相应的网络协议上，但在其他方面它们的行为是相同的。
- en: UDP is also a datagram protocol, meaning that each network transmission is complete
    and self-contained, and received as a single integral unit. While the application
    might not consider a single UDP packet a complete request, the network does.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: UDP也是一个数据报协议，这意味着每次网络传输都是完整且自包含的，并且作为一个单一的整体接收。尽管应用程序可能不会将单个UDP数据包视为一个完整请求，但网络会。
- en: When a host transmits data via UDP, it has no way of knowing if the data ever
    reaches its destination. Programs that receive UDP data just listen to the network
    and accept whatever happens to arrive. When a program receives data via UDP, it
    cannot verify the source of that data. Although each UDP packet does include a
    source address, this address is easily faked. Each UDP packet includes a checksum
    for the packet, but there’s no integrity checking for the data stream as a whole.
    This is why UDP is called *connectionless*, or *stateless*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机通过UDP传输数据时，它无法知道数据是否到达了目的地。接收UDP数据的程序只是监听网络并接受任何到达的数据。当程序通过UDP接收数据时，它无法验证数据的来源。尽管每个UDP数据包都包括一个源地址，但这个地址很容易被伪造。每个UDP数据包都包括一个数据包校验和，但没有对整个数据流的完整性检查。这就是为什么UDP被称为*无连接的*或*无状态的*。
- en: No integrity checking, no guard against data loss, the potential for faked packets—all
    this sounds pretty unreliable. So why use UDP at all?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 没有完整性检查，没有防止数据丢失的防御措施，伪造数据包的可能性——所有这些都听起来非常不可靠。那么为什么还要使用UDP呢？
- en: UDP-based applications often have their own error-correction methods or otherwise
    don’t mesh well with more reliable protocols, such as TCP. For example, simple
    client DNS queries must time out within just a few seconds or users will whine
    uncontrollably. TCP connections time out only after two minutes. DNS requires
    quick failures and only a single packet per transaction, which makes UDP a better
    choice than TCP for simple DNS queries. Real-time streaming services, such as
    video conferencing applications, also use UDP. (After all, if a few pixels go
    missing during a video conference, you don’t want those pixels a minute later.)
    Most other UDP-based applications use UDP for similar reasons.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基于UDP的应用程序通常有自己的错误纠正方法，或者与更可靠协议（如TCP）不兼容。例如，简单的客户端DNS查询必须在几秒钟内超时，否则用户会无法控制地抱怨。TCP连接只有在两分钟后才会超时。DNS需要快速失败，并且每个事务只有一个数据包，这使得UDP比TCP更适合简单的DNS查询。实时流媒体服务，如视频会议应用程序，也使用UDP。（毕竟，如果在视频会议中丢失了一些像素，你不想一分钟后还看到这些像素。）大多数其他基于UDP的应用程序出于类似的原因使用UDP。
- en: Because the UDP protocol itself doesn’t return anything when you connect to
    a port, there’s no reliable way to remotely test if a UDP port is reachable (although
    tools such as `nmap` try to do so).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP协议本身在连接到端口时不会返回任何内容，因此没有可靠的方法来远程测试UDP端口是否可达（尽管像`nmap`这样的工具试图这样做）。
- en: If you want a protocol that responds at the network layer, look at TCP.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个在网络层做出响应的协议，请查看TCP。
- en: TCP
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP
- en: TCP includes nifty features, such as error correction and recovery. The receiver
    must acknowledge every packet it gets; otherwise, the sender retransmits any unacknowledged
    packets. Unlike UDP, applications that use TCP can expect reliable data transmission.
    This makes TCP a *connected*, or *stateful*, protocol.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: TCP包括一些巧妙的功能，如错误纠正和恢复。接收方必须确认它收到的每个数据包；否则，发送方会重新传输任何未确认的数据包。与UDP不同，使用TCP的应用程序可以期待可靠的数据传输。这使得TCP成为一个*连接的*或*有状态的*协议。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This discussion covers both TCPv6 and TCPv4\. While they differ because of their
    underlying transport protocol, they behave in the same way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论涵盖了TCPv6和TCPv4。尽管它们因为其底层传输协议的不同而有所区别，但它们的行为方式是相同的。
- en: TCP is also a *streaming protocol*, which means that a single request can be
    split among several network packets. While the sender might transmit several chunks
    of data one after the other, that data might arrive out of order or fragmented.
    The recipient must track these chunks and assemble them properly to complete the
    network transaction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: TCP也是一个*流协议*，这意味着单个请求可以被分割成几个网络数据包。虽然发送者可能会连续发送几个数据块，但这些数据可能会乱序到达或碎片化。接收者必须跟踪这些数据块并正确组装它们以完成网络事务。
- en: For hosts to exchange TCP data, they must set up a channel for that data to
    flow across. One host requests a connection, the other host responds to the request,
    and then the first host starts transmitting. This setup process is known as the
    *three-way handshake*. Similarly, once transmission is complete, the systems must
    do a certain amount of work to tear down the connections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了主机之间交换TCP数据，它们必须为数据流建立一个通道。一个主机请求建立连接，另一个主机响应请求，然后第一个主机开始传输。这个过程被称为*三次握手*。同样，一旦传输完成，系统必须进行一定的工作来断开连接。
- en: To test if a TCP port is open, you can use `telnet(1)` or `nc(1)` to connect
    to the port. Here, I see if I can connect to port 22 on the host `caddis`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试TCP端口是否开放，你可以使用`telnet(1)`或`nc(1)`连接到该端口。在这里，我看看我是否可以连接到`caddis`主机的端口22。
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I connect to the remote port and see information displayed by the port, use
    the telnet escape character **`^]`** (CTRL-]) to disconnect **1**, and enter **`c`**
    **2** to close telnet.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我连接到远程端口并查看端口显示的信息，使用telnet的转义字符**`^]`**（CTRL-]）断开连接**1**，并输入**`c`** **2**关闭telnet。
- en: TCP is commonly used by applications most suited to its fairly generic set of
    timeouts and transmission features, such as email programs, FTP clients, and web
    browsers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: TCP通常被适用于其相当通用的超时和传输特性的应用程序使用，例如电子邮件程序、FTP客户端和网页浏览器。
- en: How Protocols Fit Together
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议如何协同工作
- en: You can compare the network stack to sitting with your family at a holiday dinner.
    The datalink layer (ARP, in the case of Ethernet) lets you see everyone else at
    the table. IP gives every person at the table their own unique chair (except for
    the twins using piano bench NAT). ICMP provides basic, lower-layer information
    such as “The quickest way to the baked sweet potatoes is to get Uncle Mike to
    pass them”?^([[31](#ftn.id324463)]) or “Aunt Liz can’t lift the ham platter.”
    TCP is where you hand someone the butter and the other person must say “thanks”
    before you let it go. UDP is like tossing a roll at Grandma Lucas; she might catch
    it or it might bounce off her forehead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将网络堆栈比作在假日晚餐时与家人一起坐下。数据链路层（在以太网的情况下是ARP）让你看到桌子上的每个人。IP为桌子上的每个人提供他们自己的独特椅子（除了使用钢琴凳NAT的双胞胎）。ICMP提供基本、低层信息，例如“到达烤红薯最快的方式是让迈克叔叔递给你”？^([[31](#ftn.id324463)])
    或者“丽兹阿姨抬不起火腿盘。”TCP是你递给别人黄油，而另一个人必须说“谢谢”你才能放手的地方。UDP就像向露卡斯奶奶扔一个面包卷；她可能接住它，或者它可能弹回她的额头。
- en: Transport Protocol Ports
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输协议端口
- en: Transport protocol ports permit one server to serve many different services
    over a single transport protocol, multiplexing connections between machines. When
    a network server starts, it attaches, or *binds*, to one or more logical ports.
    A logical port is just an arbitrary number ranging from 0 to 65536, although nothing
    uses port 0\. For example, Internet mail servers often bind to port 25.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议端口允许一个服务器通过单个传输协议提供多种不同的服务，在机器之间多路复用连接。当网络服务器启动时，它会附加到，或*绑定*到一个或多个逻辑端口。逻辑端口只是一个从0到65536的任意数字，尽管没有东西使用端口0。例如，互联网邮件服务器通常绑定到端口25。
- en: Each TCP or UDP packet arriving at a system carries a field containing its desired
    destination port number. If an incoming packet asks for port 25, it is connected
    to the mail server running on that port. This means that other programs can run
    on other ports, clients can talk to those different ports, and no one gets confused
    except you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个到达系统的TCP或UDP数据包都携带一个字段，包含其期望的目标端口号。如果传入的数据包请求端口25，它将连接到运行在该端口的邮件服务器。这意味着其他程序可以运行在其他端口上，客户端可以与这些不同的端口通信，除了你之外没有人会感到困惑。
- en: Note that port assignments are not some sort of physical constant, but rather
    are mutually agreed upon. There’s no reason that email services should run on
    port 25 other than the fact that everyone agrees that they should. If someone
    tries to send you email, their mail server will automatically connect to port
    25 on your server. If you run email on port 80 and have a web server on port 25,
    you’ll never get your email, and your web server won’t get much traffic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，端口分配并不是某种物理常数，而是相互协商的结果。除了每个人都同意电子邮件服务应该运行在端口 25 的原因之外，没有理由让电子邮件服务运行在端口 25。如果有人试图给你发送电子邮件，他们的邮件服务器会自动连接到你的服务器上的端口
    25。如果你在端口 80 上运行电子邮件并在端口 25 上有一个 Web 服务器，你将永远收不到你的电子邮件，你的 Web 服务器也不会获得太多流量。
- en: 'The file */etc/services* contains a list of port numbers and the associated
    services. The file has a very simple, five-column format, as shown in these two
    sample lines:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/services* 包含了一组端口号及其相关服务。该文件具有非常简单的五列格式，如下两行示例所示：
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first field is the name of the service assigned to this port. This entry
    is for the service `www`. Port 80 is assigned to `www`, both TCP and UDP. Then
    there’s a list of any other names assigned to this port. Port 80 is also known
    as `http`. Finally, there’s a comment that gives more detail about the service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是分配给此端口的服务的名称。此条目是为服务 `www`。端口 80 被分配给 `www`，既支持 TCP 也支持 UDP。然后是分配给此端口的任何其他名称。端口
    80 也被称为 `http`。最后，有一个注释，提供了更多关于服务的详细信息。
- en: 'The HTTP protocol used on the Web runs over TCP, so why is UDP port 80 also
    reserved for HTTP? The answer is pretty simple: Computer people are easily confused.
    Having two services share the same port number but run on different protocols
    confuses people—for example, the `syslog` service runs on port 514 via UDP, and
    the `lpr` printer protocol runs on port 514 over TCP.^([[32](#ftn.id322914)])'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上使用的 HTTP 协议运行在 TCP 上，那么为什么 UDP 端口 80 也被保留用于 HTTP 呢？答案相当简单：计算机人士很容易感到困惑。让两个服务共享相同的端口号但运行在不同的协议上会让人困惑——例如，`syslog`
    服务通过 UDP 在端口 514 上运行，而 `lpr` 打印机协议通过 TCP 在端口 514 上运行.^([[32](#ftn.id322914)])
- en: Some server programs read */etc/services* to learn which port to bind to on
    startup, and many client programs read */etc/services* to learn which port they
    should try to connect to. If you run servers on unusual ports, you might need
    to edit this file to get these programs to attach where needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器程序在启动时读取 */etc/services* 来了解应该绑定到哪个端口，而许多客户端程序也读取 */etc/services* 来了解它们应该尝试连接到哪个端口。如果你在非标准端口上运行服务器，你可能需要编辑此文件，以便这些程序在需要的地方附加。
- en: As with all standards, there are times you will want to break the rules. The
    SSH daemon `sshd` normally binds to port 22/TCP, but I’ve run it on ports 23 (`telnet`),
    80 (`www`), 443 (`https`), and others to evade naïve packet-filtering firewalls.
    You will find your own reasons to break the standards. That’s fine, as long as
    you understand what you’re doing and how it affects others.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有标准一样，有时你会想要打破规则。SSH 守护进程 `sshd` 通常绑定到端口 22/TCP，但我已经将它运行在端口 23 (`telnet`)、80
    (`www`)、443 (`https`) 等其他端口上，以规避简单的数据包过滤防火墙。你会发现你自己的理由去打破标准。这是可以的，只要你理解你在做什么以及它如何影响他人。
- en: Reserved Ports
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保留端口
- en: Ports below 1024 in both TCP and UDP can be opened only by the root user. These
    ports are assigned (mostly) to core Internet infrastructure protocols, such as
    DNS, SSH, HTTP, LDAP, and so on—services that only a few select hosts on each
    network should offer. Only programs with root-level privileges can bind to reserved
    ports. For example, a user can run a game server on a high-numbered port if the
    system policy allows, but that’s different from setting up a web page visible
    to the whole world that claims the machine’s official purpose is a game server.
    The port assignment for these core protocols is generally permanent, and if you
    want to interoperate with other sites, you won’t change them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TCP 和 UDP 中低于 1024 的端口只能由 root 用户打开。这些端口分配（主要是）给核心互联网基础设施协议，如 DNS、SSH、HTTP、LDAP
    等等——只有网络中少数选定的主机应该提供的服务。只有具有 root 级别权限的程序才能绑定到保留端口。例如，如果系统策略允许，用户可以在高编号端口上运行游戏服务器，但这与设置一个面向全世界的网页不同，该网页声称机器的官方目的是游戏服务器。这些核心协议的端口分配通常是永久的，如果你想要与其他站点互操作，你不会改变它们。
- en: OpenBSD software usually binds to a reserved port as root and then drops privileges,
    performing the rest of its functions as an unprivileged user. These unprivileged
    users, discussed in [Chapter 6](ch06.html "Chapter 6. User Management"), have
    even fewer privileges than a normal user account.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD软件通常以root身份绑定到保留端口，然后降低权限，作为无权限用户执行其余功能。这些无权限用户，在第6章（ch06.html "第6章。用户管理"）中讨论，比普通用户账户的权限还要少。
- en: If you must run a service that binds to a reserved port, and it can run only
    as root, consider carefully whether you actually need it. Try to find an alternative
    server that does privilege separation. If you can’t, at least install that service
    on a dedicated machine to reduce its threat to other services on your network.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须运行绑定到保留端口的程序，并且它只能以root身份运行，请仔细考虑你是否真的需要它。尝试找到一个可以进行权限分离的替代服务器。如果你找不到，至少将此服务安装在专用机器上，以减少其对网络中其他服务构成的威胁。
- en: Which Ports Are Open?
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哪些端口是开放的？
- en: 'So, network services are made available via TCP or UDP ports. Programs bind
    to ports to offer network services. This brings up two obvious questions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，网络服务通过TCP或UDP端口提供。程序绑定到端口以提供网络服务。这提出了两个明显的问题：
- en: Which ports are open?
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些端口是开放的？
- en: What programs are listening to each port?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些程序在监听每个端口？
- en: You can answer these questions with `netstat(1)` and `fstat(1)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `netstat(1)` 和 `fstat(1)` 来回答这些问题。
- en: Using netstat
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 netstat
- en: The `netstat(1)` program provides general visibility into the network stack.
    Use `netstat` to check your routing table, examine open sockets, see how many
    packets are traversing your interfaces, and so on. (I could write an entire book
    about `netstat`, but no one would buy it. Instead, I’ll sprinkle bits of `netstat`
    magic throughout this book.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat(1)` 程序提供了对网络堆栈的一般可见性。使用 `netstat` 检查你的路由表，检查打开的套接字，查看有多少数据包正在穿越你的接口，等等。（我本可以写一本关于
    `netstat` 的整本书，但没有人会买。相反，我将在本书中穿插一些 `netstat` 的魔法。）'
- en: When looking at network information, I recommend turning off DNS lookups by
    using the `-n` flag. You can always rerun a check with DNS turned on, but adding
    DNS queries to the network sockets can sometimes skew the information you’re viewing,
    and almost always slows the command.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看网络信息时，我建议使用 `-n` 标志关闭DNS查找。你总是可以在DNS打开的情况下重新运行检查，但将DNS查询添加到网络套接字有时会扭曲你看到的信息，并且几乎总是会减慢命令的执行速度。
- en: The `-f` argument lets you choose a protocol family to display. Use `-f inet`
    to see only IPv4 sockets, or `-f inet6` to see only IPv6\. Read `netstat(1)` for
    the full protocol list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 参数允许你选择要显示的协议族。使用 `-f inet` 只显示IPv4套接字，或使用 `-f inet6` 只显示IPv6套接字。阅读 `netstat(1)`
    获取完整的协议列表。'
- en: Finally, `-a` tells `netstat` to show all sockets opened by any process, rather
    than just sockets owned by the user.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`-a` 告诉 `netstat` 显示由任何进程打开的所有套接字，而不仅仅是用户拥有的套接字。
- en: 'Let’s put all those options together and have a look at the output. Here, I
    show the open IPv4 sockets on my system:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些选项放在一起，看看输出结果。在这里，我展示了系统上的公开IPv4套接字：
- en: '[PRE7]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The list starts with open TCP ports **1**. The `Recv-Q` and `Send-Q` columns
    **2** show the number of bytes that the system is in the process of receiving
    or trying to send.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表以开放的TCP端口 **1** 开始。`Recv-Q` 和 `Send-Q` 列 **2** 显示了系统正在接收或尝试发送的字节数。
- en: The `Local Address` column shows the IP address attached to the local machine
    where this socket is listening. It’s possible—common, even—for a service to bind
    to a port on only a single address on a machine. If the port is part of an actual
    connection, as the first example **3** shows, the IP address is followed by the
    port number. This particular TCP connection is attached to port 22 at the address
    192.0.2.135\. Port 22 is reserved for SSH, so this is probably an SSH connection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Local Address` 列显示了此套接字正在监听的本地机器上的IP地址。一个服务绑定到机器上的单个地址的端口是可能的——甚至很常见。如果端口是实际连接的一部分，如第一个示例
    **3** 所示，IP地址后面跟着端口号。这个特定的TCP连接连接到地址192.0.2.135的端口22。端口22是为SSH保留的，所以这很可能是SSH连接。'
- en: If the local address is an asterisk followed by a port number **8**, this is
    a wildcard bind. A program has bound to this port, and has asked the kernel to
    figure out the IP address. It’s probably (but not necessarily) a listening socket.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地地址是一个星号后跟端口号 **8**，这是一个通配符绑定。一个程序已绑定到该端口，并请求内核确定IP地址。这可能是（但不一定是）一个监听套接字。
- en: The `Foreign Address` column **4** shows the IP address and port of the remote
    host involved in a connection. If there’s a foreign address shown, it always includes
    the port. If this column shows two asterisks **6**, that means the service is
    waiting for a connection on the local port.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`外部地址`列**4**显示了参与连接的远程主机的IP地址和端口号。如果有显示外部地址，它总是包括端口号。如果此列显示两个星号**6**，则表示服务正在本地端口上等待连接。'
- en: The `(state)` column applies only to TCP connections. A live and working TCP
    connection is in the `ESTABLISHED` state **5**. Other states (`SYN_RCVD`, `ACK`,
    and `SYN+ACK`) are all normal parts of connection creation, while `LAST_ACK`,
    `FIN_WAIT_1`, and `FIN_WAIT_2` mean that the connection is closing. A state of
    `LISTEN` **7** means that this socket is waiting for an incoming connection.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`(状态)`列仅适用于TCP连接。一个活跃且正在工作的TCP连接处于`ESTABLISHED`状态**5**。其他状态（`SYN_RCVD`、`ACK`和`SYN+ACK`）都是连接创建的正常部分，而`LAST_ACK`、`FIN_WAIT_1`和`FIN_WAIT_2`表示连接正在关闭。`LISTEN`状态**7**表示此套接字正在等待传入连接。'
- en: UDP ports are given their own section **9**. You might see remote hosts in the
    UDP section, especially for long-running protocols such as NFS and NTP, but remember
    that UDP is stateless, so you’ll never see state on a UDP connection.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: UDP端口号被分配到自己的部分**9**。你可能会在UDP部分看到远程主机，特别是对于像NFS和NTP这样的长时间运行的协议，但请记住UDP是无状态的，所以在UDP连接上你永远不会看到状态。
- en: 'If you’re interested in only TCP or UDP sockets, you can use the `-p` flag
    to show only a particular protocol. Here, I look at TCP sockets:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只对TCP或UDP套接字感兴趣，可以使用`-p`标志来仅显示特定协议。在这里，我查看TCP套接字：
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While this looks similar to the first output example, note that we see both
    IPv4 and IPv6 TCP connections and services. TCP runs over both IPv4 and IPv6,
    so choosing it shows both address families. It’s entirely possible to have a service
    running on one address family and not the other. Many of my systems listen for
    incoming SSH connections only on IPv6; doing so hides me from port scanners and
    worms (for now, anyway).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来与第一个输出示例相似，但请注意，我们看到了IPv4和IPv6的TCP连接和服务。TCP可以在IPv4和IPv6上运行，所以选择它显示了两个地址族。完全有可能有一个服务在一个地址族上运行，而在另一个地址族上不运行。我的许多系统只监听IPv6上的传入SSH连接；这样做可以让我从端口扫描器和蠕虫中隐藏起来（至少目前是这样）。
- en: 'Rather than listing every service waiting for an incoming connection, you can
    show only live connections by dropping the `-a` flag:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是列出每个等待传入连接的服务，你可以通过省略`-a`标志来仅显示活动连接：
- en: '[PRE9]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using fstat
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用fstat
- en: Now that you know which TCP and UDP ports are open, how can you tell which programs
    are listening on them? OpenBSD includes `fstat(1)`, a program that displays all
    open files and sockets on the system. Network connections are open sockets. Running
    `fstat` on an idle system can generate hundreds of lines of output—one entry for
    each file opened by any process. While that’s educational and useful, it’s not
    what we’re looking for. Specifically, we want to see which programs are holding
    network sockets open. The string `internet` indicates network sockets.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了哪些TCP和UDP端口是开放的，你如何知道哪些程序正在监听它们？OpenBSD包括`fstat(1)`程序，该程序显示系统上所有打开的文件和套接字。网络连接是打开的套接字。在空闲系统上运行`fstat`可以生成数百行输出——每个进程打开的每个文件都有一个条目。虽然这是教育性和有用的，但并不是我们想要的。具体来说，我们想看到哪些程序正在保持网络套接字打开。字符串`internet`表示网络套接字。
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, you see an `sshd` process owned by the user `mwlucas`. That’s an unprivileged
    process, tied to a particular SSH session. Further down the list, you see an SSH
    daemon owned by root listening to the network. When a connection request arrives,
    the root-owned SSH daemon will hand it off to an unprivileged child process. You
    can also see that we have a variety of `sendmail` processes listening to the network.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你看到由用户`mwlucas`拥有的`sshd`进程。这是一个无特权的进程，与特定的SSH会话相关联。在列表的下方，你看到由root拥有的SSH守护进程正在监听网络。当一个连接请求到达时，root拥有的SSH守护进程会将它转交给一个无特权的子进程。你还可以看到我们有一些`sendmail`进程正在监听网络。
- en: This system runs the expected SSH and email servers, and no one has bound anything
    to odd ports. My nasty paranoid suspicions were unfounded (this time, anyway).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统运行了预期的SSH和电子邮件服务器，并且没有人将任何内容绑定到奇数端口。我那令人讨厌的偏执怀疑是没有根据的（至少这次是这样）。
- en: Between `netstat` and `fstat`, you should be able to get a good idea of what
    your system is doing on your network at any given time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`netstat`和`fstat`之间，你应该能够了解在任何给定时间你的系统在网络上的行为。
- en: IP Routing
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP路由
- en: Most sysadmins don’t need to understand much about IP routing, because most
    servers have only one network interface and one default gateway. The network administrator
    gives you an IPv4 address and a default route, you put them in the appropriate
    configuration files, and you’re routed. You don’t need even that for most IPv6
    hosts, as autoconfiguration makes things magically work. Servers will need a static
    IPv6 address and a manual default route.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统管理员不需要深入了解IP路由，因为大多数服务器只有一个网络接口和一个默认网关。网络管理员会给你一个IPv4地址和一个默认路由，你只需将它们放入适当的配置文件中，就可以进行路由。对于大多数IPv6主机来说，甚至不需要这样做，因为自动配置可以使一切神奇地工作。服务器将需要一个静态IPv6地址和一个手动默认路由。
- en: Some servers have multiple interfaces, such as one to their default gateway
    and another to a group of related application or backup servers. OpenBSD systems
    frequently wind up in the network infrastructure, however, or sit in demilitarized
    zones (DMZs) where the server must make routing decisions. If you want to use
    OpenBSD in such an environment, or as a firewall, you must understand the basics
    of routing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器有多个接口，例如一个连接到默认网关，另一个连接到一组相关的应用程序或备份服务器。然而，OpenBSD系统通常位于网络基础设施中，或者位于需要做出路由决策的隔离区（DMZ）。如果你想在这样的环境中使用OpenBSD，或者作为防火墙，你必须了解路由的基本知识。
- en: '*Routing* is simply deciding where to send packets. If your system is attached
    to a network, it doesn’t need to make any decisions; it just sends the packet
    to that network. Your system on 192.0.2.0/24 already knows how to reach any IP
    address beginning with 192.0.2—it can just send everything out to the local Ethernet.
    Where does it send those packets?'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由*简单地说就是决定将数据包发送到何处。如果你的系统连接到网络，它不需要做出任何决定；它只需将数据包发送到该网络。你的192.0.2.0/24系统已经知道如何到达以192.0.2开头的任何IP地址——它只需将所有内容发送到本地以太网。它将这些数据包发送到何处？'
- en: Most computers use a *default route*, which is an IP address on the local network
    where they send all packets bound for nonlocal IP addresses. This is very common
    where one router or firewall provides all network access. This device probably
    also has a default route that points to your ISP, which makes all the complicated
    routing decisions for you.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机使用*默认路由*，这是本地网络中的一个IP地址，它们将所有目标非本地IP地址的数据包发送到该地址。这在只有一个路由器或防火墙提供所有网络访问的地方非常常见。这个设备可能还有一个指向你的ISP的默认路由，为你做出所有复杂的路由决策。
- en: In other cases, you might have a dynamic routing protocol running on your network.
    If you’re using Open Shortest Path First (OSPF), Border Gateway Protocol (BGP),
    or Routing Information Protocol (RIP), OpenBSD has daemons specifically for integrating
    these protocols. There’s an introductory middle ground between full dynamic routing
    and simple default routes, however, and you should understand it before attempting
    full dynamic routing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，你可能在网络中运行动态路由协议。如果你使用的是开放最短路径优先（OSPF）、边界网关协议（BGP）或路由信息协议（RIP），OpenBSD有专门用于集成这些协议的守护进程。然而，在完全动态路由和简单默认路由之间有一个中间地带，在尝试完全动态路由之前，你应该了解它。
- en: We’ll cover a simple case here using an IPv4 example. (IPv6 routing is exactly
    like IPv4 routing, but with a lot more colons.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用一个IPv4示例来介绍一个简单的情况。（IPv6路由与IPv4路由完全相同，但包含更多的冒号。）
- en: IPv4 Routed Network Example
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4路由网络示例
- en: 'If a network has multiple gateways leading to different networks, hosts on
    the network must make routing decisions. Suppose your network has multiple routers
    attached to it, each going to a different network. Machines on your network decide
    where to send packets. Here’s an example of a common double-firewall situation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个网络有多个网关通向不同的网络，网络上的主机必须做出路由决策。假设你的网络连接了多个路由器，每个路由器都连接到不同的网络。你的网络上的计算机决定将数据包发送到何处。以下是一个常见的双防火墙情况的示例：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1616080.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1616080.png)'
- en: In this network design, hosts must transit a DMZ before entering either the
    Internet or the internal network. (Other designs exist, such as the hub-and-spoke
    model, but I’ve specifically chosen a design where routing is needed.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种网络设计中，主机必须穿越DMZ才能进入互联网或内部网络。（其他设计也存在，例如中心辐射模型，但我特意选择了一个需要路由的设计。）
- en: The external firewall provides one layer of protection. It permits only traffic
    specifically deemed necessary (we’ll go into the default deny stance in [Chapter 21](ch21.html
    "Chapter 21. Packet Filtering")). It does, however, permit incoming connections
    to hosts in your DMZ.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 外部防火墙提供了一层保护。它只允许被认为必要的特定流量（我们将在第21章[Chapter 21](ch21.html "Chapter 21. Packet
    Filtering")中介绍默认拒绝策略）。然而，它确实允许连接到你的DMZ主机。
- en: The hosts in the DMZ are to some extent vulnerable. They are not trusted enough
    to be on the internal network. Your intrusion-detection systems or your web servers
    might live here.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: DMZ中的主机在一定程度上是脆弱的。它们不足以信任它们在内部网络中。你的入侵检测系统或你的Web服务器可能在这里。
- en: The internal firewall, like the external firewall, permits only traffic deemed
    necessary to organization purposes. It probably doesn’t allow any connections
    from the outside world, however, and it doesn’t trust the hosts on the DMZ.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 内部防火墙，就像外部防火墙一样，只允许被认为对组织目的必要的流量。然而，它可能不允许来自外部世界的任何连接，并且它不信任DMZ上的主机。
- en: Only highly trusted hosts are permitted on the internal network. This is where
    the organization keeps its most precious data, such as the financial records,
    customer databases, and movie collections.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 只有高度信任的主机才被允许在内部网络上。这是组织保存其最宝贵数据的地方，例如财务记录、客户数据库和电影收藏。
- en: Many of the hosts in this network need to make only very simple routing decisions.
    Anything on the internal network has just one way to reach anything, and any host
    on the Internet has only one way to reach the internal or DMZ networks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络中的许多主机只需要做出非常简单的路由决策。内部网络上的任何事物都只有一种方式可以到达任何事物，而互联网上的任何主机也只有一个方式可以到达内部或DMZ网络。
- en: The external firewall is directly attached to the DMZ network, so it can send
    packets to those hosts. It needs a default route pointing to the Internet so it
    can reach the rest of the world. To reach the hosts on the internal network, it
    must send packets to the internal firewall’s external interface. If you don’t
    configure this on the external firewall, data will never reach the internal firewall.
    Because the external firewall is responsible for the internal network’s Internet
    access, losing this route would disconnect the internal network from the Internet;
    internal systems could send packets, but would never receive any. The external
    firewall needs routing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 外部防火墙直接连接到DMZ网络，因此它可以向这些主机发送数据包。它需要一个指向互联网的默认路由，以便它可以到达世界上的其他地方。要到达内部网络上的主机，它必须将数据包发送到内部防火墙的外部接口。如果你在外部防火墙上没有配置这一点，数据将永远不会到达内部防火墙。因为外部防火墙负责内部网络的互联网访问，丢失此路由将使内部网络与互联网断开连接；内部系统可以发送数据包，但永远不会收到任何数据。外部防火墙需要路由。
- en: Similarly, you could configure routing on each host inside the DMZ. In that
    case, ICMP redirects from the firewalls would provide routing for these hosts,
    but trusting ICMP redirects on a vulnerable network is unwise and messy because
    it assumes that every host on the DMZ and every firewall accepts and sends ICMP
    redirects. If you’re using OpenBSD, you want your server to be secure, so configure
    routing on your DMZ systems.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以在DMZ内部每个主机上配置路由。在这种情况下，来自防火墙的ICMP重定向将为这些主机提供路由，但在易受攻击的网络中信任ICMP重定向是不明智且混乱的，因为它假设DMZ上的每个主机和每个防火墙都接受并发送ICMP重定向。如果你使用OpenBSD，你希望你的服务器是安全的，因此请在你的DMZ系统上配置路由。
- en: In this example, I configure routing for the external firewall. Configuring
    routing for the DMZ hosts is nearly identical to this example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我配置了外部防火墙的路由。为DMZ主机配置路由几乎与这个例子相同。
- en: Managing Routing with route(8)
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用route(8)管理路由
- en: The `route(8)` command manages all system routing. Like `netstat`, `route` has
    several subfunctions that allow you to view, edit, and monitor the system routing
    table. While the `route(8)` man page has complete details, the ability to view,
    add, and delete routes should be enough to get you started.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`route(8)`命令管理所有系统路由。像`netstat`一样，`route`有几个子功能，允许你查看、编辑和监控系统路由表。虽然`route(8)`手册页有完整的详细信息，但查看、添加和删除路由的能力应该足以让你开始。'
- en: Viewing Routes
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查看路由
- en: OpenBSD, like any other network device, keeps routes in a routing table. To
    view the IPv4 and IPv6 routes, enter **`route show`**. Add **`-n`** to remove
    IP-address-to-name translations.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD，就像任何其他网络设备一样，将路由保存在路由表中。要查看IPv4和IPv6路由，请输入**`route show`**。添加**`-n`**以删除IP地址到名称的转换。
- en: 'Here’s the IPv4 routing table:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是IPv4路由表：
- en: '[PRE11]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The table shows the following information:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 表格显示了以下信息：
- en: The `Destination` field lists the range of IP addresses this route applies to—destination
    addresses. The `default` entry indicates the default gateway, which is where the
    system sends all packets that have no specific route.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标`字段列出了此路由应用的IP地址范围——目标地址。`默认`条目表示默认网关，即系统发送所有没有特定路由的数据包的地方。'
- en: The `Gateway` field tells where packets for this route should be sent. A gateway
    could be a hostname, an IP address, or a network interface.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网关`字段说明了此路由的数据包应该发送到何处。网关可以是主机名、IP地址或网络接口。'
- en: The `Flags` field contains markers that indicate what sort of route this is
    and how it behaves. The next section covers the various route flags.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标志`字段包含指示此路由类型及其行为的标记。下一节将介绍各种路由标志。'
- en: The `Refs` field shows the number of references to the route in the kernel (also
    known as the *refcounter*). If the refcounter drops to zero, the route is removed.
    This has no practical use for system administration, because one reference is
    sufficient to keep the route in the routing table; additional references don’t
    change anything.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`引用`字段显示了内核中对该路由的引用次数（也称为*引用计数器*）。如果引用计数器降至零，则删除路由。这对于系统管理来说没有实际用途，因为一个引用就足以保持路由在路由表中；额外的引用不会改变任何事情。'
- en: The `Use` counter increments each time a packet uses that route.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`使用`计数器每次数据包使用该路由时都会增加。'
- en: The `Mtu` is the MTU—the largest frame size that can travel over this route.
    If the field contains a hyphen (`-`), OpenBSD uses the MTU of the underlying physical
    interface. The loopback interface, `lo0`, isn’t a physical interface, so OpenBSD
    explicitly sets the MTU very high. You might see a route with a lower MTU if Path
    MTU Discovery has kicked in.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mtu`是MTU——可以通过此路由传输的最大帧大小。如果字段包含连字符（`-`），OpenBSD将使用底层物理接口的MTU。回环接口`lo0`不是一个物理接口，因此OpenBSD明确地将MTU设置得非常高。您可能会看到具有较低MTU的路由，如果路径MTU发现已启动。'
- en: The `Prio` field gives the route priority. OpenBSD supports multiple routes
    to a single destination. Some routes are more desirable than others, and OpenBSD
    will use the route with the lowest priority number. Routes provided by dynamic
    routing protocols, such as BGP or OSPF, get higher priority numbers than static
    routes.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`优先级`字段给出了路由的优先级。OpenBSD支持到单个目的地的多个路由。一些路由比其他路由更受欢迎，OpenBSD将使用优先级编号最低的路由。由动态路由协议（如BGP或OSPF）提供的路由比静态路由具有更高的优先级编号。'
- en: The `Iface` field shows which interface this route uses.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`接口`字段显示了此路由使用的接口。'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenBSD also includes dynamic routing daemons such as `ospfd(8)` and `bgpd(8)`.
    I don’t cover them here, because that topic would fill a book on its own.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD还包括动态路由守护进程，如`ospfd(8)`和`bgpd(8)`。这里不涉及它们，因为这个主题本身就可以写一本书。
- en: Let’s see what’s interesting in the routes in this sample. The first entry at
    **1** is the system default route. If there is no more specific route, packets
    will be sent to the IP address 192.0.2.1.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个示例中路由中有什么有趣的。第一个条目**1**是系统默认路由。如果没有更具体的路由，数据包将被发送到IP地址192.0.2.1。
- en: To reach the network 127.0.0.0/8 at **2**, packets should go to the IP address
    127.0.0.1\. 127.0.0.0/8 is the address range reserved for loopback addresses,
    and 127.0.0.1 is always the local machine. Notice the high MTU; this is a software
    interface, so there’s no physical limit on the size of frames sent through it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达**2**处的网络127.0.0.0/8，数据包应发送到IP地址127.0.0.1。127.0.0.0/8是为回环地址保留的地址范围，127.0.0.1始终是本地机器。注意高MTU；这是一个软件接口，因此通过它的帧大小没有物理限制。
- en: To reach the IP address 127.0.0.1 at **3**, send the packets to the IP address
    127.0.0.1\. This might seem a bit pedantic, but it’s a valid route and needs to
    be in the table. Remember that 127.0.0.1 is always the loopback address of the
    local machine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达**3**处的IP地址127.0.0.1，请将数据包发送到IP地址127.0.0.1。这听起来可能有点繁琐，但这是一个有效的路由，需要包含在表中。请记住，127.0.0.1始终是本地机器的回环地址。
- en: To reach the IP address 192.0.2.0/24 at **4**, use a gateway of `link#1`. This
    is a local physical interface—in this case, our Ethernet interface. The interface
    named `link#1` is actually the interface with index `#1`, which isn’t really exposed
    to the system administrator anywhere else. These addresses are local to the machine,
    and you must figure out which interface this is by the IP address attached to
    the machine. Addresses local to the machine don’t actually need to be in the routing
    table, but no one has bothered to remove this historical nit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问IP地址192.0.2.0/24的**4**，请使用`link#1`作为网关。这是一个本地物理接口——在这种情况下，我们的以太网接口。名为`link#1`的接口实际上是索引`#1`的接口，实际上在系统管理员的其他地方并没有真正暴露。这些地址是本地的，你必须通过机器上的IP地址来确定这个接口。机器本地的地址实际上不需要在路由表中，但没有人费心移除这个历史性的小错误。
- en: To reach a specific IP address on the local network at **5**, you’ll get a route
    of the IP address and the physical media address. Because this host is connected
    via Ethernet, the gateway is a MAC address. Every local address that the system
    needs to find gets a route entry, and you should almost always show a specific
    route for the default gateway.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本地网络上的特定IP地址**5**，你会得到一个包含IP地址和物理媒体地址的路由。因为此主机通过以太网连接，网关是一个MAC地址。系统需要查找的每个本地地址都会得到一个路由条目，你应该几乎总是显示默认网关的特定路由。
- en: The last route at **6** is for the multicast address range 224/8\. If you’re
    not using multicast, it should go to the local host.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**6**处的最后一个路由是为多播地址范围224/8设计的。如果你没有使用多播，它应该指向本地主机。'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Multicast is a complicated topic beyond the scope of this book (again). But
    if you’re interested, OpenBSD supports multicast just fine.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 多播是一个超出本书范围（再次）的复杂主题。但如果你感兴趣，OpenBSD支持多播没有问题。
- en: Route Flags
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由标志
- en: 'The `Flags` column of the routing table indicates how routes are generated
    or used. `netstat(1)` contains a complete list of route flags. [Table 11-2](ch11.html#common_route_flags
    "Table 11-2. Table 11-2: Common Route Flags") lists the common ones.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 路由表的`Flags`列指示路由是如何生成或使用的。`netstat(1)`包含完整的路由标志列表。[表11-2](ch11.html#common_route_flags
    "表11-2. 表11-2：常见路由标志")列出了常见的标志。
- en: 'Table 11-2. Table 11-2: Common Route Flags'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-2。表11-2：常见路由标志
- en: '| Flag | Description |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `C` | This route was cloned. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `C` | 此路由已被克隆。 |'
- en: '| `c` | This is a protocol-specific route (such as to an Ethernet MAC address).
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 这是一个特定协议的路由（例如，到以太网MAC地址）。 |'
- en: '| `D` | This route is dynamic. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 此路由是动态的。 |'
- en: '| `G` | This route goes via a gateway. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `G` | 此路由通过网关转发。 |'
- en: '| `H` | This route is for a specific host. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 此路由是为特定主机设计的。 |'
- en: '| `L` | This route is for the local link layer. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `L` | 此路由是用于本地链路层的。 |'
- en: '| `M` | This route was modified. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `M` | 此路由已被修改。 |'
- en: '| `R` | This is a reject route. Packets are dropped, and an error is sent.
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `R` | 这是一个拒绝路由。数据包被丢弃，并发送错误。 |'
- en: '| `B` | This is a blackhole route. Packets are dropped silently. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `B` | 这是一个黑洞路由。数据包被静默丢弃。 |'
- en: These flags tell you where a route came from and how it’s used.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志告诉你路由的来源以及如何使用它。
- en: Adding Routes
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加路由
- en: Add routes with the `route add` command. You must know the destination network,
    its netmask, and the gateway.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`route add`命令添加路由。你必须知道目标网络、其子网掩码和网关。
- en: '[PRE12]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our example network, the outer firewall needs a route to reach the private
    network, 192.0.2.128/25\. To route this network to the inner firewall at 192.0.2.2,
    run this command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例网络中，外防火墙需要一个路由来访问私有网络，192.0.2.128/25。要将此网络路由到内防火墙192.0.2.2，请运行以下命令：
- en: '[PRE13]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Packets will use that route immediately. If you run `route show`, you’ll see
    that new route.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包将立即使用该路由。如果你运行`route show`，你会看到新路由。
- en: 'To add a default route, run `route add default` with the IP address of the
    default gateway, like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加默认路由，请运行`route add default`，并指定默认网关的IP地址，如下所示：
- en: '[PRE14]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To add routes automatically at boot, put the `route` statement in the */etc/hostname.if*
    file that leads to the destination network. These routes appear when the interface
    is brought up, before */etc/rc.securelevel* runs or any local daemons start. You’ll
    see examples of using *hostname.if* for routes in the next chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动时自动添加路由，请将`route`语句放入指向目标网络的*/etc/hostname.if*文件中。这些路由在接口启动时出现，在*/etc/rc.securelevel*运行或任何本地守护进程启动之前。你将在下一章中看到使用*hostname.if*添加路由的示例。
- en: To add a default route automatically at boot, put the default router IP address
    in */etc/mygate*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动时自动添加默认路由，请将默认网关IP地址放入*/etc/mygate*。
- en: Deleting Routes
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除路由
- en: To delete a routing table entry, use `route delete` with the network address
    and netmask.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除路由表条目，请使用`route delete`命令，并指定网络地址和子网掩码。
- en: '[PRE15]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To remove the route added in the previous example, run this command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除之前示例中添加的路由，请运行此命令：
- en: '[PRE16]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should now have a decent idea of how routing works.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对路由的工作方式有一个相当清晰的认识。
- en: Now that you know how things are supposed to fit together, let’s see how to
    configure Ethernet networks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了事物应该如何配合，让我们看看如何配置以太网网络。
- en: '* * *'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[27](#id460204)]) You laugh, but the technical reviewer for this book was
    part of the first IP-over-carrier-pigeon implementation team that tackled the
    practical tests as specified in RFC 1149\. That’s how I knew he had the time to
    review this book in excruciating detail. (If that’s how he spends his time, he
    couldn’t very well claim he was too busy, now could he?)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#id460204)]) 你可能会笑，但本书的技术审稿人是第一个处理RFC 1149中规定的实际测试的IP-over-carrier-pigeon实施团队的一员。这就是我知道他花时间如此详细地审阅这本书的原因。（如果他就是这样度过他的时间，他不可能声称自己太忙，对吧？）
- en: ^([[28](#id433870)]) I never do take pity on my readers; I just don’t want you
    to actually *say* so.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#id433870)]) 我从不真正同情我的读者；我只是不希望你真的*这么说*。
- en: ^([[29](#id369078)]) Some operating systems treat addresses containing numbers
    that begin with 0 as octal. Don’t actually use addresses like 192.000.002.013,
    or you might get a base-8 surprise.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#id369078)]) 一些操作系统将数字以0开头的地址视为八进制。实际上不要使用像192.000.002.013这样的地址，否则你可能会得到一个基于8的惊喜。
- en: ^([[30](#id453475)]) Or you can go look it up. Whatever—you not believing me
    won’t hurt my feelings.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#id453475)]) 或者你可以去查查。随便吧——你不相信我并不会伤害我的感情。
- en: ^([[31](#id324463)]) For the record, Uncle Mike’s security policy prevents him
    from passing baked sweet potatoes. If you want them, you’re going to have to take
    them by force.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#id324463)]) 记录在案，迈克叔叔的安全策略阻止他传递烤甘薯。如果你想得到它们，你将不得不强行拿走。
- en: ^([[32](#id322914)]) I used to count how many people confused 514/tcp and 514/udp,
    but the number got so high that I got depressed, so I stopped.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#id322914)]) 我曾经计算过有多少人混淆了514/tcp和514/udp，但这个数字太高了，以至于我感到沮丧，所以我停止了。
