- en: Part II-2. TCP/IP NETWORK INTERFACE/INTERNET LAYER CONNECTION PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分-2. TCP/IP网络接口/互联网层连接协议
- en: '[Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS
    RESOLUTION PROTOCOL (ARP)")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。地址解析与TCP/IP地址解析协议（ARP）")'
- en: '[Chapter 14](ch14.html "Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP
    REVERSE ADDRESS RESOLUTION PROTOCOL (RARP)")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。反向地址解析与TCP/IP反向地址解析协议（RARP）")'
- en: The second layer of the OSI Reference Model is the *data link layer*; it corresponds
    to the TCP/IP *network interface layer*. At this layer, most local area network
    (LAN), wide area network (WAN), and wireless LAN (WLAN) technologies are defined,
    such as Ethernet and IEEE 802.11.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: OSI参考模型的第二层是*数据链路层*；它对应于TCP/IP的*网络接口层*。在这一层，定义了大多数局域网（LAN）、广域网（WAN）和无线局域网（WLAN）技术，如以太网和IEEE
    802.11。
- en: The third layer of the OSI Reference Model is the *network layer*, also called
    the *internet layer* in the TCP/IP model. At this layer, internetworking protocols
    are defined, the most notable being the Internet Protocol (IP).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: OSI参考模型的第三层是*网络层*，在TCP/IP模型中也称为*互联网层*。在这一层，定义了互联网协议，其中最著名的是互联网协议（IP）。
- en: The second and third layers are intimately related, because messages sent at
    the network layer must be carried over individual physical networks at the data
    link layer. They perform different tasks, but as neighbors in the protocol stack,
    they must cooperate with each other.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层和第三层密切相关，因为网络层发送的消息必须在数据链路层通过单个物理网络传输。它们执行不同的任务，但作为协议栈中的邻居，它们必须相互协作。
- en: A set of protocols serves the important task of linking together these two layers
    and allowing them to work together. The problem is deciding where exactly these
    protocols should live. They are sort of the black sheep of the networking world.
    Nobody denies their importance, but they always think they belong in "the other
    guy's" layer. For example, since these protocols pass data on layer 2 networks,
    the folks who deal with layer 2 technologies say the protocols belong at layer
    3\. But those who work with layer 3 protocols consider these low-level protocols
    that provide services to layer 3, and hence put them as part of layer 2.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一组协议承担着将这两层连接起来并使它们协同工作的重任。问题是决定这些协议应该放在哪里。它们在网络世界中有点像“黑羊”。没有人否认它们的重要性，但他们总是认为它们属于“别人的”层。例如，由于这些协议在层2网络上传递数据，处理层2技术的那些人认为这些协议属于层3。但那些与层3协议工作的人认为这些低级协议为层3提供服务，因此将它们视为层2的一部分。
- en: 'So where do these protocols go? Well, to some extent, it doesn''t really matter.
    I consider them somewhat special, so I gave them their own home. Welcome to networking
    layer limbo, also known as OSI model layer 2.5\. This is where I put a couple
    of protocols that serve as glue between the data link and network layers. The
    main job performed here is address resolution, or providing mappings between layer
    2 and layer 3 addresses. This resolution can be done in either direction, and
    is represented by the two TCP/IP protocols described in this part: the Address
    Resolution Protocol (ARP) and the Reverse Address Resolution Protocol (RARP),
    which, despite their similarities, are used for rather different purposes.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些协议去哪里呢？在一定程度上，这并不真的重要。我认为它们有些特别，所以我为它们提供了一个自己的家。欢迎来到网络层混沌之地，也称为OSI模型2.5层。这就是我将一些作为数据链路层和网络层之间粘合剂的协议放在一起的地方。这里的主要工作是地址解析，或者提供层2和层3地址之间的映射。这种解析可以是双向的，在本部分中描述的两个TCP/IP协议中得到了体现：地址解析协议（ARP）和反向地址解析协议（RARP），尽管它们有相似之处，但用于相当不同的目的。
- en: I suggest familiarity with the basics of layer 2 and layer 3 (described in Parts
    I-2 and I-3) before proceeding here. In particular, some understanding of IP addressing
    is helpful, though not strictly necessary.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在继续之前熟悉层2和层3的基础知识（在第I-2部分和I-3部分中描述），特别是对IP地址的某些理解有帮助，尽管不是严格必要的。
- en: Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。地址解析与TCP/IP地址解析协议（ARP）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Communication on an internetwork is accomplished by sending data at layer 3
    using a network layer address, but the actual transmission of that data occurs
    at layer 2 using a data link layer address. This means that every device with
    a fully specified networking protocol stack will have both a layer 2 and a layer
    3 address. It is necessary to define some way of being able to link these addresses
    together. Usually, this is done by taking a network layer address and determining
    what data link layer address goes with it. This process is called *address resolution*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上的通信是通过在第3层使用网络层地址发送数据来完成的，但实际上数据的传输是在第2层使用数据链路层地址进行的。这意味着每个具有完全指定的网络协议栈的设备都将拥有第2层和第3层的地址。有必要定义一种方法来将这些地址联系起来。通常，这是通过获取网络层地址并确定与之相对应的数据链路层地址来实现的。这个过程被称为*地址解析*。
- en: In this chapter, I look at the problem of address resolution at both a conceptual
    and practical level, with, of course, a focus on how it is done in the TCP/IP
    protocol suite. I begin with an overview of address resolution in gen-eral terms,
    which describes the issues involved in the process. I then fully describe the
    TCP/IP Address Resolution Protocol (ARP), probably the best-known and most commonly
    used address resolution technique. I then provide a brief look at how address
    resolution is done for multicast addresses in the Internet Protocol (IP), and
    finally, the method used in the new IP version 6 (IPv6).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我从概念和实际层面探讨了地址解析的问题，当然，重点是它在TCP/IP协议套件中的实现方式。我首先概述了地址解析的一般概念，它描述了过程中涉及的问题。然后，我详细描述了TCP/IP地址解析协议（ARP），这可能是最知名和最常用的地址解析技术。然后，我简要地探讨了在互联网协议（IP）中如何进行多播地址的地址解析，最后，介绍了新IP版本6（IPv6）中使用的方法。
- en: Address Resolution Concepts and Issues
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址解析的概念和问题
- en: Due to the prominence of TCP/IP in the world of networking, most discussions
    of address resolution jump straight to TCP/IP's ARP. This protocol is indeed important,
    and we will take a look at it later in this chapter. However, the basic problem
    of address resolution is not unique to any given implementation that deals with
    it, such as ARP. To provide better understanding of resolving addresses between
    the data link layer and the network layer and to support our examination of ARP,
    we'll begin by looking at the matter in more general terms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP/IP在网络领域的突出地位，大多数关于地址解析的讨论都直接跳到了TCP/IP的ARP。这个协议确实很重要，我们将在本章后面讨论它。然而，地址解析的基本问题并不特定于任何处理它的特定实现，如ARP。为了更好地理解数据链路层和网络层之间解析地址的问题，并支持我们对ARP的考察，我们将首先从更一般的角度来探讨这个问题。
- en: 'I start by discussing the need for address resolution in general terms. I then
    describe the two main methods for solving the address resolution problem: direct
    mapping and dynamic resolution. I also explore some of the efficiency issues involved
    in practical dynamic address resolution, with a focus on the importance of caching.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先从一般意义上讨论地址解析的需求。然后描述了解决地址解析问题的两种主要方法：直接映射和动态解析。我还探讨了实际动态地址解析中的一些效率问题，重点关注缓存的重要性。
- en: The Need for Address Resolution
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址解析的需求
- en: Some people may balk at the notion of address resolution and the need for protocols
    that perform this function. In [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE
    MODEL ISSUES AND CONCEPTS")'s discussion of the OSI Reference Model, I talked
    extensively about how the whole point of having conceptual layers was to separate
    logical functions and allow higher-layer protocols to be hidden from lower-layer
    details. Given this, why do you need address resolution protocols that tie protocols
    and layers together?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能对地址解析的概念以及执行此功能的协议的需求感到犹豫。在[第5章](ch05.html "第5章. OSI参考模型的一般问题和概念")中关于OSI参考模型的讨论中，我详细地谈到了拥有概念层的目的在于分离逻辑功能，并允许高层协议隐藏于底层细节之外。鉴于这一点，为什么你需要将协议和层联系起来的地址解析协议呢？
- en: This is true. However, the OSI Reference Model is exactly that—a *model*. There
    are often practicalities that arise that require solutions that don't strictly
    fit the layer model. When the model doesn't fit reality, the model must yield.
    And so it is in dealing with the problem of address resolution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真的。然而，OSI参考模型正是这样一个*模型*。常常会出现一些需要解决方案的实际情况，这些解决方案并不严格符合层模型。当模型不符合现实时，模型必须让步。因此，在处理地址解析问题时也是如此。
- en: Addressing at Layer 2 and Layer 3
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2层和第3层的地址解析
- en: 'When you consider the seven layers of the OSI Reference Model, there are two
    that deal with addressing: the data link layer and the network layer. The physical
    layer is not strictly concerned with addressing at all, but rather, only with
    sending at the bit level. The layers above the network layer all work with network
    layer addresses.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑OSI参考模型的七层时，有两层与寻址有关：数据链路层和网络层。物理层根本不严格涉及寻址，而是仅在位级别上进行发送。网络层以上的所有层都使用网络层地址。
- en: But why is addressing done at two different layers? The answer is that they
    are very different types of addresses that are used for different purposes. The
    layer 2 addresses (such as IEEE 802 MAC addresses) are used for local transmissions
    between hardware devices that can communicate directly. They are used to implement
    basic local area network (LAN), wireless LAN (WLAN), and wide area network (WAN)
    technologies. In contrast, layer 3 addresses (most commonly, IP addresses) are
    used in internetworking to create the equivalent of a massive virtual network
    at the network layer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么要在两个不同的层级上进行寻址呢？答案是它们是用于不同目的的非常不同类型的地址。第2层地址（如IEEE 802 MAC地址）用于在可以直接通信的硬件设备之间进行本地传输。它们用于实现基本局域网（LAN）、无线局域网（WLAN）和广域网（WAN）技术。相比之下，第3层地址（最常见的是IP地址）用于互联网互连，以在网络层创建一个庞大的虚拟网络。
- en: 'The most important distinction between these types of addresses is between
    layers 2 and 3: Layer 2 deals with directly connected devices (on the same network),
    while layer 3 deals with *indirectly* connected devices (as well as directly connected
    ones). Say, for example, you want to connect to the web server at [http://www.tcpipguide.com](http://www.tcpipguide.com).
    This is a website that runs on a server that has an Ethernet card in it that''s
    used for connecting it to its Internet service provider site. However, even if
    you know its MAC address, you cannot use it to talk directly to this server using
    the Ethernet card in your home PC, because the devices are on different networks—in
    fact, they may be on different continents!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型地址之间最重要的区别在于第2层和第3层：第2层处理直接连接的设备（在同一网络中），而第3层处理*间接*连接的设备（以及直接连接的设备）。比如说，你想连接到[http://www.tcpipguide.com](http://www.tcpipguide.com)上的Web服务器。这是一个运行在服务器上的网站，该服务器内置了以太网卡，用于连接到其互联网服务提供商站点。然而，即使你知道它的MAC地址，你也不能使用它通过你家用PC中的以太网卡直接与该服务器通信，因为设备位于不同的网络中——实际上，它们可能位于不同的洲！
- en: Instead, you communicate at layer 3, using the IP and higher-layer protocols
    such as the Transmission Control Protocol (TCP) and Hypertext Transfer Protocol
    (HTTP). Your request is *routed* from your home machine, through a sequence of
    routers to the server at *The TCP/IP Guide*, and the response is routed back to
    you. The communication is, logically, at layers 3 and above; you send the request
    not to the MAC address of the server's network card, but rather to the server's
    IP address.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你在第3层进行通信，使用IP和更高层协议，如传输控制协议（TCP）和超文本传输协议（HTTP）。你的请求从你的家用机器出发，通过一系列路由器到达“TCP/IP指南”服务器，响应信息再返回给你。从逻辑上讲，通信是在第3层及以上进行的；你发送请求不是直接到服务器的网络卡的MAC地址，而是发送到服务器的IP地址。
- en: However, though you can *virtually* connect devices at layer 3, these connections
    are really conceptual only. When you send a request using IP, it is sent one *hop*
    at a time, from one physical network to the next. At each of these hops, an actual
    transmission occurs at the physical and data link layers. When your request is
    sent to your local router at layer 3, the actual request is encapsulated in a
    frame using whatever method you physically connect to the router, and then passed
    to the router using its data link layer address. The same happens for each subsequent
    step, until finally, the router nearest the destination sends to the destination
    using its data link (MAC) address. This is illustrated in [Figure 13-1](ch13.html#why_address_resolution_is_necessary_even
    "Figure 13-1. Why address resolution is necessary Even though conceptually the
    client and server are directly connected at layer 3, in reality, information passing
    between them goes over multiple layer 2 links. In this example, a client on the
    local network is accessing a server somewhere on the Internet. Logically, this
    connection can be made directly between the client and server, but in reality,
    it is a sequence of physical links at layer 2\. In this case, there are six such
    links, most of them between routers that lie between the client and server. At
    each step, the decision of where to send the data is made based on a layer 3 address,
    but the actual transmission must be performed using the layer 2 address of the
    next intended recipient in the route.").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管你可以在第3层**虚拟地**连接设备，但这些连接实际上只是概念上的。当你使用IP发送请求时，请求是逐个**跳**发送的，从一个物理网络到下一个。在每个这样的跳中，物理和数据链路层都会发生实际传输。当你的请求发送到第3层的本地路由器时，实际的请求会封装在一个使用你物理连接到路由器的任何方法创建的帧中，然后通过路由器的数据链路层地址传递给路由器。后续的每个步骤都会发生同样的情况，直到最终，离目的地最近的路由器使用其数据链路（MAC）地址将数据发送到目的地。这如图[图13-1](ch13.html#why_address_resolution_is_necessary_even
    "图13-1. 为什么地址解析是必要的 尽管在概念上客户端和服务器在第3层直接连接，但实际上它们之间的信息传递要经过多个第2层链路。在这个例子中，本地网络上的一个客户端正在访问互联网上的某个服务器。逻辑上，这种连接可以直接在客户端和服务器之间建立，但实际上，它是一系列第2层的物理链路。在这种情况下，有六个这样的链路，其中大多数位于客户端和服务器之间的路由器之间。在每一步，数据发送的决定是基于第3层地址，但实际上必须使用路由路径中下一个预期接收者的第2层地址进行传输。")所示。
- en: '![Why address resolution is necessary Even though conceptually the client and
    server are directly connected at layer 3, in reality, information passing between
    them goes over multiple layer 2 links. In this example, a client on the local
    network is accessing a server somewhere on the Internet. Logically, this connection
    can be made directly between the client and server, but in reality, it is a sequence
    of physical links at layer 2\. In this case, there are six such links, most of
    them between routers that lie between the client and server. At each step, the
    decision of where to send the data is made based on a layer 3 address, but the
    actual transmission must be performed using the layer 2 address of the next intended
    recipient in the route.](httpatomoreillycomsourcenostarchimages287769.png.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![为什么地址解析是必要的 尽管在概念上客户端和服务器在第3层直接连接，但实际上它们之间的信息传递要经过多个第2层链路。在这个例子中，本地网络上的一个客户端正在访问互联网上的某个服务器。逻辑上，这种连接可以直接在客户端和服务器之间建立，但实际上，它是一系列第2层的物理链路。在这种情况下，有六个这样的链路，其中大多数位于客户端和服务器之间的路由器之间。在每一步，数据发送的决定是基于第3层地址，但实际上必须使用路由路径中下一个预期接收者的第2层地址进行传输。](httpatomoreillycomsourcenostarchimages287769.png.jpg)'
- en: Figure 13-1. Why address resolution is necessary Even though conceptually the
    client and server are directly connected at layer 3, in reality, information passing
    between them goes over multiple layer 2 links. In this example, a client on the
    local network is accessing a server somewhere on the Internet. Logically, this
    connection can be made directly between the client and server, but in reality,
    it is a sequence of physical links at layer 2\. In this case, there are six such
    links, most of them between routers that lie between the client and server. At
    each step, the decision of where to send the data is made based on a layer 3 address,
    but the actual transmission must be performed using the layer 2 address of the
    next intended recipient in the route.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1. 为什么地址解析是必要的 虽然在概念上客户端和服务器在第三层直接连接，但在现实中，它们之间传递的信息要经过多个第二层链接。在这个例子中，本地网络上的一个客户端正在访问互联网上的某个服务器。在逻辑上，这个连接可以直接在客户端和服务器之间建立，但在现实中，它是一系列第二层的物理链接。在这种情况下，有六个这样的链接，其中大多数位于客户端和服务器之间的路由器之间。在每一步，决定将数据发送到哪里的决策是基于第三层地址，但实际的传输必须使用路由中下一个预期接收者的第二层地址来执行。
- en: 'The basic problem is that IP addresses are at *too high of a level* for the
    physical hardware on networks to deal with; they don''t understand what they are.
    When your request shows up at the router that connects to *The TCP/IP Guide*,
    it can see the [http://www.tcpipguide.com](http://www.tcpipguide.com) server''s
    IP address, but that isn''t helpful: It needs to send to server''s *MAC address*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基本问题是，IP地址对于网络上的物理硬件来说层级太高，它们不理解它们是什么。当你的请求到达连接到**《TCP/IP指南》**的路由器时，它可以看到[http://www.tcpipguide.com](http://www.tcpipguide.com)服务器的IP地址，但这并没有帮助：它需要发送到服务器的**MAC地址**。
- en: The identical issue exists even with communication between devices on a LAN.
    Even if the web server is sitting on the same desk as the client, the communication
    is logically at the IP layer, but must also be accomplished at the data link layer.
    This means you need a way of translating between the addresses at these two layers.
    This process is called *address resolution*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在局域网内的设备之间进行通信，也存在相同的问题。即使Web服务器和客户端坐在同一张桌子上，通信在逻辑上是IP层，但必须在数据链路层完成。这意味着你需要一种在两个层之间转换地址的方法。这个过程被称为**地址解析**。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Address resolution is required because internetworked devices
    communicate logically using layer 3 addresses, but the actual transmissions between
    devices take place using layer 2 (hardware) addresses.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 地址解析是必需的，因为互联网设备使用第三层地址进行逻辑通信，但设备之间的实际传输使用的是第二层（硬件）地址。'
- en: General Address Resolution Methods
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用地址解析方法
- en: In fact, not only do you need to have a way of making this translation, but
    you need to be concerned with the manner in which it is done. Since the translation
    occurs for each hop of every datagram sent over an internetwork, the efficiency
    of the process is extremely important. You don't want to use a resolution method
    that takes a lot of network resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不仅需要有一种进行这种转换的方法，还需要关注它是如何进行的。由于这种转换发生在通过互联网发送的每个数据报的每个跳转中，因此这个过程的高效性非常重要。你不想使用占用大量网络资源的解析方法。
- en: 'Address resolution can be accomplished in two basic ways: direct mapping and
    dynamic resolution.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 地址解析可以通过两种基本方式实现：直接映射和动态解析。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*By necessity, it is not possible to have a fully general address resolution
    method that works automatically. Since it deals with linking data link layer addresses
    to network layer addresses, the implementation must be specific to the technologies
    used in each of these layers. The only method that could really be considered
    generic would be the use of static, manually updated tables that say, link this
    layer 3 address to this layer 2 address." This, of course, is not automatic and
    brings with it all the limitations of manual configuration*.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于必须性，不可能有一个完全通用的自动地址解析方法。因为它涉及到将数据链路层地址与网络层地址链接起来，所以实现必须针对这些层中每个层所使用的特定技术。唯一可以考虑为通用方法的是使用静态、手动更新的表格，例如，将这个第3层地址链接到这个第2层地址。"当然，这并不是自动的，并带来了手动配置的所有局限性*。'
- en: Address Resolution Through Direct Mapping
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过直接映射进行地址解析
- en: Network layer addresses must be resolved into data link layer addresses numerous
    times during the travel of each datagram across an internetwork. You therefore
    want the process to be as simple and efficient as possible. The easiest method
    of accomplishing this is to do *direct mapping* between the two types of addresses.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个数据报穿越互联网的过程中，网络层地址必须多次解析为数据链路层地址。因此，你希望这个过程尽可能简单和高效。实现这一点的最简单方法是在这两种类型的地址之间进行*直接映射*。
- en: How Direct Mapping Works
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接映射是如何工作的
- en: In the direct mapping technique, a formula is used to map the higher-layer address
    into the lower-layer address. This is the simpler and more efficient technique,
    but it has some limitations, especially regarding the size of the data link layer
    address compared to the network layer address.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接映射技术中，使用一个公式将高层地址映射到低层地址。这是一种更简单、更有效的方法，但它有一些局限性，尤其是在数据链路层地址和网络层地址的大小比较方面。
- en: The basic idea behind direct mapping is to choose a scheme for layer 2 and layer
    3 addresses so that you can determine one from the other using a simple algorithm.
    This enables you to take the layer 3 address and follow a short procedure to convert
    it into a layer 2 address. In essence, whenever you have the layer 3 address,
    you already have the layer 2 address.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 直接映射背后的基本思想是选择一种第2层和第3层地址的方案，以便你可以使用简单的算法从其中一个确定另一个。这使得你可以通过简短的程序将第3层地址转换为第2层地址。本质上，只要你有了第3层地址，你就已经有了第2层地址。
- en: The simplest example of direct mapping would be if you used the same structure
    and semantics for both data link and network layer addresses. This is generally
    impractical, because the two types of addresses serve different purposes, and
    are therefore based on incompatible standards. However, you can still perform
    direct mapping if you have the flexibility of creating layer 3 addresses that
    are large enough to encode a complete data link layer address within them. Then
    determining the layer 2 address is a simply matter of selecting a certain portion
    of the layer 3 address.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 直接映射的最简单例子可能是，如果你为数据链路层和网络层地址使用了相同的结构和语义。这通常是不切实际的，因为这两种类型的地址服务于不同的目的，因此基于不兼容的标准。然而，如果你有足够的灵活性来创建足够大的第3层地址，以便在其中编码完整的链路层地址，你仍然可以进行直接映射。然后确定第2层地址就变成了简单地从第3层地址中选择一定部分的问题。
- en: 'As an example, consider a simple LAN technology like ARCNet. It uses a short,
    8-bit data link layer address, with valid values of 1 to 255, which can be assigned
    by an administrator. You could easily set up an IP network on such a LAN by taking
    a Class C network and using the ARCNet data link layer as the last octet. So,
    if the network was, for example, 222.101.33.0, you could assign the IP address
    222.101.33.1 to the device with ARCNet address #1, the IP address 222.101.33.29
    to the device with ARCNet address #29, and so forth, as shown in [Figure 13-2](ch13.html#address_resolution_through_direct_-id001
    "Figure 13-2. Address resolution through direct mapping With a small hardware
    address size, you can easily map each hardware address to a layer 3 address. As
    you can see in this figure, when the hardware address is small, it is easy to
    define a mapping that directly corresponds to a portion of a layer 3 address.
    In this example, an 8-bit MAC address, such as the one used for ARCNet, is mapped
    to the last byte of the device''s IP address, thereby making address resolution
    a trivial matter.").'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的局域网技术，如ARCNet为例。它使用一个短的8位数据链路层地址，有效值为1到255，可以由管理员分配。你可以在这样的LAN上轻松设置一个IP网络，通过使用ARCNet数据链路层作为最后一个八位字节来从类C网络中获取。因此，如果网络是，例如，222.101.33.0，你可以将IP地址222.101.33.1分配给具有ARCNet地址#1的设备，将IP地址222.101.33.29分配给具有ARCNet地址#29的设备，依此类推，如[图13-2](ch13.html#address_resolution_through_direct_-id001
    "图13-2. 通过直接映射进行地址解析")所示。在一个小的硬件地址大小下，你可以轻松地将每个硬件地址映射到一个第3层地址。如图所示，当硬件地址较小时，定义一个直接对应于第3层地址一部分的映射是很容易的。在这个例子中，一个8位的MAC地址，如ARCNet所使用的，被映射到设备的IP地址的最后字节，从而使地址解析变得微不足道。
- en: '![Address resolution through direct mapping With a small hardware address size,
    you can easily map each hardware address to a layer 3 address. As you can see
    in this figure, when the hardware address is small, it is easy to define a mapping
    that directly corresponds to a portion of a layer 3 address. In this example,
    an 8-bit MAC address, such as the one used for ARCNet, is mapped to the last byte
    of the device''s IP address, thereby making address resolution a trivial matter.](httpatomoreillycomsourcenostarchimages287771.png.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![通过直接映射进行地址解析 由于硬件地址尺寸较小，你可以轻松地将每个硬件地址映射到第3层地址。如图所示，当硬件地址较小时，定义一个直接对应于第3层地址一部分的映射非常容易。在这个例子中，一个8位的MAC地址，例如用于ARCNet的地址，被映射到设备的IP地址的最后字节，从而使地址解析变得非常简单。](httpatomoreillycomsourcenostarchimages287771.png.jpg)'
- en: Figure 13-2. Address resolution through direct mapping With a small hardware
    address size, you can easily map each hardware address to a layer 3 address. As
    you can see in this figure, when the hardware address is small, it is easy to
    define a mapping that directly corresponds to a portion of a layer 3 address.
    In this example, an 8-bit MAC address, such as the one used for ARCNet, is mapped
    to the last byte of the device's IP address, thereby making address resolution
    a trivial matter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2. 通过直接映射进行地址解析 由于硬件地址尺寸较小，你可以轻松地将每个硬件地址映射到第3层地址。如图所示，当硬件地址较小时，定义一个直接对应于第3层地址一部分的映射非常容易。在这个例子中，一个8位的MAC地址，例如用于ARCNet的地址，被映射到设备的IP地址的最后字节，从而使地址解析变得非常简单。
- en: The appeal of this system is obvious. Conceptually, it is trivial to understand—to
    get the hardware address for a device, you just use the final eight bits of the
    IP address. It's also very simple to program devices to perform, and highly efficient,
    requiring no exchange of data on the network at all.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的吸引力是显而易见的。从概念上讲，理解起来非常简单——要获取设备的硬件地址，你只需使用IP地址的最后八位即可。编程设备执行操作也非常简单，效率极高，根本不需要在网络上交换数据。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** When the layer 2 address is smaller than the layer 3 address,
    it is possible to define a direct mapping between them so that the hardware address
    can be determined directly from the network layer address. This makes address
    resolution extremely simple, but reduces flexibility in how addresses are assigned.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 当第2层地址小于第3层地址时，可以在它们之间定义一个直接映射，以便可以直接从网络层地址确定硬件地址。这使得地址解析变得极其简单，但减少了地址分配的灵活性。'
- en: Problems with Direct Mapping
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接映射的问题
- en: Unfortunately, direct mapping works only when it is possible to express the
    data link layer address as a function of the network layer address. Consider instead
    the same IP address, 222.101.33.29, which is running on an Ethernet network. Here,
    the data link layer addresses are hardwired into the hardware itself (they can
    sometimes be overridden, but usually this is not done). More important, the MAC
    address is 48 bits wide, not 8\. This means the layer 2 address is bigger than
    the layer 3 address, and there is no way to do direct mapping, as [Figure 13-3](ch13.html#address_resolution_problems_with_large_h
    "Figure 13-3. Address resolution problems with large hardware address size Direct
    mapping is impossible when the layer 2 address is larger in size than the layer
    3 address.") illustrates. As you can see, when the layer 2 address is larger in
    size than the layer 3 address, it is not possible to define a mapping between
    them that can be used for address resolution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，直接映射仅在数据链路层地址可以表示为网络层地址的函数时才有效。考虑一下相同的IP地址，222.101.33.29，它在以太网网络上运行。在这里，数据链路层地址是硬编码在硬件本身中的（有时可以覆盖，但通常不这样做）。更重要的是，MAC地址是48位宽，而不是8位。这意味着第2层地址比第3层地址大，无法进行直接映射，如图13-3所示。如图所示，当第2层地址的尺寸大于第3层地址时，无法定义一个用于地址解析的映射。
- en: '![Address resolution problems with large hardware address size Direct mapping
    is impossible when the layer 2 address is larger in size than the layer 3 address.](httpatomoreillycomsourcenostarchimages287773.png.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![大硬件地址尺寸的地址解析问题 当第2层地址的尺寸大于第3层地址时，直接映射是不可能的。](httpatomoreillycomsourcenostarchimages287773.png.jpg)'
- en: Figure 13-3. Address resolution problems with large hardware address size Direct
    mapping is impossible when the layer 2 address is larger in size than the layer
    3 address.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3. 使用大硬件地址大小的地址解析问题 当第 2 层地址的大小大于第 3 层地址时，直接映射是不可能的。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*When the hardware address size exceeds the network layer address size, you
    could do a partial mapping. For example, you could use the IP address to get*
    part *of the MAC address and hope you don''t have any duplication in the bits
    you didn''t use. This method is not well suited to regular transmissions, but
    is used for resolving multicast addresses in IPv4 to Ethernet addresses. You''ll
    see how this is done near the end of the chapter*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*当硬件地址大小超过网络层地址大小时，你可以进行部分映射。例如，你可以使用 IP 地址来获取*部分*的 MAC 地址，并希望你在未使用的位上没有重复。这种方法不适合常规传输，但用于在
    IPv4 中解析多播地址到以太网地址。你将在本章末尾看到这是如何完成的*。'
- en: In general, then, direct mapping is not possible when the layer 3 address is
    smaller than the layer 2 address. Consider that Ethernet is the most popular technology
    at layer 2 and uses a 48-bit address, and IP is the most popular technology at
    layer 3 and uses a 32-bit address. This is one reason why direct mapping is a
    technique that is not widely used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说，当第 3 层地址小于第 2 层地址时，直接映射是不可能的。考虑到以太网是第 2 层最流行的技术，使用 48 位地址，而 IP 是第 3
    层最流行的技术，使用 32 位地址。这就是为什么直接映射是一种不太广泛使用的技术的原因。
- en: What about the next generation of IP? IPv6 supports massive 128-bit addresses
    (see [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING")). Furthermore, regular
    (unicast) addresses are even defined using a method that creates them from data
    link layer addresses using a special mapping. This would, in theory, allow IPv6
    to use direct mapping for address resolution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那下一代 IP 呢？IPv6 支持大量的 128 位地址（见[第 25 章](ch25.html "第 25 章。IPv6 地址"))。此外，常规（单播）地址甚至是通过一种方法定义的，该方法使用特殊映射从数据链路层地址创建它们。在理论上，这将允许
    IPv6 使用直接映射进行地址解析。
- en: 'However, the decision was made to have IPv6 use dynamic resolution just as
    IPv4 does. One reason might be historical, since IPv4 uses dynamic resolution.
    However, the bigger reason is probably due to a disadvantage of direct mapping:
    its inflexibility. Dynamic resolution is a more generalized solution, because
    it allows data link layer and network layer addresses to be independent, and its
    disadvantages can be mostly neutralized through careful implementation, as you
    will see.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，决定让 IPv6 使用与 IPv4 一样动态解析。一个可能的原因是历史原因，因为 IPv4 使用动态解析。然而，更大的原因可能是直接映射的缺点：它的不灵活性。动态解析是一个更通用的解决方案，因为它允许数据链路层和网络层地址独立，并且其缺点可以通过仔细的实现大部分得到中和，正如你将看到的。
- en: In fact, evidence for this can be seen in the fact that dynamic resolution of
    IP is defined on ARCNet, the example I just used. You could do direct mapping
    there, but it restricts you to a certain pattern of IP addressing that reduces
    flexibility.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种证据可以在 IP 的动态解析定义在 ARCNet 的事实中看到，我刚才提到的例子。你可以在那里进行直接映射，但它限制了你使用一定模式的 IP
    地址，这减少了灵活性。
- en: Dynamic Address Resolution
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态地址解析
- en: You just saw that direct mapping provides a simple and highly efficient means
    of resolving network layer addresses into data link layer addresses. Unfortunately,
    it is a technique that you either cannot or should not use in a majority of cases.
    You cannot use it when the size of the data link layer address is larger than
    that of the network layer address. You shouldn't use it when you need flexibility,
    because direct mapping requires you to make layer 3 and layer 2 addresses correspond.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到，直接映射提供了一种简单且非常高效的将网络层地址解析为数据链路层地址的方法。不幸的是，这是一种在大多数情况下你既不能使用也不应该使用的技术。当数据链路层地址的大小大于网络层地址的大小时，你不能使用它。当你需要灵活性时，你不应该使用它，因为直接映射要求你使第
    3 层和第 2 层地址相对应。
- en: The alternative to direct mapping is a technique called *dynamic address resolution*.
    This uses a special protocol that allows a device with only an IP address to determine
    the corresponding data link layer address, even if the two address types take
    completely different forms. This is normally done by interrogating one or more
    other devices on a local network to determine what data link layer address corresponds
    to a given IP address. This is more complex and less efficient than direct mapping,
    but it's more flexible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 直接映射的替代方法是称为 *动态地址解析* 的技术。这使用一种特殊的协议，允许只有IP地址的设备确定对应的数据链路层地址，即使这两种地址类型完全不同。这通常是通过查询本地网络中的一个或多个其他设备来确定与给定IP地址相对应的数据链路层地址来完成的。这比直接映射更复杂、效率更低，但更灵活。
- en: How Dynamic Addressing Works
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态寻址的工作原理
- en: 'To understand how dynamic addressing works, you can consider a simple analogy.
    I''m sure you''ve seen a limousine driver who is waiting to pick up a person at
    the airport. (Well, you''ve seen it in a movie, haven''t you?) This is similar
    to the problem here: The driver knows the name of the person who will be transported,
    but not the person''s face (a type of "local address" in a manner of speaking!).
    To find the person, the driver holds up a card bearing that person''s name. Everyone
    other than that person ignores the card, but the named individual should recognize
    it and approach the driver.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解动态寻址是如何工作的，你可以考虑一个简单的类比。我敢肯定你见过在机场等待接人的豪华轿车司机。（嗯，你在电影里见过，不是吗？）这与这里的问题类似：司机知道将被运输的人的名字，但不知道那个人的面孔（从某种意义上说，这是一种“本地地址”！）。为了找到那个人，司机举起了写有那个人名字的卡片。除了那个人之外的其他人都忽略了这张卡片，但被点名的人应该认出它并走向司机。
- en: You do the same thing with dynamic address resolution in a network. Let's say
    that Device A wants to send to Device B but knows only Device B's network layer
    address (its "name") and not its data link layer address (its "face"). It broadcasts
    a layer 2 frame containing the layer 3 address of Device B—this is like holding
    up the card with someone's name on it. The devices other than Device B don't recognize
    this layer 3 address and ignore it. Device B, however, knows its own network layer
    address. It recognizes this in the broadcast frame and sends a direct response
    back to Device A. This tells Device A what Device B's layer 2 address is, and
    the resolution is complete. [Figure 13-4](ch13.html#dynamic_address_resolution_the_device_th
    "Figure 13-4. Dynamic address resolution The device that wants to send data broadcasts
    a request asking for a response with a hardware address from the other device.
    Device A needs to send data to Device B, but knows only its IP address (IPB) and
    not its hardware address. Device A broadcasts a request asking to be sent the
    hardware address of the device using the IP address IPB. Device B responds back
    to Device A directly with the hardware address.") illustrates the process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，动态地址解析做的是同样的事情。假设设备A想要向设备B发送数据，但只知道设备B的网络层地址（它的“名字”），而不是它的数据链路层地址（它的“面孔”）。它广播一个包含设备B的第三层地址的层2帧——这就像拿着写有某人名字的卡片一样。除了设备B之外的其他设备不识别这个第三层地址，并忽略它。然而，设备B知道自己的网络层地址。它在广播帧中识别出这一点，并直接向设备A发送响应。这告诉设备A设备B的层2地址，解析完成。[图13-4](ch13.html#dynamic_address_resolution_the_device_th
    "图13-4. 动态地址解析 想要发送数据的设备广播一个请求，要求从另一个设备那里获取带有硬件地址的响应。设备A需要向设备B发送数据，但只知道它的IP地址（IPB），而不是它的硬件地址。设备A广播一个请求，要求使用IP地址IPB发送设备的硬件地址。设备B直接向设备A响应，提供硬件地址。")展示了这个过程。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *Dynamic address resolution* is usually implemented using a
    special protocol. A device that knows only the network layer address of another
    device can use this protocol to request the other device''s hardware address.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *动态地址解析* 通常是通过一种特殊的协议来实现的。一个只知道另一个设备的网络层地址的设备可以使用此协议来请求该设备的硬件地址。'
- en: '![Dynamic address resolution The device that wants to send data broadcasts
    a request asking for a response with a hardware address from the other device.
    Device A needs to send data to Device B, but knows only its IP address (IPB) and
    not its hardware address. Device A broadcasts a request asking to be sent the
    hardware address of the device using the IP address IPB. Device B responds back
    to Device A directly with the hardware address.](httpatomoreillycomsourcenostarchimages287775.png.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![动态地址解析 该设备想要发送数据，广播一个请求，要求从另一设备获取响应的硬件地址。设备A需要向设备B发送数据，但只知道其IP地址（IPB），而不知道其硬件地址。设备A广播一个请求，要求使用IP地址IPB发送该设备的硬件地址。设备B直接向设备A响应，提供硬件地址。](http://atomoreilly.com/source/nostarch/images/287775.png.jpg)'
- en: Figure 13-4. Dynamic address resolution The device that wants to send data broadcasts
    a request asking for a response with a hardware address from the other device.
    Device A needs to send data to Device B, but knows only its IP address (IPB) and
    not its hardware address. Device A broadcasts a request asking to be sent the
    hardware address of the device using the IP address IPB. Device B responds back
    to Device A directly with the hardware address.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4. 动态地址解析 想要发送数据的设备广播一个请求，要求从另一设备获取响应的硬件地址。设备A需要向设备B发送数据，但只知道其IP地址（IPB），而不知道其硬件地址。设备A广播一个请求，要求使用IP地址IPB发送该设备的硬件地址。设备B直接向设备A响应，提供硬件地址。
- en: Direct mapping is very simple, but as you can see, dynamic resolution isn't
    exactly rocket science either! It's a simple technique that is easily implemented.
    Furthermore, it removes the restrictions associated with direct mapping. There
    is no need for any specific relationship between the network layer address and
    the data link layer address; they can have a completely different structure and
    size.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接映射非常简单，但正如你所见，动态解析也不完全是火箭科学！它是一种简单易行且易于实现的技术。此外，它消除了与直接映射相关的限制。网络层地址和数据链路层地址之间不需要任何特定的关系；它们可以具有完全不同的结构和大小。
- en: 'There is one nagging issue though: the efficiency problem. Where direct mapping
    involves a quick calculation, dynamic resolution requires you to use a protocol
    to send a message over the network. Fortunately, there are techniques that you
    can employ to remove some of the sting of this cost through careful implementation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管直接映射涉及快速计算，但动态解析并不完全是火箭科学！它是一种简单易行的技术，可以消除与直接映射相关的限制。网络层地址和数据链路层地址之间不需要任何特定的关系；它们可以具有完全不同的结构和大小。
- en: Dynamic Address Resolution Caching and Efficiency Issues
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态地址解析与效率问题
- en: You've now seen how dynamic address resolution removes the restrictions that
    you saw in direct mapping, thereby allowing you to easily associate layer 2 and
    layer 3 addresses of any size or structure. The only problem with it is that each
    address resolution requires you to send an extra message that would not be required
    in direct mapping. Worse yet, since you don't know the layer 2 identity of the
    recipient, you must use a broadcast message (or at least a multicast), which means
    that many devices on the local network must take resources to examine the data
    frame and check which IP address is being resolved.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了动态地址解析如何消除了你在直接映射中看到的限制，从而允许你轻松地关联任何大小或结构的2层和3层地址。它的唯一问题是，每个地址解析都需要你发送一条额外的消息，这在直接映射中是不必要的。更糟糕的是，由于你不知道接收者的2层身份，你必须使用广播消息（或者至少是多播），这意味着本地网络上的许多设备必须消耗资源来检查数据帧并确定正在解析哪个IP地址。
- en: Sure, sending one extra message may not seem like that big of a deal, and the
    frame doesn't have to be very large since it contains only a network layer address
    and some control information. However, when you have to do this for *every* hop
    of every datagram transmission, the overhead really adds up. For this reason,
    while basic dynamic address resolution is simple and functional, it's usually
    not enough. You must add some *intelligence* to the implementation of address
    resolution in order to reduce the impact on the performance of continual address
    resolutions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，发送一条额外的消息可能看起来不是什么大问题，因为帧不需要非常大，因为它只包含网络层地址和一些控制信息。然而，当你必须为每个数据报传输的每个跳步都这样做时，开销真的会累积起来。因此，尽管基本的动态地址解析简单且功能性强，但通常不足以满足需求。你必须向地址解析的实现中添加一些**智能**，以减少对持续地址解析性能的影响。
- en: Consider that most devices on a local network send to only a small handful of
    other physical devices and tend to do so over and over again. This is a phenomenon
    known as *locality of reference*, which is observed in a variety of different
    areas in the computing field. If you send a request to an Internet website from
    your office PC, it will need to go first to your company network's local router,
    so you will need to resolve the router's layer 2 address. If you later click a
    link on that site, that request will also need to go to the router. In fact, almost
    everything you do off your local network probably goes first to that same router
    (commonly called a *default gateway*). Having to do a fresh resolution each time
    would be, well, stupid. It would be like having to look up the phone number of
    your best friend every time you want to call to say hello.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到局域网上的大多数设备只向少数几个物理设备发送数据，并且往往反复这样做。这种现象被称为*引用局部性*，它在计算领域的许多不同领域都有观察到。如果你从你的办公PC向互联网网站发送请求，它首先需要到达你的公司网络本地路由器，因此你需要解析路由器的层2地址。如果你稍后点击该网站上的链接，该请求也需要发送到路由器。实际上，你几乎在本地网络之外所做的一切可能首先都会发送到同一个路由器（通常称为*默认网关*）。每次都必须进行新的解析将是愚蠢的。这就像每次你想给最好的朋友打电话说你好时，都必须查找他们的电话号码一样。
- en: To avoid being accused of making address resolution protocols that are, well,
    stupid, designers always include a *caching* mechanism. After a device's network
    layer address is resolved to a data link layer address, the link between the two
    is kept in the memory of the device for a period of time. When it needs the layer
    2 address the next time, the device just does a quick lookup in its cache. This
    means that instead of doing a broadcast on every datagram, you do it only once
    for a whole sequence of datagrams.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免被指责设计出愚蠢的地址解析协议，设计者通常会包括一个*缓存*机制。当一个设备的网络层地址解析为数据链路层地址后，这两个地址之间的连接会在设备内存中保持一段时间。当它下次需要层2地址时，设备只需在其缓存中进行快速查找。这意味着，你不需要在每一个数据报上执行广播，而只需在整个数据报序列中执行一次。
- en: Caching is by far the most important performance-enhancing tool in dynamic resolution.
    It transforms what would otherwise be a very wasteful process into one that, most
    of the time, is no less efficient than direct mapping. It does, however, add complexity.
    The cache table entries must be maintained. There is also the problem that the
    information in the table may become *stale* over time. What happens if you change
    the network layer address or the data link layer address of a device? For this
    reason, cache entries must be set to expire periodically. The discussion of caching
    in TCP/IP's ARP later in this chapter shows some of the particulars of how these
    issues are handled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是动态解析中最重要的性能提升工具。它将原本可能非常浪费的过程转变为在大多数情况下与直接映射一样高效的过程。然而，它确实增加了复杂性。缓存表条目必须得到维护。还有一个问题，表中的信息可能会随着时间的推移而变得*过时*。如果你更改了设备的网络层地址或数据链路层地址会发生什么？因此，缓存条目必须定期过期。本章后面关于TCP/IP的ARP中缓存的讨论展示了如何处理这些问题的某些细节。
- en: Other Enhancements to Dynamic Resolution
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态解析的其他增强
- en: Other enhancements are also possible to the basic dynamic resolution scheme.
    Let's consider again our example of sending a request to the Internet. You send
    a request that needs to go to the local router, so you resolve its address and
    send it the request. A moment later, the reply comes back to the router to be
    sent to you, so the router needs *your* address. Thus, it would have to do a dynamic
    resolution on you, even though you just exchanged frames. Again, this is stupid.
    Instead, you can improve efficiency through *cross-resolution*; when Device A
    resolves the address of Device B, Device B also adds the entry for Device A to
    *its* cache.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基本动态解析方案也可以进行其他增强。让我们再次考虑我们的例子，即向互联网发送请求。你发送一个需要发送到本地路由器的请求，因此你解析其地址并发送请求。片刻之后，回复返回到路由器，以便发送给你，因此路由器需要*你的*地址。因此，即使你刚刚交换了帧，它也必须对你进行动态解析。这同样是愚蠢的。相反，你可以通过*交叉解析*来提高效率；当设备A解析设备B的地址时，设备B也会将其条目添加到*自己的*缓存中。
- en: Another improvement can be made, too. If you think about it, the devices on
    a local network are going to talk to each other fairly often, even if they aren't
    chatting right now. If Device A is resolving Device B's network layer address,
    it will broadcast a frame that Devices C, D, E, and so on all see. Why not have
    them also update *their* cache tables with resolution information that they see,
    for future use?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以进行其他改进。如果你这么想，局域网中的设备将会相当频繁地相互通信，即使它们现在没有聊天。如果设备A正在解析设备B的网络层地址，它将广播一个所有设备C、D、E等都能看到的帧。为什么不让它们也更新*它们*的缓存表，以备将来使用解析信息呢？
- en: These and other enhancements all serve to cut down on the efficiency problems
    with dynamic address resolution. They combine to make dynamic resolution close
    enough to direct mapping in overall capability that there is no good reason not
    to use it. Once again, you can see some more particulars of this in the section
    that describes ARP's caching feature.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及其他增强功能都是为了减少动态地址解析的效率问题。它们结合起来使得动态解析在整体能力上接近直接映射，因此没有很好的理由不使用它。再次强调，你可以在描述ARP缓存功能的章节中看到更多关于这方面的细节。
- en: 'Incidentally, one other performance-improving idea sometimes comes up during
    this discussion: Instead of preceding a datagram transmission with an extra broadcast
    step for address resolution, why not just broadcast the datagram and be done with
    it? You actually could do this, and if the datagram were small enough, it would
    be more efficient. Usually, though, datagrams are large, while resolution frames
    can be quite compact; it makes sense to do a small broadcast and then a large
    unicast rather than a large broadcast. Also, suppose you did broadcast this one
    datagram. What about the next datagram and the one after that? Each of these would
    then need to be broadcast also. When you do a resolution with caching, you need
    to broadcast only once in a while, instead of continually.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在这次讨论中，有时还会提出一个提高性能的想法：为什么不直接广播数据报，而不是先进行额外的广播步骤来解析地址呢？实际上你可以这样做，如果数据报足够小，这将更有效率。然而，通常情况下，数据报很大，而解析帧可以相当紧凑；进行小范围的广播然后进行大范围的单播是有意义的，而不是进行大范围的广播。此外，假设你广播了这个数据报。下一个数据报和再下一个数据报怎么办？这些数据报也需要广播。当你使用缓存进行解析时，你只需要偶尔广播一次，而不是持续不断地广播。
- en: TCP/IP Address Resolution Protocol (ARP)
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 地址解析协议 (ARP)
- en: ARP is a full-featured, dynamic resolution protocol used to match IP addresses
    to underlying data link layer addresses. Originally developed for Ethernet, it
    has now been generalized to allow IP to operate over a wide variety of layer 2
    technologies.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ARP 是一个功能齐全的动态解析协议，用于将IP地址与底层的数据链路层地址匹配。最初是为以太网开发的，但现在已被推广，允许IP在多种2层技术上进行操作。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Address Resolution Protocol described here is used for resolving unicast
    addresses in version 4 of the Internet Protocol (IPv4). Multicast addresses under
    IPv4 use a direct mapping method, and IPv6 uses the new Neighbor Discovery (ND)
    Protocol instead of ARP. These methods are both discussed near the end of this
    chapter*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里描述的地址解析协议用于解析互联网协议第4版（IPv4）中的单播地址。IPv4中的多播地址使用直接映射方法，而IPv6使用新的邻居发现（ND）协议而不是ARP。这两种方法都在本章末尾进行讨论*。'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RELATED INFORMATION** *For a discussion of ARP-related issues in networks
    with mobile IP devices, see [Chapter 30](ch30.html "Chapter 30. INTERNET PROTOCOL
    MOBILITY SUPPORT (MOBILE IP)")*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *有关具有移动IP设备的网络中ARP相关问题的讨论，请参阅[第30章](ch30.html "第30章。互联网协议移动支持（移动IP）")*。'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RELATED INFORMATION** *The software application `arp`, which is used to administer
    the TCP/IP ARP implementation on a host, is covered in [Chapter 88](ch88.html
    "Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS")*.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *用于在主机上管理TCP/IP ARP实现的软件应用`arp`，在[第88章](ch88.html "第88章。TCP/IP 管理和故障排除工具与协议")中有详细说明*。'
- en: Physical networks function at layers 1 and 2 of the OSI Reference Model and
    use data link layer addresses. In contrast, internetworking protocols function
    at layer 3, interconnecting these physical networks to create a possibly huge
    internetwork of devices specified using network layer addresses. Address resolution
    is the process whereby network layer addresses are resolved into data link layer
    addresses. This permits data to be sent one hop at a time across an internetwork.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 物理网络在OSI参考模型的第1层和第2层运行，并使用数据链路层地址。相比之下，互联网协议在第三层运行，将这些物理网络互联起来，创建一个可能非常大的设备互联网，这些设备使用网络层地址指定。地址解析是将网络层地址解析为数据链路层地址的过程。这允许数据在互联网中逐跳发送。
- en: The problem of address resolution was apparent from the very start in the development
    of the TCP/IP protocol suite. Much of the early development of IP was performed
    on the then-fledgling Ethernet LAN technology; this was even before Ethernet had
    been officially standardized as IEEE 802.3\. It was necessary to define a way
    to map IP addresses to Ethernet addresses to allow communication over Ethernet
    networks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 地址解析问题在TCP/IP协议套件的开发一开始就很明显。IP的早期开发大部分是在当时新兴的以太网局域网技术上进行的；这甚至是在以太网被正式标准化为IEEE
    802.3之前。有必要定义一种将IP地址映射到以太网地址的方法，以便在以太网网络上进行通信。
- en: 'As we have already seen in this chapter, there are two basic methods to correlate
    IP and Ethernet addresses: direct mapping or dynamic resolution. However, Ethernet
    addresses are 48 bits long, while IP addresses are only 32 bits, which immediately
    rules out direct mapping. Furthermore, the designers of IP wanted the flexibility
    that results from using the dynamic resolution model. To this end, they developed
    the TCP/IP *Address Resolution Protocol (ARP)*. This protocol is described in
    one of the earliest of the Internet RFCs still in common use: RFC 826, "An Ethernet
    Address Resolution Protocol," which was published in 1982.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中已经看到的，关联IP和以太网地址有两种基本方法：直接映射或动态解析。然而，以太网地址是48位长，而IP地址只有32位，这立即排除了直接映射。此外，IP的设计者希望使用动态解析模型带来的灵活性。为此，他们开发了TCP/IP
    *地址解析协议（ARP）*。该协议在互联网RFCs中描述，这些RFC是最早的，现在仍在普遍使用：RFC 826，“一个以太网地址解析协议”，于1982年发布。
- en: The name makes clear that ARP was originally developed for Ethernet. Thus, it
    represents a nexus between the most popular layer 2 LAN protocol and the most
    popular layer 3 internetworking protocol. This is true even two decades later.
    However, it was also obvious from the beginning that even though Ethernet was
    a very common way of transporting IP, it would not be the only one. Therefore,
    ARP was made a general protocol that was capable of resolving addresses from IP
    to Ethernet as well as numerous other data link layer technologies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称上可以看出，ARP最初是为以太网开发的。因此，它代表了最流行的第2层局域网协议和最流行的第3层互联网协议之间的一个枢纽。即使二十年后，这一点仍然是正确的。然而，从一开始就很明显，尽管以太网是传输IP的一种非常常见的方式，但它不会是唯一的方式。因此，ARP被设计成一个通用协议，能够从IP解析到以太网以及其他多种数据链路层技术。
- en: The basic operation of ARP involves encoding the IP address of the intended
    recipient in a broadcast message. It is sent on a local network to allow the intended
    recipient of an IP datagram to respond to the source with its data link layer
    address. This is done using a simple request and reply method. A special format
    is used for ARP messages, which are passed down to the local data link layer for
    transmission.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ARP的基本操作涉及在广播消息中编码目标接收者的IP地址。它被发送到本地网络，以便IP数据报的目标接收者能够用其数据链路层地址对源进行响应。这是通过简单的请求和回复方法完成的。ARP消息使用特殊格式，这些消息被传递到本地数据链路层进行传输。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *ARP* was developed to facilitate dynamic address resolution
    between IP and Ethernet and can now be used on other layer 2 technologies as well.
    It works by allowing an IP device to send a broadcast on the local network, and
    it requests a response with a hardware address from another device on the same
    local network.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *ARP*（地址解析协议）是为了促进IP和以太网之间的动态地址解析而开发的，现在也可以用于其他第2层技术。它通过允许IP设备在本地网络发送广播，并从同一本地网络上的另一设备请求一个硬件地址来工作。'
- en: This basic operation is supplemented by methods to improve performance. Since
    it was known from the start that having to perform a resolution using broadcast
    for each datagram was ridiculously inefficient, ARP has always used a cache, where
    it keeps bindings between IP addresses and data link layer addresses on the local
    network. Over time, various techniques have been developed to improve the methods
    used for maintaining cache entries. Refinements and additional features, such
    as support for cross-resolution by pairs of devices as well as proxy ARP, have
    also been defined over the years and added to the basic ARP feature set.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本操作通过提高性能的方法得到了补充。由于从一开始就知道必须对每个数据报使用广播进行解析是荒谬的低效，因此ARP始终使用一个缓存，在该缓存中它保留本地网络中IP地址和数据链路层地址之间的绑定。随着时间的推移，已经开发出各种技术来改进用于维护缓存条目的方法。在过去的几年中，还定义了改进和附加功能，例如支持设备对之间的交叉解析以及代理ARP，并将这些功能添加到基本的ARP功能集中。
- en: ARP Address Specification and General Operation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARP地址规范和一般操作
- en: An ARP transaction begins when a source device on an IP network has an IP datagram
    to send. It must first decide whether the destination device is on the local network
    or a distant network. If it's the former, it will send directly to the destination;
    if it's the latter, it will send the datagram to one of the routers on the physical
    network for forwarding. Either way, it will determine the IP address of the device
    that needs to be the immediate destination of its IP datagram on the local network.
    After packaging the datagram it will pass it to its ARP software for address resolution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当IP网络上的源设备有一个要发送的IP数据报时，ARP事务就开始了。它必须首先决定目标设备是在本地网络还是远程网络。如果是前者，它将直接发送到目标；如果是后者，它将数据报发送到物理网络上的一个路由器以进行转发。无论哪种方式，它都将确定本地网络上需要成为其IP数据报直接目标设备的IP地址。在封装数据报后，它将将其传递给其ARP软件进行地址解析。
- en: The basic operation of ARP is a *request and response* pair of transmissions
    on the local network. The source (the one that needs to send the IP datagram)
    transmits a broadcast containing information about the destination (the intended
    recipient of the datagram). The destination then responds via unicast back to
    the source, telling the source the hardware address of the destination.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ARP的基本操作是在本地网络上进行的一对请求和响应传输。源（需要发送IP数据报的一方）广播包含有关目标（数据报的预期接收者）的信息。然后目标通过单播向源响应，告诉源目标的硬件地址。
- en: ARP Message Types and Address Designations
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARP消息类型和地址指定
- en: 'The terms *source* and *destination* apply to the same devices throughout the
    transaction. However, there are two different messages sent in ARP: one from the
    source to the destination and one from the destination to the source. For each
    ARP message, the *sender* is the one that is transmitting the message and the
    *target* is the one receiving it. Thus, the identity of the sender and target
    changes for each message. Here''s how the sender and target identities work for
    requests and replies:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*源*和*目标*这两个术语在整个事务中适用于相同的设备。然而，在ARP中发送了两种不同的消息：一种是从源到目标的消息，另一种是从目标到源的消息。对于每个ARP消息，*发送者*是正在传输消息的一方，而*目标*是接收它的一方。因此，发送者和目标的身份在每个消息中都会改变。以下是请求和回复中发送者和目标身份的工作方式：'
- en: '**Request** For the initial request, the sender is the source (the device with
    the IP datagram to send), and the target is the destination.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求** 对于初始请求，发送者是源（要发送IP数据报的设备），目标是目标。'
- en: '**Reply** For the reply to the ARP request, the sender is the destination.
    It replies to the source, which becomes the target.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**回复** 对于ARP请求的回复，发送者是目标。它向源回复，源成为目标。'
- en: 'Each of the two parties in any message has two addresses (layer 2 and layer
    3) to be concerned with, so the following four different addresses are involved
    in each message:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 任何消息中的双方都有两个地址（二层和三层）需要关注，因此每个消息都涉及以下四个不同的地址：
- en: '**Sender Hardware Address** The layer 2 address of the sender of the ARP message.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送者硬件地址** ARP消息的发送者的二层地址。'
- en: '**Sender Protocol Address** The layer 3 (IP) address of the sender of the ARP
    message.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送者协议地址** ARP消息的发送者的三层（IP）地址。'
- en: '**Target Hardware Address** The layer 2 address of the target of the ARP message.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标硬件地址** ARP消息的目标的二层地址。'
- en: '**Target Protocol Address** The layer 3 (IP) address of the target.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标协议地址** 目标的三层（IP）地址。'
- en: These addresses each have a position in the ARP message format, which we'll
    examine shortly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些地址在 ARP 消息格式中都有位置，我们将在稍后进行考察。
- en: ARP General Operation
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARP 通用操作
- en: With that background in place, let's look at the steps that occur in an ARP
    transaction. (These steps are also shown graphically in the illustration in [Figure 13-5](ch13s02.html#address_resolution_protocol_arp_transact
    "Figure 13-5. Address Resolution Protocol (ARP) transaction process ARP works
    by having the source device broadcast a request to find the destination, which
    responds using a reply message. ARP caches are also consulted and updated as needed.").)
    This diagram shows the sequence of steps that occur in a typical ARP transaction,
    as well as the message exchanges between a source and destination device, and
    the cache checking and update functions. (Incidentally, those little stacks are
    hard disks, not cans of soup!)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个背景之后，让我们看看在 ARP 事务中发生的步骤。（这些步骤也在 [图 13-5](ch13s02.html#address_resolution_protocol_arp_transact
    "图 13-5. 地址解析协议 (ARP) 事务处理过程 ARP 通过源设备广播一个请求以查找目标，目标使用回复消息进行响应。ARP 缓存也会被咨询并更新。")
    中的插图中有图形展示。）此图显示了典型 ARP 事务中发生的步骤序列，以及源设备和目标设备之间的消息交换，以及缓存检查和更新功能。（顺便说一句，那些小堆栈是硬盘，而不是汤罐头！）
- en: '**Source Device Checks Cache** The source device will first check its cache
    to determine if it already has a resolution of the destination device. If so,
    it can skip to step 9.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备检查缓存** 源设备首先会检查其缓存以确定是否已经解析了目标设备。如果是这样，它可以直接跳到步骤 9。'
- en: '**Source Device Generates ARP Request Message** The source device generates
    an ARP Request message. It puts its own data link layer address as the Sender
    Hardware Address and its own IP address as the Sender Protocol Address. It fills
    in the IP address of the destination as the Target Protocol Address. (It must
    leave the Target Hardware Address blank, since that it is what it is trying to
    determine!)'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备生成 ARP 请求消息** 源设备生成一个 ARP 请求消息。它将自己的数据链路层地址作为发送者硬件地址，自己的 IP 地址作为发送者协议地址。它填写目标设备的
    IP 地址作为目标协议地址。（它必须将目标硬件地址留空，因为它正在尝试确定这个地址！）'
- en: '**Source Device Broadcasts ARP Request Message** The source broadcasts the
    ARP Request message on the local network.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备广播 ARP 请求消息** 源设备在本地网络上广播 ARP 请求消息。'
- en: '![Address Resolution Protocol (ARP) transaction process ARP works by having
    the source device broadcast a request to find the destination, which responds
    using a reply message. ARP caches are also consulted and updated as needed.](httpatomoreillycomsourcenostarchimages287777.png.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![地址解析协议 (ARP) 事务处理过程 ARP 通过源设备广播一个请求以查找目标，目标使用回复消息进行响应。ARP 缓存也会被咨询并更新。](httpatomoreillycomsourcenostarchimages287777.png.jpg)'
- en: Figure 13-5. Address Resolution Protocol (ARP) transaction process ARP works
    by having the source device broadcast a request to find the destination, which
    responds using a reply message. ARP caches are also consulted and updated as needed.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13-5. 地址解析协议 (ARP) 事务处理过程 ARP 通过源设备广播一个请求以查找目标，目标使用回复消息进行响应。当需要时，ARP 缓存也会被咨询并更新。
- en: '**Local Devices Process ARP Request Message** The message is received by each
    device on the local network. It is processed, with each device looking for a match
    on the Target Protocol Address. Those that do not match will drop the message
    and take no further action.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本地设备处理 ARP 请求消息** 消息被本地网络上的每个设备接收。它被处理，每个设备都会寻找与目标协议地址匹配的匹配项。那些不匹配的将丢弃消息并采取进一步行动。'
- en: '**Destination Device Generates ARP Reply Message** The one device whose IP
    address matches the contents of the Target Protocol Address of the message will
    generate an ARP Reply message. It takes the Sender Hardware Address and Sender
    Protocol Address fields from the ARP Request message and uses these as the values
    for the Target Hardware Address and Target Protocol Address of the reply. It then
    fills in its own layer 2 address as the Sender Hardware Address and its IP address
    as the Sender Protocol Address. Other fields are filled in, as explained in the
    description of the ARP message format in the following section.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**目标设备生成 ARP 回复消息** 那个 IP 地址与消息中的目标协议地址内容匹配的设备将生成一个 ARP 回复消息。它从 ARP 请求消息中获取发送者硬件地址和发送者协议地址字段，并使用这些值作为回复的目标硬件地址和目标协议地址。然后它填写自己的第
    2 层地址作为发送者硬件地址，自己的 IP 地址作为发送者协议地址。其他字段按以下章节中 ARP 消息格式描述的解释进行填写。'
- en: '**Destination Device Updates ARP Cache** If the source needs to send an IP
    datagram to the destination now, it makes sense that the destination will probably
    need to send a response to the source at some point soon. (After all, most communication
    on a network is bidirectional.) Next, as an optimization, the destination device
    will add an entry to its own ARP cache that contains the hardware and IP addresses
    of the source that sent the ARP Request. This saves the destination from needing
    to do an unnecessary resolution cycle later on.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**目标设备更新ARP缓存** 如果源设备现在需要向目标发送IP数据报，那么目标设备可能很快需要向源设备发送响应是有意义的。（毕竟，网络上的大多数通信都是双向的。）接下来，作为一个优化，目标设备将在其ARP缓存中添加一个条目，包含发送ARP请求的源的硬件和IP地址。这可以节省目标设备在以后不需要进行不必要的解析周期。'
- en: '**Destination Device Sends ARP Reply Message** The destination device sends
    the ARP Reply message. This reply is, however, sent unicast to the source device,
    because there is no need to broadcast it.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**目标设备发送ARP回复消息** 目标设备发送ARP回复消息。然而，这个回复是单播发送给源设备的，因为不需要广播。'
- en: '**Source Device Processes ARP Reply Message** The source device processes the
    reply from the destination. It stores the Sender Hardware Address as the layer
    2 address of the destination and uses that address for sending its IP datagram.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备处理ARP回复消息** 源设备处理来自目标的回复。它将发送者硬件地址作为目标层的2层地址存储，并使用该地址发送其IP数据报。'
- en: '**Source Device Updates ARP Cache** The source device uses the Sender Protocol
    Address and Sender Hardware Address to update its ARP cache for use in the future
    when transmitting to this device.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备更新ARP缓存** 源设备使用发送者协议地址和发送者硬件地址来更新其ARP缓存，以便在将来向该设备传输时使用。'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ARP is a relatively simple request-and-reply protocol. The
    source device broadcasts an ARP Request that''s looking for a particular device
    based on the device''s IP address. That device responds with its hardware address
    in an ARP Reply message.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ARP是一种相对简单的请求-回复协议。源设备广播一个ARP请求，根据设备的IP地址寻找特定的设备。该设备通过ARP回复消息回复其硬件地址。'
- en: Note that this description goes a bit beyond the basic steps in address resolution,
    because two enhancements are mentioned. One is caching, which you'll explore shortly.
    The other is cross-resolution (described earlier in this chapter in the overview
    of caching issues in dynamic resolution), which is step 6 of the process. This
    is why the source device includes its IP address in the request. It isn't really
    needed for any other reason, so you can see that this feature was built into ARP
    from the start.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个描述超出了地址解析的基本步骤，因为提到了两个增强功能。一个是缓存，你很快就会了解。另一个是交叉解析（在本章关于动态解析缓存问题的概述中描述），这是过程的第6步。这就是为什么源设备在请求中包含其IP地址的原因。实际上并不需要其他原因，所以你可以看到这个功能是从ARP一开始就被构建在内的。
- en: ARP Message Format
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARP消息格式
- en: You've just seen how address resolution is accomplished in ARP, through an exchange
    of messages between the source device seeking to perform the resolution and the
    destination device that responds to it. As with other protocols, a special *message
    format* is used for containing the information required for each step of the resolution
    process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到了如何在ARP中通过源设备寻求解析和响应它的目标设备之间的消息交换来完成地址解析。与其他协议一样，使用特殊的*消息格式*来包含解析过程中每一步所需的信息。
- en: 'ARP messages use a relatively simple format. It includes a field describing
    the type of message (its *operational code* or *opcode*) and information on both
    layer 2 and layer 3 addresses. In order to support addresses that may be of varying
    length, the format specifies the type of protocol used at both layer 2 and layer
    3, as well as the length of the addresses used at each of these layers. It then
    includes space for all four of the address combinations described earlier in this
    chapter: Sender Hardware Address, Sender Protocol Address, Target Hardware Address,
    and Target Protocol Address.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ARP消息使用相对简单的格式。它包括一个字段，描述消息的类型（其*操作码*或*opcode*）以及关于第2层和第3层地址的信息。为了支持可能具有不同长度的地址，格式指定了第2层和第3层使用的协议类型，以及在这些层中使用的地址长度。然后包括空间以容纳本章前面描述的所有四种地址组合：发送者硬件地址、发送者协议地址、目标硬件地址和目标协议地址。
- en: The format used for ARP messages is described in [Table 13-1](ch13s02.html#arp_message_format-id001
    "Table 13-1. ARP Message Format"). [Figure 13-6](ch13s02.html#arp_message_format-id002
    "Figure 13-6. ARP message format") shows how the ARP message format is designed
    to accommodate layer 2 and layer 3 addresses of various sizes. This diagram shows
    the most common implementation, which uses 32 bits for the layer 3 ("Protocol")
    addresses and 48 bits for the layer 2 hardware addresses. These numbers correspond
    to the address sizes of the IPv4 and IEEE 802 MAC addresses that are used by Ethernet.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ARP 消息的格式在 [表 13-1](ch13s02.html#arp_message_format-id001 "表 13-1. ARP 消息格式")
    中描述。 [图 13-6](ch13s02.html#arp_message_format-id002 "图 13-6. ARP 消息格式") 展示了 ARP
    消息格式是如何设计以适应各种大小的层2和层3地址的。此图显示了最常用的实现，它使用 32 位用于层3（"协议"）地址，48 位用于层2硬件地址。这些数字对应于以太网使用的
    IPv4 和 IEEE 802 MAC 地址的大小。
- en: Table 13-1. ARP Message Format
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1. ARP 消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| HRD | 2 | Hardware Type: This field specifies the type of hardware used for
    the local network transmitting the ARP message; thus, it also identifies the type
    of addressing used. Some of the most common values for this field are shown in
    [Table 13-2](ch13s02.html#arp_hardware_type_hrd_field_values "Table 13-2. ARP
    Hardware Type (HRD) Field Values"). |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| HRD | 2 | 硬件类型：此字段指定用于传输 ARP 消息的本地网络的硬件类型；因此，它也标识了使用的寻址类型。此字段最常见的值显示在 [表
    13-2](ch13s02.html#arp_hardware_type_hrd_field_values "表 13-2. ARP 硬件类型 (HRD)
    字段值") 中。 |'
- en: '| PRO | 2 | Protocol Type: This field is the complement of the Hardware Type
    field, specifying the type of layer 3 addresses used in the message. For IPv4
    addresses, this value is 2048 (0800 hex), which corresponds to the EtherType code
    for IP. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| PRO | 2 | 协议类型：此字段是硬件类型字段的补码，指定消息中使用的层3地址的类型。对于 IPv4 地址，此值是 2048（十六进制 0800），对应于
    IP 的 EtherType 代码。 |'
- en: '| HLN | 1 | Hardware Address Length: Specifies how long hardware addresses
    are in this message. For Ethernet or other networks using IEEE 802 MAC addresses,
    the value is 6. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| HLN | 1 | 硬件地址长度：指定此消息中硬件地址的长度。对于以太网或其他使用 IEEE 802 MAC 地址的网络，此值是 6。 |'
- en: '| PLN | 1 | Protocol Address Length: Again, the complement of the preceding
    field; specifies how long protocol (layer 3) addresses are in this message. For
    IPv4 addresses, this value is 4. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| PLN | 1 | 协议地址长度：同样，是前一个字段的补码；指定此消息中协议（层3）地址的长度。对于 IPv4 地址，此值是 4。 |'
- en: '| OP | 2 | Opcode: This field specifies the nature of the ARP message being
    sent. The first two values (1 and 2) are used for regular ARP. Numerous other
    values are also defined to support other protocols that use the ARP frame format,
    such as RARP, as shown in [Table 13-3](ch13s02.html#arp_opcode_op_field_values
    "Table 13-3. ARP Opcode (OP) Field Values"). Some protocols are more widely used
    than others. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| OP | 2 | 操作码：此字段指定发送的 ARP 消息的性质。前两个值（1 和 2）用于常规 ARP。还定义了多个其他值以支持使用 ARP 帧格式的其他协议，如
    RARP，如 [表 13-3](ch13s02.html#arp_opcode_op_field_values "表 13-3. ARP 操作码 (OP)
    字段值") 所示。某些协议比其他协议更广泛使用。 |'
- en: '| SHA | Variable, equals value in HLN field | Sender Hardware Address: The
    hardware (layer 2) address of the device sending this message, which is the IP
    datagram source device on a request, and the IP datagram destination on a reply.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| SHA | 变量，等于 HLN 字段中的值 | 发送者硬件地址：发送此消息的设备的硬件（层2）地址，在请求中是 IP 数据报源设备，在回复中是 IP
    数据报目标。 |'
- en: '| SPA | Variable, equals value in PLN field | Sender Protocol Address: The
    IP address of the device sending this message. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| SPA | 变量，等于 PLN 字段中的值 | 发送者协议地址：发送此消息的设备的 IP 地址。 |'
- en: '| THA | Variable, equals value in HLN field | Target Hardware Address: The
    hardware (layer 2) address of the device this message is being sent to. This is
    the IP datagram destination device on a request, and the IP datagram source on
    a reply. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| THA | 变量，等于 HLN 字段中的值 | 目标硬件地址：此消息要发送到的设备的硬件（层2）地址。在请求中这是 IP 数据报目标设备，在回复中是
    IP 数据报源。 |'
- en: '| TPA | Variable, equals value in PLN field | Target Protocol Address: The
    IP address of the device this message is being sent to. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| TPA | 变量，等于 PLN 字段中的值 | 目标协议地址：此消息要发送到的设备的 IP 地址。 |'
- en: Table 13-2. ARP Hardware Type (HRD) Field Values
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-2. ARP 硬件类型 (HRD) 字段值
- en: '| Hardware Type (HRD) Value | Hardware Type |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 硬件类型 (HRD) 值 | 硬件类型 |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Ethernet (10 Mb) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 以太网（10 Mb） |'
- en: '| 6 | IEEE 802 Networks |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 6 | IEEE 802 网络 |'
- en: '| 7 | ARCNeT |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 7 | ARCNeT |'
- en: '| 15 | Frame Relay |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| 16 | Asynchronous Transfer Mode (ATM) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| 17 | HDLC |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| 18 | Fibre Channel |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| 19 | Asynchronous Transfer Mode (ATM) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 20 | Serial Line |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: Table 13-3. ARP Opcode (OP) Field Values
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| Opcode | ARP Message Type |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| 1 | ARP Request |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| 2 | ARP Reply |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| 3 | RARP Request |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| 4 | RARP Reply |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| 5 | DRARP Request |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| 6 | DRARP Reply |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| 7 | DRARP Error |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| 8 | InARP Request |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| 9 | InARP Reply |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '![ARP message format](httpatomoreillycomsourcenostarchimages287779.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 13-6. ARP message format
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Once the ARP message has been composed, it is passed down to the data link layer
    for transmission. The entire contents of the ARP message become the payload for
    the message actually sent on the network, such as an Ethernet frame on an Ethernet
    LAN. Note that the total size of the ARP message is variable, since the address
    fields are of variable length. Normally, though, these messages are quite small.
    For example, they are only 28 bytes for a network carrying IPv4 datagrams in IEEE
    802 MAC addresses.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: ARP Caching
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARP is a dynamic resolution protocol, which means that every resolution requires
    the interchange of messages on the network. Each time a device sends an ARP message,
    it ties up the local network, consuming network bandwidth that cannot be used
    for other traffic. ARP messages aren't large, but having to send them for every
    hop of every IP datagram would represent an unacceptable performance hit on the
    network. It also wastes time compared to the simpler direct mapping method of
    resolution. On top of this, the ARP Request message is broadcasted, which means
    every device on the local network must spend CPU time examining the contents of
    each one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The general solution to the efficiency issues with dynamic resolution is to
    employ *caching*. In addition to reducing network traffic, caching also ensures
    that the resolution of commonly used addresses is fast, thereby making overall
    performance comparable to direct mapping. For this reason, caching functionality
    has been built into ARP from the start.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Static and Dynamic ARP Cache Entries
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ARP cache takes the form of a table containing matched sets of hardware
    and IP addresses. Each device on the network manages its own ARP cache table.
    There are two different ways that cache entries can be put into the ARP cache:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Static ARP Cache Entries** These are address resolutions that are manually
    added to the cache table for a device and are kept in the cache on a permanent
    basis. Static entries are typically managed using a tool such as the arp software
    utility (see [Chapter 88](ch88.html "Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING
    UTILITIES AND PROTOCOLS")).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic ARP Cache Entries** These are hardware and IP address pairs that
    are added to the cache by the software itself as a result of past ARP resolutions
    that were successfully completed. They are kept in the cache for only a period
    of time and are then removed.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: A device's ARP cache can contain both static and dynamic entries, each of which
    has advantages and disadvantages. However, dynamic entries are used most often
    because they are automatic and don't require administrator intervention.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的ARP缓存可以包含静态和动态条目，每个条目都有其优缺点。然而，动态条目使用得最频繁，因为它们是自动的，不需要管理员干预。
- en: Static ARP entries are best used for devices that a given device needs to communicate
    with on a regular basis. For example, a workstation might have a static ARP entry
    for its local router and file server. Since the entry is static, it is always
    found in step 1 of the ARP transaction process, and there is no need to ever send
    resolution messages for the destination in that entry. The disadvantage is that
    these entries must be manually added, and they must also be changed if the hardware
    or IP addresses of any of the hardware in the entries change. Also, each static
    entry takes space in the ARP cache, so you don't want to overuse static entries.
    It wouldn't be a good idea to have static entries for every device on the network,
    for example.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 静态ARP条目最适合用于需要定期与之通信的设备。例如，工作站可能为其本地路由器和文件服务器设置静态ARP条目。由于条目是静态的，它总是在ARP事务过程的第1步中找到，并且不需要为该条目中的目标发送解析消息。缺点是这些条目必须手动添加，如果条目中任何硬件的硬件或IP地址发生变化，它们也必须更改。此外，每个静态条目都会占用ARP缓存的空间，因此你不希望过度使用静态条目。例如，为网络上的每个设备设置静态条目可能不是个好主意。
- en: Cache Entry Expiration
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存条目过期
- en: Dynamic entries are added automatically to the cache on an as-needed basis,
    so they represent mappings for hosts and routers that a given device is actively
    using. They do not need to be manually added or maintained. However, it is also
    important to realize that dynamic entries cannot be added to the cache and left
    there forever—dynamic entries left in place for a long time can become stale.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 动态条目根据需要自动添加到缓存中，因此它们代表设备正在积极使用的宿主机和路由器的映射。它们不需要手动添加或维护。然而，重要的是要认识到，动态条目不能永久留在缓存中——长时间留在原地的动态条目可能会变得过时。
- en: Consider Device A's ARP cache, which contains a dynamic mapping for Device B,
    which is another host on the network. If dynamic entries stayed in the cache forever,
    the following situations might arise.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑设备A的ARP缓存，其中包含对设备B的动态映射，设备B是网络上的另一个主机。如果动态条目永远留在缓存中，可能会出现以下情况。
- en: '**Device Hardware Changes** Device B might experience a hardware failure that
    requires its network interface card to be replaced. The mapping in Device A''s
    cache would become invalid, since the hardware address in the entry is no longer
    on the network.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备硬件更改** 设备B可能会遇到需要更换其网络接口卡的硬件故障。由于条目中的硬件地址不再在网络上，设备A的缓存中的映射将变得无效。'
- en: '**Device IP Address Changes** Similarly, the mapping in Device A''s cache also
    would become invalid if Device B''s IP address changed.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备IP地址更改** 类似地，如果设备B的IP地址更改，设备A的缓存中的映射也会变得无效。'
- en: '**Device Removal** Suppose Device B is removed from the local network. Device
    A would never need to send to it again at the data link layer, but the mapping
    would remain in Device A''s cache, wasting space and possibly taking up search
    time.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备移除** 假设设备B从本地网络中移除。设备A将永远不会在数据链路层再次向它发送数据，但映射将保留在设备A的缓存中，浪费空间，并可能占用搜索时间。'
- en: To avoid these problems, dynamic cache entries must be set to automatically
    expire after a period of time. This is handled automatically by the ARP implementation,
    with typical timeout values being 10 or 20 minutes. After a particular entry times
    out, it is removed from the cache. The next time that address mapping is needed,
    a fresh resolution is performed to update the cache. This is very slightly less
    efficient than static entries, but sending two 28-byte messages every 10 or 20
    minutes isn't a big deal.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，动态缓存条目必须设置为在一段时间后自动过期。这由ARP实现自动处理，典型的超时值是10或20分钟。在特定条目超时后，它将从缓存中删除。下次需要地址映射时，将执行新的解析以更新缓存。这比静态条目稍微低效一点，但每10或20分钟发送两个28字节的消息并不是什么大问题。
- en: As mentioned in the overview of ARP operation, dynamic cache entries are added
    not only when a device initiates a resolution, but when it is the destination
    device as well. This is another enhancement that reduces unnecessary address resolution
    traffic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如ARP操作概述中所述，动态缓存条目不仅在设备启动解析时添加，当它是目标设备时也会添加。这是另一个减少不必要的地址解析流量的增强功能。
- en: Other Caching Features
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他缓存功能
- en: Other enhancements are also typically put into place, depending on the implementation.
    Standard ARP requires that if Device A initiates resolution with a broadcast,
    each device on the network should update its own cache entries for Device A, even
    if they are not the device that Device A is trying to reach. However, these "third-party"
    devices are *not* required to create new cache entries for Device A in this situation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据实现方式，通常还会实施其他增强功能。标准ARP要求，如果设备A通过广播启动解析，网络上的每个设备都应该更新自己的设备A的缓存条目，即使它们不是设备A试图到达的设备。然而，在这些情况下，“第三方”设备**不需要**为设备A创建新的缓存条目。
- en: The issue here is a trade-off. Creating a new cache entry would save any of
    those devices from needing to resolve Device A's address in the near future. However,
    it also means every device on the network will quickly have an ARP cache table
    filled up with the addresses of most of the other devices on the network. This
    may not be desirable in larger networks. Even in smaller ones, this model may
    not make sense, given that modern computing is client/server in nature and peer
    devices on a LAN may not often communicate directly. Some devices may choose to
    create such cache entries, but they may set them to expire after a very short
    time to avoid filling the cache.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是一个权衡。创建一个新的缓存条目将使这些设备中的任何一个在未来不需要解析设备A的地址。然而，这也意味着网络上的每个设备都会很快将ARP缓存表填满，其中包含网络上大多数其他设备的地址。这在较大的网络中可能不是所希望的。即使在较小的网络中，这种模式可能也不合理，因为现代计算本质上是客户端/服务器模式，局域网上的对等设备可能不会经常直接通信。一些设备可能会选择创建这样的缓存条目，但它们可能会将它们设置为在非常短的时间内过期，以避免填满缓存。
- en: Each ARP implementation is also responsible for any other housekeeping required
    to maintain the cache. For example, if a device is on a local network with many
    hosts and its cache table is too small, it might be necessary for older, less
    frequently used entries to be removed to make room for newer ones. Ideally, the
    cache should be large enough to hold all the other devices with which a device
    communicates on a regular basis on the network, along with some room for ones
    it occasionally talks to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ARP实现还负责维护缓存所需的所有其他家务工作。例如，如果一个设备在一个有大量主机的本地网络上，并且其缓存表太小，那么可能有必要删除较旧、使用频率较低的条目，为新条目腾出空间。理想情况下，缓存应该足够大，可以容纳设备在网络上定期通信的所有其他设备，以及一些偶尔与之通信的设备的空间。
- en: Proxy ARP
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理ARP
- en: ARP was designed to be used by devices that are directly connected on a local
    network. Each device on the network should be capable of sending both unicast
    and broadcast transmissions directly to one another. Normally, if Device A and
    Device B are separated by a router, they would not be considered local to each
    other. Device A would not send directly to Device B or vice versa; they would
    send to the router instead at layer 2 and would be considered two hops apart at
    layer 3.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ARP被设计为供直接连接在本地网络上的设备使用。网络上的每个设备都应该能够直接向彼此发送单播和广播传输。通常，如果设备A和设备B通过路由器分离，它们就不会被认为是彼此的本地设备。设备A不会直接向设备B发送，反之亦然；它们会在第二层向路由器发送，并在第三层被认为是两个跳数之隔。
- en: In some networking situations, however, there might be two physical network
    segments that are in the same IP network or subnetwork and are connected by a
    router. In other words, Device A and Device B might be on different networks at
    the data link layer level, but on the same IP network or subnet. When this happens,
    Device A and Device B will each think the other is on the local network when they
    look to send IP datagrams.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些网络情况下，可能会有两个物理网络段位于同一IP网络或子网络中，并通过路由器连接。换句话说，设备A和设备B可能在数据链路层级别位于不同的网络，但在同一IP网络或子网中。当这种情况发生时，设备A和设备B在尝试发送IP数据报时，都会认为对方位于本地网络中。
- en: 'In this situation, suppose that Device A wants to send a datagram to Device
    B. It doesn''t have Device B''s hardware address in the cache, so it begins an
    address resolution. When it broadcasts the ARP Request message to get Device B''s
    hardware address, however, it will quickly run into a problem: Device B is not
    on Device A''s local network. The router between them will not pass Device A''s
    broadcast onto Device B''s part of the network, because routers don''t pass hardware-layer
    broadcasts. Device B will never get the request, and thus Device A will not get
    a reply containing Device B''s hardware address.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，假设设备A想要向设备B发送数据报。它没有在缓存中找到设备B的硬件地址，因此开始地址解析。然而，当它广播ARP请求消息以获取设备B的硬件地址时，它将很快遇到一个问题：设备B不在设备A的本地网络中。它们之间的路由器不会将设备A的广播传递到设备B的网络部分，因为路由器不会传递硬件层的广播。设备B永远不会收到请求，因此设备A将不会收到包含设备B硬件地址的回复。
- en: The solution to this situation is called *ARP proxying* or *Proxy ARP*. In this
    technique, the router that sits between the local networks is configured to respond
    to Device A's broadcast on behalf of Device B. It does not send back to Device
    A the hardware address of Device B. Since they are not on the same network, Device
    A cannot send directly to Device B anyway. Instead, the router sends Device A
    its own hardware address. Device A then sends to the router, which forwards the
    message to Device B on the other network. Of course, the router also does the
    same thing on Device A's behalf for Device B, and for every other device on both
    networks, when a broadcast is sent that targets a device that isn't on the same
    actual physical network as the resolution initiator. This is illustrated in [Figure 13-7](ch13s02.html#arp_proxy_operation_these_two_examples_s
    "Figure 13-7. ARP Proxy operation These two examples show how a router acting
    as an ARP proxy returns its own hardware address in response to requests by one
    device for an address on the other network. In this small internetwork shown,
    a single router connects two LANs that are on the same IP network or subnet. The
    router will not pass ARP broadcasts, but has been configured to act as an ARP
    proxy. In this example, Device A and Device D are each trying to send an IP datagram
    to the other, and so each broadcasts an ARP Request. The router responds to the
    request sent by Device A as if it were Device D, giving to Device A its own hardware
    address (without propagating Device A's broadcast). It will forward the message
    sent by Device A to Device D on Device D's network. Similarly, it responds to
    Device D as if it were Device A, giving its own address, then forwarding what
    Device D sends to it over to the network where Device A is located.").
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下的解决方案被称为*ARP代理*或*代理ARP*。在这种技术中，位于本地网络之间的路由器被配置为代表设备B响应设备A的广播。它不会将设备B的硬件地址发送回设备A。由于它们不在同一个网络中，设备A无论如何也无法直接向设备B发送数据。相反，路由器将发送设备A自己的硬件地址。然后设备A将消息发送给路由器，路由器将消息转发到另一个网络中的设备B。当然，路由器也会代表设备A为设备B做同样的事情，以及为两个网络上的其他每个设备做同样的事情，当发送的广播消息的目标设备不在与解析发起者相同的实际物理网络上时。这如图[图13-7](ch13s02.html#arp_proxy_operation_these_two_examples_s
    "图13-7. ARP代理操作 这两个示例展示了作为ARP代理的路由器如何响应一个设备对另一个网络地址的请求，并返回其自己的硬件地址。在这个小型的互联网示例中，一个路由器连接了两个位于相同IP网络或子网上的局域网。路由器不会传递ARP广播，但已被配置为ARP代理。在这个例子中，设备A和设备D各自试图向对方发送IP数据报，因此每个都广播了ARP请求。路由器以设备D的身份响应设备A发送的请求，向设备A提供其自己的硬件地址（而不传播设备A的广播）。它将设备A发送给设备D的消息转发到设备D的网络。同样，它以设备A的身份响应设备D，提供其自己的地址，然后将设备D发送给它的消息转发到设备A所在的网络。")所示。
- en: Proxy ARP provides flexibility for networks where hosts are not all actually
    on the same physical network but are configured as if they were at the network
    layer. It can be used to provide support in other special situations where a device
    cannot respond directly to ARP message broadcasts. It may be used when a firewall
    is configured for security purposes. A type of proxying is also used as part of
    Mobile IP to solve the problem of address resolution when a mobile device travels
    away from its home network.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代理ARP为那些主机实际上不在同一个物理网络上，但被配置为在网络层上的网络提供了灵活性。它可以用于在其他特殊情况下提供支持，在这些情况下，设备无法直接响应ARP消息广播。当防火墙出于安全目的配置时，可能会使用它。在移动IP中，也使用一种代理类型来解决移动设备离开其本地网络时地址解析的问题。
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Since ARP relies on broadcasts for address resolution, and
    broadcasts are not propagated beyond a physical network, ARP cannot function between
    devices on different physical networks. When such operation is required, a device,
    such as a router, can be configured as an ARP proxy to respond to ARP requests
    on the behalf of a device on a different network.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于 ARP 依赖于广播进行地址解析，而广播不会在物理网络之外传播，因此 ARP 不能在位于不同物理网络上的设备之间工作。当需要此类操作时，可以将设备（如路由器）配置为
    ARP 代理，代表不同网络上的设备响应 ARP 请求。'
- en: '![ARP Proxy operation These two examples show how a router acting as an ARP
    proxy returns its own hardware address in response to requests by one device for
    an address on the other network. In this small internetwork shown, a single router
    connects two LANs that are on the same IP network or subnet. The router will not
    pass ARP broadcasts, but has been configured to act as an ARP proxy. In this example,
    Device A and Device D are each trying to send an IP datagram to the other, and
    so each broadcasts an ARP Request. The router responds to the request sent by
    Device A as if it were Device D, giving to Device A its own hardware address (without
    propagating Device A''s broadcast). It will forward the message sent by Device
    A to Device D on Device D''s network. Similarly, it responds to Device D as if
    it were Device A, giving its own address, then forwarding what Device D sends
    to it over to the network where Device A is located.](httpatomoreillycomsourcenostarchimages287781.png.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![ARP 代理操作 这些示例展示了作为 ARP 代理的路由器如何响应一个设备对另一网络地址的请求，返回其自己的硬件地址。在这个所示的小型互联网中，一个路由器连接了位于同一
    IP 网络或子网上的两个局域网。该路由器不会传递 ARP 广播，但已被配置为作为 ARP 代理。在这个例子中，设备 A 和设备 D 都试图向对方发送 IP
    数据报，因此每个都广播了一个 ARP 请求。路由器响应设备 A 发送的请求，就像它是设备 D 一样，向设备 A 提供其自己的硬件地址（而不传播设备 A 的广播）。它将设备
    A 发送给设备 D 的消息转发到设备 D 的网络。同样，它以设备 A 的身份响应设备 D，提供自己的地址，然后将设备 D 发送给它的消息转发到设备 A 所在的网络。](http://atomoreilly.com/source/nostarch/images/287781.png.jpg)'
- en: Figure 13-7. ARP Proxy operation These two examples show how a router acting
    as an ARP proxy returns its own hardware address in response to requests by one
    device for an address on the other network. In this small internetwork shown,
    a single router connects two LANs that are on the same IP network or subnet. The
    router will not pass ARP broadcasts, but has been configured to act as an ARP
    proxy. In this example, Device A and Device D are each trying to send an IP datagram
    to the other, and so each broadcasts an ARP Request. The router responds to the
    request sent by Device A as if it were Device D, giving to Device A its own hardware
    address (without propagating Device A's broadcast). It will forward the message
    sent by Device A to Device D on Device D's network. Similarly, it responds to
    Device D as if it were Device A, giving its own address, then forwarding what
    Device D sends to it over to the network where Device A is located.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-7. ARP 代理操作 这两个示例展示了作为 ARP 代理的路由器如何响应一个设备对另一网络地址的请求，返回其自己的硬件地址。在这个所示的小型互联网中，一个路由器连接了位于同一
    IP 网络或子网上的两个局域网。该路由器不会传递 ARP 广播，但已被配置为作为 ARP 代理。在这个例子中，设备 A 和设备 D 都试图向对方发送 IP
    数据报，因此每个都广播了一个 ARP 请求。路由器响应设备 A 发送的请求，就像它是设备 D 一样，向设备 A 提供其自己的硬件地址（而不传播设备 A 的广播）。它将设备
    A 发送给设备 D 的消息转发到设备 D 的网络。同样，它以设备 A 的身份响应设备 D，提供自己的地址，然后将设备 D 发送给它的消息转发到设备 A 所在的网络。
- en: The main advantage of proxying is that it is transparent to the hosts on the
    different physical network segments. The technique has some drawbacks, however.
    First, it introduces added complexity. Second, if more than one router connects
    two physical networks using the same network ID, problems may arise. Third, it
    introduces potential security risks; since it essentially means that a router
    impersonates devices by acting as a proxy for them, the potential for a device
    spoofing another is real. For these reasons, it may be better to redesign the
    network so that routing is done between physical networks separated by a router,
    if possible.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的主要优势是它对不同物理网络段上的主机是透明的。然而，这项技术也有一些缺点。首先，它引入了额外的复杂性。其次，如果多个路由器使用相同的网络 ID 连接两个物理网络，可能会出现问题。第三，它引入了潜在的安全风险；因为它本质上意味着路由器通过充当代理来冒充设备，因此设备冒充另一个设备的可能性是真实的。出于这些原因，如果可能的话，最好重新设计网络，以便在由路由器分隔的物理网络之间进行路由。
- en: TCP/IP Address Resolution for IP Multicast Addresses
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 地址解析用于 IP 组播地址
- en: Like most discussions of address resolution, most of this chapter so far has
    focused on unicast communication, where a datagram is sent from one source device
    to one destination device. Whether direct mapping or dynamic resolution is used
    for resolving a network layer address, it is a relatively simple matter to resolve
    addresses when there is only one intended recipient of the datagram. As you've
    seen, TCP/IP uses ARP for its dynamic resolution scheme, which is designed for
    unicast resolution only.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数关于地址解析的讨论一样，到目前为止，本章的大部分内容都集中在单播通信上，其中数据报从一个源设备发送到单个目标设备。无论使用直接映射还是动态解析来解析网络层地址，当只有一个预期的数据报接收者时，解析地址相对简单。正如你所看到的，TCP/IP
    使用 ARP 进行其动态解析方案，该方案仅设计用于单播解析。
- en: However, IP also supports *multicasting* of datagrams, as I explain in the sections
    on IP multicasting and IP multicast addressing in Chapters [Chapter 23](ch23.html
    "Chapter 23. IP ROUTING AND MULTICASTING") and [Chapter 17](ch17.html "Chapter 17. CLASSFUL
    (CONVENTIONAL) ADDRESSING"), respectively. In this situation, the datagram must
    be sent to multiple recipients, which complicates matters considerably. You need
    to establish a relationship of some sort between the IP multicast group address
    and the addresses of the devices at the data link layer. You could do this by
    converting the IP multicast datagram to individual unicast transmissions at the
    data link layer with each using ARP for resolution, but this would be horribly
    inefficient.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IP 也支持数据报的 *组播*，正如我在第 23 章（[第 23 章。IP 路由和组播](ch23.html "第 23 章。IP 路由和组播")）和第
    17 章（[第 17 章。类地址（传统）寻址](ch17.html "第 17 章。类地址（传统）寻址")）中关于 IP 组播和 IP 组播地址的章节中解释的那样。在这种情况下，数据报必须发送到多个接收者，这大大增加了复杂性。您需要在
    IP 组播组地址和数据链路层设备的地址之间建立某种关系。您可以通过在数据链路层将 IP 组播数据报转换为单个单播传输来实现这一点，每个都使用 ARP 进行解析，但这将非常低效。
- en: When possible, IP makes use of the multicast addressing and delivery capabilities
    of the underlying network to deliver multicast datagrams on a physical network.
    Perhaps surprisingly, even though ARP employs dynamic resolution, multicast address
    resolution is done using a version of the direct mapping technique. By defining
    a *mapping* between IP multicast groups and data link layer multicast groups,
    you enable physical devices to know when to pay attention to multicasted datagrams.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，IP 利用底层网络的组播寻址和交付能力，在物理网络上交付组播数据报。也许令人惊讶的是，尽管 ARP 使用动态解析，但组播地址解析是使用直接映射技术的一种版本。通过定义
    IP 组播组和数据链路层组播组之间的 *映射*，您使物理设备知道何时关注组播数据报。
- en: The most commonly used multicast-capable data link addressing scheme is the
    IEEE 802 addressing system best known for its use in Ethernet networks. These
    data link layer addresses have 48 bits, arranged into two blocks of 24\. The upper
    24 bits are arranged into a block called the *organizationally unique identifier
    (OUI)*, with different values assigned to individual organizations; the lower
    24 bits are then used for specific devices.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的具有组播功能的数据链路层寻址方案是 IEEE 802 寻址系统，它最著名的用途是在以太网网络中。这些数据链路层地址有 48 位，分为两个 24
    位的块。高 24 位被组织成一个称为 *组织唯一标识符 (OUI)* 的块，不同的值分配给各个组织；然后低 24 位用于特定设备。
- en: The Internet Assigned Number Authority (IANA) itself has an OUI that it uses
    for mapping multicast addresses to IEEE 802 addresses. This OUI is 01:00:5E. To
    form a mapping for Ethernet, 24 bits are used for this OUI, and the 25th (of the
    48) is always zero. This leaves 23 bits of the original 48 to encode the multicast
    address. To do the mapping, the lower-order 23 bits of the multicast address are
    used as the last 23 bits of the Ethernet address starting with 01:00:5E for sending
    the multicast message.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网分配号码权威机构 (IANA) 本身有一个用于将组播地址映射到 IEEE 802 地址的 OUI。这个 OUI 是 01:00:5E。为了形成以太网的映射，使用
    24 位用于这个 OUI，第 25 位（48位中的第 25 位）始终为零。这留下了原始 48 位中的 23 位来编码组播地址。为了进行映射，组播地址的低位
    23 位被用作以太网地址的最后 23 位，以 01:00:5E 开头发送组播消息。
- en: '[Figure 13-8](ch13s03.html#mapping_of_multicast_ip_addresses_to_iee "Figure 13-8. Mapping
    of multicast IP Addresses to IEEE 802 multicast MAC addresses Multicast IP addresses
    are mapped to IEEE 802 multicast MAC addresses by copying the IANA multicast OUI
    value (01-00-5E) to the top 24 bits, setting the 25th bit to zero, and copying
    the bottom 23 bits of the multicast address to the remaining 23 bits. To create
    a 48-bit multicast IEEE 802 (Ethernet) address, the top 24 bits are filled in
    with the IANA''s multicast OUI, 01-00-5E. The 25th bit is zero, and the bottom
    23 bits of the multicast group are put into the bottom 23 bits of the MAC address.
    This leaves 5 bits (shown hatched) that are not mapped to the MAC address, meaning
    that 32 different IP addresses may have the same mapped multicast MAC address.")
    illustrates how the multicast address mapping process works.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-8](ch13s03.html#mapping_of_multicast_ip_addresses_to_iee "图13-8. 多播IP地址映射到IEEE
    802多播MAC地址 多播IP地址通过复制IANA多播OUI值（01-00-5E）到最高24位，将第25位设置为0，并将多播地址的最低23位复制到剩余的23位来映射到IEEE
    802多播MAC地址。为了创建一个48位的多播IEEE 802（以太网）地址，最高24位填充了IANA的多播OUI，01-00-5E。第25位是0，多播组的最低23位放入MAC地址的最低23位。这留下了5位（如图中阴影所示）没有映射到MAC地址，这意味着32个不同的IP地址可能有相同的多播MAC地址。")'
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** IP multicast addresses are resolved to IEEE 802 (Ethernet)
    MAC addresses using a direct mapping technique that uses 23 of the 28 bits in
    the IP multicast group address.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IP多播地址通过使用23位IP多播组地址的直接映射技术解析为IEEE 802（以太网）MAC地址。'
- en: Of course, there are 28 unique bits in IP multicast addresses, so this is a
    "bit" of a problem! What it means is that there is no unique mapping between IP
    multicast addresses and Ethernet multicast addresses. Since 5 of the 28 bits of
    the multicast group cannot be encoded in the Ethernet address, 32 (2⁵) different
    IP multicast addresses map onto each possible Ethernet multicast address. In theory,
    this would be a problem, but in practice, it isn't. The chances of any two IP
    multicast addresses on a single network mapping to the same Ethernet multicast
    address at the same time are pretty small.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，IP多播地址中有28个独特的比特位，所以这有点问题！这意味着IP多播地址和以太网多播地址之间没有唯一的映射关系。由于多播组的28位中的5位无法编码到以太网地址中，因此32个（2⁵）不同的IP多播地址映射到每个可能的以太网多播地址。在理论上，这可能会成为一个问题，但在实践中，它并不是。在单个网络中，任何两个IP多播地址同时映射到相同的以太网多播地址的概率相当小。
- en: '![Mapping of multicast IP Addresses to IEEE 802 multicast MAC addresses Multicast
    IP addresses are mapped to IEEE 802 multicast MAC addresses by copying the IANA
    multicast OUI value (01-00-5E) to the top 24 bits, setting the 25th bit to zero,
    and copying the bottom 23 bits of the multicast address to the remaining 23 bits.
    To create a 48-bit multicast IEEE 802 (Ethernet) address, the top 24 bits are
    filled in with the IANA''s multicast OUI, 01-00-5E. The 25th bit is zero, and
    the bottom 23 bits of the multicast group are put into the bottom 23 bits of the
    MAC address. This leaves 5 bits (shown hatched) that are not mapped to the MAC
    address, meaning that 32 different IP addresses may have the same mapped multicast
    MAC address.](httpatomoreillycomsourcenostarchimages287783.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![多播IP地址映射到IEEE 802多播MAC地址的图示 多播IP地址通过复制IANA多播OUI值（01-00-5E）到最高24位，将第25位设置为0，并将多播地址的最低23位复制到剩余的23位来映射到IEEE
    802多播MAC地址。为了创建一个48位的多播IEEE 802（以太网）地址，最高24位填充了IANA的多播OUI，01-00-5E。第25位是0，多播组的最低23位放入MAC地址的最低23位。这留下了5位（如图中阴影所示）没有映射到MAC地址，这意味着32个不同的IP地址可能有相同的多播MAC地址。](httpatomoreillycomsourcenostarchimages287783.png)'
- en: Figure 13-8. Mapping of multicast IP Addresses to IEEE 802 multicast MAC addresses
    Multicast IP addresses are mapped to IEEE 802 multicast MAC addresses by copying
    the IANA multicast OUI value (01-00-5E) to the top 24 bits, setting the 25th bit
    to zero, and copying the bottom 23 bits of the multicast address to the remaining
    23 bits. To create a 48-bit multicast IEEE 802 (Ethernet) address, the top 24
    bits are filled in with the IANA's multicast OUI, 01-00-5E. The 25th bit is zero,
    and the bottom 23 bits of the multicast group are put into the bottom 23 bits
    of the MAC address. This leaves 5 bits (shown hatched) that are not mapped to
    the MAC address, meaning that 32 different IP addresses may have the same mapped
    multicast MAC address.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-8. 多播 IP 地址到 IEEE 802 多播 MAC 地址的映射 多播 IP 地址通过复制 IANA 多播 OUI 值（01-00-5E）到最高
    24 位，将第 25 位设置为零，并将多播地址的最低 23 位复制到剩余的 23 位，映射到 IEEE 802 多播 MAC 地址。为了创建一个 48 位的多播
    IEEE 802（以太网）地址，最高 24 位填充了 IANA 的多播 OUI，01-00-5E。第 25 位为零，多播组的最低 23 位放入 MAC 地址的最低
    23 位。这留下了 5 位（以虚线表示）没有映射到 MAC 地址，这意味着 32 个不同的 IP 地址可能有相同的多播 MAC 地址映射。
- en: Still, it is possible that two IP multicast groups might be in use on the same
    physical network and might map to the same data link layer multicast address.
    For this reason, devices must not assume that all multicast messages they receive
    are for their groups; they must pass up the messages to the IP layer to check
    the full IP multicast address to make sure that they really were supposed to get
    the multicast datagram they received. If they accidentally get one that was intended
    for a multicast group they are not a member of, they discard it. This happens
    infrequently, so the relative lack of efficiency is not a large concern.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，可能存在两个 IP 多播组在同一物理网络上使用，并映射到相同的数据链路层多播地址的情况。因此，设备不能假设它们接收到的所有多播消息都是为它们的组设计的；它们必须将消息传递到
    IP 层以检查完整的 IP 多播地址，以确保它们确实应该接收它们接收到的多播数据报。如果它们意外地收到一个旨在为它们不是成员的多播组设计的消息，它们将丢弃它。这种情况很少发生，因此相对缺乏效率不是一个大问题。
- en: TCP/IP Address Resolution for IP Version 6
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 地址解析针对 IP 版本 6
- en: The TCP/IP ARP is a fairly generic protocol for dynamically resolving network
    layer addresses into data link layer addresses. Even though it was designed for
    IPv4, the message format allows for variable-length addresses at both the hardware
    and network layers. This flexibility means it would have been theoretically possible
    to use it for the new version of IP, IPv6\. Some minor changes might have been
    required, but the technique could have been about the same.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP ARP 是一个相当通用的协议，用于动态地将网络层地址解析为数据链路层地址。尽管它是为 IPv4 设计的，但消息格式允许硬件和网络层使用可变长度的地址。这种灵活性意味着理论上可以使用它来处理
    IP 的新版本，IPv6。可能需要一些小的改动，但技术可能大致相同。
- en: The designers of IPv6 chose not to do this, however. Changing IP is a big job
    that has been under way for many years, providing a rare opportunity to change
    various aspects of TCP/IP. The Internet Engineering Task Force (IETF) decided
    to take advantage of the changes in IPv6 to overhaul not only IP itself, but also
    many of the protocols that support or assist it. In IPv6, the address resolution
    job of ARP has been combined with several functions performed by the Internet
    Control Message Protocol (ICMP) in the original TCP/IP suite, supplemented with
    additional capabilities and defined as the new Neighbor Discovery (ND) Protocol.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IPv6 的设计者选择不这样做。改变 IP 是一项庞大的工作，已经进行了多年，提供了改变 TCP/IP 各个方面的罕见机会。互联网工程任务组（IETF）决定利用
    IPv6 的变化来彻底改革 IP 本身，以及支持或协助它的许多协议。在 IPv6 中，ARP 的地址解析任务与原始 TCP/IP 套件中由互联网控制消息协议（ICMP）执行的一些功能相结合，补充了额外的功能，并定义为新的邻居发现（ND）协议。
- en: The term *neighbor* in IPv6 simply refers to devices on a local network, and
    as the name implies, ND is responsible for tasks related to communicating information
    between neighbors (among other things). I describe ND briefly in [Chapter 36](ch36.html
    "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL"), including a discussion of
    the various tasks it performs. Here, I focus specifically on how ND performs address
    resolution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 中的术语 *邻居* 简单地指的是本地网络上的设备，正如其名所示，ND 负责与邻居（以及其他事物）之间通信信息的相关任务。我在 [第 36 章](ch36.html
    "第 36 章。IPV6 邻居发现 (ND) 协议") 中简要介绍了 ND，包括讨论它执行的各种任务。在这里，我特别关注 ND 如何执行地址解析。
- en: The basic concepts of address resolution in IPv6 ND aren't all that different
    from those in IPv4 ARP. Resolution is still dynamic and is based on the use of
    a cache table that maintains pairings of IPv6 addresses and hardware addresses.
    Each device on a physical network keeps track of this information for its neighbors.
    When a source device needs to send an IPv6 datagram to a local network neighbor
    but doesn't have its hardware address, it initiates the resolution process. For
    clarity in the text let's say that, as usual, Device A is trying to send to Device
    B.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 ND中地址解析的基本概念与IPv4 ARP中的概念并没有太大的不同。解析仍然是动态的，并且基于使用一个缓存表来维护IPv6地址和硬件地址的配对。物理网络上的每个设备都会跟踪其邻居的这些信息。当一个源设备需要向本地网络邻居发送IPv6数据报，但没有其硬件地址时，它将启动解析过程。为了在文本中清晰起见，让我们说，像往常一样，设备A正在尝试向设备B发送数据。
- en: Instead of sending an ARP Request message, Device A creates an ND Neighbor Solicitation
    message. Now, here's where the first big change can be seen from ARP. If the underlying
    data link protocol supports multicasting, as Ethernet does, the Neighbor Solicitation
    message is not broadcast. Instead, it is sent to the *solicited-node address*
    of the device whose IPv6 address you are trying to resolve. So Device A won't
    broadcast the message, but it will multicast it to Device B's solicited-node multicast
    address.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于发送ARP请求消息，设备A创建了一个ND邻居请求消息。现在，从这里我们可以看到从ARP的第一个重大变化。如果底层数据链路协议支持多播，就像以太网一样，邻居请求消息就不会广播。相反，它被发送到要解析的IPv6地址的设备的请求节点地址。所以设备A不会广播消息，但它会将消息多播到设备B的请求节点多播地址。
- en: The solicited-node multicast address is a special mapping that each device on
    a multicast-capable network creates from its unicast address; it is described
    in [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING")'s discussion of IPv6
    multicast addresses. The solicited-node address isn't unique for every IPv6 address,
    but the odds of any two neighbors on a given network having the same one are small.
    Each device that receives a multicasted Neighbor Solicitation must still check
    to make sure it is the device whose address the source is trying to resolve.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请求节点多播地址是从每个多播能力网络设备的多播地址创建的特殊映射；它在第25章（[第25章。IPv6寻址](ch25.html "第25章。IPv6寻址")）中关于IPv6多播地址的讨论中描述。请求节点地址对于每个IPv6地址并不是唯一的，但在给定网络上任何两个邻居具有相同地址的概率很小。每个接收到多播邻居请求的设备仍然需要检查以确保它就是源设备试图解析的设备。
- en: Why bother with this, if devices still have to check each message? The multicast
    will affect at most a small number of devices. With a broadcast, each and every
    device on the local network would receive the message, while the use of the solicited-node
    address means at most that a couple of devices will need to process it. Other
    devices don't even have to bother checking the Neighbor Solicitation message at
    all.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备仍然需要检查每条消息，为什么还要这样做呢？多播最多只会影响少数设备。使用广播，本地网络上的每个设备都会接收到消息，而使用请求节点地址意味着最多只有几台设备需要处理它。其他设备甚至不需要麻烦检查邻居请求消息。
- en: Device B will receive the Neighbor Solicitation and respond back to Device A
    with a Neighbor Advertisement. This is analogous to the ARP Reply and tells Device
    A the physical address of Device B. Device A then adds Device B's information
    to its neighbor cache. For efficiency, cross-resolution is supported, as in IPv4
    address resolution. This is done by having Device A include its own layer 2 address
    in the Neighbor Solicitation, assuming it knows it. Device B will record this
    along with Device A's IP address in Device B's neighbor cache.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 设备B将接收邻居请求并回应对设备A的邻居通告。这类似于ARP回复，并告诉设备A设备B的物理地址。然后设备A将设备B的信息添加到其邻居缓存中。为了提高效率，支持跨解析，就像IPv4地址解析一样。这是通过设备A在邻居请求中包含其自己的第2层地址来实现的，假设它知道这个地址。设备B将记录这个地址以及设备A的IP地址到设备B的邻居缓存中。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Address resolution in IPv6 uses the new *Neighbor Discovery
    (ND) Protocol* instead of the Address Resolution Protocol (ARP). A device trying
    to send an IPv6 datagram sends a Neighbor Solicitation message to get the address
    of another device, which responds with a Neighbor Advertisement. When possible,
    to improve efficiency, the request is sent using a special type of multicast address
    rather than broadcast.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPv6中的地址解析使用新的*邻居发现（ND）协议*而不是地址解析协议（ARP）。试图发送IPv6数据报的设备会发送一个邻居请求消息以获取另一个设备的地址，该设备会响应一个邻居广告。当可能时，为了提高效率，请求会使用一种特殊的组播地址而不是广播发送。'
- en: This is actually a fairly simplified explanation of how resolution works in
    IPv6, because ND is quite complicated. Neighbor solicitations and advertisements
    are also used for other functions, such as testing the reachability of nodes and
    determining if duplicate addresses are in use. There are many special cases and
    issues that ND addresses to ensure that no problems develop during address resolution.
    ND also supports proxied address resolution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是对IPv6中解析工作原理的相对简化解释，因为邻居发现（ND）相当复杂。邻居请求和广告也用于其他功能，例如测试节点的可达性以及确定是否有重复地址在使用。ND还处理许多特殊情况问题，以确保在地址解析过程中不会出现任何问题。ND还支持代理地址解析。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Even though I put this discussion where it would be near the other discussions
    of address resolution, ND really isn''t a layer connection or lower-level protocol
    like ARP. It is analogous to ICMP ([Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS
    AND GENERAL OPERATION")) in its role and function, and, in fact, makes use of
    ICMP(v6) messages. One advantage of this architectural change is that there is
    less dependence on the characteristics of the physical network, so resolution
    is accomplished in a way that''s more similar to other network support activities.
    Thus, it is possible to make use of facilities that can be applied to all IP datagram
    transmissions, such as IP security features. [Chapter 36](ch36.html "Chapter 36. IPV6
    NEIGHBOR DISCOVERY (ND) PROTOCOL") contains much more information on this subject*.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管我把这次讨论放在了接近其他地址解析讨论的位置，但ND实际上并不是一个像ARP那样的层连接或底层协议。它在角色和功能上与ICMP ([第31章](ch31.html
    "第31章。ICMP概念和一般操作"))相似，并且实际上使用了ICMP(v6)消息。这种架构变化的一个优点是减少了对外部网络特性的依赖，因此解析是以更类似于其他网络支持活动的方式完成的。因此，可以利用适用于所有IP数据报传输的设施，例如IP安全特性。[第36章](ch36.html
    "第36章。IPv6邻居发现（ND）协议")包含更多关于这个主题的信息*。'
- en: Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP REVERSE ADDRESS RESOLUTION
    PROTOCOL (RARP)
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。反向地址解析和TCP/IP反向地址解析协议（RARP）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: In [Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS
    RESOLUTION PROTOCOL (ARP)"), you explored the operation of the TCP/IP Address
    Resolution Protocol (ARP). ARP is used when a device needs to determine the layer
    2 (hardware) address of some other device but has only its layer 3 (network, IP)
    address. It broadcasts a hardware layer request, and the target device responds
    with the hardware address that matches the known IP address.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "第13章。地址解析和TCP/IP地址解析协议（ARP）")中，你探讨了TCP/IP地址解析协议（ARP）的操作。当设备需要确定其他设备的第2层（硬件）地址但只知道其第3层（网络，IP）地址时，会使用ARP。它会广播一个硬件层请求，目标设备会响应一个与已知IP地址匹配的硬件地址。
- en: In theory, it is also possible to use ARP in the opposite way. If you know the
    hardware address of a device but not its IP address, you could broadcast a request
    containing the hardware address and get back a response that contains the IP address.
    In this chapter, you will briefly explore this concept of *reverse address resolution*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，也可以以相反的方式使用ARP。如果你知道设备的硬件地址但不知道其IP地址，你可以广播一个包含硬件地址的请求，并得到一个包含IP地址的响应。在本章中，你将简要探讨这种*反向地址解析*的概念。
- en: The obvious first question is why would you ever need to do this? Since you
    are dealing with communication on an Internet Protocol (IP) internetwork, you
    are always going to know the IP address of the destination of the datagram you
    need to send—it's right there in the datagram itself. You also know your own IP
    address as well. Or do you?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，首先的问题是你为什么要做这件事？既然你正在处理基于互联网协议（IP）的通信，你总是知道你需要发送的数据报的IP地址——它就在数据报本身中。你也知道自己的IP地址。或者你不知道？
- en: In a traditional TCP/IP network, every normal host on a network knows its IP
    address because it is stored somewhere on the machine. When you turn on your PC,
    the TCP/IP software reads the IP address from a file, which allows your PC to
    learn and start using its IP address. However, there are some devices, such as
    diskless workstations, that don't have any means of storing an IP address where
    it can be easily retrieved. When these units are powered up, they know their physical
    address only (because it's wired into the hardware) but not their IP address.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的TCP/IP网络中，网络上的每个普通主机都知道自己的IP地址，因为它的IP地址存储在机器的某个地方。当你打开你的PC时，TCP/IP软件会从文件中读取IP地址，这使得你的PC能够学习和开始使用它的IP地址。然而，有些设备，如无盘工作站，没有任何存储IP地址的手段，以便可以轻松检索。当这些单元启动时，它们只知道自己的物理地址（因为它是通过硬件连接的），但不知道自己的IP地址。
- en: The problem you need to solve here is what is commonly called *bootstrapping*
    in the computer industry. This refers to the concept of starting something from
    a zero state; it is analogous to "pulling yourself up by your own bootstraps."
    This is seemingly impossible, just as it seems paradoxical to use TCP/IP to configure
    the IP address that is needed for TCP/IP communications. However, it is indeed
    possible to do this, by making use of broadcasts, which allow local communication
    even when the target's address is not known.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要解决的问题在计算机行业中通常被称为*引导*。这指的是从零状态开始某事的概念；它类似于“自己拉起自己的靴带”。这似乎是不可能的，就像使用TCP/IP来配置TCP/IP通信所需的IP地址一样似乎矛盾。然而，通过使用广播，即使不知道目标地址，也可以实现这一点，这是可能的。
- en: The Reverse Address Resolution Protocol (RARP)
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向地址解析协议（RARP）
- en: The first method devised to address the bootstrapping problem in TCP/IP was
    the backward use of ARP, which is described in the previous chapter. This technique
    was formalized in RFC 903, "A Reverse Address Resolution Protocol (RARP)," published
    in 1984\. ARP allows Device A to say, "I am Device A, and I have Device B's IP
    address. Device B please tell me your hardware address." RARP is used by Device
    A to say, "I am Device A, and I am sending this broadcast using my hardware address;
    can someone please tell me *my* IP address?"
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 解决TCP/IP启动问题所采用的第一种方法是反向使用ARP，这在上一章中已有描述。这种技术被正式化在1984年发布的RFC 903，“反向地址解析协议（RARP）”。ARP允许设备A说：“我是设备A，我拥有设备B的IP地址。设备B，请告诉我你的硬件地址。”RARP由设备A用来表示：“我是设备A，我正在使用我的硬件地址发送这个广播；请有人告诉我我的IP地址？”
- en: The two-step operation of RARP is illustrated in [Figure 14-1](ch14.html#operation_of_the_reverse_address_resolut
    "Figure 14-1. Operation of the Reverse Address Resolution Protocol (RARP) RARP
    works like ARP but in reverse; a device broadcasts its hardware address and an
    RARP server responds with its IP address. Here, instead of Device A providing
    the IP address of another device and asking for its hardware address, it is providing
    its own hardware address and asking for an IP address it can use. The answer,
    in this case, is provided by Device D, which is serving as an RARP server for
    this network."). As the name suggests, RARP works like ARP but in reverse, which
    is why this diagram is similar to [Figure 13-4](ch13.html#dynamic_address_resolution_the_device_th
    "Figure 13-4. Dynamic address resolution The device that wants to send data broadcasts
    a request asking for a response with a hardware address from the other device.
    Device A needs to send data to Device B, but knows only its IP address (IPB) and
    not its hardware address. Device A broadcasts a request asking to be sent the
    hardware address of the device using the IP address IPB. Device B responds back
    to Device A directly with the hardware address.").
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'RARP的兩步操作如[图14-1](ch14.html#operation_of_the_reverse_address_resolut "图14-1.
    反向地址解析协议（RARP）的操作 RARP的工作方式与ARP相反；设备广播其硬件地址，而RARP服务器则响应其IP地址。在这里，不是设备A提供另一个设备的IP地址并请求其硬件地址，而是提供自己的硬件地址并请求一个可以使用的IP地址。在这种情况下，答案是设备D提供的，它正在作为该网络的RARP服务器。")所示。正如其名称所暗示的，RARP的工作方式与ARP相反，这就是为什么这个图与[图13-4](ch13.html#dynamic_address_resolution_the_device_th
    "图13-4. 动态地址解析 想要发送数据的设备广播一个请求，请求从另一个设备获得硬件地址。设备A需要向设备B发送数据，但只知道其IP地址（IPB），不知道其硬件地址。设备A广播一个请求，请求通过IP地址IPB发送该设备的硬件地址。设备B直接向设备A响应，提供硬件地址。")相似。 '
- en: The next question then is who knows Device A's IP address if Device A doesn't?
    The answer is that a special *RARP server* must be configured to listen for RARP
    requests and then issue replies to them. Each physical network where RARP is in
    use must have RARP software running on at least one machine.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 那么接下来的问题是，如果设备A不知道，谁知道设备A的IP地址？答案是必须配置一个特殊的*RARP服务器*来监听RARP请求，然后对它们做出响应。每个使用RARP的物理网络都必须至少在一台机器上运行RARP软件。
- en: 'RARP is not only very similar to ARP, it basically is ARP. RFC 903 doesn''t
    define a whole new protocol from scratch; it just describes a new method for using
    ARP to perform the opposite of its normal function. RARP uses ARP messages in
    the same format as ARP (described in [Chapter 13](ch13.html "Chapter 13. ADDRESS
    RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")), but uses different
    opcodes to accomplish its reverse function. As in ARP, a request and reply are
    used in an exchange. The meaning of the address fields is the same, too: The sender
    is the device transmitting a message, while the target is the one receiving it.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: RARP不仅与ARP非常相似，实际上它基本上就是ARP。RFC 903并没有从头定义一个全新的协议；它只是描述了一种使用ARP来执行其正常功能相反的新方法。RARP使用与ARP相同的格式（在[第13章](ch13.html
    "第13章. 地址解析与TCP/IP地址解析协议（ARP）")中描述）的ARP消息，但使用不同的操作码来完成其反向功能。与ARP一样，在交换中使用了请求和回复。地址字段的意义也是相同的：发送者是传输消息的设备，而目标是接收它的设备。
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The *Reverse Address Resolution Protocol (RARP)* is the earliest
    and simplest protocol that''s designed to allow a device to obtain an IP address
    for use on a TCP/IP network. It is based directly on ARP and works in basically
    the same way, but in reverse: A device sends a request containing its hardware
    address, and a device set up as an RARP server responds back with the device''s
    assigned IP address.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *反向地址解析协议（RARP）* 是最早且最简单的协议，旨在允许设备在TCP/IP网络上获取IP地址。它直接基于ARP，基本上以相同的方式工作，但相反：设备发送包含其硬件地址的请求，而设置为RARP服务器的设备则响应并提供设备的分配IP地址。'
- en: '![Operation of the Reverse Address Resolution Protocol (RARP) RARP works like
    ARP but in reverse; a device broadcasts its hardware address and an RARP server
    responds with its IP address. Here, instead of Device A providing the IP address
    of another device and asking for its hardware address, it is providing its own
    hardware address and asking for an IP address it can use. The answer, in this
    case, is provided by Device D, which is serving as an RARP server for this network.](httpatomoreillycomsourcenostarchimages287785.png.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![反向地址解析协议 (RARP) 操作 RARP 与 ARP 类似，但方向相反；设备广播其硬件地址，RARP 服务器以其 IP 地址响应。在这里，不是设备
    A 提供另一个设备的 IP 地址并请求其硬件地址，而是提供自己的硬件地址并请求可以使用的 IP 地址。在这种情况下，答案是设备 D 提供的，它作为该网络的
    RARP 服务器。](httpatomoreillycomsourcenostarchimages287785.png.jpg)'
- en: Figure 14-1. Operation of the Reverse Address Resolution Protocol (RARP) RARP
    works like ARP but in reverse; a device broadcasts its hardware address and an
    RARP server responds with its IP address. Here, instead of Device A providing
    the IP address of another device and asking for its hardware address, it is providing
    its own hardware address and asking for an IP address it can use. The answer,
    in this case, is provided by Device D, which is serving as an RARP server for
    this network.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1. 反向地址解析协议 (RARP) 操作 RARP 与 ARP 类似，但方向相反；设备广播其硬件地址，RARP 服务器以其 IP 地址响应。在这里，不是设备
    A 提供另一个设备的 IP 地址并请求其硬件地址，而是提供自己的硬件地址并请求可以使用的 IP 地址。在这种情况下，答案是设备 D 提供的，它作为该网络的
    RARP 服务器。
- en: RARP General Operation
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RARP 通用操作
- en: '[Figure 14-2](ch14s02.html#reverse_address_resolution_protocol_rarp "Figure 14-2. Reverse
    Address Resolution Protocol (RARP) operation RARP consists of the exchange of
    one broadcast request message and one unicast reply message.") shows the steps
    followed in a RARP transaction. As you can see, RARP uses a simple request and
    reply exchange to allow a device to obtain an IP address.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-2](ch14s02.html#reverse_address_resolution_protocol_rarp "图 14-2. 反向地址解析协议
    (RARP) 操作 RARP 包括一个广播请求消息和一个单播回复消息的交换。") 展示了 RARP 事务中遵循的步骤。如您所见，RARP 使用简单的请求和回复交换，允许设备获取
    IP 地址。'
- en: '![Reverse Address Resolution Protocol (RARP) operation RARP consists of the
    exchange of one broadcast request message and one unicast reply message.](httpatomoreillycomsourcenostarchimages287787.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![反向地址解析协议 (RARP) 操作 RARP 包括一个广播请求消息和一个单播回复消息的交换。](httpatomoreillycomsourcenostarchimages287787.png)'
- en: Figure 14-2. Reverse Address Resolution Protocol (RARP) operation RARP consists
    of the exchange of one broadcast request message and one unicast reply message.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2. 反向地址解析协议 (RARP) 操作 RARP 包括一个广播请求消息和一个单播回复消息的交换。
- en: 'Here''s what happens at each step:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是每个步骤发生的情况：
- en: '**Source Device Generates RARP Request Message** The source device generates
    an RARP Request message. Thus, it uses the value 3 for the *opcode* in the message.
    It puts its own data link layer address as both the Sender Hardware Address and
    also the Target Hardware Address. It leaves both the Sender Protocol Address and
    the Target Protocol Address blank, since it doesn''t know either.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备生成 RARP 请求消息** 源设备生成一个 RARP 请求消息。因此，它在消息中使用值 3 作为 *opcode*。它将自己的数据链路层地址作为发送者硬件地址和目标硬件地址。它将发送者协议地址和目标协议地址留空，因为它不知道这些信息。'
- en: '**Source Device Broadcasts RARP Request Message** The source broadcasts the
    ARP Request message on the local network.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备广播 RARP 请求消息** 源设备在本地网络上广播 ARP 请求消息。'
- en: '**Local Devices Process RARP Request Message** The message is received by each
    device on the local network and processed. Devices that are not configured to
    act as RARP servers ignore the message.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本地设备处理 RARP 请求消息** 该消息被本地网络上的每个设备接收并处理。未配置为作为 RARP 服务器的设备会忽略该消息。'
- en: '**RARP Server Generates RARP Reply Message** Any device on the network that
    is set up to act as an RARP server responds to the broadcast from the source device.
    It generates an RARP Reply using an opcode value of 4\. It sets the Sender Hardware
    Address and Sender Protocol Address to its own hardware and IP address, since
    it is the sender of the reply. It then sets the Target Hardware Address to the
    hardware address of the original source device. It looks up in a table the hardware
    address of the source, determines that device''s IP address assignment, and puts
    it into the Target Protocol Address field.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RARP服务器生成RARP响应消息** 网络上任何设置为充当RARP服务器的设备都会对源设备的广播做出响应。它使用操作码值为4生成一个RARP响应。它将发送者硬件地址和发送者协议地址设置为它自己的硬件和IP地址，因为它是对话的发送者。然后，它将目标硬件地址设置为原始源设备的硬件地址。它在表中查找源设备的硬件地址，确定该设备的IP地址分配，并将其放入目标协议地址字段。'
- en: '**RARP Server Sends RARP Reply Message** The RARP server sends the RARP Reply
    message unicast to the device looking to be configured.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RARP服务器发送RARP响应消息** RARP服务器将RARP响应消息单播发送给正在尝试配置的设备。'
- en: '**Source Device Processes RARP Reply Message** The source device processes
    the reply from the RARP server. It then configures itself using the IP address
    in the Target Protocol Address supplied by the RARP server.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源设备处理RARP响应消息** 源设备处理来自RARP服务器的响应。然后，它使用RARP服务器提供的目标协议地址中的IP地址来配置自己。'
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*More than one RARP server may respond to a request, if two or more are configured
    on any local network. The source device will typically use the first reply and
    discard the others*.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果任何本地网络上配置了两个或更多的RARP服务器，则可能有多于一个的RARP服务器响应请求。源设备通常会使用第一个响应并丢弃其他响应*。'
- en: Limitations of RARP
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RARP的局限性
- en: 'RARP is the earliest and most rudimentary of the class of technologies I call
    *host configuration protocols*, which I describe in general terms in [Chapter 59](ch59.html
    "Chapter 59. HOST CONFIGURATION CONCEPTS, ISSUES, AND MOTIVATION"). As the first
    of these protocols, RARP was a useful addition to TCP/IP in the early 1980s, but
    has several shortcomings, the most important of which are as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: RARP是我所说的*主机配置协议*类别中最早且最基础的协议之一，我在[第59章](ch59.html "第59章。主机配置概念、问题和动机")中以一般术语描述了这些协议。作为这些协议中的第一个，RARP在20世纪80年代初对TCP/IP来说是一个有用的补充，但它有几个缺点，其中最重要的是以下这些：
- en: '**Low-Level Hardware Orientation** RARP works using hardware broadcasts. This
    means that if you have a large internetwork with many physical networks, you need
    an RARP server on *every* network segment. Worse, if you need reliability to make
    sure RARP keeps running even if one RARP server goes down, you need *two* on each
    physical network. This makes centralized management of IP addresses difficult.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**低级硬件导向** RARP使用硬件广播工作。这意味着如果你有一个由许多物理网络组成的大型互连网络，你需要在*每个*网络段上都有一个RARP服务器。更糟糕的是，如果你需要可靠性来确保RARP即使在某个RARP服务器宕机的情况下也能继续运行，你需要在每个物理网络上配置*两个*RARP服务器。这使得IP地址的集中管理变得困难。'
- en: '**Manual Assignment** RARP allows hosts to configure themselves automatically,
    but the RARP server must still be set up with a manual table of bindings between
    hardware and IP addresses. These must be maintained for each server, which is,
    again, a lot of work for an administrator.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动分配** RARP允许主机自动配置自己，但RARP服务器仍需手动设置硬件与IP地址之间的绑定表。这些绑定表需要为每个服务器维护，这又给管理员带来了大量工作。'
- en: '**Limited Information** RARP provides a host with only its IP address. It cannot
    provide other needed information such as, for example, a subnet mask or default
    gateway.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限信息** RARP只为主机提供其IP地址。它无法提供其他所需信息，例如，例如，子网掩码或默认网关。'
- en: 'The importance of host configuration has increased dramatically since the early
    1980s. Many organizations assign IP addresses dynamically even for hosts that
    have disk storage, because of the many advantages this provides in administration
    and because of the efficient use of address space. For this reason, RARP has been
    replaced by two more capable technologies that operate at higher layers in the
    TCP/IP protocol stack: BOOTP and DHCP. They are discussed in the application layer
    section on host configuration protocols, in Chapters [Chapter 60](ch60.html "Chapter 60. TCP/IP
    BOOTSTRAP PROTOCOL (BOOTP)") through [Chapter 64](ch64.html "Chapter 64. DHCP
    CLIENT/SERVER IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT").'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 自20世纪80年代初以来，主机配置的重要性显著增加。许多组织甚至为具有磁盘存储的主机动态分配IP地址，因为这种做法在管理和地址空间的高效使用上提供了许多优势。因此，RARP已被两种更高级的技术所取代，这些技术运行在TCP/IP协议栈的更高层：BOOTP和DHCP。它们在主机配置协议的应用层部分中进行了讨论，从第[第60章](ch60.html
    "第60章。TCP/IP引导协议(BOOTP)")到第[第64章](ch64.html "第64章。DHCP客户端/服务器实现、功能以及IPv6支持")。
