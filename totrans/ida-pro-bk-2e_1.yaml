- en: Part I. Introduction to IDA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。IDA简介
- en: Chapter 1. Introduction to Disassembly
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。汇编简介
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: You may be wondering what to expect in a book dedicated to IDA Pro. While obviously
    IDA-centric, this book is not intended to come across as *The IDA Pro User’s Manual*.
    Instead, we intend to use IDA as the enabling tool for discussing reverse engineering
    techniques that you will find useful in analyzing a wide variety of software,
    ranging from vulnerable applications to malware. When appropriate, we will provide
    detailed steps to be followed in IDA for performing specific actions related to
    the task at hand. As a result we will take a rather roundabout walk through IDA’s
    capabilities, beginning with the basic tasks you will want to perform upon initial
    examination of a file and leading up to advanced uses and customization of IDA
    for more challenging reverse engineering problems. We make no attempt to cover
    all of IDA’s features. We do, however, cover the features that you will find most
    useful in meeting your reverse engineering challenges. This book will help make
    IDA the most potent weapon in your arsenal of tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道一本专门介绍IDA Pro的书会有什么内容。虽然显然是以IDA为中心，但这本书并不打算成为*IDA Pro用户手册*。相反，我们打算使用IDA作为讨论逆向工程技术的工具，这些技术对于分析各种软件非常有用，从易受攻击的应用程序到恶意软件。在适当的时候，我们将提供在IDA中执行与当前任务相关的特定操作的详细步骤。因此，我们将对IDA的功能进行较为曲折的探索，从检查文件时的基本任务开始，到高级使用和定制IDA以解决更复杂的逆向工程问题。我们并不试图涵盖IDA的所有功能。然而，我们确实涵盖了你在解决逆向工程挑战时最可能发现有用的功能。这本书将帮助使IDA成为你工具库中最强大的武器。
- en: Prior to diving into any IDA specifics, it will be useful to cover some of the
    basics of the disassembly process as well as review some other tools available
    for reverse engineering of compiled code. While none of these tools offers the
    complete range of IDA’s capabilities, each does address specific subsets of IDA
    functionality and offer valuable insight into specific IDA features. The remainder
    of this chapter is dedicated to understanding the disassembly process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究IDA的任何具体内容之前，了解汇编过程的一些基本知识以及回顾一些可用于编译代码逆向工程的其他工具将是有用的。虽然这些工具中没有哪一个提供IDA的全部功能，但每个工具都针对IDA功能的具体子集，并为特定IDA功能提供了宝贵的见解。本章的其余部分致力于理解汇编过程。
- en: Disassembly Theory
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编理论
- en: Anyone who has spent any time at all studying programming languages has probably
    learned about the various generations of languages, but they are summarized here
    for those who may have been sleeping.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何花时间研究编程语言的人可能都了解过各种语言代系，但这里总结了这些内容，以便那些可能一直在睡觉的人了解。
- en: '**First-generation languages**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一代语言**'
- en: These are the lowest form of language, generally consisting of ones and zeros
    or some shorthand form such as hexadecimal, and readable only by binary ninjas.
    Things are confusing at this level because it is often difficult to distinguish
    data from instructions since everything looks pretty much the same. First-generation
    languages may also be referred to as *machine languages*, and in some cases *byte
    code*, while machine language programs are often referred to as *binaries*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最基本的语言形式，通常由一和零或一些简写形式，如十六进制组成，只有二进制忍者才能阅读。在这个层面上，事情很混乱，因为通常很难区分数据和指令，因为它们看起来几乎完全相同。第一代语言也被称为*机器语言*，在某些情况下称为*字节码*，而机器语言程序通常被称为*二进制*。
- en: '**Second-generation languages**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二代语言**'
- en: Also called *assembly languages*, second-generation languages are a mere table
    lookup away from machine language and generally map specific bit patterns, or
    operation codes (opcodes), to short but memorable character sequences called *mnemonics*.
    Occasionally these mnemonics actually help programmers remember the instructions
    with which they are associated. An *assembler* is a tool used by programmers to
    translate their assembly language programs into machine language suitable for
    execution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为*汇编语言*，第二代语言仅通过查找表即可接近机器语言，通常将特定的位模式或操作码（opcodes）映射到简短但易于记忆的字符序列，称为*助记符*。偶尔，这些助记符实际上有助于程序员记住与它们相关的指令。*汇编器*是程序员用来将他们的汇编语言程序翻译成适合执行的目标机器语言的工具。
- en: '**Third-generation languages**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三代语言**'
- en: These languages take another step toward the expressive capability of natural
    languages by introducing keywords and constructs that programmers use as the building
    blocks for their programs. Third-generation languages are generally platform independent,
    though programs written using them may be platform dependent as a result of using
    features unique to a specific operating system. Often-cited examples include FORTRAN,
    COBOL, C, and Java. Programmers generally use compilers to translate their programs
    into assembly language or all the way to machine language (or some rough equivalent
    such as byte code).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言通过引入程序员用作程序构建块的键词和结构，进一步提高了自然语言的表达能力。第三代语言通常是平台无关的，尽管使用它们编写的程序可能由于使用了特定操作系统的独特功能而具有平台依赖性。常引用的例子包括
    FORTRAN、COBOL、C 和 Java。程序员通常使用编译器将他们的程序翻译成汇编语言，甚至直接翻译成机器语言（或某些粗略的等效物，如字节码）。
- en: '**Fourth-generation languages**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**第四代语言**'
- en: These exist but aren’t relevant to this book and will not be discussed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具存在，但与本书无关，因此不会进行讨论。
- en: The What of Disassembly
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反汇编的“是什么”
- en: In a traditional software development model, compilers, assemblers, and linkers
    are used by themselves or in combination to create executable programs. In order
    to work our way backwards (or reverse engineer programs), we use tools to undo
    the assembly and compilation processes. Not surprisingly, such tools are called
    *disassemblers* and *decompilers*, and they do pretty much what their names imply.
    A disassembler undoes the assembly process, so we should expect assembly language
    as the output (and therefore machine language as input). Decompilers aim to produce
    output in a high-level language when given assembly or even machine language as
    input.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的软件开发模型中，编译器、汇编器和链接器单独使用或组合使用来创建可执行程序。为了逆向工作（或进行逆向工程），我们使用工具来撤销汇编和编译过程。不出所料，这样的工具被称为*反汇编器*和*反汇编器*，它们基本上做了它们名字暗示的事情。反汇编器撤销汇编过程，因此我们应该期望输出是汇编语言（因此输入是机器语言）。反汇编器旨在在给定汇编语言甚至机器语言作为输入时产生高级语言输出。
- en: 'The promise of “source code recovery” will always be attractive in a competitive
    software market, and thus the development of usable decompilers remains an active
    research area in computer science. The following are just a few of the reasons
    that decompilation is difficult:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在竞争激烈的软件市场中，“源代码恢复”的承诺总是具有吸引力，因此，可用的反汇编器的开发仍然是计算机科学中的一个活跃的研究领域。以下只是几个说明反汇编困难的原因：
- en: '**The compilation process is lossy**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译过程是有损的**。'
- en: At the machine language level there are no variable or function names, and variable
    type information can be determined only by how the data is used rather than explicit
    type declarations. When you observe 32 bits of data being transferred, you’ll
    need to do some investigative work to determine whether those 32 bits represent
    an integer, a 32-bit floating point value, or a 32-bit pointer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器语言级别，没有变量或函数名，变量类型信息只能通过数据的使用方式来确定，而不是通过显式的类型声明。当你观察到32位数据正在传输时，你需要做一些调查工作来确定这32位代表一个整数、一个32位的浮点值还是一个32位的指针。
- en: '**Compilation is a many-to-many operation**.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译是一个多对多的操作**。'
- en: This means that a source program can be translated to assembly language in many
    different ways, and machine language can be translated back to source in many
    different ways. As a result, it is quite common that compiling a file and immediately
    decompiling it may yield a vastly different source file from the one that was
    input.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着源程序可以以多种不同的方式翻译成汇编语言，机器语言也可以以多种不同的方式翻译回源代码。因此，编译一个文件然后立即反汇编它可能会产生与输入文件截然不同的源文件是很常见的。
- en: '**Decompilers are very language and library dependent**.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**反汇编器非常依赖于语言和库**。'
- en: Processing a binary produced by a Delphi compiler with a decompiler designed
    to generate C code can yield very strange results. Similarly, feeding a compiled
    Windows binary through a decompiler that has no knowledge of the Windows programming
    API may not yield anything useful.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计用于生成C代码的反汇编器处理由Delphi编译器生成的二进制文件可能会产生非常奇怪的结果。同样，将编译的Windows二进制文件通过一个对Windows编程API一无所知的反汇编器处理可能不会产生任何有用的结果。
- en: '**A nearly perfect disassembly capability is needed in order to accurately
    decompile a binary**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了准确反汇编二进制文件，需要几乎完美的反汇编能力**。'
- en: Any errors or omissions in the disassembly phase will almost certainly propagate
    through to the decompiled code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编阶段出现的任何错误或遗漏几乎肯定会传播到反编译代码中。
- en: Hex-Rays, the most sophisticated decompiler on the market today, will be reviewed
    in [Chapter 23](ch23.html "Chapter 23. Real-World IDA Plug-ins").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Hex-Rays，目前市场上最复杂的反编译器，将在[第23章](ch23.html "第23章。现实世界的IDA插件")中回顾。
- en: The Why of Disassembly
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反汇编的“为什么”
- en: 'The purpose of disassembly tools is often to facilitate understanding of programs
    when source code is unavailable. Common situations in which disassembly is used
    include these:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编工具的目的通常是为了在源代码不可用时方便理解程序。使用反汇编的常见情况包括以下这些：
- en: Analysis of malware
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件分析
- en: Analysis of closed-source software for vulnerabilities
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭源软件的安全漏洞分析
- en: Analysis of closed-source software for interoperability
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭源软件的互操作性分析
- en: Analysis of compiler-generated code to validate compiler performance/correctness
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析编译器生成的代码以验证编译器性能/正确性
- en: Display of program instructions while debugging
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试时显示程序指令
- en: The subsequent sections will explain each situation in more detail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将更详细地解释每种情况。
- en: Malware Analysis
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恶意软件分析
- en: Unless you are dealing with a script-based worm, malware authors seldom do you
    the favor of providing the source code to their creations. Lacking source code,
    you are faced with a very limited set of options for discovering exactly how the
    malware behaves. The two main techniques for malware analysis are dynamic analysis
    and static analysis. *Dynamic analysis* involves allowing the malware to execute
    in a carefully controlled environment (sandbox) while recording every observable
    aspect of its behavior using any number of system instrumentation utilities. In
    contrast, *static analysis* attempts to understand the behavior of a program simply
    by reading through the program code, which, in the case of malware, generally
    consists of a disassembly listing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在处理基于脚本的蠕虫，恶意软件作者很少会提供他们作品的源代码。没有源代码，你将面临一个非常有限的选项集，以发现恶意软件的确切行为。恶意软件分析的两个主要技术是动态分析和静态分析。*动态分析*涉及在精心控制的环境中（沙盒）允许恶意软件执行，同时使用任何数量的系统仪器工具记录其行为的每一个可观察方面。相比之下，*静态分析*试图通过阅读程序代码来理解程序的行为，在恶意软件的情况下，这通常由反汇编列表组成。
- en: Vulnerability Analysis
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞分析
- en: 'For the sake of simplification, let’s break the entire security-auditing process
    into three steps: vulnerability discovery, vulnerability analysis, and exploit
    development. The same steps apply whether you have source code or not; however,
    the level of effort increases substantially when all you have is a binary. The
    first step in the process is to discover a potentially exploitable condition in
    a program. This is often accomplished using dynamic techniques such as fuzzing,^([[1](#ftn.CHP-1-FN-1)])
    but it can also be performed (usually with much more effort) via static analysis.
    Once a problem has been discovered, further analysis is often required to determine
    whether the problem is exploitable at all and, if so, under what conditions.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，让我们将整个安全审计过程分为三个步骤：漏洞发现、漏洞分析和利用开发。无论你是否拥有源代码，这些步骤都适用；然而，当你只有二进制文件时，所需的努力水平会大幅增加。这个过程的第一步是在程序中发现一个可能可利用的条件。这通常是通过使用模糊测试等动态技术来完成的，但也可以通过静态分析来完成（通常需要更多的努力）。一旦发现问题，通常需要进行进一步的分析，以确定问题是否可利用，如果是的话，在什么条件下可利用。
- en: Disassembly listings provide the level of detail required to understand exactly
    how the compiler has chosen to allocate program variables. For example, it might
    be useful to know that a 70-byte character array declared by a programmer was
    rounded up to 80 bytes when allocated by the compiler. Disassembly listings also
    provide the only means to determine exactly how a compiler has chosen to order
    all of the variables declared globally or within functions. Understanding the
    spatial relationships among variables is often essential when attempting to develop
    exploits. Ultimately, by using a disassembler and a debugger together, an exploit
    may be developed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编列表提供了理解编译器如何选择分配程序变量的详细程度。例如，可能有用的是知道程序员声明的70字节字符数组在编译器分配时被四舍五入到80字节。反汇编列表还提供了唯一的方法来确定编译器如何选择对所有全局或函数内声明的变量进行排序。在尝试开发利用程序时，理解变量之间的空间关系通常是至关重要的。最终，通过使用反汇编器和调试器一起，可以开发出利用程序。
- en: Software Interoperability
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件互操作性
- en: When software is released in binary form only, it is very difficult for competitors
    to create software that can interoperate with it or to provide plug-in replacements
    for that software. A common example is driver code released for hardware that
    is supported on only one platform. When a vendor is slow to support or, worse
    yet, refuses to support the use of its hardware with alternative platforms, substantial
    reverse engineering effort may be required in order to develop software drivers
    to support the hardware. In these cases, static code analysis is almost the only
    remedy and often must go beyond the software driver to understand embedded firmware.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件仅以二进制形式发布时，竞争对手很难创建可以与之互操作的软件或提供该软件的插件替代品。一个常见的例子是为仅支持一个平台的硬件发布的驱动代码。当供应商缓慢支持或更糟糕的是拒绝支持其硬件与替代平台的使用时，可能需要大量的逆向工程工作来开发支持该硬件的软件驱动程序。在这些情况下，静态代码分析几乎是唯一的补救措施，并且通常必须超出软件驱动程序来理解嵌入式固件。
- en: Compiler Validation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器验证
- en: Since the purpose of a compiler (or assembler) is to generate machine language,
    good disassembly tools are often required to verify that the compiler is doing
    its job in accordance with any design specifications. Analysts may also be interested
    in locating additional opportunities for optimizing compiler output and, from
    a security standpoint, ascertaining whether the compiler itself has been compromised
    to the extent that it may be inserting back doors into generated code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器（或汇编器）的目的是生成机器语言，因此通常需要优秀的拆解工具来验证编译器是否按照任何设计规范完成其工作。分析师还可能对寻找优化编译器输出的额外机会感兴趣，从安全角度来看，确定编译器本身是否已被破坏到可能在其生成的代码中插入后门的程度。
- en: Debugging Displays
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试显示
- en: Perhaps the single most common use of disassemblers is to generate listings
    within debuggers. Unfortunately, disassemblers embedded within debuggers tend
    to be fairly unsophisticated. They are generally incapable of batch disassembly
    and sometimes balk at disassembling when they cannot determine the boundaries
    of a function. This is one of the reasons why it is best to use a debugger in
    conjunction with a high-quality disassembler to provide better situational awareness
    and context during debugging.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最常见的使用拆解器的方式是在调试器中生成列表。不幸的是，嵌入在调试器中的拆解器往往相当简单。它们通常无法进行批量拆解，有时在无法确定函数边界时甚至拒绝拆解。这就是为什么最好将调试器与高质量的拆解器一起使用，以便在调试过程中提供更好的情境意识和上下文。
- en: '* * *'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-1-FN-1)]) *Fuzzing* is a vulnerability-discovery technique that
    relies on generating large numbers of unique inputs for programs in the hope that
    one of those inputs will cause the program to fail in a manner that can be detected,
    analyzed, and ultimately exploited.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-1-FN-1)]) *模糊测试*是一种漏洞发现技术，它依赖于为程序生成大量唯一的输入，希望其中之一会导致程序以可检测、分析并最终可利用的方式失败。
- en: The How of Disassembly
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆解的“如何”
- en: 'Now that you’re well versed in the purposes of disassembly, it’s time to move
    on to how the process actually works. Consider a typical daunting task faced by
    a disassembler: *Take these 100KB, distinguish code from data, convert the code
    to assembly language for display to a user, and please don’t miss anything along
    the way*. We could tack any number of special requests on the end of this, such
    as asking the disassembler to locate functions, recognize jump tables, and identify
    local variables, making the disassembler’s job that much more difficult.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了拆解的目的，是时候继续了解这个过程是如何实际运作的了。考虑一个典型的令拆解者感到畏惧的任务：*将这些100KB的数据区分开来，区分代码和数据，将代码转换为汇编语言以供用户显示，并且在过程中请勿遗漏任何细节*。我们可以在末尾添加任何数量的特殊要求，例如要求拆解器定位函数、识别跳转表和识别局部变量，从而使拆解器的任务变得更加困难。
- en: In order to accommodate all of our demands, any disassembler will need to pick
    and choose from a variety of algorithms as it navigates through the files that
    we feed it. The quality of the generated disassembly listing will be directly
    related to the quality of the algorithms utilized and how well they have been
    implemented. In this section we will discuss two of the fundamental algorithms
    in use today for disassembling machine code. As we present these algorithms, we
    will also point out their shortcomings in order to prepare you for situations
    in which your disassembler appears to fail. By understanding a disassembler’s
    limitations, you will be able to manually intervene to improve the overall quality
    of the disassembly output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足我们的所有需求，任何反汇编器在导航我们提供的文件时都需要从各种算法中进行选择。生成的反汇编列表的质量将直接与所使用算法的质量以及它们的实现程度有关。在本节中，我们将讨论目前用于反汇编机器代码的两个基本算法。在介绍这些算法时，我们还将指出它们的不足，以便为你的反汇编器似乎失败的情况做好准备。通过了解反汇编器的限制，你将能够手动干预以改善反汇编输出的整体质量。
- en: A Basic Disassembly Algorithm
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本反汇编算法
- en: For starters, let’s develop a simple algorithm for accepting machine language
    as input and producing assembly language as output. In doing so, we will gain
    an understanding of the challenges, assumptions, and compromises that underlie
    an automated disassembly process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开发一个简单的算法，用于接受机器语言作为输入并产生汇编语言作为输出。通过这样做，我们将了解自动化反汇编过程背后的挑战、假设和妥协。
- en: '**Step 1**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1**'
- en: The first step in the disassembly process is to identify a region of code to
    disassemble. This is not necessarily as straightforward as it may seem. Instructions
    are generally mixed with data, and it is important to distinguish between the
    two. In the most common case, disassembly of an executable file, the file will
    conform to a common format for executable files such as the *Portable Executable
    (PE)* format used on Windows or the *Executable and Linking Format (ELF)* common
    on many Unix-based systems. These formats typically contain mechanisms (often
    in the form of hierarchical file headers) for locating the sections of the file
    that contain code and entry points^([[2](#ftn.CHP-1-FN-2)]) into that code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编过程的第一步是确定要反汇编的代码区域。这并不一定像看起来那么简单。指令通常与数据混合，区分两者很重要。在最常见的情况下，反汇编可执行文件时，文件将符合可执行文件的通用格式，例如在Windows上使用的通用可执行文件（PE）格式或许多基于Unix系统的通用可执行链接格式（ELF）。这些格式通常包含机制（通常以分层文件头的形式），用于定位包含代码和进入该代码的入口点^([[2](#ftn.CHP-1-FN-2)])。
- en: '**Step 2**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2**'
- en: Given an initial address of an instruction, the next step is to read the value
    contained at that address (or file offset) and perform a table lookup to match
    the binary opcode value to its assembly language mnemonic. Depending on the complexity
    of the instruction set being disassembled, this may be a trivial process, or it
    may involve several additional operations such as understanding any prefixes that
    may modify the instruction’s behavior and determining any operands required by
    the instruction. For instruction sets with variable-length instructions, such
    as the Intel x86, additional instruction bytes may need to be retrieved in order
    to completely disassemble a single instruction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一条指令的初始地址，下一步是读取该地址（或文件偏移量）中包含的值，并执行表查找以将二进制操作码值与其汇编语言助记符匹配。根据正在反汇编的指令集的复杂性，这可能是一个简单的过程，也可能涉及几个额外的操作，例如理解可能修改指令行为的任何前缀以及确定指令所需的任何操作数。对于具有可变长度指令的指令集，例如英特尔x86，可能需要检索额外的指令字节才能完全反汇编单个指令。
- en: '**Step 3**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3**'
- en: Once an instruction has been fetched and any required operands decoded, its
    assembly language equivalent is formatted and output as part of the disassembly
    listing. It may be possible to choose from more than one assembly language output
    syntax. For example, the two predominant formats for x86 assembly language are
    the Intel format and the AT&T format.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦取回指令并解码了所需的操作数，其汇编语言等效物将被格式化并作为反汇编列表的一部分输出。可能可以选择多种汇编语言输出语法。例如，x86汇编语言的两种主要格式是英特尔格式和AT&T格式。
- en: 'X86 ASSEMBLY SYNTAX: AT&T VS. INTEL'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: X86汇编语法：AT&T与英特尔
- en: 'There are two main syntaxes used for assembly source code: AT&T and Intel.
    Even though they are second-generation languages, the two vary greatly in syntax
    from variable, constant, and register access to segment and instruction size overrides
    to indirection and offsets. The AT&T assembly syntax is distinguished by its use
    of the % symbol to prefix all register names, the use of $ as a prefix for literal
    constants (also called *immediate operands*), and its operand ordering in which
    the source operand appears as the left-hand operand and the destination operand
    appears on the right. Using AT&T syntax, the instruction to add four to the EAX
    register would read: `add $0x4,%eax`. The GNU Assembler (Gas) and many other GNU
    tools, including gcc and gdb, utilize AT&T syntax.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用于汇编源代码的两种主要语法是AT&T和Intel。尽管它们是第二代语言，但它们在语法上差异很大，从变量、常量和寄存器访问到段和指令大小覆盖，再到间接和偏移量。AT&T汇编语法的特点是使用%符号作为所有寄存器名称的前缀，使用$作为文字常量（也称为*立即操作数*）的前缀，以及其操作数顺序，其中源操作数作为左手操作数，目标操作数位于右侧。使用AT&T语法，将四个加到EAX寄存器的指令将读取为：`add
    $0x4,%eax`。GNU汇编器（Gas）和许多其他GNU工具，包括gcc和gdb，都使用AT&T语法。
- en: 'Intel syntax differs from AT&T in that it requires no register or literal prefixes
    and the operand ordering is reversed such that the source operand appears on the
    right and the destination appears on the left. The same add instruction using
    the Intel syntax would read: `add eax,0x4`. Assemblers utilizing Intel syntax
    include the Microsoft Assembler (MASM), Borland’s Turbo Assembler (TASM), and
    the Netwide Assembler (NASM).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Intel语法与AT&T不同，因为它不需要寄存器或文字前缀，并且操作数顺序相反，即源操作数位于右侧，目标操作数位于左侧。使用Intel语法的相同加法指令将读取为：`add
    eax,0x4`。使用Intel语法的汇编器包括Microsoft汇编器（MASM）、Borland的Turbo汇编器（TASM）和Netwide汇编器（NASM）。
- en: '**Step 4**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4**'
- en: Following the output of an instruction, we need to advance to the next instruction
    and repeat the previous process until we have disassembled every instruction in
    the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出一个指令之后，我们需要前进到下一个指令并重复之前的步骤，直到我们反汇编了文件中的每个指令。
- en: Various algorithms exist for determining where to begin a disassembly, how to
    choose the next instruction to be disassembled, how to distinguish code from data,
    and how to determine when the last instruction has been disassembled. The two
    predominant disassembly algorithms are *linear sweep* and *recursive descent*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种算法来确定反汇编的开始位置，如何选择下一个要反汇编的指令，如何区分代码和数据，以及如何确定最后一个指令已经被反汇编。两种主要的反汇编算法是*线性扫描*和*递归下降*。
- en: Linear Sweep Disassembly
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性扫描反汇编
- en: 'The linear sweep disassembly algorithm takes a very straightforward approach
    to locating instructions to disassemble: Where one instruction ends, another begins.
    As a result, the most difficult decision faced is where to begin. The usual solution
    is to assume that everything contained in sections of a program marked as code
    (typically specified by the program file’s headers) represents machine language
    instructions. Disassembly begins with the first byte in a code section and moves,
    in a linear fashion, through the section, disassembling one instruction after
    another until the end of the section is reached. No effort is made to understand
    the program’s control flow through recognition of nonlinear instructions such
    as branches.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 线性扫描反汇编算法采用了一种非常直接的方法来定位要反汇编的指令：一个指令结束，另一个指令开始。因此，面临的最困难的决定是哪里开始。通常的解决方案是假设程序中标记为代码的部分（通常由程序文件的头部指定）包含的是机器语言指令。反汇编从代码部分的第一字节开始，以线性方式通过该部分，逐个反汇编指令，直到达到部分的末尾。没有努力去通过识别非线性指令（如分支）来理解程序的控制流。
- en: During the disassembly process, a pointer can be maintained to mark the beginning
    of the instruction currently being disassembled. As part of the disassembly process,
    the length of each instruction is computed and used to determine the location
    of the next instruction to be disassembled. Instruction sets with fixed-length
    instructions (MIPS, for example) are somewhat easier to disassemble, as locating
    subsequent instructions is straightforward.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编过程中，可以维护一个指针来标记当前正在反汇编的指令的开始。作为反汇编过程的一部分，计算每个指令的长度，并用于确定下一个要反汇编的指令的位置。具有固定长度指令集（例如MIPS）的反汇编相对容易，因为定位后续指令是直接的。
- en: 'The main advantage of the linear sweep algorithm is that it provides complete
    coverage of a program’s code sections. One of the primary disadvantages of the
    linear sweep method is that it fails to account for the fact that data may be
    comingled with code. This is evident in [Example 1-1](ch01s04.html#linear_sweep_disassembly-id1
    "Example 1-1. Linear sweep disassembly"), which shows the output of a function
    disassembled with a linear sweep disassembler. This function contains a switch
    statement, and the compiler used in this case has elected to implement the switch
    using a jump table. Furthermore, the compiler has elected to embed the jump table
    within the function itself. The `jmp` statement at ![](httpatomoreillycomsourcenostarchimages854061.png),
    `401250`, references an address table starting at ![](httpatomoreillycomsourcenostarchimages854063.png),
    `401257`. Unfortunately, the disassembler treats ![](httpatomoreillycomsourcenostarchimages854063.png)
    as if it were an instruction and incorrectly generates the corresponding assembly
    language representation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 线性扫描算法的主要优势是它提供了对程序代码段的全面覆盖。线性扫描方法的其中一个主要缺点是它未能考虑到数据可能与代码混合在一起的事实。这在[示例 1-1](ch01s04.html#linear_sweep_disassembly-id1
    "示例 1-1. 线性扫描反汇编")中表现得尤为明显，该示例展示了使用线性扫描反汇编器反汇编的函数输出。这个函数包含了一个switch语句，并且在这个例子中，编译器选择使用跳转表来实现switch。此外，编译器还选择在函数本身中嵌入跳转表。位于`401250`的`jmp`语句引用了一个以`401257`开始的地址表。不幸的是，反汇编器将`401257`视为一条指令，并错误地生成了相应的汇编语言表示：
- en: Example 1-1. Linear sweep disassembly
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-1. 线性扫描反汇编
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we examine successive 4-byte groups as little-endian^([[3](#ftn.CHP-1-FN-3)])
    values beginning at ![](httpatomoreillycomsourcenostarchimages854063.png), we
    see that each represents a pointer to a nearby address that is in fact the destination
    for one of various jumps (`004012e0`, `0040128b`, `00401290`, . . .). Thus, the
    `loopne` instruction at ![](httpatomoreillycomsourcenostarchimages854063.png)
    is not an instruction at all. Instead, it indicates a failure of the linear sweep
    algorithm to properly distinguish embedded data from code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`401257`开始，以小端格式检查连续的4字节组作为值，我们会看到每个值代表一个指向附近地址的指针，而这个地址实际上是各种跳转（`004012e0`、`0040128b`、`00401290`等）的目的地。因此，位于`401257`的`loopne`指令根本不是一条指令。相反，它表明线性扫描算法未能正确地区分嵌入的数据和代码。
- en: Linear sweep is used by the disassembly engines contained in the GNU debugger
    (gdb), Microsoft’s WinDbg debugger, and the `objdump` utility.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 线性扫描被包含在GNU调试器（gdb）、微软的WinDbg调试器和`objdump`实用程序中的反汇编引擎所使用。
- en: Recursive Descent Disassembly
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归下降反汇编
- en: Recursive descent takes a different approach to locating instructions. Recursive
    descent focuses on the concept of control flow, which determines whether an instruction
    should be disassembled or not based on whether it is referenced by another instruction.
    To understand recursive descent, it is helpful to classify instructions according
    to how they affect the CPU instruction pointer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 递归下降采用不同的方法来定位指令。递归下降关注控制流的概念，根据指令是否被其他指令引用来决定是否应该反汇编指令。为了理解递归下降，根据指令如何影响CPU指令指针对指令进行分类是有帮助的。
- en: Sequential Flow Instructions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序流程指令
- en: Sequential flow instructions pass execution to the instruction that immediately
    follows. Examples of sequential flow instructions include simple arithmetic instructions,
    such as `add`; register-to-memory transfer instructions, such as `mov`; and stack-manipulation
    operations, such as `push` and `pop`. For such instructions, disassembly proceeds
    as with linear sweep.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序流程指令将执行传递给紧随其后的指令。顺序流程指令的例子包括简单的算术指令，如`add`；寄存器到内存传输指令，如`mov`；以及栈操作，如`push`和`pop`。对于此类指令，反汇编过程与线性扫描相同。
- en: Conditional Branching Instructions
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件分支指令
- en: Conditional branching instructions, such as the x86 `jnz`, offer two possible
    execution paths. If the condition evaluates to true, the branch is taken, and
    the instruction pointer must be changed to reflect the target of the branch. However,
    if the condition is false, execution continues in a linear fashion, and a linear
    sweep methodology can be used to disassemble the next instruction. As it is generally
    not possible in a static context to determine the outcome of a conditional test,
    the recursive descent algorithm disassembles both paths, deferring disassembly
    of the branch target instruction by adding the address of the target instruction
    to a list of addresses to be disassembled at a later point.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分支指令，如 x86 的 `jnz`，提供两条可能的执行路径。如果条件评估为真，则执行分支，并且指令指针必须更改以反映分支的目标。然而，如果条件为假，执行将以线性方式继续，可以使用线性扫描方法来反汇编下一个指令。由于在静态上下文中通常无法确定条件测试的结果，递归下降算法会反汇编两条路径，通过将目标指令的地址添加到稍后要反汇编的地址列表中，延迟反汇编分支目标指令。
- en: Unconditional Branching Instructions
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无条件分支指令
- en: Unconditional branches do not follow the linear flow model and therefore are
    handled differently by the recursive descent algorithm. As with the sequential
    flow instructions, execution can flow to only one instruction; however, that instruction
    need not immediately follow the branch instruction. In fact, as seen in [Example 1-1](ch01s04.html#linear_sweep_disassembly-id1
    "Example 1-1. Linear sweep disassembly"), there is no requirement at all for an
    instruction to immediately follow an unconditional branch. Therefore, there is
    no reason to disassemble the bytes that follow an unconditional branch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件分支不遵循线性流程模型，因此递归下降算法会以不同的方式处理它们。与顺序流程指令一样，执行只能流向一个指令；然而，该指令不必立即跟随分支指令。实际上，正如[示例
    1-1](ch01s04.html#linear_sweep_disassembly-id1 "示例 1-1. 线性扫描反汇编")所示，无条件分支后不需要指令立即跟随。因此，没有必要反汇编无条件分支后的字节。
- en: A recursive descent disassembler will attempt to determine the target of the
    unconditional jump and add the destination address to the list of addresses that
    have yet to be explored. Unfortunately, some unconditional branches can cause
    problems for recursive descent disassemblers. When the target of a jump instruction
    depends on a runtime value, it may not be possible to determine the destination
    of the jump using static analysis. The x86 instruction `jmp eax` demonstrates
    this problem. The `eax` register contains a value only when the program is actually
    running. Since the register contains no value during static analysis, we have
    no way to determine the target of the jump instruction, and consequently, we have
    no way to determine where to continue the disassembly process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 递归下降反汇编器将尝试确定无条件跳转的目标，并将目标地址添加到尚未探索的地址列表中。不幸的是，某些无条件分支可能会给递归下降反汇编器带来问题。当跳转指令的目标依赖于运行时值时，可能无法通过静态分析确定跳转的目的地。x86
    指令 `jmp eax` 就展示了这个问题。`eax` 寄存器仅在程序实际运行时才包含值。由于在静态分析期间寄存器不包含值，我们无法确定跳转指令的目标，因此也无法确定反汇编过程的继续位置。
- en: Function Call Instructions
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数调用指令
- en: Function call instructions operate in a manner very similar to unconditional
    jump instructions (including the inability of the disassembler to determine the
    target of instructions such as `call eax`), with the additional expectation that
    execution usually returns to the instruction immediately following the call instruction
    once the function completes. In this regard, they are similar to conditional branch
    instructions in that they generate two execution paths. The target address of
    the call instruction is added to a list for deferred disassembly, while the instruction
    immediately following the call is disassembled in a manner similar to linear sweep.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用指令的操作方式与无条件跳转指令非常相似（包括反汇编器无法确定如 `call eax` 这样的指令的目标），并且还有一个额外的期望，即函数完成后执行通常会返回到调用指令之后的指令。在这方面，它们与条件分支指令相似，因为它们生成两条执行路径。调用指令的目标地址被添加到列表中以便延迟反汇编，而调用指令之后的指令以类似于线性扫描的方式反汇编。
- en: Recursive descent can fail if programs do not behave as expected when returning
    from called functions. For example, code in a function can deliberately manipulate
    the return address of that function so that upon completion, control returns to
    a location different from the one expected by the disassembler. A simple example
    is shown in the following incorrect listing, where function `foo` simply adds
    1 to the return address before returning to the caller.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序在从被调用函数返回时没有按预期行为，递归下降可能会失败。例如，函数中的代码可以故意操纵该函数的返回地址，使得在完成时，控制权返回到与反汇编器预期不同的位置。以下是一个简单的错误列表示例，其中函数`foo`在返回调用者之前简单地将1加到返回地址上。
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As a result, control does not actually pass to the `add` instruction at ![](httpatomoreillycomsourcenostarchimages854061.png)
    following the call to `foo`. A proper disassembly appears below:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，控制实际上并没有传递到调用`foo`之后的![图片链接](httpatomoreillycomsourcenostarchimages854061.png)处的`add`指令。下面是一个适当的反汇编示例：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This listing more clearly shows the actual flow of the program in which function
    `foo` actually returns to the `mov` instruction at ![](httpatomoreillycomsourcenostarchimages854063.png).
    It is important to understand that a linear sweep disassembler will also fail
    to properly disassemble this code, though for slightly different reasons.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表更清楚地显示了程序的实际流程，其中函数`foo`实际上返回到`mov`指令，如图所示 ![图片链接](httpatomoreillycomsourcenostarchimages854063.png)。重要的是要理解，线性扫描反汇编器也会失败地正确反汇编此代码，尽管原因略有不同。
- en: Return Instructions
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回指令
- en: In some cases, the recursive descent algorithm runs out of paths to follow.
    A function return instruction (x86 `ret`, for example) offers no information about
    what instruction will be executed next. If the program were actually running,
    an address would be taken from the top of the runtime stack, and execution would
    resume at that address. Disassemblers do not have the benefit of access to a stack.
    Instead, disassembly abruptly comes to a halt. It is at this point that the recursive
    descent disassembler turns to the list of addresses it has been setting aside
    for deferred disassembly. An address is removed from this list, and the disassembly
    process is continued from this address. This is the recursive process that lends
    the disassembly algorithm its name.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，递归下降算法会耗尽可跟随的路径。一个函数返回指令（例如x86的`ret`）不会提供关于下一个要执行指令的信息。如果程序实际上正在运行，则会从运行时栈的顶部取一个地址，并且执行将从该地址恢复。反汇编器没有访问栈的优势。相反，反汇编会突然停止。正是在这一点上，递归下降反汇编器转向它为延迟反汇编而保留的地址列表。从这个列表中移除一个地址，并从这个地址继续反汇编过程。这就是赋予反汇编算法其名称的递归过程。
- en: One of the principle advantages of the recursive descent algorithm is its superior
    ability to distinguish code from data. As a control flow–based algorithm, it is
    much less likely to incorrectly disassemble data values as code. The main disadvantage
    of recursive descent is the inability to follow indirect code paths, such as jumps
    or calls, which utilize tables of pointers to look up a target address. However,
    with the addition of some heuristics to identify pointers to code, recursive descent
    disassemblers can provide very complete code coverage and excellent recognition
    of code versus data. [Example 1-2](ch01s04.html#recursive_descent_disassembly-id1
    "Example 1-2. Recursive descent disassembly") shows the output of a recursive
    descent disassembler used on the same switch statement shown earlier in [Example 1-1](ch01s04.html#linear_sweep_disassembly-id1
    "Example 1-1. Linear sweep disassembly").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 递归下降算法的一个主要优点是其区分代码和数据的能力优于其他算法。作为一个基于控制流的算法，它不太可能错误地将数据值反汇编为代码。递归下降的主要缺点是无法跟随间接代码路径，例如跳转或调用，这些路径使用指针表来查找目标地址。然而，通过添加一些启发式方法来识别指向代码的指针，递归下降反汇编器可以提供非常完整的代码覆盖率和出色的代码与数据识别。[示例1-2](ch01s04.html#recursive_descent_disassembly-id1
    "示例1-2。递归下降反汇编")显示了在之前[示例1-1](ch01s04.html#linear_sweep_disassembly-id1 "示例1-1。线性扫描反汇编")中显示的相同switch语句上使用的递归下降反汇编器的输出。
- en: Example 1-2. Recursive descent disassembly
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-2。递归下降反汇编
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the table of jump destinations has been recognized and formatted accordingly.
    IDA Pro is the most prominent example of a recursive descent disassembler. An
    understanding of the recursive descent process will help us recognize situations
    in which IDA may produce less than optimal disassemblies and allow us to develop
    strategies to improve IDA’s output.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，跳转目标表已经被识别并相应地格式化。IDA Pro是最著名的递归下降反汇编器的例子。理解递归下降过程将帮助我们识别IDA可能产生非最佳反汇编的情况，并允许我们制定策略来提高IDA的输出。
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-1-FN-2)]) A *program entry point* is simply the address of the instruction
    to which the operating system passes control once a program has been loaded into
    memory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-1-FN-2)]) *程序入口点*简单地是指操作系统在程序加载到内存后传递控制权的指令地址。
- en: ^([[3](#CHP-1-FN-3)]) A CPU is described as either big-endian or little-endian
    depending on whether the CPU saves the most significant byte of a multibyte value
    first (big-endian) or whether it stores the least significant byte first (little-endian).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-1-FN-3)]) CPU被描述为大端或小端，这取决于CPU是首先保存多字节值的最重要字节（大端）还是首先存储最不重要的字节（小端）。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Is deep understanding of disassembly algorithms essential when using a disassembler?
    No. Is it useful? Yes! Battling your tools is the last thing you want to spend
    time doing while reverse engineering. One of the many advantages of IDA is that,
    unlike most other disassemblers, it offers you plenty of opportunity to guide
    and override its decisions. The net result is that the finished product, an accurate
    disassembly, will be far superior to anything else available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反汇编器时，对反汇编算法的深入理解是否是必要的？不是。它有用吗？是的！在与工具斗争时，你肯定不希望花费时间。IDA的许多优点之一是，与其他大多数反汇编器不同，它为你提供了很多机会来引导和覆盖其决策。最终结果是，最终产品，一个准确的反汇编，将远远优于其他任何可用的东西。
- en: In the next chapter we will review a variety of existing tools that prove useful
    in many reverse engineering situations. While not directly related to IDA, many
    of these tools have influenced and been influenced by IDA, and they help to explain
    the wide variety of informational displays available in the IDA user interface.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾各种现有工具，这些工具在许多逆向工程场景中非常有用。虽然这些工具与IDA没有直接关系，但许多工具都受到了IDA的影响，并且它们有助于解释IDA用户界面中可用的广泛信息显示。
- en: Chapter 2. Reversing and Disassembly Tools
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。逆向工程和反汇编工具
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: With some disassembly background under our belts, and before we begin our dive
    into the specifics of IDA Pro, it will be useful to understand some of the other
    tools that are used for reverse engineering binaries. Many of these tools predate
    IDA and continue to be useful for quick glimpses into files as well as for double-checking
    the work that IDA does. As we will see, IDA rolls many of the capabilities of
    these tools into its user interface to provide a single, integrated environment
    for reverse engineering. Finally, although IDA does contain an integrated debugger,
    we will not cover debuggers here as [Chapter 24](ch24.html "Chapter 24. The IDA
    Debugger"), [Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger Integration"),
    and [Chapter 26](ch26.html "Chapter 26. Additional Debugger Features") are dedicated
    to the topic.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了一些反汇编背景知识之后，在我们开始深入研究IDA Pro的具体细节之前，了解一些用于逆向工程二进制文件的其他工具将是有用的。许多这些工具在IDA之前就已经存在，并且继续用于快速查看文件以及双重检查IDA的工作。正如我们将看到的，IDA将这些工具的许多功能整合到其用户界面中，以提供一个单一的、集成的逆向工程环境。最后，尽管IDA包含一个集成的调试器，但在这里我们不会介绍调试器，因为[第24章](ch24.html
    "第24章。IDA调试器")、[第25章](ch25.html "第25章。反汇编器/调试器集成")和[第26章](ch26.html "第26章。附加调试器功能")都专门讨论了这个主题。
- en: Classification Tools
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类工具
- en: When first confronted with an unknown file, it is often useful to answer simple
    questions such as “What is this thing?” The first rule of thumb when attempting
    to answer that question is to *never* rely on a filename extension to determine
    what a file actually is. That is also the second, third, and fourth rules of thumb.
    Once you have become an adherent of the *file extensions are meaningless* line
    of thinking, you may wish to familiarize yourself with one or more of the following
    utilities.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次遇到一个未知文件时，回答简单的问题，如“这是什么？”通常很有用。尝试回答该问题的第一规则是*永远不要*依赖文件扩展名来确定文件实际上是什么。这也是第二个、第三个和第四个经验法则。一旦你成为“文件扩展名没有意义”这一观点的拥护者，你可能希望熟悉以下一个或多个实用工具。
- en: file
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: file
- en: The `file` command is a standard utility, included with most *NIX-style operating
    systems and with the Cygwin^([[4](#ftn.CHP-2-FN-1)]) or MinGW^([[5](#ftn.CHP-2-FN-2)])
    tools for Windows. `File` attempts to identify a file’s type by examining specific
    fields within the file. In some cases `file` recognizes common strings such as
    *#!/bin/sh* (a shell script) or *<html>* (an HTML document). Files containing
    non-ASCII content present somewhat more of a challenge. In such cases, `file`
    attempts to determine whether the content appears to be structured according to
    a known file format. In many cases it searches for specific tag values (often
    referred to as magic numbers^([[6](#ftn.CHP-2-FN-3)])) known to be unique to specific
    file types. The hex listings below show several examples of magic numbers used
    to identify some common file types.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 命令是一个标准实用工具，包含在大多数 *NIX 风格的操作系统以及 Windows 的 Cygwin^([[4](#ftn.CHP-2-FN-1)])
    或 MinGW^([[5](#ftn.CHP-2-FN-2)]) 工具中。`File` 通过检查文件中的特定字段来尝试识别文件类型。在某些情况下，`file`
    识别常见的字符串，如 *#!/bin/sh*（一个 shell 脚本）或 *<html>*（一个 HTML 文档）。包含非 ASCII 内容的文件会带来一些挑战。在这种情况下，`file`
    尝试确定内容是否似乎遵循一个已知的文件格式。在许多情况下，它会搜索特定的标签值（通常称为魔数^([[6](#ftn.CHP-2-FN-3)]))，这些值被认为是特定文件类型的独特标识。下面的十六进制列表显示了用于识别一些常见文件类型的几个魔数示例。'
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`file` has the capability to identify a large number of file formats, including
    several types of ASCII text files and various executable and data file formats.
    The magic number checks performed by `file` are governed by rules contained in
    a *magic file*. The default magic file varies by operating system, but common
    locations include */usr/share/file/magic*, */usr/share/misc/magic*, and */etc/magic*.
    Please refer to the documentation for `file` for more information concerning magic
    files.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 能够识别大量文件格式，包括几种 ASCII 文本文件类型以及各种可执行和数据文件格式。`file` 执行的魔数检查受一个 *magic
    文件* 中包含的规则的约束。默认的 magic 文件因操作系统而异，但常见位置包括 */usr/share/file/magic*，*/usr/share/misc/magic*
    和 */etc/magic*。请参阅 `file` 的文档以获取有关 magic 文件的更多信息。'
- en: THE CYGWIN ENVIRONMENT
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CYGWIN 环境
- en: Cygwin is a set of utilities for the Windows operating system that provides
    a Linux-style command shell and associated programs. During installation, users
    can choose from a large number of standard packages, including compilers (gcc,
    g++), interpreters (Perl, Python, Ruby), networking utilities (`nc`, `ssh`), and
    many others. Once Cygwin has been installed, many programs written for use with
    Linux can be compiled and executed on Windows systems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin 是一套为 Windows 操作系统提供的工具，它提供了一个 Linux 风格的命令 shell 和相关程序。在安装过程中，用户可以从大量的标准包中进行选择，包括编译器（gcc、g++）、解释器（Perl、Python、Ruby）、网络工具（`nc`、`ssh`）等。一旦安装了
    Cygwin，许多为 Linux 编写的程序就可以在 Windows 系统上编译和执行。
- en: In some cases, `file` can distinguish variations within a given file type. The
    following listing demonstrates `file`’s ability to identify not only several variations
    of ELF binaries but also information pertaining to how the binary was linked (statically
    or dynamically) and whether the binary was stripped or not.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`file` 可以区分给定文件类型内的变体。以下列表展示了 `file` 能够识别的不仅仅是几种 ELF 二进制文件的变体，还包括有关二进制文件是如何链接（静态或动态）以及二进制文件是否被剥离的信息。
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: STRIPPING BINARY EXECUTABLE FILES
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 剥离二进制可执行文件
- en: Stripping a binary is the process of removing symbols from the binary file.
    Binary object files contain symbols as a result of the compilation process. Some
    of these symbols are utilized during the linking process to resolve references
    between files when creating the final executable file or library. In other cases,
    symbols may be present to provide additional information for use with debuggers.
    Following the linking process, many of the symbols are no longer required. Options
    passed to the linker can cause the linker to remove the unnecessary symbols at
    build time. Alternatively, a utility named `strip` may be used to remove symbols
    from existing binary files. While a stripped binary will be smaller than its unstripped
    counterpart, the behavior of the stripped binary will remain unchanged.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 去除二进制文件中的符号是移除二进制文件中符号的过程。二进制目标文件包含符号，这是编译过程的结果。其中一些符号在链接过程中被用于解决文件之间的引用，以创建最终的执行文件或库。在其他情况下，符号可能存在以提供用于调试器的额外信息。在链接过程之后，许多符号不再需要。传递给链接器的选项可以导致链接器在构建时移除不必要的符号。或者，可以使用名为
    `strip` 的实用程序从现有二进制文件中移除符号。虽然去除符号的二进制文件将比未去除符号的对应文件更小，但去除符号的二进制文件的行为将保持不变。
- en: '`file` and similar utilities are not foolproof. It is quite possible for a
    file to be misidentified simply because it happens to bear the identifying marks
    of some file format. You can see this for yourself by using a hex editor to modify
    the first four bytes of any file to the Java magic number sequence: `CA FE BA
    BE`. The `file` utility will incorrectly identify the newly modified file as *compiled
    Java class data*. Similarly, a text file containing only the two characters `MZ`
    will be identified as an *MS-DOS executable*. A good approach to take in any reverse
    engineering effort is to never fully trust the output of any tool until you have
    correlated that output with several tools and manual analysis.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 和类似的实用程序并非万无一失。一个文件可能仅仅因为偶然带有某种文件格式的标识符而被错误识别。您可以通过使用十六进制编辑器修改任何文件的第一个四个字节为
    Java 魔数序列：`CA FE BA BE` 来亲自看到这一点。`file` 实用程序将错误地将新修改的文件识别为 *编译的 Java 类数据*。同样，只包含两个字符
    `MZ` 的文本文件将被识别为 *MS-DOS 可执行文件*。在任何逆向工程工作中，一个好的做法是在您将输出与多个工具和手动分析相关联之前，不要完全信任任何工具的输出。'
- en: PE Tools
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PE Tools
- en: PE Tools^([[7](#ftn.CHP-2-FN-4)]) is a collection of tools useful for analyzing
    both running processes and executable files on Windows systems. [Figure 2-1](ch02.html#the_pe_tools_utility
    "Figure 2-1. The PE Tools utility") shows the primary interface offered by PE
    Tools, which displays a list of active processes and provides access to all of
    the PE Tools utilities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: PE Tools^([[7](#ftn.CHP-2-FN-4)]) 是一套用于分析 Windows 系统上运行进程和可执行文件的工具集合。[图 2-1](ch02.html#the_pe_tools_utility
    "图 2-1. PE 工具实用程序") 显示了 PE Tools 提供的主要界面，该界面显示活动进程列表并提供对所有 PE Tools 实用程序的访问。
- en: '![The PE Tools utility](httpatomoreillycomsourcenostarchimages854065.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![PE 工具实用程序](httpatomoreillycomsourcenostarchimages854065.png)'
- en: Figure 2-1. The PE Tools utility
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1. PE 工具实用程序
- en: From the process list, users can dump a process’s memory image to a file or
    utilize the PE Sniffer utility to determine what compiler was used to build the
    executable or whether the executable was processed by any known obfuscation utilities.
    The Tools menu offers similar options for analysis of disk files. Users can view
    a file’s PE header fields by using the embedded PE Editor utility, which also
    allows for easy modification of any header values. Modification of PE headers
    is often required when attempting to reconstruct a valid PE from an obfuscated
    version of that file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从进程列表中，用户可以将进程的内存映像导出到文件，或者使用 PE 嗅探器实用程序来确定用于构建可执行文件的编译器，或者可执行文件是否被任何已知的混淆工具处理。工具菜单提供了类似的分析磁盘文件选项。用户可以使用嵌入的
    PE 编辑器实用程序查看文件的 PE 标头字段，该实用程序还允许轻松修改任何标头值。在尝试从该文件的混淆版本中重建有效的 PE 时，通常需要修改 PE 标头。
- en: BINARY FILE OBFUSCATION
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件混淆
- en: '*Obfuscation* is any attempt to obscure the true meaning of something. When
    applied to executable files, obfuscation is any attempt to hide the true behavior
    of a program. Programmers may employ obfuscation for a number of reasons. Commonly
    cited examples include protecting proprietary algorithms and obscuring malicious
    intent. Nearly all forms of malware utilize obfuscation in an effort to hinder
    analysis. Tools are widely available to assist program authors in generating obfuscated
    programs. Obfuscation tools and techniques and their associated impact on the
    reverse engineering process will be discussed further in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis").'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*混淆*是指任何试图掩盖某事物真正含义的尝试。当应用于可执行文件时，混淆是指任何试图隐藏程序真实行为的尝试。程序员可能出于多种原因采用混淆。常见的例子包括保护专有算法和掩盖恶意意图。几乎所有形式的恶意软件都利用混淆来阻碍分析。有许多工具可供程序作者使用，以生成混淆程序。混淆工具和技术及其对逆向工程过程的影响将在[第21章](ch21.html
    "第21章。混淆代码分析")中进一步讨论。'
- en: PEiD
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEiD
- en: PEiD^([[8](#ftn.CHP-2-FN-5)]) is another Windows tool whose primary purposes
    are to identify the compiler used to build a particular Windows PE binary and
    to identify any tools used to obfuscate a Windows PE binary. [Figure 2-2](ch02.html#the_peid_utility
    "Figure 2-2. The PEiD utility") shows the use of PEiD to identify the tool (ASPack
    in this case) used to obfuscate a variant of the Gaobot^([[9](#ftn.CHP-2-FN-6)])
    worm.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PEiD^([[8](#ftn.CHP-2-FN-5)]) 是另一个Windows工具，其主要目的是识别用于构建特定Windows PE二进制的编译器以及识别用于混淆Windows
    PE二进制的任何工具。[图2-2](ch02.html#the_peid_utility "图2-2。PEiD工具")显示了使用PEiD识别用于混淆Gaobot^([[9](#ftn.CHP-2-FN-6)])蠕虫变体的工具（在本例中为ASPack）。
- en: '![The PEiD utility](httpatomoreillycomsourcenostarchimages854067.png.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![PEiD工具](httpatomoreillycomsourcenostarchimages854067.png.jpg)'
- en: Figure 2-2. The PEiD utility
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2. PEiD工具
- en: Many additional capabilities of PEiD overlap those of PE Tools, including the
    ability to summarize PE file headers, collect information on running processes,
    and perform basic disassembly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PEiD具有许多与PE Tools重叠的附加功能，包括总结PE文件头、收集有关运行进程的信息以及执行基本反汇编。
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-2-FN-1)]) See [http://www.cygwin.com/](http://www.cygwin.com/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-2-FN-1)]) 请参阅 [http://www.cygwin.com/](http://www.cygwin.com/)。
- en: ^([[5](#CHP-2-FN-2)]) See [http://www.mingw.org/](http://www.mingw.org/).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-2-FN-2)]) 请参阅 [http://www.mingw.org/](http://www.mingw.org/)。
- en: ^([[6](#CHP-2-FN-3)]) A *magic number* is a special tag value required by some
    file format specifications whose presence indicates conformance to such specifications.
    In some cases humorous reasons surround the selection of magic numbers. The `MZ`
    tag in MS-DOS executable file headers represents the initials of Mark Zbikowski,
    one of the original architects of MS-DOS, while the hex value `0xcafebabe`, the
    well-known magic number associated with Java *.class* files, was chosen because
    it is an easily remembered sequence of hex digits.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-2-FN-3)]) *魔数*是一些文件格式规范所要求的特殊标记值，其存在表示符合此类规范。在某些情况下，选择魔数的原因可能带有幽默感。在MS-DOS可执行文件头中的`MZ`标记代表Mark
    Zbikowski的缩写，他是MS-DOS的原始架构师之一，而与Java *.class* 文件关联的众所周知的魔数`0xcafebabe`被选择，因为它是一串易于记忆的十六进制数字。
- en: ^([[7](#CHP-2-FN-4)]) See [http://petools.org.ru/petools.shtml](http://petools.org.ru/petools.shtml).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-2-FN-4)]) 请参阅 [http://petools.org.ru/petools.shtml](http://petools.org.ru/petools.shtml)。
- en: ^([[8](#CHP-2-FN-5)]) See [http://peid.info/](http://peid.info/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-2-FN-5)]) 请参阅 [http://peid.info/](http://peid.info/)。
- en: ^([[9](#CHP-2-FN-6)]) See [http://securityresponse.symantec.com/security_response/writeup.jsp?docid=2003-112112-1102-99](http://securityresponse.symantec.com/security_response/writeup.jsp?docid=2003-112112-1102-99).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#CHP-2-FN-6)]) 请参阅 [http://securityresponse.symantec.com/security_response/writeup.jsp?docid=2003-112112-1102-99](http://securityresponse.symantec.com/security_response/writeup.jsp?docid=2003-112112-1102-99)。
- en: Summary Tools
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要工具
- en: Since our goal is to reverse engineer binary program files, we are going to
    need more sophisticated tools to extract detailed information following initial
    classification of a file. The tools discussed in this section, by necessity, are
    far more aware of the formats of the files that they process. In most cases, these
    tools understand a very specific file format, and the tools are utilized to parse
    input files to extract very specific information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是逆向工程二进制程序文件，我们需要更复杂的工具来提取文件初步分类后的详细信息。本节讨论的工具，由于必要性，对它们处理的文件格式有更深入的了解。在大多数情况下，这些工具理解一个非常具体的文件格式，并且这些工具被用来解析输入文件以提取非常具体的信息。
- en: nm
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nm
- en: When source files are compiled to object files, compilers must embed information
    regarding the location of any global (external) symbols so that the linker will
    be able to resolve references to those symbols when it combines object files to
    create an executable. Unless instructed to strip symbols from the final executable,
    the linker generally carries symbols from the object files over into the resulting
    executable. According to the man page, the purpose of the `nm` utility is to “list
    symbols from object files.”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当源文件被编译成对象文件时，编译器必须嵌入有关任何全局（外部）符号位置的信息，以便链接器在将对象文件组合成可执行文件时能够解析对这些符号的引用。除非指示从最终可执行文件中删除符号，否则链接器通常会将符号从对象文件中传递到生成的可执行文件中。根据
    man 页面，`nm` 工具的目的是“列出对象文件中的符号”。
- en: 'When `nm` is used to examine an intermediate object file (a *.o* file rather
    than an executable), the default output yields the names of any functions and
    global variables declared in the file. Sample output of the `nm` utility is shown
    below:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `nm` 检查一个中间对象文件（一个 *.o* 文件而不是可执行文件）时，默认输出会显示文件中声明的任何函数和全局变量的名称。以下是 `nm`
    工具的示例输出：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here we see that `nm` lists each symbol along with some information about the
    symbol. The letter codes are used to indicate the type of symbol being listed.
    In this example, we see the following letter codes, which we will now explain:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `nm` 列出了每个符号以及一些关于符号的信息。字母代码用于指示所列符号的类型。在这个例子中，我们可以看到以下字母代码，我们将现在解释它们：
- en: '| **`U`** | An undefined symbol, usually an external symbol reference. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **`U`** | 一个未定义的符号，通常是一个外部符号引用。|'
- en: '| **`T`** | A symbol defined in the text section, usually a function name.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **`T`** | 定义在文本节中的符号，通常是一个函数名。|'
- en: '| **`t`** | A local symbol defined in the text section. In a C program, this
    usually equates to a static function. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **`t`** | 定义在文本节中的局部符号。在一个 C 程序中，这通常等同于一个静态函数。|'
- en: '| **`D`** | An initialized data value. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **`D`** | 一个初始化的数据值。|'
- en: '| **`C`** | An uninitialized data value. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **`C`** | 一个未初始化的数据值。|'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Uppercase letter codes are used for global symbols, whereas lowercase letter
    codes are used for local symbols. A full explanation of the letter codes can be
    found in the man page for `nm`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 用来表示全局符号的大写字母代码，而用来表示局部符号的小写字母代码。关于字母代码的完整解释可以在 `nm` 的 man 页面中找到。
- en: 'Somewhat more information is displayed when `nm` is used to display symbols
    from an executable file. During the link process, symbols are resolved to virtual
    addresses (when possible), which results in more information being available when
    `nm` is run. Truncated example output from `nm` used on an executable is shown
    here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `nm` 来显示可执行文件中的符号时，会显示更多一些的信息。在链接过程中，符号被解析为虚拟地址（如果可能的话），这使得当运行 `nm` 时可以获得更多信息。以下是使用
    `nm` 在可执行文件上截取的示例输出：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point, some of the symbols (`main`, for example) have been assigned
    virtual addresses, new ones (`frame_dummy`) have been introduced as a result of
    the linking process, some (`my_unitialized_global`) have had their symbol type
    changed, and others remain undefined as they continue to reference external symbols.
    In this case, the binary we are examining is dynamically linked, and the undefined
    symbols are defined in the shared C library. More information regarding `nm` can
    be found in its associated man page.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，一些符号（例如 `main`）已经被分配了虚拟地址，一些新的符号（例如 `frame_dummy`）由于链接过程而被引入，一些（例如 `my_unitialized_global`）已经改变了它们的符号类型，还有一些由于继续引用外部符号而仍然是未定义的。在这种情况下，我们正在检查的二进制文件是动态链接的，未定义的符号在共享
    C 库中定义。有关 `nm` 的更多信息，可以在其关联的 man 页面中找到。
- en: ldd
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldd
- en: 'When an executable is created, the location of any library functions referenced
    by that executable must be resolved. The linker has two methods for resolving
    calls to library functions: *static linking* and *dynamic linking*. Command-line
    arguments provided to the linker determine which of the two methods is used. An
    executable may be statically linked, dynamically linked, or both.^([[10](#ftn.CHP-2-FN-7)])'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个可执行文件时，必须解析该可执行文件引用的任何库函数的位置。链接器有两种解析库函数调用的方法：*静态链接*和*动态链接*。提供给链接器的命令行参数决定了使用哪种方法。一个可执行文件可以是静态链接的、动态链接的，或者两者都是。[^10](#ftn.CHP-2-FN-7)]
- en: When static linking is requested, the linker combines an application’s object
    files with a copy of the required library to create an executable file. At runtime,
    there is no need to locate the library code because it is already contained within
    the executable. Advantages of static linking are that (1) it results in slightly
    faster function calls and (2) distribution of binaries is easier because no assumptions
    need be made regarding the availability of library code on users’ systems. Disadvantages
    of static linking include (1) larger resulting executables and (2) greater difficulty
    upgrading programs when library components change. Programs are more difficult
    to update because they must be relinked every time a library is changed. From
    a reverse engineering perspective, static linking complicates matters somewhat.
    If we are faced with the task of analyzing a statically linked binary, there is
    no easy way to answer the questions “Which libraries are linked into this binary?”
    and “Which of these functions is a library function?” [Chapter 12](ch12.html "Chapter 12. Library
    Recognition Using FLIRT Signatures") will discuss the challenges encountered while
    reverse engineering statically linked code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求静态链接时，链接器将应用程序的对象文件与所需库的副本组合在一起以创建可执行文件。在运行时，无需定位库代码，因为它已经包含在可执行文件中。静态链接的优点是（1）它导致函数调用略微更快，以及（2）二进制文件的分发更容易，因为无需对用户系统上库代码的可用性做出假设。静态链接的缺点包括（1）生成的可执行文件更大，以及（2）当库组件发生变化时，升级程序更加困难。由于每次库发生变化时都必须重新链接，因此程序更新更加困难。从逆向工程的角度来看，静态链接使问题变得复杂。如果我们面临分析静态链接二进制文件的任务，就没有简单的方法来回答“哪些库被链接到这个二进制文件中？”和“这些函数中哪个是库函数？”等问题。[第12章](ch12.html
    "第12章。使用FLIRT签名识别库")将讨论在逆向工程静态链接代码时遇到的挑战。
- en: Dynamic linking differs from static linking in that the linker has no need to
    make a copy of any required libraries. Instead, the linker simply inserts references
    to any required libraries (often *.so* or *.dll* files) into the final executable,
    usually resulting in much smaller executable files. Upgrading library code is
    much easier when dynamic linking is utilized. Since a single copy of a library
    is maintained and that copy is referenced by many binaries, replacing the single
    outdated library with a new version instantly updates every binary that makes
    use of that library. One of the disadvantages of using dynamic linking is that
    it requires a more complicated loading process. All of the necessary libraries
    must be located and loaded into memory, as opposed to loading one statically linked
    file that happens to contain all of the library code. Another disadvantage of
    dynamic linking is that vendors must distribute not only their own executable
    file but also all library files upon which that executable depends. Attempting
    to execute a program on a system that does not contain all the required library
    files will result in an error.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接与静态链接的不同之处在于，链接器无需复制任何所需的库。相反，链接器只需将任何所需库的引用（通常是*.so*或*.dll*文件）插入到最终的执行文件中，通常导致可执行文件更小。当使用动态链接时，升级库代码要容易得多。由于维护单个库副本，并且许多二进制文件引用该副本，因此用新版本替换单个过时的库可以立即更新所有使用该库的二进制文件。使用动态链接的一个缺点是它需要一个更复杂的加载过程。所有必要的库都必须定位并加载到内存中，而不是加载一个包含所有库代码的静态链接文件。动态链接的另一个缺点是，供应商必须分发自己的可执行文件以及该可执行文件所依赖的所有库文件。在系统不包含所有必需的库文件的情况下尝试执行程序将导致错误。
- en: 'The following output demonstrates the creation of dynamically and statically
    linked versions of a program, the size of the resulting binaries, and the manner
    in which `file` identifies those binaries:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出演示了创建程序动态和静态链接版本的过程，生成的二进制文件的大小，以及`file`如何识别这些二进制文件：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order for dynamic linking to function properly, dynamically linked binaries
    must indicate which libraries they depend on along with the specific resources
    that are required from each of those libraries. As a result, unlike statically
    linked binaries, it is quite simple to determine the libraries on which a dynamically
    linked binary depends. The `ldd` (*list dynamic dependencies*) utility is a simple
    tool used to list the dynamic libraries required by any executable. In the following
    example, `ldd` is used to determine the libraries on which the Apache web server
    depends:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使动态链接正常工作，动态链接的二进制文件必须指明它们依赖的库以及从每个库中需要的特定资源。因此，与静态链接的二进制文件不同，确定动态链接二进制文件依赖的库相当简单。`ldd`
    (*列出动态依赖*) 实用程序是一个简单的工具，用于列出任何可执行文件所需的动态库。在以下示例中，使用 `ldd` 确定Apache网络服务器依赖的库：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ldd` utility is available on Linux and BSD systems. On OS X systems, similar
    functionality is available using the `otool` utility with the `–L` option: `otool
    -L` *`filename`*. On Windows systems, the `dumpbin` utility, part of the Visual
    Studio tool suite, can be used to list dependent libraries: `dumpbin /dependents`
    *`filename`*.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldd` 实用程序在 Linux 和 BSD 系统上可用。在 OS X 系统上，可以使用带有 `–L` 选项的 `otool` 实用程序实现类似的功能：`otool
    -L` *`filename`*。在 Windows 系统上，可以使用 Visual Studio 工具套件中的 `dumpbin` 实用程序列出依赖库：`dumpbin
    /dependents` *`filename`*。'
- en: objdump
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: objdump
- en: 'Whereas `ldd` is fairly specialized, `objdump` is extremely versatile. The
    purpose of `objdump` is to “display information from object files.”^([[11](#ftn.CHP-2-FN-8)])
    This is a fairly broad goal, and in order to accomplish it, `objdump` responds
    to a large number (30+) of command-line options tailored to extract various pieces
    of information from object files. `objdump` can be used to display the following
    data (and much more) related to object files:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ldd` 相对专业，但 `objdump` 非常灵活。`objdump` 的目的是“显示对象文件中的信息。”^([[11](#ftn.CHP-2-FN-8)])
    这是一个相当广泛的目标，为了实现它，`objdump` 响应大量（30+）的命令行选项，这些选项针对从对象文件中提取各种信息。`objdump` 可以用来显示与对象文件相关的以下数据（等等）：
- en: '**Section headers**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**段头信息**'
- en: Summary information for each of the sections in the program file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 程序文件中每个段的摘要信息。
- en: '**Private headers**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有头信息**'
- en: Program memory layout information and other information required by the runtime
    loader, including a list of required libraries such as that produced by `ldd`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 程序内存布局信息以及其他由运行时加载器所需的信息，包括由 `ldd` 产生的所需库列表。
- en: '**Debugging information**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试信息**'
- en: Extracts any debugging information embedded in the program file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序文件中提取任何嵌入的调试信息。
- en: '**Symbol information**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号信息**'
- en: Dumps symbol table information in a manner similar to the `nm` utility.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似于 `nm` 实用程序的方式转储符号表信息。
- en: '**Disassembly listing**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**反汇编列表**'
- en: '`objdump` performs a linear sweep disassembly of sections of the file marked
    as code. When disassembling x86 code, `objdump` can generate either AT&T or Intel
    syntax, and the disassembly can be captured as a text file. Such a text file is
    called a disassembly *dead listing*, and while these files can certainly be used
    for reverse engineering, they are difficult to navigate effectively and even more
    difficult to modify in a consistent and error-free manner.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`objdump` 对标记为代码的文件部分执行线性扫描反汇编。当反汇编 x86 代码时，`objdump` 可以生成 AT&T 或 Intel 语法，并将反汇编内容捕获为文本文件。这样的文本文件称为反汇编
    *死列表*，虽然这些文件当然可以用于逆向工程，但它们难以有效地导航，甚至更难以以一致且无错误的方式修改。'
- en: '`objdump` is available as part of the GNU binutils^([[12](#ftn.CHP-2-FN-9)])
    tool suite and can be found on Linux, FreeBSD, and Windows (via Cygwin). `objdump`
    relies on the Binary File Descriptor library (libbfd), a component of binutils,
    to access object files and thus is capable of parsing file formats supported by
    libbfd (ELF and PE among others). For ELF-specific parsing, a utility named `readelf`
    is also available. `readelf` offers most of the same capabilities as `objdump`,
    and the primary difference between the two is that `readelf` does not rely upon
    libbfd.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`objdump` 是 GNU binutils^([[12](#ftn.CHP-2-FN-9)]) 工具套件的一部分，可在 Linux、FreeBSD
    和 Windows（通过 Cygwin）上找到。`objdump` 依赖于二进制文件描述符库（libbfd），这是 binutils 的一个组件，用于访问对象文件，因此能够解析由
    libbfd 支持的文件格式（ELF 和 PE 等等）。对于 ELF 特定的解析，还有一个名为 `readelf` 的实用程序可用。`readelf` 提供了与
    `objdump` 大多数相同的功能，两者之间的主要区别在于 `readelf` 不依赖于 libbfd。'
- en: otool
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: otool
- en: '`otool` is most easily described as an `objdump`-like utility for OS X, and
    it is useful for parsing information about OS X Mach-O binaries. The following
    listing demonstrates how `otool` displays the dynamic library dependencies for
    a Mach-O binary, thus performing a function similar to `ldd`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`otool` 最容易描述为类似于 `objdump` 的实用工具，用于解析关于OS X Mach-O二进制文件的信息。以下列表展示了 `otool`
    如何显示Mach-O二进制文件的动态库依赖关系，从而执行类似于 `ldd` 的功能。'
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`otool` can be used to display information related to a file’s headers and
    symbol tables and to perform disassembly of the file’s code section. For more
    information regarding the capabilities of `otool`, please refer to the associated
    man page.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`otool` 可以用来显示与文件头和符号表相关的信息，以及执行文件代码段的反汇编。有关 `otool` 功能的更多信息，请参阅相关的手册页面。'
- en: dumpbin
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dumpbin
- en: '`dumpbin` is a command-line utility included with Microsoft’s Visual Studio
    suite of tools. Like `otool` and `objdump`, `dumpbin` is capable of displaying
    a wide range of information related to Windows PE files. The following listing
    shows how `dumpbin` displays the dynamic dependencies of the Windows calculator
    program in a manner similar to `ldd`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumpbin` 是微软Visual Studio工具套件中包含的命令行实用工具。像 `otool` 和 `objdump` 一样，`dumpbin`
    能够显示与Windows PE文件相关的广泛信息。以下列表展示了 `dumpbin` 如何以类似于 `ldd` 的方式显示Windows计算器程序的动态依赖关系。'
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Additional `dumpbin` options offer the ability to extract information from various
    sections of a PE binary, including symbols, imported function names, exported
    function names, and disassembled code. Additional information related to the use
    of `dumpbin` is available via the Microsoft Developer Network (MSDN).^([[13](#ftn.CHP-2-FN-10)])
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumpbin` 的附加选项提供了从PE二进制文件的不同部分提取信息的能力，包括符号、导入函数名称、导出函数名称和反汇编代码。有关 `dumpbin`
    的更多信息，请参阅微软开发者网络（MSDN）。^([[13](#ftn.CHP-2-FN-10)])'
- en: c++filt
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: c++filt
- en: 'Languages that allow function overloading must have a mechanism for distinguishing
    among the many overloaded versions of a function since each version has the same
    name. The following C++ example shows the prototypes for several overloaded versions
    of a function named `demo`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 允许函数重载的语言必须有一种机制来区分函数的许多重载版本，因为每个版本都有相同的名称。以下C++示例显示了名为 `demo` 的几个重载版本的函数原型：
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As a general rule, it is not possible to have two functions with the same name
    in an object file. In order to allow overloading, compilers derive unique names
    for overloaded functions by incorporating information describing the type sequence
    of the function arguments. The process of deriving unique names for functions
    with identical names is called *name mangling*.^([[14](#ftn.CHP-2-FN-11)]) If
    we use `nm` to dump the symbols from the compiled version of the preceding C++
    code, we might see something like the following (filtered to focus on versions
    of `demo`):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在目标文件中不允许存在两个同名函数。为了允许函数重载，编译器通过结合描述函数参数类型序列的信息来为重载函数生成唯一的名称。为具有相同名称的函数生成唯一名称的过程称为*名称混淆*。^([[14](#ftn.CHP-2-FN-11)])
    如果我们使用 `nm` 从前面C++代码的编译版本中导出符号，我们可能会看到如下内容（过滤以关注 `demo` 的版本）：
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The C++ standard does not define standards for name-mangling schemes, leaving
    compiler designers to develop their own. In order to decipher the mangled variants
    of `demo` shown here, we need a tool that understands our compiler’s (g++ in this
    case) name-mangling scheme. This is precisely the purpose of the `c++filt` utility.
    `c++filt` treats each input word as if it were a mangled name and then attempts
    to determine the compiler that was used to generate that name. If the name appears
    to be a valid mangled name, it outputs the demangled version of the name. When
    `c++filt` does not recognize a word as a mangled name, it simply outputs the word
    with no changes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准没有定义名称混淆方案的标准，这留给编译器设计者开发自己的方案。为了解读这里显示的 `demo` 的混淆版本，我们需要一个理解我们编译器（在这种情况下是
    g++）名称混淆方案的工具。这正是 `c++filt` 工具的目的。`c++filt` 将每个输入词视为混淆名称，然后尝试确定生成该名称的编译器。如果名称看起来是一个有效的混淆名称，它将输出名称的解混淆版本。当
    `c++filt` 识别不出一个词为混淆名称时，它将简单地输出该词而不做任何更改。
- en: 'If we pass the results of `nm` from the preceding example through `c++filt`,
    it is possible to recover the demangled function names, as seen here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面示例中的 `nm` 结果通过 `c++filt` 传递，就有可能恢复解混淆的函数名称，如下所示：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is important to note that mangled names contain additional information about
    functions that `nm` does not normally provide. This information can be extremely
    helpful in reversing engineering situations, and in more complex cases, this extra
    information may include data regarding class names or function-calling conventions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，混淆名称包含关于函数的额外信息，这些信息是 `nm` 通常不提供的。这种信息在逆向工程情况下可能非常有用，在更复杂的情况下，这些额外信息可能包括有关类名或函数调用约定的数据。
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[10](#CHP-2-FN-7)]) For more information on linking, consult John R. Levine,
    *Linkers and Loaders* (San Francisco: Morgan Kaufmann, 2000).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#CHP-2-FN-7)]) 关于链接的更多信息，请咨询 John R. Levine 的著作 *链接器和加载器*（旧金山：Morgan
    Kaufmann，2000年）。
- en: ^([[11](#CHP-2-FN-8)]) See [http://www.sourceware.org/binutils/docs/binutils/objdump.html#objdump/](http://www.sourceware.org/binutils/docs/binutils/objdump.html#objdump/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#CHP-2-FN-8)]) 请参阅 [http://www.sourceware.org/binutils/docs/binutils/objdump.html#objdump/](http://www.sourceware.org/binutils/docs/binutils/objdump.html#objdump/)。
- en: ^([[12](#CHP-2-FN-9)]) See [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#CHP-2-FN-9)]) 请参阅 [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/)。
- en: ^([[13](#CHP-2-FN-10)]) See [http://msdn.microsoft.com/en-us/library/c1h23y6c(VS.71).aspx](http://msdn.microsoft.com/en-us/library/c1h23y6c(VS.71).aspx).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#CHP-2-FN-10)]) 请参阅 [http://msdn.microsoft.com/en-us/library/c1h23y6c(VS.71).aspx](http://msdn.microsoft.com/en-us/library/c1h23y6c(VS.71).aspx)。
- en: ^([[14](#CHP-2-FN-11)]) For an overview of name mangling, refer to [http://en.wikipedia.org/wiki/Name_mangling](http://en.wikipedia.org/wiki/Name_mangling).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#CHP-2-FN-11)]) 关于名称混淆的概述，请参阅 [http://en.wikipedia.org/wiki/Name_mangling](http://en.wikipedia.org/wiki/Name_mangling)。
- en: Deep Inspection Tools
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度检查工具
- en: So far, we have discussed tools that perform a cursory analysis of files based
    on minimal knowledge of those files’ internal structure. We have also seen tools
    capable of extracting specific pieces of data from files based on very detailed
    knowledge of a file’s structure. In this section we discuss tools designed to
    extract specific types of information independently of the type of file being
    analyzed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了基于对文件内部结构最少了解进行文件粗略分析的工具。我们也看到了能够根据对文件结构的非常详细的知识从文件中提取特定数据点的工具。在本节中，我们将讨论旨在独立于被分析文件类型提取特定类型信息的工具。
- en: strings
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: strings
- en: It is occasionally useful to ask more generic questions regarding file content,
    questions that don’t necessarily require any specific knowledge of a file’s structure.
    One such question is “Does this file contain any embedded strings?” Of course,
    we must first answer the question “What exactly constitutes a string?” Let’s loosely
    define a *string* as a consecutive sequence of printable characters. This definition
    is often augmented to specify a minimum length and a specific character set. Thus,
    we could specify a search for all sequences of at least four consecutive ASCII
    printable characters and print the results to the console. Searches for such strings
    are generally not limited in any way by the structure of a file. You can search
    for strings in an ELF binary just as easily as you can search for strings in a
    Microsoft Word document.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时询问有关文件内容的一般性问题是有用的，这些问题不一定需要任何特定于文件结构的知识。这样一个问题就是：“这个文件是否包含任何嵌入的字符串？”当然，我们首先必须回答“究竟什么构成了一个字符串？”让我们松散地定义一个
    *字符串* 为可打印字符的连续序列。这个定义通常会被扩展以指定最小长度和特定的字符集。因此，我们可以指定搜索所有至少由四个连续ASCII可打印字符组成的序列，并将结果打印到控制台。对这种字符串的搜索通常不会受到文件结构的任何限制。你可以在ELF二进制文件中搜索字符串，就像你可以在Microsoft
    Word文档中搜索字符串一样。
- en: 'The `strings` utility is designed specifically to extract string content from
    files, often without regard for the format of those files. Using `strings` with
    its default settings (7-bit ASCII sequences of at least four characters) might
    yield something like the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings` 工具专门设计用于从文件中提取字符串内容，通常不考虑这些文件的格式。使用 `strings` 的默认设置（至少四个字符的7位ASCII序列）可能会得到如下结果：'
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unfortunately, while we see some strings that look like they might be output
    by the program, other strings appear to be function names and library names. We
    should be careful not to jump to any conclusions regarding the behavior of the
    program. Analysts often fall into the trap of attempting to deduce the behavior
    of a program based on the output of `strings`. Remember, the presence of a string
    within a binary in no way indicates that the string is ever used in any manner
    by that binary.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，虽然我们看到了一些看起来可能是程序输出的字符串，但其他字符串似乎是函数名和库名。我们应该小心不要对程序的行为得出任何结论。分析师常常陷入根据
    `strings` 输出推断程序行为的陷阱。记住，二进制文件中字符串的存在并不能表明该字符串以任何方式被该二进制文件使用。
- en: 'Some final notes on the use of `strings`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `strings` 的使用的一些注意事项：
- en: When using `strings` on executable files, it is important to remember that,
    by default, only the loadable, initialized sections of the file will be scanned.
    Use the `-a` command-line argument to force `strings` to scan the entire input
    file.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在可执行文件上使用 `strings` 时，重要的是要记住，默认情况下，只有文件的可加载、初始化部分会被扫描。使用 `-a` 命令行参数可以强制 `strings`
    扫描整个输入文件。
- en: '`strings` gives no indication of where, within a file, a string is located.
    Use the `-t` command-line argument to have `strings` print file offset information
    for each string found.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings` 命令无法提供字符串在文件中的具体位置信息。使用 `-t` 命令行参数可以让 `strings` 打印出每个找到的字符串的文件偏移量信息。'
- en: Many files utilize alternate character sets. Utilize the `-e` command-line argument
    to cause `strings` to search for wide characters such as 16-bit Unicode.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多文件使用替代字符集。使用 `-e` 命令行参数可以让 `strings` 搜索宽字符，如 16 位 Unicode。
- en: Disassemblers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反汇编器
- en: As mentioned earlier, a number of tools are available to generate dead listing–style
    disassemblies of binary object files. PE, ELF, and Mach-O binaries can be disassembled
    using `dumpbin`, `objdump`, and `otool`, respectively. None of those, however,
    can deal with arbitrary blocks of binary data. You will occasionally be confronted
    with a binary file that does not conform to a widely used file format, in which
    case you will need tools capable of beginning the disassembly process at user-specified
    offsets.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有几种工具可以生成类似 dead listing 风格的二进制对象文件反汇编。PE、ELF 和 Mach-O 二进制文件分别可以使用 `dumpbin`、`objdump`
    和 `otool` 进行反汇编。然而，这些工具都无法处理任意块的二进制数据。你偶尔会遇到不符合广泛使用文件格式的二进制文件，在这种情况下，你需要能够从用户指定的偏移量开始反汇编过程的工具。
- en: Two examples of such *stream disassemblers* for the x86 instruction set are
    `ndisasm` and `diStorm`.^([[15](#ftn.CHP-2-FN-12)]) `ndisasm` is a utility included
    with the Netwide Assembler (NASM).^([[16](#ftn.CHP-2-FN-13)]) The following example
    illustrates the use of `ndisasm` to disassemble a piece of shellcode generated
    using the Metasploit framework.^([[17](#ftn.CHP-2-FN-14)])
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对此类 *流反汇编器* 的 x86 指令集的两个示例：`ndisasm` 和 `diStorm`。^([[15](#ftn.CHP-2-FN-12)])
    `ndisasm` 是 Netwide Assembler (NASM) 包含的一个实用工具。^([[16](#ftn.CHP-2-FN-13)]) 以下示例说明了如何使用
    `ndisasm` 反汇编由 Metasploit 框架生成的 shellcode。^([[17](#ftn.CHP-2-FN-14)])
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The flexibility of stream disassembly is useful in many situations. One scenario
    involves the analysis of computer network attacks in which network packets may
    contain shellcode. Stream disassemblers can be used to disassemble the portions
    of the packet that contain shellcode in order to analyze the behavior of the malicious
    payload. Another situation involves the analysis of ROM images for which no layout
    reference can be located. Portions of the ROM will contain data, while other portions
    will contain code. Stream disassemblers can be used to disassemble just those
    portions of the image thought to be code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 流反汇编的灵活性在许多情况下都很有用。一种场景涉及分析计算机网络攻击，其中网络数据包可能包含 shellcode。流反汇编器可以用来反汇编包含 shellcode
    的数据包部分，以便分析恶意负载的行为。另一种情况涉及分析无法找到布局参考的 ROM 图像。ROM 的某些部分将包含数据，而其他部分将包含代码。流反汇编器可以用来反汇编被认为可能是代码的那些图像部分。
- en: '* * *'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[15](#CHP-2-FN-12)]) See [http://www.ragestorm.net/distorm/](http://www.ragestorm.net/distorm/).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#CHP-2-FN-12)]) 请参阅 [http://www.ragestorm.net/distorm/](http://www.ragestorm.net/distorm/)。
- en: ^([[16](#CHP-2-FN-13)]) See [http://nasm.sourceforge.net/](http://nasm.sourceforge.net/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#CHP-2-FN-13)]) 请参阅 [http://nasm.sourceforge.net/](http://nasm.sourceforge.net/)。
- en: ^([[17](#CHP-2-FN-14)]) See [http://www.metasploit.com/](http://www.metasploit.com/).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#CHP-2-FN-14)]) 请参阅 [http://www.metasploit.com/](http://www.metasploit.com/)。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The tools discussed in this chapter are not necessarily the best of their breed.
    They do, however, represent tools commonly available for anyone who wishes to
    reverse engineer binary files. More important, they represent the types of tools
    that motivated much of the development of IDA. In the coming chapters, we will
    discuss such tools. An awareness of these tools will greatly enhance your understanding
    of the IDA user interface and the many informational displays that IDA offers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的工具并不一定是同类中的最佳选择。然而，它们确实代表了那些希望逆向工程二进制文件的人通常可以获得的工具。更重要的是，它们代表了激发IDA大部分开发工作的工具类型。在接下来的章节中，我们将讨论这些工具。对这些工具的了解将大大增强你对IDA用户界面以及IDA提供的众多信息显示的理解。
- en: Chapter 3. IDA Pro Background
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。IDA Pro背景
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: The Interactive Disassembler Professional, better and heretofore known as *IDA
    Pro* or simply *IDA* is a product of Hex-Rays,^([[18](#ftn.CHP-3-FN-1)]) located
    in Liège, Belgium. The programming genius behind IDA is Ilfak Guilfanov, better
    known as simply *Ilfak*. IDA began its life over a decade ago as an MS-DOS, console-based
    application, which is significant in that it helps us understand something about
    the nature of IDA’s user interface. Among other things, non-GUI versions of IDA
    ship for all IDA-supported platforms^([[19](#ftn.CHP-3-FN-2)]) and continue to
    use the console-style interface derived from the original DOS versions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式反汇编器专业版，更广为人知的是*IDA Pro*或简称*IDA*，是位于比利时列日市的Hex-Rays公司的一个产品。IDA背后的编程天才伊尔法克·古尔法诺夫，更广为人知的是*伊尔法克*。IDA的生命始于十多年前，作为一个基于MS-DOS的控制台应用程序，这在很大程度上有助于我们了解IDA用户界面的本质。在众多方面，IDA的非GUI版本适用于所有IDA支持的平台^([[19](#ftn.CHP-3-FN-2)])，并且继续使用从原始DOS版本派生出的控制台风格界面。
- en: At its heart, IDA is a recursive descent disassembler; however, a substantial
    amount of effort has gone into developing logic to augment the recursive-descent
    process. In order to overcome one of the larger shortcomings of recursive descent,
    IDA employs a large number of heuristic techniques to identify additional code
    that may not have been found during the recursive-descent process. Beyond the
    disassembly process itself, IDA goes to great lengths not only to distinguish
    data disassemblies from code disassemblies but also to determine exactly what
    type of data is being represented by those data disassemblies. While the code
    that you view in IDA is in assembly language, one of the fundamental goals of
    IDA is to paint a picture as close to source code as possible. IDA makes every
    effort to annotate generated disassemblies with not only datatype information
    but also derived variable and function names. These annotations minimize the amount
    of raw hex and maximize the amount of symbolic information presented to the user.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，IDA是一个递归下降反汇编器；然而，大量的努力已经投入到开发逻辑中，以增强递归下降过程。为了克服递归下降的一个较大缺陷，IDA采用大量启发式技术来识别在递归下降过程中可能未被发现的其他代码。在反汇编过程本身之外，IDA还竭尽全力不仅区分数据反汇编和代码反汇编，而且确定那些数据反汇编所代表的确切数据类型。虽然你在IDA中看到的代码是汇编语言，但IDA的一个基本目标就是尽可能接近源代码地描绘一幅图景。IDA竭尽全力对生成的反汇编进行注释，不仅包括数据类型信息，还包括派生变量和函数名称。这些注释最大限度地减少了原始十六进制代码的数量，并最大化了向用户展示的符号信息量。
- en: Hex-Rays’ Stance on Piracy
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hex-Rays对盗版的立场
- en: As an IDA user you should be aware of several facts. IDA is Hex-Rays’ flagship
    product; accordingly, it is very sensitive about unauthorized distribution of
    IDA. In the past, the company has seen a direct cause and effect relationship
    between releases of pirated versions of IDA and declining sales. The former publisher
    of IDA, DataRescue, has even gone so far as to post the names of pirates to its
    Hall of Shame.^([[20](#ftn.CHP-3-FN-3)]) IDA thus utilizes several antipiracy
    techniques in an effort to curb piracy and enforce licensing restrictions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为IDA用户，你应该意识到几个事实。IDA是Hex-Rays的旗舰产品；因此，它非常关注IDA的未经授权的分发。在过去，公司已经看到了IDA盗版版本发布和销售下降之间的直接因果关系。IDA的前出版商DataRescue甚至将海盗的名字贴在了其耻辱柱上^([[20](#ftn.CHP-3-FN-3)])。因此，IDA利用几种反盗版技术来遏制盗版并执行许可限制。
- en: 'The first technique to be aware of: Each copy of IDA is watermarked in order
    to uniquely tie it to its purchaser. If a copy of IDA turns up on a warez site,
    Hex-Rays has the ability to track that copy back to the original buyer, who will
    then be blacklisted from future sales. It is not uncommon to find discussions
    related to “leaked” copies of IDA on the IDA support forums at Hex-Rays.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第一种技术：每个IDA副本都会被水印，以便将其唯一地与其购买者联系起来。如果IDA的副本出现在warez网站上，Hex-Rays有追踪该副本回到原始购买者的能力，然后该购买者将被列入未来销售的
    blacklist。在Hex-Rays的IDA支持论坛上找到与“泄露”的IDA副本相关的讨论并不罕见。
- en: Another technique IDA uses to enforce its licensing policies involves scanning
    for additional copies of IDA running on the local network. When the Windows version
    of IDA is launched, a UDP packet is broadcast on port 23945, and IDA waits for
    responses to see whether other instances of IDA running under the same license
    key are present on the same subnet. The number of responses is compared to the
    number of seats to which the license applies, and if too many copies are found
    on the network, IDA will refuse to start. Do note, however, that it is permissible
    to run multiple instances of IDA on a single computer with a single license.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: IDA使用的另一种技术来强制执行其许可政策涉及在本地网络中扫描运行IDA的额外副本。当启动IDA的Windows版本时，会在端口23945上广播一个UDP数据包，并且IDA等待响应以查看是否在同一子网上存在运行在相同许可证密钥下的IDA的其他实例。将响应的数量与许可证适用的座位数进行比较，如果网络中找到的副本太多，IDA将拒绝启动。但是请注意，使用单个许可证在单台计算机上运行多个IDA实例是允许的。
- en: The final method of license enforcement centers on the use of key files tied
    to each purchaser. At startup, IDA searches for a valid *ida.key* file. Failure
    to locate a valid key file will cause IDA to shut down immediately. Key files
    are also used in determining eligibility for upgraded copies of IDA. In essence,
    *ida.key* represents your purchase receipt, and you should safeguard it to ensure
    that you remain eligible for future upgrades.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证执行的最终方法集中在使用与每个购买者关联的密钥文件。启动时，IDA会搜索有效的*ida.key*文件。如果找不到有效的密钥文件，IDA将立即关闭。密钥文件还用于确定升级IDA副本的资格。本质上，*ida.key*代表您的购买收据，您应该妥善保管它以确保您有资格进行未来的升级。
- en: '* * *'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[18](#CHP-3-FN-1)]) For many years, IDA was marketed by DataRescue; however,
    in January 2008, Ilfak moved marketing and sales of IDA to his own company, Hex-Rays.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#CHP-3-FN-1)]) 多年来，IDA由DataRescue进行市场推广；然而，在2008年1月，Ilfak将IDA的市场营销和销售转移到了他自己的公司，Hex-Rays。
- en: ^([[19](#CHP-3-FN-2)]) Currently supported platforms are Windows, Linux, and
    OS X.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#CHP-3-FN-2)]) 当前支持的平台是Windows、Linux和OS X。
- en: '^([[20](#CHP-3-FN-3)]) The Hall of Shame has been migrated to the Hex-Rays
    website: [http://www.hex-rays.com/idapro/hallofshame.html](http://www.hex-rays.com/idapro/hallofshame.html).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#CHP-3-FN-3)]) 恶名昭彰的网站已迁移到Hex-Rays网站：[http://www.hex-rays.com/idapro/hallofshame.html](http://www.hex-rays.com/idapro/hallofshame.html)。
- en: Obtaining IDA Pro
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取IDA Pro
- en: First and foremost, IDA is not free software. The folks at Hex-Rays make their
    living in part through the sales of IDA. A limited-functionality, freeware^([[21](#ftn.CHP-3-FN-4)])
    version of IDA is available for people who wish to familiarize themselves with
    its basic capabilities, but it doesn’t keep pace with the most recent versions.
    The freeware version, discussed more extensively in [Appendix A](apa.html "Appendix A. Using
    IDA Freeware 5.0"), is a stripped-down edition of IDA 5.0 (the current version
    being 6.1). Along with the freeware version, Hex-Rays also distributes a restricted-functionality
    demonstration copy^([[22](#ftn.CHP-3-FN-5)]) of the current version. If the rave
    reviews that are found anywhere reverse engineering is discussed are not sufficient
    to convince you to purchase a copy, then spending some time with either the freeware
    or demo version will surely help you realize that IDA, and the customer support
    that comes along with it, is well worth owning.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要明确的是，IDA不是免费软件。Hex-Rays的人部分通过IDA的销售谋生。对于希望熟悉其基本功能的人来说，IDA有一个有限功能的免费软件版本，但它并不与最新版本保持同步。在[附录A](apa.html
    "附录A. 使用IDA免费软件5.0")中更详细地讨论了免费软件版本，它是IDA 5.0（当前版本为6.1）的简化版。除了免费软件版本外，Hex-Rays还分发当前版本的有限功能演示版。如果任何地方关于逆向工程讨论的狂热评论不足以说服您购买副本，那么花些时间使用免费软件或演示版本肯定有助于您认识到IDA及其附带客户支持是值得拥有的。
- en: IDA Versions
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA版本
- en: 'As of version 6.0, IDA is available in GUI and console versions for Windows,
    Linux, and OS X. IDA makes use of the Qt cross-platform GUI libraries to provide
    a consistent user interface on all three platforms. From a functionality standpoint,
    IDA Pro is offered in two versions: standard and advanced. The two versions differ
    primarily in the number of processor architectures for which they support disassembly.
    A quick look at the list of supported processors^([[23](#ftn.CHP-3-FN-6)]) shows
    that the standard version (approximately USD540 as of this writing) supports more
    than 30 processor families, while the advanced version (at almost twice the price)
    supports more than 50\. Additional architectures supported in the advanced version
    include x64, AMD64, MIPS, PPC, and SPARC, among others.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 自 6.0 版本起，IDA 在 Windows、Linux 和 OS X 上提供图形用户界面（GUI）和控制台版本。IDA 利用 Qt 跨平台 GUI
    库在所有三个平台上提供一致的用户界面。从功能角度来看，IDA Pro 提供两种版本：标准版和高级版。这两个版本的主要区别在于它们支持的处理器架构数量。快速查看支持的处理器列表^([[23](#ftn.CHP-3-FN-6)])
    可以看出，标准版（截至本文撰写时约为 540 美元）支持超过 30 个处理器系列，而高级版（价格几乎是标准版的两倍）支持超过 50 个。高级版还支持其他架构，包括
    x64、AMD64、MIPS、PPC 和 SPARC 等。
- en: IDA Licenses
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA 许可证
- en: Two licensing options are available when you purchase IDA. From the Hex-Rays
    website:^([[24](#ftn.CHP-3-FN-7)]) “Named licenses are linked to a specific end-user
    and may be used on as many computers as that particular end-user uses,” while
    “Computer licenses are linked to a specific computer and may be used by different
    end-users on that computer provided only one user is active at any time.” Note
    that while a single named license entitles you to install the software on as many
    computers as you like, you are the only person who may run those copies of IDA,
    and, for a single license, IDA may be running on only one of those computers at
    any given time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当您购买 IDA 时，有两种许可选项可用。从 Hex-Rays 网站上可以看到：^([[24](#ftn.CHP-3-FN-7))) “命名许可证与特定最终用户相关联，并且可以在该特定最终用户使用的任何多台计算机上使用，”而“计算机许可证与特定计算机相关联，并且只要任何时候只有一个用户活跃，就可以由不同的最终用户在该计算机上使用。”请注意，尽管单个命名许可证使您有权在您喜欢的任何多台计算机上安装软件，但您是唯一可以运行这些
    IDA 副本的人，并且对于单个许可证，IDA 在任何给定时间只能在一台计算机上运行。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike many other software licenses for proprietary software, IDA’s license
    specifically grants users the right to reverse engineer IDA.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多专有软件的软件许可不同，IDA 的许可特别授予用户逆向工程 IDA 的权利。
- en: Purchasing IDA
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购买 IDA
- en: Prior to version 6.0, IDA purchases included a Windows GUI version along with
    console versions for Windows, Linux, and OS X. Beginning with version 6.0, purchasers
    must specify exactly which operating system they wish to run their copy of IDA
    on. Each copy of IDA 6.*x* includes console and Qt-based GUI versions for the
    specified operating system only. Additional licenses for alternate operating systems
    are available for a reduced price. You can purchase IDA through authorized distributors
    listed on the IDA sales web page or directly from Hex-Rays by fax or email. Purchased
    copies can be delivered via CD or downloaded, and they entitle the buyer to a
    year of support and upgrades. In addition to the IDA installer, the CD distribution
    contains a variety of extras such as the IDA software development kit (SDK) and
    other utilities. Users who opt to download their purchased copy of IDA typically
    receive only the installer bundle and are required to download other components
    separately.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 6.0 版本之前，IDA 购买包括 Windows GUI 版本以及 Windows、Linux 和 OS X 的控制台版本。从 6.0 版本开始，购买者必须明确指定他们希望在哪个操作系统上运行
    IDA 的副本。每个 IDA 6.*x* 版本的副本仅包括指定操作系统的控制台和基于 Qt 的 GUI 版本。对于其他操作系统的额外许可证以较低的价格提供。您可以通过
    IDA 销售网页上列出的授权分销商或直接通过 Hex-Rays 通过传真或电子邮件购买 IDA。购买的副本可以通过 CD 发送或下载，并且使购买者有权获得一年的支持和升级。除了
    IDA 安装程序外，CD 分发还包含各种额外内容，如 IDA 软件开发工具包（SDK）和其他实用程序。选择下载其购买的 IDA 副本的用户通常只会收到安装程序包，并需要单独下载其他组件。
- en: Hex-Rays has been known to restrict sales to specific countries based on its
    experiences with piracy in those countries. It also maintains a blacklist of users
    who have violated the terms of licensing for IDA and may refuse to do business
    with such users and/or their employers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Hex-Rays 因其在某些国家的盗版经验而众所周知，会根据这些国家的经验限制对这些国家的销售。它还维护一个违反 IDA 许可协议的用户黑名单，并且可能拒绝与这些用户及其雇主进行交易。
- en: Upgrading IDA
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级 IDA
- en: The IDA Help menu contains an option to check for an available upgrade. Additionally,
    IDA will automatically issue warnings that your support period is about to expire
    based on the expiration date contained in your key file. The upgrade process typically
    involves submitting your *ida.key* file to Hex-Rays, which will then validate
    your key and provide you with details on how to obtain your upgraded version.
    Should you find that your version of IDA is too old to be eligible for an upgrade,
    be sure to take advantage of Hex-Rays’ reduced upgrade pricing for holders of
    expired keys.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 帮助菜单中包含一个检查可用升级的选项。此外，IDA 将根据您密钥文件中的到期日期自动发出警告，通知您的支持期即将到期。升级过程通常涉及将您的 *ida.key*
    文件提交给 Hex-Rays，然后 Hex-Rays 将验证您的密钥，并提供有关如何获取升级版本的详细信息。如果您发现您的 IDA 版本太旧，不符合升级资格，请务必利用
    Hex-Rays 为过期密钥持有者提供的降低升级价格。
- en: Warning
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Failure to maintain close control over your key file could result in an unauthorized
    user requesting your allotted upgrade, preventing you from upgrading your copy
    of IDA.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未能对您的密钥文件进行严格控制，可能会导致未经授权的用户请求您的升级，从而阻止您升级您的 IDA 版本。
- en: As a final note on upgrading any version of IDA, we highly recommend backing
    up your existing IDA installation or installing your upgrade to a completely different
    directory in order to avoid losing any configuration files that you may have modified.
    You will need to edit the corresponding files in your upgrade version to re-enable
    any changes that you have previously made. Similarly you will need to move, recompile,
    or otherwise obtain new versions of any custom IDA plug-ins that you may have
    been using (more about plug-ins and the plug-in installation process in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture")).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对升级任何版本 IDA 的最后一点说明，我们强烈建议您备份现有的 IDA 安装，或将升级安装到完全不同的目录，以避免丢失您可能已修改的任何配置文件。您将需要编辑升级版本中的相应文件，以重新启用您之前所做的任何更改。同样，您还需要移动、重新编译或以其他方式获取您可能正在使用的任何自定义
    IDA 插件的最新版本（有关插件和插件安装过程，请参阅第 17 章[“第 17 章. IDA 插件架构”](ch17.html "Chapter 17. The
    IDA Plug-in Architecture")）。
- en: '* * *'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[21](#CHP-3-FN-4)]) See [http://www.hex-rays.com/idapro/idadownfreeware.htm](http://www.hex-rays.com/idapro/idadownfreeware.htm).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[21](#CHP-3-FN-4)]) 请参阅 [http://www.hex-rays.com/idapro/idadownfreeware.htm](http://www.hex-rays.com/idapro/idadownfreeware.htm)。
- en: ^([[22](#CHP-3-FN-5)]) See [http://www.hex-rays.com/idapro/idadowndemo.htm](http://www.hex-rays.com/idapro/idadowndemo.htm).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[22](#CHP-3-FN-5)]) 请参阅 [http://www.hex-rays.com/idapro/idadowndemo.htm](http://www.hex-rays.com/idapro/idadowndemo.htm)。
- en: ^([[23](#CHP-3-FN-6)]) See [http://www.hex-rays.com/idapro/idaproc.htm](http://www.hex-rays.com/idapro/idaproc.htm).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-3-FN-6)]) 请参阅 [http://www.hex-rays.com/idapro/idaproc.htm](http://www.hex-rays.com/idapro/idaproc.htm)。
- en: ^([[24](#CHP-3-FN-7)]) See [http://www.hex-rays.com/idapro/idaorder.htm](http://www.hex-rays.com/idapro/idaorder.htm).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#CHP-3-FN-7)]) 请参阅 [http://www.hex-rays.com/idapro/idaorder.htm](http://www.hex-rays.com/idapro/idaorder.htm)。
- en: IDA Support Resources
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA 支持资源
- en: 'As an IDA user, you may wonder where you can turn for help when you have IDA-related
    questions. If we do our job well enough, this book will suffice in most situations.
    When you find yourself needing additional help, though, here are some popular
    resources:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 IDA 用户，当您有与 IDA 相关的问题时，可能会想知道您可以去哪里寻求帮助。如果我们做得足够好，这本书在大多数情况下就足够了。当您发现自己需要额外的帮助时，以下是一些流行的资源：
- en: '**Official help documentation**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**官方帮助文档**'
- en: IDA ships with a menu-activated help system, but it is primarily an overview
    of the IDA user interface and the scripting subsystem. No help is available for
    the IDA SDK, nor is much help available when you have questions like “How do I
    do *x*?”
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 随附菜单激活的帮助系统，但它主要是对 IDA 用户界面和脚本子系统的概述。对于 IDA SDK，没有可用的帮助，当您有像“我该如何做 *x*？”这样的问题时，也没有太多帮助。
- en: '**Hex-Rays’ support page and forums**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hex-Rays 的支持页面和论坛**'
- en: Hex-Rays hosts a support page^([[25](#ftn.CHP-3-FN-8)]) that offers links to
    various IDA-related resources, including online forums available to licensed users.
    Users will find that Ilfak and other core Hex-Rays programmers are frequent contributors
    to the forums. The forums are also a good starting point for unofficial support
    of the SDK, since many experienced IDA users are more than willing to offer assistance
    based on their personal experiences.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Hex-Rays 提供了一个支持页面^([[25](#ftn.CHP-3-FN-8)])，其中包含指向各种与 IDA 相关资源的链接，包括可供授权用户访问的在线论坛。用户会发现
    Ilfak 和其他核心 Hex-Rays 程序员是论坛的频繁贡献者。论坛也是 SDK 非官方支持的良好起点，因为许多经验丰富的 IDA 用户愿意根据他们的个人经验提供帮助。
- en: 'Questions concerning use of the SDK are often answered with “Read the include
    files.” The SDK is officially unsupported with a purchase of IDA; however, Hex-Rays
    does offer a yearly support plan for an annual fee of USD10,000 (yep, that’s right:
    $10K). An excellent resource to familiarize yourself with the SDK is “IDA Plug-in
    Writing in C/C++” by Steve Micallef.^([[26](#ftn.CHP-3-FN-9)])'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 SDK 的使用问题通常以“阅读包含文件”来回答。IDA 的官方支持不包括在 IDA 的购买中；然而，Hex-Rays 提供了一项年度支持计划，年费为
    10,000 美元（没错：10K）。熟悉 SDK 的一个极好资源是 Steve Micallef 所著的“IDA 插件编写（C/C++）”。^([[26](#ftn.CHP-3-FN-9)])
- en: '**OpenRCE.org**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenRCE.org**'
- en: A vibrant reverse engineering community exists at [http://www.openrce.org/](http://www.openrce.org/),
    which contains numerous articles related to novel uses of IDA along with active
    user forums. Similar to the forums at Hex-Rays, OpenRCE.org attracts a large number
    of experienced IDA users who are often more than willing to share their advice
    on how to resolve almost any problem you may encounter with IDA.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://www.openrce.org/](http://www.openrce.org/) 存在一个充满活力的逆向工程社区，其中包含许多与
    IDA 新颖用途相关的文章以及活跃的用户论坛。与 Hex-Rays 的论坛类似，OpenRCE.org 吸引了大量的经验丰富的 IDA 用户，他们通常非常愿意分享如何解决你可能在
    IDA 中遇到的几乎所有问题的建议。
- en: '**RCE Forums**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**RCE 论坛**'
- en: The Reverse Code Engineering (RCE) forums at [http://www.woodmann.com/](http://www.woodmann.com/)
    contain countless posts related to the use of IDA Pro. The focus of the forums
    is much broader than the use of IDA Pro, however, with wide coverage of many tools
    and techniques useful to the binary reverse engineer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://www.woodmann.com/](http://www.woodmann.com/) 的 Reverse Code Engineering
    (RCE) 论坛中，有无数篇与 IDA Pro 使用相关的帖子。然而，论坛的焦点远不止 IDA Pro 的使用，它广泛覆盖了许多对二进制逆向工程师有用的工具和技术。
- en: '**The IDA Palace**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDA 宫殿**'
- en: Though it has had problems finding a permanent residence, the IDA Palace^([[27](#ftn.CHP-3-FN-10)])
    is a website dedicated to hosting information on IDA-related resources. Visitors
    can expect to find links to various papers related to IDA usage along with scripts
    and plug-ins for extending IDA’s capabilities.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它曾遇到寻找永久居所的问题，IDA 宫殿^([[27](#ftn.CHP-3-FN-10)]) 是一个专门用于托管与 IDA 相关资源的网站。访问者可以期待找到与
    IDA 使用相关的各种论文链接，以及扩展 IDA 功能的脚本和插件。
- en: '**Ilfak’s blog**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ilfak 的博客**'
- en: Finally, Ilfak’s blog^([[28](#ftn.CHP-3-FN-11)]) often contains postings detailing
    the use of IDA to solve various problems ranging from general disassembly to debugging
    and malware analysis. Additionally, postings by other Hex-Rays team members often
    detail some of the latest IDA features, as well as features that are under development.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Ilfak 的博客^([[28](#ftn.CHP-3-FN-11)]) 经常包含详细说明如何使用 IDA 解决各种问题的帖子，从一般的反汇编到调试和恶意软件分析。此外，其他
    Hex-Rays 团队成员的帖子经常详细介绍了 IDA 的最新功能以及正在开发中的功能。
- en: '* * *'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[25](#CHP-3-FN-8)]) See [http://www.hex-rays.com/idapro/idasupport.htm](http://www.hex-rays.com/idapro/idasupport.htm).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-3-FN-8)]) 请参阅 [http://www.hex-rays.com/idapro/idasupport.htm](http://www.hex-rays.com/idapro/idasupport.htm)。
- en: ^([[26](#CHP-3-FN-9)]) See [http://www.binarypool.com/idapluginwriting/idapw.pdf](http://www.binarypool.com/idapluginwriting/idapw.pdf).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#CHP-3-FN-9)]) 请参阅 [http://www.binarypool.com/idapluginwriting/idapw.pdf](http://www.binarypool.com/idapluginwriting/idapw.pdf)。
- en: ^([[27](#CHP-3-FN-10)]) See [http://old.idapalace.net/](http://old.idapalace.net/).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#CHP-3-FN-10)]) 请参阅 [http://old.idapalace.net/](http://old.idapalace.net/)。
- en: ^([[28](#CHP-3-FN-11)]) See [http://www.hexblog.com/](http://www.hexblog.com/).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#CHP-3-FN-11)]) 请参阅 [http://www.hexblog.com/](http://www.hexblog.com/)。
- en: Your IDA Installation
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的 IDA 安装
- en: Once you calm down from the initial excitement of receiving your shiny, new
    IDA CD and get down to the task of installing IDA, you will see that your CD contains
    directories named *utilities* and *sdk* containing various add-on utilities and
    the IDA software development kit, respectively. These will be discussed in detail
    later in the book. In the root directory of the CD you will find an installation
    binary. For Windows users, this binary is a traditional Windows installer executable.
    For Linux and OS X users, the installation binary is a gzipped *.tar* file.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从收到闪亮的新 IDA 光盘的初始兴奋中平静下来，开始安装 IDA 的任务时，你会发现光盘包含名为 *utilities* 和 *sdk* 的目录，分别包含各种附加实用程序和
    IDA 软件开发套件。这些将在本书的后续部分详细讨论。在光盘的根目录中，你可以找到一个安装二进制文件。对于 Windows 用户，这个二进制文件是一个传统的
    Windows 安装程序可执行文件。对于 Linux 和 OS X 用户，安装二进制文件是一个压缩的 *.tar* 文件。
- en: Windows Installation
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 安装
- en: 'Installing IDA on Windows is very straightforward. IDA’s Windows installer
    requires a password that is supplied with your CD or via email if you have downloaded
    your copy of IDA. Launching the Windows installer walks you through several informational
    dialogs, only one of which requires any thought. As shown in [Figure 3-1](ch03s04.html#choosing_your_installation_location
    "Figure 3-1. Choosing your installation location"), you will be offered the opportunity
    to specify an installation location or to accept the default suggested by the
    installer. Regardless of whether you choose the default or specify an alternate
    location, for the remainder of this book we will refer to your chosen install
    location as `<IDADIR>`. In your IDA directory, you will find your key file, *ida.key*,
    along with the following IDA executables:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 IDA 非常简单。IDA 的 Windows 安装程序需要一个密码，该密码随 CD 提供或如果您下载了 IDA 的副本，将通过电子邮件提供。启动
    Windows 安装程序会引导您通过几个信息对话框，其中只有一个需要您思考。如图 [图 3-1](ch03s04.html#choosing_your_installation_location
    "图 3-1. 选择您的安装位置") 所示，您将有机会指定安装位置或接受安装程序建议的默认位置。无论您选择默认位置还是指定其他位置，在此书余下的部分，我们将把您选择的安装位置称为
    `<IDADIR>`。在您的 IDA 目录中，您将找到您的密钥文件 *ida.key* 以及以下 IDA 可执行文件：
- en: '*idag.exe* is the Windows native GUI version of IDA. Beginning with version
    6.2, this file will cease to be shipped with IDA.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*idag.exe* 是 IDA 的 Windows 原生 GUI 版本。从版本 6.2 开始，此文件将不再随 IDA 一起提供。'
- en: '*idaq.exe* is the Windows Qt GUI version of IDA (versions 6.0 and later).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*idaq.exe* 是 IDA 的 Windows Qt GUI 版本（版本 6.0 及以后）。'
- en: '*idaw.exe* is the Windows text-mode version of IDA.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*idaw.exe* 是 IDA 的 Windows 文本模式版本。'
- en: '![Choosing your installation location](httpatomoreillycomsourcenostarchimages854069.png.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![选择您的安装位置](httpatomoreillycomsourcenostarchimages854069.png.jpg)'
- en: Figure 3-1. Choosing your installation location
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1. 选择您的安装位置
- en: With the move to the Qt cross-platform GUI library in IDA version 6.0, the native
    Windows version of IDA (*idag.exe*) has been deprecated and will cease to ship
    with IDA beginning with version 6.2.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 随着IDA版本 6.0 中 Qt 跨平台 GUI 库的引入，IDA 的原生 Windows 版本 (*idag.exe*) 已被弃用，并且从版本 6.2
    开始将不再随 IDA 一起提供。
- en: OS X and Linux Installation
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OS X 和 Linux 安装
- en: 'For installation on either OS X or Linux, `gunzip` and `untar` the appropriate
    archive to a location of your choosing. On a Linux system, it might look like
    this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 或 Linux 上安装时，请将相应的存档文件使用 `gunzip` 和 `untar` 命令解压缩到您选择的任何位置。在 Linux 系统上，它可能看起来像这样：
- en: '[PRE17]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On an OS X system, it will look like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 系统上，它可能看起来像这样：
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In either case, you will have a top-level directory named *ida* that contains
    all required files.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，您都将有一个名为 *ida* 的顶级目录，其中包含所有必需的文件。
- en: For both OS X and Linux, the name of the GUI version is *idaq* and the name
    of the console version is *idal*. The appearance of the console version is very
    similar to the Windows console version of IDA, which is shown in [Figure 3-2](ch03s04.html#the_console_version_of_ida_pro
    "Figure 3-2. The console version of IDA Pro"). Linux users may need to verify
    (using `ldd`) that all shared libraries required by IDA are available on their
    systems. One plug-in in particular, IDAPython, expects to find Python version
    2.6 installed. You may need to upgrade your Python installation or create symbolic
    links as necessary to satisfy IDA requirements.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OS X 和 Linux，GUI 版本的名称是 *idaq*，控制台版本的名称是 *idal*。控制台版本的外观与 IDA 的 Windows 控制台版本非常相似，如图
    [图 3-2](ch03s04.html#the_console_version_of_ida_pro "图 3-2. IDA Pro 的控制台版本") 所示。Linux
    用户可能需要验证（使用 `ldd`）IDA 所需的所有共享库是否都可用。特别是有一个插件，IDAPython，它期望找到已安装的 Python 2.6 版本。您可能需要升级您的
    Python 安装或创建必要的符号链接以满足 IDA 的要求。
- en: '![The console version of IDA Pro](httpatomoreillycomsourcenostarchimages854071.png.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![IDA Pro 的控制台版本](httpatomoreillycomsourcenostarchimages854071.png.jpg)'
- en: Figure 3-2. The console version of IDA Pro
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2. IDA Pro 的控制台版本
- en: IDA and SELinux
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA 和 SELinux
- en: 'If you are a Linux user that has SELinux enabled, you may find that IDA complains
    it “cannot enable executable stack as shared object” when attempting to load your
    desired processor module. The `execstack` command may be used to fix this problem
    on a per module basis as shown here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是启用了 SELinux 的 Linux 用户，您可能会发现当尝试加载您想要的处理器模块时，IDA 会抱怨“无法将可执行堆栈作为共享对象启用”。可以使用
    `execstack` 命令按模块修复此问题，如下所示：
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 32-bit vs. 64-bit IDA
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32 位 vs. 64 位 IDA
- en: Users of the advanced version of IDA will notice that they have two versions
    of each IDA executable, such as *idag.exe* and *idag64.exe* or *idaq* and *idaq64*.
    The distinction between the versions is that *idax64* is capable of disassembling
    64-bit code; however, all of the IDA executables themselves are 32-bit code. As
    a result, users running IDA on 64-bit platforms need to ensure that any supporting
    software required by IDA is available in a 32-bit version. For example, 64-bit
    Linux users must ensure that a 32-bit version of Python is installed if they wish
    to use IDAPython for scripting. Consult the documentation for your operating system
    for details on mixing 32- and 64-bit software.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDA 高级版本的用户会注意到，他们有两个版本的每个 IDA 可执行文件，例如 *idag.exe* 和 *idag64.exe* 或 *idaq*
    和 *idaq64*。版本之间的区别在于 *idax64* 能够反汇编 64 位代码；然而，所有的 IDA 可执行文件本身都是 32 位代码。因此，在 64
    位平台上运行 IDA 的用户需要确保 IDA 所需的任何支持软件都提供 32 位版本。例如，如果 64 位 Linux 用户希望使用 IDAPython 进行脚本编写，他们必须确保已安装
    32 位版本的 Python。有关混合 32 位和 64 位软件的详细信息，请参阅操作系统的文档。
- en: The IDA Directory Layout
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA 目录布局
- en: 'Instant familiarity with the contents of your IDA installation is by no means
    a requirement before you start using IDA. However, since our attention is turned
    to your new IDA install for the moment, let’s take an initial look at the basic
    layout. An understanding of the IDA directory structure will become more important
    as you progress to using the more advanced features of IDA covered later in the
    book. A brief description of each of the subdirectories within the IDA installation
    follows (for Windows and Linux users, these are found under *<IDADIR>*; for OS
    X users, these will be found under *<IDA-DIR>/idaq.app/Contents/MacOS*):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 IDA 之前，对 IDA 安装内容的即时熟悉绝对不是必需的。然而，由于我们目前关注的是您的新 IDA 安装，让我们先看看基本布局。随着您使用书中稍后介绍的
    IDA 更高级功能，对 IDA 目录结构的理解将变得更加重要。以下是 IDA 安装中每个子目录的简要描述（对于 Windows 和 Linux 用户，这些位于
    *<IDADIR>* 下；对于 OS X 用户，这些位于 *<IDA-DIR>/idaq.app/Contents/MacOS* 下）：
- en: '**cfg**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**cfg**'
- en: The *cfg* directory contains various configuration files, including the basic
    IDA configuration file *ida.cfg*, the GUI configuration file *idagui.cfg*, and
    the text-mode user interface configuration file *idatui.cfg*. Some of the more
    useful configuration capabilities of IDA will be covered in [Chapter 11](ch11.html
    "Chapter 11. Customizing IDA").
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*cfg* 目录包含各种配置文件，包括基本的 IDA 配置文件 *ida.cfg*，GUI 配置文件 *idagui.cfg*，以及文本模式用户界面配置文件
    *idatui.cfg*。IDA 中一些更有用的配置功能将在第 11 章（[第 11 章. 自定义 IDA](ch11.html "第 11 章. 自定义
    IDA")）中介绍。'
- en: '**idc**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**idc**'
- en: The *idc* directory contains the core files required by IDA’s built-in scripting
    language, IDC. Scripting with IDC will be covered in more detail in [Chapter 15](ch15.html
    "Chapter 15. IDA Scripting").
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*idc* 目录包含 IDA 内置脚本语言 IDC 所需的核心文件。使用 IDC 脚本将在第 15 章（[第 15 章. IDA 脚本](ch15.html
    "第 15 章. IDA 脚本")）中更详细地介绍。'
- en: '**ids**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**ids**'
- en: The *ids* directory contains symbol files (*IDS files* in IDA parlance) that
    describe the content of shared libraries that may be referenced by binaries loaded
    into IDA. These IDS files contain summary information that lists all entries that
    are exported from a given library. These entries describe the type and number
    of parameters that a function requires, the return type (if any) of a function,
    and the calling convention utilized by the function.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*ids* 目录包含符号文件（在 IDA 术语中称为 *IDS 文件*），描述可能被加载到 IDA 中的二进制文件引用的共享库的内容。这些 IDS 文件包含摘要信息，列出了从给定库导出的所有条目。这些条目描述了函数所需的类型和参数数量，函数的返回类型（如果有），以及函数使用的调用约定。'
- en: '**loaders**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载器**'
- en: The *loaders* directory contains IDA extensions that are used during the file-loading
    process to recognize and parse known file formats such as PE or ELF files. IDA
    loaders will be discussed in more detail in [Chapter 18](ch18.html "Chapter 18. Binary
    Files and IDA Loader Modules").
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*加载器* 目录包含在文件加载过程中使用的 IDA 扩展，用于识别和解析已知文件格式，如 PE 或 ELF 文件。IDA 加载器将在第 18 章（[第
    18 章. 二进制文件和 IDA 加载器模块](ch18.html "第 18 章. 二进制文件和 IDA 加载器模块")）中更详细地讨论。'
- en: '**plugins**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**插件**'
- en: The *plugins* directory contains IDA modules designed to provide additional,
    and in most cases user-defined, behavior for IDA. IDA plug-ins will be discussed
    in greater detail in [Chapter 17](ch17.html "Chapter 17. The IDA Plug-in Architecture").
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*插件* 目录包含为 IDA 提供额外（在大多数情况下是用户定义）行为的 IDA 模块。IDA 插件将在第 17 章（[第 17 章. IDA 插件架构](ch17.html
    "第 17 章. IDA 插件架构")）中更详细地讨论。'
- en: '**procs**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**'
- en: The *procs* directory contains the processor modules supported by the installed
    version of IDA. Processor modules provide the machine-language-to-assembly-language
    translation capability within IDA and are responsible for generating the assembly
    language displayed in the IDA user interface. IDA processor modules will be discussed
    in more detail in [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules").
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**procs**目录包含由安装的IDA版本支持的处理器模块。处理器模块在IDA中提供机器语言到汇编语言的翻译功能，并负责生成在IDA用户界面中显示的汇编语言。IDA处理器模块将在第19章（[第19章。IDA处理器模块](ch19.html
    "Chapter 19. IDA Processor Modules")）中更详细地讨论。'
- en: '**sig**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**sig**'
- en: The *sig* directory contains signatures for existing code that IDA utilizes
    for various pattern-matching operations. It is through such pattern matching that
    IDA can identify sequences of code as known library code, potentially saving you
    significant amounts of time in the analysis process. The signatures are generated
    using IDA’s Fast Library Identification and Recognition Technology (FLIRT), which
    will be covered in more detail in [Chapter 12](ch12.html "Chapter 12. Library
    Recognition Using FLIRT Signatures").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**sig**目录包含IDA用于各种模式匹配操作现有代码的签名。正是通过这种模式匹配，IDA能够识别代码序列为已知的库代码，这可能在分析过程中为你节省大量时间。这些签名是使用IDA的快速库识别和识别技术（FLIRT）生成的，这将在第12章（[第12章。使用FLIRT签名识别库](ch12.html
    "Chapter 12. Library Recognition Using FLIRT Signatures")）中更详细地介绍。'
- en: '**til**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**sig**'
- en: The *til* directory contains type library information that IDA uses to record
    the layout of data structures specific to various compiler libraries. Customizing
    IDA type libraries will be discussed further in [Chapter 13](ch13.html "Chapter 13. Extending
    IDA’s Knowledge").
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**til**目录包含IDA使用的类型库信息，用于记录特定编译库的数据结构布局。在第13章（[第13章。扩展IDA的知识](ch13.html "Chapter
    13. Extending IDA’s Knowledge")）中将进一步讨论自定义IDA类型库。'
- en: Thoughts on IDA’s User Interface
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于IDA用户界面的思考
- en: IDA’s MS-DOS heritage remains evident to this day. Regardless of the interface
    (text or GUI) that you happen to be using, IDA makes extensive use of hotkeys.
    While this is not necessarily a bad thing, it can yield unexpected results if
    you believe that you are in a text-entry mode and find that nearly every keystroke
    leads IDA to perform some hotkey action. For example, this can happen while using
    the GUI if you position the cursor to make a change and are expecting that anything
    you type will appear at the cursor location (IDA is not your mother’s word processor).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的MS-DOS血统至今依然明显。无论你使用的是哪种界面（文本或GUI），IDA都广泛使用快捷键。虽然这并不一定是个坏事情，但如果你认为自己在文本输入模式中，却发现几乎每个按键都会导致IDA执行某个快捷键动作，这可能会产生意外的结果。例如，在使用GUI时，如果你将光标定位以进行更改，并期望你输入的任何内容都会出现在光标位置（IDA不是你母亲用的文字处理器）。
- en: From a data-entry perspective, IDA accepts virtually all of its input via dialogs,
    so if you are attempting to enter any data at all into IDA, do make sure you see
    a dialog in which to enter that data. The one exception is IDA’s hex-editing feature,
    which is only available via the Hex View window.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据输入的角度来看，IDA几乎所有的输入都通过对话框进行，所以如果你试图在IDA中输入任何数据，务必确保你看到了一个可以输入数据的对话框。唯一的例外是IDA的十六进制编辑功能，它仅通过十六进制视图窗口可用。
- en: 'A final point worth remembering is this: *There is no undo in IDA!* If you
    inadvertently press a key that happens to initiate a hotkey action, do not waste
    any time searching for an undo feature within IDA’s menu system—you will not find
    one. Nor will you find a command history list to help you determine what it was
    you just did.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的一个最后要点是：**在IDA中没有撤销操作**！如果你不小心按下了会触发快捷键动作的键，不要浪费时间在IDA的菜单系统中寻找撤销功能——你找不到。同样，你也不会找到一个命令历史列表来帮助你确定你刚才做了什么。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With the mundane details out of the way, it is time to move on to using IDA
    to accomplish something useful. Over the course of the next few chapters, you
    will discover how to use IDA to perform basic file analysis, learn how to interpret
    the IDA data displays, and learn how to manipulate those displays to further your
    understanding of a program’s behavior.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些琐碎的细节之后，是时候转向使用IDA来完成一些有用的任务了。在接下来的几章中，你将了解到如何使用IDA进行基本文件分析，学习如何解释IDA的数据显示，以及如何操作这些显示来加深你对程序行为的理解。
