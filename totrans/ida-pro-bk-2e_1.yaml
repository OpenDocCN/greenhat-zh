- en: Part I. Introduction to IDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1. Introduction to Disassembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may be wondering what to expect in a book dedicated to IDA Pro. While obviously
    IDA-centric, this book is not intended to come across as *The IDA Pro User’s Manual*.
    Instead, we intend to use IDA as the enabling tool for discussing reverse engineering
    techniques that you will find useful in analyzing a wide variety of software,
    ranging from vulnerable applications to malware. When appropriate, we will provide
    detailed steps to be followed in IDA for performing specific actions related to
    the task at hand. As a result we will take a rather roundabout walk through IDA’s
    capabilities, beginning with the basic tasks you will want to perform upon initial
    examination of a file and leading up to advanced uses and customization of IDA
    for more challenging reverse engineering problems. We make no attempt to cover
    all of IDA’s features. We do, however, cover the features that you will find most
    useful in meeting your reverse engineering challenges. This book will help make
    IDA the most potent weapon in your arsenal of tools.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to diving into any IDA specifics, it will be useful to cover some of the
    basics of the disassembly process as well as review some other tools available
    for reverse engineering of compiled code. While none of these tools offers the
    complete range of IDA’s capabilities, each does address specific subsets of IDA
    functionality and offer valuable insight into specific IDA features. The remainder
    of this chapter is dedicated to understanding the disassembly process.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembly Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone who has spent any time at all studying programming languages has probably
    learned about the various generations of languages, but they are summarized here
    for those who may have been sleeping.
  prefs: []
  type: TYPE_NORMAL
- en: '**First-generation languages**'
  prefs: []
  type: TYPE_NORMAL
- en: These are the lowest form of language, generally consisting of ones and zeros
    or some shorthand form such as hexadecimal, and readable only by binary ninjas.
    Things are confusing at this level because it is often difficult to distinguish
    data from instructions since everything looks pretty much the same. First-generation
    languages may also be referred to as *machine languages*, and in some cases *byte
    code*, while machine language programs are often referred to as *binaries*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Second-generation languages**'
  prefs: []
  type: TYPE_NORMAL
- en: Also called *assembly languages*, second-generation languages are a mere table
    lookup away from machine language and generally map specific bit patterns, or
    operation codes (opcodes), to short but memorable character sequences called *mnemonics*.
    Occasionally these mnemonics actually help programmers remember the instructions
    with which they are associated. An *assembler* is a tool used by programmers to
    translate their assembly language programs into machine language suitable for
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Third-generation languages**'
  prefs: []
  type: TYPE_NORMAL
- en: These languages take another step toward the expressive capability of natural
    languages by introducing keywords and constructs that programmers use as the building
    blocks for their programs. Third-generation languages are generally platform independent,
    though programs written using them may be platform dependent as a result of using
    features unique to a specific operating system. Often-cited examples include FORTRAN,
    COBOL, C, and Java. Programmers generally use compilers to translate their programs
    into assembly language or all the way to machine language (or some rough equivalent
    such as byte code).
  prefs: []
  type: TYPE_NORMAL
- en: '**Fourth-generation languages**'
  prefs: []
  type: TYPE_NORMAL
- en: These exist but aren’t relevant to this book and will not be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: The What of Disassembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a traditional software development model, compilers, assemblers, and linkers
    are used by themselves or in combination to create executable programs. In order
    to work our way backwards (or reverse engineer programs), we use tools to undo
    the assembly and compilation processes. Not surprisingly, such tools are called
    *disassemblers* and *decompilers*, and they do pretty much what their names imply.
    A disassembler undoes the assembly process, so we should expect assembly language
    as the output (and therefore machine language as input). Decompilers aim to produce
    output in a high-level language when given assembly or even machine language as
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The promise of “source code recovery” will always be attractive in a competitive
    software market, and thus the development of usable decompilers remains an active
    research area in computer science. The following are just a few of the reasons
    that decompilation is difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The compilation process is lossy**.'
  prefs: []
  type: TYPE_NORMAL
- en: At the machine language level there are no variable or function names, and variable
    type information can be determined only by how the data is used rather than explicit
    type declarations. When you observe 32 bits of data being transferred, you’ll
    need to do some investigative work to determine whether those 32 bits represent
    an integer, a 32-bit floating point value, or a 32-bit pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compilation is a many-to-many operation**.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that a source program can be translated to assembly language in many
    different ways, and machine language can be translated back to source in many
    different ways. As a result, it is quite common that compiling a file and immediately
    decompiling it may yield a vastly different source file from the one that was
    input.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decompilers are very language and library dependent**.'
  prefs: []
  type: TYPE_NORMAL
- en: Processing a binary produced by a Delphi compiler with a decompiler designed
    to generate C code can yield very strange results. Similarly, feeding a compiled
    Windows binary through a decompiler that has no knowledge of the Windows programming
    API may not yield anything useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**A nearly perfect disassembly capability is needed in order to accurately
    decompile a binary**.'
  prefs: []
  type: TYPE_NORMAL
- en: Any errors or omissions in the disassembly phase will almost certainly propagate
    through to the decompiled code.
  prefs: []
  type: TYPE_NORMAL
- en: Hex-Rays, the most sophisticated decompiler on the market today, will be reviewed
    in [Chapter 23](ch23.html "Chapter 23. Real-World IDA Plug-ins").
  prefs: []
  type: TYPE_NORMAL
- en: The Why of Disassembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of disassembly tools is often to facilitate understanding of programs
    when source code is unavailable. Common situations in which disassembly is used
    include these:'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of malware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of closed-source software for vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of closed-source software for interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of compiler-generated code to validate compiler performance/correctness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display of program instructions while debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subsequent sections will explain each situation in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Malware Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless you are dealing with a script-based worm, malware authors seldom do you
    the favor of providing the source code to their creations. Lacking source code,
    you are faced with a very limited set of options for discovering exactly how the
    malware behaves. The two main techniques for malware analysis are dynamic analysis
    and static analysis. *Dynamic analysis* involves allowing the malware to execute
    in a carefully controlled environment (sandbox) while recording every observable
    aspect of its behavior using any number of system instrumentation utilities. In
    contrast, *static analysis* attempts to understand the behavior of a program simply
    by reading through the program code, which, in the case of malware, generally
    consists of a disassembly listing.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of simplification, let’s break the entire security-auditing process
    into three steps: vulnerability discovery, vulnerability analysis, and exploit
    development. The same steps apply whether you have source code or not; however,
    the level of effort increases substantially when all you have is a binary. The
    first step in the process is to discover a potentially exploitable condition in
    a program. This is often accomplished using dynamic techniques such as fuzzing,^([[1](#ftn.CHP-1-FN-1)])
    but it can also be performed (usually with much more effort) via static analysis.
    Once a problem has been discovered, further analysis is often required to determine
    whether the problem is exploitable at all and, if so, under what conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: Disassembly listings provide the level of detail required to understand exactly
    how the compiler has chosen to allocate program variables. For example, it might
    be useful to know that a 70-byte character array declared by a programmer was
    rounded up to 80 bytes when allocated by the compiler. Disassembly listings also
    provide the only means to determine exactly how a compiler has chosen to order
    all of the variables declared globally or within functions. Understanding the
    spatial relationships among variables is often essential when attempting to develop
    exploits. Ultimately, by using a disassembler and a debugger together, an exploit
    may be developed.
  prefs: []
  type: TYPE_NORMAL
- en: Software Interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When software is released in binary form only, it is very difficult for competitors
    to create software that can interoperate with it or to provide plug-in replacements
    for that software. A common example is driver code released for hardware that
    is supported on only one platform. When a vendor is slow to support or, worse
    yet, refuses to support the use of its hardware with alternative platforms, substantial
    reverse engineering effort may be required in order to develop software drivers
    to support the hardware. In these cases, static code analysis is almost the only
    remedy and often must go beyond the software driver to understand embedded firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the purpose of a compiler (or assembler) is to generate machine language,
    good disassembly tools are often required to verify that the compiler is doing
    its job in accordance with any design specifications. Analysts may also be interested
    in locating additional opportunities for optimizing compiler output and, from
    a security standpoint, ascertaining whether the compiler itself has been compromised
    to the extent that it may be inserting back doors into generated code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Displays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the single most common use of disassemblers is to generate listings
    within debuggers. Unfortunately, disassemblers embedded within debuggers tend
    to be fairly unsophisticated. They are generally incapable of batch disassembly
    and sometimes balk at disassembling when they cannot determine the boundaries
    of a function. This is one of the reasons why it is best to use a debugger in
    conjunction with a high-quality disassembler to provide better situational awareness
    and context during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-1-FN-1)]) *Fuzzing* is a vulnerability-discovery technique that
    relies on generating large numbers of unique inputs for programs in the hope that
    one of those inputs will cause the program to fail in a manner that can be detected,
    analyzed, and ultimately exploited.
  prefs: []
  type: TYPE_NORMAL
- en: The How of Disassembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’re well versed in the purposes of disassembly, it’s time to move
    on to how the process actually works. Consider a typical daunting task faced by
    a disassembler: *Take these 100KB, distinguish code from data, convert the code
    to assembly language for display to a user, and please don’t miss anything along
    the way*. We could tack any number of special requests on the end of this, such
    as asking the disassembler to locate functions, recognize jump tables, and identify
    local variables, making the disassembler’s job that much more difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to accommodate all of our demands, any disassembler will need to pick
    and choose from a variety of algorithms as it navigates through the files that
    we feed it. The quality of the generated disassembly listing will be directly
    related to the quality of the algorithms utilized and how well they have been
    implemented. In this section we will discuss two of the fundamental algorithms
    in use today for disassembling machine code. As we present these algorithms, we
    will also point out their shortcomings in order to prepare you for situations
    in which your disassembler appears to fail. By understanding a disassembler’s
    limitations, you will be able to manually intervene to improve the overall quality
    of the disassembly output.
  prefs: []
  type: TYPE_NORMAL
- en: A Basic Disassembly Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For starters, let’s develop a simple algorithm for accepting machine language
    as input and producing assembly language as output. In doing so, we will gain
    an understanding of the challenges, assumptions, and compromises that underlie
    an automated disassembly process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in the disassembly process is to identify a region of code to
    disassemble. This is not necessarily as straightforward as it may seem. Instructions
    are generally mixed with data, and it is important to distinguish between the
    two. In the most common case, disassembly of an executable file, the file will
    conform to a common format for executable files such as the *Portable Executable
    (PE)* format used on Windows or the *Executable and Linking Format (ELF)* common
    on many Unix-based systems. These formats typically contain mechanisms (often
    in the form of hierarchical file headers) for locating the sections of the file
    that contain code and entry points^([[2](#ftn.CHP-1-FN-2)]) into that code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Given an initial address of an instruction, the next step is to read the value
    contained at that address (or file offset) and perform a table lookup to match
    the binary opcode value to its assembly language mnemonic. Depending on the complexity
    of the instruction set being disassembled, this may be a trivial process, or it
    may involve several additional operations such as understanding any prefixes that
    may modify the instruction’s behavior and determining any operands required by
    the instruction. For instruction sets with variable-length instructions, such
    as the Intel x86, additional instruction bytes may need to be retrieved in order
    to completely disassemble a single instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Once an instruction has been fetched and any required operands decoded, its
    assembly language equivalent is formatted and output as part of the disassembly
    listing. It may be possible to choose from more than one assembly language output
    syntax. For example, the two predominant formats for x86 assembly language are
    the Intel format and the AT&T format.
  prefs: []
  type: TYPE_NORMAL
- en: 'X86 ASSEMBLY SYNTAX: AT&T VS. INTEL'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main syntaxes used for assembly source code: AT&T and Intel.
    Even though they are second-generation languages, the two vary greatly in syntax
    from variable, constant, and register access to segment and instruction size overrides
    to indirection and offsets. The AT&T assembly syntax is distinguished by its use
    of the % symbol to prefix all register names, the use of $ as a prefix for literal
    constants (also called *immediate operands*), and its operand ordering in which
    the source operand appears as the left-hand operand and the destination operand
    appears on the right. Using AT&T syntax, the instruction to add four to the EAX
    register would read: `add $0x4,%eax`. The GNU Assembler (Gas) and many other GNU
    tools, including gcc and gdb, utilize AT&T syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Intel syntax differs from AT&T in that it requires no register or literal prefixes
    and the operand ordering is reversed such that the source operand appears on the
    right and the destination appears on the left. The same add instruction using
    the Intel syntax would read: `add eax,0x4`. Assemblers utilizing Intel syntax
    include the Microsoft Assembler (MASM), Borland’s Turbo Assembler (TASM), and
    the Netwide Assembler (NASM).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**'
  prefs: []
  type: TYPE_NORMAL
- en: Following the output of an instruction, we need to advance to the next instruction
    and repeat the previous process until we have disassembled every instruction in
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: Various algorithms exist for determining where to begin a disassembly, how to
    choose the next instruction to be disassembled, how to distinguish code from data,
    and how to determine when the last instruction has been disassembled. The two
    predominant disassembly algorithms are *linear sweep* and *recursive descent*.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Sweep Disassembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The linear sweep disassembly algorithm takes a very straightforward approach
    to locating instructions to disassemble: Where one instruction ends, another begins.
    As a result, the most difficult decision faced is where to begin. The usual solution
    is to assume that everything contained in sections of a program marked as code
    (typically specified by the program file’s headers) represents machine language
    instructions. Disassembly begins with the first byte in a code section and moves,
    in a linear fashion, through the section, disassembling one instruction after
    another until the end of the section is reached. No effort is made to understand
    the program’s control flow through recognition of nonlinear instructions such
    as branches.'
  prefs: []
  type: TYPE_NORMAL
- en: During the disassembly process, a pointer can be maintained to mark the beginning
    of the instruction currently being disassembled. As part of the disassembly process,
    the length of each instruction is computed and used to determine the location
    of the next instruction to be disassembled. Instruction sets with fixed-length
    instructions (MIPS, for example) are somewhat easier to disassemble, as locating
    subsequent instructions is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of the linear sweep algorithm is that it provides complete
    coverage of a program’s code sections. One of the primary disadvantages of the
    linear sweep method is that it fails to account for the fact that data may be
    comingled with code. This is evident in [Example 1-1](ch01s04.html#linear_sweep_disassembly-id1
    "Example 1-1. Linear sweep disassembly"), which shows the output of a function
    disassembled with a linear sweep disassembler. This function contains a switch
    statement, and the compiler used in this case has elected to implement the switch
    using a jump table. Furthermore, the compiler has elected to embed the jump table
    within the function itself. The `jmp` statement at ![](httpatomoreillycomsourcenostarchimages854061.png),
    `401250`, references an address table starting at ![](httpatomoreillycomsourcenostarchimages854063.png),
    `401257`. Unfortunately, the disassembler treats ![](httpatomoreillycomsourcenostarchimages854063.png)
    as if it were an instruction and incorrectly generates the corresponding assembly
    language representation:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1. Linear sweep disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we examine successive 4-byte groups as little-endian^([[3](#ftn.CHP-1-FN-3)])
    values beginning at ![](httpatomoreillycomsourcenostarchimages854063.png), we
    see that each represents a pointer to a nearby address that is in fact the destination
    for one of various jumps (`004012e0`, `0040128b`, `00401290`, . . .). Thus, the
    `loopne` instruction at ![](httpatomoreillycomsourcenostarchimages854063.png)
    is not an instruction at all. Instead, it indicates a failure of the linear sweep
    algorithm to properly distinguish embedded data from code.
  prefs: []
  type: TYPE_NORMAL
- en: Linear sweep is used by the disassembly engines contained in the GNU debugger
    (gdb), Microsoft’s WinDbg debugger, and the `objdump` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Descent Disassembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursive descent takes a different approach to locating instructions. Recursive
    descent focuses on the concept of control flow, which determines whether an instruction
    should be disassembled or not based on whether it is referenced by another instruction.
    To understand recursive descent, it is helpful to classify instructions according
    to how they affect the CPU instruction pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential Flow Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sequential flow instructions pass execution to the instruction that immediately
    follows. Examples of sequential flow instructions include simple arithmetic instructions,
    such as `add`; register-to-memory transfer instructions, such as `mov`; and stack-manipulation
    operations, such as `push` and `pop`. For such instructions, disassembly proceeds
    as with linear sweep.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Branching Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conditional branching instructions, such as the x86 `jnz`, offer two possible
    execution paths. If the condition evaluates to true, the branch is taken, and
    the instruction pointer must be changed to reflect the target of the branch. However,
    if the condition is false, execution continues in a linear fashion, and a linear
    sweep methodology can be used to disassemble the next instruction. As it is generally
    not possible in a static context to determine the outcome of a conditional test,
    the recursive descent algorithm disassembles both paths, deferring disassembly
    of the branch target instruction by adding the address of the target instruction
    to a list of addresses to be disassembled at a later point.
  prefs: []
  type: TYPE_NORMAL
- en: Unconditional Branching Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unconditional branches do not follow the linear flow model and therefore are
    handled differently by the recursive descent algorithm. As with the sequential
    flow instructions, execution can flow to only one instruction; however, that instruction
    need not immediately follow the branch instruction. In fact, as seen in [Example 1-1](ch01s04.html#linear_sweep_disassembly-id1
    "Example 1-1. Linear sweep disassembly"), there is no requirement at all for an
    instruction to immediately follow an unconditional branch. Therefore, there is
    no reason to disassemble the bytes that follow an unconditional branch.
  prefs: []
  type: TYPE_NORMAL
- en: A recursive descent disassembler will attempt to determine the target of the
    unconditional jump and add the destination address to the list of addresses that
    have yet to be explored. Unfortunately, some unconditional branches can cause
    problems for recursive descent disassemblers. When the target of a jump instruction
    depends on a runtime value, it may not be possible to determine the destination
    of the jump using static analysis. The x86 instruction `jmp eax` demonstrates
    this problem. The `eax` register contains a value only when the program is actually
    running. Since the register contains no value during static analysis, we have
    no way to determine the target of the jump instruction, and consequently, we have
    no way to determine where to continue the disassembly process.
  prefs: []
  type: TYPE_NORMAL
- en: Function Call Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function call instructions operate in a manner very similar to unconditional
    jump instructions (including the inability of the disassembler to determine the
    target of instructions such as `call eax`), with the additional expectation that
    execution usually returns to the instruction immediately following the call instruction
    once the function completes. In this regard, they are similar to conditional branch
    instructions in that they generate two execution paths. The target address of
    the call instruction is added to a list for deferred disassembly, while the instruction
    immediately following the call is disassembled in a manner similar to linear sweep.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive descent can fail if programs do not behave as expected when returning
    from called functions. For example, code in a function can deliberately manipulate
    the return address of that function so that upon completion, control returns to
    a location different from the one expected by the disassembler. A simple example
    is shown in the following incorrect listing, where function `foo` simply adds
    1 to the return address before returning to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, control does not actually pass to the `add` instruction at ![](httpatomoreillycomsourcenostarchimages854061.png)
    following the call to `foo`. A proper disassembly appears below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This listing more clearly shows the actual flow of the program in which function
    `foo` actually returns to the `mov` instruction at ![](httpatomoreillycomsourcenostarchimages854063.png).
    It is important to understand that a linear sweep disassembler will also fail
    to properly disassemble this code, though for slightly different reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Return Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, the recursive descent algorithm runs out of paths to follow.
    A function return instruction (x86 `ret`, for example) offers no information about
    what instruction will be executed next. If the program were actually running,
    an address would be taken from the top of the runtime stack, and execution would
    resume at that address. Disassemblers do not have the benefit of access to a stack.
    Instead, disassembly abruptly comes to a halt. It is at this point that the recursive
    descent disassembler turns to the list of addresses it has been setting aside
    for deferred disassembly. An address is removed from this list, and the disassembly
    process is continued from this address. This is the recursive process that lends
    the disassembly algorithm its name.
  prefs: []
  type: TYPE_NORMAL
- en: One of the principle advantages of the recursive descent algorithm is its superior
    ability to distinguish code from data. As a control flow–based algorithm, it is
    much less likely to incorrectly disassemble data values as code. The main disadvantage
    of recursive descent is the inability to follow indirect code paths, such as jumps
    or calls, which utilize tables of pointers to look up a target address. However,
    with the addition of some heuristics to identify pointers to code, recursive descent
    disassemblers can provide very complete code coverage and excellent recognition
    of code versus data. [Example 1-2](ch01s04.html#recursive_descent_disassembly-id1
    "Example 1-2. Recursive descent disassembly") shows the output of a recursive
    descent disassembler used on the same switch statement shown earlier in [Example 1-1](ch01s04.html#linear_sweep_disassembly-id1
    "Example 1-1. Linear sweep disassembly").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-2. Recursive descent disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the table of jump destinations has been recognized and formatted accordingly.
    IDA Pro is the most prominent example of a recursive descent disassembler. An
    understanding of the recursive descent process will help us recognize situations
    in which IDA may produce less than optimal disassemblies and allow us to develop
    strategies to improve IDA’s output.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-1-FN-2)]) A *program entry point* is simply the address of the instruction
    to which the operating system passes control once a program has been loaded into
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-1-FN-3)]) A CPU is described as either big-endian or little-endian
    depending on whether the CPU saves the most significant byte of a multibyte value
    first (big-endian) or whether it stores the least significant byte first (little-endian).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is deep understanding of disassembly algorithms essential when using a disassembler?
    No. Is it useful? Yes! Battling your tools is the last thing you want to spend
    time doing while reverse engineering. One of the many advantages of IDA is that,
    unlike most other disassemblers, it offers you plenty of opportunity to guide
    and override its decisions. The net result is that the finished product, an accurate
    disassembly, will be far superior to anything else available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will review a variety of existing tools that prove useful
    in many reverse engineering situations. While not directly related to IDA, many
    of these tools have influenced and been influenced by IDA, and they help to explain
    the wide variety of informational displays available in the IDA user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Reversing and Disassembly Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With some disassembly background under our belts, and before we begin our dive
    into the specifics of IDA Pro, it will be useful to understand some of the other
    tools that are used for reverse engineering binaries. Many of these tools predate
    IDA and continue to be useful for quick glimpses into files as well as for double-checking
    the work that IDA does. As we will see, IDA rolls many of the capabilities of
    these tools into its user interface to provide a single, integrated environment
    for reverse engineering. Finally, although IDA does contain an integrated debugger,
    we will not cover debuggers here as [Chapter 24](ch24.html "Chapter 24. The IDA
    Debugger"), [Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger Integration"),
    and [Chapter 26](ch26.html "Chapter 26. Additional Debugger Features") are dedicated
    to the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Classification Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When first confronted with an unknown file, it is often useful to answer simple
    questions such as “What is this thing?” The first rule of thumb when attempting
    to answer that question is to *never* rely on a filename extension to determine
    what a file actually is. That is also the second, third, and fourth rules of thumb.
    Once you have become an adherent of the *file extensions are meaningless* line
    of thinking, you may wish to familiarize yourself with one or more of the following
    utilities.
  prefs: []
  type: TYPE_NORMAL
- en: file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `file` command is a standard utility, included with most *NIX-style operating
    systems and with the Cygwin^([[4](#ftn.CHP-2-FN-1)]) or MinGW^([[5](#ftn.CHP-2-FN-2)])
    tools for Windows. `File` attempts to identify a file’s type by examining specific
    fields within the file. In some cases `file` recognizes common strings such as
    *#!/bin/sh* (a shell script) or *<html>* (an HTML document). Files containing
    non-ASCII content present somewhat more of a challenge. In such cases, `file`
    attempts to determine whether the content appears to be structured according to
    a known file format. In many cases it searches for specific tag values (often
    referred to as magic numbers^([[6](#ftn.CHP-2-FN-3)])) known to be unique to specific
    file types. The hex listings below show several examples of magic numbers used
    to identify some common file types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`file` has the capability to identify a large number of file formats, including
    several types of ASCII text files and various executable and data file formats.
    The magic number checks performed by `file` are governed by rules contained in
    a *magic file*. The default magic file varies by operating system, but common
    locations include */usr/share/file/magic*, */usr/share/misc/magic*, and */etc/magic*.
    Please refer to the documentation for `file` for more information concerning magic
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: THE CYGWIN ENVIRONMENT
  prefs: []
  type: TYPE_NORMAL
- en: Cygwin is a set of utilities for the Windows operating system that provides
    a Linux-style command shell and associated programs. During installation, users
    can choose from a large number of standard packages, including compilers (gcc,
    g++), interpreters (Perl, Python, Ruby), networking utilities (`nc`, `ssh`), and
    many others. Once Cygwin has been installed, many programs written for use with
    Linux can be compiled and executed on Windows systems.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, `file` can distinguish variations within a given file type. The
    following listing demonstrates `file`’s ability to identify not only several variations
    of ELF binaries but also information pertaining to how the binary was linked (statically
    or dynamically) and whether the binary was stripped or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: STRIPPING BINARY EXECUTABLE FILES
  prefs: []
  type: TYPE_NORMAL
- en: Stripping a binary is the process of removing symbols from the binary file.
    Binary object files contain symbols as a result of the compilation process. Some
    of these symbols are utilized during the linking process to resolve references
    between files when creating the final executable file or library. In other cases,
    symbols may be present to provide additional information for use with debuggers.
    Following the linking process, many of the symbols are no longer required. Options
    passed to the linker can cause the linker to remove the unnecessary symbols at
    build time. Alternatively, a utility named `strip` may be used to remove symbols
    from existing binary files. While a stripped binary will be smaller than its unstripped
    counterpart, the behavior of the stripped binary will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '`file` and similar utilities are not foolproof. It is quite possible for a
    file to be misidentified simply because it happens to bear the identifying marks
    of some file format. You can see this for yourself by using a hex editor to modify
    the first four bytes of any file to the Java magic number sequence: `CA FE BA
    BE`. The `file` utility will incorrectly identify the newly modified file as *compiled
    Java class data*. Similarly, a text file containing only the two characters `MZ`
    will be identified as an *MS-DOS executable*. A good approach to take in any reverse
    engineering effort is to never fully trust the output of any tool until you have
    correlated that output with several tools and manual analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: PE Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PE Tools^([[7](#ftn.CHP-2-FN-4)]) is a collection of tools useful for analyzing
    both running processes and executable files on Windows systems. [Figure 2-1](ch02.html#the_pe_tools_utility
    "Figure 2-1. The PE Tools utility") shows the primary interface offered by PE
    Tools, which displays a list of active processes and provides access to all of
    the PE Tools utilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![The PE Tools utility](httpatomoreillycomsourcenostarchimages854065.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1. The PE Tools utility
  prefs: []
  type: TYPE_NORMAL
- en: From the process list, users can dump a process’s memory image to a file or
    utilize the PE Sniffer utility to determine what compiler was used to build the
    executable or whether the executable was processed by any known obfuscation utilities.
    The Tools menu offers similar options for analysis of disk files. Users can view
    a file’s PE header fields by using the embedded PE Editor utility, which also
    allows for easy modification of any header values. Modification of PE headers
    is often required when attempting to reconstruct a valid PE from an obfuscated
    version of that file.
  prefs: []
  type: TYPE_NORMAL
- en: BINARY FILE OBFUSCATION
  prefs: []
  type: TYPE_NORMAL
- en: '*Obfuscation* is any attempt to obscure the true meaning of something. When
    applied to executable files, obfuscation is any attempt to hide the true behavior
    of a program. Programmers may employ obfuscation for a number of reasons. Commonly
    cited examples include protecting proprietary algorithms and obscuring malicious
    intent. Nearly all forms of malware utilize obfuscation in an effort to hinder
    analysis. Tools are widely available to assist program authors in generating obfuscated
    programs. Obfuscation tools and techniques and their associated impact on the
    reverse engineering process will be discussed further in [Chapter 21](ch21.html
    "Chapter 21. Obfuscated Code Analysis").'
  prefs: []
  type: TYPE_NORMAL
- en: PEiD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PEiD^([[8](#ftn.CHP-2-FN-5)]) is another Windows tool whose primary purposes
    are to identify the compiler used to build a particular Windows PE binary and
    to identify any tools used to obfuscate a Windows PE binary. [Figure 2-2](ch02.html#the_peid_utility
    "Figure 2-2. The PEiD utility") shows the use of PEiD to identify the tool (ASPack
    in this case) used to obfuscate a variant of the Gaobot^([[9](#ftn.CHP-2-FN-6)])
    worm.
  prefs: []
  type: TYPE_NORMAL
- en: '![The PEiD utility](httpatomoreillycomsourcenostarchimages854067.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2. The PEiD utility
  prefs: []
  type: TYPE_NORMAL
- en: Many additional capabilities of PEiD overlap those of PE Tools, including the
    ability to summarize PE file headers, collect information on running processes,
    and perform basic disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-2-FN-1)]) See [http://www.cygwin.com/](http://www.cygwin.com/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-2-FN-2)]) See [http://www.mingw.org/](http://www.mingw.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-2-FN-3)]) A *magic number* is a special tag value required by some
    file format specifications whose presence indicates conformance to such specifications.
    In some cases humorous reasons surround the selection of magic numbers. The `MZ`
    tag in MS-DOS executable file headers represents the initials of Mark Zbikowski,
    one of the original architects of MS-DOS, while the hex value `0xcafebabe`, the
    well-known magic number associated with Java *.class* files, was chosen because
    it is an easily remembered sequence of hex digits.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-2-FN-4)]) See [http://petools.org.ru/petools.shtml](http://petools.org.ru/petools.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#CHP-2-FN-5)]) See [http://peid.info/](http://peid.info/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[9](#CHP-2-FN-6)]) See [http://securityresponse.symantec.com/security_response/writeup.jsp?docid=2003-112112-1102-99](http://securityresponse.symantec.com/security_response/writeup.jsp?docid=2003-112112-1102-99).
  prefs: []
  type: TYPE_NORMAL
- en: Summary Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our goal is to reverse engineer binary program files, we are going to
    need more sophisticated tools to extract detailed information following initial
    classification of a file. The tools discussed in this section, by necessity, are
    far more aware of the formats of the files that they process. In most cases, these
    tools understand a very specific file format, and the tools are utilized to parse
    input files to extract very specific information.
  prefs: []
  type: TYPE_NORMAL
- en: nm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When source files are compiled to object files, compilers must embed information
    regarding the location of any global (external) symbols so that the linker will
    be able to resolve references to those symbols when it combines object files to
    create an executable. Unless instructed to strip symbols from the final executable,
    the linker generally carries symbols from the object files over into the resulting
    executable. According to the man page, the purpose of the `nm` utility is to “list
    symbols from object files.”
  prefs: []
  type: TYPE_NORMAL
- en: 'When `nm` is used to examine an intermediate object file (a *.o* file rather
    than an executable), the default output yields the names of any functions and
    global variables declared in the file. Sample output of the `nm` utility is shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see that `nm` lists each symbol along with some information about the
    symbol. The letter codes are used to indicate the type of symbol being listed.
    In this example, we see the following letter codes, which we will now explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`U`** | An undefined symbol, usually an external symbol reference. |'
  prefs: []
  type: TYPE_TB
- en: '| **`T`** | A symbol defined in the text section, usually a function name.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`t`** | A local symbol defined in the text section. In a C program, this
    usually equates to a static function. |'
  prefs: []
  type: TYPE_TB
- en: '| **`D`** | An initialized data value. |'
  prefs: []
  type: TYPE_TB
- en: '| **`C`** | An uninitialized data value. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Uppercase letter codes are used for global symbols, whereas lowercase letter
    codes are used for local symbols. A full explanation of the letter codes can be
    found in the man page for `nm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhat more information is displayed when `nm` is used to display symbols
    from an executable file. During the link process, symbols are resolved to virtual
    addresses (when possible), which results in more information being available when
    `nm` is run. Truncated example output from `nm` used on an executable is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point, some of the symbols (`main`, for example) have been assigned
    virtual addresses, new ones (`frame_dummy`) have been introduced as a result of
    the linking process, some (`my_unitialized_global`) have had their symbol type
    changed, and others remain undefined as they continue to reference external symbols.
    In this case, the binary we are examining is dynamically linked, and the undefined
    symbols are defined in the shared C library. More information regarding `nm` can
    be found in its associated man page.
  prefs: []
  type: TYPE_NORMAL
- en: ldd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an executable is created, the location of any library functions referenced
    by that executable must be resolved. The linker has two methods for resolving
    calls to library functions: *static linking* and *dynamic linking*. Command-line
    arguments provided to the linker determine which of the two methods is used. An
    executable may be statically linked, dynamically linked, or both.^([[10](#ftn.CHP-2-FN-7)])'
  prefs: []
  type: TYPE_NORMAL
- en: When static linking is requested, the linker combines an application’s object
    files with a copy of the required library to create an executable file. At runtime,
    there is no need to locate the library code because it is already contained within
    the executable. Advantages of static linking are that (1) it results in slightly
    faster function calls and (2) distribution of binaries is easier because no assumptions
    need be made regarding the availability of library code on users’ systems. Disadvantages
    of static linking include (1) larger resulting executables and (2) greater difficulty
    upgrading programs when library components change. Programs are more difficult
    to update because they must be relinked every time a library is changed. From
    a reverse engineering perspective, static linking complicates matters somewhat.
    If we are faced with the task of analyzing a statically linked binary, there is
    no easy way to answer the questions “Which libraries are linked into this binary?”
    and “Which of these functions is a library function?” [Chapter 12](ch12.html "Chapter 12. Library
    Recognition Using FLIRT Signatures") will discuss the challenges encountered while
    reverse engineering statically linked code.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic linking differs from static linking in that the linker has no need to
    make a copy of any required libraries. Instead, the linker simply inserts references
    to any required libraries (often *.so* or *.dll* files) into the final executable,
    usually resulting in much smaller executable files. Upgrading library code is
    much easier when dynamic linking is utilized. Since a single copy of a library
    is maintained and that copy is referenced by many binaries, replacing the single
    outdated library with a new version instantly updates every binary that makes
    use of that library. One of the disadvantages of using dynamic linking is that
    it requires a more complicated loading process. All of the necessary libraries
    must be located and loaded into memory, as opposed to loading one statically linked
    file that happens to contain all of the library code. Another disadvantage of
    dynamic linking is that vendors must distribute not only their own executable
    file but also all library files upon which that executable depends. Attempting
    to execute a program on a system that does not contain all the required library
    files will result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output demonstrates the creation of dynamically and statically
    linked versions of a program, the size of the resulting binaries, and the manner
    in which `file` identifies those binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for dynamic linking to function properly, dynamically linked binaries
    must indicate which libraries they depend on along with the specific resources
    that are required from each of those libraries. As a result, unlike statically
    linked binaries, it is quite simple to determine the libraries on which a dynamically
    linked binary depends. The `ldd` (*list dynamic dependencies*) utility is a simple
    tool used to list the dynamic libraries required by any executable. In the following
    example, `ldd` is used to determine the libraries on which the Apache web server
    depends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ldd` utility is available on Linux and BSD systems. On OS X systems, similar
    functionality is available using the `otool` utility with the `–L` option: `otool
    -L` *`filename`*. On Windows systems, the `dumpbin` utility, part of the Visual
    Studio tool suite, can be used to list dependent libraries: `dumpbin /dependents`
    *`filename`*.'
  prefs: []
  type: TYPE_NORMAL
- en: objdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whereas `ldd` is fairly specialized, `objdump` is extremely versatile. The
    purpose of `objdump` is to “display information from object files.”^([[11](#ftn.CHP-2-FN-8)])
    This is a fairly broad goal, and in order to accomplish it, `objdump` responds
    to a large number (30+) of command-line options tailored to extract various pieces
    of information from object files. `objdump` can be used to display the following
    data (and much more) related to object files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Section headers**'
  prefs: []
  type: TYPE_NORMAL
- en: Summary information for each of the sections in the program file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Private headers**'
  prefs: []
  type: TYPE_NORMAL
- en: Program memory layout information and other information required by the runtime
    loader, including a list of required libraries such as that produced by `ldd`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging information**'
  prefs: []
  type: TYPE_NORMAL
- en: Extracts any debugging information embedded in the program file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbol information**'
  prefs: []
  type: TYPE_NORMAL
- en: Dumps symbol table information in a manner similar to the `nm` utility.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disassembly listing**'
  prefs: []
  type: TYPE_NORMAL
- en: '`objdump` performs a linear sweep disassembly of sections of the file marked
    as code. When disassembling x86 code, `objdump` can generate either AT&T or Intel
    syntax, and the disassembly can be captured as a text file. Such a text file is
    called a disassembly *dead listing*, and while these files can certainly be used
    for reverse engineering, they are difficult to navigate effectively and even more
    difficult to modify in a consistent and error-free manner.'
  prefs: []
  type: TYPE_NORMAL
- en: '`objdump` is available as part of the GNU binutils^([[12](#ftn.CHP-2-FN-9)])
    tool suite and can be found on Linux, FreeBSD, and Windows (via Cygwin). `objdump`
    relies on the Binary File Descriptor library (libbfd), a component of binutils,
    to access object files and thus is capable of parsing file formats supported by
    libbfd (ELF and PE among others). For ELF-specific parsing, a utility named `readelf`
    is also available. `readelf` offers most of the same capabilities as `objdump`,
    and the primary difference between the two is that `readelf` does not rely upon
    libbfd.'
  prefs: []
  type: TYPE_NORMAL
- en: otool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`otool` is most easily described as an `objdump`-like utility for OS X, and
    it is useful for parsing information about OS X Mach-O binaries. The following
    listing demonstrates how `otool` displays the dynamic library dependencies for
    a Mach-O binary, thus performing a function similar to `ldd`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`otool` can be used to display information related to a file’s headers and
    symbol tables and to perform disassembly of the file’s code section. For more
    information regarding the capabilities of `otool`, please refer to the associated
    man page.'
  prefs: []
  type: TYPE_NORMAL
- en: dumpbin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dumpbin` is a command-line utility included with Microsoft’s Visual Studio
    suite of tools. Like `otool` and `objdump`, `dumpbin` is capable of displaying
    a wide range of information related to Windows PE files. The following listing
    shows how `dumpbin` displays the dynamic dependencies of the Windows calculator
    program in a manner similar to `ldd`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Additional `dumpbin` options offer the ability to extract information from various
    sections of a PE binary, including symbols, imported function names, exported
    function names, and disassembled code. Additional information related to the use
    of `dumpbin` is available via the Microsoft Developer Network (MSDN).^([[13](#ftn.CHP-2-FN-10)])
  prefs: []
  type: TYPE_NORMAL
- en: c++filt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Languages that allow function overloading must have a mechanism for distinguishing
    among the many overloaded versions of a function since each version has the same
    name. The following C++ example shows the prototypes for several overloaded versions
    of a function named `demo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As a general rule, it is not possible to have two functions with the same name
    in an object file. In order to allow overloading, compilers derive unique names
    for overloaded functions by incorporating information describing the type sequence
    of the function arguments. The process of deriving unique names for functions
    with identical names is called *name mangling*.^([[14](#ftn.CHP-2-FN-11)]) If
    we use `nm` to dump the symbols from the compiled version of the preceding C++
    code, we might see something like the following (filtered to focus on versions
    of `demo`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The C++ standard does not define standards for name-mangling schemes, leaving
    compiler designers to develop their own. In order to decipher the mangled variants
    of `demo` shown here, we need a tool that understands our compiler’s (g++ in this
    case) name-mangling scheme. This is precisely the purpose of the `c++filt` utility.
    `c++filt` treats each input word as if it were a mangled name and then attempts
    to determine the compiler that was used to generate that name. If the name appears
    to be a valid mangled name, it outputs the demangled version of the name. When
    `c++filt` does not recognize a word as a mangled name, it simply outputs the word
    with no changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass the results of `nm` from the preceding example through `c++filt`,
    it is possible to recover the demangled function names, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that mangled names contain additional information about
    functions that `nm` does not normally provide. This information can be extremely
    helpful in reversing engineering situations, and in more complex cases, this extra
    information may include data regarding class names or function-calling conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[10](#CHP-2-FN-7)]) For more information on linking, consult John R. Levine,
    *Linkers and Loaders* (San Francisco: Morgan Kaufmann, 2000).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#CHP-2-FN-8)]) See [http://www.sourceware.org/binutils/docs/binutils/objdump.html#objdump/](http://www.sourceware.org/binutils/docs/binutils/objdump.html#objdump/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[12](#CHP-2-FN-9)]) See [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#CHP-2-FN-10)]) See [http://msdn.microsoft.com/en-us/library/c1h23y6c(VS.71).aspx](http://msdn.microsoft.com/en-us/library/c1h23y6c(VS.71).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#CHP-2-FN-11)]) For an overview of name mangling, refer to [http://en.wikipedia.org/wiki/Name_mangling](http://en.wikipedia.org/wiki/Name_mangling).
  prefs: []
  type: TYPE_NORMAL
- en: Deep Inspection Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed tools that perform a cursory analysis of files based
    on minimal knowledge of those files’ internal structure. We have also seen tools
    capable of extracting specific pieces of data from files based on very detailed
    knowledge of a file’s structure. In this section we discuss tools designed to
    extract specific types of information independently of the type of file being
    analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is occasionally useful to ask more generic questions regarding file content,
    questions that don’t necessarily require any specific knowledge of a file’s structure.
    One such question is “Does this file contain any embedded strings?” Of course,
    we must first answer the question “What exactly constitutes a string?” Let’s loosely
    define a *string* as a consecutive sequence of printable characters. This definition
    is often augmented to specify a minimum length and a specific character set. Thus,
    we could specify a search for all sequences of at least four consecutive ASCII
    printable characters and print the results to the console. Searches for such strings
    are generally not limited in any way by the structure of a file. You can search
    for strings in an ELF binary just as easily as you can search for strings in a
    Microsoft Word document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `strings` utility is designed specifically to extract string content from
    files, often without regard for the format of those files. Using `strings` with
    its default settings (7-bit ASCII sequences of at least four characters) might
    yield something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, while we see some strings that look like they might be output
    by the program, other strings appear to be function names and library names. We
    should be careful not to jump to any conclusions regarding the behavior of the
    program. Analysts often fall into the trap of attempting to deduce the behavior
    of a program based on the output of `strings`. Remember, the presence of a string
    within a binary in no way indicates that the string is ever used in any manner
    by that binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some final notes on the use of `strings`:'
  prefs: []
  type: TYPE_NORMAL
- en: When using `strings` on executable files, it is important to remember that,
    by default, only the loadable, initialized sections of the file will be scanned.
    Use the `-a` command-line argument to force `strings` to scan the entire input
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strings` gives no indication of where, within a file, a string is located.
    Use the `-t` command-line argument to have `strings` print file offset information
    for each string found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many files utilize alternate character sets. Utilize the `-e` command-line argument
    to cause `strings` to search for wide characters such as 16-bit Unicode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disassemblers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, a number of tools are available to generate dead listing–style
    disassemblies of binary object files. PE, ELF, and Mach-O binaries can be disassembled
    using `dumpbin`, `objdump`, and `otool`, respectively. None of those, however,
    can deal with arbitrary blocks of binary data. You will occasionally be confronted
    with a binary file that does not conform to a widely used file format, in which
    case you will need tools capable of beginning the disassembly process at user-specified
    offsets.
  prefs: []
  type: TYPE_NORMAL
- en: Two examples of such *stream disassemblers* for the x86 instruction set are
    `ndisasm` and `diStorm`.^([[15](#ftn.CHP-2-FN-12)]) `ndisasm` is a utility included
    with the Netwide Assembler (NASM).^([[16](#ftn.CHP-2-FN-13)]) The following example
    illustrates the use of `ndisasm` to disassemble a piece of shellcode generated
    using the Metasploit framework.^([[17](#ftn.CHP-2-FN-14)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The flexibility of stream disassembly is useful in many situations. One scenario
    involves the analysis of computer network attacks in which network packets may
    contain shellcode. Stream disassemblers can be used to disassemble the portions
    of the packet that contain shellcode in order to analyze the behavior of the malicious
    payload. Another situation involves the analysis of ROM images for which no layout
    reference can be located. Portions of the ROM will contain data, while other portions
    will contain code. Stream disassemblers can be used to disassemble just those
    portions of the image thought to be code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#CHP-2-FN-12)]) See [http://www.ragestorm.net/distorm/](http://www.ragestorm.net/distorm/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#CHP-2-FN-13)]) See [http://nasm.sourceforge.net/](http://nasm.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#CHP-2-FN-14)]) See [http://www.metasploit.com/](http://www.metasploit.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools discussed in this chapter are not necessarily the best of their breed.
    They do, however, represent tools commonly available for anyone who wishes to
    reverse engineer binary files. More important, they represent the types of tools
    that motivated much of the development of IDA. In the coming chapters, we will
    discuss such tools. An awareness of these tools will greatly enhance your understanding
    of the IDA user interface and the many informational displays that IDA offers.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. IDA Pro Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Interactive Disassembler Professional, better and heretofore known as *IDA
    Pro* or simply *IDA* is a product of Hex-Rays,^([[18](#ftn.CHP-3-FN-1)]) located
    in Liège, Belgium. The programming genius behind IDA is Ilfak Guilfanov, better
    known as simply *Ilfak*. IDA began its life over a decade ago as an MS-DOS, console-based
    application, which is significant in that it helps us understand something about
    the nature of IDA’s user interface. Among other things, non-GUI versions of IDA
    ship for all IDA-supported platforms^([[19](#ftn.CHP-3-FN-2)]) and continue to
    use the console-style interface derived from the original DOS versions.
  prefs: []
  type: TYPE_NORMAL
- en: At its heart, IDA is a recursive descent disassembler; however, a substantial
    amount of effort has gone into developing logic to augment the recursive-descent
    process. In order to overcome one of the larger shortcomings of recursive descent,
    IDA employs a large number of heuristic techniques to identify additional code
    that may not have been found during the recursive-descent process. Beyond the
    disassembly process itself, IDA goes to great lengths not only to distinguish
    data disassemblies from code disassemblies but also to determine exactly what
    type of data is being represented by those data disassemblies. While the code
    that you view in IDA is in assembly language, one of the fundamental goals of
    IDA is to paint a picture as close to source code as possible. IDA makes every
    effort to annotate generated disassemblies with not only datatype information
    but also derived variable and function names. These annotations minimize the amount
    of raw hex and maximize the amount of symbolic information presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Hex-Rays’ Stance on Piracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an IDA user you should be aware of several facts. IDA is Hex-Rays’ flagship
    product; accordingly, it is very sensitive about unauthorized distribution of
    IDA. In the past, the company has seen a direct cause and effect relationship
    between releases of pirated versions of IDA and declining sales. The former publisher
    of IDA, DataRescue, has even gone so far as to post the names of pirates to its
    Hall of Shame.^([[20](#ftn.CHP-3-FN-3)]) IDA thus utilizes several antipiracy
    techniques in an effort to curb piracy and enforce licensing restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first technique to be aware of: Each copy of IDA is watermarked in order
    to uniquely tie it to its purchaser. If a copy of IDA turns up on a warez site,
    Hex-Rays has the ability to track that copy back to the original buyer, who will
    then be blacklisted from future sales. It is not uncommon to find discussions
    related to “leaked” copies of IDA on the IDA support forums at Hex-Rays.'
  prefs: []
  type: TYPE_NORMAL
- en: Another technique IDA uses to enforce its licensing policies involves scanning
    for additional copies of IDA running on the local network. When the Windows version
    of IDA is launched, a UDP packet is broadcast on port 23945, and IDA waits for
    responses to see whether other instances of IDA running under the same license
    key are present on the same subnet. The number of responses is compared to the
    number of seats to which the license applies, and if too many copies are found
    on the network, IDA will refuse to start. Do note, however, that it is permissible
    to run multiple instances of IDA on a single computer with a single license.
  prefs: []
  type: TYPE_NORMAL
- en: The final method of license enforcement centers on the use of key files tied
    to each purchaser. At startup, IDA searches for a valid *ida.key* file. Failure
    to locate a valid key file will cause IDA to shut down immediately. Key files
    are also used in determining eligibility for upgraded copies of IDA. In essence,
    *ida.key* represents your purchase receipt, and you should safeguard it to ensure
    that you remain eligible for future upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#CHP-3-FN-1)]) For many years, IDA was marketed by DataRescue; however,
    in January 2008, Ilfak moved marketing and sales of IDA to his own company, Hex-Rays.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#CHP-3-FN-2)]) Currently supported platforms are Windows, Linux, and
    OS X.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[20](#CHP-3-FN-3)]) The Hall of Shame has been migrated to the Hex-Rays
    website: [http://www.hex-rays.com/idapro/hallofshame.html](http://www.hex-rays.com/idapro/hallofshame.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining IDA Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First and foremost, IDA is not free software. The folks at Hex-Rays make their
    living in part through the sales of IDA. A limited-functionality, freeware^([[21](#ftn.CHP-3-FN-4)])
    version of IDA is available for people who wish to familiarize themselves with
    its basic capabilities, but it doesn’t keep pace with the most recent versions.
    The freeware version, discussed more extensively in [Appendix A](apa.html "Appendix A. Using
    IDA Freeware 5.0"), is a stripped-down edition of IDA 5.0 (the current version
    being 6.1). Along with the freeware version, Hex-Rays also distributes a restricted-functionality
    demonstration copy^([[22](#ftn.CHP-3-FN-5)]) of the current version. If the rave
    reviews that are found anywhere reverse engineering is discussed are not sufficient
    to convince you to purchase a copy, then spending some time with either the freeware
    or demo version will surely help you realize that IDA, and the customer support
    that comes along with it, is well worth owning.
  prefs: []
  type: TYPE_NORMAL
- en: IDA Versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of version 6.0, IDA is available in GUI and console versions for Windows,
    Linux, and OS X. IDA makes use of the Qt cross-platform GUI libraries to provide
    a consistent user interface on all three platforms. From a functionality standpoint,
    IDA Pro is offered in two versions: standard and advanced. The two versions differ
    primarily in the number of processor architectures for which they support disassembly.
    A quick look at the list of supported processors^([[23](#ftn.CHP-3-FN-6)]) shows
    that the standard version (approximately USD540 as of this writing) supports more
    than 30 processor families, while the advanced version (at almost twice the price)
    supports more than 50\. Additional architectures supported in the advanced version
    include x64, AMD64, MIPS, PPC, and SPARC, among others.'
  prefs: []
  type: TYPE_NORMAL
- en: IDA Licenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two licensing options are available when you purchase IDA. From the Hex-Rays
    website:^([[24](#ftn.CHP-3-FN-7)]) “Named licenses are linked to a specific end-user
    and may be used on as many computers as that particular end-user uses,” while
    “Computer licenses are linked to a specific computer and may be used by different
    end-users on that computer provided only one user is active at any time.” Note
    that while a single named license entitles you to install the software on as many
    computers as you like, you are the only person who may run those copies of IDA,
    and, for a single license, IDA may be running on only one of those computers at
    any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike many other software licenses for proprietary software, IDA’s license
    specifically grants users the right to reverse engineer IDA.
  prefs: []
  type: TYPE_NORMAL
- en: Purchasing IDA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to version 6.0, IDA purchases included a Windows GUI version along with
    console versions for Windows, Linux, and OS X. Beginning with version 6.0, purchasers
    must specify exactly which operating system they wish to run their copy of IDA
    on. Each copy of IDA 6.*x* includes console and Qt-based GUI versions for the
    specified operating system only. Additional licenses for alternate operating systems
    are available for a reduced price. You can purchase IDA through authorized distributors
    listed on the IDA sales web page or directly from Hex-Rays by fax or email. Purchased
    copies can be delivered via CD or downloaded, and they entitle the buyer to a
    year of support and upgrades. In addition to the IDA installer, the CD distribution
    contains a variety of extras such as the IDA software development kit (SDK) and
    other utilities. Users who opt to download their purchased copy of IDA typically
    receive only the installer bundle and are required to download other components
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: Hex-Rays has been known to restrict sales to specific countries based on its
    experiences with piracy in those countries. It also maintains a blacklist of users
    who have violated the terms of licensing for IDA and may refuse to do business
    with such users and/or their employers.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading IDA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IDA Help menu contains an option to check for an available upgrade. Additionally,
    IDA will automatically issue warnings that your support period is about to expire
    based on the expiration date contained in your key file. The upgrade process typically
    involves submitting your *ida.key* file to Hex-Rays, which will then validate
    your key and provide you with details on how to obtain your upgraded version.
    Should you find that your version of IDA is too old to be eligible for an upgrade,
    be sure to take advantage of Hex-Rays’ reduced upgrade pricing for holders of
    expired keys.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Failure to maintain close control over your key file could result in an unauthorized
    user requesting your allotted upgrade, preventing you from upgrading your copy
    of IDA.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note on upgrading any version of IDA, we highly recommend backing
    up your existing IDA installation or installing your upgrade to a completely different
    directory in order to avoid losing any configuration files that you may have modified.
    You will need to edit the corresponding files in your upgrade version to re-enable
    any changes that you have previously made. Similarly you will need to move, recompile,
    or otherwise obtain new versions of any custom IDA plug-ins that you may have
    been using (more about plug-ins and the plug-in installation process in [Chapter 17](ch17.html
    "Chapter 17. The IDA Plug-in Architecture")).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[21](#CHP-3-FN-4)]) See [http://www.hex-rays.com/idapro/idadownfreeware.htm](http://www.hex-rays.com/idapro/idadownfreeware.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[22](#CHP-3-FN-5)]) See [http://www.hex-rays.com/idapro/idadowndemo.htm](http://www.hex-rays.com/idapro/idadowndemo.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[23](#CHP-3-FN-6)]) See [http://www.hex-rays.com/idapro/idaproc.htm](http://www.hex-rays.com/idapro/idaproc.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[24](#CHP-3-FN-7)]) See [http://www.hex-rays.com/idapro/idaorder.htm](http://www.hex-rays.com/idapro/idaorder.htm).
  prefs: []
  type: TYPE_NORMAL
- en: IDA Support Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an IDA user, you may wonder where you can turn for help when you have IDA-related
    questions. If we do our job well enough, this book will suffice in most situations.
    When you find yourself needing additional help, though, here are some popular
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Official help documentation**'
  prefs: []
  type: TYPE_NORMAL
- en: IDA ships with a menu-activated help system, but it is primarily an overview
    of the IDA user interface and the scripting subsystem. No help is available for
    the IDA SDK, nor is much help available when you have questions like “How do I
    do *x*?”
  prefs: []
  type: TYPE_NORMAL
- en: '**Hex-Rays’ support page and forums**'
  prefs: []
  type: TYPE_NORMAL
- en: Hex-Rays hosts a support page^([[25](#ftn.CHP-3-FN-8)]) that offers links to
    various IDA-related resources, including online forums available to licensed users.
    Users will find that Ilfak and other core Hex-Rays programmers are frequent contributors
    to the forums. The forums are also a good starting point for unofficial support
    of the SDK, since many experienced IDA users are more than willing to offer assistance
    based on their personal experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Questions concerning use of the SDK are often answered with “Read the include
    files.” The SDK is officially unsupported with a purchase of IDA; however, Hex-Rays
    does offer a yearly support plan for an annual fee of USD10,000 (yep, that’s right:
    $10K). An excellent resource to familiarize yourself with the SDK is “IDA Plug-in
    Writing in C/C++” by Steve Micallef.^([[26](#ftn.CHP-3-FN-9)])'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenRCE.org**'
  prefs: []
  type: TYPE_NORMAL
- en: A vibrant reverse engineering community exists at [http://www.openrce.org/](http://www.openrce.org/),
    which contains numerous articles related to novel uses of IDA along with active
    user forums. Similar to the forums at Hex-Rays, OpenRCE.org attracts a large number
    of experienced IDA users who are often more than willing to share their advice
    on how to resolve almost any problem you may encounter with IDA.
  prefs: []
  type: TYPE_NORMAL
- en: '**RCE Forums**'
  prefs: []
  type: TYPE_NORMAL
- en: The Reverse Code Engineering (RCE) forums at [http://www.woodmann.com/](http://www.woodmann.com/)
    contain countless posts related to the use of IDA Pro. The focus of the forums
    is much broader than the use of IDA Pro, however, with wide coverage of many tools
    and techniques useful to the binary reverse engineer.
  prefs: []
  type: TYPE_NORMAL
- en: '**The IDA Palace**'
  prefs: []
  type: TYPE_NORMAL
- en: Though it has had problems finding a permanent residence, the IDA Palace^([[27](#ftn.CHP-3-FN-10)])
    is a website dedicated to hosting information on IDA-related resources. Visitors
    can expect to find links to various papers related to IDA usage along with scripts
    and plug-ins for extending IDA’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ilfak’s blog**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Ilfak’s blog^([[28](#ftn.CHP-3-FN-11)]) often contains postings detailing
    the use of IDA to solve various problems ranging from general disassembly to debugging
    and malware analysis. Additionally, postings by other Hex-Rays team members often
    detail some of the latest IDA features, as well as features that are under development.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[25](#CHP-3-FN-8)]) See [http://www.hex-rays.com/idapro/idasupport.htm](http://www.hex-rays.com/idapro/idasupport.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[26](#CHP-3-FN-9)]) See [http://www.binarypool.com/idapluginwriting/idapw.pdf](http://www.binarypool.com/idapluginwriting/idapw.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[27](#CHP-3-FN-10)]) See [http://old.idapalace.net/](http://old.idapalace.net/).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[28](#CHP-3-FN-11)]) See [http://www.hexblog.com/](http://www.hexblog.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Your IDA Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you calm down from the initial excitement of receiving your shiny, new
    IDA CD and get down to the task of installing IDA, you will see that your CD contains
    directories named *utilities* and *sdk* containing various add-on utilities and
    the IDA software development kit, respectively. These will be discussed in detail
    later in the book. In the root directory of the CD you will find an installation
    binary. For Windows users, this binary is a traditional Windows installer executable.
    For Linux and OS X users, the installation binary is a gzipped *.tar* file.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing IDA on Windows is very straightforward. IDA’s Windows installer
    requires a password that is supplied with your CD or via email if you have downloaded
    your copy of IDA. Launching the Windows installer walks you through several informational
    dialogs, only one of which requires any thought. As shown in [Figure 3-1](ch03s04.html#choosing_your_installation_location
    "Figure 3-1. Choosing your installation location"), you will be offered the opportunity
    to specify an installation location or to accept the default suggested by the
    installer. Regardless of whether you choose the default or specify an alternate
    location, for the remainder of this book we will refer to your chosen install
    location as `<IDADIR>`. In your IDA directory, you will find your key file, *ida.key*,
    along with the following IDA executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '*idag.exe* is the Windows native GUI version of IDA. Beginning with version
    6.2, this file will cease to be shipped with IDA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*idaq.exe* is the Windows Qt GUI version of IDA (versions 6.0 and later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*idaw.exe* is the Windows text-mode version of IDA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Choosing your installation location](httpatomoreillycomsourcenostarchimages854069.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1. Choosing your installation location
  prefs: []
  type: TYPE_NORMAL
- en: With the move to the Qt cross-platform GUI library in IDA version 6.0, the native
    Windows version of IDA (*idag.exe*) has been deprecated and will cease to ship
    with IDA beginning with version 6.2.
  prefs: []
  type: TYPE_NORMAL
- en: OS X and Linux Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For installation on either OS X or Linux, `gunzip` and `untar` the appropriate
    archive to a location of your choosing. On a Linux system, it might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On an OS X system, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In either case, you will have a top-level directory named *ida* that contains
    all required files.
  prefs: []
  type: TYPE_NORMAL
- en: For both OS X and Linux, the name of the GUI version is *idaq* and the name
    of the console version is *idal*. The appearance of the console version is very
    similar to the Windows console version of IDA, which is shown in [Figure 3-2](ch03s04.html#the_console_version_of_ida_pro
    "Figure 3-2. The console version of IDA Pro"). Linux users may need to verify
    (using `ldd`) that all shared libraries required by IDA are available on their
    systems. One plug-in in particular, IDAPython, expects to find Python version
    2.6 installed. You may need to upgrade your Python installation or create symbolic
    links as necessary to satisfy IDA requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '![The console version of IDA Pro](httpatomoreillycomsourcenostarchimages854071.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2. The console version of IDA Pro
  prefs: []
  type: TYPE_NORMAL
- en: IDA and SELinux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are a Linux user that has SELinux enabled, you may find that IDA complains
    it “cannot enable executable stack as shared object” when attempting to load your
    desired processor module. The `execstack` command may be used to fix this problem
    on a per module basis as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 32-bit vs. 64-bit IDA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Users of the advanced version of IDA will notice that they have two versions
    of each IDA executable, such as *idag.exe* and *idag64.exe* or *idaq* and *idaq64*.
    The distinction between the versions is that *idax64* is capable of disassembling
    64-bit code; however, all of the IDA executables themselves are 32-bit code. As
    a result, users running IDA on 64-bit platforms need to ensure that any supporting
    software required by IDA is available in a 32-bit version. For example, 64-bit
    Linux users must ensure that a 32-bit version of Python is installed if they wish
    to use IDAPython for scripting. Consult the documentation for your operating system
    for details on mixing 32- and 64-bit software.
  prefs: []
  type: TYPE_NORMAL
- en: The IDA Directory Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instant familiarity with the contents of your IDA installation is by no means
    a requirement before you start using IDA. However, since our attention is turned
    to your new IDA install for the moment, let’s take an initial look at the basic
    layout. An understanding of the IDA directory structure will become more important
    as you progress to using the more advanced features of IDA covered later in the
    book. A brief description of each of the subdirectories within the IDA installation
    follows (for Windows and Linux users, these are found under *<IDADIR>*; for OS
    X users, these will be found under *<IDA-DIR>/idaq.app/Contents/MacOS*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**cfg**'
  prefs: []
  type: TYPE_NORMAL
- en: The *cfg* directory contains various configuration files, including the basic
    IDA configuration file *ida.cfg*, the GUI configuration file *idagui.cfg*, and
    the text-mode user interface configuration file *idatui.cfg*. Some of the more
    useful configuration capabilities of IDA will be covered in [Chapter 11](ch11.html
    "Chapter 11. Customizing IDA").
  prefs: []
  type: TYPE_NORMAL
- en: '**idc**'
  prefs: []
  type: TYPE_NORMAL
- en: The *idc* directory contains the core files required by IDA’s built-in scripting
    language, IDC. Scripting with IDC will be covered in more detail in [Chapter 15](ch15.html
    "Chapter 15. IDA Scripting").
  prefs: []
  type: TYPE_NORMAL
- en: '**ids**'
  prefs: []
  type: TYPE_NORMAL
- en: The *ids* directory contains symbol files (*IDS files* in IDA parlance) that
    describe the content of shared libraries that may be referenced by binaries loaded
    into IDA. These IDS files contain summary information that lists all entries that
    are exported from a given library. These entries describe the type and number
    of parameters that a function requires, the return type (if any) of a function,
    and the calling convention utilized by the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**loaders**'
  prefs: []
  type: TYPE_NORMAL
- en: The *loaders* directory contains IDA extensions that are used during the file-loading
    process to recognize and parse known file formats such as PE or ELF files. IDA
    loaders will be discussed in more detail in [Chapter 18](ch18.html "Chapter 18. Binary
    Files and IDA Loader Modules").
  prefs: []
  type: TYPE_NORMAL
- en: '**plugins**'
  prefs: []
  type: TYPE_NORMAL
- en: The *plugins* directory contains IDA modules designed to provide additional,
    and in most cases user-defined, behavior for IDA. IDA plug-ins will be discussed
    in greater detail in [Chapter 17](ch17.html "Chapter 17. The IDA Plug-in Architecture").
  prefs: []
  type: TYPE_NORMAL
- en: '**procs**'
  prefs: []
  type: TYPE_NORMAL
- en: The *procs* directory contains the processor modules supported by the installed
    version of IDA. Processor modules provide the machine-language-to-assembly-language
    translation capability within IDA and are responsible for generating the assembly
    language displayed in the IDA user interface. IDA processor modules will be discussed
    in more detail in [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules").
  prefs: []
  type: TYPE_NORMAL
- en: '**sig**'
  prefs: []
  type: TYPE_NORMAL
- en: The *sig* directory contains signatures for existing code that IDA utilizes
    for various pattern-matching operations. It is through such pattern matching that
    IDA can identify sequences of code as known library code, potentially saving you
    significant amounts of time in the analysis process. The signatures are generated
    using IDA’s Fast Library Identification and Recognition Technology (FLIRT), which
    will be covered in more detail in [Chapter 12](ch12.html "Chapter 12. Library
    Recognition Using FLIRT Signatures").
  prefs: []
  type: TYPE_NORMAL
- en: '**til**'
  prefs: []
  type: TYPE_NORMAL
- en: The *til* directory contains type library information that IDA uses to record
    the layout of data structures specific to various compiler libraries. Customizing
    IDA type libraries will be discussed further in [Chapter 13](ch13.html "Chapter 13. Extending
    IDA’s Knowledge").
  prefs: []
  type: TYPE_NORMAL
- en: Thoughts on IDA’s User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDA’s MS-DOS heritage remains evident to this day. Regardless of the interface
    (text or GUI) that you happen to be using, IDA makes extensive use of hotkeys.
    While this is not necessarily a bad thing, it can yield unexpected results if
    you believe that you are in a text-entry mode and find that nearly every keystroke
    leads IDA to perform some hotkey action. For example, this can happen while using
    the GUI if you position the cursor to make a change and are expecting that anything
    you type will appear at the cursor location (IDA is not your mother’s word processor).
  prefs: []
  type: TYPE_NORMAL
- en: From a data-entry perspective, IDA accepts virtually all of its input via dialogs,
    so if you are attempting to enter any data at all into IDA, do make sure you see
    a dialog in which to enter that data. The one exception is IDA’s hex-editing feature,
    which is only available via the Hex View window.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final point worth remembering is this: *There is no undo in IDA!* If you
    inadvertently press a key that happens to initiate a hotkey action, do not waste
    any time searching for an undo feature within IDA’s menu system—you will not find
    one. Nor will you find a command history list to help you determine what it was
    you just did.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the mundane details out of the way, it is time to move on to using IDA
    to accomplish something useful. Over the course of the next few chapters, you
    will discover how to use IDA to perform basic file analysis, learn how to interpret
    the IDA data displays, and learn how to manipulate those displays to further your
    understanding of a program’s behavior.
  prefs: []
  type: TYPE_NORMAL
