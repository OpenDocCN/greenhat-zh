<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page289"/><img src="../images/313-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="app1"/><a href="toc.html#app1"><b>RTA REFERENCE</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb"><i>Run Time Access (RTA)</i> is a library that displays your program’s internal structures and arrays as database tables. RTA uses a subset of the PostgreSQL protocol and is compatible with the PostgreSQL bindings for C and PHP, as well as for the PostgreSQL command-line tool, psql. This appendix contains the definitions, data structures, and function prototypes for the RTA package.</p>&#13;
<p class="indent">The contents of this appendix that are taken from the RTA include excerpts from the file rta.h. We use the exact text of rta.h wherever possible. A less technical description of the material in this appendix is given in Chapters 2 and 3.</p>&#13;
<p class="indent">This appendix covers:</p>&#13;
<ul>&#13;
<li>Overview of RTA</li>&#13;
<li>RTA constants</li>&#13;
<li>Data structures</li>&#13;
<li>API subroutines</li>&#13;
<li><a id="page290"/>SELECT and UPDATE syntax</li>&#13;
<li>Internal RTA tables</li>&#13;
<li>Debug configuration</li>&#13;
<li>Error messages</li>&#13;
<li>Callback routines</li>&#13;
</ul>&#13;
<p class="indent">Linux appliances lack real-time access to status and statistics, as well as the ability to configure a service once it has started. As Linux users, we assume that to configure an application we will be able to use SSH or telnet to gain access to the service, use an editor to modify the /etc configuration file, and use the kill -1 command to terminate the process—so real-time status and statistics are features Linux programmers don’t even think to request. The lack of run-time access poses a particular challenge for network appliances where SSH is unavailable, either because it is not installed or it is not allowed.</p>&#13;
<p class="indent">Another challenge for appliance designers is that more than one type of user interface may be required. Many appliances have some combination of web, command-line, SNMP agent, front panel, and framebuffer interfaces. It is a nontrivial task to give the end user a consistent view regardless of the UI.</p>&#13;
<p class="secl"><a id="app1.1"/><a href="toc.html#app1.1"><b>Overview of RTA</b></a></p>&#13;
<p class="noindent">The RTA package addresses the challenges described above by giving realtime access to the data structures and arrays inside a running program. With minimal effort, we can use RTA to make a program’s data structures appear as PostgreSQL tables in a PostgreSQL database.</p>&#13;
<p class="indent">Using RTA, a structure definition is also the definition for a table row, and an array of structures will appear as a table. For example, the code below shows a definition of a data structure for TCP connection information.</p>&#13;
<p class="imgl"><img src="../images/314-1.jpg" alt=""/></p>&#13;
<p class="indent">The tcpconn structure describes a single connection. An array of these structures is needed if there’s more than one connection. This array might be allocated with</p>&#13;
<p class="ex2">struct tcpconn Conns[10];</p>&#13;
<p class="indent"><a id="page291"/>The above array of structures could be considered a database table, with each structure in the array as a row and each member in the structure as a column. RTA allows you to use any programming language with a PostgreSQL binding to query this table of TCP connections. Here are two sample SQL statements to manipulate the data in the Conns table:</p>&#13;
<p class="ex2">SELECT lport, dport FROM Conns WHERE fd != -1;<br/>UPDATE Conns SET dport = 0 WHERE fd = -1;</p>&#13;
<p class="indent">Don’t worry if the above statements do not make sense; there is a short tutorial on SQL later in this appendix.</p>&#13;
<p class="indent">The addition of a database API offers several advantages. For one, debugging is made easier because you can use simple PostgreSQL tools to view much of your program’s state. The PostgreSQL database API also makes it easier to build UI programs, since it includes bindings for PHP, Tcl/Tk, Perl, C, Java, Visual C++, and many other programming languages.</p>&#13;
<p class="indent">A database API can also help speed up development. When the tables used by the UI programs are carefully defined, the core application team can build the application while the UI developers work on the web pages, wizards, and MIBs of the various UI programs.</p>&#13;
<p class="indent">In order to make your arrays and structures available to the database API, you must tell RTA about the tables (including things like the name, start address, number of rows, and length of each row) and columns (including things like the associate table name, column name, column’s data type, and whether special functions called <i>callbacks</i> are to be called when the column is read or written).</p>&#13;
<p class="secl"><a id="app1.2"/><a href="toc.html#app1.2"><b>RTA Constants</b></a></p>&#13;
<p class="noindent">Here is an excerpt from the rta.h file showing the constants that describe the internal size limits for the RTA package. You can change these limits, but if you do, be sure to recompile the RTA package using your new settings.</p>&#13;
<p class="imgl"><img src="../images/315-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page292"/><img src="../images/316-1.jpg" alt=""/></p>&#13;
<p class="secl"><a id="app1.3"/><a href="toc.html#app1.3"><b>Data Structures</b></a></p>&#13;
<p class="noindent">Recall that each column in a table corresponds to a structure member, and each row in a table corresponds to an array element. In order for RTA to treat your arrays of structures as tables, you have the tell RTA about the tables. You describe each column by filling in a COLDEF structure, and you describe each table by filling in a TBLDEF structure. Here is an excerpt from rta.h that completely defines the data structures and constants associated with tables and columns.</p>&#13;
<p class="imgl"><img src="../images/316-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page293"/><img src="../images/317-1.jpg" alt=""/></p>&#13;
<p class="imgl"><img src="../images/317-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page294"/><img src="../images/318-1.jpg" alt=""/></p>&#13;
<p class="imgl"><img src="../images/318-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page295"/><img src="../images/319-1.jpg" alt=""/></p>&#13;
<p class="imgl"><img src="../images/319-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page296"/><img src="../images/320-1.jpg" alt=""/></p>&#13;
<p class="secl"><a id="app1.4"/><a href="toc.html#app1.4"><b>API Subroutines</b></a></p>&#13;
<p class="noindent">There are only six subroutines in the RTA API. Table A-1 summarizes them.</p>&#13;
<p class="tcap"><b>Table A-1:</b> Subroutines for the RTA PostgreSQL API</p>&#13;
<p class="imgc"><img src="../images/320-2.jpg" alt=""/></p>&#13;
<p class="indent">The subroutines in the RTA libraries usually return one of the following values.</p>&#13;
<p class="imgl"><img src="../images/320-3.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.5"/><a href="toc.html#app1.5"><i><b>The dbcommand() Subroutine</b></i></a></p>&#13;
<p class="noindent"><a id="page297"/>The main application in your appliance accepts TCP connections from PostgreSQL clients and passes the stream of bytes (encoded SQL requests) from the client into RTA via the dbcommand() subroutine. In turn, dbcommand() writes the stream of bytes to an input buffer to be parsed for an SQL command.</p>&#13;
<p class="indent">If the input buffer contains a complete command, the command will be executed, the number-of-characters-in (nin) variable will be decreased by the number of bytes consumed, and RTA_SUCCESS will be returned. If there is not a complete command in the input buffer, RTA_NOCMD will be returned and no bytes will be removed from the input buffer.</p>&#13;
<p class="indent">If a command is executed, the results will be encoded into the PostgreSQL protocol and placed in the output buffer (out). When the subroutine is called, the input variable, number-of-characters-out (nout), has the number of free bytes available in the output buffer. When the subroutine returns, the nout variable will be decremented by the size of the response placed in the output buffer. An error message is generated if the number of available bytes in the output buffer is too small to hold the response from the SQL command.</p>&#13;
<p class="indent">The list below summarizes the input buffers and bytes for the dbcommand() subroutine.</p>&#13;
<p class="imgc"><img src="../images/321-1.jpg" alt=""/></p>&#13;
<p class="indent">The list below summarizes the returns for the dbcommand() subroutine.</p>&#13;
<p class="imgc"><img src="../images/321-2.jpg" alt=""/></p>&#13;
<p class="indent">The prototype for the dbcommand() subroutine is shown below.</p>&#13;
<p class="imgl"><img src="../images/321-3.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.6"/><a href="toc.html#app1.6"><i><b>The rta_add_table() Subroutine</b></i></a></p>&#13;
<p class="noindent">The rta_add_table() subroutine registers a table for inclusion in the database interface, which gives external PostgreSQL clients access to the contents of the table. You need to call rta_add_table() for each of your tables.</p>&#13;
<p class="indent"><a id="page298"/>Note that the TBLDEF structure must be statically allocated. RTA keeps only the pointer to the table and does not copy the information. This means that you can change the contents of the table definition by changing the contents of the TBLDEF structure, which is useful if you need to allocate more memory for the table and change its row count and address.</p>&#13;
<p class="indent">When you add an RTA table, you will see an error message if another table with the same name already exists in the database or if the table is defined without any columns.</p>&#13;
<p class="indent">If you specify a savefile, the SQL commands in the savefile will be loaded as part of the rta_add_table() call. See “The rta_load() Subroutine” on page 300 for more details.</p>&#13;
<p class="indent">This list summarizes the input for the rta_add_table() subroutine.</p>&#13;
<p class="imgc"><img src="../images/322-1.jpg" alt=""/></p>&#13;
<p class="indent">This list summarizes the returns for the rta_add_table() subroutine.</p>&#13;
<p class="imgc"><img src="../images/322-2.jpg" alt=""/></p>&#13;
<p class="indent">The prototype of the rta_add_table() subroutine is shown below.</p>&#13;
<p class="imgl"><img src="../images/322-3.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.7"/><a href="toc.html#app1.7"><i><b>The SQL_string() Subroutine</b></i></a></p>&#13;
<p class="noindent">The SQL_string() subroutine executes the SQL command placed in the null-terminated input string, cmd. The results are encoded into the PostgreSQL protocol and placed in the output buffer, out. When the subroutine is called, the input variable, nout, has the number of free bytes available in the output buffer, out. When the subroutine returns, nout has been decremented by the size of the response placed in the output buffer. An error message is generated if the number of available bytes in the output buffer is too small to hold the response from the SQL command.</p>&#13;
<p class="indent">This subroutine may be most useful when updating a table value in order to invoke the write callbacks. (The output buffer has the results encoded in the PostgreSQL protocol and might not be too useful directly.)</p>&#13;
<p class="indent">The list below summarizes the input for the SQL_string() subroutine.</p>&#13;
<p class="imgc"><a id="page299"/><img src="../images/323-1.jpg" alt=""/></p>&#13;
<p class="indent">The SQL_string() subroutine returns nothing.</p>&#13;
<p class="indent">The prototype for the SQL_string() subroutine is shown below.</p>&#13;
<p class="imgl"><img src="../images/323-2.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.8"/><a href="toc.html#app1.8"><i><b>The rta_config_dir() Subroutine</b></i></a></p>&#13;
<p class="noindent">The rta_config_dir() subroutine sets the default path to the savefile directory. The string that the input parameter, configdir, points to is saved and prepended to the savefile names for tables with savefiles.</p>&#13;
<p class="indent">You should call the rta_config_dir() subroutine before you load your application tables. This subroutine is intended to simplify applications that let the user specify a configuration directory on the command line.</p>&#13;
<p class="indent">If the savefile uses an absolute path (starting with /), it is not prepended with the configuration directory.</p>&#13;
<p class="indent">This list summarizes the input for the rta_config_dir() subroutine.</p>&#13;
<p class="imgc"><img src="../images/323-3.jpg" alt=""/></p>&#13;
<p class="indent">This list summarizes the return values for the rta_config_dir() subroutine.</p>&#13;
<p class="imgc"><img src="../images/323-4.jpg" alt=""/></p>&#13;
<p class="indent">The prototype of the rta_config_dir() subroutine is shown below.</p>&#13;
<p class="ex">int rta_config_dir(char *configdir);</p>&#13;
<p class="secs"><a id="app1.9"/><a href="toc.html#app1.9"><i><b>The rta_save() Subroutine</b></i></a></p>&#13;
<p class="noindent">The rta_save() subroutine saves a table to a file, including all savetodisk columns to the path and file specified. Only savetodisk columns are saved. The resulting file is a list of UPDATE commands containing the desired data. There is one UPDATE command for each row in a table.</p>&#13;
<p class="indent"><a id="page300"/>The rta_save() subroutine tries to prevent corrupted save files by opening a temporary (temp) file in the same directory as the target file. The subroutine saves the data in the temp file and then automatically calls the rename() subroutine to atomically move the temp file to the savefile. The rta_save() subroutine generates errors if it cannot open the temp file or if it is unable to rename the temp file with rename().</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>As a general warning, keep in mind that any disk I/O can cause a program to block briefly. Therefore, saving and loading tables can cause your program to block for a moment.</i></p>&#13;
<p class="indent">This list summarizes the input for the rta_save() subroutine.</p>&#13;
<p class="imgc"><img src="../images/324-1.jpg" alt=""/></p>&#13;
<p class="indent">This list summarizes the return values for the rta_save() subroutine.</p>&#13;
<p class="imgc"><img src="../images/324-2.jpg" alt=""/></p>&#13;
<p class="indent">The prototype of the rta_save() subroutine is shown below.</p>&#13;
<p class="imgl"><img src="../images/324-3.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.10"/><a href="toc.html#app1.10"><i><b>The rta_load() Subroutine</b></i></a></p>&#13;
<p class="noindent">The rta_load() subroutine loads a table from a file of UPDATE commands. The file format is a series of UPDATE commands with one command per line. Any write callbacks are executed as each UPDATE occurs. Note that a call to rta_load() occurs automatically when you add the table using rta_add_table(). This list summarizes the input for the rta_load() subroutine.</p>&#13;
<p class="indent">This list summarizes the return values for the rta_load() subroutine.</p>&#13;
<p class="imgc"><img src="../images/324-4.jpg" alt=""/></p>&#13;
<p class="indent">The prototype of the rta_save() subroutine is shown below.</p>&#13;
<p class="imgc"><img src="../images/324-5.jpg" alt=""/></p>&#13;
<p class="indent">The prototype of the rta_save() subroutine is shown below.</p>&#13;
<p class="imgl"><a id="page301"/><img src="../images/325-1.jpg" alt=""/></p>&#13;
<p class="secl"><a id="app1.11"/><a href="toc.html#app1.11"><b>SELECT and UPDATE Syntax</b></a></p>&#13;
<p class="noindent">The next two sections give a brief introduction to the two SQL commands implemented by the RTA API. Neither the RTA UPDATE command nor the RTA SELECT command adhere strictly to their PostgreSQL equivalents. RTA does not allow JOIN clauses, and the WHERE clause supports only the boolean AND operator. There are no locks or transactions.</p>&#13;
<p class="secs"><a id="app1.12"/><a href="toc.html#app1.12"><i><b>The SELECT Command</b></i></a></p>&#13;
<p class="noindent">The prototype for the RTA SELECT command is shown below.</p>&#13;
<p class="ex">SELECT column_list FROM table [where_clause] [limit_clause]</p>&#13;
<p class="indent">Most NCMDCOLS (defined above) columns can be specified in the column_list or in the WHERE clause. The reserved word <i>LIMIT</i> restricts the number of rows returned to the number specified. The reserved word <i>OFFSET</i> skips the number of rows specified and begins output with the next row.</p>&#13;
<p class="indent">A column_list can contain * (a wild card character that represents all columns), a single column name, or a comma-separated list of column names.</p>&#13;
<p class="indent">A sample of the where_clause syntax is shown below:</p>&#13;
<p class="ex2">col_name = value [AND col_name = value ..]</p>&#13;
<p class="indent">In this example, all the col_name = value pairs must match for a row to match. Note that you can use five other comparison operators in addition to equality. The list below shows the six available comparison operators.</p>&#13;
<p class="imgl"><img src="../images/325-2.jpg" alt=""/></p>&#13;
<p class="indent">A sample of the limit_clause syntax is shown below:</p>&#13;
<p class="ex2">LIMIT 5</p>&#13;
<p class="indent">You will find the LIMIT and OFFSET columns to be very useful because they prevent a buffer overflow on the output buffer of dbcommand(). They are also useful for web-based UIs in which users want to be able to view data one page at a time.</p>&#13;
<p class="indent"><a id="page302"/>There are eight reserved words that can not be used as column or table names. The reserved words are <i>AND</i>, <i>FROM</i>, <i>LIMIT</i>, <i>OFFSET</i>, <i>SELECT</i>, <i>SET</i>, <i>UPDATE</i>, and <i>WHERE</i>. These are not case sensitive.</p>&#13;
<p class="indent">Strings may contain any of the following characters:</p>&#13;
<p class="imgl"><img src="../images/326-1.jpg" alt=""/></p>&#13;
<p class="indent">If a string contains a double quote, use a single quote to wrap it. The string below is enclosed in single quotes since the string contains double quotes surrounding the <i>Hi mom!</i> substring.</p>&#13;
<p class="ex2">'The sign says "Hi mom!"'</p>&#13;
<p class="indent">Use double quotes to wrap strings with embedded single quotes.</p>&#13;
<p class="indent">Examples of the SELECT command are shown below.</p>&#13;
<p class="imgl"><img src="../images/326-2.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.13"/><a href="toc.html#app1.13"><i><b>The UPDATE Command</b></i></a></p>&#13;
<p class="noindent">The UPDATE command writes values into a table. The prototype for the RTA UPDATE command is shown below.</p>&#13;
<p class="imgl"><img src="../images/326-3.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page303"/>An UPDATE invokes write callbacks on the affected columns. All data in the UPDATE_list is written before the callbacks are invoked.</p>&#13;
<p class="indent">The LIMIT clause for UPDATE is not standard PostgreSQL, but this clause can be useful for stepping through a table one row at a time. To change only the wth row of a table, use a limit clause like the one below. Note that <i>n</i> is zero indexed.</p>&#13;
<p class="imgl"><img src="../images/327-1.jpg" alt=""/></p>&#13;
<p class="secl"><a id="app1.14"/><a href="toc.html#app1.14"><b>Internal RTA Tables</b></a></p>&#13;
<p class="noindent">When you use the RTA library, your application will include the following four RTA tables.</p>&#13;
<p class="imgc"><img src="../images/327-2.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.15"/><a href="toc.html#app1.15"><i><b>The rta_tables Table</b></i></a></p>&#13;
<p class="noindent">The rta_tables table gives SQL access to all internal and registered tables. The data in the table is exactly the same as the data in the TBLDEF structures registered with the rta_add_table() subroutine. This table is the generic table editor, which is used for application debugging. The columns in the rta_tables table are shown below and correspond to the fields in the RTA_TABLE data structure described above.</p>&#13;
<p class="imgc"><img src="../images/327-3.jpg" alt=""/></p>&#13;
<p class="imgc"><a id="page304"/><img src="../images/328-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="app1.16"/><a href="toc.html#app1.16"><i><b>The rta_columns Table</b></i></a></p>&#13;
<p class="noindent">The rta_columns table lists the column definitions for all the columns in the database. The data in the table is exactly the same as the data in the COLDEF structures registered with the rta_add_table() subroutine. This table is used for the generic table viewer and table editor applications, which are used mostly for application debugging.</p>&#13;
<p class="indent">The columns in the rta_columns table are shown below.</p>&#13;
<p class="imgc"><img src="../images/328-2.jpg" alt=""/></p>&#13;
<p class="secl"><a id="app1.17"/><a href="toc.html#app1.17"><b>Debug Configuration</b></a></p>&#13;
<p class="noindent">The RTA package does not generates any user-level log messages, only debug messages. The rta_dbgconfig table specifies the handling of these debug log messages. All of the fields in this table are volatile. You need to set the values in your main program to make them seem persistent. See the sample SQL string subroutine below.</p>&#13;
<p class="ex2">SQL_string("UPDATE rta_dbgconfig SET target = 3")</p>&#13;
<p class="indent">The columns in the rta_dbgconfig table are shown below.</p>&#13;
<p class="imgc"><img src="../images/328-3.jpg" alt=""/></p>&#13;
<p class="imgc"><a id="page305"/><img src="../images/329-1.jpg" alt=""/></p>&#13;
<p class="secl"><a id="app1.18"/><a href="toc.html#app1.18"><b>Error Messages</b></a></p>&#13;
<p class="noindent">There are two types of error messages available in the RTA package: SQL request messages and internal debug messages.</p>&#13;
<p class="secs"><a id="app1.19"/><a href="toc.html#app1.19"><i><b>SQL Request Errors</b></i></a></p>&#13;
<p class="noindent">SQL request messages include the error messages returned as part of an SQL request. The six messages of this type are listed below.</p>&#13;
<p class="ex2">ERROR: Relation '%s' does not exist</p>&#13;
<p class="indent"><a id="page306"/>This reply indicates that a table requested in a SELECT or UPDATE statement does not exist. The %s is replaced by the name of the requested table.</p>&#13;
<p class="ex2">ERROR: Attribute '%s' not found</p>&#13;
<p class="indent">This reply indicates that a column requested in a SELECT or UPDATE statement does not exist. The %s is replaced by the name of the requested column.</p>&#13;
<p class="ex2">ERROR: SQL parse error</p>&#13;
<p class="indent">This reply indicates a malformed SQL request or a mismatch in the types of data in a where clause or in an UPDATE list.</p>&#13;
<p class="ex2">ERROR: Output buffer full</p>&#13;
<p class="indent">This reply indicates that the size of the response to a request exceeds the size of the output buffer. (See dbcommand() and the out and nout parameters.) This error can be avoided with a large enough output buffer, or, preferably, with the use of LIMIT and OFFSET.</p>&#13;
<p class="ex2">ERROR: String too long for '%s'</p>&#13;
<p class="indent">This reply indicates that an UPDATE to a column of type string or pointer to string would have exceeded the width of the column. The %s is replaced by the column name.</p>&#13;
<p class="ex2">ERROR: Can not UPDATE read-only column '%s'</p>&#13;
<p class="indent">This reply indicates an attempt to UPDATE a column marked as readonly. The %s is replaced by the column name.</p>&#13;
<p class="secs"><a id="app1.20"/><a href="toc.html#app1.20"><i><b>Internal Debug Messages</b></i></a></p>&#13;
<p class="noindent">The RTA program logs internal errors using the standard syslog() facility, which is available on all Linux systems. The default syslog() facility is LOG_USER, but you can change the default by setting facility in the rta_dbg table.</p>&#13;
<p class="indent">You can modify syslogd in order to do post-processing, such as generating SNMP traps from these debug messages. The RTA program sends all internal debug error messages to syslog() in this format:</p>&#13;
<p class="ex2">rta[PID]: FILE LINE#: error_message</p>&#13;
<p class="indent">The RTA program will replace PID, FILE, and LINE# with the process ID, the source filename, and the line number where the error was detected.</p>&#13;
<p class="indent">Here are the definitions used to generate debug and error messages. The RTA program will replace %s %d at the start of each error string with the filename and line number where the error was detected.</p>&#13;
<p class="secls"><b>System Errors</b></p>&#13;
<p class="imgl"><img src="../images/330-1.jpg" alt=""/></p>&#13;
<p class="secls"><b>RTA Errors</b></p>&#13;
<p class="imgl"><a id="page307"/><img src="../images/331-1.jpg" alt=""/></p>&#13;
<p class="secls"><b>SQL Errors</b></p>&#13;
<p class="imgl"><img src="../images/331-2.jpg" alt=""/></p>&#13;
<p class="secls"><b>Trace Messages</b></p>&#13;
<p class="imgc"><img src="../images/331-3.jpg" alt=""/></p>&#13;
<p class="secl"><a id="app1.21"/><a href="toc.html#app1.21"><b>Callback Routines</b></a></p>&#13;
<p class="noindent">As mentioned above, read callbacks are executed before a column value is used, and write callbacks are called after all columns have been UPDATEd. Both read and write callbacks return zero on success and nonzero on error.</p>&#13;
<p class="secs"><a id="app1.22"/><a href="toc.html#app1.22"><i><b>Read Callbacks</b></i></a></p>&#13;
<p class="noindent">Read callbacks have the following calling parameters:</p>&#13;
<p class="imgc"><img src="../images/331-4.jpg" alt=""/></p>&#13;
<p class="indent">Read callbacks are particularly useful for computing values like sums and averages. These values are not worth the effort to compute continuously if it’s possible to compute them only when the values are required.</p>&#13;
<p class="secs"><a id="app1.23"/><a href="toc.html#app1.23"><i><b>Write Callbacks</b></i></a></p>&#13;
<p class="noindent"><a id="page308"/>Write callbacks are most applicable when tied to configuration changes. As such, a write callback is also a good place to log configuration changes.</p>&#13;
<p class="indent">Write callbacks have the same parameters as read callbacks, with the addition of a pointer to a copy of the row before it was modified. Access to a copy of the unmodified row is useful to detect changes in the row’s data. This is useful since some UIs can generate an UPDATE even if nothing actually changed.</p>&#13;
<p class="indent">The callback returns zero on success and nonzero on failure. On failure, the table’s row is restored to its initial values and an SQL error is returned to the client. The returned error is TRIGGERED ACTION EXCEPTION.</p>&#13;
<p class="indent">Write callbacks have the following calling parameters:</p>&#13;
<p class="imgc"><img src="../images/332-1.jpg" alt=""/></p>&#13;
</div>&#13;
</body></html>