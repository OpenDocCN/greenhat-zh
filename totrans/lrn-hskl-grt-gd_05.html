<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Higher-Order Functions"><div class="titlepage"><div><div><h1 class="title"><a id="higher-order_functions"/>Chapter 5. Higher-Order Functions</h1></div></div></div><p>Haskell functions can take functions as parameters and return functions as return values. A function that does either of these things is called a <span class="emphasis"><em>higher-order function</em></span>. Higher-order functions are a really powerful way of solving problems and thinking about programs, and they’re indispensable when using a functional programming language like Haskell.<a id="IDX-CHP-5-0001" class="indexterm"/><a id="IDX-CHP-5-0002" class="indexterm"/><a id="IDX-CHP-5-0003" class="indexterm"/></p><div class="sect1" title="Curried Functions"><div class="titlepage"><div><div><h1 class="title"><a id="curried_functions"/>Curried Functions</h1></div></div></div><p>Every function in Haskell officially takes only one parameter. But we have defined and used several functions that take more than one parameter so far—how is that possible?</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e5783"/><img src="httpatomoreillycomsourcenostarchimages802552.png.jpg" alt="image with no caption"/></div></div><p>Well, it’s a clever trick! All the functions we’ve used so far that accepted multiple parameters have been <span class="emphasis"><em>curried functions</em></span>. A curried function is a function that, instead of taking several parameters, always takes exactly one parameter. Then when it’s called with that parameter, it returns a function that takes the next parameter, and so on.<a id="IDX-CHP-5-0004" class="indexterm"/><a id="IDX-CHP-5-0005" class="indexterm"/><a id="IDX-CHP-5-0006" class="indexterm"/><a id="IDX-CHP-5-0007" class="indexterm"/><a id="IDX-CHP-5-0008" class="indexterm"/></p><p>This is best explained with an example. Let’s take our good friend, the <code class="literal">max</code> function. It looks as if it takes two parameters and returns the one that’s bigger. For instance, consider the expression <code class="literal">max 4 5</code>. We call the function <code class="literal">max</code> with two parameters: <code class="literal">4</code> and <code class="literal">5</code>. First, <code class="literal">max</code> is applied to the value <code class="literal">4</code>. When we apply <code class="literal">max</code> to <code class="literal">4</code>, the value that is returned is actually another function, which is then applied to the value <code class="literal">5</code>. The act of applying this function to <code class="literal">5</code> finally returns a number value. As a consequence, the following two calls are equivalent:<a id="IDX-CHP-5-0009" class="indexterm"/></p><a id="I_programlisting5_d1e5854"/><pre class="programlisting">ghci&gt; max 4 5
5
ghci&gt; (max 4) 5
5</pre><p>To understand how this works, let’s examine the type of the <code class="literal">max</code> function:</p><a id="I_programlisting5_d1e5861"/><pre class="programlisting">ghci&gt; :t max
max :: (Ord a) =&gt; a -&gt; a -&gt; a</pre><p>This can also be written as follows:</p><a id="I_programlisting5_d1e5865"/><pre class="programlisting">max :: (Ord a) =&gt; a -&gt; (a -&gt; a)</pre><p>Whenever we have a type signature that features the arrow <code class="literal">-&gt;</code>, that means it’s a function that takes whatever is on the left side of the arrow and returns a value whose type is indicated on the right side of the arrow. When we have something like <code class="literal">a -&gt; (a -&gt; a)</code>, we’re dealing with a function that takes a value of type <code class="literal">a</code>, and it returns a function that also takes a value of type <code class="literal">a</code> and returns a value of type <code class="literal">a</code>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e5886"/><img src="httpatomoreillycomsourcenostarchimages802554.png.jpg" alt="image with no caption"/></div></div><p>So how is that beneficial to us? Simply speaking, if we call a function with too few parameters, we get back a <span class="emphasis"><em>partially applied</em></span> function, which is a function that takes as many parameters as we left out. For example, when we did <code class="literal">max 4</code>, we got back a function that takes one parameter. Using partial application (calling functions with too few parameters, if you will) is a neat way to create functions on the fly, so we can pass them to other functions.<a id="IDX-CHP-5-0010" class="indexterm"/></p><p>Take a look at this simple little function:</p><a id="I_programlisting5_d1e5906"/><pre class="programlisting">multThree :: Int -&gt; Int -&gt; Int -&gt; Int
multThree x y z = x * y * z</pre><p>What really happens when we call <code class="literal">multThree 3 5 9</code>, or <code class="literal">((multThree 3) 5) 9</code>? First, <code class="literal">multThree</code> is applied to <code class="literal">3</code>, because they’re separated by a space. That creates a function that takes one parameter and returns a function. Then that function is applied to <code class="literal">5</code>, which creates a function that will take one parameter, multiply 3 and 5 together, and then multiply that by the parameter. That function is applied to <code class="literal">9</code>, and the result is 135.<a id="IDX-CHP-5-0011" class="indexterm"/></p><p>You can think of functions as tiny factories that take some materials and produce something. Using that analogy, we feed our <code class="literal">multThree</code> factory the number <code class="literal">3</code>, but instead of producing a number, it churns out a slightly smaller factory. That factory receives the number <code class="literal">5</code> and also spits out a factory. The third factory receives the number <code class="literal">9</code>, and then produces our resulting number, <code class="literal">135</code>.</p><p>Remember that this function’s type can also be written as follows:</p><a id="I_programlisting5_d1e5953"/><pre class="programlisting">multThree :: Int -&gt; (Int -&gt; (Int -&gt; Int))</pre><p>The type (or type variable) before the <code class="literal">-&gt;</code> is the type of the values that a function takes, and the type after it is the type of the values it returns. So our function takes a value of type <code class="literal">Int</code> and returns a function of type <code class="literal">(Int -&gt; (Int -&gt; Int)</code>. Similarly, <span class="emphasis"><em>this</em></span> function takes a value of type <code class="literal">Int</code> and returns a function of type <code class="literal">Int -&gt; Int</code>. And finally, <span class="emphasis"><em>this</em></span> function just takes a value of type <code class="literal">Int</code> and returns another value of type <code class="literal">Int</code>.</p><p>Let’s look at an example of how we can create a new function by calling a function with too few parameters:</p><a id="I_programlisting5_d1e5987"/><pre class="programlisting">ghci&gt; let multTwoWithNine = multThree 9
ghci&gt; multTwoWithNine 2 3
54</pre><p>In this example, the expression <code class="literal">multThree 9</code> results in a function that takes two parameters. We name that function <code class="literal">multTwoWithNine</code>, because <code class="literal">multThree 9</code> is a function that takes two parameters. If both parameters are supplied, it will multiply the two parameters between them, and then multiply that by <code class="literal">9</code>, because we got the <code class="literal">multTwoWithNine</code> function by applying <code class="literal">multThree</code> to <code class="literal">9</code>.</p><p>What if we wanted to create a function that takes an <code class="literal">Int</code> and compares it to <code class="literal">100</code>? We could do something like this:</p><a id="I_programlisting5_d1e6022"/><pre class="programlisting">compareWithHundred :: Int -&gt; Ordering
compareWithHundred x = compare 100 x</pre><p>As an example, let’s try calling the function with <code class="literal">99</code>:</p><a id="I_programlisting5_d1e6029"/><pre class="programlisting">ghci&gt; compareWithHundred 99
GT</pre><p><code class="literal">100</code> is greater than <code class="literal">99</code>, so the function returns <code class="literal">GT</code>, or greater than.<a id="IDX-CHP-5-0012" class="indexterm"/><a id="IDX-CHP-5-0013" class="indexterm"/><a id="IDX-CHP-5-0014" class="indexterm"/><a id="IDX-CHP-5-0015" class="indexterm"/><a id="IDX-CHP-5-0016" class="indexterm"/><a id="IDX-CHP-5-0017" class="indexterm"/><a id="IDX-CHP-5-0018" class="indexterm"/></p><p>Now let’s think about what <code class="literal">compare 100</code> would return: a function that takes a number and compares it with <code class="literal">100</code>, which is exactly what we were trying to get in our example. In other words, the following definition and the previous one are equivalent:</p><a id="I_programlisting5_d1e6079"/><pre class="programlisting">compareWithHundred :: Int -&gt; Ordering
compareWithHundred = compare 100</pre><p>The type declaration stays the same, because <code class="literal">compare 100</code> returns a function. <code class="literal">compare</code> has a type of <code class="literal">(Ord a) =&gt; a -&gt; (a -&gt; Ordering)</code>. When we apply it to <code class="literal">100</code>, we get a function that takes a number and returns an <code class="literal">Ordering</code>.</p><div class="sect2" title="Sections"><div class="titlepage"><div><div><h2 class="title"><a id="sections"/>Sections</h2></div></div></div><p>Infix functions can also be partially applied by using <span class="emphasis"><em>sections</em></span>. To section an infix function, simply surround it with parentheses and supply a parameter on only one side. That creates a function that takes one parameter and then applies it to the side that’s missing an operand. Here’s an insultingly trivial example:</p><a id="I_programlisting5_d1e6106"/><pre class="programlisting">divideByTen :: (Floating a) =&gt; a -&gt; a
divideByTen = (/10)</pre><p>As you can see in the following code, calling <code class="literal">divideByTen 200</code> is equivalent to calling <code class="literal">200 / 10</code> or <code class="literal">(/10) 200</code>:</p><a id="I_programlisting5_d1e6119"/><pre class="programlisting">ghci&gt; divideByTen 200
20.0
ghci&gt; 200 / 10
20.0
ghci&gt; (/10) 200
20.0</pre><p>Let’s look at another example. This function checks if a character supplied to it is an uppercase letter:</p><a id="I_programlisting5_d1e6123"/><pre class="programlisting">isUpperAlphanum :: Char -&gt; Bool
isUpperAlphanum = (`elem` ['A'..'Z'])</pre><p>The only thing to watch out for with sections is when you’re using the <code class="literal">-</code> (negative or minus) operator. From the definition of sections, <code class="literal">(-4)</code> would result in a function that takes a number and subtracts 4 from it. However, for convenience, <code class="literal">(-4)</code> means negative four. So if you want to make a function that subtracts 4 from the number it gets as a parameter, you can partially apply the <code class="literal">subtract</code> function like so: <code class="literal">(subtract 4)</code>.</p></div><div class="sect2" title="Printing Functions"><div class="titlepage"><div><div><h2 class="title"><a id="printing_functions"/>Printing Functions</h2></div></div></div><p>So far, we’ve bound our partially applied functions to names and then supplied the remaining parameters to view the results. However, we never tried to print the functions themselves to the terminal. Let’s give that a go then, shall we? What happens if we try entering <code class="literal">multThree 3 4</code> into GHCi, instead of binding it to a name with a <code class="literal">let</code> or passing it to another function?<a id="IDX-CHP-5-0019" class="indexterm"/><a id="IDX-CHP-5-0020" class="indexterm"/><a id="IDX-CHP-5-0021" class="indexterm"/><a id="IDX-CHP-5-0022" class="indexterm"/><a id="IDX-CHP-5-0023" class="indexterm"/></p><a id="I_programlisting5_d1e6176"/><pre class="programlisting">ghci&gt; multThree 3 4
&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from a use of `print' at &lt;interactive&gt;:1:0-12
    Possible fix: add an instance declaration for (Show (a -&gt; a))
    In the expression: print it
    In a 'do' expression: print it</pre><p>GHCi is telling us that the expression produced a function of type <code class="literal">a -&gt; a</code>, but it doesn’t know how to print it to the screen. Functions aren’t instances of the <code class="literal">Show</code> type class, so we can’t get a neat string representation of a function. This is different, for example, than when we enter <code class="literal">1 + 1</code> at the GHCi prompt. In that case, GHCi calculates <code class="literal">2</code> as the result, and then calls <code class="literal">show</code> on <code class="literal">2</code> to get a textual representation of that number. The textual representation of <code class="literal">2</code> is just the string <code class="literal">"2"</code>, which is then printed to the screen.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Make sure you thoroughly understand how curried functions and partial application work, because they’re really important!</p></div></div></div></div>
<div class="sect1" title="Some Higher-Orderism Is in Order"><div class="titlepage"><div><div><h1 class="title"><a id="some_higher-orderism_is_in_order"/>Some Higher-Orderism Is in Order</h1></div></div></div><p>In Haskell, functions can take other functions as parameters, and as you’ve seen, they can also return functions as return values. To demonstrate this concept, let’s write a function that takes a function, and then applies it twice to some value:</p><a id="I_programlisting5_d1e6213"/><pre class="programlisting">applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e6216"/><img src="httpatomoreillycomsourcenostarchimages802556.png" alt="image with no caption"/></div></div><p>Notice the type declaration. For our earlier examples, we didn’t need parentheses when declaring function types, because <code class="literal">-&gt;</code> is naturally right-associative. However, here parentheses are mandatory. They indicate that the first parameter is a function that takes one parameter and returns a value of the same type (<code class="literal">a -&gt; a</code>). The second parameter is something of type <code class="literal">a</code>, and the return value’s type is also <code class="literal">a</code>. Notice that it doesn’t matter what type <code class="literal">a</code> is—it can be <code class="literal">Int</code>, <code class="literal">String</code>, or whatever—but all the values must be the same type.<a id="IDX-CHP-5-0024" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>You now know that under the hood, functions that seem to take multiple parameters are actually taking a single parameter and returning a partially applied function. However, to keep things simple, I’ll continue to say that a given function takes multiple parameters.<a id="IDX-CHP-5-0025" class="indexterm"/><a id="IDX-CHP-5-0026" class="indexterm"/><a id="IDX-CHP-5-0027" class="indexterm"/></p></div><p>The body of the <code class="literal">applyTwice</code> function is very simple. We just use the parameter <code class="literal">f</code> as a function, applying <code class="literal">x</code> to it by separating the <code class="literal">f</code> and <code class="literal">x</code> with a space. We then apply the result to <code class="literal">f</code> again. Here are some examples of the function in action:</p><a id="I_programlisting5_d1e6287"/><pre class="programlisting">ghci&gt; applyTwice (+3) 10
16
ghci&gt; applyTwice (++ " HAHA") "HEY"
"HEY HAHA HAHA"
ghci&gt; applyTwice ("HAHA " ++) "HEY"
"HAHA HAHA HEY"
ghci&gt; applyTwice (multThree 2 2) 9
144
ghci&gt; applyTwice (3:) [1]
[3,3,1]</pre><p>The awesomeness and usefulness of partial application is evident. If our function requires us to pass it a function that takes only one parameter, we can just partially apply a function to the point where it takes only one parameter and then pass it. For instance, the <code class="literal">+</code> function takes two parameters, and in this example, we partially applied it so that it takes only one parameter by using sections.</p><div class="sect2" title="Implementing zipWith"><div class="titlepage"><div><div><h2 class="title"><a id="implementing_zipwith"/>Implementing zipWith</h2></div></div></div><p>Now we’re going to use higher-order programming to implement a really useful function in the standard library called <code class="literal">zipWith</code>. It takes a function and two lists as parameters, and then joins the two lists by applying the function between corresponding elements. Here’s how we’ll implement it:<a id="IDX-CHP-5-0028" class="indexterm"/></p><a id="I_programlisting5_d1e6307"/><pre class="programlisting">zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys</pre><p>First let’s look at the type declaration. The first parameter is a function that takes two arguments and returns one value. They don’t have to be of the same type, but they can be. The second and third parameters are lists, and the final return value is also a list.</p><p>The first list must be a list of type <code class="literal">a</code> values, because the joining function takes <code class="literal">a</code> types as its first argument. The second must be a list of <code class="literal">b</code> types, because the second parameter of the joining function is of type <code class="literal">b</code>. The result is a list of type <code class="literal">c</code> elements.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember that if you’re writing a function (especially a higher-order function), and you’re unsure of the type, you can try omitting the type declaration and checking what Haskell infers it to be by using <code class="literal">:t</code>.<a id="IDX-CHP-5-0029" class="indexterm"/><a id="IDX-CHP-5-0030" class="indexterm"/><a id="IDX-CHP-5-0031" class="indexterm"/></p></div><p>This function is similar to the normal <code class="literal">zip</code> function. The base cases are the same, although there’s an extra argument (the joining function). However, that argument doesn’t matter in the base cases, so we can just use the <code class="literal">_</code> character for it. The function body in the last pattern is also similar to <code class="literal">zip</code>, though instead of doing <code class="literal">(x, y)</code>, it does <code class="literal">f x y</code>.</p><p>Here’s a little demonstration of all the different things our <code class="literal">zipWith'</code> function can do:</p><a id="I_programlisting5_d1e6367"/><pre class="programlisting">ghci&gt; zipWith' (+) [4,2,5,6] [2,6,2,3]
[6,8,7,9]
ghci&gt; zipWith' max [6,3,2,1] [7,3,1,5]
[7,3,2,5]
ghci&gt; zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]
["foo fighters","bar hoppers","baz aldrin"]
ghci&gt; zipWith' (*) (replicate 5 2) [1..]
[2,4,6,8,10]
ghci&gt; zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
[[3,4,6],[9,20,30],[10,12,12]]</pre><p>As you can see, a single higher-order function can be used in very versatile ways.</p></div><div class="sect2" title="Implementing flip"><div class="titlepage"><div><div><h2 class="title"><a id="implementing_flip"/>Implementing flip</h2></div></div></div><p>Now we’ll implement another function in the standard library, called <code class="literal">flip</code>. The <code class="literal">flip</code> function takes a function and returns a function that is like our original function, but with the first two arguments flipped. We can implement it like this:</p><a id="I_programlisting5_d1e6382"/><pre class="programlisting">flip' :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)
flip' f = g
    where g x y = f y x</pre><p>You can see from the type declaration that <code class="literal">flip'</code> takes a function that takes <code class="literal">a</code> and <code class="literal">b</code> types, and returns a function that takes <code class="literal">b</code> and <code class="literal">a</code> types. But because functions are curried by default, the second pair of parentheses actually is not necessary. The arrow <code class="literal">-&gt;</code> is right-associative by default, so <code class="literal">(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code> is the same as <code class="literal">(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code>, which is the same as <code class="literal">(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>. We wrote that <code class="literal">g x y = f y x</code>. If that’s true, then <code class="literal">f y x = g x y</code> must also hold, right? Keeping that in mind, we can define this function in an even simpler manner:</p><a id="I_programlisting5_d1e6420"/><pre class="programlisting">flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip' f y x = f x y</pre><p>In this new version of <code class="literal">flip'</code>, we take advantage of the fact that functions are curried. When we call <code class="literal">flip' f</code> without the parameters <code class="literal">y</code> and <code class="literal">x</code>, it will return an <code class="literal">f</code> that takes those two parameters but calls them flipped.<a id="IDX-CHP-5-0032" class="indexterm"/><a id="IDX-CHP-5-0033" class="indexterm"/><a id="IDX-CHP-5-0034" class="indexterm"/></p><p>Even though flipped functions are usually passed to other functions, we can take advantage of currying when making higher-order functions by thinking ahead and writing what their end result would be if they were fully applied.</p><a id="I_programlisting5_d1e6455"/><pre class="programlisting">ghci&gt; zip [1,2,3,4,5] "hello"
[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
ghci&gt; flip' zip [1,2,3,4,5] "hello"
[('h',1),('e',2),('l',3),('l',4),('o',5)]
ghci&gt; zipWith div [2,2..] [10,8,6,4,2]
[0,0,0,0,1]
ghci&gt; zipWith (flip' div) [2,2..] [10,8,6,4,2]
[5,4,3,2,1]</pre><p>If we <code class="literal">flip'</code> the <code class="literal">zip</code> function, we get a function that is like <code class="literal">zip</code>, except that the items from the first list are placed into the second components of the tuples and vice versa. The <code class="literal">flip' div</code> function takes its second parameter and divides that by its first, so when the numbers <code class="literal">2</code> and <code class="literal">10</code> are passed to <code class="literal">flip' div</code>, the result is the same as using <code class="literal">div 10 2</code>.</p></div></div>
<div class="sect1" title="The Functional Programmer's Toolbox"><div class="titlepage"><div><div><h1 class="title"><a id="the_functional_programmer_apostrophy_s_t"/>The Functional Programmer's Toolbox</h1></div></div></div><p>As functional programmers, we seldom want to operate on just one value. We usually want to take a bunch of numbers, letters, or some other type of data, and transform the set to produce our results. In this section, we’ll look at some useful functions that can help us work with multiple values.</p><div class="sect2" title="The map Function"><div class="titlepage"><div><div><h2 class="title"><a id="the_map_function"/>The map Function</h2></div></div></div><p>The <code class="literal">map</code> function takes a function and a list, and applies that function to every element in the list, producing a new list. Here is its definition:<a id="IDX-CHP-5-0035" class="indexterm"/><a id="IDX-CHP-5-0036" class="indexterm"/></p><a id="I_programlisting5_d1e6507"/><pre class="programlisting">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ [] = []
map f (x:xs) = f x : map f xs</pre><p>The type signature says that <code class="literal">map</code> takes a function from <code class="literal">a</code> to <code class="literal">b</code> and a list of <code class="literal">a</code> values, and returns a list of <code class="literal">b</code> values.</p><p><code class="literal">map</code> is a versatile higher-order function that can be used in many different ways. Here it is in action:</p><a id="I_programlisting5_d1e6530"/><pre class="programlisting">ghci&gt; map (+3) [1,5,3,1,6]
[4,8,6,4,9]
ghci&gt; map (++ "!") ["BIFF", "BANG", "POW"]
["BIFF!","BANG!","POW!"]
ghci&gt; map (replicate 3) [3..6]
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
ghci&gt; map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
[[1,4],[9,16,25,36],[49,64]]
ghci&gt; map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
[1,3,6,2,2]</pre><p>You’ve probably noticed that each of these examples could also be achieved with a list comprehension. For instance, <code class="literal">map (+3) [1,5,3,1,6]</code> is technically the same as <code class="literal">[x+3 | x &lt;- [1,5,3,1,6]]</code>. However, using the <code class="literal">map</code> function tends to make your code much more readable, especially once you start dealing with maps of maps.<a id="IDX-CHP-5-0037" class="indexterm"/><a id="IDX-CHP-5-0038" class="indexterm"/><a id="IDX-CHP-5-0039" class="indexterm"/><a id="IDX-CHP-5-0040" class="indexterm"/></p></div><div class="sect2" title="The filter Function"><div class="titlepage"><div><div><h2 class="title"><a id="the_filter_function"/>The filter Function</h2></div></div></div><p>The <code class="literal">filter</code> function takes a predicate and a list, and returns the list of elements that satisfy that predicate. (Remember that a <span class="emphasis"><em>predicate</em></span> is a function that tells whether something is true or false; that is, a function that returns a Boolean value.) The type signature and implementation look like this:</p><a id="I_programlisting5_d1e6572"/><pre class="programlisting">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter _ [] = []
filter p (x:xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs</pre><p>If <code class="literal">p x</code> evaluates to <code class="literal">True</code>, the element is included in the new list. If it doesn’t evaluate to <code class="literal">True</code>, it isn’t included in the new list.</p><p>Here are some <code class="literal">filter</code> examples:</p><a id="I_programlisting5_d1e6590"/><pre class="programlisting">ghci&gt; filter (&gt;3) [1,5,3,2,1,6,4,3,2,1]
[5,6,4]
ghci&gt; filter (==3) [1,2,3,4,5]
[3]
ghci&gt; filter even [1..10]
[2,4,6,8,10]
ghci&gt; let notNull x = not (null x) in filter notNull
 [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
[[1,2,3],[3,4,5],[2,2]]
ghci&gt; filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
"uagameasadifeent"
ghci&gt; filter (`elem` ['A'..'Z']) "i LAuGh at you bEcause u R all the same"
"LAGER"</pre><p>As with the <code class="literal">map</code> function, all of these examples could also be achieved by using comprehensions and predicates. There’s no set rule for when to use <code class="literal">map</code> and <code class="literal">filter</code> versus using list comprehensions. You just need to decide what’s more readable depending on the code and the context.</p><p>The <code class="literal">filter</code> equivalent of applying several predicates in a list comprehension is either filtering something several times or joining the predicates with the logical <code class="literal">&amp;&amp;</code> function. Here’s an example:</p><a id="I_programlisting5_d1e6611"/><pre class="programlisting">ghci&gt; filter (&lt;15) (filter even [1..20])
[2,4,6,8,10,12,14]</pre><p>In this example, we take the list <code class="literal">[1..20]</code> and filter it so that only even numbers remain. Then we pass that list to <code class="literal">filter (&lt;15)</code> to get rid of numbers 15 and up. Here’s the list comprehension version:</p><a id="I_programlisting5_d1e6621"/><pre class="programlisting">ghci&gt; [x | x &lt;- [1..20], x &lt; 15, even x]
[2,4,6,8,10,12,14]</pre><p>We use a list comprehension where we draw from the list <code class="literal">[1..20]</code>, and then say what conditions need to hold for a number to be in the resulting list.</p><p>Remember our <code class="literal">quicksort</code> function from <a class="xref" href="ch04.html" title="Chapter 4. Hello Recursion!">Chapter 4</a>? We used list comprehensions to filter out the list elements that were less than (or equal to) or greater than the pivot. We can achieve the same functionality in a more readable way by using <code class="literal">filter</code>:</p><a id="I_programlisting5_d1e6639"/><pre class="programlisting">quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerOrEqual = filter (&lt;= x) xs
        larger = filter (&gt; x) xs
    in  quicksort smallerOrEqual ++ [x] ++ quicksort larger</pre></div><div class="sect2" title="More Examples of map and filter"><div class="titlepage"><div><div><h2 class="title"><a id="more_examples_of_map_and_filter"/>More Examples of map and filter</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e6645"/><img src="httpatomoreillycomsourcenostarchimages802558.png.jpg" alt="image with no caption"/></div></div><p>As another example, let’s find the largest number under 100,000 that’s divisible by 3,829. To do that, we’ll just filter a set of possibilities in which we know the solution lies:</p><a id="I_programlisting5_d1e6652"/><pre class="programlisting">largestDivisible :: Integer
largestDivisible = head (filter p [100000,99999..])
    where p x = x `mod` 3829 == 0</pre><p>First, we make a descending list of all numbers less than 100,000. Then we filter it by our predicate. Because the numbers are sorted in a descending manner, the largest number that satisfies our predicate will be the first element of the filtered list. And because we end up using only the head of the filtered list, it doesn’t matter if the filtered list is finite or infinite. Haskell’s laziness causes the evaluation to stop when the first adequate solution is found.</p><p>As our next example, we’ll find the sum of all odd squares that are smaller than 10,000. In our solution, we’ll use the <code class="literal">takeWhile</code> function. This function takes a predicate and a list. Starting at the beginning of the list, it returns the list’s elements as long as the predicate holds true. Once an element is found for which the predicate doesn’t hold true, the function stops and returns the resulting list. For example, to get the first word of a string, we can do the following:<a id="IDX-CHP-5-0041" class="indexterm"/><a id="IDX-CHP-5-0042" class="indexterm"/></p><a id="I_programlisting5_d1e6669"/><pre class="programlisting">ghci&gt; takeWhile (/=' ') "elephants know how to party"
"elephants"</pre><p>To find the sum of all odd squares that are less than 10,000, we begin by mapping the <code class="literal">(^2)</code> function over the infinite list <code class="literal">[1..]</code>. Then we filter this list so we get only the odd elements. Next, using <code class="literal">takeWhile</code>, we take elements from that list only while they are smaller than 10,000. Finally, we get the sum of that list (using the <code class="literal">sum</code> function). We don’t even need to define a function for this example, because we can do it all in one line in GHCi:</p><a id="I_programlisting5_d1e6685"/><pre class="programlisting">ghci&gt; sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))
166650</pre><p>Awesome! We start with some initial data (the infinite list of all natural numbers), and then we map over it, filter it, and cut it until it suits our needs. Finally, we just sum it up!</p><p>We could have also written this example using list comprehensions, like this:</p><a id="I_programlisting5_d1e6692"/><pre class="programlisting">ghci&gt; sum (takeWhile (&lt;10000) [m | m &lt;- [n^2 | n &lt;- [1..]], odd m])
166650</pre><p>For our next problem, we’ll be dealing with Collatz sequences. A <span class="emphasis"><em>Collatz sequence</em></span> (also known as a <span class="emphasis"><em>Collatz chain</em></span>) is defined as follows:<a id="IDX-CHP-5-0043" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Start with any natural number.</p></li><li class="listitem"><p>If the number is 1, stop.</p></li><li class="listitem"><p>If the number is even, divide it by 2.</p></li><li class="listitem"><p>If the number is odd, multiply it by 3 and add 1.</p></li><li class="listitem"><p>Repeat the algorithm with the resulting number.</p></li></ul></div><p>In essence, this gives us a chain of numbers. Mathematicians theorize that for all starting numbers, the chain will finish at the number 1. For example, if we start with the number 13, we get this sequence: 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. (13 × 3 + 1 equals 40. 40 divided by 2 equals 20, and so on.) We can see that the chain that starts with 13 has 10 terms.</p><p>Here is the problem we want to solve: For all starting numbers between 1 and 100, how many Collatz chains have a length greater than 15?<a id="IDX-CHP-5-0044" class="indexterm"/></p><p>Our first step will be to write a function that produces a chain:</p><a id="I_programlisting5_d1e6732"/><pre class="programlisting">chain :: Integer -&gt; [Integer]
chain 1 = [1]
chain n
    | even n =  n:chain (n `div` 2)
    | odd n  =  n:chain (n*3 + 1)</pre><p>This is a pretty standard recursive function. The base case is one, because all our chains will end at one. We can test the function to see if it’s working correctly:</p><a id="I_programlisting5_d1e6736"/><pre class="programlisting">ghci&gt; chain 10
[10,5,16,8,4,2,1]
ghci&gt; chain 1
[1]
ghci&gt; chain 30
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]</pre><p>Now we can write the <code class="literal">numLongChains</code> function, which actually answers our question:</p><a id="I_programlisting5_d1e6743"/><pre class="programlisting">numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs &gt; 15</pre><p>We map the <code class="literal">chain</code> function to <code class="literal">[1..100]</code> to get a list of chains, which are themselves represented as lists. Then we filter them by a predicate that checks whether a list’s length is longer than 15. Once we’ve done the filtering, we see how many chains are left in the resulting list.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>This function has a type of <code class="literal">numLongChains :: Int</code> because <code class="literal">length</code> returns an <code class="literal">Int</code> instead of a <code class="literal">Num a</code>. If we wanted to return a more general <code class="literal">Num a</code>, we could have used <code class="literal">fromIntegral</code> on the resulting length.</p></div></div><div class="sect2" title="Mapping Functions with Multiple Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="mapping_functions_with_multiple_paramete"/>Mapping Functions with Multiple Parameters</h2></div></div></div><p>So far, we’ve mapped functions that take only one parameter (like <code class="literal">map (*2) [0..]</code>). However, we can also map functions that take multiple parameters. For example, we could do something like <code class="literal">map (*) [0..]</code>. In this case, the function <code class="literal">*</code>, which has a type of <code class="literal">(Num a) =&gt; a -&gt; a -&gt; a</code>, is applied to each number in the list.</p><p>As you’ve seen, giving only one parameter to a function that takes two parameters will cause it to return a function that takes one parameter. So if we map <code class="literal">*</code> to the list <code class="literal">[0..]</code>, we will get back a list of functions that take only one parameter.</p><p>Here’s an example:<a id="IDX-CHP-5-0045" class="indexterm"/><a id="IDX-CHP-5-0046" class="indexterm"/><a id="IDX-CHP-5-0047" class="indexterm"/><a id="IDX-CHP-5-0048" class="indexterm"/><a id="IDX-CHP-5-0049" class="indexterm"/><a id="IDX-CHP-5-0050" class="indexterm"/><a id="IDX-CHP-5-0051" class="indexterm"/><a id="IDX-CHP-5-0052" class="indexterm"/><a id="IDX-CHP-5-0053" class="indexterm"/><a id="IDX-CHP-5-0054" class="indexterm"/></p><a id="I_programlisting5_d1e6847"/><pre class="programlisting">ghci&gt; let listOfFuns = map (*) [0..]
ghci&gt; (listOfFuns !! 4) 5
20</pre><p>Getting the element with the index <code class="literal">4</code> from our list returns a function that’s equivalent to <code class="literal">(4*)</code>. Then we just apply <code class="literal">5</code> to that function, which is the same as <code class="literal">(4*) 5</code>, or just <code class="literal">4 * 5</code>.</p></div></div>
<div class="sect1" title="Lambdas"><div class="titlepage"><div><div><h1 class="title"><a id="lambdas"/>Lambdas</h1></div></div></div><p><span class="emphasis"><em>Lambdas</em></span> are anonymous functions that we use when we need a function only once.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e6874"/><img src="httpatomoreillycomsourcenostarchimages802560.png.jpg" alt="image with no caption"/></div></div><p>Normally, we make a lambda with the sole purpose of passing it to a higher-order function. To declare a lambda, we write a <code class="literal">\</code> (because it kind of looks like the Greek letter lambda (λ) if you squint hard enough), and then we write the function’s parameters, separated by spaces. After that comes a <code class="literal">-&gt;</code>, and then the function body. We usually surround lambdas with parentheses.</p><p>In the previous section, we used a <code class="literal">where</code> binding in our <code class="literal">numLongChains</code> function to make the <code class="literal">isLong</code> function for the sole purpose of passing it to <code class="literal">filter</code>. Instead of doing that, we can also use a lambda, like this:</p><a id="I_programlisting5_d1e6901"/><pre class="programlisting">numLongChains :: Int
numLongChains = length (filter (\xs -&gt; length xs &gt; 15) (map chain [1..100]))</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e6904"/><img src="httpatomoreillycomsourcenostarchimages802562.png.jpg" alt="image with no caption"/></div></div><p>Lambdas are expressions, which is why we can just pass them to functions like this. The expression <code class="literal">(\xs -&gt; length xs &gt; 15)</code> returns a function that tells us whether the length of the list passed to it is greater than 15.</p><p>People who don’t understand how currying and partial application work often use lambdas where they are not necessary. For instance, the following expressions are equivalent:</p><a id="I_programlisting5_d1e6916"/><pre class="programlisting">ghci&gt; map (+3) [1,6,3,2]
[4,9,6,5]
ghci&gt; map (\x -&gt; x + 3) [1,6,3,2]
[4,9,6,5]</pre><p>Both <code class="literal">(+3)</code> and <code class="literal">(\x -&gt; x + 3)</code> are functions that take a number and add 3 to it, so these expressions yield the same results. However, we don’t want to make a lambda in this case, because using partial application is much more readable.</p><p>Like normal functions, lambdas can take any number of parameters:</p><a id="I_programlisting5_d1e6929"/><pre class="programlisting">ghci&gt; zipWith (\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
[153.0,61.5,31.0,15.75,6.6]</pre><p>And like normal functions, you can pattern match in lambdas. The only difference is that you can’t define several patterns for one parameter (like making a <code class="literal">[]</code> and a <code class="literal">(x:xs)</code> pattern for the same parameter and then having values fall through).</p><a id="I_programlisting5_d1e6939"/><pre class="programlisting">ghci&gt; map (\(a,b) -&gt; a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
[3,8,9,8,7]</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>If a pattern match fails in a lambda, a runtime error occurs, so be careful!</p></div><p>Let’s look at another interesting example:</p><a id="I_programlisting5_d1e6946"/><pre class="programlisting">addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z

addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree' = \x -&gt; \y -&gt; \z -&gt; x + y + z</pre><p>Due to the way functions are curried by default, these two functions are equivalent. Yet the first <code class="literal">addThree</code> function is far more readable. The second one is little more than a gimmick to illustrate currying.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Notice that in the second example, the lambdas are not surrounded with parentheses. When you write a lambda without parentheses, it assumes that everything to the right of the arrow <code class="literal">-&gt;</code> belongs to it. So in this case, omitting the parentheses saves some typing. Of course, you can include the parentheses if you prefer them.</p></div><p>However, there are times when using the currying notation instead is useful. I think that the <code class="literal">flip</code> function is the most readable when it’s defined like this:</p><a id="I_programlisting5_d1e6964"/><pre class="programlisting">flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip' f = \x y -&gt; f y x</pre><p>Even though this is the same as writing <code class="literal">flip' f x y = f y x</code>, our new notation makes it obvious that this will often be used for producing a new function. The most common use case with <code class="literal">flip</code> is calling it with just the function parameter, or the function parameter and one extra parameter, and then passing the resulting function on to a <code class="literal">map</code> or a <code class="literal">zipWith</code>:<a id="IDX-CHP-5-0055" class="indexterm"/><a id="IDX-CHP-5-0056" class="indexterm"/><a id="IDX-CHP-5-0057" class="indexterm"/><a id="IDX-CHP-5-0058" class="indexterm"/><a id="IDX-CHP-5-0059" class="indexterm"/><a id="IDX-CHP-5-0060" class="indexterm"/><a id="IDX-CHP-5-0061" class="indexterm"/><a id="IDX-CHP-5-0062" class="indexterm"/><a id="IDX-CHP-5-0063" class="indexterm"/><a id="IDX-CHP-5-0064" class="indexterm"/><a id="IDX-CHP-5-0065" class="indexterm"/><a id="IDX-CHP-5-0066" class="indexterm"/></p><a id="I_programlisting5_d1e7032"/><pre class="programlisting">ghci&gt; zipWith (flip (++)) ["love you", "love me"] ["i ", "you "]
["i love you","you love me"]
ghci&gt; map (flip subtract 20) [1,2,3,4]
[19,18,17,16]</pre><p>You can use lambdas this way in your own functions when you want to make it explicit that your functions are meant to be partially applied and then passed on to other functions as a parameter.</p></div>
<div class="sect1" title="I Fold You So"><div class="titlepage"><div><div><h1 class="title"><a id="i_fold_you_so"/>I Fold You So</h1></div></div></div><p>Back when we were dealing with recursion in <a class="xref" href="ch04.html" title="Chapter 4. Hello Recursion!">Chapter 4</a>, many of the recursive functions that operated on lists followed the same pattern. We had a base case for the empty list, we introduced the <code class="literal">x:xs</code> pattern, and then we performed some action involving a single element and the rest of the list. It turns out this is a very common pattern, so the creators of Haskell introduced some useful functions, called <span class="emphasis"><em>folds</em></span>, to encapsulate it. Folds allow you to reduce a data structure (like a list) to a single value.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e7050"/><img src="httpatomoreillycomsourcenostarchimages802564.png.jpg" alt="image with no caption"/></div></div><p>Folds can be used to implement any function where you traverse a list once, element by element, and then return something based on that. Whenever you want to traverse a list to return something, chances are you want a fold.</p><p>A fold takes a <span class="emphasis"><em>binary function</em></span> (one that takes two parameters, such as <code class="literal">+</code> or <code class="literal">div</code>), a starting value (often called the <span class="emphasis"><em>accumulator</em></span>), and a list to fold up.</p><p>Lists can be folded up from the left or from the right. The fold function calls the given binary function, using the accumulator and the first (or last) element of the list as parameters. The resulting value is the new accumulator. Then the fold function calls the binary function again with the new accumulator and the new first (or last) element of the list, resulting in another new accumulator. This repeats until the function has traversed the entire list and reduced it down to a single accumulator value.</p><div class="sect2" title="Left Folds with foldl"><div class="titlepage"><div><div><h2 class="title"><a id="left_folds_with_foldl"/>Left Folds with foldl</h2></div></div></div><p>First, let’s look at the <code class="literal">foldl</code> function. This is called a <span class="emphasis"><em>left fold</em></span>, since it folds the list up from the left side. In this case, the binary function is applied between the starting accumulator and the head of the list. That produces a new accumulator value, and the binary function is called with that value and the next element, and so on.<a id="IDX-CHP-5-0067" class="indexterm"/><a id="IDX-CHP-5-0068" class="indexterm"/><a id="IDX-CHP-5-0069" class="indexterm"/><a id="IDX-CHP-5-0070" class="indexterm"/><a id="IDX-CHP-5-0071" class="indexterm"/></p><p>Let’s implement the <code class="literal">sum</code> function again, this time using a fold instead of explicit recursion:</p><a id="I_programlisting5_d1e7108"/><pre class="programlisting">sum' :: (Num a) =&gt; [a] -&gt; a
sum' xs = foldl (\acc x -&gt; acc + x) 0 xs</pre><p>Now we can test it:</p><a id="I_programlisting5_d1e7112"/><pre class="programlisting">ghci&gt; sum' [3,5,2,1]
11</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e7115"/><img src="httpatomoreillycomsourcenostarchimages802566.png.jpg" alt="image with no caption"/></div></div><p>Let’s take an in-depth look at how this fold happens. <code class="literal">\acc x -&gt; acc + x</code> is the binary function. <code class="literal">0</code> is the starting value, and <code class="literal">xs</code> is the list to be folded up. First, <code class="literal">0</code> and <code class="literal">3</code> are passed to the binary function as the <code class="literal">acc</code> and <code class="literal">x</code> parameters, respectively. In this case, the binary function is simply an addition, so the two values are added, which produces <code class="literal">3</code> as the new accumulator value. Next, <code class="literal">3</code> and the next list value (<code class="literal">5</code>) are passed to the binary function, and they are added together to produce <code class="literal">8</code> as the new accumulator value. In the same way, <code class="literal">8</code> and <code class="literal">2</code> are added together to produce <code class="literal">10</code>, and then <code class="literal">10</code> and <code class="literal">1</code> are added together to produce the final value of <code class="literal">11</code>. Congratulations, you’ve folded your first list!</p><p>The diagram on the left illustrates how a fold happens, step by step. The number that’s on the left side of the <code class="literal">+</code> is the accumulator value. You can see how the list is consumed up from the left side by the accumulator. (Om nom nom nom!) If we take into account that functions are curried, we can write this implementation even more succinctly, like so:</p><a id="I_programlisting5_d1e7180"/><pre class="programlisting">sum' :: (Num a) =&gt; [a] -&gt; a
sum' = foldl (+) 0</pre><p>The lambda function <code class="literal">(\acc x -&gt; acc + x)</code> is the same as <code class="literal">(+)</code>. We can omit the <code class="literal">xs</code> as the parameter because calling <code class="literal">foldl (+) 0</code> will return a function that takes a list. Generally, if you have a function like <code class="literal">foo a = bar b a</code>, you can rewrite it as <code class="literal">foo = bar b</code> because of currying.</p></div><div class="sect2" title="Right Folds with foldr"><div class="titlepage"><div><div><h2 class="title"><a id="right_folds_with_foldr"/>Right Folds with foldr</h2></div></div></div><p>The right fold function, <code class="literal">foldr</code>, is similar to the left fold, except the accumulator eats up the values from the right. Also, the order of the parameters in the right fold’s binary function is reversed: The current list value is the first parameter, and the accumulator is the second. (It makes sense that the right fold has the accumulator on the right, since it folds from the right side.)<a id="IDX-CHP-5-0072" class="indexterm"/><a id="IDX-CHP-5-0073" class="indexterm"/><a id="IDX-CHP-5-0074" class="indexterm"/><a id="IDX-CHP-5-0075" class="indexterm"/><a id="IDX-CHP-5-0076" class="indexterm"/></p><p>The accumulator value (and hence, the result) of a fold can be of any type. It can be a number, a Boolean, or even a new list. As an example, let’s implement the <code class="literal">map</code> function with a right fold. The accumulator will be a list, and we’ll be accumulating the mapped list element by element. Of course, our starting element will need to be an empty list:</p><a id="I_programlisting5_d1e7235"/><pre class="programlisting">map' :: (a -&gt; b) -&gt; [a] -&gt; [b]
map' f xs = foldr (\x acc -&gt; f x : acc) [] xs</pre><p>If we’re mapping <code class="literal">(+3)</code> to <code class="literal">[1,2,3]</code>, we approach the list from the right side. We take the last element, which is <code class="literal">3</code>, and apply the function to it, which gives <code class="literal">6</code>. Then we prepend it to the accumulator, which was <code class="literal">[]</code>. <code class="literal">6:[]</code> is <code class="literal">[6]</code>, so that’s now the accumulator. We then apply <code class="literal">(+3)</code> to <code class="literal">2</code>, yielding <code class="literal">5</code>, and prepend (<code class="literal">:</code>) that to the accumulator. Our new accumulator value is now <code class="literal">[5,6]</code>. We then apply <code class="literal">(+3)</code> to <code class="literal">1</code> and prepend the result to the accumulator again, giving a final result of <code class="literal">[4,5,6]</code>.</p><p>Of course, we could have implemented this function with a left fold instead, like this:</p><a id="I_programlisting5_d1e7288"/><pre class="programlisting">map' :: (a -&gt; b) -&gt; [a] -&gt; [b]
map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</pre><p>However, the <code class="literal">++</code> function is much slower than <code class="literal">:</code>, so we usually use right folds when we’re building up new lists from a list.</p><p>One big difference between the two types of folds is that right folds work on infinite lists, whereas left ones don’t!</p><p>Let’s implement one more function with a right fold. As you know, the <code class="literal">elem</code> function checks whether a value is part of a list. Here’s how we can use <code class="literal">foldr</code> to implement it:</p><a id="I_programlisting5_d1e7308"/><pre class="programlisting">elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
elem' y ys = foldr (\x acc -&gt; if x == y then True else acc) False ys</pre><p>Here, the accumulator is a Boolean value. (Remember that the type of the accumulator value and the type of the end result are always the same when dealing with folds.) We start with a value of <code class="literal">False</code>, since we’re assuming the value isn’t in the list to begin with. This also gives us the correct value if we call it on the empty list, since calling a fold on an empty list just returns the starting value.</p><p>Next, we check if the current element is the element we want. If it is, we set the accumulator to <code class="literal">True</code>. If it’s not, we just leave the accumulator unchanged. If it was <code class="literal">False</code> before, it stays that way because this current element is not the one we’re seeking. If it was <code class="literal">True</code>, it stays that way as the rest of the list is folded up.<a id="IDX-CHP-5-0077" class="indexterm"/><a id="IDX-CHP-5-0078" class="indexterm"/><a id="IDX-CHP-5-0079" class="indexterm"/><a id="IDX-CHP-5-0080" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e7344"/><img src="httpatomoreillycomsourcenostarchimages802568.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="The foldl and foldr1 Functions"><div class="titlepage"><div><div><h2 class="title"><a id="the_foldl_and_foldr1_functions"/>The foldl and foldr1 Functions</h2></div></div></div><p>The <code class="literal">foldl1</code> and <code class="literal">foldr1</code> functions work much like <code class="literal">foldl</code> and <code class="literal">foldr</code>, except that you don’t need to provide them with an explicit starting accumulator. They assume the first (or last) element of the list to be the starting accumulator, and then start the fold with the element next to it. With that in mind, the <code class="literal">maximum</code> function can be implemented like so:</p><a id="I_programlisting5_d1e7369"/><pre class="programlisting">maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' = foldl1 max</pre><p>We implemented <code class="literal">maximum</code> by using a <code class="literal">foldl1</code>. Instead of providing a starting accumulator, <code class="literal">foldl1</code> just assumes the first element as the starting accumulator and moves on to the second one. So all <code class="literal">foldl1</code> needs is a binary function and a list to fold up! We start at the beginning of the list and then compare each element with the accumulator. If it’s greater than our accumulator, we keep it as the new accumulator; otherwise, we keep the old one. We passed <code class="literal">max</code> to <code class="literal">foldl1</code> as the binary function because it does exactly that: takes two values and returns the one that’s larger. By the time we’ve finished folding our list, only the largest element remains.</p><p>Because they depend on the lists they’re called with having at least one element, these functions cause runtime errors if called with empty lists. <code class="literal">foldl</code> and <code class="literal">foldr</code>, on the other hand, work fine with empty lists.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When making a fold, think about how it acts on an empty list. If the function doesn’t make sense when given an empty list, you can probably use a <code class="literal">foldl1</code> or <code class="literal">foldr1</code> to implement it.</p></div></div><div class="sect2" title="Some Fold Examples"><div class="titlepage"><div><div><h2 class="title"><a id="some_fold_examples"/>Some Fold Examples</h2></div></div></div><p>To demonstrate how powerful folds are, let’s implement some standard library functions using folds. First, we’ll write our own version of <code class="literal">reverse</code>:</p><a id="I_programlisting5_d1e7417"/><pre class="programlisting">reverse' :: [a] -&gt; [a]
reverse' = foldl (\acc x -&gt; x : acc) []</pre><p>Here, we reverse a list by using the empty list as a starting accumulator and then approaching our original list from the left and placing the current element at the start of the accumulator.</p><p>The function <code class="literal">\acc x -&gt; x : acc</code> is just like the <code class="literal">:</code> function, except that the parameters are flipped. That’s why we could have also written <code class="literal">reverse'</code> like so:<a id="IDX-CHP-5-0081" class="indexterm"/><a id="IDX-CHP-5-0082" class="indexterm"/><a id="IDX-CHP-5-0083" class="indexterm"/></p><a id="I_programlisting5_d1e7447"/><pre class="programlisting">reverse' :: [a] -&gt; [a]
reverse' = foldl (flip (:)) []</pre><p>Next, we’ll implement <code class="literal">product</code>:</p><a id="I_programlisting5_d1e7454"/><pre class="programlisting">product' :: (Num a) =&gt; [a] -&gt; a
product' = foldl (*) 1</pre><p>To calculate the product of all the numbers in the list, we start with <code class="literal">1</code> as the accumulator. Then we fold left with the <code class="literal">*</code> function, multiplying each element with the accumulator.</p><p>Now we’ll implement <code class="literal">filter</code>:</p><a id="I_programlisting5_d1e7469"/><pre class="programlisting">filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter' p = foldr (\x acc -&gt; if p x then x : acc else acc) []</pre><p>Here, we use an empty list as the starting accumulator. Then we fold from the right and inspect each element. <code class="literal">p</code> is our predicate. If <code class="literal">p x</code> is <code class="literal">True</code>—meaning that if the predicate holds for the current element—we put it at the beginning of the accumulator. Otherwise, we just reuse our old accumulator.</p><p>Finally, we’ll implement <code class="literal">last</code>:</p><a id="I_programlisting5_d1e7488"/><pre class="programlisting">last' :: [a] -&gt; a
last' = foldl1 (\_ x -&gt; x)</pre><p>To get the last element of a list, we use a <code class="literal">foldl1</code>. We start at the first element of the list, and then use a binary function that disregards the accumulator and always sets the current element as the new accumulator. Once we’ve reached the end, the accumulator—that is, the last element—will be returned.</p></div><div class="sect2" title="Another Way to Look at Folds"><div class="titlepage"><div><div><h2 class="title"><a id="another_way_to_look_at_folds"/>Another Way to Look at Folds</h2></div></div></div><p>Another way to picture right and left folds is as successive applications of some function to elements in a list. Say we have a right fold, with a binary function <code class="literal">f</code> and a starting accumulator <code class="literal">z</code>. When we right fold over the list <code class="literal">[3,4,5,6]</code>, we’re essentially doing this:</p><a id="I_programlisting5_d1e7509"/><pre class="programlisting">f 3 (f 4 (f 5 (f 6 z)))</pre><p><code class="literal">f</code> is called with the last element in the list and the accumulator, then that value is given as the accumulator to the next-to-last value, and so on.</p><p>If we take <code class="literal">f</code> to be <code class="literal">+</code> and the starting accumulator value to be <code class="literal">0</code>, we’re doing this:<a id="IDX-CHP-5-0084" class="indexterm"/><a id="IDX-CHP-5-0085" class="indexterm"/><a id="IDX-CHP-5-0086" class="indexterm"/><a id="IDX-CHP-5-0087" class="indexterm"/><a id="IDX-CHP-5-0088" class="indexterm"/><a id="IDX-CHP-5-0089" class="indexterm"/></p><a id="I_programlisting5_d1e7553"/><pre class="programlisting">3 + (4 + (5 + (6 + 0)))</pre><p>Or if we write <code class="literal">+</code> as a prefix function, we’re doing this:</p><a id="I_programlisting5_d1e7560"/><pre class="programlisting">(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))</pre><p>Similarly, doing a left fold over that list with <code class="literal">g</code> as the binary function and <code class="literal">z</code> as the accumulator is the equivalent of this:</p><a id="I_programlisting5_d1e7570"/><pre class="programlisting">g (g (g (g z 3) 4) 5) 6</pre><p>If we use <code class="literal">flip (:)</code> as the binary function and <code class="literal">[]</code> as the accumulator (so we’re reversing the list), that’s the equivalent of the following:</p><a id="I_programlisting5_d1e7581"/><pre class="programlisting">flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6</pre><p>And sure enough, if you evaluate that expression, you get <code class="literal">[6,5,4,3]</code>.</p></div><div class="sect2" title="Folding Infinite Lists"><div class="titlepage"><div><div><h2 class="title"><a id="folding_infinite_lists"/>Folding Infinite Lists</h2></div></div></div><p>Viewing folds as successive function applications on values of a list can give you insight as to why <code class="literal">foldr</code> sometimes works perfectly fine on infinite lists. Let’s implement the <code class="literal">and</code> function with a <code class="literal">foldr</code>, and then write it out as a series of successive function applications, as we did with our previous examples. You’ll see how <code class="literal">foldr</code> works with Haskell’s laziness to operate on lists that have infinite length.</p><p>The <code class="literal">and</code> function takes a list of <code class="literal">Bool</code> values and returns <code class="literal">False</code> if one or more elements are <code class="literal">False</code>; otherwise, it returns <code class="literal">True</code>. We’ll approach the list from the right and use <code class="literal">True</code> as the starting accumulator. We’ll use <code class="literal">&amp;&amp;</code> as the binary function, because we want to end up with <code class="literal">True</code> only if all the elements are <code class="literal">True</code>. The <code class="literal">&amp;&amp;</code> function returns <code class="literal">False</code> if either of its parameters is <code class="literal">False</code>, so if we come across an element in the list that is <code class="literal">False</code>, the accumulator will be set as <code class="literal">False</code> and the final result will also be <code class="literal">False</code>, even if all the remaining elements are <code class="literal">True</code>:</p><a id="I_programlisting5_d1e7658"/><pre class="programlisting">and' :: [Bool] -&gt; Bool
and' xs = foldr (&amp;&amp;) True xs</pre><p>Knowing how <code class="literal">foldr</code> works, we see that the expression <code class="literal">and' [True,False,True]</code> will be evaluated like this:</p><a id="I_programlisting5_d1e7668"/><pre class="programlisting">True &amp;&amp; (False &amp;&amp; (True &amp;&amp; True))</pre><p>The last <code class="literal">True</code> represents our starting accumulator, whereas the first three <code class="literal">Bool</code> values are from the list <code class="literal">[True,False,True]</code>. If we try to evaluate the previous expression, we will get <code class="literal">False</code>.<a id="IDX-CHP-5-0090" class="indexterm"/><a id="IDX-CHP-5-0091" class="indexterm"/><a id="IDX-CHP-5-0092" class="indexterm"/><a id="IDX-CHP-5-0093" class="indexterm"/><a id="IDX-CHP-5-0094" class="indexterm"/></p><p>Now what if we try this with an infinite list, say <code class="literal">repeat False</code>, which has an infinite number of elements, all of which are <code class="literal">False</code>? If we write that out, we get something like this:</p><a id="I_programlisting5_d1e7714"/><pre class="programlisting">False &amp;&amp; (False &amp;&amp; (False &amp;&amp; (False ...</pre><p>Haskell is lazy, so it will compute only what it really must. And the <code class="literal">&amp;&amp;</code> function works in such a way that if its first parameter is <code class="literal">False</code>, it disregards its second parameter, because the <code class="literal">&amp;&amp;</code> function returns <code class="literal">True</code> only if both of its parameters are <code class="literal">True</code>:</p><a id="I_programlisting5_d1e7733"/><pre class="programlisting">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
True &amp;&amp; x = x False &amp;&amp; _ = False</pre><p>In the case of the endless list of <code class="literal">False</code> values, the second pattern matches, and <code class="literal">False</code> is returned without Haskell needing to evaluate the rest of the infinite list:</p><a id="I_programlisting5_d1e7744"/><pre class="programlisting">ghci&gt; and' (repeat False)
False</pre><p><code class="literal">foldr</code> will work on infinite lists when the binary function that we’re passing to it doesn’t always need to evaluate its second parameter to give us some sort of answer. For instance, <code class="literal">&amp;&amp;</code> doesn’t care what its second parameter is if its first parameter is <code class="literal">False</code>.</p></div><div class="sect2" title="Scans"><div class="titlepage"><div><div><h2 class="title"><a id="scans"/>Scans</h2></div></div></div><p>The <code class="literal">scanl</code> and <code class="literal">scanr</code> functions are like <code class="literal">foldl</code> and <code class="literal">foldr</code>, except they report all the intermediate accumulator states in the form of a list. The <code class="literal">scanl1</code> and <code class="literal">scanr1</code> functions are analogous to <code class="literal">foldl1</code> and <code class="literal">foldr1</code>. Here are some examples of these functions in action:</p><a id="I_programlisting5_d1e7786"/><pre class="programlisting">ghci&gt; scanl (+) 0 [3,5,2,1]
[0,3,8,10,11]
ghci&gt; scanr (+) 0 [3,5,2,1]
[11,8,3,1,0]
ghci&gt; scanl1 (\acc x -&gt; if x &gt; acc then x else acc) [3,4,5,3,7,9,2,1]
[3,4,5,5,7,9,9,9]
ghci&gt; scanl (flip (:)) [] [3,2,1]
[[],[3],[2,3],[1,2,3]]</pre><p>When using a <code class="literal">scanl</code>, the final result will be in the last element of the resulting list. <code class="literal">scanr</code> will place the result in the head of the list.</p><p>Scans are used to monitor the progress of a function that can be implemented as a fold. As an exercise in using scans, let’s try answering this question: How many elements does it take for the sum of the square roots of all natural numbers to exceed 1,000?<a id="IDX-CHP-5-0095" class="indexterm"/><a id="IDX-CHP-5-0096" class="indexterm"/><a id="IDX-CHP-5-0097" class="indexterm"/><a id="IDX-CHP-5-0098" class="indexterm"/><a id="IDX-CHP-5-0099" class="indexterm"/></p><p>To get the square roots of all natural numbers, we just call <code class="literal">map sqrt [1..]</code>. To get the sum, we could use a fold. However, because we’re interested in how the sum progresses, we’ll use a scan instead. Once we’ve done the scan, we can check how many sums are under 1,000.</p><a id="I_programlisting5_d1e7820"/><pre class="programlisting">sqrtSums :: Int
sqrtSums = length (takeWhile (&lt;1000) (scanl1 (+) (map sqrt [1..]))) + 1</pre><p>We use <code class="literal">takeWhile</code> here instead of <code class="literal">filter</code> because <code class="literal">filter</code> wouldn’t cut off the resulting list once a number that’s equal to or over 1,000 is found; it would keep searching. Even though we know the list is ascending, <code class="literal">filter</code> doesn’t, so we use <code class="literal">takeWhile</code> to cut off the scan list at the first occurrence of a sum greater than 1,000.</p><p>The first sum in the scan list will be 1. The second will be 1 plus the square root of 2. The third will be that plus the square root of 3. If there are <span class="emphasis"><em>x</em></span> sums under 1,000, then it takes <span class="emphasis"><em>x</em></span>+1 elements for the sum to exceed 1,000:</p><a id="I_programlisting5_d1e7847"/><pre class="programlisting">ghci&gt; sqrtSums
131
ghci&gt; sum (map sqrt [1..131])
1005.0942035344083
ghci&gt; sum (map sqrt [1..130])
993.6486803921487</pre><p>And behold, our answer is correct! If we sum the first 130 square roots, the result is just below 1,000, but if we add another one to that, we go over our threshold.</p></div></div>
<div class="sect1" title="Function Application with $"><div class="titlepage"><div><div><h1 class="title"><a id="function_application_with_dollar"/>Function Application with $</h1></div></div></div><p>Now we’ll look at the <code class="literal">$</code> function, also called the <span class="emphasis"><em>function application operator</em></span>. First, let’s see how it’s defined:</p><a id="I_programlisting5_d1e7862"/><pre class="programlisting">($) :: (a -&gt; b) -&gt; a -&gt; b
f $ x = f x</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e7865"/><img src="httpatomoreillycomsourcenostarchimages802570.png.jpg" alt="image with no caption"/></div></div><p>What the heck? What is this useless function? It’s just function application! Well, that’s almost true, but not quite. Whereas normal function application (putting a space between two things) has a really high precedence, the <code class="literal">$</code> function has the lowest precedence. Function application with a space is left-associative (so <code class="literal">f a b c</code> is the same as <code class="literal">((f a) b) c</code>), while function application with <code class="literal">$</code> is right-associative.</p><p>So how does this help us? Most of the time, it’s a convenience function that lets us write fewer parentheses. For example, consider the expression <code class="literal">sum (map sqrt [1..130])</code>. Because <code class="literal">$</code> has such a low precedence, we can rewrite that expression as <code class="literal">sum $ map sqrt [1..130]</code>. When a <code class="literal">$</code> is encountered, the expression on its right is applied as the parameter to the function on its left.<a id="IDX-CHP-5-0100" class="indexterm"/><a id="IDX-CHP-5-0101" class="indexterm"/><a id="IDX-CHP-5-0102" class="indexterm"/><a id="IDX-CHP-5-0103" class="indexterm"/></p><p>How about <code class="literal">sqrt 3 + 4 + 9</code>? This adds together 9, 4, and the square root of 3. However, if we wanted the square root of 3 + 4 + 9, we would need to write <code class="literal">sqrt (3 + 4 + 9)</code>. With <code class="literal">$</code>, we can also write this as <code class="literal">sqrt $ 3 + 4 + 9</code>. You can imagine <code class="literal">$</code> as almost being the equivalent of writing an opening parenthesis and then writing a closing parenthesis on the far right side of the expression.</p><p>Let’s look at another example:</p><a id="I_programlisting5_d1e7934"/><pre class="programlisting">ghci&gt; sum (filter (&gt; 10) (map (*2) [2..10]))
80</pre><p>Whoa, that’s a lot of parentheses! It looks kind of ugly. Here, <code class="literal">(*2)</code> is mapped onto <code class="literal">[2..10]</code>, then we filter the resulting list to keep only those numbers that are larger than <code class="literal">10</code>, and finally those numbers are added together.</p><p>We can use the <code class="literal">$</code> function to rewrite our previous example and make it a little easier on the eyes:</p><a id="I_programlisting5_d1e7953"/><pre class="programlisting">ghci&gt; sum $ filter (&gt; 10) (map (*2) [2..10])
80</pre><p>The <code class="literal">$</code> function is right-associative, meaning that something like <code class="literal">f $ g $ x</code> is equivalent to <code class="literal">f $ (g $ x)</code>. With that in mind, the preceding example can once again be rewritten as follows:</p><a id="I_programlisting5_d1e7966"/><pre class="programlisting">ghci&gt; sum $ filter (&gt; 10) $ map (*2) [2..10]
80</pre><p>Apart from getting rid of parentheses, <code class="literal">$</code> lets us treat function application like just another function. This allows us to, for instance, map function application over a list of functions, like this:</p><a id="I_programlisting5_d1e7973"/><pre class="programlisting">ghci&gt; map ($ 3) [(4+), (10*), (^2), sqrt]
[7.0,30.0,9.0,1.7320508075688772]</pre><p>Here, the function <code class="literal">($ 3)</code> gets mapped over the list. If you think about what the <code class="literal">($ 3)</code> function does, you’ll see that it takes a function and then applies that function to <code class="literal">3</code>. So every function in the list gets applied to <code class="literal">3</code>, which is evident in the result.</p></div>
<div class="sect1" title="Function Composition"><div class="titlepage"><div><div><h1 class="title"><a id="function_composition"/>Function Composition</h1></div></div></div><p>In mathematics, <span class="emphasis"><em>function composition</em></span> is defined like this: (<span class="emphasis"><em>f</em></span> º <span class="emphasis"><em>g</em></span>)(<span class="emphasis"><em>x</em></span>) = <span class="emphasis"><em>f(g(x)</em></span>). This means that composing two functions is the equivalent of calling one function with some value and then calling another function with the result of the first function.<a id="IDX-CHP-5-0104" class="indexterm"/><a id="IDX-CHP-5-0105" class="indexterm"/></p><p>In Haskell, function composition is pretty much the same thing. We do function composition with the <code class="literal">.</code> function, which is defined like this:</p><a id="I_programlisting5_d1e8023"/><pre class="programlisting">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
f . g = \x -&gt; f (g x)</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e8026"/><img src="httpatomoreillycomsourcenostarchimages802572.png.jpg" alt="image with no caption"/></div></div><p>Notice the type declaration. <code class="literal">f</code> must take as its parameter a value that has the same type as <code class="literal">g</code>’s return value. So the resulting function takes a parameter of the same type that <code class="literal">g</code> takes and returns a value of the same type that <code class="literal">f</code> returns. For example, the expression <code class="literal">negate . (* 3)</code> returns a function that takes a number, multiplies it by 3, and then negates it.</p><p>One use for function composition is making functions on the fly to pass to other functions. Sure, we can use lambdas for that, but many times, function composition is clearer and more concise.</p><p>For example, say we have a list of numbers and we want to turn them all into negative numbers. One way to do that would be to get each number’s absolute value and then negate it, like so:</p><a id="I_programlisting5_d1e8052"/><pre class="programlisting">ghci&gt; map (\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]</pre><p>Notice the lambda and how it looks like the result of function composition. Using function composition, we can rewrite that as follows:</p><a id="I_programlisting5_d1e8056"/><pre class="programlisting">ghci&gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]</pre><p>Fabulous! Function composition is right-associative, so we can compose many functions at a time. The expression <code class="literal">f (g (z x))</code> is equivalent to <code class="literal">(f . g . z) x</code>. With that in mind, we can turn something messy, like this:<a id="IDX-CHP-5-0106" class="indexterm"/></p><a id="I_programlisting5_d1e8072"/><pre class="programlisting">ghci&gt; map (\xs -&gt; negate (sum (tail xs))) [[1..5],[3..6],[1..7]]
[-14,-15,-27]</pre><p>into something much cleaner, like this:<a id="IDX-CHP-5-0107" class="indexterm"/><a id="IDX-CHP-5-0108" class="indexterm"/><a id="IDX-CHP-5-0109" class="indexterm"/><a id="IDX-CHP-5-0110" class="indexterm"/><a id="IDX-CHP-5-0111" class="indexterm"/><a id="IDX-CHP-5-0112" class="indexterm"/><a id="IDX-CHP-5-0113" class="indexterm"/></p><a id="I_programlisting5_d1e8103"/><pre class="programlisting">ghci&gt; map (negate . sum . tail) [[1..5],[3..6],[1..7]]
[-14,-15,-27]</pre><p><code class="literal">negate . sum . tail</code> is a function that takes a list, applies the <code class="literal">tail</code> function to it, then applies the <code class="literal">sum</code> function to the result of that, and finally applies <code class="literal">negate</code> to the previous result. So it’s equivalent to the preceding lambda.</p><div class="sect2" title="Function Composition with Multiple Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="function_composition_with_multiple_param"/>Function Composition with Multiple Parameters</h2></div></div></div><p>But what about functions that take several parameters? Well, if we want to use them in function composition, we usually must partially apply them so that each function takes just one parameter. Consider this expression:</p><a id="I_programlisting5_d1e8123"/><pre class="programlisting">sum (replicate 5 (max 6.7 8.9))</pre><p>This expression can be rewritten as follows:</p><a id="I_programlisting5_d1e8127"/><pre class="programlisting">(sum . replicate 5) max 6.7 8.9</pre><p>which is equivalent to this:</p><a id="I_programlisting5_d1e8131"/><pre class="programlisting">sum . replicate 5 $ max 6.7 8.9</pre><p>The function <code class="literal">replicate 5</code> is applied to the result of <code class="literal">max 6.7 8.9</code>, and then <code class="literal">sum</code> is applied to that result. Notice that we partially applied the <code class="literal">replicate</code> function to the point where it takes only one parameter, so that when the result of <code class="literal">max 6.7 8.9</code> gets passed to <code class="literal">replicate 5</code>, the result is a list of numbers, which is then passed to <code class="literal">sum</code>.</p><p>If we want to rewrite an expression with a lot of parentheses using function composition, we can start by first writing out the innermost function and its parameters. Then we put a <code class="literal">$</code> before it and compose all the functions that came before by writing them without their last parameter and putting dots between them. Say we have this expression:</p><a id="I_programlisting5_d1e8162"/><pre class="programlisting">replicate 2 (product (map (*3) (zipWith max [1,2] [4,5])))</pre><p>We can write this as follows:</p><a id="I_programlisting5_d1e8167"/><pre class="programlisting">replicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]</pre><p>How did we turn the first example into the second one? Well, first we look at the function on the far right and its parameters, just before the bunch of closing parentheses. That function is <code class="literal">zipWith max [1,2] [4,5]</code>. We’re going to keep that as it is, so now we have this:</p><a id="I_programlisting5_d1e8174"/><pre class="programlisting">zipWith max [1,2] [4,5]</pre><p>Then we look at which function was applied to <code class="literal">zipWith max [1,2] [4,5]</code> and see that it was <code class="literal">map (*3)</code>. So we put a <code class="literal">$</code> between it and what we had before:</p><a id="I_programlisting5_d1e8187"/><pre class="programlisting">map (*3) $ zipWith max [1,2] [4,5]</pre><p>Now we start the compositions. We check which function was applied to all this, and we see that it was <code class="literal">product</code>, so we compose it with <code class="literal">map (*3)</code>:</p><a id="I_programlisting5_d1e8197"/><pre class="programlisting">product . map (*3) $ zipWith max [1,2] [4,5]</pre><p>And finally, we see that the function <code class="literal">replicate 2</code> was applied to all this, and we can write the expression as follows:</p><a id="I_programlisting5_d1e8204"/><pre class="programlisting">replicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]</pre><p>If the expression ends with three parentheses, chances are that if you translate it into function composition by following this procedure, it will have two composition operators.</p></div><div class="sect2" title="Point-Free Style"><div class="titlepage"><div><div><h2 class="title"><a id="point-free_style"/>Point-Free Style</h2></div></div></div><p>Another common use of function composition is defining functions in the <span class="emphasis"><em>point-free style</em></span>. For example, consider a function we wrote earlier:<a id="IDX-CHP-5-0114" class="indexterm"/><a id="IDX-CHP-5-0115" class="indexterm"/></p><a id="I_programlisting5_d1e8226"/><pre class="programlisting">sum' :: (Num a) =&gt; [a] -&gt; a
sum' xs = foldl (+) 0 xs</pre><p>The <code class="literal">xs</code> is on the far right on both sides of the equal sign. Because of currying, we can omit the <code class="literal">xs</code> on both sides, since calling <code class="literal">foldl (+) 0</code> creates a function that takes a list. In this way, we are writing the function in point-free style:</p><a id="I_programlisting5_d1e8239"/><pre class="programlisting">sum' :: (Num a) =&gt; [a] -&gt; a
sum' = foldl (+) 0</pre><p>As another example, let’s try writing the following function in point-free style:</p><a id="I_programlisting5_d1e8243"/><pre class="programlisting">fn x = ceiling (negate (tan (cos (max 50 x))))</pre><p>We can’t just get rid of the <code class="literal">x</code> on both right sides, since the <code class="literal">x</code> in the function body is surrounded by parentheses. <code class="literal">cos (max 50)</code> wouldn’t make sense—you can’t get the cosine of a function. What we <span class="emphasis"><em>can</em></span> do is express <code class="literal">fn</code> as a composition of functions, like this:</p><a id="I_programlisting5_d1e8262"/><pre class="programlisting">fn = ceiling . negate . tan . cos . max 50</pre><p>Excellent! Many times, a point-free style is more readable and concise, because it makes you think about functions and what kinds of functions composing them results in, instead of thinking about data and how it’s shuffled around. You can take simple functions and use composition as glue to form more complex functions.</p><p>However, if a function is too complex, writing it in point-free style can actually be less readable. For this reason, making long chains of function composition is discouraged. The preferred style is to use <code class="literal">let</code> bindings to give labels to intermediary results or to split the problem into subproblems that are easier for someone reading the code to understand.</p><p>Earlier in the chapter, we solved the problem of finding the sum of all odd squares that are smaller than 10,000. Here’s what the solution looks like when put into a function:</p><a id="I_programlisting5_d1e8274"/><pre class="programlisting">oddSquareSum :: Integer
oddSquareSum = sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))</pre><p>With our knowledge of function composition, we can also write the function like this:</p><a id="I_programlisting5_d1e8278"/><pre class="programlisting">oddSquareSum :: Integer
oddSquareSum = sum . takeWhile (&lt;10000) . filter odd $ map (^2) [1..]</pre><p>It may seem a bit weird at first, but you will get used to this style quickly. There’s less visual noise because we removed the parentheses. When reading this, you can just say that <code class="literal">filter odd</code> is applied to the result of <code class="literal">map (^2) [1..]</code>, then <code class="literal">takeWhile (&lt;10000)</code> is applied to the result of that, and finally <code class="literal">sum</code> is applied to that result.</p></div></div></body></html>