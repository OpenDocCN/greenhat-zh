<html><head></head><body><div class="part" title="Part&#xA0;II.&#xA0;Basic IDA Usage"><div class="titlepage"><div><div><h1 class="title"><a id="basic_ida_usage"/>Part II. Basic IDA Usage</h1></div></div></div><div class="partintro" id="id3141472" title="Basic IDA Usage"><div/><p/></div></div>
<div class="chapter" title="Chapter&#xA0;4.&#xA0;Getting Started with IDA"><div class="titlepage"><div><div><h1 class="title"><a id="getting_started_with_ida"/>Chapter 4. Getting Started with IDA</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id4"/><div class="mediaobject"><a id="I_mediaobject1_d1e3125"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>It’s about time we got down to actually using IDA. The remainder of this book is dedicated to various features of IDA and how you can leverage them to best suit your reverse engineering needs. In this chapter we begin by covering the options you are presented with when you launch IDA, and then we describe just what is happening when you open a binary file for analysis. Finally, we’ll present a quick overview of the user interface to lay the groundwork for the remaining chapters.</p><p>For the sake of standardization, examples in both this chapter and the remainder of the book will be presented with the Windows Qt GUI interface unless an example requires a specific, different version of IDA (such as an example of Linux debugging).</p><div class="sect1" title="Launching IDA"><div class="titlepage"><div><div><h1 class="title"><a id="launching_ida"/>Launching IDA</h1></div></div></div><p>Any time you launch IDA, you will be greeted briefly by a splash screen that displays a summary of your license information. Once the splash screen clears, IDA displays another dialog offering three ways to proceed to its desktop environment, as shown in <a class="xref" href="ch04.html#launching_ida-id1" title="Figure 4-1. Launching IDA">Figure 4-1</a>.<a class="indexterm" id="IDX-CHP-4-0001"/><a class="indexterm" id="IDX-CHP-4-0002"/><a class="indexterm" id="IDX-CHP-4-0003"/><a class="indexterm" id="IDX-CHP-4-0004"/><a class="indexterm" id="IDX-CHP-4-0005"/><a class="indexterm" id="IDX-CHP-4-0006"/><a class="indexterm" id="IDX-CHP-4-0007"/><a class="indexterm" id="IDX-CHP-4-0008"/><a class="indexterm" id="IDX-CHP-4-0009"/><a class="indexterm" id="IDX-CHP-4-0010"/><a class="indexterm" id="IDX-CHP-4-0011"/></p><div class="figure"><a id="launching_ida-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3184"/><img alt="Launching IDA" src="httpatomoreillycomsourcenostarchimages854073.png.jpg"/></div></div><p class="title">Figure 4-1. Launching IDA</p></div><p>If you prefer not to see the welcome message, feel free to uncheck the Display at startup checkbox at the bottom of the dialog. If you check the box, future sessions will begin as if you had clicked the Go button, and you will be taken directly to an empty IDA workspace. If at some point you find yourself longing for the Welcome dialog (after all, it conveniently allows you to return to recently used files), you will need to edit IDA’s registry key to set the <code class="literal">DisplayWelcome</code> value back to <em class="replaceable"><code>1</code></em>. Alternatively, selecting Windows ▸ Reset hidden messages will restore <span class="emphasis"><em>all</em></span> previously hidden messages.<a class="indexterm" id="IDX-CHP-4-0012"/><a class="indexterm" id="IDX-CHP-4-0013"/><a class="indexterm" id="IDX-CHP-4-0014"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>When installed on Windows, IDA creates the following registry key: <code class="literal">HKEY_CURRENT_USER\Software\Hex-Rays\IDA</code>.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-1" id="CHP-4-FN-1">29</a>]</sup> Many options that can be configured within IDA itself (as opposed to editing one of the configuration files) are stored within this registry key. However, on other platforms, IDA stores such values in a binary data file <span class="emphasis"><em>($HOME/.idapro/ida.reg)</em></span> that is not easily edited.</p></div><p>Each of the three options shown in <a class="xref" href="ch04.html#launching_ida-id1" title="Figure 4-1. Launching IDA">Figure 4-1</a> offers a slightly different method to proceed to the IDA desktop. These three launch options are reviewed here:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>New</strong></span></span></dt><dd><p>Choosing New opens a standard File Open dialog to select the file to be analyzed. Following file selection, one or more additional dialogs are displayed that allow you to choose specific file-analysis options before the file is loaded, analyzed, and displayed.<a class="indexterm" id="IDX-CHP-4-0015"/></p></dd><dt><span class="term"><span class="strong"><strong>Go</strong></span></span></dt><dd><p>The Go button terminates the load process and causes IDA to open with an empty workspace. At this point, if you want to open a file, you may drag and drop a binary file onto your IDA desktop, or you may use one of the options from the File menu to open a file. The File ▸ Open command results in a File Open dialog, as described previously. By default, IDA utilizes a <span class="emphasis"><em>known extensions</em></span> filter to limit the view of the File dialog. Make sure that you modify or clear the filter (such as choosing All Files) so that the File dialog correctly displays the file you are interested in opening.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-2" id="CHP-4-FN-2">30</a>]</sup> When you open a file this way, IDA attempts to automatically identify the selected file’s type; however, you should pay careful attention to the Loading dialog to see which loaders have been selected to process the file.<a class="indexterm" id="IDX-CHP-4-0016"/><a class="indexterm" id="IDX-CHP-4-0017"/><a class="indexterm" id="IDX-CHP-4-0018"/><a class="indexterm" id="IDX-CHP-4-0019"/><a class="indexterm" id="IDX-CHP-4-0020"/><a class="indexterm" id="IDX-CHP-4-0021"/><a class="indexterm" id="IDX-CHP-4-0022"/><a class="indexterm" id="IDX-CHP-4-0023"/><a class="indexterm" id="IDX-CHP-4-0024"/><a class="indexterm" id="IDX-CHP-4-0025"/><a class="indexterm" id="IDX-CHP-4-0026"/><a class="indexterm" id="IDX-CHP-4-0027"/><a class="indexterm" id="IDX-CHP-4-0028"/><a class="indexterm" id="IDX-CHP-4-0029"/><a class="indexterm" id="IDX-CHP-4-0030"/><a class="indexterm" id="IDX-CHP-4-0031"/></p></dd><dt><span class="term"><span class="strong"><strong>Previous</strong></span></span></dt><dd><p>You should utilize the Previous button when you wish to open one of the files in the list of recent files that is directly below the Previous button. The list of recently used files is populated with values from the <code class="literal">History</code> subkey of IDA’s Windows registry key (or <span class="emphasis"><em>ida.reg</em></span> on non-Windows platforms). The maximum length of the history list is initially set to 10, but this limit may be raised as high as 100 by editing the appropriate entry in <span class="emphasis"><em>idagui.cfg</em></span> or <span class="emphasis"><em>idatui.cfg</em></span> (see <a class="xref" href="ch11.html" title="Chapter 11. Customizing IDA">Chapter 11</a>). Utilizing the history list is the most convenient option for resuming work on recently used database files.<a class="indexterm" id="IDX-CHP-4-0032"/><a class="indexterm" id="IDX-CHP-4-0033"/></p></dd></dl></div><div class="sect2" title="IDA File Loading"><div class="titlepage"><div><div><h2 class="title"><a id="ida_file_loading"/>IDA File Loading</h2></div></div></div><p>When choosing to open a new file using the File ▸ Open command, you will be presented with the loading dialog shown in <a class="xref" href="ch04.html#the_ida_load_a_new_file_dialog" title="Figure 4-2. The IDA Load a New File dialog">Figure 4-2</a>. IDA generates a list of potential file types and displays that list at the top of the dialog. This list represents the IDA loaders that are best suited for dealing with the selected file. The list is created by executing each of the file loaders in IDA’s <span class="emphasis"><em>loaders</em></span> directory in order to find any loaders<sup>[<a class="footnote" href="#ftn.CHP-4-FN-3" id="CHP-4-FN-3">31</a>]</sup> that recognize the new file. Note that in <a class="xref" href="ch04.html#the_ida_load_a_new_file_dialog" title="Figure 4-2. The IDA Load a New File dialog">Figure 4-2</a>, both the Windows PE loader (<span class="emphasis"><em>pe.ldw</em></span>) and the MS-DOS EXE loader (<span class="emphasis"><em>dos.ldw</em></span>) claim to recognize the selected file. Readers familiar with the PE file format will not be surprised by this, as the PE file format is an extended form of the MS-DOS EXE file format. The last entry in the list, Binary File, will always be present since it is IDA’s default for loading files that it does not recognize, and this provides the lowest-level method for loading any file. When offered the choice of several loaders, it is not a bad initial strategy to simply accept the default selection unless you possess specific information that contradicts IDA’s determination.<a class="indexterm" id="IDX-CHP-4-0034"/></p><div class="figure"><a id="the_ida_load_a_new_file_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3370"/><img alt="The IDA Load a New File dialog" src="httpatomoreillycomsourcenostarchimages854075.png.jpg"/></div></div><p class="title">Figure 4-2. The IDA Load a New File dialog</p></div><p>At times, Binary File will be the only entry that appears in the loader list. In such cases, the implied message is that none of the loaders recognize the chosen file. If you opt to continue the loading process, make sure that you select the processor type in accordance with your understanding of the file contents.<a class="indexterm" id="IDX-CHP-4-0035"/><a class="indexterm" id="IDX-CHP-4-0036"/><a class="indexterm" id="IDX-CHP-4-0037"/><a class="indexterm" id="IDX-CHP-4-0038"/></p><p>The Processor Type drop-down menu allows you to specify which processor module (from IDA’s <span class="emphasis"><em>procs</em></span> directory) should be used during the disassembly process. In most cases, IDA will choose the proper processor based on information that it reads from the executable file’s headers. When IDA can’t properly determine the processor type associated with the file being opened, you will need to manually select a processor type before continuing with the file-loading operation.<a class="indexterm" id="IDX-CHP-4-0039"/></p><p>The Loading Segment and Loading Offset fields are active only when the Binary File input format is chosen in conjunction with an x86 family processor. Since the binary loader is unable to extract any memory layout information, the segment and offset values entered here are combined to form the base address for the loaded file content. Should you forget to specify a base address during the initial loading process, the base address of the IDA image can be modified at any time using the Edit ▸ Segments ▸ Rebase Program command.<a class="indexterm" id="IDX-CHP-4-0040"/></p><p>The Kernel Options buttons provide access to configure the specific disassembly analysis options that IDA will utilize to enhance the recursive-descent process. In the overwhelming majority of cases, the default options provide the best possible disassembly. The IDA help files provide additional information on available kernel options.<a class="indexterm" id="IDX-CHP-4-0041"/></p><p>The Processor Options button provides access to configuration options that apply to the selected processor module. However, processor options are not necessarily available for every processor module. Limited help is available for processor options as these options are very highly dependent on the selected processor module and the programming proficiency of the module’s author.<a class="indexterm" id="IDX-CHP-4-0042"/></p><p>The remaining Options checkboxes are used to gain finer control over the file-loading process. Each of the options is described further in IDA’s help file. The options are not applicable to all input file types, and in most cases, you can rely on the default selections. Specific cases when you may need to modify these options will be covered in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>.<a class="indexterm" id="IDX-CHP-4-0043"/></p></div><div class="sect2" title="Using the Binary File Loader"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_binary_file_loader"/>Using the Binary File Loader</h2></div></div></div><p>When you opt to utilize the binary loader, you need to be prepared to do more than your usual share of the processing work. With no file header information to guide the analysis process, it is up to you to step in and perform tasks that more capable loaders often do automatically. Examples of situations that may call for the use of the binary loader include the analysis of ROM images and exploit payloads that may have been extracted from network packet captures or log files.</p><p>When the x86 processor module is paired with the binary loader, the dialog shown in <a class="xref" href="ch04.html#x86_mode_selection" title="Figure 4-3. x86 mode selection">Figure 4-3</a> will be displayed. With no recognizable file headers available to assist IDA, it is up to the user to specify whether code should be treated as 16-bit or 32-bit mode code. Other processors for which IDA can distinguish between 16- and 32-bit modes include ARM and MIPS.<a class="indexterm" id="IDX-CHP-4-0044"/></p><div class="figure"><a id="x86_mode_selection"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3436"/><img alt="x86 mode selection" src="httpatomoreillycomsourcenostarchimages854077.png.jpg"/></div></div><p class="title">Figure 4-3. x86 mode selection</p></div><p>Binary files contain no information concerning their memory layout (at least no information that IDA knows how to recognize). When an x86 processor type has been selected, base address information must be specified in the loader dialog’s Loading Segment and Loading Offset fields, as mentioned earlier. For all other processor types, IDA displays the memory layout dialog shown in <a class="xref" href="ch04.html#the_memory_organization_dialog" title="Figure 4-4. The Memory Organization dialog">Figure 4-4</a>. As a convenience, you may create a RAM section, a ROM section, or both and designate the address range of each. The Input File options are used to specify which portion of the input file (the default is the entire file) should be loaded and to which address the file content should be mapped.<a class="indexterm" id="IDX-CHP-4-0045"/></p><div class="figure"><a id="the_memory_organization_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3451"/><img alt="The Memory Organization dialog" src="httpatomoreillycomsourcenostarchimages854079.png.jpg"/></div></div><p class="title">Figure 4-4. The Memory Organization dialog</p></div><p><a class="xref" href="ch04.html#binary_file_loading" title="Figure 4-5. Binary file loading">Figure 4-5</a> shows the last step of a binary load—a gentle reminder that you need to do some work. The message highlights the fact that IDA has no header information available to help it distinguish code bytes from data bytes in the binary file. At this point, you are reminded to designate one of the addresses in the file as an entry point by telling IDA to turn the byte(s) at that address into code (C is the hotkey used to force IDA to treat a byte as code). For binary files, IDA will not perform any initial disassembly until you take the time to identify at least one byte as code.<a class="indexterm" id="IDX-CHP-4-0046"/><a class="indexterm" id="IDX-CHP-4-0047"/><a class="indexterm" id="IDX-CHP-4-0048"/><a class="indexterm" id="IDX-CHP-4-0049"/><a class="indexterm" id="IDX-CHP-4-0050"/></p><div class="figure"><a id="binary_file_loading"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3481"/><img alt="Binary file loading" src="httpatomoreillycomsourcenostarchimages854081.png.jpg"/></div></div><p class="title">Figure 4-5. Binary file loading</p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-1" id="ftn.CHP-4-FN-1">29</a>] </sup>Older versions of IDA used <code class="literal">HKEY_CURRENT_USER\Software\Datarescue\IDA</code>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-2" id="ftn.CHP-4-FN-2">30</a>] </sup>On non-Windows systems, it is not uncommon for executable files to have no file extension at all.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-3" id="ftn.CHP-4-FN-3">31</a>] </sup>IDA loaders will be discussed further in <a class="xref" href="ch18.html" title="Chapter 18. Binary Files and IDA Loader Modules">Chapter 18</a>.</p></div></div></div>
<div class="sect1" title="IDA Database Files"><div class="titlepage"><div><div><h1 class="title"><a id="ida_database_files"/>IDA Database Files</h1></div></div></div><p>When you are happy with your loading options and click OK to close the dialog, the real work of loading the file begins. At this point, IDA’s goal is to load the selected executable file into memory and to analyze the relevant portions. This results in the creation of an IDA database whose components are stored in four files, each with a base name matching the selected executable and whose extensions are .<span class="emphasis"><em>id0</em></span>, .<span class="emphasis"><em>id1</em></span>, .<span class="emphasis"><em>nam</em></span>, and .<span class="emphasis"><em>til</em></span>. The .<span class="emphasis"><em>id0</em></span> file contains the content of a B-tree–style database, while the <span class="emphasis"><em>.id1</em></span> file contains flags that describe each program byte. The .<span class="emphasis"><em>nam</em></span> file contains index information related to named program locations as displayed in IDA’s Names window (discussed further in <a class="xref" href="ch05.html" title="Chapter 5. IDA Data Displays">Chapter 5</a>). Finally, the .<span class="emphasis"><em>til</em></span> file is used to store information concerning local type definitions specific to a given database. The formats of each of these files are proprietary to IDA, and they are not easily edited outside of the IDA environment.<a class="indexterm" id="IDX-CHP-4-0051"/><a class="indexterm" id="IDX-CHP-4-0052"/><a class="indexterm" id="IDX-CHP-4-0053"/><a class="indexterm" id="IDX-CHP-4-0054"/><a class="indexterm" id="IDX-CHP-4-0055"/><a class="indexterm" id="IDX-CHP-4-0056"/><a class="indexterm" id="IDX-CHP-4-0057"/><a class="indexterm" id="IDX-CHP-4-0058"/><a class="indexterm" id="IDX-CHP-4-0059"/><a class="indexterm" id="IDX-CHP-4-0060"/><a class="indexterm" id="IDX-CHP-4-0061"/><a class="indexterm" id="IDX-CHP-4-0062"/></p><p>For convenience, these four files are archived, and optionally compressed, into a single IDB file whenever you close your current project. When people refer to an IDA database, they are typically referring to the IDB file. An uncompressed database file is usually 10 times the size of the original input binary file. When the database is closed properly, you should never see files with <span class="emphasis"><em>.id0</em></span>, <span class="emphasis"><em>.id1</em></span>, <span class="emphasis"><em>.nam</em></span>, or <span class="emphasis"><em>.til</em></span> extensions in your working directories. Their presence often indicates that a database was not closed properly (for example, when IDA crashes) and that the database may be corrupt.</p><div class="sidebar"><a id="loader_warnings"/><p class="title">LOADER WARNINGS</p><p>Once a loader begins to analyze a file, it may encounter circumstances that require additional user input in order to complete the loading process. One example of this occurs with PE files that have been created with PDB debugging information. If IDA determines that a <span class="emphasis"><em>Program Database (PDB)</em></span> file may exist, you will be asked whether you want IDA to locate and to process the corresponding PDB file as shown in this message:</p><div class="blockquote"><blockquote class="blockquote"><p>IDA Pro has determined that the input file was linked with debug information. Do you want to look for the corresponding PDB file at the local symbol store and the Microsoft Symbol Server?</p></blockquote></div><p>A second example of a loader-generated informational message occurs with obfuscated programs such as malware. Obfuscation techniques often play fast and loose with file format specifications, which can cause problems for loaders expecting well-structured files. Knowing this, the PE loader performs some validation on import tables, and if the import tables do not seem to be formatted according to convention, IDA will display the following message:</p><div class="blockquote"><blockquote class="blockquote"><p>The imports segment seems to be destroyed. This MAY mean that the file was packed or otherwise modified in order to make it more difficult to analyze. If you want to see the imports segment in the original form, please reload it with the ‘make imports section’ checkbox cleared.</p></blockquote></div><p>Examples of this error and how to deal with it will be covered in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>.</p></div><p>It is important to understand that once a database has been created for a given executable, IDA no longer requires access to that executable unless you intend to use IDA’s integrated debugger to debug the executable itself. From a security standpoint, this is a nice feature. For instance, when you are analyzing a malware sample, you can pass the associated database among analysts without passing along the malicious executable itself. There are no known cases in which an IDA database has been used as an attack vector for malicious software.</p><p>At its heart, IDA is nothing more than a database application. New databases are created and populated automatically from executable files. The various displays that IDA offers are simply views into the database that reveal information in a format useful to the software reverse engineer. Any modifications that users make to the database are reflected in the views and saved with the database, but these changes have no effect on the original executable file. The power of IDA lies in the tools it contains to analyze and manipulate the data within the database.</p><div class="sect2" title="IDA Database Creation"><div class="titlepage"><div><div><h2 class="title"><a id="ida_database_creation"/>IDA Database Creation</h2></div></div></div><p>Once you have chosen a file to analyze and specified your options, IDA initiates the creation of a database. For this process, IDA turns control over to the selected loader module, whose job it is to load the file from disk, parse any file-header information that it may recognize, create various program sections containing either code or data as specified in the file’s headers, and, finally, identify specific entry points into the code before returning control to IDA. In this regard, IDA loader modules behave much as operating system loaders behave. The IDA loader will determine a virtual memory layout based on information contained in the program file headers and configure the database accordingly.<a class="indexterm" id="IDX-CHP-4-0063"/><a class="indexterm" id="IDX-CHP-4-0064"/></p><p>Once the loader has finished, the disassembly engine within IDA takes over and begins passing one address at a time to the selected processor module. The processor module’s job is to determine the type of instruction located at that address, the length of the instruction at that address, and the location(s) at which execution can continue from that address (e.g., is the current instruction sequential or branching?). When IDA is comfortable that it has found all of the instructions in the file, it makes a second pass through the list of instruction addresses and asks the processor module to generate the assembly language version of each instruction for display.</p><p>Following this disassembly, IDA automatically conducts additional analysis of the binary file to extract additional information likely to be useful to the analyst. Users can expect to find some or all of the following information incorporated into the database once IDA completes its initial analysis:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Compiler identification</strong></span></span></dt><dd><p>It is often useful to know what compiler was used to build a piece of software. Identifying the compiler that was used can help us understand function-calling conventions used in a binary as well as determine what libraries the binary may be linked with. When a file is loaded, IDA attempts to identify the compiler that was used to create the input file. If the compiler can be identified, the input file is scanned for sequences of boilerplate code known to be used by that compiler. Such functions are color coded in an effort to reduce the amount of code that needs to be analyzed.</p></dd><dt><span class="term"><span class="strong"><strong>Function argument and local variable identification</strong></span></span></dt><dd><p>Within each identified function (addresses that are targets of call instructions), IDA performs a detailed analysis of the behavior of the stack pointer register in order to both recognize accesses to variables located within the stack and understand the layout of the function’s stack frame.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-4" id="CHP-4-FN-4">32</a>]</sup> Names are automatically generated for such variables based on their use as either local variables within the function or as arguments passed into the function as part of the function call process.<a class="indexterm" id="IDX-CHP-4-0065"/><a class="indexterm" id="IDX-CHP-4-0066"/><a class="indexterm" id="IDX-CHP-4-0067"/><a class="indexterm" id="IDX-CHP-4-0068"/><a class="indexterm" id="IDX-CHP-4-0069"/></p></dd><dt><span class="term"><span class="strong"><strong>Datatype information</strong></span></span></dt><dd><p>Utilizing knowledge of common library functions and their required parameters, IDA adds comments to the database to indicate the locations at which parameters are passed into these functions. These comments save the analyst a tremendous amount of time by providing information that would otherwise need to be retrieved from various application programming interface (API) references.</p></dd></dl></div></div><div class="sect2" title="Closing IDA Databases"><div class="titlepage"><div><div><h2 class="title"><a id="closing_ida_databases"/>Closing IDA Databases</h2></div></div></div><p>Any time you close a database, whether you are closing IDA altogether or simply switching to a different database, you are presented with the Save Database dialog, as shown in <a class="xref" href="ch04s02.html#the_save_database_dialog" title="Figure 4-6. The Save Database dialog">Figure 4-6</a>.<a class="indexterm" id="IDX-CHP-4-0070"/></p><div class="figure"><a id="the_save_database_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3678"/><img alt="The Save Database dialog" src="httpatomoreillycomsourcenostarchimages854083.png.jpg"/></div></div><p class="title">Figure 4-6. The Save Database dialog</p></div><p>If this is the initial save of a newly created database, the new database filename is derived from the input filename by replacing the input extension with the <span class="emphasis"><em>.idb</em></span> extension (e.g., <span class="emphasis"><em>example.exe</em></span> yields a database named <span class="emphasis"><em>example.idb</em></span>). When the input file has no extension, <span class="emphasis"><em>.idb</em></span> is appended to form the name of the database (e.g., <span class="emphasis"><em>httpd</em></span> yields <span class="emphasis"><em>httpd.idb</em></span>). The available save options and their associated implications are summarized in the following list:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Don’t pack database</strong></span></span></dt><dd><p>This option simply flushes changes to the four database component files and closes the desktop <span class="emphasis"><em>without</em></span> creating an IDB file. This option is <span class="emphasis"><em>not recommended</em></span> when closing your databases.</p></dd><dt><span class="term"><span class="strong"><strong>Pack database (Store)</strong></span></span></dt><dd><p>Selecting the Store option results in the four database component files being archived into a single IDB file. Any previous IDB will be overwritten without confirmation. No compression is used with the Store option. Once the IDB file has been created, the four database component files are deleted.<a class="indexterm" id="IDX-CHP-4-0071"/><a class="indexterm" id="IDX-CHP-4-0072"/><a class="indexterm" id="IDX-CHP-4-0073"/><a class="indexterm" id="IDX-CHP-4-0074"/><a class="indexterm" id="IDX-CHP-4-0075"/><a class="indexterm" id="IDX-CHP-4-0076"/><a class="indexterm" id="IDX-CHP-4-0077"/><a class="indexterm" id="IDX-CHP-4-0078"/><a class="indexterm" id="IDX-CHP-4-0079"/><a class="indexterm" id="IDX-CHP-4-0080"/><a class="indexterm" id="IDX-CHP-4-0081"/></p></dd><dt><span class="term"><span class="strong"><strong>Pack database (Deflate)</strong></span></span></dt><dd><p>The Deflate option is identical to the Store option, with the exception that the database component files are compressed within the IDB archive.</p></dd><dt><span class="term"><span class="strong"><strong>Collect garbage</strong></span></span></dt><dd><p>Requesting garbage collection causes IDA to delete any unused memory pages from the database prior to closing it. Select this option in conjunction with Deflate in order to create the smallest possible IDB file. This option is not generally required unless disk space is at a premium.</p></dd><dt><span class="term"><span class="strong"><strong>DON’T SAVE the database</strong></span></span></dt><dd><p>You may wonder why anyone would choose not to save his work. It turns out that this option is the only way to discard changes that you have made to a database since the last time it was saved. When this option is selected, IDA simply deletes the four database component files and leaves any existing IDB file untouched. Using this option is as close as you will get to an undo or revert capability while using IDA.</p></dd></dl></div></div><div class="sect2" title="Reopening a Database"><div class="titlepage"><div><div><h2 class="title"><a id="reopening_a_database"/>Reopening a Database</h2></div></div></div><p>Granted, reopening an existing database doesn’t involve rocket science,<sup>[<a class="footnote" href="#ftn.CHP-4-FN-5" id="CHP-4-FN-5">33</a>]</sup> so you may be wondering why this topic is covered at all. Under ordinary circumstances, returning to work on an existing database is as simple as selecting the database using one of IDA’s file-opening methods. Database files open much faster the second (and subsequent) time around because there is no analysis to perform. As an added bonus, IDA restores your IDA desktop to the same state it was in at the time it was closed.<a class="indexterm" id="IDX-CHP-4-0082"/></p><p>Now for the bad news. Believe or not, IDA crashes on occasion. Whether because of a bug in IDA itself or because of a bug in some bleeding-edge plug-in you have installed, crashes leave open databases in a potentially corrupt state. Once you restart IDA and attempt to reopen the affected database, you are likely to see one of the dialogs shown in <a class="xref" href="ch04s02.html#database_restore_dialog" title="Figure 4-7. Database Restore dialog">Figure 4-7</a> and <a class="xref" href="ch04s02.html#database_repair_dialog" title="Figure 4-8. Database Repair dialog">Figure 4-8</a>.</p><div class="figure"><a id="database_restore_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3810"/><img alt="Database Restore dialog" src="httpatomoreillycomsourcenostarchimages854085.png.jpg"/></div></div><p class="title">Figure 4-7. Database Restore dialog</p></div><p>When IDA crashes, there is no opportunity for IDA to close the active database, and the intermediate database files do not get deleted. If this was not the first time that you were working with a particular database, you may have a situation in which both an IDB file and potentially corrupt intermediate files are present at the same time. The IDB file represents the last-known good state of the database, while the intermediate files contain any changes that may have been made since the last save operation. In this case, you will be offered the choice to revert to the saved version or resume use of the open, potentially corrupt version, as shown in <a class="xref" href="ch04s02.html#database_restore_dialog" title="Figure 4-7. Database Restore dialog">Figure 4-7</a>. Choosing Continue with Unpacked Base by no means guarantees that you will recover your work. The unpacked database is probably in an inconsistent state, which will prompt IDA to offer the dialog shown in <a class="xref" href="ch04s02.html#database_repair_dialog" title="Figure 4-8. Database Repair dialog">Figure 4-8</a>. In this case, IDA itself recommends that you consider restoring from the packed data, so consider yourself warned if you opt to go with a repaired database.<a class="indexterm" id="IDX-CHP-4-0083"/><a class="indexterm" id="IDX-CHP-4-0084"/><a class="indexterm" id="IDX-CHP-4-0085"/><a class="indexterm" id="IDX-CHP-4-0086"/><a class="indexterm" id="IDX-CHP-4-0087"/></p><div class="figure"><a id="database_repair_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3843"/><img alt="Database Repair dialog" src="httpatomoreillycomsourcenostarchimages854087.png.jpg"/></div></div><p class="title">Figure 4-8. Database Repair dialog</p></div><p>When an active database has never been saved, thus leaving only intermediate files present at the time of the crash, IDA offers the repair option in <a class="xref" href="ch04s02.html#database_repair_dialog" title="Figure 4-8. Database Repair dialog">Figure 4-8</a> as soon as you try to open the original executable file again.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-4" id="ftn.CHP-4-FN-4">32</a>] </sup>Stack frames are discussed further in <a class="xref" href="ch06.html" title="Chapter 6. Disassembly Navigation">Chapter 6</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-5" id="ftn.CHP-4-FN-5">33</a>] </sup>Unless you happen to be opening <span class="emphasis"><em>rocket_science.idb</em></span>.</p></div></div></div>
<div class="sect1" title="Introduction to the IDA Desktop"><div class="titlepage"><div><div><h1 class="title"><a id="introduction_to_the_ida_desktop"/>Introduction to the IDA Desktop</h1></div></div></div><p>Given the amount of time you are likely to spend staring at your IDA desktop, you will want to spend some time familiarizing yourself with its various components. <a class="xref" href="ch04s03.html#the_ida_desktop" title="Figure 4-9. The IDA desktop">Figure 4-9</a> shows an overview of a default IDA desktop. The behavior of the desktop during file analysis is discussed in the following section.<a class="indexterm" id="IDX-CHP-4-0088"/></p><p>Areas of interest in this introductory view include the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The <span class="emphasis"><em>toolbar area</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e3875"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> contains tools corresponding to the most commonly used IDA operations. Toolbars are added to and removed from the desktop using the View ▸ Toolbars command. Using drag-and-drop, you can reposition each of the toolbars to suit your needs. <a class="xref" href="ch04s03.html#the_ida_desktop" title="Figure 4-9. The IDA desktop">Figure 4-9</a> shows IDA’s basic mode toolbar with a single row of tool buttons. An advanced mode toolbar is available using View ▸ Toolbars ▸ Advanced mode. The Advanced mode toolbars contain three full rows of tool buttons.<a class="indexterm" id="IDX-CHP-4-0089"/><a class="indexterm" id="IDX-CHP-4-0090"/><a class="indexterm" id="IDX-CHP-4-0091"/><a class="indexterm" id="IDX-CHP-4-0092"/></p><div class="figure"><a id="the_ida_desktop"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3898"/><img alt="The IDA desktop" src="httpatomoreillycomsourcenostarchimages854089.png.jpg"/></div></div><p class="title">Figure 4-9. The IDA desktop</p></div></li><li class="listitem"><p>The horizontal color band is IDA’s <span class="emphasis"><em>overview navigator</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e3909"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, also called the <span class="emphasis"><em>navigation band</em></span>. The navigation band presents a linear view of the address space of the loaded file. By default, the entire address range of the binary is represented. You can zoom in and out of the address range by right-clicking anywhere within the navigation band and selecting one of the available zoom options. Different colors represent different types of file content, such as data or code. A small <span class="emphasis"><em>current position indicator</em></span> (yellow by default) points at the navigation band address that corresponds to the current address range being displayed in the disassembly window. Hovering the mouse cursor over any portion of the navigation band yields a tool tip that describes that location in the binary. Clicking the navigation band jumps the disassembly view to the selected location within the binary. The colors used in the navigation band can be customized using the Options ▸ Colors command. Dragging the navigation band away from the IDA desktop yields a detached Overview Navigator, as shown in <a class="xref" href="ch04s03.html#the_overview_navigator" title="Figure 4-10. The Overview Navigator">Figure 4-10</a>. Also shown in <a class="xref" href="ch04s03.html#the_overview_navigator" title="Figure 4-10. The Overview Navigator">Figure 4-10</a> is the current position indicator (the half-length, downward-facing arrow to the left of location <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e3926"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>) and a <span class="emphasis"><em>color key</em></span> identifying the file content by functional groups.<a class="indexterm" id="IDX-CHP-4-0093"/><a class="indexterm" id="IDX-CHP-4-0094"/><a class="indexterm" id="IDX-CHP-4-0095"/><a class="indexterm" id="IDX-CHP-4-0096"/><a class="indexterm" id="IDX-CHP-4-0097"/><a class="indexterm" id="IDX-CHP-4-0098"/></p><div class="figure"><a id="the_overview_navigator"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3957"/><img alt="The Overview Navigator" src="httpatomoreillycomsourcenostarchimages854091.png.jpg"/></div></div><p class="title">Figure 4-10. The Overview Navigator</p></div></li><li class="listitem"><p>Coming back to <a class="xref" href="ch04s03.html#the_ida_desktop" title="Figure 4-9. The IDA desktop">Figure 4-9</a>, <span class="emphasis"><em>tabs</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e3970"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> are provided for each of the currently open data displays. Data displays contain information extracted from the binary and represent the various views into the database. The majority of your analysis work is likely to take place through interaction with the available data displays. <a class="xref" href="ch04s03.html#the_ida_desktop" title="Figure 4-9. The IDA desktop">Figure 4-9</a> shows three of the available data displays: IDA-View, Functions, and Graph Overview. Additional data displays are available via the View ▸ Open Subviews menu, and this menu is also used to restore any displays that have been closed, whether on purpose or inadvertently.<a class="indexterm" id="IDX-CHP-4-0099"/><a class="indexterm" id="IDX-CHP-4-0100"/><a class="indexterm" id="IDX-CHP-4-0101"/><a class="indexterm" id="IDX-CHP-4-0102"/><a class="indexterm" id="IDX-CHP-4-0103"/><a class="indexterm" id="IDX-CHP-4-0104"/><a class="indexterm" id="IDX-CHP-4-0105"/><a class="indexterm" id="IDX-CHP-4-0106"/><a class="indexterm" id="IDX-CHP-4-0107"/><a class="indexterm" id="IDX-CHP-4-0108"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>disassembly view</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e4017"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> is the primary data display. Two display styles are available for the disassembly view: graph view (default) and listing view. In graph view, IDA displays a flowchart-style graph of a single function at any given time. When this is combined with the <span class="emphasis"><em>graph overview</em></span>, you can gain an understanding of the flow of the function using a visual breakdown of the function’s structure. When the IDA-View window is active, the spacebar toggles between graph view–style and listing-style displays. If you wish to make listing view your default, you must uncheck Use graph view by default on the Graph tab via the Options ▸ General menu, as shown in <a class="xref" href="ch04s03.html#ida_graph_options" title="Figure 4-11. IDA graph options">Figure 4-11</a>.<a class="indexterm" id="IDX-CHP-4-0109"/><a class="indexterm" id="IDX-CHP-4-0110"/><a class="indexterm" id="IDX-CHP-4-0111"/><a class="indexterm" id="IDX-CHP-4-0112"/></p><div class="figure"><a id="ida_graph_options"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e4044"/><img alt="IDA graph options" src="httpatomoreillycomsourcenostarchimages854097.png.jpg"/></div></div><p class="title">Figure 4-11. IDA graph options</p></div></li><li class="listitem"><p>In graph view, it is seldom possible to fit the entire graph of a function into the display area at one time. The <span class="emphasis"><em>graph overview</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e4055"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>, present only when graph view is active, provides a zoomed-out snapshot of the basic graph structure. A dotted rectangle indicates the current display within the graph view. Clicking within the graph overview repositions the graph view accordingly.</p></li><li class="listitem"><p>The <span class="emphasis"><em>Output window</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e4067"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> is where you can expect to find any informational messages generated by IDA. Here you will find status messages concerning the progress of the file-analysis phase, along with any error messages resulting from user-requested operations. The Output window roughly equates to a console output device.<a class="indexterm" id="IDX-CHP-4-0113"/><a class="indexterm" id="IDX-CHP-4-0114"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>Functions window</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e4089"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> rounds out the default IDA display windows and will be discussed further in <a class="xref" href="ch05.html" title="Chapter 5. IDA Data Displays">Chapter 5</a>.<a class="indexterm" id="IDX-CHP-4-0115"/></p></li></ol></div></div>
<div class="sect1" title="Desktop Behavior During Initial Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="desktop_behavior_during_initial_analysis"/>Desktop Behavior During Initial Analysis</h1></div></div></div><p>A tremendous amount of activity takes place within the IDA desktop during the initial autoanalysis of a newly opened file. You can gain an understanding of this analysis by observing various desktop displays during the analysis process. Desktop activity you may observe includes the following:<a class="indexterm" id="IDX-CHP-4-0116"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Progress messages printed to the Output window</p></li><li class="listitem"><p>Initial location and disassembly output generated for the disassembly window</p></li><li class="listitem"><p>Initial population of the Functions window, followed by periodic updates as the analysis progresses</p></li><li class="listitem"><p>Transformation of the navigation band as new areas of the binary are recognized as code and data, blocks of code are further recognized as functions, and, finally, functions are recognized specifically as library code using IDA’s pattern-matching techniques</p></li><li class="listitem"><p>The current position indicator traversing the navigation band to show the regions currently being analyzed</p></li></ul></div><p>The following output is representative of messages generated by IDA during the initial analysis of a newly opened binary file. Notice that the messages form a narrative of the analysis process and offer insight into the sequence of operations performed by IDA during that analysis.</p><a id="I_programlisting1_d1e4128"/><pre class="programlisting">Loading file 'C:\IdaBook\ch4_example.exe' into database...
  Detected file format: Portable executable for 80386 (PE)
    0. Creating a new segment  (00401000-0040C000) ... ... OK
    1. Creating a new segment  (0040C000-0040E000) ... ... OK
    2. Creating a new segment  (0040E000-00411000) ... ... OK
  Reading imports directory...
    3. Creating a new segment  (0040C120-0040E000) ... ... OK
  Plan  FLIRT signature: Microsoft VisualC 2-10/net runtime
  autoload.cfg: vc32rtf.sig autoloads mssdk.til
  Assuming __cdecl calling convention by default
  main() function at 401070, named "_main"
  Marking typical code sequences...
  Flushing buffers, please wait...ok
  File 'C:\IdaBook\ch4_example.exe' is successfully loaded into the database.
  Compiling file 'C:\Program Files\IdaPro\idc\ida.idc'...
    Executing function 'main'...
  Compiling file 'C:\Program Files\IdaPro\idc\onload.idc'...
  Executing function 'OnLoad'...
  IDA is analysing the input file...
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> You may start to explore the input file right now.
  ------------------------------------------------------------------------------
  Python 2.6.5 (r265:79096, Mar 19 2010, 21:48:26) [MSC v.1500 32 bit (Intel)]
  IDAPython v1.4.2 final (serial 0) (c) The IDAPython Team
  &lt;idapython@googlegroups.com&gt;
  ------------------------------------------------------------------------------
  Using FLIRT signature: Microsoft VisualC 2-10/net runtime
  Propagating type information...
  Function argument information has been propagated
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> The initial autoanalysis has been finished.</pre><p>Two particularly helpful progress messages are <code class="literal">You may start to explore the input file right now</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e4147"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <code class="literal">The initial autoanalysis has been finished</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e4156"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. The first message informs you that IDA has made enough progress with its analysis that you can begin navigating through the various data displays. Navigating does not imply changing, however, and you should wait to make any changes to the database until the analysis phase has been completed. If you attempt to change the database prior to completion of the analysis phase, the analysis engine may come along later and modify your changes further, or you may even prevent the analysis engine from doing its job correctly. The second of these messages, which is fairly self-explanatory, indicates that you can expect no more automatic changes to take place in the desktop data displays. At this point it is safe to make any changes you like to the database.<a class="indexterm" id="IDX-CHP-4-0117"/><a class="indexterm" id="IDX-CHP-4-0118"/><a class="indexterm" id="IDX-CHP-4-0119"/><a class="indexterm" id="IDX-CHP-4-0120"/></p></div>
<div class="sect1" title="IDA Desktop Tips and Tricks"><div class="titlepage"><div><div><h1 class="title"><a id="ida_desktop_tips_and_tricks"/>IDA Desktop Tips and Tricks</h1></div></div></div><p>IDA offers a tremendous amount of information, and its desktop can become cluttered. Here are some tips for making the best use of your desktop:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The more screen real estate you dedicate to IDA, the happier you will be. Use this fact to justify the purchase of a king-size monitor (or two)!</p></li><li class="listitem"><p>Don’t forget the View ▸ Open Subviews command as a means of restoring data displays that you have inadvertently closed.<a class="indexterm" id="IDX-CHP-4-0121"/></p></li><li class="listitem"><p>The Windows ▸ Reset Desktop command offers a useful way to quickly restore your desktop to its original layout.<a class="indexterm" id="IDX-CHP-4-0122"/></p></li><li class="listitem"><p>Utilize the Windows ▸ Save Desktop command to save a current layout of desktop configurations that you find particularly useful. The Windows ▸ Load Desktop command is used to quickly revert to a saved layout.<a class="indexterm" id="IDX-CHP-4-0123"/><a class="indexterm" id="IDX-CHP-4-0124"/></p></li><li class="listitem"><p>The only window for which the display font can be changed is the Disassembly window (either graph or listing view). Fonts are set using the Options ▸ Font command.<a class="indexterm" id="IDX-CHP-4-0125"/></p></li></ul></div></div>
<div class="sect1" title="Reporting Bugs"><div class="titlepage"><div><div><h1 class="title"><a id="reporting_bugs"/>Reporting Bugs</h1></div></div></div><p>As with any piece of software, IDA has been known to contain an occasional bug, so what can you expect from Hex-Rays if you think you have found a bug in IDA itself? First, Hex-Rays has one of the most responsive support systems you can will ever deal with. Second, don’t be surprised if you hear back from Ilfak himself within a day of submitting a support request.<a class="indexterm" id="IDX-CHP-4-0126"/><a class="indexterm" id="IDX-CHP-4-0127"/><a class="indexterm" id="IDX-CHP-4-0128"/><a class="indexterm" id="IDX-CHP-4-0129"/><a class="indexterm" id="IDX-CHP-4-0130"/><a class="indexterm" id="IDX-CHP-4-0131"/></p><p>Two methods are available for submitting bug reports. You can send email to <span class="email"><a class="email" href="mailto:support@hex-rays.com">support@hex-rays.com</a></span>, or if you prefer not to use email, you may post to the Bug Reports forum on the Hex-Rays bulletin boards. In either case, you should both verify that you can reproduce your bug and be prepared to provide Hex-Rays with a copy of the database file involved with the problem. Recall that Hex-Rays only provides SDK support for an additional fee. For bugs related to a plug-in that you have installed, you will need to contact the plug-in’s author. For bugs related to a plug-in that you are developing, you will need to take advantage of the support forums available for IDA users and hope for a helpful response from a fellow user.</p></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id3"/>Summary</h1></div></div></div><p>Familiarity with the IDA workspace will greatly enhance your experience with IDA. Reverse engineering binary code is difficult enough without having to struggle with your tools. The options that you choose during the initial loading phase and the subsequent autoanalysis performed by IDA set the stage for all of the analysis that you will do later. At this point you may be content with the work that IDA has accomplished on your behalf, and for simple binaries, autoanalysis may be all that you need. On the other hand, if you wonder what puts the <span class="emphasis"><em>interactive</em></span> in IDA, you are now ready to dive deeper into the functionality of IDA’s many data displays. In the coming chapters you will be introduced to each of the primary displays, the circumstances under which you will find each one useful, and how to utilize these displays to enhance and update your databases.</p></div>
<div class="chapter" title="Chapter&#xA0;5.&#xA0;IDA Data Displays"><div class="titlepage"><div><div><h1 class="title"><a id="ida_data_displays"/>Chapter 5. IDA Data Displays</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id5"/><div class="mediaobject"><a id="I_mediaobject2_d1e4259"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>At this point you should have some confidence loading binaries into IDA and letting IDA work its magic while you sip your favorite beverage. Once IDA’s initial analysis phase is complete, it is time for you to take control. One of the best ways for you to familiarize yourself with IDA’s displays is simply to browse around the various tabbed subwindows that IDA populates with data about your binary. The efficiency and effectiveness of your reverse engineering sessions will improve as your comfort level with IDA increases.<a class="indexterm" id="IDX-CHP-5-0001"/><a class="indexterm" id="IDX-CHP-5-0002"/><a class="indexterm" id="IDX-CHP-5-0003"/></p><p>Before we dive into the major IDA subdisplays, it is useful to cover a few basic rules concerning IDA’s user interface:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>There is no undo in IDA</strong></span>.</span></dt><dd><p>If something unexpected happens to your database as a result of an inadvertent keypress, you are on your own to restore your displays to their previous states.</p></dd><dt><span class="term"><span class="strong"><strong>Almost all actions have an associated menu item, hotkey, and toolbar button</strong></span>.</span></dt><dd><p>Remember, the IDA toolbar is highly configurable, as is the mapping of hotkeys to menu actions.<a class="indexterm" id="IDX-CHP-5-0004"/><a class="indexterm" id="IDX-CHP-5-0005"/><a class="indexterm" id="IDX-CHP-5-0006"/></p></dd><dt><span class="term"><span class="strong"><strong>IDA offers good, context-sensitive menu actions in response to right mouse clicks</strong></span>.</span></dt><dd><p>While these menus do not offer an exhaustive list of permissible actions at a given location, they do serve as good reminders for the most common actions you will be performing.</p></dd></dl></div><p>With these facts in mind, let’s begin our coverage of the principal IDA data displays.<a class="indexterm" id="IDX-CHP-5-0007"/></p><div class="sect1" title="The Principal IDA Displays"><div class="titlepage"><div><div><h1 class="title"><a id="the_principal_ida_displays"/>The Principal IDA Displays</h1></div></div></div><p>In its default configuration, IDA creates seven (as of version 6.1) display windows during the initial loading-and-analysis phase for a new binary. Each of these display windows is accessible via a set of title tabs displayed immediately beneath the navigation band (shown previously in <a class="xref" href="ch04s03.html#the_ida_desktop" title="Figure 4-9. The IDA desktop">Figure 4-9</a>). The three immediately visible windows are the IDA-View window, the Functions window, and the Output window. Whether or not they are open by default, all of the windows discussed in this chapter can be opened via the View ▸ Open Subviews menu. Keep this fact in mind, as it is fairly easy to inadvertently close the display windows.<a class="indexterm" id="IDX-CHP-5-0008"/><a class="indexterm" id="IDX-CHP-5-0009"/><a class="indexterm" id="IDX-CHP-5-0010"/><a class="indexterm" id="IDX-CHP-5-0011"/></p><p>The <span class="keycap">esc</span> key is one of the more useful hotkeys in all of IDA. When the disassembly window is active, the <span class="keycap">esc</span> key functions in a manner similar to a web browser’s back button and is therefore very useful in navigating the disassembly display (navigation is covered in detail in <a class="xref" href="ch06.html" title="Chapter 6. Disassembly Navigation">Chapter 6</a>). Unfortunately, when any other window is active, the <span class="keycap">esc</span> key serves to close the window. Occasionally, this is exactly what you want. At other times, you will immediately wish you had that closed window back.<a class="indexterm" id="IDX-CHP-5-0012"/><a class="indexterm" id="IDX-CHP-5-0013"/></p><div class="sect2" title="The Disassembly Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_disassembly_window"/>The Disassembly Window</h2></div></div></div><p>Also known as the IDA-View window, the disassembly window will be your primary tool for manipulating and analyzing binaries. Accordingly, it is important that you become intimately familiar with the manner in which information is presented in the disassembly window.</p><p>Two display formats are available for the disassembly window: the default graph-based view and a text-oriented listing view. Most IDA users tend to prefer one view over the other, and the view that better suits your needs is often determined by how you prefer to visualize a program’s flow. If you prefer to use the text listing view as your default disassembly view, you can change the default by using the Options ▸ General dialog to turn off Use graph view by default on the Graph tab. Whenever the disassembly view is active, you can easily switch between graph and listing views at any time by using the spacebar.<a class="indexterm" id="IDX-CHP-5-0014"/><a class="indexterm" id="IDX-CHP-5-0015"/></p><div class="sect3" title="IDA Graph View"><div class="titlepage"><div><div><h3 class="title"><a id="ida_graph_view"/>IDA Graph View</h3></div></div></div><p><a class="xref" href="ch05.html#ida_graph_view-id1" title="Figure 5-1. IDA graph view">Figure 5-1</a> shows a very simple function displayed in graph view. Graph views are somewhat reminiscent of program flowcharts in that a function is broken up into basic blocks<sup>[<a class="footnote" href="#ftn.CHP-5-FN-1" id="CHP-5-FN-1">34</a>]</sup> so you can visualize the function’s control flow from one block to another.<a class="indexterm" id="IDX-CHP-5-0016"/><a class="indexterm" id="IDX-CHP-5-0017"/><a class="indexterm" id="IDX-CHP-5-0018"/></p><div class="figure"><a id="ida_graph_view-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e4408"/><img alt="IDA graph view" src="httpatomoreillycomsourcenostarchimages854105.png"/></div></div><p class="title">Figure 5-1. IDA graph view</p></div><p>Onscreen, you’ll notice IDA uses different colored arrows to distinguish various types of flows<sup>[<a class="footnote" href="#ftn.CHP-5-FN-2" id="CHP-5-FN-2">35</a>]</sup> between the blocks of a function. Basic blocks that terminate with a conditional jump generate two possible flows depending on the condition being tested: the <span class="emphasis"><em>Yes edge</em></span> arrow (yes, the branch is taken) is green by default, and the <span class="emphasis"><em>No edge</em></span> arrow (no, the branch is not taken) is red by default. Basic blocks that terminate with only one potential successor block utilize a <span class="emphasis"><em>Normal edge</em></span> (blue by default) to point to the next block to be executed.<a class="indexterm" id="IDX-CHP-5-0019"/><a class="indexterm" id="IDX-CHP-5-0020"/><a class="indexterm" id="IDX-CHP-5-0021"/><a class="indexterm" id="IDX-CHP-5-0022"/><a class="indexterm" id="IDX-CHP-5-0023"/><a class="indexterm" id="IDX-CHP-5-0024"/><a class="indexterm" id="IDX-CHP-5-0025"/><a class="indexterm" id="IDX-CHP-5-0026"/><a class="indexterm" id="IDX-CHP-5-0027"/><a class="indexterm" id="IDX-CHP-5-0028"/><a class="indexterm" id="IDX-CHP-5-0029"/><a class="indexterm" id="IDX-CHP-5-0030"/></p><p>In graph mode, IDA displays one function at a time. For users with a wheel mouse, graph zooming is possible using the <span class="keycap">ctrl</span>- wheel combination. Keyboard zoom control requires <span class="keycap">ctrl</span>-+ to zoom in or <span class="keycap">ctrl</span>- − to zoom out (using the + and − keys on the numeric keypad). Large or complex functions may cause the graph view to become extremely cluttered, making the graph difficult to navigate. In such cases, the Graph Overview window (see <a class="xref" href="ch05.html#the_graph_overview_window" title="Figure 5-2. The Graph Overview window">Figure 5-2</a>) is available to provide some situational awareness. The overview window always displays the complete block structure of the graph along with a dashed frame that indicates the region of the graph currently being viewed in the disassembly window. The dashed frame can be dragged across the overview window to rapidly reposition the graph view to any desired location on the graph.<a class="indexterm" id="IDX-CHP-5-0031"/></p><div class="figure"><a id="the_graph_overview_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e4505"/><img alt="The Graph Overview window" src="httpatomoreillycomsourcenostarchimages854107.png"/></div></div><p class="title">Figure 5-2. The Graph Overview window</p></div><p>With the graph display, there are several ways that you can manipulate the view to suit your needs:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Panning</strong></span></span></dt><dd><p>First, in addition the using the Graph Overview window to rapidly reposition the graph, you can also reposition the graph by clicking and dragging the background of the graph view.</p><div class="sidebar"><a id="hey_comma_isnat_something_missing_here_q"/><p class="title">HEY, ISN’T SOMETHING MISSING HERE?</p><p>When using graph view, it may seem as if less information is available to you about each line of the disassembly. The reason for this is that IDA chooses to hide many of the more traditional pieces of information about each disassembled line (such as virtual address information) in order to minimize the amount of space required to display each basic block. You can choose to display additional information with each disassembly line by choosing among the available <span class="emphasis"><em>disassembly line parts</em></span> accessible via the <span class="emphasis"><em>Disassembly</em></span> tab from Options ▸ General. For example, to add virtual addresses to each disassembly line, we enable <span class="emphasis"><em>line prefixes</em></span>, transforming the graph from <a class="xref" href="ch05.html#ida_graph_view-id1" title="Figure 5-1. IDA graph view">Figure 5-1</a> into the graph shown in <a class="xref" href="ch05.html#graph_view_with_line_prefixes_enabled" title="Figure 5-3. Graph view with line prefixes enabled">Figure 5-3</a>.<a class="indexterm" id="IDX-CHP-5-0032"/><a class="indexterm" id="IDX-CHP-5-0033"/></p><div class="figure"><a id="graph_view_with_line_prefixes_enabled"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e4548"/><img alt="Graph view with line prefixes enabled" src="httpatomoreillycomsourcenostarchimages854109.png"/></div></div><p class="title">Figure 5-3. Graph view with line prefixes enabled</p></div></div></dd><dt><span class="term"><span class="strong"><strong>Rearranging blocks</strong></span></span></dt><dd><p>Individual blocks within the graph can be dragged to new positions by clicking the title bar for the desired block and dragging it to a new position. Beware that IDA performs only minimal rerouting of any edges associated with a moved block. You can manually reroute edges by dragging vertices to new locations. New vertices can be introduced into an edge by double-clicking the desired location within an edge while holding the <span class="keycap">shift</span> key. If at any point you find yourself wishing to revert to the default layout for your graph, you can do so by right-clicking the graph and choosing Layout Graph.<a class="indexterm" id="IDX-CHP-5-0034"/><a class="indexterm" id="IDX-CHP-5-0035"/><a class="indexterm" id="IDX-CHP-5-0036"/><a class="indexterm" id="IDX-CHP-5-0037"/><a class="indexterm" id="IDX-CHP-5-0038"/><a class="indexterm" id="IDX-CHP-5-0039"/><a class="indexterm" id="IDX-CHP-5-0040"/><a class="indexterm" id="IDX-CHP-5-0041"/><a class="indexterm" id="IDX-CHP-5-0042"/><a class="indexterm" id="IDX-CHP-5-0043"/><a class="indexterm" id="IDX-CHP-5-0044"/><a class="indexterm" id="IDX-CHP-5-0045"/><a class="indexterm" id="IDX-CHP-5-0046"/><a class="indexterm" id="IDX-CHP-5-0047"/></p></dd><dt><span class="term"><span class="strong"><strong>Grouping and collapsing blocks</strong></span></span></dt><dd><p>Blocks can be grouped, either individually or together with other blocks, and collapsed to reduce the clutter in the display. Collapsing blocks is a particularly useful technique for keeping track of blocks that you have already analyzed. You can collapse any block by right-clicking the block’s title bar and selecting Group Nodes.</p></dd><dt><span class="term"><span class="strong"><strong>Creating additional disassembly windows</strong></span></span></dt><dd><p>If you ever find yourself wanting to view graphs of two functions simultaneously, all you need to do is open another disassembly window using Views ▸ Open Subviews ▸ Disassembly. The first disassembly window opened is titled <span class="emphasis"><em>IDA View-A</em></span>. Subsequent disassembly windows are titled <span class="emphasis"><em>IDA View-B</em></span>, <span class="emphasis"><em>IDA View-C</em></span>, and so on. Each disassembly is independent of the other, and it is perfectly acceptable to view a graph in one window while viewing a text listing in another or to view three different graphs in three different windows.</p></dd></dl></div><p>Keep in mind that your control over the view extends beyond just these examples. Additional IDA graphing capabilities are covered in <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>, while more information on the manipulation of IDA’s graph view is available in the IDA help file.</p></div><div class="sect3" title="IDA Text View"><div class="titlepage"><div><div><h3 class="title"><a id="ida_text_view"/>IDA Text View</h3></div></div></div><p>The text-oriented disassembly window is the traditional display used for viewing and manipulating IDA-generated disassemblies. The text display presents the entire disassembly listing of a program (as opposed to a single function at a time in graph mode) and provides the only means for viewing the data regions of a binary. All of the information available in the graph display is available in the text display in one form or another.</p><p><a class="xref" href="ch05.html#the_ida_text_view" title="Figure 5-4. The IDA text view">Figure 5-4</a> shows the text view listing of the same function shown in <a class="xref" href="ch05.html#ida_graph_view-id1" title="Figure 5-1. IDA graph view">Figure 5-1</a> and <a class="xref" href="ch05.html#graph_view_with_line_prefixes_enabled" title="Figure 5-3. Graph view with line prefixes enabled">Figure 5-3</a>. The disassembly is presented in linear fashion, with virtual addresses displayed by default. Virtual addresses are typically displayed in a <code class="literal">[SECTION NAME]:[VIRTUAL ADDRESS]</code> format such as <code class="literal">.text:004011C1</code>.<a class="indexterm" id="IDX-CHP-5-0048"/></p><div class="figure"><a id="the_ida_text_view"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e4677"/><img alt="The IDA text view" src="httpatomoreillycomsourcenostarchimages854111.png.jpg"/></div></div><p class="title">Figure 5-4. The IDA text view</p></div><p>The left portion of the display, seen at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e4684"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, is called the <span class="emphasis"><em>arrows window</em></span> and is used to depict nonlinear flow within a function. Solid arrows represent unconditional jumps, while dashed arrows represent conditional jumps. When a jump (conditional or unconditional) transfers control to an earlier address in the program, a heavy weighted line (solid or dashed) is used. Such reverse flow in a program often indicates the presence of a loop. In <a class="xref" href="ch05.html#the_ida_text_view" title="Figure 5-4. The IDA text view">Figure 5-4</a>, a loop arrow flows from address <code class="literal">004011CF</code> to <code class="literal">004011C5</code>.<a class="indexterm" id="IDX-CHP-5-0049"/><a class="indexterm" id="IDX-CHP-5-0050"/><a class="indexterm" id="IDX-CHP-5-0051"/><a class="indexterm" id="IDX-CHP-5-0052"/></p><p>The declarations at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e4716"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> (also present in graph view) represent IDA’s best estimate concerning the layout of the function’s stack frame.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-3" id="CHP-5-FN-3">36</a>]</sup> IDA computes the structure of a function’s stack frame by performing detailed analysis of the behavior of the stack pointer and any stack frame pointer used within a function. Stack displays are discussed further in <a class="xref" href="ch06.html" title="Chapter 6. Disassembly Navigation">Chapter 6</a>.</p><p>The comments (a semicolon introduces a comment) at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e4738"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> are <span class="emphasis"><em>cross-references</em></span>. In this case we see code cross-references (as opposed to data cross-references), which indicate that another program instruction transfers control to the location containing the cross-reference comment. Cross-references are the subject of <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>.<a class="indexterm" id="IDX-CHP-5-0053"/></p><p>For the remainder of the book we will primarily utilize the text display for examples. We’ll use the graph display only in cases where it may provide significantly more clarity. In <a class="xref" href="ch07.html" title="Chapter 7. Disassembly Manipulation">Chapter 7</a> we will cover the specifics of manipulating the text display in order to clean up and annotate a disassembly.</p></div></div><div class="sect2" title="The Functions Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_functions_window"/>The Functions Window</h2></div></div></div><p>The Functions window is used to list every function that IDA has recognized in the database. A Functions window entry might look like the following:<a class="indexterm" id="IDX-CHP-5-0054"/><a class="indexterm" id="IDX-CHP-5-0055"/><a class="indexterm" id="IDX-CHP-5-0056"/><a class="indexterm" id="IDX-CHP-5-0057"/></p><a id="I_programlisting2_d1e4779"/><pre class="programlisting">malloc              .text                00BDC260 00000180 R . . . B . .</pre><p>This particular line indicates that the <code class="literal">malloc</code> function can be found in the <code class="literal">.text</code> section of the binary at virtual address <code class="literal">00BDC260</code>, is 384 bytes (hex 180) long, returns to the caller (<code class="literal">R</code>), and uses the EBP register (<code class="literal">B</code>) to reference its local variables. Flags used to describe a function (such as <code class="literal">R</code> and <code class="literal">B</code> above) are described in IDA’s built-in help file (or by right-clicking a function and choosing Properties. The flags are shown as editable checkboxes in the resulting Properties dialog).<a class="indexterm" id="IDX-CHP-5-0058"/></p><p>As with other display windows, double-clicking an entry in the Functions window causes the disassembly window to jump to the location of the selected function.</p></div><div class="sect2" title="The Output Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_output_window"/>The Output Window</h2></div></div></div><p>The Output window at the bottom of the IDA workspace rounds out the default set of windows that are visible when a new file is opened. The Ouput window serves as IDA’s output console and is the place to look for information on tasks IDA is performing. When a binary is first opened, for example, messages are generated to indicate both what phase of analysis IDA is in at any given time and what actions IDA is carrying out to create the new database. As you work with a database, the Output window is used to output the status of various operations that you perform. The contents of the Output window can be copied to the system clipboard or cleared entirely by right-clicking anywhere in the window and selecting the appropriate operation. The Output window will often be the primary means by which you display output from any scripts and plug-ins that you develop for IDA.<a class="indexterm" id="IDX-CHP-5-0059"/><a class="indexterm" id="IDX-CHP-5-0060"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-1" id="ftn.CHP-5-FN-1">34</a>] </sup>A <span class="emphasis"><em>basic block</em></span> is a maximal sequence of instructions that executes, without branching, from beginning to end. Each basic block therefore has a single entry point (the first instruction in the block) and a single exit point (the last instruction in the block). The first instruction in a basic block is often the target of a branching instruction, while the last instruction in a basic block is often a branch instruction.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-2" id="ftn.CHP-5-FN-2">35</a>] </sup>IDA uses the term <span class="emphasis"><em>flow</em></span> to indicate how execution can continue from a given instruction. A <span class="emphasis"><em>normal</em></span> (also called <span class="emphasis"><em>ordinary</em></span>) flow indicates default sequential execution of instructions. A <span class="emphasis"><em>jump</em></span> flow indicates that the current instruction jumps (or may jump) to a nonsequential location. A <span class="emphasis"><em>call</em></span> flow indicates that the current instruction calls a subroutine.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-3" id="ftn.CHP-5-FN-3">36</a>] </sup>A <span class="emphasis"><em>stack frame</em></span> (or <span class="emphasis"><em>activation record</em></span>) is a block of memory, allocated in a program’s runtime stack, that contains both the parameters passed into a function and the local variables declared within the function. Stack frames are allocated upon entry into a function and released as the function exits. Stack frames are discussed in more detail in <a class="xref" href="ch06.html" title="Chapter 6. Disassembly Navigation">Chapter 6</a>.</p></div></div></div>
<div class="sect1" title="Secondary IDA Displays"><div class="titlepage"><div><div><h1 class="title"><a id="secondary_ida_displays"/>Secondary IDA Displays</h1></div></div></div><p>In addition to the disassembly, Functions, and Output windows, IDA opens a number of other tabbed windows on your IDA desktop. These tabs are present just under the navigation band (see <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e4830"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> in <a class="xref" href="ch04s03.html#the_ida_desktop" title="Figure 4-9. The IDA desktop">Figure 4-9</a>). These windows are used to provide alternate or specialized views into the database. The utility of these displays depends on both the characteristics of the binary you are analyzing and your skill with IDA. Several of these windows are sufficiently specialized to require more detailed coverage in later chapters.</p><div class="sect2" title="The Hex View Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_hex_view_window"/>The Hex View Window</h2></div></div></div><p>Hex View is something of a misnomer in this case, as the IDA Hex View window can be configured to display a variety of formats and doubles as a hex editor. By default, the Hex View window provides a standard hex dump of the program content with 16 bytes per line and ASCII equivalents displayed alongside. As with the disassembly window, several hex views can be opened simultaneously. The first Hex window is titled <span class="emphasis"><em>Hex View-A</em></span>, the second <span class="emphasis"><em>Hex View-B</em></span>, the next <span class="emphasis"><em>Hex View-C</em></span>, and so on. By default, the first Hex window is synchronized with the first disassembly window. When a disassembly view is synchronized with a hex view, scrolling in one window causes the other window to scroll to the same location (same virtual address). In addition, when an item is selected in disassembly view, the corresponding bytes are highlighted in hex view. In <a class="xref" href="ch05s02.html#synchronized_hex_and_disassembly_views" title="Figure 5-5. Synchronized hex and disassembly views">Figure 5-5</a>, the disassembly view cursor is positioned at address <code class="literal">0040108C</code>, a call instruction, causing the five bytes that make up the instruction to be highlighted in the Hex window.<a class="indexterm" id="IDX-CHP-5-0061"/><a class="indexterm" id="IDX-CHP-5-0062"/><a class="indexterm" id="IDX-CHP-5-0063"/><a class="indexterm" id="IDX-CHP-5-0064"/><a class="indexterm" id="IDX-CHP-5-0065"/><a class="indexterm" id="IDX-CHP-5-0066"/><a class="indexterm" id="IDX-CHP-5-0067"/></p><div class="figure"><a id="synchronized_hex_and_disassembly_views"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e4888"/><img alt="Synchronized hex and disassembly views" src="httpatomoreillycomsourcenostarchimages854113.png.jpg"/></div></div><p class="title">Figure 5-5. Synchronized hex and disassembly views</p></div><p>Also shown in <a class="xref" href="ch05s02.html#synchronized_hex_and_disassembly_views" title="Figure 5-5. Synchronized hex and disassembly views">Figure 5-5</a> is the hex display context menu, available when you right-click anywhere within the hex display. This context menu is where you may specify with which, if any, disassembly view you would like to synchronize a particular hex display. Deselecting the synchronization option allows a Hex window to be scrolled independently of any disassembly window. Selecting the Edit menu option turns the Hex View into a hex editor. Once you are finished editing, you must either commit or cancel your changes in order to return to view mode. The Data Format menu item allows you to select from a variety of display formats such as 1-, 2-, 4-, or 8-byte hexadecimal; signed decimal; or unsigned decimal integers and various floating point formats. The Columns menu option allows you to change the number of columns used in the display, and the Text option allows you to turn the text dump on and off.</p><p>In some cases you may find that the Hex window shows nothing but question marks. This is IDA’s way of telling you that it has no idea what values might occupy a given virtual address range. Such is the case when a program contains a bss<sup>[<a class="footnote" href="#ftn.CHP-5-FN-4" id="CHP-5-FN-4">37</a>]</sup> section, which typically occupies no space within a file but is expanded by the loader to accommodate the program’s static storage requirements.<a class="indexterm" id="IDX-CHP-5-0068"/></p></div><div class="sect2" title="The Exports Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_exports_window"/>The Exports Window</h2></div></div></div><p>The Exports window lists the entry points into a file. These include the program’s execution entry point, as specified in its header section, along with any functions and variables that the file exports for use by other files. Exported functions are commonly found in shared libraries such as Windows DLL files. Exported entries are listed by name, virtual address, and, if applicable, by ordinal number.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-5" id="CHP-5-FN-5">38</a>]</sup> For executable files, the Exports window always contains at least one entry: the program’s execution entry point. IDA names this entry point <code class="literal">start</code>. A typical Exports window entry follows:<a class="indexterm" id="IDX-CHP-5-0069"/><a class="indexterm" id="IDX-CHP-5-0070"/><a class="indexterm" id="IDX-CHP-5-0071"/><a class="indexterm" id="IDX-CHP-5-0072"/><a class="indexterm" id="IDX-CHP-5-0073"/><a class="indexterm" id="IDX-CHP-5-0074"/></p><a id="I_programlisting2_d1e4949"/><pre class="programlisting">LoadLibraryA                          7C801D77 578</pre><p>As with many of the other IDA windows, double-clicking an entry in the Exports window will jump the disassembly window to the address associated with that entry. The Exports window offers functionality available in command-line tools such as <code class="literal">objdump</code> (<code class="literal">-T</code>), <code class="literal">readelf (-s</code>), and <code class="literal">dumpbin</code> (<code class="literal">/EXPORTS</code>).</p></div><div class="sect2" title="The Imports Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_imports_window"/>The Imports Window</h2></div></div></div><p>The Imports window is a counterpart to the Exports window. It lists all functions that are imported by the binary being analyzed. The Imports window is relevant only when a binary makes use of shared libraries. Statically linked binaries have no external dependencies and therefore no imports. Each entry in the Imports window lists the name of an imported item (function or data) and the name of the library that contains that item. Since the code for an imported function resides in a shared library, the addresses listed with each entry refer to the virtual address of the associated import table entry.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-6" id="CHP-5-FN-6">39</a>]</sup> An example of an Import window entry is shown here:<a class="indexterm" id="IDX-CHP-5-0075"/><a class="indexterm" id="IDX-CHP-5-0076"/><a class="indexterm" id="IDX-CHP-5-0077"/></p><a id="I_programlisting2_d1e4990"/><pre class="programlisting">0040E108  GetModuleHandleA         KERNEL32</pre><p>Double-clicking this import would jump the disassembly window to address <code class="literal">0040E108</code>. The contents of this memory location in hex view would be <code class="literal">?? ?? ?? ??</code>. IDA is a static analysis tool, and it has no way to know what address will be entered into this memory location when the program is executed. The Imports window also offers functionality available in command-line tools such as <code class="literal">objdump</code> (<code class="literal">-T</code>), <code class="literal">readelf</code> (<code class="literal">-s</code>), and <code class="literal">dumpbin</code> (<code class="literal">/IMPORTS</code>).<a class="indexterm" id="IDX-CHP-5-0078"/><a class="indexterm" id="IDX-CHP-5-0079"/><a class="indexterm" id="IDX-CHP-5-0080"/></p><p>An important point to remember about the Imports window is that it displays only the symbols that a binary wants handled automatically by the dynamic loader. Symbols that a binary chooses to load on its own using a mechanism such as <code class="literal">dlopen/dlsym</code> or <code class="literal">LoadLibrary/GetProcAddress</code> will not be listed in the Imports window.</p></div><div class="sect2" title="The Structures Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_structures_window"/>The Structures Window</h2></div></div></div><p>The Structures window is used to display the layout of any complex data structures, such as C structs or unions, that IDA determines are in use within a binary. During the analysis phase, IDA consults its extensive library of function-type signatures in an attempt to match function parameter types to memory used within the program. The Structures window shown in <a class="xref" href="ch05s02.html#the_structures_window-id1" title="Figure 5-6. The Structures window">Figure 5-6</a> indicates that IDA believes the program uses the <code class="literal">sockaddr</code><sup>[<a class="footnote" href="#ftn.CHP-5-FN-7" id="CHP-5-FN-7">40</a>]</sup> data structure.<a class="indexterm" id="IDX-CHP-5-0081"/><a class="indexterm" id="IDX-CHP-5-0082"/></p><div class="figure"><a id="the_structures_window-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e5070"/><img alt="The Structures window" src="httpatomoreillycomsourcenostarchimages854115.png"/></div></div><p class="title">Figure 5-6. The Structures window</p></div><p>There are many possible reasons why IDA may have arrived at this conclusion. One such reason might be that IDA has observed a call to the C library <code class="literal">connect</code><sup>[<a class="footnote" href="#ftn.CHP-5-FN-8" id="CHP-5-FN-8">41</a>]</sup> function to establish a new network connection. Double-clicking the name of a data structure (<code class="literal">sockaddr</code> in this case) causes IDA to expand the structure, and this allows you to see the detailed layout of the structure, including individual field names and sizes.</p><p>The two primary uses for the Structures window are (1) to provide a ready reference for the layout of standard data structures and (2) to provide you with a means to create your own data structures for use as memory layout templates when you discover custom data structures within a program. Structure definition and the application of structures within disassemblies are covered in more detail in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>.</p></div><div class="sect2" title="The Enums Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_enums_window"/>The Enums Window</h2></div></div></div><p>The Enums window is somewhat similar to the Structures window. When IDA detects the use of a standard enumerated datatype (C <code class="literal">enum</code>), that datatype will be listed in the Enums window. You can make your disassemblies far more readable by using enums in place of integer constants. Like the Structures window, the Enums window offers facilities for defining your own enumerated types that you can use with your disassembled binaries.<a class="indexterm" id="IDX-CHP-5-0083"/><a class="indexterm" id="IDX-CHP-5-0084"/><a class="indexterm" id="IDX-CHP-5-0085"/><a class="indexterm" id="IDX-CHP-5-0086"/><a class="indexterm" id="IDX-CHP-5-0087"/><a class="indexterm" id="IDX-CHP-5-0088"/><a class="indexterm" id="IDX-CHP-5-0089"/><a class="indexterm" id="IDX-CHP-5-0090"/><a class="indexterm" id="IDX-CHP-5-0091"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-4" id="ftn.CHP-5-FN-4">37</a>] </sup>A <span class="emphasis"><em>bss</em></span> section is created by a compiler to house all of a program’s uninitialized, static variables. Since no initial value is assigned to these variables, there is no need to allocate space for them in the program’s file image, so the section’s size is noted in one of the program’s headers. When the program is executed, the loader allocates the required space and initializes the entire block to zero.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-5" id="ftn.CHP-5-FN-5">38</a>] </sup>An export ordinal number may be used in a shared library to make a function accessible by number rather than name. The use of ordinals can speed the address lookup process and allow programmers to hide the names of their functions. Export ordinals are used in Windows DLLs.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-6" id="ftn.CHP-5-FN-6">39</a>] </sup>An import table provides space for a loader to store addresses of imported functions once the required libraries have been loaded and the addresses of those functions are known. A single import table entry holds the address of one imported function.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-7" id="ftn.CHP-5-FN-7">40</a>] </sup>A <code class="literal">sockaddr</code> structure is a datatype in the C standard library often used to represent an endpoint in a network connection. A <code class="literal">sockaddr</code> variable can be used to hold an IP address and port number as part of the process of establishing a TCP connection to a remote computer.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-8" id="ftn.CHP-5-FN-8">41</a>] </sup><code class="literal">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);</code></p></div></div></div>
<div class="sect1" title="Tertiary IDA Displays"><div class="titlepage"><div><div><h1 class="title"><a id="tertiary_ida_displays"/>Tertiary IDA Displays</h1></div></div></div><p>The last windows that we will discuss are those that IDA does not open by default. Each of these windows is available via View ▸ Open Subviews, but they tend to provide information to which you may not require immediate access and are thus initially kept out of the way.</p><div class="sect2" title="The Strings Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_strings_window"/>The Strings Window</h2></div></div></div><p>The Strings window is the built-in IDA equivalent of the <code class="literal">strings</code> utility and then some. In IDA versions 5.1 and earlier, the Strings window was open as part of the default desktop; however, with version 5.2, the Strings window is no longer open by default, though it remains available via View ▸ Open Subviews ▸ Strings.<a class="indexterm" id="IDX-CHP-5-0092"/></p><p>The purpose of the Strings window is to display a list of strings extracted from a binary along with the address at which each string resides. Like double-clicking names in the Names window, double-clicking any string listed in the Strings window causes the disassembly window to jump to the address of the selected string. When used with cross-references (<a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>), the Strings window provides the means to rapidly spot an interesting string and to track back to any location in the program that references that string. For example, you might see the string <span class="emphasis"><em>SOFTWARE\Microsoft\Windows\Current Version\Run</em></span> listed and wonder why an application is referencing this particular key within the Windows registry. As you will see in the following chapter, navigating to the program location that references this string takes only four clicks. Understanding the operation of the Strings window is essential to using it effectively. IDA does not permanently store the strings it extracts from a binary. Therefore, every time the Strings window is opened, the entire database must be scanned or rescanned for string content. String scanning is performed in accordance with the settings of the Strings window, and you can access these settings by right-clicking within the Strings window and selecting Setup. As shown in <a class="xref" href="ch05s03.html#the_setup_strings_window" title="Figure 5-7. The Setup Strings window">Figure 5-7</a>, the Setup Strings window is used to specify the types of strings that IDA should scan for. The default string type that IDA scans for is a C-style, null-terminated, 7-bit, ASCII string of at least five characters in length.<a class="indexterm" id="IDX-CHP-5-0093"/><a class="indexterm" id="IDX-CHP-5-0094"/></p><div class="figure"><a id="the_setup_strings_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e5179"/><img alt="The Setup Strings window" src="httpatomoreillycomsourcenostarchimages854117.png.jpg"/></div></div><p class="title">Figure 5-7. The Setup Strings window</p></div><p>If you expect to encounter anything other than C-style strings, you should reconfigure the Setup Strings window to choose the appropriate string type to search for. For example, Windows programs often make use of Unicode strings, while Borland Delphi binaries use Pascal-style strings with a 2-byte length. Every time you close the Setup Strings window by clicking OK, IDA will rescan the database for strings in accordance with the new settings. Two setup options deserve special mention:<a class="indexterm" id="IDX-CHP-5-0095"/><a class="indexterm" id="IDX-CHP-5-0096"/><a class="indexterm" id="IDX-CHP-5-0097"/><a class="indexterm" id="IDX-CHP-5-0098"/><a class="indexterm" id="IDX-CHP-5-0099"/><a class="indexterm" id="IDX-CHP-5-0100"/><a class="indexterm" id="IDX-CHP-5-0101"/><a class="indexterm" id="IDX-CHP-5-0102"/><a class="indexterm" id="IDX-CHP-5-0103"/><a class="indexterm" id="IDX-CHP-5-0104"/><a class="indexterm" id="IDX-CHP-5-0105"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Display only defined strings</strong></span></span></dt><dd><p>This option restricts the Strings window to displaying only named string data items that have been automatically created by IDA or manually created by the user. With this option selected, all other options are disabled, and IDA will not automatically scan for additional string content.</p></dd><dt><span class="term"><span class="strong"><strong>Ignore instructions/data definitions</strong></span></span></dt><dd><p>This option causes IDA to scan for strings across instruction and existing data definitions. Using this option allows IDA to (1) see strings that may be embedded in the code portion of a binary and have been mistakenly converted into instructions or (2) to see strings within data that may be formatted as something other than a string (such as an array of bytes or integers). This option will also lead to the generation of many <span class="emphasis"><em>junk</em></span> strings, which are sequences that happen to consist of five or more ASCII characters whether or not they are legible. The effect of using this option is similar to using the <code class="literal">strings</code> command with the <code class="literal">-a</code> switch.</p></dd></dl></div><p><a class="xref" href="ch05s03.html#example_of_undetected_string_data" title="Figure 5-8. Example of undetected string data">Figure 5-8</a> demonstrates that IDA does not necessarily show all strings within a binary if the strings setup is not configured properly. In this case, Ignore instructions/data definitions has not been selected.</p><div class="figure"><a id="example_of_undetected_string_data"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e5254"/><img alt="Example of undetected string data" src="httpatomoreillycomsourcenostarchimages854119.png.jpg"/></div></div><p class="title">Figure 5-8. Example of undetected string data</p></div><p>The result is that the string at location <code class="literal">.rdata:0040C19C</code> (“Please guess a number between 1 and %d.”) remains undetected. The moral here is to make sure that you are looking for all of the types of strings you expect to encounter in all of the places you might find them.<a class="indexterm" id="IDX-CHP-5-0106"/><a class="indexterm" id="IDX-CHP-5-0107"/><a class="indexterm" id="IDX-CHP-5-0108"/><a class="indexterm" id="IDX-CHP-5-0109"/></p></div><div class="sect2" title="The Names Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_names_window"/>The Names Window</h2></div></div></div><p>The Names window, shown in <a class="xref" href="ch05s03.html#the_names_window-id1" title="Figure 5-9. The Names window">Figure 5-9</a>, provides a summary listing of all of the global names within a binary. A <span class="emphasis"><em>name</em></span> is nothing more than a symbolic description given to a program virtual address. IDA initially derives the list of names from symbol-table and signature analysis during the initial loading of a file. Names can be sorted alphabetically or in virtual address order (either ascending or descending). The Names window is useful for rapidly navigating to known locations within a program listing. Double-clicking any Names window entry will immediately jump the disassembly view to display the selected name.<a class="indexterm" id="IDX-CHP-5-0110"/></p><div class="figure"><a id="the_names_window-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e5298"/><img alt="The Names window" src="httpatomoreillycomsourcenostarchimages854121.png.jpg"/></div></div><p class="title">Figure 5-9. The Names window</p></div><p>Displayed names are both color and letter coded. The coding scheme is summarized below:<a class="indexterm" id="IDX-CHP-5-0111"/><a class="indexterm" id="IDX-CHP-5-0112"/><a class="indexterm" id="IDX-CHP-5-0113"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>F</strong></span></p></td><td style="text-align: left" valign="top"><p>A regular function. These are functions that IDA does not recognize as library functions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>L</strong></span></p></td><td style="text-align: left" valign="top"><p>A library function. IDA recognizes library functions through the use of signature-matching algorithms. If a signature does not exist for a given library function, the function will be labeled as a regular function instead.</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>I</strong></span></p></td><td style="text-align: left" valign="top"><p>An imported name, most commonly a function name imported from a shared library. The difference between this and a library function is that no code is present for an imported name, while the body of a library function will be present in the disassembly.</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>C</strong></span></p></td><td style="text-align: left" valign="top"><p>Named code. These are named program instruction locations that IDA does not consider to be part of any function. This is possible when IDA finds a name in a program’s symbol table but never sees a <code class="literal">call</code> to the corresponding program location.</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>D</strong></span></p></td><td style="text-align: left" valign="top"><p>Data. Named data locations typically represent global variables.</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>A</strong></span></p></td><td style="text-align: left" valign="top"><p>String data. This is a referenced data location containing a sequence of characters that conform to one of IDA’s known string data types, such as a null-terminated ASCII C string.</p></td></tr></tbody></table></div><p>As you browse through disassemblies, you will notice that there are many named locations for which no name is listed in the Names window. In the process of disassembling a program, IDA generates names for all locations that are referenced directly either as code (a branch or call target) or as data (read, written, or address taken). If a location is named in the program’s symbol table, IDA adopts the name from the symbol table. If no symbol table entry is available for a given program location, IDA generates a default name for use in the disassembly. When IDA chooses to name a location, the virtual address of the location is combined with a prefix that indicates what type of location is being named. Incorporating the virtual address into a generated name ensures that all generated names will be unique, as no two locations can share the same virtual address. Autogenerated names of this type are not displayed in the Names window. Some of the more common prefixes used for autogenerated names include these:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><strong class="userinput"><code>sub_</code></strong><strong class="userinput"><code><em class="replaceable"><code>xxxxxx</code></em></code></strong></p></td><td style="text-align: left" valign="top"><p>A subroutine at address <em class="replaceable"><code>xxxxxx</code></em></p></td></tr><tr><td style="text-align: left" valign="top"><p><strong class="userinput"><code>loc_</code></strong><strong class="userinput"><code><em class="replaceable"><code>xxxxxx</code></em></code></strong></p></td><td style="text-align: left" valign="top"><p>An instruction location at address <em class="replaceable"><code>xxxxxx</code></em></p></td></tr><tr><td style="text-align: left" valign="top"><p><strong class="userinput"><code>byte_</code></strong><strong class="userinput"><code><em class="replaceable"><code>xxxxxx</code></em></code></strong></p></td><td style="text-align: left" valign="top"><p>8-bit data at location <em class="replaceable"><code>xxxxxx</code></em></p></td></tr><tr><td style="text-align: left" valign="top"><p><strong class="userinput"><code>word_</code></strong><strong class="userinput"><code><em class="replaceable"><code>xxxxxx</code></em></code></strong></p></td><td style="text-align: left" valign="top"><p>16-bit data at location <em class="replaceable"><code>xxxxxx</code></em></p></td></tr><tr><td style="text-align: left" valign="top"><p><strong class="userinput"><code>dword_</code></strong><strong class="userinput"><code><em class="replaceable"><code>xxxxxx</code></em></code></strong></p></td><td style="text-align: left" valign="top"><p>32-bit data at location <em class="replaceable"><code>xxxxxx</code></em></p></td></tr><tr><td style="text-align: left" valign="top"><p><strong class="userinput"><code>unk_</code></strong><strong class="userinput"><code><em class="replaceable"><code>xxxxxx</code></em></code></strong></p></td><td style="text-align: left" valign="top"><p>Data of unknown size at location <em class="replaceable"><code>xxxxxx</code></em></p></td></tr></tbody></table></div><p>Throughout the course of the book we will show additional algorithms that IDA applies in choosing names for program data locations.<a class="indexterm" id="IDX-CHP-5-0114"/><a class="indexterm" id="IDX-CHP-5-0115"/><a class="indexterm" id="IDX-CHP-5-0116"/><a class="indexterm" id="IDX-CHP-5-0117"/><a class="indexterm" id="IDX-CHP-5-0118"/><a class="indexterm" id="IDX-CHP-5-0119"/></p></div><div class="sect2" title="The Segments Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_segments_window"/>The Segments Window</h2></div></div></div><p>The Segments window displays a summary listing of the segments present in the binary file. Note that what IDA terms <span class="emphasis"><em>segments</em></span> are most often called <span class="emphasis"><em>sections</em></span> when discussing the structure of binary files. Do not confuse the use of the term <span class="emphasis"><em>segments</em></span> in this manner with the memory segments associated with CPUs that implement a segmented memory architecture. Information presented in the window includes the segment name, start and end addresses, and permission flags. The start and end addresses represent the virtual address range to which the program sections will be mapped at runtime. The following listing is an example of Segments window content from a Windows binary:<a class="indexterm" id="IDX-CHP-5-0120"/><a class="indexterm" id="IDX-CHP-5-0121"/></p><a id="I_programlisting2_d1e5515"/><pre class="programlisting">Name   Start    End      R W X D L Align  Base
 Type   Class  AD es   ss   ds   fs       gs
UPX0   00401000 00407000 R W X . L para   0001 public CODE   32
 0000 0000 0001 FFFFFFFF FFFFFFFF
UPX1   00407000 00408000 R W X . L para   0002 public CODE   32
 0000 0000 0001 FFFFFFFF FFFFFFFF
UPX2   00408000 0040803C R W . . L para   0003 public DATA   32
 0000 0000 0001 FFFFFFFF FFFFFFFF
.idata 0040803C 00408050 R W . . L para   0003 public XTRN   32
 0000 0000 0001 FFFFFFFF FFFFFFFF
UPX2   00408050 00409000 R W . . L para   0003 public DATA   32
 0000 0000 0001 FFFFFFFF FFFFFFFF</pre><p>In this case, we might quickly suspect that something is funny with this particular binary since it uses nonstandard segment names and has two executable segments that are writable, thus indicating the possibility of self-modifying code (more on this in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>). The fact that IDA knows the size of a segment does not indicate that IDA knows the contents of the segment. For a variety of reasons, segments often occupy less space on disk than they do in memory. In such cases, IDA displays values for the portions of the segment that IDA has determined it could fill from the disk file. For the remainder of the segment, IDA displays question marks.</p><p>Double-clicking any entry in the window jumps the disassembly view to the start of the selected segment. Right-clicking an entry provides a context menu from which you can add new segments, delete existing segments, or edit the properties of existing segments. These features are particularly useful when reverse engineering files with nonstandard formats, as the binary’s segment structure may not have been detected by the IDA loader.</p><p>Command-line counterparts to the Segments window include <code class="literal">objdump</code> (<code class="literal">-h</code>), <code class="literal">readelf</code> (<code class="literal">-S</code>), and <code class="literal">dumpbin</code> (<code class="literal">/HEADERS</code>).</p></div><div class="sect2" title="The Signatures Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_signatures_window"/>The Signatures Window</h2></div></div></div><p>IDA makes use of an extensive library of signatures for identifying known blocks of code. Signatures are used to identify common compiler-generated startup sequences in an attempt to determine the compiler that may have been used to build a given binary. Signatures are also used to categorize functions as known library functions inserted by a compiler or as functions added to the binary as a result of static linking. When IDA identifies library functions for you, you can focus more of your effort on the code that IDA did not recognize (which is probably far more interesting to you than reverse engineering the inner workings of <code class="literal">printf</code>).<a class="indexterm" id="IDX-CHP-5-0122"/><a class="indexterm" id="IDX-CHP-5-0123"/><a class="indexterm" id="IDX-CHP-5-0124"/><a class="indexterm" id="IDX-CHP-5-0125"/><a class="indexterm" id="IDX-CHP-5-0126"/><a class="indexterm" id="IDX-CHP-5-0127"/><a class="indexterm" id="IDX-CHP-5-0128"/></p><p>The Signatures window is used to list the signatures that IDA has already matched against the open binary file. An example from a Windows PE file is shown here:</p><a id="I_programlisting2_d1e5579"/><pre class="programlisting">File      State     #func  Library name
vc32rtf   Applied   501    Microsoft VisualC 2-8/net runtime</pre><p>This example indicates that IDA has applied the <code class="literal">vc32rtf</code> signatures (from <span class="emphasis"><em>&lt;IDADIR&gt;/sigs</em></span>) against the binary and, in doing so, has been able to recognize 501 functions as library functions. That’s 501 functions that you will not need to reverse engineer!</p><p>In at least two cases, you will want to know how to apply additional signatures against your binaries. In the first case, IDA may fail to recognize the compiler that was used to build a binary, with a resulting inability to select appropriate signatures to apply. In this case, you may wish to force IDA to apply one or more signatures that your preliminary analysis has led you to believe IDA should try. The second situation involves creating your own signatures for libraries that may not have existing signatures included with IDA. An example might be the creation of signatures for the static version of the OpenSSL libraries that ship with FreeBSD 8.0. DataRescue makes a toolkit available for generating custom signatures that can be used by IDA’s signature-matching engine. We’ll cover the generation of custom signatures in <a class="xref" href="ch12.html" title="Chapter 12. Library Recognition Using FLIRT Signatures">Chapter 12</a>. Regardless of why you want to apply new signatures, either pressing the <span class="keycap">insert</span> key or right-clicking the Signatures window will offer you the Apply new signature option, at which time you can choose from a list of all signatures known to your installation of IDA.</p></div><div class="sect2" title="The Type Libraries Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_type_libraries_window"/>The Type Libraries Window</h2></div></div></div><p>Similar in concept to the Signatures window is the Type Libraries window. Type libraries represent IDA’s accumulated knowledge of predefined datatypes and function prototypes gleaned from header files included with most popular compilers. By processing header files, IDA understands the datatypes that are expected by common library functions and can annotate your disassemblies accordingly. Similarly, from these header files IDA understands both the size and layout of complex data structures. All of this type information is collected into TIL files (<span class="emphasis"><em>&lt;IDADIR&gt;/til</em></span>) and applied any time a binary is analyzed. As with signatures, IDA must first be able to deduce the libraries that a program uses before it can select an appropriate set of TIL files to load. You can request that IDA load additional type libraries by pressing the <span class="keycap">insert</span> key or by right-clicking within the Type Libraries window and choosing Load type library. Type libraries are covered in more detail in <a class="xref" href="ch13.html" title="Chapter 13. Extending IDA’s Knowledge">Chapter 13</a>.<a class="indexterm" id="IDX-CHP-5-0129"/></p></div><div class="sect2" title="The Function Calls Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_function_calls_window"/>The Function Calls Window</h2></div></div></div><p>In any program, a function can both call and be called by other functions. In fact, it is a fairly simple task to construct a graph that displays the relationships between callers and callees. Such a graph is called a <span class="emphasis"><em>function call graph</em></span> or <span class="emphasis"><em>function call tree</em></span> (we will demonstrate how to have IDA generate such graphs in <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>). On occasion, we may not be interested in seeing the entire call graph of a program; instead, we may be interested only in knowing the immediate neighbors of a given function. For our purposes, we will call Y a neighbor of X if Y directly calls X or X directly calls Y.<a class="indexterm" id="IDX-CHP-5-0130"/><a class="indexterm" id="IDX-CHP-5-0131"/><a class="indexterm" id="IDX-CHP-5-0132"/><a class="indexterm" id="IDX-CHP-5-0133"/><a class="indexterm" id="IDX-CHP-5-0134"/><a class="indexterm" id="IDX-CHP-5-0135"/><a class="indexterm" id="IDX-CHP-5-0136"/><a class="indexterm" id="IDX-CHP-5-0137"/><a class="indexterm" id="IDX-CHP-5-0138"/></p><p>The Function Calls window provides the answer to this neighbor question. When you open the Function Calls window, IDA determines the neighbors of the function in which the cursor is positioned and generates a display such as that shown in <a class="xref" href="ch05s03.html#the_function_calls_window-id1" title="Figure 5-10. The Function Calls window">Figure 5-10</a>.<a class="indexterm" id="IDX-CHP-5-0139"/></p><div class="figure"><a id="the_function_calls_window-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e5685"/><img alt="The Function Calls window" src="httpatomoreillycomsourcenostarchimages854123.png"/></div></div><p class="title">Figure 5-10. The Function Calls window</p></div><p>In this example, we see that the function named <code class="literal">sub_40182C</code> is called from six different locations in <code class="literal">_main</code> and <code class="literal">_main</code> in turn makes 15 other function calls. Double-clicking any line within the Function Calls window immediately jumps the disassembly window to the selected calling or called function (or caller and callee). IDA cross-references (xrefs) are the mechanisms that underlie the generation of the Function Calls windows. Xrefs will be covered in more detail in <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>.</p></div><div class="sect2" title="The Problems Window"><div class="titlepage"><div><div><h2 class="title"><a id="the_problems_window"/>The Problems Window</h2></div></div></div><p>The Problems window is IDA’s way of informing you of any difficulties that it has encountered in disassembling a binary and how it has chosen to deal with those difficulties. In some instances, you may be able to manipulate the disassembly to help IDA overcome a problem, and in other instances you may not. You can expect to encounter problems in even the simplest of binaries. In many cases, simply choosing to ignore the problems is not a bad strategy. In order to correct many of the problems, you need to have a better understanding of the binary than IDA has, which for most of us is probably not going to happen. A sample set of problems follows:<a class="indexterm" id="IDX-CHP-5-0140"/><a class="indexterm" id="IDX-CHP-5-0141"/></p><a id="I_programlisting2_d1e5714"/><pre class="programlisting">Address          Type       Instruction
.text:0040104C   BOUNDS     call    eax
.text:004010B0   BOUNDS     call    eax
.text:00401108   BOUNDS     call    eax
.text:00401350   BOUNDS     call    dword ptr [eax]
.text:004012A0   DECISION   push    ebp
.text:004012D0   DECISION   push    ebp
.text:00401560   DECISION   jmp     ds:__set_app_type
.text:004015F8   DECISION   dd 0FFFFFFFFh
.text:004015FC   DECISION   dd 0</pre><p>Each problem is characterized by (1) the address at which the problem occurs, (2) the type of problem encountered, and (3) the instruction present at the problem location. In this example, we see a <code class="literal">BOUNDS</code> problem and a <code class="literal">DECISION</code> problem. A <code class="literal">BOUNDS</code> problem occurs when the destination of a <code class="literal">call</code> or <code class="literal">jump</code> either can’t be determined (as in this example, since the value of <code class="literal">eax</code> is unknown to IDA) or appears to lie outside the range of virtual addresses in a program. A <code class="literal">DECISION</code> problem is most often not a problem at all. A <code class="literal">DECISION</code> usually represents an address at which IDA has chosen to disassemble bytes as instructions rather than data even though the address has never been referenced during the recursive descent instruction traversal (see <a class="xref" href="ch01.html" title="Chapter 1. Introduction to Disassembly">Chapter 1</a>). A complete list of problem types and suggestions for how to deal with them is available in the built-in IDA help file (see topic <span class="emphasis"><em>Problems List</em></span>).</p></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id4"/>Summary</h1></div></div></div><p>At first glance, the number of displays that IDA offers can seem overwhelming. You may find it easiest to stick with the primary displays until you are comfortable enough to begin exploring the additional display offerings. In any case, you should certainly not feel obligated to use everything that IDA throws at you. Not every window will be useful in every reverse engineering scenario.</p><p>In addition to the windows covered in this chapter, you will be confronted by a tremendous number of dialogs as you endeavor to master IDA. We will introduce key dialogs as they become relevant in the remainder of the book. Finally, other than the default disassembly view graph, we have elected not to cover graphs in this chapter. The IDA menu system distinguishes graphs as a separate category of display from the subviews discussed in this chapter. We will cover the reasons behind this in <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>, which deals exclusively with graphs.</p><p>At this point, you should be starting to get comfortable with the IDA user interface. In the next chapter, we begin to focus on the many ways that you can manipulate a disassembly to enhance your understanding of its behavior and to generally make your life easier with IDA.</p></div>
<div class="chapter" title="Chapter&#xA0;6.&#xA0;Disassembly Navigation"><div class="titlepage"><div><div><h1 class="title"><a id="disassembly_navigation"/>Chapter 6. Disassembly Navigation</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id6"/><div class="mediaobject"><a id="I_mediaobject3_d1e5763"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>In this and the following chapter we cover the heart of what puts the <span class="emphasis"><em>Interactive</em></span> in <span class="emphasis"><em>IDA Pro</em></span>, which is, in a nutshell, ease of navigation and ease of manipulation. The focus of this chapter is navigation; specifically, we show how IDA facilitates moving around a disassembly in a logical manner. So far, we have shown that at a basic level IDA simply combines the features of many common reverse engineering tools into an integrated disassembly display. Navigating around the display is one of the essential skills required in order to master IDA. Static disassembly listings offer no inherent navigational capability other than scrolling up and down the listing. Even with the best text editors, such <span class="emphasis"><em>dead listings</em></span> are very difficult to navigate, as the best they have to offer is generally nothing more than an integrated, <code class="literal">grep</code>-style search. As you shall see, IDA’s database underpinnings provide for exceptional navigational features.<a class="indexterm" id="IDX-CHP-6-0001"/></p><div class="sect1" title="Basic IDA Navigation"><div class="titlepage"><div><div><h1 class="title"><a id="basic_ida_navigation"/>Basic IDA Navigation</h1></div></div></div><p>In your initial experience with IDA, you may be happy to make use of nothing more than the navigational features that IDA has to offer. In addition to offering fairly standard search features that you are accustomed to from your use of text editors or word processors, IDA develops and displays a comprehensive list of cross-references that behave in a manner similar to hyperlinks on a web page. The end result is that, in most cases, navigating to locations of interest requires nothing more than a double-click.<a class="indexterm" id="IDX-CHP-6-0002"/><a class="indexterm" id="IDX-CHP-6-0003"/><a class="indexterm" id="IDX-CHP-6-0004"/><a class="indexterm" id="IDX-CHP-6-0005"/></p><div class="sect2" title="Double-Click Navigation"><div class="titlepage"><div><div><h2 class="title"><a id="double-click_navigation"/>Double-Click Navigation</h2></div></div></div><p>When a program is disassembled, every location in the program is assigned a virtual address. As a result, we can navigate anywhere within a program by providing the virtual address of the location we are interested in visiting. Unfortunately for us, maintaining a catalog of addresses in our head is not a trivial task. This fact motivated early programmers to assign symbolic names to program locations that they wished to reference, making things a whole lot easier on themselves. The assignment of symbolic names to program addresses was not unlike the assignment of mnemonic instruction names to program opcodes; programs became easier to read and write by making them easier to remember.</p><p>As we discussed previously, IDA generates symbolic names during the analysis phase by examining a binary’s symbol table or by automatically generating a name based on how a location is referenced within the binary. In addition to its symbolic purpose, any name displayed in the disassembly window is a potential navigation target similar to a hyperlink on a web page. The two differences between these names and standard hyperlinks are (1) that the names are never highlighted in any way to indicate that they can be followed and (2) that IDA requires a double-click to follow rather than the single-click required by a hyperlink. We have already seen the use of names in various subwindows such as the Functions, Imports, and Exports windows. Recall that for each of these windows, double-clicking a name caused the disassembly view to jump to the referenced location. This is one example of the double-click navigation at work. In the following listing, each of the symbols labeled <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5809"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> represents a named navigational target. Double-clicking any of them will cause IDA to relocate the display to the selected location.<a class="indexterm" id="IDX-CHP-6-0006"/><a class="indexterm" id="IDX-CHP-6-0007"/></p><a id="I_programlisting3_d1e5823"/><pre class="programlisting">.text:0040132B loc_40132B:                   ; CODE XREF: <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>sub_4012E4+B^j
.text:0040132B       cmp     edx, 0CDh
.text:00401331       jg      short <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>loc_40134E
.text:00401333       jz      <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>loc_4013BF
.text:00401339       sub     edx, 0Ah
.text:0040133C       jz      short <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>loc_4013A7
.text:0040133E       sub     edx, 0C1h
.text:00401344       jz      short <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>loc_4013AF
.text:00401346       dec     edx
.text:00401347       jz      short <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>loc_4013B7
.text:00401349       jmp     <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>loc_4013DD   ; default
.text:00401349                              ; jumptable 00401300 case 0
.text:0040134E ; ----------------------------------------------------------
.text:0040134E
.text:0040134E loc_40134E:                   ; CODE XREF: <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>sub_4012E4+4D^j</pre><p>For navigational purposes, IDA treats two additional display entities as navigational targets. First, cross-references (shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5876"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> here) are treated as navigational targets. Cross-references are generally formated as a name and a hex offset. The cross-reference at the right of <code class="literal">loc_40134E</code> in the previous listing refers to a location that is <code class="literal">4D<sub>16</sub></code> or <code class="literal">77<sub>10</sub></code> bytes beyond the start of <code class="literal">sub_4012E4</code>. Double-clicking the cross-reference text will jump the display to the referencing location (<code class="literal">00401331</code> in this case). Cross-references are covered in more detail in <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>.<a class="indexterm" id="IDX-CHP-6-0008"/><a class="indexterm" id="IDX-CHP-6-0009"/></p><p>The second type of display entity afforded special treatment in a navigational sense is one that uses hexadecimal values. If a displayed hexadecimal value represents a valid virtual address within the binary, then double-clicking the value will reposition the disassembly window to display the selected virtual address. In the listing that follows, double-clicking any of the values indicated by <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5916"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> will jump the display, because each is a valid virtual address within the given binary, while double-clicking any of the values indicated by <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5922"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> will have no effect.<a class="indexterm" id="IDX-CHP-6-0010"/><a class="indexterm" id="IDX-CHP-6-0011"/></p><a id="I_programlisting3_d1e5936"/><pre class="programlisting">.data:00409013       db    <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>4
.data:00409014       dd <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>4037B0h
.data:00409018       db    <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>0
.data:00409019       db  <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>0Ah
.data:0040901A       dd <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>404590h
.data:0040901E       db    <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>0
.data:0040901F       db  <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>0Ah
.data:00409020       dd <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>404DA8h</pre><p>A final note about double-click navigation concerns the IDA Output window, which is most often used to display informational messages. When a navigational target, as previously described, appears as the first item in a message, double-clicking the message will jump the display to the indicated target.</p><a id="I_programlisting3_d1e5989"/><pre class="programlisting">Propagating type information...
  Function argument information has been propagated
  The initial autoanalysis has been finished.
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> 40134e is an interesting location
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/> Testing: 40134e
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> loc_4013B7
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/> Testing: loc_4013B7</pre><p>In the Output window excerpt just shown, the two messages indicated by <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6017"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> can be used to navigate to the addresses indicated at the start of the respective messages. Double-clicking any of the other messages, including those at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6023"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>, will result in no action at all.</p></div><div class="sect2" title="Jump to Address"><div class="titlepage"><div><div><h2 class="title"><a id="jump_to_address"/>Jump to Address</h2></div></div></div><p>Occasionally, you will know exactly what address you would like to navigate to, yet no name will be handy in the disassembly window to offer simple double-click navigation. In such a case, you have a few options. The first, and most primitive, option is to use the disassembly window scroll bar to scroll the display up or down until the desired location comes into view. This is usually feasible only when the location you are navigating to is known by its virtual address, since the disassembly window is organized linearly by virtual address. If all you know is a named location such as a subroutine named <code class="literal">foobar</code>, then navigating via the scroll bar becomes something of a needle-in-a-haystack search. At that point, you might choose to sort the Functions window alphabetically, scroll to the desired name, and double-click the name. A third option is to use one of IDA’s search features available via the Search menu, which typically involves specifying some search criteria before asking IDA to perform a search. In the case of searching for a known location, this is usually overkill.<a class="indexterm" id="IDX-CHP-6-0012"/><a class="indexterm" id="IDX-CHP-6-0013"/><a class="indexterm" id="IDX-CHP-6-0014"/><a class="indexterm" id="IDX-CHP-6-0015"/><a class="indexterm" id="IDX-CHP-6-0016"/><a class="indexterm" id="IDX-CHP-6-0017"/><a class="indexterm" id="IDX-CHP-6-0018"/><a class="indexterm" id="IDX-CHP-6-0019"/><a class="indexterm" id="IDX-CHP-6-0020"/><a class="indexterm" id="IDX-CHP-6-0021"/></p><p>Ultimately, the easiest way to get to a known disassembly location is to make use of the Jump to Address dialog shown in <a class="xref" href="ch06.html#the_jump_to_address_dialog" title="Figure 6-1. The Jump to Address dialog">Figure 6-1</a>.<a class="indexterm" id="IDX-CHP-6-0022"/><a class="indexterm" id="IDX-CHP-6-0023"/></p><div class="figure"><a id="the_jump_to_address_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e6085"/><img alt="The Jump to Address dialog" src="httpatomoreillycomsourcenostarchimages854125.png.jpg"/></div></div><p class="title">Figure 6-1. The Jump to Address dialog</p></div><p>The Jump to Address dialog is accessed via Jump ▸ Jump to Address, or by using the G hotkey while the disassembly window is active. Thinking of this dialog as the <span class="emphasis"><em>Go</em></span> dialog may help you remember the associated hotkey. Navigating to any location in the binary is as simple as specifying the address (a name or hex value will do) and clicking OK, which will immediately jump the display to the desired location. Values entered into the dialog are remembered and made available on subsequent use via a drop-down list. This history feature makes returning to previously requested locations somewhat easier.<a class="indexterm" id="IDX-CHP-6-0024"/></p></div><div class="sect2" title="Navigation History"><div class="titlepage"><div><div><h2 class="title"><a id="navigation_history"/>Navigation History</h2></div></div></div><p>If we compare IDA’s document-navigation functions to those of a web browser, we might equate names and addresses to hyperlinks, as each can be followed relatively easily to view a new location. Another feature IDA shares with traditional web browsers is the concept of forward and backward navigation based on the order in which you navigate the disassembly. Each time you navigate to a new location within a disassembly, your current location is appended to a history list. Two menu operations are available for traversing this list. First, Jump ▸ Jump to Previous Position repositions the disassembly to the most recent entry in the history list. The behavior is conceptually identical to a web browser’s <span class="emphasis"><em>back</em></span> button. The associated hotkey is <span class="keycap">esc</span>, and it is one of the most useful hotkeys that you can commit to memory. Be forewarned, however, that using <span class="keycap">esc</span> when any window other than the disassembly window is active causes the active window to be closed. (You can always reopen windows that you closed accidentally via View ▸ Open Subviews.) Backward navigation is extremely handy when you have followed a chain of function calls several levels deep and you decide that you want to navigate back to your original position within the disassembly.<a class="indexterm" id="IDX-CHP-6-0025"/><a class="indexterm" id="IDX-CHP-6-0026"/><a class="indexterm" id="IDX-CHP-6-0027"/><a class="indexterm" id="IDX-CHP-6-0028"/><a class="indexterm" id="IDX-CHP-6-0029"/><a class="indexterm" id="IDX-CHP-6-0030"/><a class="indexterm" id="IDX-CHP-6-0031"/><a class="indexterm" id="IDX-CHP-6-0032"/><a class="indexterm" id="IDX-CHP-6-0033"/><a class="indexterm" id="IDX-CHP-6-0034"/><a class="indexterm" id="IDX-CHP-6-0035"/></p><p>Jump ▸ Jump to Next Position is the counterpart operation that moves the disassembly window forward in the history list in a manner similar to a web browser’s <span class="emphasis"><em>forward</em></span> button. For the sake of completeness, the associated hotkey for this operation is <span class="keycap">ctrl</span>-<span class="keycap">enter</span>, though it tends to be less useful than using <span class="keycap">esc</span> for backward navigation.</p><p>Finally, two of the more useful toolbar buttons, shown in <a class="xref" href="ch06.html#forward_and_backward_navigation_buttons" title="Figure 6-2. Forward and backward navigation buttons">Figure 6-2</a>, provide the familiar browser-style forward and backward behavior. Each of the buttons is associated with a drop-down history list that offers you instant access to any location in the navigation history without having to trace your steps through the entire list.</p><div class="figure"><a id="forward_and_backward_navigation_buttons"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e6173"/><img alt="Forward and backward navigation buttons" src="httpatomoreillycomsourcenostarchimages854127.png.jpg"/></div></div><p class="title">Figure 6-2. Forward and backward navigation buttons</p></div></div></div></div>
<div class="sect1" title="Stack Frames"><div class="titlepage"><div><div><h1 class="title"><a id="stack_frames"/>Stack Frames</h1></div></div></div><p>Because IDA Pro is such a low-level analysis tool, many of its features and displays expect the user to be somewhat familiar with the low-level details of compiled languages, many of which center on the specifics of generating machine language and managing the memory used by a high-level program. Therefore, from time to time this book covers some of the theory of compiled programs in order to make sense of the related IDA displays.</p><p>One such low-level concept is that of the stack frame. <span class="emphasis"><em>Stack frames</em></span> are blocks of memory allocated within a program’s runtime stack and dedicated to a specific invocation of a function. Programmers typically group executable statements into units called <span class="emphasis"><em>functions</em></span> (also called <span class="emphasis"><em>procedures</em></span>, <span class="emphasis"><em>subroutines</em></span>, or <span class="emphasis"><em>methods</em></span>). In some cases this may be a requirement of the language being used. In most cases it is considered good programming practice to build programs from such functional units.</p><p>When a function is not executing, it typically requires little to no memory. When a function is called, however, it may require memory for several reasons. First, the caller of a function may wish to pass information into the function in the form of parameters (arguments), and these parameters need to be stored somewhere the function can find them. Second, the function may need temporary storage space while performing its task. This temporary space is often allocated by a programmer through the declaration of local variables, which can be used within the function but cannot be accessed once the function has completed.</p><p>Compilers utilize stack frames (also called <span class="emphasis"><em>activation records</em></span>) to make the allocation and deallocation of function parameters and local variables transparent to the programmer. A compiler inserts code to place a function’s parameters into the stack frame prior to transferring control to the function itself, at which point the compiler inserts code to allocate enough memory to hold the function’s local variables. As a consequence of the way stack frames are constructed, the address to which the function should return is also stored within the new stack frame. A pleasant result of the use of stack frames is that recursion becomes possible, as each recursive call to a function is given its own stack frame, neatly segregating each call from its predecessor. The following steps detail the operations that take place when a function is called:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The caller places any parameters required by the function being called into locations as dictated by the calling convention (see <a class="xref" href="ch06s02.html#calling_conventions" title="Calling Conventions">Calling Conventions</a> in <a class="xref" href="ch06s02.html#calling_conventions" title="Calling Conventions">Calling Conventions</a>) employed by the called function. This operation may result in a change to the program stack pointer if parameters are placed on the runtime stack.<a class="indexterm" id="IDX-CHP-6-0036"/></p></li><li class="listitem"><p>The caller transfers control to the function being called. This is usually performed with an instruction such as the x86 <code class="literal">CALL</code> or the MIPS <code class="literal">JAL</code>. A return address is typically saved onto the program stack or in a CPU register.</p></li><li class="listitem"><p>If necessary, the called function takes steps to configure a frame pointer<sup>[<a class="footnote" href="#ftn.CHP-6-FN-1" id="CHP-6-FN-1">42</a>]</sup> and saves any register values that the caller expects to remain unchanged.<a class="indexterm" id="IDX-CHP-6-0037"/></p></li><li class="listitem"><p>The called function allocates space for any local variables that it may require. This is often done by adjusting the program stack pointer to reserve space on the runtime stack.</p></li><li class="listitem"><p>The called function performs its operations, potentially generating a result. In the course of performing its operations, the called function may access the parameters passed to it by the calling function. If the function returns a result, the result is often placed into a specific register or registers that the caller can examine once the function returns.</p></li><li class="listitem"><p>Once the function has completed its operations, any stack space reserved for local variables is released. This is often done by reversing the actions performed in step 4.</p></li><li class="listitem"><p>Any registers whose values were saved (in step 3) on behalf of the caller are restored to their original values. This includes the restoration of the caller’s frame pointer register.</p></li><li class="listitem"><p>The called function returns control to the caller. Typical instructions for this include the x86 <code class="literal">RET</code> and the MIPS <code class="literal">JR</code> instructions. Depending on the calling convention in use, this operation may also serve to clear one or more parameters from the program stack.</p></li><li class="listitem"><p>Once the caller regains control, it may need to remove parameters from the program stack. In such cases a stack adjustment may be required to restore the program stack pointer to the value that it held prior to step 1.</p></li></ol></div><p>Steps 3 and 4 are so commonly performed upon entry to a function that together they are called the function’s <span class="emphasis"><em>prologue</em></span>. Similarly, steps 6 through 8 are so frequently performed at the end of a function that together they make up the function’s <span class="emphasis"><em>epilogue</em></span>. With the exception of step 5, which represents the body of the function, all of these operations constitute the overhead associated with calling a function.<a class="indexterm" id="IDX-CHP-6-0038"/><a class="indexterm" id="IDX-CHP-6-0039"/><a class="indexterm" id="IDX-CHP-6-0040"/><a class="indexterm" id="IDX-CHP-6-0041"/><a class="indexterm" id="IDX-CHP-6-0042"/><a class="indexterm" id="IDX-CHP-6-0043"/></p><div class="sect2" title="Calling Conventions"><div class="titlepage"><div><div><h2 class="title"><a id="calling_conventions"/>Calling Conventions</h2></div></div></div><p>With a basic understanding of what stack frames are, we can take a closer look at exactly how they are structured. The examples that follow reference the x86 architecture and the behavior associated with common x86 compilers such as Microsoft Visual C/C++ or GNU’s gcc/g++. One of the most important steps in the creation of a stack frame involves the placement of function parameters onto the stack by the calling function. The calling function must store parameters exactly as the function being called expects to find them; otherwise, serious problems can arise. Functions advertise the manner in which they expect to receive their arguments by selecting and adhering to a specific calling convention.<a class="indexterm" id="IDX-CHP-6-0044"/></p><p>A <span class="emphasis"><em>calling convention</em></span> dictates exactly where a caller should place any parameters that a function requires. Calling conventions may require parameters to be placed in specific registers, on the program stack, or in both registers and on the stack. Equally important to when parameters are passed on the program stack is determining who is responsible for removing them from the stack once the called function has completed. Some calling conventions dictate that the caller is responsible for removing parameters that it placed on the stack, while other calling conventions dictate that the called function will take care of removing the parameters from the stack. Adherence to publicized calling conventions is essential in maintaining the integrity of the program stack pointer.</p><div class="sect3" title="The C Calling Convention"><div class="titlepage"><div><div><h3 class="title"><a id="the_c_calling_convention"/>The C Calling Convention</h3></div></div></div><p>The default calling convention used by most C compilers for the x86 architecture is called the <span class="emphasis"><em>C calling convention</em></span>. The <code class="literal">_cdecl</code> modifier may be used by C/C++ programs to force compilers to utilize the C calling convention when the default calling convention may have been overridden. We will refer to this calling convention as the <code class="literal">cdecl</code> calling convention from here on. The <code class="literal">cdecl</code> calling convention specifies that the caller place parameters to a function on the stack in right-to-left order and that the caller (as opposed to the callee) remove the parameters from the stack after the called function completes.</p><p>One result of placing parameters on the stack in right-to-left order is that the leftmost (first) parameter of the function will always be on the top of the stack when the function is called. This makes the first parameter easy to find regardless of the number of parameters the function expects, and it makes the <code class="literal">cdecl</code> calling convention ideally suited for use with functions that can take a variable number of arguments (such as <code class="literal">printf</code>).</p><p>Requiring the calling function to remove parameters from the stack means that you will often see instructions that make an adjustment to the program stack pointer immediately following the return from a called function. In the case of functions that can accept a variable number of arguments, the caller is ideally suited to make this adjustment, as the caller knows exactly how many arguments it has chosen to pass to the function and can easily make the correct adjustment, whereas the called function never knows ahead of time how many parameters it may receive and would have a difficult time making the necessary stack adjustment.<a class="indexterm" id="IDX-CHP-6-0045"/><a class="indexterm" id="IDX-CHP-6-0046"/><a class="indexterm" id="IDX-CHP-6-0047"/></p><p>In the following examples we consider calls to a function having the following prototype:</p><a id="I_programlisting3_d1e6347"/><pre class="programlisting">void demo_cdecl(int w, int x, int y, int z);</pre><p>By default, this function will use the <code class="literal">cdecl</code> calling convention, expecting the four parameters to be pushed in right-to-left order and requiring the caller to clean the parameters off the stack. A compiler might generate code for a call to this function as follows:</p><a id="I_programlisting3_d1e6354"/><pre class="programlisting">; demo_cdecl(1, 2, 3, 4);   //programmer calls demo_cdecl
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> push   4           ; push parameter z
  push   3           ; push parameter y
  push   2           ; push parameter x
  push   1           ; push parameter w
  call   demo_cdecl  ; call the function
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> add    esp, 16     ; adjust esp to its former value</pre><p>The four <code class="literal">push</code> operations beginning at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6373"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> result in a net change to the program stack pointer (ESP) of 16 bytes (<code class="literal">4 * sizeof(int)</code> on a 32-bit architecture), which is undone at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6382"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> following the return from <code class="literal">demo_cdecl</code>. If <code class="literal">demo_cdecl</code> is called 50 times, each call will be followed by an adjustment similar to that at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6395"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. The following example also adheres to the <code class="literal">cdecl</code> calling convention while eliminating the need for the caller to explicitly clean parameters off the stack following each call to <code class="literal">demo_cdecl</code>.</p><a id="I_programlisting3_d1e6407"/><pre class="programlisting">; demo_cdecl(1, 2, 3, 4);   //programmer calls demo_cdecl
   mov   [esp+12], 4   ; move parameter z to fourth position on stack
   mov   [esp+8], 3    ; move parameter y to third position on stack
   mov   [esp+4], 2    ; move parameter x to second position on stack
   mov   [esp], 1      ; move parameter w to top of stack
   call   demo_cdecl  ; call the function</pre><p>In this example, the compiler has preallocated storage space for the parameters to <code class="literal">demo_cdecl</code> at the top of the stack during the function prologue. When the parameters for <code class="literal">demo_cdecl</code> are placed on the stack, there is no change to the program stack pointer, which eliminates the need to adjust the stack pointer when the call to <code class="literal">demo_cdecl</code> completes. The GNU compilers (gcc and g++) utilize this technique to place function parameters onto the stack.<a class="indexterm" id="IDX-CHP-6-0048"/><a class="indexterm" id="IDX-CHP-6-0049"/><a class="indexterm" id="IDX-CHP-6-0050"/></p><p>Note that either method results in the stack pointer pointing to the leftmost argument when the function is called.<a class="indexterm" id="IDX-CHP-6-0051"/><a class="indexterm" id="IDX-CHP-6-0052"/><a class="indexterm" id="IDX-CHP-6-0053"/><a class="indexterm" id="IDX-CHP-6-0054"/><a class="indexterm" id="IDX-CHP-6-0055"/><a class="indexterm" id="IDX-CHP-6-0056"/></p></div><div class="sect3" title="The Standard Calling Convention"><div class="titlepage"><div><div><h3 class="title"><a id="the_standard_calling_convention"/>The Standard Calling Convention</h3></div></div></div><p><span class="emphasis"><em>Standard</em></span> in this case is a bit of a misnomer as it is a name that Microsoft created for its own calling convention marked by the use of the <code class="literal">_stdcall</code> modifier in a function declaration, as shown here:</p><a id="I_programlisting3_d1e6462"/><pre class="programlisting">void _stdcall demo_stdcall(int w, int x, int y);</pre><p>In order to avoid any confusion surrounding the word <span class="emphasis"><em>standard</em></span>, we will refer to this calling convention as the <code class="literal">stdcall</code> calling convention for the remainder of the book.</p><p>As with the <code class="literal">cdecl</code> calling convention, <code class="literal">stdcall</code> requires that function parameters be placed on the program stack in right-to-left order. The difference when using <code class="literal">stdcall</code> is that the called function is responsible for clearing the function parameters from the stack when the function has finished. In order for a function to do this, the function must know exactly how many parameters are on the stack. This is possible only for functions that accept a fixed number of parameters. As a result, variable argument functions such as <code class="literal">printf</code> cannot make use of the <code class="literal">stdcall</code> calling convention. The <code class="literal">demo_stdcall</code> function, for example, expects three integer parameters, occupying a total of 12 bytes on the stack (<code class="literal">3 * sizeof(int)</code> on a 32-bit architecture). An x86 compiler can use a special form of the <code class="literal">RET</code> instruction to simultaneously pop the return address from the top of the stack and add 12 to the stack pointer to clear the function parameters. In the case of <code class="literal">demo_stdcall</code>, we might see the following instruction used to return to the caller:<a class="indexterm" id="IDX-CHP-6-0057"/></p><a id="I_programlisting3_d1e6505"/><pre class="programlisting">ret 12     ; return and clear 12 bytes from the stack</pre><p>The primary advantage to the use of <code class="literal">stdcall</code> is the elimination of code to clean parameters off the stack following every function call, which results in slightly smaller, slightly faster programs. By convention Microsoft utilizes the <code class="literal">stdcall</code> convention for all fixed-argument functions exported from shared library (DLL) files. This is an important point to remember if you are attempting to generate function prototypes or binary-compatible replacements for any shared library components.</p></div><div class="sect3" title="The fastcall Convention for x86"><div class="titlepage"><div><div><h3 class="title"><a id="the_fastcall_convention_for_x86"/>The fastcall Convention for x86</h3></div></div></div><p>A variation on the <code class="literal">stdcall</code> convention, the <code class="literal">fastcall</code> calling convention passes up to two parameters in CPU registers rather than on the program stack. The Microsoft Visual C/C++ and GNU gcc/g++ (version 3.4 and later) compilers recognize the <code class="literal">fastcall</code> modifier in function declarations. When <code class="literal">fastcall</code> is specified, the first two parameters passed to a function will be placed in the ECX and EDX registers, respectively. Any remaining parameters are placed on the stack in right-to-left order similar to <code class="literal">stdcall</code>. Also similar to <code class="literal">stdcall</code>, <code class="literal">fastcall</code> functions are responsible for removing parameters from the stack when they return to their caller. The following declaration demonstrates the use of the <code class="literal">fastcall</code> modifier.<a class="indexterm" id="IDX-CHP-6-0058"/><a class="indexterm" id="IDX-CHP-6-0059"/></p><a id="I_programlisting3_d1e6551"/><pre class="programlisting">void fastcall demo_fastcall(int w, int x, int y, int z);</pre><p>A compiler might generate the following code in order to call <code class="literal">demo_fastcall</code>:</p><a id="I_programlisting3_d1e6558"/><pre class="programlisting">; demo_fastcall(1, 2, 3, 4);   //programmer calls demo_fastcall
   push   4              ; move parameter z to second position on stack
   push   3              ; move parameter y to top position on stack
   mov    edx, 2         ; move parameter x to edx
   mov    ecx, 1         ; move parameter w to ecx
   call   demo_fastcall  ; call the function</pre><p>Note that no stack adjustment is required upon return from the call to <code class="literal">demo_fastcall</code>, as <code class="literal">demo_fastcall</code> is responsible for clearing parameters <code class="literal">y</code> and <code class="literal">z</code> from the stack as it returns to the caller. It is important to understand that because two arguments are passed in registers, the called function needs to clear only 8 bytes from the stack even though there are four arguments to the function.</p></div><div class="sect3" title="C++ Calling Conventions"><div class="titlepage"><div><div><h3 class="title"><a id="c_plus_plus_calling_conventions"/>C++ Calling Conventions</h3></div></div></div><p>Nonstatic member functions in C++ classes differ from standard functions in that they must make available the <code class="literal">this</code> pointer, which points to the object used to invoke the function. The address of the object used to invoke the function must be supplied by the caller and is therefore provided as a parameter when calling nonstatic member functions. The C++ language standard does not specify how <code class="literal">this</code> should be passed to nonstatic member functions, so it should come as no surprise that different compilers use different techniques when passing <code class="literal">this</code>.</p><p>Microsoft Visual C++ offers the <code class="literal">thiscall</code> calling convention, which passes <code class="literal">this</code> in the ECX register and requires the nonstatic member function to clean parameters off the stack as in <code class="literal">stdcall</code>. The GNU <code class="literal">g++</code> compiler treats <code class="literal">this</code> as the implied first parameter to any nonstatic member function and behaves in all other respects as if the <code class="literal">cdecl</code> convention is being used. Thus, for <code class="literal">g++-</code>compiled code, <code class="literal">this</code> is placed on top of the stack prior to calling the nonstatic member function, and the caller is responsible for removing parameters (there will always be at least one) from the stack once the function returns. Additional features of compiled C++ are discussed in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>.</p></div><div class="sect3" title="Other Calling Conventions"><div class="titlepage"><div><div><h3 class="title"><a id="other_calling_conventions"/>Other Calling Conventions</h3></div></div></div><p>Complete coverage of every existing calling convention would require a book in its own right. Calling conventions are often language-, compiler-, and CPU-specific, and some research on your part may be required as you encounter code generated by less-common compilers. A few situations deserve special mention, however: optimized code, custom assembly language code, and system calls.<a class="indexterm" id="IDX-CHP-6-0060"/></p><p>When functions are exported for use by other programmers (such as library functions), it is important that they adhere to well-known calling conventions so that programmers can easily interface to those functions. On the other hand, if a function is intended for internal program use only, then the calling convention used by that function need be known only within that function’s program. In such cases, optimizing compilers may choose to use alternate calling conventions in order to generate faster code. Instances in which this may occur include the use of the <code class="literal">/GL</code> option with Microsoft Visual C++ and the use of the <code class="literal">regparm</code> keyword with GNU gcc/g++.<a class="indexterm" id="IDX-CHP-6-0061"/><a class="indexterm" id="IDX-CHP-6-0062"/><a class="indexterm" id="IDX-CHP-6-0063"/><a class="indexterm" id="IDX-CHP-6-0064"/><a class="indexterm" id="IDX-CHP-6-0065"/></p><p>When programmers go to the trouble of using assembly language, they gain complete control over how parameters will be passed to any functions that they happen to create. Unless they wish to make their functions available to other programmers, assembly language programmers are free to pass parameters in any way they see fit. As a result, you may need to take extra care when analyzing custom assembly code. Custom assembly code is often encountered in obfuscation routines and shellcode.</p><p>A <span class="emphasis"><em>system call</em></span> is a special type of function call used to request an operating system service. System calls usually effect a state transition from user mode to kernel mode in order for the operating system kernel to service the user’s request. The manner in which system calls are initiated varies across operating systems and CPUs. For example, Linux x86 system calls may be initiated using the <code class="literal">int 0x80</code> instruction or the <code class="literal">sysenter</code> instruction, while other x86 operating systems may use only the <code class="literal">sysenter</code> instruction or alternate interrupt numbers. On many x86 systems (Linux being an exception) parameters for system calls are placed on the runtime stack, and a system call number is placed in the EAX register immediately prior to initiating the system call. Linux system calls accept their parameters in specific registers and occasionally in memory when there are more parameters than available registers.<a class="indexterm" id="IDX-CHP-6-0066"/><a class="indexterm" id="IDX-CHP-6-0067"/></p></div></div><div class="sect2" title="Local Variable Layout"><div class="titlepage"><div><div><h2 class="title"><a id="local_variable_layout"/>Local Variable Layout</h2></div></div></div><p>Unlike the calling conventions that dictate the manner in which parameters are passed into a function, there are no conventions that mandate the layout of a function’s local variables. When compiling a function, one task a compiler is faced with is to compute the amount of space required by a function’s local variables. Another task is to determine whether those variables can be allocated in CPU registers or whether they must be allocated on the program stack. The exact manner in which these allocations are made is irrelevant to both the caller of a function and to any functions that may, in turn, be called. Most notably, it is typically impossible to determine a function’s local variable layout based on examination of the function’s source code.<a class="indexterm" id="IDX-CHP-6-0068"/></p></div><div class="sect2" title="Stack Frame Examples"><div class="titlepage"><div><div><h2 class="title"><a id="stack_frame_examples"/>Stack Frame Examples</h2></div></div></div><p>Consider the following function compiled on a 32-bit x86-based computer:</p><a id="I_programlisting3_d1e6693"/><pre class="programlisting">void bar(int j, int k);   // a function to call
void demo_stackframe(int a, int b, int c) {
   int x;
   char buffer[64];
   int y;
   int z;
   // body of function not terribly relevant other than
   bar(z, y);
}</pre><p>We compute the minimum amount of stack space required for local variables as 76 bytes (three 4-byte integers and a 64-byte buffer). This function could use either <code class="literal">stdcall</code> or <code class="literal">cdecl</code>, and the stack frame will look the same. <a class="xref" href="ch06s02.html#an_esp-based_stack_frame" title="Figure 6-3. An ESP-based stack frame">Figure 6-3</a> shows one possible implementation of a stack frame for an invocation of <code class="literal">demo_stackframe</code>, assuming that no frame pointer register is used (thus the stack pointer, ESP, serves as the frame pointer). This frame would be set up on entry to <code class="literal">demo_stackframe</code> with the one-line prologue:<a class="indexterm" id="IDX-CHP-6-0069"/></p><a id="I_programlisting3_d1e6715"/><pre class="programlisting">sub   esp, 76     ; allocate sufficient space for all local variables</pre><p>The Offset column indicates the base+displacement address required to reference any of the local variables or parameters in the stack frame.<a class="indexterm" id="IDX-CHP-6-0070"/></p><div class="figure"><a id="an_esp-based_stack_frame"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e6725"/><img alt="An ESP-based stack frame" src="httpatomoreillycomsourcenostarchimages854129.png"/></div></div><p class="title">Figure 6-3. An ESP-based stack frame</p></div><p>Generating functions that utilize the stack pointer to compute all variable references requires a little more effort on the part of the compiler, as the stack pointer changes frequently and the compiler must make sure that proper offsets are used at all times when referencing any variables within the stack frame. Consider the call made to <code class="literal">bar</code> in function <code class="literal">demo_stackframe</code>, the code for which is shown here:</p><a id="I_programlisting3_d1e6738"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> push   dword [esp+4]     ; push y
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> push   dword [esp+4]     ; push z
  call   bar
  add    esp, 8              ; cdecl requires caller to clear parameters</pre><p>The <code class="literal">push</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6756"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> correctly pushes local variable <code class="literal">y</code> per the offset in <a class="xref" href="ch06s02.html#an_esp-based_stack_frame" title="Figure 6-3. An ESP-based stack frame">Figure 6-3</a>. At first glance it might appear that the <code class="literal">push</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6771"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> incorrectly references local variable <code class="literal">y</code> a second time. However, because we are dealing with an ESP-based frame and the <code class="literal">push</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6783"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> modifies ESP, all of the offsets in <a class="xref" href="ch06s02.html#an_esp-based_stack_frame" title="Figure 6-3. An ESP-based stack frame">Figure 6-3</a> must be temporarily adjusted each time ESP changes. Following <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6791"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, the new offset for local variable <code class="literal">z</code> becomes <code class="literal">[esp+4]</code> as correctly referenced in the <code class="literal">push</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6807"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. When examining functions that reference stack frame variables using the stack pointer, you must be careful to note any changes to the stack pointer and adjust all future variable offsets accordingly. One advantage of using the stack pointer to reference all stack frame variables is that all other registers remain available for other purposes.<a class="indexterm" id="IDX-CHP-6-0071"/><a class="indexterm" id="IDX-CHP-6-0072"/><a class="indexterm" id="IDX-CHP-6-0073"/><a class="indexterm" id="IDX-CHP-6-0074"/><a class="indexterm" id="IDX-CHP-6-0075"/><a class="indexterm" id="IDX-CHP-6-0076"/></p><p>Once <code class="literal">demo_stackframe</code> has completed, it needs to return to the caller. Ultimately a <code class="literal">ret</code> instruction will be used to pop the desired return address off the top of the stack into the instruction pointer register (EIP in this case). Before the return address can be popped, the local variables need to be removed from the top of the stack so that the stack pointer correctly points to the saved return address when the <code class="literal">ret</code> instruction is executed. For this particular function the resulting epilogue becomes</p><a id="I_programlisting3_d1e6844"/><pre class="programlisting">add     esp, 76     ; adjust esp to point to the saved return address
ret                 ; return to the caller</pre><p>At the expense of dedicating a register for use as a frame pointer and some code to configure the frame pointer on entry to the function, the job of computing local variable offsets can be made easier. In x86 programs, the EBP (<span class="emphasis"><em>extended base pointer</em></span>) register is typically dedicated for use as a stack frame pointer. By default, most compilers generate code to use a frame pointer, though options typically exist for specifying that the stack pointer should be used instead. GNU gcc/g++, for example, offers the <code class="literal">-fomit-frame-pointer</code> compiler option, which generates functions that do not rely on a fixed-frame pointer register.</p><p>In order to see what the stack frame for <code class="literal">demo_stackframe</code> will look like using a dedicated frame pointer, we need to consider this new prologue code:<a class="indexterm" id="IDX-CHP-6-0077"/></p><a id="I_programlisting3_d1e6862"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> push    ebp        ; save the caller's ebp value
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> mov     ebp, esp   ; make ebp point to the saved register value
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> sub     esp, 76    ; allocate space for local variables</pre><p>The <code class="literal">push</code> instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6886"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> saves the value of EBP currently being used by the caller. Functions that adhere to the System V Application Binary Interface for Intel 32-bit Processors<sup>[<a class="footnote" href="#ftn.CHP-6-FN-2" id="CHP-6-FN-2">43</a>]</sup> are allowed to modify the EAX, ECX, and EDX registers but are required to preserve the caller’s values for all other registers. Therefore, if we wish to use EBP as a frame pointer, we must save the current value of EBP before we change it, and we must restore the value of EBP before we return to the caller. If any other registers need to be saved on behalf of the caller (ESI or EDI, for example), compilers may choose to save them at the same time EBP is saved, or they may defer saving them until local variables have been allocated. Thus, there is no standard location within a stack frame for the storage of saved registers.<a class="indexterm" id="IDX-CHP-6-0078"/></p><p>Once EBP has been saved, it can be changed to point to the current stack location. This is accomplished by the <code class="literal">mov</code> instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6906"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>, which copies the current value of the stack pointer into EBP. Finally, as in the non-EBP-based stack frame, space for local variables is allocated at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6912"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>. The resulting stack frame layout is shown in <a class="xref" href="ch06s02.html#an_ebp-based_stack_frame" title="Figure 6-4. An EBP-based stack frame">Figure 6-4</a>.</p><div class="figure"><a id="an_ebp-based_stack_frame"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e6923"/><img alt="An EBP-based stack frame" src="httpatomoreillycomsourcenostarchimages854131.png"/></div></div><p class="title">Figure 6-4. An EBP-based stack frame</p></div><p>With a dedicated frame pointer, all variable offsets are computed relative to the frame pointer register. It is most often (though not necessarily) the case that positive offsets are used to access function parameters, while negative offsets are required to access local variables. With a dedicated frame pointer in use, the stack pointer may be freely changed without affecting the offset to any variables within the frame. The call to function <code class="literal">bar</code> can now be implemented as follows:</p><a id="I_programlisting3_d1e6933"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/> push   dword [ebp-72]       ; push y
  push   dword [ebp-76]       ; push z
  call   bar
  add    esp, 8               ; cdecl requires caller to clear parameters</pre><p>The fact that the stack pointer has changed following the <code class="literal">push</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e6945"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> has no effect on the access to local variable <code class="literal">z</code> in the succeeding <code class="literal">push</code>.</p><p>Finally, the use of a frame pointer necessitates a slightly different epilogue once the function completes, as the caller’s frame pointer must be restored prior to returning. Local variables must be cleared from the stack before the old value of the frame pointer can be retrieved, but this is made easy by the fact that the current frame pointer points to the old frame pointer. In x86 programs utilizing EBP as a frame pointer, the following code represents a typical epilogue:<a class="indexterm" id="IDX-CHP-6-0079"/><a class="indexterm" id="IDX-CHP-6-0080"/></p><a id="I_programlisting3_d1e6968"/><pre class="programlisting">mov    esp, ebp      ; clears local variables by reseting esp
pop    ebp           ; restore the caller's value of ebp
ret                  ; pop return address to return to the caller</pre><p>This operation is so common that the x86 architecture offers the <code class="literal">leave</code> instruction as an abbreviated means of accomplishing the same task.</p><a id="I_programlisting3_d1e6975"/><pre class="programlisting">leave                ; copies ebp to esp AND then pops into ebp
ret                  ; pop return address to return to the caller</pre><p>While the names of registers and instructions used will certainly differ for other processor architectures, the basic process of building stack frames will remain the same. Regardless of the architecture, you will want to familiarize yourself with typical prologue and epilogue sequences so that you can quickly move on to analyzing more interesting code within functions.</p></div><div class="sect2" title="IDA Stack Views"><div class="titlepage"><div><div><h2 class="title"><a id="ida_stack_views"/>IDA Stack Views</h2></div></div></div><p>Stack frames are clearly a runtime concept; a stack frame can’t exist without a stack and without a running program. While this is true, it doesn’t mean that you should ignore the concept of a stack frame when you are performing static analysis with tools such as IDA. All of the code required to set up stack frames for each function is present within a binary. Through careful analysis of this code, we can gain a detailed understanding of the structure of any function’s stack frame even when the function is not running. In fact, some of IDA’s most sophisticated analysis is performed specifically to determine the layout of stack frames for every function that IDA disassembles. During initial analysis, IDA goes to great lengths to monitor the behavior of the the stack pointer over the course of a function by making note of every <code class="literal">push</code> or <code class="literal">pop</code> operation along with any arithmetic operations that may change the stack pointer, such as adding or subtracting constant values. The first goal of this analysis is to determine the exact size of the local variable area allocated to a function’s stack frame. Additional goals include determining whether a dedicated frame pointer is in use in a given function (by recognizing a <code class="literal">push ebp/mov ebp, esp</code> sequence, for example) and recognizing all memory references to variables within a function’s stack frame. For example, if IDA noted the following instruction in the body of <code class="literal">demo_stackframe</code></p><a id="I_programlisting3_d1e6995"/><pre class="programlisting">mov    eax, [ebp+8]</pre><p>it would understand that the first argument to the function (<code class="literal">a</code> in this case) is being loaded into the EAX register (refer to <a class="xref" href="ch06s02.html#an_ebp-based_stack_frame" title="Figure 6-4. An EBP-based stack frame">Figure 6-4</a>). Through careful analysis of the stack frame structure, IDA can distinguish between memory references that access function arguments (those that lie below the saved return address) and references that access local variables (those that lie above the saved return address). IDA takes the additional step of determining which memory locations within a stack frame are directly referenced. For example, while the stack frame in <a class="xref" href="ch06s02.html#an_ebp-based_stack_frame" title="Figure 6-4. An EBP-based stack frame">Figure 6-4</a> is 96 bytes in size, there are only seven variables that we are likely to see referenced (four locals and three parameters).<a class="indexterm" id="IDX-CHP-6-0081"/><a class="indexterm" id="IDX-CHP-6-0082"/><a class="indexterm" id="IDX-CHP-6-0083"/><a class="indexterm" id="IDX-CHP-6-0084"/><a class="indexterm" id="IDX-CHP-6-0085"/></p><p>Understanding the behavior of a function often comes down to understanding the types of data that the function manipulates. When reading a disassembly listing, one of the first opportunities that you will have to understand the data a function manipulates is to view the breakdown of the function’s stack frame. IDA offers two views into any function’s stack frame: a summary view and a detail view. In order to understand these two views, we will refer to the following version of <code class="literal">demo_stackframe</code>, which we have compiled using gcc.</p><a id="I_programlisting3_d1e7027"/><pre class="programlisting">void demo_stackframe(int a, int b, int c) {
   int x = c;
   char buffer[64];
   int y = b;
   int z = 10;
   buffer[0] = 'A';
   bar(z, y);
}</pre><p>In this example, local variables <code class="literal">x</code> and <code class="literal">y</code> are initialized from parameters <code class="literal">c</code> and <code class="literal">b</code>, respectively. Local variable <code class="literal">z</code> is initialized with the constant value 10, and the first character in the 64-byte local array, named <code class="literal">buffer</code>, is initialized to the letter <code class="literal">'A'</code>. The corresponding IDA disassembly of this function appears here.</p><a id="I_programlisting3_d1e7053"/><pre class="programlisting">.text:00401090 ; ========= S U B R O U T I N E ===========================
    .text:00401090
    .text:00401090 ; Attributes: <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>bp-based frame
    .text:00401090
    .text:00401090 demo_stackframe proc near      ; CODE XREF: sub_4010C1+41↓p
    .text:00401090
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>   .text:00401090 var_60          = dword ptr −60h
    .text:00401090 var_5C          = dword ptr −5Ch
    .text:00401090 var_58          = byte ptr −58h
    .text:00401090 var_C           = dword ptr −0Ch
    .text:00401090 arg_4           = dword ptr  0Ch
    .text:00401090 arg_8           = dword ptr  10h
    .text:00401090
    .text:00401090                 push    ebp
    .text:00401091                 mov     ebp, esp
    .text:00401093                 sub     esp, <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>78h
    .text:00401096                 mov     eax, [ebp+<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>arg_8]
      .text:00401099                <img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>mov     [ebp+var_C], eax
    .text:0040109C                <img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>mov     eax, [ebp+arg_4]
    .text:0040109F                <img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>mov     [ebp+var_5C], eax
    .text:004010A2                <img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/>mov     [ebp+var_60], 0Ah
    .text:004010A9                <img alt="" src="httpatomoreillycomsourcenostarchimages854135.png"/>mov     [ebp+var_58], 41h
    .text:004010AD                 mov     eax, [ebp+var_5C]
    .text:004010B0                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     [esp+4], eax
    .text:004010B4                 mov     eax, [ebp+var_60]
    .text:004010B7                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     [esp], eax
    .text:004010BA                 call    bar
    .text:004010BF                 leave
    .text:004010C0                 retn
    .text:004010C0 demo_stackframe endp</pre><p>There are many points to cover in this listing as we begin to acquaint ourselves with IDA’s disassembly notation. We begin at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7124"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> by noting that IDA believes this function uses the EBP register as a frame pointer based on analysis of the function prologue. At <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7130"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> we learn that gcc has allocated 120 bytes (78h equates to 120) of local variable space in the stack frame. This includes 8 bytes for passing the two parameters to <code class="literal">bar</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7139"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, but it is still far greater than the 76 bytes we had estimated previously and demonstrates that compilers occasionally pad the local variable space with extra bytes in order to ensure a particular alignment within the stack frame. Beginning at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7145"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>, IDA provides a summary stack view that lists every variable that is directly referenced within the stack frame, along with the variable’s size and offset distance from the frame pointer.<a class="indexterm" id="IDX-CHP-6-0086"/><a class="indexterm" id="IDX-CHP-6-0087"/></p><p>IDA assigns names to variables based on their location relative to the saved return address. Local variables lie above the saved return address, while function parameters lie below the saved return address. Local variable names are derived using the <code class="literal">var_</code> prefix joined with a hexadecimal suffix that indicates the distance, in bytes, that the variable lies above the saved frame pointer. Local variable <code class="literal">var_C</code>, in this case, is a 4-byte (dword) variable that lies 12 bytes above the saved frame pointer (<code class="literal">[ebp-0Ch]</code>). Function parameter names are generated using the <code class="literal">arg_</code> prefix combined with a hexadecimal suffix that represents the relative distance from the topmost parameter. Thus the topmost 4-byte parameter would be named <code class="literal">arg_0</code>, while successive parameters would be named <code class="literal">arg_4</code>, <code class="literal">arg_8</code>, <code class="literal">arg_C</code>, and so on. In this particular example <code class="literal">arg_0</code> is not listed because the function makes no use of parameter <code class="literal">a</code>. Because IDA fails to locate any memory reference to <code class="literal">[ebp+8]</code> (the location of the first parameter), <code class="literal">arg_0</code> is not listed in the summary stack view. A quick scan of the summary stack view reveals that there are many stack locations that IDA has failed to name because no direct references to those locations exist in the program code.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The only stack variables that IDA will automatically generate names for are those that are directly referenced within a function.<a class="indexterm" id="IDX-CHP-6-0088"/></p></div><p>An important difference between IDA’s disassembly listing and the stack frame analysis that we performed earlier is the fact that nowhere in the disassembly listing do we see memory references similar to <code class="literal">[ebp-12]</code>. Instead, IDA has replaced all constant offsets with symbolic names corresponding to the symbols in the stack view and their relative offsets from the stack frame pointer. This is in keeping with IDA’s goal of generating a higher-level disassembly. It is simply easier to deal with symbolic names than numeric constants. In fact, as we will see later, IDA allows us to change the names of any stack variable to whatever we wish, making the names that much easier for us to remember. The summary stack view serves as a map from IDA-generated names to their corresponding stack frame offsets. For example, where the memory reference <code class="literal">[ebp+arg_8]</code> appears in the disassembly, <code class="literal">[ebp+10h]</code> or <code class="literal">[ebp+16]</code> could be used instead. If you prefer numeric offsets, IDA will happily show them to you. Right-clicking <code class="literal">arg_8</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7223"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> yields the context-sensitive menu shown in <a class="xref" href="ch06s02.html#selecting_an_alternate_display_format" title="Figure 6-5. Selecting an alternate display format">Figure 6-5</a>, which contains several options to change the display format.<a class="indexterm" id="IDX-CHP-6-0089"/><a class="indexterm" id="IDX-CHP-6-0090"/><a class="indexterm" id="IDX-CHP-6-0091"/><a class="indexterm" id="IDX-CHP-6-0092"/><a class="indexterm" id="IDX-CHP-6-0093"/></p><div class="figure"><a id="selecting_an_alternate_display_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e7251"/><img alt="Selecting an alternate display format" src="httpatomoreillycomsourcenostarchimages854137.png.jpg"/></div></div><p class="title">Figure 6-5. Selecting an alternate display format</p></div><p>In this example, since we have source code available for comparison, we can map the IDA-generated variable names back to the names used in the original source using a variety of clues available in the disassembly.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>First, <code class="literal">demo_stackframe</code> takes three parameters: <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>. These correspond to variables <code class="literal">arg_0</code>, <code class="literal">arg_4</code>, and <code class="literal">arg_8</code> respectively (though <code class="literal">arg_0</code> is missing in the disassembly because it is never referenced).</p></li><li class="listitem"><p>Local variable <code class="literal">x</code> is initialized from parameter <code class="literal">c</code>. Thus <code class="literal">var_C</code> corresponds to <code class="literal">x</code> since it is initialized from <code class="literal">arg_8</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7306"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>.</p></li><li class="listitem"><p>Similarly, local variable <code class="literal">y</code> is initialized from parameter <code class="literal">b</code>. Thus, <code class="literal">var_5C</code> corresponds to <code class="literal">y</code> since it is initialized from <code class="literal">arg_4</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7331"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span>.</p></li><li class="listitem"><p>Local variable <code class="literal">z</code> corresponds to <code class="literal">var_60</code> since it is initialized with the value 10 at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7346"/><img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/></span>.</p></li><li class="listitem"><p>The 64-byte character array <code class="literal">buffer</code> begins at <code class="literal">var_58</code> since <code class="literal">buffer[0]</code> is initialized with <span class="emphasis"><em>A</em></span> (ASCII 0x41) at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7367"/><img alt="" src="httpatomoreillycomsourcenostarchimages854135.png"/></span>.</p></li><li class="listitem"><p>The two arguments for the call to <code class="literal">bar</code> are moved into the stack at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7379"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> rather than being pushed onto the stack. This is typical of current versions of gcc (versions 3.4 and later). IDA recognizes this convention and elects not to create local variable references for the two items at the top of the stack frame.<a class="indexterm" id="IDX-CHP-6-0094"/><a class="indexterm" id="IDX-CHP-6-0095"/><a class="indexterm" id="IDX-CHP-6-0096"/><a class="indexterm" id="IDX-CHP-6-0097"/><a class="indexterm" id="IDX-CHP-6-0098"/><a class="indexterm" id="IDX-CHP-6-0099"/><a class="indexterm" id="IDX-CHP-6-0100"/><a class="indexterm" id="IDX-CHP-6-0101"/></p></li></ol></div><p>In addition to the summary stack view, IDA offers a detailed stack frame view in which every byte allocated to a stack frame is accounted for. The detailed view is accessed by double-clicking any variable name associated with a given stack frame. Double-clicking <code class="literal">var_C</code> in the previous listing would bring up the stack frame view shown in <a class="xref" href="ch06s02.html#ida_stack_frame_view" title="Figure 6-6. IDA stack frame view">Figure 6-6</a> (<span class="keycap">esc</span> closes the window).<a class="indexterm" id="IDX-CHP-6-0102"/></p><div class="figure"><a id="ida_stack_frame_view"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e7426"/><img alt="IDA stack frame view" src="httpatomoreillycomsourcenostarchimages854139.png"/></div></div><p class="title">Figure 6-6. IDA stack frame view</p></div><p>Because the detailed view accounts for every byte in the stack frame, it occupies significantly more space than the summary view, which lists only referenced variables. The portion of the stack frame shown in <a class="xref" href="ch06s02.html#ida_stack_frame_view" title="Figure 6-6. IDA stack frame view">Figure 6-6</a> spans a total of 32 bytes, which represents only a small portion of the entire stack frame. Note that no names are assigned to bytes that are not referenced directly within the function. For example, parameter <code class="literal">a</code>, corresponding to <code class="literal">arg_0</code>, was never referenced within <code class="literal">demo_stackframe</code>. With no memory reference to analyze, IDA opts to do nothing with the corresponding bytes in the stack frame, which occupy offsets <code class="literal">+00000008</code> through <code class="literal">+0000000B</code>. On the other hand, <code class="literal">arg_4</code> was directly referenced at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e7454"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> in the disassembly listing, where its contents were loaded into the 32-bit EAX register. Based on the fact that 32 bits of data were moved, IDA is able to infer that the <code class="literal">arg_4</code> is a 4-byte quantity and labels it as such (<code class="literal">db</code> defines 1 byte of storage; <code class="literal">dw</code> defines 2 bytes of storage, also called a <span class="emphasis"><em>word</em></span>; and <code class="literal">dd</code> defines 4 bytes of storage, also called a <span class="emphasis"><em>double word</em></span>).</p><p>Two special values shown in <a class="xref" href="ch06s02.html#ida_stack_frame_view" title="Figure 6-6. IDA stack frame view">Figure 6-6</a> are “ <code class="literal">s</code>” and “ <code class="literal">r</code>” (each starts with a leading space). These pseudo variables are IDA’s special representation of the saved return address (“ <code class="literal">r</code>”) and the saved register value(s) (“ <code class="literal">s</code>” representing only EBP in this example). These values are included in the stack frame view for completeness, as every byte in the stack frame is accounted for.<a class="indexterm" id="IDX-CHP-6-0103"/><a class="indexterm" id="IDX-CHP-6-0104"/><a class="indexterm" id="IDX-CHP-6-0105"/></p><p>Stack frame view offers a detailed look at the inner workings of compilers. In <a class="xref" href="ch06s02.html#ida_stack_frame_view" title="Figure 6-6. IDA stack frame view">Figure 6-6</a> it is clear that the compiler has inserted 8 extra bytes between the saved frame pointer “ <code class="literal">s</code>” and the local variable <code class="literal">x</code> (<code class="literal">var_C</code>). These bytes occupy offsets <code class="literal">−00000001</code> through <code class="literal">−00000008</code> in the stack frame. Further, a little math performed on the offset associated with each variable listed in the summary view reveals that the compiler has allocated 76 (rather than 64 per the source code) bytes to the character buffer at <code class="literal">var_58</code>. Unless you happen to be a compiler writer yourself or are willing to dig deep into the source code for gcc, all you can do is speculate as to why these extra bytes are allocated in this manner. In most cases we can chalk up the extra bytes to padding for alignment, and usually the presence of these extra bytes has no impact on a program’s behavior. After all, if a programmer asks for 64 bytes and is given 76, the program should behave no differently, especially since the programmer shouldn’t be using more than the 64 bytes requested. On the other hand, if you happen to be an exploit developer and learn that it is possible to overflow this particular buffer, then you might be very interested in the fact that nothing interesting can even begin to happen until you have supplied at least 76 bytes, which is the effective size of the buffer as far as the compiler is concerned. In <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a> we will return to the stack frame view and its uses in dealing with more complex datatypes such as arrays and structures.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-1" id="ftn.CHP-6-FN-1">42</a>] </sup>A <span class="emphasis"><em>frame pointer</em></span> is a register that points to a location inside a stack frame. Variables within the stack frame are typically referenced by their relative distance from the location to which the frame pointer points.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-2" id="ftn.CHP-6-FN-2">43</a>] </sup>See <a class="ulink" href="http://www.sco.com/developers/devspecs/abi386-4.pdf">http://www.sco.com/developers/devspecs/abi386-4.pdf</a>.</p></div></div></div>
<div class="sect1" title="Searching the Database"><div class="titlepage"><div><div><h1 class="title"><a id="searching_the_database"/>Searching the Database</h1></div></div></div><p>IDA makes it easy to navigate to things that you know about and designs many of its data displays to summarize specific types of information (names, strings, imports, and so on), making them easy to find as well. However, what features are offered to help you conduct more general searches through your databases? If you take time to review the contents of the Search menu, you will find a long list of options, the majority of which take you to the next item in some category. For example, Search ▸ Next Code moves the cursor to the next location containing an instruction. You may also wish to familiarize yourself with the options available on the Jump menu. For many of these, you are presented with a list of locations to choose from. Jump ▸ Jump to Function, for example, brings up a list of all functions, allowing you to quickly choose one and navigate to it. While these canned search features may often be useful, two types of general-purpose searches are worth more detailed discussion: text searches and binary searches.<a class="indexterm" id="IDX-CHP-6-0106"/><a class="indexterm" id="IDX-CHP-6-0107"/></p><div class="sect2" title="Text Searches"><div class="titlepage"><div><div><h2 class="title"><a id="text_searches"/>Text Searches</h2></div></div></div><p>IDA text searches amount to substring searches through the disassembly listing view. Text searches are initiated via Search ▸ Text (hotkey: <span class="keycap">alt</span>-T), which opens the dialog shown in <a class="xref" href="ch06s03.html#text_search_dialog" title="Figure 6-7. Text Search dialog">Figure 6-7</a>. A number of self-explanatory options dictate specific details concerning the search to be performed. As shown, POSIX-style regular expressions are permitted. The <span class="emphasis"><em>Identifier</em></span> search is somewhat misnamed. In reality it restricts the search to find whole words only and can match any whole word on an assembly line, including opcode mnemonics or constant values. An Identifier search for <code class="literal">401116</code> would fail to find a symbol named <code class="literal">loc_401116</code>.<a class="indexterm" id="IDX-CHP-6-0108"/><a class="indexterm" id="IDX-CHP-6-0109"/><a class="indexterm" id="IDX-CHP-6-0110"/><a class="indexterm" id="IDX-CHP-6-0111"/><a class="indexterm" id="IDX-CHP-6-0112"/><a class="indexterm" id="IDX-CHP-6-0113"/><a class="indexterm" id="IDX-CHP-6-0114"/><a class="indexterm" id="IDX-CHP-6-0115"/><a class="indexterm" id="IDX-CHP-6-0116"/><a class="indexterm" id="IDX-CHP-6-0117"/><a class="indexterm" id="IDX-CHP-6-0118"/><a class="indexterm" id="IDX-CHP-6-0119"/><a class="indexterm" id="IDX-CHP-6-0120"/></p><p>Selecting <span class="emphasis"><em>Find all occurences</em></span> causes the search results to be opened in a new window, allowing easy navigation to any single match of the search criteria. Finally, the previous search can be repeated to locate the next match using <span class="keycap">ctrl</span>-T or Search ▸ Next Text.</p><div class="figure"><a id="text_search_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e7618"/><img alt="Text Search dialog" src="httpatomoreillycomsourcenostarchimages854141.png.jpg"/></div></div><p class="title">Figure 6-7. Text Search dialog</p></div></div><div class="sect2" title="Binary Searches"><div class="titlepage"><div><div><h2 class="title"><a id="binary_searches"/>Binary Searches</h2></div></div></div><p>If you need to search for specific binary content such as a known sequence of bytes, then text searches are not the answer. Instead, you need to use IDA’s binary search facilities. While the text search searches the disassembly window, the binary search will search only the content portion of the Hex View window. Either the hex dump or the ASCII dump can be searched, depending on how the search string is specified. A binary search is initiated using Search ▸ Sequence of Bytes, or <span class="keycap">alt</span>-B. <a class="xref" href="ch06s03.html#binary_search_dialog" title="Figure 6-8. Binary Search dialog">Figure 6-8</a> shows the Binary Search dialog. To search for a sequence of hex bytes, the search string should be specified as a space-separated list of two-digit hex values such as <code class="literal">CA FE BA BE</code>, which offers identical behavior as a search for <code class="literal">ca fe ba be</code>, despite the availability of a Case-sensitive option.<a class="indexterm" id="IDX-CHP-6-0121"/><a class="indexterm" id="IDX-CHP-6-0122"/><a class="indexterm" id="IDX-CHP-6-0123"/><a class="indexterm" id="IDX-CHP-6-0124"/></p><p>To alternatively search for embedded string data (effectively searching the ASCII dump portion of the Hex View window), you must surround the search strings with quotes. Use the Unicode strings option to search for the Unicode version of your search string.<a class="indexterm" id="IDX-CHP-6-0125"/><a class="indexterm" id="IDX-CHP-6-0126"/></p><p>The Case-sensitive option can be a cause of confusion. For string searches it is fairly straightforward; a search for “hello” will successfully find “HELLO” if Case-sensitive is not selected. Things get a little interesting if you perform a hex search and leave Case-sensitive unchecked. If you conduct a case-insensitive search for <code class="literal">E9 41 C3</code>, you may be surprised when your search matches <code class="literal">E9 61 C3</code>. The two strings are considered to match because 0x41 corresponds to the character <span class="emphasis"><em>A</em></span> while 0x61 corresponds to <span class="emphasis"><em>a</em></span>. So, even though you have specified a hex search, 0x41 is considered equivalent to 0x61 because you failed to specify a case-sensitive search.<a class="indexterm" id="IDX-CHP-6-0127"/><a class="indexterm" id="IDX-CHP-6-0128"/><a class="indexterm" id="IDX-CHP-6-0129"/><a class="indexterm" id="IDX-CHP-6-0130"/></p><div class="figure"><a id="binary_search_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e7692"/><img alt="Binary Search dialog" src="httpatomoreillycomsourcenostarchimages854143.png.jpg"/></div></div><p class="title">Figure 6-8. Binary Search dialog</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p>When conducting hex searches, make sure that you specify Case-sensitive if you want to restrict the search to exact matches. This is important if you are searching for specific opcode sequences rather than ASCII text.</p></div><p>Searching for subsequent matches for binary data is done using <span class="keycap">ctrl</span>-B or Search ▸ Next Sequence of Bytes. Finally, it is not necessary to conduct your binary searches from within the Hex View window. IDA allows you to specify binary search criteria while the disassembly view is active, in which case a successful search will jump the disassembly window to the location whose underlying bytes match the specified search criteria.</p></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id5"/>Summary</h1></div></div></div><p>The intent of this chapter was to provide you with the minimum essential skills for effectively making your way around a disassembly. The overwhelming majority of your interactions with IDA will involve the operations that we have discussed so far. With navigation safely under your belt, the logical next step is learning how to modify IDA databases to suit your particular needs. In the next chapter we begin to look at how to make the most basic changes to a disassembly as a means of adding new knowledge based on our understanding of a binary’s content and behavior.</p></div>
<div class="chapter" title="Chapter&#xA0;7.&#xA0;Disassembly Manipulation"><div class="titlepage"><div><div><h1 class="title"><a id="disassembly_manipulation"/>Chapter 7. Disassembly Manipulation</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id7"/><div class="mediaobject"><a id="I_mediaobject4_d1e7714"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>After navigation, the next most significant features of IDA are designed to allow you to modify the disassembly to suit your needs. In this chapter we will show that because of IDA’s underlying database nature, changes that you make to a disassembly are easily propagated to all IDA subviews to maintain a consistent picture of your disassembly. One of the most powerful features that IDA offers is the ability to easily manipulate disassemblies to add new information or reformat a listing to suit your particular needs. IDA automatically handles operations such as global search and replace when it makes sense to do so and makes trivial work of reformatting instructions and data and vice versa, features not available in other disassembly tools.<a class="indexterm" id="IDX-CHP-7-0001"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember: There is no undo in IDA. Keep this in mind as you start manipulating the database. The closest you’re going to get is saving the database often and reverting to a recently saved version of the database.</p></div><div class="sect1" title="Names and Naming"><div class="titlepage"><div><div><h1 class="title"><a id="names_and_naming"/>Names and Naming</h1></div></div></div><p>At this point, we have encountered two categories of names in IDA disassemblies: names associated with virtual addresses (named locations) and names associated with stack frame variables. In the majority of cases IDA will automatically generate all of these names according to the guidelines previously discussed. IDA refers to such automatically generated names as <span class="emphasis"><em>dummy names</em></span>.<a class="indexterm" id="IDX-CHP-7-0002"/><a class="indexterm" id="IDX-CHP-7-0003"/><a class="indexterm" id="IDX-CHP-7-0004"/><a class="indexterm" id="IDX-CHP-7-0005"/><a class="indexterm" id="IDX-CHP-7-0006"/><a class="indexterm" id="IDX-CHP-7-0007"/></p><p>Unfortunately, these names seldom hint at the intended purpose of a location or variable and therefore don’t generally add to our understanding of a program’s behavior. As you begin to analyze any program, one of the first and most common ways that you will want to manipulate a disassembly listing is to change default names into more meaningful names. Fortunately, IDA allows you to easily change any name and handles all of the details of propagating all name changes throughout the entire disassembly. In most cases, changing a name is as simple as clicking the name you wish to change (this highlights the name) and using the N hotkey to open a name-change dialog. Alternatively, right-clicking the name to be changed generally presents a context-sensitive menu that contains a Rename option, as shown in <a class="xref" href="ch06s02.html#selecting_an_alternate_display_format" title="Figure 6-5. Selecting an alternate display format">Figure 6-5</a>. The name-change process does differ somewhat between stack variables and named locations, and these differences are detailed in the following sections.<a class="indexterm" id="IDX-CHP-7-0008"/><a class="indexterm" id="IDX-CHP-7-0009"/><a class="indexterm" id="IDX-CHP-7-0010"/></p><div class="sect2" title="Parameters and Local Variables"><div class="titlepage"><div><div><h2 class="title"><a id="parameters_and_local_variables"/>Parameters and Local Variables</h2></div></div></div><p>Names associated with stack variables are the simplest form of name in a disassembly listing, primarily because they are not associated with a specific virtual address and thus can never appear in the Names window. As in most programming languages, such names are considered to be restricted in scope based on the function to which a given stack frame belongs. Thus, every function in a program might have its own stack variable named <code class="literal">arg_0</code>, but no function may have more than one variable named <code class="literal">arg_0</code>. The dialog shown in <a class="xref" href="ch07.html#renaming_a_stack_variable" title="Figure 7-1. Renaming a stack variable">Figure 7-1</a> is used to rename a stack variable.<a class="indexterm" id="IDX-CHP-7-0011"/><a class="indexterm" id="IDX-CHP-7-0012"/><a class="indexterm" id="IDX-CHP-7-0013"/><a class="indexterm" id="IDX-CHP-7-0014"/></p><div class="figure"><a id="renaming_a_stack_variable"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7804"/><img alt="Renaming a stack variable" src="httpatomoreillycomsourcenostarchimages854145.png.jpg"/></div></div><p class="title">Figure 7-1. Renaming a stack variable</p></div><p>Once a new name is supplied, IDA takes care of changing every occurrence of the old name in the context of the current function. Changing the name of <code class="literal">var_5C</code> to <code class="literal">y</code> for <code class="literal">demo_stackframe</code> would result in the new listing shown here, with changes at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7820"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>.</p><a id="I_programlisting4_d1e7826"/><pre class="programlisting">.text:00401090 ; =========== S U B R O U T I N E =========================
.text:00401090
.text:00401090 ; Attributes: bp-based frame
.text:00401090
.text:00401090 demo_stackframe proc near      ; CODE XREF: sub_4010C1+41↓p
.text:00401090
.text:00401090 var_60          = dword ptr −60h
.text:00401090 <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>y             = dword ptr −5Ch
.text:00401090 var_58          = byte ptr −58h
.text:00401090 var_C           = dword ptr −0Ch
.text:00401090 arg_4           = dword ptr  0Ch
.text:00401090 arg_8           = dword ptr  10h
.text:00401090
.text:00401090                 push    ebp
.text:00401091                 mov     ebp, esp
.text:00401093                 sub     esp, 112
.text:00401096                 mov     eax, [ebp+arg_8]
.text:00401099                 mov     [ebp+var_C], eax
.text:0040109C                 mov     eax, [ebp+arg_4]
.text:0040109F                 mov     [ebp+y], eax
.text:004010A2                 mov     [ebp+var_60], 0Ah
.text:004010A9                 mov     [ebp+var_58], 41h
.text:004010AD                 mov     eax, [ebp+<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>y]
.text:004010B0                 mov     [esp+4], eax
.text:004010B4                 mov     eax, [ebp+var_60]
.text:004010B7                 mov     [esp], eax
.text:004010BA                 call    bar
.text:004010BF                 leave
.text:004010C0                 retn
.text:004010C0 demo_stackframe endp</pre><p>Should you ever wish to revert to the default name for a given variable, open the renaming dialog and enter a blank name, and IDA will regenerate the default name for you.</p></div><div class="sect2" title="Named Locations"><div class="titlepage"><div><div><h2 class="title"><a id="named_locations"/>Named Locations</h2></div></div></div><p>Renaming a named location or adding a name to an unnamed location is slightly different from changing the name of a stack variable. The process for accessing the name-change dialog is identical (hotkey N), but things quickly change. <a class="xref" href="ch07.html#renaming_a_location" title="Figure 7-2. Renaming a location">Figure 7-2</a> shows the renaming dialog associated with named locations.<a class="indexterm" id="IDX-CHP-7-0015"/></p><p>This dialog informs you exactly what address you are naming along with a list of attributes that can be associated with the name. The maximum name length merely echoes a value from one of IDA’s configuration files (<span class="emphasis"><em>&lt;IDADIR&gt;/cfg/ida.cfg</em></span>). You are free to use names longer than this value, which will cause IDA to complain weakly by informing you that you have exceeded the maximum name length and offering to increase the maximum name length for you. Should you choose to do so, the new maximum name length value will be enforced (weakly) only in the current database. Any new databases that you create will continue to be governed by the maximum name length contained in the configuration file.</p><div class="figure"><a id="renaming_a_location"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7860"/><img alt="Renaming a location" src="httpatomoreillycomsourcenostarchimages854147.png.jpg"/></div></div><p class="title">Figure 7-2. Renaming a location</p></div><p>The following attributes can be associated with any named location:<a class="indexterm" id="IDX-CHP-7-0016"/><a class="indexterm" id="IDX-CHP-7-0017"/><a class="indexterm" id="IDX-CHP-7-0018"/><a class="indexterm" id="IDX-CHP-7-0019"/><a class="indexterm" id="IDX-CHP-7-0020"/><a class="indexterm" id="IDX-CHP-7-0021"/><a class="indexterm" id="IDX-CHP-7-0022"/><a class="indexterm" id="IDX-CHP-7-0023"/><a class="indexterm" id="IDX-CHP-7-0024"/><a class="indexterm" id="IDX-CHP-7-0025"/><a class="indexterm" id="IDX-CHP-7-0026"/><a class="indexterm" id="IDX-CHP-7-0027"/><a class="indexterm" id="IDX-CHP-7-0028"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Local name</strong></span></span></dt><dd><p>A local name is restricted in scope to the current function, so the uniqueness of local names is enforced only within a given function. Like local variables, two different functions may contain identical local names, but a single function cannot contain two local names that are identical. Named locations that exist outside function boundaries cannot be designated as local names. These include names that represent function names as well as global variables. The most common use for local names is to provide symbolic names for the targets of jumps within a function, such as those associated with branching control structures.</p></dd><dt><span class="term"><span class="strong"><strong>Include in names list</strong></span></span></dt><dd><p>Selecting this option causes a name to be added to the Names window, which can make the name easier to find when you wish to return to it. Autogenerated (dummy) names are never included in the Names window by default.</p></dd><dt><span class="term"><span class="strong"><strong>Public name</strong></span></span></dt><dd><p>A public name is typically a name that is being exported by a binary such as a shared library. IDA’s parsers typically discover public names while parsing file headers during initial loading into the database. You can force a symbol to be treated as public by selecting this attribute. In general, this has very little effect on the disassembly other than to cause public annotations to be added to the name in the disassembly listing and in the Names window.</p></dd><dt><span class="term"><span class="strong"><strong>Autogenerated name</strong></span></span></dt><dd><p>This attribute appears to have no discernible effect on disassemblies. Selecting it does not cause IDA to automatically generate a name.</p></dd><dt><span class="term"><span class="strong"><strong>Weak name</strong></span></span></dt><dd><p>A weak symbol is a specialized form of public symbol utilized only when no public symbol of the same name is found to override it. Marking a symbol as weak has some significance to an assembler but little significance in an IDA disassembly.<a class="indexterm" id="IDX-CHP-7-0029"/><a class="indexterm" id="IDX-CHP-7-0030"/><a class="indexterm" id="IDX-CHP-7-0031"/><a class="indexterm" id="IDX-CHP-7-0032"/><a class="indexterm" id="IDX-CHP-7-0033"/><a class="indexterm" id="IDX-CHP-7-0034"/><a class="indexterm" id="IDX-CHP-7-0035"/><a class="indexterm" id="IDX-CHP-7-0036"/><a class="indexterm" id="IDX-CHP-7-0037"/></p></dd><dt><span class="term"><span class="strong"><strong>Create name anyway</strong></span></span></dt><dd><p>As discussed previously, no two locations within a function may be given the same name. Similarly, no two locations outside any function (in the global scope) may be given the same name. This option is somewhat confusing, as it behaves differently depending on the type of name you are attempting to create.</p><p>If you are editing a name at the global scope (such as a function name or global variable) and you attempt to assign a name that is already in use in the database, IDA will display the conflicting name dialog, shown in <a class="xref" href="ch07.html#name_conflict_dialog" title="Figure 7-3. Name conflict dialog">Figure 7-3</a>, offering to automatically generate a unique numeric suffix to resolve the conflict. This dialog is presented regardless of whether you have selected the Create name anyway option or not.</p><p>If, however, you are editing a local name within a function and you attempt to assign a name that is already in use, the default behavior is simply to reject the attempt. If you are determined to use the given name, you must select Create name anyway in order to force IDA to generate a unique numeric suffix for the local name. Of course, the simplest way to resolve any name conflict is to choose a name that is not already in use.</p></dd></dl></div><div class="figure"><a id="name_conflict_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e8004"/><img alt="Name conflict dialog" src="httpatomoreillycomsourcenostarchimages854149.png.jpg"/></div></div><p class="title">Figure 7-3. Name conflict dialog</p></div></div><div class="sect2" title="Register Names"><div class="titlepage"><div><div><h2 class="title"><a id="register_names"/>Register Names</h2></div></div></div><p>A third type of name that is often overlooked is the register name. Within the boundaries of a function, IDA allows registers to be renamed. It may be useful to rename a register when a compiler has elected to allocate a variable in a register rather than on the program stack, and you wish to refer to the variable using a name more suited to its purpose than <span class="emphasis"><em>EDX</em></span>, for example. Register renaming works much the same as renaming in any other location. Use the N hotkey, or right-click the register name and select <span class="strong"><strong>Rename</strong></span> to open the register-renaming dialog. When you rename a register you are, in effect, providing an alias with which to refer to the register for the duration of the current function (IDA even denotes this alias with an <code class="literal">alias = register</code> syntax at the beginning of the function). IDA takes care of replacing all instances of the register name with the alias that you provide. It is not possible to rename a register used in code that does not belong to a function.<a class="indexterm" id="IDX-CHP-7-0038"/><a class="indexterm" id="IDX-CHP-7-0039"/></p></div></div></div>
<div class="sect1" title="Commenting in IDA"><div class="titlepage"><div><div><h1 class="title"><a id="commenting_in_ida"/>Commenting in IDA</h1></div></div></div><p>Another useful feature in IDA is the ability to embed comments in your databases. Comments are a particularly useful way to leave notes for yourself regarding your progress as you analyze a program. In particular, comments are helpful for describing sequences of assembly language instructions in a higher-level fashion. For example, you might opt to write comments using C language statements to summarize the behavior of a particular function. On subsequent analysis of the function, the comments would serve to refresh your memory faster than reanalyzing the assembly language statements.<a class="indexterm" id="IDX-CHP-7-0040"/><a class="indexterm" id="IDX-CHP-7-0041"/><a class="indexterm" id="IDX-CHP-7-0042"/></p><p>IDA offers several styles of comments, each suited for a different purpose. Comments may be associated with any line of the disassembly listing using options available from Edit ▸ Comments. Hotkeys or context menus offer alternate access to IDA’s commenting features. To help you understand IDA’s commenting features, we refer to the following disassembly of the function <code class="literal">bar</code>:</p><a id="I_programlisting4_d1e8052"/><pre class="programlisting">.text:00401050 ; =============== S U B R O U T I N E
=======================================
.text:00401050
.text:00401050 <img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>; void bar(int j, int k);
.text:00401050 ; Attributes: bp-based frame
.text:00401050
.text:00401050 <img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>
bar       proc near               ; CODE XREF: demo_stackframe+2A,p
.text:00401050
.text:00401050 arg_0     = dword ptr  8
.text:00401050 arg_4     = dword ptr  0Ch
.text:00401050
.text:00401050   push   ebp
.text:00401051   mov   ebp, esp
.text:00401053   sub   esp, 8
.text:00401056  <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>The next three lines test j &lt; k
.text:00401056   mov   eax, [ebp+arg_0]
.text:00401059   cmp   eax, [ebp+arg_4]
.text:0040105C   jge   short loc_40106C <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>;
 Repeating comments get echoed at referencing locations
.text:0040105E   mov   [esp], offset aTheSecondParam <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>;
 "The second parameter is larger"
.text:00401065   call  printf
.text:0040106A   jmp   short locret_40108E <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>; jump to the end of the function
.text:0040106C ; -------------------
--------------------------------------------------------
.text:0040106C
.text:0040106C loc_40106C:                             ; CODE XREF: bar+C·j
.text:0040106C   mov   eax, [ebp+arg_0] <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>;
 Repeating comments get echoed at referencing locations
.text:0040106F   cmp   eax, [ebp+arg_4]
.text:00401072   jle   short loc_401082
.text:00401074   mov   [esp], offset aTheFirstParame <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>;
 "The first parameter is larger"
.text:0040107B   call  printf
.text:00401080   jmp   short locret_40108E
.text:00401082 ; -----------------------
----------------------------------------------------
.text:00401082
.text:00401082 loc_401082:                             ; CODE XREF: bar+22·j
.text:00401082   mov   [esp], offset aTheParametersA <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>;
 "the parameters are equal"
.text:00401089   call  printf
.text:0040108E
.text:0040108E locret_40108E:                          ; CODE XREF: bar+1A·j
.text:0040108E                                         ; bar+30·j
.text:0040108E   leave
.text:0040108F   retn
.text:0040108F bar  endp</pre><p>The majority of IDA comments are prefixed with a semicolon to indicate that the remainder of the line is to be considered a comment. This is similar to commenting styles used by many assemblers and equates to #-style comments in many scripting languages or //-style comments in C++.<a class="indexterm" id="IDX-CHP-7-0043"/><a class="indexterm" id="IDX-CHP-7-0044"/><a class="indexterm" id="IDX-CHP-7-0045"/><a class="indexterm" id="IDX-CHP-7-0046"/><a class="indexterm" id="IDX-CHP-7-0047"/></p><div class="sect2" title="Regular Comments"><div class="titlepage"><div><div><h2 class="title"><a id="regular_comments"/>Regular Comments</h2></div></div></div><p>The most straightforward comment is the <span class="emphasis"><em>regular comment</em></span>. Regular comments are placed at the end of existing assembly lines, as at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8134"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> in the preceding listing. Right-click in the right margin of the disassembly or use the colon (:) hotkey to activate the comment entry dialog. Regular comments will span multiple lines if you enter multiple lines in the comment entry dialog. Each of the lines will be indented to line up on the right side of the disassembly. To edit or delete a comment, you must reopen the comment entry dialog and edit or delete all of the comment text as appropriate. By default, regular comments are displayed as blue text.<a class="indexterm" id="IDX-CHP-7-0048"/><a class="indexterm" id="IDX-CHP-7-0049"/><a class="indexterm" id="IDX-CHP-7-0050"/></p><p>IDA itself makes extensive use of regular comments. During the analysis phase, IDA inserts regular comments to describe parameters that are being pushed for function calls. This occurs only when IDA has parameter name or type information for the function being called. This information is typically contained within type libraries, which are discussed in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a> and <a class="xref" href="ch13.html" title="Chapter 13. Extending IDA’s Knowledge">Chapter 13</a>, but also may be entered manually.</p></div><div class="sect2" title="Repeatable Comments"><div class="titlepage"><div><div><h2 class="title"><a id="repeatable_comments"/>Repeatable Comments</h2></div></div></div><p>A <span class="emphasis"><em>repeatable comment</em></span> is a comment that is entered once but that may appear automatically in many locations throughout the disassembly. Location <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8165"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> in the previous listing shows a repeatable comment. In a disassembly listing the default color for repeatable comments is blue, making them indistinguishable from regular comments. It is the behavior rather than the appearance that matters in this case. The behavior of repeatable comments is tied to the concept of cross-references. When one program location refers to a second location that contains a repeatable comment, the comment associated with the second location is echoed at the first location. By default, the echoed comment appears as gray text, making the repeated comment distinguishable from other comments. The hotkey for repeatable comments is the semicolon (;), making it very easy to confuse repeatable comments and regular comments.<a class="indexterm" id="IDX-CHP-7-0051"/><a class="indexterm" id="IDX-CHP-7-0052"/></p><p>In the previous listing, note that the comment at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8181"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> is identical to the comment at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8187"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. The comment at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8193"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> has been repeated because the instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8199"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> (<code class="literal">jge short loc_40106C</code>) refers to the address of <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8209"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> (<code class="literal">0040106C</code>).</p><p>A regular comment added at a location that is displaying a repeated comment overrides the repeated comment so that only the regular comment will be displayed. If you entered a regular comment at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8220"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, the repeatable comment inherited from <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8226"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> would no longer be displayed at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8232"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. If you then deleted the regular comment at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8238"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, the repeatable comment would once again be displayed.<a class="indexterm" id="IDX-CHP-7-0053"/></p><p>A variant form of repeatable comment is associated with strings. Whenever IDA automatically creates a string variable, a virtual repeatable comment is added at all locations referencing the string variable. We say <span class="emphasis"><em>virtual</em></span> because the comment cannot be edited by the user. The content of the virtual comment is set to the content of the string variable and displayed throughout the database just as a repeatable comment would be. As a result, any program locations that refer to the string variable will display the contents of the string variable as a repeated comment. The three comments annotated <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8252"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> demonstrate such comments displayed as a result of references to string variables.<a class="indexterm" id="IDX-CHP-7-0054"/><a class="indexterm" id="IDX-CHP-7-0055"/></p></div><div class="sect2" title="Anterior and Posterior Lines"><div class="titlepage"><div><div><h2 class="title"><a id="anterior_and_posterior_lines"/>Anterior and Posterior Lines</h2></div></div></div><p><span class="emphasis"><em>Anterior and posterior lines</em></span> are full-line comments that appear either immediately before (anterior) or after (posterior) a given disassembly line. These comments are the only IDA comments that are <span class="emphasis"><em>not</em></span> prefixed with the semicolon character. An example of an anterior line comment appears at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8276"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> in the previous listing. You can distinguish an anterior line from a posterior line by comparing the address associated with the line to the address associated with the instruction immediately preceding or following the line.<a class="indexterm" id="IDX-CHP-7-0056"/><a class="indexterm" id="IDX-CHP-7-0057"/><a class="indexterm" id="IDX-CHP-7-0058"/></p></div><div class="sect2" title="Function Comments"><div class="titlepage"><div><div><h2 class="title"><a id="function_comments"/>Function Comments</h2></div></div></div><p><span class="emphasis"><em>Function comments</em></span> allow you to group comments for display at the top of a function’s disassembly listing. An example of a function comment is shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8300"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>, where the function prototype has been entered. You enter function comments by first highlighting the function name at the top of the function (<span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8306"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span>) and then adding either a regular or repeatable comment. Repeatable function comments are echoed at any locations that call the commented function. IDA will automatically generate function prototype-style comments when you use the Set Function Type command discussed in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>.<a class="indexterm" id="IDX-CHP-7-0059"/><a class="indexterm" id="IDX-CHP-7-0060"/></p></div></div>
<div class="sect1" title="Basic Code Transformations"><div class="titlepage"><div><div><h1 class="title"><a id="basic_code_transformations"/>Basic Code Transformations</h1></div></div></div><p>In many cases you will be perfectly content with the disassembly listings that IDA generates. In some cases you won’t. As the types of files that you analyze diverge farther and farther from ordinary executables generated with common compilers, you may find that you need to take more control of the disassembly analysis and display processes. This will be especially true if you find yourself performing analysis of obfuscated code or files that utilize a custom (unknown to IDA) file format.</p><p>Code transformations facilitated by IDA include the following:<a class="indexterm" id="IDX-CHP-7-0061"/><a class="indexterm" id="IDX-CHP-7-0062"/><a class="indexterm" id="IDX-CHP-7-0063"/><a class="indexterm" id="IDX-CHP-7-0064"/><a class="indexterm" id="IDX-CHP-7-0065"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Converting data into code</p></li><li class="listitem"><p>Converting code into data</p></li><li class="listitem"><p>Designating a sequence of instructions as a function</p></li><li class="listitem"><p>Changing the starting or ending address of an existing function</p></li><li class="listitem"><p>Changing the display format for instruction operands</p></li></ul></div><p>The degree to which you utilize these operations depends on a wide variety of factors and personal preferences. In general, if a binary is very complex, or if IDA is not familiar with the code sequences generated by the compiler used to build the binary, then IDA will encounter more problems during the analysis phase, and you will need to make manual adjustments to the disassembled code.</p><div class="sect2" title="Code Display Options"><div class="titlepage"><div><div><h2 class="title"><a id="code_display_options"/>Code Display Options</h2></div></div></div><p>The simplest transformations that you can make to a disassembly listing involve customizing the amount of information that IDA generates for each disassembly line. Each disassembled line can be considered as a collection of parts that IDA refers to, not surprisingly, as <span class="emphasis"><em>disassembly line parts</em></span>. Labels, mnemonics, and operands are always present in a disassembly line. You can select additional parts for each disassembly line via Options ▸ General on the Disassembly tab, as shown in <a class="xref" href="ch07s03.html#disassembly_line_display_options" title="Figure 7-4. Disassembly line display options">Figure 7-4</a>.<a class="indexterm" id="IDX-CHP-7-0066"/></p><div class="figure"><a id="disassembly_line_display_options"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e8384"/><img alt="Disassembly line display options" src="httpatomoreillycomsourcenostarchimages854151.png.jpg"/></div></div><p class="title">Figure 7-4. Disassembly line display options</p></div><p>The <span class="emphasis"><em>Display Disassembly Line Parts</em></span> section in the upper right offers several options for customizing disassembly lines. For IDA’s text disassembly view, line prefixes, comments, and repeatable comments are selected by default. Each item is described here and shown in the listing that follows.<a class="indexterm" id="IDX-CHP-7-0067"/><a class="indexterm" id="IDX-CHP-7-0068"/><a class="indexterm" id="IDX-CHP-7-0069"/><a class="indexterm" id="IDX-CHP-7-0070"/><a class="indexterm" id="IDX-CHP-7-0071"/><a class="indexterm" id="IDX-CHP-7-0072"/><a class="indexterm" id="IDX-CHP-7-0073"/><a class="indexterm" id="IDX-CHP-7-0074"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Line prefixes</strong></span></span></dt><dd><p>A line prefix is the <code class="literal">section:address</code> portion of each disassembly line. Deselecting this option causes the line prefix to be removed from each disassembly line (the default in graph view). To illustrate this option, we have disabled line prefixes in the next listing.</p></dd><dt><span class="term"><span class="strong"><strong>Stack pointer</strong></span></span></dt><dd><p>IDA performs extensive analysis on each function in order to track changes to the program stack pointer. This analysis is essential in understanding the layout of each function’s stack frame. Selecting the Stack pointer option causes IDA to display the relative change to the stack pointer throughout the course of each function. This may be useful in recognizing discrepancies in calling conventions (IDA may not understand that a particular function uses <code class="literal">stdcall</code>, for example) or unusual manipulations of the stack pointer. Stack pointer tracking is shown in the column under <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8441"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. In this example, the stack pointer has changed by four bytes following the first instruction and a total of 0x7C bytes following the third instruction. By the time the function completes, the stack pointer is restored to its original value (a relative change of zero bytes). Whenever IDA encounters a function return statement and detects that the stack pointer value is not zero, an error condition is flagged and the instruction line highlighted in red. In some cases, this might be a deliberate attempt to frustrate automated analysis. In other cases, it may be that a compiler utilizes prologues and epilogues that IDA can’t accurately analyze.<a class="indexterm" id="IDX-CHP-7-0075"/></p></dd><dt><span class="term"><span class="strong"><strong>Comments and repeatable comments</strong></span></span></dt><dd><p>Deselecting either of these options inhibits the display of the respective comment type. This may be useful if you wish to declutter a disassembly listing.</p></dd><dt><span class="term"><span class="strong"><strong>Auto comments</strong></span></span></dt><dd><p>IDA can automatically comment some instruction types. This can serve as a reminder as to how particular instructions behave. No comments are added for trivial instructions such as the x86 <code class="literal">mov</code>. The comments at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8467"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> are examples of auto comments. User comments take precedence over auto comments; in this case if you want to see IDA’s automatic comment for a line, you’ll have to remove any comments you’ve added (regular or repeatable).</p></dd><dt><span class="term"><span class="strong"><strong>Bad instruction</strong></span> <strong class="userinput"><code>&lt;BAD&gt;</code></strong> <span class="strong"><strong>marks</strong></span></span></dt><dd><p>IDA can mark instructions that are legal for the processor but that may not be recognized by some assemblers. Undocumented (as opposed to illegal) CPU instructions may fall in this category. In such cases IDA will disassemble the instruction as a sequence of data bytes and display the undocumented instruction as a comment prefaced with <code class="literal">&lt;BAD&gt;</code>. The intent is to generate a disassembly that most assemblers can handle. Refer to the IDA help file for more information on the use of <code class="literal">&lt;BAD&gt;</code> marks.<a class="indexterm" id="IDX-CHP-7-0076"/><a class="indexterm" id="IDX-CHP-7-0077"/><a class="indexterm" id="IDX-CHP-7-0078"/><a class="indexterm" id="IDX-CHP-7-0079"/></p></dd><dt><span class="term"><span class="strong"><strong>Number of opcode bytes</strong></span></span></dt><dd><p>Most disassemblers are capable of generating listing files that display the generated machine language bytes side by side with the assembly language instructions from which they are derived. IDA allows you to view the machine language bytes associated with each instruction by synchronizing a hex display to the disassembly listing display. You can optionally view machine language bytes mixed with assembly language instructions by specifying the number of machine language bytes that IDA should display for each instruction.</p><p>This is fairly straightforward when you are disassembling code for processors that have a fixed instruction size, but it is somewhat more difficult for variable-length instruction processors such as the x86, for which instructions may range from one to more than a dozen bytes in size. Regardless of the instruction length, IDA reserves display space in the disassembly listing for the number of bytes that you specify here, pushing the remaining portions of the disassembly line to the right to accommodate the specified number of opcode bytes. Number of opcode bytes has been set to 5 in the following disassembly and can be seen in the columns under <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8513"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The + symbol at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8519"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> indicates that the specified instruction is too long to be fully displayed given the current settings.</p></dd></dl></div><a id="I_programlisting4_d1e8525"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>     <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>
000 55                   push    ebp
004 89 E5                mov     ebp, esp
004 83 EC 78             sub     esp, 78h        <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>; Integer Subtraction
07C 8B 45 10             mov     eax, [ebp+arg_8]
07C 89 45 F4             mov     [ebp+var_C], eax
07C 8B 45 0C             mov     eax, [ebp+arg_4]
07C 89 45 A4             mov     [ebp+var_5C], eax
07C C7 45 A0 0A <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>00+     mov     [ebp+var_60], 0Ah
07C C6 45 A8 41          mov     [ebp+var_58], 41h
07C 8B 45 A4             mov     eax, [ebp+var_5C]
07C 89 44 24 04          mov     [esp+4], eax
07C 8B 45 A0             mov     eax, [ebp+var_60]
07C 89 04 24             mov     [esp], eax
07C E8 91 FF FF FF       call    bar             <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>; Call Procedure
07C C9                   leave                   <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>; High Level Procedure Exit
000 C3                   retn                    <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>; Return Near from Procedure</pre><p>You can further customize the disassembly display by adjusting the indentation values and margins shown in the lower right of <a class="xref" href="ch07s03.html#disassembly_line_display_options" title="Figure 7-4. Disassembly line display options">Figure 7-4</a>. Any changes to these options affect only the current database. Global settings for each of these options are stored in the main configuration file, <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/ida.cfg</em></span>.</p></div><div class="sect2" title="Formatting Instruction Operands"><div class="titlepage"><div><div><h2 class="title"><a id="formatting_instruction_operands"/>Formatting Instruction Operands</h2></div></div></div><p>During the disassembly process, IDA makes many decisions regarding how to format operands associated with each instruction. The biggest decisions generally revolve around how to format various integer constants used by the wide variety of instruction types. Among other things, these constants can represent relative offsets in jump or call instructions, absolute addresses of global variables, values to be used in arithmetic operations, or programmer-defined constants. In order to make a disassembly more readable, IDA attempts to use symbolic names rather than numbers whenever possible. In some cases, formatting decisions are made based on the context of the instruction being disassembled (such as a call instruction); in other cases, the decision is based on the data being used (such as access to a global variable or an offset into a stack frame). In many other cases, the exact context in which a constant is being used may not be clear. When this happens, the associated constant is typically formatted as a hexadecimal constant.<a class="indexterm" id="IDX-CHP-7-0080"/><a class="indexterm" id="IDX-CHP-7-0081"/><a class="indexterm" id="IDX-CHP-7-0082"/><a class="indexterm" id="IDX-CHP-7-0083"/><a class="indexterm" id="IDX-CHP-7-0084"/><a class="indexterm" id="IDX-CHP-7-0085"/><a class="indexterm" id="IDX-CHP-7-0086"/><a class="indexterm" id="IDX-CHP-7-0087"/><a class="indexterm" id="IDX-CHP-7-0088"/><a class="indexterm" id="IDX-CHP-7-0089"/><a class="indexterm" id="IDX-CHP-7-0090"/><a class="indexterm" id="IDX-CHP-7-0091"/><a class="indexterm" id="IDX-CHP-7-0092"/><a class="indexterm" id="IDX-CHP-7-0093"/></p><p>If you happen not to be one of the few people in the world who eat, sleep, and breathe hex, then you will welcome IDA’s operand formatting features. Right-clicking any constant in a disassembly opens a context-sensitive menu similar to that shown in <a class="xref" href="ch07s03.html#formatting_options_for_constants" title="Figure 7-5. Formatting options for constants">Figure 7-5</a>.</p><div class="figure"><a id="formatting_options_for_constants"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e8639"/><img alt="Formatting options for constants" src="httpatomoreillycomsourcenostarchimages854153.png.jpg"/></div></div><p class="title">Figure 7-5. Formatting options for constants</p></div><p>In this case, menu options are offered enabling the constant (<code class="literal">41h</code>) to be reformatted as decimal, octal, or binary values. Since the constant in this example falls within the ASCII printable range, an option is also presented to format the value as a character constant. In all cases, the menu displays the exact text that will replace the operand text should a particular option be selected.</p><p>In many cases, programmers use named constants in their source code. Such constants may be the result of <code class="literal">#define</code> statements (or their equivalent), or they may belong to a set of enumerated constants. Unfortunately, by the time a compiler is finished with the source code, it is no longer possible to determine whether the source used a symbolic constant or a literal, numeric constant. IDA maintains a large catalog of named constants associated with many common libraries such as the C standard library or the Windows API. This catalog is accessible via the Use standard symbolic constant option on the context-sensitive menu associated with any constant value. Selecting this option for the constant <code class="literal">0Ah</code> in <a class="xref" href="ch07s03.html#formatting_options_for_constants" title="Figure 7-5. Formatting options for constants">Figure 7-5</a> opens the symbol-selection dialog shown in <a class="xref" href="ch07s03.html#symbol-selection_dialog" title="Figure 7-6. Symbol-selection dialog">Figure 7-6</a>.<a class="indexterm" id="IDX-CHP-7-0094"/><a class="indexterm" id="IDX-CHP-7-0095"/></p><div class="figure"><a id="symbol-selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e8670"/><img alt="Symbol-selection dialog" src="httpatomoreillycomsourcenostarchimages854155.png"/></div></div><p class="title">Figure 7-6. Symbol-selection dialog</p></div><p>The dialog is populated from IDA’s internal list of constants after filtering according to the value of the constant we are attempting to format. In this case we see all of the constants that IDA knows to be equated with the value <code class="literal">0Ah</code>. If we determined that the value was being used in conjunction with the creation of an X.25-style network connection, then we might select AF_CCITT and end up with the following disassembly line:<a class="indexterm" id="IDX-CHP-7-0096"/></p><a id="I_programlisting4_d1e8683"/><pre class="programlisting">.text:004010A2                 mov     [ebp+var_60], AF_CCITT</pre><p>The list of standard constants is a useful way to determine whether a particular constant may be associated with a known name and can save a lot of time reading through API documentation in search of potential matches.</p></div><div class="sect2" title="Manipulating Functions"><div class="titlepage"><div><div><h2 class="title"><a id="manipulating_functions"/>Manipulating Functions</h2></div></div></div><p>There are a number of reasons that you may wish to manipulate functions after the initial autoanalysis has been completed. In some cases, such as when IDA fails to locate a call to a function, functions may not be recognized, as there may be no obvious way to reach them. In other cases, IDA may fail to properly locate the end of a function, requiring some manual intervention on your part to correct the disassembly. IDA may have trouble locating the end of a function if a compiler has split the function across several address ranges or when, in the process of optimizing code, a compiler merges common end sequences of two or more functions in order to save space.<a class="indexterm" id="IDX-CHP-7-0097"/><a class="indexterm" id="IDX-CHP-7-0098"/></p><div class="sect3" title="Creating New Functions"><div class="titlepage"><div><div><h3 class="title"><a id="creating_new_functions"/>Creating New Functions</h3></div></div></div><p>Under certain circumstances, new functions can be created where no function exists. New functions can be created from existing instructions that do not already belong to a function, or they can be created from raw data bytes that have not been defined by IDA in any other manner (such as double words or strings). You create functions by placing the cursor on the first byte or instruction to be included in the new function and selecting Edit ▸ Functions ▸ Create Function. IDA attempts to convert data to code if necessary. Then it scans forward to analyze the structure of the function and search for a return statement. If IDA can locate a suitable end of the function, it generates a new function name, analyzes the stack frame, and restructures the code in the form of a function. If it can’t locate the end of the function or encounters any illegal instructions, then the operation fails.<a class="indexterm" id="IDX-CHP-7-0099"/><a class="indexterm" id="IDX-CHP-7-0100"/><a class="indexterm" id="IDX-CHP-7-0101"/><a class="indexterm" id="IDX-CHP-7-0102"/><a class="indexterm" id="IDX-CHP-7-0103"/></p></div><div class="sect3" title="Deleting Functions"><div class="titlepage"><div><div><h3 class="title"><a id="deleting_functions"/>Deleting Functions</h3></div></div></div><p>You can delete existing functions using Edit ▸ Functions ▸ Delete Function. You may wish to delete a function if you believe that IDA has erred in its autoanalysis.</p></div><div class="sect3" title="Function Chunks"><div class="titlepage"><div><div><h3 class="title"><a id="function_chunks"/>Function Chunks</h3></div></div></div><p>Function chunks are commonly found in code generated by the Microsoft Visual C++ compiler. Chunks are the result of the compiler moving blocks of code that are less frequently executed in order to squeeze frequently executed blocks into memory pages that are less likely to be swapped out.<a class="indexterm" id="IDX-CHP-7-0104"/></p><p>When a function is split in such a manner, IDA attempts to locate all of the associated chunks by following the jumps that lead to each chunk. In most cases IDA does a good job of locating all of the chunks and listing each chunk in the function’s header, as shown in the following partial function disassembly:</p><a id="I_programlisting4_d1e8741"/><pre class="programlisting">.text:004037AE ChunkedFunc     proc near
.text:004037AE
.text:004037AE var_420         = dword ptr −420h
.text:004037AE var_41C         = dword ptr −41Ch
.text:004037AE var_4           = dword ptr −4
.text:004037AE hinstDLL        = dword ptr  8
.text:004037AE fdwReason       = dword ptr  0Ch
.text:004037AE lpReserved      = dword ptr  10h
.text:004037AE
.text:004037AE ; FUNCTION CHUNK AT <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>.text:004040D7 SIZE 00000011 BYTES
.text:004037AE ; FUNCTION CHUNK AT .text:004129ED SIZE 0000000A BYTES
.text:004037AE ; FUNCTION CHUNK AT .text:00413DBC SIZE 00000019 BYTES
.text:004037AE
.text:004037AE                 push    ebp
.text:004037AF                 mov     ebp, esp</pre><p>Function chunks are easily reached by double-clicking the address associated with the chunk, as at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8751"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. Within the disassembly listing, function chunks are denoted by comments that delimit their instructions and that refer to the owning function, as shown in this listing:<a class="indexterm" id="IDX-CHP-7-0105"/><a class="indexterm" id="IDX-CHP-7-0106"/><a class="indexterm" id="IDX-CHP-7-0107"/><a class="indexterm" id="IDX-CHP-7-0108"/><a class="indexterm" id="IDX-CHP-7-0109"/><a class="indexterm" id="IDX-CHP-7-0110"/><a class="indexterm" id="IDX-CHP-7-0111"/><a class="indexterm" id="IDX-CHP-7-0112"/><a class="indexterm" id="IDX-CHP-7-0113"/></p><a id="I_programlisting4_d1e8791"/><pre class="programlisting">.text:004040D7 ; START OF FUNCTION CHUNK FOR ChunkedFunc
.text:004040D7
.text:004040D7 loc_0040C0D7:                   ; CODE XREF: ChunkedFunc+72↑j
.text:004040D7                 dec     eax
.text:004040D8                 jnz     loc_403836
.text:004040DE                 call    sub_4040ED
.text:004040E3                 jmp     loc_403836
.text:004040E3 ; END OF FUNCTION CHUNK FOR ChunkedFunc</pre><p>In some cases IDA may fail to locate every chunk associated with a function, or functions may be misidentified as chunks rather than as functions in their own right. In such cases, you may find that you need to create your own function chunks or delete existing function chunks.</p><p>You create new function chunks by selecting the range of addresses that belong to the chunk, which must not be part of any existing function, and selecting Edit ▸ Functions ▸ Append Function Tail. At this point you will be asked to select the parent function from a list of all defined functions.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In disassembly listings, function chunks are referred to as just that: function chunks. In the IDA menu system, functions chunks are instead referred to as function tails.</p></div><p>You can delete existing function chunks by positioning the cursor on any line within the chunk to be deleted and selecting Edit ▸ Functions ▸ Remove Function Tail. At this point you will be asked to confirm your action prior to deleting the selected chunk.</p><p>If function chunks are turning out to be more trouble than they are worth, you can ask IDA not to create function chunks by deselecting the Create function tails loader option when you first load a file into IDA. This option is one of the loader options accessible via Kernel Options (see <a class="xref" href="ch04.html" title="Chapter 4. Getting Started with IDA">Chapter 4</a>) in the initial file-load dialog. If you disable function tails, the primary difference that you may notice is that functions that would otherwise have contained tails contain jumps to regions outside the function boundaries. IDA high-lights such jumps using red lines and arrows in the arrow windows on the left side of the disassembly. In the graph view for the corresponding function, the targets of such jumps are not displayed.</p></div><div class="sect3" title="Function Attributes"><div class="titlepage"><div><div><h3 class="title"><a id="function_attributes"/>Function Attributes</h3></div></div></div><p>IDA associates a number of attributes with each function that it recognizes. The function properties dialog shown in <a class="xref" href="ch07s03.html#function_editing_dialog" title="Figure 7-7. Function editing dialog">Figure 7-7</a> can be used to edit many of these attributes. Each attribute that can be modified is explained here.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Name of function</strong></span></span></dt><dd><p>An alternative means for changing the name of a function.</p></dd><dt><span class="term"><span class="strong"><strong>Start address</strong></span></span></dt><dd><p>The address of the first instruction in the function. IDA most often determines this automatically, either during analysis or from the address used during the create function operation.<a class="indexterm" id="IDX-CHP-7-0114"/><a class="indexterm" id="IDX-CHP-7-0115"/><a class="indexterm" id="IDX-CHP-7-0116"/><a class="indexterm" id="IDX-CHP-7-0117"/><a class="indexterm" id="IDX-CHP-7-0118"/><a class="indexterm" id="IDX-CHP-7-0119"/><a class="indexterm" id="IDX-CHP-7-0120"/><a class="indexterm" id="IDX-CHP-7-0121"/></p><div class="figure"><a id="function_editing_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e8855"/><img alt="Function editing dialog" src="httpatomoreillycomsourcenostarchimages854157.png.jpg"/></div></div><p class="title">Figure 7-7. Function editing dialog</p></div></dd><dt><span class="term"><span class="strong"><strong>End address</strong></span></span></dt><dd><p>The address following the last instruction in the function. Most frequently, this is the address of the location that follows the function’s return instruction. In most cases, this address is determined automatically during the analysis phase or as part of function creation. In cases where IDA has trouble determining the true end of a function, you may need to edit this value manually. Remember, this address is not actually part of the function but follows the last instruction in the function.</p></dd><dt><span class="term"><span class="strong"><strong>Local variables area</strong></span></span></dt><dd><p>This represents the number of stack bytes dedicated to local variables (see <a class="xref" href="ch06s02.html#an_ebp-based_stack_frame" title="Figure 6-4. An EBP-based stack frame">Figure 6-4</a>) for the function. In most cases, this value is computed automatically based on analysis of stack pointer behavior within the function.</p></dd><dt><span class="term"><span class="strong"><strong>Saved registers</strong></span></span></dt><dd><p>This is the number of bytes used to save registers (see <a class="xref" href="ch06s02.html#an_ebp-based_stack_frame" title="Figure 6-4. An EBP-based stack frame">Figure 6-4</a>) on behalf of the caller. IDA considers the saved register region to lie on top of the saved return address and below any local variables associated with the function. Some compilers choose to save registers on top of a function’s local variables. IDA considers the space required to save such registers as belonging to the local variable area rather than a dedicated saved registers area.</p></dd><dt><span class="term"><span class="strong"><strong>Purged bytes</strong></span></span></dt><dd><p>Purged bytes shows the number of bytes of parameters that a function removes from the stack when it returns to its caller. For <code class="literal">cdecl</code> functions, this value is always zero. For <code class="literal">stdcall</code> functions, this value represents the amount of space consumed by any parameters that are passed on the stack (see <a class="xref" href="ch06s02.html#an_ebp-based_stack_frame" title="Figure 6-4. An EBP-based stack frame">Figure 6-4</a>). In x86 programs, IDA can automatically determine this value when it observes the use of the <code class="literal">RET N</code> variant of the return instruction.<a class="indexterm" id="IDX-CHP-7-0122"/><a class="indexterm" id="IDX-CHP-7-0123"/><a class="indexterm" id="IDX-CHP-7-0124"/><a class="indexterm" id="IDX-CHP-7-0125"/><a class="indexterm" id="IDX-CHP-7-0126"/><a class="indexterm" id="IDX-CHP-7-0127"/><a class="indexterm" id="IDX-CHP-7-0128"/><a class="indexterm" id="IDX-CHP-7-0129"/></p></dd><dt><span class="term"><span class="strong"><strong>Frame pointer delta</strong></span></span></dt><dd><p>In some cases, compilers may adjust a function’s frame pointer to point somewhere into the middle of the local variable area rather than at the saved frame pointer at the bottom of the local variable area. This distance from the adjusted frame pointer to the saved frame pointer is termed the <span class="emphasis"><em>frame pointer delta</em></span>. In most cases any frame pointer delta will be computed automatically when the function is analyzed. Compilers utilize a stack frame delta as a speed optimization. The purpose of the delta is to keep as many stack frame variables as possible within reach of a 1-byte signed offset (−128..+127) from the frame pointer.</p></dd></dl></div><p>Additional attribute checkboxes are available to further characterize the function. As with other fields within the dialog, these checkboxes generally reflect the results of IDA’s automatic analysis. The following attributes can be toggled on and off.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Does not return</strong></span></span></dt><dd><p>The function does not return to its caller. When such a function is called, IDA does not assume that execution continues following the associated call instruction.</p></dd><dt><span class="term"><span class="strong"><strong>Far function</strong></span></span></dt><dd><p>Used to mark a function as a far function on segmented architectures. Callers of the function would need to specify both a segment and an offset value when calling the function. The need to use far calls is typically dictated by the memory model in use within a program rather than by the fact that the architecture supports segmentation, for example, the use of the <span class="emphasis"><em>large</em></span> (as opposed to <span class="emphasis"><em>flat</em></span>) memory model on an x86.</p></dd><dt><span class="term"><span class="strong"><strong>Library func</strong></span></span></dt><dd><p>Flags a function as library code. Library code might include support routines included by a compiler or functions that are part of a statically linked library. Marking a function as a library function causes the function to be displayed using the assigned library function coloring to distinguish it from nonlibrary code.</p></dd><dt><span class="term"><span class="strong"><strong>Static func</strong></span></span></dt><dd><p>Does nothing other than display the static modifier in the function’s attribute list.</p></dd><dt><span class="term"><span class="strong"><strong>BP based frame</strong></span></span></dt><dd><p>Indicates that the function utilizes a frame pointer. In most cases you determine this automatically by analyzing the function’s prologue. If analysis fails to recognize that a frame pointer is used in the given function, you can manually select this attribute. If you do manually select this attribute, make sure that you adjust the saved register size (usually increased by the size of the saved frame pointer) and local variable size (usually decreased by the size of the saved frame pointer) accordingly. For frame pointer–based frames, memory references that make use of the frame pointer are formatted to make use of symbolic stack variable names rather than numeric offsets. If this attribute is not set, then stack frame references are assumed to be relative to the stack pointer register.<a class="indexterm" id="IDX-CHP-7-0130"/><a class="indexterm" id="IDX-CHP-7-0131"/><a class="indexterm" id="IDX-CHP-7-0132"/><a class="indexterm" id="IDX-CHP-7-0133"/><a class="indexterm" id="IDX-CHP-7-0134"/><a class="indexterm" id="IDX-CHP-7-0135"/></p></dd><dt><span class="term"><span class="strong"><strong>BP equals to SP</strong></span></span></dt><dd><p>Some functions configure the frame pointer to point to the top of the stack frame (along with the stack pointer) upon entering a function. This attribute should be set in such cases. This is essentially the same as having a frame pointer delta equal in size to the local variable area.<a class="indexterm" id="IDX-CHP-7-0136"/></p></dd></dl></div></div><div class="sect3" title="Stack Pointer Adjustments"><div class="titlepage"><div><div><h3 class="title"><a id="stack_pointer_adjustments"/>Stack Pointer Adjustments</h3></div></div></div><p>As we mentioned previously, IDA makes every effort to track changes to the stack pointer at each instruction within a function. The accuracy that IDA manages to achieve in doing so significantly impacts the accuracy of the function’s stack frame layout. When IDA is unable to determine whether an instruction alters the stack pointer, you may find that you need to specify a manual stack pointer adjustment.</p><p>The most straightforward example of such a case occurs when one function calls another function that makes use of the <code class="literal">stdcall</code> calling convention. If the function being called resides in a shared library that IDA does not have knowledge of (IDA ships with knowledge of the signatures and calling conventions of many common library functions), then IDA will be unaware that the function utilizes <code class="literal">stdcall</code> and will fail to account for the fact that the stack pointer will have been modified by the called function prior to returning. Thus, IDA will reflect an inaccurate value for the stack pointer for the remainder of the function. The following function call sequence, in which <code class="literal">some_imported_func</code> resides in a shared library, demonstrates this problem (note that the stack pointer line part option has been turned on):</p><a id="I_programlisting4_d1e9028"/><pre class="programlisting">.text:004010EB   01C      push     eax
    .text:004010F3   020      push     2
    .text:004010FB   024      push     1
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>   .text:00401102   028      call    some_imported_func
    .text:00401107   <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>028      mov     ebx, eax</pre><p>Since <code class="literal">some_imported_func</code> uses <code class="literal">stdcall</code>, it cleans the three parameters from the stack as it returns, and the correct stack pointer value at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e9050"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> should be <code class="literal">01C</code>. One way to fix this problem is to associate a manual stack adjustment with the instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e9059"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Stack adjustments can be added by highlighting the address to which the adjustment applies, selecting Edit ▸ Functions ▸ Change Stack Pointer (hotkey <span class="keycap">alt</span>-K), and specifying the number of bytes by which the stack pointer changes, in this case 12.<a class="indexterm" id="IDX-CHP-7-0137"/></p><p>While the previous example serves to illustrate a point, there is a better solution to this particular problem. Consider the case in which <code class="literal">some_imported_func</code> is called many different times. In that case, we would need to make the stack adjustment we just made at each location from which <code class="literal">some_imported_func</code> is called. Clearly this could be very tedious, and we might miss something. The better solution is to educate IDA regarding the behavior of <code class="literal">some_imported_func</code>. Because we are dealing with an imported function, when we attempt to navigate to it, we eventually end up at the import table entry for that function, which looks something like the following entry:<a class="indexterm" id="IDX-CHP-7-0138"/><a class="indexterm" id="IDX-CHP-7-0139"/><a class="indexterm" id="IDX-CHP-7-0140"/><a class="indexterm" id="IDX-CHP-7-0141"/><a class="indexterm" id="IDX-CHP-7-0142"/><a class="indexterm" id="IDX-CHP-7-0143"/><a class="indexterm" id="IDX-CHP-7-0144"/><a class="indexterm" id="IDX-CHP-7-0145"/></p><a id="I_programlisting4_d1e9114"/><pre class="programlisting">.idata:00418078   ; Segment type: Externs
.idata:00418078   ; _idata
.idata:00418078         extrn some_imported_func:dword ; DATA XREF: sub_401034↑r</pre><p>Even though this is an imported function, IDA allows you to edit one piece of information concerning its behavior: the number of purged bytes associated with the function. By editing this function, you can specify the number of bytes that it clears off the stack when it returns, and IDA will propagate the information that you supply to every location that calls the function, instantly correcting the stack pointer computations at each of those locations.</p><p>In order to improve its automated analysis, IDA incorporates advanced techniques that attempt to resolve stack pointer discrepancies by solving a system of linear equations related to the behavior of the stack pointer. As a result, you may not even realize that IDA has no prior knowledge of the details of functions such as <code class="literal">some_imported_func</code>. For more information on these techniques, refer to Ilfak’s blog post titled “Simplex method in IDA Pro” at <a class="ulink" href="http://hexblog.com/2006/06/">http://hexblog.com/2006/06/</a>.</p></div></div><div class="sect2" title="Converting Data to Code (and Vice Versa)"><div class="titlepage"><div><div><h2 class="title"><a id="converting_data_to_code_open_parenthesis"/>Converting Data to Code (and Vice Versa)</h2></div></div></div><p>During the automatic analysis phase, bytes are occasionally categorized incorrectly. Data bytes may be incorrectly classified as code bytes and disassembled into instructions, or code bytes may be incorrectly classified as data bytes and formatted as data values. This happens for many reasons, including the fact that some compilers embed data into the code section of programs or the fact that some code bytes are never directly referenced as code and IDA opts not to disassemble them. Obfuscated programs in particular tend to blur the distinction between code sections and data sections.<a class="indexterm" id="IDX-CHP-7-0146"/></p><p>Regardless of the reason that you wish to reformat your disassembly, doing so is fairly easy. The first option for reformatting anything is to remove its current formatting (code or data). It is possible to undefine functions, code, or data by right-clicking the item that you wish to undefine and selecting Undefine (also Edit ▸ Undefine or hotkey U) from the resulting context-sensitive menu. Undefining an item causes the underlying bytes to be reformatted as a list of raw byte values. Large regions can be undefined by using a click-and-drag operation to select a range of addresses prior to performing the undefine operation. As an example, consider the simple function listing that follows:<a class="indexterm" id="IDX-CHP-7-0147"/><a class="indexterm" id="IDX-CHP-7-0148"/></p><a id="I_programlisting4_d1e9143"/><pre class="programlisting">.text:004013E0 sub_4013E0      proc near
.text:004013E0                 push    ebp
.text:004013E1                 mov     ebp, esp
.text:004013E3                 pop     ebp
.text:004013E4                 retn
.text:004013E4 sub_4013E0      endp</pre><p>Undefining this function would yield the series of uncategorized bytes shown here, which we could choose to reformat in virtually any manner:<a class="indexterm" id="IDX-CHP-7-0149"/></p><a id="I_programlisting4_d1e9150"/><pre class="programlisting">.text:004013E0 unk_4013E0      db  55h ; U
.text:004013E1                 db  89h ; ë
.text:004013E2                 db 0E5h ; s
.text:004013E3                 db  5Dh ; ]
.text:004013E4                 db 0C3h ; +</pre><p>To disassemble a sequence of undefined bytes, right-click the first byte to be disassembled and select Code (also Edit ▸ Code or hotkey C). This causes IDA to disassemble all bytes until it encounters a defined item or an illegal instruction. Large regions can be converted to code by using a click-and-drag operation to select a range of addresses prior to performing the code-conversion operation.</p><p>The complementary operation of converting code to data is a little more complex. First, it is not possible to convert code to data using the context menu. Available alternatives include Edit ▸ Data and the D hotkey. Bulk conversions of instructions to data are easiest to accomplish by first undefining all of the instructions that you wish to convert to data and then formatting the data appropriately. Basic data formatting is discussed in the following section.<a class="indexterm" id="IDX-CHP-7-0150"/></p></div></div>
<div class="sect1" title="Basic Data Transformations"><div class="titlepage"><div><div><h1 class="title"><a id="basic_data_transformations"/>Basic Data Transformations</h1></div></div></div><p>Properly formatted data can be as important in developing an understanding of a program’s behavior as properly formatted code. IDA takes information from a variety of sources and uses many algorithms in order to determine the most appropriate way to format data within a disassembly. A few examples serve to illustrate how data formats are selected.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Datatypes and/or sizes can be inferred from the manner in which registers are used. An instruction observed to load a 32-bit register from memory implies that the associated memory location holds a 4-byte datatype (though we may not be able to distinguish between a 4-byte integer and a 4-byte pointer).</p></li><li class="listitem"><p>Function prototypes can be used to assign datatypes to function parameters. IDA maintains a large library of function prototypes for exactly this purpose. Analysis is performed on the parameters passed to functions in an attempt to tie a parameter to a memory location. If such a relationship can be uncovered, then a datatype can be applied to the associated memory location. Consider a function whose single parameter is a pointer to a CRITICAL_SECTION (a Windows API datatype). If IDA can determine the address passed in a call to this function, then IDA can flag that address as a CRITICAL_SECTION object.<a class="indexterm" id="IDX-CHP-7-0151"/><a class="indexterm" id="IDX-CHP-7-0152"/><a class="indexterm" id="IDX-CHP-7-0153"/><a class="indexterm" id="IDX-CHP-7-0154"/><a class="indexterm" id="IDX-CHP-7-0155"/><a class="indexterm" id="IDX-CHP-7-0156"/></p></li><li class="listitem"><p>Analysis of a sequence of bytes can reveal likely datatypes. This is precisely what happens when a binary is scanned for string content. When long sequences of ASCII characters are encountered, it is not unreasonable to assume that they represent character arrays.<a class="indexterm" id="IDX-CHP-7-0157"/></p></li></ol></div><p>In the next few sections we discuss some basic transformations that you can perform on data within your disassemblies.</p><div class="sect2" title="Specifying Data Sizes"><div class="titlepage"><div><div><h2 class="title"><a id="specifying_data_sizes"/>Specifying Data Sizes</h2></div></div></div><p>The simplest way to modify a piece of data is to adjust its size. IDA offers a number of data size/type specifiers. The most commonly encountered specifiers are <code class="literal">db</code>, <code class="literal">dw</code>, and <code class="literal">dd</code>, representing 1-, 2-, and 4-byte data, respectively. The first way to change a data item’s size is via the Options ▸ Setup Data Types dialog shown in <a class="xref" href="ch07s04.html#the_datatype_setup_dialog" title="Figure 7-8. The datatype setup dialog">Figure 7-8</a>.</p><p>There are two parts to this dialog. The left side of the dialog contains a column of buttons used to immediately change the data size of the currently selected item. The right side of the dialog contains a column of checkboxes used to configure what IDA terms the <span class="emphasis"><em>data carousel</em></span>. Note that for each button on the left, there is a corresponding checkbox on the right. The data carousel is a revolving list of datatypes that contains only those types whose checkboxes are selected. Modifying the contents of the data carousel has no immediate impact on the IDA display. Instead, each type on the data carousel is listed on the context-sensitive menu that appears when you right-click a data item. Thus, it is easier to reformat data to a type listed in the data carousel than to a type not listed in the data carousel. Given the datatypes selected in <a class="xref" href="ch07s04.html#the_datatype_setup_dialog" title="Figure 7-8. The datatype setup dialog">Figure 7-8</a>, right-clicking a data item would offer you the opportunity to reformat that item as byte, word, or double-word data.<a class="indexterm" id="IDX-CHP-7-0158"/></p><div class="figure"><a id="the_datatype_setup_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e9232"/><img alt="The datatype setup dialog" src="httpatomoreillycomsourcenostarchimages854159.png.jpg"/></div></div><p class="title">Figure 7-8. The datatype setup dialog</p></div><p>The name for the data carousel derives from the behavior of the associated data formatting hotkey: D. When you press D, the item at the currently selected address is reformatted to the next type in the data carousel list. With the three-item list specified previously, an item currently formatted as <code class="literal">db</code> toggles to <code class="literal">dw</code>, an item formatted as <code class="literal">dw</code> toggles to <code class="literal">dd</code>, and an item formatted as <code class="literal">dd</code> toggles back to <code class="literal">db</code> to complete the circuit around the carousel. Using the data hotkey on a nondata item such as code causes the item to be formatted as the first datatype in the carousel list (<code class="literal">db</code> in this case).<a class="indexterm" id="IDX-CHP-7-0159"/><a class="indexterm" id="IDX-CHP-7-0160"/><a class="indexterm" id="IDX-CHP-7-0161"/><a class="indexterm" id="IDX-CHP-7-0162"/><a class="indexterm" id="IDX-CHP-7-0163"/><a class="indexterm" id="IDX-CHP-7-0164"/><a class="indexterm" id="IDX-CHP-7-0165"/></p><p>Toggling through datatypes causes data items to grow, shrink, or remain the same size. If an item’s size remains the same, then the only observable change is in the way the data is formatted. If you reduce an item’s size, from <code class="literal">dd</code> (4 bytes) to <code class="literal">db</code> (1 byte) for example, any extra bytes (3 in this case) become undefined. If you increase the size of an item, IDA complains if the bytes following the item are already defined and asks you, in a roundabout way, if you want IDA to undefine the next item in order to expand the current item. The message you encounter in such cases is “Directly convert to data?” This message generally means that IDA will undefine a sufficient number of succeeding items to satisfy your request. For example, when converting byte data (<code class="literal">db</code>) to double-word data (<code class="literal">dd</code>), 3 additional bytes must be consumed to form the new data item.<a class="indexterm" id="IDX-CHP-7-0166"/></p><p>Datatypes and sizes can be specified for any location that describes data, including stack variables. To change the size of stack-allocated variables, open the detailed stack frame view by double-clicking the variable you wish to modify; then change the variable’s size as you would any other variable.</p></div><div class="sect2" title="Working with Strings"><div class="titlepage"><div><div><h2 class="title"><a id="working_with_strings"/>Working with Strings</h2></div></div></div><p>IDA recognizes a large number of string formats. By default, IDA searches for and formats C-style null-terminated strings. To force data to be converted to a string, utilize the options on the Edit ▸ Strings menu to select a specific string style. If the bytes beginning at the currently selected address form a string of the selected style, IDA groups those bytes together into a single-string variable. At any time, you can use the A hotkey to format the currently selected location in the default string style.<a class="indexterm" id="IDX-CHP-7-0167"/></p><p>Two dialogs are responsible for the configuration of string data. The first, shown in <a class="xref" href="ch07s04.html#string_data_configuration" title="Figure 7-9. String data configuration">Figure 7-9</a>, is accessed via Options ▸ ASCII String Style, though ASCII in this case is a bit of a misnomer, as a much wider variety of string styles are understood.</p><p>Similar to the datatype configuration dialog, the buttons on the left are used to create a string of the specified style at the currently selected location. A string is created only if the data at the current location conforms to the specified string format. For <span class="emphasis"><em>Character terminated</em></span> strings, up to two termination characters can be specified toward the bottom of the dialog. The radio buttons on the right of the dialog are used to specify the default string style associated with the use of the strings hotkey (A).</p><div class="figure"><a id="string_data_configuration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e9327"/><img alt="String data configuration" src="httpatomoreillycomsourcenostarchimages854161.png.jpg"/></div></div><p class="title">Figure 7-9. String data configuration</p></div><p>The second dialog used to configure string operations is the Options ▸ General dialog, shown in <a class="xref" href="ch07s04.html#ida_strings_options" title="Figure 7-10. IDA Strings options">Figure 7-10</a>, where the Strings tab allows configuration of additional strings-related options. While you can specify the default string type here as well using the available drop-down box, the majority of available options deal with the naming and display of string data, regardless of their type. The Name generation area on the right of the dialog is visible only when the Generate names option is selected. When name generation is turned off, string variables are given dummy names beginning with the <code class="literal">asc_</code> prefix.<a class="indexterm" id="IDX-CHP-7-0168"/><a class="indexterm" id="IDX-CHP-7-0169"/><a class="indexterm" id="IDX-CHP-7-0170"/><a class="indexterm" id="IDX-CHP-7-0171"/><a class="indexterm" id="IDX-CHP-7-0172"/></p><div class="figure"><a id="ida_strings_options"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e9359"/><img alt="IDA Strings options" src="httpatomoreillycomsourcenostarchimages854163.png.jpg"/></div></div><p class="title">Figure 7-10. IDA Strings options</p></div><p>When name generation is enabled, the Name generation options control how IDA generates names for string variables. When Generate serial names is <span class="emphasis"><em>not</em></span> selected (the default), the specified prefix is combined with characters taken from the string to generate a name that does not exceed the current maximum name length. An example of such a string appears here:<a class="indexterm" id="IDX-CHP-7-0173"/><a class="indexterm" id="IDX-CHP-7-0174"/><a class="indexterm" id="IDX-CHP-7-0175"/><a class="indexterm" id="IDX-CHP-7-0176"/><a class="indexterm" id="IDX-CHP-7-0177"/><a class="indexterm" id="IDX-CHP-7-0178"/></p><a id="I_programlisting4_d1e9393"/><pre class="programlisting">.rdata:00402069 aThisIsACharact db 'This is a Character array',0</pre><p>Title case is used in the name, and any characters that are not legal to use within names (such as spaces) are omitted when forming the name. The Mark as autogenerated option causes generated names to appear in a different color (dark blue by default) than user-specified names (blue by default). Preserve case forces the name to use characters as they appear within the string rather than converting them to title case. Finally, Generate serial names causes IDA to serialize names by appending numeric suffixes (beginning with Number). The number of digits in generated suffixes is controlled by the Width field. As configured in <a class="xref" href="ch07s04.html#ida_strings_options" title="Figure 7-10. IDA Strings options">Figure 7-10</a>, the first three names to be generated would be <code class="literal">a000</code>, <code class="literal">a001</code>, and <code class="literal">a002</code>.<a class="indexterm" id="IDX-CHP-7-0179"/><a class="indexterm" id="IDX-CHP-7-0180"/><a class="indexterm" id="IDX-CHP-7-0181"/><a class="indexterm" id="IDX-CHP-7-0182"/></p></div><div class="sect2" title="Specifying Arrays"><div class="titlepage"><div><div><h2 class="title"><a id="specifying_arrays"/>Specifying Arrays</h2></div></div></div><p>One of the drawbacks to disassembly listings derived from higher-level languages is that they provide very few clues regarding the size of arrays. In a disassembly listing, specifying an array can require a tremendous amount of space if each item in the array is specified on its own disassembly line. The following listing shows data declarations that follow the named variable <code class="literal">unk_402060</code>. The fact that only the first item in the listing is referenced by any instructions suggests that it may be the first element in an array. Rather than being referenced directly, additional elements within arrays are often referenced using more complex index computations to offset from the beginning of the array.</p><a id="I_programlisting4_d1e9429"/><pre class="programlisting">.rdata:00402060 unk_402060      db    0    ; DATA XREF: sub_401350+8↑o
.rdata:00402060                            ; sub_401350+18↑o
.rdata:00402061                 db    0
.rdata:00402062                 db    0
.rdata:00402063                 db    0
.rdata:00402064                 db    0
.rdata:00402065                 db    0
.rdata:00402066                 db    0
.rdata:00402067                 db    0
.rdata:00402068                 db    0
.rdata:00402069                 db    0
.rdata:0040206A                 db    0</pre><p>IDA provides facilities for grouping consecutive data definitions together into a single array definition. To create an array, select the first element of the array (we chose <code class="literal">unk_402060</code>) and use Edit ▸ Array to launch the array-creation dialog shown in <a class="xref" href="ch07s04.html#array-creation_dialog" title="Figure 7-11. Array-creation dialog">Figure 7-11</a>. If a data item has been defined at a given location, then an Array option will be available when you right-click the item. The type of array to be created is dictated by the datatype associated with the item selected as the first item in the array. In this case we are creating an array of bytes.<a class="indexterm" id="IDX-CHP-7-0183"/><a class="indexterm" id="IDX-CHP-7-0184"/><a class="indexterm" id="IDX-CHP-7-0185"/><a class="indexterm" id="IDX-CHP-7-0186"/><a class="indexterm" id="IDX-CHP-7-0187"/></p><div class="figure"><a id="array-creation_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e9458"/><img alt="Array-creation dialog" src="httpatomoreillycomsourcenostarchimages854165.png.jpg"/></div></div><p class="title">Figure 7-11. Array-creation dialog</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Prior to creating an array, make sure that you select the proper size for array elements by changing the size of the first item in the array to the appropriate value.</p></div><p>Following are descriptions of useful fields for array creation:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Array element width</strong></span></span></dt><dd><p>This value indicates the size of an individual array element (1 byte in this case) and is dictated by the size of the data value that was selected when the dialog was launched.</p></dd><dt><span class="term"><span class="strong"><strong>Maximum possible size</strong></span></span></dt><dd><p>This value is automatically computed as the maximum number of elements (not bytes) that can be included in the array before another defined data item is encountered. Specifying a larger size may be possible but will require succeeding data items to be undefined in order to absorb them into the array.</p></dd><dt><span class="term"><span class="strong"><strong>Number of elements</strong></span></span></dt><dd><p>This is where you specify the exact size of the array. The total number of bytes occupied by the array can be computed as Number of elements × Array element width.</p></dd><dt><span class="term"><span class="strong"><strong>Items on a line</strong></span></span></dt><dd><p>Specifies the number of elements to be displayed on each disassembly line. This can be used to reduce the amount of space required to display the array.</p></dd><dt><span class="term"><span class="strong"><strong>Element width</strong></span></span></dt><dd><p>This value is for formatting purposes only and controls the column width when multiple items are displayed on a single line.<a class="indexterm" id="IDX-CHP-7-0188"/><a class="indexterm" id="IDX-CHP-7-0189"/><a class="indexterm" id="IDX-CHP-7-0190"/><a class="indexterm" id="IDX-CHP-7-0191"/><a class="indexterm" id="IDX-CHP-7-0192"/></p></dd><dt><span class="term"><span class="strong"><strong>Use “dup” construct</strong></span></span></dt><dd><p>This option causes identical data values to be grouped into a single item with a repetition specifier.</p></dd><dt><span class="term"><span class="strong"><strong>Signed elements</strong></span></span></dt><dd><p>Dictates whether data is displayed as signed or unsigned values.</p></dd><dt><span class="term"><span class="strong"><strong>Display indexes</strong></span></span></dt><dd><p>Causes array indexes to be displayed as regular comments. This is useful if you need to locate specific data values within large arrays. Selecting this option also enables the Indexes radio buttons so you can choose the display format for each index value.<a class="indexterm" id="IDX-CHP-7-0193"/></p></dd><dt><span class="term"><span class="strong"><strong>Create as array</strong></span></span></dt><dd><p>Not checking this may seem to go against the purpose of the dialog, and it is usually left checked. Uncheck it if your goal is simply to specify some number of consecutive items without grouping them into an array.</p></dd></dl></div><p>Accepting the options specified in <a class="xref" href="ch07s04.html#array-creation_dialog" title="Figure 7-11. Array-creation dialog">Figure 7-11</a> results in the following compact array declaration, which can be read as an array of bytes (<code class="literal">db</code>) named <code class="literal">byte_402060</code> consisting of the value <code class="literal">0</code> repeated <code class="literal">416</code> (<code class="literal">1A0h</code>) times.</p><a id="I_programlisting4_d1e9570"/><pre class="programlisting">.rdata:00402060 byte_402060     db 1A0h dup(0)     ; DATA XREF: sub_401350+8↑o
.rdata:00402060                                    ; sub_401350+18↑o</pre><p>The net effect is that 416 lines of disassembly have been condensed to a single line (largely due to the use of <code class="literal">dup</code>). In the next chapter we will discuss the creation of arrays within stack frames.</p></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id6"/>Summary</h1></div></div></div><p>Together with the previous chapter, this chapter encompasses the most common operations that IDA users will ever need to perform. Through the use of database modifications, you will combine your own knowledge with the knowledge imparted by IDA during its analysis phase to produce much more useful databases. As with source code, the effective use of names, assignment of datatypes, and detailed comments will not only assist you in remembering what you have analyzed but will also greatly assist others who may be required to make use of your work. In the next chapter we continue to drill into IDA’s capabilities by taking a look at how to deal with more complex data structures, such as those represented by the C <code class="literal">struct</code>, and go on to examine some of the low-level details of compiled C++.</p></div>
<div class="chapter" title="Chapter&#xA0;8.&#xA0;Datatypes and Data Structures"><div class="titlepage"><div><div><h1 class="title"><a id="datatypes_and_data_structures"/>Chapter 8. Datatypes and Data Structures</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id8"/><div class="mediaobject"><a id="I_mediaobject5_d1e9589"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>The low-hanging fruit in understanding the behavior of binary programs lies in cataloging the library functions that the program calls. A C program that calls the <code class="literal">connect</code> function is creating a network connection. A Windows program that calls <code class="literal">RegOpenKey</code> is accessing the Windows registry. Additional analysis is required, however, to gain an understanding of how and why these functions are called.<a class="indexterm" id="IDX-CHP-8-0001"/><a class="indexterm" id="IDX-CHP-8-0002"/></p><p>Discovering how a function is called requires learning what parameters are passed to the function. In the case of a <code class="literal">connect</code> call, beyond the simple fact that the function is being called, it is important to know exactly what network address the program is connecting to. Understanding the data that is being passed into functions is the key to reverse engineering a function’s signature (the number, type, and sequence of parameters required by the function) and, as such, points out the importance of understanding how datatypes and data structures are manipulated at the assembly language level.</p><p>In this chapter we will examine how IDA conveys datatype information to the user, how data structures are stored in memory, and how data within those data structures is accessed. The simplest method for associating a specific datatype with a variable is to observe the use of the variable as a parameter to a function that we know something about. During its analysis phase, IDA makes every effort to annotate datatypes when they can be deduced based on a variable’s use with a function for which IDA possesses a prototype. When possible, IDA will go as far as using a formal parameter name lifted from a function prototype rather than generating a default dummy name for the variable. This can be seen in the following disassembly of a call to <code class="literal">connect</code>:<a class="indexterm" id="IDX-CHP-8-0003"/></p><a id="I_programlisting5_d1e9621"/><pre class="programlisting">.text:004010F3                 push    10h             ; namelen
.text:004010F5                 lea     ecx, <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>[ebp+name]
.text:004010F8                 push    ecx             ; name
.text:004010F9                 mov     edx, <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>[ebp+s]
.text:004010FF                 push    edx             ; s
.text:00401100                 call    connect</pre><p>In this listing we can see that each <code class="literal">push</code> has been commented with the name of the parameter that is being pushed (taken from IDA’s knowledge of the function prototype). In addition, two local stack variables <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9640"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> have been named for the parameters that they correspond to. In most cases, these names will be far more informative than the dummy names that IDA would otherwise generate.<a class="indexterm" id="IDX-CHP-8-0004"/></p><p>IDA’s ability to propagate type information from function prototypes is not limited to library functions contained in IDA’s type libraries. IDA can propagate formal parameter names and data types from any function in your database as long as you have explicitly set the function’s type information. Upon initial analysis, IDA assigns dummy names and the generic type <code class="literal">int</code> to all function arguments, unless through type propagation it has reason to do otherwise. In any case, you must set a function’s type by using the Edit ▸ Functions ▸ Set Function Type command, right-clicking on a function name, and choosing Set Function Type on the context menu or using the Y hotkey. For the function shown below, this results in the dialog shown in <a class="xref" href="ch08.html#setting_a_functionas_type" title="Figure 8-1. Setting a function’s type">Figure 8-1</a>, in which you may enter the function’s correct prototype.<a class="indexterm" id="IDX-CHP-8-0005"/><a class="indexterm" id="IDX-CHP-8-0006"/></p><a id="I_programlisting5_d1e9662"/><pre class="programlisting">.text:00401050 ; ======== S U B R O U T I N E =========================
.text:00401050
.text:00401050 ; Attributes: bp-based frame
.text:00401050
.text:00401050 foo     proc near      ; CODE XREF: demo_stackframe+2A↓p
.text:00401050
.text:00401050 arg_0   = dword ptr  8
.text:00401050 arg_4   = dword ptr  0Ch
.text:00401050
.text:00401050         push    ebp
.text:00401051         mov     ebp, esp</pre><p>As shown below, IDA assumes an <code class="literal">int</code> return type, correctly deduces that the <code class="literal">cdecl</code> calling convention is used based on the type of <code class="literal">ret</code> instruction used, incorporates the name of the function as we have modified it, and assumes all parameters are of type <code class="literal">int</code>. Because we have not yet modified the argument names, IDA displays only their types.<a class="indexterm" id="IDX-CHP-8-0007"/><a class="indexterm" id="IDX-CHP-8-0008"/><a class="indexterm" id="IDX-CHP-8-0009"/><a class="indexterm" id="IDX-CHP-8-0010"/><a class="indexterm" id="IDX-CHP-8-0011"/><a class="indexterm" id="IDX-CHP-8-0012"/><a class="indexterm" id="IDX-CHP-8-0013"/></p><div class="figure"><a id="setting_a_functionas_type"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e9705"/><img alt="Setting a function’s type" src="httpatomoreillycomsourcenostarchimages854167.png.jpg"/></div></div><p class="title">Figure 8-1. Setting a function’s type</p></div><p>If we modify the prototype to read <code class="literal">int __cdecl foo(float f, char *ptr)</code>, IDA will automatically insert a prototype comment <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9716"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> for the function and change the argument names <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9722"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> in the disassembly as shown below.</p><a id="I_programlisting5_d1e9728"/><pre class="programlisting">.text:00401050 ; ======== S U B R O U T I N E =========================
.text:00401050
.text:00401050 ; Attributes: bp-based frame
.text:00401050
.text:00401050 <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>; int __cdecl foo(float f, char *ptr)
.text:00401050 foo     proc near      ; CODE XREF: demo_stackframe+2A↓p
.text:00401050
.text:00401050 <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>f       = dword ptr  8
.text:00401050 <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>ptr     = dword ptr  0Ch
.text:00401050
.text:00401050         push    ebp
.text:00401051         mov     ebp, esp</pre><p>Finally, IDA propagates this information to all callers of the newly modified function, resulting in improved annotation of all related function calls as shown here. Note that the argument names <code class="literal">f</code> and <code class="literal">ptr</code> have been propagated out as comments <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9756"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> in the calling function and used to rename variables <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9762"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> that formerly used dummy names.</p><a id="I_programlisting5_d1e9768"/><pre class="programlisting">.text:004010AD         mov     eax, [ebp+<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>ptr]
.text:004010B0         mov     [esp+4], eax    <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>; ptr
.text:004010B4         mov     eax, [ebp+<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>f]
.text:004010B7         mov     [esp], eax      <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>; f
.text:004010BA         call    foo</pre><p>Returning to imported library functions, it is often the case that IDA will already know the prototype of the function. In such cases, you can easily view the prototype by holding the mouse over the function name.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-1" id="CHP-8-FN-1">44</a>]</sup> When IDA has no knowledge of a function’s parameter sequence, it should, at a minimum, know the name of the library from which the function was imported (see the Imports window). When this happens, your best resources for learning the behavior of the function are any associated man pages or other available API documentation (such as MSDN online<sup>[<a class="footnote" href="#ftn.CHP-8-FN-2" id="CHP-8-FN-2">45</a>]</sup>). When all else fails, remember the adage: <span class="emphasis"><em>Google is your friend</em></span>.<a class="indexterm" id="IDX-CHP-8-0014"/></p><p>For the remainder of this chapter, we will be discussing how to recognize when data structures are being used in a program, how to decipher the organizational layout of such structures, and how to use IDA to improve the readability of a disassembly when such structures are in use. Since C++ classes are a complex extension of C structures, the chapter concludes with a discussion of reverse engineering compiled C++ programs.</p><div class="sect1" title="Recognizing Data Structure Use"><div class="titlepage"><div><div><h1 class="title"><a id="recognizing_data_structure_use"/>Recognizing Data Structure Use</h1></div></div></div><p>While primitive datatypes are often a natural fit with the size of a CPU’s registers or instruction operands, composite datatypes such as arrays and structures typically require more complex instruction sequences in order to access the individual data items that they contain. Before we can discuss IDA’s feature for improving the readability of code that utilizes complex datatypes, we need to review what that code looks like.<a class="indexterm" id="IDX-CHP-8-0015"/><a class="indexterm" id="IDX-CHP-8-0016"/></p><div class="sect2" title="Array Member Access"><div class="titlepage"><div><div><h2 class="title"><a id="array_member_access"/>Array Member Access</h2></div></div></div><p>Arrays are the simplest composite data structure in terms of memory layout. Traditionally, arrays are contiguous blocks of memory that contain consecutive elements of the same datatype. The size of an array is easy to compute, as it is the product of the number of elements in the array and the size of each element. Using C notation, the minimum number of bytes consumed by the following array<a class="indexterm" id="IDX-CHP-8-0017"/></p><a id="I_programlisting5_d1e9835"/><pre class="programlisting">int array_demo[100];</pre><p>is computed as</p><a id="I_programlisting5_d1e9839"/><pre class="programlisting">int bytes = 100 * sizeof(int);</pre><p>Individual array elements are accessed by supplying an index value, which may be a variable or a constant, as shown in these array references:</p><a id="I_programlisting5_d1e9843"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> array_demo[20] = 15;  //fixed index into the array
  for (int i = 0; i &lt; 100; i++) {
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>     array_demo[i] = i;  //varying index into the array
  }</pre><p>Assuming, for the sake of example, that <code class="literal">sizeof(int)</code> is 4 bytes, then the first array access at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9861"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> accesses the integer value that lies 80 bytes into the array, while the second array access at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9867"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> accesses successive integers at offsets 0, 4, 8, .. 96 bytes into the array. The offset for the first array access can be computed at compile time as <code class="literal">20 * 4</code>. In most cases, the offset for the second array access must be computed at runtime because the value of the loop counter, <code class="literal">i</code>, is not fixed at compile time. Thus for each pass through the loop, the product <code class="literal">i * 4</code> must be computed to determine the exact offset into the array. Ultimately, the manner in which an array element is accessed depends not only on the type of index used but also on where the array happens to be allocated within the program’s memory space.<a class="indexterm" id="IDX-CHP-8-0018"/><a class="indexterm" id="IDX-CHP-8-0019"/><a class="indexterm" id="IDX-CHP-8-0020"/><a class="indexterm" id="IDX-CHP-8-0021"/><a class="indexterm" id="IDX-CHP-8-0022"/></p><div class="sect3" title="Globally Allocated Arrays"><div class="titlepage"><div><div><h3 class="title"><a id="globally_allocated_arrays"/>Globally Allocated Arrays</h3></div></div></div><p>When an array is allocated within the global data area of a program (within the <code class="literal">.data</code> or <code class="literal">.bss</code> section, for example), the base address of the array is known to the compiler at compile time. The fixed base address makes it possible for the compiler to compute fixed addresses for any array element that is accessed using a fixed index. Consider the following trivial program that accesses a global array using both fixed and variable offsets:</p><a id="I_programlisting5_d1e9913"/><pre class="programlisting">int global_array[3];

int main() {
   int idx = 2;
   global_array[0] = 10;
   global_array[1] = 20;
   global_array[2] = 30;
   global_array[idx] = 40;
}</pre><p>This program disassembles to the following:</p><a id="I_programlisting5_d1e9917"/><pre class="programlisting">.text:00401000 _main           proc near
.text:00401000
.text:00401000 idx             = dword ptr −4
.text:00401000
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 push    ecx
.text:00401004                 mov     [ebp+idx], 2
.text:0040100B                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>mov     dword_40B720, 10
.text:00401015                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     dword_40B724, 20
.text:0040101F                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     dword_40B728, 30
.text:00401029                 mov     eax, [ebp+idx]
.text:0040102C                <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>mov     dword_40B720[eax*4], 40
.text:00401037                 xor     eax, eax
.text:00401039                 mov     esp, ebp
.text:0040103B                 pop     ebp
.text:0040103C                 retn
.text:0040103C _main           endp</pre><p>While this program has only one global variable, the disassembly lines at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9945"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9951"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9957"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> seem to indicate that there are three global variables. The computation of an offset (<code class="literal">eax * 4</code>) at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9966"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> is the only thing that seems to hint at the presence of a global array named <code class="literal">dword_40B720</code>, yet this is the same name as the global variable found at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9976"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>.</p><p>Based on the dummy names assigned by IDA, we know that the global array is made up of the 12 bytes beginning at address <code class="literal">0040B720</code>. During the compilation process, the compiler has used the fixed indexes (0, 1, 2) to compute the actual addresses of the corresponding elements in the array (<code class="literal">0040B720</code>, <code class="literal">0040B724</code>, and <code class="literal">0040B728</code>), which are referenced using the global variables at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e9996"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10003"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10009"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. Using IDA’s array-formatting operations discussed in the last chapter (Edit ▸ Array), <code class="literal">dword_40B720</code> can be formatted as a three-element array yielding the alternate disassembly lines shown in the following listing. Note that this particular formatting highlights the use of offsets into the array:<a class="indexterm" id="IDX-CHP-8-0023"/></p><a id="I_programlisting5_d1e10023"/><pre class="programlisting">.text:0040100B                 mov     dword_40B720, 10
.text:00401015                 mov     dword_40B720+4, 20
.text:0040101F                 mov     dword_40B720+8, 30</pre><p>There are two points to note in this example. First, when constant indexes are used to access global arrays, the corresponding array elements will appear as global variables in the corresponding disassembly. In other words, the disassembly will offer essentially no evidence that an array exists. The second point is that the use of variable index values leads us to the start of the array because the base address will be revealed (as in <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10027"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>) when the computed offset is added to it to compute the actual array location to be accessed. The computation at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10033"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> offers one additional piece of significant information about the array. By observing the amount by which the array index is multiplied (4 in this case), we learn the size (though not the type) of an individual element in the array.</p></div><div class="sect3" title="Stack-Allocated Arrays"><div class="titlepage"><div><div><h3 class="title"><a id="stack-allocated_arrays"/>Stack-Allocated Arrays</h3></div></div></div><p>How does array access differ if the array is allocated as a stack variable instead? Instinctively, we might think that it must be different since the compiler can’t know an absolute address at compile time, so surely even accesses that use constant indexes must require some computation at runtime. In practice, however, compilers treat stack-allocated arrays almost identically to globally allocated arrays.<a class="indexterm" id="IDX-CHP-8-0024"/><a class="indexterm" id="IDX-CHP-8-0025"/></p><p>Consider the following program that makes use of a small stack-allocated array:</p><a id="I_programlisting5_d1e10054"/><pre class="programlisting">int main() {
   int stack_array[3];
   int idx = 2;
   stack_array[0] = 10;
   stack_array[1] = 20;
   stack_array[2] = 30;
   stack_array[idx] = 40;
}</pre><p>The address at which <code class="literal">stack_array</code> will be allocated is unknown at compile time, so it is not possible for the compiler to precompute the address of <code class="literal">stack_array[1]</code> at compile time as it did in the global array example. By examining the disassembly listing for this function, we gain insight into how stack-allocated arrays are accessed:</p><a id="I_programlisting5_d1e10064"/><pre class="programlisting">.text:00401000 _main           proc near
.text:00401000
.text:00401000 var_10          = dword ptr −10h
.text:00401000 var_C           = dword ptr −0Ch
.text:00401000 var_8           = dword ptr −8
.text:00401000 idx             = dword ptr −4
.text:00401000
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 sub     esp, 10h
.text:00401006                 mov     [ebp+idx], 2
.text:0040100D                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>mov     [ebp+var_10], 10
.text:00401014                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     [ebp+var_C], 20
.text:0040101B                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     [ebp+var_8], 30
.text:00401022                 mov     eax, [ebp+idx]
.text:00401025                <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>mov     [ebp+eax*4+var_10], 40
.text:0040102D                 xor     eax, eax
.text:0040102F                 mov     esp, ebp
.text:00401031                 pop     ebp
.text:00401032                 retn
.text:00401032 _main           endp</pre><p>As with the global array example, this function appears to have three variables (<code class="literal">var_10</code>, <code class="literal">var_C</code>, and <code class="literal">var_8</code>) rather than an array of three integers. Based on the constant operands used at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10101"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10107"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10114"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, we know that what appear to be local variable references are actually references to the three elements of <code class="literal">stack_array</code> whose first element must reside at <code class="literal">var_10</code>, the local variable with the lowest memory address.</p><p>To understand how the compiler resolved the references to the other elements of the array, consider what the compiler goes through when dealing with the reference to <code class="literal">stack_array[1]</code>, which lies 4 bytes into the array, or 4 bytes beyond the location of <code class="literal">var_10</code>. Within the stack frame, the compiler has elected to allocate <code class="literal">stack_array</code> at <code class="literal">ebp - 0x10</code>. The compiler understands that <code class="literal">stack_array[1]</code> lies at <code class="literal">ebp - 0x10 + 4</code>, which simplifies to <code class="literal">ebp - 0x0C</code>. The result is that IDA displays this as a local variable reference. The net effect is that, similar to globally allocated arrays, the use of constant index values tends to hide the presence of a stack-allocated array. Only the array access at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10150"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> hints at the fact that <code class="literal">var_10</code> is the first element in the array rather than a simple integer variable. In addition, the disassembly line at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10159"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> also helps us conclude that the size of individual elements in the array is 4 bytes.</p><p>Stack-allocated arrays and globally allocated arrays are thus treated very similarly by compilers. However, there is an extra piece of information that we can attempt to extract from the disassembly of the stack example. Based on the location of <code class="literal">idx</code> within the stack, it is possible to conclude that the array that begins with <code class="literal">var_10</code> contains no more than three elements (otherwise, it would overwrite <code class="literal">idx</code>). If you are an exploit developer, this can be very useful in determining exactly how much data you can fit into an array before you overflow it and begin to corrupt the data that follows.<a class="indexterm" id="IDX-CHP-8-0026"/><a class="indexterm" id="IDX-CHP-8-0027"/></p></div><div class="sect3" title="Heap-Allocated Arrays"><div class="titlepage"><div><div><h3 class="title"><a id="heap-allocated_arrays"/>Heap-Allocated Arrays</h3></div></div></div><p>Heap-allocated arrays are allocated using a dynamic memory allocation function such as <code class="literal">malloc</code> (C) or <code class="literal">new</code> (C++). From the compiler’s perspective, the primary difference in dealing with a heap-allocated array is that the compiler must generate all references into the array based on the address value returned from the memory allocation function. For the sake of comparison, we now take a look at the following function, which allocates a small array in the program heap:<a class="indexterm" id="IDX-CHP-8-0028"/><a class="indexterm" id="IDX-CHP-8-0029"/><a class="indexterm" id="IDX-CHP-8-0030"/></p><a id="I_programlisting5_d1e10204"/><pre class="programlisting">int main() {
   int *heap_array = (int*)malloc(3 * sizeof(int));
   int idx = 2;
   heap_array[0] = 10;
   heap_array[1] = 20;
   heap_array[2] = 30;
   heap_array[idx] = 40;
}</pre><p>In studying the corresponding disassembly that follows, you should notice a few similarities and differences with the two previous disassemblies:</p><a id="I_programlisting5_d1e10208"/><pre class="programlisting">.text:00401000 _main      proc near
.text:00401000
.text:00401000 heap_array      = dword ptr −8
.text:00401000 idx             = dword ptr −4
.text:00401000
.text:00401000            push    ebp
.text:00401001            mov     ebp, esp
.text:00401003            sub     esp, 8
.text:00401006           <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>push    0Ch             ; size_t
.text:00401008            call    _malloc
.text:0040100D            add     esp, 4
.text:00401010            mov     [ebp+heap_array], eax
.text:00401013            mov     [ebp+idx], 2
.text:0040101A            mov     eax, [ebp+heap_array]
.text:0040101D           <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>mov     dword ptr [eax], 10
.text:00401023            mov     ecx, [ebp+heap_array]
.text:00401026           <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     dword ptr [ecx+4], 20
.text:0040102D            mov     edx, [ebp+heap_array]
.text:00401030           <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     dword ptr [edx+8], 30
.text:00401037            mov     eax, [ebp+idx]
.text:0040103A            mov     ecx, [ebp+heap_array]
.text:0040103D           <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>mov     dword ptr [ecx+eax*4], 40
.text:00401044            xor     eax, eax
.text:00401046            mov     esp, ebp
.text:00401048            pop     ebp
.text:00401049            retn
.text:00401049 _main      endp</pre><p>The starting address of the array (returned from <code class="literal">malloc</code> in the EAX register) is stored in the local variable <code class="literal">heap_array</code>. In this example, unlike the previous examples, every access to the array begins with reading the contents of <code class="literal">heap_array</code> to obtain the array’s base address before an offset value can be added to compute the address of the correct element within the array. The references to <code class="literal">heap_array[0]</code>, <code class="literal">heap_array[1]</code>, and <code class="literal">heap_array[2]</code> require offsets of 0, 4, and 8 bytes, respectively, as seen at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10261"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10267"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10273"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The operation that most closely resembles the previous examples is the reference to <code class="literal">heap_array[idx]</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10282"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>, in which the offset into the array continues to be computed by multiplying the array index by the size of an array element.<a class="indexterm" id="IDX-CHP-8-0031"/><a class="indexterm" id="IDX-CHP-8-0032"/><a class="indexterm" id="IDX-CHP-8-0033"/></p><p>Heap-allocated arrays have one particularly nice feature. When both the total size of the array and the size of each element can be determined, it is easy to compute the number of elements allocated to the array. For heap-allocated arrays, the parameter passed to the memory allocation function (<code class="literal">0x0C</code> passed to <code class="literal">malloc</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10308"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>) represents the total number of bytes allocated to the array. Dividing this by the size of an element (4 bytes in this example, as observed from the offsets at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10314"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10320"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10327"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>) tells us the number of elements in the array. In the previous example, a three-element array was allocated.</p><p>The only firm conclusion we can draw regarding the use of arrays is that they are easiest to recognize when a variable is used as an index into the array. The array-access operation requires the index to be scaled by the size of an array element before adding the resulting offset to the base address of the array. Unfortunately, as we will show in the next section, when constant index values are used to access array elements, they do little to suggest the presence of an array and look remarkably similar to code used to access structure members.</p></div></div><div class="sect2" title="Structure Member Access"><div class="titlepage"><div><div><h2 class="title"><a id="structure_member_access"/>Structure Member Access</h2></div></div></div><p>C-style structs, referred to here generically as <span class="emphasis"><em>structures</em></span>, are heterogeneous collections of data that allow grouping of items of dissimilar datatypes into a single composite datatype. A major distinguishing feature of structures is that the data fields within a structure are accessed by name rather than by index, as is done with arrays. Unfortunately, field names are converted to numeric offsets by the compiler, so by the time you are looking at a disassembly, structure field access looks remarkably similar to accessing array elements using constant indexes.<a class="indexterm" id="IDX-CHP-8-0034"/></p><p>When a compiler encounters a structure definition, the compiler maintains a running total of the number of bytes consumed by the fields of the structure in order to determine the offset at which each field resides within the structure. The following structure definition will be used with the upcoming examples:<a class="indexterm" id="IDX-CHP-8-0035"/><a class="indexterm" id="IDX-CHP-8-0036"/><a class="indexterm" id="IDX-CHP-8-0037"/></p><a id="I_programlisting5_d1e10357"/><pre class="programlisting">struct ch8_struct {   //Size     Minimum offset     Default offset
   int field1;        //  4             0                  0
   short field2;      //  2             4                  4
   char field3;       //  1             6                  6
   int field4;        //  4             7                  8
   double field5;     //  8             11                 16
};                //Minimum total size: 19   Default size: 24</pre><p>The minimum required space to allocate a structure is determined by the sum of the space required to allocate each field within the structure. However, you should never assume that a compiler utilizes the minimum required space to allocate a structure. By default, compilers seek to align structure fields to memory addresses that allow for the most efficient reading and writing of those fields. For example, 4-byte integer fields will be aligned to offsets that are divisible by 4, while 8-byte doubles will be aligned to offsets that are divisible by 8. Depending on the composition of the structure, meeting alignment requirements may require the insertion of padding bytes, causing the actual size of a structure to be larger than the sum of its component fields. The default offsets and resulting structure size for the example structure shown previously can be seen in the <code class="literal">Default offset</code> column.<a class="indexterm" id="IDX-CHP-8-0038"/><a class="indexterm" id="IDX-CHP-8-0039"/></p><p>Structures can be packed into the minimum required space by using compiler options to request specific member alignments. Microsoft Visual C/C++ and GNU gcc/g++ both recognize the <code class="literal">pack</code> pragma as a means of controlling structure field alignment. The GNU compilers additionally recognize the <code class="literal">packed</code> attribute as a means of controlling structure alignment on a per-structure basis. Requesting 1-byte alignment for structure fields causes compilers to squeeze the structure into the minimum required space. For our example structure, this yields the offsets and structure size found in the <code class="literal">Minimum offset</code> column. Note that some CPUs perform better when data is aligned according to its type, while other CPUs may generate exceptions if data is <span class="emphasis"><em>not</em></span> aligned on specific boundaries.<a class="indexterm" id="IDX-CHP-8-0040"/><a class="indexterm" id="IDX-CHP-8-0041"/></p><p>With these facts in mind, we can begin our look at how structures are treated in compiled code. For the sake of comparison, it is worth observing that, as with arrays, access to structure members is performed by adding the base address of the structure to the offset of the desired member. However, while array offsets can be computed at runtime from a provided index value (because each item in an array has the same size), structure offsets must be precomputed and will turn up in compiled code as fixed offsets into the structure, looking nearly identical to array references that make use of constant indexes.</p><div class="sect3" title="Globally Allocated Structures"><div class="titlepage"><div><div><h3 class="title"><a id="globally_allocated_structures"/>Globally Allocated Structures</h3></div></div></div><p>As with globally allocated arrays, the address of globally allocated structures is known at compile time. This allows the compiler to compute the address of each member of the structure at compile time and eliminates the need to do any math at runtime. Consider the following program that accesses a globally allocated structure:<a class="indexterm" id="IDX-CHP-8-0042"/><a class="indexterm" id="IDX-CHP-8-0043"/></p><a id="I_programlisting5_d1e10407"/><pre class="programlisting">struct ch8_struct global_struct;

int main() {
   global_struct.field1 = 10;
   global_struct.field2 = 20;
   global_struct.field3 = 30;
   global_struct.field4 = 40;
   global_struct.field5 = 50.0;
}</pre><p>If this program is compiled with default structure alignment options, we can expect to see something like the following when we disassemble it:</p><a id="I_programlisting5_d1e10411"/><pre class="programlisting">.text:00401000 _main           proc near
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 mov     dword_40EA60, 10
.text:0040100D                 mov     word_40EA64, 20
.text:00401016                 mov     byte_40EA66, 30
.text:0040101D                 mov     dword_40EA68, 40
.text:00401027                 fld     ds:dbl_40B128
.text:0040102D                 fstp    dbl_40EA70
.text:00401033                 xor     eax, eax
.text:00401035                 pop     ebp
.text:00401036                 retn
.text:00401036 _main           endp</pre><p>This disassembly contains no math whatsoever to access the members of the structure, and, in the absence of source code, it would not be possible to state with any certainty that a structure is being used at all. Because the compiler has performed all of the offset computations at compile time, this program appears to reference five global variables rather than five fields within a single structure. You should be able to note the similarities with the previous example regarding globally allocated arrays using constant index values.<a class="indexterm" id="IDX-CHP-8-0044"/></p></div><div class="sect3" title="Stack-Allocated Structures"><div class="titlepage"><div><div><h3 class="title"><a id="stack-allocated_structures"/>Stack-Allocated Structures</h3></div></div></div><p>Like stack-allocated arrays (see <a class="xref" href="ch08.html#stack-allocated_arrays" title="Stack-Allocated Arrays">Stack-Allocated Arrays</a>), stack-allocated structures are equally difficult to recognize based on stack layout alone. Modifying the preceding program to use a stack-allocated structure, declared in <code class="literal">main</code>, yields the following disassembly:<a class="indexterm" id="IDX-CHP-8-0045"/><a class="indexterm" id="IDX-CHP-8-0046"/><a class="indexterm" id="IDX-CHP-8-0047"/><a class="indexterm" id="IDX-CHP-8-0048"/></p><a id="I_programlisting5_d1e10444"/><pre class="programlisting">.text:00401000 _main           proc near
.text:00401000
.text:00401000 var_18          = dword ptr −18h
.text:00401000 var_14          = word ptr −14h
.text:00401000 var_12          = byte ptr −12h
.text:00401000 var_10          = dword ptr −10h
.text:00401000 var_8           = qword ptr −8
.text:00401000
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 sub     esp, 18h
.text:00401006                 mov     [ebp+var_18], 10
.text:0040100D                 mov     [ebp+var_14], 20
.text:00401013                 mov     [ebp+var_12], 30
.text:00401017                 mov     [ebp+var_10], 40
.text:0040101E                 fld     ds:dbl_40B128
.text:00401024                 fstp    [ebp+var_8]
.text:00401027                 xor     eax, eax
.text:00401029                 mov     esp, ebp
.text:0040102B                 pop     ebp
.text:0040102C                 retn
.text:0040102C _main           endp</pre><p>Again, no math is performed to access the structure’s fields since the compiler can determine the relative offsets for each field within the stack frame at compile time. In this case, we are left with the same, potentially misleading picture that five individual variables are being used rather than a single variable that happens to contain five distinct fields. In reality, <code class="literal">var_18</code> should be the start of a 24-byte structure, and each of the other variables should somehow be formatted to reflect the fact that they are fields within the structure.</p></div><div class="sect3" title="Heap-Allocated Structures"><div class="titlepage"><div><div><h3 class="title"><a id="heap-allocated_structures"/>Heap-Allocated Structures</h3></div></div></div><p>Heap-allocated structures turn out to be much more revealing regarding the size of the structure and the layout of its fields. When a structure is allocated in the program heap, the compiler has no choice but to generate code to compute the proper offset into the structure whenever a field is accessed. This is a result of the structure’s address being unknown at compile time. For globally allocated structures, the compiler is able to compute a fixed starting address. For stack-allocated structures, the compiler can compute a fixed relationship between the start of the structure and the frame pointer for the enclosing stack frame. When a structure has been allocated in the heap, the only reference to the structure available to the compiler is the pointer to the structure’s starting address.</p><p>Modifying our structure example once again to make use of a heap-allocated structure results in the following disassembly. Similar to the heap-allocated array example from page 134, we declare a pointer within <code class="literal">main</code> and assign it the address of a block of memory large enough to hold our structure:</p><a id="I_programlisting5_d1e10461"/><pre class="programlisting">.text:00401000 _main           proc near
.text:00401000
.text:00401000 heap_struct     = dword ptr −4
.text:00401000
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 push    ecx
.text:00401004                <img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>push    24              ; size_t
.text:00401006                 call    _malloc
.text:0040100B                 add     esp, 4
.text:0040100E                 mov     [ebp+heap_struct], eax
.text:00401011                 mov     eax, [ebp+heap_struct]
.text:00401014                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>mov     dword ptr [eax], 10
.text:0040101A                 mov     ecx, [ebp+heap_struct]
.text:0040101D                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     word ptr [ecx+4], 20
.text:00401023                 mov     edx, [ebp+heap_struct]
.text:00401026                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     byte ptr [edx+6], 30
.text:0040102A                 mov     eax, [ebp+heap_struct]
.text:0040102D                <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>mov     dword ptr [eax+8], 40
.text:00401034                 mov     ecx, [ebp+heap_struct]
.text:00401037                 fld     ds:dbl_40B128
.text:0040103D                <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>fstp    qword ptr [ecx+10h]
.text:00401040                 xor     eax, eax
.text:00401042                 mov     esp, ebp
.text:00401044                 pop     ebp
.text:00401045                 retn
.text:00401045 _main           endp</pre><p>In this example, unlike the global and stack-allocated structure examples, we are able to discern the exact size and layout of the structure. The structure size can be inferred to be 24 bytes based on the amount of memory requested from <code class="literal">malloc</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10505"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>. The structure contains the following fields at the indicated offsets:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A 4-byte (<code class="literal">dword</code>) field at offset 0 <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10518"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span></p></li><li class="listitem"><p>A 2-byte (<code class="literal">word</code>) field at offset 4 <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10529"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span></p></li><li class="listitem"><p>A 1-byte field at offset 6 <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10537"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span></p></li><li class="listitem"><p>A 4-byte (<code class="literal">dword</code>) field at offset 8 <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10548"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span></p></li><li class="listitem"><p>An 8-byte (<code class="literal">qword</code>) field at offset 16 (10h) <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10559"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span></p></li></ul></div><p>Based on the use of floating point instructions, we can further deduce that the <code class="literal">qword</code> field is actually a <code class="literal">double</code>. The same program compiled to pack structures with a 1-byte alignment yields the following disassembly:<a class="indexterm" id="IDX-CHP-8-0049"/><a class="indexterm" id="IDX-CHP-8-0050"/></p><a id="I_programlisting5_d1e10580"/><pre class="programlisting">.text:00401000 _main           proc near
.text:00401000
.text:00401000 heap_struct     = dword ptr −4
.text:00401000
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 push    ecx
.text:00401004                 push    19              ; size_t
.text:00401006                 call    _malloc
.text:0040100B                 add     esp, 4
.text:0040100E                 mov     [ebp+heap_struct], eax
.text:00401011                 mov     eax, [ebp+heap_struct]
.text:00401014                 mov     dword ptr [eax], 10
.text:0040101A                 mov     ecx, [ebp+heap_struct]
.text:0040101D                 mov     word ptr [ecx+4], 20
.text:00401023                 mov     edx, [ebp+heap_struct]
.text:00401026                 mov     byte ptr [edx+6], 30
.text:0040102A                 mov     eax, [ebp+heap_struct]
.text:0040102D                 mov     dword ptr [eax+7], 40
.text:00401034                 mov     ecx, [ebp+heap_struct]
.text:00401037                 fld     ds:dbl_40B128
.text:0040103D                 fstp    qword ptr [ecx+0Bh]
.text:00401040                 xor     eax, eax
.text:00401042                 mov     esp, ebp
.text:00401044                 pop     ebp
.text:00401045                 retn
.text:00401045 _main           endp</pre><p>The only changes to the program are the smaller size of the structure (now 19 bytes) and the adjusted offsets to account for the realignment of each structure field.</p><p>Regardless of the alignment used when compiling a program, finding structures allocated and manipulated in the program heap is the fastest way to determine the size and layout of a given data structure. However, keep in mind that many functions will not do you the favor of immediately accessing every member of a structure to help you understand the structure’s layout. Instead, you may need to follow the use of the pointer to the structure and make note of the offsets used whenever that pointer is dereferenced. In this manner, you will eventually be able to piece together the complete layout of the structure.</p></div><div class="sect3" title="Arrays of Structures"><div class="titlepage"><div><div><h3 class="title"><a id="arrays_of_structures"/>Arrays of Structures</h3></div></div></div><p>Some programmers would say that the beauty of composite data structures is that they allow you to build arbitrarily complex structures by nesting smaller structures within larger structures. Among other possibilities, this capability allows for arrays of structures, structures within structures, and structures that contain arrays as members. The preceding discussions regarding arrays and structures apply just as well when dealing with nested types such as these. As an example, consider an array of structures like the following simple program in which <code class="literal">heap_struct</code> points to an array of five <code class="literal">ch8_struct</code> items:</p><a id="I_programlisting5_d1e10597"/><pre class="programlisting">int main() {
     int idx = 1;
     struct ch8_struct *heap_struct;
     heap_struct = (struct ch8_struct*)malloc(sizeof(struct ch8_struct) * 5);
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    heap_struct[idx].field1 = 10;
  }</pre><p>The operations required to access <code class="literal">field1</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10610"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> include multiplying the index value by the size of an array element, in this case the size of the structure, and then adding the offset to the desired field. The corresponding disassembly is shown here:</p><a id="I_programlisting5_d1e10616"/><pre class="programlisting">.text:00401000 _main           proc near
.text:00401000
.text:00401000 idx             = dword ptr −8
.text:00401000 heap_struct     = dword ptr −4
.text:00401000
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 sub     esp, 8
.text:00401006                 mov     [ebp+idx], 1
.text:0040100D                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>push    120              ; size_t
.text:0040100F                 call    _malloc
.text:00401014                 add     esp, 4
.text:00401017                 mov     [ebp+heap_struct], eax
.text:0040101A                 mov     eax, [ebp+idx]
.text:0040101D                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>imul    eax, 24
.text:00401020                 mov     ecx, [ebp+heap_struct]
.text:00401023                <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>mov     dword ptr [ecx+eax], 10
.text:0040102A                 xor     eax, eax
.text:0040102C                 mov     esp, ebp
.text:0040102E                 pop     ebp
.text:0040102F                 retn
.text:0040102F _main           endp</pre><p>The disassembly reveals 120 bytes (<span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10638"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>) being requested from the heap. The array index is multiplied by 24 at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10644"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> before being added to the start address for the array at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10650"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>. No additional offset is required in order to generate the final address for the reference at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e10656"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>. From these facts we can deduce the size of an array item (24), the number of items in the array (<code class="literal">120 / 24 = 5</code>), and the fact that there is a 4-byte (<code class="literal">dword</code>) field at offset 0 within each array element. This short listing does not offer enough information to draw any conclusions about how the remaining 20 bytes within each structure are allocated to additional fields.</p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-1" id="ftn.CHP-8-FN-1">44</a>] </sup>Holding the mouse over any name in the IDA display causes a tool tip–style pop-up window to be displayed that shows up to 10 lines of disassembly at the target location. In the case of library function names, this often includes the prototype for calling the library function.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-2" id="ftn.CHP-8-FN-2">45</a>] </sup>Please see <a class="ulink" href="http://msdn.microsoft.com/library/">http://msdn.microsoft.com/library/</a>.</p></div></div></div>
<div class="sect1" title="Creating IDA Structures"><div class="titlepage"><div><div><h1 class="title"><a id="creating_ida_structures"/>Creating IDA Structures</h1></div></div></div><p>In the last chapter we saw how IDA’s array-aggregation capabilities allow disassembly listings to be simplified by collapsing long lists of data declarations into a single disassembly line. In the next few sections we take a look at IDA’s facilities for improving the readability of code that manipulates structures. Our goal is to move away from structure references such as <code class="literal">[edx + 10h]</code> and toward something more readable like <code class="literal">[edx + ch8_struct.field5]</code>.<a class="indexterm" id="IDX-CHP-8-0051"/><a class="indexterm" id="IDX-CHP-8-0052"/><a class="indexterm" id="IDX-CHP-8-0053"/><a class="indexterm" id="IDX-CHP-8-0054"/></p><p>Whenever you discover that a program is manipulating a data structure, you need to decide whether you want to incorporate structure field names into your disassembly or whether you can make sense of all the numeric offsets sprinkled throughout the listing. In some cases, IDA may recognize the use of a structure defined as part of the C standard library or the Windows API. In such cases, IDA may have knowledge of the exact layout of the structure and be able to convert numeric offsets into more symbolic field names. This is the ideal case, as it leaves you with a lot less work to do. We will return to this scenario once we understand a little more about how IDA deals with structure definitions in general.</p><div class="sect2" title="Creating a New Structure (or Union)"><div class="titlepage"><div><div><h2 class="title"><a id="creating_a_new_structure_open_parenthesi"/>Creating a New Structure (or Union)</h2></div></div></div><p>When a program appears to be using a structure for which IDA has no layout knowledge, IDA offers facilities for specifying the composition of the structure and having the newly defined structure incorporated into the disassembly. Structure creation in IDA takes place within the Structures window (see <a class="xref" href="ch08s02.html#the_structures_window-id2" title="Figure 8-2. The Structures window">Figure 8-2</a>). No structure can be incorporated into a disassembly until it is first listed in the Structures window. Any structure that is known to IDA and that is recognized to be used by a program will automatically be listed in the Structures window.<a class="indexterm" id="IDX-CHP-8-0055"/></p><div class="figure"><a id="the_structures_window-id2"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10715"/><img alt="The Structures window" src="httpatomoreillycomsourcenostarchimages854169.png"/></div></div><p class="title">Figure 8-2. The Structures window</p></div><p>There are two reasons why the use of a structure may go unrecognized during the analysis phase. First, even though IDA may have knowledge of a particular structure’s layout, there may be insufficient information for IDA to conclude that the program utilizes the structure. Second, the structure may be a nonstandard structure that IDA knows nothing about. In both cases the problem can be overcome, and in both cases the solution begins with the Structures window.</p><p>The first four lines of text in the Structures window serve as a constant reminder of the operations that are possible within the window. The principal operations we are concerned with involve adding, removing, and editing structures. Adding a structure is initiated using the <span class="keycap">insert</span> key, which opens the Create Structure/Union dialog shown in <a class="xref" href="ch08s02.html#the_create_structure_solidus_union_dialo" title="Figure 8-3. The Create Structure/Union dialog">Figure 8-3</a>.<a class="indexterm" id="IDX-CHP-8-0056"/><a class="indexterm" id="IDX-CHP-8-0057"/><a class="indexterm" id="IDX-CHP-8-0058"/><a class="indexterm" id="IDX-CHP-8-0059"/><a class="indexterm" id="IDX-CHP-8-0060"/></p><div class="figure"><a id="the_create_structure_solidus_union_dialo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10747"/><img alt="The Create Structure/Union dialog" src="httpatomoreillycomsourcenostarchimages854171.png.jpg"/></div></div><p class="title">Figure 8-3. The Create Structure/Union dialog</p></div><p>In order to create a new structure, you must first specify the name in the Structure name field. The first two checkboxes determine where or whether the new structure will be displayed within the Structures window. The third checkbox, Create union, specifies whether you are defining a structure or a C-style union.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-3" id="CHP-8-FN-3">46</a>]</sup> For structures, the size is computed as the sum of the sizes of each component field, while for unions, the size is computed as the size of the largest component field. The Add standard structure button is used to access the list of all structure datatypes that IDA is currently aware of. The behavior of this button is discussed in <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a> in <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a>. Once you specify a structure name and click OK, an empty structure definition will be created in the Structures window, as shown in <a class="xref" href="ch08s02.html#an_empty_structure_definition" title="Figure 8-4. An empty structure definition">Figure 8-4</a>.<a class="indexterm" id="IDX-CHP-8-0061"/><a class="indexterm" id="IDX-CHP-8-0062"/><a class="indexterm" id="IDX-CHP-8-0063"/></p><div class="figure"><a id="an_empty_structure_definition"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10782"/><img alt="An empty structure definition" src="httpatomoreillycomsourcenostarchimages854173.png"/></div></div><p class="title">Figure 8-4. An empty structure definition</p></div><p>This structure definition must be edited to complete the definition of the structure layout.</p></div><div class="sect2" title="Editing Structure Members"><div class="titlepage"><div><div><h2 class="title"><a id="editing_structure_members"/>Editing Structure Members</h2></div></div></div><p>In order to add fields to your new structure, you must make use of the field-creation commands D, A, and the asterisk key (*) on the numeric keypad. Initially, only the D command is useful, and unfortunately, its behavior is highly dependent on the location of the cursor. For that reason, the following steps are recommended for adding fields to a structure.<a class="indexterm" id="IDX-CHP-8-0064"/><a class="indexterm" id="IDX-CHP-8-0065"/><a class="indexterm" id="IDX-CHP-8-0066"/><a class="indexterm" id="IDX-CHP-8-0067"/><a class="indexterm" id="IDX-CHP-8-0068"/><a class="indexterm" id="IDX-CHP-8-0069"/><a class="indexterm" id="IDX-CHP-8-0070"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>To add a new field to a structure, position the cursor on the last line of the structure definition (the one containing <code class="literal">ends</code>) and press <span class="strong"><strong>D</strong></span>. This causes a new field to be added to the end of the structure. The size of the new field will be set according to the first size selected on the data carousel (<a class="xref" href="ch07.html" title="Chapter 7. Disassembly Manipulation">Chapter 7</a>). The name of the field will initially be <code class="literal">field_</code><em class="replaceable"><code>N</code></em>, where <em class="replaceable"><code>N</code></em> is the numeric offset from the start of the structure to the start of the new field (<code class="literal">field_0</code>, for example).</p></li><li class="listitem"><p>Should you need to modify the size of the field, you may do so by first ensuring that the cursor is positioned on the new field name and then selecting the correct data size for the field by repeatedly pressing D in order to cycle through the datatypes on the data carousel. Alternatively, you may use Options ▸ Setup Data Types to specify a size that is not available on the data carousel. If the field is an array, right-click the name and select <span class="strong"><strong>Array</strong></span> to open the array specification dialog (<a class="xref" href="ch07.html" title="Chapter 7. Disassembly Manipulation">Chapter 7</a>).</p></li><li class="listitem"><p>To change the name of a structure field, click the field name and use the N hotkey, or right-click the name and select <span class="strong"><strong>Rename</strong></span>; then provide a new name for the field.</p></li></ol></div><p>The following helpful hints may be of use as you define your own structures.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The byte offset to a field is displayed as an eight-digit hex value on the left side of the Structures window.</p></li><li class="listitem"><p>Every time you add or delete a structure field or change the size of an existing field, the new <code class="literal">sizeof</code> the structure will be reflected on the first line of the structure definition.</p></li><li class="listitem"><p>You can add comments to a structure field just as you can add comments to any disassembly line. Right-click (or use a hotkey) on the field you wish to add a comment to and select one of the available comment options.</p></li><li class="listitem"><p>Contrary to the instructions at the top of the Structures window, the U key will delete a structure field only if it is the last field in the structure. For all other fields, pressing U merely undefines the field, which removes the name but <span class="emphasis"><em>does not</em></span> remove the bytes allocated to the field.</p></li><li class="listitem"><p>You are responsible for proper alignment of all fields within a structure definition. IDA makes no distinction between packed or unpacked structures. If you require padding bytes to properly align fields, then you are responsible for adding them. Padding bytes are best added as dummy fields of the proper size, which you may or may not choose to undefine once you have added additional fields.<a class="indexterm" id="IDX-CHP-8-0071"/><a class="indexterm" id="IDX-CHP-8-0072"/></p></li><li class="listitem"><p>Bytes allocated in the middle of a structure can be removed only by first undefining the associated field and then selecting Edit ▸ Shrink Struct Type to remove the undefined bytes.</p></li><li class="listitem"><p>Bytes may be inserted into the middle of a structure by selecting the field that will follow the new bytes and then using Edit ▸ Expand Struct Type to insert a specified number of bytes before the selected field.</p></li><li class="listitem"><p>If you know the size of a structure but not the layout, you need to create two fields. The first field should be an array of <code class="literal">size-1</code> bytes. The second field should be a 1-byte field. After you have created the second field, undefine the first (array) field. The size of the structure will be preserved, and you can easily come back later to define fields and their sizes as you learn more about the layout of the structure.</p></li></ul></div><p>Through repeated application of these steps (add field, set field size, add padding, and so on), you can create an IDA representation of the <code class="literal">ch8_struct</code> (unpacked version), as shown in <a class="xref" href="ch08s02.html#manually_generated_definition_of_the_ch8" title="Figure 8-5. Manually generated definition of the ch8_struct">Figure 8-5</a>.</p><div class="figure"><a id="manually_generated_definition_of_the_ch8"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10913"/><img alt="Manually generated definition of the ch8_struct" src="httpatomoreillycomsourcenostarchimages854175.png"/></div></div><p class="title">Figure 8-5. Manually generated definition of the <code class="literal">ch8_struct</code></p></div><p>In this example, padding bytes have been included to achieve proper field alignment, and fields have been renamed according to the names used in the preceding examples. Note that the offsets to each field and the overall size (24 bytes) of the structure match the values seen in the earlier examples.</p><p>If you ever feel that a structure definition is taking up too much space in your Structures window, you can collapse the definition into a one-line summary by choosing any field within the structure and pressing the minus key (–) on the numeric keypad. This is useful once a structure has been completely defined and requires little further editing. The collapsed version of <code class="literal">ch8_struct</code> is shown in <a class="xref" href="ch08s02.html#a_collapsed_structure_definition" title="Figure 8-6. A collapsed structure definition">Figure 8-6</a>.</p><p>The majority of structures that IDA is already aware of will be displayed in this one-line fashion since it is not expected that they will need to be edited. The collapsed display provides a reminder that you can use the plus key (+) on the numeric keypad to expand the definition. Alternatively, double-clicking the name of the structure will also expand the definition.<a class="indexterm" id="IDX-CHP-8-0073"/><a class="indexterm" id="IDX-CHP-8-0074"/><a class="indexterm" id="IDX-CHP-8-0075"/><a class="indexterm" id="IDX-CHP-8-0076"/><a class="indexterm" id="IDX-CHP-8-0077"/><a class="indexterm" id="IDX-CHP-8-0078"/><a class="indexterm" id="IDX-CHP-8-0079"/></p><div class="figure"><a id="a_collapsed_structure_definition"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e10965"/><img alt="A collapsed structure definition" src="httpatomoreillycomsourcenostarchimages854177.png.jpg"/></div></div><p class="title">Figure 8-6. A collapsed structure definition</p></div></div><div class="sect2" title="Stack Frames as Specialized Structures"><div class="titlepage"><div><div><h2 class="title"><a id="stack_frames_as_specialized_structures"/>Stack Frames as Specialized Structures</h2></div></div></div><p>You may notice that structure definitions look somewhat similar to the detailed stack frame views associated with functions. This is no accident, as internally IDA treats both identically. Both represent contiguous blocks of bytes that can be subdivided into named component fields, each associated with a numeric offset into the structure. The minor difference is that stack frames utilize both positive and negative field offsets centered on a frame pointer or return address, while structures use positive offsets from the beginning of the structure.<a class="indexterm" id="IDX-CHP-8-0080"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-3" id="ftn.CHP-8-FN-3">46</a>] </sup>A <span class="emphasis"><em>union</em></span> is similar to a struct in that it may consist of many named fields, each of differing type. The difference between the two lies in the fact that fields within a union directly overlap one another so that the size of a union is equal to the size of the largest field.</p></div></div></div>
<div class="sect1" title="Using Structure Templates"><div class="titlepage"><div><div><h1 class="title"><a id="using_structure_templates"/>Using Structure Templates</h1></div></div></div><p>There are two ways to make use of structure definitions in your disassemblies. First, you can reformat memory references to make them more readable by converting numeric structure offsets such as <code class="literal">[ebx+8]</code> into symbolic references such as <code class="literal">[ebx+ch8_struct.field4]</code>. The latter form provides far more information about what is being referenced. Because IDA uses a hierarchical notation, it is clear exactly what type of structure, and exactly which field within that structure, is being accessed. This technique for applying structure templates is most often used when a structure is being referenced through a pointer. The second way to use structure templates is to provide additional datatypes that can be applied to stack and global variables.</p><p>In order to understand how structure definitions can be applied to instruction operands, it is helpful to view each definition as something similar to set of enumerated constants. For example, the definition of <code class="literal">ch8_struct</code> in <a class="xref" href="ch08s02.html#manually_generated_definition_of_the_ch8" title="Figure 8-5. Manually generated definition of the ch8_struct">Figure 8-5</a> might be expressed in pseudo-C as the following:</p><a id="I_programlisting5_d1e10996"/><pre class="programlisting">enum {
   ch8_struct.field1 = 0,
   ch8_struct.field2 = 4,
   ch8_struct.field3 = 6,
   ch8_struct.field4 = 8,
   ch8_struct.field5 = 16
};</pre><p>Given such a definition, IDA allows you to reformat any constant value used in an operand into an equivalent symbolic representation. <a class="xref" href="ch08s03.html#applying_a_structure_offset" title="Figure 8-7. Applying a structure offset">Figure 8-7</a> shows just such an operation in progress. The memory reference <code class="literal">[ecx+10h]</code> may represent an access to <code class="literal">field5</code> within a <code class="literal">ch8_struct</code>.<a class="indexterm" id="IDX-CHP-8-0081"/><a class="indexterm" id="IDX-CHP-8-0082"/><a class="indexterm" id="IDX-CHP-8-0083"/><a class="indexterm" id="IDX-CHP-8-0084"/></p><div class="figure"><a id="applying_a_structure_offset"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11027"/><img alt="Applying a structure offset" src="httpatomoreillycomsourcenostarchimages854179.png.jpg"/></div></div><p class="title">Figure 8-7. Applying a structure offset</p></div><p>The Structure offset option, available by right-clicking 10h in this case, offers three alternatives for formatting the instruction operand. The alternatives are pulled from the set of structures containing a field whose offset is 16.</p><p>As an alternative to formatting individual memory references, stack and global variables can be formatted as entire structures. To format a stack variable as a structure, open the detailed stack frame view by double-clicking the variable to be formatted as a structure and then use <span class="strong"><strong>Edit</strong></span> ▸ <span class="strong"><strong>Struct Var</strong></span> (<span class="keycap">alt</span>-Q) to display a list of known structures similar to that shown in <a class="xref" href="ch08s03.html#the_structure_selection_dialog" title="Figure 8-8. The structure selection dialog">Figure 8-8</a>.</p><div class="figure"><a id="the_structure_selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11050"/><img alt="The structure selection dialog" src="httpatomoreillycomsourcenostarchimages854181.png"/></div></div><p class="title">Figure 8-8. The structure selection dialog</p></div><p>Selecting one of the available structures combines the corresponding number of bytes in the stack into the corresponding structure type and reformats all related memory references as structure references. The following code is an excerpt from the stack-allocated structure example we examined previously:<a class="indexterm" id="IDX-CHP-8-0085"/><a class="indexterm" id="IDX-CHP-8-0086"/></p><a id="I_programlisting5_d1e11065"/><pre class="programlisting">.text:00401006                 mov     [ebp+var_18], 10
.text:0040100D                 mov     [ebp+var_14], 20
.text:00401013                 mov     [ebp+var_12], 30
.text:00401017                 mov     [ebp+var_10], 40
.text:0040101E                 fld     ds:dbl_40B128
.text:00401024                 fstp    [ebp+var_8]</pre><p>Recall that we concluded that <code class="literal">var_18</code> is actually the first field in a 24-byte structure. The detailed stack frame for this particular interpretation is shown in <a class="xref" href="ch08s03.html#stack_allocated_structure_prior_to_forma" title="Figure 8-9. Stack allocated structure prior to formatting">Figure 8-9</a>.</p><div class="figure"><a id="stack_allocated_structure_prior_to_forma"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11078"/><img alt="Stack allocated structure prior to formatting" src="httpatomoreillycomsourcenostarchimages854183.png"/></div></div><p class="title">Figure 8-9. Stack allocated structure prior to formatting</p></div><p>Selecting <code class="literal">var_18</code> and formatting it as a <code class="literal">ch8_struct</code> (Edit ▸ Struct Var) collapses the 24 bytes (the size of <code class="literal">ch8_struct</code>) beginning at <code class="literal">var_18</code> into a single variable, resulting in the reformatted stack display shown in <a class="xref" href="ch08s03.html#stack_allocated_structure_after_formatti" title="Figure 8-10. Stack allocated structure after formatting">Figure 8-10</a>. In this case, applying the structure template to <code class="literal">var_18</code> will generate a warning message indicating that some variables will be destroyed in the process of converting <code class="literal">var_18</code> into a structure. Based on our earlier analysis, this is to be expected, so we simply acknowledge the warning to complete the operation.</p><div class="figure"><a id="stack_allocated_structure_after_formatti"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11109"/><img alt="Stack allocated structure after formatting" src="httpatomoreillycomsourcenostarchimages854185.png"/></div></div><p class="title">Figure 8-10. Stack allocated structure after formatting</p></div><p>Following reformatting, IDA understands that any memory reference into the 24-byte block allocated to <code class="literal">var_18</code> must refer to a field within the structure. When IDA encounters such a reference, it makes every effort to resolve the memory reference to one of the defined fields within the structure variable. In this case, the disassembly is automatically reformatted to incorporate the structure layout, as shown here:<a class="indexterm" id="IDX-CHP-8-0087"/><a class="indexterm" id="IDX-CHP-8-0088"/><a class="indexterm" id="IDX-CHP-8-0089"/></p><a id="I_programlisting5_d1e11132"/><pre class="programlisting">.text:00401006                 mov     [ebp+var_18.field1], 10
.text:0040100D                 mov     [ebp+var_18.field2], 20
.text:00401013                 mov     [ebp+var_18.field3], 30
.text:00401017                 mov     [ebp+var_18.field4], 40
.text:0040101E                 fld     ds:dbl_40B128
.text:00401024                 fstp    [ebp+var_18.field5]</pre><p>The advantage to using structure notation within the disassembly is an overall improvement in the readability of the disassembly. The use of field names in the reformatted display provides a much more accurate reflection of how data was actually manipulated in the original source code.<a class="indexterm" id="IDX-CHP-8-0090"/></p><p>The procedure for formatting global variables as structures is nearly identical to that used for stack variables. To do so, select the variable or address that marks the beginning of the structure and use <span class="strong"><strong>Edit</strong></span> ▸ <span class="strong"><strong>Struct Var</strong></span> (<span class="keycap">alt</span>-Q) to choose the appropriate structure type. As an alternative for undefined global data only (not stack data), you may use IDA’s context-sensitive menu, and select the structure option to view and select an available structure template to apply at the selected address.<a class="indexterm" id="IDX-CHP-8-0091"/></p></div>
<div class="sect1" title="Importing New Structures"><div class="titlepage"><div><div><h1 class="title"><a id="importing_new_structures"/>Importing New Structures</h1></div></div></div><p>After working with IDA’s structure-creation and editing features for a while, you may find yourself longing for an easier way to do things. Fortunately, IDA does offer some shortcuts concerning new structures. IDA is capable of parsing individual C (not C++) data declarations, as well as entire C header files, and automatically building IDA structure representations for any structures defined in those declarations or header files. If you happen to have the source code, or at least the header files, for the binary that you are reversing, then you can save a lot of time by having IDA extract related structures directly from the source code.</p><div class="sect2" title="Parsing C Structure Declarations"><div class="titlepage"><div><div><h2 class="title"><a id="parsing_c_structure_declarations"/>Parsing C Structure Declarations</h2></div></div></div><p>A Local Types subview window is available by using the View ▸ OpenSubviews ▸ Local Types command. The Local Types window displays a list of all types that have been parsed into the current database. For new databases, the Local Types window is initially empty, but the window offers the capability to parse new types via the <code class="literal">insert</code> key or the Insert option from the context menu. The resulting type entry dialog is shown in <a class="xref" href="ch08s04.html#the_local_types_entry_dialog" title="Figure 8-11. The Local Types entry dialog">Figure 8-11</a>.<a class="indexterm" id="IDX-CHP-8-0092"/><a class="indexterm" id="IDX-CHP-8-0093"/><a class="indexterm" id="IDX-CHP-8-0094"/></p><div class="figure"><a id="the_local_types_entry_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11182"/><img alt="The Local Types entry dialog" src="httpatomoreillycomsourcenostarchimages854187.png.jpg"/></div></div><p class="title">Figure 8-11. The Local Types entry dialog</p></div><p>Errors encountered while parsing the new type are displayed in the IDA output window. If the type declaration is successfully parsed, the type and its associated declaration are listed in the Local Types window, as shown in <a class="xref" href="ch08s04.html#the_local_types_window" title="Figure 8-12. The Local Types window">Figure 8-12</a>.<a class="indexterm" id="IDX-CHP-8-0095"/><a class="indexterm" id="IDX-CHP-8-0096"/><a class="indexterm" id="IDX-CHP-8-0097"/><a class="indexterm" id="IDX-CHP-8-0098"/></p><div class="figure"><a id="the_local_types_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11206"/><img alt="The Local Types window" src="httpatomoreillycomsourcenostarchimages854189.png.jpg"/></div></div><p class="title">Figure 8-12. The Local Types window</p></div><p>Note that the IDA parser utilizes a default structure member alignment of 4 bytes. If your structure requires an alternate alignment, you may include it, and IDA will recognize a <code class="literal">pragma pack</code> directive to specify the desired member alignment.<a class="indexterm" id="IDX-CHP-8-0099"/></p><p>Datatypes added to the Local Types windows are not immediately available via the Structures window. There are two methods for adding local type declarations to the Structures window. The easiest method is to right-click on the desired local type and select <span class="strong"><strong>Synchronize to idb</strong></span>. Alternatively, as each new type is added to a list of standard structures; the new type may be imported into the Structures window as described in <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a> in <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a>.</p></div><div class="sect2" title="Parsing C Header Files"><div class="titlepage"><div><div><h2 class="title"><a id="parsing_c_header_files"/>Parsing C Header Files</h2></div></div></div><p>To parse a header file, use <span class="strong"><strong>File</strong></span> ▸ <span class="strong"><strong>Load File</strong></span> ▸ <span class="strong"><strong>Parse C Header File</strong></span> to choose the header you wish to parse. If all goes well, IDA returns the message: <code class="literal">Compilation successful</code>. If the parser encounters any problems, you are notified that there were errors. Any associated error messages are displayed in the IDA output window.</p><p>IDA adds all structures that were successfully parsed to both the list of local types and the list of standard structures (to the end of the list to be exact) available in the current database. When a new structure has the same name as an existing structure, the existing structure definition is overwritten with the new structure layout. None of the new structures appear in the Structures window until you elect to explicitly add them, as described above for local types or in <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a> in <a class="xref" href="ch08s05.html" title="Using Standard Structures">Using Standard Structures</a>.<a class="indexterm" id="IDX-CHP-8-0100"/><a class="indexterm" id="IDX-CHP-8-0101"/><a class="indexterm" id="IDX-CHP-8-0102"/><a class="indexterm" id="IDX-CHP-8-0103"/><a class="indexterm" id="IDX-CHP-8-0104"/><a class="indexterm" id="IDX-CHP-8-0105"/></p><p>When parsing C header files, it is useful to keep the following points in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The built-in parser does not necessarily use the same default structure member alignment as your compiler, though it does honor the <code class="literal">pack</code> pragma. By default, the parser creates structures that are 4-byte aligned.</p></li><li class="listitem"><p>The parser understands the C preprocessor <code class="literal">include</code> directive. To resolve <code class="literal">include</code> directives, the parser searches the directory containing the file being parsed as well as any directories listed as <code class="literal">Include</code> directories in the Options ▸ Compiler configuration dialog.</p></li><li class="listitem"><p>The parser understands only C standard datatypes. However, the parser also understands the preprocessor <code class="literal">define</code> directive as well as the C <code class="literal">typedef</code> statement. Thus, types such as <code class="literal">uint32_t</code> will be correctly parsed if the parser has encountered an appropriate <code class="literal">typedef</code> prior to their use.</p></li><li class="listitem"><p>When you don’t have any source code, you may find it easier to quickly define a structure layout in C notation using a text editor and parse the resulting header file or paste the declaration as a new local type, rather than using IDA’s cumbersome manual structure-definition tools.</p></li><li class="listitem"><p>New structures are available only in the current database. You must repeat the structure-creation steps in each additional database for which you wish to use the structures. We will discuss some steps for simplifying this process when we discuss TIL files later in the chapter.</p></li></ul></div><p>In general, to maximize your chances of successfully parsing a header file, you will want to simplify your structure definitions as much as possible through the use of standard C datatypes and minimizing the use of <code class="literal">include</code> files. Remember, the most important thing about creating structures in IDA is to ensure that the layout is correct. Correct layout depends far more on the correct size of each field and the correct alignment of the structure than getting the exact type of each field just right. In other words, if you need to replace all occurrences of <code class="literal">uint32_t</code> with <code class="literal">int</code> in order to get a file to parse correctly, you should go right ahead and do it.</p></div></div>
<div class="sect1" title="Using Standard Structures"><div class="titlepage"><div><div><h1 class="title"><a id="using_standard_structures"/>Using Standard Structures</h1></div></div></div><p>As mentioned previously, IDA recognizes a tremendous number of data structures associated with various library and API functions. When a database is initially created, IDA attempts to determine the compiler and platform associated with the binary and loads the structure templates derived from related library header files. As IDA encounters actual structure manipulations in the disassembly, it adds the appropriate structure definitions to the Structures window. Thus, the Structures window represents the subset of known structures that happen to apply to the current binary. In addition to creating your own custom structures, you can add additional standard structures to the Structures window by drawing from IDA’s list of known structure types.<a class="indexterm" id="IDX-CHP-8-0106"/><a class="indexterm" id="IDX-CHP-8-0107"/><a class="indexterm" id="IDX-CHP-8-0108"/><a class="indexterm" id="IDX-CHP-8-0109"/><a class="indexterm" id="IDX-CHP-8-0110"/><a class="indexterm" id="IDX-CHP-8-0111"/><a class="indexterm" id="IDX-CHP-8-0112"/><a class="indexterm" id="IDX-CHP-8-0113"/></p><p>The process for adding a new structure begins by pressing the <span class="keycap">insert</span> key inside the Structures window. <a class="xref" href="ch08s02.html#the_create_structure_solidus_union_dialo" title="Figure 8-3. The Create Structure/Union dialog">Figure 8-3</a> showed the Create Structure/Union dialog, one component of which is the Add standard structure button. Clicking this button grants access to the master list of structures pertaining to the current compiler (as detected during the analysis phase) and file format. This master list of structures also contains any structures that have been added to the database as a result of parsing C header files. The structure selection dialog shown in <a class="xref" href="ch08s05.html#standard_structure_selection" title="Figure 8-13. Standard structure selection">Figure 8-13</a> is used to choose a structure to add to the Structures window.<a class="indexterm" id="IDX-CHP-8-0114"/><a class="indexterm" id="IDX-CHP-8-0115"/></p><div class="figure"><a id="standard_structure_selection"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11375"/><img alt="Standard structure selection" src="httpatomoreillycomsourcenostarchimages854191.png.jpg"/></div></div><p class="title">Figure 8-13. Standard structure selection</p></div><p>You may utilize the search functionality to locate structures based on a partial text match. The dialog also allows for prefix matching. If you know the first few characters of the structure name, simply type them in (they will appear in the status bar at the bottom of the dialog), and the list display will jump to the first structure with a matching prefix. Choosing a structure adds the structure and any nested structures to the Structures window.</p><p>As an example of using standard structures, consider a case in which you wish to examine the file headers associated with a Windows PE binary. By default, the file headers are not loaded into the database when it is first created; however, file headers can be loaded if you select the Manual load option during initial database creation. Loading the file headers ensures only that the data bytes associated with those headers will be present in the database. In most cases, the headers will not be formatted in any way because typical programs make no direct reference to their own file headers. Thus there is no reason for the analyzer to apply structure templates to the headers.</p><p>After conducting some research on the format of a PE binary, you will learn that a PE file begins with an MS-DOS header structure named <code class="literal">IMAGE_DOS_HEADER</code>. Further, data contained within the <code class="literal">IMAGE_DOS_HEADER</code> points to the location of an <code class="literal">IMAGE_NT_HEADERS</code> structure, which details the memory layout of the PE binary. Choosing to load the PE headers, you might see something similar to the following unformatted data disassembly. Readers familiar with the PE file structure may recognize the familiar MS-DOS magic value <code class="literal">MZ</code> as the first two bytes in the file.<a class="indexterm" id="IDX-CHP-8-0116"/></p><a id="I_programlisting5_d1e11401"/><pre class="programlisting">HEADER:00400000 __ImageBase     db  4Dh ; M
HEADER:00400001                 db  5Ah ; Z
HEADER:00400002                 db  90h ; É
HEADER:00400003                 db    0
HEADER:00400004                 db    3
HEADER:00400005                 db    0
HEADER:00400006                 db    0
HEADER:00400007                 db    0
HEADER:00400008                 db    4
HEADER:00400009                 db    0
HEADER:0040000A                 db    0
HEADER:0040000B                 db    0
HEADER:0040000C                 db 0FFh
HEADER:0040000D                 db 0FFh
HEADER:0040000E                 db    0
HEADER:0040000F                 db    0</pre><p>As this file is formatted here, you would need some PE file reference documentation to help you make sense of each of the data bytes. By using structure templates, IDA can format these bytes as an <code class="literal">IMAGE_DOS_HEADER</code>, making the data far more useful. The first step is to add the standard <code class="literal">IMAGE_DOS_HEADER</code> as detailed above (you could add the <code class="literal">IMAGE_NT_HEADERS</code> structure while you are at it). The second step is to convert the bytes beginning at <code class="literal">__ImageBase</code> into an <code class="literal">IMAGE_DOS_HEADER</code> structure using <span class="strong"><strong>Edit</strong></span> ▸ <span class="strong"><strong>Struct Var</strong></span> (<span class="keycap">alt</span>-Q). This results in the reformatted display shown here:<a class="indexterm" id="IDX-CHP-8-0117"/><a class="indexterm" id="IDX-CHP-8-0118"/></p><a id="I_programlisting5_d1e11438"/><pre class="programlisting">HEADER:00400000 __ImageBase IMAGE_DOS_HEADER
 &lt;5A4Dh, 90h, 3, 0, 4, 0, 0FFFFh, 0, 0B8h, \
HEADER:00400000                               0, 0, 0, 40h, 0, 0, 0, 0, 0, 80h&gt;
HEADER:00400040 db 0Eh</pre><p>As you can see, the first 64 (0x40) bytes in the file have been collapsed into a single data structure, with the type noted in the disassembly. Unless you possess encyclopedic knowledge of this particular structure, though, the meaning of each field may remain somewhat cryptic. We can take this operation one step further, however, by expanding the structure. When a structured data item is expanded, each field is annotated with its corresponding field name from the structure definition. Collapsed structures can be expanded using the plus key (+) on the numeric keypad. The final version of the listing follows:<a class="indexterm" id="IDX-CHP-8-0119"/></p><a id="I_programlisting5_d1e11446"/><pre class="programlisting">HEADER:00400000 __ImageBase     dw 5A4Dh                ; e_magic
HEADER:00400000                 dw 90h                  ; e_cblp
HEADER:00400000                 dw 3                    ; e_cp
HEADER:00400000                 dw 0                    ; e_crlc
HEADER:00400000                 dw 4                    ; e_cparhdr
HEADER:00400000                 dw 0                    ; e_minalloc
HEADER:00400000                 dw 0FFFFh               ; e_maxalloc
HEADER:00400000                 dw 0                    ; e_ss
HEADER:00400000                 dw 0B8h                 ; e_sp
HEADER:00400000                 dw 0                    ; e_csum
HEADER:00400000                 dw 0                    ; e_ip
HEADER:00400000                 dw 0                    ; e_cs
HEADER:00400000                 dw 40h                  ; e_lfarlc
HEADER:00400000                 dw 0                    ; e_ovno
HEADER:00400000                 dw 4 dup(0)             ; e_res
HEADER:00400000                 dw 0                    ; e_oemid
HEADER:00400000                 dw 0                    ; e_oeminfo
HEADER:00400000                 dw 0Ah dup(0)           ; e_res2
HEADER:00400000                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>dd 80h                  ; e_lfanew
HEADER:00400040                 db  0Eh</pre><p>Unfortunately, the fields of <code class="literal">IMAGE_DOS_HEADER</code> do not possess particularly meaningful names, so we may need to consult a PE file reference to remind ourselves that the <code class="literal">e_lfanew</code> field <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11462"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> indicates the file offset at which an <code class="literal">IMAGE_NT_HEADERS</code> structure can be found. Applying all of the previous steps to create an <code class="literal">IMAGE_NT_HEADER</code> at address <code class="literal">00400080</code> (0x80 bytes into the database) yields the nicely formatted structure shown in part here:<a class="indexterm" id="IDX-CHP-8-0120"/><a class="indexterm" id="IDX-CHP-8-0121"/><a class="indexterm" id="IDX-CHP-8-0122"/><a class="indexterm" id="IDX-CHP-8-0123"/></p><a id="I_programlisting5_d1e11496"/><pre class="programlisting">HEADER:00400080                 dd 4550h                ; Signature
HEADER:00400080                 dw 14Ch                 ; FileHeader.Machine
HEADER:00400080                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>
dw 5                    ; FileHeader.NumberOfSections
HEADER:00400080                 dd 4789ADF1h            ; FileHeader.TimeDateStamp
HEADER:00400080                 dd 1400h                ; File
Header.PointerToSymbolTable
HEADER:00400080                 dd 14Eh                 ; FileHeader.NumberOfSymbols
HEADER:00400080                 dw 0E0h                 ; File
Header.SizeOfOptionalHeader
HEADER:00400080                 dw 307h                 ; FileHeader.Characteristics
HEADER:00400080                 dw 10Bh                 ; OptionalHeader.Magic
HEADER:00400080                 db 2                    ; Optional
Header.MajorLinkerVersion
HEADER:00400080                 db 38h                  ; Optional
Header.MinorLinkerVersion
HEADER:00400080                 dd 800h                 ; OptionalHeader.SizeOfCode
HEADER:00400080                 dd 800h                 ; Optional
Header.SizeOfInitializedData
HEADER:00400080                 dd 200h                 ; Optional
Header.SizeOfUninitializedData
HEADER:00400080                 dd 1000h                ; Optional
Header.AddressOfEntryPoint
HEADER:00400080                 dd 1000h                ; OptionalHeader.BaseOfCode
HEADER:00400080                 dd 2000h                ; OptionalHeader.BaseOfData
HEADER:00400080                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>dd 400000h
              ; OptionalHeader.ImageBase</pre><p>Fortunately for us, the field names in this case are somewhat more meaningful. We quickly see that the file consists of five sections <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11512"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and should be loaded into memory at virtual address <code class="literal">00400000</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11521"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Expanded structures can be returned to their collapsed state using the minus key (−) on the keypad.</p></div>
<div class="sect1" title="IDA TIL Files"><div class="titlepage"><div><div><h1 class="title"><a id="ida_til_files"/>IDA TIL Files</h1></div></div></div><p>All datatype and function prototype information in IDA is stored in TIL files. IDA ships with type library information for many major compilers and APIs stored in the <span class="emphasis"><em>&lt;IDADIR&gt;/til</em></span> directory. The Types window (View ▸ Open subview ▸ Type Libraries) lists currently loaded <span class="emphasis"><em>.til</em></span> files and is used to load additional <span class="emphasis"><em>.til</em></span> files that you may wish to use. Type libraries are loaded automatically based on attributes of the binary discovered during the analysis phase. Under ideal circumstances, most users will never need to deal with <span class="emphasis"><em>.til</em></span> files directly.</p><div class="sect2" title="Loading New TIL Files"><div class="titlepage"><div><div><h2 class="title"><a id="loading_new_til_files"/>Loading New TIL Files</h2></div></div></div><p>In some cases, IDA may fail to detect that a specific compiler was used to build a binary, perhaps because the binary has undergone some form of obfuscation. When this happens, you may load additional <span class="emphasis"><em>.til</em></span> files by pressing the <span class="keycap">insert</span> key within the Types window and selecting the desired <span class="emphasis"><em>.til</em></span> files. When a new <span class="emphasis"><em>.til</em></span> file is loaded, all structure definitions contained in the file are added to the list of standard structures, and type information is applied for any functions within the binary that have matching prototypes in the newly loaded <span class="emphasis"><em>.til</em></span> file. In other words, when IDA gains new knowledge about the nature of a function, it automatically applies that new knowledge.<a class="indexterm" id="IDX-CHP-8-0124"/><a class="indexterm" id="IDX-CHP-8-0125"/><a class="indexterm" id="IDX-CHP-8-0126"/><a class="indexterm" id="IDX-CHP-8-0127"/><a class="indexterm" id="IDX-CHP-8-0128"/><a class="indexterm" id="IDX-CHP-8-0129"/><a class="indexterm" id="IDX-CHP-8-0130"/></p></div><div class="sect2" title="Sharing TIL Files"><div class="titlepage"><div><div><h2 class="title"><a id="sharing_til_files"/>Sharing TIL Files</h2></div></div></div><p>IDA also makes use of <span class="emphasis"><em>.til</em></span> files to store any custom structure definitions that you create manually in the Structures window or through parsing C header files. Such structures are stored in a dedicated <span class="emphasis"><em>.til</em></span> file associated with the database in which they were created. This file shares the base name of the database and has a <span class="emphasis"><em>.til</em></span> extension. For a database named <span class="emphasis"><em>some_file.idb</em></span>, the associated type library file would be <span class="emphasis"><em>some_file.til</em></span>. Under normal circumstances you will never see this file unless you happen to have the database open in IDA. Recall that an <span class="emphasis"><em>.idb</em></span> file is actually an archive file (similar to a <span class="emphasis"><em>.tar</em></span> file) used to hold the components of a database when they are not in use. When a database is opened, the component files (the <span class="emphasis"><em>.til</em></span> file being one of them) are extracted as working files for IDA.</p><p>A discussion regarding how to share <span class="emphasis"><em>.til</em></span> files across databases can be found at <a class="ulink" href="http://www.hex-rays.com/forum/viewtopic.php?f=6&amp;t=986">http://www.hex-rays.com/forum/viewtopic.php?f=6&amp;t=986</a>.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-4" id="CHP-8-FN-4">47</a>]</sup> Two techniques are mentioned. The first technique is somewhat unofficial and involves copying the <span class="emphasis"><em>.til</em></span> file from an open database into your IDA <span class="emphasis"><em>til</em></span> directory from which it can be opened, in any other database, via the Types window. A more official way to extract the custom type information from a database is to generate an IDC script that can be used to re-create the custom structures in any other database. Such a script can be generated using the File ▸ Produce File ▸ Dump Typeinfo to IDC File command. However, unlike the first technique, this technique dumps only the structures listed in the Structures window, which may not include all structures parsed from C header files (whereas the <span class="emphasis"><em>.til</em></span> file-copying technique will).<a class="indexterm" id="IDX-CHP-8-0131"/></p><p>Hex-Rays also provides a standalone tool, named <code class="literal">tilib</code>, for creating <span class="emphasis"><em>.til</em></span> files outside of IDA. The utility is available as a <span class="emphasis"><em>.zip</em></span> file for registered users via the Hex-Rays IDA download page. Installation is as simple as extracting the <span class="emphasis"><em>.zip</em></span> file contents into <span class="emphasis"><em>&lt;IDADIR&gt;</em></span>. The <code class="literal">tilib</code> utility may be used to list the contents of existing <span class="emphasis"><em>.til</em></span> files or create new <span class="emphasis"><em>.til</em></span> files by parsing C (not C++) header files. The following command would list the contents of the Visual Studio 6 type library:</p><a id="I_programlisting5_d1e11672"/><pre class="programlisting">C:\Program Files\IdaPro&gt;tilib -l til\pc\vc6win.til</pre><p>Creating a new <span class="emphasis"><em>.til</em></span> file involves naming the header file to be parsed and the <span class="emphasis"><em>.til</em></span> file to be created. Command line options allow you to specify additional include file directories or, alternatively, previously parsed <span class="emphasis"><em>.til</em></span> files in order to resolve any dependencies contained in your header file. The following command creates a new <span class="emphasis"><em>.til</em></span> file containing the declaration of <code class="literal">ch8_struct</code>. The resulting <span class="emphasis"><em>.til</em></span> file must be moved into <span class="emphasis"><em>&lt;IDADIR&gt;/til</em></span> before IDA can make use of it.<a class="indexterm" id="IDX-CHP-8-0132"/><a class="indexterm" id="IDX-CHP-8-0133"/><a class="indexterm" id="IDX-CHP-8-0134"/><a class="indexterm" id="IDX-CHP-8-0135"/><a class="indexterm" id="IDX-CHP-8-0136"/><a class="indexterm" id="IDX-CHP-8-0137"/></p><a id="I_programlisting5_d1e11718"/><pre class="programlisting">C:\Program Files\IdaPro&gt;tilib -c -hch8_struct.h ch8.til</pre><p>The <code class="literal">tilib</code> utility contains a substantial number of additional capabilities, some of which are detailed in the README file included with the <code class="literal">tilib</code> distribution, and others of which are briefly detailed by running <code class="literal">tilib</code> with no arguments. Prior to version 6.1, <code class="literal">tilib</code> is distributed only as a Windows executable; however, the <span class="emphasis"><em>.til</em></span> files that it generates are compatible with all versions of IDA.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-4" id="ftn.CHP-8-FN-4">47</a>] </sup>This link is accessible to registered users only.</p></div></div></div>
<div class="sect1" title="C++ Reversing Primer"><div class="titlepage"><div><div><h1 class="title"><a id="c_plus_plus_reversing_primer"/>C++ Reversing Primer</h1></div></div></div><p>C++ classes are the object-oriented extensions of C structs, so it is somewhat logical to wrap up our discussion of data structures with a review of the features of compiled C++ code. C++ is sufficiently complex that detailed coverage of the topic is beyond the scope of this book. Here we attempt to cover the highlights and a few of the differences between Microsoft’s Visual C++ and GNU’s g++.<a class="indexterm" id="IDX-CHP-8-0138"/></p><p>An important point to remember is that a solid, fundamental understanding of the C++ language will assist you greatly in understanding compiled C++. Object-oriented concepts such as inheritance and polymorphism are difficult enough to learn well at the source level. Attempting to dive into these concepts at the assembly level without understanding them at the source level will certainly be an exercise in frustration.</p><div class="sect2" title="The this Pointer"><div class="titlepage"><div><div><h2 class="title"><a id="the_this_pointer"/>The this Pointer</h2></div></div></div><p>The <code class="literal">this</code> pointer is a pointer available in all nonstatic C++ member functions. Whenever such a function is called, <code class="literal">this</code> is initialized to point to the object used to invoke the function. Consider the following functions calls:</p><a id="I_programlisting5_d1e11758"/><pre class="programlisting">//object1, object2, and *p_obj are all the same type.
object1.member_func();
object2.member_func();
p_obj-&gt;member_func();</pre><p>In the three calls to <code class="literal">member_func</code>, <code class="literal">this</code> takes on the values <code class="literal">&amp;object1</code>, <code class="literal">&amp;object2</code>, and <code class="literal">p_obj</code>, respectively. It is easiest to view <code class="literal">this</code> as a hidden first parameter passed in to all nonstatic member functions. As discussed in <a class="xref" href="ch06.html" title="Chapter 6. Disassembly Navigation">Chapter 6</a>, Microsoft Visual C++ utilizes the <code class="literal">thiscall</code> calling convention and passes <code class="literal">this</code> in the ECX register. The GNU g++ compiler treats <code class="literal">this</code> exactly as if it was the first (leftmost) parameter to nonstatic member functions and pushes the address of the object used to invoke the function as the topmost item on the stack prior to calling the function.<a class="indexterm" id="IDX-CHP-8-0139"/><a class="indexterm" id="IDX-CHP-8-0140"/><a class="indexterm" id="IDX-CHP-8-0141"/><a class="indexterm" id="IDX-CHP-8-0142"/><a class="indexterm" id="IDX-CHP-8-0143"/></p><p>From a reverse engineering point of view, the moving of an address into the ECX register immediately prior to a function call is a probable indicator of two things. First, the file was compiled using Visual C++. Second, the function is a member function. When the same address is passed to two or more functions, we can conclude that those functions all belong to the same class hierarchy.</p><p>Within a function, the use of ECX prior to initializing it implies that the caller must have initialized ECX and is a possible sign that the function is a member function (though the function may simply use the <code class="literal">fastcall</code> calling convention). Further, when a member function is observed to pass <code class="literal">this</code> to additional functions, those functions can be inferred to be members of the same class as well.</p><p>For code compiled using g++, calls to member functions stand out somewhat less. However, any function that does not take a pointer as its first argument can certainly be ruled out as a member function.</p></div><div class="sect2" title="Virtual Functions and Vtables"><div class="titlepage"><div><div><h2 class="title"><a id="virtual_functions_and_vtables"/>Virtual Functions and Vtables</h2></div></div></div><p>Virtual functions provide the means for polymorphic behavior in C++ programs. For each class (or subclass through inheritance) that contains virtual functions, the compiler generates a table containing pointers to each virtual function in the class. Such tables are called <span class="emphasis"><em>vtables</em></span>. Furthermore, every class that contains virtual functions is given an additional data member whose purpose is to point to the appropriate vtable at runtime. This member is typically referred to as a <span class="emphasis"><em>vtable pointer</em></span> and is allocated as the first data member within the class. When an object is created at runtime, its vtable pointer is set to point at the appropriate vtable. When that object invokes a virtual function, the correct function is selected by performing a lookup in the object’s vtable. Thus, vtables are the underlying mechanism that facilitates runtime resolution of calls to virtual functions.</p><p>A few examples may help to clarify the use of vtables. Consider the following C++ class definitions:</p><a id="I_programlisting5_d1e11835"/><pre class="programlisting">class BaseClass {
public:
   BaseClass();
   virtual void vfunc1() = 0;
   virtual void vfunc2();
   virtual void vfunc3();
   virtual void vfunc4();
private:
   int x;
   int y;
};

class SubClass : public BaseClass {
public:
   SubClass();
   virtual void vfunc1();
   virtual void vfunc3();
   virtual void vfunc5();
private:
   int z;
};</pre><p>In this case, SubClass inherits from BaseClass. BaseClass contains four virtual functions, while SubClass contains five (four from BaseClass plus the new <code class="literal">vfunc5</code>). Within BaseClass, <code class="literal">vfunc1</code> is a <span class="emphasis"><em>pure virtual function</em></span> by virtue of the use of <code class="literal">= 0</code> in its declaration. Pure virtual functions have no implementation in their declaring class and <span class="emphasis"><em>must</em></span> be overridden in a subclass before the class is considered concrete. In other words, there is no function named <code class="literal">Base-Class::vfunc1</code>, and until a subclass provides an implementation, no objects can be instantiated. SubClass provides such an implementation, so SubClass objects can be created.<a class="indexterm" id="IDX-CHP-8-0144"/></p><p>At first glance BaseClass appears to contain two data members and Sub Class three data members. Recall, however, that any class that contains virtual functions, either explicitly or because they are inherited, also contains a vtable pointer. As a result, instantiated BaseClass objects actually have three data members, while instantiated SubClass objects have four data members. In each case, the first data member is the vtable pointer. Within SubClass, the vtable pointer is actually inherited from BaseClass rather than being introduced specifically for SubClass. <a class="xref" href="ch08s07.html#a_simple_vtable_layout" title="Figure 8-14. A simple vtable layout">Figure 8-14</a> shows a simplified memory layout in which a single SubClass object has been dynamically allocated. During the creation of the object, the compiler ensures that the new object’s vtable pointer points to the correct vtable (SubClass’s in this case).</p><div class="figure"><a id="a_simple_vtable_layout"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e11868"/><img alt="A simple vtable layout" src="httpatomoreillycomsourcenostarchimages854193.png"/></div></div><p class="title">Figure 8-14. A simple vtable layout</p></div><p>Note that the vtable for SubClass contains two pointers to functions belonging to BaseClass (<code class="literal">BaseClass::vfunc2</code> and <code class="literal">BaseClass::vfunc4</code>). This is because SubClass does not override either of these functions and instead inherits them from BaseClass. Also shown is the typical handling of pure virtual function entries. Because there is no implementation for the pure virtual function <code class="literal">BaseClass::vfunc1</code>, no address is available to store in the BaseClass vtable slot for <code class="literal">vfunc1</code>. In such cases, compilers insert the address of an error handling function, often dubbed <code class="literal">purecall</code>, which in theory should never be called but which will usually abort the program in the event that it somehow is called.<a class="indexterm" id="IDX-CHP-8-0145"/><a class="indexterm" id="IDX-CHP-8-0146"/><a class="indexterm" id="IDX-CHP-8-0147"/></p><p>One consequence of the presence of a vtable pointer is that you must account for it when you manipulate the class within IDA. Recall that C++ classes are an extension of C structures. Therefore, you may choose to make use of IDA’s structure definition features to define the layout of C++ classes. In the case of classes that contain virtual functions, you must remember to include a vtable pointer as the first field within the class. Vtable pointers must also be accounted for in the total size of an object. This is most apparent when observing the dynamic allocation of an object using the <code class="literal">new</code><sup>[<a class="footnote" href="#ftn.CHP-8-FN-5" id="CHP-8-FN-5">48</a>]</sup> operator, where the size value passed to <code class="literal">new</code> includes the space consumed by all explicitly declared fields in the class (and any superclasses) as well as any space required for a vtable pointer.</p><p>In the following example a SubClass object is created dynamically, and its address saved in a BaseClass pointer. The pointer is then passed to a function (<code class="literal">call_vfunc</code>), which uses the pointer to call <code class="literal">vfunc3</code>.</p><a id="I_programlisting5_d1e11931"/><pre class="programlisting">void call_vfunc(BaseClass *b) {
   b-&gt;vfunc3();
}

int main() {
   BaseClass *bc = new SubClass();
   call_vfunc(bc);
}</pre><p>Since <code class="literal">vfunc3</code> is a virtual function, the compiler must ensure that <code class="literal">Sub-Class::vfunc3</code> is called in this case because the pointer points to a Sub-Class object. The following disassembled version of <code class="literal">call_vfunc</code> demonstrates how the virtual function call is resolved:</p><a id="I_programlisting5_d1e11945"/><pre class="programlisting">.text:004010A0 call_vfunc      proc near
.text:004010A0
.text:004010A0 b               = dword ptr  8
.text:004010A0
.text:004010A0                 push    ebp
.text:004010A1                 mov     ebp, esp
.text:004010A3                 mov     eax, [ebp+b]
.text:004010A6                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>mov     edx, [eax]
.text:004010A8                 mov     ecx, [ebp+b]
.text:004010AB                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     eax, [edx+8]
.text:004010AE                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>call    eax
.text:004010B0                 pop     ebp
.text:004010B1                 retn
.text:004010B1 call_vfunc      endp</pre><p>The vtable pointer is read from the structure at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11967"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and saved in the EDX register. Since the parameter <code class="literal">b</code> points to a SubClass object, this will be the address of SubClass’s vtable. At <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11976"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, the vtable is indexed to read the third pointer (the address of <code class="literal">SubClass::vfunc3</code> in this case) into the EAX register. Finally, at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e11985"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, the virtual function is called.<a class="indexterm" id="IDX-CHP-8-0148"/><a class="indexterm" id="IDX-CHP-8-0149"/><a class="indexterm" id="IDX-CHP-8-0150"/><a class="indexterm" id="IDX-CHP-8-0151"/></p><p>Note that the vtable indexing operation at <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e12008"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> looks very much like a structure reference operation. In fact, it is no different, and it is possible to define a structure to represent the layout of a class’s vtable and then use the defined structure to make the disassembly more readable, as shown here:</p><a id="I_programlisting5_d1e12014"/><pre class="programlisting">00000000 SubClass_vtable struc ; (sizeof=0x14)
00000000 vfunc1          dd ?
00000004 vfunc2          dd ?
00000008 vfunc3          dd ?
0000000C vfunc4          dd ?
00000010 vfunc5          dd ?
00000014 SubClass_vtable ends</pre><p>This structure allows the vtable reference operation to be reformatted as follows:</p><a id="I_programlisting5_d1e12018"/><pre class="programlisting">.text:004010AB                 mov     eax, [edx+SubClass_vtable.vfunc3]</pre></div><div class="sect2" title="The Object Life Cycle"><div class="titlepage"><div><div><h2 class="title"><a id="the_object_life_cycle"/>The Object Life Cycle</h2></div></div></div><p>An understanding of the mechanism by which objects are created and destroyed can help to reveal object hierarchies and nested object relationships as well as quickly identify class constructor and destructor functions.<sup>[<a class="footnote" href="#ftn.CHP-8-FN-6" id="CHP-8-FN-6">49</a>]</sup><a class="indexterm" id="IDX-CHP-8-0152"/></p><p>For global and statically allocated objects, constructors are called during program startup and prior to entry into the <code class="literal">main</code> function. Constructors for stack-allocated objects are invoked at the point the object comes into scope within the function in which it is declared. In many cases, this will be immediately upon entry to the function in which it is declared. However, when an object is declared within a block statement, its constructor is not invoked until that block is entered, if it is entered at all. When an object is allocated dynamically in the program heap, its creation is a two-step process. In the first step, the <code class="literal">new</code> operator is invoked to allocate the object’s memory. In the second step, the constructor is invoked to initialize the object. A major difference between Microsoft’s Visual C++ and GNU’s g++ is that Visual C++ ensures that the result of <code class="literal">new</code> is not null prior to invoking the constructor.<a class="indexterm" id="IDX-CHP-8-0153"/></p><p>When a constructor executes, the following sequence of actions takes place:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the class has a superclass, the superclass constructor is invoked.</p></li><li class="listitem"><p>If the class has any virtual functions, the vtable pointer is initialized to point to the class’s vtable. Note that this may overwrite a vtable pointer that was initialized in the superclass, which is exactly the desired behavior.</p></li><li class="listitem"><p>If the class has any data members that are themselves objects, then the constructor for each such data member is invoked.</p></li><li class="listitem"><p>Finally, the code-specific constructor is executed. This is the code representing the C++ behavior of the constructor specified by the programmer.</p></li></ol></div><p>Constructors do not specify a return type; however, constructors generated by Microsoft Visual C++ actually return <code class="literal">this</code> in the EAX register. Regardless, this is a Visual C++ implementation detail and does not permit C++ programmers to access the returned value.</p><p>Destructors are called in essentially the reverse order. For global and static objects, destructors are called by cleanup code that is executed after the <code class="literal">main</code> function terminates. Destructors for stack-allocated objects are invoked as the objects go out of scope. Destructors for heap-allocated objects are invoked via the <code class="literal">delete</code> operator immediately before the memory allocated to the object is released.</p><p>The actions performed by destructors mimic those performed by constructors, with the exception that they are performed in roughly reverse order.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the class has any virtual functions, the vtable pointer for the object is restored to point to the vtable for the associated class. This is required in case a subclass had overwritten the vtable pointer as part of its creation process.</p></li><li class="listitem"><p>The programmer-specified code for the destructor executes.</p></li><li class="listitem"><p>If the class has any data members that are themselves objects, the destructor for each such member is executed.</p></li><li class="listitem"><p>Finally, if the object has a superclass, the superclass destructor is called.</p></li></ol></div><p>By understanding when superclass constructors and destructors are called, it is possible to trace an object’s inheritance hierarchy through the chain of calls to its related superclass functions. A final point regarding vtables relates to how they are referenced within programs. There are only two circumstances in which a class’s vtable is referenced directly, within the class constructor(s) and destructor. When you locate a vtable, you can utilize IDA’s data cross-referencing capabilities (see <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>) to quickly locate all constructors and destructors for the associated class.</p></div><div class="sect2" title="Name Mangling"><div class="titlepage"><div><div><h2 class="title"><a id="name_mangling"/>Name Mangling</h2></div></div></div><p>Also called <span class="emphasis"><em>name decoration</em></span>, <span class="emphasis"><em>name mangling</em></span> is the mechanism C++ compilers use to distinguish among overloaded<sup>[<a class="footnote" href="#ftn.CHP-8-FN-7" id="CHP-8-FN-7">50</a>]</sup> versions of a function. In order to generate unique names for overloaded functions, compilers decorate the function name with additional characters used to encode various pieces of information about the function. Encoded information typically describes the return type of the function, the class to which the function belongs, and the parameter sequence (type and order) required to call the function.<a class="indexterm" id="IDX-CHP-8-0154"/><a class="indexterm" id="IDX-CHP-8-0155"/><a class="indexterm" id="IDX-CHP-8-0156"/><a class="indexterm" id="IDX-CHP-8-0157"/><a class="indexterm" id="IDX-CHP-8-0158"/></p><p>Name mangling is a compiler implementation detail for C++ programs and as such is not part of the C++ language specification. Not unexpectedly, compiler vendors have developed their own, often-incompatible conventions for name mangling. Fortunately, IDA understands the name-mangling conventions employed by Microsoft Visual C++ and GNU g++ as well as a few other compilers. By default, when a mangled name is encountered within a program, IDA displays the demangled equivalent as a comment anywhere the name appears in the disassembly. IDA’s name-demangling options are selected using the dialog shown in <a class="xref" href="ch08s07.html#demangled_name_display_options" title="Figure 8-15. Demangled name display options">Figure 8-15</a>, which is accessed using Options ▸ Demangled Names.<a class="indexterm" id="IDX-CHP-8-0159"/></p><div class="figure"><a id="demangled_name_display_options"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e12146"/><img alt="Demangled name display options" src="httpatomoreillycomsourcenostarchimages854195.png.jpg"/></div></div><p class="title">Figure 8-15. Demangled name display options</p></div><p>The three principal options control whether demangled names are displayed as comments, whether the names themselves are demangled, or whether no demangling is performed at all. Displaying demangled names as comments results in a display similar to the following:</p><a id="I_programlisting5_d1e12153"/><pre class="programlisting">.text:00401050 ; protected: __thiscall SubClass::SubClass(void)
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  text:00401050 ??0SubClass@@IAE@XZ  proc near
  ...
  .text:004010DC           <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>
call  ??0SubClass@@IAE@XZ  ; SubClass::SubClass(void)</pre><p>Likewise, displaying demangled names as names results in the following:</p><a id="I_programlisting5_d1e12169"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:00401050 protected: __thiscall SubClass::SubClass(void) proc near
  ...
  .text:004010DC             <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>call    SubClass::SubClass(void)</pre><p>where <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e12184"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is representative of the first line of a disassembled function and <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e12190"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> is representative of a call to that function.</p><p>The Assume GCC v3.x names checkbox is used to distinguish between the mangling scheme used in g++ version 2.9.<span class="emphasis"><em>x</em></span> and that used in g++ versions 3.<span class="emphasis"><em>x</em></span> and later. Under normal circumstances, IDA should automatically detect the naming conventions in use in g++-compiled code. The Setup short names and Setup long names buttons offer fine-grained control over the formatting of demangled names with a substantial number of options that are documented in IDA’s help system.<a class="indexterm" id="IDX-CHP-8-0160"/><a class="indexterm" id="IDX-CHP-8-0161"/><a class="indexterm" id="IDX-CHP-8-0162"/><a class="indexterm" id="IDX-CHP-8-0163"/><a class="indexterm" id="IDX-CHP-8-0164"/><a class="indexterm" id="IDX-CHP-8-0165"/><a class="indexterm" id="IDX-CHP-8-0166"/><a class="indexterm" id="IDX-CHP-8-0167"/><a class="indexterm" id="IDX-CHP-8-0168"/></p><p>Because mangled names carry so much information regarding the signature of each function, they reduce the time required to understand the number and types of parameters passed into a function. When mangled names are available within a binary, IDA’s demangling capability instantly reveals the parameter types and return types for all functions whose names are mangled. In contrast, for any function that does not utilize a mangled name, you must conduct time-consuming analysis of the data flowing into and out of the function in order to determine the signature of the function.</p></div><div class="sect2" title="Runtime Type Identification"><div class="titlepage"><div><div><h2 class="title"><a id="runtime_type_identification"/>Runtime Type Identification</h2></div></div></div><p>C++ provides operators that allow for runtime determination (<code class="literal">typeid</code>) and checking (<code class="literal">dynamic_cast</code>) of an object’s datatype. To facilitate these operations, C++ compilers must embed type information within a program binary and implement procedures whereby the type of a polymorphic object can be determined with certainty regardless of the type of the pointer that may be dereferenced to access the object. Unfortunately, as with name mangling, Runtime Type Identification (RTTI) is a compiler implementation detail rather than a language issue, and there is no standard means by which compilers implement RTTI capabilities.<a class="indexterm" id="IDX-CHP-8-0169"/></p><p>We will take brief look at the similarities and differences between the RTTI implementations of Microsoft Visual C++ and GNU g++. Specifically, the only details presented here concern how to locate RTTI information and, from there, how to learn the name of class to which that information pertains. Readers desiring more detailed discussion of Microsoft’s RTTI implementation should consult the references listed at the end of this chapter. In particular, the references detail how to traverse a class’s inheritance hierarchy, including how to trace that hierarchy when multiple inheritance is being used.</p><p>Consider the following simple program, which makes use of polymorphism:<a class="indexterm" id="IDX-CHP-8-0170"/></p><a id="I_programlisting5_d1e12259"/><pre class="programlisting">class abstract_class {
public:
   virtual int vfunc() = 0;
};

class concrete_class : public abstract_class {
public:
   concrete_class();
   int vfunc();
};

void print_type(abstract_class *p) {
   cout &lt;&lt; typeid(*p).name() &lt;&lt; endl;
}

int main() {
   abstract_class *sc = new concrete_class();
   print_type(sc);
}</pre><p>The <code class="literal">print_type</code> function must correctly print the type of the object being pointed to by the pointer <code class="literal">p</code>. In this case, it is trivial to realize that “concrete_class” must be printed based on the fact that a <code class="literal">concrete_class</code> object is created in the <code class="literal">main</code> function. The question we answer here is: How does <code class="literal">print_type</code>, and more specifically <code class="literal">typeid</code>, know what type of object <code class="literal">p</code> is pointing to?<a class="indexterm" id="IDX-CHP-8-0171"/><a class="indexterm" id="IDX-CHP-8-0172"/><a class="indexterm" id="IDX-CHP-8-0173"/><a class="indexterm" id="IDX-CHP-8-0174"/><a class="indexterm" id="IDX-CHP-8-0175"/><a class="indexterm" id="IDX-CHP-8-0176"/><a class="indexterm" id="IDX-CHP-8-0177"/></p><p>The answer is surprisingly simple. Since every polymorphic object contains a pointer to a vtable, compilers leverage that fact by co-locating class-type information with the class vtable. Specifically, the compiler places a pointer immediately prior to the class vtable. This pointer points to a structure that contains information used to determine the name of the class that owns the vtable. In g++ code, this pointer points to a <code class="literal">type_info</code> structure, which contains a pointer to the name of the class. In Visual C++, the pointer points to a Microsoft <code class="literal">RTTICompleteObjectLocator</code> structure, which in turn contains a pointer to a <code class="literal">TypeDescriptor</code> structure. The <code class="literal">TypeDescriptor</code> structure contains a character array that specifies the name of the polymorphic class.</p><p>It is important to realize that RTTI information is required only in C++ programs that use the <code class="literal">typeid</code> or <code class="literal">dynamic_cast</code> operator. Most compilers provide options to disable the generation of RTTI in binaries that do not require it; therefore, you should not be surprised if RTTI information ever happens to be missing.</p></div><div class="sect2" title="Inheritance Relationships"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance_relationships"/>Inheritance Relationships</h2></div></div></div><p>If you dig deep enough into some RTTI implementations, you will find that it is possible to unravel inheritance relationships, though you must understand the compiler’s particular implementation of RTTI in order to do so. Also, RTTI may not be present when a program does not utilize the <code class="literal">typeid</code> or <code class="literal">dynamic_cast</code> operators. Lacking RTTI information, what techniques can be employed to determine inheritance relationships among C++ classes?<a class="indexterm" id="IDX-CHP-8-0178"/></p><p>The simplest method of determining an inheritance hierarchy is to observe the chain of calls to superclass constructors that are called when an object is created. The single biggest hindrance to this technique is the use of inline<sup>[<a class="footnote" href="#ftn.CHP-8-FN-8" id="CHP-8-FN-8">51</a>]</sup> constructors, the use of which makes it impossible to understand that a superclass constructor has in fact been called.<a class="indexterm" id="IDX-CHP-8-0179"/><a class="indexterm" id="IDX-CHP-8-0180"/><a class="indexterm" id="IDX-CHP-8-0181"/></p><p>An alternative means for determining inheritance relationships involves the analysis and comparison of vtables. For example, in comparing the vtables shown in <a class="xref" href="ch08s07.html#a_simple_vtable_layout" title="Figure 8-14. A simple vtable layout">Figure 8-14</a>, we note that the vtable for SubClass contains two of the same pointers that appear in the vtable for BaseClass. We can easily conclude that BaseClass and SubClass must be related in some way, but which one is the base class and which one is the subclass? In such cases we can apply the following guidelines, singly or in combination, in an attempt to understand the nature of their relationship.<a class="indexterm" id="IDX-CHP-8-0182"/><a class="indexterm" id="IDX-CHP-8-0183"/><a class="indexterm" id="IDX-CHP-8-0184"/><a class="indexterm" id="IDX-CHP-8-0185"/><a class="indexterm" id="IDX-CHP-8-0186"/><a class="indexterm" id="IDX-CHP-8-0187"/><a class="indexterm" id="IDX-CHP-8-0188"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When two vtables contain the same number of entries, the two corresponding classes <span class="emphasis"><em>may</em></span> be involved in an inheritance relationship.</p></li><li class="listitem"><p>When the vtable for class X contains more entries than the vtable for class Y, class X <span class="emphasis"><em>may</em></span> be a subclass of class Y.</p></li><li class="listitem"><p>When the vtable for class X contains entries that are also found in the vtable for class Y, then one of the following relationships must exist: X is a subclass of Y, Y is a subclass of X, or X and Y are both subclasses of a common superclass Z.</p></li><li class="listitem"><p>When the vtable for class X contains entries that are also found in the vtable for class Y and the vtable for class X contains at least one <code class="literal">purecall</code> entry that is not also present in the corresponding vtable entry for class Y, then class Y is a subclass of class X.</p></li></ul></div><p>While the list above is by no means all-inclusive, we can use these guidelines to deduce the relationship between BaseClass and SubClass in <a class="xref" href="ch08s07.html#a_simple_vtable_layout" title="Figure 8-14. A simple vtable layout">Figure 8-14</a>. In this case, the last three rules all apply, but the last rule specifically leads us to conclude, based on vtable analysis alone, that SubClass inherits from BaseClass.</p></div><div class="sect2" title="C++ Reverse Engineering References"><div class="titlepage"><div><div><h2 class="title"><a id="c_plus_plus_reverse_engineering_referenc"/>C++ Reverse Engineering References</h2></div></div></div><p>For further reading on the topic of reverse engineering compiled C++, check out these excellent references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Igor Skochinsky’s article “Reversing Microsoft Visual C++ Part II: Classes, Methods and RTTI,” available at <a class="ulink" href="http://www.openrce.org/articles/full_view/23">http://www.openrce.org/articles/full_view/23</a>.</p></li><li class="listitem"><p>Paul Vincent Sabanal and Mark Vincent Yason’s paper “Reversing C++,” available at <a class="ulink" href="http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf">http://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf</a>.</p></li></ul></div><p>While many of the details in each of these articles apply specifically to programs compiled using Microsoft Visual C++, many of the concepts apply equally to programs compiled using other C++ compilers.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-5" id="ftn.CHP-8-FN-5">48</a>] </sup>The <code class="literal">new</code> operator is used for dynamic memory allocation in C++ in much the same way that <code class="literal">malloc</code> is used in C (though <code class="literal">new</code> is built into the C++ language, where <code class="literal">malloc</code> is merely a standard library function).</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-6" id="ftn.CHP-8-FN-6">49</a>] </sup>A <span class="emphasis"><em>class constructor</em></span> function is an initialization function that is invoked automatically when an object is created. A corresponding <span class="emphasis"><em>destructor</em></span> is optional and would be called when an object is no longer in scope or similar.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-7" id="ftn.CHP-8-FN-7">50</a>] </sup>In C++, <span class="emphasis"><em>function overloading</em></span> allows programmers to use the same name for several functions. The only requirement is that each version of an overloaded function must differ from every other version in the sequence and/or quantity of parameter types that the function receives. In other words, each function prototype must be unique.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FN-8" id="ftn.CHP-8-FN-8">51</a>] </sup>In C/C++ programs a function declared as <code class="literal">inline</code> is treated as a macro by the compiler, and the code for the function is expanded in place of an explicit function call. Since the presence of an assembly language call statement is a dead giveaway that a function is being called, the use of inline functions tends to hide the fact that a function is being used.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id7"/>Summary</h1></div></div></div><p>You can expect to encounter complex datatypes in all but the most trivial programs. Understanding how data within complex data structures is accessed and knowing how to recognize clues to the layout of those complex data structures is an essential reverse engineering skill. IDA provides a wide variety of features designed specifically to address the need to deal with complex data structures. Familiarity with these features will greatly enhance your ability to comprehend what data is being manipulated and spend more time understanding how and why that data is being manipulated.</p><p>In the next chapter, we round out our discussion of IDA’s basic capabilities with a discussion of cross-references and graphing before moving on to the more advanced aspects of IDA usage that set it apart from other reverse engineering tools.</p></div>
<div class="chapter" title="Chapter&#xA0;9.&#xA0;Cross-References and Graphing"><div class="titlepage"><div><div><h1 class="title"><a id="cross-references_and_graphing"/>Chapter 9. Cross-References and Graphing</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id9"/><div class="mediaobject"><a id="I_mediaobject6_d1e12444"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>Some of the more common questions asked while reverse engineering a binary are along the lines of “Where is this function called from?” and “What functions access this data?” These and other similar questions seek to catalog the references to and from various resources in a program. Two examples serve to show the usefulness of such questions.</p><p>Consider the case in which you have located a function containing a stack-allocated buffer that can be overflowed, possibly leading to exploitation of the program. Since the function may be buried deep within a complex application, your next step might be to determine exactly how the function can be reached. The function is useless to you unless you can get it to execute. This leads to the question “What functions call this vulnerable function?” as well as additional questions regarding the nature of the data that those functions may pass to the vulnerable function. This line of reasoning must continue as you work your way back up potential call chains to find one that you can influence to properly exploit the overflow that you have discovered.<a class="indexterm" id="IDX-CHP-9-0001"/><a class="indexterm" id="IDX-CHP-9-0002"/><a class="indexterm" id="IDX-CHP-9-0003"/><a class="indexterm" id="IDX-CHP-9-0004"/><a class="indexterm" id="IDX-CHP-9-0005"/></p><p>In another case, consider a binary that contains a large number of ASCII strings, at least one of which you find suspicious, such as “Executing Denial of Service attack!” Does the presence of this string indicate that the binary actually performs a Denial of Service attack? No, it simply indicates that the binary happens to contain that particular ASCII sequence. You might infer that the message is displayed somehow just prior to launching an attack; however, you need to find the related code in order to verify your suspicions. Here the answer to the question “Where is this string referenced?” would help you to quickly track down the program location(s) that make use of the string. From there, perhaps it can assist you in locating any actual Denial of Service attack code.<a class="indexterm" id="IDX-CHP-9-0006"/></p><p>IDA helps to answer these types of questions through its extensive cross-referencing features. IDA provides a number of mechanisms for displaying and accessing cross-reference data, including graph-generation capabilities that provide a highly visual representation of the relationships between code and data. In this chapter we discuss the types of cross-reference information that IDA makes available, the tools for accessing cross-reference data, and how to interpret that data.</p><div class="sect1" title="Cross-References"><div class="titlepage"><div><div><h1 class="title"><a id="cross-references"/>Cross-References</h1></div></div></div><p>We begin our discussion by noting that cross-references within IDA are often referred to simply as <span class="emphasis"><em>xrefs</em></span>. Within this text, we will use <span class="emphasis"><em>xref</em></span> only where it is used to refer to the content of an IDA menu item or dialog. In all other cases we will stick to the term <span class="emphasis"><em>cross-reference</em></span>.</p><p>There are two basic categories of cross-references in IDA: code cross-references and data cross-references. Within each category, we will detail several different types of cross-references. Associated with each cross-reference is the notion of a direction. All cross-references are made from one address to another address. The <span class="emphasis"><em>from</em></span> and <span class="emphasis"><em>to</em></span> addresses may be either code or data addresses. If you are familiar with graph theory, you may choose to think of addresses as <span class="emphasis"><em>nodes</em></span> in a directed graph and cross-references as the edges in that graph. <a class="xref" href="ch09.html#basic_graph_components" title="Figure 9-1. Basic graph components">Figure 9-1</a> provides a quick refresher on graph terminology. In this simple graph, three nodes <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12502"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> are connected by two directed edges <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12509"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>.<a class="indexterm" id="IDX-CHP-9-0007"/><a class="indexterm" id="IDX-CHP-9-0008"/><a class="indexterm" id="IDX-CHP-9-0009"/></p><div class="figure"><a id="basic_graph_components"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e12527"/><img alt="Basic graph components" src="httpatomoreillycomsourcenostarchimages854197.png"/></div></div><p class="title">Figure 9-1. Basic graph components</p></div><p>Note that nodes may also be referred to as <span class="emphasis"><em>vertices</em></span>. Directed edges are drawn using arrows to indicate the allowed direction of travel across the edge. In <a class="xref" href="ch09.html#basic_graph_components" title="Figure 9-1. Basic graph components">Figure 9-1</a>, it is possible to travel from the upper node to either of the lower nodes, but it is not possible to travel from either of the lower nodes to the upper node.</p><p>Code cross-references are a very important concept, as they facilitate IDA’s generation of <span class="emphasis"><em>control flow graphs</em></span> and <span class="emphasis"><em>function call graphs</em></span>, each of which we discuss later in the chapter.<a class="indexterm" id="IDX-CHP-9-0010"/><a class="indexterm" id="IDX-CHP-9-0011"/><a class="indexterm" id="IDX-CHP-9-0012"/><a class="indexterm" id="IDX-CHP-9-0013"/></p><p>Before we dive into the details of cross-references, it is useful to understand how IDA displays cross-reference information in a disassembly listing. <a class="xref" href="ch09.html#a_basic_cross-reference" title="Figure 9-2. A basic cross-reference">Figure 9-2</a> shows the header line for a disassembled function (<code class="literal">sub_401000</code>) containing a cross-reference as a regular comment (right side of the figure).</p><div class="figure"><a id="a_basic_cross-reference"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e12573"/><img alt="A basic cross-reference" src="httpatomoreillycomsourcenostarchimages854199.png"/></div></div><p class="title">Figure 9-2. A basic cross-reference</p></div><p>The text <code class="literal">CODE XREF</code> indicates that this is a code cross-reference rather than a data cross-reference (<code class="literal">DATA XREF</code>). An address follows, <code class="literal">_main+2A</code> in this case, indicating the address from which the cross-reference originates. Note that this is a more descriptive form of address than <code class="literal">.text:0040154A</code>, for example. While both forms represent the same program location, the format used in the cross-reference offers the additional information that the cross-reference is being made from within the function named <code class="literal">_main</code>, specifically 0x2A (42) bytes into the <code class="literal">_main</code> function. An up or down arrow will always follow the address, indicating the relative direction to the referencing location. In <a class="xref" href="ch09.html#a_basic_cross-reference" title="Figure 9-2. A basic cross-reference">Figure 9-2</a>, the down arrow indicates that <code class="literal">_main+2A</code> lies at a higher address than <code class="literal">sub_401000</code>, and thus you would need to scroll down to reach it. Similarly, an up arrow indicates that a referencing location lies at a lower memory address, requiring that you scroll up to reach it. Finally, every cross-reference comment contains a single-character suffix to identify the type of cross-reference that is being made. Each suffix is described later as we detail all of IDA’s cross-reference types.<a class="indexterm" id="IDX-CHP-9-0014"/><a class="indexterm" id="IDX-CHP-9-0015"/></p><div class="sect2" title="Code Cross-References"><div class="titlepage"><div><div><h2 class="title"><a id="code_cross-references"/>Code Cross-References</h2></div></div></div><p>A code cross-reference is used to indicate that an instruction transfers or may transfer control to another instruction. The manner in which instructions transfer control is referred to as a <span class="emphasis"><em>flow</em></span> within IDA. IDA distinguishes among three basic flow types: <span class="emphasis"><em>ordinary</em></span>, <span class="emphasis"><em>jump</em></span>, and <span class="emphasis"><em>call</em></span>. Jump and call flows are further divided according to whether the target address is a near or far address. Far addresses are encountered only in binaries that make use of segmented addresses. In the discussion that follows, we make use of the disassembled version of the following program:<a class="indexterm" id="IDX-CHP-9-0016"/><a class="indexterm" id="IDX-CHP-9-0017"/></p><a id="I_programlisting6_d1e12636"/><pre class="programlisting">int read_it;            //integer variable read in main
int write_it;           //integer variable written 3 times in main
int ref_it;             //integer variable whose address is taken in main

void callflow() {}      //function called twice from main

int main() {
   int *p = &amp;ref_it;    //results in an "offset" style data reference
   *p = read_it;        //results in a "read" style data reference
   write_it = *p;       //results in a "write" style data reference
   callflow();          //results in a "call" style code reference
   if (read_it == 3) {  //results in "jump" style code reference
      write_it = 2;     //results in a "write" style data reference
   }
   else {               //results in an "jump" style code reference
      write_it = 1;     //results in a "write" style data reference
   }
   callflow();          //results in an "call" style code reference
}</pre><p>The program contains operations that will exercise all of IDA’s cross-referencing features, as noted in the comment text.<a class="indexterm" id="IDX-CHP-9-0018"/></p><p>An <span class="emphasis"><em>ordinary flow</em></span> is the simplest flow type, and it represents sequential flow from one instruction to another. This is the default execution flow for all nonbranching instructions such as <code class="literal">ADD</code>. There are no special display indicators for ordinary flows other than the order in which instructions are listed in the disassembly. If instruction A has an ordinary flow to instruction B, then instruction B will immediately follow instruction A in the disassembly listing. In the following listing, every instruction other than <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12651"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12657"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> has an associated ordinary flow to its immediate successor:</p><div class="example"><a id="cross-reference_sources_and_targets"/><p class="title">Example 9-1. Cross-reference sources and targets</p><div class="example-contents"><pre class="programlisting">.text:00401010 _main           proc near
  .text:00401010
  .text:00401010 p               = dword ptr −4
  .text:00401010
  .text:00401010                 push    ebp
  .text:00401011                 mov     ebp, esp
  .text:00401013                 push    ecx
  .text:00401014                <img alt="" src="httpatomoreillycomsourcenostarchimages854135.png"/>mov     [ebp+p], offset ref_it
  .text:0040101B                 mov     eax, [ebp+p]
  .text:0040101E                <img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>mov     ecx, read_it
  .text:00401024                 mov     [eax], ecx
  .text:00401026                 mov     edx, [ebp+p]
  .text:00401029                 mov     eax, [edx]
  .text:0040102B                <img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/>mov     write_it, eax
  .text:00401030                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>call    callflow
  .text:00401035                <img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/>cmp     read_it, 3
  .text:0040103C                 jnz     short loc_40104A
  .text:0040103E                <img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/>mov     write_it, 2
  .text:00401048                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>jmp     short loc_401054
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>
 .text:0040104A ; -------------------------------------------------------------
  .text:0040104A
  .text:0040104A loc_40104A:                         <img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>; CODE XREF: _main+2C↑j
  .text:0040104A                <img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/>mov     write_it, 1
  .text:00401054
  .text:00401054 loc_401054:                         <img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>; CODE XREF: _main+38↑j
  .text:00401054                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>call    callflow
  .text:00401059                 xor     eax, eax
    .text:0040105B                 mov     esp, ebp
  .text:0040105D                 pop     ebp
  .text:0040105E                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>retn
  .text:0040105E _main           endp</pre></div></div><p>Instructions used to invoke functions, such as the x86 <code class="literal">call</code> instructions at <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12753"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, are assigned a <span class="emphasis"><em>call flow</em></span>, indicating transfer of control to the target function. In most cases, an ordinary flow is also assigned to <code class="literal">call</code> instructions, as most functions return to the location that follows the <code class="literal">call</code>. If IDA believes that a function does not return (as determined during the analysis phase), then calls to that function will not have an ordinary flow assigned. Call flows are noted by the display of cross-references at the target function (the destination address of the flow). The resulting disassembly of the <code class="literal">callflow</code> function is shown here:<a class="indexterm" id="IDX-CHP-9-0019"/><a class="indexterm" id="IDX-CHP-9-0020"/><a class="indexterm" id="IDX-CHP-9-0021"/><a class="indexterm" id="IDX-CHP-9-0022"/><a class="indexterm" id="IDX-CHP-9-0023"/><a class="indexterm" id="IDX-CHP-9-0024"/><a class="indexterm" id="IDX-CHP-9-0025"/></p><a id="I_programlisting6_d1e12795"/><pre class="programlisting">.text:00401000 callflow        proc near               ; CODE XREF: _main+20↓p
.text:00401000                                         ; _main:loc_401054↓p
.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 pop     ebp
.text:00401004                 retn
.text:00401004 callflow        endp</pre><p>In this example, two cross-references are displayed at the address of <code class="literal">callflow</code> to indicate that the function is called twice. The address displayed in the cross-references is displayed as an offset into the calling function unless the calling address has an associated name, in which case the name is used. Both forms of addresses are used in the cross-references shown here. Cross-references resulting from function calls are distinguished through use of the <code class="literal">p</code> suffix (think <span class="emphasis"><em>P</em></span> for <span class="emphasis"><em>Procedure</em></span>).</p><p>A <span class="emphasis"><em>jump flow</em></span> is assigned to each unconditional and conditional branch instruction. Conditional branches are also assigned ordinary flows to account for control flow when the branch is not taken. Unconditional branches have no associated ordinary flow because the branch is always taken in such cases. The dashed line break at <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12816"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> is a display device used to indicate that an ordinary flow does not exist between two adjacent instructions. Jump flows are associated with jump-style cross-references displayed at the target of the jump, as shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12822"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>. As with call-style cross-references, jump cross-references display the address of the referring location (the source of the jump). Jump cross-references are distinguished by the use of a <code class="literal">j</code> suffix (think <span class="emphasis"><em>J</em></span> for <span class="emphasis"><em>Jump</em></span>).<a class="indexterm" id="IDX-CHP-9-0026"/><a class="indexterm" id="IDX-CHP-9-0027"/><a class="indexterm" id="IDX-CHP-9-0028"/><a class="indexterm" id="IDX-CHP-9-0029"/></p></div><div class="sect2" title="Data Cross-References"><div class="titlepage"><div><div><h2 class="title"><a id="data_cross-references"/>Data Cross-References</h2></div></div></div><p>Data cross-references are used to track the manner in which data is accessed within a binary. Data cross-references can be associated with any byte in an IDA database that is associated with a virtual address (in other words, data cross-references are never associated with stack variables). The three most commonly encountered types of data cross-references are used to indicate when a location is being read, when a location is being written, and when the address of a location is being taken. The global variables associated with the previous example program are shown here, as they provide several examples of data cross-references.<a class="indexterm" id="IDX-CHP-9-0030"/><a class="indexterm" id="IDX-CHP-9-0031"/><a class="indexterm" id="IDX-CHP-9-0032"/></p><a id="I_programlisting6_d1e12864"/><pre class="programlisting">.data:0040B720 read_it       dd ?                    ; DATA XREF: _main+E↑r
.data:0040B720                                       ; _main+25↑r
.data:0040B724 write_it      dd ?                    ; DATA XREF: _main+1B↑w
.data:0040B724                                     <img alt="" src="httpatomoreillycomsourcenostarchimages854201.png"/> ; _main+2E↑w ...
.data:0040B728 ref_it        db    ? ;               ; DATA XREF: _main+4↑o
.data:0040B729               db    ? ;
.data:0040B72A               db    ? ;
.data:0040B72B               db    ? ;</pre><p>A <span class="emphasis"><em>read cross-reference</em></span> is used to indicate that the contents of a memory location are being accessed. Read cross-references can originate only from an instruction address but may refer to any program location. The global variable <code class="literal">read_it</code> is read at locations marked <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12880"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> in <a class="xref" href="ch09.html#cross-reference_sources_and_targets" title="Example 9-1. Cross-reference sources and targets">Example 9-1</a>. The associated cross-reference comments shown in this listing indicate exactly which locations in <code class="literal">main</code> are referencing <code class="literal">read_it</code> and are recognizable as read cross-references based on the use of the <code class="literal">r</code> suffix. The first read performed on <code class="literal">read_it</code> is a 32-bit read into the ECX register, which leads IDA to format <code class="literal">read_it</code> as a dword (<code class="literal">dd</code>). In general IDA takes as many cues as it possibly can in order to determine the size and/or type of variables based on how they are accessed and how they are used as parameters to functions.<a class="indexterm" id="IDX-CHP-9-0033"/></p><p>The global variable <code class="literal">write_it</code> is referenced at the locations marked <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12915"/><img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/></span> in <a class="xref" href="ch09.html#cross-reference_sources_and_targets" title="Example 9-1. Cross-reference sources and targets">Example 9-1</a>. Associated <span class="emphasis"><em>write cross-references</em></span> are generated and displayed as comments for the <code class="literal">write_it</code> variable, indicating the program locations that modify the contents of the variable. Write cross-references utilize the <code class="literal">w</code> suffix. Here again, IDA has determined the size of the variable based on the fact that the 32-bit EAX register is copied into <code class="literal">write_it</code>. Note that the list of cross-references displayed at <code class="literal">write_it</code> terminates with an ellipsis (<span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12939"/><img alt="" src="httpatomoreillycomsourcenostarchimages854201.png"/></span> above), indicating that the number of cross-references to <code class="literal">write_it</code> exceeds the current display limit for cross-references. This limit can be modified through the Number of displayed xrefs setting on the Cross-references tab in the Options ▸ General dialog. As with read cross-references, write cross-references can originate only from a program instruction but may reference any program location. Generally speaking, a write cross-reference that targets a program instruction byte is indicative of self-modifying code, which is usually considered bad form and is frequently encountered in the de-obfuscation routines used in malware.<a class="indexterm" id="IDX-CHP-9-0034"/><a class="indexterm" id="IDX-CHP-9-0035"/></p><p>The third type of data cross-reference, an <span class="emphasis"><em>offset cross-reference</em></span>, indicates that the address of a location is being used (rather than the content of the location). The address of global variable <code class="literal">ref_it</code> is taken at location <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12963"/><img alt="" src="httpatomoreillycomsourcenostarchimages854135.png"/></span> in <a class="xref" href="ch09.html#cross-reference_sources_and_targets" title="Example 9-1. Cross-reference sources and targets">Example 9-1</a>, resulting in the offset cross-reference comment at <code class="literal">ref_it</code> in the previous listing (suffix <code class="literal">o</code>). Offset cross-references are commonly the result of pointer operations either in code or in data. Array access operations, for example, are typically implemented by adding an offset to the starting address of the array. As a result, the first address in most global arrays can often be recognized by the presence of an offset cross-reference. For this reason, most string data (strings being arrays of characters in C/C++) is the target of offset cross-references.<a class="indexterm" id="IDX-CHP-9-0036"/><a class="indexterm" id="IDX-CHP-9-0037"/></p><p>Unlike read and write cross-references, which can originate only from instruction locations, offset cross-references can originate from either instruction locations or data locations. An example of an offset that can originate from a program’s data section is any table of pointers (such as a vtable) that results in the generation of an offset cross-reference from each location within the table to the location being pointed to by those locations. You can see this if you examine the vtable for class <code class="literal">SubClass</code> from <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>, whose disassembly is shown here:</p><a id="I_programlisting6_d1e12995"/><pre class="programlisting">.rdata:00408148 off_408148  dd offset SubClass::vfunc1
(void) ; DATA XREF: SubClass::SubClass(void)+12↑o
.rdata:0040814C          dd offset BaseClass::vfunc2(void)
.rdata:00408150          dd offset SubClass::vfunc3(void)
.rdata:00408154          dd offset BaseClass::vfunc4(void)
.rdata:00408158          dd offset SubClass::vfunc5(void)</pre><p>Here you see that the address of the vtable is used in the function <code class="literal">SubClass::SubClass(void)</code>, which is the class constructor. The header lines for function <code class="literal">SubClass::vfunc3(void)</code>, shown here, show the offset cross-reference that links the function to a vtable.</p><a id="I_programlisting6_d1e13005"/><pre class="programlisting">.text:00401080 public: virtual void __thiscall SubClass::vfunc3(void) proc near
.text:00401080                                      ; DATA XREF: .rdata:00408150↓o</pre><p>This example demonstrates one of the characteristics of C++ virtual functions that becomes quite obvious when combined with offset cross-references, namely that C++ virtual functions are never called directly and should never be the target of a call cross-reference. Instead, all C++ virtual functions should be referred to by at least one vtable entry and should always be the target of at least one offset cross-reference. Remember that overriding a virtual function is not mandatory. Therefore, a virtual function can appear in more than one vtable, as discussed in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>. Backtracking offset cross-references is one technique for easily locating C++ vtables in a program’s data section.<a class="indexterm" id="IDX-CHP-9-0038"/></p></div><div class="sect2" title="Cross-Reference Lists"><div class="titlepage"><div><div><h2 class="title"><a id="cross-reference_lists"/>Cross-Reference Lists</h2></div></div></div><p>With an understanding of what cross-references are, we can now discuss the manner in which you may access all of this data within IDA. As mentioned previously, the number of cross-reference comments that can be displayed at a given location is limited by a configuration setting that defaults to 2. As long as the number of cross-references to a location does not exceed this limit, then working with those cross-references is fairly straightforward. Mousing over the cross-reference text displays the disassembly of the source region in a tool tip–style display, while double-clicking the cross-reference address jumps the disassembly window to the source of the cross-reference.<a class="indexterm" id="IDX-CHP-9-0039"/><a class="indexterm" id="IDX-CHP-9-0040"/></p><p>There are two methods for viewing the complete list of cross-references to a location. The first method is to open a cross-references subview associated with a specific address. By positioning the cursor on an address that is the target of one or more cross-references and selecting View ▸ Open Subviews ▸ Cross-References, you can open the complete list of cross-references to a given location, as shown in <a class="xref" href="ch09.html#cross-reference_display_window" title="Figure 9-3. Cross-reference display window">Figure 9-3</a>, which shows the complete list of cross-references to variable <code class="literal">write_it</code>.<a class="indexterm" id="IDX-CHP-9-0041"/><a class="indexterm" id="IDX-CHP-9-0042"/><a class="indexterm" id="IDX-CHP-9-0043"/><a class="indexterm" id="IDX-CHP-9-0044"/></p><div class="figure"><a id="cross-reference_display_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13052"/><img alt="Cross-reference display window" src="httpatomoreillycomsourcenostarchimages854203.png.jpg"/></div></div><p class="title">Figure 9-3. Cross-reference display window</p></div><p>The columns of the window indicate the direction (Up or Down) to the source of the cross-reference, the type of cross-reference (using the type suffixes discussed previously), the source address of the cross-reference, and the corresponding disassembled text at the source address, including any comments that may exist at the source address. As with other windows that display lists of addresses, double-clicking any entry repositions the disassembly display to the corresponding source address. Once opened, the cross-reference display window remains open and accessible via a title tab displayed along with every other open subview’s title tab above the disassembly area.<a class="indexterm" id="IDX-CHP-9-0045"/></p><p>The second way to access a list of cross-references is to highlight a name that you are interested in learning about and choose Jump ▸ Jump to xref (hotkey <span class="keycap">ctrl</span>-X) to open a dialog that lists every location that references the selected symbol. The resulting dialog, shown in <a class="xref" href="ch09.html#jump_to_cross-reference_dialog" title="Figure 9-4. Jump to cross-reference dialog">Figure 9-4</a>, is nearly identical in appearance to the cross-reference subview shown in <a class="xref" href="ch09.html#cross-reference_display_window" title="Figure 9-3. Cross-reference display window">Figure 9-3</a>. In this case, the dialog was activated using the <span class="keycap">ctrl</span>-X hotkey with the first instance of <code class="literal">write_it</code> (<code class="literal">.text:0040102B</code>) selected.</p><div class="figure"><a id="jump_to_cross-reference_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13086"/><img alt="Jump to cross-reference dialog" src="httpatomoreillycomsourcenostarchimages854205.png.jpg"/></div></div><p class="title">Figure 9-4. Jump to cross-reference dialog</p></div><p>The primary difference in the two displays is behavioral. Being a modal dialog,<sup>[<a class="footnote" href="#ftn.CHP-9-FN-1" id="CHP-9-FN-1">52</a>]</sup> the display in <a class="xref" href="ch09.html#jump_to_cross-reference_dialog" title="Figure 9-4. Jump to cross-reference dialog">Figure 9-4</a> has buttons to interact with and terminate the dialog. The primary purpose of this dialog is to select a referencing location and jump to it. Double-clicking one of the listed locations dismisses the dialog and repositions the disassembly window at the selected location. The second difference between the dialog and the cross-reference subview is that the former can be opened using a hotkey or context-sensitive menu from any instance of a symbol, while the latter can be opened only when you position the cursor on an address that is the target of a cross-reference and choose View ▸ Open Subviews ▸ Cross-References. Another way of thinking about it is that the dialog can be opened at the source of any cross-reference, while the subview can be opened only at the destination of the cross-reference.<a class="indexterm" id="IDX-CHP-9-0046"/><a class="indexterm" id="IDX-CHP-9-0047"/><a class="indexterm" id="IDX-CHP-9-0048"/><a class="indexterm" id="IDX-CHP-9-0049"/><a class="indexterm" id="IDX-CHP-9-0050"/><a class="indexterm" id="IDX-CHP-9-0051"/></p><p>An example of the usefulness of cross-reference lists might be to rapidly locate every location from which a particular function is called. Many people consider the use of the C <code class="literal">strcpy</code><sup>[<a class="footnote" href="#ftn.CHP-9-FN-2" id="CHP-9-FN-2">53</a>]</sup> function to be dangerous. Using cross-references, locating every call to <code class="literal">strcpy</code> is as simple as finding any one call to <code class="literal">strcpy</code>, using the <span class="keycap">ctrl</span>-X hotkey to bring up the cross-reference dialog, and working your way through every call cross-reference. If you don’t want to take the time to find <code class="literal">strcpy</code> used somewhere in the binary, you can even get away with adding a comment with the text <span class="emphasis"><em>strcpy</em></span> in it and activating the cross-reference dialog using the comment.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-3" id="CHP-9-FN-3">54</a>]</sup></p></div><div class="sect2" title="Function Calls"><div class="titlepage"><div><div><h2 class="title"><a id="function_calls"/>Function Calls</h2></div></div></div><p>A specialized cross-reference listing dealing exclusively with function calls is available by choosing View ▸ Open Subviews ▸ Function Calls. <a class="xref" href="ch09.html#function_calls_window" title="Figure 9-5. Function calls window">Figure 9-5</a> shows the resulting dialog, which lists all locations that call the current function (as defined by the cursor location at the time the view is opened) in the upper half of the window and all calls made by the current function in the lower half of the window.</p><div class="figure"><a id="function_calls_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13163"/><img alt="Function calls window" src="httpatomoreillycomsourcenostarchimages854207.png"/></div></div><p class="title">Figure 9-5. Function calls window</p></div><p>Here again, each listed cross-reference can be used to quickly reposition the disassembly listing to the corresponding cross-reference location. Restricting ourselves to considering function call cross-references allows us to think about more abstract relationships than simple mappings from one address to another and instead consider how functions relate to one another. In the next section, we show how IDA takes advantage of this by providing several types of graphs, all designed to assist you in interpreting a binary.<a class="indexterm" id="IDX-CHP-9-0052"/><a class="indexterm" id="IDX-CHP-9-0053"/><a class="indexterm" id="IDX-CHP-9-0054"/><a class="indexterm" id="IDX-CHP-9-0055"/><a class="indexterm" id="IDX-CHP-9-0056"/><a class="indexterm" id="IDX-CHP-9-0057"/><a class="indexterm" id="IDX-CHP-9-0058"/><a class="indexterm" id="IDX-CHP-9-0059"/><a class="indexterm" id="IDX-CHP-9-0060"/><a class="indexterm" id="IDX-CHP-9-0061"/><a class="indexterm" id="IDX-CHP-9-0062"/><a class="indexterm" id="IDX-CHP-9-0063"/><a class="indexterm" id="IDX-CHP-9-0064"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-1" id="ftn.CHP-9-FN-1">52</a>] </sup>A modal dialog must be closed before you can continue normal interaction with the underlying application. Modeless dialogs can remain open while you continue normal interaction with the application.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-2" id="ftn.CHP-9-FN-2">53</a>] </sup>The <code class="literal">C strcpy</code> function copies a source array of characters, up to and including the associated null termination character, to a destination array, with no checks whatsoever that the destination array is large enough to hold all of the characters from the source.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-3" id="ftn.CHP-9-FN-3">54</a>] </sup>When a symbol name appears in a comment, IDA treats that symbol just as if it was an operand in a disassembled instruction. Double-clicking the symbol repositions the disassembly window, and the right-click context-sensitive menu becomes available.</p></div></div></div>
<div class="sect1" title="IDA Graphing"><div class="titlepage"><div><div><h1 class="title"><a id="ida_graphing"/>IDA Graphing</h1></div></div></div><p>Because cross-references relate one address to another, they are a natural place to begin if we want to make graphs of our binaries. By restricting ourselves to specific types of cross-references, we can derive a number of useful graphs for analyzing our binaries. For starters, cross-references serve as the edges (the lines that connect points) in our graphs. Depending on the type of graph we wish to generate, individual nodes (the points in the graph) can be individual instructions, groups of instructions called <span class="emphasis"><em>basic blocks</em></span>, or entire functions. IDA has two distinct graphing capabilities: an external graphing capability utilizing a bundled graphing application and an integrated, interactive graphing capability. Both of these graphing capabilities are covered in the following sections.<a class="indexterm" id="IDX-CHP-9-0065"/></p><div class="sect2" title="IDA External (Third-Party) Graphing"><div class="titlepage"><div><div><h2 class="title"><a id="ida_external_open_parenthesis_third-part"/>IDA External (Third-Party) Graphing</h2></div></div></div><p>IDA’s external graphing capability utilizes third-party graphing applications to display IDA-generated graph files. For Windows versions prior to 6.1, IDA ships with a bundled graphing application named <code class="literal">wingraph32</code>.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-4" id="CHP-9-FN-4">55</a>]</sup> For IDA 6.0, non-Windows versions of IDA are configured to use the dotty<sup>[<a class="footnote" href="#ftn.CHP-9-FN-5" id="CHP-9-FN-5">56</a>]</sup> graph viewer by default. Beginning with IDA 6.1, all versions of IDA ship with and are configured to use the <code class="literal">qwingraph</code><sup>[<a class="footnote" href="#ftn.CHP-9-FN-6" id="CHP-9-FN-6">57</a>]</sup> graph viewer, which is a cross-platform Qt port of <code class="literal">wingraph32</code>. While the dotty configuration options remain visible for Linux users, they are commented out by default. The graph viewer used by IDA may be configured by editing the GRAPH_VISUALIZER variable in <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/ida.cfg</em></span>.<a class="indexterm" id="IDX-CHP-9-0066"/><a class="indexterm" id="IDX-CHP-9-0067"/><a class="indexterm" id="IDX-CHP-9-0068"/></p><p>Whenever an external-style graph is requested, the source for the graph is generated and saved to a temporary file; then the designated third-party graph viewer is launched to display the graph. IDA supports two graph specification languages, Graph Description Language<sup>[<a class="footnote" href="#ftn.CHP-9-FN-7" id="CHP-9-FN-7">58</a>]</sup> (GDL) and the DOT<sup>[<a class="footnote" href="#ftn.CHP-9-FN-8" id="CHP-9-FN-8">59</a>]</sup> language utilized by the graphviz<sup>[<a class="footnote" href="#ftn.CHP-9-FN-9" id="CHP-9-FN-9">60</a>]</sup> project. The graph specification language used by IDA may be configured by editing the <code class="literal">GRAPH_FORMAT</code> variable in <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/ida.cfg</em></span>. Legal values for this variable are <code class="literal">DOT</code> and <code class="literal">GDL</code>. You must ensure that the language you specify here is compatible with the viewer you have specified in <code class="literal">GRAPH_VISUALIZER</code>.<a class="indexterm" id="IDX-CHP-9-0069"/><a class="indexterm" id="IDX-CHP-9-0070"/></p><p>Five types of graphs may be generated from the View ▸ Graphs submenu. Available external mode graphs include the following:<a class="indexterm" id="IDX-CHP-9-0071"/><a class="indexterm" id="IDX-CHP-9-0072"/><a class="indexterm" id="IDX-CHP-9-0073"/><a class="indexterm" id="IDX-CHP-9-0074"/><a class="indexterm" id="IDX-CHP-9-0075"/><a class="indexterm" id="IDX-CHP-9-0076"/><a class="indexterm" id="IDX-CHP-9-0077"/><a class="indexterm" id="IDX-CHP-9-0078"/><a class="indexterm" id="IDX-CHP-9-0079"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Function flowchart</p></li><li class="listitem"><p>Call graph for the entire binary</p></li><li class="listitem"><p>Graph of cross-references to a symbol</p></li><li class="listitem"><p>Graph of cross-references from a symbol</p></li><li class="listitem"><p>Customized cross-reference graph</p></li></ul></div><p>For two of these, the flowchart and the call graph, IDA is capable of generating and saving GDL (not DOT) files for use independently of IDA. These options may be found on the File ▸ Produce file submenu. Saving the specification file for other types of graphs may be possible if your configured graph viewer allows you to save the currently displayed graph. A number of limitations exist when dealing with any external graph. First and foremost is the fact that external graphs are not interactive. Manipulation of displayed external graphs is limited by the capabilities of your chosen external graph viewer (often only zooming and panning).</p><div class="sidebar"><a id="basic_blocks"/><p class="title">BASIC BLOCKS</p><p>In a computer program, a <span class="emphasis"><em>basic block</em></span> is a grouping of one or more instructions with a single entry to the beginning of the block and a single exit from the end of the block. In general, other than the last instruction, every instruction within a basic block transfers control to exactly one <span class="emphasis"><em>successor</em></span> instruction within the block. Similarly, other than the first instruction, every instruction in a basic block receives control from exactly one <span class="emphasis"><em>predecessor</em></span> instruction within the block. For the purposes of basic block determination, the fact that function call instructions transfer control outside the current function is generally ignored unless it is known that the function being called fails to return normally. An important behavioral characteristic of basic blocks is that once the first instruction in a basic block is executed, the remainder of the block is guaranteed to execute to completion. This can factor significantly into runtime instrumentation of a program, since it is no longer necessary to set a breakpoint on every instruction in a program or even single-step the program in order to record which instructions have executed. Instead, breakpoints can be set on the first instruction of each basic block, and as each breakpoint is hit, every instruction in its associated block can be marked as executed. The Process Stalker component of Pedram Amini’s PaiMei<sup>[<a class="footnote" href="#ftn.CHP-9-FN-10" id="CHP-9-FN-10">61</a>]</sup> framework performs in exactly this manner.</p></div><div class="sect3" title="External Flowcharts"><div class="titlepage"><div><div><h3 class="title"><a id="external_flowcharts"/>External Flowcharts</h3></div></div></div><p>With the cursor positioned within a function, View ▸ Graphs ▸ Flow Chart (hotkey F12) generates and displays an external flowchart. The flowchart display is the external graph that most closely resembles IDA’s integrated graph-based disassembly view. These are not the flowcharts you may have been taught during an introductory programming class. Instead, these graphs might better be named “control flow graphs,” as they group a function’s instructions into basic blocks and use edges to indicate flow from one block to another.<a class="indexterm" id="IDX-CHP-9-0080"/></p><p><a class="xref" href="ch09s02.html#external_flowchart_graph" title="Figure 9-6. External flowchart graph">Figure 9-6</a> shows a portion of the flowchart of a relatively simple function. As you can see, external flowcharts offer very little in the way of address information, which can make it difficult to correlate the flowchart view to its corresponding disassembly listing.</p><div class="figure"><a id="external_flowchart_graph"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13398"/><img alt="External flowchart graph" src="httpatomoreillycomsourcenostarchimages854209.png"/></div></div><p class="title">Figure 9-6. External flowchart graph</p></div><p>Flowchart graphs are derived by following the ordinary and jump flows for each instruction in a function, beginning with the entry point to the function.<a class="indexterm" id="IDX-CHP-9-0081"/></p></div><div class="sect3" title="External Call Graphs"><div class="titlepage"><div><div><h3 class="title"><a id="external_call_graphs"/>External Call Graphs</h3></div></div></div><p>A function call graph is useful for gaining a quick understanding of the hierarchy of function calls made within a program. Call graphs are generated by creating a graph node for each function and then connecting function nodes based on the existence of a call cross-reference from one function to another. The process of generating a call graph for a single function can be viewed as a recursive descent through all of the functions that are called from the initial function. In many cases, it is sufficient to stop descending the call tree once a library function is reached, as it is easier to learn how the library function operates by reading documentation associated with the library rather than by attempting to reverse engineer the compiled version of the function. In fact, in the case of a dynamically linked binary it is not possible to descend into library functions, since the code for such functions is not present within the dynamically linked binary. Statically linked binaries present a different challenge when generating graphs. Since statically linked binaries contain all of the code for the libraries that have been linked to the program, related function call graphs can become extremely large.<a class="indexterm" id="IDX-CHP-9-0082"/><a class="indexterm" id="IDX-CHP-9-0083"/><a class="indexterm" id="IDX-CHP-9-0084"/><a class="indexterm" id="IDX-CHP-9-0085"/><a class="indexterm" id="IDX-CHP-9-0086"/><a class="indexterm" id="IDX-CHP-9-0087"/></p><p>In order to discuss function call graphs, we make use of the following trivial program that does nothing other than create a simple hierarchy of function calls:</p><a id="I_programlisting6_d1e13441"/><pre class="programlisting">#include &lt;stdio.h&gt;

void depth_2_1() {
   printf("inside depth_2_1\n");
}

void depth_2_2() {
   fprintf(stderr, "inside depth_2_2\n");
}

void depth_1() {
   depth_2_1();
   depth_2_2();
   printf("inside depth_1\n");
}

int main() {
   depth_1();
}</pre><p>After compiling a dynamically linked binary using GNU gcc, we can ask IDA to generate a function call graph using View ▸ Graphs ▸ Function Calls, which should yield a graph similar to that shown in <a class="xref" href="ch09s02.html#external_function_call_graph" title="Figure 9-7. External function call graph">Figure 9-7</a>. In this instance we have truncated the left side of the graph somewhat in order to offer a bit more detail. The call graph associated with the <code class="literal">main</code> function can be seen within the circled area in the figure.</p><div class="figure"><a id="external_function_call_graph"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13453"/><img alt="External function call graph" src="httpatomoreillycomsourcenostarchimages854211.png.jpg"/></div></div><p class="title">Figure 9-7. External function call graph</p></div><p>Alert readers may notice that the compiler has substituted calls to <code class="literal">puts</code> and <code class="literal">fwrite</code> for <code class="literal">printf</code> and <code class="literal">fprintf</code>, respectively, as they are more efficient when printing static strings. Note that IDA utilizes different colors to represent different types of nodes in the graph, though the colors are not configurable in any way.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-11" id="CHP-9-FN-11">62</a>]</sup><a class="indexterm" id="IDX-CHP-9-0088"/><a class="indexterm" id="IDX-CHP-9-0089"/><a class="indexterm" id="IDX-CHP-9-0090"/></p><p>Given the straightforward nature of the previous program listing, why does the graph appear to be twice as crowded as it should be? The answer is that the compiler, as virtually all compilers do, has inserted wrapper code responsible for library initialization and termination as well as for configuring parameters properly prior to transferring control to the <code class="literal">main</code> function.<a class="indexterm" id="IDX-CHP-9-0091"/></p><p>Attempting to graph a statically linked version of the same program results in the nasty mess shown in <a class="xref" href="ch09s02.html#function_call_graph_in_a_statically_link" title="Figure 9-8. Function call graph in a statically linked binary">Figure 9-8</a>.</p><p>The graph in <a class="xref" href="ch09s02.html#function_call_graph_in_a_statically_link" title="Figure 9-8. Function call graph in a statically linked binary">Figure 9-8</a> demonstrate a behavior of external graphs in general, namely that they are always scaled initially to display the entire graph, which can result in very cluttered displays. For this particular graph, the status bar at the bottom of the WinGraph32 window indicates that there are 946 nodes and 10,125 edges that happen to cross over one another in 100,182 locations. Other than demonstrating the complexity of statically linked binaries, this graph is all but unusable. No amount of zooming and panning will simplify the graph, and beyond that, there is no way to easily locate a specific function such as <code class="literal">main</code> other than by reading the label on each node. By the time you have zoomed in enough to be able to read the labels associated with each node, only a few dozen nodes will fit within the display.<a class="indexterm" id="IDX-CHP-9-0092"/></p><div class="figure"><a id="function_call_graph_in_a_statically_link"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13516"/><img alt="Function call graph in a statically linked binary" src="httpatomoreillycomsourcenostarchimages854213.png.jpg"/></div></div><p class="title">Figure 9-8. Function call graph in a statically linked binary</p></div></div><div class="sect3" title="External Cross-Reference Graphs"><div class="titlepage"><div><div><h3 class="title"><a id="external_cross-reference_graphs"/>External Cross-Reference Graphs</h3></div></div></div><p>Two types of cross-reference graphs can be generated for global symbols (functions or global variables): cross-references to a symbol (View ▸ Graphs ▸ Xrefs To) and cross-references from a symbol (View ▸ Graphs ▸ Xrefs From). To generate an Xrefs To graph, a recursive ascent is performed by backtracking all cross-references to the selected symbol until a symbol to which no other symbols refer is reached. When analyzing a binary, you can use an Xrefs To graph to answer the question, “What sequence of calls must be made to reach this function?” <a class="xref" href="ch09s02.html#xrefs_to_graph" title="Figure 9-9. Xrefs To graph">Figure 9-9</a> shows the use of an Xrefs To graph to display the paths that can be followed to reach the <code class="literal">puts</code> function.<a class="indexterm" id="IDX-CHP-9-0093"/><a class="indexterm" id="IDX-CHP-9-0094"/></p><div class="figure"><a id="xrefs_to_graph"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13540"/><img alt="Xrefs To graph" src="httpatomoreillycomsourcenostarchimages854215.png"/></div></div><p class="title">Figure 9-9. Xrefs To graph</p></div><p>Similarly, Xrefs To graphs can assist you in visualizing all of the locations that reference a global variable and the chain of function calls required to reach those locations. Cross-reference graphs are the only graphs capable of incorporating data cross-reference information.</p><p>In order to create an Xrefs From graph, a recursive descent is performed by following cross-references from the selected symbol. If the symbol is a function name, only call references from the function are followed, so data references to global variables do not show up in the graph. If the symbol is an initialized global pointer variable (meaning that it actually points to something), then the corresponding data offset cross-reference is followed. When you graph cross-references from a function, the effective behavior is a function call graph rooted at the selected function, as shown in <a class="xref" href="ch09s02.html#xrefs_from_graph" title="Figure 9-10. Xrefs From graph">Figure 9-10</a>.<a class="indexterm" id="IDX-CHP-9-0095"/></p><p>Unfortunately, the same cluttered graph problems exist when graphing functions with a complex call graph.</p><div class="figure"><a id="xrefs_from_graph"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13559"/><img alt="Xrefs From graph" src="httpatomoreillycomsourcenostarchimages854217.png"/></div></div><p class="title">Figure 9-10. Xrefs From graph</p></div></div><div class="sect3" title="Custom Cross-Reference Graphs"><div class="titlepage"><div><div><h3 class="title"><a id="custom_cross-reference_graphs"/>Custom Cross-Reference Graphs</h3></div></div></div><p>Custom cross-reference graphs, called <span class="emphasis"><em>User xref charts</em></span> in IDA, provide the maximum flexibility in generating cross-reference graphs to suit your needs. In addition to combining cross-references to a symbol and cross-references from a symbol into a single graph, custom cross-reference graphs allow you to specify a maximum recursion depth and the types of symbols that should be included or excluded from the resulting graph.<a class="indexterm" id="IDX-CHP-9-0096"/><a class="indexterm" id="IDX-CHP-9-0097"/><a class="indexterm" id="IDX-CHP-9-0098"/></p><p>View ▸ Graphs ▸ User Xrefs Chart opens the graph customization dialog shown in <a class="xref" href="ch09s02.html#user_cross-reference_graph_dialog" title="Figure 9-11. User cross-reference graph dialog">Figure 9-11</a>. Each global symbol that occurs within the specified address range appears as a node within the resulting graph, which is constructed according to the options specified in the dialog. In the most common case, generating cross-references from a single symbol, the start and end addresses are identical. If the start and end addresses differ, then the resulting graph is generated for all nonlocal symbols that occur within the specified range. In the extreme case where the start address is the lowest address in the database and the end address is the highest address in the database, the resulting graph degenerates to the function call graph for the entire binary.</p><div class="figure"><a id="user_cross-reference_graph_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13592"/><img alt="User cross-reference graph dialog" src="httpatomoreillycomsourcenostarchimages854219.png.jpg"/></div></div><p class="title">Figure 9-11. User cross-reference graph dialog</p></div><p>The options that are selected in <a class="xref" href="ch09s02.html#user_cross-reference_graph_dialog" title="Figure 9-11. User cross-reference graph dialog">Figure 9-11</a> represent the default options for all custom cross-reference graphs. Following is a description of the purpose of each set of options:<a class="indexterm" id="IDX-CHP-9-0099"/><a class="indexterm" id="IDX-CHP-9-0100"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Starting direction</strong></span></span></dt><dd><p>Options allow you to decide whether to search for cross-references from the selected symbol, to the selected symbol, or both. If all other options are left at their default settings, restricting the starting direction to Cross references to results in an Xrefs To–style graph, while restricting direction to Cross references from generates an Xrefs From–style graph.</p></dd><dt><span class="term"><span class="strong"><strong>Parameters</strong></span></span></dt><dd><p>The Recursive option enables recursive descent (Xrefs From) or ascent (Xrefs To) from the selected symbols. Follow only current direction forces any recursion to occur in only one direction. In other words, if this option is selected, and node B is discovered to be reachable from node A, the recursive descent into B adds additional nodes that can be reached only <span class="emphasis"><em>from</em></span> node B. Newly discovered nodes that refer <span class="emphasis"><em>to</em></span> node B will not be added to the graph. If you choose to deselect Follow only current direction, then when both starting directions are selected, each new node added to the graph is recursed in both the <span class="emphasis"><em>to</em></span> and <span class="emphasis"><em>from</em></span> directions.<a class="indexterm" id="IDX-CHP-9-0101"/></p></dd><dt><span class="term"><span class="strong"><strong>Recursion depth</strong></span></span></dt><dd><p>This option sets the maximum recursion depth and is useful for limiting the size of generated graphs. A setting of −1 causes recursion to proceed as deep as possible and generates the largest possible graphs.</p></dd><dt><span class="term"><span class="strong"><strong>Ignore</strong></span></span></dt><dd><p>These options dictate what types of nodes will be excluded from the generated graph. This is another means of restricting the size of the resulting graph. In particular, ignoring cross-references from library functions can lead to drastic simplifications of graphs in statically linked binaries. The trick is to make sure that IDA recognizes as many library functions as possible. Library code recognition is the subject of <a class="xref" href="ch12.html" title="Chapter 12. Library Recognition Using FLIRT Signatures">Chapter 12</a>.<a class="indexterm" id="IDX-CHP-9-0102"/></p></dd><dt><span class="term"><span class="strong"><strong>Print options</strong></span></span></dt><dd><p>These options control two aspects of graph formatting. Print comments causes any function comments to be included in a function’s graph node. If Print recursion dots is selected and recursion would continue beyond the specified recursion limit, a node containing an ellipsis is displayed to indicate that further recursion is possible.<a class="indexterm" id="IDX-CHP-9-0103"/></p></dd></dl></div><p><a class="xref" href="ch09s02.html#user_xref_graph_for_function_depth_under" title="Figure 9-12. User xref graph for function depth_1">Figure 9-12</a> shows a custom cross-reference graph generated for function <code class="literal">depth_1</code> in our example program using default options and a recursion depth of 1.</p><div class="figure"><a id="user_xref_graph_for_function_depth_under"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13677"/><img alt="User xref graph for function depth_1" src="httpatomoreillycomsourcenostarchimages854221.png"/></div></div><p class="title">Figure 9-12. User xref graph for function <code class="literal">depth_1</code></p></div><p>User-generated cross-reference graphs are the most powerful external-mode graphing capability available in IDA. External flowcharts have largely been superseded by IDA’s integrated graph-based disassembly view, and the remaining external graph types are simply canned versions of user-generated cross-reference graphs.<a class="indexterm" id="IDX-CHP-9-0104"/><a class="indexterm" id="IDX-CHP-9-0105"/><a class="indexterm" id="IDX-CHP-9-0106"/><a class="indexterm" id="IDX-CHP-9-0107"/><a class="indexterm" id="IDX-CHP-9-0108"/></p></div></div><div class="sect2" title="IDA’s Integrated Graph View"><div class="titlepage"><div><div><h2 class="title"><a id="idaas_integrated_graph_view"/>IDA’s Integrated Graph View</h2></div></div></div><p>With version 5.0, IDA introduced a long-awaited interactive, graph-based disassembly view that was tightly integrated into IDA. As mentioned previously, the integrated graphing mode provides an alternative interface to the standard text-style disassembly listing. While in graph mode, disassembled functions are displayed as control flow graphs similar to external-style flowchart graphs. Because a function-oriented control flow graph is used, only one function at a time can be displayed while in graph mode, and graph mode cannot be used for instructions that lie outside any function. For cases in which you wish to view several functions at once, or when you need to view instructions that are not part of a function, you must revert to the text-oriented disassembly listing.<a class="indexterm" id="IDX-CHP-9-0109"/><a class="indexterm" id="IDX-CHP-9-0110"/><a class="indexterm" id="IDX-CHP-9-0111"/></p><p>We detailed basic manipulation of the graph view in <a class="xref" href="ch05.html" title="Chapter 5. IDA Data Displays">Chapter 5</a>, but we reiterate a few points here. Switching between text view and graph view is accomplished by pressing the spacebar or right-clicking anywhere in the disassembly window and selecting either Text View or Graph View as appropriate. The easiest way to pan around the graph is to click the background of the graph view and drag the graph in the appropriate direction. For large graphs, you may find it easier to pan using the Graph Overview window instead. The Graph Overview window always displays a dashed rectangle around the portion of the graph currently being displayed in the disassembly window. At any time, you can click and drag the dashed rectangle to reposition the graph display. Because the graph overview window displays a miniature version of the entire graph, using it for panning eliminates the need to constantly release the mouse button and reposition the mouse as required when panning across large graphs in the disassembly window.<a class="indexterm" id="IDX-CHP-9-0112"/></p><p>There are no significant differences between manipulating a disassembly in graph mode and manipulating a disassembly in text mode. Double-click navigation continues to work as you would expect it to, as does the navigation history list. Any time you navigate to a location that does not lie within a function (such as a global variable), the display will automatically switch to text mode. Graph mode will automatically be restored once you navigate back to a function. Access to stack variables is identical to that of text mode, with the summary stack view being displayed in the root basic block of the displayed function. Detailed stack frame views are accessed by double-clicking any stack variable, just as in text mode. All options for formatting instruction operands in text mode remain available and are accessed in the same manner in graph mode.<a class="indexterm" id="IDX-CHP-9-0113"/><a class="indexterm" id="IDX-CHP-9-0114"/></p><p>The primary user interface change related to graph mode deals with the handing of individual graph nodes. <a class="xref" href="ch09s02.html#typical_expanded_graph_view_node" title="Figure 9-13. Typical expanded graph view node">Figure 9-13</a> shows a simple graph node and its related title bar button controls.<a class="indexterm" id="IDX-CHP-9-0115"/></p><div class="figure"><a id="typical_expanded_graph_view_node"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13742"/><img alt="Typical expanded graph view node" src="httpatomoreillycomsourcenostarchimages854223.png"/></div></div><p class="title">Figure 9-13. Typical expanded graph view node</p></div><p>From left to right, the three buttons on the node’s title bar allow you to change the background color of the node, assign or change the name of the node, and access the list of cross-references to the node. Coloring nodes is a useful way to remind yourself that you have already analyzed a node or to simply make it stand out from others, perhaps because it contains code of particular interest. Once you assign a node a color, the color is also used as the background color for the corresponding instructions in text mode. To easily remove any coloring, right-click the node’s title bar and select <span class="strong"><strong>Set node color to default</strong></span>.<a class="indexterm" id="IDX-CHP-9-0116"/></p><p>The middle button on the title bar in <a class="xref" href="ch09s02.html#typical_expanded_graph_view_node" title="Figure 9-13. Typical expanded graph view node">Figure 9-13</a> is used to assign a name to the address of the first instruction of the node’s basic block. Since basic blocks are often the target of jump instructions, many nodes may already have a dummy name assigned as the result of being targeted by a jump cross-reference. However, it is possible for a basic block to begin without having a name assigned. Consider the following lines of code:</p><a id="I_programlisting6_d1e13759"/><pre class="programlisting">.text:00401041               <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>jg      short loc_401053
.text:00401043               <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     ecx, [ebp+arg_0]</pre><p>The instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13775"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> has two potential successors, <code class="literal">loc_401053</code> and the instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13784"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Because it has two successors, <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13790"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> must terminate a basic block, which results in <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13796"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> becoming the first instruction in a new basic block, even though it is not targeted explicitly by a jump and thus has no dummy name assigned.</p><p>The rightmost button in <a class="xref" href="ch09s02.html#typical_expanded_graph_view_node" title="Figure 9-13. Typical expanded graph view node">Figure 9-13</a> is used to access the list of cross-references that target the node. Since cross-reference comments are not displayed by default in graph mode, this is the easiest way to access and navigate to any location that references the node. Unlike the cross-reference lists we have discussed previously, the generated node cross-reference list also contains an entry for the ordinary flow into the node (designated by type <code class="literal">^</code>). This is required because it is not always obvious in graph view which node is the linear predecessor of a given node. If you wish to view normal cross-reference comments in graph mode, access the Cross-References tab under Options ▸ General and set the Number of displayed xrefs option to something other than zero.<a class="indexterm" id="IDX-CHP-9-0117"/><a class="indexterm" id="IDX-CHP-9-0118"/><a class="indexterm" id="IDX-CHP-9-0119"/><a class="indexterm" id="IDX-CHP-9-0120"/><a class="indexterm" id="IDX-CHP-9-0121"/><a class="indexterm" id="IDX-CHP-9-0122"/><a class="indexterm" id="IDX-CHP-9-0123"/><a class="indexterm" id="IDX-CHP-9-0124"/></p><p>Nodes within a graph may be <span class="emphasis"><em>grouped</em></span> either by themselves or with other nodes in order to reduce some of the clutter in a graph. To group multiple nodes, <span class="keycap">ctrl</span>-click the title bar of each node to be grouped and then right-click the title bar of any selected node and select <span class="strong"><strong>Group nodes</strong></span>. You will be prompted to enter some text (defaults to the first instruction in the group) to be displayed in the collapsed node. <a class="xref" href="ch09s02.html#typical_collapsed_open_parenthesis_group" title="Figure 9-14. Typical collapsed (grouped) graph view node">Figure 9-14</a> shows the result of grouping the node in <a class="xref" href="ch09s02.html#typical_expanded_graph_view_node" title="Figure 9-13. Typical expanded graph view node">Figure 9-13</a> and changing the node text to <span class="emphasis"><em>collapsed node demo</em></span>.<a class="indexterm" id="IDX-CHP-9-0125"/></p><div class="figure"><a id="typical_collapsed_open_parenthesis_group"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e13864"/><img alt="Typical collapsed (grouped) graph view node" src="httpatomoreillycomsourcenostarchimages854225.png"/></div></div><p class="title">Figure 9-14. Typical collapsed (grouped) graph view node</p></div><p>Note that two additional buttons are now present in the title bar. In left-to-right order, these buttons allow you to uncollapse (expand) the grouped node and edit the node text. Uncollapsing a node merely expands the nodes within a group to their original form; it does not change the fact that the node or nodes now belong to a group. When a group is uncollapsed, the two new buttons just mentioned are removed and replaced with a single Collapse Group button. An expanded group can easily be collapsed again using the Collapse Group button or by right-clicking the title bar of any node in the group and selecting Hide Group. To completely remove a grouping applied to one or more nodes, you must right-click the title bar of the collapsed node or one of the participating uncollapsed nodes and select <span class="strong"><strong>Ungroup Nodes</strong></span>. This action has the side effect of expanding the group if it was collapsed at the time.<a class="indexterm" id="IDX-CHP-9-0126"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-4" id="ftn.CHP-9-FN-4">55</a>] </sup>Hex-Rays makes the source for <code class="literal">wingraph32</code> available at <a class="ulink" href="http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip">http://www.hex-rays.com/idapro/freefiles/wingraph32_src.zip</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-5" id="ftn.CHP-9-FN-5">56</a>] </sup>dotty is a graph viewing tool included as part of the graphviz project.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-6" id="ftn.CHP-9-FN-6">57</a>] </sup>Hex-Rays makes the source for <code class="literal">qwingraph</code> available at <a class="ulink" href="http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip">http://www.hex-rays.com/idapro/freefiles/qwingraph_src.zip</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-7" id="ftn.CHP-9-FN-7">58</a>] </sup>A GDL reference can be found at <a class="ulink" href="http://www.absint.com/aisee/manual/windows/node58.html">http://www.absint.com/aisee/manual/windows/node58.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-8" id="ftn.CHP-9-FN-8">59</a>] </sup>A DOT reference can be found at <a class="ulink" href="http://www.graphviz.org/doc/info/lang.html">http://www.graphviz.org/doc/info/lang.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-9" id="ftn.CHP-9-FN-9">60</a>] </sup>See <a class="ulink" href="http://www.graphviz.org/">http://www.graphviz.org/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-10" id="ftn.CHP-9-FN-10">61</a>] </sup>Please see <a class="ulink" href="http://pedram.redhive.com/code/paimei/">http://pedram.redhive.com/code/paimei/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-11" id="ftn.CHP-9-FN-11">62</a>] </sup>The graphs depicted in this chapter have been edited outside of IDA to remove node coloring for the purposes of improving readability.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id8"/>Summary</h1></div></div></div><p>Graphs are a powerful tool available to assist you in analyzing any binary. If you are accustomed to viewing disassemblies in pure text format, it may take some time to adjust to using a graph-based display. In IDA, it is generally a matter of realizing that all of the information that was available in the text display remains available in the graph display; however, it may be formatted somewhat differently. Cross-references, for example, become the edges that connect the basic blocks in a graph display.<a class="indexterm" id="IDX-CHP-9-0127"/></p><p>Choosing the proper graph to view plays an important role in optimizing the use of graphs for analysis. If you want to know how a particular function is reached, then you are probably interested in a function call or cross-reference graph. If you want to know how a specific instruction is reached, then you are probably more interested in a control flow graph.</p><p>Some of the frustration that users have experienced in the past with IDA’s graphing capabilities is directly attributable to the inflexibility of the <code class="literal">wingraph32</code> application and its related graphs. These frustrations were addressed in part with the introduction of an integrated graph-based disassembly mode. IDA is primarily a disassembler, however, and graph generation is not its primary purpose. Readers interested in dedicated graph-based analysis tools may wish to investigate applications designed specifically for that purpose, such as BinNavi,<sup>[<a class="footnote" href="#ftn.CHP-9-FN-12" id="CHP-9-FN-12">63</a>]</sup> produced by Halvar Flake’s company Zynamics.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-13" id="CHP-9-FN-13">64</a>]</sup></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-12" id="ftn.CHP-9-FN-12">63</a>] </sup>See <a class="ulink" href="http://www.zynamics.com/binnavi.html">http://www.zynamics.com/binnavi.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-13" id="ftn.CHP-9-FN-13">64</a>] </sup>Note that Zynamics was acquired by Google in March 2011.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;10.&#xA0;The Many Faces of IDA"><div class="titlepage"><div><div><h1 class="title"><a id="the_many_faces_of_ida"/>Chapter 10. The Many Faces of IDA</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id10"/><div class="mediaobject"><a id="I_mediaobject7_d1e13905"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>For many years, the Windows GUI version was the superstar in the IDA stable. Since the release of IDA version 6.0 this is no longer the case, as Linux and OS X users can now enjoy GUI versions of IDA for their platforms. However, this new version in no way changes the fact that there are several alternative ways to use IDA. The original version of IDA was actually an MS-DOS console application, and the console version remains available on all platforms to this day. With built-in remote debugging capabilities, IDA is a powerful multiplatform analysis and debugging tool.<a class="indexterm" id="IDX-CHP-10-0001"/></p><p>Beyond its interactive capabilities, IDA offers a batch-processing mode in all of its versions to facilitate automated processing of large numbers of files. The key to effective batch processing with IDA is to understand what each version can and cannot do and choose the appropriate version of IDA to suit your requirements. In this chapter we discuss IDA’s console version and how to make the most of IDA’s batch-processing facilities.</p><div class="sect1" title="Console Mode IDA"><div class="titlepage"><div><div><h1 class="title"><a id="console_mode_ida"/>Console Mode IDA</h1></div></div></div><p>The heart of all console versions of IDA is a Borland-developed, console I/O library called <span class="emphasis"><em>TVision</em></span> that has been ported to several platforms, including Windows, Linux, and Mac OS X, among others. Hex-Rays makes the source code for its current TVision port available to paying IDA customers on its IDA download page.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-1" id="CHP-10-FN-1">65</a>]</sup><a class="indexterm" id="IDX-CHP-10-0002"/><a class="indexterm" id="IDX-CHP-10-0003"/><a class="indexterm" id="IDX-CHP-10-0004"/><a class="indexterm" id="IDX-CHP-10-0005"/><a class="indexterm" id="IDX-CHP-10-0006"/><a class="indexterm" id="IDX-CHP-10-0007"/><a class="indexterm" id="IDX-CHP-10-0008"/><a class="indexterm" id="IDX-CHP-10-0009"/><a class="indexterm" id="IDX-CHP-10-0010"/><a class="indexterm" id="IDX-CHP-10-0011"/><a class="indexterm" id="IDX-CHP-10-0012"/></p><p>The use of a common library across all platforms keeps the user interface consistent on all of the console versions. There are a few annoyances to deal with in moving from platform to platform, however, such as varying degrees of support for the mouse, resizing, and the ability to pass hotkeys to the IDA application. We discuss some of the problems and, when available, workarounds in the platform-specific sections that follow.</p><div class="sect2" title="Common Features of Console Mode"><div class="titlepage"><div><div><h2 class="title"><a id="common_features_of_console_mode"/>Common Features of Console Mode</h2></div></div></div><p>As the term <span class="emphasis"><em>console mode</em></span> implies, the text-based versions of IDA all run within a terminal or shell of some sort. These consoles may have varying degrees of support for resizing and the use of a mouse, resulting in limitations that you will need to learn to live with. The types of limitations depend on which platform and terminal program you are using.<a class="indexterm" id="IDX-CHP-10-0013"/><a class="indexterm" id="IDX-CHP-10-0014"/></p><p>The console user interface consists of a menu bar across the top line of the display to show menu options and status and a common operations bar across the bottom line of the display that’s similar to a text-based toolbar. Available operations are activated using hotkeys or, when supported, by clicking the mouse. Virtually every command available in the GUI version is available in some form in the console version, and most of the hotkey associations are preserved as well.</p><p>The IDA display windows consume the space between the upper menu bar and the lower command bar. However, a common limitation, regardless of which terminal program you happen to use, is that there is little display room when the screen is limited to roughly 80 by 25 characters and no graphics. Therefore, console versions of IDA typically open only two display windows by default: the disassembly window and the messages window. In order to approximate the tabbed display windows found in the GUI version, IDA uses the TVision library’s overlapping windowing capability for text windows and assigns the F6 key (in lieu of window title tabs) to cycle through available open windows. Each window is numbered sequentially, and the window ID is present in the upper left-hand corner.</p><p>When mouse support is available in your console, it is possible to resize an IDA display window by clicking and dragging the lower right corner of the display window to the desired size. To repositioxsn a display window, you click and drag the display’s top border. Lacking mouse support, you can move and resize individual displays via Window ▸ Resize/Move (<span class="keycap">ctrl</span>-F5) and then use your arrow keys to move and <span class="keycap">shift</span>-arrow keys to resize the active window. If your terminal program can be resized using the mouse, IDA recognizes the new terminal size and expands (or shrinks) to fill it as appropriate.<a class="indexterm" id="IDX-CHP-10-0015"/></p><p>Without graphics capability, the integrated graph-based disassembly mode is not available, and no control-flow arrows are displayed in the left margin of the disassembly listing window. However, all subviews available in the GUI version are available in the console versions. As in the GUI version, the majority of subviews are accessible via the View ▸ Open Subviews menu. The one major difference in available displays is that hex dumps are not available as a unique subview. Instead, you can toggle a disassembly to a hex dump and back using Options ▸ Dump/Normal View (<span class="keycap">ctrl</span>-F4). In order to have both a disassembly and a hex view open simultaneously, you must open a second disassembly window (View ▸ Open Subviews ▸ Disassembly) and toggle the new view to a hex dump. Unfortunately, there is no way to synchronize the new hex dump to the existing disassembly view.<a class="indexterm" id="IDX-CHP-10-0016"/><a class="indexterm" id="IDX-CHP-10-0017"/><a class="indexterm" id="IDX-CHP-10-0018"/><a class="indexterm" id="IDX-CHP-10-0019"/><a class="indexterm" id="IDX-CHP-10-0020"/><a class="indexterm" id="IDX-CHP-10-0021"/></p><p>With mouse support, navigating your way around the disassembly remains much the same as the GUI version, where double-clicking any name takes you to the corresponding address. Alternatively, positioning the cursor on a name and pressing <span class="keycap">enter</span> causes the display to jump to the corresponding named location (this also happens to work in the GUI version). Pressing <span class="keycap">enter</span> while the cursor is positioned on the name of a stack variable opens the detailed stack frame view for the associated function. Without mouse support, the menus work similarly to many other console applications, employing the <span class="keycap">alt</span>-<span class="emphasis"><em>x</em></span> method of menu navigation, where <span class="emphasis"><em>x</em></span> is a highlighted character on the current screen.</p></div><div class="sect2" title="Windows Console Specifics"><div class="titlepage"><div><div><h2 class="title"><a id="windows_console_specifics"/>Windows Console Specifics</h2></div></div></div><p>The Windows <span class="emphasis"><em>cmd.exe</em></span> (<span class="emphasis"><em>command.exe</em></span> on the Windows 9<span class="emphasis"><em>x</em></span> family) terminal is not terribly flexible, but it is fairly well supported by IDA’s console version. The Windows console version of IDA is named <span class="emphasis"><em>idaw.exe</em></span>, while the GUI version is named <span class="emphasis"><em>idag.exe</em></span>. The corresponding versions for 64-bit binaries (available with the advanced version of IDA) are named <span class="emphasis"><em>idaw64.exe</em></span> and <span class="emphasis"><em>idag64.exe</em></span>, respectively.<a class="indexterm" id="IDX-CHP-10-0022"/></p><p>In order for IDA’s mouse support to work in Windows, you must ensure that QuickEdit mode is disabled for the terminal in which you are running IDA. To configure QuickEdit mode as one of the terminal’s properties, right-click the terminal’s title bar and select <span class="strong"><strong>Properties</strong></span>; then deselect <span class="strong"><strong>QuickEdit mode</strong></span> on the Options tab. You must do this prior to launching IDA, as the change will not be recognized while IDA is running.<a class="indexterm" id="IDX-CHP-10-0023"/></p><p>Unlike Linux terminals running under X Windows, <span class="emphasis"><em>cmd.exe</em></span> cannot be expanded by using the mouse to enlarge the window. On Windows only, IDA’s console version offers the Window ▸ Set Video Mode menu option to resize <span class="emphasis"><em>cmd.exe</em></span> to one of six fixed terminal sizes, up to a maximum of 255 by 100.</p><p>While no graph mode is available in the disassembly window, IDA’s external graphing options are available. Selections from the View ▸ Graphs menu will cause IDA to launch the configured graph viewer (such as <code class="literal">qwingraph</code>) to display the resulting graph. For Windows versions of IDA, it is possible to open several graphs at once and continue to use IDA while the graphs are open.<a class="indexterm" id="IDX-CHP-10-0024"/></p></div><div class="sect2" title="Linux Console Specifics"><div class="titlepage"><div><div><h2 class="title"><a id="linux_console_specifics"/>Linux Console Specifics</h2></div></div></div><p>The Linux console version of IDA is named <span class="emphasis"><em>idal</em></span> (or <span class="emphasis"><em>idal64</em></span> for analyzing 64-bit binaries). Prior to IDA 6.0, Linux and OS X console versions were included as standard components of your IDA distribution. As such, when you copy these console versions to your Linux or OS X platform, you must also copy your IDA key file (<span class="emphasis"><em>ida.key</em></span>) so that your console version will run properly. Note that this requires that you install IDA on a Windows machine at least once, even if you never intend to run the Windows version. On Unix-style systems you may alternatively copy your key file to <span class="emphasis"><em>$HOME/.idapro/ida.key</em></span>. If you do not create it, IDA automatically creates the IDA personal settings directory (<span class="emphasis"><em>$HOME/.idapro</em></span>) the first time you launch IDA.<a class="indexterm" id="IDX-CHP-10-0025"/><a class="indexterm" id="IDX-CHP-10-0026"/><a class="indexterm" id="IDX-CHP-10-0027"/><a class="indexterm" id="IDX-CHP-10-0028"/><a class="indexterm" id="IDX-CHP-10-0029"/><a class="indexterm" id="IDX-CHP-10-0030"/><a class="indexterm" id="IDX-CHP-10-0031"/><a class="indexterm" id="IDX-CHP-10-0032"/><a class="indexterm" id="IDX-CHP-10-0033"/><a class="indexterm" id="IDX-CHP-10-0034"/><a class="indexterm" id="IDX-CHP-10-0035"/></p><p>IDA 6.<span class="emphasis"><em>x</em></span> installations are much simpler. Because IDA 6.<span class="emphasis"><em>x</em></span> is purchased for a specific platform, the installation procedure on your platform takes care of installing the GUI version, the console version, and your IDA key file to suitable locations.</p><p>Basic navigation in the Linux version is similar to navigation in the Windows console version; several Linux specifics are addressed in this section. Users’ tastes for Linux terminal programs are as varied as their tastes for Linux distributions in general. IDA includes a file named <span class="emphasis"><em>tvtuning.txt</em></span> that offers some details on how to configure various terminal types, including remote Windows terminal clients such as SecureCRT and PuTTY.<a class="indexterm" id="IDX-CHP-10-0036"/></p><p>One of the biggest challenges that you will face when using Linux terminal programs is making sure that your hotkey sequences are passed all the way to IDA and not captured by the terminal program itself. For example, will <span class="keycap">alt</span>-F open IDA’s File menu or your console’s File menu? The two options for dealing with this problem are to find a terminal program whose hotkey sequences don’t overlap IDA’s (or that can be configured not to overlap) or to edit IDA’s configuration file to remap commands to hotkeys that are not used by your terminal. If you choose to remap the hotkeys, you may want to update the hotkey mappings on every computer on which you use IDA so that you don’t have to remember which mapping is in effect at each location. You may also find it difficult to interact with other IDA users who are using the default mappings.</p><p>If you choose to use the standard Linux text display, the dimensions of your IDA console will be fixed, and your mouse support will be dependent on your use of GPM (the Linux console mouse server). If you are not using GPM for mouse support, you should specify the <code class="literal">noGPM</code> option for TVision when you launch IDA, as shown here:</p><a id="I_programlisting7_d1e14206"/><pre class="programlisting"># TVOPT=noGPM ./idal [file to disassemble]</pre><p>Color choices are quite limited in console mode, and you may need to adjust your color settings (Options ▸ Colors) to ensure that all text is visible and does not blend into the background. Four predefined color palettes are available, with the option to customize the colors (a choice of 16) used for various parts of the disassembly.<a class="indexterm" id="IDX-CHP-10-0037"/></p><p>If you are running X, then you may be running KDE’s <code class="literal">konsole</code>, Gnome’s <code class="literal">gnome-terminal</code>, a straight <code class="literal">xterm</code>, or some other variation on a terminal. Other than <code class="literal">xterm</code>, most terminals offer their own menus and associated hotkeys that may or may not overlap IDA’s hotkey assignments. Consequently, <code class="literal">xterm</code> is not a bad choice for running IDA, although it is not necessarily the most visually appealing. KDE’s <code class="literal">konsole</code> is our preferred Linux console as it offers the best appearance, fewest hotkey collisions, and smoothest mouse performance.<a class="indexterm" id="IDX-CHP-10-0038"/><a class="indexterm" id="IDX-CHP-10-0039"/><a class="indexterm" id="IDX-CHP-10-0040"/><a class="indexterm" id="IDX-CHP-10-0041"/><a class="indexterm" id="IDX-CHP-10-0042"/><a class="indexterm" id="IDX-CHP-10-0043"/><a class="indexterm" id="IDX-CHP-10-0044"/><a class="indexterm" id="IDX-CHP-10-0045"/><a class="indexterm" id="IDX-CHP-10-0046"/><a class="indexterm" id="IDX-CHP-10-0047"/><a class="indexterm" id="IDX-CHP-10-0048"/></p><p>In order to address some of the problems surrounding keyboard and mouse use within various X Windows consoles, Jeremy Cooper developed a native X11 port<sup>[<a class="footnote" href="#ftn.CHP-10-FN-2" id="CHP-10-FN-2">66</a>]</sup> of the TVision libraries. Using this modified version of TVision allows you to launch IDA in its own X window rather than consume an entire console. Compiling Cooper’s TVision port yields a drop in replacement for libtvision.so, the shared TVision library used by <code class="literal">idal</code>. After installing the new library, you may receive an error message stating that a VGA font can’t be loaded when you attempt to run IDA. If this happens, you will need to install a VGA font and let your X server know where to find it. A suitable VGA font is available at <a class="ulink" href="http://gilesorr.com/bashprompt/xfonts/">http://gilesorr.com/bashprompt/xfonts/</a> (download both <code class="literal">vga</code> and <code class="literal">sabvga</code>). Another interesting feature of using the native X11 port is that you can forward the X11 window to another machine. Thus, you can run IDA on Linux but forward the X11 window (over <code class="literal">ssh</code> of course) to a Mac.<a class="indexterm" id="IDX-CHP-10-0049"/><a class="indexterm" id="IDX-CHP-10-0050"/><a class="indexterm" id="IDX-CHP-10-0051"/></p><p>For remote access to your Linux-based IDA installation using the Hex-Rays–supplied TVision libraries, we recommend that you configure your terminal software to emulate an xterm (consult <span class="emphasis"><em>tvtuning.txt</em></span> and your terminal emulator’s documentation for more information) and then launch IDA according to the instructions contained in <span class="emphasis"><em>tvtuning.txt</em></span>. For example, you must specify <code class="literal">TVOPT=xtrack</code> in order for the mouse to work with IDA when using SecureCRT as your terminal emulator.<a class="indexterm" id="IDX-CHP-10-0052"/><a class="indexterm" id="IDX-CHP-10-0053"/><a class="indexterm" id="IDX-CHP-10-0054"/></p><p>You can, of course, choose to export your <code class="literal">TVOPT</code> settings, eliminating the need to specify them every time you launch IDA. For a full overview of available TVision options, refer to <span class="emphasis"><em>linux.cpp</em></span> in the TVision source distribution.</p><p>External graph views on Linux are available from the console version only if you happen to be running IDA in a windowing environment, and you have configured the <code class="literal">GRAPH_VISUALIZER</code> variable in <span class="emphasis"><em>ida.cfg</em></span> to point to a suitable graph rendering program.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-3" id="CHP-10-FN-3">67</a>]</sup> IDA versions prior to 6.0 are only capable of generating graphs using GDL. You may install a GDL viewer such as aiSee<sup>[<a class="footnote" href="#ftn.CHP-10-FN-4" id="CHP-10-FN-4">68</a>]</sup> and configure IDA to launch the new application by editing IDA’s main configuration file, <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/ida.cfg</em></span>. The configuration option <code class="literal">GRAPH_VISUALIZER</code> specifies the command to be used to view IDA’s GDL graphs (all legacy mode graphs). The default setting looks something like this:<a class="indexterm" id="IDX-CHP-10-0055"/></p><a id="I_programlisting7_d1e14363"/><pre class="programlisting">GRAPH_VISUALIZER        = "qwingraph.exe -remove -timelimit 10"</pre><p>The <code class="literal">remove</code> option asks <code class="literal">qwingraph</code> to delete the input file, which is useful when you are displaying temporary files. The <code class="literal">timelimit</code> option specifies the number of seconds to spend attempting to generate a pretty graph. If the graph cannot be laid out neatly within this time, <code class="literal">qwingraph</code> switches to a “fast and ugly”<sup>[<a class="footnote" href="#ftn.CHP-10-FN-5" id="CHP-10-FN-5">69</a>]</sup> layout algorithm. Beginning with IDA 6.0, the <code class="literal">GRAPH_VISUALIZER</code> option is enclosed in a conditional block to provide separate settings for Windows and non-Windows platforms. If you are editing <span class="emphasis"><em>ida.cfg</em></span> on a non-Windows platform, make sure that you are editing the correct portion of the file. If you have installed a GDL viewer such as aiSee, then you need to edit <code class="literal">GRAPH_VISUALIZER</code> to point to your viewer of choice. For a typical installation of aiSee, this might result in the following:<a class="indexterm" id="IDX-CHP-10-0056"/><a class="indexterm" id="IDX-CHP-10-0057"/><a class="indexterm" id="IDX-CHP-10-0058"/><a class="indexterm" id="IDX-CHP-10-0059"/><a class="indexterm" id="IDX-CHP-10-0060"/><a class="indexterm" id="IDX-CHP-10-0061"/><a class="indexterm" id="IDX-CHP-10-0062"/><a class="indexterm" id="IDX-CHP-10-0063"/><a class="indexterm" id="IDX-CHP-10-0064"/></p><a id="I_programlisting7_d1e14434"/><pre class="programlisting">GRAPH_VISUALIZER  = "/usr/local/bin/aisee"</pre><p>Note that it is always best to specify the full path to your GDL viewer to ensure that it is found when IDA attempts to launch it. Finally, since <code class="literal">qwingraph</code> is open source software, users of older versions of IDA are free to download the source for <code class="literal">qwingraph</code> from Hex-Rays (see <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a>), build it, and integrate <code class="literal">qwingraph</code> into their IDA installations.</p></div><div class="sect2" title="OS X Console Specifics"><div class="titlepage"><div><div><h2 class="title"><a id="os_x_console_specifics"/>OS X Console Specifics</h2></div></div></div><p>IDA’s console versions for OS X are named the same as the Linux versions (<span class="emphasis"><em>idal</em></span> and <span class="emphasis"><em>idal64</em></span>). As with the Linux and Windows console versions, the OS X versions rely on the TVision library to support console I/O.<a class="indexterm" id="IDX-CHP-10-0065"/><a class="indexterm" id="IDX-CHP-10-0066"/></p><p>The fact that the Mac keyboard has a different layout than a PC keyboard presents a few challenges when running the Mac version of IDA, primarily because the Mac’s <span class="keycap">option</span>/<span class="keycap">alt</span> key does not behave like the PC’s <span class="keycap">alt</span> key where application menus are concerned.</p><p>The obvious choice for attempting to run IDA is the Mac’s Terminal application. When launching IDA using Terminal, be sure to configure the <span class="keycap">option</span> key as an <span class="keycap">alt</span> key for use within IDA. Doing so allows keyboard access to IDA <span class="keycap">alt</span> key shortcuts, such as all of the main IDA menus (<span class="keycap">alt</span>-F for the File menu, for example). If you don’t select this option, you’ll have to use the <span class="keycap">esc</span> key in lieu of <span class="keycap">alt</span>; thus, <span class="keycap">esc</span>-F brings up the File menu. Since <span class="keycap">esc</span> has back or close-window functionality in IDA, this approach is not recommended. <a class="xref" href="ch10.html#mac_os_x_terminal_keyboard_settings_dial" title="Figure 10-1. Mac OS X Terminal keyboard settings dialog">Figure 10-1</a> shows the Terminal Inspector dialog, which is accessed via Terminal ▸ Preferences when Terminal is active. Select the <span class="strong"><strong>Use option key as meta key</strong></span> checkbox to make the <span class="keycap">option</span> key behave as an <span class="keycap">alt</span> key.</p><p>One potential alternative to Terminal is iTERM,<sup>[<a class="footnote" href="#ftn.CHP-10-FN-6" id="CHP-10-FN-6">70</a>]</sup> which allows the <span class="keycap">alt</span> functionality of the <span class="keycap">option</span> key and enables mouse sup-port as well. Another terminal that many developers seem to like is the gnome terminal, which has been ported<sup>[<a class="footnote" href="#ftn.CHP-10-FN-7" id="CHP-10-FN-7">71</a>]</sup> to X11 on OS X. Since this requires the installation of XCODE and X11, we won’t do more than mention the existence of the port. Using the default Terminal or iTERM should be sufficient for most users.<a class="indexterm" id="IDX-CHP-10-0067"/></p><p>An alternative way to run IDA on OS X is to install X11 (available on your OS X installation disks as an optional package) and Jeremy Cooper’s modified TVision library (libtvision.dylib for OS X) to run IDA as a native X11 application. You may wish to add <span class="emphasis"><em>/usr/X11R6/bin</em></span> to your system PATH (edit PATH in <span class="emphasis"><em>/etc/profile</em></span>) for easier access to X11-related binaries.<a class="indexterm" id="IDX-CHP-10-0068"/><a class="indexterm" id="IDX-CHP-10-0069"/><a class="indexterm" id="IDX-CHP-10-0070"/><a class="indexterm" id="IDX-CHP-10-0071"/><a class="indexterm" id="IDX-CHP-10-0072"/><a class="indexterm" id="IDX-CHP-10-0073"/></p><div class="figure"><a id="mac_os_x_terminal_keyboard_settings_dial"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e14572"/><img alt="Mac OS X Terminal keyboard settings dialog" src="httpatomoreillycomsourcenostarchimages854227.png.jpg"/></div></div><p class="title">Figure 10-1. Mac OS X Terminal keyboard settings dialog</p></div><p>In this configuration, IDA may be launched from an xterm, and it will execute in its own window with full mouse functionality. The problem with the <span class="keycap">option</span>/<span class="keycap">alt</span> key will remain, however, as X11 views this key as <span class="emphasis"><em>Mode_switch</em></span> and fails to pass the key to IDA. Fortunately, X11 allows you to remap keys through the use of the <code class="literal">xmodmap</code> utility. One solution is to create (or edit) a file named <span class="emphasis"><em>.Xmodmap</em></span> in your home directory (something like <span class="emphasis"><em>/Users/idabook/.Xmodmap</em></span>) containing the following commands:</p><a id="I_programlisting7_d1e14598"/><pre class="programlisting">clear Mod1
keycode 66 = Alt_L
keycode 69 = Alt_R
add Mod1 = Alt_L
add Mod1 = Alt_R</pre><p>The default X11 startup script (<span class="emphasis"><em>/etc/X11/xinit/xinitrc</em></span>) contains commands to read <span class="emphasis"><em>.Xmodmap</em></span> whenever you launch X11. If you have created your own <span class="emphasis"><em>.xinitrc</em></span> file, which overrides the default <span class="emphasis"><em>xinitrc</em></span>, you should make sure that it contains a command such as the following; otherwise your <span class="emphasis"><em>.Xmodmap</em></span> file will not be processed.</p><a id="I_programlisting7_d1e14617"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> xmodmap $HOME/.Xmodmap</pre><p>Finally, you need to modify the default settings for X11 to prevent the system from overriding your modified key map. <a class="xref" href="ch10.html#x11_preferences_on_os_x" title="Figure 10-2. X11 Preferences on OS X">Figure 10-2</a> shows the X11 Preferences dialog.<a class="indexterm" id="IDX-CHP-10-0074"/><a class="indexterm" id="IDX-CHP-10-0075"/><a class="indexterm" id="IDX-CHP-10-0076"/><a class="indexterm" id="IDX-CHP-10-0077"/></p><div class="figure"><a id="x11_preferences_on_os_x"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e14644"/><img alt="X11 Preferences on OS X" src="httpatomoreillycomsourcenostarchimages854229.png.jpg"/></div></div><p class="title">Figure 10-2. X11 Preferences on OS X</p></div><p>To prevent the system from overriding your keyboard mappings, you must deselect the middle option: <span class="strong"><strong>Follow system keyboard layout</strong></span>. Once you have made this change, restart X11, and your modified keyboard settings should take effect, making the <span class="keycap">alt</span> key available to access IDA’s menus. You can verify that X11 recognizes the <span class="keycap">alt</span> key by using <code class="literal">xmodmap</code> to print the current list of keyboard modifiers, as follows:</p><a id="I_programlisting7_d1e14663"/><pre class="programlisting">idabook:~ idabook$ xmodmap
  xmodmap:  up to 2 keys per modifier, (keycodes in parentheses):

  shift       Shift_L (0x40),  Shift_R (0x44)
  lock        Caps_Lock (0x41)
  control     Control_L (0x43),  Control_R (0x46)
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> mod1        Alt_L (0x42),  Alt_R (0x45)
  mod2        Meta_L (0x3f)
  mod3
  mod4
  mod5</pre><p>If <code class="literal">mod1</code> does not list <code class="literal">Alt_L</code> and <code class="literal">Alt_R</code>, as shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14682"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, then your key map has not been updated, in which case you should rerun the <code class="literal">xmodmap</code> command listed at <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e14692"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> in the previous code.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-1" id="ftn.CHP-10-FN-1">65</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/idadown.htm">http://www.hex-rays.com/idapro/idadown.htm</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-2" id="ftn.CHP-10-FN-2">66</a>] </sup>See <a class="ulink" href="http://simon.baymoo.org/universe/ida/tvision/">http://simon.baymoo.org/universe/ida/tvision/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-3" id="ftn.CHP-10-FN-3">67</a>] </sup>Refer to <a class="xref" href="ch09s02.html" title="IDA Graphing">IDA Graphing</a> in <a class="xref" href="ch09s02.html" title="IDA Graphing">IDA Graphing</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-4" id="ftn.CHP-10-FN-4">68</a>] </sup>The GDL viewer aiSee is available for many platforms and is free for noncommercial use. It can be found at <a class="ulink" href="http://www.aisee.de/">http://www.aisee.de/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-5" id="ftn.CHP-10-FN-5">69</a>] </sup>See <code class="literal">timelm.c</code> in the <code class="literal">wingraph32</code> or <code class="literal">qwingraph</code> source distribution.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-6" id="ftn.CHP-10-FN-6">70</a>] </sup>See <a class="ulink" href="http://iterm.sourceforge.net/">http://iterm.sourceforge.net/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-7" id="ftn.CHP-10-FN-7">71</a>] </sup>See <a class="ulink" href="http://www.macports.org/">http://www.macports.org/</a>.</p></div></div></div>
<div class="sect1" title="Using IDA&#x2019;s Batch Mode"><div class="titlepage"><div><div><h1 class="title"><a id="using_idaas_batch_mode"/>Using IDA’s Batch Mode</h1></div></div></div><p>All versions of IDA can be executed in batch mode to facilitate automated processing tasks. The primary purpose of using batch mode is to launch IDA, have it run a specific IDC script, and have it terminate once the script completes. Several command-line options are available to control the processing performed during batch mode execution.<a class="indexterm" id="IDX-CHP-10-0078"/><a class="indexterm" id="IDX-CHP-10-0079"/><a class="indexterm" id="IDX-CHP-10-0080"/><a class="indexterm" id="IDX-CHP-10-0081"/><a class="indexterm" id="IDX-CHP-10-0082"/><a class="indexterm" id="IDX-CHP-10-0083"/><a class="indexterm" id="IDX-CHP-10-0084"/></p><p>GUI versions of IDA do not require a console in order to execute, making them very easy to incorporate into virtually any type of automation script or wrapper program. When run in batch mode, the GUI versions of IDA do not display any graphical components. Running the Windows console versions (<span class="emphasis"><em>idaw.exe</em></span> and <span class="emphasis"><em>idaw64.exe</em></span>) generates a full console display that closes automatically when the batch processing is complete. The console display can be suppressed by redirecting output to a null device (NUL for <span class="emphasis"><em>cmd.exe</em></span>, <span class="emphasis"><em>/dev/null</em></span> in cygwin), as shown here:</p><a id="I_programlisting7_d1e14738"/><pre class="programlisting">C:\Program Files\Ida&gt;idaw -B some_program.exe &gt; NUL</pre><p>IDA’s batch mode is controlled by the command-line parameters listed here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">-A</code> option causes IDA to run in autonomous mode, which means that no dialogs requiring user interaction will be displayed. (If you have never clicked through IDA’s license agreement, then the license agreement dialog will be displayed in spite of the presence of this switch.)<a class="indexterm" id="IDX-CHP-10-0085"/></p></li><li class="listitem"><p>The <code class="literal">-c</code> option causes IDA to delete any existing database associated with the file specified on the command line and generate an entirely new database.</p></li><li class="listitem"><p>The <code class="literal">-S</code> option is used to specify which IDC script IDA should execute on startup. To execute <span class="emphasis"><em>myscript.idc</em></span>, the syntax is <code class="literal">-Smyscript.idc</code> (no space between <code class="literal">S</code> and the script name). IDA searches for the named script in the <span class="emphasis"><em>&lt;IDADIR&gt;/idc</em></span> directory. If you have IDAPython properly installed, you may also specify a python script here.</p></li><li class="listitem"><p>The <code class="literal">-B</code> option invokes batch mode and is equivalent to supplying IDA with <code class="literal">-A -c -Sanalysis.idc</code> at execution. The <span class="emphasis"><em>analysis.idc</em></span> script that ships with IDA simply waits for IDA to analyze the file named on the command line before dumping an assembly listing (<span class="emphasis"><em>.asm</em></span> file) of the disassembly and closing IDA in order to save and close the newly generated database.</p></li></ul></div><p>The <code class="literal">-S</code> option is the key to batch mode, as IDA will terminate only if the designated script causes IDA to terminate. If the script does not shut down IDA, then all of the options simply combine to automate the IDA startup process. Scripting with IDC is discussed in <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>.</p><p>Because of limitations with the TVision library used by the Linux and OS X versions of IDA, batch execution must be performed within a TTY console. This makes simple things such as output redirection and background processing impossible. Fortunately, the latest version of TVision recognizes the <code class="literal">TVHEADLESS</code> environment variable, which allows console output (<code class="literal">stdout</code>) to be redirected, as shown here:<a class="indexterm" id="IDX-CHP-10-0086"/></p><a id="I_programlisting7_d1e14809"/><pre class="programlisting"># TVHEADLESS=1 ./idal -B input_file.exe &gt; /dev/null</pre><p>Fully detaching from the console for background execution requires the additional redirection of both <code class="literal">stdin</code> and <code class="literal">stderr</code>.</p><p>Ilfak discusses batch mode in one of his blog posts here: <a class="ulink" href="http://hexblog.com/2007/03/on_batch_analysis.html">http://hexblog.com/2007/03/on_batch_analysis.html</a>. Among other things, he details how to move beyond invoking a single script and discusses how to execute an IDA plug-in from batch mode.</p></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id9"/>Summary</h1></div></div></div><p>While GUI versions of IDA remain the most fully featured versions available, console mode alternatives and batch-processing capabilities offer IDA users tremendous flexibility in creating complex analysis solutions built around IDA’s automated analysis capabilities.</p><p>At this point we have covered all of IDA’s basic capabilities, and it is time to move on to more advanced features. Over the course of the next few chapters we will cover some of IDA’s more useful configuration options and present some additional utilities designed to improve IDA’s binary analysis capabilities.</p></div></body></html>