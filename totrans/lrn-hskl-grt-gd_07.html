<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Making Our Own Types and Type Classes"><div class="titlepage"><div><div><h1 class="title"><a id="making_our_own_types_and_type_classes"/>Chapter 7. Making Our Own Types and Type Classes</h1></div></div></div><p>So far, we’ve run into a lot of data types: <code class="literal">Bool</code>, <code class="literal">Int</code>, <code class="literal">Char</code>, <code class="literal">Maybe</code>, and so on. But how do we make our own? In this chapter, you’ll learn how to create custom types and put them to work!<a id="IDX-CHP-7-0001" class="indexterm"/><a id="IDX-CHP-7-0002" class="indexterm"/><a id="IDX-CHP-7-0003" class="indexterm"/><a id="IDX-CHP-7-0004" class="indexterm"/><a id="IDX-CHP-7-0005" class="indexterm"/><a id="IDX-CHP-7-0006" class="indexterm"/><a id="IDX-CHP-7-0007" class="indexterm"/><a id="IDX-CHP-7-0008" class="indexterm"/><a id="IDX-CHP-7-0009" class="indexterm"/><a id="IDX-CHP-7-0010" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e9944"/><img src="httpatomoreillycomsourcenostarchimages802592.png.jpg" alt="image with no caption"/></div></div><div class="sect1" title="Defining a New Data Type"><div class="titlepage"><div><div><h1 class="title"><a id="defining_a_new_data_type"/>Defining a New Data Type</h1></div></div></div><p>One way to make our own type is to use the <code class="literal">data</code> keyword. Let’s see how the <code class="literal">Bool</code> type is defined in the standard library.</p><a id="I_programlisting7_d1e9960"/><pre class="programlisting">data Bool = False | True</pre><p>Using the <code class="literal">data</code> keyword like this means that a new data type is being defined. The part before the equal sign denotes the type, which in this case is <code class="literal">Bool</code>. The parts after the equal sign are value constructors. They specify the different values that this type can have. The <code class="literal">|</code> is read as <span class="emphasis"><em>or</em></span>. So we can read this as saying that the <code class="literal">Bool</code> type can have a value of <code class="literal">True</code> or <code class="literal">False</code>. Note that both the type name and the value constructors must start with an uppercase letter.<a id="IDX-CHP-7-0011" class="indexterm"/><a id="IDX-CHP-7-0012" class="indexterm"/><a id="IDX-CHP-7-0013" class="indexterm"/><a id="IDX-CHP-7-0014" class="indexterm"/><a id="IDX-CHP-7-0015" class="indexterm"/><a id="IDX-CHP-7-0016" class="indexterm"/><a id="IDX-CHP-7-0017" class="indexterm"/></p><p>In a similar fashion, we can think of the <code class="literal">Int</code> type as being defined like this:</p><a id="I_programlisting7_d1e10022"/><pre class="programlisting">data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647</pre><p>The first and last value constructors are the minimum and maximum possible values of <code class="literal">Int</code>. It’s not actually defined like this—you can see I’ve omitted a bunch of numbers—but this is useful for illustrative purposes.</p><p>Now let’s think about how we would represent a shape in Haskell. One way would be to use tuples. A circle could be denoted as <code class="literal">(43.1, 55.0, 10.4)</code>, where the first and second fields are the coordinates of the circle’s center and the third field is the radius. The problem is that those could also represent a 3D vector or anything else that could be identified by three numbers. A better solution would be to make our own type to represent a shape.</p></div></div>
<div class="sect1" title="Shaping Up"><div class="titlepage"><div><div><h1 class="title"><a id="shaping_up"/>Shaping Up</h1></div></div></div><p>Let’s say that a shape can be a circle or a rectangle. Here’s one possible definition:</p><a id="I_programlisting7_d1e10039"/><pre class="programlisting">data Shape = Circle Float Float Float | Rectangle Float Float Float Float</pre><p>What does it mean? Think of it like this: The <code class="literal">Circle</code> value constructor has three fields, which take floats. So when we write a value constructor, we can optionally add some types after it, and those types define the types of values it will contain. Here, the first two fields are the coordinates of its center, and the third one is its radius. The <code class="literal">Rectangle</code> value constructor has four fields that accept floats. The first two act as the coordinates to its upper-left corner, and the second two act as coordinates to its lower-right corner.</p><p>Value constructors are actually functions that ultimately return a value of a data type. Let’s take a look at the type signatures for these two value constructors.<a id="IDX-CHP-7-0018" class="indexterm"/></p><a id="I_programlisting7_d1e10054"/><pre class="programlisting">ghci&gt; :t Circle
Circle :: Float -&gt; Float -&gt; Float -&gt; Shape
ghci&gt; :t Rectangle
Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape</pre><p>So value constructors are functions like everything else. Who would have thought? The fields that are in the data type act as parameters to its value constructors.</p><p>Now let’s make a function that takes a <code class="literal">Shape</code> and returns its area.<a id="IDX-CHP-7-0019" class="indexterm"/></p><a id="I_programlisting7_d1e10068"/><pre class="programlisting">area :: Shape -&gt; Float
area (Circle _ _ r) = pi * r ^ 2
area (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)</pre><p>First, note the type declaration. It says that the function takes a <code class="literal">Shape</code> and returns a <code class="literal">Float</code>. We couldn’t write a type declaration of <code class="literal">Circle -&gt; Float</code>, because <code class="literal">Circle</code> is not a type, while <code class="literal">Shape</code> is (just as we can’t write a function with a type declaration of <code class="literal">True -&gt; Int</code>, for example).</p><p>Next, notice that we can pattern match against constructors. We’ve already done this against values like <code class="literal">[]</code>, <code class="literal">False</code>, and <code class="literal">5</code>, but those values didn’t have any fields. In this case, we just write a constructor and then bind its fields to names. Because we’re interested in only the radius, we don’t actually care about the first two fields, which tell us where the circle is.</p><a id="I_programlisting7_d1e10103"/><pre class="programlisting">ghci&gt; area $ Circle 10 20 10
314.15927
ghci&gt; area $ Rectangle 0 0 100 100
10000.0</pre><p>Yay, it works! But if we try to just print out <code class="literal">Circle 10 20 5</code> from the prompt, we’ll get an error. That’s because Haskell doesn’t know how to display our data type as a string (yet). Remember that when we try to print a value out from the prompt, Haskell first applies the <code class="literal">show</code> function to it to get the string representation of our value, and then it prints that to the terminal.</p><p>To make our <code class="literal">Shape</code> type part of the <code class="literal">Show</code> type class, we modify it like this:</p><a id="I_programlisting7_d1e10121"/><pre class="programlisting">data Shape = Circle Float Float Float | Rectangle Float Float Float Float
     deriving (Show)</pre><p>We won’t concern ourselves with <code class="literal">deriving</code> too much for now. Let’s just say that if we add <code class="literal">deriving (Show)</code> at the end of a data declaration (it can go on the same line or the next one—it doesn’t matter), Haskell automatically makes that type part of the <code class="literal">Show</code> type class. We’ll be taking a closer look at <code class="literal">deriving</code> in <a class="xref" href="ch07s05.html" title="Derived Instances">Derived Instances</a> in <a class="xref" href="ch07s05.html" title="Derived Instances">Derived Instances</a>.</p><p>So now we can do this:</p><a id="I_programlisting7_d1e10144"/><pre class="programlisting">ghci&gt; Circle 10 20 5
Circle 10.0 20.0 5.0
ghci&gt; Rectangle 50 230 60 90
Rectangle 50.0 230.0 60.0 90.0</pre><p>Value constructors are functions, so we can map them, partially apply them, and so on. If we want a list of concentric circles with different radii, we can do this:<a id="IDX-CHP-7-0020" class="indexterm"/><a id="IDX-CHP-7-0021" class="indexterm"/><a id="IDX-CHP-7-0022" class="indexterm"/><a id="IDX-CHP-7-0023" class="indexterm"/><a id="IDX-CHP-7-0024" class="indexterm"/></p><a id="I_programlisting7_d1e10171"/><pre class="programlisting">ghci&gt; map (Circle 10 20) [4,5,6,6]
[Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0
20.0 6.0]</pre><div class="sect2" title="Improving Shape with the Point Data Type"><div class="titlepage"><div><div><h2 class="title"><a id="improving_shape_with_the_point_data_type"/>Improving Shape with the Point Data Type</h2></div></div></div><p>Our data type is good, but it could be better. Let’s make an intermediate data type that defines a point in two-dimensional space. Then we can use that to make our shapes more understandable.</p><a id="I_programlisting7_d1e10178"/><pre class="programlisting">data Point = Point Float Float deriving (Show)
data Shape = Circle Point Float | Rectangle Point Point deriving (Show)</pre><p>Notice that when defining a point, we used the same name for the data type and the value constructor. This has no special meaning, although it’s common if there’s only one value constructor. So now the <code class="literal">Circle</code> has two fields: One is of type <code class="literal">Point</code> and the other of type <code class="literal">Float</code>. This makes it easier to understand what’s what. The same goes for <code class="literal">Rectangle</code>. Now we need to adjust our <code class="literal">area</code> function to reflect these changes.</p><a id="I_programlisting7_d1e10197"/><pre class="programlisting">area :: Shape -&gt; Float
area (Circle _ r) = pi * r ^ 2
area (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)</pre><p>The only thing we needed to change were the patterns. We disregarded the whole point in the <code class="literal">Circle</code> pattern. In the <code class="literal">Rectangle</code> pattern, we just used nested pattern matching to get the fields of the points. If we wanted to reference the points themselves for some reason, we could have used as-patterns.</p><p>Now we can test our improved version:</p><a id="I_programlisting7_d1e10209"/><pre class="programlisting">ghci&gt; area (Rectangle (Point 0 0) (Point 100 100))
10000.0
ghci&gt; area (Circle (Point 0 0) 24)
1809.5574</pre><p>How about a function that nudges a shape? It takes a shape, the amount to move it on the x axis, and the amount to move it on the y axis. It returns a new shape that has the same dimensions but is located somewhere else.</p><a id="I_programlisting7_d1e10213"/><pre class="programlisting">nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape
nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r
nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b
    = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))</pre><p>This is pretty straightforward. We add the nudge amounts to the points that denote the position of the shape. Let’s test it:<a id="IDX-CHP-7-0025" class="indexterm"/><a id="IDX-CHP-7-0026" class="indexterm"/><a id="IDX-CHP-7-0027" class="indexterm"/><a id="IDX-CHP-7-0028" class="indexterm"/><a id="IDX-CHP-7-0029" class="indexterm"/><a id="IDX-CHP-7-0030" class="indexterm"/><a id="IDX-CHP-7-0031" class="indexterm"/><a id="IDX-CHP-7-0032" class="indexterm"/></p><a id="I_programlisting7_d1e10252"/><pre class="programlisting">ghci&gt; nudge (Circle (Point 34 34) 10) 5 10
Circle (Point 39.0 44.0) 10.0</pre><p>If we don’t want to deal with points directly, we can make some auxiliary functions that create shapes of some size at the zero coordinates and then nudge those.</p><p>First, let’s make a function that takes a radius and makes a circle that is located at the origin of the coordinate system, with the radius we supplied:</p><a id="I_programlisting7_d1e10258"/><pre class="programlisting">baseCircle :: Float -&gt; Shape
baseCircle r = Circle (Point 0 0) r</pre><p>Now let’s make a function that takes a width and a height and makes a rectangle with those dimensions and its bottom-left corner located at the origin:</p><a id="I_programlisting7_d1e10262"/><pre class="programlisting">baseRect :: Float -&gt; Float -&gt; Shape
baseRect width height = Rectangle (Point 0 0) (Point width height)</pre><p>Now we can use these functions to make shapes that are located at the origin of the coordinate system and then nudge them to where we want them to be, which makes it easier to create shapes:</p><a id="I_programlisting7_d1e10266"/><pre class="programlisting">ghci&gt; nudge (baseRect 40 100) 60 23
Rectangle (Point 60.0 23.0) (Point 100.0 123.0)</pre></div><div class="sect2" title="Exporting Our Shapes in a Module"><div class="titlepage"><div><div><h2 class="title"><a id="exporting_our_shapes_in_a_module"/>Exporting Our Shapes in a Module</h2></div></div></div><p>You can also export your data types in your custom modules. To do that, just write your type along with the functions you are exporting, and then add some parentheses that specify the value constructors that you want to export, separated by commas. If you want to export all the value constructors for a given type, just write two dots (<code class="literal">..</code>).</p><p>Suppose we want to export our shape functions and types in a module. We start off like this:</p><a id="I_programlisting7_d1e10278"/><pre class="programlisting">module Shapes
( Point(..)
, Shape(..)
, area
, nudge
, baseCircle
, baseRect
) where</pre><p>By using <code class="literal">Shape(..)</code>, we export all the value constructors for <code class="literal">Shape</code>. This means that people who import our module can make shapes by using the <code class="literal">Rectangle</code> and <code class="literal">Circle</code> value constructors. It’s the same as writing <code class="literal">Shape (Rectangle, Circle)</code>, but shorter.<a id="IDX-CHP-7-0033" class="indexterm"/><a id="IDX-CHP-7-0034" class="indexterm"/><a id="IDX-CHP-7-0035" class="indexterm"/><a id="IDX-CHP-7-0036" class="indexterm"/></p><p>Also, if we decide to add some value constructors to our type later on, we don’t need to modify the exports. That’s because using <code class="literal">..</code> automatically exports all value constructors for a given type.</p><p>Alternatively, we could opt to not export any value constructors for <code class="literal">Shape</code> by just writing <code class="literal">Shape</code> in the export statement, without the parentheses. That way, people who import our module could make shapes only by using the auxiliary functions <code class="literal">baseCircle</code> and <code class="literal">baseRect</code>.</p><p>Remember that value constructors are just functions that take the fields as parameters and return a value of some type (like <code class="literal">Shape</code>). So when we choose not to export them, we prevent the person importing our module from using those value constructors directly. Not exporting the value constructors of our data types makes them more abstract, since we’re hiding their implementation. Also, whoever uses our module can’t pattern match against the value constructors. This is good if we want people who import our module to be able to interact with our type only via the auxiliary functions that we supply in our module. That way, they don’t need to know about the internal details of our module, and we can change those details whenever we want, as long as the functions that we export act the same.</p><p><code class="literal">Data.Map</code> uses this approach. You can’t create a map by directly using its value constructor, whatever it may be, because it’s not exported. However, you can make a map by using one of the auxiliary functions like <code class="literal">Map.fromList</code>. The people in charge of <code class="literal">Data.Map</code> can change the way that maps are internally represented without breaking existing programs.</p><p>But for simpler data types, exporting the value constructors is perfectly fine, too.</p></div></div>
<div class="sect1" title="Record Syntax"><div class="titlepage"><div><div><h1 class="title"><a id="record_syntax"/>Record Syntax</h1></div></div></div><p>Now let’s look at how we can create another kind of data type. Say we’ve been tasked with creating a data type that describes a person. The information that we want to store about that person is first name, last name, age, height, phone number, and favorite ice cream flavor. (I don’t know about you, but that’s all I ever want to know about a person.) Let’s give it a go!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e10358"/><img src="httpatomoreillycomsourcenostarchimages802594.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting7_d1e10363"/><pre class="programlisting">data Person = Person String String Int Float String String deriving (Show)</pre><p>The first field is the first name, the second is the last name, the third is the age, and so on. Now let’s make a person.<a id="IDX-CHP-7-0037" class="indexterm"/></p><a id="I_programlisting7_d1e10372"/><pre class="programlisting">ghci&gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci&gt; guy
Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"</pre><p>That’s kind of cool, although slightly unreadable.</p><p>Now what if we want to create functions to get specific pieces of information about a person? We need a function that gets some person’s first name, a function that gets some person’s last name, and so on. Well, we would need to define them like this:</p><a id="I_programlisting7_d1e10378"/><pre class="programlisting">firstName :: Person -&gt; String
firstName (Person firstname _ _ _ _ _) = firstname

lastName :: Person -&gt; String
lastName (Person _ lastname _ _ _ _) = lastname

age :: Person -&gt; Int
age (Person _ _ age _ _ _) = age

height :: Person -&gt; Float
height (Person _ _ _ height _ _) = height

phoneNumber :: Person -&gt; String
phoneNumber (Person _ _ _ _ number _) = number

flavor :: Person -&gt; String
flavor (Person _ _ _ _ _ flavor) = flavor</pre><p>Whew! I certainly did not enjoy writing that! But despite being very cumbersome and <span class="emphasis"><em>boring</em></span> to write, this method works.</p><a id="I_programlisting7_d1e10385"/><pre class="programlisting">ghci&gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
ghci&gt; firstName guy
"Buddy"
ghci&gt; height guy
184.2
ghci&gt; flavor guy
"Chocolate"</pre><p>“Still, there must be a better way!” you say. Well, no, there isn’t, sorry. Just kidding—there is. Hahaha!</p><p>Haskell gives us an alternative way to write data types. Here’s how we could achieve the same functionality with <span class="emphasis"><em>record syntax</em></span>:<a id="IDX-CHP-7-0038" class="indexterm"/><a id="IDX-CHP-7-0039" class="indexterm"/><a id="IDX-CHP-7-0040" class="indexterm"/><a id="IDX-CHP-7-0041" class="indexterm"/><a id="IDX-CHP-7-0042" class="indexterm"/><a id="IDX-CHP-7-0043" class="indexterm"/></p><a id="I_programlisting7_d1e10421"/><pre class="programlisting">data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     , height :: Float
                     , phoneNumber :: String
                     , flavor :: String } deriving (Show)</pre><p>So instead of just naming the field types one after another and separating them with spaces, we use curly brackets. First, we write the name of the field (for instance, <code class="literal">firstName</code>), followed by a double colon (<code class="literal">::</code>), and then the type. The resulting data type is exactly the same. The main benefit of using this syntax is that it creates functions that look up fields in the data type. By using record syntax to create this data type, Haskell automatically makes these functions: <code class="literal">firstName</code>, <code class="literal">lastName</code>, <code class="literal">age</code>, <code class="literal">height</code>, <code class="literal">phoneNumber</code>, and <code class="literal">flavor</code>. Take a look:</p><a id="I_programlisting7_d1e10450"/><pre class="programlisting">ghci&gt; :t flavor
flavor :: Person -&gt; String
ghci&gt; :t firstName
firstName :: Person -&gt; String</pre><p>There’s another benefit to using record syntax. When we derive <code class="literal">Show</code> for the type, it displays it differently if we use record syntax to define and instantiate the type.</p><p>Say we have a type that represents a car. We want to keep track of the company that made it, the model name, and its year of production. We can define this type without using record syntax, like so:</p><a id="I_programlisting7_d1e10459"/><pre class="programlisting">data Car = Car String String Int deriving (Show)</pre><p>A car is displayed like this:</p><a id="I_programlisting7_d1e10463"/><pre class="programlisting">ghci&gt; Car "Ford" "Mustang" 1967
Car "Ford" "Mustang" 1967</pre><p>Now let’s see what happens when we define it using record syntax:</p><a id="I_programlisting7_d1e10468"/><pre class="programlisting">data Car = Car { company :: String
               , model :: String
               , year :: Int
               } deriving (Show)</pre><p>We can make a car like this:</p><a id="I_programlisting7_d1e10472"/><pre class="programlisting">ghci&gt; Car {company="Ford", model="Mustang", year=1967}
Car {company = "Ford", model = "Mustang", year = 1967}</pre><p>When making a new car, we don’t need to put the fields in the proper order, as long as we list all of them. But if we don’t use record syntax, we must specify them in order.</p><p>Use record syntax when a constructor has several fields and it’s not obvious which field is which. If we make a 3D vector data type by doing <code class="literal">data Vector = Vector Int Int Int</code>, it’s pretty obvious that the fields are the components of a vector. However, in our <code class="literal">Person</code> and <code class="literal">Car</code> types, the fields are not so obvious, and we greatly benefit from using record syntax.</p></div>
<div class="sect1" title="Type Parameters"><div class="titlepage"><div><div><h1 class="title"><a id="type_parameters"/>Type Parameters</h1></div></div></div><p>A value constructor can take some parameters and then produce a new value. For instance, the <code class="literal">Car</code> constructor takes three values and produces a <code class="literal">car</code> value. In a similar manner, type constructors can take types as parameters to produce new types. This might sound a bit too meta at first, but it’s not that complicated. (If you’re familiar with templates in C++, you’ll see some parallels.) To get a clear picture of how type parameters work in action, let’s take a look at how a type we’ve already met is implemented.<a id="IDX-CHP-7-0044" class="indexterm"/><a id="IDX-CHP-7-0045" class="indexterm"/><a id="IDX-CHP-7-0046" class="indexterm"/></p><a id="I_programlisting7_d1e10509"/><pre class="programlisting">data Maybe a = Nothing | Just a</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e10512"/><img src="httpatomoreillycomsourcenostarchimages802596.png.jpg" alt="image with no caption"/></div></div><p>The <code class="literal">a</code> here is the type parameter. And because there’s a type parameter involved, we call <code class="literal">Maybe</code> a <span class="emphasis"><em>type constructor</em></span>. Depending on what we want this data type to hold when it’s not <code class="literal">Nothing</code>, this type constructor can end up producing a type of <code class="literal">Maybe Int</code>, <code class="literal">Maybe Car</code>, <code class="literal">Maybe String</code>, and so on. No value can have a type of just <code class="literal">Maybe</code>, because that’s not a type—it’s a type constructor. In order for this to be a real type that a value can be part of, it must have all its type parameters filled up.</p><p>So if we pass <code class="literal">Char</code> as the type parameter to <code class="literal">Maybe</code>, we get a type of <code class="literal">Maybe Char</code>. The value <code class="literal">Just 'a'</code> has a type of <code class="literal">Maybe Char</code>, for example.</p><p>Most of the time, we don’t pass types as parameters to type constructors explicitly. That’s because Haskell has type inference. So when we make a value <code class="literal">Just 'a'</code>, for example, Haskell figures out that it’s a <code class="literal">Maybe Char</code>.</p><p>If we want to explicitly pass a type as a type parameter, we must do it in the type part of Haskell, which is usually after the <code class="literal">::</code> symbol. This can come in handy if, for example, we want a value of <code class="literal">Just 3</code> to have the type <code class="literal">Maybe Int</code>. By default, Haskell will infer the type <code class="literal">(Num a) =&gt; Maybe a</code> for that value. We can use an explicit type annotation to restrict the type a bit:<a id="IDX-CHP-7-0047" class="indexterm"/><a id="IDX-CHP-7-0048" class="indexterm"/><a id="IDX-CHP-7-0049" class="indexterm"/><a id="IDX-CHP-7-0050" class="indexterm"/></p><a id="I_programlisting7_d1e10602"/><pre class="programlisting">ghci&gt; Just 3 :: Maybe Int
Just 3</pre><p>You might not know it, but we used a type that has a type parameter before we used <code class="literal">Maybe</code>: the list type. Although there’s some syntactic sugar in play, the list type takes a parameter to produce a concrete type. Values can have an <code class="literal">[Int]</code> type, a <code class="literal">[Char]</code> type, or a <code class="literal">[[String]]</code> type, but you can’t have a value that just has a type of <code class="literal">[]</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We say that a type is <span class="emphasis"><em>concrete</em></span> if it doesn’t take any type parameters at all (like <code class="literal">Int</code> or <code class="literal">Bool</code>), or if it takes type parameters and they’re all filled up (like <code class="literal">Maybe Char</code>). If you have some value, its type is always a concrete type.</p></div><p>Let’s play around with the <code class="literal">Maybe</code> type:</p><a id="I_programlisting7_d1e10642"/><pre class="programlisting">ghci&gt; Just "Haha"
Just "Haha"
ghci&gt; Just 84
Just 84
ghci&gt; :t Just "Haha"
Just "Haha" :: Maybe [Char]
ghci&gt; :t Just 84
Just 84 :: (Num a) =&gt; Maybe a
ghci&gt; :t Nothing
Nothing :: Maybe a
ghci&gt; Just 10 :: Maybe Double
Just 10.0</pre><p>Type parameters are useful because they allow us to make data types that can hold different things. For instance, we could make a separate <code class="literal">Maybe</code>-like data type for every type that it could contain, like so:</p><a id="I_programlisting7_d1e10649"/><pre class="programlisting">data IntMaybe = INothing | IJust Int

data StringMaybe = SNothing | SJust String

data ShapeMaybe = ShNothing | ShJust Shape</pre><p>But even better, we could use type parameters to make a generic <code class="literal">Maybe</code> that can contain values of any type at all!</p><p>Notice that the type of <code class="literal">Nothing</code> is <code class="literal">Maybe a</code>. Its type is <span class="emphasis"><em>polymorphic</em></span>, which means that it features type variables, namely the <code class="literal">a</code> in <code class="literal">Maybe a</code>. If some function requires a <code class="literal">Maybe Int</code> as a parameter, we can give it a <code class="literal">Nothing</code>, because a <code class="literal">Nothing</code> doesn’t contain a value anyway, so it doesn’t matter. The <code class="literal">Maybe a</code> type can act like a <code class="literal">Maybe Int</code> if it must, just as <code class="literal">5</code> can act like an <code class="literal">Int</code> or a <code class="literal">Double</code>. Similarly, the type of the empty list is <code class="literal">[a]</code>. An empty list can act like a list of anything. That’s why we can do <code class="literal">[1,2,3] ++ []</code> and <code class="literal">["ha","ha","ha"] ++ []</code>.<a id="IDX-CHP-7-0051" class="indexterm"/></p><div class="sect2" title="Should We Parameterize Our Car?"><div class="titlepage"><div><div><h2 class="title"><a id="should_we_parameterize_our_car_question"/>Should We Parameterize Our Car?</h2></div></div></div><p>When does using type parameters make sense? Usually, we use them when our data type would work regardless of the type of the value it then holds, as with our <code class="literal">Maybe a</code> type. If our type acts as some kind of box, it’s good to use parameters.<a id="IDX-CHP-7-0052" class="indexterm"/></p><p>Consider our <code class="literal">Car</code> data type:</p><a id="I_programlisting7_d1e10729"/><pre class="programlisting">data Car = Car { company :: String
               , model :: String
               , year :: Int
               } deriving (Show)</pre><p>We could change it to this:</p><a id="I_programlisting7_d1e10733"/><pre class="programlisting">data Car a b c = Car { company :: a
                     , model :: b
                     , year :: c
                     } deriving (Show)</pre><p>But would we really benefit? Probably not, because we would just end up defining functions that work on only the <code class="literal">Car String String Int</code> type. For instance, given our first definition of <code class="literal">Car</code>, we could make a function that displays the car’s properties in an easy-to-read format.</p><a id="I_programlisting7_d1e10743"/><pre class="programlisting">tellCar :: Car -&gt; String
tellCar (Car {company = c, model = m, year = y}) =
    "This " ++ c ++ " " ++ m ++ " was made in " ++ show y</pre><p>We could test it like this:</p><a id="I_programlisting7_d1e10747"/><pre class="programlisting">ghci&gt; let stang = Car {company="Ford", model="Mustang", year=1967}
ghci&gt; tellCar stang
"This Ford Mustang was made in 1967"</pre><p>It’s a good little function! The type declaration is cute, and it works nicely.</p><p>Now what if <code class="literal">Car</code> was <code class="literal">Car a b c</code>?<a id="IDX-CHP-7-0053" class="indexterm"/><a id="IDX-CHP-7-0054" class="indexterm"/><a id="IDX-CHP-7-0055" class="indexterm"/><a id="IDX-CHP-7-0056" class="indexterm"/></p><a id="I_programlisting7_d1e10776"/><pre class="programlisting">tellCar :: (Show a) =&gt; Car String String a -&gt; String
tellCar (Car {company = c, model = m, year = y}) =
    "This " ++ c ++ " " ++ m ++ " was made in " ++ show y</pre><p>We would need to force this function to take a <code class="literal">Car</code> type of <code class="literal">(Show a) =&gt; Car String String a</code>. You can see that the type signature is more complicated, and the only actual benefit would be that we could use any type that’s an instance of the <code class="literal">Show</code> type class as the type for <code class="literal">c</code>:</p><a id="I_programlisting7_d1e10792"/><pre class="programlisting">ghci&gt; tellCar (Car "Ford" "Mustang" 1967)
"This Ford Mustang was made in 1967"
ghci&gt; tellCar (Car "Ford" "Mustang" "nineteen sixty seven")
"This Ford Mustang was made in \"nineteen sixty seven\""
ghci&gt; :t Car "Ford" "Mustang" 1967
Car "Ford" "Mustang" 1967 :: (Num t) =&gt; Car [Char] [Char] t
ghci&gt; :t Car "Ford" "Mustang" "nineteen sixty seven"
Car "Ford" "Mustang" "nineteen sixty seven" :: Car [Char] [Char] [Char]</pre><p>In real life though, we would end up using <code class="literal">Car String String Int</code> most of the time. So, parameterizing the <code class="literal">Car</code> type isn’t worth it.</p><p>We usually use type parameters when the type that’s contained inside the data type’s various value constructors isn’t really that important for the type to work. A list of stuff is a list of stuff, and it doesn’t matter what the type of that stuff is. If we need to sum a list of numbers, we can specify later in the summing function that we specifically want a list of numbers. The same goes for <code class="literal">Maybe</code>, which represents an option of either having nothing or having one of something. It doesn’t matter what the type of that something is.</p><p>Another example of a parameterized type that you’ve already met is <code class="literal">Map k v</code> from <code class="literal">Data.Map</code>. The <code class="literal">k</code> is the type of the keys in a map, and <code class="literal">v</code> is the type of the values. This is a good example of where type parameters are very useful. Having maps parameterized enables us to have mappings from any type to any other type, as long as the type of the key is part of the <code class="literal">Ord</code> type class. If we were defining a mapping type, we could add a type class constraint in the data declaration:</p><a id="I_programlisting7_d1e10824"/><pre class="programlisting">data (Ord k) =&gt; Map k v = ...</pre><p>However, it’s a very strong convention in Haskell to never add type class constraints in data declarations. Why? Well, because it doesn’t provide much benefit, and we end up writing more class constraints, even when we don’t need them. If we put the <code class="literal">Ord k</code> constraint in the data declaration for <code class="literal">Map k v</code>, we still need to put the constraint into functions that assume the keys in a map can be ordered. If we don’t put the constraint in the data declaration, then we don’t need to put <code class="literal">(Ord k) =&gt;</code> in the type declarations of functions that don’t care whether the keys can be ordered. An example of such a function is <code class="literal">toList</code>, which just takes a mapping and converts it to an associative list. Its type signature is <code class="literal">toList :: Map k a -&gt; [(k, a)]</code>. If <code class="literal">Map k v</code> had a type constraint in its data declaration, the type for <code class="literal">toList</code> would need to be <code class="literal">toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)]</code>, even though the function doesn’t compare keys by order.<a id="IDX-CHP-7-0057" class="indexterm"/><a id="IDX-CHP-7-0058" class="indexterm"/><a id="IDX-CHP-7-0059" class="indexterm"/><a id="IDX-CHP-7-0060" class="indexterm"/><a id="IDX-CHP-7-0061" class="indexterm"/></p><p>So don’t put type constraints into data declarations, even if it seems to make sense. You’ll need to put them into the function type declarations either way.</p></div><div class="sect2" title="Vector von Doom"><div class="titlepage"><div><div><h2 class="title"><a id="vector_von_doom"/>Vector von Doom</h2></div></div></div><p>Let’s implement a 3D vector type and add some operations for it. We’ll make it a parameterized type, because even though it will usually contain numeric types, it will still support several of them, like <code class="literal">Int</code>, <code class="literal">Integer</code>, and <code class="literal">Double</code>, to name a few.</p><a id="I_programlisting7_d1e10890"/><pre class="programlisting">data Vector a = Vector a a a deriving (Show)

vplus :: (Num a) =&gt; Vector a -&gt; Vector a -&gt; Vector a
(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)

dotProd :: (Num a) =&gt; Vector a -&gt; Vector a -&gt; a
(Vector i j k) `dotProd` (Vector l m n) = i*l + j*m + k*n

vmult :: (Num a) =&gt; Vector a -&gt; a -&gt; Vector a
(Vector i j k) `vmult` m = Vector (i*m) (j*m) (k*m)</pre><p>Imagine a vector as an arrow in space—a line that points somewhere. The vector <code class="literal">Vector 3 4 5</code> would be a line that starts at the coordinates (0,0,0) in 3D space and ends at (and points to) the coordinates (3,4,5).</p><p>The vector functions work as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">vplus</code> function adds two vectors together. This is done just by adding their corresponding components. When you add two vectors, you get a vector that’s the same as putting the second vector at the end of the first one and then drawing a vector from the beginning of the first one to the end of the second one. So adding two vectors together results in a third vector.</p></li><li class="listitem"><p>The <code class="literal">dotProd</code> function gets the dot product of two vectors. The result of a dot product is a number, and we get it by multiplying the components of a vector pairwise and then adding all that together. The dot product of two vectors is useful when we want to figure out the angle between two vectors.</p></li><li class="listitem"><p>The <code class="literal">vmult</code> function multiplies a vector with a number. If we multiply a vector with a number, we multiply every component of the vector with that number, effectively elongating (or shortening it), but it keeps on pointing in the same general direction.</p></li></ul></div><p>These functions can operate on any type in the form of <code class="literal">Vector a</code>, as long as the <code class="literal">a</code> is an instance of the <code class="literal">Num</code> type class. For instance, they can operate on values of type <code class="literal">Vector Int</code>, <code class="literal">Vector Integer</code>, <code class="literal">Vector Float</code>, and so on, because <code class="literal">Int</code>, <code class="literal">Integer</code>, and <code class="literal">Float</code> are all instances of the <code class="literal">Num</code> type class. However, they won’t work on values of type <code class="literal">Vector Char</code> or <code class="literal">Vector Bool</code>.<a id="IDX-CHP-7-0062" class="indexterm"/><a id="IDX-CHP-7-0063" class="indexterm"/><a id="IDX-CHP-7-0064" class="indexterm"/><a id="IDX-CHP-7-0065" class="indexterm"/><a id="IDX-CHP-7-0066" class="indexterm"/><a id="IDX-CHP-7-0067" class="indexterm"/><a id="IDX-CHP-7-0068" class="indexterm"/><a id="IDX-CHP-7-0069" class="indexterm"/><a id="IDX-CHP-7-0070" class="indexterm"/><a id="IDX-CHP-7-0071" class="indexterm"/></p><p>Also, if you examine the type declaration for these functions, you’ll see that they can operate only on vectors of the same type, and the numbers involved must also be of the type that is contained in the vectors. We can’t add together a <code class="literal">Vector Int</code> and a <code class="literal">Vector Double</code>.</p><p>Notice that we didn’t put a <code class="literal">Num</code> class constraint in the data declaration. As explained in the previous section, even if we put it there, we would still need to repeat it in the functions.</p><p>Once again, it’s very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the <code class="literal">=</code> is the type constructor, and the constructors after it (possibly separated by <code class="literal">|</code> characters) are value constructors. For instance, giving a function the following type would be wrong:</p><a id="I_programlisting7_d1e11024"/><pre class="programlisting">Vector a a a -&gt; Vector a a a -&gt; a</pre><p>This doesn’t work because the type of our vector is <code class="literal">Vector a</code>, and not <code class="literal">Vector a a a</code>. It takes only one type parameter, even though its value constructor has three fields.</p><p>Now, let’s play around with our vectors.</p><a id="I_programlisting7_d1e11037"/><pre class="programlisting">ghci&gt; Vector 3 5 8 `vplus` Vector 9 2 8
Vector 12 7 16
ghci&gt; Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3
Vector 12 9 19
ghci&gt; Vector 3 9 7 `vmult` 10
Vector 30 90 70
ghci&gt; Vector 4 9 5 `dotProd` Vector 9.0 2.0 4.0
74.0
ghci&gt; Vector 2 9 3 `vmult` (Vector 4 9 5 `dotProd` Vector 9 2 4)
Vector 148 666 222</pre></div></div>
<div class="sect1" title="Derived Instances"><div class="titlepage"><div><div><h1 class="title"><a id="derived_instances"/>Derived Instances</h1></div></div></div><p>In <a class="xref" href="ch02s04.html" title="Type Classes 101">Type Classes 101</a> in <a class="xref" href="ch02s04.html" title="Type Classes 101">Type Classes 101</a>, you learned that a type class is a sort of an interface that defines some behavior, and that a type can be made an instance of a type class if it supports that behavior. For example, the <code class="literal">Int</code> type is an instance of the <code class="literal">Eq</code> type class because the <code class="literal">Eq</code> type class defines behavior for stuff that can be equated. And because integers can be equated, <code class="literal">Int</code> was made a part of the <code class="literal">Eq</code> type class. The real usefulness comes with the functions that act as the interface for <code class="literal">Eq</code>, namely <code class="literal">==</code> and <code class="literal">/=</code>. If a type is a part of the <code class="literal">Eq</code> type class, we can use the <code class="literal">==</code> functions with values of that type. That’s why expressions like <code class="literal">4 == 4</code> and <code class="literal">"foo" == "bar"</code> type check.<a id="IDX-CHP-7-0072" class="indexterm"/><a id="IDX-CHP-7-0073" class="indexterm"/><a id="IDX-CHP-7-0074" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e11100"/><img src="httpatomoreillycomsourcenostarchimages802598.png.jpg" alt="image with no caption"/></div></div><p>Haskell type classes are often confused with classes in languages like Java, Python, C++ and the like, which trips up a lot of programmers. In those languages, classes are a blueprint from which we create objects that can do some actions. But we don’t make data from Haskell type classes. Instead, we first make our data type, and then we think about how it can act. If it can act like something that can be equated, we make it an instance of the <code class="literal">Eq</code> type class. If it can act like something that can be ordered, we make it an instance of the <code class="literal">Ord</code> type class.<a id="IDX-CHP-7-0075" class="indexterm"/></p><p>Let’s see how Haskell can automatically make our type an instance of any of the following type classes: <code class="literal">Eq</code>, <code class="literal">Ord</code>, <code class="literal">Enum</code>, <code class="literal">Bounded</code>, <code class="literal">Show</code>, and <code class="literal">Read</code>. Haskell can derive the behavior of our types in these contexts if we use the <code class="literal">deriving</code> keyword when making our data type.</p><div class="sect2" title="Equating People"><div class="titlepage"><div><div><h2 class="title"><a id="equating_people"/>Equating People</h2></div></div></div><p>Consider this data type:</p><a id="I_programlisting7_d1e11147"/><pre class="programlisting">data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     }</pre><p>It describes a person. Let’s assume that no two people have the same combination of first name, last name, and age. If we have records for two people, does it make sense to see if they represent the same person? Sure it does. We can try to equate them to see if they are equal. That’s why it would make sense for this type to be part of the <code class="literal">Eq</code> type class. We’ll derive the instance.</p><a id="I_programlisting7_d1e11154"/><pre class="programlisting">data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     } deriving (Eq)</pre><p>When we derive the <code class="literal">Eq</code> instance for a type and then try to compare two values of that type with <code class="literal">==</code> or <code class="literal">/=</code>, Haskell will see if the value constructors match (there’s only one value constructor here though), and then it will check if all the data contained inside matches by testing each pair of fields with <code class="literal">==</code>. However, there’s a catch: The types of all the fields also must be part of the <code class="literal">Eq</code> type class. But since that’s the case with both <code class="literal">String</code> and <code class="literal">Int</code>, we’re okay.</p><p>First, let’s make a few people. Put the following in a script:</p><a id="I_programlisting7_d1e11182"/><pre class="programlisting">mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}
mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}</pre><p>Now let’s test our <code class="literal">Eq</code> instance:<a id="IDX-CHP-7-0076" class="indexterm"/><a id="IDX-CHP-7-0077" class="indexterm"/><a id="IDX-CHP-7-0078" class="indexterm"/><a id="IDX-CHP-7-0079" class="indexterm"/></p><a id="I_programlisting7_d1e11209"/><pre class="programlisting">ghci&gt; mca == adRock
False
ghci&gt; mikeD == adRock
False
ghci&gt; mikeD == mikeD
True
ghci&gt; mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}
True</pre><p>Of course, since <code class="literal">Person</code> is now in <code class="literal">Eq</code>, we can use it as the <code class="literal">a</code> for all functions that have a class constraint of <code class="literal">Eq a</code> in their type signature, such as <code class="literal">elem</code>.</p><a id="I_programlisting7_d1e11229"/><pre class="programlisting">ghci&gt; let beastieBoys = [mca, adRock, mikeD]
ghci&gt; mikeD `elem` beastieBoys
True</pre></div><div class="sect2" title="Show Me How to Read"><div class="titlepage"><div><div><h2 class="title"><a id="show_me_how_to_read"/>Show Me How to Read</h2></div></div></div><p>The <code class="literal">Show</code> and <code class="literal">Read</code> type classes are for things that can be converted to or from strings, respectively. As with <code class="literal">Eq</code>, if a type’s constructors have fields, their type must be a part of <code class="literal">Show</code> or <code class="literal">Read</code> if we want to make our type an instance of them.</p><p>Let’s make our <code class="literal">Person</code> data type a part of <code class="literal">Show</code> and <code class="literal">Read</code> as well.</p><a id="I_programlisting7_d1e11262"/><pre class="programlisting">data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     } deriving (Eq, Show, Read)</pre><p>Now we can print a person out to the terminal.</p><a id="I_programlisting7_d1e11266"/><pre class="programlisting">ghci&gt; mikeD
Person {firstName = "Michael", lastName = "Diamond", age = 43}
ghci&gt; "mikeD is: " ++ show mikeD
"mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"</pre><p>If we had tried to print a person on the terminal before making the <code class="literal">Person</code> data type part of <code class="literal">Show</code>, Haskell would have complained, claiming it didn’t know how to represent a person as a string. But since we first derived a <code class="literal">Show</code> instance for the data type, we didn’t get any complaints.</p><p><code class="literal">Read</code> is pretty much the inverse type class of <code class="literal">Show</code>. It’s for converting strings to values of our type. Remember though, that when we use the <code class="literal">read</code> function, we might need to use an explicit type annotation to tell Haskell which type we want to get as a result. To demonstrate this, let’s put a string that represents a person in a script and then load that script in GHCi:<a id="IDX-CHP-7-0080" class="indexterm"/><a id="IDX-CHP-7-0081" class="indexterm"/></p><a id="I_programlisting7_d1e11297"/><pre class="programlisting">mysteryDude = "Person { firstName =\"Michael\"" ++
                     ", lastName =\"Diamond\"" ++
                     ", age = 43}"</pre><p>We wrote our string across several lines like this for increased readability. If we want to <code class="literal">read</code> that string, we need to tell Haskell which type we expect in return:</p><a id="I_programlisting7_d1e11304"/><pre class="programlisting">ghci&gt; read mysteryDude :: Person
Person {firstName = "Michael", lastName = "Diamond", age = 43}</pre><p>If we use the result of our <code class="literal">read</code> later in a way that Haskell can infer that it should read it as a person, we don’t need to use type annotation.</p><a id="I_programlisting7_d1e11312"/><pre class="programlisting">ghci&gt; read mysteryDude == mikeD
True</pre><p>We can also read parameterized types, but we must give Haskell enough information so that it can figure out which type we want. If we try the following, we’ll get an error:</p><a id="I_programlisting7_d1e11316"/><pre class="programlisting">ghci&gt; read "Just 3" :: Maybe a</pre><p>In this case, Haskell doesn’t know which type to use for the type parameter <code class="literal">a</code>. But if we tell it that we want it to be an <code class="literal">Int</code>, it works just fine:</p><a id="I_programlisting7_d1e11326"/><pre class="programlisting">ghci&gt; read "Just 3" :: Maybe Int
Just 3</pre></div><div class="sect2" title="Order in the Court!"><div class="titlepage"><div><div><h2 class="title"><a id="order_in_the_court_exclamation"/>Order in the Court!</h2></div></div></div><p>We can derive instances for the <code class="literal">Ord</code> type class, which is for types that have values that can be ordered. If we compare two values of the same type that were made using different constructors, the value that was defined first is considered smaller. For instance, consider the <code class="literal">Bool</code> type, which can have a value of either <code class="literal">False</code> or <code class="literal">True</code>. For the purpose of seeing how it behaves when compared, we can think of it as being implemented like this:</p><a id="I_programlisting7_d1e11345"/><pre class="programlisting">data Bool = False | True deriving (Ord)</pre><p>Because the <code class="literal">False</code> value constructor is specified first and the <code class="literal">True</code> value constructor is specified after it, we can consider <code class="literal">True</code> as greater than <code class="literal">False</code>.</p><a id="I_programlisting7_d1e11361"/><pre class="programlisting">ghci&gt; True `compare` False
GT
ghci&gt; True &gt; False
True
ghci&gt; True &lt; False
False</pre><p>If two values were made using the same constructor, they are considered to be equal, unless they have fields. If they have fields, the fields are compared to see which is greater. (Note that in this case, the types of the fields also must be part of the <code class="literal">Ord</code> type class.)<a id="IDX-CHP-7-0082" class="indexterm"/><a id="IDX-CHP-7-0083" class="indexterm"/><a id="IDX-CHP-7-0084" class="indexterm"/><a id="IDX-CHP-7-0085" class="indexterm"/></p><p>In the <code class="literal">Maybe a</code> data type, the <code class="literal">Nothing</code> value constructor is specified before the <code class="literal">Just</code> value constructor, so the value of <code class="literal">Nothing</code> is always smaller than the value of <code class="literal">Just something</code>, even if that something is minus one billion trillion. But if we specify two <code class="literal">Just</code> values, then it will compare what’s inside them.</p><a id="I_programlisting7_d1e11405"/><pre class="programlisting">ghci&gt; Nothing &lt; Just 100
True
ghci&gt; Nothing &gt; Just (-49999)
False
ghci&gt; Just 3 `compare` Just 2
GT
ghci&gt; Just 100 &gt; Just 50
True</pre><p>However, we can’t do something like <code class="literal">Just (*3) &gt; Just (*2)</code>, because <code class="literal">(*3)</code> and <code class="literal">(*2)</code> are functions, which are not instances of <code class="literal">Ord</code>.</p></div><div class="sect2" title="Any Day of the Week"><div class="titlepage"><div><div><h2 class="title"><a id="any_day_of_the_week"/>Any Day of the Week</h2></div></div></div><p>We can easily use algebraic data types to make enumerations, and the <code class="literal">Enum</code> and <code class="literal">Bounded</code> type classes help us with that. Consider the following data type:<a id="IDX-CHP-7-0086" class="indexterm"/></p><a id="I_programlisting7_d1e11435"/><pre class="programlisting">data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday</pre><p>Because all the type’s value constructors are nullary (that is, they don’t have any fields), we can make it part of the <code class="literal">Enum</code> type class. The <code class="literal">Enum</code> type class is for things that have predecessors and successors. We can also make it part of the <code class="literal">Bounded</code> type class, which is for things that have a lowest possible value and highest possible value. And while we’re at it, let’s also make it an instance of all the other derivable type classes.</p><a id="I_programlisting7_d1e11448"/><pre class="programlisting">data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
            deriving (Eq, Ord, Show, Read, Bounded, Enum)</pre><p>Now let’s see what we can do with our new <code class="literal">Day</code> type. Because it’s part of the <code class="literal">Show</code> and <code class="literal">Read</code> type classes, we can convert values of this type to and from strings.<a id="IDX-CHP-7-0087" class="indexterm"/><a id="IDX-CHP-7-0088" class="indexterm"/><a id="IDX-CHP-7-0089" class="indexterm"/><a id="IDX-CHP-7-0090" class="indexterm"/></p><a id="I_programlisting7_d1e11473"/><pre class="programlisting">ghci&gt; Wednesday
Wednesday
ghci&gt; show Wednesday
"Wednesday"
ghci&gt; read "Saturday" :: Day
Saturday</pre><p>Because it’s part of the <code class="literal">Eq</code> and <code class="literal">Ord</code> type classes, we can compare or equate days.</p><a id="I_programlisting7_d1e11483"/><pre class="programlisting">ghci&gt; Saturday == Sunday
False
ghci&gt; Saturday == Saturday
True
ghci&gt; Saturday &gt; Friday
True
ghci&gt; Monday `compare` Wednesday
LT</pre><p>It’s also part of <code class="literal">Bounded</code>, so we can get the lowest and highest day.</p><a id="I_programlisting7_d1e11490"/><pre class="programlisting">ghci&gt; minBound :: Day
Monday
ghci&gt; maxBound :: Day
Sunday</pre><p>As it’s an instance of <code class="literal">Enum</code>, we can get predecessors and successors of days and make list ranges from them!</p><a id="I_programlisting7_d1e11498"/><pre class="programlisting">ghci&gt; succ Monday
Tuesday
ghci&gt; pred Saturday
Friday
ghci&gt; [Thursday .. Sunday]
[Thursday,Friday,Saturday,Sunday]
ghci&gt; [minBound .. maxBound] :: [Day]
[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]</pre></div></div>
<div class="sect1" title="Type Synonyms"><div class="titlepage"><div><div><h1 class="title"><a id="type_synonyms"/>Type Synonyms</h1></div></div></div><p>As mentioned earlier, when writing types, the <code class="literal">[Char]</code> and <code class="literal">String</code> types are equivalent and interchangeable. That’s implemented with <span class="emphasis"><em>type synonyms</em></span>.<a id="IDX-CHP-7-0091" class="indexterm"/></p><p>Type synonyms don’t really do anything per se—they’re just about giving some types different names so that they make more sense to someone reading our code and documentation. Here’s how the standard library defines <code class="literal">String</code> as a synonym for <code class="literal">[Char]</code>:<a id="IDX-CHP-7-0092" class="indexterm"/><a id="IDX-CHP-7-0093" class="indexterm"/><a id="IDX-CHP-7-0094" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e11539"/><img src="httpatomoreillycomsourcenostarchimages802600.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting7_d1e11544"/><pre class="programlisting">type String = [Char]</pre><p>The <code class="literal">type</code> keyword here might be misleading, because a new type is not being created (that’s done with the <code class="literal">data</code> keyword). Rather, this defines a synonym for an existing type.</p><p>If we make a function that converts a string to uppercase and call it <code class="literal">toUpperString</code>, we can give it a type declaration of this:</p><a id="I_programlisting7_d1e11559"/><pre class="programlisting">toUpperString :: [Char] -&gt; [Char]</pre><p>Alternatively, we can use this type declaration:</p><a id="I_programlisting7_d1e11563"/><pre class="programlisting">toUpperString :: String -&gt; String.</pre><p>The two are essentially the same, but the latter is nicer to read.</p><div class="sect2" title="Making Our Phonebook Prettier"><div class="titlepage"><div><div><h2 class="title"><a id="making_our_phonebook_prettier"/>Making Our Phonebook Prettier</h2></div></div></div><p>When we were dealing with the <code class="literal">Data.Map</code> module, we first represented a phonebook with an association list (a list of key/value pairs) before converting it into a map. Here’s that version:</p><a id="I_programlisting7_d1e11576"/><pre class="programlisting">phoneBook :: [(String, String)]
phoneBook =
    [("betty", "555-2938")
    ,("bonnie", "452-2928")
    ,("patsy", "493-2928")
    ,("lucille", "205-2928")
    ,("wendy", "939-8282")
    ,("penny", "853-2492")
    ]</pre><p>The type of <code class="literal">phoneBook</code> is <code class="literal">[(String, String)]</code>. That tells us that it’s an association list that maps from strings to strings, but not much else. Let’s make a type synonym to convey some more information in the type declaration.</p><a id="I_programlisting7_d1e11586"/><pre class="programlisting">type PhoneBook = [(String,String)]</pre><p>Now the type declaration for our phonebook can be <code class="literal">phoneBook :: PhoneBook</code>. Let’s make a type synonym for <code class="literal">String</code> as well.</p><a id="I_programlisting7_d1e11596"/><pre class="programlisting">type PhoneNumber = String
type Name = String
type PhoneBook = [(Name, PhoneNumber)]</pre><p>Haskell programmers give type synonyms to the <code class="literal">String</code> type when they want to convey more information about the strings in their functions—what they actually represent.<a id="IDX-CHP-7-0095" class="indexterm"/><a id="IDX-CHP-7-0096" class="indexterm"/></p><p>So now, when we implement a function that takes a name and a number and checks if that name and number combination is in our phonebook, we can give it a very pretty and descriptive type declaration.</p><a id="I_programlisting7_d1e11613"/><pre class="programlisting">inPhoneBook :: Name -&gt; PhoneNumber -&gt; PhoneBook -&gt; Bool
inPhoneBook name pnumber pbook = (name, pnumber) `elem` pbook</pre><p>If we decided not to use type synonyms, our function would have this type:</p><a id="I_programlisting7_d1e11618"/><pre class="programlisting">inPhoneBook :: String -&gt; String -&gt; [(String, String)] -&gt; Bool</pre><p>In this case, the type declaration that takes advantage of type synonyms is easier to understand. However, you shouldn’t go overboard with these synonyms. We introduce type synonyms either to describe what some existing type represents in our functions (and thus our type declarations become better documentation) or when something has a longish type that’s repeated a lot (like <code class="literal">[(String, String)]</code>) but represents something more specific in the context of our functions.</p></div><div class="sect2" title="Parameterizing Type Synonyms"><div class="titlepage"><div><div><h2 class="title"><a id="parameterizing_type_synonyms"/>Parameterizing Type Synonyms</h2></div></div></div><p>Type synonyms can also be parameterized. If we want a type that represents an association list type, but still want it to be general so it can use any type as the keys and values, we can do this:</p><a id="I_programlisting7_d1e11630"/><pre class="programlisting">type AssocList k v = [(k, v)]</pre><p>Now a function that gets the value by a key in an association list can have a type of <code class="literal">(Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v</code>. <code class="literal">AssocList</code> is a type constructor that takes two types and produces a concrete type—for instance, <code class="literal">AssocList Int String</code>.</p><p>Just as we can partially apply functions to get new functions, we can partially apply type parameters and get new type constructors from them. When we call a function with too few parameters, we get back a new function. In the same way, we can specify a type constructor with too few type parameters and get back a partially applied type constructor. If we wanted a type that represents a map (from <code class="literal">Data.Map</code>) from integers to something, we could do this:<a id="IDX-CHP-7-0097" class="indexterm"/><a id="IDX-CHP-7-0098" class="indexterm"/><a id="IDX-CHP-7-0099" class="indexterm"/><a id="IDX-CHP-7-0100" class="indexterm"/><a id="IDX-CHP-7-0101" class="indexterm"/><a id="IDX-CHP-7-0102" class="indexterm"/></p><a id="I_programlisting7_d1e11674"/><pre class="programlisting">type IntMap v = Map Int v</pre><p>Or we could do it like this:</p><a id="I_programlisting7_d1e11678"/><pre class="programlisting">type IntMap = Map Int</pre><p>Either way, the <code class="literal">IntMap</code> type constructor takes one parameter, and that is the type of what the integers will point to.</p><p>If you’re going to try to implement this, you probably will want to do a qualified import of <code class="literal">Data.Map</code>. When you do a qualified import, type constructors also need to be preceded with a module name.</p><a id="I_programlisting7_d1e11690"/><pre class="programlisting">type IntMap = Map.Map Int</pre><p>Make sure that you really understand the distinction between type constructors and value constructors. Just because we made a type synonym called <code class="literal">IntMap</code> or <code class="literal">AssocList</code> doesn’t mean that we can do stuff like <code class="literal">AssocList [(1,2), (4,5),(7,9)]</code>. All it means is that we can refer to its type by using different names. We can do <code class="literal">[(1,2),(3,5),(8,9)] :: AssocList Int Int</code>, which will make the numbers inside assume a type of <code class="literal">Int</code>. However, we can still use that list in the same way that we would use any normal list that has pairs of integers.</p><p>Type synonyms (and types generally) can be used only in the type portion of Haskell. Haskell’s type portion includes data and type declarations, as well as after a <code class="literal">::</code> in type declarations or type annotations.</p></div><div class="sect2" title="Go Left, Then Right"><div class="titlepage"><div><div><h2 class="title"><a id="go_left_comma_then_right"/>Go Left, Then Right</h2></div></div></div><p>Another cool data type that takes two types as its parameters is the <code class="literal">Either a b</code> type. This is roughly how it’s defined:</p><a id="I_programlisting7_d1e11723"/><pre class="programlisting">data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)</pre><p>It has two value constructors. If <code class="literal">Left</code> is used, then its contents are of type <code class="literal">a</code>; if <code class="literal">Right</code> is used, its contents are of type <code class="literal">b</code>. So we can use this type to encapsulate a value of one type or another. Then when we get a value of type <code class="literal">Either a b</code>, we usually pattern match on both <code class="literal">Left</code> and <code class="literal">Right</code>, and we do different stuff based on which one matches.</p><a id="I_programlisting7_d1e11749"/><pre class="programlisting">ghci&gt; Right 20
Right 20
ghci&gt; Left "w00t"
Left "w00t"
ghci&gt; :t Right 'a'
Right 'a' :: Either a Char
ghci&gt; :t Left True
Left True :: Either Bool b</pre><p>In this code, when we examine the type of <code class="literal">Left True</code>, we see that the type is <code class="literal">Either Bool b</code>. The first type parameter is <code class="literal">Bool</code>, because we made our value with the <code class="literal">Left</code> value constructor, whereas the second type parameter remains polymorphic. This is similar to how a <code class="literal">Nothing</code> value has the type <code class="literal">Maybe a</code>.<a id="IDX-CHP-7-0103" class="indexterm"/></p><p>So far, you’ve seen <code class="literal">Maybe a</code> mostly used to represent the results of computations that could have failed. But sometimes, <code class="literal">Maybe a</code> isn’t good enough, because <code class="literal">Nothing</code> doesn’t convey much information other than that something has failed. That’s fine for functions that can fail in only one way, or if we’re not interested in how or why they failed. For instance, a <code class="literal">Data.Map</code> lookup fails only if the key wasn’t in the map, so we know exactly what happened.</p><p>However, when we’re interested in how or why some function failed, we usually use the result type of <code class="literal">Either a b</code>, where <code class="literal">a</code> is a type that can tell us something about the possible failure, and <code class="literal">b</code> is the type of a successful computation. Hence, errors use the <code class="literal">Left</code> value constructor, and results use <code class="literal">Right</code>.</p><p>As an example, suppose that a high school has lockers so that students have some place to put their Guns N’ Roses posters. Each locker has a code combination. When students need to be assigned a locker, they tell the locker supervisor which locker number they want, and he gives them the code. However, if someone is already using that locker, the student needs to pick a different one. We’ll use a map from <code class="literal">Data.Map</code> to represent the lockers. It will map from locker numbers to a pair that indicates whether the locker is in use and the locker code.</p><a id="I_programlisting7_d1e11811"/><pre class="programlisting">import qualified Data.Map as Map

data LockerState = Taken | Free deriving (Show, Eq)

type Code = String

type LockerMap = Map.Map Int (LockerState, Code)</pre><p>We introduce a new data type to represent whether a locker is taken or free, and we make a type synonym for the locker code. We also make a type synonym for the type that maps from integers to pairs of locker state and code.</p><p>Next, we’ll make a function that searches for the code in a locker map. We’ll use an <code class="literal">Either String Code</code> type to represent our result, because our lookup can fail in two ways: The locker can be taken, in which case we can’t tell the code, or the locker number might not exist. If the lookup fails, we’re just going to use a <code class="literal">String</code> to indicate what happened.</p><a id="I_programlisting7_d1e11824"/><pre class="programlisting">lockerLookup :: Int -&gt; LockerMap -&gt; Either String Code
lockerLookup lockerNumber map = case Map.lookup lockerNumber map of
    Nothing -&gt; Left $ "Locker " ++ show lockerNumber ++ " doesn't exist!"
    Just (state, code) -&gt; if state /= Taken
                            then Right code
                            else Left $ "Locker " ++ show lockerNumber
                                        ++ " is already taken!"</pre><p>We do a normal lookup in the map. If we get a <code class="literal">Nothing</code>, we return a value of type <code class="literal">Left String</code>, saying that the locker doesn’t exist. If we do find it, then we do an additional check to see if the locker is in use. If it is, we return a <code class="literal">Left</code> saying that it’s already taken. If it isn’t, we return a value of type <code class="literal">Right Code</code>, in which we give the student the correct code for the locker. It’s actually a <code class="literal">Right String</code> (which is a <code class="literal">Right [Char])</code>, but we added that type synonym to introduce some additional documentation into the type declaration.<a id="IDX-CHP-7-0104" class="indexterm"/><a id="IDX-CHP-7-0105" class="indexterm"/><a id="IDX-CHP-7-0106" class="indexterm"/></p><p>Here’s an example map:</p><a id="I_programlisting7_d1e11860"/><pre class="programlisting">lockers :: LockerMap
lockers = Map.fromList
    [(100,(Taken, "ZD39I"))
    ,(101,(Free, "JAH3I"))
    ,(103,(Free, "IQSA9"))
    ,(105,(Free, "QOTSA"))
    ,(109,(Taken, "893JJ"))
    ,(110,(Taken, "99292"))
    ]</pre><p>Now let’s try looking up some locker codes.</p><a id="I_programlisting7_d1e11864"/><pre class="programlisting">ghci&gt; lockerLookup 101 lockers
Right "JAH3I"
ghci&gt; lockerLookup 100 lockers
Left "Locker 100 is already taken!"
ghci&gt; lockerLookup 102 lockers
Left "Locker number 102 doesn't exist!"
ghci&gt; lockerLookup 110 lockers
Left "Locker 110 is already taken!"
ghci&gt; lockerLookup 105 lockers
Right "QOTSA"</pre><p>We could have used a <code class="literal">Maybe a</code> to represent the result, but then we wouldn’t know why we couldn’t get the code. But now we have information about the failure in our result type.</p></div></div>
<div class="sect1" title="Recursive Data Structures"><div class="titlepage"><div><div><h1 class="title"><a id="recursive_data_structures"/>Recursive Data Structures</h1></div></div></div><p>As you’ve seen, a constructor in an algebraic data type can have several fields (or none at all), and each field must be of some concrete type. So we can make types that have themselves as types in their fields! And that means we can create recursive data types, where one value of some type contains values of that type, which in turn contain more values of the same type, and so on.<a id="IDX-CHP-7-0107" class="indexterm"/><a id="IDX-CHP-7-0108" class="indexterm"/><a id="IDX-CHP-7-0109" class="indexterm"/></p><p>Think about this list: <code class="literal">[5]</code>. That’s just syntactic sugar for <code class="literal">5:[]</code>. On the left side of the <code class="literal">:</code>, there’s a value; on the right side, there’s a list. In this case, it’s an empty list. Now how about the list <code class="literal">[4,5]</code>? Well, that desugars to <code class="literal">4:(5:[])</code>. Looking at the first <code class="literal">:</code>, we see that it also has an element on its left side and a list, <code class="literal">(5:[])</code>, on its right side. The same goes for a list like <code class="literal">3:(4:(5:6:[]))</code>, which could be written either like that or like <code class="literal">3:4:5:6:[]</code> (because <code class="literal">:</code> is right-associative) or <code class="literal">[3,4,5,6]</code>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e11926"/><img src="httpatomoreillycomsourcenostarchimages802602.png.jpg" alt="image with no caption"/></div></div><p>A list can be an empty list, or it can be an element joined together with a <code class="literal">:</code> with another list (that might be an empty list).</p><p>Let’s use algebraic data types to implement our own list!<a id="IDX-CHP-7-0110" class="indexterm"/></p><a id="I_programlisting7_d1e11941"/><pre class="programlisting">data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)</pre><p>This follows our definition of lists. It’s either an empty list or a combination of a head with some value and a list. If you’re confused about this, you might find it easier to understand in record syntax.</p><a id="I_programlisting7_d1e11945"/><pre class="programlisting">data List a = Empty | Cons { listHead :: a, listTail :: List a}
    deriving (Show, Read, Eq, Ord)</pre><p>You might also be confused about the <code class="literal">Cons</code> constructor here. Informally speaking, <code class="literal">Cons</code> is another word for <code class="literal">:</code>. In lists, <code class="literal">:</code> is actually a constructor that takes a value and another list and returns a list. In other words, it has two fields: One field is of the type of <code class="literal">a</code>, and the other is of the type <code class="literal">List a</code>.</p><a id="I_programlisting7_d1e11968"/><pre class="programlisting">ghci&gt; Empty
Empty
ghci&gt; 5 `Cons` Empty
Cons 5 Empty
ghci&gt; 4 `Cons` (5 `Cons` Empty)
Cons 4 (Cons 5 Empty)
ghci&gt; 3 `Cons` (4 `Cons` (5 `Cons` Empty))
Cons 3 (Cons 4 (Cons 5 Empty))</pre><p>We called our <code class="literal">Cons</code> constructor in an infix manner so you can see how it’s just like <code class="literal">:</code>. <code class="literal">Empty</code> is like <code class="literal">[]</code>, and <code class="literal">4 `Cons` (5 `Cons` Empty)</code> is like <code class="literal">4:(5:[])</code>.</p><div class="sect2" title="Improving Our List"><div class="titlepage"><div><div><h2 class="title"><a id="improving_our_list"/>Improving Our List</h2></div></div></div><p>We can define functions to be automatically infix by naming them using only special characters. We can also do the same with constructors, since they’re just functions that return a data type. There is one restriction however: Infix constructors must begin with a colon. So check this out:<a id="IDX-CHP-7-0111" class="indexterm"/><a id="IDX-CHP-7-0112" class="indexterm"/></p><a id="I_programlisting7_d1e12007"/><pre class="programlisting">infixr 5 :-:
data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)</pre><p>First, notice a new syntactic construct: the fixity declaration, which is the line above our data declaration. When we define functions as operators, we can use that to give them a <span class="emphasis"><em>fixity</em></span> (but we don’t have to). A fixity states how tightly the operator binds and whether it’s left-associative or right-associative. For instance, the <code class="literal">*</code> operator’s fixity is <code class="literal">infixl 7 *</code>, and the <code class="literal">+</code> operator’s fixity is <code class="literal">infixl 6</code>. That means that they’re both left-associative (in other words, <code class="literal">4 * 3 * 2</code> is the same as <code class="literal">(4 * 3) * 2</code>), but <code class="literal">*</code> binds tighter than <code class="literal">+</code>, because it has a greater fixity. So <code class="literal">5 * 4 + 3</code> is equivalent to <code class="literal">(5 * 4) + 3</code>.<a id="IDX-CHP-7-0113" class="indexterm"/></p><p>Otherwise, we just wrote <code class="literal">a :-: (List a)</code> instead of <code class="literal">Cons a (List a)</code>. Now, we can write out lists in our list type like so:</p><a id="I_programlisting7_d1e12057"/><pre class="programlisting">ghci&gt; 3 :-: 4 :-: 5 :-: Empty
3 :-: (4 :-: (5 :-: Empty))
ghci&gt; let a = 3 :-: 4 :-: 5 :-: Empty
ghci&gt; 100 :-: a
100 :-: (3 :-: (4 :-: (5 :-: Empty)))</pre><p>Let’s make a function that adds two of our lists together. This is how <code class="literal">++</code> is defined for normal lists:</p><a id="I_programlisting7_d1e12064"/><pre class="programlisting">infixr 5  ++
(++) :: [a] -&gt; [a] -&gt; [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)</pre><p>We’ll just steal that for our own list. We’ll name the function <code class="literal">^++</code>.</p><a id="I_programlisting7_d1e12071"/><pre class="programlisting">infixr 5  ^++
(^++) :: List a -&gt; List a -&gt; List a
Empty ^++ ys = ys
(x :-: xs) ^++ ys = x :-: (xs ^++ ys)</pre><p>Now let’s see try it:</p><a id="I_programlisting7_d1e12076"/><pre class="programlisting">ghci&gt; let a = 3 :-: 4 :-: 5 :-: Empty
ghci&gt; let b = 6 :-: 7 :-: Empty
ghci&gt; a ^++ b
3 :-: (4 :-: (5 :-: (6 :-: (7 :-: Empty))))</pre><p>If we wanted, we could implement all of the functions that operate on lists on our own list type.</p><p>Notice how we pattern matched on <code class="literal">(x :-: xs)</code>. That works because pattern matching is actually about matching constructors. We can match on <code class="literal">:-:</code> because it is a constructor for our own list type, and we can also match on <code class="literal">:</code> because it is a constructor for the built-in list type. The same goes for <code class="literal">[]</code>. Because pattern matching works (only) on constructors, we can match for normal prefix constructors or stuff like <code class="literal">8</code> or <code class="literal">'a'</code>, which are basically constructors for the numeric and character types, respectively.<a id="IDX-CHP-7-0114" class="indexterm"/><a id="IDX-CHP-7-0115" class="indexterm"/><a id="IDX-CHP-7-0116" class="indexterm"/><a id="IDX-CHP-7-0117" class="indexterm"/></p></div><div class="sect2" title="Let's Plant a Tree"><div class="titlepage"><div><div><h2 class="title"><a id="let_apostrophy_s_plant_a_tree"/>Let's Plant a Tree</h2></div></div></div><p>To get a better feel for recursive data structures in Haskell, we’re going to implement a binary search tree.</p><p>In a binary search tree, an element points to two elements—one on its left and one on its right. The element to the left is smaller; the element to the right is bigger. Each of those elements can also point to two elements (or one or none). In effect, each element has up to two subtrees.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e12125"/><img src="httpatomoreillycomsourcenostarchimages802604.png.jpg" alt="image with no caption"/></div></div><p>A cool thing about binary search trees is that we know that all the elements at the left subtree of, say, 5, will be smaller than 5. Elements in the right subtree will be bigger. So if we need to find if 8 is in our tree, we start at 5, and then because 8 is greater than 5, we go right. We’re now at 7, and because 8 is greater than 7, we go right again. And we’ve found our element in three hops! If this were a normal list (or a tree, but really unbalanced), it would take us seven hops to see if 8 is in there.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Sets and maps from <code class="literal">Data.Set</code> and <code class="literal">Data.Map</code> are implemented using trees, but instead of normal binary search trees, they use <span class="emphasis"><em>balanced</em></span> binary search trees. A tree is balanced if its left and right subtrees are of approximately the same height. This makes searching through the tree faster. But for our examples, we’ll just be implementing normal binary search trees.</p></div><p>Here’s what we’re going to say: A tree is either an empty tree or it’s an element that contains some value and two trees. Sounds like a perfect fit for an algebraic data type!</p><a id="I_programlisting7_d1e12146"/><pre class="programlisting">data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show)</pre><p>Instead of manually building a tree, we’ll make a function that takes a tree and an element and inserts an element. We do this by comparing the new value to the tree’s root node. If it’s smaller than the root, we go left; if it’s larger, we go right. We then do the same for every subsequent node until we reach an empty tree. Once we’ve reached an empty tree, we insert a node with our new value.</p><p>In languages like C, we would do this by modifying the pointers and values inside the tree. In Haskell, we can’t modify our tree directly, so we need to make a new subtree each time we decide to go left or right. In the end, the insertion function returns a completely new tree, because Haskell doesn’t have a concept of pointers, just values. Hence, the type for our insertion function will be something like <code class="literal">a -&gt; Tree a - &gt; Tree a</code>. It takes an element and a tree and returns a new tree that has that element inside. This might seem like it’s inefficient, but Haskell makes it possible to share most of the subtrees between the old tree and the new tree.</p><p>Here are two functions for building the tree:</p><a id="I_programlisting7_d1e12158"/><pre class="programlisting">singleton :: a -&gt; Tree a
singleton x = Node x EmptyTree EmptyTree

treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a
treeInsert x EmptyTree = singleton x
treeInsert x (Node a left right)
    | x == a = Node x left right
    | x &lt; a  = Node a (treeInsert x left) right
    | x &gt; a  = Node a left (treeInsert x right)</pre><p><code class="literal">singleton</code> is a utility function for making a singleton tree (a tree with just one node). It’s just a shortcut for creating a node that has something set as its root, and two empty subtrees.</p><p>The <code class="literal">treeInsert</code> function is to insert an element into a tree. Here, we first have the base case as a pattern. If we’ve reached an empty subtree, that means we’re where we want to go, and we insert a singleton tree with our element. If we’re not inserting into an empty tree, then we need to do some checking. First, if the element we’re inserting is equal to the root element, we just return a tree that’s the same. If it’s smaller, we return a tree that has the same root value and the same right subtree, but instead of its left subtree, we put a tree that has our value inserted into it. We do the same if our value is bigger than the root element, but the other way around.</p><p>Next up, we’re going to make a function that checks if some element is in the tree:</p><a id="I_programlisting7_d1e12171"/><pre class="programlisting">treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool
treeElem x EmptyTree = False
treeElem x (Node a left right)
    | x == a = True
    | x &lt; a  = treeElem x left
    | x &gt; a  = treeElem x right</pre><p>First, we define the base case. If we’re looking for an element in an empty tree, then it’s certainly not there. Notice how this is the same as the base case when searching for elements in lists. If we’re not looking for an element in an empty tree, then we check some things. If the element in the root node is what we’re looking for, great! If it’s not, what then? Well, we can take advantage of knowing that all the left elements are smaller than the root node. If the element we’re looking for is smaller than the root node, we check to see if it’s in the left subtree. If it’s bigger, we check to see if it’s in the right subtree.<a id="IDX-CHP-7-0118" class="indexterm"/></p><p>Now let’s have some fun with our trees! Instead of manually creating one (although we could), we’ll use a fold to build a tree from a list. Remember that pretty much everything that traverses a list one item at a time and returns a value can be implemented with a fold! We’re going to start with the empty tree and then approach a list from the right and insert element after element into our accumulator tree.</p><a id="I_programlisting7_d1e12182"/><pre class="programlisting">ghci&gt; let nums = [8,6,4,1,7,3,5]
ghci&gt; let numsTree = foldr treeInsert EmptyTree nums
ghci&gt; numsTree
Node 5
    (Node 3
        (Node 1 EmptyTree EmptyTree)
        (Node 4 EmptyTree EmptyTree)
    )
    (Node 7
        (Node 6 EmptyTree EmptyTree)
        (Node 8 EmptyTree EmptyTree)
    )</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>If you run this in GHCi, the result from <code class="literal">numsTree</code> will be printed in one long line. Here, it’s broken up into many lines; otherwise, it would run off the page!</p></div><p>In this <code class="literal">foldr</code>, <code class="literal">treeInsert</code> is the folding binary function (it takes a tree and a list element and produces a new tree), and <code class="literal">EmptyTree</code> is the starting accumulator. <code class="literal">nums</code>, of course, is the list we’re folding over.</p><p>When we print our tree to the console, it’s not very readable, but we can still make out its structure. We see that the root node is <code class="literal">5</code> and that it has two subtrees: one with a root node of <code class="literal">3</code> and the other with a root node of <code class="literal">7</code>.</p><p>We can also check if certain values are contained in the tree, like this:</p><a id="I_programlisting7_d1e12218"/><pre class="programlisting">ghci&gt; 8 `treeElem` numsTree
True
ghci&gt; 100 `treeElem` numsTree
False
ghci&gt; 1 `treeElem` numsTree
True
ghci&gt; 10 `treeElem` numsTree
False</pre><p>As you can see, algebraic data structures are a really cool and powerful concept in Haskell. We can use them to make anything from Boolean values and weekday enumerations to binary search trees, and more!<a id="IDX-CHP-7-0119" class="indexterm"/></p></div></div>
<div class="sect1" title="Type Classes 102"><div class="titlepage"><div><div><h1 class="title"><a id="type_classes_102"/>Type Classes 102</h1></div></div></div><p>So far, you’ve learned about some of the standard Haskell type classes and seen which types they contain. You’ve also learned how to automatically make your own type instances of the standard type classes by asking Haskell to derive the instances. This section explains how to make your own type classes and how to make type instances of them by hand.<a id="IDX-CHP-7-0120" class="indexterm"/><a id="IDX-CHP-7-0121" class="indexterm"/><a id="IDX-CHP-7-0122" class="indexterm"/></p><p>A quick type class recap: Type classes are sort of like interfaces. A type class defines some behavior (such as comparing for equality, comparing for ordering, and enumeration). Types that can behave in that way are made instances of that type class. The behavior of type classes is achieved by defining functions or just type declarations that we then implement. So when we say that a type is an instance of a type class, we mean that we can use the functions that the type class defines with that type.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e12246"/><img src="httpatomoreillycomsourcenostarchimages802606.png.jpg" alt="image with no caption"/></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember that type classes have nothing to do with classes in languages like Java or Python. This confuses many people, so I want you to forget everything you know about classes in imperative languages right now!</p></div><div class="sect2" title="Inside the Eq Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="inside_the_eq_type_class"/>Inside the Eq Type Class</h2></div></div></div><p>As an example, let’s look at the <code class="literal">Eq</code> type class. Remember that <code class="literal">Eq</code> is for values that can be equated. It defines the functions <code class="literal">==</code> and <code class="literal">/=</code>. If we have the type <code class="literal">Car</code> and comparing two cars with the equality function <code class="literal">==</code> makes sense, then it makes sense for <code class="literal">Car</code> to be an instance of <code class="literal">Eq</code>.</p><p>This is how the <code class="literal">Eq</code> class is defined in the standard library:</p><a id="I_programlisting7_d1e12289"/><pre class="programlisting">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
    x == y = not (x /= y)
    x /= y = not (x == y)</pre><p>Whoa! Some strange syntax and keywords here!</p><p><code class="literal">class Eq a where</code> means a new type class called <code class="literal">Eq</code> is being defined. The <code class="literal">a</code> is the type variable, so <code class="literal">a</code> will play the role of the type that will soon be made an instance of <code class="literal">Eq</code>. (It doesn’t need to be called <code class="literal">a</code>, and it doesn’t even need to be one letter—it just must be in all lowercase.)</p><p>Next, several functions are defined. Note that it’s not mandatory to implement the function bodies themselves; just their type declarations are required. Here, the function bodies for the functions that <code class="literal">Eq</code> defines are implemented—defined in terms of mutual recursion. It says that two values whose types are instances of <code class="literal">Eq</code> are equal if they are not different, and they are different if they are not equal. You’ll see how this helps us soon.<a id="IDX-CHP-7-0123" class="indexterm"/><a id="IDX-CHP-7-0124" class="indexterm"/><a id="IDX-CHP-7-0125" class="indexterm"/><a id="IDX-CHP-7-0126" class="indexterm"/><a id="IDX-CHP-7-0127" class="indexterm"/><a id="IDX-CHP-7-0128" class="indexterm"/></p><p>The final type of the functions that we define in a type class is also worth noting. If we have, say, <code class="literal">class Eq a where</code>, and then define a type declaration within that class like <code class="literal">(==) :: a -&gt; a -&gt; Bool</code>, when we examine the type of that function later, it will have the type of <code class="literal">(Eq a) =&gt; a -&gt; a -&gt; Bool</code>.</p></div><div class="sect2" title="A Traffic Light Data Type"><div class="titlepage"><div><div><h2 class="title"><a id="a_traffic_light_data_type"/>A Traffic Light Data Type</h2></div></div></div><p>So once we have a class, what can we do with it? We can make type instances of that class and get some nice functionality. Check out this type, for instance:</p><a id="I_programlisting7_d1e12360"/><pre class="programlisting">data TrafficLight = Red | Yellow | Green</pre><p>It defines the states of a traffic light. Notice how we didn’t derive any class instances for it. That’s because we’re going to write some instances by hand. Here’s how we make it an instance of <code class="literal">Eq</code>:</p><a id="I_programlisting7_d1e12367"/><pre class="programlisting">instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False</pre><p>We did it by using the <code class="literal">instance</code> keyword. So <code class="literal">class</code> is for defining new type classes, and <code class="literal">instance</code> is for making our types instances of type classes. When we were defining <code class="literal">Eq</code>, we wrote <code class="literal">class Eq a where</code>, and we said that <code class="literal">a</code> plays the role of whichever type will be made an instance later. We can see that clearly here, because when we’re making an instance, we write <code class="literal">instance Eq TrafficLight where</code>. We replace the <code class="literal">a</code> with the actual type.</p><p>Because <code class="literal">==</code> was defined in terms of <code class="literal">/=</code> and vice versa in the class declaration, we needed to overwrite only one of them in the instance declaration. That’s called the <span class="emphasis"><em>minimal complete definition</em></span> for the type class—the minimum of functions that we must implement so that our type can behave as the class advertises. To fulfill the minimal complete definition for <code class="literal">Eq</code>, we need to overwrite either <code class="literal">==</code> or <code class="literal">/=</code>. If <code class="literal">Eq</code> were defined simply like this:</p><a id="I_programlisting7_d1e12420"/><pre class="programlisting">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool</pre><p>we would need to implement both of these functions when making a type an instance of <code class="literal">Eq</code>, because Haskell wouldn’t know how these two functions are related. The minimal complete definition would then be both <code class="literal">==</code> and <code class="literal">/=</code>.</p><p>You can see that we implemented <code class="literal">==</code> simply by doing pattern matching. Since there are many more cases where two lights aren’t equal, we specified the ones that <span class="emphasis"><em>are</em></span> equal, and then just did a catchall pattern saying that if it’s none of the previous combinations, then two lights aren’t equal.<a id="IDX-CHP-7-0129" class="indexterm"/><a id="IDX-CHP-7-0130" class="indexterm"/><a id="IDX-CHP-7-0131" class="indexterm"/><a id="IDX-CHP-7-0132" class="indexterm"/><a id="IDX-CHP-7-0133" class="indexterm"/></p><p>Let’s make this an instance of <code class="literal">Show</code> by hand, too. To satisfy the minimal complete definition for <code class="literal">Show</code>, we just need to implement its <code class="literal">show</code> function, which takes a value and turns it into a string:</p><a id="I_programlisting7_d1e12472"/><pre class="programlisting">instance Show TrafficLight where
    show Red = "Red light"
    show Yellow = "Yellow light"
    show Green = "Green light"</pre><p>Once again, we used pattern matching to achieve our goals. Let’s see how it works in action:</p><a id="I_programlisting7_d1e12476"/><pre class="programlisting">ghci&gt; Red == Red
True
ghci&gt; Red == Yellow
False
ghci&gt; Red `elem` [Red, Yellow, Green]
True
ghci&gt; [Red, Yellow, Green]
[Red light,Yellow light,Green light]</pre><p>We could have just derived <code class="literal">Eq</code>, and it would have had the same effect (but we didn’t for educational purposes). However, deriving <code class="literal">Show</code> would have just directly translated the value constructors to strings. If we want our lights to appear as <code class="literal">Red light</code>, we need to make the instance declaration by hand.</p></div><div class="sect2" title="Subclassing"><div class="titlepage"><div><div><h2 class="title"><a id="subclassing"/>Subclassing</h2></div></div></div><p>You can also make type classes that are subclasses of other type classes. The class declaration for <code class="literal">Num</code> is a bit long, but here’s the first part:</p><a id="I_programlisting7_d1e12497"/><pre class="programlisting">class (Eq a) =&gt; Num a where
   ...</pre><p>As mentioned previously, there are a lot of places where we can cram in class constraints. So this is just like writing <code class="literal">class Num a where</code>, but we state that our type <code class="literal">a</code> must be an instance of <code class="literal">Eq</code>. We’re essentially saying that we need to make a type an instance of <code class="literal">Eq</code> before we can make it an instance of <code class="literal">Num</code>. Before some type can be considered a number, it makes sense that we can determine whether values of that type can be equated.<a id="IDX-CHP-7-0134" class="indexterm"/></p><p>That’s all there is to subclassing—it’s just a class constraint on a class declaration! When defining function bodies in the class declaration or in instance declarations, we can assume that <code class="literal">a</code> is a part of <code class="literal">Eq</code>, so we can use <code class="literal">==</code> on values of that type.</p></div><div class="sect2" title="Parameterized Types As Instances of Type Classes"><div class="titlepage"><div><div><h2 class="title"><a id="parameterized_types_as_instances_of_type"/>Parameterized Types As Instances of Type Classes</h2></div></div></div><p>But how are the <code class="literal">Maybe</code> or list types made as instances of type classes? What makes <code class="literal">Maybe</code> different from, say, <code class="literal">TrafficLight</code> is that <code class="literal">Maybe</code> in itself isn’t a concrete type—it’s a type constructor that takes one type parameter (like <code class="literal">Char</code>) to produce a concrete type (like <code class="literal">Maybe Char</code>). Let’s take a look at the <code class="literal">Eq</code> type class again:<a id="IDX-CHP-7-0135" class="indexterm"/><a id="IDX-CHP-7-0136" class="indexterm"/><a id="IDX-CHP-7-0137" class="indexterm"/><a id="IDX-CHP-7-0138" class="indexterm"/></p><a id="I_programlisting7_d1e12576"/><pre class="programlisting">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
    x == y = not (x /= y)
    x /= y = not (x == y)</pre><p>From the type declarations, we see that <code class="literal">a</code> is used as a concrete type because all the types in functions must be concrete. Remember that you can’t have a function of the type <code class="literal">a -&gt; Maybe</code>, but you <span class="emphasis"><em>can</em></span> have a function of the type <code class="literal">a -&gt; Maybe a</code> or <code class="literal">Maybe Int -&gt; Maybe String</code>. That’s why we can’t do something like this:</p><a id="I_programlisting7_d1e12595"/><pre class="programlisting">instance Eq Maybe where
    ...</pre><p>The <code class="literal">a</code> must be a concrete type, and <code class="literal">Maybe</code> is not; it’s a type constructor that takes one parameter and then <span class="emphasis"><em>produces</em></span> a concrete type.</p><p>It would also be tedious if we needed to make a separate instance for every possible type that <code class="literal">Maybe</code>’s type parameter could take on. If we needed to write <code class="literal">instance Eq (Maybe Int) where</code>, <code class="literal">instance Eq (Maybe Char) where</code>, and so on for every type, we would get nowhere. That’s why we can just leave the parameter as a type variable, like so:</p><a id="I_programlisting7_d1e12619"/><pre class="programlisting">instance Eq (Maybe m) where
    Just x == Just y = x == y
    Nothing == Nothing = True
    _ == _ = False</pre><p>This is like saying that we want to make all types of the form <code class="literal">Maybe something</code> an instance of <code class="literal">Eq</code>. We actually could have written <code class="literal">(Maybe something)</code>, but using single letters conforms to the Haskell style.</p><p>The <code class="literal">(Maybe m)</code> here plays the role of the <code class="literal">a</code> from <code class="literal">class Eq a where</code>. While <code class="literal">Maybe</code> isn’t a concrete type, <code class="literal">Maybe m</code> is. By specifying a type parameter as a type variable (<code class="literal">m</code>, which is in lowercase), we said that we want all types that are in the form of <code class="literal">Maybe m</code>, where <code class="literal">m</code> is any type, to be an instance of <code class="literal">Eq</code>.</p><p>There’s one problem with this though. Can you spot it? We use <code class="literal">==</code> on the contents of the <code class="literal">Maybe</code>, but we have no assurance that what the <code class="literal">Maybe</code> contains can be used with <code class="literal">Eq</code>! That’s why we modify our instance declaration like this:<a id="IDX-CHP-7-0139" class="indexterm"/></p><a id="I_programlisting7_d1e12682"/><pre class="programlisting">instance (Eq m) =&gt; Eq (Maybe m) where
    Just x == Just y = x == y
    Nothing == Nothing = True
    _ == _ = False</pre><p>We needed to add a class constraint! With this instance declaration, we say that we want all types of the form <code class="literal">Maybe m</code> to be part of the <code class="literal">Eq</code> type class, but only those types where the <code class="literal">m</code> (what’s contained inside the <code class="literal">Maybe</code>) is also a part of <code class="literal">Eq</code>. This is actually how Haskell would derive the instance.</p><p>Most of the time, class constraints in class declarations are used for making a type class a subclass of another type class, and class constraints in instance declarations are used to express requirements about the contents of some type. For instance, here we required the contents of the <code class="literal">Maybe</code> to also be part of the <code class="literal">Eq</code> type class.<a id="IDX-CHP-7-0140" class="indexterm"/><a id="IDX-CHP-7-0141" class="indexterm"/></p><p>When making instances, if you see that a type is used as a concrete type in the type declarations (like the <code class="literal">a</code> in <code class="literal">a -&gt; a -&gt; Bool</code>), you need to supply type parameters and add parentheses so that you end up with a concrete type.</p><p>Take into account that the type you’re trying to make an instance of will replace the parameter in the class declaration. The <code class="literal">a</code> from <code class="literal">class Eq a where</code> will be replaced with a real type when you make an instance, so try to mentally put your type into the function type declarations as well. The following type declaration really doesn’t make much sense:</p><a id="I_programlisting7_d1e12731"/><pre class="programlisting">(==) :: Maybe -&gt; Maybe -&gt; Bool</pre><p>But this does:</p><a id="I_programlisting7_d1e12735"/><pre class="programlisting">(==) :: (Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool</pre><p>This is just something to think about, because <code class="literal">==</code> will always have a type of <code class="literal">(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>, no matter what instances we make.</p><p>Oh, and one more thing: If you want to see what the instances of a type class are, just type <code class="literal">:info YourTypeClass</code> in GHCi. For instance, typing <code class="literal">:info Num</code> will show which functions the type class defines, and it will give you a list of the types in the type class. <code class="literal">:info</code> works for types and type constructors, too. If you do <code class="literal">:info Maybe</code>, it will show you all the type classes that <code class="literal">Maybe</code> is an instance of. Here’s an example:</p><a id="I_programlisting7_d1e12762"/><pre class="programlisting">ghci&gt; :info Maybe
data Maybe a = Nothing | Just a -- Defined in Data.Maybe
instance (Eq a) =&gt; Eq (Maybe a) -- Defined in Data.Maybe
instance Monad Maybe -- Defined in Data.Maybe
instance Functor Maybe -- Defined in Data.Maybe
instance (Ord a) =&gt; Ord (Maybe a) -- Defined in Data.Maybe
instance (Read a) =&gt; Read (Maybe a) -- Defined in GHC.Read
instance (Show a) =&gt; Show (Maybe a) -- Defined in GHC.Show</pre></div></div>
<div class="sect1" title="A Yes-No Type Class"><div class="titlepage"><div><div><h1 class="title"><a id="a_yes-no_type_class"/>A Yes-No Type Class</h1></div></div></div><p>In JavaScript and some other weakly typed languages, you can put almost anything inside an <code class="literal">if</code> expression. For example, in JavaScript, you can do something like this:<a id="IDX-CHP-7-0142" class="indexterm"/><a id="IDX-CHP-7-0143" class="indexterm"/><a id="IDX-CHP-7-0144" class="indexterm"/><a id="IDX-CHP-7-0145" class="indexterm"/><a id="IDX-CHP-7-0146" class="indexterm"/></p><a id="I_programlisting7_d1e12788"/><pre class="programlisting">if (0) alert("YEAH!") else alert("NO!")</pre><p>Or like this:</p><a id="I_programlisting7_d1e12792"/><pre class="programlisting">if ("") alert ("YEAH!") else alert("NO!")</pre><p>Or like this:</p><a id="I_programlisting7_d1e12796"/><pre class="programlisting">if (false) alert("YEAH!") else alert("NO!")</pre><p>All of these will throw an alert of <code class="literal">NO!</code>.</p><p>However, the following code will give an alert of <code class="literal">YEAH!</code>, since JavaScript considers any nonempty string to be a true value:</p><a id="I_programlisting7_d1e12808"/><pre class="programlisting">if ("WHAT") alert ("YEAH!") else alert("NO!")</pre><p>Even though strictly using <code class="literal">Bool</code> for Boolean semantics works better in Haskell, let’s try to implement this JavaScript-like behavior, just for fun! We’ll start out with a class declaration:</p><a id="I_programlisting7_d1e12816"/><pre class="programlisting">class YesNo a where
    yesno :: a -&gt; Bool</pre><p>This is pretty simple. The <code class="literal">YesNo</code> type class defines one function. That function takes one value of a type that can be considered to hold some concept of trueness and tells us for sure if it’s true or not. Notice that from the way we use <code class="literal">a</code> in the function that <code class="literal">a</code> must be a concrete type.<a id="IDX-CHP-7-0147" class="indexterm"/></p><p>Next up, let’s define some instances. For numbers, we’ll assume that (as in JavaScript) any number that isn’t <code class="literal">0</code> is true in a Boolean context and <code class="literal">0</code> is false.</p><a id="I_programlisting7_d1e12842"/><pre class="programlisting">instance YesNo Int where
    yesno 0 = False
    yesno _ = True</pre><p>Empty lists (and by extension, strings) are a no-ish value, while nonempty lists are a yes-ish value.<a id="IDX-CHP-7-0148" class="indexterm"/><a id="IDX-CHP-7-0149" class="indexterm"/></p><a id="I_programlisting7_d1e12852"/><pre class="programlisting">instance YesNo [a] where
    yesno [] = False
    yesno _ = True</pre><p>Notice how we just put a type parameter <code class="literal">a</code> in there to make the list a concrete type, even though we don’t make any assumptions about the type that’s contained in the list.</p><p><code class="literal">Bool</code> itself also holds trueness and falseness, and it’s pretty obvious which is which:</p><a id="I_programlisting7_d1e12863"/><pre class="programlisting">instance YesNo Bool where
    yesno = id</pre><p>But what’s <code class="literal">id</code>? It’s just a standard library function that takes a parameter and returns the same thing, which is what we would be writing here anyway.</p><p>Let’s make <code class="literal">Maybe a</code> an instance, too:</p><a id="I_programlisting7_d1e12876"/><pre class="programlisting">instance YesNo (Maybe a) where
    yesno (Just _) = True
    yesno Nothing = False</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e12879"/><img src="httpatomoreillycomsourcenostarchimages802608.png.jpg" alt="image with no caption"/></div></div><p>We didn’t need a class constraint, because we made no assumptions about the contents of the <code class="literal">Maybe</code>. We just said that it’s true-ish if it’s a <code class="literal">Just</code> value and false-ish if it’s a <code class="literal">Nothing</code>. We still need to write out <code class="literal">(Maybe a)</code> instead of just <code class="literal">Maybe</code>. If you think about it, a <code class="literal">Maybe -&gt; Bool</code> function can’t exist (because <code class="literal">Maybe</code> isn’t a concrete type), whereas a <code class="literal">Maybe a -&gt; Bool</code> is fine and dandy. Still, this is really cool, because now any type of the form <code class="literal">Maybe something</code> is part of <code class="literal">YesNo</code>, and it doesn’t matter what that something is.</p><p>Previously, we defined a <code class="literal">Tree a</code> type that represented a binary search tree. We can say an empty tree is false-ish, and anything that’s not an empty tree is true-ish:</p><a id="I_programlisting7_d1e12922"/><pre class="programlisting">instance YesNo (Tree a) where
    yesno EmptyTree = False
    yesno _ = True</pre><p>Can a traffic light be a yes or no value? Sure. If it’s red, you stop. If it’s green, you go. (If it’s yellow? Eh, I usually run the yellows because I live for adrenaline.)</p><a id="I_programlisting7_d1e12926"/><pre class="programlisting">instance YesNo TrafficLight where
    yesno Red = False
    yesno _ = True</pre><p>Now that we have some instances, let’s go play!<a id="IDX-CHP-7-0150" class="indexterm"/><a id="IDX-CHP-7-0151" class="indexterm"/><a id="IDX-CHP-7-0152" class="indexterm"/></p><a id="I_programlisting7_d1e12939"/><pre class="programlisting">ghci&gt; yesno $ length []
False
ghci&gt; yesno "haha"
True
ghci&gt; yesno ""
False
ghci&gt; yesno $ Just 0
True
ghci&gt; yesno True
True
ghci&gt; yesno EmptyTree
False
ghci&gt; yesno []
False
ghci&gt; yesno [0,0,0]
True
ghci&gt; :t yesno
yesno :: (YesNo a) =&gt; a -&gt; Bool</pre><p>It works!</p><p>Now let’s make a function that mimics the <code class="literal">if</code> statement, but that works with <code class="literal">YesNo</code> values.</p><a id="I_programlisting7_d1e12952"/><pre class="programlisting">yesnoIf :: (YesNo y) =&gt; y -&gt; a -&gt; a -&gt; a
yesnoIf yesnoVal yesResult noResult =
    if yesno yesnoVal
        then yesResult
        else noResult</pre><p>This takes a <code class="literal">YesNo</code> value and two values of any type. If the yes-no--ish value is more of a yes, it returns the first of the two values; otherwise, it returns the second of them. Let’s try it:</p><a id="I_programlisting7_d1e12959"/><pre class="programlisting">ghci&gt; yesnoIf [] "YEAH!" "NO!"
"NO!"
ghci&gt; yesnoIf [2,3,4] "YEAH!" "NO!"
"YEAH!"
ghci&gt; yesnoIf True "YEAH!" "NO!"
"YEAH!"
ghci&gt; yesnoIf (Just 500) "YEAH!" "NO!"
"YEAH!"
ghci&gt; yesnoIf Nothing "YEAH!" "NO!"
"NO!"</pre></div>
<div class="sect1" title="The Functor Type Class"><div class="titlepage"><div><div><h1 class="title"><a id="the_functor_type_class"/>The Functor Type Class</h1></div></div></div><p>So far, we’ve encountered a lot of the type classes in the standard library. We’ve played with <code class="literal">Ord</code>, which is for stuff that can be ordered. We’ve palled around with <code class="literal">Eq</code>, which is for things that can be equated. We’ve seen <code class="literal">Show</code>, which presents an interface for types whose values can be displayed as strings. Our good friend <code class="literal">Read</code> is there whenever we need to convert a string to a value of some type. And now, we’re going to take a look at the <code class="literal">Functor</code> type class, which is for things that can be mapped over.<a id="IDX-CHP-7-0153" class="indexterm"/><a id="IDX-CHP-7-0154" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e12991"/><img src="httpatomoreillycomsourcenostarchimages802610.png.jpg" alt="image with no caption"/></div></div><p>You’re probably thinking about lists now, since mapping over lists is such a dominant idiom in Haskell. And you’re right, the list type is part of the <code class="literal">Functor</code> type class.</p><p>What better way to get to know the <code class="literal">Functor</code> type class than to see how it’s implemented? Let’s take a peek.</p><a id="I_programlisting7_d1e13006"/><pre class="programlisting">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</pre><p>We see that it defines one function, <code class="literal">fmap</code>, and doesn’t provide any default implementation for that function. The type of <code class="literal">fmap</code> is interesting. In the definitions of type classes so far, the type variable that played the role of the type in the type class was a concrete type, like the <code class="literal">a</code> in <code class="literal">(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>. But now, the <code class="literal">f</code> is not a concrete type (a type that a value can hold, like <code class="literal">Int</code>, <code class="literal">Bool</code>, or <code class="literal">Maybe String</code>), but a type constructor that takes one type parameter. (A quick refresher example: <code class="literal">Maybe Int</code> is a concrete type, but <code class="literal">Maybe</code> is a type constructor that takes one type as the parameter.)</p><p>We see that <code class="literal">fmap</code> takes a function from one type to another and a functor value applied with one type and returns a functor value applied with another type. If this sounds a bit confusing, don’t worry—all will be revealed soon when we check out a few examples.</p><p>Hmm . . . the type declaration for <code class="literal">fmap</code> reminds me of something. Let’s look at the type signature of the <code class="literal">map</code> function:</p><a id="I_programlisting7_d1e13054"/><pre class="programlisting">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</pre><p>Ah, interesting! It takes a function from one type to another and a list of one type and returns a list of another type. My friends, I think we have ourselves a functor! In fact, <code class="literal">map</code> is just a <code class="literal">fmap</code> that works only on lists. Here’s how the list is an instance of the <code class="literal">Functor</code> type class:<a id="IDX-CHP-7-0155" class="indexterm"/><a id="IDX-CHP-7-0156" class="indexterm"/></p><a id="I_programlisting7_d1e13078"/><pre class="programlisting">instance Functor [] where
    fmap = map</pre><p>That’s it! Notice how we didn’t write <code class="literal">instance Functor [a] where</code>. This is because <code class="literal">f</code> must be a type constructor that takes one type, which we can see in the following type declaration:</p><a id="I_programlisting7_d1e13088"/><pre class="programlisting">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</pre><p><code class="literal">[a]</code> is already a concrete type (of a list with any type inside it), while <code class="literal">[]</code> is a type constructor that takes one type and can produce types such as <code class="literal">[Int]</code>, <code class="literal">[String]</code>, or even <code class="literal">[[String]]</code>.</p><p>Since for lists, <code class="literal">fmap</code> is just <code class="literal">map</code>, we get the same results when using these functions on lists:</p><a id="I_programlisting7_d1e13114"/><pre class="programlisting">ghci&gt; fmap (*2) [1..3]
[2,4,6]
ghci&gt; map (*2) [1..3]
[2,4,6]</pre><p>What happens when we <code class="literal">map</code> or <code class="literal">fmap</code> over an empty list? Well, of course, we get an empty list. It turns an empty list of type <code class="literal">[a]</code> into an empty list of type <code class="literal">[b]</code>.</p><div class="sect2" title="Maybe As a Functor"><div class="titlepage"><div><div><h2 class="title"><a id="maybe_as_a_functor"/>Maybe As a Functor</h2></div></div></div><p>Types that can act like a box can be functors. You can think of a list as a box that can be empty or have something inside it, including another box. That box can also be empty or contain something and another box, and so on. So, what else has the properties of being like a box? For one, the <code class="literal">Maybe a</code> type. In a way, it’s like a box that can hold nothing (in which case it has the value of <code class="literal">Nothing</code>), or it can contain one item (like <code class="literal">"HAHA"</code>, in which case it has a value of <code class="literal">Just "HAHA"</code>).</p><p>Here’s how <code class="literal">Maybe</code> is a functor:</p><a id="I_programlisting7_d1e13152"/><pre class="programlisting">instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing</pre><p>Again, notice how we wrote <code class="literal">instance Functor Maybe where</code> instead of <code class="literal">instance Functor (Maybe m) where</code>, as we did when we were dealing with <code class="literal">YesNo</code>. <code class="literal">Functor</code> wants a type constructor that takes one type, and not a concrete type. If you mentally replace the <code class="literal">f</code>s with <code class="literal">Maybe</code>s, <code class="literal">fmap</code> acts like a <code class="literal">(a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code> for this particular type, which looks okay. But if you replace <code class="literal">f</code> with <code class="literal">(Maybe m)</code>, then it would seem to act like a <code class="literal">(a -&gt; b) -&gt; Maybe m a -&gt; Maybe m b</code>, which doesn’t make sense, because <code class="literal">Maybe</code> takes just one type parameter.<a id="IDX-CHP-7-0157" class="indexterm"/><a id="IDX-CHP-7-0158" class="indexterm"/><a id="IDX-CHP-7-0159" class="indexterm"/></p><p>The <code class="literal">fmap</code> implementation is pretty simple. If it’s an empty value of <code class="literal">Nothing</code>, then just return a <code class="literal">Nothing</code>. If we map over an empty box, we get an empty box. If we map over an empty list, we get an empty list. If it’s not an empty value, but rather a single value packed in a <code class="literal">Just</code>, then we apply the function on the contents of the <code class="literal">Just</code>:</p><a id="I_programlisting7_d1e13224"/><pre class="programlisting">ghci&gt; fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.")
Just "Something serious. HEY GUYS IM INSIDE THE JUST"
ghci&gt; fmap (++ " HEY GUYS IM INSIDE THE JUST") Nothing
Nothing
ghci&gt; fmap (*2) (Just 200)
Just 400
ghci&gt; fmap (*2) Nothing
Nothing</pre></div><div class="sect2" title="Trees Are Functors, Too"><div class="titlepage"><div><div><h2 class="title"><a id="trees_are_functors_comma_too"/>Trees Are Functors, Too</h2></div></div></div><p>Another thing that can be mapped over and made an instance of <code class="literal">Functor</code> is our <code class="literal">Tree a</code> type. It can be thought of as a box (it holds several or no values), and the <code class="literal">Tree</code> type constructor takes exactly one type parameter. If you look at <code class="literal">fmap</code> as if it were a function made only for <code class="literal">Tree</code>, its type signature would look like this: <code class="literal">(a -&gt; b) -&gt; Tree a -&gt; Tree b</code>.</p><p>We’re going to use recursion on this one. Mapping over an empty tree will produce an empty tree. Mapping over a nonempty tree will produce a tree consisting of our function applied to the root value, and its left and right subtrees will be the previous subtrees, but with our function mapped over them. Here’s the code:<a id="IDX-CHP-7-0160" class="indexterm"/></p><a id="I_programlisting7_d1e13257"/><pre class="programlisting">instance Functor Tree where
    fmap f EmptyTree = EmptyTree
    fmap f (Node x left right) = Node (f x) (fmap f left) (fmap f right)</pre><p>Now let’s test it:</p><a id="I_programlisting7_d1e13261"/><pre class="programlisting">ghci&gt; fmap (*2) EmptyTree
EmptyTree
ghci&gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3])
Node 20 (Node 12 EmptyTree EmptyTree) (Node 28 EmptyTree EmptyTree)</pre><p>Be careful though! If you use the <code class="literal">Tree a</code> type to represent a binary search tree, there is no guarantee that it will remain a binary search tree after mapping a function over it. For something to be considered a binary search tree, all the elements to the left of some node must be smaller than the element in the node, and all the elements to the right must be greater. But if you map a function like <code class="literal">negate</code> over a binary search tree, the elements to the left of the node suddenly become greater than its element, and your binary search tree becomes just a normal binary tree.<a id="IDX-CHP-7-0161" class="indexterm"/><a id="IDX-CHP-7-0162" class="indexterm"/><a id="IDX-CHP-7-0163" class="indexterm"/><a id="IDX-CHP-7-0164" class="indexterm"/><a id="IDX-CHP-7-0165" class="indexterm"/><a id="IDX-CHP-7-0166" class="indexterm"/></p></div><div class="sect2" title="Either a As a Functor"><div class="titlepage"><div><div><h2 class="title"><a id="either_a_as_a_functor"/>Either a As a Functor</h2></div></div></div><p>How about <code class="literal">Either a b</code>? Can this be made a functor? The <code class="literal">Functor</code> type class wants a type constructor that takes only one type parameter, but <code class="literal">Either</code> takes two. Hmmm . . . I know, we’ll partially apply <code class="literal">Either</code> by feeding it only one parameter, so that it has one free parameter.</p><p>Here’s how <code class="literal">Either a</code> is a functor in the standard libraries, more specifically in the <code class="literal">Control.Monad.Instances</code> module:</p><a id="I_programlisting7_d1e13324"/><pre class="programlisting">instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x</pre><p>Well well, what do we have here? You can see how <code class="literal">Either a</code> was made an instance instead of just <code class="literal">Either</code>. That’s because <code class="literal">Either a</code> is a type constructor that takes one parameter, whereas <code class="literal">Either</code> takes two. If <code class="literal">fmap</code> were specifically for <code class="literal">Either a</code>, the type signature would be this:</p><a id="I_programlisting7_d1e13347"/><pre class="programlisting">(b -&gt; c) -&gt; Either a b -&gt; Either a c</pre><p>Because that’s the same as the following:</p><a id="I_programlisting7_d1e13351"/><pre class="programlisting">(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</pre><p>The function is mapped in the case of a <code class="literal">Right</code> value constructor, but it isn’t mapped in the case of a <code class="literal">Left</code>. Why is that? Well, looking back at how the <code class="literal">Either a b</code> type is defined, we see this:</p><a id="I_programlisting7_d1e13364"/><pre class="programlisting">data Either a b = Left a | Right b</pre><p>If we wanted to map one function over both of them, <code class="literal">a</code> and <code class="literal">b</code> would need to be the same type. Think about it: If we try to map a function that takes a string and returns a string, and <code class="literal">b</code> is a string but <code class="literal">a</code> is a number, it won’t really work out. Also, considering what <code class="literal">fmap</code>’s type would be if it operated only on <code class="literal">Either a b</code> values, we can see that the first parameter must remain the same, while the second one can change, and the first parameter is actualized by the <code class="literal">Left</code> value constructor.</p><p>This also goes nicely with our box analogy if we think of the <code class="literal">Left</code> part as sort of an empty box with an error message written on the side telling us why it’s empty.</p><p>Maps from <code class="literal">Data.Map</code> can also be made into functor values, because they hold values (or not!). In the case of <code class="literal">Map k v</code>, <code class="literal">fmap</code> will map a function <code class="literal">v -&gt; v'</code> over a map of type <code class="literal">Map k v</code> and return a map of type <code class="literal">Map k v'</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">'</code> character has no special meaning in types, just as it has no special meaning when naming values. It’s just used to denote things that are similar, but slightly changed.<a id="IDX-CHP-7-0167" class="indexterm"/><a id="IDX-CHP-7-0168" class="indexterm"/><a id="IDX-CHP-7-0169" class="indexterm"/><a id="IDX-CHP-7-0170" class="indexterm"/><a id="IDX-CHP-7-0171" class="indexterm"/><a id="IDX-CHP-7-0172" class="indexterm"/><a id="IDX-CHP-7-0173" class="indexterm"/><a id="IDX-CHP-7-0174" class="indexterm"/></p></div><p>As an exercise, you can try to figure out how <code class="literal">Map k</code> is made an instance of <code class="literal">Functor</code> by yourself!</p><p>As you’ve seen from the examples, with <code class="literal">Functor</code>, type classes can represent pretty cool higher-order concepts. You’ve also had some more practice with partially applying types and making instances. In <a class="xref" href="ch11.html" title="Chapter 11. Applicative Functors">Chapter 11</a>, we’ll take a look at some laws that apply for functors.</p></div></div>
<div class="sect1" title="Kinds and Some Type-Foo"><div class="titlepage"><div><div><h1 class="title"><a id="kinds_and_some_type-foo"/>Kinds and Some Type-Foo</h1></div></div></div><p>Type constructors take other types as parameters to eventually produce concrete types. This behavior is similar to that of functions, which take values as parameters to produce values. Also like functions, type constructors can be partially applied. For example, <code class="literal">Either String</code> is a type constructor that takes one type and produces a concrete type, like <code class="literal">Either String Int</code>.<a id="IDX-CHP-7-0175" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e13489"/><img src="httpatomoreillycomsourcenostarchimages802612.png.jpg" alt="image with no caption"/></div></div><p>In this section, we’ll take a look at formally defining how types are applied to type constructors. You don’t really need to read this section to continue on your magical Haskell quest, but it may help you to see how Haskell’s type system works. And if you don’t quite understand everything right now, that’s okay, too.</p><p>Values like <code class="literal">3</code>, <code class="literal">"YEAH"</code>, or <code class="literal">takeWhile</code> (functions are also values—we can pass them around and such) each has their own types. Types are little labels that values carry so that we can reason about the values. But types have their own little labels called <span class="emphasis"><em>kinds</em></span>. A kind is more or less the type of a type. This may sound a bit weird and confusing, but it’s actually a really cool concept.</p><p>What are kinds, and what are they good for? Well, let’s examine the kind of a type by using the <code class="literal">:k</code> command in GHCi:</p><a id="I_programlisting7_d1e13515"/><pre class="programlisting">ghci&gt; :k Int
Int :: *</pre><p>What does that <code class="literal">*</code> mean? It indicates that the type is a concrete type. A concrete type is a type that doesn’t take any type parameters. Values can have only types that are concrete types. If I had to read <code class="literal">*</code> out loud (I haven’t had to do that yet), I would say “star,” or just “type.”</p><p>Okay, now let’s see what the kind of <code class="literal">Maybe</code> is:<a id="IDX-CHP-7-0176" class="indexterm"/><a id="IDX-CHP-7-0177" class="indexterm"/></p><a id="I_programlisting7_d1e13538"/><pre class="programlisting">ghci&gt; :k Maybe
Maybe :: * -&gt; *</pre><p>This kind tells us that the <code class="literal">Maybe</code> type constructor takes one concrete type (like <code class="literal">Int</code>) and returns a concrete type (like <code class="literal">Maybe Int</code>). Just as <code class="literal">Int -&gt; Int</code> means that a function takes an <code class="literal">Int</code> and returns an <code class="literal">Int</code>, <code class="literal">* -&gt; *</code> means that the type constructor takes one concrete type and returns a concrete type. Let’s apply the type parameter to <code class="literal">Maybe</code> and see what the kind of that type is:</p><a id="I_programlisting7_d1e13568"/><pre class="programlisting">ghci&gt; :k Maybe Int
Maybe Int :: *</pre><p>Just as you might have expected, we applied the type parameter to <code class="literal">Maybe</code> and got back a concrete type (that’s what <code class="literal">* -&gt; *</code> means). A parallel (although not equivalent—types and kinds are two different things) to this is if we call <code class="literal">:t isUpper</code> and <code class="literal">:t isUpper 'A'</code>. The <code class="literal">isUpper</code> function has a type of <code class="literal">Char -&gt; Bool</code>, and <code class="literal">isUpper 'A'</code> has a type of <code class="literal">Bool</code>, because its value is basically <code class="literal">False</code>. Both those types, however, have a kind of <code class="literal">*</code>.</p><p>We used <code class="literal">:k</code> on a type to get its kind, in the same way as we can use <code class="literal">:t</code> on a value to get its type. Again, types are the labels of values, and kinds are the labels of types, and there are parallels between the two.</p><p>Now let’s look at the kind of <code class="literal">Either</code>:</p><a id="I_programlisting7_d1e13616"/><pre class="programlisting">ghci&gt; :k Either
Either :: * -&gt; * -&gt; *</pre><p>This tells us that <code class="literal">Either</code> takes two concrete types as type parameters to produce a concrete type. It also looks somewhat like the type declaration of a function that takes two values and returns something. Type constructors are curried (just like functions), so we can partially apply them, as you can see here:</p><a id="I_programlisting7_d1e13623"/><pre class="programlisting">ghci&gt; :k Either String
Either String :: * -&gt; *
ghci&gt; :k Either String Int
Either String Int :: *</pre><p>When we wanted to make <code class="literal">Either a</code> part of the <code class="literal">Functor</code> type class, we needed to partially apply it, because <code class="literal">Functor</code> wants types that take only one parameter, while <code class="literal">Either</code> takes two. In other words, <code class="literal">Functor</code> wants types of kind <code class="literal">* -&gt; *</code>, so we needed to partially apply <code class="literal">Either</code> to get this instead of its original kind, <code class="literal">* -&gt; * -&gt; *</code>.</p><p>Looking at the definition of <code class="literal">Functor</code> again, we can see that the <code class="literal">f</code> type variable is used as a type that takes one concrete type to produce a concrete type:<a id="IDX-CHP-7-0178" class="indexterm"/></p><a id="I_programlisting7_d1e13665"/><pre class="programlisting">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</pre><p>We know it must produce a concrete type, because it’s used as the type of a value in a function. And from that, we can deduce that types that want to be friends with <code class="literal">Functor</code> must be of kind <code class="literal">* -&gt; *</code>.</p></div></body></html>