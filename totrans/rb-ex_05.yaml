- en: Chapter 5. Number Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Numbers are fundamental for all computers and programming languages, and Ruby
    is no exception. In this chapter’s scripts, we’ll deal with useful data that is
    primarily numeric but is otherwise quite diverse. We’ll explore some pure math,
    following up with recursion, which I introduced in [Chapter 4](ch04.html "Chapter 4. Text
    Manipulation"). We’ll also do some type conversion, whereby numbers will be represented
    in different ways that are convenient for human users. We’ll also do some unit
    conversion, specifically monetary units.^([[12](#ftn.CHP-5-FNOTE-1)]) While doing
    all of this, we’ll also delve further into metaprogramming, Hashes, using external
    libraries, and two distinct formats for data storage in external files: XML (eXtensible
    Markup Language) and YAML (YAML Ain’t Markup Language). That’s a lot of ground
    to cover, so let’s get started.'
  prefs: []
  type: TYPE_NORMAL
- en: '#15 Computing Powers (power_of.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the most purely mathematical of this chapter’s scripts, and it deals
    with exponentiation. Before we get too far into the script itself, let’s use irb
    to explore how Ruby handles exponentiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the way to express “to the power of” in Ruby is with the double
    asterisk. Since both the number raised to some power and the power itself are
    expressions, they can also be more complex, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can raise a number (called the *base*) to a given exponent easily with the
    `**` operator. As you can see in line four in the above code, when you want to
    reverse a traditional exponentiation, you can use a reciprocal power.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*We use floating-point numbers for the exponent in ❶, because we don’t want
    our expression to be rounded down to zero*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have the base and the exponent, you can find the missing result. If you
    have the result of the exponentiation and the exponent, you can undo your operation
    to find the base by using the reciprocal of the exponent. What if you know the
    base and the result, and want to find the exponent? That’s what this script is
    for. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want this operation to be a method that can be called on any Integer, so
    we take advantage of Ruby’s open classes and simply add a new method. We have
    the standard boilerplate and RDoc up to the method definition at ❶, which shows
    that it takes an argument called `base`. The lines up to and including ❷ cause
    our `power_of` method to exit early under conditions that are not appropriate
    for it to do its job. We return the `nil` value when asked to find a power in
    relation to a `base` that isn’t even an Integer, because that question is meaningless.
    We also return `nil` when the `base` is zero and the result is neither zero nor
    one, because zero raised to any power will always be either zero or one, making
    that question also meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: There will certainly be other situations where our response is meaningful. We
    return `1` at ❸ if the `base` and the result of the exponentiation (`self`) are
    the same value, because any number to the power of one will be itself. We return
    `0` at ❹ if `self` is one, because any number raised to the zero power will equal
    one. This is confusing for many people. How can something multiplied by itself
    zero times be anything?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer lies in what’s called the *multiplicative identity*, which is how
    mathematicians describe the fact that any number times one equals one times that
    number as well as that number itself. You can always assume with any standard
    multiplication that there could be any number of “times one” additions to your
    multiplication, and it won’t matter. We can also see this in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since you can always assume a “times one” for anything multiplied by itself
    twice, or by itself once, you can similarly assume it for something multiplied
    by itself zero times, which is all raising something to the zero power means.
    Therefore, raising something to the zero power will result in a value of one.
  prefs: []
  type: TYPE_NORMAL
- en: At ❺, we return `false` if the base is one. This is because one can never be
    raised to a power that will result in a value other than one. How do we know that
    our result isn’t one? Because we would have already returned a zero at ❹ if `self`
    was one. At ❻, we also return `false` if the absolute value of the `base` (acquired
    through calling `base.abs`) is greater than the absolute value of `self`. We do
    this because you can’t raise a `base` to an Integer power and get a result with
    a smaller absolute value than your original `base`.
  prefs: []
  type: TYPE_NORMAL
- en: Everything from ❶ to ❻ deals with the odd cases—either meaningless situations
    or situations that let us know we’re finished, otherwise known as *exit conditions*.
    What happens next? If a given number is a power of a given `base`, it means that
    that number divided by the `base` is also a power of the `base`, but the exponent
    will be one lower. Let’s demonstrate in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Three to the third power is 27, three to the second power is nine, and 27 is
    equal to nine times three. If we’re trying to find an exponent and none of our
    base cases apply, we can simply divide `self` by the `base`, try to get the power
    of the new divided value relative to the same `base`, and remember to add one
    to our new result if it turns out to be an Integer.
  prefs: []
  type: TYPE_NORMAL
- en: That’s exactly what we do at ❼ and ❽. We define a new variable called `exponent`,
    which is the result of calling the `power_of` method on `self` divided by `base`.
    The `exponent` variable will either be `nil, false`, or an Integer. How do we
    know this? Because we return either `nil` up to ❷, `false` at ❺ or ❻, or an Integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Integers have true Boolean values, so we can test with our standard ternary
    operator, as we do at ❽. If `exponent` evaluates to `true`, it’s an Integer (because
    both `nil` and `false` would evaluate to `false` in the Boolean ternary operation).
    We therefore `return` it, remembering to add one, because we’ve already divided
    by the `base` once. If `exponent` evaluates to `false`, we want to simply `return`
    that value: either `false` or `nil`.'
  prefs: []
  type: TYPE_NORMAL
- en: What happens in our new call to `power_of` on `self` divided by the `base` at
    ❼? It goes through all the same tests from ❶ to ❻, and if none of those apply,
    it divides the new value of `self` by the `base` again, remembering to add yet
    another one to the eventual result. All of this happens inside each iteration
    of the `power_of` method—the first version of it up at the top level doesn’t need
    to know or care about how many other iterations of `power_of` end up being called.
    This is what recursion is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can try out this script in irb by requiring it at the command line with
    `irb -r power_of.rb` or by entering `require ‘power_of.rb’` once you’re in irb.
    Remember that this script can only handle Integers, so `2.power_of(4)` will return
    `false`, rather than `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a sample irb session with some output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[12](#CHP-5-FNOTE-1)]) We’ll make a temperature converter in [Chapter 7](ch07.html
    "Chapter 7. Using, Optimizing, and Testing Functional Techniques"), since it depends
    on concepts we haven’t covered yet.
  prefs: []
  type: TYPE_NORMAL
- en: '#16 Adding Commas to Numbers (commify.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A standard way of formatting numbers is to present them with commas (or some
    other delimiter) separating each group of thousands. Our next script does that
    by adding a method called `commify` to all numbers. You might think that we could
    do this by opening the Integer class and adding a new method to it, as we did
    in `power_of.rb`. This is certainly a reasonable approach, except that we may
    want to use `commify` on floating-point numbers as well. What’s the solution?
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The answer deals with an object-oriented concept called *inheritance*. We discussed
    this earlier in [Chapter 3](ch03.html "Chapter 3. Programmer Utilities") when
    we added methods to the Object class. Inheritance is what allows all other classes
    to use methods of the Object class, because these other classes *inherit* from
    Object. Inheritance is a factor in our `commify` script as well. Let’s examine
    the inheritance hierarchy of some number classes in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used a method called `ancestors` that can be called not on an instance
    of a class, but on the class itself. It returns an Array of all of the ancestors
    of the class on which it is called (by *ancestors* I simply mean the classes from
    which it inherits). You may find it useful to consider inheritance through a biological
    metaphor, in which each class is a species and the ancestor classes are that species’
    ancestor species. We can see that both the Integer class and the Float class inherit
    directly from something called *Precision*.
  prefs: []
  type: TYPE_NORMAL
- en: Precision must be a class—some kind of number, right? Not exactly. Let’s continue
    in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We see that Integer is a *class*, something that can be instantiated. So is
    Float. That’s no surprise. 5 is an Integer, and 3.14 is a Float. But Precision
    is something called a Module, not a Class at all. What are Modules for?
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s continue with our biological metaphor. Both humans and bats are mammals,
    so if we called `Human.ancestors` and `Bat.ancestors`, we would have significant
    overlap—humans and bats have shared ancestors, specifically earlier mammals. If
    we called `Bird.ancestors`, there would be less overlap with either of the others,
    because birds are not mammals. However, bats and most birds can fly, which you
    could think of as a method, in object-oriented terms. We could define `Bat.fly`
    and `Bird.fly` separately, but there is another option available to us.
  prefs: []
  type: TYPE_NORMAL
- en: We can thus define the ability to fly (along with related characteristics and
    behaviors) and add that ability to existing classes. That process is called *mixing
    in*, and it’s how Ruby deals with the problem of assigning the same methods to
    different classes with distinct ancestor classes, like our Bat and Bird example.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by defining the ability to fly as a module, perhaps called Flyable.
    Modules are similar to classes, except that they don’t get instantiated. We’ll
    write our own modules later in [Chapter 10](ch10.html "Chapter 10. More Complex
    Utilities and Tricks, Part II"). For now, keep in mind that the Precision module
    adds behavior to both Integer and Float, just like our hypothetical Flyable. Flyable
    grants the ability to fly to those organisms it’s mixed into, and Precision grants
    the ability to do precise calculations to those numbers it’s mixed into.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are open, just like classes, so we can add new behavior to the Precision
    module, just as we did earlier to the Object class. Let’s take a look at the `commify.rb`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting at ❶, we define some useful constants, just like we do for a class.
    Each definition is preceded by some comments explaining what the constant is for.
    I mentioned that the `commify` method will insert commas at every grouping of
    a thousand. This is customary in the United States, but many other countries use
    a period in place of a comma and use a comma to separate units from floating-point
    portions (for which the United States uses a period). These constants are preset
    for the US notation that is useful for me, since I live here, but you can easily
    customize them to match what’s appropriate for your home country.
  prefs: []
  type: TYPE_NORMAL
- en: After some RDoc that explains the input parameters in the form of a single Hash,
    at ❷ we get to the definition of the `commify` method, our only public method.
    It accepts a Hash argument called `args` to override the default configuration
    constants, as shown at ❸. Note that the `||=` operation means that if `args` asks
    for an override (meaning it has a value in itself for the appropriate Symbol,
    such as `:delimiter` for the delimiter), we use what’s in `args`. Otherwise, we
    fall back to the Module’s appropriate constant. At ❹, we split the Integer and
    Float portions of `self`, although keep in mind that they are both instances of
    the String class, despite the fact that they represent numbers. Ruby allows us
    to assign into two different variable names at a time, as we do here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Symbols make great Hash keys, and that’s a convention you’ll see a great deal
    in both my scripts and in the whole Ruby community. You’d have a terrible time
    trying to do anything in Rails without respecting this convention. Symbols work
    particularly well for this job because they can be used as names or labels for
    things, and they take up an extremely small amount of memory*.^([[13](#ftn.CHP-5-FNOTE-2)])'
  prefs: []
  type: TYPE_NORMAL
- en: We then define a variable called `int_out` and give it the value of a method
    called `format_int`. We do the same for `float_out`, and finally `return` the
    concatenation of those two Strings at ❺. You can see that the real work occurs
    within the formatting methods (`format_int` and `format_float`), both of which
    are `private`.
  prefs: []
  type: TYPE_NORMAL
- en: The format_int Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `format_int` method at ❻ is the more conceptually complicated of the two
    methods. Let’s open irb again and step through this method’s operations. First,
    let’s define some variables representing the inputs to the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s split our String at the appropriate breakpoints, using a regular
    expression representing any group of digits that is the appropriate length. The
    notation `{x}` within a regular expression means *X instances of whatever is to
    the left*, so `a{3}` means *Three instances of the letter* a. We also use string
    interpolation so that we can use our `breakpoint` argument for the number of digits
    to break on. We want to go from right to left, so we’ll use the `reverse` method
    prior to breaking up the String into an Array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then we want to extract only those Array members that are genuine number groups,
    which we can do easily enough with another regular expression `/\d+/` (meaning
    *Consisting of one or more digits and nothing else*) and the `grep` method, which
    finds all members of an Array that match the regex argument that `grep` takes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What else is wrong with our content at this point? Not only are the number groups
    in the wrong order, but the numbers within each group are also reversed. This
    is because we reversed the entire String before doing our `split`. Now we want
    to get everything in the right order. We can just `reverse` our Array, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This won’t work. It puts the groups in the right order, but the digits within
    each group are still reversed. We can use the `map` method to reverse each member
    of the Array instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Oops. Now the digits within each set of three numbers are in the right order,
    but the groups are in the wrong order. We could define yet another variable like
    `reversed_digits` in a two-step operation, but why not take advantage of Ruby’s
    ability to chain methods?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now our digits groups are in the right order and have the correct internal ordering,
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the two different calls to the `reverse` method in the irb example
    are completely different. One is a call to the Array method `reverse` on `reversed_digits`
    and the other is a call to the String method `reverse` on each digit group that
    we call `unit` within the `map` operation.
  prefs: []
  type: TYPE_NORMAL
- en: We still have an Array, and we want a String. This calls for a `join`, using
    the delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our `format_int` method now returns a String that is an altered version of our
    `int_as_string` argument. We break up `int_as_string` at the right point (`breakpoint`),
    insert the `delimiter` between our groups of digits, and make sure that everything
    stays in the right order. That’s it for the integer component.
  prefs: []
  type: TYPE_NORMAL
- en: The format_float Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also want to be able to format floating-point portions of numbers, which
    we do with the `format_float` method at ❼. If there is no floating-point portion,
    it returns an empty String right away. Otherwise, it creates a new variable called
    `output` consisting of the `decimal_pt` argument concatenated with the `float_as_string`
    argument—remember that they’re both Strings, so the plus sign means concatenation.
    If the configuration options are such that the hundredths place is not mandatory
    (you can tell from the `show_hundredths` argument), we can simply `return` the
    `output` variable at ❽. If we need to show the hundredths place and the floating-point
    portion is only a single character wide, we need to concatenate the String `‘0’`
    onto the end of the output at ❾. Otherwise, we can simply `return` the `output`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Type Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll remember that in `power.rb`, we had an early exit condition based on
    whether or not the `base` argument was an Integer at all. You’ll also notice that
    in this script we don’t test any of the numbers to find out whether or not they’re
    real numbers. Why is that? The reason is that our new methods will be included
    in the Precision module, which is only mixed in to classes that represent some
    sort of number, like Integer and Float. Therefore, checks for numeric type are
    not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try this out with a test script. Here are the contents of `tests/test_commify.rb`,
    which we’ll run in the same directory as `commify.rb` with the command `ruby -w
    tests/test_commify.rb 186282.437` at the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We call the `commify` method on the first argument after the script name, which
    in our case is the floating-point number `186282.437`. First, we call it with
    the default parameters with regard to the delimeter character, breakpoint size,
    and so on. Then we call it with some modified configuration parameters, just to
    see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the output I got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Yours should look the same. That’s it for this script.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#CHP-5-FNOTE-2)]) My technical reviewer, Pat Eyler, wisely asked me
    to stress that the *reason* Symbols take up so little space is because each Symbol
    only takes up space once, and all subsequent instances merely refer to that same
    memory space again, instead of duplicating it, as would happen with a String or
    other type of object.
  prefs: []
  type: TYPE_NORMAL
- en: '#17 Roman Numerals (roman_numeral.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous script, you learned how to change the representation of a number
    as a String so that it had commas (or some other desired delimiting character)
    in appropriate places for easier readability. One of the most traditional ways
    to represent a number as a String is as a Roman numeral. This script adds a new
    method to all Integers called `to_roman`. Let’s see it in action in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you remember your Roman numerals, you will see that `to_roman` follows your
    expectations. It returns the empty string for zero and uses the *subtractive*
    approach of reporting four as *IV*, using a lower-value letter to the left of
    a higher-value letter to indicate subtraction. Let’s look at the source code to
    see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we only need to give Integers the ability to report their Roman numeral
    representation, we’ll open up the Integer class and give it this new method. After
    defining some constants at ❶, let’s skip down to ❷, where we define the public
    method `to_roman` that we’ve seen used in irb. In it, we define something called
    `@@roman_of`, and use the `||=` operator to set its value to that of the output
    of a method called `create_roman_of`, unless `@@roman_of` already evaluates to
    `true`. Why does it have two `@` signs at the front? We’ve already seen instance
    variables with a single `@` sign and constants that must begin with an uppercase
    letter (and traditionally are entirely uppercase), but this is something new called
    a *class variable*.
  prefs: []
  type: TYPE_NORMAL
- en: Class Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class variables are shared among every instance of a class but are able to change
    value. Let’s verify in irb that several different instances of any given class
    variable have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We define a new class variable called `@@class_var` for all Strings and also
    give all strings a new method called `cv` that returns `@@class_var`. We find
    that it has the same value for all Strings, including Strings that did not yet
    exist when we defined `@@class_var`.
  prefs: []
  type: TYPE_NORMAL
- en: We have a class variable called `@@roman_of`. What is it? To answer that, we
    need to look inside the private method `create_roman_of` at ❽. It returns a constant
    called `ARABIC_TO_ROMAN`, unless some other constant called `SUBTRACTIVE` is true.
    We can see from our constant definition section (❶) that we have set `SUBTRACTIVE`
    to true, so `create_roman_of` will not return `ARABIC_TO_ROMAN` with our current
    configuration settings. Instead, it will return the result of calling the method
    `merge` on `ARABIC_TO_ROMAN`, with `SUBTRACTIVE_TO_ROMAN` as its single argument.
  prefs: []
  type: TYPE_NORMAL
- en: Hash.merge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point we need to learn what `ARABIC_TO_ROMAN` is so we know what happens
    when `merge` is called on it. We can see from ❶ that both `ARABIC_TO_ROMAN` and
    `SUBTRACTIVE_TO_ROMAN` are Hashes. Their keys are Arabic numerals, and each key’s
    value is the representation of the key as a Roman numeral. This script can only
    represent Roman numerals up to 4,999, so we could simply define a single Hash
    of `ALL_ARABICS_TO_ROMAN` with a key for every value from one to 4,999 and be
    done with it.
  prefs: []
  type: TYPE_NORMAL
- en: That would work, but it would be terribly inelegant. What we’ve done instead
    is define base cases from which we will extrapolate all cases between zero and
    4,999\. We also separate out cases of subtractive representation (such as IV for
    four) into a separate Hash, allowing us to easily turn that feature on or off,
    as we do with the `SUBTRACTIVE` constant and the `create_roman_of` method, which
    uses the `merge` method of Hashes. This `merge` method allows a Hash to incorporate
    the information from a second Hash into itself. Let’s explore that in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can see not only that `merge` combines key/value pairs, but also that the
    incoming information (meaning the Hash argument to the `merge` method) overrides
    pre-existing pairs in the calling Hash. That’s why the `“key1”=>nil` pair from
    `hash3` overrides the `”key1“=>“value1”` pair from `hash1`. You’ll also note that
    the returned value of the `merge` method is itself just another Hash, so we can
    call any Hash method on it, including `merge` again.
  prefs: []
  type: TYPE_NORMAL
- en: So the first time we call the `to_roman` method (❷), we create a class variable
    called `@@roman_of` that contains base cases for transliteration into Roman numerals.
    It either uses the subtractive approach or it doesn’t, depending on our configuration
    options. It includes subtractive representation by default. After all that, we
    `return` an empty String at ❸ unless the Integer (`self`) is greater than zero.
  prefs: []
  type: TYPE_NORMAL
- en: You may remember that I said this script can handle Roman numerals for Integers
    up to 4,999\. That’s where line ❹ and the `maximum_representable` method (defined
    at ❾) come in. The largest value that Roman numerals can represent (without introducing
    vertical bars above letters that are not strictly part of the standard Roman alphabet)
    is 4,999, so I decided to stop there. If the Integer in question (`self`) is greater
    than the maximum value that can be shown, we simply return the result of the `to_s`
    method (❹). Let’s see this in action in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once we hit the upper limit, we still return a String representing a numeric
    value (which is all a Roman numeral is), we just use the familiar Arabic numeral
    symbols within our String.
  prefs: []
  type: TYPE_NORMAL
- en: More Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the lines from ❷ through ❹ remind you of the exit conditions in `power_of.rb`
    that prepared for a recursive call to the same method, you’ve been paying attention.
    That’s exactly what we’re about to do here. At ❺ we create a variable called `base`
    that is the value of a long chain of method calls starting on the `@@roman_of`
    class variable. The purpose of these method calls is to find the largest key of
    the `@@roman_of` Hash that is less than or equal to the `self` Integer.
  prefs: []
  type: TYPE_NORMAL
- en: We get the keys out with the `keys` method, which returns an Array of the Hash’s
    keys. We then `sort` that Array in `reverse` order, meaning that we start from
    highest to lowest. We then call a new Array method called `detect` with the conditions
    of being less than or equal to `self`. I think a great alias for detect would
    be *find first*. Let’s see it in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `detect` method cycles through each member of the Array and returns the
    first Array element that matches the conditions in the block. This is what allows
    us to find the highest value representable in terms of the `@@roman_of` Hash,
    which we put into the `base` variable at ❺. At ❻ we `return` the empty String,
    unless we both found a `base` and that `base` is greater than zero; without a
    `base` greater than zero, we can’t return anything useful.
  prefs: []
  type: TYPE_NORMAL
- en: Multiples of Our Base
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a `base` that’s an Integer greater than zero. If we’re calling something
    like `1066.to_roman`, we have no problem, because our `base` value (1,000) is
    the entire thousands place portion of our Integer. But what if we want something
    like `2112.to_roman` instead? We need to be able to keep track of how many multiples
    of `base` can go into our Integer. That’s what we do at ❼.
  prefs: []
  type: TYPE_NORMAL
- en: We use the method `round_to_base` (defined at ❿) to determine the number of
    multiples of `base` we need to deal with. Our call to `round_to_base` tells us
    how many multiples of `base` we need to handle. Calling `@@roman_of[base]` also
    finds the single letter used to represent the base.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying Strings by Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiplying a String by an Integer results in that String concatenated with
    itself as many times as the Integer. Let’s see that in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is taken directly from our `2112.to_roman` example. The output of `“MM”`
    takes care of representing the 2,000 portion of 2,112, and at line ❼ we also make
    a recursive call to `to_roman`; this time, however, we call it on a smaller number,
    specifically 112\. Because the number on which we call the `to_roman` method keeps
    getting smaller as we pull off multiples of `base`, we will eventually reach a
    point where we’ll exit with the empty String at ❸, marking the end of all of our
    recursive calls to `to_roman`. That’s when we get our final output.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is easily demonstrated within irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other options you could take with this script. Instead of making `SUBTRACTIVE`
    a class constant, we could have made the `to_roman` method take an argument. If
    you do that, you would need to keep track of two separate `[SOMETHING]_TO_ROMAN`
    Hashes, one using the subtractive display method, and one not using it. I decided
    to assume that the subtractive approach would be used because it does seem to
    be very common for Roman numerals. However, I thought I would mention how you
    could customize this script to make it slightly more complicated—but also more
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit the idea of representing Integers as different sorts of Strings
    later when we create the `to_lang` method. For now, let’s continue on to our first
    currency converter.
  prefs: []
  type: TYPE_NORMAL
- en: '#18 Currency Conversion, Basic (currency_converter1.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned earlier that the `commify` method needs to vary based on how each
    country treats the notation of numbers. The area where this issue comes up most
    often is with currency, of course. The actual conversion process consists of relatively
    straightforward math, but we’ll use this script as a vehicle to set the stage
    for two important concepts introduced in our next script—notably the representation
    of data with either *XML* (eXtensible Markup Language, [http://www.w3c.org/xml](http://www.w3c.org/xml))
    or *YAML* (YAML Ain’t Markup Language, [http://www.yaml.org](http://www.yaml.org)).
    We’ll explore both XML and YAML further in the next script, but for now, let’s
    try out our current script in irb with `irb -r currency_converter.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can see on our irb session’s first response that our `cc` instance seems
    to have some fondness for the US dollar—but if you’re in some other country, don’t
    worry, you’ll learn how to use different currencies in the improved version of
    the script. In ❶ you can see that our `cc` instance’s `output_rates` method takes
    an argument and seems to output the equivalent of that many US dollars in a few
    other currencies. You can see in ❷ that the values shift as expected with a different
    number of US dollars. Let’s see how this works by examining the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At ❶, we define the “home” currency of the class, and immediately following,
    we define some handy codes for various other currencies via the `FULLNAME_OF`
    and `EXCHANGE_RATES` Hashes. The `EXCHANGE_RATES` Hash contains our preset exchange
    rate values. These were current at the time I created this object, but I’m sure
    they’ll be at least slightly different by the time you read this.
  prefs: []
  type: TYPE_NORMAL
- en: The `initialize` method at ❷ gives us some handy instance variables related
    to the home currency, and our only public method `output_rates` (❸) is simply
    a wrapper for the private `get_value` method (❺) with a newline.^([[14](#ftn.CHP-5-FNOTE-3)])
    The `get_value` method also uses another private method called `get_rates`, the
    definition of which (❹) should be fairly clear to you at this point.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_value` method also uses another private method called `pluralize` (❿),
    which returns a String in which the term for the currency is plural when appropriate.
    I’ve implemented this very simply, because English only requires an s at the end
    of a term to pluralize it. With a few changes, this method could handle other
    languages or terms with more complex pluralization needs, most likely a Hash with
    currency terms as keys and plural endings as values. For now, we just need to
    add an `s` to the end of currency amounts greater than one.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_value` method returns (❻) a pluralized form of the base currency with
    an equals sign, followed by information about each of the currencies the class
    knows about. Starting at ❼, it maps an operation onto each currency type (represented
    by the keys of the `rates` Hash). The mapped operation (❽) is the outputting of
    a tab character, followed by properly pluralized output for that currency based
    on its relative value, full name, and abbreviation. Each currency’s String output
    is then joined together with newline characters at ❾, concluding the `return`
    statement begun back at ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is also easily demonstrated in irb with `irb -r currency_converter1.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the prettier output comes from using `puts` and that the returned
    value from `output_rates` is `nil`, largely because it’s intended to print results
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is all fine when exchange rates are constant and can be stored in a constant
    Hash, as in this script. However, the main impetus of having a currency converter
    stems from the fact that exchange rates constantly change. We need a converter
    that can update itself with new information when that information becomes available
    and yet continue to work when such information is inaccessible, for whatever reason.
    That’s our next script.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#CHP-5-FNOTE-3)]) We defined `initialize` before the `private` keyword,
    but `initialize` is always a private method, so `output_rates` is the only public
    method of CurrencyConverter.
  prefs: []
  type: TYPE_NORMAL
- en: '#19 Currency Conversion, Advanced (currency_converter2.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script builds on what we already know from the previous one and uses a
    similar approach for the actual conversion process. What we’ve added is the ability
    to store and retrieve external data in both YAML and XML formats. YAML is so readable
    that I will simply tell you what you need to know for this script, and I’m sure
    that you’ll be inspired to learn more about how it works. XML is a bit more complicated,
    and it’s beyond the scope of this book to teach it to you if you’re not familiar
    with it, but you won’t need to be an expert to follow along. I’ll describe the
    relevant bits of XML for this script’s operation, just as I’ll do with YAML. If
    you find that the XML-related content of this chapter is going a bit too fast,
    please refer to the excellent online XML Tutorial at [http://www.w3schools.com/xml](http://www.w3schools.com/xml).
  prefs: []
  type: TYPE_NORMAL
- en: This script differs from the previous in several ways. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does this file differ from the previous one? The class definition of CurrencyConverter
    is delayed until ❸, due to some more comments and `require` statements at ❶. I
    also open the Hash class and give it a subtraction method, identified by the minus
    sign at ❷. This new method takes another Hash and returns the original Hash without
    any pairs found in the argument Hash. Think of it this way: If `merge` is addition
    of Hashes, this method is the subtraction of Hashes. I suppose a good alternative
    name would be either `demerge` or `unmerge` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our CurrencyConverter class (❸), we have two new constants: `BASE_URL`,
    which is used for downloading completely new exchange rates, and `RATES_DIRECTORY`,
    which is used to store exchange rates once they have been downloaded. The class’s
    `initialize` method accepts a currency `code`, so folks from other countries can
    define their own native converters more easily. (It assumes US dollars with no
    argument.) If it gets a currency `code` that it doesn’t understand, it shouldn’t
    proceed, so we make it break out of the entire program with the command `fail`,
    which causes the program to stop running. The `output_rates` method (❹) also tries
    to get new rates when told to, saves rates in a local file, and performs the operations
    we already know about from the last script.'
  prefs: []
  type: TYPE_NORMAL
- en: How does it get new rates? The `get_rates` method (❻) shows us that it either
    loads old rates or downloads new rates. If it tries to `download_new_rates` (❺)
    but fails to do so, it will fall back to its old rates again. It defaults to downloading
    new rates, so let’s look at `download_new_rates`.
  prefs: []
  type: TYPE_NORMAL
- en: After some explanatory printing, we get a `begin` statement, which starts a
    block of code that means *Try something, and fall back to some other code if the
    attempt fails*. What we’re trying to do is call the `get_xml_lines` method. If
    that fails, we’ll explain to the user via `puts` that the download failed and
    return `nil`. The `end` statement tells us that the block of code pertaining to
    the `begin` has ended. The `return nil` is what allows us to fall back to old
    exchanges rates within `get_rates` if the `get_xml_lines` method failed.
  prefs: []
  type: TYPE_NORMAL
- en: So what does `get_xml_lines` do? It’s defined at ❼, and it finds all lines from
    a given XML file in which one unit of the base currency appears with an equals
    sign. These lines tell us our exchange rates. Let’s take a look at what one of
    those XML files looks like. Here are a few lines from a file I downloaded from
    [http://www.currencysource.com/RSS/USD.xml](http://www.currencysource.com/RSS/USD.xml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you’re not already familiar with XML, you can see here that it consists of
    text in which various content is enclosed by *tags*, which are those bits of text
    within the `<` and `>` characters. Newlines are not meaningful. We have two definitions
    of a type of thing called `item`, each of which has a title, a link, a description,
    and a pubDate. This is the content we’re searching through. You’ll notice that
    the `<title>` lines contain direct statements about exchange rates between the
    base currency and some other currency—in my example, the Argentinian peso and
    the Australian dollar.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this operation might fail is that the file we’re trying to open and
    call `readlines` on is not a local file, but a file retrieved from the Internet
    via a URL. The `open-uri` library that we required at ❶ modifies the `open` command
    to allow us to open URLs as well as local files. Without a functioning Internet
    connection, the `open` will fail, meaning that there will be no file on which
    to call the `readlines` method within `get_xml_lines`. However, if our download
    operation worked, we’ll be able to assign content into the `raw_rate_lines` variable
    within `download_new_rates`. The rest of the `download_new_rates` method extracts
    the exchange rate content out of the raw lines.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Rates Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `download_new_rates` method extracts the exchange rate by first defining
    a variable for the `rates`, which is a Hash. We give `Hash.new` an argument halfway
    through `download_new_rates` so that when a given key is not found in the Hash,
    the returned value is no longer `nil`, but instead the argument that was passed
    to `Hash.new` (the empty String in our example). For our purposes, we want to
    find `comparison_codes`, which are all the pairs pertaining to currencies and
    their codes, without the `@base_currency`.^([[15](#ftn.CHP-5-FNOTE-4)]) We then
    cycle through each key, which is the abbreviation or code associated with the
    matching currency, and call the `get_rate_for_abbr_from_raw_rate_lines` method,
    which gets the exchange rate for a given abbreviation from the `raw_rate_lines`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_rate_for_abbr_from_raw_rate_lines` method is defined immediately after
    the definition of `get_rates` at ❻. The `regex` variable is a Hash that stores
    some regular expressions that signify the opening and closing of the content we
    care about (the actual exchange rate value). We detect the first line containing
    the interpolated `abbr` value and then strip off the opening and closing `regex`
    values by substituting each of them with the empty string. We then `return` the
    floating-point version (via the `to_f` method) of what we have left. That’s the
    exchange rate for the currency matching the `abbr` argument.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve gotten our rates via downloading, which means that we’re ready to save
    them into a local file within `initialize`. We immediately exit `save_rates_in_local_file!`
    (❿) and do nothing if we have no rates. The reason for this is that if there is
    some problem with getting rates, we don’t want to overwrite our good stored data
    from a previous use of this script. Assuming that all is well, we open a new file
    for writing with the name `rates_filename`, which looks like a variable. It’s
    actually a method, defined at ❾. It returns something like `“extras/currency_exchange_rates/USD.yaml”`
    or `“extras/currency_exchange_rates/CAD.yaml”`, depending on what your base currency
    is. It’s a method because it’s entirely dependent on the value of `@base_currency`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some schools of programming would have defined an instance variable *`@rates_filename`*
    within the *`initialize`* method, just as we did with *`@base_currency`* and *`@name`*.
    Conversely, we could have treated *`@name`* the same way we do *`rates_filename`*,
    defining a method called *`name`* that simply returns the value of *`CURRENCY_CODES[@base_currency]`*.
    Either approach is useful. Using an instance variable (the “eager” approach) is
    faster, but the different variables with a close relationship to each other could
    get out of sync, especially in a more complex program. Using a method (the “lazy”
    approach) is slower, because it has to recalculate its return value every time—but
    it also means that your variables won’t get out of agreement with each other,
    at least in this case*.'
  prefs: []
  type: TYPE_NORMAL
- en: Whether it’s an instance variable or a method, our main concern regarding `rates_filename`
    is that it is a name of a file that can be written into. We do the writing using
    `YAML.dump`, which takes two arguments; the first is a data structure that will
    be converted into YAML and written into the second argument, which is a File object.
    Let’s open `extras/currency_exchange_rates/USD.yaml` and see what we’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That’s the entire content of `USD.yaml`. It represents a single Hash whose keys
    are currency codes and whose values are floating-point numbers. You’ll notice
    that newlines are significant, and while this example doesn’t show it, so is indentation.
    There’s a lot about YAML that you can learn at [http://www.yaml.org](http://www.yaml.org),
    but I find that `YAML.dump` is a great way to learn how things are represented
    in YAML. If you pass a data structure that you understand into `YAML.dump`, you
    can read the resulting. yaml file to see what the proper representation is. You
    can then change the data structure in some specific way, rewrite using `YAML.dump`,
    and compare the results. It’s very useful.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, we have now stored our exchange rate data as YAML in an external
    file, using `save_rates_in_local_file!`. We still have the `rates` variable available,
    so we use it, calling the `get_value` method, which uses the same approach as
    in the previous script.
  prefs: []
  type: TYPE_NORMAL
- en: What If You Can’t Download New Rates?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a later call to the script, we might not be able to download new rates, as
    previously noted. Therefore, let’s look at the `get_rates` method again and assume
    that we either told the script not to download new rates (using a `false` value
    for the `try_new_rates` argument) or that the download attempt failed. Either
    way, we’ll need to get our rates from the stored YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `load_old_rates` method is at ❽. It informs the user that there will be
    an attempt to read from the local file. Getting the real data out of a YAML file
    could hardly be easier: You just call `YAML.load`, and give it a File argument,
    which, in our case is the result of calling `File.open` on `rates_filename`. The
    result of `YAML.load` is whichever data structure was stored in the external file,
    so we simply assign it into a variable called `rates`. We then ensure that we
    were able to read data into `rates` before proceeding, and finally return `rates`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After all this explanation, it’s finally time to see the script in action in
    irb with `irb -r currency_converter2.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we can easily define converters for specific currencies; then
    we can tell the `output_rates` method to try to download new rates or not to download
    them, depending on whether or not the optional second argument evaluates to `false`.
    In line ❶, you see that I’ve passed in `(not true)` just to make that point. You’ll
    also notice that the return values with special characters like newlines and tabs
    represent those characters the same way we do when we insert them, while printing
    those return values causes them to be interpreted, making the printing output
    prettier, or at least more easily readable.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script depends on the directory hierarchy at `BASE_URL` staying the same.
    If it ever changes, you will need to update `get_xml_lines()` at ❼ accordingly.
    We’re also about to get deeper into some functional programming topics. Once you’re
    comfortable with `lambda` (introduced in the next chapter), you could replace
    the `rates_filename` method with a lambda that accepts `RATES_DIRECTORY` and `@base_currency`
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#CHP-5-FNOTE-4)]) We remove the `@base_currency` since it’s not useful
    to give the exchange rate between a given currency and itself—the rate would always
    be exactly one.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was new in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: Exponentiation in Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning `nil` when a method’s operation is not possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More recursion and exit conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hash.merge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.detect` (“find first”)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtracting Hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting the entire script with `fail`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`begin—rescue—end`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading with `open-uri`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing XML files with regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to YAML files with `YAML.dump`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from YAML files with `YAML.load`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s almost as if this chapter weren’t really about numbers—we covered a large
    amount of generically useful information, especially Modules, Class Variables,
    and external data storage and retrieval using either XML or YAML (or both). We’ve
    done a bit of functional programming already in the last two chapters, but we’ll
    get into the deep lambda magic in [Chapter 6](ch06.html "Chapter 6. Functionalism
    with Blocks and Procs").
  prefs: []
  type: TYPE_NORMAL
