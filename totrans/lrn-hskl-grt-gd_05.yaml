- en: Chapter 5. Higher-Order Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。高阶函数
- en: Haskell functions can take functions as parameters and return functions as return
    values. A function that does either of these things is called a *higher-order
    function*. Higher-order functions are a really powerful way of solving problems
    and thinking about programs, and they’re indispensable when using a functional
    programming language like Haskell.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell函数可以接受函数作为参数，并返回函数作为返回值。执行这些操作的函数被称为*高阶函数*。高阶函数是解决问题和思考程序的一种非常强大的方式，当使用像Haskell这样的函数式编程语言时，它们是必不可少的。
- en: Curried Functions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化函数
- en: Every function in Haskell officially takes only one parameter. But we have defined
    and used several functions that take more than one parameter so far—how is that
    possible?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell中的每个函数官方上只接受一个参数。但到目前为止，我们已经定义并使用了几个接受超过一个参数的函数——这是怎么做到的？
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802552.png.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802552.png.jpg)'
- en: Well, it’s a clever trick! All the functions we’ve used so far that accepted
    multiple parameters have been *curried functions*. A curried function is a function
    that, instead of taking several parameters, always takes exactly one parameter.
    Then when it’s called with that parameter, it returns a function that takes the
    next parameter, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是一个巧妙的技巧！我们迄今为止使用的所有接受多个参数的函数都是*柯里化函数*。柯里化函数是一种函数，它不是接受多个参数，而是始终只接受一个参数。然后当它用那个参数被调用时，它返回一个接受下一个参数的函数，依此类推。
- en: 'This is best explained with an example. Let’s take our good friend, the `max`
    function. It looks as if it takes two parameters and returns the one that’s bigger.
    For instance, consider the expression `max 4 5`. We call the function `max` with
    two parameters: `4` and `5`. First, `max` is applied to the value `4`. When we
    apply `max` to `4`, the value that is returned is actually another function, which
    is then applied to the value `5`. The act of applying this function to `5` finally
    returns a number value. As a consequence, the following two calls are equivalent:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好用一个例子来说明。让我们以我们的好朋友`max`函数为例。它看起来像接受两个参数并返回较大的那个。例如，考虑表达式`max 4 5`。我们用两个参数调用`max`函数：`4`和`5`。首先，`max`应用于值`4`。当我们把`max`应用于`4`时，返回的实际上是一个函数，然后这个函数被应用于值`5`。将这个函数应用于`5`最终返回一个数值。因此，以下两个调用是等价的：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To understand how this works, let’s examine the type of the `max` function:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解它是如何工作的，让我们检查一下`max`函数的类型：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can also be written as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成以下形式：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Whenever we have a type signature that features the arrow `->`, that means it’s
    a function that takes whatever is on the left side of the arrow and returns a
    value whose type is indicated on the right side of the arrow. When we have something
    like `a -> (a -> a)`, we’re dealing with a function that takes a value of type
    `a`, and it returns a function that also takes a value of type `a` and returns
    a value of type `a`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有一个带有箭头`->`的类型签名时，这意味着它是一个函数，它接受箭头左侧的任何内容，并返回一个类型在箭头右侧指示的值。当我们有类似`a -> (a
    -> a)`的东西时，我们正在处理一个接受类型为`a`的值的函数，它返回一个也接受类型为`a`的值并返回类型为`a`的值的函数。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802554.png.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802554.png.jpg)'
- en: So how is that beneficial to us? Simply speaking, if we call a function with
    too few parameters, we get back a *partially applied* function, which is a function
    that takes as many parameters as we left out. For example, when we did `max 4`,
    we got back a function that takes one parameter. Using partial application (calling
    functions with too few parameters, if you will) is a neat way to create functions
    on the fly, so we can pass them to other functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对我们有什么好处呢？简单来说，如果我们用一个参数太少的方式来调用一个函数，我们会得到一个*部分应用*的函数，这是一个接受我们遗漏的参数数量的函数。例如，当我们执行`max
    4`时，我们得到一个接受一个参数的函数。使用部分应用（如果你愿意的话，就是用参数太少的函数调用）是一种创建函数的好方法，因此我们可以将它们传递给其他函数。
- en: 'Take a look at this simple little function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个简单的小函数：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What really happens when we call `multThree 3 5 9`, or `((multThree 3) 5) 9`?
    First, `multThree` is applied to `3`, because they’re separated by a space. That
    creates a function that takes one parameter and returns a function. Then that
    function is applied to `5`, which creates a function that will take one parameter,
    multiply 3 and 5 together, and then multiply that by the parameter. That function
    is applied to `9`, and the result is 135.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `multThree 3 5 9` 或 `((multThree 3) 5) 9` 时，实际上发生了什么？首先，`multThree` 被应用到
    `3` 上，因为它们之间有一个空格。这创建了一个接受一个参数并返回一个函数的函数。然后，这个函数被应用到 `5` 上，创建了一个将接受一个参数，将 `3`
    和 `5` 相乘，然后将结果乘以该参数的函数。这个函数被应用到 `9` 上，结果是 `135`。
- en: You can think of functions as tiny factories that take some materials and produce
    something. Using that analogy, we feed our `multThree` factory the number `3`,
    but instead of producing a number, it churns out a slightly smaller factory. That
    factory receives the number `5` and also spits out a factory. The third factory
    receives the number `9`, and then produces our resulting number, `135`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函数想象成小型的工厂，它们接受一些材料并生产出东西。使用这个类比，我们向我们的 `multThree` 工厂提供数字 `3`，但它不是生产一个数字，而是产生一个稍微小一点的工厂。这个工厂接收数字
    `5` 并也吐出一个工厂。第三个工厂接收数字 `9`，然后产生我们的结果数字，`135`。
- en: 'Remember that this function’s type can also be written as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个函数的类型也可以写成以下形式：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The type (or type variable) before the `->` is the type of the values that a
    function takes, and the type after it is the type of the values it returns. So
    our function takes a value of type `Int` and returns a function of type `(Int
    -> (Int -> Int)`. Similarly, *this* function takes a value of type `Int` and returns
    a function of type `Int -> Int`. And finally, *this* function just takes a value
    of type `Int` and returns another value of type `Int`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `->` 前面的类型（或类型变量）是函数接受的值的类型，在它后面的类型是它返回的值的类型。所以我们的函数接受一个类型为 `Int` 的值并返回一个类型为
    `(Int -> (Int -> Int)` 的函数。同样，*这个* 函数接受一个类型为 `Int` 的值并返回一个类型为 `Int -> Int` 的函数。最后，*这个*
    函数只接受一个类型为 `Int` 的值并返回另一个类型为 `Int` 的值。
- en: 'Let’s look at an example of how we can create a new function by calling a function
    with too few parameters:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，说明我们如何通过调用参数不足的函数来创建一个新的函数：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the expression `multThree 9` results in a function that takes
    two parameters. We name that function `multTwoWithNine`, because `multThree 9`
    is a function that takes two parameters. If both parameters are supplied, it will
    multiply the two parameters between them, and then multiply that by `9`, because
    we got the `multTwoWithNine` function by applying `multThree` to `9`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，表达式 `multThree 9` 得到一个接受两个参数的函数。我们称这个函数为 `multTwoWithNine`，因为 `multThree
    9` 是一个接受两个参数的函数。如果两个参数都提供了，它将在它们之间乘以两个参数，然后乘以 `9`，因为我们通过将 `multThree` 应用到 `9`
    得到 `multTwoWithNine` 函数。
- en: 'What if we wanted to create a function that takes an `Int` and compares it
    to `100`? We could do something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个接受 `Int` 并将其与 `100` 进行比较的函数，我们可以这样做：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As an example, let’s try calling the function with `99`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试用 `99` 调用这个函数：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`100` is greater than `99`, so the function returns `GT`, or greater than.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`100` 大于 `99`，所以函数返回 `GT`，即大于。'
- en: 'Now let’s think about what `compare 100` would return: a function that takes
    a number and compares it with `100`, which is exactly what we were trying to get
    in our example. In other words, the following definition and the previous one
    are equivalent:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们思考一下 `compare 100` 会返回什么：一个接受一个数字并将其与 `100` 进行比较的函数，这正是我们在例子中试图得到的东西。换句话说，以下定义和前面的定义是等价的：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The type declaration stays the same, because `compare 100` returns a function.
    `compare` has a type of `(Ord a) => a -> (a -> Ordering)`. When we apply it to
    `100`, we get a function that takes a number and returns an `Ordering`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明保持不变，因为 `compare 100` 返回一个函数。`compare` 的类型是 `(Ord a) => a -> (a -> Ordering)`。当我们将其应用到
    `100` 上时，我们得到一个接受一个数字并返回一个 `Ordering` 的函数。
- en: Sections
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分
- en: 'Infix functions can also be partially applied by using *sections*. To section
    an infix function, simply surround it with parentheses and supply a parameter
    on only one side. That creates a function that takes one parameter and then applies
    it to the side that’s missing an operand. Here’s an insultingly trivial example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 中缀函数也可以通过使用 *部分应用* 来部分应用。要部分应用一个中缀函数，只需将其用括号括起来，并在一边提供一个参数。这创建了一个接受一个参数并将其应用到缺少操作数的边的函数。这里有一个令人难以置信的简单例子：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the following code, calling `divideByTen 200` is equivalent
    to calling `200 / 10` or `(/10) 200`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，调用 `divideByTen 200` 等同于调用 `200 / 10` 或 `(/10) 200`：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s look at another example. This function checks if a character supplied
    to it is an uppercase letter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一个例子。这个函数检查传递给它的字符是否为大写字母：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The only thing to watch out for with sections is when you’re using the `-`
    (negative or minus) operator. From the definition of sections, `(-4)` would result
    in a function that takes a number and subtracts 4 from it. However, for convenience,
    `(-4)` means negative four. So if you want to make a function that subtracts 4
    from the number it gets as a parameter, you can partially apply the `subtract`
    function like so: `(subtract 4)`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `-`（负号或减号）运算符时需要注意的只有一点。根据部分应用的定义，`(-4)` 会得到一个接受一个数字并从它减去 4 的函数。然而，为了方便，`(-4)`
    表示负四。所以，如果你想创建一个从它得到的参数中减去 4 的函数，你可以这样部分应用 `subtract` 函数：`(subtract 4)`。
- en: Printing Functions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印函数
- en: So far, we’ve bound our partially applied functions to names and then supplied
    the remaining parameters to view the results. However, we never tried to print
    the functions themselves to the terminal. Let’s give that a go then, shall we?
    What happens if we try entering `multThree 3 4` into GHCi, instead of binding
    it to a name with a `let` or passing it to another function?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将部分应用函数绑定到名称上，然后提供了剩余的参数以查看结果。然而，我们从未尝试将函数本身打印到终端。那么，我们尝试在 GHCi 中输入
    `multThree 3 4` 而不是用 `let` 绑定它到一个名称或传递给另一个函数会发生什么呢？
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: GHCi is telling us that the expression produced a function of type `a -> a`,
    but it doesn’t know how to print it to the screen. Functions aren’t instances
    of the `Show` type class, so we can’t get a neat string representation of a function.
    This is different, for example, than when we enter `1 + 1` at the GHCi prompt.
    In that case, GHCi calculates `2` as the result, and then calls `show` on `2`
    to get a textual representation of that number. The textual representation of
    `2` is just the string `"2"`, which is then printed to the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi 告诉我们表达式产生了一个类型为 `a -> a` 的函数，但它不知道如何将其打印到屏幕上。函数不是 `Show` 类型类的实例，所以我们无法得到一个函数的整洁字符串表示。这与我们在
    GHCi 提示符中输入 `1 + 1` 的情况不同。在这种情况下，GHCi 计算出 `2` 作为结果，然后对 `2` 调用 `show` 来获取该数字的文本表示。`2`
    的文本表示只是字符串 `"2"`，然后将其打印到屏幕上。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you thoroughly understand how curried functions and partial application
    work, because they’re really important!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你彻底理解了柯里化函数和部分应用的工作原理，因为它们非常重要！
- en: Some Higher-Orderism Is in Order
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有些时候需要高级思维
- en: 'In Haskell, functions can take other functions as parameters, and as you’ve
    seen, they can also return functions as return values. To demonstrate this concept,
    let’s write a function that takes a function, and then applies it twice to some
    value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，函数可以接受其他函数作为参数，并且如你所见，它们也可以返回函数作为返回值。为了演示这个概念，让我们编写一个接受一个函数，然后将其应用于某个值两次的函数：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802556.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802556.png)'
- en: Notice the type declaration. For our earlier examples, we didn’t need parentheses
    when declaring function types, because `->` is naturally right-associative. However,
    here parentheses are mandatory. They indicate that the first parameter is a function
    that takes one parameter and returns a value of the same type (`a -> a`). The
    second parameter is something of type `a`, and the return value’s type is also
    `a`. Notice that it doesn’t matter what type `a` is—it can be `Int`, `String`,
    or whatever—but all the values must be the same type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类型声明。在我们的早期示例中，我们声明函数类型时不需要括号，因为 `->` 是自然右结合的。然而，在这里括号是强制性的。它们表示第一个参数是一个接受一个参数并返回相同类型值（`a
    -> a`）的函数。第二个参数是类型为 `a` 的某个东西，返回值的类型也是 `a`。注意，`a` 的类型无关紧要——它可以是一个 `Int`、`String`
    或其他任何类型，但所有值必须是相同类型。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You now know that under the hood, functions that seem to take multiple parameters
    are actually taking a single parameter and returning a partially applied function.
    However, to keep things simple, I’ll continue to say that a given function takes
    multiple parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道，在底层，看似接受多个参数的函数实际上只接受一个参数并返回一个部分应用函数。然而，为了简化问题，我将继续说一个给定的函数接受多个参数。
- en: 'The body of the `applyTwice` function is very simple. We just use the parameter
    `f` as a function, applying `x` to it by separating the `f` and `x` with a space.
    We then apply the result to `f` again. Here are some examples of the function
    in action:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyTwice` 函数的主体非常简单。我们只是使用参数 `f` 作为函数，通过在 `f` 和 `x` 之间留空格将 `x` 应用到它上。然后我们再次将结果应用到
    `f` 上。以下是该函数的一些示例：'
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The awesomeness and usefulness of partial application is evident. If our function
    requires us to pass it a function that takes only one parameter, we can just partially
    apply a function to the point where it takes only one parameter and then pass
    it. For instance, the `+` function takes two parameters, and in this example,
    we partially applied it so that it takes only one parameter by using sections.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用的神奇之处和实用性显而易见。如果我们的函数需要我们传递一个只接受一个参数的函数，我们只需将函数部分应用到只接受一个参数的点，然后传递它。例如，`+`
    函数接受两个参数，在这个例子中，我们通过使用部分应用使其只接受一个参数。
- en: Implementing zipWith
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 zipWith
- en: 'Now we’re going to use higher-order programming to implement a really useful
    function in the standard library called `zipWith`. It takes a function and two
    lists as parameters, and then joins the two lists by applying the function between
    corresponding elements. Here’s how we’ll implement it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用高阶编程来实现标准库中的一个非常有用的函数，称为 `zipWith`。它接受一个函数和两个列表作为参数，然后通过在对应元素之间应用该函数来连接两个列表。以下是我们的实现方法：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First let’s look at the type declaration. The first parameter is a function
    that takes two arguments and returns one value. They don’t have to be of the same
    type, but they can be. The second and third parameters are lists, and the final
    return value is also a list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看类型声明。第一个参数是一个接受两个参数并返回一个值的函数。它们不必是同一类型，但可以是。第二个和第三个参数是列表，最终返回值也是一个列表。
- en: The first list must be a list of type `a` values, because the joining function
    takes `a` types as its first argument. The second must be a list of `b` types,
    because the second parameter of the joining function is of type `b`. The result
    is a list of type `c` elements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表必须是类型 `a` 的值列表，因为连接函数将其第一个参数作为 `a` 类型。第二个必须是类型 `b` 的列表，因为连接函数的第二个参数是类型
    `b`。结果是类型 `c` 的元素列表。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that if you’re writing a function (especially a higher-order function),
    and you’re unsure of the type, you can try omitting the type declaration and checking
    what Haskell infers it to be by using `:t`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你正在编写一个函数（尤其是高阶函数），并且你不确定类型，你可以尝试省略类型声明，并使用 `:t` 检查 Haskell 推断的类型。
- en: This function is similar to the normal `zip` function. The base cases are the
    same, although there’s an extra argument (the joining function). However, that
    argument doesn’t matter in the base cases, so we can just use the `_` character
    for it. The function body in the last pattern is also similar to `zip`, though
    instead of doing `(x, y)`, it does `f x y`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于正常的 `zip` 函数。基本案例是相同的，尽管有一个额外的参数（连接函数）。然而，在基本案例中，这个参数并不重要，所以我们可以只使用 `_`
    字符。最后一个模式中的函数体也类似于 `zip`，不过它不是做 `(x, y)`，而是 `f x y`。
- en: 'Here’s a little demonstration of all the different things our `zipWith''` function
    can do:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `zipWith'` 函数可以做的所有不同事情的演示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, a single higher-order function can be used in very versatile
    ways.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个单独的高阶函数可以以非常灵活的方式使用。
- en: Implementing flip
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 flip
- en: 'Now we’ll implement another function in the standard library, called `flip`.
    The `flip` function takes a function and returns a function that is like our original
    function, but with the first two arguments flipped. We can implement it like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现标准库中的另一个函数，称为 `flip`。`flip` 函数接受一个函数并返回一个函数，类似于我们的原始函数，但前两个参数被反转。我们可以这样实现它：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can see from the type declaration that `flip''` takes a function that takes
    `a` and `b` types, and returns a function that takes `b` and `a` types. But because
    functions are curried by default, the second pair of parentheses actually is not
    necessary. The arrow `->` is right-associative by default, so `(a -> b -> c) ->
    (b -> a -> c)` is the same as `(a -> b -> c) -> (b -> (a -> c))`, which is the
    same as `(a -> b -> c) -> b -> a -> c`. We wrote that `g x y = f y x`. If that’s
    true, then `f y x = g x y` must also hold, right? Keeping that in mind, we can
    define this function in an even simpler manner:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型声明中可以看出，`flip` 接受一个接受 `a` 和 `b` 类型的函数，并返回一个接受 `b` 和 `a` 类型的函数。但是，因为函数默认是柯里化的，所以第二个括号实际上是不必要的。箭头
    `->` 默认是右结合的，所以 `(a -> b -> c) -> (b -> a -> c)` 与 `(a -> b -> c) -> (b -> (a
    -> c))` 相同，这又与 `(a -> b -> c) -> b -> a -> c` 相同。我们写了 `g x y = f y x`。如果这是真的，那么
    `f y x = g x y` 也必须成立，对吧？记住这一点，我们可以以更简单的方式定义这个函数：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this new version of `flip'`, we take advantage of the fact that functions
    are curried. When we call `flip' f` without the parameters `y` and `x`, it will
    return an `f` that takes those two parameters but calls them flipped.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `flip` 函数的新版本中，我们利用了函数是柯里化的这一事实。当我们调用 `flip f` 而不带参数 `y` 和 `x` 时，它将返回一个接受这两个参数但调用顺序相反的
    `f` 函数。
- en: Even though flipped functions are usually passed to other functions, we can
    take advantage of currying when making higher-order functions by thinking ahead
    and writing what their end result would be if they were fully applied.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管翻转函数通常传递给其他函数，但通过提前思考和编写它们完全应用时的最终结果，我们可以利用柯里化来制作高阶函数。
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we `flip'` the `zip` function, we get a function that is like `zip`, except
    that the items from the first list are placed into the second components of the
    tuples and vice versa. The `flip' div` function takes its second parameter and
    divides that by its first, so when the numbers `2` and `10` are passed to `flip'
    div`, the result is the same as using `div 10 2`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们翻转 `zip` 函数，我们将得到一个类似于 `zip` 的函数，除了第一个列表的项目被放置在元组的第二个组件中，反之亦然。`flip div`
    函数将其第二个参数除以第一个参数，因此当将数字 `2` 和 `10` 传递给 `flip div` 时，结果与使用 `div 10 2` 相同。
- en: The Functional Programmer's Toolbox
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式程序员的工具箱
- en: As functional programmers, we seldom want to operate on just one value. We usually
    want to take a bunch of numbers, letters, or some other type of data, and transform
    the set to produce our results. In this section, we’ll look at some useful functions
    that can help us work with multiple values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数式程序员，我们很少只想对一个值进行操作。我们通常想要处理一组数字、字母或其他类型的数据，并将该集合转换以产生我们的结果。在本节中，我们将探讨一些有用的函数，这些函数可以帮助我们处理多个值。
- en: The map Function
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`map` 函数'
- en: 'The `map` function takes a function and a list, and applies that function to
    every element in the list, producing a new list. Here is its definition:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数接受一个函数和一个列表，并将该函数应用于列表中的每个元素，从而生成一个新列表。以下是它的定义：'
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The type signature says that `map` takes a function from `a` to `b` and a list
    of `a` values, and returns a list of `b` values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名表明 `map` 接受一个从 `a` 到 `b` 的函数和一个 `a` 类型的值列表，并返回一个 `b` 类型的值列表。
- en: '`map` is a versatile higher-order function that can be used in many different
    ways. Here it is in action:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 是一个多才多艺的高阶函数，可以用多种方式使用。以下是它的实际应用：'
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You’ve probably noticed that each of these examples could also be achieved with
    a list comprehension. For instance, `map (+3) [1,5,3,1,6]` is technically the
    same as `[x+3 | x <- [1,5,3,1,6]]`. However, using the `map` function tends to
    make your code much more readable, especially once you start dealing with maps
    of maps.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些示例中的每一个也可以通过列表推导来实现。例如，`map (+3) [1,5,3,1,6]` 技术上等同于 `[x+3 | x <-
    [1,5,3,1,6]]`。然而，使用 `map` 函数通常会使你的代码更易于阅读，尤其是当你开始处理映射的映射时。
- en: The filter Function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`filter` 函数'
- en: 'The `filter` function takes a predicate and a list, and returns the list of
    elements that satisfy that predicate. (Remember that a *predicate* is a function
    that tells whether something is true or false; that is, a function that returns
    a Boolean value.) The type signature and implementation look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数接受一个谓词和一个列表，并返回满足该谓词的元素列表。（记住，*谓词* 是一个告诉某事是否为真的函数；也就是说，一个返回布尔值的函数。）类型签名和实现如下所示：'
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If `p x` evaluates to `True`, the element is included in the new list. If it
    doesn’t evaluate to `True`, it isn’t included in the new list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `p x` 评估为 `True`，则该元素包含在新列表中。如果它不评估为 `True`，则不包含在新列表中。
- en: 'Here are some `filter` examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 `filter` 的示例：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As with the `map` function, all of these examples could also be achieved by
    using comprehensions and predicates. There’s no set rule for when to use `map`
    and `filter` versus using list comprehensions. You just need to decide what’s
    more readable depending on the code and the context.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与`map`函数一样，所有这些例子也可以通过使用推导式和谓词来实现。没有固定的规则来决定何时使用`map`和`filter`与使用列表推导式。你只需要根据代码和上下文决定哪个更易读。
- en: 'The `filter` equivalent of applying several predicates in a list comprehension
    is either filtering something several times or joining the predicates with the
    logical `&&` function. Here’s an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式中应用多个谓词的`filter`等价于多次过滤或使用逻辑`&&`函数连接谓词。以下是一个例子：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we take the list `[1..20]` and filter it so that only even
    numbers remain. Then we pass that list to `filter (<15)` to get rid of numbers
    15 and up. Here’s the list comprehension version:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们取列表`[1..20]`并过滤它，使得只有偶数剩下。然后我们传递这个列表到`filter (<15)`以去除15及以上的数字。这里是列表推导式的版本：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use a list comprehension where we draw from the list `[1..20]`, and then
    say what conditions need to hold for a number to be in the resulting list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表推导式，从列表`[1..20]`中抽取，然后说明一个数字要进入结果列表需要满足的条件。
- en: 'Remember our `quicksort` function from [Chapter 4](ch04.html "Chapter 4. Hello
    Recursion!")? We used list comprehensions to filter out the list elements that
    were less than (or equal to) or greater than the pivot. We can achieve the same
    functionality in a more readable way by using `filter`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在第4章中提到的`quicksort`函数？我们使用列表推导式来过滤出小于（或等于）或大于枢轴的列表元素。我们可以通过使用`filter`以更可读的方式实现相同的功能：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: More Examples of map and filter
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map和filter的更多示例
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802558.png.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802558.png.jpg)'
- en: 'As another example, let’s find the largest number under 100,000 that’s divisible
    by 3,829\. To do that, we’ll just filter a set of possibilities in which we know
    the solution lies:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们找出小于100,000且能被3,829整除的最大数字。为了做到这一点，我们只需过滤一组可能的解：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we make a descending list of all numbers less than 100,000\. Then we
    filter it by our predicate. Because the numbers are sorted in a descending manner,
    the largest number that satisfies our predicate will be the first element of the
    filtered list. And because we end up using only the head of the filtered list,
    it doesn’t matter if the filtered list is finite or infinite. Haskell’s laziness
    causes the evaluation to stop when the first adequate solution is found.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们制作一个小于100,000的所有数字的降序列表。然后我们通过谓词过滤它。因为数字是按降序排列的，所以满足我们谓词的最大数字将是过滤列表的第一个元素。而且因为我们最终只使用过滤列表的头部，所以过滤列表是有限的还是无限的无关紧要。Haskell的惰性使得评估在找到第一个合适的解时停止。
- en: 'As our next example, we’ll find the sum of all odd squares that are smaller
    than 10,000\. In our solution, we’ll use the `takeWhile` function. This function
    takes a predicate and a list. Starting at the beginning of the list, it returns
    the list’s elements as long as the predicate holds true. Once an element is found
    for which the predicate doesn’t hold true, the function stops and returns the
    resulting list. For example, to get the first word of a string, we can do the
    following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一个例子，我们将找出小于10,000的所有奇数平方的和。在我们的解决方案中，我们将使用`takeWhile`函数。这个函数接受一个谓词和一个列表。从列表的开始处开始，只要谓词为真，它就返回列表的元素。一旦找到一个不满足谓词的元素，函数就会停止并返回结果列表。例如，要获取字符串的第一个单词，我们可以这样做：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To find the sum of all odd squares that are less than 10,000, we begin by mapping
    the `(^2)` function over the infinite list `[1..]`. Then we filter this list so
    we get only the odd elements. Next, using `takeWhile`, we take elements from that
    list only while they are smaller than 10,000\. Finally, we get the sum of that
    list (using the `sum` function). We don’t even need to define a function for this
    example, because we can do it all in one line in GHCi:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出小于10,000的所有奇数平方的和，我们首先将`(^2)`函数映射到无限列表`[1..]`上。然后我们过滤这个列表，只保留奇数元素。接下来，使用`takeWhile`，我们只从列表中取出小于10,000的元素。最后，我们得到这个列表的和（使用`sum`函数）。在这个例子中，我们甚至不需要定义一个函数，因为在GHCi中我们可以一行完成：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Awesome! We start with some initial data (the infinite list of all natural numbers),
    and then we map over it, filter it, and cut it until it suits our needs. Finally,
    we just sum it up!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们从一个初始数据（所有自然数的无限列表）开始，然后对其进行映射、过滤和裁剪，直到它满足我们的需求。最后，我们只需将其求和！
- en: 'We could have also written this example using list comprehensions, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用列表推导式来写这个例子，如下所示：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For our next problem, we’ll be dealing with Collatz sequences. A *Collatz sequence*
    (also known as a *Collatz chain*) is defined as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个问题，我们将处理柯尔察茨序列。一个*柯尔察茨序列*（也称为*柯尔察茨链*）被定义为如下：
- en: Start with any natural number.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何自然数开始。
- en: If the number is 1, stop.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是1，停止。
- en: If the number is even, divide it by 2.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是偶数，将其除以2。
- en: If the number is odd, multiply it by 3 and add 1.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是奇数，将其乘以3再加1。
- en: Repeat the algorithm with the resulting number.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用结果数字重复算法。
- en: 'In essence, this gives us a chain of numbers. Mathematicians theorize that
    for all starting numbers, the chain will finish at the number 1\. For example,
    if we start with the number 13, we get this sequence: 13, 40, 20, 10, 5, 16, 8,
    4, 2, 1\. (13 × 3 + 1 equals 40\. 40 divided by 2 equals 20, and so on.) We can
    see that the chain that starts with 13 has 10 terms.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这给我们一个数字链。数学家们理论认为，对于所有起始数字，链最终都会结束在数字1。例如，如果我们从数字13开始，我们得到这个序列：13, 40,
    20, 10, 5, 16, 8, 4, 2, 1。 (13 × 3 + 1等于40。40除以2等于20，以此类推。) 我们可以看到，以13开始的链有10项。
- en: 'Here is the problem we want to solve: For all starting numbers between 1 and
    100, how many Collatz chains have a length greater than 15?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们想要解决的问题：对于1到100之间的所有起始数字，有多少柯尔察茨链的长度大于15？
- en: 'Our first step will be to write a function that produces a chain:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步将是编写一个生成链的函数：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is a pretty standard recursive function. The base case is one, because
    all our chains will end at one. We can test the function to see if it’s working
    correctly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当标准的递归函数。基本情况是1，因为所有我们的链最终都会结束在1。我们可以测试这个函数，看看它是否工作正常：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we can write the `numLongChains` function, which actually answers our question:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`numLongChains`函数，它实际上回答了我们的问题：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We map the `chain` function to `[1..100]` to get a list of chains, which are
    themselves represented as lists. Then we filter them by a predicate that checks
    whether a list’s length is longer than 15\. Once we’ve done the filtering, we
    see how many chains are left in the resulting list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`chain`函数映射到`[1..100]`以获得一系列链，这些链本身也以列表的形式表示。然后我们通过一个谓词来过滤它们，该谓词检查列表的长度是否超过15。一旦过滤完成，我们就可以看到结果列表中剩下多少链。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This function has a type of `numLongChains :: Int` because `length` returns
    an `Int` instead of a `Num a`. If we wanted to return a more general `Num a`,
    we could have used `fromIntegral` on the resulting length.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '这个函数的类型是`numLongChains :: Int`，因为`length`返回一个`Int`而不是`Num a`。如果我们想返回一个更一般的`Num
    a`，我们可以在结果长度上使用`fromIntegral`。'
- en: Mapping Functions with Multiple Parameters
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射多参数函数
- en: So far, we’ve mapped functions that take only one parameter (like `map (*2)
    [0..]`). However, we can also map functions that take multiple parameters. For
    example, we could do something like `map (*) [0..]`. In this case, the function
    `*`, which has a type of `(Num a) => a -> a -> a`, is applied to each number in
    the list.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们映射了只接受一个参数的函数（如`map (*2) [0..]`）。然而，我们也可以映射接受多个参数的函数。例如，我们可以做类似`map
    (*) [0..]`的事情。在这种情况下，函数`*`，其类型为`(Num a) => a -> a -> a`，被应用到列表中的每个数字上。
- en: As you’ve seen, giving only one parameter to a function that takes two parameters
    will cause it to return a function that takes one parameter. So if we map `*`
    to the list `[0..]`, we will get back a list of functions that take only one parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，给一个需要两个参数的函数只提供一个参数，会导致它返回一个只接受一个参数的函数。所以如果我们将`*`映射到列表`[0..]`，我们就会得到一个只接受一个参数的函数列表。
- en: 'Here’s an example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Getting the element with the index `4` from our list returns a function that’s
    equivalent to `(4*)`. Then we just apply `5` to that function, which is the same
    as `(4*) 5`, or just `4 * 5`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的列表中获取索引为`4`的元素返回一个等价于`(4*)`的函数。然后我们只需将`5`应用到该函数上，这相当于`(4*) 5`，或者简单地`4 *
    5`。
- en: Lambdas
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立函数
- en: '*Lambdas* are anonymous functions that we use when we need a function only
    once.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*独立函数*是我们需要只使用一次函数时使用的匿名函数。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802560.png.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802560.png.jpg)'
- en: Normally, we make a lambda with the sole purpose of passing it to a higher-order
    function. To declare a lambda, we write a `\` (because it kind of looks like the
    Greek letter lambda (λ) if you squint hard enough), and then we write the function’s
    parameters, separated by spaces. After that comes a `->`, and then the function
    body. We usually surround lambdas with parentheses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们创建一个lambda的唯一目的是将其传递给一个高阶函数。要声明一个lambda，我们写一个`\`（因为如果你足够用力地眯眼，它有点像希腊字母lambda（λ）），然后我们写函数的参数，用空格分隔。之后是`->`，然后是函数体。我们通常用括号包围lambda。
- en: 'In the previous section, we used a `where` binding in our `numLongChains` function
    to make the `isLong` function for the sole purpose of passing it to `filter`.
    Instead of doing that, we can also use a lambda, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在`numLongChains`函数中使用了`where`绑定来创建`isLong`函数，仅为了将其传递给`filter`。我们也可以这样做，就像这样使用lambda：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802562.png.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802562.png.jpg)'
- en: Lambdas are expressions, which is why we can just pass them to functions like
    this. The expression `(\xs -> length xs > 15)` returns a function that tells us
    whether the length of the list passed to it is greater than 15.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda是表达式，这就是为什么我们可以像这样将它们传递给函数。表达式`(\xs -> length xs > 15)`返回一个函数，告诉我们传递给它的列表长度是否大于15。
- en: 'People who don’t understand how currying and partial application work often
    use lambdas where they are not necessary. For instance, the following expressions
    are equivalent:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不理解柯里化和部分应用如何工作的人经常在不必要的地方使用lambda。例如，以下表达式是等价的：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both `(+3)` and `(\x -> x + 3)` are functions that take a number and add 3 to
    it, so these expressions yield the same results. However, we don’t want to make
    a lambda in this case, because using partial application is much more readable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+3)`和`(\\x -> x + 3)`都是接受一个数字并将其加3的函数，所以这些表达式产生相同的结果。然而，在这种情况下，我们不想创建一个lambda，因为使用部分应用的可读性更好。'
- en: 'Like normal functions, lambdas can take any number of parameters:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如普通函数一样，lambda可以接受任意数量的参数：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And like normal functions, you can pattern match in lambdas. The only difference
    is that you can’t define several patterns for one parameter (like making a `[]`
    and a `(x:xs)` pattern for the same parameter and then having values fall through).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如普通函数一样，你可以在lambda中进行模式匹配。唯一的区别是，你不能为一个参数定义多个模式（比如为同一个参数创建一个`[]`和一个`(x:xs)`模式，然后让值通过）。
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a pattern match fails in a lambda, a runtime error occurs, so be careful!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果lambda中的模式匹配失败，将发生运行时错误，所以请小心！
- en: 'Let’s look at another interesting example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个有趣的例子：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Due to the way functions are curried by default, these two functions are equivalent.
    Yet the first `addThree` function is far more readable. The second one is little
    more than a gimmick to illustrate currying.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数默认是柯里化的，这两个函数是等价的。然而，第一个`addThree`函数的可读性要高得多。第二个函数几乎只是一个花招，用来说明柯里化。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that in the second example, the lambdas are not surrounded with parentheses.
    When you write a lambda without parentheses, it assumes that everything to the
    right of the arrow `->` belongs to it. So in this case, omitting the parentheses
    saves some typing. Of course, you can include the parentheses if you prefer them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第二个例子中，lambda表达式没有被括号包围。当你写一个没有括号的lambda表达式时，它假定箭头`->`右侧的所有内容都属于它。因此，在这种情况下，省略括号可以节省一些打字。当然，如果你更喜欢的话，也可以包括括号。
- en: 'However, there are times when using the currying notation instead is useful.
    I think that the `flip` function is the most readable when it’s defined like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时使用柯里化符号而不是它是有用的。我认为当`flip`函数这样定义时，它的可读性最高：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Even though this is the same as writing `flip'' f x y = f y x`, our new notation
    makes it obvious that this will often be used for producing a new function. The
    most common use case with `flip` is calling it with just the function parameter,
    or the function parameter and one extra parameter, and then passing the resulting
    function on to a `map` or a `zipWith`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这与写作`flip' f x y = f y x`相同，我们新的符号使得很明显，这通常会被用来产生一个新的函数。`flip`最常见的使用案例是只传递函数参数，或者函数参数和一个额外的参数，然后将得到的函数传递给`map`或`zipWith`：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can use lambdas this way in your own functions when you want to make it
    explicit that your functions are meant to be partially applied and then passed
    on to other functions as a parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要明确指出你的函数旨在部分应用并随后作为参数传递给其他函数时，你可以在自己的函数中使用这种方式使用 lambda。
- en: I Fold You So
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我折叠你
- en: Back when we were dealing with recursion in [Chapter 4](ch04.html "Chapter 4. Hello
    Recursion!"), many of the recursive functions that operated on lists followed
    the same pattern. We had a base case for the empty list, we introduced the `x:xs`
    pattern, and then we performed some action involving a single element and the
    rest of the list. It turns out this is a very common pattern, so the creators
    of Haskell introduced some useful functions, called *folds*, to encapsulate it.
    Folds allow you to reduce a data structure (like a list) to a single value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理递归（第 4 章）时，许多操作列表的递归函数遵循相同的模式。我们有一个空列表的基例，我们引入了 `x:xs` 模式，然后执行涉及单个元素和列表其余部分的一些操作。事实证明，这是一个非常常见的模式，因此
    Haskell 的创造者引入了一些有用的函数，称为**折叠**，来封装它。折叠允许你将数据结构（如列表）缩减为单个值。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802564.png.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802564.png.jpg)'
- en: Folds can be used to implement any function where you traverse a list once,
    element by element, and then return something based on that. Whenever you want
    to traverse a list to return something, chances are you want a fold.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠（Folds）可以用来实现任何一次遍历列表，逐个元素，然后基于这些元素返回结果的函数。每当你要遍历一个列表来返回某个结果时，很可能你需要一个折叠操作。
- en: A fold takes a *binary function* (one that takes two parameters, such as `+`
    or `div`), a starting value (often called the *accumulator*), and a list to fold
    up.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠操作需要一个**二元函数**（一个接受两个参数的函数，例如 `+` 或 `div`），一个起始值（通常称为**累加器**），以及一个要折叠的列表。
- en: Lists can be folded up from the left or from the right. The fold function calls
    the given binary function, using the accumulator and the first (or last) element
    of the list as parameters. The resulting value is the new accumulator. Then the
    fold function calls the binary function again with the new accumulator and the
    new first (or last) element of the list, resulting in another new accumulator.
    This repeats until the function has traversed the entire list and reduced it down
    to a single accumulator value.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以从左侧或右侧折叠。折叠函数使用给定的二元函数调用，使用累加器和列表的第一个（或最后一个）元素作为参数。结果值是新的累加器。然后折叠函数再次使用新的累加器和列表的新第一个（或最后一个）元素调用二元函数，产生另一个新的累加器。这个过程重复进行，直到函数遍历了整个列表，并将其缩减为单个累加器值。
- en: Left Folds with foldl
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 foldl 的左折叠
- en: First, let’s look at the `foldl` function. This is called a *left fold*, since
    it folds the list up from the left side. In this case, the binary function is
    applied between the starting accumulator and the head of the list. That produces
    a new accumulator value, and the binary function is called with that value and
    the next element, and so on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `foldl` 函数。这被称为**左折叠**，因为它从列表的左侧开始折叠。在这种情况下，二元函数应用于起始累加器和列表的头部。这会产生一个新的累加器值，然后使用该值和下一个元素调用二元函数，依此类推。
- en: 'Let’s implement the `sum` function again, this time using a fold instead of
    explicit recursion:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次实现 `sum` 函数，这次使用折叠而不是显式的递归：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can test it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试它：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802566.png.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802566.png.jpg)'
- en: Let’s take an in-depth look at how this fold happens. `\acc x -> acc + x` is
    the binary function. `0` is the starting value, and `xs` is the list to be folded
    up. First, `0` and `3` are passed to the binary function as the `acc` and `x`
    parameters, respectively. In this case, the binary function is simply an addition,
    so the two values are added, which produces `3` as the new accumulator value.
    Next, `3` and the next list value (`5`) are passed to the binary function, and
    they are added together to produce `8` as the new accumulator value. In the same
    way, `8` and `2` are added together to produce `10`, and then `10` and `1` are
    added together to produce the final value of `11`. Congratulations, you’ve folded
    your first list!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这个折叠是如何发生的。`\acc x -> acc + x` 是二进制函数。`0` 是起始值，`xs` 是要折叠的列表。首先，`0`
    和 `3` 分别作为 `acc` 和 `x` 参数传递给二进制函数。在这种情况下，二进制函数只是一个加法，所以这两个值相加，产生新的累加器值 `3`。接下来，`3`
    和下一个列表值 (`5`) 被传递给二进制函数，并将它们相加以产生新的累加器值 `8`。以同样的方式，`8` 和 `2` 相加以产生 `10`，然后 `10`
    和 `1` 相加以产生最终值 `11`。恭喜你，你已经折叠了你的第一个列表！
- en: 'The diagram on the left illustrates how a fold happens, step by step. The number
    that’s on the left side of the `+` is the accumulator value. You can see how the
    list is consumed up from the left side by the accumulator. (Om nom nom nom!) If
    we take into account that functions are curried, we can write this implementation
    even more succinctly, like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图示说明了折叠是如何一步一步发生的。`+` 左侧的数字是累加器值。你可以看到累加器是如何从左侧消耗列表的。（嗯嗯嗯！）如果我们考虑到函数是柯里化的，我们可以将这个实现写得更加简洁，如下所示：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The lambda function `(\acc x -> acc + x)` is the same as `(+)`. We can omit
    the `xs` as the parameter because calling `foldl (+) 0` will return a function
    that takes a list. Generally, if you have a function like `foo a = bar b a`, you
    can rewrite it as `foo = bar b` because of currying.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数 `(\acc x -> acc + x)` 与 `(+)` 相同。我们可以省略 `xs` 作为参数，因为调用 `foldl (+)
    0` 将返回一个接受列表的函数。通常，如果你有一个像 `foo a = bar b a` 这样的函数，你可以通过柯里化将其重写为 `foo = bar b`。
- en: Right Folds with foldr
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `foldr` 的右折叠
- en: 'The right fold function, `foldr`, is similar to the left fold, except the accumulator
    eats up the values from the right. Also, the order of the parameters in the right
    fold’s binary function is reversed: The current list value is the first parameter,
    and the accumulator is the second. (It makes sense that the right fold has the
    accumulator on the right, since it folds from the right side.)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 右折叠函数 `foldr` 与左折叠类似，但累加器从右侧消耗值。此外，右折叠的二进制函数的参数顺序是颠倒的：当前列表值是第一个参数，累加器是第二个。 (右折叠的累加器在右侧是有意义的，因为它从右侧折叠。)
- en: 'The accumulator value (and hence, the result) of a fold can be of any type.
    It can be a number, a Boolean, or even a new list. As an example, let’s implement
    the `map` function with a right fold. The accumulator will be a list, and we’ll
    be accumulating the mapped list element by element. Of course, our starting element
    will need to be an empty list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠的累加器值（以及结果）可以是任何类型。它可以是数字、布尔值，甚至是新列表。作为一个例子，让我们用右折叠实现 `map` 函数。累加器将是一个列表，我们将逐个元素累积映射的列表。当然，我们的起始元素需要是一个空列表：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we’re mapping `(+3)` to `[1,2,3]`, we approach the list from the right side.
    We take the last element, which is `3`, and apply the function to it, which gives
    `6`. Then we prepend it to the accumulator, which was `[]`. `6:[]` is `[6]`, so
    that’s now the accumulator. We then apply `(+3)` to `2`, yielding `5`, and prepend
    (`:`) that to the accumulator. Our new accumulator value is now `[5,6]`. We then
    apply `(+3)` to `1` and prepend the result to the accumulator again, giving a
    final result of `[4,5,6]`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `(+3)` 映射到 `[1,2,3]`，我们将从右侧接近列表。我们取最后一个元素，即 `3`，并将其应用于该函数，得到 `6`。然后我们将其预连接到累加器，累加器最初是
    `[]`。`6:[]` 是 `[6]`，因此现在是累加器。然后我们将 `(+3)` 应用到 `2` 上，得到 `5`，并将其预连接到累加器。我们的新累加器值现在是
    `[5,6]`。然后我们将 `(+3)` 应用到 `1` 上，并将结果再次预连接到累加器，得到最终结果 `[4,5,6]`。
- en: 'Of course, we could have implemented this function with a left fold instead,
    like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以用左折叠来实现这个函数，如下所示：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: However, the `++` function is much slower than `:`, so we usually use right
    folds when we’re building up new lists from a list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`++` 函数比 `:` 慢得多，所以我们通常在从列表构建新列表时使用右折叠。
- en: One big difference between the two types of folds is that right folds work on
    infinite lists, whereas left ones don’t!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 两种折叠类型之间的一大区别是，右折叠可以在无限列表上工作，而左折叠则不行！
- en: 'Let’s implement one more function with a right fold. As you know, the `elem`
    function checks whether a value is part of a list. Here’s how we can use `foldr`
    to implement it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再实现一个使用右折叠的函数。正如你所知，`elem`函数检查一个值是否是列表的一部分。以下是我们可以如何使用`foldr`来实现它的方法：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, the accumulator is a Boolean value. (Remember that the type of the accumulator
    value and the type of the end result are always the same when dealing with folds.)
    We start with a value of `False`, since we’re assuming the value isn’t in the
    list to begin with. This also gives us the correct value if we call it on the
    empty list, since calling a fold on an empty list just returns the starting value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，累加器是一个布尔值。（记住，在处理折叠时，累加器值的类型和最终结果的类型总是相同的。）我们从一个`False`的值开始，因为我们假设值一开始就不在列表中。这也给我们提供了正确的值，如果我们对空列表调用它，因为对空列表调用折叠只会返回起始值。
- en: Next, we check if the current element is the element we want. If it is, we set
    the accumulator to `True`. If it’s not, we just leave the accumulator unchanged.
    If it was `False` before, it stays that way because this current element is not
    the one we’re seeking. If it was `True`, it stays that way as the rest of the
    list is folded up.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查当前元素是否是我们想要的元素。如果是，我们将累加器设置为`True`。如果不是，我们只保持累加器不变。如果它之前是`False`，它将保持那样，因为当前元素不是我们正在寻找的。如果它是`True`，它将保持那样，因为剩余的列表被折叠起来。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802568.png.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802568.png.jpg)'
- en: The foldl and foldr1 Functions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foldl和foldr1函数
- en: 'The `foldl1` and `foldr1` functions work much like `foldl` and `foldr`, except
    that you don’t need to provide them with an explicit starting accumulator. They
    assume the first (or last) element of the list to be the starting accumulator,
    and then start the fold with the element next to it. With that in mind, the `maximum`
    function can be implemented like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldl1`和`foldr1`函数的工作方式与`foldl`和`foldr`非常相似，只是你不需要提供它们一个明确的起始累加器。它们假设列表的第一个（或最后一个）元素作为起始累加器，然后从它旁边的元素开始折叠。考虑到这一点，`maximum`函数可以这样实现：'
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We implemented `maximum` by using a `foldl1`. Instead of providing a starting
    accumulator, `foldl1` just assumes the first element as the starting accumulator
    and moves on to the second one. So all `foldl1` needs is a binary function and
    a list to fold up! We start at the beginning of the list and then compare each
    element with the accumulator. If it’s greater than our accumulator, we keep it
    as the new accumulator; otherwise, we keep the old one. We passed `max` to `foldl1`
    as the binary function because it does exactly that: takes two values and returns
    the one that’s larger. By the time we’ve finished folding our list, only the largest
    element remains.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`foldl1`实现了`maximum`。与提供起始累加器不同，`foldl1`只是假设第一个元素作为起始累加器，然后继续到第二个元素。所以`foldl1`所需的就是一个二元函数和一个要折叠的列表！我们从列表的开始处开始，然后比较每个元素与累加器。如果它比我们的累加器大，我们就将其作为新的累加器；否则，我们保持原来的累加器。我们将`max`传递给`foldl1`作为二元函数，因为它正是这样做的：取两个值并返回较大的那个。当我们完成列表的折叠后，只剩下最大的元素。
- en: Because they depend on the lists they’re called with having at least one element,
    these functions cause runtime errors if called with empty lists. `foldl` and `foldr`,
    on the other hand, work fine with empty lists.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们依赖于它们被调用的列表至少有一个元素，所以这些函数在用空列表调用时会导致运行时错误。另一方面，`foldl`和`foldr`与空列表一起工作得很好。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When making a fold, think about how it acts on an empty list. If the function
    doesn’t make sense when given an empty list, you can probably use a `foldl1` or
    `foldr1` to implement it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行折叠时，考虑它对空列表的作用。如果函数在给空列表时没有意义，你可能可以使用`foldl1`或`foldr1`来实现它。
- en: Some Fold Examples
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些折叠示例
- en: 'To demonstrate how powerful folds are, let’s implement some standard library
    functions using folds. First, we’ll write our own version of `reverse`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示折叠有多么强大，让我们使用折叠来实现一些标准库函数。首先，我们将编写自己的`reverse`版本：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we reverse a list by using the empty list as a starting accumulator and
    then approaching our original list from the left and placing the current element
    at the start of the accumulator.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用空列表作为起始累加器，然后从左边接近我们的原始列表，并将当前元素放在累加器的开头来反转列表。
- en: 'The function `\acc x -> x : acc` is just like the `:` function, except that
    the parameters are flipped. That’s why we could have also written `reverse''`
    like so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '函数`\acc x -> x : acc`就像`:`函数一样，只是参数被翻转了。这就是为什么我们也可以像这样写出`reverse''`：'
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we’ll implement `product`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `product`：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To calculate the product of all the numbers in the list, we start with `1` as
    the accumulator. Then we fold left with the `*` function, multiplying each element
    with the accumulator.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算列表中所有数字的乘积，我们以 `1` 作为累加器开始。然后我们使用 `*` 函数向左折叠，将每个元素与累加器相乘。
- en: 'Now we’ll implement `filter`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现 `filter`：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we use an empty list as the starting accumulator. Then we fold from the
    right and inspect each element. `p` is our predicate. If `p x` is `True`—meaning
    that if the predicate holds for the current element—we put it at the beginning
    of the accumulator. Otherwise, we just reuse our old accumulator.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用空列表作为起始累加器。然后我们从右向左折叠并检查每个元素。`p` 是我们的谓词。如果 `p x` 为 `True`——意味着如果谓词对当前元素成立——我们将它放在累加器的开头。否则，我们只是重新使用我们的旧累加器。
- en: 'Finally, we’ll implement `last`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现 `last`：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To get the last element of a list, we use a `foldl1`. We start at the first
    element of the list, and then use a binary function that disregards the accumulator
    and always sets the current element as the new accumulator. Once we’ve reached
    the end, the accumulator—that is, the last element—will be returned.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取列表的最后一个元素，我们使用 `foldl1`。我们从列表的第一个元素开始，然后使用一个二元函数，该函数忽略累加器并将当前元素始终设置为新的累加器。一旦我们到达末尾，累加器（即最后一个元素）将被返回。
- en: Another Way to Look at Folds
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一种看待折叠的方式
- en: 'Another way to picture right and left folds is as successive applications of
    some function to elements in a list. Say we have a right fold, with a binary function
    `f` and a starting accumulator `z`. When we right fold over the list `[3,4,5,6]`,
    we’re essentially doing this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种想象左右折叠的方式是将某个函数连续应用于列表中的元素。假设我们有一个右折叠，二元函数 `f` 和起始累加器 `z`。当我们对列表 `[3,4,5,6]`
    进行右折叠时，我们实际上在做以下操作：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`f` is called with the last element in the list and the accumulator, then that
    value is given as the accumulator to the next-to-last value, and so on.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`f` 被调用时使用列表中的最后一个元素和累加器，然后该值作为累加器传递给倒数第二个值，依此类推。'
- en: 'If we take `f` to be `+` and the starting accumulator value to be `0`, we’re
    doing this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `f` 设为 `+` 并将初始累加器值设为 `0`，我们正在做以下操作：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or if we write `+` as a prefix function, we’re doing this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们将 `+` 写作前缀函数，我们正在做以下操作：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Similarly, doing a left fold over that list with `g` as the binary function
    and `z` as the accumulator is the equivalent of this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用 `g` 作为二元函数和 `z` 作为累加器对该列表进行左折叠等同于以下操作：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we use `flip (:)` as the binary function and `[]` as the accumulator (so
    we’re reversing the list), that’s the equivalent of the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `flip (:)` 作为二元函数并将 `[]` 作为累加器（因此我们正在反转列表），那么这等同于以下操作：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And sure enough, if you evaluate that expression, you get `[6,5,4,3]`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，如果你评估这个表达式，你会得到 `[6,5,4,3]`。
- en: Folding Infinite Lists
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折叠无限列表
- en: Viewing folds as successive function applications on values of a list can give
    you insight as to why `foldr` sometimes works perfectly fine on infinite lists.
    Let’s implement the `and` function with a `foldr`, and then write it out as a
    series of successive function applications, as we did with our previous examples.
    You’ll see how `foldr` works with Haskell’s laziness to operate on lists that
    have infinite length.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将折叠视为对列表值进行连续函数应用可以让你了解为什么 `foldr` 有时在无限列表上工作得很好。让我们使用 `foldr` 实现函数 `and`，然后像我们之前的例子一样将其写成一系列连续的函数应用。你会看到
    `foldr` 如何与 Haskell 的惰性一起在具有无限长度的列表上操作。
- en: 'The `and` function takes a list of `Bool` values and returns `False` if one
    or more elements are `False`; otherwise, it returns `True`. We’ll approach the
    list from the right and use `True` as the starting accumulator. We’ll use `&&`
    as the binary function, because we want to end up with `True` only if all the
    elements are `True`. The `&&` function returns `False` if either of its parameters
    is `False`, so if we come across an element in the list that is `False`, the accumulator
    will be set as `False` and the final result will also be `False`, even if all
    the remaining elements are `True`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 函数接受一个 `Bool` 值列表并返回 `False` 如果有一个或多个元素是 `False`；否则，它返回 `True`。我们将从右向左处理列表，并使用
    `True` 作为起始累加器。我们将使用 `&&` 作为二元函数，因为我们只想在所有元素都是 `True` 时得到 `True`。`&&` 函数在其任一参数为
    `False` 时返回 `False`，因此如果我们遇到列表中的 `False` 元素，累加器将被设置为 `False`，最终结果也将是 `False`，即使所有剩余的元素都是
    `True`：'
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Knowing how `foldr` works, we see that the expression `and'' [True,False,True]`
    will be evaluated like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 `foldr` 的工作原理后，我们看到表达式 `and' [True,False,True]` 将被评估如下：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The last `True` represents our starting accumulator, whereas the first three
    `Bool` values are from the list `[True,False,True]`. If we try to evaluate the
    previous expression, we will get `False`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`True`代表我们的起始累加器，而前三个`Bool`值来自列表`[True,False,True]`。如果我们尝试评估前面的表达式，我们将得到`False`。
- en: 'Now what if we try this with an infinite list, say `repeat False`, which has
    an infinite number of elements, all of which are `False`? If we write that out,
    we get something like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们尝试使用无限列表，比如`repeat False`，它有无限个元素，所有这些元素都是`False`，会发生什么？如果我们把它写出来，我们得到类似这样的东西：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Haskell is lazy, so it will compute only what it really must. And the `&&`
    function works in such a way that if its first parameter is `False`, it disregards
    its second parameter, because the `&&` function returns `True` only if both of
    its parameters are `True`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell是惰性的，所以它只会计算它真正必须计算的内容。`&&`函数以这种方式工作，即如果它的第一个参数是`False`，它会忽略其第二个参数，因为`&&`函数只有在两个参数都是`True`时才返回`True`：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the case of the endless list of `False` values, the second pattern matches,
    and `False` is returned without Haskell needing to evaluate the rest of the infinite
    list:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在无限个`False`值的列表的情况下，第二个模式匹配，并且`False`被返回，而Haskell不需要评估无限列表的其余部分：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`foldr` will work on infinite lists when the binary function that we’re passing
    to it doesn’t always need to evaluate its second parameter to give us some sort
    of answer. For instance, `&&` doesn’t care what its second parameter is if its
    first parameter is `False`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递给`foldr`的二进制函数不需要总是评估其第二个参数以给出某种答案时，`foldr`将在无限列表上工作。例如，如果第一个参数是`False`，`&&`就不关心其第二个参数是什么。
- en: Scans
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描
- en: 'The `scanl` and `scanr` functions are like `foldl` and `foldr`, except they
    report all the intermediate accumulator states in the form of a list. The `scanl1`
    and `scanr1` functions are analogous to `foldl1` and `foldr1`. Here are some examples
    of these functions in action:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`scanl`和`scanr`函数类似于`foldl`和`foldr`，但它们以列表的形式报告所有中间累加器状态。`scanl1`和`scanr1`函数类似于`foldl1`和`foldr1`。以下是一些这些函数实际应用的例子：'
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When using a `scanl`, the final result will be in the last element of the resulting
    list. `scanr` will place the result in the head of the list.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`scanl`时，最终结果将位于结果列表的最后一个元素中。`scanr`将结果放在列表的头部。
- en: 'Scans are used to monitor the progress of a function that can be implemented
    as a fold. As an exercise in using scans, let’s try answering this question: How
    many elements does it take for the sum of the square roots of all natural numbers
    to exceed 1,000?'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描用于监控可以表示为折叠的函数的进展。作为一个使用扫描的练习，让我们尝试回答这个问题：要使所有自然数的平方根之和超过1,000，需要多少个元素？
- en: To get the square roots of all natural numbers, we just call `map sqrt [1..]`.
    To get the sum, we could use a fold. However, because we’re interested in how
    the sum progresses, we’ll use a scan instead. Once we’ve done the scan, we can
    check how many sums are under 1,000.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到所有自然数的平方根，我们只需调用`map sqrt [1..]`。要得到总和，我们可以使用折叠。然而，因为我们对总和的进展情况感兴趣，我们将使用扫描。一旦我们完成了扫描，我们就可以检查有多少个总和小于1,000。
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We use `takeWhile` here instead of `filter` because `filter` wouldn’t cut off
    the resulting list once a number that’s equal to or over 1,000 is found; it would
    keep searching. Even though we know the list is ascending, `filter` doesn’t, so
    we use `takeWhile` to cut off the scan list at the first occurrence of a sum greater
    than 1,000.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`takeWhile`而不是`filter`，因为一旦找到等于或超过1,000的数字，`filter`就不会截断结果列表；它会继续搜索。即使我们知道列表是递增的，`filter`也不知道，所以我们使用`takeWhile`来截断扫描列表，直到出现第一个总和大于1,000的情况。
- en: 'The first sum in the scan list will be 1\. The second will be 1 plus the square
    root of 2\. The third will be that plus the square root of 3\. If there are *x*
    sums under 1,000, then it takes *x*+1 elements for the sum to exceed 1,000:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描列表中的第一个总和将是1。第二个将是1加上2的平方根。第三个将是那个数加上3的平方根。如果有*x*个总和小于1,000，那么总和超过1,000需要*x*+1个元素：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: And behold, our answer is correct! If we sum the first 130 square roots, the
    result is just below 1,000, but if we add another one to that, we go over our
    threshold.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 看哪，我们的答案是正确的！如果我们把前130个平方根相加，结果将略低于1,000，但如果我们再加上一个，就会超过我们的阈值。
- en: Function Application with $
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用$进行函数应用
- en: 'Now we’ll look at the `$` function, also called the *function application operator*.
    First, let’s see how it’s defined:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看`$`函数，也称为*函数应用操作符*。首先，让我们看看它是如何定义的：
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802570.png.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802570.png.jpg)'
- en: What the heck? What is this useless function? It’s just function application!
    Well, that’s almost true, but not quite. Whereas normal function application (putting
    a space between two things) has a really high precedence, the `$` function has
    the lowest precedence. Function application with a space is left-associative (so
    `f a b c` is the same as `((f a) b) c`), while function application with `$` is
    right-associative.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 究竟是怎么回事？这个无用的函数是什么？它只是函数应用！好吧，这几乎是对的，但并不完全正确。而正常的函数应用（在两个事物之间留空格）具有很高的优先级，而
    `$` 函数具有最低的优先级。带有空格的函数应用是左结合的（因此 `f a b c` 与 `((f a) b) c` 相同），而带有 `$` 的函数应用是右结合的。
- en: So how does this help us? Most of the time, it’s a convenience function that
    lets us write fewer parentheses. For example, consider the expression `sum (map
    sqrt [1..130])`. Because `$` has such a low precedence, we can rewrite that expression
    as `sum $ map sqrt [1..130]`. When a `$` is encountered, the expression on its
    right is applied as the parameter to the function on its left.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们有什么帮助？大多数时候，它是一个方便的函数，让我们可以少写一些括号。例如，考虑表达式 `sum (map sqrt [1..130])`。因为
    `$` 具有如此低的优先级，我们可以将那个表达式重写为 `sum $ map sqrt [1..130]`。当遇到 `$` 时，其右侧的表达式被用作左侧函数的参数。
- en: How about `sqrt 3 + 4 + 9`? This adds together 9, 4, and the square root of
    3\. However, if we wanted the square root of 3 + 4 + 9, we would need to write
    `sqrt (3 + 4 + 9)`. With `$`, we can also write this as `sqrt $ 3 + 4 + 9`. You
    can imagine `$` as almost being the equivalent of writing an opening parenthesis
    and then writing a closing parenthesis on the far right side of the expression.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `sqrt 3 + 4 + 9` 呢？这是将 9、4 和 3 的平方根相加。然而，如果我们想计算 3 + 4 + 9 的平方根，我们需要写成 `sqrt
    (3 + 4 + 9)`。使用 `$`，我们也可以写成 `sqrt $ 3 + 4 + 9`。你可以想象 `$` 几乎等同于在表达式的最右侧写一个开括号，然后写一个闭括号。
- en: 'Let’s look at another example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Whoa, that’s a lot of parentheses! It looks kind of ugly. Here, `(*2)` is mapped
    onto `[2..10]`, then we filter the resulting list to keep only those numbers that
    are larger than `10`, and finally those numbers are added together.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这么多括号！看起来有点丑。这里，`(*2)` 被映射到 `[2..10]`，然后我们过滤结果列表，只保留大于 `10` 的那些数字，最后将这些数字相加。
- en: 'We can use the `$` function to rewrite our previous example and make it a little
    easier on the eyes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `$` 函数重写我们之前的例子，使其更容易看懂：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `$` function is right-associative, meaning that something like `f $ g $
    x` is equivalent to `f $ (g $ x)`. With that in mind, the preceding example can
    once again be rewritten as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` 函数是右结合的，这意味着 `f $ g $ x` 与 `f $ (g $ x)` 相同。考虑到这一点，前面的例子可以再次重写如下：'
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Apart from getting rid of parentheses, `$` lets us treat function application
    like just another function. This allows us to, for instance, map function application
    over a list of functions, like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了去掉括号外，`$` 允许我们将函数应用视为另一个函数。这使得我们能够，例如，将函数应用映射到函数列表上，如下所示：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the function `($ 3)` gets mapped over the list. If you think about what
    the `($ 3)` function does, you’ll see that it takes a function and then applies
    that function to `3`. So every function in the list gets applied to `3`, which
    is evident in the result.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，函数 `($ 3)` 被映射到列表上。如果你考虑 `($ 3)` 函数做了什么，你会发现它接受一个函数并将其应用于 `3`。所以列表中的每个函数都被应用于
    `3`，这在结果中是显而易见的。
- en: Function Composition
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数复合
- en: 'In mathematics, *function composition* is defined like this: (*f* º *g*)(*x*)
    = *f(g(x)*). This means that composing two functions is the equivalent of calling
    one function with some value and then calling another function with the result
    of the first function.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，*函数复合* 定义如下：(*f* º *g*)(*x*) = *f(g(x)*)。这意味着复合两个函数相当于先调用一个函数并传递一些值，然后调用另一个函数并传递第一个函数的结果。
- en: 'In Haskell, function composition is pretty much the same thing. We do function
    composition with the `.` function, which is defined like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，函数复合基本上是同一件事。我们使用 `.` 函数进行函数复合，该函数定义如下：
- en: '[PRE72]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802572.png.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802572.png.jpg)'
- en: Notice the type declaration. `f` must take as its parameter a value that has
    the same type as `g`’s return value. So the resulting function takes a parameter
    of the same type that `g` takes and returns a value of the same type that `f`
    returns. For example, the expression `negate . (* 3)` returns a function that
    takes a number, multiplies it by 3, and then negates it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类型声明。`f` 必须接受一个与 `g` 返回值类型相同的参数。因此，结果函数接受与 `g` 相同类型的参数，并返回与 `f` 相同类型的值。例如，表达式
    `negate . (* 3)` 返回一个函数，该函数接受一个数字，将其乘以3，然后取其相反数。
- en: One use for function composition is making functions on the fly to pass to other
    functions. Sure, we can use lambdas for that, but many times, function composition
    is clearer and more concise.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合的一个用途是动态创建函数并将其传递给其他函数。当然，我们可以使用lambda表达式来做到这一点，但很多时候，函数组合更清晰、更简洁。
- en: 'For example, say we have a list of numbers and we want to turn them all into
    negative numbers. One way to do that would be to get each number’s absolute value
    and then negate it, like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个数字列表，并且我们想将它们全部转换为负数。一种方法是通过获取每个数字的绝对值然后取其相反数，如下所示：
- en: '[PRE73]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Notice the lambda and how it looks like the result of function composition.
    Using function composition, we can rewrite that as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意lambda及其看起来像函数组合的结果。使用函数组合，我们可以将其重写如下：
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Fabulous! Function composition is right-associative, so we can compose many
    functions at a time. The expression `f (g (z x))` is equivalent to `(f . g . z)
    x`. With that in mind, we can turn something messy, like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！函数组合是右结合的，所以我们可以一次组合多个函数。表达式 `f (g (z x))` 等价于 `(f . g . z) x`。考虑到这一点，我们可以将一些混乱的表达式，比如这个：
- en: '[PRE75]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'into something much cleaner, like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 变得更加简洁，如下所示：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`negate . sum . tail` is a function that takes a list, applies the `tail` function
    to it, then applies the `sum` function to the result of that, and finally applies
    `negate` to the previous result. So it’s equivalent to the preceding lambda.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`negate . sum . tail` 是一个函数，它接受一个列表，对其应用 `tail` 函数，然后对那个结果应用 `sum` 函数，最后对前一个结果应用
    `negate`。所以它与前面的lambda表达式等价。'
- en: Function Composition with Multiple Parameters
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多参数的函数组合
- en: 'But what about functions that take several parameters? Well, if we want to
    use them in function composition, we usually must partially apply them so that
    each function takes just one parameter. Consider this expression:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于需要多个参数的函数怎么办？如果我们想在函数组合中使用它们，通常必须部分应用它们，以便每个函数只接受一个参数。考虑这个表达式：
- en: '[PRE77]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This expression can be rewritten as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式可以被重写如下：
- en: '[PRE78]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'which is equivalent to this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下表达式等价：
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The function `replicate 5` is applied to the result of `max 6.7 8.9`, and then
    `sum` is applied to that result. Notice that we partially applied the `replicate`
    function to the point where it takes only one parameter, so that when the result
    of `max 6.7 8.9` gets passed to `replicate 5`, the result is a list of numbers,
    which is then passed to `sum`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `replicate 5` 被应用于 `max 6.7 8.9` 的结果，然后 `sum` 函数被应用于该结果。请注意，我们部分应用了 `replicate`
    函数，使其只接受一个参数，因此当 `max 6.7 8.9` 的结果传递给 `replicate 5` 时，结果是一个数字列表，然后该列表被传递给 `sum`。
- en: 'If we want to rewrite an expression with a lot of parentheses using function
    composition, we can start by first writing out the innermost function and its
    parameters. Then we put a `$` before it and compose all the functions that came
    before by writing them without their last parameter and putting dots between them.
    Say we have this expression:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用函数组合重写一个包含许多括号的复杂表达式，我们可以先写出最内层的函数及其参数。然后我们在它前面加上一个 `$` 符号，并通过省略它们最后的参数并在它们之间加上点来组合所有之前的函数。比如说我们有一个这样的表达式：
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can write this as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写成以下形式：
- en: '[PRE81]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'How did we turn the first example into the second one? Well, first we look
    at the function on the far right and its parameters, just before the bunch of
    closing parentheses. That function is `zipWith max [1,2] [4,5]`. We’re going to
    keep that as it is, so now we have this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何将第一个例子转换为第二个例子的呢？首先，我们看看最右边的函数及其参数，就在一串闭合括号之前。这个函数是 `zipWith max [1,2]
    [4,5]`。我们将保持它不变，所以我们现在有这个：
- en: '[PRE82]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then we look at which function was applied to `zipWith max [1,2] [4,5]` and
    see that it was `map (*3)`. So we put a `$` between it and what we had before:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看看哪个函数被应用于 `zipWith max [1,2] [4,5]`，我们看到它是 `map (*3)`。所以我们在这两者之间加上一个 `$`
    符号：
- en: '[PRE83]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now we start the compositions. We check which function was applied to all this,
    and we see that it was `product`, so we compose it with `map (*3)`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始组合。我们检查所有这些应用了哪个函数，我们看到是`product`，所以我们将其与`map (*3)`组合：
- en: '[PRE84]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And finally, we see that the function `replicate 2` was applied to all this,
    and we can write the expression as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到函数`replicate 2`被应用到所有这些上，我们可以将表达式写成以下形式：
- en: '[PRE85]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If the expression ends with three parentheses, chances are that if you translate
    it into function composition by following this procedure, it will have two composition
    operators.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式以三个括号结束，那么很可能，如果你按照这个程序将其翻译成函数组合，它将有两个组合运算符。
- en: Point-Free Style
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无点风格
- en: 'Another common use of function composition is defining functions in the *point-free
    style*. For example, consider a function we wrote earlier:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合的另一个常见用途是在**无点风格**中定义函数。例如，考虑我们之前编写的一个函数：
- en: '[PRE86]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `xs` is on the far right on both sides of the equal sign. Because of currying,
    we can omit the `xs` on both sides, since calling `foldl (+) 0` creates a function
    that takes a list. In this way, we are writing the function in point-free style:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`xs`位于等号两边的最右边。由于柯里化，我们可以省略两边的`xs`，因为调用`foldl (+) 0`创建了一个接受列表的函数。这样，我们就在无点风格中编写函数：'
- en: '[PRE87]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As another example, let’s try writing the following function in point-free
    style:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们尝试以下函数的无点风格写法：
- en: '[PRE88]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can’t just get rid of the `x` on both right sides, since the `x` in the
    function body is surrounded by parentheses. `cos (max 50)` wouldn’t make sense—you
    can’t get the cosine of a function. What we *can* do is express `fn` as a composition
    of functions, like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地在等号两边都去掉`x`，因为函数体内的`x`被括号包围。`cos (max 50)`是没有意义的——你不能得到一个函数的余弦值。我们**可以**做的是将`fn`表示为函数的组合，如下所示：
- en: '[PRE89]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Excellent! Many times, a point-free style is more readable and concise, because
    it makes you think about functions and what kinds of functions composing them
    results in, instead of thinking about data and how it’s shuffled around. You can
    take simple functions and use composition as glue to form more complex functions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！很多时候，无点风格更易于阅读和简洁，因为它让你思考函数以及什么样的函数组合会产生，而不是思考数据以及它是如何被重新排列的。你可以使用简单的函数，并用组合作为粘合剂来形成更复杂的函数。
- en: However, if a function is too complex, writing it in point-free style can actually
    be less readable. For this reason, making long chains of function composition
    is discouraged. The preferred style is to use `let` bindings to give labels to
    intermediary results or to split the problem into subproblems that are easier
    for someone reading the code to understand.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个函数过于复杂，用无点风格编写它实际上可能更难以阅读。因此，不建议编写长的函数组合链。首选的风格是使用`let`绑定来给中间结果命名，或者将问题分解成更易于阅读代码的人理解的子问题。
- en: 'Earlier in the chapter, we solved the problem of finding the sum of all odd
    squares that are smaller than 10,000\. Here’s what the solution looks like when
    put into a function:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们解决了寻找小于10,000的所有奇数平方和的问题。以下是将其放入函数中的解决方案：
- en: '[PRE90]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'With our knowledge of function composition, we can also write the function
    like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们对函数组合的了解，我们也可以这样写函数：
- en: '[PRE91]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: It may seem a bit weird at first, but you will get used to this style quickly.
    There’s less visual noise because we removed the parentheses. When reading this,
    you can just say that `filter odd` is applied to the result of `map (^2) [1..]`,
    then `takeWhile (<10000)` is applied to the result of that, and finally `sum`
    is applied to that result.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这可能有点奇怪，但你会很快习惯这种风格。由于我们去掉了括号，视觉噪音更少。阅读时，你只需说`filter odd`被应用到`map (^2) [1..]`的结果上，然后`takeWhile
    (<10000)`被应用到那个结果上，最后`sum`被应用到那个结果上。
