- en: Chapter 5. Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haskell functions can take functions as parameters and return functions as return
    values. A function that does either of these things is called a *higher-order
    function*. Higher-order functions are a really powerful way of solving problems
    and thinking about programs, and they’re indispensable when using a functional
    programming language like Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Curried Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every function in Haskell officially takes only one parameter. But we have defined
    and used several functions that take more than one parameter so far—how is that
    possible?
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802552.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, it’s a clever trick! All the functions we’ve used so far that accepted
    multiple parameters have been *curried functions*. A curried function is a function
    that, instead of taking several parameters, always takes exactly one parameter.
    Then when it’s called with that parameter, it returns a function that takes the
    next parameter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is best explained with an example. Let’s take our good friend, the `max`
    function. It looks as if it takes two parameters and returns the one that’s bigger.
    For instance, consider the expression `max 4 5`. We call the function `max` with
    two parameters: `4` and `5`. First, `max` is applied to the value `4`. When we
    apply `max` to `4`, the value that is returned is actually another function, which
    is then applied to the value `5`. The act of applying this function to `5` finally
    returns a number value. As a consequence, the following two calls are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how this works, let’s examine the type of the `max` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we have a type signature that features the arrow `->`, that means it’s
    a function that takes whatever is on the left side of the arrow and returns a
    value whose type is indicated on the right side of the arrow. When we have something
    like `a -> (a -> a)`, we’re dealing with a function that takes a value of type
    `a`, and it returns a function that also takes a value of type `a` and returns
    a value of type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802554.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So how is that beneficial to us? Simply speaking, if we call a function with
    too few parameters, we get back a *partially applied* function, which is a function
    that takes as many parameters as we left out. For example, when we did `max 4`,
    we got back a function that takes one parameter. Using partial application (calling
    functions with too few parameters, if you will) is a neat way to create functions
    on the fly, so we can pass them to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this simple little function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What really happens when we call `multThree 3 5 9`, or `((multThree 3) 5) 9`?
    First, `multThree` is applied to `3`, because they’re separated by a space. That
    creates a function that takes one parameter and returns a function. Then that
    function is applied to `5`, which creates a function that will take one parameter,
    multiply 3 and 5 together, and then multiply that by the parameter. That function
    is applied to `9`, and the result is 135.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of functions as tiny factories that take some materials and produce
    something. Using that analogy, we feed our `multThree` factory the number `3`,
    but instead of producing a number, it churns out a slightly smaller factory. That
    factory receives the number `5` and also spits out a factory. The third factory
    receives the number `9`, and then produces our resulting number, `135`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that this function’s type can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The type (or type variable) before the `->` is the type of the values that a
    function takes, and the type after it is the type of the values it returns. So
    our function takes a value of type `Int` and returns a function of type `(Int
    -> (Int -> Int)`. Similarly, *this* function takes a value of type `Int` and returns
    a function of type `Int -> Int`. And finally, *this* function just takes a value
    of type `Int` and returns another value of type `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how we can create a new function by calling a function
    with too few parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the expression `multThree 9` results in a function that takes
    two parameters. We name that function `multTwoWithNine`, because `multThree 9`
    is a function that takes two parameters. If both parameters are supplied, it will
    multiply the two parameters between them, and then multiply that by `9`, because
    we got the `multTwoWithNine` function by applying `multThree` to `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to create a function that takes an `Int` and compares it
    to `100`? We could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, let’s try calling the function with `99`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`100` is greater than `99`, so the function returns `GT`, or greater than.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s think about what `compare 100` would return: a function that takes
    a number and compares it with `100`, which is exactly what we were trying to get
    in our example. In other words, the following definition and the previous one
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The type declaration stays the same, because `compare 100` returns a function.
    `compare` has a type of `(Ord a) => a -> (a -> Ordering)`. When we apply it to
    `100`, we get a function that takes a number and returns an `Ordering`.
  prefs: []
  type: TYPE_NORMAL
- en: Sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Infix functions can also be partially applied by using *sections*. To section
    an infix function, simply surround it with parentheses and supply a parameter
    on only one side. That creates a function that takes one parameter and then applies
    it to the side that’s missing an operand. Here’s an insultingly trivial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following code, calling `divideByTen 200` is equivalent
    to calling `200 / 10` or `(/10) 200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at another example. This function checks if a character supplied
    to it is an uppercase letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing to watch out for with sections is when you’re using the `-`
    (negative or minus) operator. From the definition of sections, `(-4)` would result
    in a function that takes a number and subtracts 4 from it. However, for convenience,
    `(-4)` means negative four. So if you want to make a function that subtracts 4
    from the number it gets as a parameter, you can partially apply the `subtract`
    function like so: `(subtract 4)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Printing Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve bound our partially applied functions to names and then supplied
    the remaining parameters to view the results. However, we never tried to print
    the functions themselves to the terminal. Let’s give that a go then, shall we?
    What happens if we try entering `multThree 3 4` into GHCi, instead of binding
    it to a name with a `let` or passing it to another function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: GHCi is telling us that the expression produced a function of type `a -> a`,
    but it doesn’t know how to print it to the screen. Functions aren’t instances
    of the `Show` type class, so we can’t get a neat string representation of a function.
    This is different, for example, than when we enter `1 + 1` at the GHCi prompt.
    In that case, GHCi calculates `2` as the result, and then calls `show` on `2`
    to get a textual representation of that number. The textual representation of
    `2` is just the string `"2"`, which is then printed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you thoroughly understand how curried functions and partial application
    work, because they’re really important!
  prefs: []
  type: TYPE_NORMAL
- en: Some Higher-Orderism Is in Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Haskell, functions can take other functions as parameters, and as you’ve
    seen, they can also return functions as return values. To demonstrate this concept,
    let’s write a function that takes a function, and then applies it twice to some
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802556.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the type declaration. For our earlier examples, we didn’t need parentheses
    when declaring function types, because `->` is naturally right-associative. However,
    here parentheses are mandatory. They indicate that the first parameter is a function
    that takes one parameter and returns a value of the same type (`a -> a`). The
    second parameter is something of type `a`, and the return value’s type is also
    `a`. Notice that it doesn’t matter what type `a` is—it can be `Int`, `String`,
    or whatever—but all the values must be the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You now know that under the hood, functions that seem to take multiple parameters
    are actually taking a single parameter and returning a partially applied function.
    However, to keep things simple, I’ll continue to say that a given function takes
    multiple parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the `applyTwice` function is very simple. We just use the parameter
    `f` as a function, applying `x` to it by separating the `f` and `x` with a space.
    We then apply the result to `f` again. Here are some examples of the function
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The awesomeness and usefulness of partial application is evident. If our function
    requires us to pass it a function that takes only one parameter, we can just partially
    apply a function to the point where it takes only one parameter and then pass
    it. For instance, the `+` function takes two parameters, and in this example,
    we partially applied it so that it takes only one parameter by using sections.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing zipWith
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re going to use higher-order programming to implement a really useful
    function in the standard library called `zipWith`. It takes a function and two
    lists as parameters, and then joins the two lists by applying the function between
    corresponding elements. Here’s how we’ll implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First let’s look at the type declaration. The first parameter is a function
    that takes two arguments and returns one value. They don’t have to be of the same
    type, but they can be. The second and third parameters are lists, and the final
    return value is also a list.
  prefs: []
  type: TYPE_NORMAL
- en: The first list must be a list of type `a` values, because the joining function
    takes `a` types as its first argument. The second must be a list of `b` types,
    because the second parameter of the joining function is of type `b`. The result
    is a list of type `c` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that if you’re writing a function (especially a higher-order function),
    and you’re unsure of the type, you can try omitting the type declaration and checking
    what Haskell infers it to be by using `:t`.
  prefs: []
  type: TYPE_NORMAL
- en: This function is similar to the normal `zip` function. The base cases are the
    same, although there’s an extra argument (the joining function). However, that
    argument doesn’t matter in the base cases, so we can just use the `_` character
    for it. The function body in the last pattern is also similar to `zip`, though
    instead of doing `(x, y)`, it does `f x y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a little demonstration of all the different things our `zipWith''` function
    can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a single higher-order function can be used in very versatile
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing flip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’ll implement another function in the standard library, called `flip`.
    The `flip` function takes a function and returns a function that is like our original
    function, but with the first two arguments flipped. We can implement it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from the type declaration that `flip''` takes a function that takes
    `a` and `b` types, and returns a function that takes `b` and `a` types. But because
    functions are curried by default, the second pair of parentheses actually is not
    necessary. The arrow `->` is right-associative by default, so `(a -> b -> c) ->
    (b -> a -> c)` is the same as `(a -> b -> c) -> (b -> (a -> c))`, which is the
    same as `(a -> b -> c) -> b -> a -> c`. We wrote that `g x y = f y x`. If that’s
    true, then `f y x = g x y` must also hold, right? Keeping that in mind, we can
    define this function in an even simpler manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this new version of `flip'`, we take advantage of the fact that functions
    are curried. When we call `flip' f` without the parameters `y` and `x`, it will
    return an `f` that takes those two parameters but calls them flipped.
  prefs: []
  type: TYPE_NORMAL
- en: Even though flipped functions are usually passed to other functions, we can
    take advantage of currying when making higher-order functions by thinking ahead
    and writing what their end result would be if they were fully applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we `flip'` the `zip` function, we get a function that is like `zip`, except
    that the items from the first list are placed into the second components of the
    tuples and vice versa. The `flip' div` function takes its second parameter and
    divides that by its first, so when the numbers `2` and `10` are passed to `flip'
    div`, the result is the same as using `div 10 2`.
  prefs: []
  type: TYPE_NORMAL
- en: The Functional Programmer's Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As functional programmers, we seldom want to operate on just one value. We usually
    want to take a bunch of numbers, letters, or some other type of data, and transform
    the set to produce our results. In this section, we’ll look at some useful functions
    that can help us work with multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: The map Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `map` function takes a function and a list, and applies that function to
    every element in the list, producing a new list. Here is its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The type signature says that `map` takes a function from `a` to `b` and a list
    of `a` values, and returns a list of `b` values.
  prefs: []
  type: TYPE_NORMAL
- en: '`map` is a versatile higher-order function that can be used in many different
    ways. Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You’ve probably noticed that each of these examples could also be achieved with
    a list comprehension. For instance, `map (+3) [1,5,3,1,6]` is technically the
    same as `[x+3 | x <- [1,5,3,1,6]]`. However, using the `map` function tends to
    make your code much more readable, especially once you start dealing with maps
    of maps.
  prefs: []
  type: TYPE_NORMAL
- en: The filter Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filter` function takes a predicate and a list, and returns the list of
    elements that satisfy that predicate. (Remember that a *predicate* is a function
    that tells whether something is true or false; that is, a function that returns
    a Boolean value.) The type signature and implementation look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If `p x` evaluates to `True`, the element is included in the new list. If it
    doesn’t evaluate to `True`, it isn’t included in the new list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some `filter` examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As with the `map` function, all of these examples could also be achieved by
    using comprehensions and predicates. There’s no set rule for when to use `map`
    and `filter` versus using list comprehensions. You just need to decide what’s
    more readable depending on the code and the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filter` equivalent of applying several predicates in a list comprehension
    is either filtering something several times or joining the predicates with the
    logical `&&` function. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we take the list `[1..20]` and filter it so that only even
    numbers remain. Then we pass that list to `filter (<15)` to get rid of numbers
    15 and up. Here’s the list comprehension version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We use a list comprehension where we draw from the list `[1..20]`, and then
    say what conditions need to hold for a number to be in the resulting list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember our `quicksort` function from [Chapter 4](ch04.html "Chapter 4. Hello
    Recursion!")? We used list comprehensions to filter out the list elements that
    were less than (or equal to) or greater than the pivot. We can achieve the same
    functionality in a more readable way by using `filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: More Examples of map and filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802558.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As another example, let’s find the largest number under 100,000 that’s divisible
    by 3,829\. To do that, we’ll just filter a set of possibilities in which we know
    the solution lies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, we make a descending list of all numbers less than 100,000\. Then we
    filter it by our predicate. Because the numbers are sorted in a descending manner,
    the largest number that satisfies our predicate will be the first element of the
    filtered list. And because we end up using only the head of the filtered list,
    it doesn’t matter if the filtered list is finite or infinite. Haskell’s laziness
    causes the evaluation to stop when the first adequate solution is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our next example, we’ll find the sum of all odd squares that are smaller
    than 10,000\. In our solution, we’ll use the `takeWhile` function. This function
    takes a predicate and a list. Starting at the beginning of the list, it returns
    the list’s elements as long as the predicate holds true. Once an element is found
    for which the predicate doesn’t hold true, the function stops and returns the
    resulting list. For example, to get the first word of a string, we can do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the sum of all odd squares that are less than 10,000, we begin by mapping
    the `(^2)` function over the infinite list `[1..]`. Then we filter this list so
    we get only the odd elements. Next, using `takeWhile`, we take elements from that
    list only while they are smaller than 10,000\. Finally, we get the sum of that
    list (using the `sum` function). We don’t even need to define a function for this
    example, because we can do it all in one line in GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! We start with some initial data (the infinite list of all natural numbers),
    and then we map over it, filter it, and cut it until it suits our needs. Finally,
    we just sum it up!
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have also written this example using list comprehensions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For our next problem, we’ll be dealing with Collatz sequences. A *Collatz sequence*
    (also known as a *Collatz chain*) is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with any natural number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is 1, stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is even, divide it by 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is odd, multiply it by 3 and add 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat the algorithm with the resulting number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In essence, this gives us a chain of numbers. Mathematicians theorize that
    for all starting numbers, the chain will finish at the number 1\. For example,
    if we start with the number 13, we get this sequence: 13, 40, 20, 10, 5, 16, 8,
    4, 2, 1\. (13 × 3 + 1 equals 40\. 40 divided by 2 equals 20, and so on.) We can
    see that the chain that starts with 13 has 10 terms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the problem we want to solve: For all starting numbers between 1 and
    100, how many Collatz chains have a length greater than 15?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step will be to write a function that produces a chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty standard recursive function. The base case is one, because
    all our chains will end at one. We can test the function to see if it’s working
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write the `numLongChains` function, which actually answers our question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We map the `chain` function to `[1..100]` to get a list of chains, which are
    themselves represented as lists. Then we filter them by a predicate that checks
    whether a list’s length is longer than 15\. Once we’ve done the filtering, we
    see how many chains are left in the resulting list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function has a type of `numLongChains :: Int` because `length` returns
    an `Int` instead of a `Num a`. If we wanted to return a more general `Num a`,
    we could have used `fromIntegral` on the resulting length.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Functions with Multiple Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve mapped functions that take only one parameter (like `map (*2)
    [0..]`). However, we can also map functions that take multiple parameters. For
    example, we could do something like `map (*) [0..]`. In this case, the function
    `*`, which has a type of `(Num a) => a -> a -> a`, is applied to each number in
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, giving only one parameter to a function that takes two parameters
    will cause it to return a function that takes one parameter. So if we map `*`
    to the list `[0..]`, we will get back a list of functions that take only one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Getting the element with the index `4` from our list returns a function that’s
    equivalent to `(4*)`. Then we just apply `5` to that function, which is the same
    as `(4*) 5`, or just `4 * 5`.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Lambdas* are anonymous functions that we use when we need a function only
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802560.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Normally, we make a lambda with the sole purpose of passing it to a higher-order
    function. To declare a lambda, we write a `\` (because it kind of looks like the
    Greek letter lambda (λ) if you squint hard enough), and then we write the function’s
    parameters, separated by spaces. After that comes a `->`, and then the function
    body. We usually surround lambdas with parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we used a `where` binding in our `numLongChains` function
    to make the `isLong` function for the sole purpose of passing it to `filter`.
    Instead of doing that, we can also use a lambda, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802562.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Lambdas are expressions, which is why we can just pass them to functions like
    this. The expression `(\xs -> length xs > 15)` returns a function that tells us
    whether the length of the list passed to it is greater than 15.
  prefs: []
  type: TYPE_NORMAL
- en: 'People who don’t understand how currying and partial application work often
    use lambdas where they are not necessary. For instance, the following expressions
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Both `(+3)` and `(\x -> x + 3)` are functions that take a number and add 3 to
    it, so these expressions yield the same results. However, we don’t want to make
    a lambda in this case, because using partial application is much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like normal functions, lambdas can take any number of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: And like normal functions, you can pattern match in lambdas. The only difference
    is that you can’t define several patterns for one parameter (like making a `[]`
    and a `(x:xs)` pattern for the same parameter and then having values fall through).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a pattern match fails in a lambda, a runtime error occurs, so be careful!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another interesting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Due to the way functions are curried by default, these two functions are equivalent.
    Yet the first `addThree` function is far more readable. The second one is little
    more than a gimmick to illustrate currying.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that in the second example, the lambdas are not surrounded with parentheses.
    When you write a lambda without parentheses, it assumes that everything to the
    right of the arrow `->` belongs to it. So in this case, omitting the parentheses
    saves some typing. Of course, you can include the parentheses if you prefer them.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are times when using the currying notation instead is useful.
    I think that the `flip` function is the most readable when it’s defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though this is the same as writing `flip'' f x y = f y x`, our new notation
    makes it obvious that this will often be used for producing a new function. The
    most common use case with `flip` is calling it with just the function parameter,
    or the function parameter and one extra parameter, and then passing the resulting
    function on to a `map` or a `zipWith`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can use lambdas this way in your own functions when you want to make it
    explicit that your functions are meant to be partially applied and then passed
    on to other functions as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: I Fold You So
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back when we were dealing with recursion in [Chapter 4](ch04.html "Chapter 4. Hello
    Recursion!"), many of the recursive functions that operated on lists followed
    the same pattern. We had a base case for the empty list, we introduced the `x:xs`
    pattern, and then we performed some action involving a single element and the
    rest of the list. It turns out this is a very common pattern, so the creators
    of Haskell introduced some useful functions, called *folds*, to encapsulate it.
    Folds allow you to reduce a data structure (like a list) to a single value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802564.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Folds can be used to implement any function where you traverse a list once,
    element by element, and then return something based on that. Whenever you want
    to traverse a list to return something, chances are you want a fold.
  prefs: []
  type: TYPE_NORMAL
- en: A fold takes a *binary function* (one that takes two parameters, such as `+`
    or `div`), a starting value (often called the *accumulator*), and a list to fold
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Lists can be folded up from the left or from the right. The fold function calls
    the given binary function, using the accumulator and the first (or last) element
    of the list as parameters. The resulting value is the new accumulator. Then the
    fold function calls the binary function again with the new accumulator and the
    new first (or last) element of the list, resulting in another new accumulator.
    This repeats until the function has traversed the entire list and reduced it down
    to a single accumulator value.
  prefs: []
  type: TYPE_NORMAL
- en: Left Folds with foldl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s look at the `foldl` function. This is called a *left fold*, since
    it folds the list up from the left side. In this case, the binary function is
    applied between the starting accumulator and the head of the list. That produces
    a new accumulator value, and the binary function is called with that value and
    the next element, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the `sum` function again, this time using a fold instead of
    explicit recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802566.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s take an in-depth look at how this fold happens. `\acc x -> acc + x` is
    the binary function. `0` is the starting value, and `xs` is the list to be folded
    up. First, `0` and `3` are passed to the binary function as the `acc` and `x`
    parameters, respectively. In this case, the binary function is simply an addition,
    so the two values are added, which produces `3` as the new accumulator value.
    Next, `3` and the next list value (`5`) are passed to the binary function, and
    they are added together to produce `8` as the new accumulator value. In the same
    way, `8` and `2` are added together to produce `10`, and then `10` and `1` are
    added together to produce the final value of `11`. Congratulations, you’ve folded
    your first list!
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram on the left illustrates how a fold happens, step by step. The number
    that’s on the left side of the `+` is the accumulator value. You can see how the
    list is consumed up from the left side by the accumulator. (Om nom nom nom!) If
    we take into account that functions are curried, we can write this implementation
    even more succinctly, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The lambda function `(\acc x -> acc + x)` is the same as `(+)`. We can omit
    the `xs` as the parameter because calling `foldl (+) 0` will return a function
    that takes a list. Generally, if you have a function like `foo a = bar b a`, you
    can rewrite it as `foo = bar b` because of currying.
  prefs: []
  type: TYPE_NORMAL
- en: Right Folds with foldr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The right fold function, `foldr`, is similar to the left fold, except the accumulator
    eats up the values from the right. Also, the order of the parameters in the right
    fold’s binary function is reversed: The current list value is the first parameter,
    and the accumulator is the second. (It makes sense that the right fold has the
    accumulator on the right, since it folds from the right side.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The accumulator value (and hence, the result) of a fold can be of any type.
    It can be a number, a Boolean, or even a new list. As an example, let’s implement
    the `map` function with a right fold. The accumulator will be a list, and we’ll
    be accumulating the mapped list element by element. Of course, our starting element
    will need to be an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we’re mapping `(+3)` to `[1,2,3]`, we approach the list from the right side.
    We take the last element, which is `3`, and apply the function to it, which gives
    `6`. Then we prepend it to the accumulator, which was `[]`. `6:[]` is `[6]`, so
    that’s now the accumulator. We then apply `(+3)` to `2`, yielding `5`, and prepend
    (`:`) that to the accumulator. Our new accumulator value is now `[5,6]`. We then
    apply `(+3)` to `1` and prepend the result to the accumulator again, giving a
    final result of `[4,5,6]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we could have implemented this function with a left fold instead,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: However, the `++` function is much slower than `:`, so we usually use right
    folds when we’re building up new lists from a list.
  prefs: []
  type: TYPE_NORMAL
- en: One big difference between the two types of folds is that right folds work on
    infinite lists, whereas left ones don’t!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement one more function with a right fold. As you know, the `elem`
    function checks whether a value is part of a list. Here’s how we can use `foldr`
    to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, the accumulator is a Boolean value. (Remember that the type of the accumulator
    value and the type of the end result are always the same when dealing with folds.)
    We start with a value of `False`, since we’re assuming the value isn’t in the
    list to begin with. This also gives us the correct value if we call it on the
    empty list, since calling a fold on an empty list just returns the starting value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check if the current element is the element we want. If it is, we set
    the accumulator to `True`. If it’s not, we just leave the accumulator unchanged.
    If it was `False` before, it stays that way because this current element is not
    the one we’re seeking. If it was `True`, it stays that way as the rest of the
    list is folded up.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802568.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The foldl and foldr1 Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `foldl1` and `foldr1` functions work much like `foldl` and `foldr`, except
    that you don’t need to provide them with an explicit starting accumulator. They
    assume the first (or last) element of the list to be the starting accumulator,
    and then start the fold with the element next to it. With that in mind, the `maximum`
    function can be implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We implemented `maximum` by using a `foldl1`. Instead of providing a starting
    accumulator, `foldl1` just assumes the first element as the starting accumulator
    and moves on to the second one. So all `foldl1` needs is a binary function and
    a list to fold up! We start at the beginning of the list and then compare each
    element with the accumulator. If it’s greater than our accumulator, we keep it
    as the new accumulator; otherwise, we keep the old one. We passed `max` to `foldl1`
    as the binary function because it does exactly that: takes two values and returns
    the one that’s larger. By the time we’ve finished folding our list, only the largest
    element remains.'
  prefs: []
  type: TYPE_NORMAL
- en: Because they depend on the lists they’re called with having at least one element,
    these functions cause runtime errors if called with empty lists. `foldl` and `foldr`,
    on the other hand, work fine with empty lists.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When making a fold, think about how it acts on an empty list. If the function
    doesn’t make sense when given an empty list, you can probably use a `foldl1` or
    `foldr1` to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Some Fold Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how powerful folds are, let’s implement some standard library
    functions using folds. First, we’ll write our own version of `reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we reverse a list by using the empty list as a starting accumulator and
    then approaching our original list from the left and placing the current element
    at the start of the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `\acc x -> x : acc` is just like the `:` function, except that
    the parameters are flipped. That’s why we could have also written `reverse''`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll implement `product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To calculate the product of all the numbers in the list, we start with `1` as
    the accumulator. Then we fold left with the `*` function, multiplying each element
    with the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll implement `filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use an empty list as the starting accumulator. Then we fold from the
    right and inspect each element. `p` is our predicate. If `p x` is `True`—meaning
    that if the predicate holds for the current element—we put it at the beginning
    of the accumulator. Otherwise, we just reuse our old accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll implement `last`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To get the last element of a list, we use a `foldl1`. We start at the first
    element of the list, and then use a binary function that disregards the accumulator
    and always sets the current element as the new accumulator. Once we’ve reached
    the end, the accumulator—that is, the last element—will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Another Way to Look at Folds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to picture right and left folds is as successive applications of
    some function to elements in a list. Say we have a right fold, with a binary function
    `f` and a starting accumulator `z`. When we right fold over the list `[3,4,5,6]`,
    we’re essentially doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`f` is called with the last element in the list and the accumulator, then that
    value is given as the accumulator to the next-to-last value, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take `f` to be `+` and the starting accumulator value to be `0`, we’re
    doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if we write `+` as a prefix function, we’re doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, doing a left fold over that list with `g` as the binary function
    and `z` as the accumulator is the equivalent of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `flip (:)` as the binary function and `[]` as the accumulator (so
    we’re reversing the list), that’s the equivalent of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, if you evaluate that expression, you get `[6,5,4,3]`.
  prefs: []
  type: TYPE_NORMAL
- en: Folding Infinite Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewing folds as successive function applications on values of a list can give
    you insight as to why `foldr` sometimes works perfectly fine on infinite lists.
    Let’s implement the `and` function with a `foldr`, and then write it out as a
    series of successive function applications, as we did with our previous examples.
    You’ll see how `foldr` works with Haskell’s laziness to operate on lists that
    have infinite length.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `and` function takes a list of `Bool` values and returns `False` if one
    or more elements are `False`; otherwise, it returns `True`. We’ll approach the
    list from the right and use `True` as the starting accumulator. We’ll use `&&`
    as the binary function, because we want to end up with `True` only if all the
    elements are `True`. The `&&` function returns `False` if either of its parameters
    is `False`, so if we come across an element in the list that is `False`, the accumulator
    will be set as `False` and the final result will also be `False`, even if all
    the remaining elements are `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing how `foldr` works, we see that the expression `and'' [True,False,True]`
    will be evaluated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The last `True` represents our starting accumulator, whereas the first three
    `Bool` values are from the list `[True,False,True]`. If we try to evaluate the
    previous expression, we will get `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what if we try this with an infinite list, say `repeat False`, which has
    an infinite number of elements, all of which are `False`? If we write that out,
    we get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Haskell is lazy, so it will compute only what it really must. And the `&&`
    function works in such a way that if its first parameter is `False`, it disregards
    its second parameter, because the `&&` function returns `True` only if both of
    its parameters are `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the endless list of `False` values, the second pattern matches,
    and `False` is returned without Haskell needing to evaluate the rest of the infinite
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`foldr` will work on infinite lists when the binary function that we’re passing
    to it doesn’t always need to evaluate its second parameter to give us some sort
    of answer. For instance, `&&` doesn’t care what its second parameter is if its
    first parameter is `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Scans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `scanl` and `scanr` functions are like `foldl` and `foldr`, except they
    report all the intermediate accumulator states in the form of a list. The `scanl1`
    and `scanr1` functions are analogous to `foldl1` and `foldr1`. Here are some examples
    of these functions in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When using a `scanl`, the final result will be in the last element of the resulting
    list. `scanr` will place the result in the head of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scans are used to monitor the progress of a function that can be implemented
    as a fold. As an exercise in using scans, let’s try answering this question: How
    many elements does it take for the sum of the square roots of all natural numbers
    to exceed 1,000?'
  prefs: []
  type: TYPE_NORMAL
- en: To get the square roots of all natural numbers, we just call `map sqrt [1..]`.
    To get the sum, we could use a fold. However, because we’re interested in how
    the sum progresses, we’ll use a scan instead. Once we’ve done the scan, we can
    check how many sums are under 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We use `takeWhile` here instead of `filter` because `filter` wouldn’t cut off
    the resulting list once a number that’s equal to or over 1,000 is found; it would
    keep searching. Even though we know the list is ascending, `filter` doesn’t, so
    we use `takeWhile` to cut off the scan list at the first occurrence of a sum greater
    than 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first sum in the scan list will be 1\. The second will be 1 plus the square
    root of 2\. The third will be that plus the square root of 3\. If there are *x*
    sums under 1,000, then it takes *x*+1 elements for the sum to exceed 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: And behold, our answer is correct! If we sum the first 130 square roots, the
    result is just below 1,000, but if we add another one to that, we go over our
    threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Function Application with $
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we’ll look at the `$` function, also called the *function application operator*.
    First, let’s see how it’s defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802570.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What the heck? What is this useless function? It’s just function application!
    Well, that’s almost true, but not quite. Whereas normal function application (putting
    a space between two things) has a really high precedence, the `$` function has
    the lowest precedence. Function application with a space is left-associative (so
    `f a b c` is the same as `((f a) b) c`), while function application with `$` is
    right-associative.
  prefs: []
  type: TYPE_NORMAL
- en: So how does this help us? Most of the time, it’s a convenience function that
    lets us write fewer parentheses. For example, consider the expression `sum (map
    sqrt [1..130])`. Because `$` has such a low precedence, we can rewrite that expression
    as `sum $ map sqrt [1..130]`. When a `$` is encountered, the expression on its
    right is applied as the parameter to the function on its left.
  prefs: []
  type: TYPE_NORMAL
- en: How about `sqrt 3 + 4 + 9`? This adds together 9, 4, and the square root of
    3\. However, if we wanted the square root of 3 + 4 + 9, we would need to write
    `sqrt (3 + 4 + 9)`. With `$`, we can also write this as `sqrt $ 3 + 4 + 9`. You
    can imagine `$` as almost being the equivalent of writing an opening parenthesis
    and then writing a closing parenthesis on the far right side of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Whoa, that’s a lot of parentheses! It looks kind of ugly. Here, `(*2)` is mapped
    onto `[2..10]`, then we filter the resulting list to keep only those numbers that
    are larger than `10`, and finally those numbers are added together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `$` function to rewrite our previous example and make it a little
    easier on the eyes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$` function is right-associative, meaning that something like `f $ g $
    x` is equivalent to `f $ (g $ x)`. With that in mind, the preceding example can
    once again be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from getting rid of parentheses, `$` lets us treat function application
    like just another function. This allows us to, for instance, map function application
    over a list of functions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, the function `($ 3)` gets mapped over the list. If you think about what
    the `($ 3)` function does, you’ll see that it takes a function and then applies
    that function to `3`. So every function in the list gets applied to `3`, which
    is evident in the result.
  prefs: []
  type: TYPE_NORMAL
- en: Function Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In mathematics, *function composition* is defined like this: (*f* º *g*)(*x*)
    = *f(g(x)*). This means that composing two functions is the equivalent of calling
    one function with some value and then calling another function with the result
    of the first function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Haskell, function composition is pretty much the same thing. We do function
    composition with the `.` function, which is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802572.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the type declaration. `f` must take as its parameter a value that has
    the same type as `g`’s return value. So the resulting function takes a parameter
    of the same type that `g` takes and returns a value of the same type that `f`
    returns. For example, the expression `negate . (* 3)` returns a function that
    takes a number, multiplies it by 3, and then negates it.
  prefs: []
  type: TYPE_NORMAL
- en: One use for function composition is making functions on the fly to pass to other
    functions. Sure, we can use lambdas for that, but many times, function composition
    is clearer and more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have a list of numbers and we want to turn them all into
    negative numbers. One way to do that would be to get each number’s absolute value
    and then negate it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the lambda and how it looks like the result of function composition.
    Using function composition, we can rewrite that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Fabulous! Function composition is right-associative, so we can compose many
    functions at a time. The expression `f (g (z x))` is equivalent to `(f . g . z)
    x`. With that in mind, we can turn something messy, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'into something much cleaner, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`negate . sum . tail` is a function that takes a list, applies the `tail` function
    to it, then applies the `sum` function to the result of that, and finally applies
    `negate` to the previous result. So it’s equivalent to the preceding lambda.'
  prefs: []
  type: TYPE_NORMAL
- en: Function Composition with Multiple Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'But what about functions that take several parameters? Well, if we want to
    use them in function composition, we usually must partially apply them so that
    each function takes just one parameter. Consider this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'which is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The function `replicate 5` is applied to the result of `max 6.7 8.9`, and then
    `sum` is applied to that result. Notice that we partially applied the `replicate`
    function to the point where it takes only one parameter, so that when the result
    of `max 6.7 8.9` gets passed to `replicate 5`, the result is a list of numbers,
    which is then passed to `sum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to rewrite an expression with a lot of parentheses using function
    composition, we can start by first writing out the innermost function and its
    parameters. Then we put a `$` before it and compose all the functions that came
    before by writing them without their last parameter and putting dots between them.
    Say we have this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'How did we turn the first example into the second one? Well, first we look
    at the function on the far right and its parameters, just before the bunch of
    closing parentheses. That function is `zipWith max [1,2] [4,5]`. We’re going to
    keep that as it is, so now we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we look at which function was applied to `zipWith max [1,2] [4,5]` and
    see that it was `map (*3)`. So we put a `$` between it and what we had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we start the compositions. We check which function was applied to all this,
    and we see that it was `product`, so we compose it with `map (*3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we see that the function `replicate 2` was applied to all this,
    and we can write the expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: If the expression ends with three parentheses, chances are that if you translate
    it into function composition by following this procedure, it will have two composition
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: Point-Free Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common use of function composition is defining functions in the *point-free
    style*. For example, consider a function we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xs` is on the far right on both sides of the equal sign. Because of currying,
    we can omit the `xs` on both sides, since calling `foldl (+) 0` creates a function
    that takes a list. In this way, we are writing the function in point-free style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As another example, let’s try writing the following function in point-free
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t just get rid of the `x` on both right sides, since the `x` in the
    function body is surrounded by parentheses. `cos (max 50)` wouldn’t make sense—you
    can’t get the cosine of a function. What we *can* do is express `fn` as a composition
    of functions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Many times, a point-free style is more readable and concise, because
    it makes you think about functions and what kinds of functions composing them
    results in, instead of thinking about data and how it’s shuffled around. You can
    take simple functions and use composition as glue to form more complex functions.
  prefs: []
  type: TYPE_NORMAL
- en: However, if a function is too complex, writing it in point-free style can actually
    be less readable. For this reason, making long chains of function composition
    is discouraged. The preferred style is to use `let` bindings to give labels to
    intermediary results or to split the problem into subproblems that are easier
    for someone reading the code to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in the chapter, we solved the problem of finding the sum of all odd
    squares that are smaller than 10,000\. Here’s what the solution looks like when
    put into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'With our knowledge of function composition, we can also write the function
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: It may seem a bit weird at first, but you will get used to this style quickly.
    There’s less visual noise because we removed the parentheses. When reading this,
    you can just say that `filter odd` is applied to the result of `map (^2) [1..]`,
    then `takeWhile (<10000)` is applied to the result of that, and finally `sum`
    is applied to that result.
  prefs: []
  type: TYPE_NORMAL
