<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;COLLECTORS AND SENSORS"><div class="titlepage"><div><div><h1 class="title"><a id="collectors_and_sensors"/>Chapter 2. COLLECTORS AND SENSORS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e1151"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages651574.png.jpg"/></div></div><p>The collector and sensors are the irreplaceable components of any flow system. Why? You can analyze data in innumerable ways, but before you do, you must gather and store the data, and you do that with sensors and the collector.<a class="indexterm" id="IDX-CHP-2-0001"/></p><p>Because these pieces of your flow system are so critical, you'll begin your implementation with the collector and proceed to the first sensor.</p><div class="sect1" title="Collector Considerations"><div class="titlepage"><div><div><h1 class="title"><a id="collector_considerations"/>Collector Considerations</h1></div></div></div><p>The <span class="emphasis"><em>collector</em></span> is the host that receives records from network equipment and is where you'll perform most of your work. You must practice good systems administration on your collector, but you have a lot of flexibility on your hardware, operating system, and software.</p><div class="sect2" title="Operating System"><div class="titlepage"><div><div><h2 class="title"><a id="operating_system"/>Operating System</h2></div></div></div><p>The collector runs on a Unix-like operating system. Almost any modern Unix-like operating system will suffice. I recommend a BSD operating system. (If you've never worked with BSD, permit me to suggest you buy one of my BSD books, such as <span class="emphasis"><em>Absolute FreeBSD</em></span> or <span class="emphasis"><em>Absolute OpenBSD</em></span>.)<a class="indexterm" id="IDX-CHP-2-0002"/><a class="indexterm" id="IDX-CHP-2-0003"/><a class="indexterm" id="IDX-CHP-2-0004"/><a class="indexterm" id="IDX-CHP-2-0005"/><a class="indexterm" id="IDX-CHP-2-0006"/><a class="indexterm" id="IDX-CHP-2-0007"/><a class="indexterm" id="IDX-CHP-2-0008"/><a class="indexterm" id="IDX-CHP-2-0009"/><a class="indexterm" id="IDX-CHP-2-0010"/><a class="indexterm" id="IDX-CHP-2-0011"/></p><p>That said, Linux, OpenSolaris, or any standard 32-bit or 64-bit Unix-like system with a recent GCC compiler and libraries will work just fine. The more unusual your operating system, however, the more trouble you will have with your collector and reporting system. Some commercial Unix-like operating systems are noted for behavior that technically complies with the standards but differs from every other Unix-like operating system in bizarre or downright unspeakable ways.<sup>[<a class="footnote" href="#ftn.CHP-2-FN-1" id="CHP-2-FN-1">3</a>]</sup> Pick something known for playing well with others.<a class="indexterm" id="IDX-CHP-2-0012"/></p><p>Whichever system you choose, it must be secure. Every active Unix-like operating system has a current security and hardening guide. Get it. Read it. Use it. Your collector should provide no other services except for those related to flow management. This will let you harden the system much more than a multipurpose machine permits.</p></div><div class="sect2" title="System Resources"><div class="titlepage"><div><div><h2 class="title"><a id="system_resources"/>System Resources</h2></div></div></div><p>Flow collection uses very few system resources other than disk space. (I've run flow collectors on Pentium Pro servers.)</p><p>The amount of disk space needed depends on the type of traffic on your network and how long you want to retain your records. In my environment, a data flow averaging 5Mbps uses about 2GB of disk a month. Today, disk capacity expands faster than network utilization. I've found that it's possible to retain all data for the indefinite future if you keep buying larger disks.</p><p>Additional memory and CPU resources will accelerate flow reporting. When provisioning a machine for flow collection, I suggest using a slower but larger hard drive (like one of the "green" drives) and adding memory. The slower hard drive will save you money and power, and additional memory will improve the system's buffer cache and let you analyze data more quickly.</p><p>Get at least 4GB or more of RAM for your collector. Any modern Unix-like OS caches recently accessed disk files in RAM. Large amounts of memory will accelerate running multiple reports on the same data more than anything else.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FN-1" id="ftn.CHP-2-FN-1">3</a>] </sup>I would name names, but IBM has better lawyers than I do.</p></div></div></div>
<div class="sect1" title="Sensor Considerations"><div class="titlepage"><div><div><h1 class="title"><a id="sensor_considerations"/>Sensor Considerations</h1></div></div></div><p>The sensor is the device or program that captures flow data from your network and forwards it to the collector. Flow sensors are perhaps the most difficult portion of a flow-based management system to implement, especially on a geographically large network. You don't want to drive across the continent just to install a flow sensor!</p><p>The good news is, you don't need to worry about making those road trips. In fact, you probably already have flow sensors installed that you just haven't configured yet. Do you have Internet border routers? Have them act as sensors. Got a high-end Cisco switch? Great, use that.<a class="indexterm" id="IDX-CHP-2-0013"/><a class="indexterm" id="IDX-CHP-2-0014"/><a class="indexterm" id="IDX-CHP-2-0015"/><a class="indexterm" id="IDX-CHP-2-0016"/><a class="indexterm" id="IDX-CHP-2-0017"/><a class="indexterm" id="IDX-CHP-2-0018"/><a class="indexterm" id="IDX-CHP-2-0019"/></p><p>If you don't have hardware that can do the job, you can implement a flow sensor in software.<a class="indexterm" id="IDX-CHP-2-0020"/></p><div class="sect2" title="Location"><div class="titlepage"><div><div><h2 class="title"><a id="location"/>Location</h2></div></div></div><p>If you have even a medium-sized network, you'll quickly realize that you need to be selective about your sensor locations. Perhaps you have a couple dozen small switches and a hefty central core switch at your headquarters, half a dozen DMZs, an Internet border, and several remote facilities connected via VPN or MPLS. You could conceivably have sensors at each of these locations. Which are worth the effort?</p><div class="sect3" title="Internet Border"><div class="titlepage"><div><div><h3 class="title"><a id="internet_border"/>Internet Border</h3></div></div></div><p>Start with your Internet border. Almost all modern commercial-grade routers can export flow records. Analyzing those flows will tell you how you're using your Internet access. Knowing how much of your traffic is web surfing versus how much of your traffic is accessing your VPN will immediately help you make better decisions.</p></div><div class="sect3" title="Ethernet Core"><div class="titlepage"><div><div><h3 class="title"><a id="ethernet_core"/>Ethernet Core</h3></div></div></div><p>Look at your network's Ethernet core next. The internal LAN will have much more traffic than the wide-area Internet connection. Analyzing flow data from your internal network will quickly expose problems, misconfigurations, and performance issues. Your network architecture dictates sensor placement.</p><p>If you have a single large core switch, such as a Cisco 4000 or 7000, the switch itself can probably export flow information.</p><p>If you have multiple switches in your Ethernet core, you might think you need flow export on every one of them, but that's overly ambitious. You do not need a complete record of every last packet that passes through every switch on your office network.</p><p>When considering where to capture data, think about how traffic flows from device to device, and configure flow export only from central "choke" points. For example, my main data center has a configuration common in large enterprises: a large Cisco switch at its core and client switches in wiring closets on each floor. Every closet switch and every server is attached directly to the core switch. Any traffic that leaves a local switch must pass through the core switch.</p><p>I collect flow data only from the central switch. This means that I'm blind to any traffic that remains entirely on a closet switch, but I capture all client broadcast traffic and anything that goes to servers or leaves the network. Even if a client uses a printer attached to the local switch, the print job traverses the print server attached to the core switch. One single flow export point offers adequate visibility into the entire network.</p><p>If your Ethernet core is only one or two small switches and none of the switches can export flow information, you can still implement flow-based network management if one of the switches has a "sniffer" or "monitor" port. One of the switches is effectively the network core. If you haven't designated a particular switch as the core, use the switch that serves the highest number of servers. Attach a software flow sensor to the monitor port (see <a class="xref" href="ch02s10.html" title="Configuring Software Flow Sensors">Configuring Software Flow Sensors</a> in <a class="xref" href="ch02s10.html" title="Configuring Software Flow Sensors">Configuring Software Flow Sensors</a>).<a class="indexterm" id="IDX-CHP-2-0021"/><a class="indexterm" id="IDX-CHP-2-0022"/><a class="indexterm" id="IDX-CHP-2-0023"/><a class="indexterm" id="IDX-CHP-2-0024"/></p></div></div><div class="sect2" title="From Remote Facilities"><div class="titlepage"><div><div><h2 class="title"><a id="from_remote_facilities"/>From Remote Facilities</h2></div></div></div><p>Apply similar reasoning to remote facilities. Each remote facility has at least one router connecting it to the global network. It might be connected to an MPLS cloud or the Internet, but it's still your link into the outside world. Capture flows from that device.</p><p>If a remote facility has a export-capable core switch, use it as well. If the site reports many problems and the central switch cannot export flows, consider implementing a software sensor or upgrading the core switch.<a class="indexterm" id="IDX-CHP-2-0025"/></p><p>Have remote sites export their flows to your central collector. Maintaining multiple collectors increases your workload with very little gain.</p></div><div class="sect2" title="From Private Network Segments/DMZs"><div class="titlepage"><div><div><h2 class="title"><a id="from_private_network_segments_solidus_dm"/>From Private Network Segments/DMZs</h2></div></div></div><p>Tracking flows from your core network, and your Internet border provides insight into your entire network, including servers on isolated or private network segments such as DMZs. You can see the traffic DMZ servers exchange with your core network and the Internet. What you cannot see is the traffic among DMZ servers.</p><p>If you have only one or two servers on a DMZ, you probably don't need flow export on that network segment. If you have several servers, you'll want flow export. You don't need to decide right away, however. Fine-tune your flow management installation on your core and border networks, and then implement flow export on your DMZs.</p></div></div>
<div class="sect1" title="Implementing the Collector"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_the_collector"/>Implementing the Collector</h1></div></div></div><p>Enough theory, enough planning. Let's install something!</p><p>An Internet search reveals any number of freely available flow collectors. The big three are cflowd, flowd, and flow-tools. Cflowd is obsolete, is unsupported, and doesn't compile on 64-bit systems. I have high hopes for flowd, but it's a comparatively new tool and doesn't yet have broad support among users or third-party software. That leaves us with flow-tools, the most commonly used flow management tool kit.</p><p>Flow-tools is older but has a very broad user community. The original author (Mark Fullmer) released version 0.68 in 2005 and went on to other projects. Any unmaintained software slowly becomes obsolete, but a group of users assumed responsibility for flow-tools in 2007. These users collect improvements and bug fixes, and they release updated versions as needed. Although you'll still find occasional bugs, as with any software, flow-tools has a broad base of users.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Do not use version 0.68 of flow-tools. It has many small problems and does not function correctly on 64-bit systems. (It seems to work on 64-bit systems, but actually corrupts data, which is even worse than completely failing to work!) Take the time to install the newer version, 0.68.5 as of this writing.<a class="indexterm" id="IDX-CHP-2-0026"/><a class="indexterm" id="IDX-CHP-2-0027"/><a class="indexterm" id="IDX-CHP-2-0028"/><a class="indexterm" id="IDX-CHP-2-0029"/></p></div></div>
<div class="sect1" title="Installing Flow-tools"><div class="titlepage"><div><div><h1 class="title"><a id="installing_flow-tools"/>Installing Flow-tools</h1></div></div></div><p>You can install flow-tools from an operating system package or from source. Before installing it, visit the flow-tools website at <a class="ulink" href="http://code.google.com/p/flow-tools/">http://code.google.com/p/flow-tools/</a> to download the most recent version.<a class="indexterm" id="IDX-CHP-2-0030"/><a class="indexterm" id="IDX-CHP-2-0031"/></p><div class="sect2" title="Installing from Packages"><div class="titlepage"><div><div><h2 class="title"><a id="installing_from_packages"/>Installing from Packages</h2></div></div></div><p>Most Unix-like operating systems offer prepackaged versions of freely available software. If you can use precompiled, prepackaged software, do so.</p><p>However, many operating systems include only flow-tools version 0.68 rather than the newer version with its the bug fixes. Some operating systems, such as FreeBSD, include the newer software as a package called <span class="emphasis"><em>flow-tools-ng</em></span>.</p><p>Fine details in the flow-tools package names are important. For example, flow-tools was recently at version 0.68.4. A search for a CentOS flow-tools RPM revealed version 0.68-4, which is actually revision 4 of flow-tools package 0.68. At first glance, this might look like the correct package, but it's not.</p><p>By the time this book reaches print, ideally major OS vendors will provide an updated package. If not, you get to install from source.</p></div><div class="sect2" title="Installing from Source"><div class="titlepage"><div><div><h2 class="title"><a id="installing_from_source"/>Installing from Source</h2></div></div></div><p>To install the latest version of flow-tools from source, download the source code from <a class="ulink" href="http://code.google.com/p/flow-tools/">http://code.google.com/p/flow-tools/</a>, and extract it. You'll need GNU <code class="literal">make</code> and GCC, as well as the libraries and header files for your operating system.</p><a id="I_programlisting2_d1e1413"/><pre class="programlisting"># <strong class="userinput"><code>tar -xf flow-tools-0.68.4.tar.bz2</code></strong></pre><p>Now go into the <span class="emphasis"><em>flow-tools</em></span> directory, and read the <span class="emphasis"><em>INSTALL</em></span> file for the current compiling instructions. The process probably includes the steps <code class="literal">configure</code>, <code class="literal">make</code>, and <code class="literal">make install</code>.</p><p>Before installing, run <strong class="userinput"><code>./configure —help</code></strong> to list the build and installation options. The option I find most useful when installing is <code class="literal">prefix</code>, which allows you to specify where you want the software installed.</p><p>Most Unix-like operating systems install prepackaged software in <span class="emphasis"><em>/usr/local/bin</em></span>, <span class="emphasis"><em>/usr/local/sbin</em></span>, and so on. When you build a package such as flow-tools from source, however, your installation is not tightly integrated with the system's package management system. I suggest installing it in a location not used by the rest of the system because you don't want an operating system update to overwrite part of flow-tools or, worse, revert it to the obsolete version shipped with your OS! (Don't forget to update your PATH and MANPATH environment variables to include your new directories.)<a class="indexterm" id="IDX-CHP-2-0032"/><a class="indexterm" id="IDX-CHP-2-0033"/></p><p>In the following example, you'll install flow-tools under <span class="emphasis"><em>/usr/local/flow</em></span>. I'll use this directory for the examples throughout this book.<a class="indexterm" id="IDX-CHP-2-0034"/><a class="indexterm" id="IDX-CHP-2-0035"/><a class="indexterm" id="IDX-CHP-2-0036"/></p><a id="I_programlisting2_d1e1476"/><pre class="programlisting"># <strong class="userinput"><code>./configure --prefix=/usr/local/flow</code></strong>
# <strong class="userinput"><code>make</code></strong>
# <strong class="userinput"><code>make install</code></strong></pre><p>If your system is missing any prerequisites, the installation process will produce an error after the first command. After a successful install, you will find commands under <span class="emphasis"><em>/usr/local/flow/bin</em></span>, manual pages under <span class="emphasis"><em>/usr/local/flow/share/man</em></span>, and so on.</p><div class="sidebar"><a id="don_apostrophy_t_clean_up"/><p class="title">DON'T CLEAN UP</p><p>Do not run make clean after building flow-tools from source. I find that I occasionally need to return to the source code for troubleshooting.</p></div></div></div>
<div class="sect1" title="Running flow-capture"><div class="titlepage"><div><div><h1 class="title"><a id="running_flow-capture"/>Running flow-capture</h1></div></div></div><p>The <code class="literal">flow-capture</code> program listens on a specified UDP port for incoming flow exports. It then captures the data and writes flow records to disk. <code class="literal">flow-capture</code> must know where to write the files, how often to start a new file, who to accept flow information from, and so on. The <code class="literal">flow-capture</code> manual page offers many options, but the following example suffices for many situations:</p><a id="I_programlisting2_d1e1513"/><pre class="programlisting"># <strong class="userinput"><code>flow-capture -p /var/run/flow-capture.pid -n 287</code></strong>
 <strong class="userinput"><code>-w /var/db/flows -S 5 192.0.2.1/192.0.2.10/5678</code></strong></pre><p>The <code class="literal">-p</code> argument tells <code class="literal">flow-capture</code> where to store its process ID (PID) file. The location <span class="emphasis"><em>/var/run/flow-capture.pid</em></span> is a common default for most Unix-like operating systems.</p><p>The <code class="literal">-n</code> option tells <code class="literal">flow-capture</code> how many times it should rotate its log files in a 24-hour period. <code class="literal">287</code> tells <code class="literal">flow-capture</code> to create a new log file every five minutes. (The astute among you will notice that a day contains 288 five-minute periods. Flow-capture creates one file and then rotates to a new one 287 times in a day, for a total of 288 log files per day.) Many of the add-on reporting programs you'll use expect log files in five-minute increments.</p><p>Tell <code class="literal">flow-capture</code> where to write its files with <code class="literal">-w</code>. The directory <span class="emphasis"><em>/var/db/flows</em></span> is a common choice, though some prefer <span class="emphasis"><em>/var/log/flows</em></span>. Either way, each collector needs its own directory, so you might want to use something like <span class="emphasis"><em>/var/db/flows/internet</em></span> or <span class="emphasis"><em>/var/log/internet_flows</em></span>.</p><p>The <code class="literal">-S</code> <em class="replaceable"><code>5</code></em> option tells <code class="literal">flow-capture</code> to log messages to syslog, telling how many flows it has processed, how many packets it has received, and how many flows it believes it has dropped. The argument (<code class="literal">5</code>) is the number of minutes between log messages.</p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">flow-capture</code> uses the syslog facility LOCAL6. (Check a syslog tutorial to learn how to manage syslog messages.) You cannot change this facility without delving deep into the <code class="literal">flow-capture</code> source code.<a class="indexterm" id="IDX-CHP-2-0037"/><a class="indexterm" id="IDX-CHP-2-0038"/><a class="indexterm" id="IDX-CHP-2-0039"/><a class="indexterm" id="IDX-CHP-2-0040"/></p></div><p>The last command line argument (<code class="literal">192.0.2.10/192.0.2.1/5678</code>) specifies <code class="literal">flow-capture</code>'s network configuration. The first address is the IP address on the local machine that <code class="literal">flow-capture</code> listens to. As you can see in the listing above, our sample collector runs on the IP address 192.0.2.10. If you put a 0 in this space, the collector will accept traffic on all IP addresses on the machine. Even if your collector has only one IP address, I recommend explicitly assigning that address to your collector. You might add more IP addresses to your collector at a later date, and you probably don't want <code class="literal">flow-capture</code> attaching to those addresses as well.<a class="indexterm" id="IDX-CHP-2-0041"/><a class="indexterm" id="IDX-CHP-2-0042"/></p><p>The second IP, 192.0.2.1, is the address of the sensor that is permitted to send data to this collector. If you were to put 0 here (or eliminate it) instead of an IP address, <code class="literal">flow-capture</code> would accept flow data from any address. Doing so increases the risk that an intruder will send bogus data to your collector but also permits you to accept flows from multiple sources simultaneously. (Almost all Unix-like operating systems have packet filter functions that would let you protect this port from all but sensors you specify, however.)</p><p>Finally, <code class="literal">5678</code> is the UDP port <code class="literal">flow-capture</code> listens to. Because no authority has formally assigned a UDP port for Cisco NetFlow, you should use any high-numbered port not reserved by any other service. Port 6434 is assigned to sFlow, and ports 4739–4740 have been assigned to IPFIX, so you might want to use one of those ports. Also, many Cisco NetFlow products use port 2055, which was assigned to Cisco for a product never publicly released.</p><p>Try to start <code class="literal">flow-capture</code> on your system with options appropriate for your system. Confirm that it continues to run for a few minutes. This validates that you haven't made any fundamental mistakes in building or installing the software and that your command line is basically correct.</p><div class="sect2" title="Starting flow-capture at Boot"><div class="titlepage"><div><div><h2 class="title"><a id="starting_flow-capture_at_boot"/>Starting flow-capture at Boot</h2></div></div></div><p>Your operating system must start <code class="literal">flow-capture</code> at boot time, just as it does any other critical service. The process for doing so varies widely with operating systems. If you installed flow-tools from a package provided by your operating system vendor, it almost certainly includes a startup script. For example, the Red Hat Linux RPM installs a startup script in <span class="emphasis"><em>/etc/init.d</em></span>. The FreeBSD package includes a startup script configured in <span class="emphasis"><em>/etc/rc.local</em></span>. You'll need to tell the script where to store the captured flow files, how often to rotate them, and what hosts to accept flow data from—in fact, all of the things you set in the <code class="literal">flow-capture</code> command in the previous section.<a class="indexterm" id="IDX-CHP-2-0043"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>If the package for your chosen operating system doesn't include a startup script, add your <code class="literal">flow-capture</code> command into the computer's startup system appropriately. Check your operating system documentation. Sometimes this is as simple as copying the command into <span class="emphasis"><em>/etc/rc.local</em></span>. <code class="literal">flow-capture</code> should start only after the network and local storage are started.</p></div><p>Reboot your system to verify that <code class="literal">flow-capture</code> starts on boot.</p></div></div>
<div class="sect1" title="How Many Collectors?"><div class="titlepage"><div><div><h1 class="title"><a id="how_many_collectors_question"/>How Many Collectors?</h1></div></div></div><p>Now that you have one instance of <code class="literal">flow-capture</code> running, it's time to decide how to handle incoming data. You can choose to have all your sensors feed data to a single collector or have each sensor feed data to its own collector instance.<a class="indexterm" id="IDX-CHP-2-0044"/><a class="indexterm" id="IDX-CHP-2-0045"/><a class="indexterm" id="IDX-CHP-2-0046"/><a class="indexterm" id="IDX-CHP-2-0047"/><a class="indexterm" id="IDX-CHP-2-0048"/></p><p>Having all sensors feed records to one collector is simple. Configure one and only one collector, and do not restrict the addresses that can send to it. Configure all your sensors to use that single collector. The collector will intermingle all the flow records from all sensors into one common log file. But how do you tell whether flows are from one part of the network or another? You can differentiate flows by the sensor IP address, but this adds steps to the analysis.</p><p>In the absence of compelling reasons otherwise, I recommend running a separate collector for each flow sensor to help you keep your data separate. All the <code class="literal">flow-capture</code> instances can run on the same server and use the same IP address, and you can assign each <code class="literal">flow-capture</code> process its own UDP port and data directory so that you can analyze traffic from each network segment separately. Combining separated data is much easier than separating combined data.<a class="indexterm" id="IDX-CHP-2-0049"/></p></div>
<div class="sect1" title="Collector Log Files"><div class="titlepage"><div><div><h1 class="title"><a id="collector_log_files"/>Collector Log Files</h1></div></div></div><p>Your collector won't record anything until a sensor starts sending data. Once data reaches the collector, however, the collector creates a log file of the following format:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="emphasis"><em>tmp-v05.2009-11-15.134501-0500</em></span></td></tr></table><p>The leading <span class="emphasis"><em>tmp</em></span> in this filename indicates that this is a temporary file. <code class="literal">flow-capture</code> is still writing to this file. The year, month, and day on which the flow file was created comes next, followed by the timestamp in 24-hour format. The time given is the time the flow file was created, not the time the log file was completed and closed off. This example flow file was created on November 15, 2009 (<span class="emphasis"><em>2009-11-15</em></span>), at 13:45:01 or 1:45:01 <span class="keycap"><strong>pm</strong></span> (<span class="emphasis"><em>134501</em></span>). The last number (<span class="emphasis"><em>−0500</em></span>) is the time zone offset from UTC. My collector is running in Eastern standard time, negative five hours east of UTC. If your collector is in a time zone west of UTC, the time zone offset will have a <span class="emphasis"><em>+</em></span> in front of it. If you have multiple collectors in multiple time zones, I recommend having them all use the same time zone, such as UTC.<a class="indexterm" id="IDX-CHP-2-0050"/><a class="indexterm" id="IDX-CHP-2-0051"/></p><p>When it's time to create a new file, <code class="literal">flow-capture</code> renames the current temporary file to begin with <span class="emphasis"><em>ft-</em></span> and creates a new temporary file. The name otherwise remains the same, allowing you to easily identify and sort flow files by creation time.</p></div>
<div class="sect1" title="Collector Troubleshooting"><div class="titlepage"><div><div><h1 class="title"><a id="collector_troubleshooting"/>Collector Troubleshooting</h1></div></div></div><p>If you configure a sensor to send data to your collector but <code class="literal">flow-capture</code> isn't generating any log files within a few minutes, start troubleshooting. Either the sensor is not transmitting data, flow-capture is not writing the data to disk, or a firewall between the sensor and collector is blocking that port.<a class="indexterm" id="IDX-CHP-2-0052"/><a class="indexterm" id="IDX-CHP-2-0053"/><a class="indexterm" id="IDX-CHP-2-0054"/><a class="indexterm" id="IDX-CHP-2-0055"/><a class="indexterm" id="IDX-CHP-2-0056"/><a class="indexterm" id="IDX-CHP-2-0057"/><a class="indexterm" id="IDX-CHP-2-0058"/></p><p>To begin troubleshooting, first verify that sensor data is reaching your collector with <code class="literal">tcpdump</code> in order to separate network problems from local software problems.<a class="indexterm" id="IDX-CHP-2-0059"/></p><a id="I_programlisting2_d1e1825"/><pre class="programlisting"># <strong class="userinput"><code>tcpdump -p -n -i em0 udp and port 5678</code></strong></pre><p>The <code class="literal">-p</code> tells <code class="literal">tcpdump</code> to <span class="emphasis"><em>not</em></span> put the interface into promiscuous mode. This means that the system will only sniff traffic that reaches the local interface. (A proper switch configuration should prevent promiscuous-mode sniffing, but using <code class="literal">-p</code> means that the machine won't even try.) The <code class="literal">-i</code> argument gives the name of the interface that you want to listen to, <code class="literal">em0</code> in this case, which happens to be a network card on my system. (Most Linux distributions have a primary network interface of <code class="literal">eth0</code>.) Finally, specify the port your collector runs on, <code class="literal">5678</code> in this case.</p><p>This command should print information about every packet arriving at your collector host on the specified port. If you don't see any data reaching the collector host, check your sensor configuration and the configuration of any firewalls between the sensor and collector, and then use your packet sniffer progressively closer to the sensor until you find where the data stops. If you reach your sensor and find that it's not putting any flow exports on the wire, your sensor configuration is suspect. If necessary, contact your vendor for assistance.</p><p>If the system is receiving flow data but <code class="literal">flow-capture</code> is not writing any log files, check your flow-capture configuration to be sure that you specified the proper UDP port and directory. Verify that the user running <code class="literal">flow-capture</code> can write files to that directory. Also check the system logs, such as <span class="emphasis"><em>/var/log/messages</em></span>, for error messages. (Remember, <code class="literal">flow-capture</code> uses LOCAL6. Be certain to configure syslog to log LOCAL6 messages to a file.)</p></div>
<div class="sect1" title="Configuring Hardware Flow Sensors"><div class="titlepage"><div><div><h1 class="title"><a id="configuring_hardware_flow_sensors"/>Configuring Hardware Flow Sensors</h1></div></div></div><p>Configuring hardware flow sensors is your simplest and best option in most cases. Many network hardware manufacturers, such as Cisco, include flow export in their products. Cisco routers have supported NetFlow since the 1990s. Some larger Cisco switches also support NetFlow, but for best results you must configure switches differently than routers. Juniper routers also support flow export, so I'll cover configuring them. A number of smaller router vendors also support flow export, but you'll need to check your vendor's documentation for configuration instructions.<a class="indexterm" id="IDX-CHP-2-0060"/><a class="indexterm" id="IDX-CHP-2-0061"/></p><p>The book's examples will assume that the flow collector is running on the host 10.10.10.10 on UDP port 5678. Replace these with appropriate values for your environment.<a class="indexterm" id="IDX-CHP-2-0062"/><a class="indexterm" id="IDX-CHP-2-0063"/><a class="indexterm" id="IDX-CHP-2-0064"/><a class="indexterm" id="IDX-CHP-2-0065"/><a class="indexterm" id="IDX-CHP-2-0066"/></p><div class="sect2" title="Cisco Routers"><div class="titlepage"><div><div><h2 class="title"><a id="cisco_routers"/>Cisco Routers</h2></div></div></div><p>Configure NetFlow on a Cisco router interface by interface. You probably need NetFlow only on your upstream interface(s), not on the local Ethernet interface. (If you have a complex Ethernet infrastructure, such as an HSRP or VRRP cluster, you might want to monitor flows on the Ethernet interfaces as well.) In the following example, you activate NetFlow on the interface Serial0/0:<a class="indexterm" id="IDX-CHP-2-0067"/><a class="indexterm" id="IDX-CHP-2-0068"/></p><a id="I_programlisting2_d1e1925"/><pre class="programlisting">Router# <strong class="userinput"><code>conf t</code></strong>
Router(config)# <strong class="userinput"><code>int s0/0</code></strong>
Router(config-if)# <strong class="userinput"><code>ip route-cache flow</code></strong>
Router(config-if)# <strong class="userinput"><code>exit</code></strong></pre><p>Repeat this configuration on all upstream router interfaces, and then tell the router where to send flow data.</p><a id="I_programlisting2_d1e1940"/><pre class="programlisting">Router(config)# <strong class="userinput"><code>ip flow-export version 5</code></strong>
Router(config)# <strong class="userinput"><code>ip flow-export destination 10.10.10.10 5678</code></strong></pre><p>Now save your work. You should find that data goes to your collector almost immediately.</p><p>To see the flow information tracked on your router, use the IOS command <strong class="userinput"><code>show ip cache flow</code></strong>.<a class="indexterm" id="IDX-CHP-2-0069"/></p><p>Some Cisco models use a slightly different syntax. If you have trouble, search Cisco's website or the Internet for suggestions.</p></div><div class="sect2" title="Cisco Switches"><div class="titlepage"><div><div><h2 class="title"><a id="cisco_switches"/>Cisco Switches</h2></div></div></div><p>NetFlow on Cisco switches is a comparatively recent development and is limited to higher-end models. As a rule, only modular switches such as the 4000, 6000, and their descendants support NetFlow export. Many switches also require an add-on NetFlow card that you might or might not have. Stackable switches do not, nor do smaller stand-alone managed switches. Enable or disable NetFlow for the switch as a whole, not on a per-interface basis.<a class="indexterm" id="IDX-CHP-2-0070"/></p><p>NetFlow support varies widely by model and the IOS version installed. I'm providing a sample configuration here, but do not blindly install it on your switch! Cisco switches can perform many tasks in many different ways, and what works in my environment might not work in yours.</p><p>Before configuring NetFlow on your router, ask Cisco how to capture all flow data from your model of switch in your environment. Your configuration will probably look similar to the following sample.<a class="indexterm" id="IDX-CHP-2-0071"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you decide that you want to just try this and see what happens, back up your configuration first and try it while you have no users on the network.</p></div><a id="I_programlisting2_d1e1983"/><pre class="programlisting">Switch# <strong class="userinput"><code>conf t</code></strong>
Switch(config)# <strong class="userinput"><code>ip route-cache flow</code></strong>
Switch(config)# <strong class="userinput"><code>ip flow ingress</code></strong>
Switch(config)# <strong class="userinput"><code>ip flow ingress layer2-switched</code></strong>
Switch(config)# <strong class="userinput"><code>ip flow-export version 7</code></strong>
Switch(config)# <strong class="userinput"><code>ip flow-export destination 10.10.10.10 5678</code></strong></pre><p>The second line's configuration statement (<code class="literal">ip route-cache flow</code>) tells the switch to activate flows, and the next one (<code class="literal">ip flow ingress</code>) tells the switch to track flows based on the route they take to enter the switch.<a class="indexterm" id="IDX-CHP-2-0072"/><a class="indexterm" id="IDX-CHP-2-0073"/><a class="indexterm" id="IDX-CHP-2-0074"/><a class="indexterm" id="IDX-CHP-2-0075"/><a class="indexterm" id="IDX-CHP-2-0076"/><a class="indexterm" id="IDX-CHP-2-0077"/><a class="indexterm" id="IDX-CHP-2-0078"/></p><p>By default these routing-capable switches export information only about flows that they route, not switched Ethernet traffic. However, because you want to capture flow information about the local Ethernet traffic as well, you tell the switch to capture the layer 2 flows as well with <strong class="userinput"><code>ip flow ingress layer2-switched</code></strong>.</p><p>Cisco switches speak NetFlow version 7, so you might as well use it. Turn it on with <strong class="userinput"><code>ip flow-export version 7</code></strong>. Finally, you tell the switch where to send the flow data, to <code class="literal">10.10.10.10</code>, port <code class="literal">5678</code>.<a class="indexterm" id="IDX-CHP-2-0079"/></p><p>Once you've completed your configuration, save your work. Data should arrive at your collector almost immediately. As with a Cisco router, use the command <strong class="userinput"><code>show ip cache flow</code></strong> to see current flow statistics.<a class="indexterm" id="IDX-CHP-2-0080"/></p></div><div class="sect2" title="Juniper Routers"><div class="titlepage"><div><div><h2 class="title"><a id="juniper_routers"/>Juniper Routers</h2></div></div></div><p>Juniper configurations are much longer than Cisco configurations, but the configuration isn't that difficult. Start by telling the Juniper how to sample flow traffic and where you want the flows sent.</p><a id="I_programlisting2_d1e2071"/><pre class="programlisting">forwarding-options {
   sampling {
     input {
       family inet {
❶      rate 1;
       run-length 9;
     }
   }
   output {
❷     cflowd 10.10.10.10 {
❸     port 5678
❹     source-address 172.16.16.16;
      version 5;
      no-local-dump;
      }
   }
  }
}</pre><p>Despite all the parentheses, this configuration isn't that hard to understand. You begin at ❶ by defining how heavily you want to sample flows. In this example, I've set the sampling rate to 1. This Juniper samples 1 flow out of every 1, or all, flows. If you were to set the sampling rate to 100, the Juniper would sample 1 out of every 100 packets. This example betrays my personal bias; I record all traffic, if possible. If complete traffic recording overloads your router, increase the sampling level until the hardware can support it. Those of you with 10GB networks almost certainly must sample! The only way to determine the lowest sustainable sampling rate on your network is through experimentation. Sampling too aggressively overloads the router and causes packet loss.<a class="indexterm" id="IDX-CHP-2-0081"/><a class="indexterm" id="IDX-CHP-2-0082"/><a class="indexterm" id="IDX-CHP-2-0083"/><a class="indexterm" id="IDX-CHP-2-0084"/></p><p>As you might remember, cflowd is an obsolete flow collector. Juniper hardware uses that name to specify where the router will send flows. At ❷ you tell the Juniper where to find your flow collector, the UDP port (❸) the collector runs on, and what address on the router (❹) to send packets from.<a class="indexterm" id="IDX-CHP-2-0085"/></p><p>Now enable sampling on the interface(s) you want to capture flow data from.</p><a id="I_programlisting2_d1e2106"/><pre class="programlisting">...
  family inet {
    sampling {
      input;
      output;
    }
...</pre><p>This configuration sends the incoming and outgoing traffic on this interface to the flow export (or sampling) engine.</p></div></div>
<div class="sect1" title="Configuring Software Flow Sensors"><div class="titlepage"><div><div><h1 class="title"><a id="configuring_software_flow_sensors"/>Configuring Software Flow Sensors</h1></div></div></div><p>Suppose you need flow export on a network but don't have any switches that support flow export. Never fear, you can implement a flow sensor in software instead of buying new hardware.</p><p>Using software instead of hardware for flow sensing has limitations. For one, software needs to run on a server, so it adds another device to your network. Also, you can only capture data from a managed Ethernet switch. The software might not capture all the traffic, and it might not tell you when it misses something. And flow sensor software is yet another thing that the network administrator must configure, patch, and maintain. Don't you have enough to do already? Still, for a small network, software is the only realistic choice.</p><div class="sect2" title="Setting Up Sensor Server Hardware"><div class="titlepage"><div><div><h2 class="title"><a id="setting_up_sensor_server_hardware"/>Setting Up Sensor Server Hardware</h2></div></div></div><p>Flow sensor software requires very few system resources. You can easily use a desktop that your management took out of production because it ran so slowly that the receptionist couldn't use it anymore. I've run effective flow sensors on tiny computers such as the Soekris (<a class="ulink" href="http://www.soekris.com/">http://www.soekris.com/</a>). Even a modest machine with a 266MHz CPU and 128MB of RAM was mostly idle while capturing traffic off a low-traffic LAN.<a class="indexterm" id="IDX-CHP-2-0086"/></p><p>Whatever hardware you choose, your flow sensor machine needs at least two network interfaces. One interface must be capable of handling many packets per second. If you're recycling a discarded desktop machine with a network card embedded on the motherboard, assume that the built-in network card is not of sufficient quality. Very few desktop motherboard vendors use high-end network chipsets, preferring to use inexpensive chipsets that are just barely adequate for most users. If you're not sure what network card to buy, Intel's cards usually suffice for a flow sensor. The embedded network cards on server-grade systems are usually adequate; they're not great, but they're adequate.<a class="indexterm" id="IDX-CHP-2-0087"/><a class="indexterm" id="IDX-CHP-2-0088"/><a class="indexterm" id="IDX-CHP-2-0089"/><a class="indexterm" id="IDX-CHP-2-0090"/><a class="indexterm" id="IDX-CHP-2-0091"/><a class="indexterm" id="IDX-CHP-2-0092"/><a class="indexterm" id="IDX-CHP-2-0093"/></p><p>Finally, if you recycle an old machine for flow sensor hardware, get a new hard drive. Flow sensors use very little hard drive space, but the hard drive is the system component most likely to fail with age. You don't want to install your flow sensor just to see your work evaporate in a few weeks because the hard drive shattered! (Senior systems administrators might consider building a flow sensor bootable CD out of a tool kit such as FreeSBIE so that you can mass-produce easily replaceable sensors.)<a class="indexterm" id="IDX-CHP-2-0094"/></p><p>Finally, I recommend using the same operating system on both your flow sensor server and your collector. This is certainly not a requirement, but running multiple operating systems in production just because you can is a symptom of having too much time on your hands.</p></div><div class="sect2" title="Network Setup"><div class="titlepage"><div><div><h2 class="title"><a id="network_setup"/>Network Setup</h2></div></div></div><p>Using a software flow sensor requires that you have a switch capable of <span class="emphasis"><em>port mirroring</em></span> or <span class="emphasis"><em>port monitoring</em></span>. This is often called a <span class="emphasis"><em>sniffer port</em></span>. The switch copies all traffic crossing the switch to the monitor interface. You might verify this with a packet sniffer before proceeding.<a class="indexterm" id="IDX-CHP-2-0095"/></p><p>To configure a monitor port on a Cisco system, define the interfaces you want to monitor and the interface to which you want to direct traffic. In the following example, a Cisco switch is copying all traffic from VLAN 1 into interface Gi0/4. (Many switch vendors also offer web-based configuration tools.)</p><a id="I_programlisting2_d1e2178"/><pre class="programlisting">router# <strong class="userinput"><code>conf t</code></strong>
❶ router(config)# <strong class="userinput"><code>monitor session 1 source vlan 1</code></strong>
❷ router(config)# <strong class="userinput"><code>monitor session 1 destination interface</code></strong> <strong class="userinput"><code>Gi0/4</code></strong></pre><p>You start at ❶ by defining a monitor session and telling the switch which VLAN or ports to monitor. Then at ❷ you tell the switch where to replicate the monitored traffic. This small switch will now copy all traffic crossing the main VLAN to the monitor port.</p><p>A switch that can export flows should be large enough to allow you to connect all of your primary servers to it so that all critical traffic crosses that big switch and your flow exports capture pretty much everything vital. If you use a few smaller switches instead of one big one, ensure that the monitor port captures traffic from all critical servers.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember, any traffic that remains on a closet switch will not be captured. You could deploy a flow sensor on every switch, but that quickly becomes cumbersome.<a class="indexterm" id="IDX-CHP-2-0096"/><a class="indexterm" id="IDX-CHP-2-0097"/><a class="indexterm" id="IDX-CHP-2-0098"/><a class="indexterm" id="IDX-CHP-2-0099"/><a class="indexterm" id="IDX-CHP-2-0100"/></p></div></div><div class="sect2" title="Sensor Server Setup"><div class="titlepage"><div><div><h2 class="title"><a id="sensor_server_setup"/>Sensor Server Setup</h2></div></div></div><p>A switch will not accept regular traffic on a monitor port, so the sensor machine cannot use the monitor port for its network traffic. (Go ahead, try it.) Sniffer ports are only for watching the network, not participating in the network. Your sensor box needs a second network card for regular network activity.</p><p>On Linux and BSD systems, you must activate the sniffer interface before it can sense traffic. It's also wise to disable ARP on the interface (with the <code class="literal">up</code> and <code class="literal">-arp</code> commands) so that your sniffer interface doesn't even try to participate in the network. Here, you start the interface em0 and disable ARP on it:</p><a id="I_programlisting2_d1e2230"/><pre class="programlisting"># <strong class="userinput"><code>ifconfig</code></strong>
 <strong class="userinput"><code>em0</code></strong>
 <strong class="userinput"><code>up -arp</code></strong></pre><p>Substitute your sniffer interface for em0, and then use <code class="literal">tcpdump</code> to verify that you're seeing network traffic on your sniffer interface.</p><a id="I_programlisting2_d1e2245"/><pre class="programlisting"># <strong class="userinput"><code>tcpdump -n -i em0</code></strong></pre><p>You should see traffic records streaming across the screen. Press <span class="keycap"><strong>ctrl</strong></span>-C to stop the output.</p></div><div class="sect2" title="Running the Sensor on the Collector"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_sensor_on_the_collector"/>Running the Sensor on the Collector</h2></div></div></div><p>If your collector runs on higher-end hardware and you don't need many sensors, you might consider running the sensor on the collector machine. Add another network interface to the machine, have the sensor run on that interface, then configure the sensor to transmit to a UDP port on the localhost IP (127.0.0.1), and have the collector accept connections only from 127.0.0.1.</p><p>This machine becomes doubly security sensitive, however. Not only does the collector have a historical record of traffic through your network, but it can view all current network activity. Secure this machine!</p></div></div>
<div class="sect1" title="The Sensor: softflowd"><div class="titlepage"><div><div><h1 class="title"><a id="the_sensor_colon_softflowd"/>The Sensor: softflowd</h1></div></div></div><p>Again, an Internet search will reveal many different software flow sensors, but I recommend <code class="literal">softflowd</code>, from <a class="ulink" href="http://www.mindrot.org/softflowd.html">http://www.mindrot.org/softflowd.html</a>. Go there to identify the current version; if you can find a current package for your operating system, use it. If you cannot find a package, download the source code, and install the program by hand.<a class="indexterm" id="IDX-CHP-2-0101"/></p><p>Check the <code class="literal">softflowd</code> README file for instructions on how to build. Much like flow-tools, <code class="literal">softflowd</code> has a <code class="literal">configure</code> script. I prefer to install my add-on software in a different directory than the main system so I can easily keep it separate. Here I install <code class="literal">softflowd</code> under <span class="emphasis"><em>/usr/local/softflowd</em></span>:<a class="indexterm" id="IDX-CHP-2-0102"/><a class="indexterm" id="IDX-CHP-2-0103"/></p><a id="I_programlisting2_d1e2300"/><pre class="programlisting"># <strong class="userinput"><code>configure --prefix=/usr/local/softflowd</code></strong>
# <strong class="userinput"><code>gmake</code></strong>
# <strong class="userinput"><code>gmake install</code></strong></pre><p>This installs two programs (<code class="literal">softflowd</code> and <code class="literal">softflowctl</code>), a man page for each program, and a README file.</p><div class="sect2" title="Running softflowd"><div class="titlepage"><div><div><h2 class="title"><a id="running_softflowd"/>Running softflowd</h2></div></div></div><p>To run <code class="literal">softflowd</code>, you must know the interface <code class="literal">softflowd</code> will listen to, the collector's hostname or IP address, and the port the collector is running on. Here, I'm having <code class="literal">softflowd</code> listen to the port em0 and transmit data to 10.10.10.10 on port 5678:<a class="indexterm" id="IDX-CHP-2-0104"/></p><a id="I_programlisting2_d1e2337"/><pre class="programlisting"># <strong class="userinput"><code>softflowd -i</code></strong> <strong class="userinput"><code>em0</code></strong> <strong class="userinput"><code>-t maxlife=300 -n</code></strong> <strong class="userinput"><code>10.10.10.10:5678</code></strong></pre><p>The <code class="literal">-t maxlife=300</code> in the middle of the command sets the flow timeout to 300 seconds, or five minutes.</p><p><code class="literal">softflowd</code> is more flexible than a hardware flow sensor, which means you have more opportunities to misconfigure it. The manual page has a complete list of ways you can adjust <code class="literal">softflowd</code>'s performance, but most of them are not useful in most environments. The one option that might be helpful, though, is the ability to change the upper limit on the number of flows <code class="literal">soft-flowd</code> will track at any one time.</p><p>By default <code class="literal">softflowd</code> tracks up to 8,192 flows at once, using about 800KB of memory. That's an awful lot of simultaneous connections, but if you're monitoring a high-bandwidth link, you might need to raise it. (The next section shows how to see how many flows <code class="literal">softflowd</code> is actually tracking at any given time.) Use the <strong class="userinput"><code>-m</code></strong> flag to specify the upper limit on the number of tracked flows.</p><a id="I_programlisting2_d1e2376"/><pre class="programlisting"># <strong class="userinput"><code>softflowd -i</code></strong> <strong class="userinput"><code>em0</code></strong> <strong class="userinput"><code>-t 5m -m 16384 -n</code></strong> <strong class="userinput"><code>10.10.10.10:5678</code></strong></pre><p>This example tracks twice the normal number of flows.</p></div><div class="sect2" title="Watching softflowd"><div class="titlepage"><div><div><h2 class="title"><a id="watching_softflowd"/>Watching softflowd</h2></div></div></div><p>The <code class="literal">softflowctl</code> program allows the network administrator to manage a running <code class="literal">softflowd</code> process. You can use it to start and stop collecting flows, view currently tracked flows, and flush all flows being tracked to the collector. The softflowctl manual page gives instructions for all of softflowctl's features, but I'll cover only the functions used in normal circumstances.</p><p>The easy <code class="literal">softflowctl</code> commands are <code class="literal">shutdown</code> and <code class="literal">exit</code>. To tell <code class="literal">softflowd</code> to export all the flows it's currently tracking to the collector and shut itself down, use the <code class="literal">shutdown</code> command. This is the recommended way to terminate <code class="literal">softflowd</code>.<a class="indexterm" id="IDX-CHP-2-0105"/><a class="indexterm" id="IDX-CHP-2-0106"/><a class="indexterm" id="IDX-CHP-2-0107"/><a class="indexterm" id="IDX-CHP-2-0108"/></p><a id="I_programlisting2_d1e2439"/><pre class="programlisting"># <strong class="userinput"><code>softflowctl shutdown</code></strong></pre><p>If you want <code class="literal">softflowd</code> to shut itself off without sending any additional flows to the collector, use the <code class="literal">exit</code> command. You will lose any data <code class="literal">softflowd</code> has gathered but not exported.</p><a id="I_programlisting2_d1e2454"/><pre class="programlisting"># <strong class="userinput"><code>softflowctl exit</code></strong></pre><p>The more interesting features of <code class="literal">softflowctl</code> include the ability to view currently tracked flows and the ability to view the <code class="literal">softflowd</code>'s internal statistics on tracked flows.<a class="indexterm" id="IDX-CHP-2-0109"/></p><div class="sect3" title="Viewing Tracked Flows"><div class="titlepage"><div><div><h3 class="title"><a id="viewing_tracked_flows"/>Viewing Tracked Flows</h3></div></div></div><p>If you want to see the flows that <code class="literal">softflowd</code> is currently tracking, use <code class="literal">softflowctl</code>'s <code class="literal">dump-flows</code> command. Each line is a single flow. If you see flows, <code class="literal">softflowd</code> is working.</p><a id="I_programlisting2_d1e2490"/><pre class="programlisting"># <strong class="userinput"><code>softflowctl dump-flows</code></strong>
softflowd[61946]: Dumping flow data:
ACTIVE seq:84 [❶ 192.0.2.253]:❷ 4234 &lt;&gt; [❸ 239.255.255.250]:❹
 1900 proto:❺17 octets&gt;:314 packets&gt;:1 octets&lt;:0
 packets&lt;:0 start:2011-12-07T15:03:18.541 finish:2011-12-07T15:03:18
.541 tcp&gt;:00 tcp&lt;:00 flowlabel&gt;:00000000 flowlabel&lt;:00000000
EXPIRY EVENT for flow 84 now
...</pre><p>This flow involves a host with an IP of 192.0.2.253 (❶) and port 4234 (❷), and the other end of the connection is the host 239.255.255.250 (❸) on port 1900 (❹). This flow uses protocol 17 (❺), or UDP. Although you can see timing information as well, you'll have other ways to view this data more conveniently.</p></div><div class="sect3" title="Viewing Flow Statistics"><div class="titlepage"><div><div><h3 class="title"><a id="viewing_flow_statistics"/>Viewing Flow Statistics</h3></div></div></div><p><code class="literal">softflowd</code> starts tracking flows immediately upon starting. You can use <code class="literal">softflowctl</code> to query <code class="literal">softflowd</code> about the characteristics of the flows it is currently tracking with the <code class="literal">statistics</code> command, as shown here:</p><a id="I_programlisting2_d1e2513"/><pre class="programlisting"># <strong class="userinput"><code>softflowctl statistics</code></strong></pre><p>I'll break up the lengthy output from this command into a few sections to make it easier to understand.</p><a id="I_programlisting2_d1e2519"/><pre class="programlisting">❶ softflowd[61946]: Accumulated statistics:
❷ Number of active flows: 16
❸ Packets processed: 11898
❹ Fragments: 0
❺ Ignored packets: 46 (46 non-IP, 0 too short)
❻ Flows expired: 759 (0 forced)
❼ Flows exported: 784 in 67 packets (0 failures)
❽ Packets received by libpcap: 12156
❾ Packets dropped by libpcap: 0
❿ Packets dropped by interface: 0</pre><p>The first line at ❶ includes one interesting number: the process ID of the <code class="literal">softflowd</code> process you're querying. If you're running multiple instances of <code class="literal">softflowd</code> on one machine, this will help you verify that you're querying the correct one.<a class="indexterm" id="IDX-CHP-2-0110"/><a class="indexterm" id="IDX-CHP-2-0111"/><a class="indexterm" id="IDX-CHP-2-0112"/><a class="indexterm" id="IDX-CHP-2-0113"/><a class="indexterm" id="IDX-CHP-2-0114"/></p><p>The number of active flows at ❷ tells you how many flows <code class="literal">softflowd</code> thinks are ongoing. This is not the same as the number of active connections on your network at the moment. Remember, a sensor tracks a flow unless either it has reason to think that the flow has ended or the timeout expires. A flow from a DNS or UDP NFS request remains in <code class="literal">softflowd</code>'s list of tracked flows until the timeout expires, which may be long after the corresponding network activity has ceased.</p><p>The number of packets processed (❸) should always increase, and the number of fragments (❹) probably will increase but less quickly.</p><p>The number of packets dropped (❺) is much more interesting. Every network tends to have "odd stuff " fluttering across it now and then. Flow management only handles TCP/IP and its related protocols, including IPv6, SCTP, and other advanced protocols. When <code class="literal">softflowd</code> encounters packets that are not part of TCP/IP, such as DECNet, it counts them but doesn't otherwise process them. Dropped packets might come from bad hardware, badly scrambled TCP/IP stacks, unusual network protocols, or any other weird error. You might try <code class="literal">netstat -s</code> to get an idea about which part of your system is dropping packets, and why. <code class="literal">softflowd</code> also drops packets that are too short to contain actual data.</p><p>You can see at ❻ that the number of flows <code class="literal">softflowd</code> has expired, as well as at ❼ how many it has exported to the collector. These numbers do not necessarily equal each other, because the former is a <code class="literal">softflowd</code> internal statistic. The number of flows exported should match the number received on the collector, however. If you see that <code class="literal">softflowd</code> has forced some flows to expire, use <code class="literal">-m</code> to increase the number of flows <code class="literal">softflowd</code> may track.</p><p>Libpcap is the packet-capture software <code class="literal">softflowd</code> uses. At ❽, the number of packets libpcap receives should be roughly comparable to the number of packets <code class="literal">softflowd</code> has processed. At ❾, the number of packets dropped by libpcap should be very low for proper data capture. If this number is increasing, investigate. Your operating system or your hardware might not be adequate to the load being placed on it.<a class="indexterm" id="IDX-CHP-2-0115"/><a class="indexterm" id="IDX-CHP-2-0116"/></p><p>It's also possible that your network card might not be up to the task of capturing all the data from your network. Finally, at ❿, the packets dropped by interface counter should be zero, or at least very low.<a class="indexterm" id="IDX-CHP-2-0117"/><a class="indexterm" id="IDX-CHP-2-0118"/><a class="indexterm" id="IDX-CHP-2-0119"/><a class="indexterm" id="IDX-CHP-2-0120"/></p><p>The output continues with information about the expired flows.</p><a id="I_programlisting2_d1e2625"/><pre class="programlisting">Expired flow statistics:   minimum       average       maximum
  Flow bytes:              ❶   221     ❹ 263570        7564472
  Flow packets:            ❷     1          345           9446
  Duration:                ❸ 0.00s     ❺  22.73s        307.47s</pre><p>The smallest flow (❶) had 221 bytes. The smallest number of packets in a flow (❷) was 1. The briefest flow (❸) lasted less than one one-hundredth of a second.</p><p>You can make some guesses based on this data. For example, it's likely but not certain that the 221-byte flow was in a single packet, and it probably was the briefest as well. You might have many flows containing a small number of bytes in a single packet, though, and it's possible that the 221-byte flow was broken into multiple small packets. To reach any conclusions about particular flows, you must perform more detailed analysis. Treat the maximum values similarly; the flow with the greatest number of bytes was not necessarily the flow with the greatest number of packets.</p><p>The average flow (❹) was 263,570 bytes, or roughly 257KB, and lasted about 22 seconds (❺). Again, you cannot assume that the average-sized flows are the same as the flows with the average number of packets or the flows of average duration.<a class="indexterm" id="IDX-CHP-2-0121"/><a class="indexterm" id="IDX-CHP-2-0122"/></p><p>The statistics end with a count of the reasons why <code class="literal">softflowd</code> expired and exported each flow and a per-protocol statistics list.</p><a id="I_programlisting2_d1e2646"/><pre class="programlisting">Expired flow reasons:
        tcp =        10   tcp.rst =      ❶ 1   tcp.fin =       ❷ 1
        udp =       126      icmp =      ❸ 0   general =         0
❹   maxlife =         5
❺  over 2Gb =         0
❻  maxflows =         0
❼   flushed =         0

 Per-protocol statistics:     Octets      Packets   Avg Life    Max Life
             tcp (6):       32994923        36899     195.36s     330.44s
            udp (17):          46014          135       0.00s       0.03s</pre><p>TCP and UDP have their own entries, including the specific reasons why flows were expired. For example, as shown at ❶, TCP flows can be expired by a TCP RST indicating that a port is closed or by the TCP FIN (❷) that marks the end of a normal session. Similarly, a UDP request to a closed port can generate an ICMP response, as shown at ❸, or it might just time out.</p><p><code class="literal">softflowctl</code> also displays the number of flows expired because the timeout elapsed (❹) and the number expired because they exceeded the maximum size of a single flow (❺).</p><p>The <code class="literal">softflowd</code> program tracks a maximum number of flows simultaneously. If <code class="literal">softflowd</code> detects more flows than it can track, it expires older idle flows until it has sufficient capacity to track active flows. If the maxflows number (❼) begins climbing, increase the number of flows <code class="literal">softflowd</code> can track at any time.</p><p>Finally, the flushed entry (❽) shows how many flows were expired when the administrator ran <code class="literal">softflowctl expire-all</code>.</p><p>The statistics section ends with per-protocol flow information.</p><p>Now that you've gathered some data, you'll learn how to look at it in <a class="xref" href="ch03.html" title="Chapter 3. VIEWING FLOWS">Chapter 3</a>.</p></div></div></div></body></html>