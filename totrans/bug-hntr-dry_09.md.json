["```\n01    #include <string.h>\n02\n03    void\n04    overflow (char *arg)\n05    {\n06        char  buf[12];\n07\n08        strcpy (buf, arg);\n09    }\n10\n11    int\n12    main (int argc, char *argv[])\n13    {\n14        if (argc > 1)\n15            overflow (argv[1]);\n16\n17        return 0;\n18    }\n```", "```\nlinux$ `gcc -fno-stack-protector -o stackoverflow stackoverflow.c`\n```", "```\nlinux$ `gdb -q ./stackoverflow`\n\n(gdb) `run $(perl -e 'print \"A\"x12 . \"B\"x4 . \"C\"x4')`\nStarting program: /home/tk/BHD/stackoverflow $(perl -e 'print \"A\"x12 . \"B\"x4 . \"C\"x4')\n\nProgram received signal SIGSEGV, Segmentation fault.\n`0x43434343 in ?? ()`\n\n(gdb) `info registers`\neax            0xbfab9fac     −1079271508\necx            0xbfab9fab     −1079271509\nedx            0x15           21\nebx            0xb8088ff4     −1207398412\nesp            0xbfab9fc0     0xbfab9fc0\nebp            0x42424242     0x42424242\nesi            0x8048430      134513712\nedi            0x8048310      134513424\n`eip            0x43434343     0x43434343`\neflags         0x10246   [ PF ZF IF RF ]\ncs             0x73      115\nss             0x7b      123\nds             0x7b      123\nes             0x7b      123\nfs             0x0       0\ngs             0x33      51\n```", "```\nC:\\Users\\tk\\BHD>`cl /nologo /GS- stackoverflow.c`\nstackoverflow.c\n```", "```\n01    #include <stdio.h>\n02\n03    typedef struct pkt {\n04        char *  value;\n05    } pkt_t;\n06\n07    int\n08    main (void)\n09    {\n10        pkt_t *  packet  = NULL;\n11\n12        printf (\"%s\", packet->value);\n13\n14        return 0;\n15    }\n```", "```\n[..]\n(1334.12dc): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n`eax=00000000` ebx=7713b68f ecx=00000001 edx=77c55e74 esi=00000002 edi=00001772\neip=0040100e esp=0012ff34 ebp=0012ff38 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\n*** WARNING: Unable to verify checksum for image00400000\n*** ERROR: Module load completed but symbols could not be loaded for image00400000\nimage00400000+0x100e:\n`0040100e 8b08            mov     ecx,dword ptr [eax]  ds:0023:00000000=????????`\n[..]\n```", "```\n0:000> `!analyze -v`\n[..]\nFAULTING_IP:\nimage00400000+100e\n0040100e 8b08            mov     ecx,dword ptr [eax]\n\nEXCEPTION_RECORD:  ffffffff -- (.exr 0xffffffffffffffff)\nExceptionAddress: 0040100e (image00400000+0x0000100e)\n   `ExceptionCode: c0000005 (Access violation)`\n  ExceptionFlags: 00000000\nNumberParameters: 2\n   Parameter[0]: 00000000\n   Parameter[1]: 00000000\n`Attempt to read from address 00000000`\n[..]\n```", "```\n[..]\nunsigned int user_input = 0x80000000;\nsigned int   length     = user_input;\n[..]\n```", "```\n[..]\nchar       cbuf[] = \"AAAA\";\nsigned int si     = *(int *)cbuf;\n[..]\n```", "```\n01    #include <stdio.h>\n02\n03    unsigned int\n04    get_user_length (void)\n05    {\n06        return (0xffffffff);\n07    }\n08\n09    int\n10    main (void)\n11    {\n12        signed int length = 0;\n13\n14        length = get_user_length ();\n15\n16        printf (\"length: %d %u (0x%x)\\n\", length, length, length);\n17\n18        if (length < 12)\n19            printf (\"argument length ok\\n\");\n20        else\n21            printf (\"Error: argument length too long\\n\");\n22\n23        return 0;\n24    }\n```", "```\nC:\\Users\\tk\\BHD>`cl /nologo implicit.c`\nimplicit.c\n\nC:\\Users\\tk\\BHD>`implicit.exe`\nlength: −1 4294967295 (0xffffffff)\nargument length ok\n```", "```\n01    #include <stdio.h>\n02\n03    int\n04    main (void)\n05    {\n06        int  i = 16;\n07\n08        printf (\"%d\\n\", i);\n09        printf (\"%x\\n\", i);\n10\n11        return 0;\n12    }\n```", "```\nlinux$ `gcc -g -o got got.c`\n\nlinux$ `gdb -q ./got`\n\n(gdb) `set disassembly-flavor intel`\n\n(gdb) `disassemble main`\nDump of assembler code for function main:\n0x080483c4 <main+0>:    push   ebp\n0x080483c5 <main+1>:    mov    ebp,esp\n0x080483c7 <main+3>:    and    esp,0xfffffff0\n0x080483ca <main+6>:    sub    esp,0x20\n0x080483cd <main+9>:    mov    DWORD PTR [esp+0x1c],0x10\n0x080483d5 <main+17>:   mov    eax,0x80484d0\n0x080483da <main+22>:   mov    edx,DWORD PTR [esp+0x1c]\n0x080483de <main+26>:   mov    DWORD PTR [esp+0x4],edx\n0x080483e2 <main+30>:   mov    DWORD PTR [esp],eax\n`0x080483e5 <main+33>:   call   0x80482fc <printf@plt>`\n0x080483ea <main+38>:   mov    eax,0x80484d4\n0x080483ef <main+43>:   mov    edx,DWORD PTR [esp+0x1c]\n0x080483f3 <main+47>:   mov    DWORD PTR [esp+0x4],edx\n0x080483f7 <main+51>:   mov    DWORD PTR [esp],eax\n`0x080483fa <main+54>:   call   0x80482fc <printf@plt>`\n0x080483ff <main+59>:   mov    eax,0x0\n0x08048404 <main+64>:   leave\n0x08048405 <main+65>:   ret\nEnd of assembler dump.\n```", "```\n(gdb) `x/1i 0x80482fc`\n0x80482fc <printf@plt>: jmp    DWORD PTR ds:`0x80495d8`\n```", "```\n(gdb) `x/1x 0x80495d8`\n0x80495d8 <_GLOBAL_OFFSET_TABLE_+20>:   `0x08048302`\n```", "```\n(gdb) `x/2i 0x08048302`\n0x8048302 <printf@plt+6>:       push   0x10\n0x8048307 <printf@plt+11>:      jmp    0x80482cc\n```", "```\n(gdb) `list 0`\n1    #include <stdio.h>\n2\n3    int\n4    main (void)\n5    {\n6        int    i    = 16;\n7\n8        printf (\"%d\\n\", i);\n`9        printf (\"%x\\n\", i);`\n10\n\n(gdb) `break 9`\nBreakpoint 1 at 0x80483ea: file got.c, line 9.\n```", "```\n(gdb) `run`\nStarting program: /home/tk/BHD/got\n16\n\nBreakpoint 1, main () at got.c:9\n9        printf (\"%x\\n\", i);\n```", "```\n(gdb) `disassemble main`\nDump of assembler code for function main:\n0x080483c4 <main+0>:    push   ebp\n0x080483c5 <main+1>:    mov    ebp,esp\n0x080483c7 <main+3>:    and    esp,0xfffffff0\n0x080483ca <main+6>:    sub    esp,0x20\n0x080483cd <main+9>:    mov    DWORD PTR [esp+0x1c],0x10\n0x080483d5 <main+17>:   mov    eax,0x80484d0\n0x080483da <main+22>:   mov    edx,DWORD PTR [esp+0x1c]\n0x080483de <main+26>:   mov    DWORD PTR [esp+0x4],edx\n0x080483e2 <main+30>:   mov    DWORD PTR [esp],eax\n`0x080483e5 <main+33>:   call   0x80482fc <printf@plt>`\n0x080483ea <main+38>:   mov    eax,0x80484d4\n0x080483ef <main+43>:   mov    edx,DWORD PTR [esp+0x1c]\n0x080483f3 <main+47>:   mov    DWORD PTR [esp+0x4],edx\n0x080483f7 <main+51>:   mov    DWORD PTR [esp],eax\n`0x080483fa <main+54>:   call   0x80482fc <printf@plt>`\n0x080483ff <main+59>:   mov    eax,0x0\n0x08048404 <main+64>:   leave\n0x08048405 <main+65>:   ret\nEnd of assembler dump.\n```", "```\n(gdb) `x/1i 0x80482fc`\n0x80482fc <printf@plt>: jmp    DWORD PTR ds:`0x80495d8`\n```", "```\n(gdb) `x/1x 0x80495d8`\n0x80495d8 <_GLOBAL_OFFSET_TABLE_+20>:   `0xb7ed21c0`\n```", "```\n(gdb) `x/10i 0xb7ed21c0`\n0xb7ed21c0 <printf>:    push   ebp\n0xb7ed21c1 <printf+1>:  mov    ebp,esp\n0xb7ed21c3 <printf+3>:  push   ebx\n0xb7ed21c4 <printf+4>:  call   0xb7ea1aaf\n0xb7ed21c9 <printf+9>:  add    ebx,0xfae2b\n0xb7ed21cf <printf+15>: sub    esp,0xc\n0xb7ed21d2 <printf+18>: lea    eax,[ebp+0xc]\n0xb7ed21d5 <printf+21>: mov    DWORD PTR [esp+0x8],eax\n0xb7ed21d9 <printf+25>: mov    eax,DWORD PTR [ebp+0x8]\n0xb7ed21dc <printf+28>: mov    DWORD PTR [esp+0x4],eax\n```", "```\n(gdb) `set variable *(0x80495d8)=0x41414141`\n\n(gdb) `x/1x 0x80495d8`\n0x80495d8 <_GLOBAL_OFFSET_TABLE_+20>:   `0x41414141`\n\n(gdb) `continue`\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n`0x41414141 in ?? ()`\n\n(gdb) `info registers eip`\neip            `0x41414141`    0x41414141\n```", "```\nlinux$ `objdump -R got`\n\ngot:     file format elf32-i386\n\nDYNAMIC RELOCATION RECORDS\nOFFSET   TYPE              VALUE\n080495c0 R_386_GLOB_DAT    __gmon_start__\n080495d0 R_386_JUMP_SLOT   __gmon_start__\n080495d4 R_386_JUMP_SLOT   __libc_start_main\n`080495d8 R_386_JUMP_SLOT   printf`\n\nlinux$ `readelf -r got`\n\nRelocation section '.rel.dyn' at offset 0x27c contains 1 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n080495c0  00000106 R_386_GLOB_DAT    00000000   __gmon_start__\n\nRelocation section '.rel.plt' at offset 0x284 contains 3 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n080495d0  00000107 R_386_JUMP_SLOT   00000000   __gmon_start__\n080495d4  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main\n`080495d8  00000307 R_386_JUMP_SLOT   00000000   printf`\n```"]