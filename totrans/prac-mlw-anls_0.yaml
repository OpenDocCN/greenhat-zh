- en: Sleep for 1 hour
  prefs: []
  type: TYPE_NORMAL
- en: superlongsleep
  prefs: []
  type: TYPE_NORMAL
- en: c3VwZXJsb25nc2xlZXA=
  prefs: []
  type: TYPE_NORMAL
- en: Sleep for 24 hours
  prefs: []
  type: TYPE_NORMAL
- en: shortsleep
  prefs: []
  type: TYPE_NORMAL
- en: c2hvcnRzbGVlcA==
  prefs: []
  type: TYPE_NORMAL
- en: Sleep for 1 minute
  prefs: []
  type: TYPE_NORMAL
- en: run:www.example.com/fast.exe
  prefs: []
  type: TYPE_NORMAL
- en: cnVuOnd3dy5leGFtcGxlLmNvbS9mYXN0LmV4ZQ==
  prefs: []
  type: TYPE_NORMAL
- en: Download and execute a binary
  prefs: []
  type: TYPE_NORMAL
- en: on the local system
  prefs: []
  type: TYPE_NORMAL
- en: connect:www.example.com:80
  prefs: []
  type: TYPE_NORMAL
- en: Y29ubmVjdDp3d3cuZXhhbXBsZS5jb206ODA=
  prefs: []
  type: TYPE_NORMAL
- en: Use a custom protocol to establish
  prefs: []
  type: TYPE_NORMAL
- en: a reverse shell
  prefs: []
  type: TYPE_NORMAL
- en: Malware-Focused Network Signatures
  prefs: []
  type: TYPE_NORMAL
- en: '**319**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to creating signatures for this backdoor is to target the full
    set of commands known to be used by the malware (including the surrounding context).
    Content expressions for the five commands recognized by the malware would contain
    the following strings:'
  prefs: []
  type: TYPE_NORMAL
- en: <!-- adsrv?bG9uZ3NsZWVw -->
  prefs: []
  type: TYPE_NORMAL
- en: <!-- adsrv?c3VwZXJsb25nc2xlZXA= -->
  prefs: []
  type: TYPE_NORMAL
- en: <!-- adsrv?c2hvcnRzbGVlcA== -->
  prefs: []
  type: TYPE_NORMAL
- en: <!-- adsrv?cnVu
  prefs: []
  type: TYPE_NORMAL
- en: <!-- adsrv?Y29ubmVj
  prefs: []
  type: TYPE_NORMAL
- en: The last two expressions target only the static part of the commands (run and
    connect), and since the length of the argument is not known, they do not target
    the trailing comment characters (-->).
  prefs: []
  type: TYPE_NORMAL
- en: While signatures that use all of these elements will likely find this precise
    piece of malware, there is a risk of being too specific at the expense of robust-ness.
    If the attacker changes any part of the malware—the command set, the encoding,
    or the command prefix—a very precise signature will cease to be effective.
  prefs: []
  type: TYPE_NORMAL
- en: '***Targeting Multiple Elements***'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we saw that different parts of the command interpretation were in
    different parts of the code. Given that knowledge, we can create different signatures
    to target the various elements separately.
  prefs: []
  type: TYPE_NORMAL
- en: The three elements that appear to be in distinct functions are comment bracketing,
    the fixed adsrv? with a Base64 expression following, and the actual command parsing.
    Based on these three elements, a set of signature elements could include the following
    (for brevity, only the primary elements of each signature are included, with each
    line representing a different signature).
  prefs: []
  type: TYPE_NORMAL
- en: pcre:"/<!-- adsrv\?([a-zA-Z0-9+\/=]{4})+ -->/"
  prefs: []
  type: TYPE_NORMAL
- en: 'content:"<!-- "; content:"bG9uZ3NsZWVw -->"; within:100; content:"<!-- "; content:"c3VwZXJsb25nc2xlZXA=
    -->"; within:100; content:"<!-- "; content:"c2hvcnRzbGVlcA== -->"; within:100;
    content:"<!-- "; content:"cnVu";within:100;content: "-->"; within:100; content:"<!--
    "; content:"Y29ubmVj"; within:100; content:"-->"; within:100; These signatures
    target the three different elements that make up a command being sent to the malware.
    All include the comment bracketing.'
  prefs: []
  type: TYPE_NORMAL
- en: The first signature targets the command prefix adsrv? followed by a generic
    Base64-encoded command. The rest of the signatures target a known Base64-encoded
    command without any dependency on a command prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know the parsing occurs in a separate section of the code, it makes
    sense to target it independently. If the attacker changes one part of the code
    or the other, our signatures will still detect the unchanged part.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are still making assumptions. The new signatures may be more prone
    to false positives. We are also assuming that the attacker will most likely continue
    to use comment bracketing, since comment bracketing is a part of regular web communications
    and is unlikely to be considered **320**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: suspicious. Nevertheless, this strategy provides more robust coverage than our
    initial attempt and is more likely to detect future variants of the malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the signature we created earlier for beacon traffic. Recall that
    we combined every possible element into the same signature: alert tcp $HOME_NET
    any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon "; content:"User-Agent:
    Mozilla/4.0 (compatible\; MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *";
    uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10
    [012]){8} HTTP/"; classtype:trojan-activity; sid:2000002; rev:1;)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This signature has a limited scope and would become useless if the attacker
    made any changes to the malware. A way to address different elements individually
    and avoid rapid obsolescence is with these two targets:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: 'Target 1: User-Agent string, Accept string, no referrer'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: 'Target 2: Specific URI, no referrer'
  prefs: []
  type: TYPE_NORMAL
- en: 'This strategy would yield two signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious
    Beacon UA with Accept Anomaly"; content:"User-Agent: Mozilla/4.0 (compatible\;
    MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *"; content:!"|0d0a|referer:";
    nocase; classtype:trojan-activity; sid:2000004; rev:1;)'
  prefs: []
  type: TYPE_NORMAL
- en: 'alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious
    Beacon URI"; uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:'
  prefs: []
  type: TYPE_NORMAL
- en: '"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10[012]){8}
    HTTP/"; classtype:trojan-activity; sid:2000005; rev:1;)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the Attacker’s Perspective**'
  prefs: []
  type: TYPE_NORMAL
- en: When designing a signature strategy, it’s wise to try to understand the attacker’s
    perspective. Attackers are playing a constant game of cat-and-mouse. Their intent
    is to blend in with regular traffic to avoid detection and maintain successful
    ongoing operations. Like any software developers, attackers struggle to update
    software, to remain current and compatible with changing systems. Any changes
    that are necessary should be minimal, as large changes can threaten the integrity
    of their systems.
  prefs: []
  type: TYPE_NORMAL
- en: As previously discussed, using multiple signatures that target different parts
    of the malicious code makes detection more resilient to attacker modifications.
    Often, attackers will change their software slightly to avoid detection by a specific
    signature. By creating multiple signatures that key off of different aspects of
    the communication, you can still successfully detect the malware, even if the
    attacker has updated a portion of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are three additional rules of thumb that you can use to take advantage
    of attacker weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on elements of the protocol that are part of both end points.**'
  prefs: []
  type: TYPE_NORMAL
- en: Changing either the client code or the server code alone is much easier than
    changing both. Look for elements of the protocol that use code at Malware-Focused
    Network Signatures
  prefs: []
  type: TYPE_NORMAL
- en: '**321**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: both the client and server side, and create a signature based on these elements.
    The attacker will need to do a lot of extra work to render such a signature obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on any elements of the protocol known to be part of a key.**'
  prefs: []
  type: TYPE_NORMAL
- en: Often, some hard-coded components of a protocol are used as a key. For example,
    an attacker may use a specific User-Agent string as an authentication key so that
    illegitimate probing can be detected (and possibly rerouted). In order for an
    attacker to bypass such a signature, he would need to change code at both end
    points.
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify elements of the protocol that are not immediately apparent in traffic.**'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the simultaneous actions of multiple defenders can impede the detection
    of malware. If another defender creates a signature that achieves sufficient success
    against an attacker, the attacker may be com-pelled to adjust his malware to avoid
    the signature. If you are relying on the same signature, or a signature that targets
    the same aspects of the attacker’s communication protocol, the attacker’s adjustment
    will affect your signature as well. In order to avoid being rendered obsolete
    by the attacker’s response to another defender, try to identify aspects of malicious
    operations that other defenders might not have focused on. Knowledge gained from
    carefully observing the malware will help you develop a more robust signature.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve described the way in which malware uses the network for
    command and control. We’ve also covered some of the techniques malware uses to
    disguise its activity to look like regular network traffic. Malware analysis can
    improve the effectiveness of network defense by providing insights into the signature-generation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve described several advantages to basing network signatures on a deeper
    malware analysis, rather than a surface analysis of existing traffic captures
    or a sandbox-based analysis. Signatures based on malware analysis can be more
    precise, reducing the trial and error needed to produce low false-positive signatures.
    Additionally, they have a higher likelihood of identifying new strains of the
    same malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has addressed what is often the endgame of basic malware analysis:
    development of an effective countermeasure to protect from future malware. However,
    this chapter assumes that it is possible to achieve a good understanding of the
    malware through dynamic and static analyses. In some cases, malware authors take
    active measures to prevent effective analysis. The next set of chapters explain
    the techniques malware authors use to stymie analysis and what steps you can take
    to ensure that you can fully decompose and understand the malware in question.'
  prefs: []
  type: TYPE_NORMAL
- en: '**322**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s labs focus on identifying the networking components of malware.
    To some degree, these labs build on Chapter 13, since when developing network
    signatures, you’ll often need to deal with encoded content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 14-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in file *Lab14-01.exe*. This program is not harmful
    to your system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Which networking libraries does the malware use, and what are their advantages?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What source elements are used to construct the networking beacon, and what conditions
    would cause the beacon to change?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Why might the information embedded in the networking beacon be of interest to
    the attacker?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Does the malware use standard Base64 encoding? If not, how is the encoding unusual?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the overall purpose of this malware?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: What elements of the malware’s communication may be effectively detected using
    a network signature?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: What mistakes might analysts make in trying to develop a signature for this
    malware?
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: What set of signatures would detect this malware (and future variants)?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 14-2**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in file *Lab14-02.exe*. This malware has been configured
    to beacon to a hard-coded loopback address in order to prevent it from harming
    your system, but imagine that it is a hard-coded external address.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages or disadvantages of coding malware to use direct IP
    addresses?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Which networking libraries does this malware use? What are the advantages or
    disadvantages of using these libraries?
  prefs: []
  type: TYPE_NORMAL
- en: Malware-Focused Network Signatures
  prefs: []
  type: TYPE_NORMAL
- en: '**323**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the source of the URL that the malware uses for beaconing?
  prefs: []
  type: TYPE_NORMAL
- en: What advantages does this source offer?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Which aspect of the HTTP protocol does the malware leverage to achieve its objectives?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What kind of information is communicated in the malware’s initial beacon?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: What are some disadvantages in the design of this malware’s communication channels?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: Is the malware’s encoding scheme standard?
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: How is communication terminated?
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of this malware, and what role might it play in the attacker’s
    arsenal?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 14-3**'
  prefs: []
  type: TYPE_NORMAL
- en: This lab builds on Lab 14-1\. Imagine that this malware is an attempt by the
    attacker to improve his techniques. Analyze the malware found in file *Lab14-03.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What hard-coded elements are used in the initial beacon? What elements, if any,
    would make a good signature?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What elements of the initial beacon may not be conducive to a long-lasting signature?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: How does the malware obtain commands? What example from the chapter used a similar
    methodology? What are the advantages of this technique?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: When the malware receives input, what checks are performed on the input to determine
    whether it is a valid command? How does the attacker hide the list of commands
    the malware is searching for?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What type of encoding is used for command arguments? How is it different from
    Base64, and what advantages or disadvantages does it offer?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: What commands are available to this malware?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of this malware?
  prefs: []
  type: TYPE_NORMAL
- en: 8\.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced the idea of targeting different areas of code with independent
    signatures (where possible) in order to add resiliency to network indicators.
    What are some distinct areas of code or configuration data that can be targeted
    by network signatures?
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: What set of signatures should be used for this malware?
  prefs: []
  type: TYPE_NORMAL
- en: '**324**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A N T I - R E V E R S E - E N G I N E E R I N G**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**A N T I - D I S A S S E M B L Y**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anti-disassembly* uses specially crafted code or data in a program to cause
    disassembly analysis tools to produce'
  prefs: []
  type: TYPE_NORMAL
- en: an incorrect program listing. This technique is crafted
  prefs: []
  type: TYPE_NORMAL
- en: by malware authors manually, with a separate tool in
  prefs: []
  type: TYPE_NORMAL
- en: the build and deployment process or interwoven into
  prefs: []
  type: TYPE_NORMAL
- en: their malware’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'All malware is designed with a particular goal in mind: keystroke logging,
    backdoor access, using a target system to send excessive email to cripple servers,
    and so on. Malware authors often go beyond this basic functionality to implement
    specific techniques to hide from the user or system administrator, using rootkits
    or process injection, or to otherwise thwart analysis and detection.'
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors use anti-disassembly techniques to delay or prevent analysis
    of malicious code. Any code that executes successfully can be reverse-engineered,
    but by armoring their code with anti-disassembly and anti-debugging techniques,
    malware authors increase the level of skill required of the malware analyst. The
    time-sensitive investigative process is hindered by
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: the malware analyst’s inability to understand the malware’s capabilities, derive
    valuable host and network signatures, and develop decoding algorithms. These additional
    layers of protection may exhaust the in-house skill level at many organizations
    and require expert consultants or large research project levels of effort to reverse-engineer.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to delaying or preventing human analysis, anti-disassembly is also
    effective at preventing certain automated analysis techniques. Many malware similarity
    detection algorithms and antivirus heuristic engines employ disassembly analysis
    to identify or classify malware. Any manual or automated process that uses individual
    program instructions will be susceptible to the anti-analysis techniques described
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding Anti-Disassembly**'
  prefs: []
  type: TYPE_NORMAL
- en: Disassembly is not a simple problem. Sequences of executable code can have multiple
    disassembly representations, some that may be invalid and obscure the real functionality
    of the program. When implementing anti-disassembly, the malware author creates
    a sequence that tricks the disassembler into showing a list of instructions that
    differ from those that will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anti-disassembly techniques work by taking advantage of the assumptions and
    limitations of disassemblers. For example, disassemblers can only represent each
    byte of a program as part of one instruction at a time. If the disassembler is
    tricked into disassembling at the wrong offset, a valid instruction could be hidden
    from view. For example, examine the following fragment of disassembled code:'
  prefs: []
  type: TYPE_NORMAL
- en: jmp short near ptr loc_2+1
  prefs: []
  type: TYPE_NORMAL
- en: ; ---------------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_2: ; CODE XREF: seg000:00000000j call near ptr 15FF2A71h '
  prefs: []
  type: TYPE_NORMAL
- en: or [ecx], dl
  prefs: []
  type: TYPE_NORMAL
- en: inc eax
  prefs: []
  type: TYPE_NORMAL
- en: ; ---------------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: db 0
  prefs: []
  type: TYPE_NORMAL
- en: This fragment of code was disassembled using the linear-disassembly technique,
    and the result is inaccurate. Reading this code, we miss the piece of information
    that its author is trying to hide. We see what appears to be a call instruction,
    but the target of the call is nonsensical . The first instruction is a jmp instruction
    whose target is invalid because it falls in the middle of the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**328**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now examine the same sequence of bytes disassembled with a different strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: jmp short loc_3
  prefs: []
  type: TYPE_NORMAL
- en: ; ---------------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: db 0E8h
  prefs: []
  type: TYPE_NORMAL
- en: ; ---------------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_3: ; CODE XREF: seg000:00000000j push 2Ah'
  prefs: []
  type: TYPE_NORMAL
- en: call Sleep 
  prefs: []
  type: TYPE_NORMAL
- en: This fragment reveals a different sequence of assembly mnemonics, and it appears
    to be more informative. Here, we see a call to the API function Sleep at . The
    target of the first jmp instruction is now properly represented, and we can see
    that it jumps to a push instruction followed by the call to Sleep.
  prefs: []
  type: TYPE_NORMAL
- en: The byte on the third line of this example is 0xE8, but this byte is not executed
    by the program because the jmp instruction skips over it.
  prefs: []
  type: TYPE_NORMAL
- en: This fragment was disassembled with a flow-oriented disassembler, rather than
    the linear disassembler used previously. In this case, the flow-oriented disassembler
    was more accurate because its logic more closely mirrored the real program and
    did not attempt to disassemble any bytes that were not part of execution flow.
    We’ll discuss linear and flow-oriented disassembly in more detail in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: So, disassembly is not as simple as you may have thought. The disassembly examples
    show two completely different sets of instructions for the same set of bytes.
    This demonstrates how anti-disassembly can cause the disassembler to produce an
    inaccurate set of instructions for a given range of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Some anti-disassembly techniques are generic enough to work on most disassemblers,
    while some target specific products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defeating Disassembly Algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: Anti-disassembly techniques are born out of inherent weaknesses in disassembler
    algorithms. Any disassembler must make certain assumptions in order to present
    the code it is disassembling clearly. When these assumptions fail, the malware
    author has an opportunity to fool the malware analyst.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of disassembler algorithms: linear and flow-oriented.'
  prefs: []
  type: TYPE_NORMAL
- en: Linear disassembly is easier to implement, but it’s also more error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linear Disassembly***'
  prefs: []
  type: TYPE_NORMAL
- en: The *linear-disassembly* strategy iterates over a block of code, disassembling
    one instruction at a time linearly, without deviating. This basic strategy is
    employed by disassembler writing tutorials and is widely used by debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**329**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Linear disassembly uses the size of the disassembled instruction to determine
    which byte to disassemble next, without regard for flow-control instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code fragment shows the use of the disassembly library libdisasm
    ( *http://sf.net/projects/bastard/files/libdisasm/*) to implement a crude disassembler
    in a handful of lines of C using linear disassembly: char buffer[BUF_SIZE];'
  prefs: []
  type: TYPE_NORMAL
- en: int position = 0;
  prefs: []
  type: TYPE_NORMAL
- en: while (position < BUF_SIZE) {
  prefs: []
  type: TYPE_NORMAL
- en: x86_insn_t insn;
  prefs: []
  type: TYPE_NORMAL
- en: int size = x86_disasm(buf, BUF_SIZE, 0, position, &insn); if (size != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: char disassembly_line[1024];
  prefs: []
  type: TYPE_NORMAL
- en: x86_format_insn(&insn, disassembly_line, 1024, intel_syntax); printf("%s\n",
    disassembly_line);
  prefs: []
  type: TYPE_NORMAL
- en: position += size;
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: /* invalid/unrecognized instruction */
  prefs: []
  type: TYPE_NORMAL
- en: position++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: x86_cleanup();
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a buffer of data named buffer contains instructions to be disassembled.
    The function x86_disasm will populate a data structure with the specifics of the
    instruction it just disassembled and return the size of the instruction. The loop
    increments the position variable by the size value  if a valid instruction was
    disassembled; otherwise, it increments by one .
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm will disassemble most code without a problem, but it will introduce
    occasional errors even in nonmalicious binaries. The main drawback to this method
    is that it will disassemble too much code. The algorithm will keep blindly disassembling
    until the end of the buffer, even if flow-control instructions will cause only
    a small portion of the buffer to execute.
  prefs: []
  type: TYPE_NORMAL
- en: In a PE-formatted executable file, the executable code is typically contained
    in a single section. It is reasonable to assume that you could get away with just
    applying this linear-disassembly algorithm to the .text section containing the
    code, but the problem is that the code section of nearly all binaries will also
    contain data that isn’t instructions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common types of data items found in a code section is a pointer
    value, which is used in a table-driven switch idiom. The following disassembly
    fragment (from a nonlinear disassembler) shows a function that contains switch
    pointers immediately following the function code.
  prefs: []
  type: TYPE_NORMAL
- en: '**330**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: jmp ds:off_401050[eax*4] ; switch jump
  prefs: []
  type: TYPE_NORMAL
- en: ; switch cases omitted ...
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: pop esi
  prefs: []
  type: TYPE_NORMAL
- en: retn
  prefs: []
  type: TYPE_NORMAL
- en: ; ---------------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 'off_401050 dd offset loc_401020 ; DATA XREF: _main+19r dd offset loc_401027
    ; jump table for switch statement dd offset loc_40102E'
  prefs: []
  type: TYPE_NORMAL
- en: dd offset loc_401035
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction in this function is retn. In memory, the bytes immediately
    following the retn instruction are the pointer values beginning with 401020 at
    , which in memory will appear as the byte sequence 20 10 40 00
  prefs: []
  type: TYPE_NORMAL
- en: 'in hex. These four pointer values shown in the code fragment make up 16 bytes
    of data inside the .text section of this binary. They also happen to disassemble
    to valid instructions. The following disassembly fragment would be produced by
    a linear-disassembly algorithm when it continues disassembling instructions beyond
    the end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: and [eax],dl
  prefs: []
  type: TYPE_NORMAL
- en: inc eax
  prefs: []
  type: TYPE_NORMAL
- en: add [edi],ah
  prefs: []
  type: TYPE_NORMAL
- en: adc [eax+0x0],al
  prefs: []
  type: TYPE_NORMAL
- en: adc cs:[eax+0x0],al
  prefs: []
  type: TYPE_NORMAL
- en: xor eax,0x4010
  prefs: []
  type: TYPE_NORMAL
- en: Many of instructions in this fragment consist of multiple bytes. The key way
    that malware authors exploit linear-disassembly algorithms lies in plant-ing data
    bytes that form the opcodes of multibyte instructions. For example, the standard
    local call instruction is 5 bytes, beginning with the opcode 0xE8\.
  prefs: []
  type: TYPE_NORMAL
- en: If the 16 bytes of data that compose the switch table end with the value 0xE8,
    the disassembler would encounter the call instruction opcode and treat the next
    4 bytes as an operand to that instruction, instead of the beginning of the next
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Linear-disassembly algorithms are the easiest to defeat because they are unable
    to distinguish between code and data.
  prefs: []
  type: TYPE_NORMAL
- en: '***Flow-Oriented Disassembly***'
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced category of disassembly algorithms is the *flow-oriented disassembler*.
    This is the method used by most commercial disassemblers such as IDA Pro.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between flow-oriented and linear disassembly is that the
    disassembler doesn’t blindly iterate over a buffer, assuming the data is Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**331**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: nothing but instructions packed neatly together. Instead, it examines each instruction
    and builds a list of locations to disassemble.
  prefs: []
  type: TYPE_NORMAL
- en: The following fragment shows code that can be disassembled correctly only with
    a flow-oriented disassembler.
  prefs: []
  type: TYPE_NORMAL
- en: test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: jz short loc_1A
  prefs: []
  type: TYPE_NORMAL
- en: push Failed_string
  prefs: []
  type: TYPE_NORMAL
- en: call printf
  prefs: []
  type: TYPE_NORMAL
- en: jmp short loc_1D
  prefs: []
  type: TYPE_NORMAL
- en: ; ---------------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 'Failed_string: db ''Failed'',0'
  prefs: []
  type: TYPE_NORMAL
- en: ; ---------------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_1A: '
  prefs: []
  type: TYPE_NORMAL
- en: xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_1D:'
  prefs: []
  type: TYPE_NORMAL
- en: retn
  prefs: []
  type: TYPE_NORMAL
- en: This example begins with a test and a conditional jump. When the flow-oriented
    disassembler reaches the conditional branch instruction jz at , it notes that
    at some point in the future it needs to disassemble the location loc_1A at .
    Because this is only a conditional branch, the instruction at 
  prefs: []
  type: TYPE_NORMAL
- en: is also a possibility in execution, so the disassembler will disassemble this
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at  and  are responsible for printing the string Failed to the screen.
    Following this is a jmp instruction at . The flow-oriented disassembler will
    add the target of this, loc_1D, to the list of places to disassemble in the future.
    Since jmp is unconditional, the disassembler will not automatically disassemble
    the instruction immediately following in memory. Instead, it will step back and
    check the list of places it noted previously, such as loc_1A, and disassemble
    starting from that point.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, when a linear disassembler encounters the jmp instruction, it will
    continue blindly disassembling instructions sequentially in memory, regardless
    of the logical flow of the code. In this case, the Failed string would be disassembled
    as code, inadvertently hiding the ASCII string and the last two instructions in
    the example fragment. For example, the following fragment shows the same code
    disassembled with a linear-disassembly algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: jz short near ptr loc_15+5
  prefs: []
  type: TYPE_NORMAL
- en: push Failed_string
  prefs: []
  type: TYPE_NORMAL
- en: call printf
  prefs: []
  type: TYPE_NORMAL
- en: jmp short loc_15+9
  prefs: []
  type: TYPE_NORMAL
- en: 'Failed_string:'
  prefs: []
  type: TYPE_NORMAL
- en: inc esi
  prefs: []
  type: TYPE_NORMAL
- en: popa
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_15:'
  prefs: []
  type: TYPE_NORMAL
- en: imul ebp, [ebp+64h], 0C3C03100h
  prefs: []
  type: TYPE_NORMAL
- en: '**332**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: In linear disassembly, the disassembler has no choice to make about which instructions
    to disassemble at a given time. Flow-oriented disassemblers make choices and assumptions.
    Though assumptions and choices might seem unnecessary, simple machine code instructions
    are complicated by the addition of problematic code aspects such as pointers,
    exceptions, and conditional branching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional branches give the flow-oriented disassembler a choice of two places
    to disassemble: the true or the false branch. In typical compiler-generated code,
    there would be no difference in output if the disassembler processes the true
    or false branch first. In handwritten assembly code and anti-disassembly code,
    however, the two branches can often produce different disassembly for the same
    block of code. When there is a conflict, most disassemblers trust their initial
    interpretation of a given location first. Most flow-oriented disassemblers will
    process (and thus trust) the false branch of any conditional jump first.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-1 shows a sequence of bytes and their corresponding machine instructions.
    Notice the string hello in the middle of the instructions. When the program executes,
    this string is skipped by the call instruction, and its 6
  prefs: []
  type: TYPE_NORMAL
- en: bytes and NULL terminator are never executed as instructions.
  prefs: []
  type: TYPE_NORMAL
- en: CALL
  prefs: []
  type: TYPE_NORMAL
- en: h e l l o
  prefs: []
  type: TYPE_NORMAL
- en: POP RET
  prefs: []
  type: TYPE_NORMAL
- en: E8
  prefs: []
  type: TYPE_NORMAL
- en: '06'
  prefs: []
  type: TYPE_NORMAL
- en: '00'
  prefs: []
  type: TYPE_NORMAL
- en: '00'
  prefs: []
  type: TYPE_NORMAL
- en: '00'
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  prefs: []
  type: TYPE_NORMAL
- en: 6c
  prefs: []
  type: TYPE_NORMAL
- en: 6c
  prefs: []
  type: TYPE_NORMAL
- en: 6F
  prefs: []
  type: TYPE_NORMAL
- en: '00'
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: C3
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-1: call instruction followed by a string*'
  prefs: []
  type: TYPE_NORMAL
- en: The call instruction is another place where the disassembler must make a decision.
    The location being called is added to the future disassembly list, along with
    the location immediately after the call. Just as with the conditional jump instructions,
    most disassemblers will disassemble the bytes after the call instruction first
    and the called location later. In handwritten assembly, programmers will often
    use the call instruction to get a pointer to a fixed piece of data instead of
    actually calling a subroutine. In this example, the call instruction is used to
    create a pointer for the string hello on the stack. The pop instruction following
    the call then takes this value off the top of the stack and puts it into a register
    (EAX in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we disassemble this binary with IDA Pro, we see that it has produced disassembly
    that is not what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: E8 06 00 00 00 call near ptr loc_4011CA+1
  prefs: []
  type: TYPE_NORMAL
- en: 68 65 6C 6C 6F
  prefs: []
  type: TYPE_NORMAL
- en: push 6F6C6C65h
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_4011CA:'
  prefs: []
  type: TYPE_NORMAL
- en: 00 58 C3 add [eax-3Dh], bl
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, the first letter of the string hello is the letter *h*, which
    is 0x68 in hexadecimal. This is also the opcode of the 5-byte instruction  push
    DWORD. The null terminator for the hello string turned out to also be the first
    Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**333**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: byte of another legitimate instruction. The flow-oriented disassembler in IDA
    Pro decided to process the thread of disassembly at  (immediately following the
    call instruction) before processing the target of the call instruction, and thus
    produced these two erroneous instructions. Had it processed the target first,
    it still would have produced the first push instruction, but the instruction following
    the push would have conflicted with the real instructions it disassembled as a
    result of the call target.
  prefs: []
  type: TYPE_NORMAL
- en: 'If IDA Pro produces inaccurate results, you can manually switch bytes from
    data to instructions or instructions to data by using the C or D keys on the keyboard,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the C key turns the cursor location into code.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the D key turns the cursor location into data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same function after manual cleanup:'
  prefs: []
  type: TYPE_NORMAL
- en: E8 06 00 00 00 call loc_4011CB
  prefs: []
  type: TYPE_NORMAL
- en: 68 65 6C 6C 6F 00 aHello db 'hello',0
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_4011CB:'
  prefs: []
  type: TYPE_NORMAL
- en: 58 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: C3 retn
  prefs: []
  type: TYPE_NORMAL
- en: '**Anti-Disassembly Techniques**'
  prefs: []
  type: TYPE_NORMAL
- en: The primary way that malware can force a disassembler to produce inaccurate
    disassembly is by taking advantage of the disassembler’s choices and assumptions.
    The techniques we will examine in this chapter exploit the most basic assumptions
    of the disassembler and are typically easily fixed by a malware analyst. More
    advanced techniques involve taking advantage of information that the disassembler
    typically doesn’t have access to, as well as generating code that is impossible
    to disassemble completely with conventional assembly listings.
  prefs: []
  type: TYPE_NORMAL
- en: '***Jump Instructions with the Same Target***'
  prefs: []
  type: TYPE_NORMAL
- en: The most common anti-disassembly technique seen in the wild is two back-to-back
    conditional jump instructions that both point to the same target. For example,
    if a jz loc_512 is followed by jnz loc_512, the location loc_512 will always be
    jumped to. The combination of jz with jnz is, in effect, an unconditional jmp,
    but the disassembler doesn’t recognize it as such because it only disassembles
    one instruction at a time. When the disassembler encounters the jnz, it continues
    disassembling the false branch of this instruction, despite the fact that it will
    never be executed in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '**334**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows IDA Pro’s first interpretation of a piece of code
    protected with this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: 74 03 jz short near ptr loc_4011C4+1
  prefs: []
  type: TYPE_NORMAL
- en: 75 01 jnz short near ptr loc_4011C4+1
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_4011C4: ; CODE XREF: sub_4011C0'
  prefs: []
  type: TYPE_NORMAL
- en: ; sub_4011C0+2j
  prefs: []
  type: TYPE_NORMAL
- en: E8 58 C3 90 90 call near ptr 90D0D521h
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the instruction immediately following the two conditional jump
    instructions appears to be a call instruction at , beginning with the byte 0xE8\.
    This is not the case, however, as both conditional jump instructions actually
    point 1 byte beyond the 0xE8 byte. When this fragment is viewed with IDA Pro,
    the code cross-references shown at  loc_4011C4 will appear in red, rather than
    the standard blue, because the actual references point inside the instruction
    at this location, instead of the beginning of the instruction. As a malware analyst,
    this is your first indication that anti-disassembly may be employed in the sample
    you are analyzing.
  prefs: []
  type: TYPE_NORMAL
- en: The following is disassembly of the same code, but this time fixed with the
    D key, to turn the byte immediately following the jnz instruction into data, and
    the C key to turn the bytes at loc_4011C5 into instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 74 03 jz short near ptr loc_4011C5
  prefs: []
  type: TYPE_NORMAL
- en: 75 01 jnz short near ptr loc_4011C5
  prefs: []
  type: TYPE_NORMAL
- en: ; -------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: E8 db 0E8h
  prefs: []
  type: TYPE_NORMAL
- en: ; -------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_4011C5: ; CODE XREF: sub_4011C0'
  prefs: []
  type: TYPE_NORMAL
- en: ; sub_4011C0+2j
  prefs: []
  type: TYPE_NORMAL
- en: 58 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: C3 retn
  prefs: []
  type: TYPE_NORMAL
- en: The column on the left in these examples shows the bytes that constitute the
    instruction. Display of this field is optional, but it’s important when learning
    anti-disassembly. To display these bytes (or turn them off), select **Options****General**.
    The Number of Opcode Bytes option allows you to enter a number for how many bytes
    you would like to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-2 shows the sequence of bytes in this example graphically.
  prefs: []
  type: TYPE_NORMAL
- en: JZ
  prefs: []
  type: TYPE_NORMAL
- en: JNZ
  prefs: []
  type: TYPE_NORMAL
- en: POP RET
  prefs: []
  type: TYPE_NORMAL
- en: 74 03 75 01 E8
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: C3
  prefs: []
  type: TYPE_NORMAL
- en: CALL
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-2: A jz instruction followed by a jnz instruction* Anti-Disassembly'
  prefs: []
  type: TYPE_NORMAL
- en: '**335**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***A Jump Instruction with a Constant Condition***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another anti-disassembly technique commonly found in the wild is composed of
    a single conditional jump instruction placed where the condition will always be
    the same. The following code uses this technique: 33 C0 xor eax, eax'
  prefs: []
  type: TYPE_NORMAL
- en: 74 01 jz short near ptr loc_4011C4+1
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_4011C4: ; CODE XREF: 004011C2j'
  prefs: []
  type: TYPE_NORMAL
- en: '; DATA XREF: .rdata:004020ACo'
  prefs: []
  type: TYPE_NORMAL
- en: E9 58 C3 68 94 jmp near ptr 94A8D521h
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this code begins with the instruction xor eax, eax. This instruction
    will set the EAX register to zero and, as a byproduct, set the zero flag. The
    next instruction is a conditional jump that will jump if the zero flag is set.
    In reality, this is not conditional at all, since we can guarantee that the zero
    flag will always be set at this point in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed previously, the disassembler will process the false branch first,
    which will produce conflicting code with the true branch, and since it processed
    the false branch first, it trusts that branch more. As you’ve learned, you can
    use the D key on the keyboard while your cursor is on a line of code to turn the
    code into data, and pressing the C key will turn the data into code. Using these
    two keyboard shortcuts, a malware analyst could fix this fragment and have it
    show the real path of execution, as follows: 33 C0 xor eax, eax'
  prefs: []
  type: TYPE_NORMAL
- en: 74 01 jz short near ptr loc_4011C5
  prefs: []
  type: TYPE_NORMAL
- en: ; --------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: E9 db 0E9h
  prefs: []
  type: TYPE_NORMAL
- en: ; --------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_4011C5: ; CODE XREF: 004011C2j'
  prefs: []
  type: TYPE_NORMAL
- en: '; DATA XREF: .rdata:004020ACo'
  prefs: []
  type: TYPE_NORMAL
- en: 58 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: C3 retn
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the 0xE9 byte is used exactly as the 0xE8 byte in the previous
    example. E9 is the opcode for a 5-byte jmp instruction, and E8 is the opcode for
    a 5-byte call instruction. In each case, by tricking the disassembler into disassembling
    this location, the 4 bytes following this opcode are effectively hidden from view.
    Figure 15-3 shows this example graphically.
  prefs: []
  type: TYPE_NORMAL
- en: XOR
  prefs: []
  type: TYPE_NORMAL
- en: JZ
  prefs: []
  type: TYPE_NORMAL
- en: POP
  prefs: []
  type: TYPE_NORMAL
- en: RET
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: C0
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: '01'
  prefs: []
  type: TYPE_NORMAL
- en: E9
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: C3
  prefs: []
  type: TYPE_NORMAL
- en: JMP
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-3: False conditional of xor followed by a jz instruction* **336**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Impossible Disassembly***'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we examined code that was improperly disassembled
    by the first attempt made by the disassembler, but with an interactive disassembler
    like IDA Pro, we were able to work with the disassembly and have it produce accurate
    results. However, under some conditions, no traditional assembly listing will
    accurately represent the instructions that are executed. We use the term *impossible
    disassembly* for such conditions, but the term isn’t strictly accurate. You could
    disassemble these techniques, but you would need a vastly different representation
    of code than what is currently provided by disassemblers.
  prefs: []
  type: TYPE_NORMAL
- en: The simple anti-disassembly techniques we have discussed use a data byte placed
    strategically after a conditional jump instruction, with the idea that disassembly
    starting at this byte will prevent the real instruction that follows from being
    disassembled because the byte that is inserted is the opcode for a multibyte instruction.
    We’ll call this a *rogue byte* because it is not part of the program and is only
    in the code to throw off the disassembler. In all of these examples, the rogue
    byte can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the rogue byte can’t be ignored? What if it is part of a legitimate
    instruction that is actually executed at runtime? Here, we encounter a tricky
    scenario where any given byte may be a part of multiple instructions that are
    executed. No disassembler currently on the market will represent a single byte
    as being part of two instructions, yet the processor has no such limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-4 shows an example. The first instruction in this 4-byte sequence
    is a 2-byte jmp instruction. The target of the jump is the second byte of itself.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t cause an error, because the byte FF is the first byte of the next
    2-byte instruction, inc eax.
  prefs: []
  type: TYPE_NORMAL
- en: JMP −1
  prefs: []
  type: TYPE_NORMAL
- en: EB
  prefs: []
  type: TYPE_NORMAL
- en: FF
  prefs: []
  type: TYPE_NORMAL
- en: C0
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: INC EAX DEC EAX
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-4: Inward-pointing jmp instruction*'
  prefs: []
  type: TYPE_NORMAL
- en: The predicament when trying to represent this sequence in disassembly is that
    if we choose to represent the FF byte as part of the jmp instruction, then it
    won’t be available to be shown as the beginning of the inc eax instruction. The
    FF byte is a part of both instructions that actually execute, and our modern disassemblers
    have no way of representing this. This 4-byte sequence increments EAX, and then
    decrements it, which is effectively a complicated NOP sequence. It could be inserted
    at almost any location within a program to break the chain of valid disassembly.
    To solve this problem, a malware analyst could choose to replace this entire sequence
    with NOP instructions using an IDC or IDAPython script that calls the PatchByte
    function. Another alternative is to simply turn it all into data with the D key,
    so that disassembly will resume as expected at the end of the 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**337**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: For a glimpse of the complexity that can be achieved with these sorts of instruction
    sequences, let’s examine a more advanced specimen. Figure 15-5
  prefs: []
  type: TYPE_NORMAL
- en: shows an example that operates on the same principle as the prior one, where
    some bytes are part of multiple instructions.
  prefs: []
  type: TYPE_NORMAL
- en: MOV ax, 05EBh
  prefs: []
  type: TYPE_NORMAL
- en: XOR eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: JZ - 7
  prefs: []
  type: TYPE_NORMAL
- en: Fake CALL
  prefs: []
  type: TYPE_NORMAL
- en: '66'
  prefs: []
  type: TYPE_NORMAL
- en: B8
  prefs: []
  type: TYPE_NORMAL
- en: EB
  prefs: []
  type: TYPE_NORMAL
- en: '05'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: C0
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: F9
  prefs: []
  type: TYPE_NORMAL
- en: E8
  prefs: []
  type: TYPE_NORMAL
- en: JMP 5
  prefs: []
  type: TYPE_NORMAL
- en: Real Code
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-5: Multilevel inward-jumping sequence*'
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction in this sequence is a 4-byte mov instruction. The last
    2 bytes have been highlighted because they are both part of this instruction and
    are also their own instruction to be executed later. The first instruction populates
    the AX register with data. The second instruction, an xor, will zero out this
    register and set the zero flag. The third instruction is a conditional jump that
    will jump if the zero flag is set, but it is actually unconditional, since the
    previous instruction will always set the zero flag. The disassembler will decide
    to disassemble the instruction immediately following the jz instruction, which
    will begin with the byte 0xE8, the opcode for a 5-byte call instruction. The instruction
    beginning with the byte E8 will never execute in reality.
  prefs: []
  type: TYPE_NORMAL
- en: The disassembler in this scenario can’t disassemble the target of the jz instruction
    because these bytes are already being accurately represented as part of the mov
    instruction. The code that the jz points to will always be executed, since the
    zero flag will always be set at this point. The jz instruction points to the middle
    of the first 4-byte mov instruction. The last 2 bytes of this instruction are
    the operand that will be moved into the register. When disassembled or executed
    on their own, they form a jmp instruction that will jump forward 5 bytes from
    the end of the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'When first viewed in IDA Pro, this sequence will look like the following: 66
    B8 EB 05 mov ax, 5EBh'
  prefs: []
  type: TYPE_NORMAL
- en: 31 C0 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 74 F9 jz short near ptr sub_4011C0+1
  prefs: []
  type: TYPE_NORMAL
- en: 'loc_4011C8:'
  prefs: []
  type: TYPE_NORMAL
- en: E8 58 C3 90 90 call near ptr 98A8D525h
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no way to clean up the code so that all executing instructions
    are represented, we must choose the instructions to leave in. The net side effect
    of this anti-disassembly sequence is that the EAX register is set to zero. If
    you manipulate the code with the D and C keys in IDA Pro so that the only instructions
    visible are the xor instruction and the hidden instructions, your result should
    look like the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**338**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 66 byte_4011C0 db 66h B8 db 0B8h
  prefs: []
  type: TYPE_NORMAL
- en: EB db 0EBh
  prefs: []
  type: TYPE_NORMAL
- en: 05 db 5
  prefs: []
  type: TYPE_NORMAL
- en: ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 31 C0 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 74 db 74h
  prefs: []
  type: TYPE_NORMAL
- en: F9 db 0F9h
  prefs: []
  type: TYPE_NORMAL
- en: E8 db 0E8h
  prefs: []
  type: TYPE_NORMAL
- en: ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 58 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: C3 retn
  prefs: []
  type: TYPE_NORMAL
- en: This is a somewhat acceptable solution because it shows only the instructions
    that are relevant to understanding the program. However, this solution may interfere
    with analysis processes such as graphing, since it’s difficult to tell exactly
    how the xor instruction or the pop and retn sequences are executed.
  prefs: []
  type: TYPE_NORMAL
- en: A more complete solution would be to use the PatchByte function from the IDC
    scripting language to modify remaining bytes so that they appear as NOP
  prefs: []
  type: TYPE_NORMAL
- en: instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has two areas of undisassembled bytes that we need to convert
    into NOP instructions: 4 bytes starting at memory address 0x004011C0'
  prefs: []
  type: TYPE_NORMAL
- en: 'and 3 bytes starting at memory address 0x004011C6\. The following IDAPython
    script will convert these bytes into NOP bytes (0x90):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def NopBytes(start, length):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, length):'
  prefs: []
  type: TYPE_NORMAL
- en: PatchByte(start + i, 0x90)
  prefs: []
  type: TYPE_NORMAL
- en: MakeCode(start)
  prefs: []
  type: TYPE_NORMAL
- en: NopBytes(0x004011C0, 4)
  prefs: []
  type: TYPE_NORMAL
- en: NopBytes(0x004011C6, 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'This code takes the long approach by making a utility function called NopBytes
    to NOP-out a range of bytes. It then uses that utility function against the two
    ranges that we need to fix. When this script is executed, the resulting disassembly
    is clean, legible, and logically equivalent to the original: 90 nop'
  prefs: []
  type: TYPE_NORMAL
- en: 90 nop
  prefs: []
  type: TYPE_NORMAL
- en: 90 nop
  prefs: []
  type: TYPE_NORMAL
- en: 90 nop
  prefs: []
  type: TYPE_NORMAL
- en: 31 C0 xor eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 90 nop
  prefs: []
  type: TYPE_NORMAL
- en: 90 nop
  prefs: []
  type: TYPE_NORMAL
- en: 90 nop
  prefs: []
  type: TYPE_NORMAL
- en: 58 pop eax
  prefs: []
  type: TYPE_NORMAL
- en: C3 retn
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**339**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The IDAPython script we just crafted worked beautifully for this scenario, but
    it is limited in its usefulness when applied to new challenges. To reuse the previous
    script, the malware analyst must decide which offsets and which length of bytes
    to change to NOP instructions, and manually edit the script with the new values.
  prefs: []
  type: TYPE_NORMAL
- en: '***NOP-ing Out Instructions with IDA Pro***'
  prefs: []
  type: TYPE_NORMAL
- en: With a little IDA Python knowledge, we can develop a script that allows malware
    analysts to easily NOP-out instructions as they see fit. The following script
    establishes the hotkey ALT-N. Once this script is executed, whenever the user
    presses ALT-N, IDA Pro will NOP-out the instruction that is currently at the cursor
    location. It will also conveniently advance the cursor to the next instruction
    to facilitate easy NOP-outs of large blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: import idaapi
  prefs: []
  type: TYPE_NORMAL
- en: idaapi.CompileLine('static n_key() { RunPythonStatement("nopIt()"); }') AddHotkey("Alt-N",
    "n_key")
  prefs: []
  type: TYPE_NORMAL
- en: 'def nopIt():'
  prefs: []
  type: TYPE_NORMAL
- en: start = ScreenEA()
  prefs: []
  type: TYPE_NORMAL
- en: end = NextHead(start)
  prefs: []
  type: TYPE_NORMAL
- en: 'for ea in range(start, end):'
  prefs: []
  type: TYPE_NORMAL
- en: PatchByte(ea, 0x90)
  prefs: []
  type: TYPE_NORMAL
- en: Jump(end)
  prefs: []
  type: TYPE_NORMAL
- en: Refresh()
  prefs: []
  type: TYPE_NORMAL
- en: '**Obscuring Flow Control**'
  prefs: []
  type: TYPE_NORMAL
- en: Modern disassemblers such as IDA Pro do an excellent job of correlating function
    calls and deducing high-level information based on the knowledge of how functions
    are related to each other. This type of analysis works well against code written
    in a standard programming style with a standard compiler, but is easily defeated
    by the malware author.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Function Pointer Problem***'
  prefs: []
  type: TYPE_NORMAL
- en: Function pointers are a common programming idiom in the C programming language
    and are used extensively behind the scenes in C++. Despite this, they still prove
    to be problematic to a disassembler.
  prefs: []
  type: TYPE_NORMAL
- en: Using function pointers in the intended fashion in a C program can greatly reduce
    the information that can be automatically deduced about program flow. If function
    pointers are used in handwritten assembly or crafted in a nonstandard way in source
    code, the results can be difficult to reverse-engineer without dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The following assembly listing shows two functions. The second function uses
    the first through a function pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '**340**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '004011C0 sub_4011C0 proc near ; DATA XREF: sub_4011D0+5o 004011C0'
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0 arg_0 = dword ptr 8
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011C1 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 004011C3 mov eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 004011C6 shl eax, 2
  prefs: []
  type: TYPE_NORMAL
- en: 004011C9 pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011CA retn
  prefs: []
  type: TYPE_NORMAL
- en: 004011CA sub_4011C0 endp
  prefs: []
  type: TYPE_NORMAL
- en: '004011D0 sub_4011D0 proc near ; CODE XREF: _main+19p 004011D0 ; sub_401040+8Bp
    004011D0'
  prefs: []
  type: TYPE_NORMAL
- en: 004011D0 var_4 = dword ptr -4
  prefs: []
  type: TYPE_NORMAL
- en: 004011D0 arg_0 = dword ptr 8
  prefs: []
  type: TYPE_NORMAL
- en: 004011D0
  prefs: []
  type: TYPE_NORMAL
- en: 004011D0 push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011D1 mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 004011D3 push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004011D4 push esi
  prefs: []
  type: TYPE_NORMAL
- en: 004011D5 mov [ebp+var_4], offset sub_4011C0
  prefs: []
  type: TYPE_NORMAL
- en: 004011DC push 2Ah
  prefs: []
  type: TYPE_NORMAL
- en: 004011DE call [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: 004011E1 add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 004011E4 mov esi, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004011E6 mov eax, [ebp+arg_0]
  prefs: []
  type: TYPE_NORMAL
- en: 004011E9 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 004011EA call [ebp+var_4]
  prefs: []
  type: TYPE_NORMAL
- en: 004011ED add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 004011F0 lea eax, [esi+eax+1]
  prefs: []
  type: TYPE_NORMAL
- en: 004011F4 pop esi
  prefs: []
  type: TYPE_NORMAL
- en: 004011F5 mov esp, ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011F7 pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011F8 retn
  prefs: []
  type: TYPE_NORMAL
- en: 004011F8 sub_4011D0 endp
  prefs: []
  type: TYPE_NORMAL
- en: While this example isn’t particularly difficult to reverse-engineer, it does
    expose one key issue. The function sub_4011C0 is actually called from two different
    places ( and ) within the sub_4011D0 function, but it shows only one cross-reference
    at . This is because IDA Pro was able to detect the initial reference to the
    function when its offset was loaded into a stack variable on line 004011D5\. What
    IDA Pro does not detect, however, is the fact that this function is then called
    twice from the locations  and . Any function prototype information that would
    normally be autopropagated to the calling function is also lost.
  prefs: []
  type: TYPE_NORMAL
- en: When used extensively and in combination with other anti-disassembly techniques,
    function pointers can greatly compound the complexity and difficulty of reverse-engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**341**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Missing Code Cross-References in IDA Pro***'
  prefs: []
  type: TYPE_NORMAL
- en: All of the information not autopropagated upward, such as function argument
    names, can be added manually as comments by the malware analyst.
  prefs: []
  type: TYPE_NORMAL
- en: In order to add actual cross-references, we must use the IDC language (or IDAPython)
    to tell IDA Pro that the function sub_4011C0 is actually called from the two locations
    in the other function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IDC function we use is called AddCodeXref. It takes three arguments: the
    location the reference is from, the location the reference is to, and a flow type.
    The function can support several different flow types, but for our purposes, the
    most useful are either fl_CF for a normal call instruction or a fl_JF'
  prefs: []
  type: TYPE_NORMAL
- en: 'for a jump instruction. To fix the previous example assembly code listing in
    IDA Pro, the following script was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: AddCodeXref(0x004011DE, 0x004011C0, fl_CF);
  prefs: []
  type: TYPE_NORMAL
- en: AddCodeXref(0x004011EA, 0x004011C0, fl_CF);
  prefs: []
  type: TYPE_NORMAL
- en: '***Return Pointer Abuse***'
  prefs: []
  type: TYPE_NORMAL
- en: The call and jmp instructions are not the only instructions to transfer control
    within a program. The counterpart to the call instruction is retn (also represented
    as ret). The call instruction acts just like the jmp instruction, except it pushes
    a return pointer on the stack. The return point will be the memory address immediately
    following the end of the call instruction itself.
  prefs: []
  type: TYPE_NORMAL
- en: As call is a combination of jmp and push, retn is a combination of pop and jmp.
    The retn instruction pops the value from the top of the stack and jumps to it.
    It is typically used to return from a function call, but there is no architectural
    reason that it can’t be used for general flow control.
  prefs: []
  type: TYPE_NORMAL
- en: When the retn instruction is used in ways other than to return from a function
    call, even the most intelligent disassemblers can be left in the dark.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious result of this technique is that the disassembler doesn’t show
    any code cross-reference to the target being jumped to. Another key benefit of
    this technique is that the disassembler will prematurely terminate the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the following assembly fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '004011C0 sub_4011C0 proc near ; CODE XREF: _main+19p 004011C0 ; sub_401040+8Bp
    004011C0'
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0 var_4 = byte ptr -4
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0
  prefs: []
  type: TYPE_NORMAL
- en: 004011C0 call $+5
  prefs: []
  type: TYPE_NORMAL
- en: 004011C5 add [esp+4+var_4], 5
  prefs: []
  type: TYPE_NORMAL
- en: 004011C9 retn
  prefs: []
  type: TYPE_NORMAL
- en: 004011C9 sub_4011C0 endp ; sp-analysis failed
  prefs: []
  type: TYPE_NORMAL
- en: 004011C9
  prefs: []
  type: TYPE_NORMAL
- en: '**342**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 004011CA ; ------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 004011CA push ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011CB mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: 004011CD mov eax, [ebp+8]
  prefs: []
  type: TYPE_NORMAL
- en: 004011D0 imul eax, 2Ah
  prefs: []
  type: TYPE_NORMAL
- en: 004011D3 mov esp, ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011D5 pop ebp
  prefs: []
  type: TYPE_NORMAL
- en: 004011D6 retn
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple function that takes a number and returns the product of that
    number times 42\. Unfortunately, IDA Pro is unable to deduce any meaningful information
    about this function because it has been defeated by a rogue retn instruction.
    Notice that it has not detected the presence of an argument to this function.
    The first three instructions accomplish the task of jumping to the real start
    of the function. Let’s examine each of these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction in this function is call $+5\. This instruction simply
    calls the location immediately following itself, which results in a pointer to
    this memory location being placed on the stack. In this specific example, the
    value 0x004011C5 will be placed at the top of the stack after this instruction
    executes. This is a common instruction found in code that needs to be self-referential
    or position-independent, and will be covered in more detail in Chapter 19\.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction is add [esp+4+var_4], 5\. If you are used to reading IDA
    Pro disassembly, you might think that this instruction is referencing a stack
    variable var_4\. In this case, IDA Pro’s stack-frame analysis was incorrect, and
    this instruction was not referencing what would be a normal stack variable, autonamed
    to var_4 in an ordinary function. This may seem confusing at first, but notice
    that at the top of the function, var_4 is defined as the constant -4\. This means
    that what is inside the brackets is [esp+4+(-4)], which can also be represented
    as [esp+0] or simply [esp]. This instruction is adding five to the value at the
    top of the stack, which was 0x004011C5\. The result of the addition instruction
    is that the value at the top of the stack will be 0x004011CA.
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction in this sequence is the retn instruction, which has the
    sole purpose of taking this value off the stack and jumping to it. If you examine
    the code at the location 0x004011CA, it appears to be the legitimate beginning
    of a rather normal-looking function. This “real” function was determined by IDA
    Pro to not be part of any function due to the presence of the rogue retn instruction.
  prefs: []
  type: TYPE_NORMAL
- en: To repair this example, we could patch over the first three instructions with
    NOP instructions and adjust the function boundaries to cover the real function.
  prefs: []
  type: TYPE_NORMAL
- en: To adjust the function boundaries, place the cursor in IDA Pro inside the function
    you wish to adjust and press ALT-P. Adjust the function end address to the memory
    address immediately following the last instruction in the function. To replace
    the first few instructions with nop, refer to the script technique described in
    “NOP-ing Out Instructions with IDA Pro” on page 340\.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**343**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Misusing Structured Exception Handlers***'
  prefs: []
  type: TYPE_NORMAL
- en: The Structured Exception Handling (SEH) mechanism provides a method of flow
    control that is unable to be followed by disassemblers and will fool debuggers.
    SEH is a feature of the x86 architecture and is intended to provide a way for
    the program to handle error conditions intelligently. Programming languages such
    as C++ and Ada rely heavily on exception handling and translate naturally to SEH
    when compiled on x86 systems.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring how to harness SEH to obscure flow control, let’s look at a
    few basic concepts about how it operates. Exceptions can be triggered for a number
    of reasons, such as access to an invalid memory region or dividing by zero. Additional
    software exceptions can be raised by calling the RaiseException function.
  prefs: []
  type: TYPE_NORMAL
- en: The SEH chain is a list of functions designed to handle exceptions within the
    thread. Each function in the list can either handle the exception or pass it to
    the next handler in the list. If the exception makes it all the way to the last
    handler, then it is considered to be an *unhandled exception*.
  prefs: []
  type: TYPE_NORMAL
- en: The last exception handler is the piece of code responsible for triggering the
    familiar message box that informs the user that “an unhandled exception has occurred.”
    Exceptions happen regularly in most processes, but are handled silently before
    they make it to this final state of crashing the process and informing the user.
  prefs: []
  type: TYPE_NORMAL
- en: To find the SEH chain, the OS examines the FS segment register. This register
    contains a segment selector that is used to gain access to the Thread Environment
    Block (TEB). The first structure within the TEB is the Thread Information Block
    (TIB). The first element of the TIB (and consequently the first bytes of the TEB)
    is a pointer to the SEH chain. The SEH chain is a simple linked list of 8-byte
    data structures called EXCEPTION_REGISTRATION records.
  prefs: []
  type: TYPE_NORMAL
- en: struct _EXCEPTION_REGISTRATION {
  prefs: []
  type: TYPE_NORMAL
- en: DWORD prev;
  prefs: []
  type: TYPE_NORMAL
- en: DWORD handler;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the EXCEPTION_REGISTRATION record points to the previous
    record. The second field is a pointer to the handler function.
  prefs: []
  type: TYPE_NORMAL
- en: This linked list operates conceptually as a stack. The first record to be called
    is the last record to be added to the list. The SEH chain grows and shrinks as
    layers of exception handlers in a program change due to subroutine calls and nested
    exception handler blocks. For this reason, SEH records are always built on the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use SEH to achieve covert flow control, we need not concern ourselves
    with how many exception records are currently in the chain. We just need to understand
    how to add our own handler to the top of this list, as shown in Figure 15-6\.
  prefs: []
  type: TYPE_NORMAL
- en: '**344**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: FS:[0]
  prefs: []
  type: TYPE_NORMAL
- en: prev handler
  prefs: []
  type: TYPE_NORMAL
- en: Handler Function
  prefs: []
  type: TYPE_NORMAL
- en: prev handler
  prefs: []
  type: TYPE_NORMAL
- en: Handler Function
  prefs: []
  type: TYPE_NORMAL
- en: prev handler
  prefs: []
  type: TYPE_NORMAL
- en: Handler Function
  prefs: []
  type: TYPE_NORMAL
- en: prev handler
  prefs: []
  type: TYPE_NORMAL
- en: Handler Function
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-6: Structured Exception Handling (SEH) chain* To add a record to
    this list, we need to construct a new record on the stack. Since the record structure
    is simply two DWORDs, we can do this with two push instructions. The stack grows
    upward, so the first push will be the pointer to the handler function, and the
    second push will be the pointer to the next record. We are trying to add a record
    to the top of the chain, so the next record in the chain when we finish will be
    what is currently the top, which is pointed to by fs:[0]. The following code performs
    this sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: push ExceptionHandler
  prefs: []
  type: TYPE_NORMAL
- en: push fs:[0]
  prefs: []
  type: TYPE_NORMAL
- en: mov fs:[0], esp
  prefs: []
  type: TYPE_NORMAL
- en: The ExceptionHandler function will be called first whenever an exception occurs.
    This action will be subject to the constraints imposed by Microsoft’s Software
    Data Execution Prevention (Software DEP, also known as SafeSEH).
  prefs: []
  type: TYPE_NORMAL
- en: Software DEP is a security feature that prevents the addition of third-party
    exception handlers at runtime. For purposes of handwritten assembly code, there
    are several ways to work around this technology, such as using an assembler that
    has support for SafeSEH directives. Using Microsoft’s C compilers, an author can
    add /SAFESEH:NO to the linker command line to disable this.
  prefs: []
  type: TYPE_NORMAL
- en: When the ExceptionHandler code is called, the stack will be drastically altered.
    Luckily, it is not essential for our purposes to fully examine all the data that
    is added to the stack at this point. We must simply understand how to return the
    stack to its original position prior to the exception. Remember that our goal
    is to obscure flow control and not to properly handle program exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The OS adds another SEH handler when our handler is called. To return the program
    to normal operation, we need to unlink not just our handler, but this handler
    as well. Therefore, we need to pull our original stack pointer from esp+8 instead
    of esp.
  prefs: []
  type: TYPE_NORMAL
- en: mov esp, [esp+8]
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, fs:[0]
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: mov fs:[0], eax
  prefs: []
  type: TYPE_NORMAL
- en: add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**345**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s bring all this knowledge back to our original goal of obscuring flow control.
    The following fragment contains a piece of code from a Visual C++
  prefs: []
  type: TYPE_NORMAL
- en: binary that covertly transfers flow to a subroutine. Since there is no pointer
    to this function and the disassembler doesn’t understand SEH, it appears as though
    the subroutine has no references, and the disassembler thinks the code immediately
    following the triggering of the exception will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 00401050 mov eax, (offset loc_40106B+1) 00401055 add eax, 14h
  prefs: []
  type: TYPE_NORMAL
- en: 00401058 push eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401059 push large dword ptr fs:0 ; dwMilliseconds 00401060 mov large fs:0,
    esp
  prefs: []
  type: TYPE_NORMAL
- en: 00401067 xor ecx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401069 div ecx
  prefs: []
  type: TYPE_NORMAL
- en: 0040106B
  prefs: []
  type: TYPE_NORMAL
- en: '0040106B loc_40106B: ; DATA XREF: sub_401050o 0040106B call near ptr Sleep'
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 retn
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 sub_401050 endp ; sp-analysis failed
  prefs: []
  type: TYPE_NORMAL
- en: '00401070'
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 ; ------------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: 00401071 align 10h
  prefs: []
  type: TYPE_NORMAL
- en: 00401080 dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
  prefs: []
  type: TYPE_NORMAL
- en: 00401094 dd 6808C483h
  prefs: []
  type: TYPE_NORMAL
- en: 00401098 dd offset aMysteryCode ; "Mystery Code"
  prefs: []
  type: TYPE_NORMAL
- en: 0040109C dd 2DE8h, 4C48300h, 3 dup(0CCCCCCCCh) In this example, IDA Pro has
    not only missed the fact that the subroutine at location 401080  was not called,
    but it also failed to even disassemble this function. This code sets up an exception
    handler covertly by first setting the register EAX to the value 40106C , and
    then adding 14h to it to build a pointer to the function 401080\. A divide-by-zero
    exception is triggered by setting ECX to zero with xor ecx, ecx followed by div
    ecx at , which divides the EAX register by ECX.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the C key in IDA Pro to turn the data at location 401080 into code
    and see what was hidden using this trick.
  prefs: []
  type: TYPE_NORMAL
- en: 00401080 mov esp, [esp+8]
  prefs: []
  type: TYPE_NORMAL
- en: 00401084 mov eax, large fs:0
  prefs: []
  type: TYPE_NORMAL
- en: 0040108A mov eax, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 0040108C mov eax, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 0040108E mov large fs:0, eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401094 add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 00401097 push offset aMysteryCode ; "Mystery Code"
  prefs: []
  type: TYPE_NORMAL
- en: 0040109C call printf
  prefs: []
  type: TYPE_NORMAL
- en: '**346**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thwarting Stack-Frame Analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced disassemblers can analyze the instructions in a function to deduce
    the construction of its stack frame, which allows them to display the local variables
    and parameters relevant to the function. This information is extremely valuable
    to a malware analyst, as it allows for the analysis of a single function at one
    time, and enables the analyst to better understand its inputs, outputs, and construction.
  prefs: []
  type: TYPE_NORMAL
- en: However, analyzing a function to determine the construction of its stack frame
    is not an exact science. As with many other facets of disassembly, the algorithms
    used to determine the construction of the stack frame must make certain assumptions
    and guesses that are reasonable but can usually be exploited by a knowledgeable
    malware author.
  prefs: []
  type: TYPE_NORMAL
- en: Defeating stack-frame analysis will also prevent the operation of certain analytical
    techniques, most notably the Hex-Rays Decompiler plug-in for IDA Pro, which produces
    C-like pseudocode for a function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by examining a function that has been armored to defeat stack-frame
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '00401543 sub_401543 proc near ; CODE XREF: sub_4012D0+3Cp 00401543 ; sub_401328+9Bp
    00401543'
  prefs: []
  type: TYPE_NORMAL
- en: 00401543 arg_F4 = dword ptr 0F8h
  prefs: []
  type: TYPE_NORMAL
- en: 00401543 arg_F8 = dword ptr 0FCh
  prefs: []
  type: TYPE_NORMAL
- en: '00401543'
  prefs: []
  type: TYPE_NORMAL
- en: 00401543 000 sub esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 00401546 008 sub esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 00401549 00C cmp esp, 1000h
  prefs: []
  type: TYPE_NORMAL
- en: 0040154F 00C jl short loc_401556
  prefs: []
  type: TYPE_NORMAL
- en: 00401551 00C add esp, 4
  prefs: []
  type: TYPE_NORMAL
- en: 00401554 008 jmp short loc_40155C
  prefs: []
  type: TYPE_NORMAL
- en: 00401556 ; --------------------------------------------------------------
  prefs: []
  type: TYPE_NORMAL
- en: '00401556'
  prefs: []
  type: TYPE_NORMAL
- en: '00401556 loc_401556: ; CODE XREF: sub_401543+Cj 00401556 00C add esp, 104h'
  prefs: []
  type: TYPE_NORMAL
- en: 0040155C
  prefs: []
  type: TYPE_NORMAL
- en: '0040155C loc_40155C: ; CODE XREF: sub_401543+11j 0040155C -F8'
  prefs: []
  type: TYPE_NORMAL
- en: mov [esp-0F8h+arg_F8], 1E61h
  prefs: []
  type: TYPE_NORMAL
- en: 00401564 -F8 lea eax, [esp-0F8h+arg_F8]
  prefs: []
  type: TYPE_NORMAL
- en: 00401568 -F8 mov [esp-0F8h+arg_F4], eax 0040156B -F8 mov edx, [esp-0F8h+arg_F4]
  prefs: []
  type: TYPE_NORMAL
- en: 0040156E -F8 mov eax, [esp-0F8h+arg_F8]
  prefs: []
  type: TYPE_NORMAL
- en: 00401572 -F8 inc eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401573 -F8 mov [edx], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401575 -F8 mov eax, [esp-0F8h+arg_F4]
  prefs: []
  type: TYPE_NORMAL
- en: 00401578 -F8 mov eax, [eax]
  prefs: []
  type: TYPE_NORMAL
- en: 0040157A -F8 add esp, 8
  prefs: []
  type: TYPE_NORMAL
- en: 0040157D -100 retn
  prefs: []
  type: TYPE_NORMAL
- en: 0040157D sub_401543 endp ; sp-analysis failed
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-1: A function that defeats stack-frame analysis* Anti-Disassembly'
  prefs: []
  type: TYPE_NORMAL
- en: '**347**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Stack-frame anti-analysis techniques depend heavily on the compiler used. Of
    course, if the malware is entirely written in assembly, then the author is free
    to use more unorthodox techniques. However, if the malware is crafted with a higher-level
    language such as C or C++, special care must be taken to output code that can
    be manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 15-1, the column on the far left is the standard IDA Pro line prefix,
    which contains the segment name and memory address for each function. The next
    column to the right displays the stack pointer. For each instruction, the stack
    pointer column shows the value of the ESP register relative to where it was at
    the beginning of the function. This view shows that this function is an ESP-based
    stack frame rather than an EBP-based one, like most functions. (This stack pointer
    column can be enabled in IDA Pro through the Options menu.)
  prefs: []
  type: TYPE_NORMAL
- en: At , the stack pointer begins to be shown as a negative number. This should
    never happen for an ordinary function because it means that this function could
    damage the calling function’s stack frame. In this listing, IDA Pro is also telling
    us that it thinks this function takes 62 arguments, of which it thinks 2 are actually
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Press CTRL-K in IDA Pro to examine this monstrous stack frame in detail. If
    you* *attempt to press Y to give this function a prototype, you’ll be presented
    with one of* *the most ghastly abominations of a function prototype you’ve ever
    seen.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, this function doesn’t actually take 62 arguments. In
    reality, it takes no arguments and has two local variables. The code responsible
    for breaking IDA Pro’s analysis lies near the beginning of the function, between
    locations 00401546 and 0040155C. It’s a simple comparison with two branches.
  prefs: []
  type: TYPE_NORMAL
- en: The ESP register is being compared against the value 0x1000\. If it is less
    than 0x1000, then it executes the code at 00401556; otherwise, it executes the
    code at 00401551\. Each branch adds some value to ESP—0x104 on the “less-than”
    branch and 4 on the “greater-than-or-equal-to” branch. From a disassembler’s perspective,
    there are two possible values of the stack pointer offset at this point, depending
    on which branch has been taken. The disassembler is forced to make a choice, and
    luckily for the malware author, it is tricked into making the wrong choice.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we discussed conditional branch instructions, which were not conditional
    at all because they exist where the condition is constant, such as a jz instruction
    immediately following an xor eax, eax instruction. Innovative disassembler authors
    could code special semantics in their algorithm to track such guaranteed flag
    states and detect the presence of such fake conditional branches. The code would
    be useful in many scenarios and would be very straightforward, though cumbersome,
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: In Listing 15-1, the instruction cmp esp, 1000h will always produce a fixed
    result. An experienced malware analyst might recognize that the lowest memory
    page in a Windows process would not be used as a stack, and thus this comparison
    is virtually guaranteed to always result in the “greater-than-348
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: or-equal-to” branch being executed. The disassembly program doesn’t have this
    level of intuition. Its job is to show you the instructions. It’s not designed
    to evaluate every decision in the code against a set of real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The crux of the problem is that the disassembler assumed that the add esp, 104h
    instruction was valid and relevant, and adjusted its interpretation of the stack
    accordingly. The add esp, 4 instruction in the greater-than-or-equal-to branch
    was there solely to readjust the stack after the sub esp, 4 instruction that came
    before the comparison. The net result in real time is that the ESP
  prefs: []
  type: TYPE_NORMAL
- en: value will be identical to what it was prior to the beginning of the sequence
    at address 00401546\.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome minor adjustments to the stack frame (which occur occasionally due
    to the inherently fallible nature of stack-frame analysis), in IDA Pro, you can
    put the cursor on a particular line of disassembly and press ALT-K to enter an
    adjustment to the stack pointer. In many cases, such as in Listing 15-1, it may
    prove more fruitful to patch the stack-frame manipulation instructions, as in
    the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Anti-disassembly is not confined to the techniques discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is a class of techniques that takes advantage of the inherent difficulties
    in analysis. Advanced programs such as modern disassemblers do an excellent job
    of determining which instructions constitute a program, but they still require
    assumptions and choices to be made in the process. For each choice or assumption
    that can be made by a disassembler, there may be a corresponding anti-disassembly
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter showed how disassemblers work and how linear and flow-oriented
    disassembly strategies differ. Anti-disassembly is more difficult with a flow-oriented
    disassembler but still quite possible, once you understand that the disassembler
    is making certain assumptions about where the code will execute. Many anti-disassembly
    techniques used against flow-oriented disassemblers operate by crafting conditional
    flow-control instructions for which the condition is always the same at runtime
    but unknown by the disassembler.
  prefs: []
  type: TYPE_NORMAL
- en: Obscuring flow control is a way that malware can cause the malware analyst to
    overlook portions of code or hide a function’s purpose by obscuring its relation
    to other functions and system calls. We examined several ways to accomplish this,
    ranging from using the ret instruction to using SEH handlers as a general-purpose
    jump.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter was to help you understand code from a tactical perspective.
    You learned how these types of techniques work, why they are useful, and how to
    defeat them when you encounter them in the field. More techniques are waiting
    to be discovered and invented. With this solid foundation, you will be more than
    prepared to wage war in the anti-disassembly battlefield of the future.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Disassembly
  prefs: []
  type: TYPE_NORMAL
- en: '**349**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 15-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the sample found in the file *Lab15-01.exe*. This is a command-line
    program that takes an argument and prints “Good Job!” if the argument matches
    a secret code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What anti-disassembly technique is used in this binary?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What rogue opcode is the disassembly tricked into disassembling?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: How many times is this technique used?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What command-line argument will cause the program to print
  prefs: []
  type: TYPE_NORMAL
- en: “Good Job!”?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 15-2**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in the file *Lab15-02.exe*. Correct all anti-disassembly
    countermeasures before analyzing the binary in order to answer the questions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What URL is initially requested by the program?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: How is the User-Agent generated?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What does the program look for in the page it initially requests?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What does the program do with the information it extracts from the page?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 15-3**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in the file *Lab15-03.exe*. At first glance, this
    binary appears to be a legitimate tool, but it actually contains more functionality
    than advertised.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: How is the malicious code initially called?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What does the malicious code do?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What URL does the malware use?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: What filename does the malware use?
  prefs: []
  type: TYPE_NORMAL
- en: '**350**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**A N T I - D E B U G G I N G**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anti-debugging* is a popular anti-analysis technique used by malware to recognize
    when it is under the control'
  prefs: []
  type: TYPE_NORMAL
- en: of a debugger or to thwart debuggers. Malware authors
  prefs: []
  type: TYPE_NORMAL
- en: know that malware analysts use debuggers to figure out
  prefs: []
  type: TYPE_NORMAL
- en: how malware operates, and the authors use anti-debugging techniques in an attempt
    to slow down the analyst as much as possible. Once malware realizes that it is
    running in a debugger, it may alter its normal code execution path or modify the
    code to cause a crash, thus interfering with the analysts’ attempts to understand
    it, and adding time and additional overhead to their efforts.
  prefs: []
  type: TYPE_NORMAL
- en: There are many anti-debugging techniques—perhaps hundreds of them—
  prefs: []
  type: TYPE_NORMAL
- en: and we’ll discuss only the most popular ones that we have encountered in the
    real world. We will present ways to bypass anti-debugging techniques, but our
    overall goal in this chapter (besides introducing you to specific techniques)
    is to help you to develop the skills that you’ll need to overcome new and previously
    unknown anti-debugging methods during analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Debugger Detection**'
  prefs: []
  type: TYPE_NORMAL
- en: Malware uses a variety of techniques to scan for indications that a debugger
    is attached, including using the Windows API, manually checking memory structure
    for debugging artifacts, and searching the system for residue left by a debugger.
    Debugger detection is the most common way that malware performs anti-debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Windows API***'
  prefs: []
  type: TYPE_NORMAL
- en: The use of Windows API functions is the most obvious of the anti-debugging techniques.
    The Windows API provides several functions that can be used by a program to determine
    if it is being debugged. Some of these functions were designed for debugger detection;
    others were designed for different purposes but can be repurposed to detect a
    debugger. A few of these functions use functionality not documented in the API.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the easiest way to overcome a call to an anti-debugging API function
    is to manually modify the malware during execution to not call these functions
    or to modify the flag’s post call to ensure that the proper path is taken. A more
    difficult option would be to hook these functions, as with a rootkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Windows API functions can be used for anti-debugging: **IsDebuggerPresent**'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest API function for detecting a debugger is IsDebuggerPresent.
  prefs: []
  type: TYPE_NORMAL
- en: This function searches the Process Environment Block (PEB) structure for the
    field IsDebugged, which will return zero if you are not running in the context
    of a debugger or a nonzero value if a debugger is attached.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss the PEB structure in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**CheckRemoteDebuggerPresent**'
  prefs: []
  type: TYPE_NORMAL
- en: This API function is nearly identical to IsDebuggerPresent. The name is misleading
    though, as it does not check for a debugger on a remote machine, but rather for
    a process on the local machine. It also checks the PEB structure for the IsDebugged
    field; however, it can do so for itself or another process on the local machine.
    This function takes a process handle as a parameter and will check if that process
    has a debugger attached. CheckRemoteDebuggerPresent can be used to check your
    own process by simply passing a handle to your process.
  prefs: []
  type: TYPE_NORMAL
- en: '**NtQueryInformationProcess**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a native API function in *Ntdll.dll* that retrieves information about
    a given process. The first parameter to this function is a process handle; the
    second is used to tell the function the type of process information to be retrieved.
    For example, using the value ProcessDebugPort (value 0x7) for this parameter will
    tell you if the process in question is currently being debugged. If the process
    is not being debugged, a zero will be returned; otherwise, a port number will
    be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**352**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**OutputDebugString**'
  prefs: []
  type: TYPE_NORMAL
- en: This function is used to send a string to a debugger for display. It can be
    used to detect the presence of a debugger. For example, Listing 16-1
  prefs: []
  type: TYPE_NORMAL
- en: uses SetLastError to set the current error code to an arbitrary value. If OutputDebugString
    is called and there is no debugger attached, GetLastError should no longer contain
    our arbitrary value, because an error code will be set by the OutputDebugString
    function if it fails. If OutputDebugString is called and there is a debugger attached,
    the call to OutputDebugString should succeed, and the value in GetLastError should
    not be changed.
  prefs: []
  type: TYPE_NORMAL
- en: DWORD errorValue = 12345;
  prefs: []
  type: TYPE_NORMAL
- en: SetLastError(errorValue);
  prefs: []
  type: TYPE_NORMAL
- en: OutputDebugString("Test for Debugger");
  prefs: []
  type: TYPE_NORMAL
- en: if(GetLastError() == errorValue)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ExitProcess();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: RunMaliciousPayload();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-1: OutputDebugString anti-debugging technique*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Manually Checking Structures***'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Windows API may be the most obvious method for detecting the presence
    of a debugger, but manually checking structures is the most common method used
    by malware authors. There are many reasons why malware authors are discouraged
    from using the Windows API for anti-debugging.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the API calls could be hooked by a rootkit to return false information.
    Therefore, malware authors often choose to perform the functional equivalent of
    the API call manually, rather than rely on the Windows API.
  prefs: []
  type: TYPE_NORMAL
- en: In performing manual checks, several flags within the PEB structure provide
    information about the presence of a debugger. Here, we’ll look at some of the
    commonly used flags for checking for a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking the BeingDebugged Flag**'
  prefs: []
  type: TYPE_NORMAL
- en: A Windows PEB structure is maintained by the OS for each running process, as
    shown in the example in Listing 16-2\. It contains all user-mode parameters associated
    with a process. These parameters include the process’s environment data, which
    itself includes environment variables, the loaded modules list, addresses in memory,
    and debugger status.
  prefs: []
  type: TYPE_NORMAL
- en: typedef struct _PEB {
  prefs: []
  type: TYPE_NORMAL
- en: BYTE Reserved1[2];
  prefs: []
  type: TYPE_NORMAL
- en: BYTE **BeingDebugged**;
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**353**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: BYTE Reserved2[1];
  prefs: []
  type: TYPE_NORMAL
- en: PVOID Reserved3[2];
  prefs: []
  type: TYPE_NORMAL
- en: PPEB_LDR_DATA Ldr;
  prefs: []
  type: TYPE_NORMAL
- en: PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
  prefs: []
  type: TYPE_NORMAL
- en: BYTE Reserved4[104];
  prefs: []
  type: TYPE_NORMAL
- en: PVOID Reserved5[52];
  prefs: []
  type: TYPE_NORMAL
- en: PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  prefs: []
  type: TYPE_NORMAL
- en: BYTE Reserved6[128];
  prefs: []
  type: TYPE_NORMAL
- en: PVOID Reserved7[1];
  prefs: []
  type: TYPE_NORMAL
- en: ULONG SessionId;
  prefs: []
  type: TYPE_NORMAL
- en: '} PEB, *PPEB;'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-2: Documented Process Environment Block (PEB) structure* While
    a process is running, the location of the PEB can be referenced by the location
    fs:[30h]. For anti-debugging, malware will use that location to check the BeingDebugged
    flag, which indicates whether the specified process is being debugged. Table 16-1
    shows two examples of this type of check.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-1:** Manually Checking the BeingDebugged Flag **mov method**'
  prefs: []
  type: TYPE_NORMAL
- en: '**push/pop method**'
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, dword ptr fs:[30h]
  prefs: []
  type: TYPE_NORMAL
- en: push dword ptr fs:[30h]
  prefs: []
  type: TYPE_NORMAL
- en: mov ebx, byte ptr [eax+2]
  prefs: []
  type: TYPE_NORMAL
- en: pop edx
  prefs: []
  type: TYPE_NORMAL
- en: test ebx, ebx
  prefs: []
  type: TYPE_NORMAL
- en: cmp byte ptr [edx+2], 1
  prefs: []
  type: TYPE_NORMAL
- en: jz NoDebuggerDetected
  prefs: []
  type: TYPE_NORMAL
- en: je DebuggerDetected
  prefs: []
  type: TYPE_NORMAL
- en: In the code on the left in Table 16-1, the location of the PEB is moved into
    EAX. Next, this offset plus 2 is moved into EBX, which corresponds to the offset
    into the PEB of the location of the BeingDebugged flag. Finally, EBX
  prefs: []
  type: TYPE_NORMAL
- en: is checked to see if it is zero. If so, a debugger is not attached, and the
    jump will be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is shown on the right side of Table 16-1\. The location of the
    PEB is moved into EDX using a push/pop combination of instructions, and then the
    BeingDebugged flag at offset 2 is directly compared to 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'This check can take many forms, and, ultimately, the conditional jump determines
    the code path. You can take one of the following approaches to surmount this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Force the jump to be taken (or not) by manually modifying the zero flag immediately
    before the jump instruction is executed. This is the easiest approach.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Manually change the BeingDebugged flag to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Both options are generally effective against all of the techniques described
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A number of OllyDbg plug-ins change the BeingDebugged flag for you. The most
    popular are Hide Debugger, Hidedebug, and PhantOm. All are useful for overcoming
    the* *BeingDebugged flag check and also help with many of the other techniques
    we discuss in* *this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**354**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking the ProcessHeap Flag**'
  prefs: []
  type: TYPE_NORMAL
- en: An undocumented location within the Reserved4 array (shown in Listing 16-2),
    known as ProcessHeap, is set to the location of a process’s first heap allocated
    by the loader. ProcessHeap is located at 0x18 in the PEB structure. This first
    heap contains a header with fields used to tell the kernel whether the heap was
    created within a debugger. These are known as the ForceFlags and Flags fields.
  prefs: []
  type: TYPE_NORMAL
- en: Offset 0x10 in the heap header is the ForceFlags field on Windows XP, but for
    Windows 7, it is at offset 0x44 for 32-bit applications. Malware may also look
    at offset 0x0C on Windows XP or offset 0x40 on Windows 7 for the Flags field.
    This field is almost always equal to the ForceFlags field, but is usually ORed
    with the value 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-3 shows the assembly code for this technique. (Note that two separate
    dereferences must occur.)
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, large fs:30h
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, dword ptr [eax+18h]
  prefs: []
  type: TYPE_NORMAL
- en: cmp dword ptr ds:[eax+10h], 0
  prefs: []
  type: TYPE_NORMAL
- en: jne DebuggerDetected
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-3: Manual ProcessHeap flag check*'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to overcome this technique is to change the ProcessHeap flag manually
    or to use a hide-debug plug-in for your debugger. If you are using WinDbg, you
    can start the program with the debug heap disabled. For example, the command windbg
    –hd notepad.exe will start the heap in normal mode as opposed to debug mode, and
    the flags we’ve discussed won’t be set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking NTGlobalFlag**'
  prefs: []
  type: TYPE_NORMAL
- en: Since processes run slightly differently when started with a debugger, they
    create memory heaps differently. The information that the system uses to determine
    how to create heap structures is stored at an undocumented location in the PEB
    at offset 0x68\. If the value at this location is 0x70, we know that we are running
    in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: The value of 0x70 is a combination of the following flags when a heap is created
    by a debugger. These flags are set for the process if it is started from within
    a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
    Listing 16-4 shows the assembly code for performing this check.
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, large fs:30h
  prefs: []
  type: TYPE_NORMAL
- en: cmp dword ptr ds:[eax+68h], 70h
  prefs: []
  type: TYPE_NORMAL
- en: jz DebuggerDetected
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-4: NTGlobalFlag check*'
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**355**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to overcome this technique is to change the flags manually or
    with a hide-debug plug-in for your debugger. If you are using WinDbg, you can
    start the program with the debug heap option disabled, as mentioned in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Checking for System Residue***'
  prefs: []
  type: TYPE_NORMAL
- en: 'When analyzing malware, we typically use debugging tools, which leave residue
    on the system. Malware can search for this residue in order to determine when
    you are attempting to analyze it, such as by searching registry keys for references
    to debuggers. The following is a common location for a debugger: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\AeDebug This registry key specifies the debugger that activates
    when an application error occurs. By default, this is set to Dr. Watson, so if
    it is changed to something like OllyDbg, malware may determine that it is under
    a microscope.'
  prefs: []
  type: TYPE_NORMAL
- en: Malware can also search the system for files and directories, such as common
    debugger program executables, which are typically present during malware analysis.
    (Many backdoors already have code in place to traverse filesystems.) Or the malware
    can detect residue in live memory, by viewing the current process listing or,
    more commonly, by performing a FindWindow in search of a debugger, as shown in
    Listing 16-5\.
  prefs: []
  type: TYPE_NORMAL
- en: if(**FindWindow**("OLLYDBG", 0) == NULL)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: //Debugger Not Found
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: //Debugger Detected
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-5: C code for FindWindow detection*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the code simply looks for a window named OLLYDBG.
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying Debugger Behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that debuggers can be used to set breakpoints or to single-step through
    a process in order to aid the malware analyst in reverse-engineering. However,
    when these operations are performed in a debugger, they modify the code in the
    process. Several anti-debugging techniques are used by malware to detect this
    sort of debugger behavior: INT scanning, checksum checks, and timing checks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**356**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***INT Scanning***'
  prefs: []
  type: TYPE_NORMAL
- en: INT 3 is the software interrupt used by debuggers to temporarily replace an
    instruction in a running program and to call the debug exception handler—
  prefs: []
  type: TYPE_NORMAL
- en: a basic mechanism to set a breakpoint. The opcode for INT 3 is 0xCC. Whenever
    you use a debugger to set a breakpoint, it modifies the code by inserting a 0xCC.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the specific INT 3 instruction, an INT *immediate* can set any
    interrupt, including 3 ( *immediate* can be a register, such as EAX). The INT
  prefs: []
  type: TYPE_NORMAL
- en: '*immediate* instruction uses two opcodes: 0xCD *value*. This 2-byte opcode
    is less commonly used by debuggers.'
  prefs: []
  type: TYPE_NORMAL
- en: One common anti-debugging technique has a process scan its own code for an INT
    3 modification by searching the code for the 0xCC opcode, as shown in Listing
    16-6\.
  prefs: []
  type: TYPE_NORMAL
- en: call $+5
  prefs: []
  type: TYPE_NORMAL
- en: pop edi
  prefs: []
  type: TYPE_NORMAL
- en: sub edi, 5
  prefs: []
  type: TYPE_NORMAL
- en: mov ecx, 400h
  prefs: []
  type: TYPE_NORMAL
- en: mov eax, 0CCh
  prefs: []
  type: TYPE_NORMAL
- en: repne scasb
  prefs: []
  type: TYPE_NORMAL
- en: jz DebuggerDetected
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-6: Scanning code for breakpoints*'
  prefs: []
  type: TYPE_NORMAL
- en: This code begins with a call, followed by a pop that puts EIP into EDI.
  prefs: []
  type: TYPE_NORMAL
- en: EDI is then adjusted to the start of the code. The code is then scanned for
    0xCC bytes. If a 0xCC byte is found, it knows that a debugger is present. This
    technique can be overcome by using hardware breakpoints instead of software breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '***Performing Code Checksums***'
  prefs: []
  type: TYPE_NORMAL
- en: Malware can calculate a checksum on a section of its code to accomplish the
    same goal as scanning for interrupts. Instead of scanning for 0xCC, this check
    simply performs a cyclic redundancy check (CRC) or a MD5 checksum of the opcodes
    in the malware.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is less common than scanning, but it’s equally effective.
  prefs: []
  type: TYPE_NORMAL
- en: Look for the malware to be iterating over its internal instructions followed
    by a comparison to an expected value.
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be overcome by using hardware breakpoints or by manually
    modifying the execution path with the debugger at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '***Timing Checks***'
  prefs: []
  type: TYPE_NORMAL
- en: Timing checks are one of the most popular ways for malware to detect debuggers
    because processes run more slowly when being debugged. For example, single-stepping
    through a program substantially slows execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**357**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to use timing checks to detect a debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Record a timestamp, perform a couple of operations, take another timestamp,
    and then compare the two timestamps. If there is a lag, you can assume the presence
    of a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Take a timestamp before and after raising an exception. If a process is not
    being debugged, the exception will be handled really quickly; a debugger will
    handle the exception much more slowly. By default, most debuggers require human
    intervention in order to handle exceptions, which causes enormous delay. While
    many debuggers allow you to ignore exceptions and pass them to the program, there
    will still be a sizable delay in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the rdtsc Instruction**'
  prefs: []
  type: TYPE_NORMAL
- en: The most common timing check method uses the rdtsc instruction (opcode 0x0F31),
    which returns the count of the number of ticks since the last system reboot as
    a 64-bit value placed into EDX:EAX. Malware will simply execute this instruction
    twice and compare the difference between the two readings.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-7 shows a real malware sample using the rdtsc technique.
  prefs: []
  type: TYPE_NORMAL
- en: rdtsc
  prefs: []
  type: TYPE_NORMAL
- en: xor ecx, ecx
  prefs: []
  type: TYPE_NORMAL
- en: add ecx, eax
  prefs: []
  type: TYPE_NORMAL
- en: rdtsc
  prefs: []
  type: TYPE_NORMAL
- en: sub eax, ecx
  prefs: []
  type: TYPE_NORMAL
- en: cmp eax, 0xFFF 
  prefs: []
  type: TYPE_NORMAL
- en: jb NoDebuggerDetected
  prefs: []
  type: TYPE_NORMAL
- en: rdtsc
  prefs: []
  type: TYPE_NORMAL
- en: push eax 
  prefs: []
  type: TYPE_NORMAL
- en: ret
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-7: The rdtsc timing technique*'
  prefs: []
  type: TYPE_NORMAL
- en: The malware checks to see if the difference between the two calls to rdtsc is
    greater than 0xFFF at , and if too much time has elapsed, the conditional jump
    will not be taken. If the jump is not taken, rdtsc is called again, and the result
    is pushed onto the stack at , which will cause the return to take the execution
    to a random location.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using QueryPerformanceCounter and GetTickCount**'
  prefs: []
  type: TYPE_NORMAL
- en: Two Windows API functions are used like rdtsc in order to perform an anti-debugging
    timing check. This method relies on the fact that processors have high-resolution
    performance counters—registers that store counts of activities performed in the
    processor. QueryPerformanceCounter can be called to query this counter twice in
    order to get a time difference for use in a comparison.
  prefs: []
  type: TYPE_NORMAL
- en: If too much time has passed between the two calls, the assumption is that a
    debugger is being used.
  prefs: []
  type: TYPE_NORMAL
- en: '**358**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The function GetTickCount returns the number of milliseconds that have elapsed
    since the last system reboot. (Due to the size allocated for this counter, it
    rolls over after 49.7 days.) An example of GetTickCount in practice is shown in
    Listing 16-8\.
  prefs: []
  type: TYPE_NORMAL
- en: a = **GetTickCount**();
  prefs: []
  type: TYPE_NORMAL
- en: MaliciousActivityFunction();
  prefs: []
  type: TYPE_NORMAL
- en: b = **GetTickCount**();
  prefs: []
  type: TYPE_NORMAL
- en: delta = b-a;
  prefs: []
  type: TYPE_NORMAL
- en: if ((delta) > 0x1A)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: //Debugger Detected
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: //Debugger Not Found
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-8: GetTickCount timing technique*'
  prefs: []
  type: TYPE_NORMAL
- en: All of the timing attacks we’ve discussed can be found during debugging or static
    analysis by identifying two successive calls to these functions followed by a
    comparison. These checks should catch a debugger only if you are single-stepping
    or setting breakpoints between the two calls used to capture the time delta. Therefore,
    the easiest way to avoid detection by timing is to run through these checks and
    set a breakpoint just after them, and then start your single-stepping again. If
    that is not an option, simply modify the result of the comparison to force the
    jump that you want to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfering with Debugger Functionality**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can use several techniques to interfere with normal debugger operation:
    thread local storage (TLS) callbacks, exceptions, and interrupt insertion. These
    techniques try to disrupt the program’s execution only if it is under the control
    of a debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using TLS Callbacks***'
  prefs: []
  type: TYPE_NORMAL
- en: You might think that when you load a program into a debugger, it will pause
    at the first instruction the program executes, but this is not always the case.
    Most debuggers start at the program’s entry point as defined by the PE
  prefs: []
  type: TYPE_NORMAL
- en: header. A TLS callback can be used to execute code before the entry point and
    therefore execute secretly in a debugger. If you rely only on the use of a debugger,
    you could miss certain malware functionality, as the TLS callback can run as soon
    as it is loaded into the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: TLS is a Windows storage class in which a data object is not an automatic stack
    variable, yet is local to each thread that runs the code. Basically, TLS
  prefs: []
  type: TYPE_NORMAL
- en: allows each thread to maintain a different value for a variable declared using
    Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**359**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 83](index-393_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 84](index-393_2.png)'
  prefs: []
  type: TYPE_IMG
- en: TLS. When TLS is implemented by an executable, the code will typically contain
    a .tls section in the PE header, as shown in Figure 16-1\. TLS supports callback
    functions for initialization and termination of TLS data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Windows executes these functions before running code at the normal start of
    a program.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-1: TLS callback example—a TLS table in PEview* TLS callbacks can
    be discovered by viewing the .tls section using PEview.'
  prefs: []
  type: TYPE_NORMAL
- en: You should immediately suspect anti-debugging if you see a .tls section, as
    normal programs typically do not use this section.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of TLS callbacks is easy with IDA Pro. Once IDA Pro has finished its
    analysis, you can view the entry points for a binary by pressing CTRL-E to display
    all entry points to the program, including TLS callbacks, as shown in Figure 16-2\.
    All TLS callback functions have their labels prepended with TlsCallback. You can
    browse to the callback function in IDA Pro by double-clicking the function name.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-2: Viewing a TLS callback function in IDA Pro* *(press CTRL-E to
    display)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**360**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 85](index-394_1.png)'
  prefs: []
  type: TYPE_IMG
- en: TLS callbacks can be handled within a debugger, though sometimes debuggers will
    run the TLS callback before breaking at the initial entry point. To avoid this
    problem, change the debugger’s settings. For example, if you’re using OllyDbg,
    you can have it pause before the TLS callback by selecting **Options****Debugging
    Options****Events** and setting **System breakpoint** as the place for the first
    pause, as shown in Figure 16-3\.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*OllyDbg 2.0 has more breaking capabilities than version 1.1; for example,
    it can pause* *at the start of a TLS callback. Also, WinDbg always breaks at the
    system breakpoint* *before the TLS callbacks.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-3: OllyDbg first pause options*'
  prefs: []
  type: TYPE_NORMAL
- en: Because TLS callbacks are well known, malware uses them less frequently than
    in the past. Not many legitimate applications use TLS callbacks, so a
  prefs: []
  type: TYPE_NORMAL
- en: .tls section in an executable can stand out.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Exceptions***'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, interrupts generate exceptions that are used by the debugger
    to perform operations like breakpoints. In Chapter 15, you learned how to set
    up an SEH to achieve an unconventional jump. The modification of the SEH chain
    applies to both anti-disassembly and anti-debugging. In this section, we will
    skip the SEH specifics (since they were addressed in Chapter 15) and focus on
    other ways that exceptions can be used to hamper the malware analyst.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions can be used to disrupt or detect a debugger. Most exception-based
    detection relies on the fact that debuggers will trap the exception and not immediately
    pass it to the process being debugged for handling. The default setting on most
    debuggers is to trap exceptions and not pass them to the program. If the debugger
    doesn’t pass the exception to the process properly, that failure can be detected
    within the process exception-handling mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**361**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 86](index-395_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-4 shows OllyDbg’s default settings; all exceptions will be trapped
    unless the box is checked. These options are accessed via **Options****Debugging**
    **Options****Exceptions**.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-4: Ollydbg exception processing options*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When performing malware analysis, we recommend setting the debugging options
    to* *pass all of the exceptions to the program.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Inserting Interrupts***'
  prefs: []
  type: TYPE_NORMAL
- en: A classic form of anti-debugging is to use exceptions to annoy the analyst and
    disrupt normal program execution by inserting interrupts in the middle of a valid
    instruction sequence. Depending on the debugger settings, these inser-tions could
    cause the debugger to stop, since it is the same mechanism the debugger itself
    uses to set software breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inserting INT 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Because INT 3 is used by debuggers to set software breakpoints, one anti-debugging
    technique consists of inserting 0xCC opcodes into valid sections of code in order
    to trick the debugger into thinking that the opcodes are its breakpoints. Some
    debuggers track where they set software breakpoints in order to avoid falling
    for this trick.
  prefs: []
  type: TYPE_NORMAL
- en: The 2-byte opcode sequence 0xCD03 can also be used to generate an INT 3, and
    this is often a valid way for malware to interfere with WinDbg. Outside a debugger,
    0xCD03 generates a STATUS_BREAKPOINT exception. However, inside WinDbg, it catches
    the breakpoint and then silently advances EIP by exactly 1 byte, since a breakpoint
    is normally the 0xCC opcode. This can cause the program to execute a different
    set of instructions when being debugged by WinDbg versus running normally. (OllyDbg
    is not vulnerable to interference using this 2-byte INT 3 attack.)
  prefs: []
  type: TYPE_NORMAL
- en: '**362**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-9 shows assembly code that implements this technique. This example
    sets a new SEH and then calls INT 3 to force the code to continue.
  prefs: []
  type: TYPE_NORMAL
- en: push offset continue
  prefs: []
  type: TYPE_NORMAL
- en: push dword fs:[0]
  prefs: []
  type: TYPE_NORMAL
- en: mov fs:[0], esp
  prefs: []
  type: TYPE_NORMAL
- en: int 3
  prefs: []
  type: TYPE_NORMAL
- en: //being debugged
  prefs: []
  type: TYPE_NORMAL
- en: 'continue:'
  prefs: []
  type: TYPE_NORMAL
- en: //not being debugged
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-9: INT 3 technique*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inserting INT 2D**'
  prefs: []
  type: TYPE_NORMAL
- en: The INT 2D anti-debugging technique functions like INT 3—the INT 0x2D instruction
    is used to access the kernel debugger. Because INT 0x2D is the way that kernel
    debuggers set breakpoints, the method shown in Listing 16-10 applies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inserting ICE**'
  prefs: []
  type: TYPE_NORMAL
- en: One of Intel’s undocumented instructions is the In-Circuit Emulator (ICE) breakpoint,
    icebp (opcode 0xF1). This instruction is designed to make it easier to debug using
    an ICE, because it is difficult to set an arbitrary breakpoint with an ICE.
  prefs: []
  type: TYPE_NORMAL
- en: Executing this instruction generates a single-step exception. If the program
    is being traced via single-stepping, the debugger will think it is the normal
    exception generated by the single-step and not execute a previously set exception
    handler. Malware can take advantage of this by using the exception handler for
    its normal execution flow, which would be disrupted in this case.
  prefs: []
  type: TYPE_NORMAL
- en: In order to bypass this technique, do not single-step over an icebp instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugger Vulnerabilities**'
  prefs: []
  type: TYPE_NORMAL
- en: Like all software, debuggers contain vulnerabilities, and sometimes malware
    authors attack them in order to prevent debugging. Here, we present several popular
    vulnerabilities in the way OllyDbg handles the PE format.
  prefs: []
  type: TYPE_NORMAL
- en: '***PE Header Vulnerabilities***'
  prefs: []
  type: TYPE_NORMAL
- en: The first technique modifies the Microsoft PE header of a binary executable,
    causing OllyDbg to crash when loading the executable. The result is an error of
    “Bad or Unknown 32-bit Executable File,” yet the program usually runs fine outside
    the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: This issue is due to the fact that OllyDbg follows the Microsoft specifica-tions
    regarding the PE header too strictly. In the PE header, there is typically a structure
    known as the IMAGE_OPTIONAL_HEADER. Figure 16-5 shows a subset of this structure.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**363**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 00000000h
  prefs: []
  type: TYPE_NORMAL
- en: LoaderFlags
  prefs: []
  type: TYPE_NORMAL
- en: NumberOfRvaAndSizes
  prefs: []
  type: TYPE_NORMAL
- en: 00000099h
  prefs: []
  type: TYPE_NORMAL
- en: 0x99 is invalid!
  prefs: []
  type: TYPE_NORMAL
- en: DataDirectory[0]
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Address
  prefs: []
  type: TYPE_NORMAL
- en: 00000000h
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs: []
  type: TYPE_NORMAL
- en: 00000000h
  prefs: []
  type: TYPE_NORMAL
- en: DataDirectory[1]
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Address
  prefs: []
  type: TYPE_NORMAL
- en: 01007604h
  prefs: []
  type: TYPE_NORMAL
- en: 01007604h
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs: []
  type: TYPE_NORMAL
- en: 000000C8h
  prefs: []
  type: TYPE_NORMAL
- en: 000000C8h
  prefs: []
  type: TYPE_NORMAL
- en: DataDirectory[2]
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Address
  prefs: []
  type: TYPE_NORMAL
- en: 0100B000h
  prefs: []
  type: TYPE_NORMAL
- en: 16 items in the
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs: []
  type: TYPE_NORMAL
- en: 00008958h
  prefs: []
  type: TYPE_NORMAL
- en: 00008958h
  prefs: []
  type: TYPE_NORMAL
- en: DataDirectory Array
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: DataDirectory[15]
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Address
  prefs: []
  type: TYPE_NORMAL
- en: 00000000h
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs: []
  type: TYPE_NORMAL
- en: 00000000h
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-5: PE IMAGE_OPTIONAL_HEADER and NumberOfRvaAndSizes vulnerability*
    The last several elements in this structure are of particular interest. The NumberOfRvaAndSizes
    field identifies the number of entries in the DataDirectory array that follows.
    The DataDirectory array indicates where to find other important executable components
    in the file; it is little more than an array of IMAGE_DATA_DIRECTORY structures
    at the end of the optional header structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Each data directory structure specifies the size and relative virtual address
    of the directory.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the array is set to IMAGE_NUMBEROF_DIRECTORY_ENTRIES, which is equal
    to 0x10\. The Windows loader ignores any NumberOfRvaAndSizes greater than 0x10,
    because anything larger will not fit in the DataDirectory array.
  prefs: []
  type: TYPE_NORMAL
- en: OllyDbg follows the standard and uses NumberOfRvaAndSizes no matter what.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, setting the size of the array to a value greater than 0x10
  prefs: []
  type: TYPE_NORMAL
- en: (like 0x99) will cause OllyDbg to generate a pop-up window to the user before
    exiting the program.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to overcome this technique is to manually modify the PE header
    and set the NumberOfRvaAndSizes to 0x10 using a hex editor or PE
  prefs: []
  type: TYPE_NORMAL
- en: Explorer. Or, of course, you can use a debugger that is not vulnerable to this
    technique, such as WinDbg or OllyDbg 2.0\.
  prefs: []
  type: TYPE_NORMAL
- en: Another PE header trick involves section headers, causing OllyDbg to crash during
    loading with the error “File contains too much data.” (WinDbg and OllyDbg 2.0
    are not vulnerable to this technique.) Sections contain the content of the file,
    including code, data, resources, and other information.
  prefs: []
  type: TYPE_NORMAL
- en: Each section has a header in the form of an IMAGE_SECTION_HEADER structure.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-6 shows a subset of this structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**364**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**“.text”**'
  prefs: []
  type: TYPE_NORMAL
- en: VirtualSize
  prefs: []
  type: TYPE_NORMAL
- en: 00004C52h
  prefs: []
  type: TYPE_NORMAL
- en: Location to virtually
  prefs: []
  type: TYPE_NORMAL
- en: VirtualAddress
  prefs: []
  type: TYPE_NORMAL
- en: 00401000h
  prefs: []
  type: TYPE_NORMAL
- en: load this section
  prefs: []
  type: TYPE_NORMAL
- en: SizeOfRawData
  prefs: []
  type: TYPE_NORMAL
- en: 77777777h
  prefs: []
  type: TYPE_NORMAL
- en: 77777777h is
  prefs: []
  type: TYPE_NORMAL
- en: Location of raw data
  prefs: []
  type: TYPE_NORMAL
- en: invalid!
  prefs: []
  type: TYPE_NORMAL
- en: PointerToRawData
  prefs: []
  type: TYPE_NORMAL
- en: 00000400h
  prefs: []
  type: TYPE_NORMAL
- en: in PE file
  prefs: []
  type: TYPE_NORMAL
- en: PointerToRelocations
  prefs: []
  type: TYPE_NORMAL
- en: 00000000h
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-6: PE IMAGE_SECTION_HEADER structure*'
  prefs: []
  type: TYPE_NORMAL
- en: The elements of interest are VirtualSize and the SizeOfRawData. According to
    the Windows PE specification, VirtualSize should contain the total size of the
    section when loaded into memory, and SizeOfRawData should contain the size of
    data on disk. The Windows loader uses the smaller of VirtualSize and SizeOfRawData
    to map the section data into memory. If the SizeOfRawData is larger than VirtualSize,
    only VirtualSize data is copied into memory; the rest is ignored. Because OllyDbg
    uses only the SizeOfRawData, setting the SizeofRawData to something large like
    0x77777777, will cause OllyDbg to crash.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to overcome this anti-debugging technique is to manually modify
    the PE header and set the SizeOfRawData using a hex editor to change the value
    to be close to VirtualSize. (Note that, according to the specification, this value
    must be a multiple of the FileAlignment value from the IMAGE_OPTIONAL_HEADER).
    PE Explorer is a great program to use for this purpose because it is not fooled
    by a large value for SizeofRawData.
  prefs: []
  type: TYPE_NORMAL
- en: '***The OutputDebugString Vulnerability***'
  prefs: []
  type: TYPE_NORMAL
- en: Malware often attempts to exploit a format string vulnerability in version 1.1
  prefs: []
  type: TYPE_NORMAL
- en: of OllyDbg, by providing a string of %s as a parameter to OutputDebugString
    to cause OllyDbg to crash. Beware of suspicious calls like OutputDebugString ("%s%s%s%s%s%s%s%s%s%s%s%s%s%s").
    If this call executes, your debugger will crash.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced you to some popular anti-debugging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: It takes patience and perseverance to learn to recognize and bypass anti-debugging
    techniques. Be sure to take notes during your analysis and remember the location
    of any anti-debugging techniques and how you bypass them; doing so will help you
    if you need to restart the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: Most anti-debugging techniques can be spotted using common sense, while debugging
    a process slowly. For example, if you see code terminating prematurely at a conditional
    jump, that might hint at an anti-debugging Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**365**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: technique. Most popular anti-debugging techniques involve accessing fs:[30h],
    calling a Windows API call, or performing a timing check.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as with all malware analysis, the best way to learn to thwart anti-debugging
    techniques is by continuing to reverse and study malware.
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors are always looking for new ways to thwart debuggers and to keep
    malware analysts like you on your toes.
  prefs: []
  type: TYPE_NORMAL
- en: '**366**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**L A B S**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 16-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in *Lab16-01.exe* using a debugger. This is the same
    malware as *Lab09-01.exe*, with added anti-debugging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Which anti-debugging techniques does this malware employ?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when each anti-debugging technique succeeds?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: How can you get around these anti-debugging techniques?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: How do you manually change the structures checked during runtime?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Which OllyDbg plug-in will protect you from the anti-debugging techniques used
    by this malware?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 16-2**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware found in *Lab16-02.exe* using a debugger. The goal of this
    lab is to figure out the correct password. The malware does not drop a malicious
    payload.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you run *Lab16-02.exe* from the command line?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you run *Lab16-02.exe* and guess the command-line parameter?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the command-line password?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Load *Lab16-02.exe* into IDA Pro. Where in the main function is strncmp found?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you load this malware into OllyDbg using the default settings?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: What is unique about the PE structure of *Lab16-02.exe*?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where is the callback located? (Hint: Use CTRL-E in IDA Pro.) 8\.'
  prefs: []
  type: TYPE_NORMAL
- en: Which anti-debugging technique is the program using to terminate immediately
    in the debugger and how can you avoid this check?
  prefs: []
  type: TYPE_NORMAL
- en: 9\.
  prefs: []
  type: TYPE_NORMAL
- en: What is the command-line password you see in the debugger after you disable
    the anti-debugging technique?
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Does the password found in the debugger work on the command line?
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Which anti-debugging techniques account for the different passwords in
    the debugger and on the command line, and how can you protect against them?
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**367**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lab 16-3**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the malware in *Lab16-03.exe* using a debugger. This malware is similar
    to *Lab09-02.exe*, with certain modifications, including the introduction of anti-debugging
    techniques. If you get stuck, see Lab 9-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '***Questions***'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Which strings do you see when using static analysis on the binary?
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you run this binary?
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: How must you rename the sample in order for it to run properly?
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Which anti-debugging techniques does this malware employ?
  prefs: []
  type: TYPE_NORMAL
- en: 5\.
  prefs: []
  type: TYPE_NORMAL
- en: For each technique, what does the malware do if it determines it is running
    in a debugger?
  prefs: []
  type: TYPE_NORMAL
- en: 6\.
  prefs: []
  type: TYPE_NORMAL
- en: Why are the anti-debugging techniques successful in this malware?
  prefs: []
  type: TYPE_NORMAL
- en: 7\.
  prefs: []
  type: TYPE_NORMAL
- en: What domain name does this malware use?
  prefs: []
  type: TYPE_NORMAL
- en: '**368**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**A N T I - V I R T U A L M A C H I N E**'
  prefs: []
  type: TYPE_NORMAL
- en: '**T E C H N I Q U E S**'
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors sometimes use anti-virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: (anti-VM) techniques to thwart attempts at analysis.
  prefs: []
  type: TYPE_NORMAL
- en: With these techniques, the malware attempts to detect
  prefs: []
  type: TYPE_NORMAL
- en: whether it is being run inside a virtual machine. If a
  prefs: []
  type: TYPE_NORMAL
- en: virtual machine is detected, it can act differently or
  prefs: []
  type: TYPE_NORMAL
- en: simply not run. This can, of course, cause problems
  prefs: []
  type: TYPE_NORMAL
- en: for the analyst.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-VM techniques are most commonly found in malware that is widely deployed,
    such as bots, scareware, and spyware (mostly because honeypots often use virtual
    machines and because this malware typically targets the average user’s machine,
    which is unlikely to be running a virtual machine).
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of anti-VM malware has been going down recently, and this can
    be attributed to the great increase in the usage of virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, malware authors have used anti-VM techniques because they thought
    only analysts would be running the malware in a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: However, today both administrators and users use virtual machines in order to
    make it easy to rebuild a machine (rebuilding had been a tedious process, but
    virtual machines save time by allowing you to go back to a snapshot).
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors are starting to realize that just because a machine is a virtual
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 87](index-403_1.png)'
  prefs: []
  type: TYPE_IMG
- en: machine does not necessarily mean that it isn’t a valuable victim. As virtualization
    continues to grow, anti-VM techniques will probably become even less common.
  prefs: []
  type: TYPE_NORMAL
- en: Because anti-VM techniques typically target VMware, in this chapter, we’ll focus
    on anti-VMware techniques. We’ll examine the most common techniques and how to
    defeat them by tweaking a couple of settings, removing software, or patching an
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Artifacts**'
  prefs: []
  type: TYPE_NORMAL
- en: The VMware environment leaves many artifacts on the system, especially when
    VMware Tools is installed. Malware can use these artifacts, which are present
    in the filesystem, registry, and process listing, to detect VMware.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Figure 17-1 shows the process listing for a standard VMware image
    with VMware Tools installed. Notice that three VMware processes are running: *VMwareService.exe*,
    *VMwareTray.exe*, and *VMwareUser.exe*. Any one of these can be found by malware
    as it searches the process listing for the VMware string.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 17-1: Process listing on a VMware image with*'
  prefs: []
  type: TYPE_NORMAL
- en: '*VMware Tools running*'
  prefs: []
  type: TYPE_NORMAL
- en: '*VMwareService.exe* runs the VMware Tools Service as a child of *services.exe*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be identified by searching the registry for services installed on a
    machine or by listing services using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: C:\> **net start | findstr VMware**
  prefs: []
  type: TYPE_NORMAL
- en: VMware Physical Disk Helper Service
  prefs: []
  type: TYPE_NORMAL
- en: VMware Tools Service
  prefs: []
  type: TYPE_NORMAL
- en: '**370**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The VMware installation directory *C:\Program Files\VMware\VMware Tools* may
    also contain artifacts, as can the registry. A quick search for “VMware”
  prefs: []
  type: TYPE_NORMAL
- en: in a virtual machine’s registry might find keys like the following, which are
    entries that include information about the virtual hard drive, adapters, and virtual
    mouse.
  prefs: []
  type: TYPE_NORMAL
- en: '[HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id
    0\Logical Unit Id 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '"Identifier"="VMware Virtual IDE Hard Drive"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Type"="DiskPeripheral"'
  prefs: []
  type: TYPE_NORMAL
- en: '[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0000]'
  prefs: []
  type: TYPE_NORMAL
- en: '"DeviceDesc"="VMware Accelerated AMD PCNet Adapter"'
  prefs: []
  type: TYPE_NORMAL
- en: '"DisplayName"="VMware Accelerated AMD PCNet Adapter"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mfg"="VMware, Inc."'
  prefs: []
  type: TYPE_NORMAL
- en: '"ProviderName"="VMware, Inc."'
  prefs: []
  type: TYPE_NORMAL
- en: '[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{4D36E96F-E325-11CE-BFC1-08002BE10318}\0000]'
  prefs: []
  type: TYPE_NORMAL
- en: '"LocationInformationOverride"="plugged into PS/2 mouse port"'
  prefs: []
  type: TYPE_NORMAL
- en: '"InfPath"="oem13.inf"'
  prefs: []
  type: TYPE_NORMAL
- en: '"InfSection"="VMMouse"'
  prefs: []
  type: TYPE_NORMAL
- en: '"ProviderName"="VMware, Inc."'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in Chapter 2, you can connect your virtual machine to a network
    in a variety of ways, all of which allow the virtual machine to have its own virtual
    network interface card (NIC). Because VMware must virtualize the NIC, it needs
    to create a MAC address for the virtual machine, and, depending on its configuration,
    the network adapter can also identify VMware usage.
  prefs: []
  type: TYPE_NORMAL
- en: The first three bytes of a MAC address are typically specific to the vendor,
    and MAC addresses starting with 00:0C:29 are associated with VMware.
  prefs: []
  type: TYPE_NORMAL
- en: VMware MAC addresses typically change from version to version, but all that
    a malware author needs to do is to check the virtual machine’s MAC address for
    VMware values.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can also detect VMware by other hardware, such as the mother-board.
    If you see malware checking versions of hardware, it might be trying to detect
    VMware. Look for the code that checks MAC addresses or hardware versions, and
    patch the code to avoid the check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common VMware artifacts can be easily eliminated by uninstalling VMware
    Tools or by trying to stop the VMware Tools Service with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**net stop "VMware Tools Service"**'
  prefs: []
  type: TYPE_NORMAL
- en: You may also be able to prevent malware from searching for artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you find a single VMware-related string in malware—such as net
    start | findstr VMware, VMMouse, VMwareTray.exe, or VMware Virtual IDE Hard Drive—you
    know that the malware is attempting to detect VMware artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to find this code easily in IDA Pro using the references
    to the strings. Once you find it, patch it to avoid detection while ensuring that
    the malware will function properly.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Virtual Machine Techniques
  prefs: []
  type: TYPE_NORMAL
- en: '**371**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Bypassing VMware Artifact Searching***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defeating malware that searches for VMware artifacts is often a simple two-step
    process: identify the check and then patch it. For example, say we run strings
    against the malware *vmt.exe*. We notice that the binary contains the string "VMwareTray.exe",
    and we discover a cross-reference from the code to this string. We follow this
    cross-reference to 0x401098, as shown in the disassembly in Listing 17-1 at .'
  prefs: []
  type: TYPE_NORMAL
- en: 0040102D call ds:**CreateToolhelp32Snapshot**
  prefs: []
  type: TYPE_NORMAL
- en: 00401033 lea ecx, [ebp+processentry32]
  prefs: []
  type: TYPE_NORMAL
- en: 00401039 mov ebx, eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040103B push ecx ; lppe
  prefs: []
  type: TYPE_NORMAL
- en: 0040103C push ebx ; hSnapshot
  prefs: []
  type: TYPE_NORMAL
- en: 0040103D mov [ebp+processentry32.dwSize], 22Ch
  prefs: []
  type: TYPE_NORMAL
- en: 00401047 call ds:Process32FirstW
  prefs: []
  type: TYPE_NORMAL
- en: 0040104D mov esi, ds:WideCharToMultiByte
  prefs: []
  type: TYPE_NORMAL
- en: 00401053 mov edi, ds:strncmp
  prefs: []
  type: TYPE_NORMAL
- en: 00401059 lea esp, [esp+0]
  prefs: []
  type: TYPE_NORMAL
- en: '00401060 loc_401060: ; CODE XREF: sub_401000+B7j 00401060 push 0 ; lpUsedDefaultChar'
  prefs: []
  type: TYPE_NORMAL
- en: 00401062 push 0 ; lpDefaultChar
  prefs: []
  type: TYPE_NORMAL
- en: 00401064 push 104h ; cbMultiByte
  prefs: []
  type: TYPE_NORMAL
- en: 00401069 lea edx, [ebp+Str1]
  prefs: []
  type: TYPE_NORMAL
- en: 0040106F push edx ; lpMultiByteStr
  prefs: []
  type: TYPE_NORMAL
- en: 00401070 push 0FFFFFFFFh ; cchWideChar
  prefs: []
  type: TYPE_NORMAL
- en: 00401072 lea eax, [ebp+processentry32.szExeFile]
  prefs: []
  type: TYPE_NORMAL
- en: 00401078 push eax ; lpWideCharStr
  prefs: []
  type: TYPE_NORMAL
- en: 00401079 push 0 ; dwFlags
  prefs: []
  type: TYPE_NORMAL
- en: 0040107B push 3 ; CodePage
  prefs: []
  type: TYPE_NORMAL
- en: 0040107D call esi ; WideCharToMultiByte
  prefs: []
  type: TYPE_NORMAL
- en: 0040107F lea eax, [ebp+Str1]
  prefs: []
  type: TYPE_NORMAL
- en: 00401085 lea edx, [eax+1]
  prefs: []
  type: TYPE_NORMAL
- en: '00401088 loc_401088: ; CODE XREF: sub_401000+8Dj 00401088 mov cl, [eax]'
  prefs: []
  type: TYPE_NORMAL
- en: 0040108A inc eax
  prefs: []
  type: TYPE_NORMAL
- en: 0040108B test cl, cl
  prefs: []
  type: TYPE_NORMAL
- en: 0040108D jnz short loc_401088
  prefs: []
  type: TYPE_NORMAL
- en: 0040108F sub eax, edx
  prefs: []
  type: TYPE_NORMAL
- en: 00401091 push eax ; MaxCount
  prefs: []
  type: TYPE_NORMAL
- en: 00401092 lea ecx, [ebp+Str1]
  prefs: []
  type: TYPE_NORMAL
- en: 00401098 push offset Str2 ; " **VMwareTray.exe**" 
  prefs: []
  type: TYPE_NORMAL
- en: 0040109D push ecx ; Str1
  prefs: []
  type: TYPE_NORMAL
- en: 0040109E call edi ; **strncmp** 
  prefs: []
  type: TYPE_NORMAL
- en: 004010A0 add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: 004010A3 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004010A5 jz short loc_4010C0
  prefs: []
  type: TYPE_NORMAL
- en: 004010A7 lea edx, [ebp+processentry32]
  prefs: []
  type: TYPE_NORMAL
- en: 004010AD push edx ; lppe
  prefs: []
  type: TYPE_NORMAL
- en: 004010AE push ebx ; hSnapshot
  prefs: []
  type: TYPE_NORMAL
- en: 004010AF call ds:**Process32NextW**
  prefs: []
  type: TYPE_NORMAL
- en: 004010B5 test eax, eax
  prefs: []
  type: TYPE_NORMAL
- en: 004010B7 jnz short loc_401060
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**372**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '004010C0 loc_4010C0: ; CODE XREF: sub_401000+A5j 004010C0 push 0 ; Code'
  prefs: []
  type: TYPE_NORMAL
- en: 004010C2 call ds:exit
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-1: Disassembly snippet from* vmt.exe *showing VMware artifact detection*
    Analyzing this code further, we notice that it is scanning the process listing
    with functions like CreateToolhelp32Snapshot, Process32Next, and so on. The strncmp
    at  is comparing the VMwareTray.exe string with the result of converting processentry32.szExeFile
    to ASCII to determine if the process name is in the process listing. If VMwareTray.exe
    is discovered in the process listing, the program will immediately terminate,
    as seen at 0x4010c2\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to avoid this detection:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Patch the binary while debugging so that the jump at 0x4010a5 will never be
    taken.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Use a hex editor to modify the VMwareTray.exe string to read XXXareTray.exe
    to make the comparison fail since this is not a valid process string.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Uninstall VMware Tools so that *VMwareTray.exe* will no longer run.
  prefs: []
  type: TYPE_NORMAL
- en: '***Checking for Memory Artifacts***'
  prefs: []
  type: TYPE_NORMAL
- en: VMware leaves many artifacts in memory as a result of the virtualization process.
    Some are critical processor structures, which, because they are either moved or
    changed on a virtual machine, leave recognizable footprints.
  prefs: []
  type: TYPE_NORMAL
- en: One technique commonly used to detect memory artifacts is a search through physical
    memory for the string VMware, which we have found may detect several hundred instances.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerable Instructions**'
  prefs: []
  type: TYPE_NORMAL
- en: The virtual machine monitor program monitors the virtual machine’s execution.
    It runs on the host operating system to present the guest operating system with
    a virtual platform. It also has a couple of security weaknesses that can allow
    malware to detect virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The x86 instruction-related issues in virtual machines discussed in this section
    were* *originally outlined in the USENIX 2000 paper “Analysis of the Intel Pentium’s
    Ability* *to Support a Secure Virtual Machine Monitor” by John Robin and Cynthia
    Irvine.*'
  prefs: []
  type: TYPE_NORMAL
- en: In kernel mode, VMware uses binary translation for emulation. Certain privileged
    instructions in kernel mode are interpreted and emulated, so they don’t run on
    the physical processor. Conversely, in user mode, the code runs directly on the
    processor, and nearly every instruction that interacts with hardware is either
    privileged or generates a kernel trap or interrupt. VMware catches all the interrupts
    and processes them, so that the virtual machine still thinks it is a regular machine.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Virtual Machine Techniques
  prefs: []
  type: TYPE_NORMAL
- en: '**373**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Some instructions in x86 access hardware-based information but don’t generate
    interrupts. These include sidt, sgdt, sldt, and cpuid, among others.
  prefs: []
  type: TYPE_NORMAL
- en: In order to virtualize these instructions properly, VMware would need to perform
    binary translation on every instruction (not just kernel-mode instructions), resulting
    in a huge performance hit. To avoid huge performance hits from doing full-instruction
    emulation, VMware allows certain instructions to execute without being properly
    virtualized. Ultimately, this means that certain instruction sequences will return
    different results when running under VMware than they will on native hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The processor uses certain key structures and tables, which are loaded at different
    offsets as a side effect of this lack of full translation. The *interrupt* *descriptor
    table* *(IDT)* is a data structure internal to the CPU, which is used by the operating
    system to determine the correct response to interrupts and exceptions. Under x86,
    all memory accesses pass through either the *global* *descriptor table (GDT)*
    or the *local descriptor table (LDT)*. These tables contain segment descriptors
    that provide access details for each segment, including the base address, type,
    length, access rights, and so on. IDT (IDTR), GDT
  prefs: []
  type: TYPE_NORMAL
- en: (GDTR), and LDT (LDTR) are the internal registers that contain the address and
    size of these respective tables.
  prefs: []
  type: TYPE_NORMAL
- en: Note that operating systems do not need to utilize these tables. For example,
    Windows implements a flat memory model and uses only the GDT
  prefs: []
  type: TYPE_NORMAL
- en: by default. It does not use the LDT.
  prefs: []
  type: TYPE_NORMAL
- en: Three sensitive instructions—sidt, sgdt, and sldt—read the location of these
    tables, and all store the respective register into a memory location.
  prefs: []
  type: TYPE_NORMAL
- en: While these instructions are typically used by the operating system, they are
    not privileged in the x86 architecture, and they can be executed from user space.
  prefs: []
  type: TYPE_NORMAL
- en: An x86 processor has only three registers to store the locations of these three
    tables. Therefore, these registers must contain values valid for the underlying
    host operating system and will diverge from values expected by the virtualized
    (guest) operating system. Since the sidt, sgdt, and sldt instructions can be invoked
    at any time by user-mode code without being trapped and properly virtualized by
    VMware, they can be used to detect its presence.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Red Pill Anti-VM Technique***'
  prefs: []
  type: TYPE_NORMAL
- en: Red Pill is an anti-VM technique that executes the sidt instruction to grab
    the value of the IDTR register. The virtual machine monitor must relocate the
    guest’s IDTR to avoid conflict with the host’s IDTR. Since the virtual machine
    monitor is not notified when the virtual machine runs the sidt instruction, the
    IDTR for the virtual machine is returned. The Red Pill tests for this discrepancy
    to detect the usage of VMware.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 17-2 shows how Red Pill might be used by malware.
  prefs: []
  type: TYPE_NORMAL
- en: push ebp
  prefs: []
  type: TYPE_NORMAL
- en: mov ebp, esp
  prefs: []
  type: TYPE_NORMAL
- en: sub esp, 454h
  prefs: []
  type: TYPE_NORMAL
- en: push ebx
  prefs: []
  type: TYPE_NORMAL
- en: push esi
  prefs: []
  type: TYPE_NORMAL
- en: '**374**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: push edi
  prefs: []
  type: TYPE_NORMAL
- en: push 8 ; Size
  prefs: []
  type: TYPE_NORMAL
- en: push 0 ; Val
  prefs: []
  type: TYPE_NORMAL
- en: lea eax, [ebp+Dst]
  prefs: []
  type: TYPE_NORMAL
- en: push eax ; Dst
  prefs: []
  type: TYPE_NORMAL
- en: call _memset
  prefs: []
  type: TYPE_NORMAL
- en: add esp, 0Ch
  prefs: []
  type: TYPE_NORMAL
- en: lea eax, [ebp+Dst]
  prefs: []
  type: TYPE_NORMAL
- en:  **sidt** fword ptr [eax]
  prefs: []
  type: TYPE_NORMAL
- en: mov al, [eax+5]
  prefs: []
  type: TYPE_NORMAL
- en: cmp al, 0FFh
  prefs: []
  type: TYPE_NORMAL
- en: jnz short loc_401E19
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-2: Red Pill in malware*'
  prefs: []
  type: TYPE_NORMAL
- en: The malware issues the sidt instruction at , which stores the contents of IDTR
    into the memory location pointed to by EAX. The IDTR is 6 bytes, and the fifth
    byte offset contains the start of the base memory address. That fifth byte is
    compared to 0xFF, the VMware signature.
  prefs: []
  type: TYPE_NORMAL
- en: Red Pill succeeds only on a single-processor machine. It won’t work consistently
    against multicore processors because each processor (guest or host) has an IDT
    assigned to it. Therefore, the result of the sidt instruction can vary, and the
    signature used by Red Pill can be unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: To thwart this technique, run on a multicore processor machine or simply NOP-out
    the sidt instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the No Pill Technique***'
  prefs: []
  type: TYPE_NORMAL
- en: The sgdt and sldt instruction technique for VMware detection is commonly known
    as No Pill. Unlike Red Pill, No Pill relies on the fact that the LDT
  prefs: []
  type: TYPE_NORMAL
- en: 'structure is assigned to a processor, not an operating system. And because
    Windows does not normally use the LDT structure, but VMware provides virtual support
    for it, the table will differ predictably: The LDT location on the host machine
    will be zero, and on the virtual machine, it will be nonzero. A simple check for
    zero against the result of the sldt instruction does the trick.'
  prefs: []
  type: TYPE_NORMAL
- en: The sldt method can be subverted in VMware by disabling acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, select **VM****Settings****Processors** and check the **Disable
    Acceleration** box. No Pill solves this acceleration issue by using the smsw instruction
    if the sldt method fails. This method involves inspecting the undocumented high-order
    bits returned by the smsw instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '***Querying the I/O Communication Port***'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most popular anti-VMware technique currently in use is that of querying
    the I/O communication port. This technique is frequently encountered in worms
    and bots, such as the Storm worm and Phatbot.
  prefs: []
  type: TYPE_NORMAL
- en: VMware uses virtual I/O ports for communication between the virtual machine
    and the host operating system to support functionality like copy and paste between
    the two systems. The port can be queried and compared with a magic number to identify
    the use of VMware.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Virtual Machine Techniques
  prefs: []
  type: TYPE_NORMAL
- en: '**375**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The success of this technique depends on the x86 in instruction, which copies
    data from the I/O port specified by the source operand to a memory location specified
    by the destination operand. VMware monitors the use of the in instruction and
    captures the I/O destined for the communication channel port 0x5668 (VX). Therefore,
    the second operand needs to be loaded with VX in order to check for VMware, which
    happens only when the EAX
  prefs: []
  type: TYPE_NORMAL
- en: register is loaded with the magic number 0x564D5868 (VMXh). ECX must be loaded
    with a value corresponding to the action you wish to perform on the port. The
    value 0xA means “get VMware version type,” and 0x14 means “get the memory size.”
    Both can be used to detect VMware, but 0xA is more popular because it may determine
    the VMware version.
  prefs: []
  type: TYPE_NORMAL
- en: Phatbot, also known as Agobot, is a botnet that is simple to use. One of its
    features is its built-in support of the I/O communication port technique, as shown
    in Listing 17-3\.
  prefs: []
  type: TYPE_NORMAL
- en: 004014FA push eax
  prefs: []
  type: TYPE_NORMAL
- en: 004014FB push ebx
  prefs: []
  type: TYPE_NORMAL
- en: 004014FC push ecx
  prefs: []
  type: TYPE_NORMAL
- en: 004014FD push edx
  prefs: []
  type: TYPE_NORMAL
- en: 004014FE mov eax, 'VMXh' 
  prefs: []
  type: TYPE_NORMAL
- en: 00401503 mov ebx, [ebp+var_1C]
  prefs: []
  type: TYPE_NORMAL
- en: 00401506 mov ecx, 0xA
  prefs: []
  type: TYPE_NORMAL
- en: 00401509 mov dx, 'VX' 
  prefs: []
  type: TYPE_NORMAL
- en: 0040150E in eax, dx
  prefs: []
  type: TYPE_NORMAL
- en: 0040150F mov [ebp+var_24], eax
  prefs: []
  type: TYPE_NORMAL
- en: 00401512 mov [ebp+var_1C], ebx
  prefs: []
  type: TYPE_NORMAL
- en: 00401515 mov [ebp+var_20], ecx
  prefs: []
  type: TYPE_NORMAL
- en: 00401518 mov [ebp+var_28], edx
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 0040153E mov eax, [ebp+var_1C]
  prefs: []
  type: TYPE_NORMAL
- en: 00401541 cmp eax, 'VMXh' 
  prefs: []
  type: TYPE_NORMAL
- en: 00401546 jnz short loc_40155C
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-3: Phatbot’s VMware detection*'
  prefs: []
  type: TYPE_NORMAL
- en: The malware first loads the magic number 0x564D5868 (VMXh) into the EAX
  prefs: []
  type: TYPE_NORMAL
- en: register at . Next, it loads the local variable var_1c into EBX, a memory address
    that will return any reply from VMware. ECX is loaded with the value 0xA to get
    the VMware version type. At , 0x5668 (VX) is loaded into DX, to be used in the
    following in instruction to specify the VMware I/O communication port.
  prefs: []
  type: TYPE_NORMAL
- en: Upon execution, the in instruction is trapped by the virtual machine and emulated
    to execute it. The in instruction uses parameters of EAX (magic value), ECX (operation),
    and EBX (return information). If the magic value matches VMXh and the code is
    running in a virtual machine, the virtual machine monitor will echo that back
    in the memory location specified by the EBX
  prefs: []
  type: TYPE_NORMAL
- en: register.
  prefs: []
  type: TYPE_NORMAL
- en: The check at  determines whether the code is being run in a virtual machine.
    Since the get version type option is selected, the ECX register will contain the
    type of VMware (1=Express, 2=ESX, 3=GSX, and 4=Workstation).
  prefs: []
  type: TYPE_NORMAL
- en: '**376**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to overcome this technique is to NOP-out the in instruction
    or to patch the conditional jump to allow it regardless of the outcome of the
    comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the str Instruction***'
  prefs: []
  type: TYPE_NORMAL
- en: The str instruction retrieves the segment selector from the task register, which
    points to the task state segment (TSS) of the currently executing task.
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors can use the str instruction to detect the presence of a virtual
    machine, since the values returned by the instruction may differ on the virtual
    machine versus a native system. (This technique does not work on multiprocessor
    hardware.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17-2 shows the str instruction at 0x401224 in malware known as *SNG.exe*.
    This loads the TSS into the 4 bytes: var_1 through var_4, as labeled by IDA Pro.
    Two comparisons are made at 0x40125A and 0x401262 to determine if VMware is detected.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Anti-VM x86 Instructions***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve just reviewed the most common instructions used by malware to employ
    anti-VM techniques. These instructions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: sidt
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: sgdt
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: sldt
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: smsw
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: in (with the second operand set to VX)
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: cpuid
  prefs: []
  type: TYPE_NORMAL
- en: Malware will not typically run these instructions unless it is performing VMware
    detection, and avoiding this detection can be as easy as patching the binary to
    avoid calling these instructions. These instructions are basically useless if
    executed in user mode, so if you see them, they’re likely part of anti-VMware
    code. VMware describes roughly 20 instructions as “not virtualizable,” of which
    the preceding are the most commonly used by malware.
  prefs: []
  type: TYPE_NORMAL
- en: '***Highlighting Anti-VM in IDA Pro***'
  prefs: []
  type: TYPE_NORMAL
- en: You can search for the instructions listed in the previous section in IDA Pro
    using the IDAPython script shown in Listing 17-4\. This script looks for the instructions,
    highlights any in red, and prints the total number of anti-VM
  prefs: []
  type: TYPE_NORMAL
- en: instructions found in IDA’s output window.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17-2 shows a partial result of running this script against *SNG.exe*
    with one location (str at 0x401224) highlighted by the bar. Examining the highlighted
    code in IDA Pro will allow you to quickly see if the instruction found is involved
    in an anti-VM technique. Further investigation shows that the str instruction
    is being used to detect VMware.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Virtual Machine Techniques
  prefs: []
  type: TYPE_NORMAL
- en: '**377**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 88](index-411_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: The str anti-VM technique in* SNG.exe from idautils import *'
  prefs: []
  type: TYPE_NORMAL
- en: from idc import *
  prefs: []
  type: TYPE_NORMAL
- en: heads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))
  prefs: []
  type: TYPE_NORMAL
- en: antiVM = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in heads:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (GetMnem(i) == "sidt" or GetMnem(i) == "sgdt" or GetMnem(i) == "sldt" or
    GetMnem(i) == "smsw" or GetMnem(i) == "str" or GetMnem(i) == "in" or GetMnem(i)
    == "cpuid"):'
  prefs: []
  type: TYPE_NORMAL
- en: antiVM.append(i)
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Number of potential Anti-VM instructions: %d" % (len(antiVM)) for i
    in antiVM:'
  prefs: []
  type: TYPE_NORMAL
- en: SetColor(i, CIC_ITEM, 0x0000ff)
  prefs: []
  type: TYPE_NORMAL
- en: 'Message("Anti-VM: %08x\n" % i)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 17-4: IDA Pro script to find anti-VM instructions* **378**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using ScoopyNG***'
  prefs: []
  type: TYPE_NORMAL
- en: 'ScoopyNG ( *http://www.trapkit.de/*) is a free VMware detection tool that implements
    seven different checks for a virtual machine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The first three checks look for the sidt, sgdt, and sldt (Red Pill and No Pill)
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The fourth check looks for str.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The fifth and sixth use the backdoor I/O port 0xa and 0x14 options, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: The seventh check relies on a bug in older VMware versions running in emulation
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: For a disassembled version of ScoopyNG’s fourth check, see Figure 17-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tweaking Settings**'
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed a number of ways to thwart VMware detection throughout this
    chapter, including patching code, removing VMware Tools, changing VMware settings,
    and using a multiprocessor machine.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a number of undocumented features in VMware that can help mitigate
    anti-VMware techniques. For example, placing the options in Listing 17-5 into
    the virtual machine’s *.vmx* file will make the virtual machine less detectable.
  prefs: []
  type: TYPE_NORMAL
- en: isolation.tools.getPtrLocation.disable = "TRUE"
  prefs: []
  type: TYPE_NORMAL
- en: isolation.tools.setPtrLocation.disable = "TRUE"
  prefs: []
  type: TYPE_NORMAL
