- en: '![](../images/355-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**A DB - TO - FILE UTILITY**](toc.html#app4)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This appendix describes tbl2filed, a daemon that allows you to use SQL to read
    and write values in Linux configuration files as if those values were in a database
    instead of a file. This utility is convenient if you want to use RTA for new daemons
    and want to keep the same database metaphor for reading and writing values into
    traditional, non-RTA configuration files. Topics discussed in this appendix include:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage and API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**Overview**](toc.html#app4.1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the tbl2filed daemon is to allow your UI programs to use a PostgreSQL
    library to read or write (SELECT or UPDATE) an RTA table and have an underlying
    system configuration file scanned or modified as part of the SELECT or UPDATE.
    This utility tries to mimic the common tasks of:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing values in a configuration file (SELECT value . . .)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing the values in a configuration file (UPDATE value . . .)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomically writing a file to disk (UPDATE tbl2file SET do_commit . . .)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restarting a service if necessary (UPDATE tbl2file SET do_script . . .)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tbl2filed daemon allows you to read and write configuration files by using
    PostgreSQL commands on two RTA tables. The first table, tbl2file, describes the
    files managed by the daemon, and the second table, tbl2field, describes the managed
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Figure D-1 illustrates how this utility maps two tables into text fields inside
    of disk files.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/356-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure D-1: Use SQL to access data in files.*'
  prefs: []
  type: TYPE_NORMAL
- en: This daemon also lets us put all of the restart scripts for system services
    in a single file and use a single method (a write callback) to invoke them. This
    approach might help security because it allows a non-privileged UI program to
    safely change the system configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Table Definitions**](toc.html#app4.2)'
  prefs: []
  type: TYPE_NORMAL
- en: An example is given later in this appendix, but for that example to make sense,
    you need some understanding of the contents of the two tbl2filed tables. Laddie
    uses tbl2filed to help with the networking configuration, and you may find the
    tables easier to understand by looking at them in a running Laddie system. Boot
    the Laddie CD and follow the tbl2filed link at 192.168.1.11/table_editor/rta/rta_apps.html.
  prefs: []
  type: TYPE_NORMAL
- en: '[***The tbl2file Table***](toc.html#app4.3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The table of managed file information, tbl2file, has the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/357-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The name of the file is the name as seen by the UI. It is also used as part
    of the index into tbl2field table. This can just be shorthand or a mnemonic for
    the file, for example, *resolv.*
  prefs: []
  type: TYPE_NORMAL
- en: The path is the full path to the file, including the filename. For example,
    the name field might be *resolv,* while the path might be */etc/resolv. conf.*
  prefs: []
  type: TYPE_NORMAL
- en: Writing a 1 to the do_commit flag causes the managed file’s values to be written
    back to the disk file. The file is written to a temporary file first and then
    rename() is called to move the temporary file to the destination file. This mechanism
    helps maintain consistency in the system by trying to make a write of the entire
    file as atomic as possible. A SELECT on do_commit always returns a zero.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and parsing the values from a file is expensive in terms of time and
    CPU cycles. Since the files won’t change often, we can improve the system’s responsiveness
    by caching the file’s values in the tbl2field table and only rereading the file
    if it has been modified since the last time we read it. The timestamp marks the
    last time we read and parsed the file; time is measured as the number of seconds
    since the last write. When a UI asks for a value, our daemon compares the mtime
    (time of last modification) in the file’s inode to our time stamp, and either
    rescans the file if necessary or returns the values directly from the fields table,
    if the cached values are still valid.
  prefs: []
  type: TYPE_NORMAL
- en: Setting do_script to 1 starts the script /usr/local/tbl2filed/tbl2script.sh.
    (The script location is set in the tbl2filed Makefile.) The script_parms field
    has a set of space-separated parameters that are passed to the script. The parameters
    are not passed on the command line; rather, they are passed in on standard input
    and parsed into parameters using a cut command. This script is spawned and forgotten—that
    is, we ignore any return value from it. The script is only run by an explicit
    write of 1 to the do_script column, and the column is only used for its write
    callback. A SELECT on this column will always return a zero. Laddie uses this
    script, for example, to restart networking when the user changes the appliance’s
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '[***The tbl2field Table***](toc.html#app4.4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tbl2field table that holds the values for the individual fields and has
    the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/358-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The name is the name of the file and must match the name column in the tbl2file
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The field is the name of the field as seen by all of the UI programs. This is
    always used in a WHERE clause to identify the exact field to read and update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern is a regular expression that, in combination with the skip count,
    uniquely identifies the field in the file. The pattern should include exactly
    one set of parentheses to extract the value from the text of the line. For example,
    to get the first DNS name server from the resolv.conf file, we might use the following
    regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: ^nameserver[ \t]+([0-9\.]+)
  prefs: []
  type: TYPE_NORMAL
- en: The regerr field is nonzero if the pattern can not be parsed as a regular expression.
    It should be necessary to examine regerr only during development.
  prefs: []
  type: TYPE_NORMAL
- en: The skip column tells the daemon how many of the above patterns to skip before
    selecting a line as the source of the value. For example, we’d use a skip value
    of 1 to read the second DNS nameserver from resolv.conf. This would skip over
    one nameserver and read the second one.
  prefs: []
  type: TYPE_NORMAL
- en: The format field is used to reproduce the line of configuration data in the
    target file. We could get this from the regular expression, but having a printf
    format string is a lot easier. If this column is left blank, the field is considered
    a read-only field. Any of the read-only values in /proc or /sys should have a
    blank format field. You can see a good example of a read-only value by looking
    at the uptime field in tbl2field table. For a nameserver line in resolv.conf,
    the format string would be nameserver %s. There’s no need for a \n in the format
    string, since it is added automatically by the print statement.
  prefs: []
  type: TYPE_NORMAL
- en: The value is the current value of the field as a string. Doing a SELECT on this
    column will cause the file to be read and parsed if necessary (see timestamp in
    tbl2file above). If the cached value is still valid, the value is taken directly
    from the table. A write on this column saves the value in the table but does not
    actually write the value to the file; writing a 1 to do_commit does that.
  prefs: []
  type: TYPE_NORMAL
- en: '[**A tbl2filed Example**](toc.html#app4.5)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a complete example by continuing with the nameserver configuration
    for Laddie. The /etc/resolv.conf file on a running Laddie system looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: nameserver 204.117.214.10
  prefs: []
  type: TYPE_NORMAL
- en: nameserver 199.2.252.10
  prefs: []
  type: TYPE_NORMAL
- en: nameserver 65.173.40.10
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to be able to read the first DNS nameserver with a SELECT statement
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: psql -h localhost -p 8885
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM tbl2field where name = "nameserver_1";
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \q
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Similarly, to modify the second DNS server, Laddie uses the following UPDATE
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/359-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can verify the above by booting the Laddie CD, exiting from the frame-buffer
    menu, logging in as root, and executing the commands given above. Be sure to verify
    that the file has been modified after the UPDATE command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the tbl2file and tbl2field configuration that gives us the
    ability to read and write the nameserver IP addresses as if they were in a PostgreSQL
    database. We’ll start by listing the file we want to manage in the tbl2file table:'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE tbl2file SET name=resolv, path=/etc/resolv.conf, script_parms="" LIMIT
    1 OFFSET 0
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to run a script after editing the resolv.conf file, so we can
    leave script_parms blank. You can use either full or relative path names, but
    as a security precaution, it is a good idea to use the full path name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we want to manage the three DNS nameservers. The SQL for this
    is taken from tbl2field.sql (perhaps use the full path, i.e., /opt/laddie/tbl2filed/.
    . .) and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/359-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The pattern recognizes the line with the parameter, and the single set of parentheses
    in the pattern extracts the actual field value. In the above examples, the value
    of a nameserver field must have only the digits zero through nine and/or decimal
    points. The parentheses are not part of the recognition—they are only used to
    extract the field value.
  prefs: []
  type: TYPE_NORMAL
- en: One nice feature of the tbl2filed daemon is that when you write a value to a
    field, the daemon uses the format string to build a copy of what the new configuration
    line will look like. Then it runs the pattern against the new line and rejects
    the update if the pattern doesn’t recognize the new line. In this example, an
    update for a nameserver of 11.22.33.44 would succeed, since it contains the required
    digits and decimal points; however a nameserver update of Bob's fun house would
    fail, since it does not contain the required digits and decimals.
  prefs: []
  type: TYPE_NORMAL
- en: The nameserver example also illustrates the use of the skip column. The primary
    nameserver has skip set to zero, meaning that we use the first line with a matching
    pattern. The secondary nameserver is specified with skip set to 1, meaning we
    skip one matching line and use the second matching line.¹
  prefs: []
  type: TYPE_NORMAL
- en: '[**Security Notes**](toc.html#app4.6)'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you use it, this daemon can either enhance or hurt your system
    security. At first glance, having a daemon that runs with root privileges and
    accepts database connections seems like a bad idea. On the other hand, this might
    allow you to improve security by running only *one* daemon as root and running
    each of the UI programs as a non-root user. This way, if an attacker breaks into
    one of your UI programs, he or she only gains the privileges of that non-root
    user. Compare this to most Linux appliances, in which a UI needs to run as root
    in order to make system changes.
  prefs: []
  type: TYPE_NORMAL
- en: The daemon reads tbl2file.sql and tbl2field.sql when it starts, and then marks
    all of its configuration columns as read-only. Not allowing updates to the managed
    files or script parameters helps security, but it also means that you cannot update
    any part of the configuration after the program starts. You must edit the tbl2file.sql
    and tbl2field.sql files directly before starting the tbl2filed daemon. If you
    must mark any column as read-write to make development easier, be sure to change
    it back to read-only before you ship your product. Also, be sure to protect the
    write privileges on the directory and files with the daemon’s initial configuration.
  prefs: []
  type: TYPE_NORMAL
- en: __________________
  prefs: []
  type: TYPE_NORMAL
- en: ¹ The resolv.conf file is different from most Linux configuration files in that
    switching to or from DHCP as the boot configuration protocol can completely destroy
    any values you’ve previously written into it. The simple solution to this problem
    is to keep a template file and copy it to /etc/resolv.conf when necessary.
  prefs: []
  type: TYPE_NORMAL
