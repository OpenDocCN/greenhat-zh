["```\nLoading file 'C:\\IdaBook\\ch4_example.exe' into database...\n  Detected file format: Portable executable for 80386 (PE)\n    0\\. Creating a new segment  (00401000-0040C000) ... ... OK\n    1\\. Creating a new segment  (0040C000-0040E000) ... ... OK\n    2\\. Creating a new segment  (0040E000-00411000) ... ... OK\n  Reading imports directory...\n    3\\. Creating a new segment  (0040C120-0040E000) ... ... OK\n  Plan  FLIRT signature: Microsoft VisualC 2-10/net runtime\n  autoload.cfg: vc32rtf.sig autoloads mssdk.til\n  Assuming __cdecl calling convention by default\n  main() function at 401070, named \"_main\"\n  Marking typical code sequences...\n  Flushing buffers, please wait...ok\n  File 'C:\\IdaBook\\ch4_example.exe' is successfully loaded into the database.\n  Compiling file 'C:\\Program Files\\IdaPro\\idc\\ida.idc'...\n    Executing function 'main'...\n  Compiling file 'C:\\Program Files\\IdaPro\\idc\\onload.idc'...\n  Executing function 'OnLoad'...\n  IDA is analysing the input file...\n You may start to explore the input file right now.\n  ------------------------------------------------------------------------------\n  Python 2.6.5 (r265:79096, Mar 19 2010, 21:48:26) [MSC v.1500 32 bit (Intel)]\n  IDAPython v1.4.2 final (serial 0) (c) The IDAPython Team\n  <idapython@googlegroups.com>\n  ------------------------------------------------------------------------------\n  Using FLIRT signature: Microsoft VisualC 2-10/net runtime\n  Propagating type information...\n  Function argument information has been propagated\n The initial autoanalysis has been finished.\n```", "```\nmalloc              .text                00BDC260 00000180 R . . . B . .\n```", "```\nLoadLibraryA                          7C801D77 578\n```", "```\n0040E108  GetModuleHandleA         KERNEL32\n```", "```\nName   Start    End      R W X D L Align  Base\n Type   Class  AD es   ss   ds   fs       gs\nUPX0   00401000 00407000 R W X . L para   0001 public CODE   32\n 0000 0000 0001 FFFFFFFF FFFFFFFF\nUPX1   00407000 00408000 R W X . L para   0002 public CODE   32\n 0000 0000 0001 FFFFFFFF FFFFFFFF\nUPX2   00408000 0040803C R W . . L para   0003 public DATA   32\n 0000 0000 0001 FFFFFFFF FFFFFFFF\n.idata 0040803C 00408050 R W . . L para   0003 public XTRN   32\n 0000 0000 0001 FFFFFFFF FFFFFFFF\nUPX2   00408050 00409000 R W . . L para   0003 public DATA   32\n 0000 0000 0001 FFFFFFFF FFFFFFFF\n```", "```\nFile      State     #func  Library name\nvc32rtf   Applied   501    Microsoft VisualC 2-8/net runtime\n```", "```\nAddress          Type       Instruction\n.text:0040104C   BOUNDS     call    eax\n.text:004010B0   BOUNDS     call    eax\n.text:00401108   BOUNDS     call    eax\n.text:00401350   BOUNDS     call    dword ptr [eax]\n.text:004012A0   DECISION   push    ebp\n.text:004012D0   DECISION   push    ebp\n.text:00401560   DECISION   jmp     ds:__set_app_type\n.text:004015F8   DECISION   dd 0FFFFFFFFh\n.text:004015FC   DECISION   dd 0\n```", "```\n.text:0040132B loc_40132B:                   ; CODE XREF: sub_4012E4+B^j\n.text:0040132B       cmp     edx, 0CDh\n.text:00401331       jg      short loc_40134E\n.text:00401333       jz      loc_4013BF\n.text:00401339       sub     edx, 0Ah\n.text:0040133C       jz      short loc_4013A7\n.text:0040133E       sub     edx, 0C1h\n.text:00401344       jz      short loc_4013AF\n.text:00401346       dec     edx\n.text:00401347       jz      short loc_4013B7\n.text:00401349       jmp     loc_4013DD   ; default\n.text:00401349                              ; jumptable 00401300 case 0\n.text:0040134E ; ----------------------------------------------------------\n.text:0040134E\n.text:0040134E loc_40134E:                   ; CODE XREF: sub_4012E4+4D^j\n```", "```\n.data:00409013       db    4\n.data:00409014       dd 4037B0h\n.data:00409018       db    0\n.data:00409019       db  0Ah\n.data:0040901A       dd 404590h\n.data:0040901E       db    0\n.data:0040901F       db  0Ah\n.data:00409020       dd 404DA8h\n```", "```\nPropagating type information...\n  Function argument information has been propagated\n  The initial autoanalysis has been finished.\n 40134e is an interesting location\n Testing: 40134e\n loc_4013B7\n Testing: loc_4013B7\n```", "```\nvoid demo_cdecl(int w, int x, int y, int z);\n```", "```\n; demo_cdecl(1, 2, 3, 4);   //programmer calls demo_cdecl\n push   4           ; push parameter z\n  push   3           ; push parameter y\n  push   2           ; push parameter x\n  push   1           ; push parameter w\n  call   demo_cdecl  ; call the function\n add    esp, 16     ; adjust esp to its former value\n```", "```\n; demo_cdecl(1, 2, 3, 4);   //programmer calls demo_cdecl\n   mov   [esp+12], 4   ; move parameter z to fourth position on stack\n   mov   [esp+8], 3    ; move parameter y to third position on stack\n   mov   [esp+4], 2    ; move parameter x to second position on stack\n   mov   [esp], 1      ; move parameter w to top of stack\n   call   demo_cdecl  ; call the function\n```", "```\nvoid _stdcall demo_stdcall(int w, int x, int y);\n```", "```\nret 12     ; return and clear 12 bytes from the stack\n```", "```\nvoid fastcall demo_fastcall(int w, int x, int y, int z);\n```", "```\n; demo_fastcall(1, 2, 3, 4);   //programmer calls demo_fastcall\n   push   4              ; move parameter z to second position on stack\n   push   3              ; move parameter y to top position on stack\n   mov    edx, 2         ; move parameter x to edx\n   mov    ecx, 1         ; move parameter w to ecx\n   call   demo_fastcall  ; call the function\n```", "```\nvoid bar(int j, int k);   // a function to call\nvoid demo_stackframe(int a, int b, int c) {\n   int x;\n   char buffer[64];\n   int y;\n   int z;\n   // body of function not terribly relevant other than\n   bar(z, y);\n}\n```", "```\nsub   esp, 76     ; allocate sufficient space for all local variables\n```", "```\n push   dword [esp+4]     ; push y\n push   dword [esp+4]     ; push z\n  call   bar\n  add    esp, 8              ; cdecl requires caller to clear parameters\n```", "```\nadd     esp, 76     ; adjust esp to point to the saved return address\nret                 ; return to the caller\n```", "```\n push    ebp        ; save the caller's ebp value\n mov     ebp, esp   ; make ebp point to the saved register value\n sub     esp, 76    ; allocate space for local variables\n```", "```\n push   dword [ebp-72]       ; push y\n  push   dword [ebp-76]       ; push z\n  call   bar\n  add    esp, 8               ; cdecl requires caller to clear parameters\n```", "```\nmov    esp, ebp      ; clears local variables by reseting esp\npop    ebp           ; restore the caller's value of ebp\nret                  ; pop return address to return to the caller\n```", "```\nleave                ; copies ebp to esp AND then pops into ebp\nret                  ; pop return address to return to the caller\n```", "```\nmov    eax, [ebp+8]\n```", "```\nvoid demo_stackframe(int a, int b, int c) {\n   int x = c;\n   char buffer[64];\n   int y = b;\n   int z = 10;\n   buffer[0] = 'A';\n   bar(z, y);\n}\n```", "```\n.text:00401090 ; ========= S U B R O U T I N E ===========================\n    .text:00401090\n    .text:00401090 ; Attributes: bp-based frame\n    .text:00401090\n    .text:00401090 demo_stackframe proc near      ; CODE XREF: sub_4010C1+41↓p\n    .text:00401090\n   .text:00401090 var_60          = dword ptr −60h\n    .text:00401090 var_5C          = dword ptr −5Ch\n    .text:00401090 var_58          = byte ptr −58h\n    .text:00401090 var_C           = dword ptr −0Ch\n    .text:00401090 arg_4           = dword ptr  0Ch\n    .text:00401090 arg_8           = dword ptr  10h\n    .text:00401090\n    .text:00401090                 push    ebp\n    .text:00401091                 mov     ebp, esp\n    .text:00401093                 sub     esp, 78h\n    .text:00401096                 mov     eax, [ebp+arg_8]\n      .text:00401099                mov     [ebp+var_C], eax\n    .text:0040109C                mov     eax, [ebp+arg_4]\n    .text:0040109F                mov     [ebp+var_5C], eax\n    .text:004010A2                mov     [ebp+var_60], 0Ah\n    .text:004010A9                mov     [ebp+var_58], 41h\n    .text:004010AD                 mov     eax, [ebp+var_5C]\n    .text:004010B0                mov     [esp+4], eax\n    .text:004010B4                 mov     eax, [ebp+var_60]\n    .text:004010B7                mov     [esp], eax\n    .text:004010BA                 call    bar\n    .text:004010BF                 leave\n    .text:004010C0                 retn\n    .text:004010C0 demo_stackframe endp\n```", "```\n.text:00401090 ; =========== S U B R O U T I N E =========================\n.text:00401090\n.text:00401090 ; Attributes: bp-based frame\n.text:00401090\n.text:00401090 demo_stackframe proc near      ; CODE XREF: sub_4010C1+41↓p\n.text:00401090\n.text:00401090 var_60          = dword ptr −60h\n.text:00401090 y             = dword ptr −5Ch\n.text:00401090 var_58          = byte ptr −58h\n.text:00401090 var_C           = dword ptr −0Ch\n.text:00401090 arg_4           = dword ptr  0Ch\n.text:00401090 arg_8           = dword ptr  10h\n.text:00401090\n.text:00401090                 push    ebp\n.text:00401091                 mov     ebp, esp\n.text:00401093                 sub     esp, 112\n.text:00401096                 mov     eax, [ebp+arg_8]\n.text:00401099                 mov     [ebp+var_C], eax\n.text:0040109C                 mov     eax, [ebp+arg_4]\n.text:0040109F                 mov     [ebp+y], eax\n.text:004010A2                 mov     [ebp+var_60], 0Ah\n.text:004010A9                 mov     [ebp+var_58], 41h\n.text:004010AD                 mov     eax, [ebp+y]\n.text:004010B0                 mov     [esp+4], eax\n.text:004010B4                 mov     eax, [ebp+var_60]\n.text:004010B7                 mov     [esp], eax\n.text:004010BA                 call    bar\n.text:004010BF                 leave\n.text:004010C0                 retn\n.text:004010C0 demo_stackframe endp\n```", "```\n.text:00401050 ; =============== S U B R O U T I N E\n=======================================\n.text:00401050\n.text:00401050 ; void bar(int j, int k);\n.text:00401050 ; Attributes: bp-based frame\n.text:00401050\n.text:00401050 \nbar       proc near               ; CODE XREF: demo_stackframe+2A,p\n.text:00401050\n.text:00401050 arg_0     = dword ptr  8\n.text:00401050 arg_4     = dword ptr  0Ch\n.text:00401050\n.text:00401050   push   ebp\n.text:00401051   mov   ebp, esp\n.text:00401053   sub   esp, 8\n.text:00401056  The next three lines test j < k\n.text:00401056   mov   eax, [ebp+arg_0]\n.text:00401059   cmp   eax, [ebp+arg_4]\n.text:0040105C   jge   short loc_40106C ;\n Repeating comments get echoed at referencing locations\n.text:0040105E   mov   [esp], offset aTheSecondParam ;\n \"The second parameter is larger\"\n.text:00401065   call  printf\n.text:0040106A   jmp   short locret_40108E ; jump to the end of the function\n.text:0040106C ; -------------------\n--------------------------------------------------------\n.text:0040106C\n.text:0040106C loc_40106C:                             ; CODE XREF: bar+C·j\n.text:0040106C   mov   eax, [ebp+arg_0] ;\n Repeating comments get echoed at referencing locations\n.text:0040106F   cmp   eax, [ebp+arg_4]\n.text:00401072   jle   short loc_401082\n.text:00401074   mov   [esp], offset aTheFirstParame ;\n \"The first parameter is larger\"\n.text:0040107B   call  printf\n.text:00401080   jmp   short locret_40108E\n.text:00401082 ; -----------------------\n----------------------------------------------------\n.text:00401082\n.text:00401082 loc_401082:                             ; CODE XREF: bar+22·j\n.text:00401082   mov   [esp], offset aTheParametersA ;\n \"the parameters are equal\"\n.text:00401089   call  printf\n.text:0040108E\n.text:0040108E locret_40108E:                          ; CODE XREF: bar+1A·j\n.text:0040108E                                         ; bar+30·j\n.text:0040108E   leave\n.text:0040108F   retn\n.text:0040108F bar  endp\n```", "```\n\n000 55                   push    ebp\n004 89 E5                mov     ebp, esp\n004 83 EC 78             sub     esp, 78h        ; Integer Subtraction\n07C 8B 45 10             mov     eax, [ebp+arg_8]\n07C 89 45 F4             mov     [ebp+var_C], eax\n07C 8B 45 0C             mov     eax, [ebp+arg_4]\n07C 89 45 A4             mov     [ebp+var_5C], eax\n07C C7 45 A0 0A 00+     mov     [ebp+var_60], 0Ah\n07C C6 45 A8 41          mov     [ebp+var_58], 41h\n07C 8B 45 A4             mov     eax, [ebp+var_5C]\n07C 89 44 24 04          mov     [esp+4], eax\n07C 8B 45 A0             mov     eax, [ebp+var_60]\n07C 89 04 24             mov     [esp], eax\n07C E8 91 FF FF FF       call    bar             ; Call Procedure\n07C C9                   leave                   ; High Level Procedure Exit\n000 C3                   retn                    ; Return Near from Procedure\n```", "```\n.text:004010A2                 mov     [ebp+var_60], AF_CCITT\n```", "```\n.text:004037AE ChunkedFunc     proc near\n.text:004037AE\n.text:004037AE var_420         = dword ptr −420h\n.text:004037AE var_41C         = dword ptr −41Ch\n.text:004037AE var_4           = dword ptr −4\n.text:004037AE hinstDLL        = dword ptr  8\n.text:004037AE fdwReason       = dword ptr  0Ch\n.text:004037AE lpReserved      = dword ptr  10h\n.text:004037AE\n.text:004037AE ; FUNCTION CHUNK AT .text:004040D7 SIZE 00000011 BYTES\n.text:004037AE ; FUNCTION CHUNK AT .text:004129ED SIZE 0000000A BYTES\n.text:004037AE ; FUNCTION CHUNK AT .text:00413DBC SIZE 00000019 BYTES\n.text:004037AE\n.text:004037AE                 push    ebp\n.text:004037AF                 mov     ebp, esp\n```", "```\n.text:004040D7 ; START OF FUNCTION CHUNK FOR ChunkedFunc\n.text:004040D7\n.text:004040D7 loc_0040C0D7:                   ; CODE XREF: ChunkedFunc+72↑j\n.text:004040D7                 dec     eax\n.text:004040D8                 jnz     loc_403836\n.text:004040DE                 call    sub_4040ED\n.text:004040E3                 jmp     loc_403836\n.text:004040E3 ; END OF FUNCTION CHUNK FOR ChunkedFunc\n```", "```\n.text:004010EB   01C      push     eax\n    .text:004010F3   020      push     2\n    .text:004010FB   024      push     1\n   .text:00401102   028      call    some_imported_func\n    .text:00401107   028      mov     ebx, eax\n```", "```\n.idata:00418078   ; Segment type: Externs\n.idata:00418078   ; _idata\n.idata:00418078         extrn some_imported_func:dword ; DATA XREF: sub_401034↑r\n```", "```\n.text:004013E0 sub_4013E0      proc near\n.text:004013E0                 push    ebp\n.text:004013E1                 mov     ebp, esp\n.text:004013E3                 pop     ebp\n.text:004013E4                 retn\n.text:004013E4 sub_4013E0      endp\n```", "```\n.text:004013E0 unk_4013E0      db  55h ; U\n.text:004013E1                 db  89h ; ë\n.text:004013E2                 db 0E5h ; s\n.text:004013E3                 db  5Dh ; ]\n.text:004013E4                 db 0C3h ; +\n```", "```\n.rdata:00402069 aThisIsACharact db 'This is a Character array',0\n```", "```\n.rdata:00402060 unk_402060      db    0    ; DATA XREF: sub_401350+8↑o\n.rdata:00402060                            ; sub_401350+18↑o\n.rdata:00402061                 db    0\n.rdata:00402062                 db    0\n.rdata:00402063                 db    0\n.rdata:00402064                 db    0\n.rdata:00402065                 db    0\n.rdata:00402066                 db    0\n.rdata:00402067                 db    0\n.rdata:00402068                 db    0\n.rdata:00402069                 db    0\n.rdata:0040206A                 db    0\n```", "```\n.rdata:00402060 byte_402060     db 1A0h dup(0)     ; DATA XREF: sub_401350+8↑o\n.rdata:00402060                                    ; sub_401350+18↑o\n```", "```\n.text:004010F3                 push    10h             ; namelen\n.text:004010F5                 lea     ecx, [ebp+name]\n.text:004010F8                 push    ecx             ; name\n.text:004010F9                 mov     edx, [ebp+s]\n.text:004010FF                 push    edx             ; s\n.text:00401100                 call    connect\n```", "```\n.text:00401050 ; ======== S U B R O U T I N E =========================\n.text:00401050\n.text:00401050 ; Attributes: bp-based frame\n.text:00401050\n.text:00401050 foo     proc near      ; CODE XREF: demo_stackframe+2A↓p\n.text:00401050\n.text:00401050 arg_0   = dword ptr  8\n.text:00401050 arg_4   = dword ptr  0Ch\n.text:00401050\n.text:00401050         push    ebp\n.text:00401051         mov     ebp, esp\n```", "```\n.text:00401050 ; ======== S U B R O U T I N E =========================\n.text:00401050\n.text:00401050 ; Attributes: bp-based frame\n.text:00401050\n.text:00401050 ; int __cdecl foo(float f, char *ptr)\n.text:00401050 foo     proc near      ; CODE XREF: demo_stackframe+2A↓p\n.text:00401050\n.text:00401050 f       = dword ptr  8\n.text:00401050 ptr     = dword ptr  0Ch\n.text:00401050\n.text:00401050         push    ebp\n.text:00401051         mov     ebp, esp\n```", "```\n.text:004010AD         mov     eax, [ebp+ptr]\n.text:004010B0         mov     [esp+4], eax    ; ptr\n.text:004010B4         mov     eax, [ebp+f]\n.text:004010B7         mov     [esp], eax      ; f\n.text:004010BA         call    foo\n```", "```\nint array_demo[100];\n```", "```\nint bytes = 100 * sizeof(int);\n```", "```\n array_demo[20] = 15;  //fixed index into the array\n  for (int i = 0; i < 100; i++) {\n     array_demo[i] = i;  //varying index into the array\n  }\n```", "```\nint global_array[3];\n\nint main() {\n   int idx = 2;\n   global_array[0] = 10;\n   global_array[1] = 20;\n   global_array[2] = 30;\n   global_array[idx] = 40;\n}\n```", "```\n.text:00401000 _main           proc near\n.text:00401000\n.text:00401000 idx             = dword ptr −4\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 push    ecx\n.text:00401004                 mov     [ebp+idx], 2\n.text:0040100B                mov     dword_40B720, 10\n.text:00401015                mov     dword_40B724, 20\n.text:0040101F                mov     dword_40B728, 30\n.text:00401029                 mov     eax, [ebp+idx]\n.text:0040102C                mov     dword_40B720[eax*4], 40\n.text:00401037                 xor     eax, eax\n.text:00401039                 mov     esp, ebp\n.text:0040103B                 pop     ebp\n.text:0040103C                 retn\n.text:0040103C _main           endp\n```", "```\n.text:0040100B                 mov     dword_40B720, 10\n.text:00401015                 mov     dword_40B720+4, 20\n.text:0040101F                 mov     dword_40B720+8, 30\n```", "```\nint main() {\n   int stack_array[3];\n   int idx = 2;\n   stack_array[0] = 10;\n   stack_array[1] = 20;\n   stack_array[2] = 30;\n   stack_array[idx] = 40;\n}\n```", "```\n.text:00401000 _main           proc near\n.text:00401000\n.text:00401000 var_10          = dword ptr −10h\n.text:00401000 var_C           = dword ptr −0Ch\n.text:00401000 var_8           = dword ptr −8\n.text:00401000 idx             = dword ptr −4\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 sub     esp, 10h\n.text:00401006                 mov     [ebp+idx], 2\n.text:0040100D                mov     [ebp+var_10], 10\n.text:00401014                mov     [ebp+var_C], 20\n.text:0040101B                mov     [ebp+var_8], 30\n.text:00401022                 mov     eax, [ebp+idx]\n.text:00401025                mov     [ebp+eax*4+var_10], 40\n.text:0040102D                 xor     eax, eax\n.text:0040102F                 mov     esp, ebp\n.text:00401031                 pop     ebp\n.text:00401032                 retn\n.text:00401032 _main           endp\n```", "```\nint main() {\n   int *heap_array = (int*)malloc(3 * sizeof(int));\n   int idx = 2;\n   heap_array[0] = 10;\n   heap_array[1] = 20;\n   heap_array[2] = 30;\n   heap_array[idx] = 40;\n}\n```", "```\n.text:00401000 _main      proc near\n.text:00401000\n.text:00401000 heap_array      = dword ptr −8\n.text:00401000 idx             = dword ptr −4\n.text:00401000\n.text:00401000            push    ebp\n.text:00401001            mov     ebp, esp\n.text:00401003            sub     esp, 8\n.text:00401006           push    0Ch             ; size_t\n.text:00401008            call    _malloc\n.text:0040100D            add     esp, 4\n.text:00401010            mov     [ebp+heap_array], eax\n.text:00401013            mov     [ebp+idx], 2\n.text:0040101A            mov     eax, [ebp+heap_array]\n.text:0040101D           mov     dword ptr [eax], 10\n.text:00401023            mov     ecx, [ebp+heap_array]\n.text:00401026           mov     dword ptr [ecx+4], 20\n.text:0040102D            mov     edx, [ebp+heap_array]\n.text:00401030           mov     dword ptr [edx+8], 30\n.text:00401037            mov     eax, [ebp+idx]\n.text:0040103A            mov     ecx, [ebp+heap_array]\n.text:0040103D           mov     dword ptr [ecx+eax*4], 40\n.text:00401044            xor     eax, eax\n.text:00401046            mov     esp, ebp\n.text:00401048            pop     ebp\n.text:00401049            retn\n.text:00401049 _main      endp\n```", "```\nstruct ch8_struct {   //Size     Minimum offset     Default offset\n   int field1;        //  4             0                  0\n   short field2;      //  2             4                  4\n   char field3;       //  1             6                  6\n   int field4;        //  4             7                  8\n   double field5;     //  8             11                 16\n};                //Minimum total size: 19   Default size: 24\n```", "```\nstruct ch8_struct global_struct;\n\nint main() {\n   global_struct.field1 = 10;\n   global_struct.field2 = 20;\n   global_struct.field3 = 30;\n   global_struct.field4 = 40;\n   global_struct.field5 = 50.0;\n}\n```", "```\n.text:00401000 _main           proc near\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 mov     dword_40EA60, 10\n.text:0040100D                 mov     word_40EA64, 20\n.text:00401016                 mov     byte_40EA66, 30\n.text:0040101D                 mov     dword_40EA68, 40\n.text:00401027                 fld     ds:dbl_40B128\n.text:0040102D                 fstp    dbl_40EA70\n.text:00401033                 xor     eax, eax\n.text:00401035                 pop     ebp\n.text:00401036                 retn\n.text:00401036 _main           endp\n```", "```\n.text:00401000 _main           proc near\n.text:00401000\n.text:00401000 var_18          = dword ptr −18h\n.text:00401000 var_14          = word ptr −14h\n.text:00401000 var_12          = byte ptr −12h\n.text:00401000 var_10          = dword ptr −10h\n.text:00401000 var_8           = qword ptr −8\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 sub     esp, 18h\n.text:00401006                 mov     [ebp+var_18], 10\n.text:0040100D                 mov     [ebp+var_14], 20\n.text:00401013                 mov     [ebp+var_12], 30\n.text:00401017                 mov     [ebp+var_10], 40\n.text:0040101E                 fld     ds:dbl_40B128\n.text:00401024                 fstp    [ebp+var_8]\n.text:00401027                 xor     eax, eax\n.text:00401029                 mov     esp, ebp\n.text:0040102B                 pop     ebp\n.text:0040102C                 retn\n.text:0040102C _main           endp\n```", "```\n.text:00401000 _main           proc near\n.text:00401000\n.text:00401000 heap_struct     = dword ptr −4\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 push    ecx\n.text:00401004                push    24              ; size_t\n.text:00401006                 call    _malloc\n.text:0040100B                 add     esp, 4\n.text:0040100E                 mov     [ebp+heap_struct], eax\n.text:00401011                 mov     eax, [ebp+heap_struct]\n.text:00401014                mov     dword ptr [eax], 10\n.text:0040101A                 mov     ecx, [ebp+heap_struct]\n.text:0040101D                mov     word ptr [ecx+4], 20\n.text:00401023                 mov     edx, [ebp+heap_struct]\n.text:00401026                mov     byte ptr [edx+6], 30\n.text:0040102A                 mov     eax, [ebp+heap_struct]\n.text:0040102D                mov     dword ptr [eax+8], 40\n.text:00401034                 mov     ecx, [ebp+heap_struct]\n.text:00401037                 fld     ds:dbl_40B128\n.text:0040103D                fstp    qword ptr [ecx+10h]\n.text:00401040                 xor     eax, eax\n.text:00401042                 mov     esp, ebp\n.text:00401044                 pop     ebp\n.text:00401045                 retn\n.text:00401045 _main           endp\n```", "```\n.text:00401000 _main           proc near\n.text:00401000\n.text:00401000 heap_struct     = dword ptr −4\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 push    ecx\n.text:00401004                 push    19              ; size_t\n.text:00401006                 call    _malloc\n.text:0040100B                 add     esp, 4\n.text:0040100E                 mov     [ebp+heap_struct], eax\n.text:00401011                 mov     eax, [ebp+heap_struct]\n.text:00401014                 mov     dword ptr [eax], 10\n.text:0040101A                 mov     ecx, [ebp+heap_struct]\n.text:0040101D                 mov     word ptr [ecx+4], 20\n.text:00401023                 mov     edx, [ebp+heap_struct]\n.text:00401026                 mov     byte ptr [edx+6], 30\n.text:0040102A                 mov     eax, [ebp+heap_struct]\n.text:0040102D                 mov     dword ptr [eax+7], 40\n.text:00401034                 mov     ecx, [ebp+heap_struct]\n.text:00401037                 fld     ds:dbl_40B128\n.text:0040103D                 fstp    qword ptr [ecx+0Bh]\n.text:00401040                 xor     eax, eax\n.text:00401042                 mov     esp, ebp\n.text:00401044                 pop     ebp\n.text:00401045                 retn\n.text:00401045 _main           endp\n```", "```\nint main() {\n     int idx = 1;\n     struct ch8_struct *heap_struct;\n     heap_struct = (struct ch8_struct*)malloc(sizeof(struct ch8_struct) * 5);\n    heap_struct[idx].field1 = 10;\n  }\n```", "```\n.text:00401000 _main           proc near\n.text:00401000\n.text:00401000 idx             = dword ptr −8\n.text:00401000 heap_struct     = dword ptr −4\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 sub     esp, 8\n.text:00401006                 mov     [ebp+idx], 1\n.text:0040100D                push    120              ; size_t\n.text:0040100F                 call    _malloc\n.text:00401014                 add     esp, 4\n.text:00401017                 mov     [ebp+heap_struct], eax\n.text:0040101A                 mov     eax, [ebp+idx]\n.text:0040101D                imul    eax, 24\n.text:00401020                 mov     ecx, [ebp+heap_struct]\n.text:00401023                mov     dword ptr [ecx+eax], 10\n.text:0040102A                 xor     eax, eax\n.text:0040102C                 mov     esp, ebp\n.text:0040102E                 pop     ebp\n.text:0040102F                 retn\n.text:0040102F _main           endp\n```", "```\nenum {\n   ch8_struct.field1 = 0,\n   ch8_struct.field2 = 4,\n   ch8_struct.field3 = 6,\n   ch8_struct.field4 = 8,\n   ch8_struct.field5 = 16\n};\n```", "```\n.text:00401006                 mov     [ebp+var_18], 10\n.text:0040100D                 mov     [ebp+var_14], 20\n.text:00401013                 mov     [ebp+var_12], 30\n.text:00401017                 mov     [ebp+var_10], 40\n.text:0040101E                 fld     ds:dbl_40B128\n.text:00401024                 fstp    [ebp+var_8]\n```", "```\n.text:00401006                 mov     [ebp+var_18.field1], 10\n.text:0040100D                 mov     [ebp+var_18.field2], 20\n.text:00401013                 mov     [ebp+var_18.field3], 30\n.text:00401017                 mov     [ebp+var_18.field4], 40\n.text:0040101E                 fld     ds:dbl_40B128\n.text:00401024                 fstp    [ebp+var_18.field5]\n```", "```\nHEADER:00400000 __ImageBase     db  4Dh ; M\nHEADER:00400001                 db  5Ah ; Z\nHEADER:00400002                 db  90h ; É\nHEADER:00400003                 db    0\nHEADER:00400004                 db    3\nHEADER:00400005                 db    0\nHEADER:00400006                 db    0\nHEADER:00400007                 db    0\nHEADER:00400008                 db    4\nHEADER:00400009                 db    0\nHEADER:0040000A                 db    0\nHEADER:0040000B                 db    0\nHEADER:0040000C                 db 0FFh\nHEADER:0040000D                 db 0FFh\nHEADER:0040000E                 db    0\nHEADER:0040000F                 db    0\n```", "```\nHEADER:00400000 __ImageBase IMAGE_DOS_HEADER\n <5A4Dh, 90h, 3, 0, 4, 0, 0FFFFh, 0, 0B8h, \\\nHEADER:00400000                               0, 0, 0, 40h, 0, 0, 0, 0, 0, 80h>\nHEADER:00400040 db 0Eh\n```", "```\nHEADER:00400000 __ImageBase     dw 5A4Dh                ; e_magic\nHEADER:00400000                 dw 90h                  ; e_cblp\nHEADER:00400000                 dw 3                    ; e_cp\nHEADER:00400000                 dw 0                    ; e_crlc\nHEADER:00400000                 dw 4                    ; e_cparhdr\nHEADER:00400000                 dw 0                    ; e_minalloc\nHEADER:00400000                 dw 0FFFFh               ; e_maxalloc\nHEADER:00400000                 dw 0                    ; e_ss\nHEADER:00400000                 dw 0B8h                 ; e_sp\nHEADER:00400000                 dw 0                    ; e_csum\nHEADER:00400000                 dw 0                    ; e_ip\nHEADER:00400000                 dw 0                    ; e_cs\nHEADER:00400000                 dw 40h                  ; e_lfarlc\nHEADER:00400000                 dw 0                    ; e_ovno\nHEADER:00400000                 dw 4 dup(0)             ; e_res\nHEADER:00400000                 dw 0                    ; e_oemid\nHEADER:00400000                 dw 0                    ; e_oeminfo\nHEADER:00400000                 dw 0Ah dup(0)           ; e_res2\nHEADER:00400000                dd 80h                  ; e_lfanew\nHEADER:00400040                 db  0Eh\n```", "```\nHEADER:00400080                 dd 4550h                ; Signature\nHEADER:00400080                 dw 14Ch                 ; FileHeader.Machine\nHEADER:00400080                \ndw 5                    ; FileHeader.NumberOfSections\nHEADER:00400080                 dd 4789ADF1h            ; FileHeader.TimeDateStamp\nHEADER:00400080                 dd 1400h                ; File\nHeader.PointerToSymbolTable\nHEADER:00400080                 dd 14Eh                 ; FileHeader.NumberOfSymbols\nHEADER:00400080                 dw 0E0h                 ; File\nHeader.SizeOfOptionalHeader\nHEADER:00400080                 dw 307h                 ; FileHeader.Characteristics\nHEADER:00400080                 dw 10Bh                 ; OptionalHeader.Magic\nHEADER:00400080                 db 2                    ; Optional\nHeader.MajorLinkerVersion\nHEADER:00400080                 db 38h                  ; Optional\nHeader.MinorLinkerVersion\nHEADER:00400080                 dd 800h                 ; OptionalHeader.SizeOfCode\nHEADER:00400080                 dd 800h                 ; Optional\nHeader.SizeOfInitializedData\nHEADER:00400080                 dd 200h                 ; Optional\nHeader.SizeOfUninitializedData\nHEADER:00400080                 dd 1000h                ; Optional\nHeader.AddressOfEntryPoint\nHEADER:00400080                 dd 1000h                ; OptionalHeader.BaseOfCode\nHEADER:00400080                 dd 2000h                ; OptionalHeader.BaseOfData\nHEADER:00400080                dd 400000h\n              ; OptionalHeader.ImageBase\n```", "```\nC:\\Program Files\\IdaPro>tilib -l til\\pc\\vc6win.til\n```", "```\nC:\\Program Files\\IdaPro>tilib -c -hch8_struct.h ch8.til\n```", "```\n//object1, object2, and *p_obj are all the same type.\nobject1.member_func();\nobject2.member_func();\np_obj->member_func();\n```", "```\nclass BaseClass {\npublic:\n   BaseClass();\n   virtual void vfunc1() = 0;\n   virtual void vfunc2();\n   virtual void vfunc3();\n   virtual void vfunc4();\nprivate:\n   int x;\n   int y;\n};\n\nclass SubClass : public BaseClass {\npublic:\n   SubClass();\n   virtual void vfunc1();\n   virtual void vfunc3();\n   virtual void vfunc5();\nprivate:\n   int z;\n};\n```", "```\nvoid call_vfunc(BaseClass *b) {\n   b->vfunc3();\n}\n\nint main() {\n   BaseClass *bc = new SubClass();\n   call_vfunc(bc);\n}\n```", "```\n.text:004010A0 call_vfunc      proc near\n.text:004010A0\n.text:004010A0 b               = dword ptr  8\n.text:004010A0\n.text:004010A0                 push    ebp\n.text:004010A1                 mov     ebp, esp\n.text:004010A3                 mov     eax, [ebp+b]\n.text:004010A6                mov     edx, [eax]\n.text:004010A8                 mov     ecx, [ebp+b]\n.text:004010AB                mov     eax, [edx+8]\n.text:004010AE                call    eax\n.text:004010B0                 pop     ebp\n.text:004010B1                 retn\n.text:004010B1 call_vfunc      endp\n```", "```\n00000000 SubClass_vtable struc ; (sizeof=0x14)\n00000000 vfunc1          dd ?\n00000004 vfunc2          dd ?\n00000008 vfunc3          dd ?\n0000000C vfunc4          dd ?\n00000010 vfunc5          dd ?\n00000014 SubClass_vtable ends\n```", "```\n.text:004010AB                 mov     eax, [edx+SubClass_vtable.vfunc3]\n```", "```\n.text:00401050 ; protected: __thiscall SubClass::SubClass(void)\n  text:00401050 ??0SubClass@@IAE@XZ  proc near\n  ...\n  .text:004010DC           \ncall  ??0SubClass@@IAE@XZ  ; SubClass::SubClass(void)\n```", "```\n .text:00401050 protected: __thiscall SubClass::SubClass(void) proc near\n  ...\n  .text:004010DC             call    SubClass::SubClass(void)\n```", "```\nclass abstract_class {\npublic:\n   virtual int vfunc() = 0;\n};\n\nclass concrete_class : public abstract_class {\npublic:\n   concrete_class();\n   int vfunc();\n};\n\nvoid print_type(abstract_class *p) {\n   cout << typeid(*p).name() << endl;\n}\n\nint main() {\n   abstract_class *sc = new concrete_class();\n   print_type(sc);\n}\n```", "```\nint read_it;            //integer variable read in main\nint write_it;           //integer variable written 3 times in main\nint ref_it;             //integer variable whose address is taken in main\n\nvoid callflow() {}      //function called twice from main\n\nint main() {\n   int *p = &ref_it;    //results in an \"offset\" style data reference\n   *p = read_it;        //results in a \"read\" style data reference\n   write_it = *p;       //results in a \"write\" style data reference\n   callflow();          //results in a \"call\" style code reference\n   if (read_it == 3) {  //results in \"jump\" style code reference\n      write_it = 2;     //results in a \"write\" style data reference\n   }\n   else {               //results in an \"jump\" style code reference\n      write_it = 1;     //results in a \"write\" style data reference\n   }\n   callflow();          //results in an \"call\" style code reference\n}\n```", "```\n.text:00401010 _main           proc near\n  .text:00401010\n  .text:00401010 p               = dword ptr −4\n  .text:00401010\n  .text:00401010                 push    ebp\n  .text:00401011                 mov     ebp, esp\n  .text:00401013                 push    ecx\n  .text:00401014                mov     [ebp+p], offset ref_it\n  .text:0040101B                 mov     eax, [ebp+p]\n  .text:0040101E                mov     ecx, read_it\n  .text:00401024                 mov     [eax], ecx\n  .text:00401026                 mov     edx, [ebp+p]\n  .text:00401029                 mov     eax, [edx]\n  .text:0040102B                mov     write_it, eax\n  .text:00401030                call    callflow\n  .text:00401035                cmp     read_it, 3\n  .text:0040103C                 jnz     short loc_40104A\n  .text:0040103E                mov     write_it, 2\n  .text:00401048                jmp     short loc_401054\n\n .text:0040104A ; -------------------------------------------------------------\n  .text:0040104A\n  .text:0040104A loc_40104A:                         ; CODE XREF: _main+2C↑j\n  .text:0040104A                mov     write_it, 1\n  .text:00401054\n  .text:00401054 loc_401054:                         ; CODE XREF: _main+38↑j\n  .text:00401054                call    callflow\n  .text:00401059                 xor     eax, eax\n    .text:0040105B                 mov     esp, ebp\n  .text:0040105D                 pop     ebp\n  .text:0040105E                retn\n  .text:0040105E _main           endp\n```", "```\n.text:00401000 callflow        proc near               ; CODE XREF: _main+20↓p\n.text:00401000                                         ; _main:loc_401054↓p\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 pop     ebp\n.text:00401004                 retn\n.text:00401004 callflow        endp\n```", "```\n.data:0040B720 read_it       dd ?                    ; DATA XREF: _main+E↑r\n.data:0040B720                                       ; _main+25↑r\n.data:0040B724 write_it      dd ?                    ; DATA XREF: _main+1B↑w\n.data:0040B724                                      ; _main+2E↑w ...\n.data:0040B728 ref_it        db    ? ;               ; DATA XREF: _main+4↑o\n.data:0040B729               db    ? ;\n.data:0040B72A               db    ? ;\n.data:0040B72B               db    ? ;\n```", "```\n.rdata:00408148 off_408148  dd offset SubClass::vfunc1\n(void) ; DATA XREF: SubClass::SubClass(void)+12↑o\n.rdata:0040814C          dd offset BaseClass::vfunc2(void)\n.rdata:00408150          dd offset SubClass::vfunc3(void)\n.rdata:00408154          dd offset BaseClass::vfunc4(void)\n.rdata:00408158          dd offset SubClass::vfunc5(void)\n```", "```\n.text:00401080 public: virtual void __thiscall SubClass::vfunc3(void) proc near\n.text:00401080                                      ; DATA XREF: .rdata:00408150↓o\n```", "```\n#include <stdio.h>\n\nvoid depth_2_1() {\n   printf(\"inside depth_2_1\\n\");\n}\n\nvoid depth_2_2() {\n   fprintf(stderr, \"inside depth_2_2\\n\");\n}\n\nvoid depth_1() {\n   depth_2_1();\n   depth_2_2();\n   printf(\"inside depth_1\\n\");\n}\n\nint main() {\n   depth_1();\n}\n```", "```\n.text:00401041               jg      short loc_401053\n.text:00401043               mov     ecx, [ebp+arg_0]\n```", "```\n# TVOPT=noGPM ./idal [file to disassemble]\n```", "```\nGRAPH_VISUALIZER        = \"qwingraph.exe -remove -timelimit 10\"\n```", "```\nGRAPH_VISUALIZER  = \"/usr/local/bin/aisee\"\n```", "```\nclear Mod1\nkeycode 66 = Alt_L\nkeycode 69 = Alt_R\nadd Mod1 = Alt_L\nadd Mod1 = Alt_R\n```", "```\n xmodmap $HOME/.Xmodmap\n```", "```\nidabook:~ idabook$ xmodmap\n  xmodmap:  up to 2 keys per modifier, (keycodes in parentheses):\n\n  shift       Shift_L (0x40),  Shift_R (0x44)\n  lock        Caps_Lock (0x41)\n  control     Control_L (0x43),  Control_R (0x46)\n mod1        Alt_L (0x42),  Alt_R (0x45)\n  mod2        Meta_L (0x3f)\n  mod3\n  mod4\n  mod5\n```", "```\nC:\\Program Files\\Ida>idaw -B some_program.exe > NUL\n```", "```\n# TVHEADLESS=1 ./idal -B input_file.exe > /dev/null\n```"]