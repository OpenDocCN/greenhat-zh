<html><head></head><body>
<p class="calibre1">That’s right, too. We could go another iteration, but instead, let’s look at the last iteration, a place where bugs frequently arise in loops. So, let’s add a conditional breakpoint, as follows:</p>
<p class="calibre1">findruns &lt;- function(x,k) {</p>
<p class="calibre1">n &lt;- length(x)</p>
<p class="calibre1">runs &lt;- NULL</p>
<p class="calibre1">for (i in 1:(n-k)) {</p>
<p class="calibre1">if (all(x[i:(i+k-1)]==1)) runs &lt;- c(runs,i)</p>
<p class="calibre1">if (i == n-k) browser() # break in last iteration of loop</p>
<p class="calibre1">}</p>
<p class="calibre1">return(runs)</p>
<p class="calibre1">}</p>
<p class="calibre1">And now run it again. </p>
<p class="calibre1">&gt; source("findruns.R")</p>
<p class="calibre1">&gt; findruns(c(1,0,0,1,1,0,1,1,1),2)</p>
<p class="calibre1">Called from: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)</p>
<p class="calibre1">Browse[1]&gt; i</p>
<p class="calibre1">[1] 7</p>
<p class="calibre1">This shows the last iteration was for i = 7. But the vector is nine elements long, and k = 2, so our last iteration should be i = 8. Some thought then reveals that the range in the loop should have been written as follows: for (i in 1:(n-k+1)) {</p>
<p class="calibre1">By the way, note that the breakpoint that we set using setBreakpoint() is no longer valid, now that we’ve replaced the old version of the object findruns. </p>
<p class="calibre1">Subsequent testing (not shown here) indicates the code now works. </p>
<p class="calibre1">Let’s move on to a more complex example. </p>
<p class="calibre1"><b class="calibre3">13.3.6.2 Debugging Finding City Pairs</b></p>
<p class="calibre1">Recall our code in Section 3.4.2, which found the pair of cities with the closest distance between them. Here is a buggy version of that code:</p>
<p class="calibre1">1</p>
<p class="calibre1">returns the minimum value of d[i,j], i != j, and the row/col attaining 2</p>
<p class="calibre1">that minimum, for square symmetric matrix d; no special policy on</p>
<p class="calibre1">3</p>
<p class="calibre1">ties; </p>
<p class="calibre1">4</p>
<p class="calibre1">motivated by distance matrices</p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">295</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p322"/>5</p>
<p class="calibre1">mind &lt;- function(d) {</p>
<p class="calibre1">6</p>
<p class="calibre1">n &lt;- nrow(d)</p>
<p class="calibre1">7</p>
<p class="calibre1">add a column to identify row number for apply()</p>
<p class="calibre1">8</p>
<p class="calibre1">dd &lt;- cbind(d,1:n)</p>
<p class="calibre1">9</p>
<p class="calibre1">wmins &lt;- apply(dd[-n,],1,imin)</p>
<p class="calibre1">10</p>
<p class="calibre1">wmins will be 2xn, 1st row being indices and 2nd being values</p>
<p class="calibre1">11</p>
<p class="calibre1">i &lt;- which.min(wmins[1,])</p>
<p class="calibre1">12</p>
<p class="calibre1">j &lt;- wmins[2,i]</p>
<p class="calibre1">13</p>
<p class="calibre1">return(c(d[i,j],i,j))</p>
<p class="calibre1">14</p>
<p class="calibre1">}</p>
<p class="calibre1">15</p>
<p class="calibre1">16</p>
<p class="calibre1">finds the location, value of the minimum in a row x</p>
<p class="calibre1">17</p>
<p class="calibre1">imin &lt;- function(x) {</p>
<p class="calibre1">18</p>
<p class="calibre1">n &lt;- length(x)</p>
<p class="calibre1">19</p>
<p class="calibre1">i &lt;- x[n]</p>
<p class="calibre1">20</p>
<p class="calibre1">j &lt;- which.min(x[(i+1):(n-1)])</p>
<p class="calibre1">21</p>
<p class="calibre1">return(c(j,x[j]))</p>
<p class="calibre1">22</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s use R’s debugging tools to find and fix the problems. </p>
<p class="calibre1">We’ll run it first on a small test case:</p>
<p class="calibre1">&gt; source("cities.R")</p>
<p class="calibre1">&gt; m &lt;- rbind(c(0,12,5),c(12,0,8),c(5,8,0))</p>
<p class="calibre1">&gt; m</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">0</p>
<p class="calibre1">12</p>
<p class="calibre1">5</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">12</p>
<p class="calibre1">0</p>
<p class="calibre1">8</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">5</p>
<p class="calibre1">8</p>
<p class="calibre1">0</p>
<p class="calibre1">&gt; mind(m)</p>
<p class="calibre1">Error in mind(m) : subscript out of bounds</p>
<p class="calibre1">Not an auspicious start! Unfortunately, the error message doesn’t tell us where the code blew up. But the debugger will give us that information:</p>
<p class="calibre1">&gt; options(error=recover)</p>
<p class="calibre1">&gt; mind(m)</p>
<p class="calibre1">Error in mind(m) : subscript out of bounds</p>
<p class="calibre1">Enter a frame number, or 0 to exit</p>
<p class="calibre1">1: mind(m)</p>
<p class="calibre1">Selection: 1</p>
<p class="calibre1">Called from: eval(expr, envir, enclos)</p>
<p class="calibre1">Browse[1]&gt; where</p>
<p class="calibre1"><b class="calibre3">296</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p323"/>where 1: eval(expr, envir, enclos)</p>
<p class="calibre1">where 2: eval(quote(browser()), envir = sys.frame(which))</p>
<p class="calibre1">where 3 at cities.R#13: function ()</p>
<p class="calibre1">{</p>
<p class="calibre1">if (.isMethodsDispatchOn()) {</p>
<p class="calibre1">tState &lt;- tracingState(FALSE)</p>
<p class="calibre1">... </p>
<p class="calibre1">Okay, so the problem occurred in mind() rather than imin() and in particular at line 13. It still could be the fault of imin(), but for now, let’s deal with the former. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">There is another way we could have determined that the blowup occurred on line 13. </i></p>
<p class="calibre1"> <i class="calibre4">We would enter the debugger as before but probe the local variables. We could reason</i> <i class="calibre4">that if the subscript bounds error had occurred at line 9, then the variable wmins would</i> <i class="calibre4">not have been set, so querying it would give us an error message like </i> Error: object</p>
<p class="calibre1">'wmins' not found.  <i class="calibre4">On the other hand, if the blowup occurred on line 13, even j</i> <i class="calibre4">would have been set. </i></p>
<p class="calibre1">Since the error occurred with d[i,j], let’s look at those variables: Browse[1]&gt; d</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">0</p>
<p class="calibre1">12</p>
<p class="calibre1">5</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">12</p>
<p class="calibre1">0</p>
<p class="calibre1">8</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">5</p>
<p class="calibre1">8</p>
<p class="calibre1">0</p>
<p class="calibre1">Browse[1]&gt; i</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">Browse[1]&gt; j</p>
<p class="calibre1">[1] 12</p>
<p class="calibre1">This is indeed a problem—d only has three columns, yet j, a column</p>
<p class="calibre1">subscript, is 12. </p>
<p class="calibre1">Let’s look at the variable from which we gleaned j, wmins:</p>
<p class="calibre1">Browse[1]&gt; wmins</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">2</p>
<p class="calibre1">1</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">12</p>
<p class="calibre1">12</p>
<p class="calibre1">If you recall how the code was designed, column k of wmins is supposed to contain information about the minimum value in row k of d. So here wmins is saying that in the first row (k = 1) of d,(0,12,5), the minimum value is 12, occurring at index 2. But it should be 5 at index 3. So, something went wrong with this line:</p>
<p class="calibre1">wmins &lt;- apply(dd[-n, ], 1, imin)</p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">297</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p324"/>There are several possibilities here. But since ultimately imin() is called, we can check them all from within that function. So, let’s set the debug status of imin(), quit the debugger, and rerun the code. </p>
<p class="calibre1">Browse[1]&gt; Q</p>
<p class="calibre1">&gt; debug(imin)</p>
<p class="calibre1">&gt; mind(m)</p>
<p class="calibre1">debugging in: FUN(newX[, i], ...)</p>
<p class="calibre1">debug at cities.R#17: {</p>
<p class="calibre1">n &lt;- length(x)</p>
<p class="calibre1">i &lt;- x[n]</p>
<p class="calibre1">j &lt;- which.min(x[(i + 1):(n - 1)])</p>
<p class="calibre1">return(c(j, x[j]))</p>
<p class="calibre1">}</p>
<p class="calibre1">... </p>
<p class="calibre1">So, we’re in imin(). Let’s see if it properly received the first row of dd, which should be (0,12,5,1). </p>
<p class="calibre1">Browse[4]&gt; x</p>
<p class="calibre1">[1] 0 12 5 1</p>
<p class="calibre1">It’s confirmed. This seems to indicate that the first two arguments to apply() were correct and that the problem is instead within imin(), though that remains to be seen. </p>
<p class="calibre1">Let’s single-step through, occasionally typing confirmational queries: Browse[2]&gt; n</p>
<p class="calibre1">debug at cities.r#17: n &lt;- length(x)</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at cities.r#18: i &lt;- x[n]</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at cities.r#19: j &lt;- which.min(x[(i + 1):(n - 1)])</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at cities.r#20: return(c(j, x[j]))</p>
<p class="calibre1">Browse[2]&gt; print(n)</p>
<p class="calibre1">[1] 4</p>
<p class="calibre1">Browse[2]&gt; i</p>
<p class="calibre1">[1] 1</p>
<p class="calibre1">Browse[2]&gt; j</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">Recall that we designed our call which.min(x[(i + 1):(n - 1)] to look only at the above-diagonal portion of this row. This is because the matrix is symmetric and because we don’t want to consider the distance between a city and itself. </p>
<p class="calibre1"><b class="calibre3">298</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p325"/>But the value j = 2 does not confirm. The minimum value in (0,12,5) is 5, which occurs at index 3 of that vector, not index 2. Thus, the problem is in this line:</p>
<p class="calibre1">j &lt;- which.min(x[(i + 1):(n - 1)])</p>
<p class="calibre1">What could be wrong? </p>
<p class="calibre1">After taking a break, we realize that although the minimum value of (0,12,5) occurs at index 3 of that vector, that is  <i class="calibre4">not </i> what we asked which.min() to find for us. Instead, that i + 1 term means we asked for the index of the minimum in (12,5), which is 2. </p>
<p class="calibre1">We did ask which.min() for the correct information, but we failed to use it correctly, because we do want the index of the minimum in (0,12,5). We need to adjust the output of which.min() accordingly, as follows:</p>
<p class="calibre1">j &lt;- which.min(x[(i+1):(n-1)])</p>
<p class="calibre1">k &lt;- i + j</p>
<p class="calibre1">return(c(k,x[k]))</p>
<p class="calibre1">We make the fix and try again. </p>
<p class="calibre1">&gt; mind(m)</p>
<p class="calibre1">Error in mind(m) : subscript out of bounds</p>
<p class="calibre1">Enter a frame number, or 0 to exit</p>
<p class="calibre1">1: mind(m)</p>
<p class="calibre1">Selection:</p>
<p class="calibre1">Oh no,  <i class="calibre4">another </i> bounds error! To see where the blowup occurred this time, we issue the where command as before, and we find it was at line 13</p>
<p class="calibre1">again. What about i and j now? </p>
<p class="calibre1">Browse[1]&gt; i</p>
<p class="calibre1">[1] 1</p>
<p class="calibre1">Browse[1]&gt; j</p>
<p class="calibre1">[1] 5</p>
<p class="calibre1">The value of j is still wrong; it cannot be larger than 3, as we have only three columns in this matrix. On the other hand, i is correct. The overall minimum value in dd is 5, occurring in row 1, column 3. </p>
<p class="calibre1">So, let’s check the source of j again, the matrix wmins:</p>
<p class="calibre1">Browse[1]&gt; wmins</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">3</p>
<p class="calibre1">3</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">5</p>
<p class="calibre1">8</p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">299</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p326"/>Well, there are the 3 and 5 in column 1, just as should be the case. </p>
<p class="calibre1">Remember, column 1 here contains the information for row 1 in d, so wmins is saying that the minimum value in row 1 is 5, occurring at index 3 of that row, which is correct. </p>
<p class="calibre1">After taking another break, though, we realize that while wmins is correct, our  <i class="calibre4">use </i> of it isn’t. We have the rows and columns of that matrix mixed up. </p>
<p class="calibre1">This code:</p>
<p class="calibre1">i &lt;- which.min(wmins[1,])</p>
<p class="calibre1">j &lt;- wmins[2,i]</p>
<p class="calibre1">should be like this:</p>
<p class="calibre1">i &lt;- which.min(wmins[2,])</p>
<p class="calibre1">j &lt;- wmins[1,i]</p>
<p class="calibre1">After making that change and resourcing our file, we try it out. </p>
<p class="calibre1">&gt; mind(m)</p>
<p class="calibre1">[1] 5 1 3</p>
<p class="calibre1">This is correct, and subsequent tests with larger matrices worked, too. </p>
<p class="calibre1"><b class="calibre3">13.4 Moving Up in the World: More Convenient Debugging</b></p>
<p class="calibre1"><b class="calibre3">Tools</b></p>
<p class="calibre1">As just seen, R’s debugging tools are effective. However, they’re not very convenient. Fortunately, there are various tools that make the process easier. In approximate chronological order of development, they are as follows:</p>
<p class="calibre1">•</p>
<p class="calibre1">The debug package by Mark Bravington</p>
<p class="calibre1">•</p>
<p class="calibre1">My edtdbg package, which works with the Vim and Emacs text editors</p>
<p class="calibre1">•</p>
<p class="calibre1">Vitalie Spinu’s ess-tracebug, which runs under Emacs (with the same goals as edtdbg but with more Emacs-specific features)</p>
<p class="calibre1">•</p>
<p class="calibre1">REvolution Analytics’ Integrated Development Environment (IDE)</p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">As of this writing (July 2011), work is in progress by the teams that develop the</i> <i class="calibre4">StatET and RStudio IDEs to add debugging tools. </i></p>
<p class="calibre1">All of these tools are cross-platform, working on Linux, Windows, and Mac systems, with the exception of the REvolution Analytics product. That IDE is available only on Windows systems with Microsoft Visual Studio. All of the tools are open source or free, again with the exception of the REvolution Analytics product. </p>
<p class="calibre1">So, what do these packages have to offer? To me, one of the biggest problems with R’s built-in debugging tools is the lack of a window that shows the big picture—a window displaying your R code with a cursor that moves <b class="calibre3">300</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p327"/><img src="index-327_1.png" alt="Image 39" class="calibre2"/></p>
<p class="calibre1"><img src="index-327_2.png" alt="Image 40" class="calibre2"/></p>
<p class="calibre1">through the code as you single-step through it. For example, consider this excerpt from our previous browser output:</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at cities.r#17: n &lt;- length(x)</p>
<p class="calibre1">Browse[2]&gt; n</p>
<p class="calibre1">debug at cities.r#18: i &lt;- x[n]</p>
<p class="calibre1">This is nice, but where are these lines in our code? Most GUI debuggers for other languages feature a window showing the user’s source code, with a symbol indicating the next line to be executed. All of the R tools listed at the start of this section remedy this lack in core R. The Bravington debug package creates a separate window for exactly this purpose. The other tools have your text editor double as that window, thus saving space on your screen compared to using debug. </p>
<p class="calibre1">In addition, these tools allow you to set breakpoints and handle other debugging operations without moving your screen’s cursor from the editor window to your R execution window. This is convenient and saves typing as well, greatly enhancing your ability to concentrate on the real task at hand: finding your bugs. </p>
<p class="calibre1">Let’s consider the cities example again. I opened the GVim text editor on my source file in conjunction with edtdbg, did some startup for edtdbg, and then hit the [ (left bracket) key twice to single-step twice through the code. </p>
<p class="calibre1">The resulting GVim window is shown in Figure 13-1. </p>
<p class="calibre1"> <i class="calibre4">Figure 13-1: Source window in edtdbg</i></p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">301</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p328"/><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Operation of edtdbg for Emacs is the same as shown here, just with different keystrokes</i> <i class="calibre4">used for the commands. For instance, F8 is used for single-stepping instead of [. </i></p>
<p class="calibre1">First, note that the editor’s cursor is now on this line:</p>
<p class="calibre1">wmins &lt;- apply(dd[-n, ], 1, imin)</p>
<p class="calibre1">This shows the line to be executed next. </p>
<p class="calibre1">Whenever I want to single-step a line, I simply hit the [ key while I’m in the editor window. The editor then tells the browser to execute its n command, without my needing to move the mouse to the R execution window, and then the editor moves its cursor to the next line. I can also hit ] for the browser’s c command. Each time I execute a line or lines in this manner, the editor’s cursor moves right along. </p>
<p class="calibre1">Whenever I make a change to my source code, typing ,src (the comma</p>
<p class="calibre1">is part of the command) into my GVim window will tell R to call source() on it. Each time I want to rerun my code, I hit ,dt. I rarely, if ever, need to move my mouse away from the editor window to the R window and back. </p>
<p class="calibre1">In essence, the editor has become my debugger in addition to providing its editing operations. </p>
<p class="calibre1"><b class="calibre3">13.5 Ensuring Consistency in Debugging Simulation Code</b></p>
<p class="calibre1">If you’re doing anything with random numbers, you’ll need to be able to reproduce the same stream of numbers each time you run your program during the debugging session. Without this, your bugs may not be reproducible, making them even harder to fix. </p>
<p class="calibre1">The set.seed() function controls this by reinitializing the random number sequence to a given value. </p>
<p class="calibre1">Consider this example:</p>
<p class="calibre1">[1] 0.8811480 0.2853269 0.5864738</p>
<p class="calibre1">&gt; runif(3)</p>
<p class="calibre1">[1] 0.5775979 0.4588383 0.8354707</p>
<p class="calibre1">&gt; runif(3)</p>
<p class="calibre1">[1] 0.4155105 0.4852900 0.6591892</p>
<p class="calibre1">&gt; runif(3)</p>
<p class="calibre1">&gt; set.seed(8888)</p>
<p class="calibre1">&gt; runif(3)</p>
<p class="calibre1">[1] 0.5775979 0.4588383 0.8354707</p>
<p class="calibre1">&gt; set.seed(8888)</p>
<p class="calibre1">&gt; runif(3)</p>
<p class="calibre1">[1] 0.5775979 0.4588383 0.8354707</p>
<p class="calibre1">The call runif(3) generates three random numbers from the uniform</p>
<p class="calibre1">distribution on the interval (0,1). Each time we make that call, we will get a different set of three numbers. But with set.seed(), we can start over and get the same sequence of numbers. </p>
<p class="calibre1"><b class="calibre3">302</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p329"/><b class="calibre3">13.6 Syntax and Runtime Errors</b></p>
<p class="calibre1">The most common syntax errors will be lack of matching parentheses, brackets, braces, or quotation marks. When you encounter a syntax</p>
<p class="calibre1">error, this is the first thing you should check and double-check. I highly recommend that you use a text editor that does parentheses matching and syntax coloring for R, such as Vim or Emacs. </p>
<p class="calibre1">Be aware that often when you get a message saying there is a syntax error on a certain line, the error may actually be in a much earlier line. </p>
<p class="calibre1">This can occur with any language, but R seems especially prone to it. </p>
<p class="calibre1">If it just isn’t obvious to you where your syntax error is, I recommend selectively commenting out some of your code, better enabling you to pinpoint the location of the syntax problem. Generally, it helps to follow a binary search approach: Comment out half of your code (being careful to maintain syntax integrity) and see if the same error arises. If it does, it’s in the remaining half; otherwise, it’s in the half you deleted. Then cut that half in half, and so on. </p>
<p class="calibre1">You may sometimes get messages like the following:</p>
<p class="calibre1">There were 50 or more warnings (use warnings() to see the first 50) These should be heeded—run warnings() as suggested. The problem</p>
<p class="calibre1">could range from nonconvergence of an algorithm to misspecification of a matrix argument to a function. In many cases, the program output may be invalid, though it may well be fine, too, say with this message:</p>
<p class="calibre1">Fitted probabilities numerically 0 or 1 occurred in: glm... </p>
<p class="calibre1">In some cases, you may find it useful to issue this command:</p>
<p class="calibre1">&gt; options(warn=2)</p>
<p class="calibre1">This instructs R to turn warnings into actual errors and makes the locations of the warnings easier to find. </p>
<p class="calibre1"><b class="calibre3">13.7 Running GDB on R Itself</b></p>
<p class="calibre1">This section may be of interest to you even if you are not trying to fix a bug in R. For example, you may have written some C code to interface to R (covered in Chapter 15) and found it to be buggy. In order to run GDB on that C function, you must first run R itself through GDB. </p>
<p class="calibre1">Or, you may be interested in the internals of R, say to determine how you can write efficient R code, and wish to explore the internals by stepping through the R source code with a debugging tool such as GDB. </p>
<p class="calibre1">Debugging</p>
<p class="calibre1"><b class="calibre3">303</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p330"/>Although you can invoke R through GDB from a shell command line (see Section 15.1.4), for our purposes here, I suggest using separate windows for R and GDB. Here’s the procedure:</p>
<p class="calibre1">1. </p>
<p class="calibre1">Start R in one window, as usual. </p>
<p class="calibre1">2. </p>
<p class="calibre1">In another window, determine the ID number of your R process. In</p>
<p class="calibre1">UNIX family systems, for instance, this is obtained by something like ps -a. </p>
<p class="calibre1">3. </p>
<p class="calibre1">In that second window, submit GDB’s attach command with the R pro-</p>
<p class="calibre1">cess number. </p>
<p class="calibre1">4. </p>
<p class="calibre1">Submit the continue command to GDB. </p>
<p class="calibre1">You can set breakpoints in the R source code either before continuing or by interrupting GDB later with CTRL-C. See Section 15.1.4 for details for debugging C code called from R. If, on the other hand, you wish to use GDB</p>
<p class="calibre1">to explore the R source code, note the following. </p>
<p class="calibre1">The R source code is dominated by S expression pointers (SEXPs), </p>
<p class="calibre1">which are pointers to C structs that contain an R variable’s value, type, and so on. You can use the R internal function Rf_PrintValue(s) to inspect SEXP</p>
<p class="calibre1">values. For example, if the SEXP is named s, then in GDB, type this: call Rf_PrintValue(s)</p>
<p class="calibre1">This prints the value. </p>
<p class="calibre1"><b class="calibre3">304</b></p>
<p class="calibre1">Chapter 13</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p331"/><img src="index-331_1.png" alt="Image 41" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">14</b></p>
<p class="calibre1"><b class="calibre3">PERFORMANCE ENHANCEMENT:</b></p>
<p class="calibre1"><b class="calibre3">SPEED AND MEMORY</b></p>
<p class="calibre1">In computer science curricula, a common</p>
<p class="calibre1">theme is the trade-off between time and</p>
<p class="calibre1">space. In order to have a fast-running pro-</p>
<p class="calibre1">gram, you may need to use more memory space. </p>
<p class="calibre1">On the other hand, in order to conserve memory space, </p>
<p class="calibre1">you might need to settle for slower code. In the R lan-</p>
<p class="calibre1">guage, this trade-off is of particular interest for the fol-</p>
<p class="calibre1">lowing reasons:</p>
<p class="calibre1">•</p>
<p class="calibre1">R is an interpreted language. Many of the commands are written in C</p>
<p class="calibre1">and thus do run in fast machine code. But other commands, and your</p>
<p class="calibre1">own R code, are pure R and thus interpreted. So, there is a risk that your R application may run more slowly than you would like. </p>
<p class="calibre1">•</p>
<p class="calibre1">All objects in an R session are stored in memory. More precisely, all objects are stored in R’s memory address space. R places a limit of 231  <i class="calibre4">− </i> 1 bytes on the size of any object, even on 64-bit machines and even if you have a lot of RAM. Yet some applications do encounter</p>
<p class="calibre1">larger objects. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p332"/>This chapter will suggest ways that you can enhance the performance of your R code, taking into account the time/space trade-off. </p>
<p class="calibre1"><b class="calibre3">14.1 Writing Fast R Code</b></p>
<p class="calibre1">What can be done to make R code faster? Here are the main tools available to you:</p>
<p class="calibre1">•</p>
<p class="calibre1">Optimize your R code through vectorization, use of byte-code compilation, and other approaches. </p>
<p class="calibre1">•</p>
<p class="calibre1">Write the key, CPU-intensive parts of your code in a compiled language such as C/C++. </p>
<p class="calibre1">•</p>
<p class="calibre1">Write your code in some form of parallel R. </p>
<p class="calibre1">The first approach will be covered in this chapter, and the other approaches are covered in Chapters 15 and 16. </p>
<p class="calibre1">To optimize your R code, you need to understand R’s functional pro-</p>
<p class="calibre1">gramming nature and the way R uses memory. </p>
<p class="calibre1"><b class="calibre3">14.2 The Dreaded for Loop</b></p>
<p class="calibre1">The r-help discussion listserv for R often has questions about how to accomplish various tasks without for loops. There seems to be a feeling that programmers should avoid these loops at all costs.1 Those who pose the queries usually have the goal of speeding up their code. </p>
<p class="calibre1">It’s important to understand that simply rewriting code to avoid loops will not necessarily make the code faster. However, in some cases, dramatic speedup may be attained, usually through vectorization. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.2.1 Vectorization for Speedup</b></i></p>
<p class="calibre1">Sometimes, you can use vectorization instead of looping. For example, if x and y are vectors of equal lengths, you can write this:</p>
<p class="calibre1">z &lt;- x + y</p>
<p class="calibre1">This is not only more compact, but even more important, it is faster than using this loop:</p>
<p class="calibre1">for (i in 1:length(x)) z[i] &lt;- x[i] + y[i]</p>
<p class="calibre1">Let’s do a quick timing comparison:</p>
<p class="calibre1">&gt; x &lt;- runif(1000000)</p>
<p class="calibre1">&gt; y &lt;- runif(1000000)</p>
<p class="calibre1">1 By contrast, while loops pose much more of a challenge, because they are difficult to vectorize effectively. </p>
<p class="calibre1"><b class="calibre3">306</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p333"/>&gt; z &lt;- vector(length=1000000)</p>
<p class="calibre1">&gt; system.time(z &lt;- x + y)</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.052</p>
<p class="calibre1">0.016</p>
<p class="calibre1">0.068</p>
<p class="calibre1">&gt; system.time(for (i in 1:length(x)) z[i] &lt;- x[i] + y[i])</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">8.088</p>
<p class="calibre1">0.044</p>
<p class="calibre1">8.175</p>
<p class="calibre1">What a difference! The version without a loop was more than 120 times faster in elapsed time. While timings may vary from one run to another (a second run of the loop version had elapsed time of 22.958), in some cases, </p>
<p class="calibre1">“delooping” R code can really pay off. </p>
<p class="calibre1">It’s worth discussing some of the sources of slowdown in the loop version. What may not be obvious to programmers coming to R from other languages is that numerous function calls are involved in the loop version of the previous code:</p>
<p class="calibre1">•</p>
<p class="calibre1">Though syntactically the loop looks innocuous, for() is, in fact, a function. </p>
<p class="calibre1">•</p>
<p class="calibre1">The colon : looks even more innocuous, but it’s a function too. For instance, 1:10 is actually the : function called on the arguments 1</p>
<p class="calibre1">and 10:</p>
<p class="calibre1">&gt; ":"(1,10)</p>
<p class="calibre1">[1] 1 2 3 4 5 6 7 8 9 10</p>
<p class="calibre1">•</p>
<p class="calibre1">Each vector subscript operation represents a function call, with calls to [</p>
<p class="calibre1">for the two reads and to [&lt;- in the case of the write. </p>
<p class="calibre1">Function calls can be time-consuming, as they involve setting up stack frames and the like. Suffering that time penalty at every iteration of the loop adds up to a big slowdown. </p>
<p class="calibre1">By contrast, if we were to write this in C, there would be no function calls. Indeed, that is essentially what happens in our first code snippet. There are function calls there as well, namely a call to + and one to - <i class="calibre4">&gt; </i>, but each is called only once, not 1,000,000 times, as in the loop version. Thus, the first version of the code is much faster. </p>
<p class="calibre1">One type of vectorization is  <i class="calibre4">vector filtering </i> For instance, let’s rewrite our function oddcount() from Section 1.3:</p>
<p class="calibre1">oddcount &lt;- function(x) return(sum(x%%2==1))</p>
<p class="calibre1">There is no explicit loop here, and even though R will internally loop through the array, this will be done in native machine code. Again, the anticipated speedup does occur. </p>
<p class="calibre1">&gt; x &lt;- sample(1:1000000,100000,replace=T)</p>
<p class="calibre1">&gt; system.time(oddcount(x))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">307</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p334"/>0.012</p>
<p class="calibre1">0.000</p>
<p class="calibre1">0.015</p>
<p class="calibre1">&gt; system.time(</p>
<p class="calibre1">+</p>
<p class="calibre1">{</p>
<p class="calibre1">+</p>
<p class="calibre1">c &lt;- 0</p>
<p class="calibre1">+</p>
<p class="calibre1">for (i in 1:length(x))</p>
<p class="calibre1">+</p>
<p class="calibre1">if (x[i] %% 2 == 1) c &lt;- c+1</p>
<p class="calibre1">+</p>
<p class="calibre1">return(c)</p>
<p class="calibre1">+</p>
<p class="calibre1">}</p>
<p class="calibre1">+ )</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.308</p>
<p class="calibre1">0.000</p>
<p class="calibre1">0.310</p>
<p class="calibre1">You might wonder whether it matters in this case, since even the loop version of the code took less than a second to run. But if this code had been part of an enclosing loop, with many iterations, the difference could be important indeed. </p>
<p class="calibre1">Examples of other vectorized functions that may speed up your code</p>
<p class="calibre1">are ifelse(), which(), where(), any(), all(), cumsum(), and cumprod(). In the matrix case, you can use rowSums(), colSums(), and so on. In “all possible combinations” types of settings, combin(), outer(), lower.tri(), upper.tri(), or expand.grid() may be just what you need. </p>
<p class="calibre1">Though apply() eliminates an explicit loop, it is actually implemented in R rather than C and thus will usually not speed up your code. However, the other apply functions, such as lapply(), can be very helpful in speeding up your code. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.2.2 Extended Example: Achieving Better Speed in a Monte Carlo</b></i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Simulation</b></i></p>
<p class="calibre1">In some applications, simulation code can run for hours, days, or even months, so speedup methods are of high interest. Here, we’ll look at two simulation examples. </p>
<p class="calibre1">To begin, let’s consider the following code from Section 8.6:</p>
<p class="calibre1">sum &lt;- 0</p>
<p class="calibre1">nreps &lt;- 100000</p>
<p class="calibre1">for (i in 1:nreps) {</p>
<p class="calibre1">xy &lt;- rnorm(2) # generate 2 N(0,1)s</p>
<p class="calibre1">sum &lt;- sum + max(xy)</p>
<p class="calibre1">}</p>
<p class="calibre1">print(sum/nreps)</p>
<p class="calibre1">Here’s a revision (hopefully faster):</p>
<p class="calibre1">nreps &lt;- 100000</p>
<p class="calibre1">xymat &lt;- matrix(rnorm(2*nreps),ncol=2)</p>
<p class="calibre1"><b class="calibre3">308</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p335"/>maxs &lt;- pmax(xymat[,1],xymat[,2])</p>
<p class="calibre1">print(mean(maxs))</p>
<p class="calibre1">In this code, we generate all the random variates at once, storing them in a matrix xymat, with one (X,Y) pair per row:</p>
<p class="calibre1">xymat &lt;- matrix(rnorm(2*nreps),ncol=2)</p>
<p class="calibre1">Next, we find all the max(X,Y) values, storing those values in maxs, and then simply call mean(). </p>
<p class="calibre1">It’s easier to program, and we believe it will be faster. Let’s check that. </p>
<p class="calibre1">I had the original code in the file  <i class="calibre4">MaxNorm.R </i> and the improved version in <i class="calibre4">MaxNorm2.R</i>. </p>
<p class="calibre1">&gt; system.time(source("MaxNorm.R"))</p>
<p class="calibre1">[1] 0.5667599</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">1.700</p>
<p class="calibre1">0.004</p>
<p class="calibre1">1.722</p>
<p class="calibre1">&gt; system.time(source("MaxNorm2.R"))</p>
<p class="calibre1">[1] 0.5649281</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.132</p>
<p class="calibre1">0.008</p>
<p class="calibre1">0.143</p>
<p class="calibre1">The speedup is dramatic, once again. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">We achieved an increase in speed, at the expense of using more memory, by keeping our</i> <i class="calibre4">random numbers in an array instead of generating and discarding them one pair at a</i> <i class="calibre4">time. As mentioned earlier, the time/space trade-off is a common one in the computing</i> <i class="calibre4">world and in the R world in particular. </i></p>
<p class="calibre1">We attained an excellent speedup in this example, but it was misleadingly easy. Let’s look at a slightly more complicated example. </p>
<p class="calibre1">Our next example is a classic exercise from elementary probability</p>
<p class="calibre1">courses. Urn 1 contains ten blue marbles and eight yellow ones. In urn 2, the mixture is six blue and six yellow. We draw a marble at random from urn 1, transfer it to urn 2, and then draw a marble at random from urn 2. </p>
<p class="calibre1">What is the probability that that second marble is blue? This is easy to find analytically, but we’ll use simulation. Here is the straightforward way: 1</p>
<p class="calibre1"># perform nreps repetitions of the marble experiment, to estimate</p>
<p class="calibre1">2</p>
<p class="calibre1"># P(pick blue from Urn 2)</p>
<p class="calibre1">3</p>
<p class="calibre1">sim1 &lt;- function(nreps) {</p>
<p class="calibre1">4</p>
<p class="calibre1">nb1 &lt;- 10 # 10 blue marbles in Urn 1</p>
<p class="calibre1">5</p>
<p class="calibre1">n1 &lt;- 18 # number of marbles in Urn 1 at 1st pick</p>
<p class="calibre1">6</p>
<p class="calibre1">n2 &lt;- 13 # number of marbles in Urn 2 at 2nd pick</p>
<p class="calibre1">7</p>
<p class="calibre1">count &lt;- 0 # number of repetitions in which get blue from Urn 2</p>
<p class="calibre1">8</p>
<p class="calibre1">for (i in 1:nreps) {</p>
<p class="calibre1">9</p>
<p class="calibre1">nb2 &lt;- 6 # 6 blue marbles orig. in Urn 2</p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">309</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p336"/>10</p>
<p class="calibre1"># pick from Urn 1 and put in Urn 2; is it blue? </p>
<p class="calibre1">11</p>
<p class="calibre1">if (runif(1) &lt; nb1/n1) nb2 &lt;- nb2 + 1</p>
<p class="calibre1">12</p>
<p class="calibre1"># pick from Urn 2; is it blue? </p>
<p class="calibre1">13</p>
<p class="calibre1">if (runif(1) &lt; nb2/n2) count &lt;- count + 1</p>
<p class="calibre1">14</p>
<p class="calibre1">}</p>
<p class="calibre1">15</p>
<p class="calibre1">return(count/nreps) # est. P(pick blue from Urn 2)</p>
<p class="calibre1">16</p>
<p class="calibre1">}</p>
<p class="calibre1">Here is how we can do it without loops, using apply():</p>
<p class="calibre1">1</p>
<p class="calibre1">sim2 &lt;- function(nreps) {</p>
<p class="calibre1">2</p>
<p class="calibre1">nb1 &lt;- 10</p>
<p class="calibre1">3</p>
<p class="calibre1">nb2 &lt;- 6</p>
<p class="calibre1">4</p>
<p class="calibre1">n1 &lt;- 18</p>
<p class="calibre1">5</p>
<p class="calibre1">n2 &lt;- 13</p>
<p class="calibre1">6</p>
<p class="calibre1"># pre-generate all our random numbers, one row per repetition</p>
<p class="calibre1">7</p>
<p class="calibre1">u &lt;- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)</p>
<p class="calibre1">8</p>
<p class="calibre1"># define simfun for use in apply(); simulates one repetition</p>
<p class="calibre1">9</p>
<p class="calibre1">simfun &lt;- function(rw) {</p>
<p class="calibre1">10</p>
<p class="calibre1"># rw ("row") is a pair of random numbers</p>
<p class="calibre1">11</p>
<p class="calibre1"># choose from Urn 1</p>
<p class="calibre1">12</p>
<p class="calibre1">if (rw[1] &lt; nb1/n1) nb2 &lt;- nb2 + 1</p>
<p class="calibre1">13</p>
<p class="calibre1"># choose from Urn 2, and return boolean on choosing blue</p>
<p class="calibre1">14</p>
<p class="calibre1">return (rw[2] &lt; nb2/n2)</p>
<p class="calibre1">15</p>
<p class="calibre1">}</p>
<p class="calibre1">16</p>
<p class="calibre1">z &lt;- apply(u,1,simfun)</p>
<p class="calibre1">17</p>
<p class="calibre1"># z is a vector of booleans but they can be treated as 1s, 0s</p>
<p class="calibre1">18</p>
<p class="calibre1">return(mean(z))</p>
<p class="calibre1">19</p>
<p class="calibre1">}</p>
<p class="calibre1">Here, we set up a matrix u with two columns of U(0,1) random variates. </p>
<p class="calibre1">The first column is used for our simulation of drawing from urn 1, and the second for drawing from urn 2. This way, we generate all our random numbers at once, which might save a bit of time, but the main point is to set up for using apply(). Toward that goal, our function simfun() works on one repetition of the experiment—that is, one row of u. We set up the call to apply() to go through all of the nreps repetitions. </p>
<p class="calibre1">Note that since the function simfun() is declared within sim2(), the locals of sim2()—n1, n2, nb1, and nb2—are available as globals of simfun(). Also, since a Boolean vector will automatically be changed by R to 1s and 0s, we can find the fraction of TRUE values in the vector by simply calling mean(). </p>
<p class="calibre1">Now, let’s compare performance. </p>
<p class="calibre1">&gt; system.time(print(sim1(100000)))</p>
<p class="calibre1">[1] 0.5086</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">2.465</p>
<p class="calibre1">0.028</p>
<p class="calibre1">2.586</p>
<p class="calibre1">&gt; system.time(print(sim2(10000)))</p>
<p class="calibre1"><b class="calibre3">310</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p337"/>[1] 0.5031</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">2.936</p>
<p class="calibre1">0.004</p>
<p class="calibre1">3.027</p>
<p class="calibre1">In spite of the many benefits of functional programming, this approach using apply() didn’t help. Instead, things got worse. Since this could be simply due to random sampling variation, I ran the code several times again, with similar results. </p>
<p class="calibre1">So, let’s look at vectorizing this simulation. </p>
<p class="calibre1">1</p>
<p class="calibre1">sim3 &lt;- function(nreps) {</p>
<p class="calibre1">2</p>
<p class="calibre1">nb1 &lt;- 10</p>
<p class="calibre1">3</p>
<p class="calibre1">nb2 &lt;- 6</p>
<p class="calibre1">4</p>
<p class="calibre1">n1 &lt;- 18</p>
<p class="calibre1">5</p>
<p class="calibre1">n2 &lt;- 13</p>
<p class="calibre1">6</p>
<p class="calibre1">u &lt;- matrix(c(runif(2*nreps)),nrow=nreps,ncol=2)</p>
<p class="calibre1">7</p>
<p class="calibre1"># set up the condition vector</p>
<p class="calibre1">8</p>
<p class="calibre1">cndtn &lt;- u[,1] &lt;= nb1/n1 &amp; u[,2] &lt;= (nb2+1)/n2 |</p>
<p class="calibre1">9</p>
<p class="calibre1">u[,1] &gt; nb1/n1 &amp; u[,2] &lt;= nb2/n2</p>
<p class="calibre1">10</p>
<p class="calibre1">return(mean(cndtn))</p>
<p class="calibre1">11</p>
<p class="calibre1">}</p>
<p class="calibre1">The main work is done in this statement:</p>
<p class="calibre1">cndtn &lt;- u[,1] &lt;= nb1/n1 &amp; u[,2] &lt;= (nb2+1)/n2 |</p>
<p class="calibre1">u[,1] &gt; nb1/n1 &amp; u[,2] &lt;= nb2/n2</p>
<p class="calibre1">To get that, we reasoned out which conditions would lead to choosing a blue marble on the second pick, coded them, and then assigned them to cndtn. </p>
<p class="calibre1">Remember that  <i class="calibre4">&lt; </i>= and &amp; are functions; in fact, they are vector functions, so they should be fast. Sure enough, this brings quite an improvement:</p>
<p class="calibre1">&gt; system.time(print(sim3(10000)))</p>
<p class="calibre1">[1] 0.4987</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.060</p>
<p class="calibre1">0.016</p>
<p class="calibre1">0.076</p>
<p class="calibre1">In principle, the approach we took to speed up the code here could be applied to many other Monte Carlo simulations. However, it’s clear that the analog of the statement that computes cndtn would quickly become quite complex, even for seemingly simple applications. </p>
<p class="calibre1">Moreover, the approach would not work in “infinite-stage” situations, meaning an unlimited number of time steps. Here, we are considering the marble example as being two-stage, with two columns to the matrix u. </p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">311</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p338"/> <i class="calibre4"><b class="calibre3">14.2.3 Extended Example: Generating a Powers Matrix</b></i></p>
<p class="calibre1">Recall in Section 9.1.7, we needed to generate a matrix of powers of our predictor variable. We used the following code:</p>
<p class="calibre1">1</p>
<p class="calibre1"># forms matrix of powers of the vector x, through degree dg</p>
<p class="calibre1">2</p>
<p class="calibre1">powers1 &lt;- function(x,dg) {</p>
<p class="calibre1">3</p>
<p class="calibre1">pw &lt;- matrix(x,nrow=length(x))</p>
<p class="calibre1">4</p>
<p class="calibre1">prod &lt;- x # current product</p>
<p class="calibre1">5</p>
<p class="calibre1">for (i in 2:dg) {</p>
<p class="calibre1">6</p>
<p class="calibre1">prod &lt;- prod * x</p>
<p class="calibre1">7</p>
<p class="calibre1">pw &lt;- cbind(pw,prod)</p>
<p class="calibre1">8</p>
<p class="calibre1">}</p>
<p class="calibre1">9</p>
<p class="calibre1">return(pw)</p>
<p class="calibre1">10</p>
<p class="calibre1">}</p>
<p class="calibre1">One glaring problem is that cbind() is used to build up the output matrix, column by column. This is very costly in terms of memory-allocation time. It’s much better to allocate the full matrix at the beginning, even though it will be empty, as this will mean incurring the cost of only one memory-allocation operation. </p>
<p class="calibre1">1</p>
<p class="calibre1"># forms matrix of powers of the vector x, through degree dg</p>
<p class="calibre1">2</p>
<p class="calibre1">powers2 &lt;- function(x,dg) {</p>
<p class="calibre1">3</p>
<p class="calibre1">pw &lt;- matrix(nrow=length(x),ncol=dg)</p>
<p class="calibre1">4</p>
<p class="calibre1">prod &lt;- x # current product</p>
<p class="calibre1">5</p>
<p class="calibre1">pw[,1] &lt;- prod</p>
<p class="calibre1">6</p>
<p class="calibre1">for (i in 2:dg) {</p>
<p class="calibre1">7</p>
<p class="calibre1">prod &lt;- prod * x</p>
<p class="calibre1">8</p>
<p class="calibre1">pw[,i] &lt;- prod</p>
<p class="calibre1">9</p>
<p class="calibre1">}</p>
<p class="calibre1">10</p>
<p class="calibre1">return(pw)</p>
<p class="calibre1">11</p>
<p class="calibre1">}</p>
<p class="calibre1">And indeed, powers2() is a lot faster. </p>
<p class="calibre1">&gt; x &lt;- runif(1000000)</p>
<p class="calibre1">&gt; system.time(powers1(x,8))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.776</p>
<p class="calibre1">0.356</p>
<p class="calibre1">1.334</p>
<p class="calibre1">&gt; system.time(powers2(x,8))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.388</p>
<p class="calibre1">0.204</p>
<p class="calibre1">0.593</p>
<p class="calibre1"><b class="calibre3">312</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p339"/>And yet, powers2() still contains a loop. Can we do better? It would seem that this setting is perfect for outer(), whose call form is</p>
<p class="calibre1">outer(X,Y,FUN)</p>
<p class="calibre1">This call applies the function FUN() to all possible pairs of elements of X</p>
<p class="calibre1">and elements of Y. The default value of FUN is multiplication. </p>
<p class="calibre1">Here, we can write the following:</p>
<p class="calibre1">powers3 &lt;- function(x,dg) return(outer(x,1:dg,"^"))</p>
<p class="calibre1">For each combination of element of x and element of 1:dg (resulting in length(x)  <i class="calibre4">× </i> dg combinations in all), outer() calls the exponentiation function</p>
<p class="calibre1">^ on that combination, placing the results in a length(x)  <i class="calibre4">× </i> dg matrix. This is exactly what we need, and as a bonus, the code is quite compact. But is the code faster? </p>
<p class="calibre1">&gt; system.time(powers3(x,8))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">1.336</p>
<p class="calibre1">0.204</p>
<p class="calibre1">1.747</p>
<p class="calibre1">What a disappointment! Here, we’re using a fancy R function, with very compact code, but getting the worst performance of the three functions. </p>
<p class="calibre1">And it gets even worse. Here’s what happens if we try to make use of cumprod():</p>
<p class="calibre1">&gt; powers4</p>
<p class="calibre1">function(x,dg) {</p>
<p class="calibre1">repx &lt;- matrix(rep(x,dg),nrow=length(x))</p>
<p class="calibre1">return(t(apply(repx,1,cumprod)))</p>
<p class="calibre1">}</p>
<p class="calibre1">&gt; system.time(powers4(x,8))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">28.106</p>
<p class="calibre1">1.120 83.255</p>
<p class="calibre1">In this example, we made multiple copies of x, since the powers of a number n are simply cumprod(c(1,n,n,n...)). But in spite of dutifully using two C-level R functions, the performance was disastrous. </p>
<p class="calibre1">The moral of the story is that performance issues can be unpredictable. </p>
<p class="calibre1">All you can do is be armed with an understanding of the basic issues, vectorization, and the memory aspects explained next and then try various approaches. </p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">313</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p340"/><b class="calibre3">14.3 Functional Programming and Memory Issues</b></p>
<p class="calibre1">Most R objects are  <i class="calibre4">immutable</i>, or unchangeable. Thus, R operations are implemented as functions that reassign to the given object, a trait that can have performance implications. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.3.1 Vector Assignment Issues</b></i></p>
<p class="calibre1">As an example of some of the issues that can arise, consider this simple-looking statement:</p>
<p class="calibre1">z[3] &lt;- 8</p>
<p class="calibre1">As noted in Chapter 7, this assignment is more complex than it seems. It is actually implemented via the replacement function "[&lt;-" through this call and assignment:</p>
<p class="calibre1">z &lt;- "[&lt;-"(z,3,value=8)</p>
<p class="calibre1">An internal copy of z is made, element 3 of the copy is changed to 8, and then the resulting vector is reassigned to z. And recall that the latter simply means that z is pointed to the copy. </p>
<p class="calibre1">In other words, even though we are ostensibly changing just one element of the vector, the semantics say that  <i class="calibre4">the entire vector is recomputed</i>. For a long vector, this would slow down the program considerably. The same would be true for a shorter vector if it were assigned from within a loop of our code. </p>
<p class="calibre1">In some situations, R does take some measures to mitigate this impact, but it is a key point to consider when aiming for fast code. You should be mindful of this when working with vectors (including arrays). If your code seems to be running unexpectedly slowly, assignment of vectors should be a prime area of suspicion. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.3.2 Copy-on-Change Issues</b></i></p>
<p class="calibre1">A related issue is that R (usually) follows a  <i class="calibre4">copy-on-change </i> policy. For instance, if we execute the following in the previous setting:</p>
<p class="calibre1">&gt; y &lt;- z</p>
<p class="calibre1">then initially y shares the same memory area with z. But if either of them changes, then a copy is made in a different area of memory, and the changed variable will occupy the new area of memory. However, only the <i class="calibre4">first </i> change is affected, as the relocating of the moved variable means there are no longer any sharing issues. The function tracemem() will report such memory relocations. </p>
<p class="calibre1"><b class="calibre3">314</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p341"/>Though R usually adheres to copy-on-change semantics, there are excep-tions. For example, R doesn’t exhibit the location-change behavior in the following setting:</p>
<p class="calibre1">&gt; z &lt;- runif(10)</p>
<p class="calibre1">&gt; tracemem(z)</p>
<p class="calibre1">[1] "&lt;0x88c3258&gt;" </p>
<p class="calibre1">&gt; z[3] &lt;- 8</p>
<p class="calibre1">&gt; tracemem(z)</p>
<p class="calibre1">[1] "&lt;0x88c3258&gt;" </p>
<p class="calibre1">The location of z didn’t change; it was at memory address 0x88c3258</p>
<p class="calibre1">both before and after the assignment to z[3] was executed. Thus, although you should be vigilant about location change, you also can’t assume it. </p>
<p class="calibre1">Let’s look at the times involved. </p>
<p class="calibre1">&gt; z &lt;- 1:10000000</p>
<p class="calibre1">&gt; system.time(z[3] &lt;- 8)</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.180</p>
<p class="calibre1">0.084</p>
<p class="calibre1">0.265</p>
<p class="calibre1">&gt; system.time(z[33] &lt;- 88)</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">In any event, if copying is done, the vehicle is R’s internal function duplicate(). (The function is called duplicate1() in recent versions of R.) If you’re familiar with the GDB debugging tool and your R build includes debugging information, you can explore the circumstances under which a copy is performed. </p>
<p class="calibre1">Following the guide in Section 15.1.4, start up R with GDB, step through R through GDB, and place a breakpoint at duplicate1(). Each time you break at that function, submit this GDB command:</p>
<p class="calibre1">call Rf_PrintValue(s)</p>
<p class="calibre1">This will print the value of s (or whatever variable is of interest). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.3.3 Extended Example: Avoiding Memory Copy</b></i></p>
<p class="calibre1">This example, though artificial, will demonstrate the memory-copy issues discussed in the previous section. </p>
<p class="calibre1">Suppose we have a large number of unrelated vectors and, among other things, we wish to set the third element of each to 8. We could store the vectors in a matrix, one vector per row. But since they are unrelated, maybe even of different lengths, we may consider storing them in a list. </p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">315</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p342"/>But things can get very subtle when it comes to R performance issues, so let’s try it out. </p>
<p class="calibre1">&gt; m &lt;- 5000</p>
<p class="calibre1">&gt; n &lt;- 1000</p>
<p class="calibre1">&gt; z &lt;- list()</p>
<p class="calibre1">&gt; for (i in 1:m) z[[i]] &lt;- sample(1:10,n,replace=T)</p>
<p class="calibre1">&gt; system.time(for (i in 1:m) z[[i]][3] &lt;- 8)</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.288</p>
<p class="calibre1">0.024</p>
<p class="calibre1">0.321</p>
<p class="calibre1">&gt; z &lt;- matrix(sample(1:10,m*n,replace=T),nrow=m)</p>
<p class="calibre1">&gt; system.time(z[,3] &lt;- 8)</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.008</p>
<p class="calibre1">0.044</p>
<p class="calibre1">0.052</p>
<p class="calibre1">Except for system time (again), the matrix formulation did better. </p>
<p class="calibre1">One of the reasons is that in the list version, we encounter the memory-copy problem in each iteration of the loop. But in the matrix version, we encounter it only once. And, of course, the matrix version is vectorized. </p>
<p class="calibre1">But what about using lapply() on the list version? </p>
<p class="calibre1">&gt; </p>
<p class="calibre1">&gt; set3 &lt;- function(lv) {</p>
<p class="calibre1">+</p>
<p class="calibre1">lv[3] &lt;- 8</p>
<p class="calibre1">+</p>
<p class="calibre1">return(lv)</p>
<p class="calibre1">+ }</p>
<p class="calibre1">&gt; z &lt;- list()</p>
<p class="calibre1">&gt; for (i in 1:m) z[[i]] &lt;- sample(1:10,n,replace=T)</p>
<p class="calibre1">&gt; system.time(lapply(z,set3))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.100</p>
<p class="calibre1">0.012</p>
<p class="calibre1">0.112</p>
<p class="calibre1">It’s hard to beat vectorized code. </p>
<p class="calibre1"><b class="calibre3">14.4 Using Rprof() to Find Slow Spots in Your Code</b></p>
<p class="calibre1">If you think your R code is running unnecessarily slowly, a handy tool for finding the culprit is Rprof(), which gives you a report of (approximately) how much time your code is spending in each of the functions it calls. This is important, as it may not be wise to optimize  <i class="calibre4">every </i> section of your program. </p>
<p class="calibre1">Optimization may come at the expense of coding time and code clarity, so it’s of value to know where optimization would really help. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.4.1 Monitoring with Rprof()</b></i></p>
<p class="calibre1">Let’s demonstrate using Rprof() with our three versions of code to find a powers matrix from the previous extended example. We’ll call Rprof() to get the monitor started, run our code, and then call Rprof() with a NULL</p>
<p class="calibre1"><b class="calibre3">316</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p343"/>argument to stop the monitoring. Finally, we’ll call summaryRprof() to see the results. </p>
<p class="calibre1">&gt; x &lt;- runif(1000000)</p>
<p class="calibre1">&gt; Rprof()</p>
<p class="calibre1">&gt; invisible(powers1(x,8))</p>
<p class="calibre1">&gt; Rprof(NULL)</p>
<p class="calibre1">&gt; summaryRprof()</p>
<p class="calibre1">$by.self</p>
<p class="calibre1">self.time self.pct total.time total.pct</p>
<p class="calibre1">"cbind" </p>
<p class="calibre1">0.74</p>
<p class="calibre1">86.0</p>
<p class="calibre1">0.74</p>
<p class="calibre1">86.0</p>
<p class="calibre1">"*" </p>
<p class="calibre1">0.10</p>
<p class="calibre1">11.6</p>
<p class="calibre1">0.10</p>
<p class="calibre1">11.6</p>
<p class="calibre1">"matrix" </p>
<p class="calibre1">0.02</p>
<p class="calibre1">2.3</p>
<p class="calibre1">0.02</p>
<p class="calibre1">2.3</p>
<p class="calibre1">"powers1" </p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">0.86</p>
<p class="calibre1">100.0</p>
<p class="calibre1">$by.total</p>
<p class="calibre1">total.time total.pct self.time self.pct</p>
<p class="calibre1">"powers1" </p>
<p class="calibre1">0.86</p>
<p class="calibre1">100.0</p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">"cbind" </p>
<p class="calibre1">0.74</p>
<p class="calibre1">86.0</p>
<p class="calibre1">0.74</p>
<p class="calibre1">86.0</p>
<p class="calibre1">"*" </p>
<p class="calibre1">0.10</p>
<p class="calibre1">11.6</p>
<p class="calibre1">0.10</p>
<p class="calibre1">11.6</p>
<p class="calibre1">"matrix" </p>
<p class="calibre1">0.02</p>
<p class="calibre1">2.3</p>
<p class="calibre1">0.02</p>
<p class="calibre1">2.3</p>
<p class="calibre1">$sampling.time</p>
<p class="calibre1">[1] 0.86</p>
<p class="calibre1">We see immediately that the runtime of our code is dominated by calls to cbind(), which as we noted in the extended example is indeed slowing things down. </p>
<p class="calibre1">By the way, the call to invisible() in this example is used to suppress output. We certainly don’t want to see the 1,000,000-row matrix returned by powers1() here! </p>
<p class="calibre1">Profiling powers2() does not show any obvious bottlenecks. </p>
<p class="calibre1">&gt; Rprof()</p>
<p class="calibre1">&gt; invisible(powers2(x,8))</p>
<p class="calibre1">&gt; Rprof(NULL)</p>
<p class="calibre1">&gt; summaryRprof()</p>
<p class="calibre1">$by.self</p>
<p class="calibre1">self.time self.pct total.time total.pct</p>
<p class="calibre1">"powers2" </p>
<p class="calibre1">0.38</p>
<p class="calibre1">67.9</p>
<p class="calibre1">0.56</p>
<p class="calibre1">100.0</p>
<p class="calibre1">"matrix" </p>
<p class="calibre1">0.14</p>
<p class="calibre1">25.0</p>
<p class="calibre1">0.14</p>
<p class="calibre1">25.0</p>
<p class="calibre1">"*" </p>
<p class="calibre1">0.04</p>
<p class="calibre1">7.1</p>
<p class="calibre1">0.04</p>
<p class="calibre1">7.1</p>
<p class="calibre1">$by.total</p>
<p class="calibre1">total.time total.pct self.time self.pct</p>
<p class="calibre1">"powers2" </p>
<p class="calibre1">0.56</p>
<p class="calibre1">100.0</p>
<p class="calibre1">0.38</p>
<p class="calibre1">67.9</p>
<p class="calibre1">"matrix" </p>
<p class="calibre1">0.14</p>
<p class="calibre1">25.0</p>
<p class="calibre1">0.14</p>
<p class="calibre1">25.0</p>
<p class="calibre1">"*" </p>
<p class="calibre1">0.04</p>
<p class="calibre1">7.1</p>
<p class="calibre1">0.04</p>
<p class="calibre1">7.1</p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">317</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p344"/>$sampling.time</p>
<p class="calibre1">[1] 0.56</p>
<p class="calibre1">What about powers3(), the promising approach that didn’t pan out? </p>
<p class="calibre1">&gt; Rprof()</p>
<p class="calibre1">&gt; invisible(powers3(x,8))</p>
<p class="calibre1">&gt; Rprof(NULL)</p>
<p class="calibre1">&gt; summaryRprof()</p>
<p class="calibre1">$by.self</p>
<p class="calibre1">self.time self.pct total.time total.pct</p>
<p class="calibre1">"FUN" </p>
<p class="calibre1">0.94</p>
<p class="calibre1">56.6</p>
<p class="calibre1">0.94</p>
<p class="calibre1">56.6</p>
<p class="calibre1">"outer" </p>
<p class="calibre1">0.72</p>
<p class="calibre1">43.4</p>
<p class="calibre1">1.66</p>
<p class="calibre1">100.0</p>
<p class="calibre1">"powers3" </p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">1.66</p>
<p class="calibre1">100.0</p>
<p class="calibre1">$by.total</p>
<p class="calibre1">total.time total.pct self.time self.pct</p>
<p class="calibre1">"outer" </p>
<p class="calibre1">1.66</p>
<p class="calibre1">100.0</p>
<p class="calibre1">0.72</p>
<p class="calibre1">43.4</p>
<p class="calibre1">"powers3" </p>
<p class="calibre1">1.66</p>
<p class="calibre1">100.0</p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">"FUN" </p>
<p class="calibre1">0.94</p>
<p class="calibre1">56.6</p>
<p class="calibre1">0.94</p>
<p class="calibre1">56.6</p>
<p class="calibre1">$sampling.time</p>
<p class="calibre1">[1] 1.66</p>
<p class="calibre1">The function logging the largest amount of time was FUN(), which as noted in our extended example is simply multiplication. For each pair of elements of x here, one of the elements is multiplied by the other; that is, a product of two scalars is found. In other words, no vectorization! No wonder it was slow. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.4.2 How Rprof() Works</b></i></p>
<p class="calibre1">Let’s explore in a bit more detail what Rprof() does. Every 0.02 seconds (the default value), R inspects the call stack to determine which function calls are in effect at that time. It writes the result of each inspection to a file, by default  <i class="calibre4">Rprof.out</i>. Here is an excerpt of that file from our run of powers3():</p>
<p class="calibre1">... </p>
<p class="calibre1">"outer" "powers3" </p>
<p class="calibre1">"outer" "powers3" </p>
<p class="calibre1">"outer" "powers3" </p>
<p class="calibre1">"FUN" "outer" "powers3" </p>
<p class="calibre1">"FUN" "outer" "powers3" </p>
<p class="calibre1">"FUN" "outer" "powers3" </p>
<p class="calibre1">"FUN" "outer" "powers3" </p>
<p class="calibre1">... </p>
<p class="calibre1"><b class="calibre3">318</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p345"/>So, Rprof() often found that at inspection time, powers3() had called outer(), which in turn had called FUN(), the latter being the currently executing function. The function summaryRprof() conveniently summarizes all those lines in the file, but you may find that looking at the file itself reveals more insights in some cases. </p>
<p class="calibre1">Note, too, that Rprof() is no panacea. If the code you’re profiling produces many function calls (including indirect calls, triggered when your code calls some function that then calls another within R), the profiling output may be hard to decipher. This is arguably the case for the output from powers4():</p>
<p class="calibre1">$by.self</p>
<p class="calibre1">self.time self.pct total.time total.pct</p>
<p class="calibre1">"apply" </p>
<p class="calibre1">19.46</p>
<p class="calibre1">67.5</p>
<p class="calibre1">27.56</p>
<p class="calibre1">95.6</p>
<p class="calibre1">"lapply" </p>
<p class="calibre1">4.02</p>
<p class="calibre1">13.9</p>
<p class="calibre1">5.68</p>
<p class="calibre1">19.7</p>
<p class="calibre1">"FUN" </p>
<p class="calibre1">2.56</p>
<p class="calibre1">8.9</p>
<p class="calibre1">2.56</p>
<p class="calibre1">8.9</p>
<p class="calibre1">"as.vector" </p>
<p class="calibre1">0.82</p>
<p class="calibre1">2.8</p>
<p class="calibre1">0.82</p>
<p class="calibre1">2.8</p>
<p class="calibre1">"t.default" </p>
<p class="calibre1">0.54</p>
<p class="calibre1">1.9</p>
<p class="calibre1">0.54</p>
<p class="calibre1">1.9</p>
<p class="calibre1">"unlist" </p>
<p class="calibre1">0.40</p>
<p class="calibre1">1.4</p>
<p class="calibre1">6.08</p>
<p class="calibre1">21.1</p>
<p class="calibre1">"!" </p>
<p class="calibre1">0.34</p>
<p class="calibre1">1.2</p>
<p class="calibre1">0.34</p>
<p class="calibre1">1.2</p>
<p class="calibre1">"is.null" </p>
<p class="calibre1">0.32</p>
<p class="calibre1">1.1</p>
<p class="calibre1">0.32</p>
<p class="calibre1">1.1</p>
<p class="calibre1">"aperm" </p>
<p class="calibre1">0.22</p>
<p class="calibre1">0.8</p>
<p class="calibre1">0.22</p>
<p class="calibre1">0.8</p>
<p class="calibre1">"matrix" </p>
<p class="calibre1">0.14</p>
<p class="calibre1">0.5</p>
<p class="calibre1">0.74</p>
<p class="calibre1">2.6</p>
<p class="calibre1">"!=" </p>
<p class="calibre1">0.02</p>
<p class="calibre1">0.1</p>
<p class="calibre1">0.02</p>
<p class="calibre1">0.1</p>
<p class="calibre1">"powers4" </p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">28.84</p>
<p class="calibre1">100.0</p>
<p class="calibre1">"t" </p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">28.10</p>
<p class="calibre1">97.4</p>
<p class="calibre1">"array" </p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">0.22</p>
<p class="calibre1">0.8</p>
<p class="calibre1">$by.total</p>
<p class="calibre1">total.time total.pct self.time self.pct</p>
<p class="calibre1">"powers4" </p>
<p class="calibre1">28.84</p>
<p class="calibre1">100.0</p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">"t" </p>
<p class="calibre1">28.10</p>
<p class="calibre1">97.4</p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">"apply" </p>
<p class="calibre1">27.56</p>
<p class="calibre1">95.6</p>
<p class="calibre1">19.46</p>
<p class="calibre1">67.5</p>
<p class="calibre1">"unlist" </p>
<p class="calibre1">6.08</p>
<p class="calibre1">21.1</p>
<p class="calibre1">0.40</p>
<p class="calibre1">1.4</p>
<p class="calibre1">"lapply" </p>
<p class="calibre1">5.68</p>
<p class="calibre1">19.7</p>
<p class="calibre1">4.02</p>
<p class="calibre1">13.9</p>
<p class="calibre1">"FUN" </p>
<p class="calibre1">2.56</p>
<p class="calibre1">8.9</p>
<p class="calibre1">2.56</p>
<p class="calibre1">8.9</p>
<p class="calibre1">"as.vector" </p>
<p class="calibre1">0.82</p>
<p class="calibre1">2.8</p>
<p class="calibre1">0.82</p>
<p class="calibre1">2.8</p>
<p class="calibre1">"matrix" </p>
<p class="calibre1">0.74</p>
<p class="calibre1">2.6</p>
<p class="calibre1">0.14</p>
<p class="calibre1">0.5</p>
<p class="calibre1">"t.default" </p>
<p class="calibre1">0.54</p>
<p class="calibre1">1.9</p>
<p class="calibre1">0.54</p>
<p class="calibre1">1.9</p>
<p class="calibre1">"!" </p>
<p class="calibre1">0.34</p>
<p class="calibre1">1.2</p>
<p class="calibre1">0.34</p>
<p class="calibre1">1.2</p>
<p class="calibre1">"is.null" </p>
<p class="calibre1">0.32</p>
<p class="calibre1">1.1</p>
<p class="calibre1">0.32</p>
<p class="calibre1">1.1</p>
<p class="calibre1">"aperm" </p>
<p class="calibre1">0.22</p>
<p class="calibre1">0.8</p>
<p class="calibre1">0.22</p>
<p class="calibre1">0.8</p>
<p class="calibre1">"array" </p>
<p class="calibre1">0.22</p>
<p class="calibre1">0.8</p>
<p class="calibre1">0.00</p>
<p class="calibre1">0.0</p>
<p class="calibre1">"!=" </p>
<p class="calibre1">0.02</p>
<p class="calibre1">0.1</p>
<p class="calibre1">0.02</p>
<p class="calibre1">0.1</p>
<p class="calibre1">$sampling.time</p>
<p class="calibre1">[1] 28.84</p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">319</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p346"/><b class="calibre3">14.5 Byte Code Compilation</b></p>
<p class="calibre1">Starting with version 2.13, R has included a  <i class="calibre4">byte code compiler</i>, which you can use to try to speed up your code. Consider our example from Section 14.2.1. </p>
<p class="calibre1">As a trivial example, we showed that</p>
<p class="calibre1">z &lt;- x + y</p>
<p class="calibre1">was much faster than</p>
<p class="calibre1">for (i in 1:length(x)) z[i] &lt;- x[i] + y[i]</p>
<p class="calibre1">Again, that was obvious, but just to get an idea of how byte code compilation works, let’s give it a try:</p>
<p class="calibre1">&gt; library(compiler)</p>
<p class="calibre1">&gt; f &lt;- function() for (i in 1:length(x)) z[i] &lt;&lt;- x[i] + y[i]</p>
<p class="calibre1">&gt; cf &lt;- cmpfun(f)</p>
<p class="calibre1">&gt; system.time(cf())</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.845</p>
<p class="calibre1">0.003</p>
<p class="calibre1">0.848</p>
<p class="calibre1">We created a new function, cf(), from the original f(). The new code’s run time was 0.848 seconds, much faster than the 8.175 seconds the non-compiled version took. Granted, it still wasn’t as fast as the straightforward vectorized code, but it is clear that byte code compilation has potential. You should try it whenever you need faster code. </p>
<p class="calibre1"><b class="calibre3">14.6 Oh No, the Data Doesn’t Fit into Memory! </b></p>
<p class="calibre1">As mentioned earlier, all objects in an R session are stored in memory. R</p>
<p class="calibre1">places a limit of 231  <i class="calibre4">− </i> 1 bytes on the size of any object, regardless of word size (32-bit versus 64-bit) and the amount of RAM in your machine. However, you really should not consider this an obstacle. With a little extra care, applications that have large memory requirements can indeed be handled well in R. Some common approaches are chunking and using R packages for memory management. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.6.1 Chunking</b></i></p>
<p class="calibre1">One option involving no extra R packages at all is to read in your data from a disk file one chunk at a time. For example, suppose that our goal is to find means or proportions of some variables. We can use the skip argument in read.table(). </p>
<p class="calibre1">Say our data set has 1,000,000 records and we divide them into 10</p>
<p class="calibre1">chunks (or more—whatever is needed to cut the data down to a size so it fits in memory). Then we set skip = 0 on our first read, set skip = 100000</p>
<p class="calibre1">the second time, and so on. Each time we read in a chunk, we calculate <b class="calibre3">320</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p347"/>the counts or totals for that chunk and record them. After reading all the chunks, we add up all the counts or totals in order to calculate our grand means or proportions. </p>
<p class="calibre1">As another example, suppose we are performing a statistical operation, say calculating principle components, in which we have a huge number of rows—that is, a huge number of observations—but the number of variables is manageable. Again, chunking could be the solution. We apply the statistical operation to each chunk and then average the results over all the chunks. My mathematical research shows that the resulting estimators are statistically efficient in a wide class of statistical methods. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">14.6.2 Using R Packages for Memory Management</b></i></p>
<p class="calibre1">Again looking at a bit more sophistication, there are alternatives for accommodating large memory requirements in the form of some specialized R</p>
<p class="calibre1">packages. </p>
<p class="calibre1">One such package is RMySQL, an R interface to SQL databases. Using it requires some database expertise, but this package provides a much more efficient and convenient way to handle large data sets. The idea is to have SQL do its variable/case selection operations for you back at the database end and then read the resulting selected data as it is produced by SQL. </p>
<p class="calibre1">Since the latter will typically be much smaller than the overall data set, you will likely be able to circumvent R’s memory restriction. </p>
<p class="calibre1">Another useful package is biglm, which does regression and generalized linear-model analysis on very large data sets. It also uses chunking but in a different manner: Each chunk is used to update the running totals of sums needed for the regression analysis and then discarded. </p>
<p class="calibre1">Finally, some packages do their own storage management indepen-</p>
<p class="calibre1">dently of R and thus can deal with very large data sets. The two most commonly used today are ff and bigmemory. The former sidesteps memory constraints by storing data on disk instead of memory, essentially transparently to the programmer. The highly versatile bigmemory package does the same, but it can store data not only on disk but also in the machine’s main memory, which is ideal for multicore machines. </p>
<p class="calibre1">Performance Enhancement: Speed and Memory</p>
<p class="calibre1"><b class="calibre3">321</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p348"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p349"/><img src="index-349_1.png" alt="Image 42" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">15</b></p>
<p class="calibre1"><b class="calibre3">INTERFACING R TO OTHER</b></p>
<p class="calibre1"><b class="calibre3">LANGUAGES</b></p>
<p class="calibre1">R is a great language, but it can’t do every-</p>
<p class="calibre1">thing well. Thus, it is sometimes desirable</p>
<p class="calibre1">to call code written in other languages from</p>
<p class="calibre1">R. Conversely, when working in other great lan-</p>
<p class="calibre1">guages, you may encounter tasks that could be better</p>
<p class="calibre1">done in R. </p>
<p class="calibre1">R interfaces have been developed for a number of other languages, </p>
<p class="calibre1">from ubiquitous languages like C to esoteric ones like the Yacas computer algebra system. This chapter will cover two interfaces: one for calling C/C++ from R and the other for calling R from Python. </p>
<p class="calibre1"><b class="calibre3">15.1 Writing C/C++ Functions to Be Called from R</b></p>
<p class="calibre1">You may wish to write your own C/C++ functions to be called from R. Typically, the goal is performance enhancement, since C/C++ code may run much faster than R, even if you use vectorization and other R optimization techniques to speed things up. </p>
<p class="calibre1">Another possible goal in dropping down to the C/C++ level is specialized I/O. For example, R uses the TCP protocol in layer 3 of the standard Internet communication system, but UDP can be faster in some settings. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p350"/>To work in UDP, you need C/C++, which requires an interface to R for those languages. </p>
<p class="calibre1">R actually offers two C/C++ interfaces via the functions .C() and</p>
<p class="calibre1">.Call(). The latter is more versatile but requires some knowledge of R’s internal structures, so we’ll stick with .C() here. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">15.1.1 Some R-to-C/C++ Preliminaries</b></i></p>
<p class="calibre1">In C, two-dimensional arrays are stored in row-major order, in contrast to R’s column-major order. For instance, if you have a 3-by-4 array, the element in the second row and second column is element number 5 of the array when viewed linearly, since there are three elements in the first column and this is the second element in the second column. Also keep in mind that C subscripts begin at 0, rather than at 1, as with R. </p>
<p class="calibre1">All the arguments passed from R to C are received by C as pointers. </p>
<p class="calibre1">Note that the C function itself must return void. Values that you would ordinarily return must be communicated through the function’s arguments, such as result in the following example. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">15.1.2 Example: Extracting Subdiagonals from a Square Matrix</b></i></p>
<p class="calibre1">Here, we will write C code to extract subdiagonals from a square matrix. </p>
<p class="calibre1">(Thanks to my former graduate assistant, Min-Yu Huang, who wrote an earlier version of this function.) Here’s the code for the file  <i class="calibre4">sd.c</i>:</p>
<p class="calibre1">#include &lt;R.h&gt; // required</p>
<p class="calibre1">// arguments:</p>
<p class="calibre1">//</p>
<p class="calibre1">m: a square matrix</p>
<p class="calibre1">//</p>
<p class="calibre1">n: number of rows/columns of m</p>
<p class="calibre1">//</p>
<p class="calibre1">k: the subdiagonal index--0 for main diagonal, 1 for first</p>
<p class="calibre1">//</p>
<p class="calibre1">subdiagonal, 2 for the second, etc. </p>
<p class="calibre1">//</p>
<p class="calibre1">result: space for the requested subdiagonal, returned here</p>
<p class="calibre1">void subdiag(double *m, int *n, int *k, double *result)</p>
<p class="calibre1">{</p>
<p class="calibre1">int nval = *n, kval = *k; </p>
<p class="calibre1">int stride = nval + 1; </p>
<p class="calibre1">for (int i = 0, j = kval; i &lt; nval-kval; ++i, j+= stride)</p>
<p class="calibre1">result[i] = m[j]; </p>
<p class="calibre1">}</p>
<p class="calibre1">The variable stride alludes to a concept from the parallel-processing community. Say we have a matrix in 1,000 columns and our C code is looping through all the elements in a given column, from top to bottom. Again, since C uses row-major order, consecutive elements in the column are 1,000</p>
<p class="calibre1">elements apart from each other if the matrix is viewed as one long vector. </p>
<p class="calibre1"><b class="calibre3">324</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p351"/>Here, we would say that we are traversing that long vector with a stride of 1,000—that is, accessing every thousandth element. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">15.1.3 Compiling and Running Code</b></i></p>
<p class="calibre1">You compile your code using R. For example, in a Linux terminal window, we could compile our file like this:</p>
<p class="calibre1">% R CMD SHLIB sd.c</p>
<p class="calibre1">gcc -std=gnu99 -I/usr/share/R/include</p>
<p class="calibre1">-fpic -g -O2 -c sd.c -o sd.o</p>
<p class="calibre1">gcc -std=gnu99 -shared -o sd.so sd.o</p>
<p class="calibre1">-L/usr/lib/R/lib -lR</p>
<p class="calibre1">This would produce the dynamic shared library file  <i class="calibre4">sd.so</i>. </p>
<p class="calibre1">Note that R has reported how it invoked GCC in the output of the example. You can also run these commands by hand if you have special requirements, such as special libraries to be linked in. Also note that the locations of the  <i class="calibre4">include </i> and  <i class="calibre4">lib </i> directories may be system-dependent. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">GCC is easily downloadable for Linux systems. For Windows, it is included in</i> <i class="calibre4">Cygwin, an open source package available from </i> http://www.cygwin.com/ <i class="calibre4">. </i></p>
<p class="calibre1">We can then load our library into R and call our C function like this:</p>
<p class="calibre1">&gt; dyn.load("sd.so")</p>
<p class="calibre1">&gt; m &lt;- rbind(1:5, 6:10, 11:15, 16:20, 21:25)</p>
<p class="calibre1">&gt; k &lt;- 2</p>
<p class="calibre1">&gt; .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k), result=double(dim(m)[1]-k))</p>
<p class="calibre1">[[1]]</p>
<p class="calibre1">[1] 1 6 11 16 21 2 7 12 17 22 3 8 13 18 23 4 9 14 19 24 5 10 15 20 25</p>
<p class="calibre1">[[2]]</p>
<p class="calibre1">[1] 5</p>
<p class="calibre1">[[3]]</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">$result</p>
<p class="calibre1">[1] 11 17 23</p>
<p class="calibre1">For convenience here, we’ve given the name result to both the formal argument (in the C code) and the actual argument (in the R code). Note that we needed to allocate space for result in our R code. </p>
<p class="calibre1">As you can see from the example, the return value takes on the form of a list consisting of the arguments in the R call. In this case, the call had four arguments (in addition to the function name), so the returned list has four components. Typically, some of the arguments will be changed during execution of the C code, as was the case here with result. </p>
<p class="calibre1">Interfacing R to Other Languages</p>
<p class="calibre1"><b class="calibre3">325</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p352"/> <i class="calibre4"><b class="calibre3">15.1.4 Debugging R/C Code</b></i></p>
<p class="calibre1">Chapter 13 discussed a number of tools and methods for debugging R code. </p>
<p class="calibre1">However, the R/C interface presents an extra challenge. The problem in using a debugging tool such as GDB here is that you must first apply it to R</p>
<p class="calibre1">itself. </p>
<p class="calibre1">The following is a walk-through of the R/C debugging steps using GDB</p>
<p class="calibre1">on our previous  <i class="calibre4">sd.c </i> code as the example. </p>
<p class="calibre1">$ R -d gdb</p>
<p class="calibre1">GNU gdb 6.8-debian</p>
<p class="calibre1">... </p>
<p class="calibre1">(gdb) run</p>
<p class="calibre1">Starting program: /usr/lib/R/bin/exec/R</p>
<p class="calibre1">... </p>
<p class="calibre1">&gt; dyn.load("sd.so")</p>
<p class="calibre1">&gt; </p>
<p class="calibre1"># hit ctrl-c here</p>
<p class="calibre1">Program received signal SIGINT, Interrupt. </p>
<p class="calibre1">0xb7ffa430 in __kernel_vsyscall ()</p>
<p class="calibre1">(gdb) b subdiag</p>
<p class="calibre1">Breakpoint 1 at 0xb77683f3: file sd.c, line 3. </p>
<p class="calibre1">(gdb) continue</p>
<p class="calibre1">Continuing. </p>
<p class="calibre1">Breakpoint 1, subdiag (m=0x92b9480, n=0x9482328, k=0x9482348, result=0x9817148) at sd.c:3</p>
<p class="calibre1">3</p>
<p class="calibre1">int nval = *n, kval = *k; </p>
<p class="calibre1">(gdb)</p>
<p class="calibre1">So, what happened in this debugging session? </p>
<p class="calibre1">1. </p>
<p class="calibre1">We launched the debugger, GDB, with R loaded into it, from a com-</p>
<p class="calibre1">mand line in a terminal window:</p>
<p class="calibre1">R -d gdb</p>
<p class="calibre1">2. </p>
<p class="calibre1">We told GDB to run R:</p>
<p class="calibre1">(gdb) run</p>
<p class="calibre1">3. </p>
<p class="calibre1">We loaded our compiled C code into R as usual:</p>
<p class="calibre1">&gt; dyn.load("sd.so")</p>
<p class="calibre1">4. </p>
<p class="calibre1">We hit the CTRL-C interrupt key pair to pause R and put us back at the GDB prompt. </p>
<p class="calibre1">5. </p>
<p class="calibre1">We set a breakpoint at the entry to subdiag():</p>
<p class="calibre1">(gdb) b subdiag</p>
<p class="calibre1"><b class="calibre3">326</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p353"/>6. </p>
<p class="calibre1">We told GDB to resume executing R (we needed to hit the ENTER key a second time in order to get the R prompt):</p>
<p class="calibre1">(gdb) continue</p>
<p class="calibre1">We then executed our C code:</p>
<p class="calibre1">&gt; m &lt;- rbind(1:5, 6:10, 11:15, 16:20, 21:25)</p>
<p class="calibre1">&gt; k &lt;- 2</p>
<p class="calibre1">&gt; .C("subdiag", as.double(m), as.integer(dim(m)[1]), as.integer(k), </p>
<p class="calibre1">+ result=double(dim(m)[1]-k))</p>
<p class="calibre1">Breakpoint 1, subdiag (m=0x942f270, n=0x96c3328, k=0x96c3348, result=0x9a58148) at subdiag.c:46</p>
<p class="calibre1">46 if (*n &lt; 1) error("n &lt; 1\n"); </p>
<p class="calibre1">At this point, we can use GDB to debug as usual. If you’re not familiar with GDB, you may want to try one of the many quick tutorials on the Web. </p>
<p class="calibre1">Table 15-1 lists some of the most useful commands. </p>
<p class="calibre1"><b class="calibre3">Table 15-1: </b>Common GDB Commands</p>
<p class="calibre1"><b class="calibre3">Command</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1">l</p>
<p class="calibre1">List code lines</p>
<p class="calibre1">b</p>
<p class="calibre1">Set breakpoint</p>
<p class="calibre1">r</p>
<p class="calibre1">Run/rerun</p>
<p class="calibre1">n</p>
<p class="calibre1">Step to next statement</p>
<p class="calibre1">s</p>
<p class="calibre1">Step into function call</p>
<p class="calibre1">p</p>
<p class="calibre1">Print variable or expression</p>
<p class="calibre1">c</p>
<p class="calibre1">Continue</p>
<p class="calibre1">h</p>
<p class="calibre1">Help</p>
<p class="calibre1">q</p>
<p class="calibre1">Quit</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">15.1.5 Extended Example: Prediction of Discrete-Valued Time Series</b></i></p>
<p class="calibre1">Recall our example in Section 2.5.2 where we observed 0- and 1-valued data, one per time period, and attempted to predict the value in any period from the previous k values, using majority rule. We developed two competing functions for the job, preda() and predb(), as follows:</p>
<p class="calibre1"># prediction in discrete time series; 0s and 1s; use k consecutive</p>
<p class="calibre1"># observations to predict the next, using majority rule; calculate the</p>
<p class="calibre1"># error rate</p>
<p class="calibre1">preda &lt;- function(x,k) {</p>
<p class="calibre1">n &lt;- length(x)</p>
<p class="calibre1">k2 &lt;- k/2</p>
<p class="calibre1"># the vector pred will contain our predicted values</p>
<p class="calibre1">pred &lt;- vector(length=n-k)</p>
<p class="calibre1">Interfacing R to Other Languages</p>
<p class="calibre1"><b class="calibre3">327</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p354"/>for (i in 1:(n-k)) {</p>
<p class="calibre1">if (sum(x[i:(i+(k-1))]) &gt;= k2) pred[i] &lt;- 1 else pred[i] &lt;- 0</p>
<p class="calibre1">}</p>
<p class="calibre1">return(mean(abs(pred-x[(k+1):n])))</p>
<p class="calibre1">}</p>
<p class="calibre1">predb &lt;- function(x,k) {</p>
<p class="calibre1">n &lt;- length(x)</p>
<p class="calibre1">k2 &lt;- k/2</p>
<p class="calibre1">pred &lt;- vector(length=n-k)</p>
<p class="calibre1">sm &lt;- sum(x[1:k])</p>
<p class="calibre1">if (sm &gt;= k2) pred[1] &lt;- 1 else pred[1] &lt;- 0</p>
<p class="calibre1">if (n-k &gt;= 2) {</p>
<p class="calibre1">for (i in 2:(n-k)) {</p>
<p class="calibre1">sm &lt;- sm + x[i+k-1] - x[i-1]</p>
<p class="calibre1">if (sm &gt;= k2) pred[i] &lt;- 1 else pred[i] &lt;- 0</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">return(mean(abs(pred-x[(k+1):n])))</p>
<p class="calibre1">}</p>
<p class="calibre1">Since the latter avoids duplicate computation, we speculated it would be faster. Now is the time to check that. </p>
<p class="calibre1">&gt; y &lt;- sample(0:1,100000,replace=T)</p>
<p class="calibre1">&gt; system.time(preda(y,1000))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">3.816</p>
<p class="calibre1">0.016</p>
<p class="calibre1">3.873</p>
<p class="calibre1">&gt; system.time(predb(y,1000))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">1.392</p>
<p class="calibre1">0.008</p>
<p class="calibre1">1.427</p>
<p class="calibre1">Hey, not bad! That’s quite an improvement. </p>
<p class="calibre1">However, you should always ask whether R already has a fine-tuned function that will suit your needs. Since we’re basically computing a moving average, we might try the filter() function, with a constant coefficient vector, as follows:</p>
<p class="calibre1">predc &lt;- function(x,k) {</p>
<p class="calibre1">n &lt;- length(x)</p>
<p class="calibre1">f &lt;- filter(x,rep(1,k),sides=1)[k:(n-1)]</p>
<p class="calibre1">k2 &lt;- k/2</p>
<p class="calibre1">pred &lt;- as.integer(f &gt;= k2)</p>
<p class="calibre1">return(mean(abs(pred-x[(k+1):n])))</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">328</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p355"/>That’s even more compact than our first version. But it’s a lot harder to read, and for reasons we will explore soon, it may not be so fast. Let’s check. </p>
<p class="calibre1">&gt; system.time(predc(y,1000))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">3.872</p>
<p class="calibre1">0.016</p>
<p class="calibre1">3.945</p>
<p class="calibre1">Well, our second version remains the champion so far. This actually should be expected, as a look at the source code shows. Typing the following shows the source for that function:</p>
<p class="calibre1">&gt; filter</p>
<p class="calibre1">This reveals (not shown here) that filter1() is called. The latter is written in C, which should give us some speedup, but it still suffers from the duplicate computation problem—hence the slowness. </p>
<p class="calibre1">So, let’s write our own C code. </p>
<p class="calibre1">#include &lt;R.h&gt; </p>
<p class="calibre1">void predd(int *x, int *n, int *k, double *errrate)</p>
<p class="calibre1">{</p>
<p class="calibre1">int nval = *n, kval = *k, nk = nval - kval, i; </p>
<p class="calibre1">int sm = 0; // moving sum</p>
<p class="calibre1">int errs = 0; // error count</p>
<p class="calibre1">int pred; // predicted value</p>
<p class="calibre1">double k2 = kval/2.0; </p>
<p class="calibre1">// initialize by computing the initial window</p>
<p class="calibre1">for (i = 0; i &lt; kval; i++) sm += x[i]; </p>
<p class="calibre1">if (sm &gt;= k2) pred = 1; else pred = 0; </p>
<p class="calibre1">errs = abs(pred-x[kval]); </p>
<p class="calibre1">for (i = 1; i &lt; nk; i++) {</p>
<p class="calibre1">sm = sm + x[i+kval-1] - x[i-1]; </p>
<p class="calibre1">if (sm &gt;= k2) pred = 1; else pred = 0; </p>
<p class="calibre1">errs += abs(pred-x[i+kval]); </p>
<p class="calibre1">}</p>
<p class="calibre1">*errrate = (double) errs / nk; </p>
<p class="calibre1">}</p>
<p class="calibre1">This is basically predb() from before, “hand translated” into C. Let’s see if it will outdo predb(). </p>
<p class="calibre1">&gt; system.time(.C("predd",as.integer(y),as.integer(length(y)),as.integer(1000), </p>
<p class="calibre1">+</p>
<p class="calibre1">errrate=double(1)))</p>
<p class="calibre1">user system elapsed</p>
<p class="calibre1">0.004</p>
<p class="calibre1">0.000</p>
<p class="calibre1">0.003</p>
<p class="calibre1">Interfacing R to Other Languages</p>
<p class="calibre1"><b class="calibre3">329</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p356"/>The speedup is breathtaking. </p>
<p class="calibre1">You can see that writing certain functions in C can be worth the effort. </p>
<p class="calibre1">This is especially true for functions that involve iteration, as R’s own iteration constructs, such as for(), are slow. </p>
<p class="calibre1"><b class="calibre3">15.2 Using R from Python</b></p>
<p class="calibre1">Python is an elegant and powerful language, but it lacks built-in facilities for statistical and data manipulation, two areas in which R excels. This section demonstrates how to call R from Python, using RPy, one of the most popular interfaces between the two languages. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">15.2.1 Installing RPy</b></i></p>
<p class="calibre1">RPy is a Python module that allows access to R from Python. For extra efficiency, it can be used in conjunction with NumPy. </p>
<p class="calibre1">You can build the module from the source, available from  <i class="calibre4">http://rpy</i></p>
<p class="calibre1"> <i class="calibre4">.sourceforge.net</i>, or download a prebuilt version. If you are running Ubuntu, simply type this:</p>
<p class="calibre1">sudo apt-get install python-rpy</p>
<p class="calibre1">To load RPy from Python (whether in Python interactive mode or from code), execute the following:</p>
<p class="calibre1">from rpy import *</p>
<p class="calibre1">This will load a variable r, which is a Python class instance. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">15.2.2 RPy Syntax</b></i></p>
<p class="calibre1">Running R from Python is in principle quite simple. Here is an example of a command you might run from the  <i class="calibre4">&gt;&gt;&gt; </i> Python prompt:</p>
<p class="calibre1">&gt;&gt;&gt; r.hist(r.rnorm(100))</p>
<p class="calibre1">This will call the R function rnorm() to produce 100 standard normal variates and then input those values into R’s histogram function, hist(). </p>
<p class="calibre1">As you can see, R names are prefixed by r., reflecting the fact that Python wrappers for R functions are members of the class instance r. </p>
<p class="calibre1">The preceding code will, if not refined, produce ugly output, with your (possibly voluminous!) data appearing as the graph title and the  <i class="calibre4">x</i>-axis label. </p>
<p class="calibre1">You can avoid this by supplying a title and label, as in this example:</p>
<p class="calibre1">&gt;&gt;&gt; r.hist(r.rnorm(100),main='',xlab='')</p>
<p class="calibre1">RPy syntax is sometimes less simple than these examples would lead you to believe. The problem is that R and Python syntax may clash. For instance, <b class="calibre3">330</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p357"/>consider a call to the R linear model function lm(). In our example, we will predict b from a. </p>
<p class="calibre1">&gt;&gt;&gt; a = [5,12,13]</p>
<p class="calibre1">&gt;&gt;&gt; b = [10,28,30]</p>
<p class="calibre1">&gt;&gt;&gt; lmout = r.lm('v2 ~ v1',data=r.data_frame(v1=a,v2=b))</p>
<p class="calibre1">This is somewhat more complex than it would have been if done directly in R. What are the issues here? </p>
<p class="calibre1">First, since Python syntax does not include the tilde character, we needed to specify the model formula via a string. Since this is done in R anyway, this is not a major departure. </p>
<p class="calibre1">Second, we needed a data frame to contain our data. We created one</p>
<p class="calibre1">using R’s data.frame() function. In order to form a period in an R function name, we need to use an underscore on the Python end. Thus we called r.data_frame(). Note that in this call, we named the columns of our data frame v1 and v2 and then used these in our model formula. </p>
<p class="calibre1">The output object is a Python dictionary (analog of R’s list type), as you can see here (in part):</p>
<p class="calibre1">&gt;&gt;&gt; lmout</p>
<p class="calibre1">{'qr': {'pivot': [1, 2], 'qr': array([[ -1.73205081, -17.32050808], </p>
<p class="calibre1">[ 0.57735027, -6.164414 ], </p>
<p class="calibre1">[ 0.57735027, </p>
<p class="calibre1">0.78355007]]), 'qraux':</p>
<p class="calibre1">You should recognize the various attributes of lm() objects here. For example, the coefficients of the fitted regression line, which would be contained in lmout$coefficients if this were done in R, are here in Python as lmout['coefficients']. So, you can access those coefficients accordingly, for example like this:</p>
<p class="calibre1">&gt;&gt;&gt; lmout['coefficients']</p>
<p class="calibre1">{'v1': 2.5263157894736841, '(Intercept)': -2.5964912280701729}</p>
<p class="calibre1">&gt;&gt;&gt; lmout['coefficients']['v1']</p>
<p class="calibre1">2.5263157894736841</p>
<p class="calibre1">You can also submit R commands to work on variables in R’s namespace, using the function r(). This is convenient if there are many syntax clashes. </p>
<p class="calibre1">Here is how we could run the wireframe() example in Section 12.4 in RPy:</p>
<p class="calibre1">&gt;&gt;&gt; r.library('lattice')</p>
<p class="calibre1">&gt;&gt;&gt; r.assign('a',a)</p>
<p class="calibre1">&gt;&gt;&gt; r.assign('b',b)</p>
<p class="calibre1">&gt;&gt;&gt; r('g &lt;- expand.grid(a,b)')</p>
<p class="calibre1">&gt;&gt;&gt; r('g$Var3 &lt;- g$Var1^2 + g$Var1 * g$Var2')</p>
<p class="calibre1">&gt;&gt;&gt; r('wireframe(Var3 ~ Var1+Var2,g)')</p>
<p class="calibre1">&gt;&gt;&gt; r('plot(wireframe(Var3 ~ Var1+Var2,g))')</p>
<p class="calibre1">Interfacing R to Other Languages</p>
<p class="calibre1"><b class="calibre3">331</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p358"/>First, we used r.assign() to copy a variable from Python’s namespace to R’s. We then ran expand.grid() (with a period in the name instead of an underscore, since we are running in R’s namespace), assigning the result to g. Again, the latter is in R’s namespace. Note that the call to wireframe() did not automatically display the plot, so we needed to call plot(). </p>
<p class="calibre1">The official documentation for RPy is at  <i class="calibre4">http://rpy.sourceforge.net/rpy/doc/</i></p>
<p class="calibre1"> <i class="calibre4">rpy.pdf</i>. Also, you can find a useful presentation, “RPy—R from Python,” at <i class="calibre4">http://www.daimi.au.dk/~besen/TBiB2007/lecture-notes/rpy.html</i>. </p>
<p class="calibre1"><b class="calibre3">332</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p359"/><img src="index-359_1.png" alt="Image 43" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">16</b></p>
<p class="calibre1"><b class="calibre3">PARALLEL R</b></p>
<p class="calibre1">Since many R users have very large compu-</p>
<p class="calibre1">tational needs, various tools for some kind</p>
<p class="calibre1">of parallel operation of R have been devised. </p>
<p class="calibre1">This chapter is devoted to parallel R. </p>
<p class="calibre1">Many a novice in parallel processing has, with great anticipation, written parallel code for some application only to find that the parallel version actually ran more slowly than the serial one. For reasons to be discussed in this chapter, this problem is especially acute with R. </p>
<p class="calibre1">Accordingly, understanding the nature of parallel-processing hardware and software is crucial to success in the parallel world. These issues will be discussed here in the context of common platforms for parallel R. </p>
<p class="calibre1">We’ll start with a few code examples and then move to general performance issues. </p>
<p class="calibre1"><b class="calibre3">16.1 The Mutual Outlinks Problem</b></p>
<p class="calibre1">Consider a network graph of some kind, such as web links or links in a social network. Let A be the  <i class="calibre4">adjacency matrix </i> of the graph, meaning that, say, A[3,8]</p>
<p class="calibre1">is 1 or 0, depending on whether there is a link from node 3 to node 8. </p>
<p class="calibre1">For any two vertices, say any two websites, we might be interested in mutual outlinks—that is, outbound links that are common to two sites. Suppose that we want to find the mean number of mutual outlinks, averaged</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p360"/>over all pairs of websites in our data set. This mean can be found using the following outline, for an  <i class="calibre4">n</i>-by- <i class="calibre4">n </i> matrix:</p>
<p class="calibre1">1</p>
<p class="calibre1">sum = 0</p>
<p class="calibre1">2</p>
<p class="calibre1">for i = 0...n-1</p>
<p class="calibre1">3</p>
<p class="calibre1">for j = i+1...n-1</p>
<p class="calibre1">4</p>
<p class="calibre1">for k = 0...n-1 sum = sum + a[i][k]*a[j][k]</p>
<p class="calibre1">5</p>
<p class="calibre1">mean = sum / (n*(n-1)/2)</p>
<p class="calibre1">Given that our graph could contain thousands—even millions—of web-</p>
<p class="calibre1">sites, our task could entail quite large amounts of computation. A common approach to dealing with this problem is to divide the computation into smaller chunks and then process each of the chunks simultaneously, say on separate computers. </p>
<p class="calibre1">Let’s say that we have two computers at our disposal. We might have one computer handle all the odd values of i in the for i loop in line 2 and have the second computer handle the even values. Or, since dual-core computers are fairly standard these days, we could take this same approach on a single computer. This may sound simple, but a number of major issues can arise, as you’ll learn in this chapter. </p>
<p class="calibre1"><b class="calibre3">16.2 Introducing the snow Package</b></p>
<p class="calibre1">Luke Tierney’s snow (Simple Network of Workstations) package, available from the CRAN R code repository, is arguably the simplest, easiest-to-use form of parallel R and one of the most popular. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">The CRAN Task View page on parallel R, </i> http://cran.r-project.org/web/views/</p>
<p class="calibre1">HighPerformanceComputing.html <i class="calibre4">, has a fairly up-to-date list of available parallel R packages. </i></p>
<p class="calibre1">To see how snow works, here’s code for the mutual outlinks problem</p>
<p class="calibre1">described in the previous section:</p>
<p class="calibre1">1</p>
<p class="calibre1"># snow version of mutual links problem</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">mtl &lt;- function(ichunk,m) {</p>
<p class="calibre1">4</p>
<p class="calibre1">n &lt;- ncol(m)</p>
<p class="calibre1">5</p>
<p class="calibre1">matches &lt;- 0</p>
<p class="calibre1">6</p>
<p class="calibre1">for (i in ichunk) {</p>
<p class="calibre1">7</p>
<p class="calibre1">if (i &lt; n) {</p>
<p class="calibre1">8</p>
<p class="calibre1">rowi &lt;- m[i,]</p>
<p class="calibre1">9</p>
<p class="calibre1">matches &lt;- matches +</p>
<p class="calibre1">10</p>
<p class="calibre1">sum(m[(i+1):n,] %*% rowi)</p>
<p class="calibre1">11</p>
<p class="calibre1">}</p>
<p class="calibre1">12</p>
<p class="calibre1">}</p>
<p class="calibre1">13</p>
<p class="calibre1">matches</p>
<p class="calibre1">14</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">334</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p361"/>15</p>
<p class="calibre1">16</p>
<p class="calibre1">mutlinks &lt;- function(cls,m) {</p>
<p class="calibre1">17</p>
<p class="calibre1">n &lt;- nrow(m)</p>
<p class="calibre1">18</p>
<p class="calibre1">nc &lt;- length(cls)</p>
<p class="calibre1">19</p>
<p class="calibre1"># determine which worker gets which chunk of i</p>
<p class="calibre1">20</p>
<p class="calibre1">options(warn=-1)</p>
<p class="calibre1">21</p>
<p class="calibre1">ichunks &lt;- split(1:n,1:nc)</p>
<p class="calibre1">22</p>
<p class="calibre1">options(warn=0)</p>
<p class="calibre1">23</p>
<p class="calibre1">counts &lt;- clusterApply(cls,ichunks,mtl,m)</p>
<p class="calibre1">24</p>
<p class="calibre1">do.call(sum,counts) / (n*(n-1)/2)</p>
<p class="calibre1">25</p>
<p class="calibre1">}</p>
<p class="calibre1">Suppose we have this code in the file  <i class="calibre4">SnowMutLinks.R</i>. Let’s first discuss how to run it. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.2.1 Running snow Code</b></i></p>
<p class="calibre1">Running the above snow code involves the following steps:</p>
<p class="calibre1">1. </p>
<p class="calibre1">Load the code. </p>
<p class="calibre1">2. </p>
<p class="calibre1">Load the snow library. </p>
<p class="calibre1">3. </p>
<p class="calibre1">Form a snow cluster. </p>
<p class="calibre1">4. </p>
<p class="calibre1">Set up the adjacency matrix of interest. </p>
<p class="calibre1">5. </p>
<p class="calibre1">Run your code on that matrix on the cluster you formed. </p>
<p class="calibre1">Assuming we are running on a dual-core machine, we issue the following commands to R:</p>
<p class="calibre1">&gt; source("SnowMutLinks.R")</p>
<p class="calibre1">&gt; library(snow)</p>
<p class="calibre1">&gt; cl &lt;- makeCluster(type="SOCK",c("localhost","localhost"))</p>
<p class="calibre1">&gt; testm &lt;- matrix(sample(0:1,16,replace=T),nrow=4)</p>
<p class="calibre1">&gt; mutlinks(cl,testm)</p>
<p class="calibre1">[1] 0.6666667</p>
<p class="calibre1">Here, we are instructing snow to start two new R processes on our</p>
<p class="calibre1">machine (localhost is a standard network name for the local machine), which I will refer to here as  <i class="calibre4">workers</i>. I’ll refer to the original R process—the one in which we type the preceding commands—as the  <i class="calibre4">manager</i>. So, at this point, three instances of R will be running on the machine (visible by running the ps command if you are in a Linux environment, for example). </p>
<p class="calibre1">The workers form a  <i class="calibre4">cluster </i> in snow parlance, which we have named cl. </p>
<p class="calibre1">The snow package uses what is known in the parallel-processing world as a <i class="calibre4">scatter/gather </i> paradigm, which works as follows:</p>
<p class="calibre1">1. </p>
<p class="calibre1">The manager partitions the data into chunks and parcels them out to the workers (scatter phase). </p>
<p class="calibre1">Parallel R</p>
<p class="calibre1"><b class="calibre3">335</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p362"/>2. </p>
<p class="calibre1">The workers process their chunks. </p>
<p class="calibre1">3. </p>
<p class="calibre1">The manager collects the results from the workers (gather phase) and combines them as appropriate to the application. </p>
<p class="calibre1">We have specified that communication between the manager and work-</p>
<p class="calibre1">ers will be via network sockets (covered in Chapter 10). </p>
<p class="calibre1">Here’s a test matrix to check the code:</p>
<p class="calibre1">&gt; testm</p>
<p class="calibre1">[,1] [,2] [,3] [,4]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">1</p>
<p class="calibre1">[4,]</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">Row 1 has zero outlinks in common with row 2, two in common with</p>
<p class="calibre1">row 3, and one in common with row 4. Row 2 has zero outlinks in common with the rest, but row 3 has one in common with row 4. That is a total of four mutual outlinks out of 4  <i class="calibre4">× </i> 3 <i class="calibre4">/</i> 2 = 6 pairs—hence, the mean value of 4/6 = 0.6666667, as you saw earlier. </p>
<p class="calibre1">You can make clusters of any size, as long as you have the machines. </p>
<p class="calibre1">In my department, for instance, I have machines whose network names are pc28, pc29, and pc30. Each machine is dual core, so I could create a six-worker cluster as follows:</p>
<p class="calibre1">&gt; cl6 &lt;- makeCluster(type="SOCK",c("pc28","pc28","pc29","pc29","pc30","pc30"))</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.2.2 Analyzing the snow Code</b></i></p>
<p class="calibre1">Now let’s see how the mutlinks() function works. First, we sense how many rows the matrix m has, in line 17, and the number of workers in our cluster, in line 18. </p>
<p class="calibre1">Next, we need to determine which worker will handle which values of i in the for i loop in our outline code shown earlier in Section 16.1. R’s split() function is well suited for this. For instance, in the case of a 4-row matrix and a 2-worker cluster, that call produces the following:</p>
<p class="calibre1">&gt; split(1:4,1:2)</p>
<p class="calibre1">$`1`</p>
<p class="calibre1">[1] 1 3</p>
<p class="calibre1">$`2`</p>
<p class="calibre1">[1] 2 4</p>
<p class="calibre1">An R list is returned whose first element is the vector (1,3) and the second is (2,4). This will set up having one R process work on the odd values of i and the other work on the even values, as we discussed earlier. We ward off the <b class="calibre3">336</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p363"/>warnings that split() would give us (“data length is not a multiple of split variable”) by calling options(). </p>
<p class="calibre1">The real work is done in line 23, where we call the snow function</p>
<p class="calibre1">clusterApply(). This function initiates a call to the same specified function (mtl() here), with some arguments specific to each worker and some optional arguments common to all. So, here’s what the call in line 23 does: 1. </p>
<p class="calibre1">Worker 1 will be directed to call the function mtl() with the arguments ichunks[[1]] and m. </p>
<p class="calibre1">2. </p>
<p class="calibre1">Worker 2 will call mtl() with the arguments ichunks[[2]] and m, and so on for all workers. </p>
<p class="calibre1">3. </p>
<p class="calibre1">Each worker will perform its assigned task and then return the result to the manager. </p>
<p class="calibre1">4. </p>
<p class="calibre1">The manager will collect all such results into an R list, which we have assigned here to counts. </p>
<p class="calibre1">At this point, we merely need to sum all the elements of counts. Well, I shouldn’t say “merely,” because there is a little wrinkle to iron out in line 24. </p>
<p class="calibre1">R’s sum() function is capable of acting on several vector arguments, like this:</p>
<p class="calibre1">&gt; sum(1:2,c(4,10))</p>
<p class="calibre1">[1] 17</p>
<p class="calibre1">But here, counts is an R list, not a (numeric) vector. So we rely on do.call() to extract the vectors from counts, and then we call sum() on them. </p>
<p class="calibre1">Note lines 9 and 10. As you know, in R, we try to vectorize our computation wherever possible for better performance. By casting things in matrix-times-vector terms, we replace the for j and for k loops in the outline in Section 16.1 by a single vector-based expression. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.2.3 How Much Speedup Can Be Attained? </b></i></p>
<p class="calibre1">I tried this code on a 1000-by-1000 matrix m1000. I first ran it on a 4-worker cluster and then on a 12-worker cluster. In principle, I should have had speedups of 4 and 12, respectively. But the actual elapsed times were 6.2 seconds and 5.0 seconds. Compare these figures to the 16.9 seconds runtime in nonparallel form. (The latter consisted of the call mtl(1:1000,m1000).) So, I attained a speedup of about 2.7 instead of a theoretical 4.0 for a 4-worker cluster and 3.4 rather than 12.0 on the 12-node system. (Note that some timing variation occurs from run to run.) What went wrong? </p>
<p class="calibre1">In almost any parallel-processing application, you encounter  <i class="calibre4">overhead</i>, or</p>
<p class="calibre1">“wasted” time spent on noncomputational activity. In our example, there is overhead in the form of the time needed to send our matrix from the manager to the workers. We also encountered a bit of overhead in sending the function mtl() itself to the workers. And when the workers finish their tasks, returning their results to the manager causes some overhead, too. We’ll Parallel R</p>
<p class="calibre1"><b class="calibre3">337</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p364"/>discuss this in detail when we talk about general performance considerations in in Section 16.4.1. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.2.4 Extended Example: K-Means Clustering</b></i></p>
<p class="calibre1">To learn more about the capabilities of snow, we’ll look at another example, this one involving k-means clustering (KMC). </p>
<p class="calibre1">KMC is a technique for exporatory data analysis. In looking at scatter plots of your data, you may have the perception that the observations tend to cluster into groups, and KMC is a method for finding such groups. The output consists of the centroids of the groups. </p>
<p class="calibre1">The following is an outline of the algorithm:</p>
<p class="calibre1">1</p>
<p class="calibre1">for iter = 1,2,...,niters</p>
<p class="calibre1">2</p>
<p class="calibre1">set vector and count totals to 0</p>
<p class="calibre1">3</p>
<p class="calibre1">for i = 1,...,nrow(m)</p>
<p class="calibre1">4</p>
<p class="calibre1">set j = index of the closest group center to m[i,]</p>
<p class="calibre1">5</p>
<p class="calibre1">add m[i,] to the vector total for group j, v[j]</p>
<p class="calibre1">6</p>
<p class="calibre1">add 1 to the count total for group j, c[j]</p>
<p class="calibre1">7</p>
<p class="calibre1">for j = 1,...,ngrps</p>
<p class="calibre1">8</p>
<p class="calibre1">set new center of group j = v[j] / c[j]</p>
<p class="calibre1">Here, we specify niters iterations, with initcenters as our initial guesses for the centers of the groups. Our data is in the matrix m, and there are ngrps groups. </p>
<p class="calibre1">The following is the snow code to compute KMC in parallel:</p>
<p class="calibre1">1</p>
<p class="calibre1"># snow version of k-means clustering problem</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">library(snow)</p>
<p class="calibre1">4</p>
<p class="calibre1">5</p>
<p class="calibre1"># returns distances from x to each vector in y; </p>
<p class="calibre1">6</p>
<p class="calibre1"># here x is a single vector and y is a bunch of them; </p>
<p class="calibre1">7</p>
<p class="calibre1"># define distance between 2 points to be the sum of the absolute values 8</p>
<p class="calibre1"># of their componentwise differences; e.g., distance between (5,4.2) and 9</p>
<p class="calibre1"># (3,5.6) is 2 + 1.4 = 3.4</p>
<p class="calibre1">10</p>
<p class="calibre1">dst &lt;- function(x,y) {</p>
<p class="calibre1">11</p>
<p class="calibre1">tmpmat &lt;- matrix(abs(x-y),byrow=T,ncol=length(x)) # note recycling 12</p>
<p class="calibre1">rowSums(tmpmat)</p>
<p class="calibre1">13</p>
<p class="calibre1">}</p>
<p class="calibre1">14</p>
<p class="calibre1">15</p>
<p class="calibre1"># will check this worker's mchunk matrix against currctrs, the current 16</p>
<p class="calibre1"># centers of the groups, returning a matrix; row j of the matrix will 17</p>
<p class="calibre1"># consist of the vector sum of the points in mchunk closest to jth</p>
<p class="calibre1">18</p>
<p class="calibre1"># current center, and the count of such points</p>
<p class="calibre1">19</p>
<p class="calibre1">findnewgrps &lt;- function(currctrs) {</p>
<p class="calibre1">20</p>
<p class="calibre1">ngrps &lt;- nrow(currctrs)</p>
<p class="calibre1">21</p>
<p class="calibre1">spacedim &lt;- ncol(currctrs) # what dimension space are we in? </p>
<p class="calibre1"><b class="calibre3">338</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p365"/>22</p>
<p class="calibre1"># set up the return matrix</p>
<p class="calibre1">23</p>
<p class="calibre1">sumcounts &lt;- matrix(rep(0,ngrps*(spacedim+1)),nrow=ngrps)</p>
<p class="calibre1">24</p>
<p class="calibre1">for (i in 1:nrow(mchunk)) {</p>
<p class="calibre1">25</p>
<p class="calibre1">dsts &lt;- dst(mchunk[i,],t(currctrs))</p>
<p class="calibre1">26</p>
<p class="calibre1">j &lt;- which.min(dsts)</p>
<p class="calibre1">27</p>
<p class="calibre1">sumcounts[j,] &lt;- sumcounts[j,] + c(mchunk[i,],1)</p>
<p class="calibre1">28</p>
<p class="calibre1">}</p>
<p class="calibre1">29</p>
<p class="calibre1">sumcounts</p>
<p class="calibre1">30</p>
<p class="calibre1">}</p>
<p class="calibre1">31</p>
<p class="calibre1">32</p>
<p class="calibre1">parkm &lt;- function(cls,m,niters,initcenters) {</p>
<p class="calibre1">33</p>
<p class="calibre1">n &lt;- nrow(m)</p>
<p class="calibre1">34</p>
<p class="calibre1">spacedim &lt;- ncol(m) # what dimension space are we in? </p>
<p class="calibre1">35</p>
<p class="calibre1"># determine which worker gets which chunk of rows of m</p>
<p class="calibre1">36</p>
<p class="calibre1">options(warn=-1)</p>
<p class="calibre1">37</p>
<p class="calibre1">ichunks &lt;- split(1:n,1:length(cls))</p>
<p class="calibre1">38</p>
<p class="calibre1">options(warn=0)</p>
<p class="calibre1">39</p>
<p class="calibre1"># form row chunks</p>
<p class="calibre1">40</p>
<p class="calibre1">mchunks &lt;- lapply(ichunks,function(ichunk) m[ichunk,])</p>
<p class="calibre1">41</p>
<p class="calibre1">mcf &lt;- function(mchunk) mchunk &lt;&lt;- mchunk</p>
<p class="calibre1">42</p>
<p class="calibre1"># send row chunks to workers; each chunk will be a global variable at 43</p>
<p class="calibre1"># the worker, named mchunk</p>
<p class="calibre1">44</p>
<p class="calibre1">invisible(clusterApply(cls,mchunks,mcf))</p>
<p class="calibre1">45</p>
<p class="calibre1"># send dst() to workers</p>
<p class="calibre1">46</p>
<p class="calibre1">clusterExport(cls,"dst")</p>
<p class="calibre1">47</p>
<p class="calibre1"># start iterations</p>
<p class="calibre1">48</p>
<p class="calibre1">centers &lt;- initcenters</p>
<p class="calibre1">49</p>
<p class="calibre1">for (i in 1:niters) {</p>
<p class="calibre1">50</p>
<p class="calibre1">sumcounts &lt;- clusterCall(cls,findnewgrps,centers)</p>
<p class="calibre1">51</p>
<p class="calibre1">tmp &lt;- Reduce("+",sumcounts)</p>
<p class="calibre1">52</p>
<p class="calibre1">centers &lt;- tmp[,1:spacedim] / tmp[,spacedim+1]</p>
<p class="calibre1">53</p>
<p class="calibre1"># if a group is empty, let's set its center to 0s</p>
<p class="calibre1">54</p>
<p class="calibre1">centers[is.nan(centers)] &lt;- 0</p>
<p class="calibre1">55</p>
<p class="calibre1">}</p>
<p class="calibre1">56</p>
<p class="calibre1">centers</p>
<p class="calibre1">57</p>
<p class="calibre1">}</p>
<p class="calibre1">The code here is largely similar to our earlier mutual outlinks example. </p>
<p class="calibre1">However, there are a couple of new snow calls and a different kind of usage of an old call. </p>
<p class="calibre1">Let’s start with lines 39 through 44. Since our matrix m does not change from one iteration to the next, we definitely do not want to resend it to the workers repeatedly, exacerbating the overhead problem. Thus, first we need to send each worker its assigned chunk of m, just once. This is done in line 44</p>
<p class="calibre1">via snow’s clusterApply() function, which we used earlier but need to get creative with here. In line 41, we define the function mcf(), which will, running Parallel R</p>
<p class="calibre1"><b class="calibre3">339</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p366"/>on a worker, accept the worker’s chunk from the manager and then keep it as a global variable mchunk on the worker. </p>
<p class="calibre1">Line 46 makes use of a new snow function, clusterExport(), whose job it is to make copies of the manager’s global variables at the workers. The variable in question here is actually a function, dst(). Here is why we need to send it separately: The call in line 50 will send the function findnewgrps() to the workers, but although that function calls dst(), snow will not know to send the latter as well. Therefore we send it ourselves. </p>
<p class="calibre1">Line 50 itself uses another new snow call, clusterCall(). This instructs each worker to call findnewgrps(), with centers as argument. </p>
<p class="calibre1">Recall that each worker has a different matrix chunk, so this call will work on different data for each worker. This once again brings up the controversy regarding the use of global variables, discussed in Section 7.8.4. </p>
<p class="calibre1">Some software developers may be troubled by the use of a hidden argument in findnewgrps(). On the other hand, as mentioned earlier, using mchunk as an argument would mean sending it to the workers repeatedly, compromising performance. </p>
<p class="calibre1">Finally, take a look at line 51. The snow function clusterApply() always returns an R list. In this case, the return value is in sumcounts, each element of which is a matrix. We need to sum the matrices, producing a totals matrix. </p>
<p class="calibre1">Using R’s sum() function wouldn’t work, as it would total all the elements of the matrices into a single number. Matrix addition is what we need. </p>
<p class="calibre1">Calling R’s Reduce() function will do the matrix addition. Recall that any arithmetic operation in R is implemented as a function; in this case, it is implemented as the function "+". The recall to Reduce() then successively applies "+" to the elements of the list sumcounts. Of course, we could just write a loop to do this, but using Reduce() may give us a small performance boost. </p>
<p class="calibre1"><b class="calibre3">16.3 Resorting to C</b></p>
<p class="calibre1">As you’ve seen, using parallel R may greatly speed up your R code. This allows you to retain the convenience and expressive power of R, while still ameliorating large runtimes in big applications. If the parallelized R gives you sufficiently good performance, then all is well. </p>
<p class="calibre1">Nevertheless, parallel R is still R and thus still subject to the performance issues covered in Chapter 14. Recall that one solution offered in that chapter was to write a performance-critical portion of your code in C and then call that code from your main R program. (The references to C here mean C or C++.) We will explore this from a parallel-processing viewpoint. Here, instead of writing parallel R, we write ordinary R code that calls parallel C. (I assume a knowledge of C.)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.3.1 Using Multicore Machines</b></i></p>
<p class="calibre1">The C code covered here runs only on multicore systems, so we must discuss the nature of such systems. </p>
<p class="calibre1"><b class="calibre3">340</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p367"/>You are probably familiar with dual-core machines. Any computer includes a CPU, which is the part that actually runs your program. In essence, a dual-core machine has two CPUs, a quad-core system has four, and so on. </p>
<p class="calibre1">With multiple cores, you can do parallel computation! </p>
<p class="calibre1">This parallel computation is done with  <i class="calibre4">threads</i>, which are analogous to snow’s workers. In computationally intensive applications, you generally set up as many threads as there are cores, for example two threads in a dual-core machine. Ideally, these threads run simultaneously, though overhead issues do arise, as will be explained when we look at general performance issues in Section 16.4.1. </p>
<p class="calibre1">If your machine has multiple cores, it is structured as a  <i class="calibre4">shared-memory</i> system. All cores access the same RAM. The shared nature of the memory makes communication between the cores easy to program. If a thread writes to a memory location, the change is visible to the other threads, without the programmer needing to insert code to make that happen. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.3.2 Extended Example: Mutual Outlinks Problem in OpenMP</b></i></p>
<p class="calibre1">OpenMP is a very popular package for programming on multicore machines. </p>
<p class="calibre1">To see how it works, here is the mutual outlinks example again, this time in R-callable OpenMP code:</p>
<p class="calibre1">1</p>
<p class="calibre1">#include &lt;omp.h&gt; </p>
<p class="calibre1">2</p>
<p class="calibre1">#include &lt;R.h&gt; </p>
<p class="calibre1">3</p>
<p class="calibre1">4</p>
<p class="calibre1">int tot; // grand total of matches, over all threads</p>
<p class="calibre1">5</p>
<p class="calibre1">6</p>
<p class="calibre1">// processes row pairs (i,i+1), (i,i+2), ... </p>
<p class="calibre1">7</p>
<p class="calibre1">int procpairs(int i, int *m, int n)</p>
<p class="calibre1">8</p>
<p class="calibre1">{ int j,k,sum=0; </p>
<p class="calibre1">9</p>
<p class="calibre1">for (j = i+1; j &lt; n; j++) {</p>
<p class="calibre1">10</p>
<p class="calibre1">for (k = 0; k &lt; n; k++)</p>
<p class="calibre1">11</p>
<p class="calibre1">// find m[i][k]*m[j][k] but remember R uses col-major order</p>
<p class="calibre1">12</p>
<p class="calibre1">sum += m[n*k+i] * m[n*k+j]; </p>
<p class="calibre1">13</p>
<p class="calibre1">}</p>
<p class="calibre1">14</p>
<p class="calibre1">return sum; </p>
<p class="calibre1">15</p>
<p class="calibre1">}</p>
<p class="calibre1">16</p>
<p class="calibre1">17</p>
<p class="calibre1">void mutlinks(int *m, int *n, double *mlmean)</p>
<p class="calibre1">18</p>
<p class="calibre1">{ int nval = *n; </p>
<p class="calibre1">19</p>
<p class="calibre1">tot = 0; </p>
<p class="calibre1">20</p>
<p class="calibre1">#pragma omp parallel</p>
<p class="calibre1">21</p>
<p class="calibre1">{ int i,mysum=0, </p>
<p class="calibre1">22</p>
<p class="calibre1">me = omp_get_thread_num(), </p>
<p class="calibre1">23</p>
<p class="calibre1">nth = omp_get_num_threads(); </p>
<p class="calibre1">24</p>
<p class="calibre1">// in checking all (i,j) pairs, partition the work according to i; </p>
<p class="calibre1">25</p>
<p class="calibre1">// this thread me will handle all i that equal me mod nth</p>
<p class="calibre1">26</p>
<p class="calibre1">for (i = me; i &lt; nval; i += nth) {</p>
<p class="calibre1">Parallel R</p>
<p class="calibre1"><b class="calibre3">341</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p368"/>27</p>
<p class="calibre1">mysum += procpairs(i,m,nval); </p>
<p class="calibre1">28</p>
<p class="calibre1">}</p>
<p class="calibre1">29</p>
<p class="calibre1">#pragma omp atomic</p>
<p class="calibre1">30</p>
<p class="calibre1">tot += mysum; </p>
<p class="calibre1">31</p>
<p class="calibre1">}</p>
<p class="calibre1">32</p>
<p class="calibre1">int divisor = nval * (nval-1) / 2; </p>
<p class="calibre1">33</p>
<p class="calibre1">*mlmean = ((float) tot)/divisor; </p>
<p class="calibre1">34</p>
<p class="calibre1">}</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.3.3 Running the OpenMP Code</b></i></p>
<p class="calibre1">Again, compilation follows the recipe in Chapter 15. We do need to link in the OpenMP library, though, by using the -fopenmp and -lgomp options. Suppose our source file is  <i class="calibre4">romp.c</i>. Then we use the following commands to run the code:</p>
<p class="calibre1">gcc -std=gnu99 -fopenmp -I/usr/share/R/include -fpic -g -O2 -c romp.c -o romp.o gcc -std=gnu99 -shared -o romp.so romp.o -L/usr/lib/R/lib -lR -lgomp Here’s an R test:</p>
<p class="calibre1">&gt; dyn.load("romp.so")</p>
<p class="calibre1">&gt; Sys.setenv(OMP_NUM_THREADS=4)</p>
<p class="calibre1">&gt; n &lt;- 1000</p>
<p class="calibre1">&gt; m &lt;- matrix(sample(0:1,n^2,replace=T),nrow=n)</p>
<p class="calibre1">&gt; system.time(z &lt;- .C("mutlinks",as.integer(m),as.integer(n),result=double(1))) user system elapsed</p>
<p class="calibre1">0.830</p>
<p class="calibre1">0.000</p>
<p class="calibre1">0.218</p>
<p class="calibre1">&gt; z$result</p>
<p class="calibre1">[1] 249.9471</p>
<p class="calibre1">The typical way to specify the number of threads in OpenMP is through an operating system environment variable, OMP_NUM_THREADS. R is capable of setting operating system environment variables with the Sys.setenv() function. Here, I set the number of threads to 4, because I was running on a quad-core machine. </p>
<p class="calibre1">Note the runtime—only 0.2 seconds! This compares to the 5.0-second</p>
<p class="calibre1">time we saw earlier for a 12-node snow system. This might be surprising to some readers, as our code in the snow version was vectorized to a fair degree, as mentioned earlier. Vectorizing is good, but again, R has many hidden sources of overhead, so C might do even better. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">I tried R’s new byte-compilation function cmpfun(), but mtl() actually became slower. </i></p>
<p class="calibre1">Thus, if you are willing to write part of your code in parallel C, dramatic speedups may be possible. </p>
<p class="calibre1"><b class="calibre3">342</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p369"/> <i class="calibre4"><b class="calibre3">16.3.4 OpenMP Code Analysis</b></i></p>
<p class="calibre1">OpenMP code is C, with the addition of  <i class="calibre4">pragmas </i> that instruct the compiler to insert some library code to perform OpenMP operations. Look at line 20, for instance. When execution reaches this point, the threads will be activated. Each thread then executes the block that follows—lines 21 through 31—in parallel. </p>
<p class="calibre1">A key point is variable scope. All the variables within the block starting on line 21 are local to their specific threads. For example, we’ve named the total variable in line 21 mysum because each thread will maintain its own sum. </p>
<p class="calibre1">By contrast, the global variable tot on line 4 is held in common by all the threads. Each thread makes its contribution to that grand total on line 30. </p>
<p class="calibre1">But even the variable nval on line 18 is held in common with all the threads (during the execution of mutlinks()), as it is declared outside the block beginning on line 21. So, even though it is a local variable in terms of C scope, it is global to all the threads. Indeed, we could have declared tot on that line, too. It needs to be shared by all the threads, but since it’s not used outside mutlinks(), it could have been declared on line 18. </p>
<p class="calibre1">Line 29 contains another pragma, atomic. This one applies only to the single line following it—line 30, in this case—rather than to a whole block. </p>
<p class="calibre1">The purpose of the atomic pragma is to avoid what is called a  <i class="calibre4">race condition</i> in parallel-processing circles. This term describes a situation in which two threads are updating a variable at the same time, which may produce incorrect results. The atomic pragma ensures that line 30 will be executed by only one thread at a time. Note that this implies that in this section of the code, our parallel program becomes temporarily serial, which is a potential source of slowdown. </p>
<p class="calibre1">Where is the manager’s role in all of this? Actually, the manager is the original thread, and it executes lines 18 and 19, as well as .C(), the R function that makes the call to mutlinks(). When the worker threads are activated in line 21, the manager goes dormant. The worker threads become dormant once they finish line 31. At that point, the manager resumes execution. Due to the dormancy of the manager while the workers are executing, we do want to have as many workers as our machine has cores. </p>
<p class="calibre1">The function procpairs() is straightforward, but note the manner in which the matrix m is being accessed. Recall from the discussion in Chapter 15 on interfacing R to C that the two languages store matrices differently: column by column in R and row-wise in C. We need to be aware of that difference here. In addition, we have treated the matrix m as a one-dimensional array, as is common in parallel C code. In other words, if n is, say, 4, then we treat m as a vector of 16 elements. Due to the column-major nature of R</p>
<p class="calibre1">matrix storage, the vector will consist first of the four elements of column 1, then the four of column 2, and so on. To further complicate matters, we must keep in mind that array indices in C start at 0, instead of starting at 1 as in R. </p>
<p class="calibre1">Putting all of this together yields the multiplication in line 12. The factors here are the (k,i) and (k,j) elements of the version of m in the C code, which are the (i+1,k+1) and (j+1,k+1) elements back in the R code. </p>
<p class="calibre1">Parallel R</p>
<p class="calibre1"><b class="calibre3">343</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p370"/> <i class="calibre4"><b class="calibre3">16.3.5 Other OpenMP Pragmas</b></i></p>
<p class="calibre1">OpenMP includes a wide variety of possible operations—far too many to list here. This section provides an overview of some OpenMP pragmas that I consider especially useful. </p>
<p class="calibre1"><b class="calibre3">16.3.5.1 The omp barrier Pragma</b></p>
<p class="calibre1">The parallel-processing term  <i class="calibre4">barrier </i> refers to a line of code at which the threads rendezvous. The syntax for the omp barrier pragma is simple:</p>
<p class="calibre1">#pragma omp barrier</p>
<p class="calibre1">When a thread reaches a barrier, its execution is suspended until all other threads have reached that line. This is very useful for iterative algorithms; threads wait at a barrier at the end of every iteration. </p>
<p class="calibre1">Note that in addition to this explicit barrier invocation, some other pragmas place an implicit barrier following their blocks. These include single and parallel. There is an implied barrier immediately following line 31 in the previous listing, for example, which is why the manager stays dormant until all worker threads finish. </p>
<p class="calibre1"><b class="calibre3">16.3.5.2 The omp critical Pragma</b></p>
<p class="calibre1">The block that follows this pragma is a  <i class="calibre4">critical section</i>, meaning one in which only one thread is allowed to execute at a time. The omp critical pragma essentially serves the same purpose as the atomic pragma discussed earlier, except that the latter is limited to a single statement. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">The OpenMP designers defined a special pragma for this single-statement situation in</i> <i class="calibre4">the hope that the compiler can translate this to an especially fast machine instruction. </i></p>
<p class="calibre1">Here is the omp critical syntax:</p>
<p class="calibre1">1</p>
<p class="calibre1">#pragma omp critical</p>
<p class="calibre1">2</p>
<p class="calibre1">{</p>
<p class="calibre1">3</p>
<p class="calibre1">// place one or more statements here</p>
<p class="calibre1">4</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">16.3.5.3 The omp single Pragma</b></p>
<p class="calibre1">The block that follows this pragma is to be executed by only one of the threads. Here is the syntax for the omp single pragma:</p>
<p class="calibre1">1</p>
<p class="calibre1">#pragma omp single</p>
<p class="calibre1">2</p>
<p class="calibre1">{</p>
<p class="calibre1">3</p>
<p class="calibre1">// place one or more statements here</p>
<p class="calibre1">4</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">344</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p371"/>This is useful for initializing sum variables that are shared by the threads, for instance. As noted earlier, an automatic barrier is placed after the block. </p>
<p class="calibre1">This should make sense to you. If one thread is initializing a sum, you wouldn’t want other threads that make use of this variable to continue execution until the sum has been properly set. </p>
<p class="calibre1">You can learn more about OpenMP in my open source textbook on par-</p>
<p class="calibre1">allel processing at  <i class="calibre4">http://heather.cs.ucdavis.edu/parprocbook</i>. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.3.6 GPU Programming</b></i></p>
<p class="calibre1">Another type of shared-memory parallel hardware consists of graphics processing units (GPUs). If you have a sophisticated graphics card in your machine, say for playing games, you may not realize that it is also a very powerful computational device—so powerful that the slogan “A supercomputer on your desk!” is often used to refer to PCs equipped with high-end GPUs. </p>
<p class="calibre1">As with OpenMP, the idea here is that instead of writing parallel R, you write R code interfaced to parallel C. (Similar to the OpenMP case,  <i class="calibre4">C</i></p>
<p class="calibre1">here means a slightly augmented version of the C language.) The technical details become rather complex, so I won’t show any code examples, but an overview of the platform is worthwhile. </p>
<p class="calibre1">As mentioned, GPUs do follow the shared-memory/threads model, </p>
<p class="calibre1">but on a much larger scale. They have dozens, or even hundreds, of</p>
<p class="calibre1">cores (depending on how you define  <i class="calibre4">core</i>). One major difference is that several threads can be run together in a block, which can produce certain efficiencies. </p>
<p class="calibre1">Programs that access GPUs begin their run on your machine’s CPU, </p>
<p class="calibre1">referred to as the  <i class="calibre4">host</i>. They then start code running on the GPU, or  <i class="calibre4">device</i>. </p>
<p class="calibre1">This means that your data must be transferred from the host to the device, and after the device finishes its computation, the results must be transferred back to the host. </p>
<p class="calibre1">As of this writing, GPU has not yet become common among R users. </p>
<p class="calibre1">The most common usage is probably through the CRAN package gputools, which consists of some matrix algebra and statistical routines callable from R. For instance, consider matrix inversion. R provides the function solve() for this, but a parallel alternative is available in gputools with the name gpuSolve(). </p>
<p class="calibre1">For more about GPU programming, again see my book on parallel pro-</p>
<p class="calibre1">cessing at  <i class="calibre4">http://heather.cs.ucdavis.edu/parprocbook</i>. </p>
<p class="calibre1"><b class="calibre3">16.4 General Performance Considerations</b></p>
<p class="calibre1">This section discusses some issues that you may find generally useful in parallelizing R applications. I’ll present some material on the main sources of overhead and then discuss a couple of algorithmic issues. </p>
<p class="calibre1">Parallel R</p>
<p class="calibre1"><b class="calibre3">345</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p372"/> <i class="calibre4"><b class="calibre3">16.4.1 Sources of Overhead</b></i></p>
<p class="calibre1">Having at least a rough idea of the physical causes of overhead is essential to successful parallel programming. Let’s take a look at these in the contexts of the two main platforms, shared-memory and networked computers. </p>
<p class="calibre1"><b class="calibre3">16.4.1.1 Shared-Memory Machines</b></p>
<p class="calibre1">As noted earlier, the memory sharing in multicore machines makes for easier programming. However, the sharing also produces overhead, since the two cores will bump into each other if they both try to access memory at the same time. This means that one of them will need to wait, causing overhead. That overhead is typically in the range of hundreds of nanoseconds (billionths of seconds). This sounds really small, but keep in mind that the CPU is working at a subnanosecond speed, so memory access often becomes a bottleneck. </p>
<p class="calibre1">Each core may also have a  <i class="calibre4">cache</i>, in which it keeps a local copy of some of the shared memory. It’s intended to reduce contention for memory among the cores, but it produces its own overhead, involving time spent in keeping the caches consistent with each other. </p>
<p class="calibre1">Recall that GPUs are special types of multicore machines. As such, they suffer from the problems I’ve described, and more. First, the  <i class="calibre4">latency</i>, which is the time delay before the first bit arrives at the GPU from its memory after a memory read request, is quite long in GPUs. </p>
<p class="calibre1">There is also the overhead incurred in transferring data between the host and the device. The latency here is on the order of microseconds (millionths of seconds), an eternity compared to the nanosecond scale of the CPU and GPU. </p>
<p class="calibre1">GPUs have great performance potential for certain classes of applications, but overhead can be a major issue. The authors of gputools note that their matrix operations start achieving a speedup only at matrix sizes of 1000</p>
<p class="calibre1">by 1000. I wrote a GPU version of our mutual outlinks application, which turned out to have a runtime of 3.0 seconds—about half of the snow version but still far slower than the OpenMP implementation. </p>
<p class="calibre1">Again, there are ways of ameliorating these problems, but they require very careful, creative programming and a sophisticated knowledge of the physical GPU structure. </p>
<p class="calibre1"><b class="calibre3">16.4.1.2 Networked Systems of Computers</b></p>
<p class="calibre1">As you saw earlier, another way to achieve parallel computation is through networked systems of computers. You still have multiple CPUs, but in this case, they are in entirely separate computers, each with its own memory. </p>
<p class="calibre1">As pointed out earlier, network data transfer causes overhead. Its latency is again on the order of microseconds. Thus, even accessing a small amount of data across the network incurs a major delay. </p>
<p class="calibre1">Also note that snow has additional overhead, as it changes numeric</p>
<p class="calibre1">objects such as vectors and matrices to character form before sending them, say from the manager to the workers. Not only does this entail time for the conversion (both in changing from numeric to character form and <b class="calibre3">346</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p373"/>in charging back to numeric at the receiver), but the character form tends to make for much longer messages, thus longer network transfer time. </p>
<p class="calibre1">Shared-memory systems can be networked together, which, in fact, we did in the previous example. We had a hybrid situation in which we formed snow clusters from several networked dual-core computers. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.4.2 Embarrassingly Parallel Applications and Those That Aren’t</b></i></p>
<p class="calibre1">It’s no shame to be poor, but it’s no great honor either. </p>
<p class="calibre1">—Tevye,  <i class="calibre4">Fiddler on the Roof</i></p>
<p class="calibre1">Man is the only animal that blushes, or needs to. </p>
<p class="calibre1">—Mark Twain</p>
<p class="calibre1">The term  <i class="calibre4">embarrassingly parallel </i> is heard often in talk about parallel R</p>
<p class="calibre1">(and in the parallel processing field in general). The word  <i class="calibre4">embarrassing</i> alludes to the fact that the problems are so easy to parallelize that there is no intellectual challenge involved; they are embarrassingly easy. </p>
<p class="calibre1">Both of the example applications we’ve looked at here would be con-</p>
<p class="calibre1">sidered embarrassingly parallel. Parallelizing the for i loop for the mutual outlinks problem in Section 16.1 was pretty obvious. Partitioning the work in the KMC example in Section 16.2.4 was also natural and easy. </p>
<p class="calibre1">By contrast, most parallel sorting algorithms require a great deal of interaction. For instance, consider merge sort, a common method of sorting numbers. It breaks the vector to be sorted into two (or more) independent parts, say the left half and right half, which are then sorted in parallel by two processes. So far, this is embarrassingly parallel, at least after the vector is divided in half. But then the two sorted halves must be merged to produce the sorted version of the original vector, and that process is <i class="calibre4">not </i> embarrassingly parallel. It can be parallelized but in a more complex manner. </p>
<p class="calibre1">Of course, to paraphrase Tevye, it’s no shame to have an embarrassingly parallel problem! It may not exactly be an honor, but it is a cause for cele-bration, as it is easy to program. More important, embarrassingly parallel problems tend to have low communication overhead, which is crucial to performance, as discussed earlier. In fact, when most people refer to embarrassingly parallel applications, they have this low overhead in mind. </p>
<p class="calibre1">But what about nonembarrassingly parallel applications? Unfortunately, parallel R code is simply not suitable for many of them for a very basic reason: the functional programming nature of R. As discussed in Section 14.3, a statement like this:</p>
<p class="calibre1">x[3] &lt;- 8</p>
<p class="calibre1">is deceptively simple, because it can cause the entire vector x to be rewritten. This really compounds communication traffic problems. Accordingly, if your application is not embarrassingly parallel, your best strategy is probably to write the computationally intensive parts of the code in C, say using OpenMP or GPU programming. </p>
<p class="calibre1">Parallel R</p>
<p class="calibre1"><b class="calibre3">347</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p374"/>Also, note carefully that even being embarrassingly parallel does not make an algorithm efficient. Some such algorithms can still have significant communication traffic, thus compromising performance. </p>
<p class="calibre1">Consider the KMC problem, run under snow. Suppose we were to set</p>
<p class="calibre1">up a large enough number of workers so that each worker had relatively little work to do. In that case, the communication with the manager after each iteration would become a signficant portion of run time. In this situation, we would say that the  <i class="calibre4">granularity </i> is too fine, and then probably switch to using fewer workers. We would then have larger tasks for each worker, thus a  <i class="calibre4">coarser </i> granularity. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.4.3 Static Versus Dynamic Task Assignment</b></i></p>
<p class="calibre1">Look again at the loop beginning on line 26 of our OpenMP example, </p>
<p class="calibre1">reproduced here for convenience:</p>
<p class="calibre1">for (i = me; i &lt; nval; i += nth) {</p>
<p class="calibre1">mysum += procpairs(i,m,nval); </p>
<p class="calibre1">}</p>
<p class="calibre1">The variable me here was the thread number, so the effect of this code was that the various threads would work on nonoverlapping sets of values of i. We do want the values to be nonoverlapping, to avoid duplicate work and an incorrect count of total number of links, so the code was fine. But the point now is that we were, in effect, preassigning the tasks that each thread would handle. This is called  <i class="calibre4">static </i> assignment. </p>
<p class="calibre1">An alternative approach is to revise the for loop to look something like this:</p>
<p class="calibre1">int nexti = 0; // global variable</p>
<p class="calibre1">... </p>
<p class="calibre1">for ( ; myi &lt; n; ) { // revised "for" loop</p>
<p class="calibre1">#pragma omp critical</p>
<p class="calibre1">{</p>
<p class="calibre1">nexti += 1; </p>
<p class="calibre1">myi = nexti; </p>
<p class="calibre1">}</p>
<p class="calibre1">if (myi &lt; n) {</p>
<p class="calibre1">mysum += procpairs(myi,m,nval); </p>
<p class="calibre1">... </p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">... </p>
<p class="calibre1">This is  <i class="calibre4">dynamic </i> task assignment, in which it is not determined ahead of time which threads handle which values of i. Task assignment is done during execution. At first glance, dynamic assignment seems to have the potential for better performance. Suppose, for instance, that in a static assignment <b class="calibre3">348</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p375"/>setting, one thread finishes its last value of i early, while another thread still has two values of i left to do. This would mean our program would finish somewhat later than it could. In parallel-processing parlance, we would have a  <i class="calibre4">load balance </i> problem. With dynamic assignment, the thread that finished when there were two values of i left to handle could have taken up one of those values itself. We would have better balance and theoretically less overall runtime. </p>
<p class="calibre1">But don’t jump to conclusions. As always, we have the overhead issue to reckon with. Recall that a critical pragma, used in the dynamic version of the code above, has the effect of temporarily rendering the program serial rather than parallel, thus causing a slowdown. In addition, for reasons too technical to discuss here, these pragmas may cause considerable cache activity overhead. So in the end, the dynamic code could actually be substantially slower than the static version. </p>
<p class="calibre1">Various solutions to this problem have been developed, such as an</p>
<p class="calibre1">OpenMP construct named guided. But rather than present these, the point I wish to make is that they are unnecessary. In most situations, static assignment is just fine. Why is this the case? </p>
<p class="calibre1">You may recall that the standard deviation of the sum of independent, identically distributed random variables, divided by the mean of that sum, goes to zero as the number of terms goes to infinity. In other words, sums are approximately constant. This has a direct implication for our load-balancing concerns: Since the total work time for a thread in static assignment is the sum of its individual task times, that total work time will be approximately constant; there will be very little variation from thread to thread. Thus, they will all finish at pretty close to the same time, and we do not need to worry about load imbalance. Dynamic scheduling will not be necessary. </p>
<p class="calibre1">This reasoning does depend on a statistical assumption, but in practice, the assumption will typically be met sufficiently well for the outcome: Static scheduling does as well as dynamic in terms of uniformity of total work times across threads. And since static scheduling doesn’t have the overhead problems of the dynamic kind, in most cases the static approach will give better performance. </p>
<p class="calibre1">There is one more aspect of this to discuss. To illustrate the issue, consider again the mutual outlinks example. Let’s review the outline of the algorithm:</p>
<p class="calibre1">1</p>
<p class="calibre1">sum = 0</p>
<p class="calibre1">2</p>
<p class="calibre1">for i = 0...n-1</p>
<p class="calibre1">3</p>
<p class="calibre1">for j = i+1...n-1</p>
<p class="calibre1">4</p>
<p class="calibre1">for k = 0...n-1 sum = sum + a[i][k]*a[j][k]</p>
<p class="calibre1">5</p>
<p class="calibre1">mean = sum / (n*(n-1)/2)</p>
<p class="calibre1">Say n is 10000 and we have four threads, and consider ways to partition the for i loop. Naively, we might at first decide to have thread 0 handle the i values 0 through 2499, thread 1 handle 2500 through 4999, and so on. </p>
<p class="calibre1">However, this would produce a severe load imbalance, since the thread that Parallel R</p>
<p class="calibre1"><b class="calibre3">349</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p376"/>handles a given value of i does an amount of work proportional to n-i. That, in fact, is why we staggered the values of i in our actual code: Thread 0 handled the i values 0, 4, 8 ..., thread 1 worked on 1, 5, 9, ..., and so on, yielding good load balance. </p>
<p class="calibre1">The point then is that static assignment might require a bit more plan-ning. One general approach to this is to randomly assign tasks (i values, in our case here) to threads (still doing so at the outset, before work begins). </p>
<p class="calibre1">With a bit of forethought such as this, static assignment should work well in most applications. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">16.4.4 Software Alchemy: Turning General Problems into Embarrassingly</b></i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Parallel Ones</b></i></p>
<p class="calibre1">As discussed earlier, it’s difficult to attain good performance from nonembarrassingly parallel algorithms. Fortunately, for statistical applications, there is a way to turn nonembarrassingly parallel problems into embarrassingly parallel ones. The key is to exploit some statistical properties. </p>
<p class="calibre1">To demonstrate the method, let’s once again turn to our mutual out-</p>
<p class="calibre1">links problem. The method, applied with w workers on a links matrix m, consists of the following:</p>
<p class="calibre1">1. </p>
<p class="calibre1">Break the rows of m into w chunks. </p>
<p class="calibre1">2. </p>
<p class="calibre1">Have each worker find the mean number of mutual outlinks for pairs of vertices in its chunk. </p>
<p class="calibre1">3. </p>
<p class="calibre1">Average the results returned by the workers. </p>
<p class="calibre1">It can be shown mathematically that for large problems (the only ones you would need parallel computing for anyway), this chunked approach gives the estimators of the same statistical accuracy as in the nonchunked method. But meanwhile, we’ve turned a nonparallel problem into not just a parallel one but an embarrassingly parallel one! The workers in the preceding outline compute entirely independently of each other. </p>
<p class="calibre1">This method should not be confused with the usual chunk-based</p>
<p class="calibre1">approaches in parallel processing. In those, such as the merge-sort example discussed on page 347, the chunking is embarrassingly parallel, but the combining of results is not. By contrast, here the combining of results consists of simple averaging, thanks to the mathematical theory. </p>
<p class="calibre1">I tried this approach on the mutual outlinks problem in a 4-worker snow cluster. This reduced the runtime to 1.5 seconds. This is far better than the serial time of about 16 seconds, double the speedup obtained by the GPU</p>
<p class="calibre1">and approaching comparability to the OpenMP time. And the theory showing that the two methods give the same statistical accuracy was confirmed as well. The chunked method found the mean number of mutual outlinks to be 249.2881, compared to 249.2993 for the original estimator. </p>
<p class="calibre1"><b class="calibre3">350</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p377"/><b class="calibre3">16.5 Debugging Parallel R Code</b></p>
<p class="calibre1">Parallel R packages such as Rmpi, snow, foreach, and so on do not set up a terminal window for each process, thus making it impossible to use R’s debugger on the workers. (My Rdsm package, which adds a threads capability to R, is an exception to this.)</p>
<p class="calibre1">What then can you do to debug apps for those packages? Let’s consider snow for a concrete example. </p>
<p class="calibre1">First, you should debug the underlying single-worker function, such as mtl() in Section 16.2. Here, we would set up some artificial values of the arguments and then use R’s ordinary debugging facilities. </p>
<p class="calibre1">Debugging the underlying function may be sufficient. However, the bug may be in the arguments themselves or in the way we set them up. Then things get more difficult. </p>
<p class="calibre1">It’s even hard to print out trace information, such as values of variables, since print() won’t work in the worker processes. The message() function may work for some of these packages; if not, you may need to resort to using cat() to write to a file. </p>
<p class="calibre1">Parallel R</p>
<p class="calibre1"><b class="calibre3">351</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p378"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p379"/><img src="index-379_1.png" alt="Image 44" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">A</b></p>
<p class="calibre1"><b class="calibre3">INSTALLING R</b></p>
<p class="calibre1">This appendix covers the methods for</p>
<p class="calibre1">installing R on your system. You can eas-</p>
<p class="calibre1">ily download and install the precompiled</p>
<p class="calibre1">binaries, use your package manager on a UNIX-</p>
<p class="calibre1">based system, or even install from source if you prefer. </p>
<p class="calibre1"><b class="calibre3">A.1 Downloading R from CRAN</b></p>
<p class="calibre1">R, in both its base form and user-written packages, is available on the Comprehensive R Archive Network (CRAN) at the R home page,  <i class="calibre4">http://www</i></p>
<p class="calibre1"> <i class="calibre4">.r-project.org/</i>. Click CRAN and choose a site near you to download the appropriate base package for your operating system (OS). </p>
<p class="calibre1">For most users, installing R is quite simple, regardless of the platform. </p>
<p class="calibre1">You can find precompiled binaries for Windows, Linux, and Mac OS X on CRAN. You should be able to simply download the appropriate file and install R. </p>
<p class="calibre1"><b class="calibre3">A.2 Installing from a Linux Package Manager</b></p>
<p class="calibre1">Rather than using the precompiled binaries, if you’re running a Linux distribution with a centralized package repository, such as Fedora or Ubuntu, you</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p380"/>can install R using your OS’s package manager. For example, if you’re running Fedora, you can install R by typing the following at the command line: $ yum install R</p>
<p class="calibre1">For a Debian-based system, such as Ubuntu, the command looks</p>
<p class="calibre1">like this:</p>
<p class="calibre1">$ sudo apt-get install r-base</p>
<p class="calibre1">Check your distribution’s documentation for more details on installing and removing packages. </p>
<p class="calibre1"><b class="calibre3">A.3 Installing from Source</b></p>
<p class="calibre1">On Linux or other UNIX-based machines (probably including Mac OS X), you can also compile R’s source code yourself. Simply unpack the source archive and follow the classic three-command installation procedure: $ configure</p>
<p class="calibre1">$ make</p>
<p class="calibre1">$ make install</p>
<p class="calibre1">Note that you may need to run make install as root, depending on your write permissions and the location to which you’re installing R. If you want to install to a nonstandard directory, say  <i class="calibre4">/a/b/c</i>, you can run configure with the --prefix parameter, like this:</p>
<p class="calibre1">$ configure --prefix=/a/b/c</p>
<p class="calibre1">This might be helpful if you’re working on a shared machine and don’t have write permissions to the standard installation directories like  <i class="calibre4">/usr</i>. </p>
<p class="calibre1"><b class="calibre3">354</b></p>
<p class="calibre1">Appendix A</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p381"/><img src="index-381_1.png" alt="Image 45" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">B</b></p>
<p class="calibre1"><b class="calibre3">INSTALLING AND USING PACKAGES</b></p>
<p class="calibre1">One of the major strengths of R is that</p>
<p class="calibre1">thousands of user-written packages are</p>
<p class="calibre1">available on the Comprehensive R Archive</p>
<p class="calibre1">Network (CRAN) at the R home page,  <i class="calibre4">http://</i></p>
<p class="calibre1"> <i class="calibre4">www.r-project.org/</i>. Package installation is easy in most</p>
<p class="calibre1">cases, but there are nuances to be aware of for some of</p>
<p class="calibre1">the specialty packages. </p>
<p class="calibre1">This appendix starts with some package basics and then explains how to load R packages from your hard drive and from the Web. </p>
<p class="calibre1"><b class="calibre3">B.1 Package Basics</b></p>
<p class="calibre1">R uses packages to store groups of related pieces of software. The packages that are included with the R distribution are visible as subdirectories of your <i class="calibre4">library </i> directory in your R installation tree, as in  <i class="calibre4">/usr/lib/R/library</i>. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">In the R community, the term </i> library  <i class="calibre4">is often used in place of </i> package <i class="calibre4">. </i></p>
<p class="calibre1">Some packages are loaded automatically when you start R, such as the <i class="calibre4">base </i> subdirectory. However, in order to save memory and time, R does not load all available packages automatically. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p382"/>You can check which packages are currently loaded by typing this:</p>
<p class="calibre1">&gt; .path.package()</p>
<p class="calibre1"><b class="calibre3">B.2 Loading a Package from Your Hard Drive</b></p>
<p class="calibre1">If you need a package that is in your R installation but not loaded into memory yet, you can load it using the library() function. For instance, suppose you wish to generate multivariate normal random vectors. The function mvrnorm() in the package MASS does this. So, load the package as follows:</p>
<p class="calibre1">&gt; library(MASS)</p>
<p class="calibre1">The mvrnorm() function will now be ready to use. And so will its documentation (before you loaded MASS, entering help(mvrnorm) would have generated an error message). </p>
<p class="calibre1"><b class="calibre3">B.3 Downloading a Package from the Web</b></p>
<p class="calibre1">The package you want may not be in your R installation. One of the big advantages of open source software is that people love to share. People all over the world have written their own special-purpose R packages, placing them in the CRAN repository and elsewhere. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">User contributions to CRAN go through a vetting process and are generally of high</i> <i class="calibre4">quality. They are, however, not tested as throughly as R itself. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">B.3.1 Installing Packages Automatically</b></i></p>
<p class="calibre1">One way to install a package is to use the install_packages() function. For example, suppose you wish to use the mvtnorm package, which computes multivariate normal cumulative distribution functions and other quantities. </p>
<p class="calibre1">First, choose a directory in which you wish to install the package (and maybe others in the future), say  <i class="calibre4">/a/b/c</i>. Then at the R prompt, type this:</p>
<p class="calibre1">&gt; install.packages("mvtnorm","/a/b/c/")</p>
<p class="calibre1">This will cause R to automatically go to CRAN, download the package, compile it, and load it into a new directory:  <i class="calibre4">/a/b/c/mvtnorm</i>. </p>
<p class="calibre1">You do need to tell R where to find that package once it’s installed, which you can do via the .libPaths() function:</p>
<p class="calibre1">&gt; .libPaths("/a/b/c/")</p>
<p class="calibre1">This will add that new directory to the ones R was already using. If you use that directory often enough, you may wish to add that call to .libPaths() in your  <i class="calibre4">.Rprofile </i> startup file in your home directory. </p>
<p class="calibre1"><b class="calibre3">356</b></p>
<p class="calibre1">Appendix B</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p383"/>A call to .libPaths() without an argument will show you a list of all the places R will currently look for loading a package when requested. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">B.3.2 Installing Packages Manually</b></i></p>
<p class="calibre1">Sometimes you need to install “by hand” to make modifications required to make a particular R package work on your system. The following example demonstrates how I did so in one particular instance, and it will serve as a case study on handling situations in which ordinary methods don’t work. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Situations in which you need to install packages by hand typically are operating system</i> <i class="calibre4">dependent and require more computer expertise than is generally assumed in this book. </i></p>
<p class="calibre1"> <i class="calibre4">For help in very specific cases, the </i> r-help  <i class="calibre4">mailing list is invaluable. To access it, go to</i> <i class="calibre4">the R home page (</i> http://www.r-project.org/ <i class="calibre4">), click the FAQs link and then the R</i></p>
<p class="calibre1"> <i class="calibre4">FAQ link, and scroll down to Section 2.9, “What mailing lists exist for R?” </i></p>
<p class="calibre1">I wanted to install the Rmpi package on our department’s instructional machines in the directory  <i class="calibre4">/home/matloff/R</i>. I tried using install.packages() first but found that the automated process could not find the MPI library on our machines. The problem was that R was looking for those files in</p>
<p class="calibre1"> <i class="calibre4">/usr/local/lam</i>, whereas I knew they were in  <i class="calibre4">/usr/local/LAM</i>. Since these were public machines, not my own, I did not have the authority to change the name. So, I downloaded the Rmpi files in the packed form  <i class="calibre4">Rmpi_0.5-3</i></p>
<p class="calibre1"> <i class="calibre4">.tar.gz</i>. I unpacked that file in my directory  <i class="calibre4">~/tmp</i>, producing a directory named  <i class="calibre4">~/tmp/Rmpi</i>. </p>
<p class="calibre1">If I had not experienced this problem, at this point, I could have just typed the following in a terminal window from within the  <i class="calibre4">~/tmp </i> directory: R CMD INSTALL -l /home/matloff/R Rmpi</p>
<p class="calibre1">That command would install the package contained in  <i class="calibre4">~/tmp/Rmpi</i>, placing it in  <i class="calibre4">/home/matloff/R</i>. This would have been an alternative to calling install.packages(). </p>
<p class="calibre1">But as noted, I had to deal with a problem. Within the  <i class="calibre4">~/tmp/Rmpi</i> directory, there was a  <i class="calibre4">configure </i> file, so I ran this command on my Linux command line:</p>
<p class="calibre1">configure --help</p>
<p class="calibre1">It told me that I could specify the location of my MPI files to configure, as follows:</p>
<p class="calibre1">configure --with-mpi=/usr/local/LAM</p>
<p class="calibre1">This applies if you run configure directly, but I ran it via R:</p>
<p class="calibre1">R CMD INSTALL -l /home/matloff/R Rmpi --configure-args=--with-mpi=/usr/local/LAM</p>
<p class="calibre1">Installing and Using Packages</p>
<p class="calibre1"><b class="calibre3">357</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p384"/>Well, that seemed to work, in the sense that R did install the package, but R also noted that it had a problem with the threads library on our machines. Sure enough, when I tried to load Rmpi, I got a runtime error, saying that a certain threads function wasn’t there. </p>
<p class="calibre1">I knew that our threads library was fine, so I went into the configure file and commented out two lines:</p>
<p class="calibre1"># if test $ac_cv_lib_pthread_main = yes; then</p>
<p class="calibre1">MPI_LIBS="$MPI_LIBS -lpthread" </p>
<p class="calibre1"># fi</p>
<p class="calibre1">In other words, I forced it to use what I knew (or was fairly sure) would work. I then reran R CMD INSTALL, and the package loaded without any problems. </p>
<p class="calibre1"><b class="calibre3">B.4 Listing the Functions in a Package</b></p>
<p class="calibre1">You can get a list of functions in a package by calling library() with the help argument. For instance, for help on the mvtnorm package, type one of the following:</p>
<p class="calibre1">•</p>
<p class="calibre1">&gt; library(help=mvtnorm)</p>
<p class="calibre1">•</p>
<p class="calibre1">&gt; help(package=mvtnorm)</p>
<p class="calibre1"><b class="calibre3">358</b></p>
<p class="calibre1">Appendix B</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p385"/><b class="calibre3">I N D E X</b></p>
<p class="calibre1"><b class="calibre3">Special Characters</b></p>
<p class="calibre1">lines with abline() function, 263–264</p>
<p class="calibre1">list elements, 88–90</p>
<p class="calibre1">: (colon operator), 32–33</p>
<p class="calibre1">matrix rows and columns, 73–78</p>
<p class="calibre1">== operator, 54–55</p>
<p class="calibre1">points to graphs with points() func-</p>
<p class="calibre1">&gt; operator, 40</p>
<p class="calibre1">tion, 269–270</p>
<p class="calibre1">.libpaths() function, 356–357</p>
<p class="calibre1">text to graphs with text() function, </p>
<p class="calibre1"> <i class="calibre4">.Rdata</i> file, 20</p>
<p class="calibre1">270–271</p>
<p class="calibre1"> <i class="calibre4">.Rhistory</i> file, 20</p>
<p class="calibre1">addmargins() function, 131</p>
<p class="calibre1"> <i class="calibre4">.Rprofile</i> file, 19</p>
<p class="calibre1">adjacency matrix, 333</p>
<p class="calibre1">&lt;&lt;- (superassignment operator), 9</p>
<p class="calibre1">aggregate() function, 136</p>
<p class="calibre1">simplifying code, 174</p>
<p class="calibre1">all() function, 35–39</p>
<p class="calibre1">writing to nonlocals with, 161–162</p>
<p class="calibre1">analogous operations, resizing </p>
<p class="calibre1">+ operator, 31</p>
<p class="calibre1">matrices, 74</p>
<p class="calibre1">"%mut%"() function, 218</p>
<p class="calibre1">anonymous functions, 99, 187–188</p>
<p class="calibre1">antibugging, 287</p>
<p class="calibre1"><b class="calibre3">A</b></p>
<p class="calibre1">any() function, 35–39</p>
<p class="calibre1">application-specific functions, 165</p>
<p class="calibre1">abalone data set</p>
<p class="calibre1">apply() function</p>
<p class="calibre1">recoding, 51–54</p>
<p class="calibre1">applying functions to matrix rows </p>
<p class="calibre1">using lapply() function, 99</p>
<p class="calibre1">and columns, 70–72</p>
<p class="calibre1">abline() graphics function, 150</p>
<p class="calibre1">matrix-like operations, 107</p>
<p class="calibre1">abs() math function, 189</p>
<p class="calibre1">obtaining variable marginal </p>
<p class="calibre1">accessing</p>
<p class="calibre1">values, 131</p>
<p class="calibre1">data frames, 102–104</p>
<p class="calibre1">arguments.  <i class="calibre4">See also specific argument </i></p>
<p class="calibre1">files on remote machines via </p>
<p class="calibre1"> <i class="calibre4">by name</i></p>
<p class="calibre1">URLs, 243</p>
<p class="calibre1">actual, 9</p>
<p class="calibre1">Internet, 246–250</p>
<p class="calibre1">default, 9–10</p>
<p class="calibre1">implementing parallel R exam-</p>
<p class="calibre1">default values for, 146–147</p>
<p class="calibre1">ple, 248–250</p>
<p class="calibre1">formal, 9</p>
<p class="calibre1">sockets, 247–248</p>
<p class="calibre1">arithmetic operations, 30–31, 145–146</p>
<p class="calibre1">TCP/IP, 247</p>
<p class="calibre1">array() function, 134</p>
<p class="calibre1">keyboard and monitor, 232–235</p>
<p class="calibre1">arrays</p>
<p class="calibre1">using print() function, 234–235</p>
<p class="calibre1">higher-dimensional arrays, 82–83</p>
<p class="calibre1">using readline() function, 234</p>
<p class="calibre1">as vectors, 28</p>
<p class="calibre1">using scan() function, 232–234</p>
<p class="calibre1">as.matrix() function, 81</p>
<p class="calibre1">list components and values, 93–95</p>
<p class="calibre1">aspell() function, 211</p>
<p class="calibre1">actual argument, 9</p>
<p class="calibre1">assign() function</p>
<p class="calibre1">adding</p>
<p class="calibre1">variables, 109</p>
<p class="calibre1">legends to graphs with legend()</p>
<p class="calibre1">writing nonlocals with, 163</p>
<p class="calibre1">function, 270</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p386"/>atomic pragma, 343</p>
<p class="calibre1">character strings, 251–259</p>
<p class="calibre1">atomic vectors, 85–86</p>
<p class="calibre1">defined, 11</p>
<p class="calibre1">attr() function, 212</p>
<p class="calibre1">regular expressions, 254–257</p>
<p class="calibre1">forming filenames example, </p>
<p class="calibre1"><b class="calibre3">B</b></p>
<p class="calibre1">256–257</p>
<p class="calibre1">testing filename for given suffix </p>
<p class="calibre1">batch mode, 1</p>
<p class="calibre1">example, 255–256</p>
<p class="calibre1">help feature, 24</p>
<p class="calibre1">string-manipulation functions, </p>
<p class="calibre1">running R in, 3</p>
<p class="calibre1">251–254</p>
<p class="calibre1">Bernoulli sequence, 204</p>
<p class="calibre1">gregexpr(), 254</p>
<p class="calibre1">biglm package, 321</p>
<p class="calibre1">grep(), 252</p>
<p class="calibre1">bigmemory package, 321</p>
<p class="calibre1">nchar(), 252</p>
<p class="calibre1">binary files, 237</p>
<p class="calibre1">paste(), 252–253</p>
<p class="calibre1">binary search tree, 177–182</p>
<p class="calibre1">regexpr(), 253–254</p>
<p class="calibre1">body() function, 149, 151</p>
<p class="calibre1">sprintf(), 253</p>
<p class="calibre1">Boolean operators, 145–146</p>
<p class="calibre1">strsplit(), 253</p>
<p class="calibre1">braces, 144</p>
<p class="calibre1">substr(), 253</p>
<p class="calibre1">brackets, 87–88</p>
<p class="calibre1">use of string utilities in edtdbg debug-</p>
<p class="calibre1">Bravington, Mark, 300</p>
<p class="calibre1">ging tool, 257–259</p>
<p class="calibre1">breakpoints, setting, 289–290</p>
<p class="calibre1">child nodes, binary search tree, 177</p>
<p class="calibre1">calling browser() function directly, </p>
<p class="calibre1">Chinese dialects, aids for learning, </p>
<p class="calibre1">289–290</p>
<p class="calibre1">115–120</p>
<p class="calibre1">using setbreakpoint() function, 290</p>
<p class="calibre1">chi-square distribution, 193–194</p>
<p class="calibre1">breaks component, hist() function, 14</p>
<p class="calibre1">chol() linear algebra function, 197</p>
<p class="calibre1">break statement, 141</p>
<p class="calibre1">choose() set operation, 202</p>
<p class="calibre1">browser commands, 289</p>
<p class="calibre1">chunking memory, 320–321</p>
<p class="calibre1">browser() function</p>
<p class="calibre1">class() function, 212</p>
<p class="calibre1">setting breakpoints, 289–290</p>
<p class="calibre1">cleaner code, 172</p>
<p class="calibre1">single-stepping through code, 288</p>
<p class="calibre1">client/server model, 247</p>
<p class="calibre1">by() function, 126–127</p>
<p class="calibre1">closures, 151, 174–175</p>
<p class="calibre1">byrow argument, matrix() function, </p>
<p class="calibre1">cloud() function, 282–283</p>
<p class="calibre1">61, 236</p>
<p class="calibre1">cluster, snow package, 335</p>
<p class="calibre1">byte code compilation, 320</p>
<p class="calibre1">clusterApply() function, snow package, </p>
<p class="calibre1">72, 337, 339–340</p>
<p class="calibre1"><b class="calibre3">C</b></p>
<p class="calibre1">code files, 3</p>
<p class="calibre1">code safety, 41</p>
<p class="calibre1">c %in% y set operation, 202</p>
<p class="calibre1">col() function, 69–70</p>
<p class="calibre1">cache, 346</p>
<p class="calibre1">colon operator (:), 32–33</p>
<p class="calibre1">calculus, 192–193</p>
<p class="calibre1">color images, 63</p>
<p class="calibre1">categorical variables, 121</p>
<p class="calibre1">column-major order, matrix storage, </p>
<p class="calibre1">cbind() function, 12, 74–75, 106–107</p>
<p class="calibre1">59, 61</p>
<p class="calibre1">c browser command, 289</p>
<p class="calibre1">combinatorial simulation, 205–206</p>
<p class="calibre1">cdf (cumulative distribution </p>
<p class="calibre1">combn() function, 203</p>
<p class="calibre1">function), 193</p>
<p class="calibre1">comdat$countabsamecomm component, 206</p>
<p class="calibre1">ceiling() math function, 190</p>
<p class="calibre1">comdat$numabchosen component, 206</p>
<p class="calibre1">cell counts, changing to </p>
<p class="calibre1">comdat$whosleft component, 206</p>
<p class="calibre1">proportions, 130</p>
<p class="calibre1">comma-separated value (CSV) files, 103</p>
<p class="calibre1">cex option, changing graph character </p>
<p class="calibre1">comments, 3</p>
<p class="calibre1">sizes with, 272–273</p>
<p class="calibre1">complete.cases() function, 105–106</p>
<p class="calibre1">c() function, 56–57</p>
<p class="calibre1">Comprehensive R Archive Network </p>
<p class="calibre1">Chambers, John, 226</p>
<p class="calibre1">(CRAN), 24, 193, 353</p>
<p class="calibre1"><b class="calibre3">360</b></p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p387"/>computed mean, saving in variable, 5</p>
<p class="calibre1">applying logistic regression </p>
<p class="calibre1">concatenating, vectors, 4</p>
<p class="calibre1">models example, 113–115</p>
<p class="calibre1">connections, 237–238</p>
<p class="calibre1">using lapply() and sapply() on </p>
<p class="calibre1">constructors, 217</p>
<p class="calibre1">data frames, 112–113</p>
<p class="calibre1">contingency tables, 128, 229</p>
<p class="calibre1">matrix-like operations, 104–109</p>
<p class="calibre1">control statements, 139–144</p>
<p class="calibre1">apply() function, 107</p>
<p class="calibre1">if-else function, 143–144</p>
<p class="calibre1">extracting subdata frames, </p>
<p class="calibre1">looping over nonvector sets, 143</p>
<p class="calibre1">104–105</p>
<p class="calibre1">loops, 140–142</p>
<p class="calibre1">NA values, 105–106</p>
<p class="calibre1">copy-on-change policy, 314–315</p>
<p class="calibre1">rbind() and cbind() functions, </p>
<p class="calibre1">cos() math function, 190</p>
<p class="calibre1">106–107</p>
<p class="calibre1">counter() function, 175</p>
<p class="calibre1">salary study example, 108–109</p>
<p class="calibre1">counts component</p>
<p class="calibre1">merging, 109–112</p>
<p class="calibre1">hist() function, 14</p>
<p class="calibre1">employee database example, </p>
<p class="calibre1">mapsound() function, 116</p>
<p class="calibre1">111–112</p>
<p class="calibre1">covariance matrix, generating, 69–70</p>
<p class="calibre1">reading from files, 236</p>
<p class="calibre1">CRAN (Comprehensive R Archive Net-</p>
<p class="calibre1">regression analysis of exam grades </p>
<p class="calibre1">work), 24, 193, 353</p>
<p class="calibre1">example, 103–104</p>
<p class="calibre1">critical section, OpenMP, 344</p>
<p class="calibre1">data structures, 10–16</p>
<p class="calibre1">crossprod() function, 196</p>
<p class="calibre1">character strings, 11</p>
<p class="calibre1">cross-validation, 219, 222</p>
<p class="calibre1">classes, 15–16</p>
<p class="calibre1">C-style looping, 140</p>
<p class="calibre1">data frames, 14–15</p>
<p class="calibre1">CSV (comma-separated value) files, 103</p>
<p class="calibre1">lists, 12–14</p>
<p class="calibre1">ct.dat file, 128</p>
<p class="calibre1">matrices, 11–12</p>
<p class="calibre1">cumprod() math function, 190, 191</p>
<p class="calibre1">vectors, 10</p>
<p class="calibre1">cumsum() math function, 39, 190–191</p>
<p class="calibre1">debug() function, 288</p>
<p class="calibre1">cumulative distribution function </p>
<p class="calibre1">debugger() function, performing checks </p>
<p class="calibre1">(cdf), 193</p>
<p class="calibre1">after crash with, 291–292</p>
<p class="calibre1">cumulative sums and products, 191</p>
<p class="calibre1">debugging, 285–304</p>
<p class="calibre1">curve() function, 277–278</p>
<p class="calibre1">ensuring consistency in debugging </p>
<p class="calibre1">customizing graphs, 272–280</p>
<p class="calibre1">simulation code, 302</p>
<p class="calibre1">adding polygons with polygon() func-</p>
<p class="calibre1">facilities, 288–300</p>
<p class="calibre1">tion, 275–276</p>
<p class="calibre1">browser commands, 289</p>
<p class="calibre1">changing character sizes with cex</p>
<p class="calibre1">debug() and browser()</p>
<p class="calibre1">option, 272–273</p>
<p class="calibre1">functions, 288</p>
<p class="calibre1">changing ranges of axes with xlim</p>
<p class="calibre1">debugging sessions, 292–300</p>
<p class="calibre1">and ylim options, 273–275</p>
<p class="calibre1">setting breakpoints, 289–290</p>
<p class="calibre1">graphing explicit functions, 276–277</p>
<p class="calibre1">traceback() and debugger()</p>
<p class="calibre1">magnifying portions of curve </p>
<p class="calibre1">functions, 291–292</p>
<p class="calibre1">example, 277–280</p>
<p class="calibre1">trace() function, 291</p>
<p class="calibre1">smoothing points with lowess() and </p>
<p class="calibre1">global variables and, 173</p>
<p class="calibre1">loess() functions, 276</p>
<p class="calibre1">parallel R, 351</p>
<p class="calibre1">cut() function, 136–137</p>
<p class="calibre1">principles of, 285–287</p>
<p class="calibre1">antibugging, 287</p>
<p class="calibre1"><b class="calibre3">D</b></p>
<p class="calibre1">confirmation, 285–286</p>
<p class="calibre1">modular, top-down manner, 286</p>
<p class="calibre1">data argument, array() function, 134</p>
<p class="calibre1">starting small, 286</p>
<p class="calibre1">data frames, 14–15, 101–102</p>
<p class="calibre1">running GDB on R, 303–304</p>
<p class="calibre1">accessing, 102–104</p>
<p class="calibre1">syntax and runtime errors, 303</p>
<p class="calibre1">applying functions to, 112–120</p>
<p class="calibre1">tools, 287–288, 300–302</p>
<p class="calibre1">aids for learning Chinese dialects </p>
<p class="calibre1">debug package, 300–301</p>
<p class="calibre1">example, 115–120</p>
<p class="calibre1">declarations, 28–29</p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><b class="calibre3">361</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p388"/>default arguments, 9–10</p>
<p class="calibre1">employee database example, 111–112</p>
<p class="calibre1">deleting</p>
<p class="calibre1">encapsulation, 207</p>
<p class="calibre1">list elements, 88–90</p>
<p class="calibre1">end of file (EOF), 238</p>
<p class="calibre1">matrix rows and columns, 73–78</p>
<p class="calibre1">envir argument</p>
<p class="calibre1">a node from binary search tree, 181</p>
<p class="calibre1">get() function, 159</p>
<p class="calibre1">density estimates, same graph, 264–266</p>
<p class="calibre1">ls() function, 155</p>
<p class="calibre1">DES (discrete-event simulation), </p>
<p class="calibre1">environment and scope, 151–159</p>
<p class="calibre1">writing, 164–171</p>
<p class="calibre1">functions have (almost) no side </p>
<p class="calibre1">det() linear algebra function, 197</p>
<p class="calibre1">effects, 156–157</p>
<p class="calibre1">dev.off() function, 3</p>
<p class="calibre1">function to display contents of call </p>
<p class="calibre1">df parameter, mapsound() function, 116</p>
<p class="calibre1">frame example, 157–159</p>
<p class="calibre1">dgbsendeditcmd() function, 257–258</p>
<p class="calibre1">ls() function, 155–156</p>
<p class="calibre1">diag() linear algebra function, 197–198</p>
<p class="calibre1">scope hierarchy, 152–155</p>
<p class="calibre1">diff() function, 50–51</p>
<p class="calibre1">top-level environment, 152</p>
<p class="calibre1">dim argument, array() function, 134</p>
<p class="calibre1">EOF (end of file), 238</p>
<p class="calibre1">dim attribute, matrix class, 79</p>
<p class="calibre1">ess-tracebug package, 300</p>
<p class="calibre1">dimcode argument, apply() function, 70</p>
<p class="calibre1">event list, DES, 164</p>
<p class="calibre1">dimension reduction, avoiding, 80–81</p>
<p class="calibre1">event-oriented paradigm, 164</p>
<p class="calibre1">dim() function, 79</p>
<p class="calibre1">example() function, 21–22</p>
<p class="calibre1">dimnames argument, array() function, 134</p>
<p class="calibre1">exists() function, 230</p>
<p class="calibre1">dimnames() function, 131</p>
<p class="calibre1">expandut() function, 218</p>
<p class="calibre1">dir() function, 245</p>
<p class="calibre1">explicit functions, graphing, 276–277</p>
<p class="calibre1">discrete-event simulation (DES), </p>
<p class="calibre1">exp() math function, 189</p>
<p class="calibre1">writing, 164–171</p>
<p class="calibre1">extracting</p>
<p class="calibre1">discrete-valued time series, predicting, </p>
<p class="calibre1">subdata frames, 104–105</p>
<p class="calibre1">37–39</p>
<p class="calibre1">subtables, 131–134</p>
<p class="calibre1">do.call() function, 133</p>
<p class="calibre1">dosim() function, 165</p>
<p class="calibre1"><b class="calibre3">F</b></p>
<p class="calibre1">double brackets, 87–88</p>
<p class="calibre1">drop argument, 68, 81</p>
<p class="calibre1">factorial() math function, 190</p>
<p class="calibre1">dtdbg debugging tool, use of string utili-</p>
<p class="calibre1">factors, 121</p>
<p class="calibre1">ties in, 257–259</p>
<p class="calibre1">functions, 123, 136</p>
<p class="calibre1">dual-core machines, 341</p>
<p class="calibre1">aggregate(), 136</p>
<p class="calibre1">duplicate() function, 315</p>
<p class="calibre1">by(), 126–127</p>
<p class="calibre1">dynamic task assignment, 348–350</p>
<p class="calibre1">cut(), 136–137</p>
<p class="calibre1">split(), 124–126</p>
<p class="calibre1"><b class="calibre3">E</b></p>
<p class="calibre1">tapply(), 123–124</p>
<p class="calibre1">levels and, 121–122</p>
<p class="calibre1">each argument, rep() function, 34</p>
<p class="calibre1">fangyan, 115</p>
<p class="calibre1">edit() function, 150, 186–187</p>
<p class="calibre1">fargs argument, apply() function, 70</p>
<p class="calibre1">edtdbg package, 300–302</p>
<p class="calibre1">f argument, apply() function, 70</p>
<p class="calibre1">eigen() function, 197, 201</p>
<p class="calibre1">Fedora, installing R on, 353–354</p>
<p class="calibre1">eigenvalues, 201</p>
<p class="calibre1">file.exists() function, 245</p>
<p class="calibre1">eigenvectors, 201</p>
<p class="calibre1">file.info() function, 245, 246</p>
<p class="calibre1">elements</p>
<p class="calibre1">filetype criterion, Google, 24</p>
<p class="calibre1">list, adding and deleting, 88–90</p>
<p class="calibre1">filter() function, 328</p>
<p class="calibre1">vectors</p>
<p class="calibre1">filtering, 45–48</p>
<p class="calibre1">adding and deleting, 26</p>
<p class="calibre1">defined, 25</p>
<p class="calibre1">naming, 56</p>
<p class="calibre1">generating filtering indices, 45–47</p>
<p class="calibre1">embarrassingly parallel applications</p>
<p class="calibre1">matrices, 66–69</p>
<p class="calibre1">defined, 347–348</p>
<p class="calibre1">with subset() function, 47</p>
<p class="calibre1">turning general problems into, 350</p>
<p class="calibre1">with which() selection function, 47–48</p>
<p class="calibre1"><b class="calibre3">362</b></p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p389"/>findud() function, 50</p>
<p class="calibre1"><b class="calibre3">G</b></p>
<p class="calibre1">findwords() function, 90–91</p>
<p class="calibre1">first-class objects, 149</p>
<p class="calibre1">GCC, 325</p>
<p class="calibre1">floor() math function, 190</p>
<p class="calibre1">GDB (GNU debugger), 288, 327</p>
<p class="calibre1">for loop, 306–313</p>
<p class="calibre1">general-purpose editors, 186</p>
<p class="calibre1">achieving better speed in Monte </p>
<p class="calibre1">generating</p>
<p class="calibre1">Carlo simulation example, </p>
<p class="calibre1">covariance matrices, 69–70</p>
<p class="calibre1">308–311</p>
<p class="calibre1">filtering indices, 45–47</p>
<p class="calibre1">generating powers matrix example, </p>
<p class="calibre1">powers matrices, 312–313</p>
<p class="calibre1">312–313</p>
<p class="calibre1">generic functions, xxi</p>
<p class="calibre1">vectorization for speedup, 306–308</p>
<p class="calibre1">classes, 15</p>
<p class="calibre1">formal parameters</p>
<p class="calibre1">implementing on S4 classes, 225–226</p>
<p class="calibre1">mapsound() function, 116</p>
<p class="calibre1">getAnywhere() function, 211</p>
<p class="calibre1">oddcount() function, 9</p>
<p class="calibre1">get() function, 159</p>
<p class="calibre1">formals() function, 149, 151</p>
<p class="calibre1">looping over nonvector sets, 142</p>
<p class="calibre1">forming filenames, 256–257</p>
<p class="calibre1">getnextevnt() function, 165</p>
<p class="calibre1">four-element vector, adding </p>
<p class="calibre1">getwd() function, 245</p>
<p class="calibre1">element to, 26</p>
<p class="calibre1">global variables, 9, 171–174</p>
<p class="calibre1">fromcol parameter, mapsound()</p>
<p class="calibre1">GNU debugger (GDB), 288, 327</p>
<p class="calibre1">function, 116</p>
<p class="calibre1">GNU S language, xix</p>
<p class="calibre1">functional programming, xxi–xxii, </p>
<p class="calibre1">GPU programming, 171, 345</p>
<p class="calibre1">314–316</p>
<p class="calibre1">GPUs (graphics processing units), 345</p>
<p class="calibre1">avoiding memory copy example, </p>
<p class="calibre1">gputools package, 345–346</p>
<p class="calibre1">315–316</p>
<p class="calibre1">granularity, 348</p>
<p class="calibre1">copy-on-change issues, 314–315</p>
<p class="calibre1">graphical user interfaces (GUIs), xx</p>
<p class="calibre1">vector assignment issues, 314</p>
<p class="calibre1">graphics processing units (GPUs), 345</p>
<p class="calibre1">functions, 7–10.  <i class="calibre4">See also</i> math functions; </p>
<p class="calibre1">graphs, 261–283</p>
<p class="calibre1">string-manipulation functions</p>
<p class="calibre1">customizing, 272–280</p>
<p class="calibre1">anonymous, 187–188</p>
<p class="calibre1">adding legends with legend()</p>
<p class="calibre1">applying to data frames, 112–120</p>
<p class="calibre1">function, 270</p>
<p class="calibre1">aids for learning Chinese dialects </p>
<p class="calibre1">adding lines with abline()</p>
<p class="calibre1">example, 115–120</p>
<p class="calibre1">function, 263–264</p>
<p class="calibre1">applying logistic regression </p>
<p class="calibre1">adding points with points()</p>
<p class="calibre1">models example, 113–115</p>
<p class="calibre1">function, 269–270</p>
<p class="calibre1">using lapply() and sapply()</p>
<p class="calibre1">adding polygons with polygon()</p>
<p class="calibre1">functions, 112–113</p>
<p class="calibre1">function, 275–276</p>
<p class="calibre1">applying to lists, 95–99</p>
<p class="calibre1">adding text with text() function, </p>
<p class="calibre1">abalone data example, 99</p>
<p class="calibre1">270–271</p>
<p class="calibre1">lapply() and sapply() functions, 95</p>
<p class="calibre1">changing character sizes with cex</p>
<p class="calibre1">text concordance example, 95–98</p>
<p class="calibre1">option, 272–273</p>
<p class="calibre1">applying to matrix rows and columns, </p>
<p class="calibre1">changing ranges of axes with xlim</p>
<p class="calibre1">70–73</p>
<p class="calibre1">and ylim options, 273–275</p>
<p class="calibre1">apply() function, 70–72</p>
<p class="calibre1">graphing explicit functions, </p>
<p class="calibre1">finding outliers example, 72–73</p>
<p class="calibre1">276–277</p>
<p class="calibre1">default arguments, 9–10</p>
<p class="calibre1">magnifying portions of curve </p>
<p class="calibre1">listing in packages, 358</p>
<p class="calibre1">example, 277–280</p>
<p class="calibre1">as objects, 149–151</p>
<p class="calibre1">smoothing points with lowess()</p>
<p class="calibre1">replacement, 182–186</p>
<p class="calibre1">and loess() functions, 276</p>
<p class="calibre1">for statistical distributions, 193–194</p>
<p class="calibre1">pinpointing locations with locator()</p>
<p class="calibre1">transcendental, 40</p>
<p class="calibre1">function, 271–272</p>
<p class="calibre1">variable scope, 9</p>
<p class="calibre1">plot() function, 262</p>
<p class="calibre1">vector, 35–39, 311</p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><b class="calibre3">363</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p390"/>graphs ( <i class="calibre4">continued</i>)</p>
<p class="calibre1">matrices, 62–63</p>
<p class="calibre1">plots</p>
<p class="calibre1">vector, 31–32</p>
<p class="calibre1">restoring, 272</p>
<p class="calibre1">indices, filtering, 45–47</p>
<p class="calibre1">three-dimensional, 282–283</p>
<p class="calibre1">inheritance</p>
<p class="calibre1">polynomial regression example, </p>
<p class="calibre1">defined, 207</p>
<p class="calibre1">266–269</p>
<p class="calibre1">S3 classes, 214</p>
<p class="calibre1">saving to files, 280–281</p>
<p class="calibre1">initglbls() function, 165</p>
<p class="calibre1">starting new graph while keeping </p>
<p class="calibre1">input/output (I/O).  <i class="calibre4">See</i> I/O</p>
<p class="calibre1">old, 264</p>
<p class="calibre1">installing packages.  <i class="calibre4">See</i> packages</p>
<p class="calibre1">two density estimates on same graph </p>
<p class="calibre1">installing R, 353–354</p>
<p class="calibre1">example, 264–266</p>
<p class="calibre1">downloading base package from </p>
<p class="calibre1">grayscale images, 63</p>
<p class="calibre1">CRAN, 353</p>
<p class="calibre1">gregexpr() function, 254</p>
<p class="calibre1">from Linux package manager, </p>
<p class="calibre1">grep() function, 109, 252</p>
<p class="calibre1">353–354</p>
<p class="calibre1">GUIs (graphical user interfaces), xx</p>
<p class="calibre1">from source, 354</p>
<p class="calibre1">install_packages() function, 356</p>
<p class="calibre1"><b class="calibre3">H</b></p>
<p class="calibre1">integrated development environments </p>
<p class="calibre1">(IDEs), xx, 186</p>
<p class="calibre1">hard drive, loading packages from, 356</p>
<p class="calibre1">intensity, pixel, 63–64</p>
<p class="calibre1">help feature, 20–24</p>
<p class="calibre1">interactive mode, 2–3</p>
<p class="calibre1">additional topics, 23–24</p>
<p class="calibre1">interfacing R to other languages, 323–332</p>
<p class="calibre1">batch mode, 24</p>
<p class="calibre1">using R from Python, 330–332</p>
<p class="calibre1">example() function, 21–22</p>
<p class="calibre1">writing C/C++ functions to be called </p>
<p class="calibre1">help() function, 20–21</p>
<p class="calibre1">from R, 323–330</p>
<p class="calibre1">help.search() function, 22–23</p>
<p class="calibre1">compiling and running code, 325</p>
<p class="calibre1">online, 24</p>
<p class="calibre1">debugging R/C code, 326–327</p>
<p class="calibre1">help() function, 20–21</p>
<p class="calibre1">extracting subdiagonals from </p>
<p class="calibre1">help.search() function, 22–23</p>
<p class="calibre1">square matrix example, 324–325</p>
<p class="calibre1">higher-dimensional arrays, 82–83</p>
<p class="calibre1">prediction of discrete-valued time </p>
<p class="calibre1">hist() function, 3, 13–14</p>
<p class="calibre1">series example, 327–330</p>
<p class="calibre1">hosts, 345</p>
<p class="calibre1">internal data sets, 5</p>
<p class="calibre1">Huang, Min-Yu, 324</p>
<p class="calibre1">internal storage, matrix, 59, 61</p>
<p class="calibre1">Internet, accessing, 246–250</p>
<p class="calibre1"><b class="calibre3">I</b></p>
<p class="calibre1">implementing parallel R example, </p>
<p class="calibre1">248–250</p>
<p class="calibre1">identical() function, 55</p>
<p class="calibre1">sockets, 247–248</p>
<p class="calibre1">IDEs (integrated development environ-</p>
<p class="calibre1">TCP/IP, 247</p>
<p class="calibre1">ments), xx, 186</p>
<p class="calibre1">Internet Protocol (IP) address, 247</p>
<p class="calibre1">ifelse() function, 48–49</p>
<p class="calibre1">intersect() set operation, 202</p>
<p class="calibre1">assessing statistical relation of two </p>
<p class="calibre1">intextract() function, 243</p>
<p class="calibre1">variables example, 49–51</p>
<p class="calibre1">I/O (input/output), 231–250</p>
<p class="calibre1">control statements, 143–144</p>
<p class="calibre1">accessing Internet, 246–250</p>
<p class="calibre1">recoding abalone data set example, </p>
<p class="calibre1">implementing parallel R example, </p>
<p class="calibre1">51–54</p>
<p class="calibre1">248–250</p>
<p class="calibre1">if statements, nested, 141–142</p>
<p class="calibre1">sockets in R, 247–248</p>
<p class="calibre1">image manipulation, 63–66</p>
<p class="calibre1">TCP/IP, 247</p>
<p class="calibre1">images component, mapsound()</p>
<p class="calibre1">accessing keyboard and monitor, </p>
<p class="calibre1">function, 116</p>
<p class="calibre1">232–235</p>
<p class="calibre1">immutable objects, 314</p>
<p class="calibre1">using print() function, 234–235</p>
<p class="calibre1">indexing</p>
<p class="calibre1">using readline() function, 234</p>
<p class="calibre1">list, 87–88</p>
<p class="calibre1">using scan() function, 232–234</p>
<p class="calibre1"><b class="calibre3">364</b></p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p391"/>reading files, 235</p>
<p class="calibre1">lines() function, 264</p>
<p class="calibre1">accessing files on remote </p>
<p class="calibre1">Linux package manager, installing R </p>
<p class="calibre1">machines via URLs, 243</p>
<p class="calibre1">from, 353–354</p>
<p class="calibre1">connections, 237–238</p>
<p class="calibre1">lists, 12–14, 85–100</p>
<p class="calibre1">reading data frame or matrix from </p>
<p class="calibre1">accessing components and values, </p>
<p class="calibre1">files, 236</p>
<p class="calibre1">93–95</p>
<p class="calibre1">reading PUMS census files </p>
<p class="calibre1">applying functions to, 95–99</p>
<p class="calibre1">example, 239–243</p>
<p class="calibre1">abalone data example, 99</p>
<p class="calibre1">reading text files, 237</p>
<p class="calibre1">lapply() and sapply() functions, 95</p>
<p class="calibre1">writing files</p>
<p class="calibre1">text concordance example, 95–98</p>
<p class="calibre1">getting files and directory </p>
<p class="calibre1">general operations, 87–93</p>
<p class="calibre1">information, 245</p>
<p class="calibre1">adding and deleting list elements, </p>
<p class="calibre1">sum contents of many files </p>
<p class="calibre1">88–90</p>
<p class="calibre1">example, 245–246</p>
<p class="calibre1">getting size of list, 90</p>
<p class="calibre1">writing to files, 243–245</p>
<p class="calibre1">list indexing, 87–88</p>
<p class="calibre1">IP (Internet Protocol) address, 247</p>
<p class="calibre1">text concordance example, 90–93</p>
<p class="calibre1">recursive lists, 99–100</p>
<p class="calibre1"><b class="calibre3">J</b></p>
<p class="calibre1">lm()function, 15, 208–210</p>
<p class="calibre1">load balance, 349–350</p>
<p class="calibre1">join operation, 109</p>
<p class="calibre1">locator() function</p>
<p class="calibre1">determining relevant rows and col-</p>
<p class="calibre1"><b class="calibre3">K</b></p>
<p class="calibre1">umns, 64–65</p>
<p class="calibre1">pinpointing locations with, 271–272</p>
<p class="calibre1">keyboard, accessing, 232–235</p>
<p class="calibre1">loess() function, 276</p>
<p class="calibre1">printing to screen, 234–235</p>
<p class="calibre1">log10() math function, 189</p>
<p class="calibre1">using readline() function, 234</p>
<p class="calibre1">logical operations, 30–31</p>
<p class="calibre1">using scan() function, 232–234</p>
<p class="calibre1">logistic regression models, applying, </p>
<p class="calibre1">KMC (k-means clustering), 338–340</p>
<p class="calibre1">113–115</p>
<p class="calibre1">log() math function, 189</p>
<p class="calibre1"><b class="calibre3">L</b></p>
<p class="calibre1">long-run state distribution, Markov </p>
<p class="calibre1">modeling, 200</p>
<p class="calibre1">lag operations, vector, 50–51</p>
<p class="calibre1">loops, control statements, 140–142</p>
<p class="calibre1">lapply() function</p>
<p class="calibre1">lowess() function, 276</p>
<p class="calibre1">applying functions to lists, 95</p>
<p class="calibre1">ls() function</p>
<p class="calibre1">lists, 50</p>
<p class="calibre1">environment and scope, 155–156</p>
<p class="calibre1">looping over nonvector sets, 142</p>
<p class="calibre1">listing objects with, 226–227</p>
<p class="calibre1">using on data frames, 112–113</p>
<p class="calibre1">latency, 346</p>
<p class="calibre1">lazy evaluation principle, 52, 147</p>
<p class="calibre1"><b class="calibre3">M</b></p>
<p class="calibre1">leaving-one-out method, 219, 222</p>
<p class="calibre1">magnifying portions of curve, 277–280</p>
<p class="calibre1">legend() function, 270</p>
<p class="calibre1">makerow() function, 241–242</p>
<p class="calibre1">length() function</p>
<p class="calibre1">managers, snow package, 335</p>
<p class="calibre1">obtaining length of vector, 27</p>
<p class="calibre1">managing objects, 226–230</p>
<p class="calibre1">vector indexing, 32</p>
<p class="calibre1">determining object structure, </p>
<p class="calibre1">levels, factors and, 121–122</p>
<p class="calibre1">228–230</p>
<p class="calibre1">.libPaths() function, 356–357</p>
<p class="calibre1">exists() function, 230</p>
<p class="calibre1">library functions, 165</p>
<p class="calibre1">listing objects with ls() function, </p>
<p class="calibre1">linear algebra operations, on vectors </p>
<p class="calibre1">226–227</p>
<p class="calibre1">and matrices, 61, 196–201</p>
<p class="calibre1">removing specific objects with rm()</p>
<p class="calibre1">finding stationary distributions of </p>
<p class="calibre1">function, 227–228</p>
<p class="calibre1">Markov chains example, 199–201</p>
<p class="calibre1">saving collection of objects with </p>
<p class="calibre1">vector cross product example, 198–199</p>
<p class="calibre1">save() function, 228</p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><b class="calibre3">365</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p392"/>mapsound() function, 115–116</p>
<p class="calibre1">memory</p>
<p class="calibre1">marginal values, variable, 131</p>
<p class="calibre1">chunking, 320–321</p>
<p class="calibre1">m argument, apply() function, 70</p>
<p class="calibre1">functional programming, 314–316</p>
<p class="calibre1">Markov chains, 199–201</p>
<p class="calibre1">avoiding memory copy example, </p>
<p class="calibre1">MASS package, 23, 356</p>
<p class="calibre1">315–316</p>
<p class="calibre1">math functions, 189–193</p>
<p class="calibre1">copy-on-change issues, 314–315</p>
<p class="calibre1">calculating probability example, </p>
<p class="calibre1">vector assignment issues, 314</p>
<p class="calibre1">190–191</p>
<p class="calibre1">using R packages for memory </p>
<p class="calibre1">calculus, 192–193</p>
<p class="calibre1">management, 321</p>
<p class="calibre1">cumulative sums and products, 191</p>
<p class="calibre1">merge() function, 109–110</p>
<p class="calibre1">minima and maxima, 191–192</p>
<p class="calibre1">merge sort method, numerical </p>
<p class="calibre1">matrices, 11–12, 59–83</p>
<p class="calibre1">sorting, 347</p>
<p class="calibre1">adding and deleting rows and col-</p>
<p class="calibre1">merging data frames, 109–112</p>
<p class="calibre1">umns, 73–78</p>
<p class="calibre1">employee database example, </p>
<p class="calibre1">finding closest pair of vertices in </p>
<p class="calibre1">111–112</p>
<p class="calibre1">graph example, 75–78</p>
<p class="calibre1">metacharacters, 254</p>
<p class="calibre1">resizing matrix, 73–75</p>
<p class="calibre1">methods() function, 210</p>
<p class="calibre1">applying functions to rows and col-</p>
<p class="calibre1">microdata, 239</p>
<p class="calibre1">umns, 70–73</p>
<p class="calibre1">minima function, 191–192</p>
<p class="calibre1">apply() function, 70–72</p>
<p class="calibre1">min() math function, 190, 191</p>
<p class="calibre1">finding outliers example, 72–73</p>
<p class="calibre1">M/M/1 queue, 165, 168</p>
<p class="calibre1">avoiding unintended dimension </p>
<p class="calibre1">modes</p>
<p class="calibre1">reduction, 80–81</p>
<p class="calibre1">batch, 1, 3, 24</p>
<p class="calibre1">linear algebra operations on, 196–201</p>
<p class="calibre1">defined, 26</p>
<p class="calibre1">naming rows and columns, 81–82</p>
<p class="calibre1">interactive, 2–3</p>
<p class="calibre1">operations, 61–70</p>
<p class="calibre1">modulo operator, 44</p>
<p class="calibre1">filtering, 66–69</p>
<p class="calibre1">monitor, accessing, 232–235</p>
<p class="calibre1">generating covariance matrix </p>
<p class="calibre1">using print() function, 234–235</p>
<p class="calibre1">example, 69–70</p>
<p class="calibre1">using readline() function, 234</p>
<p class="calibre1">image manipulation example, </p>
<p class="calibre1">using scan() function, 232–234</p>
<p class="calibre1">63–66</p>
<p class="calibre1">Monte Carlo simulation, achieving bet-</p>
<p class="calibre1">linear algebra operations, 61</p>
<p class="calibre1">ter speed in, 308–311</p>
<p class="calibre1">matrix indexing, 62–63</p>
<p class="calibre1">multicore machines, 340–341</p>
<p class="calibre1">reading from files, 236</p>
<p class="calibre1">mutlinks() function, 336</p>
<p class="calibre1">vector/matrix distinction, 78–79</p>
<p class="calibre1">mutual outlinks, 333–334, 341–342</p>
<p class="calibre1">as vectors, 28</p>
<p class="calibre1">mvrnorm() function, MASS package, 23, 356</p>
<p class="calibre1">matrix/array-like operations, 130–131</p>
<p class="calibre1">matrix class, 79</p>
<p class="calibre1"><b class="calibre3">N</b></p>
<p class="calibre1">matrix() function, 60</p>
<p class="calibre1">matrix-inverse update method, 222</p>
<p class="calibre1">named arguments, 146–147</p>
<p class="calibre1">matrix-like operations, 104–109</p>
<p class="calibre1">names() function, 56</p>
<p class="calibre1">apply() function, 107</p>
<p class="calibre1">naming</p>
<p class="calibre1">extracting subdata frames, 104–105</p>
<p class="calibre1">matrix rows and columns, 81–82</p>
<p class="calibre1">NA values, 105–106</p>
<p class="calibre1">vector elements, 56</p>
<p class="calibre1">rbind() and cbind() functions, </p>
<p class="calibre1">NA values</p>
<p class="calibre1">106–107</p>
<p class="calibre1">matrix-like operations, 105–106</p>
<p class="calibre1">salary study example, 108–109</p>
<p class="calibre1">vectors, 43</p>
<p class="calibre1">matrix-multiplication operator, 12</p>
<p class="calibre1">n browser command, 289</p>
<p class="calibre1">maxima function, 191–192</p>
<p class="calibre1">nchar() function, 252</p>
<p class="calibre1">max() math function, 190, 192</p>
<p class="calibre1">ncol() function, 79</p>
<p class="calibre1">mean() function, 38</p>
<p class="calibre1"><b class="calibre3">366</b></p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p393"/>negative subscripts, 32, 63</p>
<p class="calibre1">matrix, 61–70</p>
<p class="calibre1">network, defined, 247</p>
<p class="calibre1">filtering, 66–69</p>
<p class="calibre1">Newton-Raphson method, 192</p>
<p class="calibre1">generating covariance matrix </p>
<p class="calibre1">next statement, 141</p>
<p class="calibre1">example, 69–70</p>
<p class="calibre1">Nile data set, 5</p>
<p class="calibre1">image manipulation example, </p>
<p class="calibre1">noise, adding to image, 65–66</p>
<p class="calibre1">63–66</p>
<p class="calibre1">nominal variables, 121</p>
<p class="calibre1">indexing, 62–63</p>
<p class="calibre1">nonlocals</p>
<p class="calibre1">linear algebra operations, 61</p>
<p class="calibre1">writing to with superassignment </p>
<p class="calibre1">matrix/array-like, 130–131</p>
<p class="calibre1">operator, 161–162</p>
<p class="calibre1">vector, 30–34</p>
<p class="calibre1">writing with assign() function, 163</p>
<p class="calibre1">arithmetic and logical operations, </p>
<p class="calibre1">nonvector sets, looping control state-</p>
<p class="calibre1">30–31</p>
<p class="calibre1">ments over, 143</p>
<p class="calibre1">colon operator (:), 32–33</p>
<p class="calibre1">nonvisible functions, 211</p>
<p class="calibre1">generating vector sequences with </p>
<p class="calibre1">nreps values, 205</p>
<p class="calibre1">seq() function, 33–34</p>
<p class="calibre1">nrow() function, 79</p>
<p class="calibre1">repeating vector constants with </p>
<p class="calibre1">NULL values, 44</p>
<p class="calibre1">rep() function, 34</p>
<p class="calibre1">vector in, matrix out, 42–43</p>
<p class="calibre1"><b class="calibre3">O</b></p>
<p class="calibre1">vector in, vector out, 40–42</p>
<p class="calibre1">vector indexing, 31–32</p>
<p class="calibre1">object-oriented programming.  <i class="calibre4">See </i> OOP</p>
<p class="calibre1">operator precedence, 33</p>
<p class="calibre1">objects.  <i class="calibre4">See also</i> managing objects</p>
<p class="calibre1">order() function, 97, 194–195</p>
<p class="calibre1">first-class, 149</p>
<p class="calibre1">outliers, 49</p>
<p class="calibre1">immutable, 314</p>
<p class="calibre1">oddcount() function, 7, 140</p>
<p class="calibre1"><b class="calibre3">P</b></p>
<p class="calibre1">omp barrier pragma, OpenMP, 344</p>
<p class="calibre1">omp critical pragma, OpenMP, 344</p>
<p class="calibre1">packages, 355–358</p>
<p class="calibre1">omp single pragma, OpenMP, 344–345</p>
<p class="calibre1">installing</p>
<p class="calibre1">OOP (object-oriented programming), </p>
<p class="calibre1">automatically, 356–357</p>
<p class="calibre1">xxi, 207–230 </p>
<p class="calibre1">manually, 357–358</p>
<p class="calibre1">managing objects.  <i class="calibre4">See</i> managing </p>
<p class="calibre1">listing functions in, 358</p>
<p class="calibre1">objects</p>
<p class="calibre1">loading from hard drive, 356</p>
<p class="calibre1">S3 classes.  <i class="calibre4">See</i> S3 classes</p>
<p class="calibre1">parallel R, 333–351</p>
<p class="calibre1">S4 classes, 222–226</p>
<p class="calibre1">debugging, 351</p>
<p class="calibre1">implementing generic function </p>
<p class="calibre1">embarrassingly parallel applica-</p>
<p class="calibre1">on, 225–226</p>
<p class="calibre1">tions, 347–348</p>
<p class="calibre1">vs. S3 classes, 226</p>
<p class="calibre1">turning general problems into, 350</p>
<p class="calibre1">writing, 223–225</p>
<p class="calibre1">implementing, 248–250</p>
<p class="calibre1">OpenMP, 344–345</p>
<p class="calibre1">mutual outlinks, 333–334</p>
<p class="calibre1">code analysis, 343</p>
<p class="calibre1">resorting to C, 340–345</p>
<p class="calibre1">omp barrier pragma, 344</p>
<p class="calibre1">GPU programming, 345</p>
<p class="calibre1">omp critical pragma, 344</p>
<p class="calibre1">multicore machines, 340–341</p>
<p class="calibre1">omp single pragma, 344–345</p>
<p class="calibre1">mutual outlinks, 341–342</p>
<p class="calibre1">operations</p>
<p class="calibre1">OpenMP code analysis, 343</p>
<p class="calibre1">list, 87–93</p>
<p class="calibre1">OpenMP pragmas, 344–345</p>
<p class="calibre1">adding and deleting list elements, </p>
<p class="calibre1">running OpenMP code, 342</p>
<p class="calibre1">88–90</p>
<p class="calibre1">snow package, 334–340</p>
<p class="calibre1">getting size of list, 90</p>
<p class="calibre1">analyzing snow code, 336–337</p>
<p class="calibre1">list indexing, 87–88</p>
<p class="calibre1">k-means clustering (KMC), 338–340</p>
<p class="calibre1">text concordance example, 90–93</p>
<p class="calibre1">running snow code, 335–336</p>
<p class="calibre1">speedup, 337–338</p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><b class="calibre3">367</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p394"/>snow package ( <i class="calibre4">continued</i>)</p>
<p class="calibre1">polynomial regression, 219–222, 266–269</p>
<p class="calibre1">sources of overhead, 346–347</p>
<p class="calibre1">port number, 247</p>
<p class="calibre1">networked systems of computers, </p>
<p class="calibre1">powers matrix, generating, 312–313</p>
<p class="calibre1">346–347</p>
<p class="calibre1">pragmas, OpenMP, 343–345</p>
<p class="calibre1">shared-memory machines, 346</p>
<p class="calibre1">preda() function, 38</p>
<p class="calibre1">static vs. dynamic task assignment, </p>
<p class="calibre1">principle of confirmation, debugging, </p>
<p class="calibre1">348–350</p>
<p class="calibre1">285–286</p>
<p class="calibre1">parent.frame() function, 156</p>
<p class="calibre1">print() function, 18, 234–235</p>
<p class="calibre1">paste() function, 252–253, 257, 269</p>
<p class="calibre1">print.ut() function, 218</p>
<p class="calibre1">PDF devices, saving displayed </p>
<p class="calibre1">prntrslts() function, 165</p>
<p class="calibre1">graphs, 281</p>
<p class="calibre1">probability, calculating, 190–191</p>
<p class="calibre1">pdf() function, 3</p>
<p class="calibre1">probability mass function (pmf), 193</p>
<p class="calibre1">Pearson product-moment </p>
<p class="calibre1">procpairs() function, 343</p>
<p class="calibre1">correlation, 49</p>
<p class="calibre1">prod() math function, 190</p>
<p class="calibre1">performance enhancement, 305–321</p>
<p class="calibre1">programming structures.  <i class="calibre4">See</i> R program-</p>
<p class="calibre1">byte code compilation, 320</p>
<p class="calibre1">ming structures</p>
<p class="calibre1">chunking, 320–321</p>
<p class="calibre1">Public Use Microdata Samples (PUMS) </p>
<p class="calibre1">functional programming, 314–316</p>
<p class="calibre1">census files, reading, 239</p>
<p class="calibre1">avoiding memory copy example, </p>
<p class="calibre1">Python, using R from, 330–332</p>
<p class="calibre1">315–316</p>
<p class="calibre1">copy-on-change issues, 314–315</p>
<p class="calibre1"><b class="calibre3">Q</b></p>
<p class="calibre1">vector assignment issues, 314</p>
<p class="calibre1">for loop, 306–313</p>
<p class="calibre1">Q browser command, 289</p>
<p class="calibre1">achieving better speed in a Monte </p>
<p class="calibre1">qr() linear algebra function, 197</p>
<p class="calibre1">Carlo simulation example, </p>
<p class="calibre1">Quicksort implementation, 176–177</p>
<p class="calibre1">308–311</p>
<p class="calibre1">generating powers matrix exam-</p>
<p class="calibre1"><b class="calibre3">R</b></p>
<p class="calibre1">ple, 312–313</p>
<p class="calibre1">vectorization for speedup, 306–308</p>
<p class="calibre1">race condition, 343</p>
<p class="calibre1">using R packages for memory </p>
<p class="calibre1">random variate generators, 204–205</p>
<p class="calibre1">rank()</p>
<p class="calibre1">management, 321</p>
<p class="calibre1">function, 195–196</p>
<p class="calibre1">rbind()</p>
<p class="calibre1">using Rprof() function to find slow </p>
<p class="calibre1">function, 12, 106–107</p>
<p class="calibre1">spots in code, 316–319</p>
<p class="calibre1">ordering events, 171</p>
<p class="calibre1">writing fast R code, 306</p>
<p class="calibre1">resizing matrices, 74–75</p>
<p class="calibre1">rbinom()</p>
<p class="calibre1">Perron-Frobenius theorem, 201</p>
<p class="calibre1">function, 204</p>
<p class="calibre1">persp() function, 22, 282</p>
<p class="calibre1">R console, 2</p>
<p class="calibre1">pixel intensity, 63–64</p>
<p class="calibre1"> <i class="calibre4">.Rdata</i> file, 20</p>
<p class="calibre1">plot()</p>
<p class="calibre1">Rdsm</p>
<p class="calibre1">function, xxi, 16, 262</p>
<p class="calibre1">package, implementing </p>
<p class="calibre1">plots</p>
<p class="calibre1">parallel R, 249</p>
<p class="calibre1">reactevnt()</p>
<p class="calibre1">restoring, 272</p>
<p class="calibre1">function, 165</p>
<p class="calibre1">readBin()</p>
<p class="calibre1">three-dimensional, 282–283</p>
<p class="calibre1">function, 248</p>
<p class="calibre1">plyr</p>
<p class="calibre1">read.csv()</p>
<p class="calibre1">package, 136</p>
<p class="calibre1">function, 108</p>
<p class="calibre1">pmax() math function, 190, 192</p>
<p class="calibre1">reading files, 235</p>
<p class="calibre1">pmf (probability mass function), 193</p>
<p class="calibre1">accessing files on remote machines </p>
<p class="calibre1">pmin() math function, 190, 191</p>
<p class="calibre1">via URLs, 243</p>
<p class="calibre1">pointers, 159–161</p>
<p class="calibre1">connections, 237–238</p>
<p class="calibre1">points() function, 269–270</p>
<p class="calibre1">reading data frames or matrices from </p>
<p class="calibre1">polygon() function, 275–276</p>
<p class="calibre1">files, 236</p>
<p class="calibre1">polymorphism</p>
<p class="calibre1">reading PUMS census files example, </p>
<p class="calibre1">defined, xxi, 207</p>
<p class="calibre1">239–243</p>
<p class="calibre1">generic functions, 208</p>
<p class="calibre1">reading text files, 237</p>
<p class="calibre1"><b class="calibre3">368</b></p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p395"/>readline() function, 234</p>
<p class="calibre1">R programming structures, 139</p>
<p class="calibre1">readLines() function, 248</p>
<p class="calibre1">anonymous functions, 187–188</p>
<p class="calibre1">reassigning matrices, 73–74</p>
<p class="calibre1">arithmetic and Boolean operators </p>
<p class="calibre1">recursion, 176–182</p>
<p class="calibre1">and values, 145–146</p>
<p class="calibre1">binary search tree example, 177–182</p>
<p class="calibre1">control statements, 139–144</p>
<p class="calibre1">Quicksort implementation, 176–177</p>
<p class="calibre1">if-else function, 143–144</p>
<p class="calibre1">recursive argument, concatenate </p>
<p class="calibre1">looping over nonvector sets, 143</p>
<p class="calibre1">function, 100</p>
<p class="calibre1">loops, 140–142</p>
<p class="calibre1">recursive vectors, 86</p>
<p class="calibre1">default values for arguments, 146–147</p>
<p class="calibre1">recycling</p>
<p class="calibre1">environment and scope issues, </p>
<p class="calibre1">defined, 25</p>
<p class="calibre1">151–159</p>
<p class="calibre1">vectors, 29–30</p>
<p class="calibre1">function to display contents of call </p>
<p class="calibre1">reference classes, 160</p>
<p class="calibre1">frame example, 157–159</p>
<p class="calibre1">regexpr() function, 253–254</p>
<p class="calibre1">ls() function, 155–156</p>
<p class="calibre1">regression analysis of exam grades, </p>
<p class="calibre1">scope hierarchy, 152–155</p>
<p class="calibre1">16–19, 103–104</p>
<p class="calibre1">side effects, 156–157</p>
<p class="calibre1">regular expressions, character string </p>
<p class="calibre1">top-level environment, 152</p>
<p class="calibre1">manipulation, 254–257</p>
<p class="calibre1">functions as objects, 149–151</p>
<p class="calibre1">remote machines, accessing files </p>
<p class="calibre1">pointers, lack of, 159–161</p>
<p class="calibre1">on, 243</p>
<p class="calibre1">recursion, 176–182</p>
<p class="calibre1">repeat loop, 241–242</p>
<p class="calibre1">binary search tree example, </p>
<p class="calibre1">repeat statement, 141</p>
<p class="calibre1">177–182</p>
<p class="calibre1">rep() function, repeating vector con-</p>
<p class="calibre1">Quicksort implementation, </p>
<p class="calibre1">stants with, 34</p>
<p class="calibre1">176–177</p>
<p class="calibre1">replacement functions, 182–186</p>
<p class="calibre1">replacement functions, 182–186</p>
<p class="calibre1">defined, 183–184</p>
<p class="calibre1">return values, 147–149</p>
<p class="calibre1">self-bookkeeping vector class </p>
<p class="calibre1">deciding whether to explicitly call </p>
<p class="calibre1">example, 184–186</p>
<p class="calibre1">return() function, 148</p>
<p class="calibre1">reshape package, 136</p>
<p class="calibre1">returning complex objects, </p>
<p class="calibre1">resizing matrices, 73–75</p>
<p class="calibre1">148–149</p>
<p class="calibre1">return statement, 8</p>
<p class="calibre1">tools for composing function code, </p>
<p class="calibre1">return values, 147–149</p>
<p class="calibre1">186–187</p>
<p class="calibre1">deciding whether to explicitly call </p>
<p class="calibre1">edit() function, 186–187</p>
<p class="calibre1">return() function, 148</p>
<p class="calibre1">text editors and IDEs, 186</p>
<p class="calibre1">returning complex objects, 148–149</p>
<p class="calibre1">writing, 161–175</p>
<p class="calibre1">REvolution Analytics, 300</p>
<p class="calibre1">binary operations, 187</p>
<p class="calibre1">rexp() function, 204</p>
<p class="calibre1">closures, 174–175</p>
<p class="calibre1">Rf_PrintValue(s) function, 304</p>
<p class="calibre1">discrete-event simulation (DES) in </p>
<p class="calibre1">rgamma() function, 204</p>
<p class="calibre1">R example, 164–171</p>
<p class="calibre1"> <i class="calibre4">.Rhistory</i> file, 20</p>
<p class="calibre1">when to use global variables, </p>
<p class="calibre1">rm() function, 227–228</p>
<p class="calibre1">171–174</p>
<p class="calibre1">rnorm() function, 3, 204</p>
<p class="calibre1">writing to nonlocals with assign()</p>
<p class="calibre1">round() function, 40–41, 190</p>
<p class="calibre1">function, 163</p>
<p class="calibre1">routers, 247</p>
<p class="calibre1">writing to nonlocals with the super-</p>
<p class="calibre1">row() function, 69–70</p>
<p class="calibre1">assignment operator, 161–162</p>
<p class="calibre1">rownames() function, 82</p>
<p class="calibre1">RPy module</p>
<p class="calibre1">R packages, for memory </p>
<p class="calibre1">installing, 330</p>
<p class="calibre1">management, 321</p>
<p class="calibre1">syntax, 330–332</p>
<p class="calibre1">rpois() function, 204</p>
<p class="calibre1">runif() function, 204</p>
<p class="calibre1">Rprof() function, 316–319</p>
<p class="calibre1">running</p>
<p class="calibre1"> <i class="calibre4">.Rprofile</i> file, 19</p>
<p class="calibre1">GDB on R, 303–304</p>
<p class="calibre1">OpenMP code, 342</p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><b class="calibre3">369</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p396"/>running ( <i class="calibre4">continued</i>)</p>
<p class="calibre1">setdiff() set operation, 202</p>
<p class="calibre1">R, 1–2</p>
<p class="calibre1">setequal() set operation, 202</p>
<p class="calibre1">batch mode, 3</p>
<p class="calibre1">setMethod() function, 225</p>
<p class="calibre1">first session, 4–7</p>
<p class="calibre1">set operations, 202–203</p>
<p class="calibre1">interactive mode, 2–3</p>
<p class="calibre1">set.seed() function, 302</p>
<p class="calibre1">snow code, 335–336</p>
<p class="calibre1">setting breakpoints, 289–290</p>
<p class="calibre1">runs of consecutive ones, finding, 35–37</p>
<p class="calibre1">calling browser() function directly, </p>
<p class="calibre1">runtime errors, 303</p>
<p class="calibre1">289–290</p>
<p class="calibre1">using setbreakpoint() function, 290</p>
<p class="calibre1"><b class="calibre3">S</b></p>
<p class="calibre1">setwd() function, 245</p>
<p class="calibre1">S expression pointers (SEXPs), 304</p>
<p class="calibre1">S (programming language), xix</p>
<p class="calibre1">shared-memory systems, 341, 346–347</p>
<p class="calibre1">S3 classes, 208–222</p>
<p class="calibre1">shared-memory/threads model, </p>
<p class="calibre1">class for storing upper-triangular </p>
<p class="calibre1">GPUs, 345</p>
<p class="calibre1">matrices example, 214–219</p>
<p class="calibre1">Sherman-Morrison-Woodbury </p>
<p class="calibre1">finding implementations of generic </p>
<p class="calibre1">formula, 222</p>
<p class="calibre1">methods, 210–212</p>
<p class="calibre1">shortcuts</p>
<p class="calibre1">generic functions, 208</p>
<p class="calibre1">help() function, 20</p>
<p class="calibre1">OOP in lm() function example, </p>
<p class="calibre1">help.search() function, 23</p>
<p class="calibre1">208–210</p>
<p class="calibre1">showframe() function, 158</p>
<p class="calibre1">procedure for polynomial regression </p>
<p class="calibre1">sim global variable, 172–173</p>
<p class="calibre1">example, 219–222</p>
<p class="calibre1">simplifying code, 172</p>
<p class="calibre1">vs. S4 classes, 226</p>
<p class="calibre1">simulation programming in R, 204–206</p>
<p class="calibre1">using inheritance, 214</p>
<p class="calibre1">built-in random variate generators, </p>
<p class="calibre1">writing, 212–213</p>
<p class="calibre1">204–205</p>
<p class="calibre1">S4 classes, 222–226</p>
<p class="calibre1">combinatorial simulation, 205–206</p>
<p class="calibre1">implementing generic function on, </p>
<p class="calibre1">obtaining same random stream in </p>
<p class="calibre1">225–226</p>
<p class="calibre1">repeated runs, 205</p>
<p class="calibre1">vs. S3 classes, 226</p>
<p class="calibre1">single brackets, 87–88</p>
<p class="calibre1">writing, 223–225</p>
<p class="calibre1">single-server queuing system, 168</p>
<p class="calibre1">salary study, 108–109</p>
<p class="calibre1">sink() function, 258</p>
<p class="calibre1">Salzman, Pete, 285</p>
<p class="calibre1">sin() math function, 190</p>
<p class="calibre1">sapply() function, 42</p>
<p class="calibre1">slots, S4 class, 224</p>
<p class="calibre1">applying functions to lists, 95</p>
<p class="calibre1">snow package, 334–335</p>
<p class="calibre1">using on data frames, 112–113</p>
<p class="calibre1">implementing parallel R, 248–249</p>
<p class="calibre1">save() function, saving collection of </p>
<p class="calibre1">k-means clustering (KMC), 338–340</p>
<p class="calibre1">objects with, 228</p>
<p class="calibre1">snow code</p>
<p class="calibre1">saving graphs to files, 280–281</p>
<p class="calibre1">analyzing, 336–337</p>
<p class="calibre1">scalars, 10</p>
<p class="calibre1">running, 335–336</p>
<p class="calibre1">Boolean operators, 145</p>
<p class="calibre1">speedup, 337–338</p>
<p class="calibre1">vectors, 26</p>
<p class="calibre1">socketConnection() function, 248</p>
<p class="calibre1">scan() function, 142, 232–234</p>
<p class="calibre1">sockets, 247–248</p>
<p class="calibre1">scatter/gather paradigm, 335–336</p>
<p class="calibre1">socketSelect() function, 248</p>
<p class="calibre1">schedevnt() function, 165, 171</p>
<p class="calibre1">solve() function, 197</p>
<p class="calibre1">scope hierarchy, 152–155.  <i class="calibre4">See also</i> envi-</p>
<p class="calibre1">sorting, numerical, 194–196</p>
<p class="calibre1">ronment and scope</p>
<p class="calibre1">sos package, 24</p>
<p class="calibre1">sepsoundtone() function, 119</p>
<p class="calibre1">source, installing R from, 354</p>
<p class="calibre1">seq() function, 21, 33–34</p>
<p class="calibre1">sourceval parameter, mapsound()</p>
<p class="calibre1">serialize() function, 248</p>
<p class="calibre1">function, 116</p>
<p class="calibre1">setbreakpoint() function, 290</p>
<p class="calibre1">Spearman rank correlation, 49</p>
<p class="calibre1">setClass() function, 223</p>
<p class="calibre1"><b class="calibre3">370</b></p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p397"/>speed</p>
<p class="calibre1">summary() function, 15, 18</p>
<p class="calibre1">byte code compilation, 320</p>
<p class="calibre1">summaryRprof() function, 319</p>
<p class="calibre1">finding slow spots in code, 316–319</p>
<p class="calibre1">summing contents of many files, 245–246</p>
<p class="calibre1">for loop, 306–313</p>
<p class="calibre1">superassignment operator (&lt;&lt;-), 9</p>
<p class="calibre1">achieving better speed in Monte </p>
<p class="calibre1">simplifying code, 174</p>
<p class="calibre1">Carlo simulation example, </p>
<p class="calibre1">writing to nonlocals with, 161–162</p>
<p class="calibre1">308–311</p>
<p class="calibre1">sweep() linear algebra function, 197–198</p>
<p class="calibre1">generating powers matrix </p>
<p class="calibre1">symmetric matrix, 77</p>
<p class="calibre1">example, 312–313</p>
<p class="calibre1">syntax errors, 303</p>
<p class="calibre1">vectorization for speedup, </p>
<p class="calibre1">306–308</p>
<p class="calibre1"><b class="calibre3">T</b></p>
<p class="calibre1">writing fast R code, 306</p>
<p class="calibre1">Spinu, Vitalie, 300</p>
<p class="calibre1">tabdom() function, 134</p>
<p class="calibre1">split() function, 124–126, 336</p>
<p class="calibre1">tables, 127–130</p>
<p class="calibre1">S-Plus (programming language), xix</p>
<p class="calibre1">extracting subtable example, </p>
<p class="calibre1">sprintf() function, 253</p>
<p class="calibre1">131–134</p>
<p class="calibre1">sqrt() function, 42, 189</p>
<p class="calibre1">finding largest cells in, 134</p>
<p class="calibre1">stack trace, 289</p>
<p class="calibre1">functions, 136–137</p>
<p class="calibre1">startup and shutdown, 19–20</p>
<p class="calibre1">aggregate(), 136</p>
<p class="calibre1">static task assignment, 348–350</p>
<p class="calibre1">cut(), 136–137</p>
<p class="calibre1">stationary distributions, Markov chains, </p>
<p class="calibre1">matrix/array-like operations, </p>
<p class="calibre1">199–201</p>
<p class="calibre1">130–131</p>
<p class="calibre1">statistical distributions, functions for, </p>
<p class="calibre1">tags, 86</p>
<p class="calibre1">193–194</p>
<p class="calibre1">tapply() function</p>
<p class="calibre1">str() function, 14</p>
<p class="calibre1">vs. by() function, 126–127</p>
<p class="calibre1">string-manipulation functions, 11, </p>
<p class="calibre1">factors, 123–124</p>
<p class="calibre1">251–254</p>
<p class="calibre1">vs. split() function, 124</p>
<p class="calibre1">gregexpr(), 254</p>
<p class="calibre1">tbl argument, subtable() function, 132</p>
<p class="calibre1">grep(), 252</p>
<p class="calibre1">tblarray array, 133</p>
<p class="calibre1">nchar(), 252</p>
<p class="calibre1">TCP/IP, 247</p>
<p class="calibre1">paste(), 252–253</p>
<p class="calibre1">termination condition, 177</p>
<p class="calibre1">regexpr(), 253–254</p>
<p class="calibre1">testing vector equality, 54–55</p>
<p class="calibre1">sprintf(), 253</p>
<p class="calibre1">text, adding to graphs with text() func-</p>
<p class="calibre1">strsplit(), 253</p>
<p class="calibre1">tion, 270–271</p>
<p class="calibre1">substr(), 253</p>
<p class="calibre1">text concordance, 90–93, 95–98</p>
<p class="calibre1">stringsAsFactors argument, data.frame()</p>
<p class="calibre1">text editors, 186</p>
<p class="calibre1">function, 102</p>
<p class="calibre1">text files, reading, 237</p>
<p class="calibre1">string utilities, in edtdbg debugging tool, </p>
<p class="calibre1">text() function, adding text to graphs </p>
<p class="calibre1">257–259</p>
<p class="calibre1">with, 270–271</p>
<p class="calibre1">strsplit() function, 253</p>
<p class="calibre1">t() function, 71, 119, 197</p>
<p class="calibre1">subdeterminants, 199</p>
<p class="calibre1">threaded code, 171</p>
<p class="calibre1">submatrices, assigning values to, 62–63</p>
<p class="calibre1">threads, 341</p>
<p class="calibre1">subnames argument, subtable()</p>
<p class="calibre1">three-dimensional tables, 129–130</p>
<p class="calibre1">function, 132</p>
<p class="calibre1">Tierney, Luke, 334</p>
<p class="calibre1">subscripting operations, 183</p>
<p class="calibre1">tocol parameter, mapsound()</p>
<p class="calibre1">subset() function, 47, 105</p>
<p class="calibre1">function, 116</p>
<p class="calibre1">subsetting, vector, 4–5</p>
<p class="calibre1">tools</p>
<p class="calibre1">substr() function, 253</p>
<p class="calibre1">for composing function code, </p>
<p class="calibre1">subtable() function, 132</p>
<p class="calibre1">186–187</p>
<p class="calibre1">suffix, testing filename for given, 255–256</p>
<p class="calibre1">edit() function, 186–187</p>
<p class="calibre1">sum() function, 190, 337</p>
<p class="calibre1">text editors and IDEs, 186</p>
<p class="calibre1">debugging, 287–288, 300–302</p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><b class="calibre3">371</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p398"/>top-level environment, 152</p>
<p class="calibre1">vectors, 10, 25–57</p>
<p class="calibre1">traceback() function, 291–292</p>
<p class="calibre1">all() and any() functions, 35–39</p>
<p class="calibre1">trace() function, 291</p>
<p class="calibre1">finding runs of consecutive ones </p>
<p class="calibre1">tracemem() function, 314–315</p>
<p class="calibre1">example, 35–37</p>
<p class="calibre1">training set, 37</p>
<p class="calibre1">predicting discrete-valued time </p>
<p class="calibre1">transcendental functions, 40</p>
<p class="calibre1">series example, 37–39</p>
<p class="calibre1">transition probability, 200</p>
<p class="calibre1">c() function, 56–57</p>
<p class="calibre1">treelike data structures, 177</p>
<p class="calibre1">common operations, 30–34</p>
<p class="calibre1">arithmetic and logical operations, </p>
<p class="calibre1"><b class="calibre3">U</b></p>
<p class="calibre1">30–31</p>
<p class="calibre1">colon operator (:), 32–33</p>
<p class="calibre1">Ubuntu, installing R on, 353–354</p>
<p class="calibre1">generating vector sequences with </p>
<p class="calibre1">unclass() function, 229</p>
<p class="calibre1">seq() function, 33–34</p>
<p class="calibre1">union() set operation, 202</p>
<p class="calibre1">repeating vector constants with </p>
<p class="calibre1">unlist() function, 93</p>
<p class="calibre1">rep() function, 34</p>
<p class="calibre1">unname() function, 94</p>
<p class="calibre1">vector indexing, 31–32</p>
<p class="calibre1">unserialize() function, 248</p>
<p class="calibre1">computing inner product of two, 196</p>
<p class="calibre1">upn argument, showframe() function, 158</p>
<p class="calibre1">declarations, 28–29</p>
<p class="calibre1">upper-triangular matrices, class for stor-</p>
<p class="calibre1">defined, 4</p>
<p class="calibre1">ing, 214–219</p>
<p class="calibre1">elements</p>
<p class="calibre1">URLs, accessing files on remote </p>
<p class="calibre1">adding and deleting, 26</p>
<p class="calibre1">machines via, 243</p>
<p class="calibre1">naming, 56</p>
<p class="calibre1">u variable, 162</p>
<p class="calibre1">filtering, 45–48</p>
<p class="calibre1">generating indices for, 45–47</p>
<p class="calibre1"><b class="calibre3">V</b></p>
<p class="calibre1">with subset() function, 47</p>
<p class="calibre1">with which() function, 47–48</p>
<p class="calibre1">values</p>
<p class="calibre1">ifelse() function, 48–54</p>
<p class="calibre1">assigning to submatrices, 62–63</p>
<p class="calibre1">assessing statistical relation of two </p>
<p class="calibre1">Boolean, 145–146</p>
<p class="calibre1">variables example, 49–51</p>
<p class="calibre1">list, accessing, 93–95</p>
<p class="calibre1">recoding abalone data set </p>
<p class="calibre1">NA, 43, 105–106</p>
<p class="calibre1">example, 51–54</p>
<p class="calibre1">NULL, 44</p>
<p class="calibre1">linear algebra operations on, </p>
<p class="calibre1">return, 147–149</p>
<p class="calibre1">196–201</p>
<p class="calibre1">vanilla option, startup/shutdown, 20</p>
<p class="calibre1">matrices and arrays as, 28</p>
<p class="calibre1">variables</p>
<p class="calibre1">NA value, 43</p>
<p class="calibre1">assessing statistical relation of two, </p>
<p class="calibre1">NULL value, 44</p>
<p class="calibre1">49–51</p>
<p class="calibre1">obtaining length of, 27</p>
<p class="calibre1">categorical, 121</p>
<p class="calibre1">recycling, 29–30</p>
<p class="calibre1">global, 9, 171–174</p>
<p class="calibre1">scalars, 26</p>
<p class="calibre1">nominal, 121</p>
<p class="calibre1">testing vector equality, 54–55</p>
<p class="calibre1">variable scope, 9</p>
<p class="calibre1">vectorized operations, 39–43</p>
<p class="calibre1">vector assignment issues, 314</p>
<p class="calibre1">vector in, matrix out, 42–43</p>
<p class="calibre1">vector cross product, 198–199</p>
<p class="calibre1">vector in, vector out, 40–42</p>
<p class="calibre1">vector filtering, 307</p>
<p class="calibre1">vertices, graph, finding, 75–78</p>
<p class="calibre1">vector-filtering capability, 176</p>
<p class="calibre1">vector functions, 311</p>
<p class="calibre1"><b class="calibre3">W</b></p>
<p class="calibre1">vectorization</p>
<p class="calibre1">defined, 25</p>
<p class="calibre1">Web, downloading packages from, </p>
<p class="calibre1">for speedup, 306–308</p>
<p class="calibre1">356–358</p>
<p class="calibre1">vectorized operations, 40</p>
<p class="calibre1">installing automatically, 356–357</p>
<p class="calibre1">vector/matrix distinction, 78–79</p>
<p class="calibre1">installing manually, 357–358</p>
<p class="calibre1"><b class="calibre3">372</b></p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p399"/>where browser command, 289</p>
<p class="calibre1">which.max() function, 73, 190</p>
<p class="calibre1">which.min() function, 190</p>
<p class="calibre1">which() function, 47–48</p>
<p class="calibre1">whitespace, 233</p>
<p class="calibre1">Wickham, Hadley, 136</p>
<p class="calibre1">wireframe() function, 282–283</p>
<p class="calibre1">wmins matrix, 77</p>
<p class="calibre1">workers, snow package, 335</p>
<p class="calibre1">working directory, 19–20</p>
<p class="calibre1">writeBin() function, 248</p>
<p class="calibre1">writeLines() function, 248</p>
<p class="calibre1">write.table() function, 244</p>
<p class="calibre1">writing, 161</p>
<p class="calibre1">binary operations, 187</p>
<p class="calibre1">C/C++ functions to be called from R, </p>
<p class="calibre1">323–324</p>
<p class="calibre1">compiling and running code, 325</p>
<p class="calibre1">debugging R/C code, 326–327</p>
<p class="calibre1">extracting subdiagonals from </p>
<p class="calibre1">square matrix example, 324–325</p>
<p class="calibre1">prediction of discrete-valued time </p>
<p class="calibre1">series example, 327–330</p>
<p class="calibre1">closures, 174–175</p>
<p class="calibre1">discrete-event simulation in R </p>
<p class="calibre1">example, 164–171</p>
<p class="calibre1">getting files and directory </p>
<p class="calibre1">information, 245</p>
<p class="calibre1">to nonlocals</p>
<p class="calibre1">with assign() function, 163</p>
<p class="calibre1">with superassignment operator, </p>
<p class="calibre1">161–162</p>
<p class="calibre1">S3 classes, 212–213</p>
<p class="calibre1">S4 classes, 223–225</p>
<p class="calibre1">summing contents of many files </p>
<p class="calibre1">example, 245–246</p>
<p class="calibre1">when to use global variables, 171–174</p>
<p class="calibre1"><b class="calibre3">X</b></p>
<p class="calibre1">xlim option, 273–275</p>
<p class="calibre1">x variable, 162</p>
<p class="calibre1"><b class="calibre3">Y</b></p>
<p class="calibre1">ylim option, 273–275</p>
<p class="calibre1"><b class="calibre3">Z</b></p>
<p class="calibre1">z variable, 162</p>
<p class="calibre1">INDEX</p>
<p class="calibre1"><b class="calibre3">373</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p400"/>The Electronic Frontier Foundation (EFF) is the leading organization defending civil liberties in the digital world. We defend free speech on the Internet, fight illegal surveillance, promote the rights of innovators to develop new digital technologies, and work to ensure that the rights and freedoms we enjoy are enhanced — </p>
<p class="calibre1">rather than eroded — as our use of technology grows. </p>
<p class="calibre1">PRIVACY EFF has sued telecom giant AT&amp;T for giving the NSA unfettered access to the private communications of millions of their customers. eff.org/nsa</p>
<p class="calibre1">FREE SPEECH EFF’s Coders’ Rights Project is defending the rights of programmers and security researchers to publish their findings without fear of legal challenges. </p>
<p class="calibre1">eff.org/freespeech</p>
<p class="calibre1">INNOVATION EFF's Patent Busting Project challenges overbroad patents that threaten technological innovation. eff.org/patent</p>
<p class="calibre1">FAIR USE EFF is fighting prohibitive standards that would take away your right to receive and use over-the-air television broadcasts any way you choose.  eff.org/IP/fairuse TRANSPARENCY EFF has developed the Switzerland Network Testing Tool to give individuals the tools to test for covert traffic filtering. eff.org/transparency</p>
<p class="calibre1">INTERNATIONAL EFF is working to ensure that international treaties do not restrict our free speech, privacy or digital consumer rights. eff.org/global</p>
<p class="calibre1">EFF is a member-supported organization. Join Now!  www.eff.org/support</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p401"/><img src="index-401_1.jpg" alt="Image 46" class="calibre2"/></p>
<p class="calibre1"><img src="index-401_2.jpg" alt="Image 47" class="calibre2"/></p>
<p class="calibre1"><img src="index-401_3.jpg" alt="Image 48" class="calibre2"/></p>
<p class="calibre1"><img src="index-401_4.jpg" alt="Image 49" class="calibre2"/></p>
<p class="calibre1"><img src="index-401_5.jpg" alt="Image 50" class="calibre2"/></p>
<p class="calibre1"><img src="index-401_6.jpg" alt="Image 51" class="calibre2"/></p>
<p class="calibre1">UPDATES</p>
<p class="calibre1">Visit  <i class="calibre4">http://www.nostarch.com/artofr.htm</i> for updates, errata, and more. </p>
<p class="calibre1"> <i class="calibre4">More no-nonsense books from </i></p>
<p class="calibre1"> <i class="calibre4"> </i> NO STARCH PRESS</p>
<p class="calibre1">MAP SCRIPTING 101</p>
<p class="calibre1">LEARN YOU A HASKELL </p>
<p class="calibre1">ELOQUENT JAVASCRIPT</p>
<p class="calibre1">An Example-Driven Guide to Building </p>
<p class="calibre1">FOR GREAT GOOD</p>
<p class="calibre1">A Modern Introduction to Programming</p>
<p class="calibre1">Interactive Maps with Bing, Yahoo!, </p>
<p class="calibre1">A Beginner’s Guide</p>
<p class="calibre1"> <i class="calibre4">by </i> MARIJN HAVERBEKE</p>
<p class="calibre1">and Google Maps</p>
<p class="calibre1">JANUARY 2011, 224 PP., $29.95</p>
<p class="calibre1"> <i class="calibre4">by </i> MIRAN LIPOVAýA</p>
<p class="calibre1">ISBN 978-1-59327-282-1</p>
<p class="calibre1"> <i class="calibre4">by </i> ADAM DUVANDER</p>
<p class="calibre1">APRIL 2011, 400 PP., $44.95</p>
<p class="calibre1">AUGUST 2010, 376 PP., $34.95</p>
<p class="calibre1">ISBN 978-1-59327-283-8 </p>
<p class="calibre1">ISBN 978-1-59327-271-5 </p>
<p class="calibre1">THE TCP/IP GUIDE</p>
<p class="calibre1">THE MANGA GUIDE™ TO </p>
<p class="calibre1">THE LINUX PROGRAMMING </p>
<p class="calibre1">A Comprehensive, Illustrated Internet </p>
<p class="calibre1">STATISTICS</p>
<p class="calibre1">INTERFACE</p>
<p class="calibre1">Protocols Reference</p>
<p class="calibre1"> <i class="calibre4">by </i> SHIN TAKAHASHI  <i class="calibre4">and </i> TREND-PRO</p>
<p class="calibre1">A Linux and UNIX® System </p>
<p class="calibre1"> <i class="calibre4">by </i> CHARLES M. KOZIEROK</p>
<p class="calibre1">CO., LTD</p>
<p class="calibre1">Programming Handbook</p>
<p class="calibre1">OCTOBER 2005, 1616 PP., $99.95,  <i class="calibre4">hardcover</i></p>
<p class="calibre1">NOVEMBER 2008, 232 PP., $19.95</p>
<p class="calibre1"> <i class="calibre4">by </i> MICHAEL KERRISK</p>
<p class="calibre1">ISBN 978-1-59327-047-6</p>
<p class="calibre1">ISBN 978-1-59327-189-3 </p>
<p class="calibre1">OCTOBER 2010, 1552 PP., $99.95,  <i class="calibre4">hardcover</i></p>
<p class="calibre1">ISBN 978-1-59327-220-3</p>
<p class="calibre1"><b class="calibre3">PHONE:</b></p>
<p class="calibre1"><b class="calibre3">EMAIL:</b></p>
<p class="calibre1">800.420.7240 OR</p>
<p class="calibre1">SALES@NOSTARCH.COM</p>
<p class="calibre1">415.863.9900</p>
<p class="calibre1"><b class="calibre3">WEB:</b></p>
<p class="calibre1">MONDAY THROUGH FRIDAY, </p>
<p class="calibre1">9 A.M. TO 5 P.M. (PST)</p>
<p class="calibre1">WWW.NOSTARCH.COM</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p402"/>The fonts used in  <i class="calibre4">The Art of R Programming </i> are New Baskerville, Futura, The Sans Mono Condensed and Dogma. The book was typeset with LATEX 2 <i class="calibre4">ε</i></p>
<p class="calibre1">package nostarch by Boris Veytsman  <i class="calibre4">(2008/06/06 v1.3 Typesetting books for No</i> <i class="calibre4">Starch Press). </i></p>
<p class="calibre1">This book was printed and bound at Malloy Incorporated in Ann Arbor, Michigan. The paper is Glatfelter Spring Forge 60# Smooth, which is certi-fied by the Sustainable Forestry Initiative (SFI). The book uses a RepKover binding, which allows it to lie flat when open. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p403"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p404"/><img src="index-404_1.png" alt="Image 52" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">T A M E   Y O U R   D A T A</b></p>
<p class="calibre1"><b class="calibre3">T</b></p>
<p class="calibre1"><b class="calibre3">T H E</b></p>
<p class="calibre1"><b class="calibre3">HE A</b></p>
<p class="calibre1"><b class="calibre3">A R T   O F   R</b></p>
<p class="calibre1">R is the world’s most popular language for developing </p>
<p class="calibre1">• Interface R with C/C++ and Python for increased </p>
<p class="calibre1"><b class="calibre3">R</b></p>
<p class="calibre1">statistical software: Archaeologists use it to track the </p>
<p class="calibre1">speed or functionality</p>
<p class="calibre1"><b class="calibre3">T O</b></p>
<p class="calibre1"><b class="calibre3">PROGR A MMING</b></p>
<p class="calibre1">spread of ancient civilizations, drug companies use it </p>
<p class="calibre1">• Find new packages for text analysis, image manipula-</p>
<p class="calibre1">to discover which medications are safe and effective, </p>
<p class="calibre1">tion, and thousands more</p>
<p class="calibre1">and actuaries use it to assess financial risks and keep </p>
<p class="calibre1"><b class="calibre3">A   T O U R   O F   S T A T I S T I C A L   S O F T W A R E   D E S I G N</b></p>
<p class="calibre1"><b class="calibre3">F R P</b></p>
<p class="calibre1">markets running smoothly. </p>
<p class="calibre1">• Squash annoying bugs with advanced debugging </p>
<p class="calibre1">techniques</p>
<p class="calibre1"> <i class="calibre4">The Art of R Programming</i> takes you on a guided tour </p>
<p class="calibre1">of software development with R, from basic types </p>
<p class="calibre1">Whether you’re designing aircraft, forecasting the </p>
<p class="calibre1">and data structures to advanced topics like closures, </p>
<p class="calibre1">weather, or you just need to tame your data,  <i class="calibre4">The Art of </i></p>
<p class="calibre1"><b class="calibre3">N O R M A N   M A T L O F F</b></p>
<p class="calibre1">recursion, and anonymous functions. No statistical </p>
<p class="calibre1"> <i class="calibre4">R Programming</i> is your guide to harnessing the power </p>
<p class="calibre1"><b class="calibre3">R</b></p>
<p class="calibre1">knowledge is required, and your programming skil s </p>
<p class="calibre1">of statistical computing. </p>
<p class="calibre1">can range from hobbyist to pro. </p>
<p class="calibre1"><b class="calibre3">O</b></p>
<p class="calibre1"><b class="calibre3">A B O U T   T H E   A U T H O R</b></p>
<p class="calibre1">Along the way, you’ll learn about functional and object-</p>
<p class="calibre1"><b class="calibre3">G</b></p>
<p class="calibre1">Norman Matloff is a professor of computer science </p>
<p class="calibre1">oriented programming, running mathematical simulations, </p>
<p class="calibre1">(and a former professor of statistics) at the University </p>
<p class="calibre1"><b class="calibre3">R</b></p>
<p class="calibre1">and rearranging complex data into simpler, more useful </p>
<p class="calibre1">of California, Davis. His research interests include </p>
<p class="calibre1">formats. You’ll also learn to:</p>
<p class="calibre1"><b class="calibre3">A</b></p>
<p class="calibre1">paral el processing and statistical regression, and </p>
<p class="calibre1">• Create artful graphs to visualize complex data sets </p>
<p class="calibre1">he is the author of several widely used web tutorials </p>
<p class="calibre1"><b class="calibre3">M</b></p>
<p class="calibre1">and functions</p>
<p class="calibre1">on software development. He has written articles for </p>
<p class="calibre1">the  <i class="calibre4">New York Times</i>, the  <i class="calibre4">Washington Post</i>,  <i class="calibre4">Forbes</i> <b class="calibre3">M</b></p>
<p class="calibre1">• Write more efficient code using paral el R and </p>
<p class="calibre1"> <i class="calibre4">Magazine</i>, and the  <i class="calibre4">Los Angeles Times</i>, and he is the </p>
<p class="calibre1">vectorization</p>
<p class="calibre1"><b class="calibre3">I</b></p>
<p class="calibre1">co-author of  <i class="calibre4">The Art of Debugging</i> (No Starch Press). </p>
<p class="calibre1"><b class="calibre3">NG</b></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">TH E FI N EST I N G E E K E NTE RTAI N M E NT™</b></i></p>
<p class="calibre1">www.nostarch.com</p>
<p class="calibre1"><b class="calibre3">MAT</b></p>
<p class="calibre1"><b class="calibre3">L</b></p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"><b class="calibre3">O</b></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">“I LI E FLAT.” </b></i></p>
<p class="calibre1"><b class="calibre3">$39.95  <i class="calibre4">($41.95 CDN)</i></b></p>
<p class="calibre1"><b class="calibre3">F</b></p>
<p class="calibre1"><b class="calibre3">S C S</b></p>
<p class="calibre1"> <i class="calibre4">This book uses RepKover —a durable binding that won’t snap shut. </i></p>
<p class="calibre1"><b class="calibre3">T O H</b></p>
<p class="calibre1"><b class="calibre3">A</b></p>
<p class="calibre1"><b class="calibre3">F</b></p>
<p class="calibre1"><b class="calibre3">M E</b></p>
<p class="calibre1"><b class="calibre3">T</b></p>
<p class="calibre1"><b class="calibre3">LV</b></p>
<p class="calibre1"><b class="calibre3">I P</b></p>
<p class="calibre1"><b class="calibre3">ST U E</b></p>
<p class="calibre1"><b class="calibre3">I T  I</b></p>
<p class="calibre1"><b class="calibre3">C E N</b></p>
<p class="calibre1"><b class="calibre3">A R :</b></p>
<p class="calibre1"><b class="calibre3">L S</b></p>
<p class="calibre1"><b class="calibre3"> SO /M</b></p>
<p class="calibre1"><b class="calibre3">F A</b></p>
<p class="calibre1"><b class="calibre3">T T</b></p>
<p class="calibre1"><b class="calibre3">W H</b></p>
<p class="calibre1"><b class="calibre3">A EM</b></p>
<p class="calibre1"><b class="calibre3">RE ATICAL &amp; </b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="outline"/></p>


<p class="calibre1">
<h1 class="calibre5" id="calibre_pb_0">Document Outline</h1>
<ul class="calibre6">
<li class="calibre7"><a href="index_split_000.html#p6">Copyright</a></li>
<li class="calibre7"><a href="index_split_000.html#p7">Brief Contents</a></li>
<li class="calibre7"><a href="index_split_000.html#p9">Contents in Detail</a></li>
<li class="calibre7"><a href="index_split_000.html#p19">Acknowledgments</a></li>
<li class="calibre7"><a href="index_split_000.html#p21">Introduction</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p21">Why Use R for Your Statistical Work? </a></li>
<li class="calibre7"><a href="index_split_000.html#p24">Whom Is This Book For? </a></li>
<li class="calibre7"><a href="index_split_000.html#p25">My Own Background</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p27">1: Getting Started</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p27">1.1 How to Run R</a></li>
<li class="calibre7"><a href="index_split_000.html#p30">1.2 A First R Session</a></li>
<li class="calibre7"><a href="index_split_000.html#p33">1.3 Introduction to Functions</a></li>
<li class="calibre7"><a href="index_split_000.html#p36">1.4 Preview of Some Important R Data Structures</a></li>
<li class="calibre7"><a href="index_split_000.html#p42">1.5 Extended Example: Regression Analysis of Exam Grades</a></li>
<li class="calibre7"><a href="index_split_000.html#p45">1.6 Startup and Shutdown</a></li>
<li class="calibre7"><a href="index_split_000.html#p46">1.7 Getting Help</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p51">2: Vectors</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p52">2.1 Scalars, Vectors, Arrays, and Matrices</a></li>
<li class="calibre7"><a href="index_split_000.html#p54">2.2 Declarations</a></li>
<li class="calibre7"><a href="index_split_000.html#p55">2.3 Recycling</a></li>
<li class="calibre7"><a href="index_split_000.html#p56">2.4 Common Vector Operations</a></li>
<li class="calibre7"><a href="index_split_001.html#p61">2.5 Using all() and any()</a></li>
<li class="calibre7"><a href="index_split_001.html#p65">2.6 Vectorized Operations</a></li>
<li class="calibre7"><a href="index_split_001.html#p69">2.7 NA and NULL Values</a></li>
<li class="calibre7"><a href="index_split_001.html#p71">2.8 Filtering</a></li>
<li class="calibre7"><a href="index_split_001.html#p74">2.9 A Vectorized if-then-else: The ifelse() Function</a></li>
<li class="calibre7"><a href="index_split_001.html#p80">2.10 Testing Vector Equality</a></li>
<li class="calibre7"><a href="index_split_001.html#p82">2.11 Vector Element Names</a></li>
<li class="calibre7"><a href="index_split_001.html#p82">2.12 More on c()</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p85">3: Matrices and Arrays</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_001.html#p85">3.1 Creating Matrices</a></li>
<li class="calibre7"><a href="index_split_001.html#p87">3.2 General Matrix Operations</a></li>
<li class="calibre7"><a href="index_split_001.html#p96">3.3 Applying Functions to Matrix Rows and Columns</a></li>
<li class="calibre7"><a href="index_split_001.html#p99">3.4 Adding and Deleting Matrix Rows and Columns</a></li>
<li class="calibre7"><a href="index_split_001.html#p104">3.5 More on the Vector/Matrix Distinction</a></li>
<li class="calibre7"><a href="index_split_001.html#p106">3.6 Avoiding Unintended Dimension Reduction</a></li>
<li class="calibre7"><a href="index_split_001.html#p107">3.7 Naming Matrix Rows and Columns</a></li>
<li class="calibre7"><a href="index_split_001.html#p108">3.8 Higher-Dimensional Arrays</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p111">4: Lists</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_001.html#p111">4.1 Creating Lists</a></li>
<li class="calibre7"><a href="index_split_001.html#p113">4.2 General List Operations</a></li>
<li class="calibre7"><a href="index_split_002.html#p119">4.3 Accessing List Components and Values</a></li>
<li class="calibre7"><a href="index_split_002.html#p121">4.4 Applying Functions to Lists</a></li>
<li class="calibre7"><a href="index_split_002.html#p125">4.5 Recursive Lists</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_002.html#p127">5: Data Frames</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_002.html#p128">5.1 Creating Data Frames</a></li>
<li class="calibre7"><a href="index_split_002.html#p130">5.2 Other Matrix-Like Operations</a></li>
<li class="calibre7"><a href="index_split_002.html#p135">5.3 Merging Data Frames</a></li>
<li class="calibre7"><a href="index_split_002.html#p138">5.4 Applying Functions to Data Frames</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_002.html#p147">6: Factors and Tables</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_002.html#p147">6.1 Factors and Levels</a></li>
<li class="calibre7"><a href="index_split_002.html#p149">6.2 Common Functions Used with Factors</a></li>
<li class="calibre7"><a href="index_split_002.html#p153">6.3 Working with Tables</a></li>
<li class="calibre7"><a href="index_split_002.html#p162">6.4 Other Factor- and Table-Related Functions</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_003.html#p165">7: R Programming Structures</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_003.html#p165">7.1 Control Statements</a></li>
<li class="calibre7"><a href="index_split_003.html#p171">7.2 Arithmetic and Boolean Operators and Values</a></li>
<li class="calibre7"><a href="index_split_003.html#p172">7.3 Default Values for Arguments</a></li>
<li class="calibre7"><a href="index_split_003.html#p173">7.4 Return Values</a></li>
<li class="calibre7"><a href="index_split_003.html#p175">7.5 Functions Are Objects</a></li>
<li class="calibre7"><a href="index_split_003.html#p177">7.6 Environment and Scope Issues</a></li>
<li class="calibre7"><a href="index_split_003.html#p185">7.7 No Pointers in R</a></li>
<li class="calibre7"><a href="index_split_003.html#p187">7.8 Writing Upstairs</a></li>
<li class="calibre7"><a href="index_split_003.html#p202">7.9 Recursion</a></li>
<li class="calibre7"><a href="index_split_003.html#p208">7.10 Replacement Functions</a></li>
<li class="calibre7"><a href="index_split_004.html#p212">7.11 Tools for Composing Function Code</a></li>
<li class="calibre7"><a href="index_split_004.html#p213">7.12 Writing Your Own Binary Operations</a></li>
<li class="calibre7"><a href="index_split_004.html#p213">7.13 Anonymous Functions</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_004.html#p215">8: Doing Math and Simulations in R</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_004.html#p215">8.1 Math Functions</a></li>
<li class="calibre7"><a href="index_split_004.html#p219">8.2 Functions for Statistical Distributions</a></li>
<li class="calibre7"><a href="index_split_004.html#p220">8.3 Sorting</a></li>
<li class="calibre7"><a href="index_split_004.html#p222">8.4 Linear Algebra Operations on Vectors and Matrices</a></li>
<li class="calibre7"><a href="index_split_004.html#p228">8.5 Set Operations</a></li>
<li class="calibre7"><a href="index_split_004.html#p230">8.6 Simulation Programming in R</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_004.html#p233">9: Object-Oriented Programming</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_004.html#p234">9.1 S3 Classes</a></li>
<li class="calibre7"><a href="index_split_004.html#p248">9.2 S4 Classes</a></li>
<li class="calibre7"><a href="index_split_004.html#p252">9.3 S3 Versus S4</a></li>
<li class="calibre7"><a href="index_split_004.html#p252">9.4 Managing Your Objects</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_004.html#p257">10: Input/Output</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_004.html#p258">10.1 Accessing the Keyboard and Monitor</a></li>
<li class="calibre7"><a href="index_split_005.html#p261">10.2 Reading and Writing Files</a></li>
<li class="calibre7"><a href="index_split_005.html#p272">10.3 Accessing the Internet</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_005.html#p277">11: String Manipulation</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_005.html#p277">11.1 An Overview of String-Manipulation Functions</a></li>
<li class="calibre7"><a href="index_split_005.html#p280">11.2 Regular Expressions</a></li>
<li class="calibre7"><a href="index_split_005.html#p283">11.3 Use of String Utilities in the edtdbg Debugging Tool</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_005.html#p287">12: Graphics</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_005.html#p287">12.1 Creating Graphs</a></li>
<li class="calibre7"><a href="index_split_005.html#p298">12.2 Customizing Graphs</a></li>
<li class="calibre7"><a href="index_split_005.html#p306">12.3 Saving Graphs to Files</a></li>
<li class="calibre7"><a href="index_split_005.html#p308">12.4 Creating Three-Dimensional Plots</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_005.html#p311">13: Debugging</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_005.html#p311">13.1 Fundamental Principles of Debugging</a></li>
<li class="calibre7"><a href="index_split_005.html#p313">13.2 Why Use a Debugging Tool? </a></li>
<li class="calibre7"><a href="index_split_005.html#p314">13.3 Using R Debugging Facilities</a></li>
<li class="calibre7"><a href="index_split_006.html#p326">13.4 Moving Up in the World: More Convenient DebuggingTools</a></li>
<li class="calibre7"><a href="index_split_006.html#p328">13.5 Ensuring Consistency in Debugging Simulation Code</a></li>
<li class="calibre7"><a href="index_split_006.html#p329">13.6 Syntax and Runtime Errors</a></li>
<li class="calibre7"><a href="index_split_006.html#p329">13.7 Running GDB on R Itself</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p331">14: Performance Enhancement: Speed and Memory</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_006.html#p332">14.1 Writing Fast R Code</a></li>
<li class="calibre7"><a href="index_split_006.html#p332">14.2 The Dreaded for Loop</a></li>
<li class="calibre7"><a href="index_split_006.html#p340">14.3 Functional Programming and Memory Issues</a></li>
<li class="calibre7"><a href="index_split_006.html#p342">14.4 Using Rprof() to Find Slow Spots in Your Code</a></li>
<li class="calibre7"><a href="index_split_006.html#p346">14.5 Byte Code Compilation</a></li>
<li class="calibre7"><a href="index_split_006.html#p346">14.6 Oh No, the Data Doesn’t Fit into Memory! </a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p349">15: Interfacing R to Other Languages</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_006.html#p349">15.1 Writing C/C++ Functions to Be Called from R</a></li>
<li class="calibre7"><a href="index_split_006.html#p356">15.2 Using R from Python</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p359">16: Parallel R</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_006.html#p359">16.1 The Mutual Outlinks Problem</a></li>
<li class="calibre7"><a href="index_split_006.html#p360">16.2 Introducing the snow Package</a></li>
<li class="calibre7"><a href="index_split_006.html#p366">16.3 Resorting to C</a></li>
<li class="calibre7"><a href="index_split_006.html#p371">16.4 General Performance Considerations</a></li>
<li class="calibre7"><a href="index_split_006.html#p377">16.5 Debugging Parallel R Code</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p379">Appendix A: Installing R</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_006.html#p379">A.1 Downloading R from CRAN</a></li>
<li class="calibre7"><a href="index_split_006.html#p379">A.2 Installing from a Linux Package Manager</a></li>
<li class="calibre7"><a href="index_split_006.html#p380">A.3 Installing from Source</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p381">Appendix B: Installing and Using Packages</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_006.html#p381">B.1 Package Basics</a></li>
<li class="calibre7"><a href="index_split_006.html#p382">B.2 Loading a Package from Your Hard Drive</a></li>
<li class="calibre7"><a href="index_split_006.html#p382">B.3 Downloading a Package from the Web</a></li>
<li class="calibre7"><a href="index_split_006.html#p384">B.4 Listing the Functions in a Package</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_006.html#p385">Index</a></li>
<li class="calibre7"><a href="index_split_006.html#p401">UPDATES</a></li>
</ul></p>
</body></html>