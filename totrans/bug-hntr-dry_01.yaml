- en: Chapter 1. Bug Hunting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 漏洞挖掘
- en: '*Bug hunting* is the process of finding bugs in software or hardware. In this
    book, however, the term *bug hunting* will be used specifically to describe the
    process of finding security-critical software bugs. Security-critical bugs, also
    called software security vulnerabilities, allow an attacker to remotely compromise
    systems, escalate local privileges, cross privilege boundaries, or otherwise wreak
    havoc on a system.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*漏洞挖掘* 是在软件或硬件中寻找错误的过程。然而，在这本书中，术语 *漏洞挖掘* 将专门用来描述寻找安全关键软件错误的过程。安全关键错误，也称为软件安全漏洞，允许攻击者远程损害系统、提升本地权限、跨越权限边界，或者以其他方式对系统造成破坏。'
- en: About a decade ago, hunting for software security vulnerabilities was mostly
    done as a hobby or as a way to gain media attention. Bug hunting found its way
    into the mainstream when people realized that it’s possible to profit from vulnerabilities.^([[1](ch01s06.html#ftn.CHP-1-FN-1)])
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大约十年前，寻找软件安全漏洞主要是作为一种爱好或作为一种吸引媒体关注的方式。当人们意识到可以从漏洞中获利时，漏洞挖掘进入了主流。[^1](ch01s06.html#ftn.CHP-1-FN-1)
- en: Software security vulnerabilities, and programs that take advantage of such
    vulnerabilities (known as *exploits*), get a lot of press coverage. In addition,
    numerous books and Internet resources describe the process of exploiting these
    vulnerabilities, and there are perpetual debates over how to disclose bug findings.
    Despite all this, surprisingly little has been published on the bug-hunting process
    itself. Although terms like *software vulnerability* or *exploit* are widely used,
    many people—even many information security professionals—don’t know how bug hunters
    find security vulnerabilities in software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全漏洞，以及利用这些漏洞的程序（称为 *漏洞利用*），得到了很多媒体报道。此外，许多书籍和互联网资源描述了利用这些漏洞的过程，并且关于如何披露漏洞发现的问题一直在持续辩论。尽管如此，关于漏洞挖掘过程本身的出版物却出奇地少。尽管像
    *软件漏洞* 或 *漏洞利用* 这样的术语被广泛使用，但许多人——甚至许多信息安全专业人士——并不知道漏洞挖掘者是如何在软件中找到安全漏洞的。
- en: If you ask 10 different bug hunters how they search through software for security-related
    bugs, you will most likely get 10 different answers. This is one of the reasons
    why there is not, and probably will never be, a “cookbook” for bug hunting. Rather
    than trying and failing to write a book of generalized instructions, I will describe
    the approaches and techniques that I used to find specific bugs in real-life software.
    Hopefully this book will help you develop your own style so you can find some
    interesting security-critical software bugs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问10个不同的漏洞挖掘者他们如何搜索软件中的安全相关错误，你很可能会得到10个不同的答案。这就是为什么至今还没有，可能永远也不会有一个“食谱”式的漏洞挖掘指南。与其试图编写一本通用的指令书而失败，我将描述我用来在现实生活中的软件中找到特定错误的方法和技术。希望这本书能帮助你发展自己的风格，以便你能够找到一些有趣的、安全关键的软件错误。
- en: 1.1 For Fun and Profit
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 为了乐趣和利益
- en: People who hunt for bugs have a variety of goals and motivations. Some independent
    bug hunters want to improve software security, while others seek personal gain
    in the form of fame, media attention, payment, or employment. A company might
    want to find bugs to use them as fodder for marketing campaigns. Of course, there
    are always the bad apples who want to find new ways to break into systems or networks.
    On the other hand, some people simply do it for fun—or to save the world. ![](httpatomoreillycomsourcenostarchimages939227.png)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找漏洞的人有不同的目标和动机。一些独立的漏洞挖掘者希望提高软件安全性，而其他人则寻求通过名声、媒体关注、报酬或就业来获得个人收益。一家公司可能希望找到漏洞，以便将其用作营销活动的素材。当然，总有那些坏苹果，他们想找到新的方法来入侵系统或网络。另一方面，有些人只是出于乐趣——或者为了拯救世界。![更多内容](httpatomoreillycomsourcenostarchimages939227.png)
- en: 1.2 Common Techniques
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 常见技术
- en: 'Although no formal documentation exists that describes the standard bug-hunting
    process, common techniques do exist. These techniques can be split into two categories:
    *static* and *dynamic*. In static analysis, also referred to as *static code analysis*,
    the source code of the software, or the disassembly of a binary, is examined but
    not executed. Dynamic analysis, on the other hand, involves debugging or fuzzing
    the target software while it’s executing. Both techniques have pros and cons,
    and most bug hunters use a combination of static and dynamic techniques.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有正式的文档描述标准的bug寻找过程，但确实存在一些常见的技巧。这些技巧可以分为两类：*静态*和*动态*。在静态分析中，也称为*静态代码分析*，检查软件的源代码或二进制的反汇编，但不执行。相反，动态分析涉及在软件执行时进行调试或模糊测试。这两种技术都有其优缺点，大多数bug猎人都会使用静态和动态技术的组合。
- en: My Preferred Techniques
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我偏爱的技巧
- en: Most of the time, I prefer the static analysis approach. I usually read the
    source code or disassembly of the target software line by line and try to understand
    it. However, reading all the code from beginning to end is generally not practical.
    When I’m looking for bugs, I typically start by trying to identify where user-influenced
    input data enters the software through an interface to the outside world. This
    could be network data, file data, or data from the execution environment, to name
    just a few examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我更喜欢静态分析方法。我通常一行一行地阅读目标软件的源代码或反汇编，并试图理解它。然而，从头到尾阅读所有代码通常并不实用。当我寻找bug时，我通常首先尝试确定用户影响的输入数据是如何通过外部世界的接口进入软件的。这可能是网络数据、文件数据或执行环境中的数据，仅举几个例子。
- en: Next, I study the different ways that the input data can travel through the
    software, while looking for any potentially exploitable code that acts on the
    data. Sometimes I’m able to identify these entry points solely by reading the
    source code (see [Chapter 2](ch02.html "Chapter 2. Back to the ’90s")) or the
    disassembly (see [Chapter 6](ch06.html "Chapter 6. One Kernel to Rule Them All")).
    In other cases, I have to combine static analysis with the results of debugging
    the target software (see [Chapter 5](ch05.html "Chapter 5. Browse and You’re Owned"))
    to find the input-handling code. I also tend to combine static and dynamic approaches
    when developing an exploit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我研究输入数据在软件中传递的不同方式，同时寻找对数据进行操作的任何可能可利用的代码。有时我能够仅通过阅读源代码（见[第2章](ch02.html
    "第2章. 回到90年代"））或反汇编（见[第6章](ch06.html "第6章. 一个内核统治一切"））来识别这些入口点。在其他情况下，我必须将静态分析与调试目标软件的结果（见[第5章](ch05.html
    "第5章. 浏览并拥有"））结合起来，以找到处理输入的代码。在开发漏洞利用时，我也倾向于结合静态和动态方法。
- en: After I’ve found a bug, I want to prove if it’s actually exploitable, so I attempt
    to build an exploit for it. When I build such an exploit, I spend most of my time
    in the debugger.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我发现bug之后，我想证明它是否真的可利用，所以我尝试为其构建一个漏洞利用程序。当我构建这样的漏洞利用程序时，我大部分时间都在调试器中度过。
- en: Potentially Vulnerable Code Locations
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能存在漏洞的代码位置
- en: This is only one approach to bug hunting. Another tactic for finding potentially
    vulnerable locations in the code is to look at the code near “unsafe” C/C++ library
    functions, such as `strcpy()` and `strcat()`, in search of possible buffer overflows.
    Alternatively, you could search the disassembly for `movsx` assembler instructions
    in order to find sign-extension vulnerabilities. If you find a potentially vulnerable
    code location, you can then trace backward through the code to see whether these
    code fragments expose any vulnerabilities accessible from an application entry
    point. I rarely use this approach, but other bug hunters swear by it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是寻找bug的一种方法。另一种寻找代码中可能存在漏洞位置的策略是查看靠近“不安全”的C/C++库函数的代码，例如`strcpy()`和`strcat()`，以寻找可能的缓冲区溢出。或者，你也可以在反汇编中搜索`movsx`汇编指令，以找到符号扩展漏洞。如果你发现了一个可能存在漏洞的代码位置，你可以通过回溯代码来查看这些代码片段是否暴露了任何从应用程序入口点可访问的漏洞。我很少使用这种方法，但其他bug猎人对此深信不疑。
- en: Fuzzing
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊测试
- en: A completely different approach to bug hunting is known as *fuzzing*. Fuzzing
    is a dynamic-analysis technique that consists of testing an application by providing
    it with malformed or unexpected input. Though I’m not an expert in fuzzing and
    fuzzing frameworks—I know bug hunters who have developed their own fuzzing frameworks
    and find most of their bugs with their fuzzing tools—I do use this approach from
    time to time to determine where user-influenced input enters the software and
    sometimes to find bugs (see [Chapter 8](ch08.html "Chapter 8. The Ringtone Massacre")).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一种被称为 *模糊测试* 的完全不同的漏洞搜索方法。模糊测试是一种动态分析技术，它通过向应用程序提供格式错误或意外的输入来测试应用程序。虽然我不是模糊测试和模糊测试框架的专家——我知道一些漏洞搜索者开发了他们自己的模糊测试框架，并使用他们的模糊测试工具找到了大部分漏洞——但我有时会使用这种方法来确定用户影响的输入何时进入软件，有时也会用它来寻找漏洞（见第
    8 章[第 8 章。铃声大屠杀](ch08.html "第 8 章。铃声大屠杀")）。
- en: You may be wondering how fuzzing can be used to identify where user-influenced
    input enters the software. Imagine you have a complex application in the form
    of a binary that you want to examine for bugs. It isn’t easy to identify the entry
    points of such complex applications, but complex software often tends to crash
    while processing malformed input data. This can hold true for software that parses
    data files, such as office products, media players, or web browsers. Most of these
    crashes are not security relevant (e.g., a division-by-zero bug in a browser),
    but they often provide an entry point where I can start looking for user-influenced
    input data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何使用模糊测试来识别用户影响的输入何时进入软件。想象一下，你有一个以二进制形式存在的复杂应用程序，你想检查其中的漏洞。识别这种复杂应用程序的入口点并不容易，但复杂的软件在处理格式错误的输入数据时往往会崩溃。这对于解析数据文件的软件（如办公产品、媒体播放器或网络浏览器）来说同样适用。大多数这些崩溃与安全无关（例如，浏览器中的除以零错误），但它们通常提供了一个我可以开始寻找用户影响的输入数据的入口点。
- en: Further Reading
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These are only a few of the available techniques and approaches that can be
    used to find bugs in software. For more information on finding security vulnerabilities
    in source code, I recommend Mark Dowd, John McDonald, and Justin Schuh’s *The
    Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities*
    (Addison-Wesley, 2007). If you want more information about fuzzing, see Michael
    Sutton, Adam Greene, and Pedram Amini’s *Fuzzing: Brute Force Vulnerability Discovery*
    (Addison-Wesley, 2007).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是可用于在软件中查找错误的技术和方法的少数几个。有关在源代码中查找安全漏洞的更多信息，我推荐 Mark Dowd、John McDonald 和
    Justin Schuh 的 *软件安全评估艺术：识别和预防软件漏洞*（Addison-Wesley，2007）。如果你想了解更多关于模糊测试的信息，请参阅
    Michael Sutton、Adam Greene 和 Pedram Amini 的 *模糊测试：暴力漏洞发现*（Addison-Wesley，2007）。
- en: 1.3 Memory Errors
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 内存错误
- en: 'The vulnerabilities described in this book have one thing in common: They all
    lead to exploitable memory errors. Such memory errors occur when a process, a
    thread, or the kernel is'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书描述的漏洞有一个共同点：它们都导致可利用的内存错误。这种内存错误发生在进程、线程或内核是
- en: Using memory it does not own (e.g., NULL pointer dereferences, as described
    in Section A.2)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用它不拥有的内存（例如，如第 A.2 节所述的空指针解引用）
- en: Using more memory than has been allocated (e.g., buffer overflows, as described
    in Section A.1)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比已分配的更多的内存（例如，如第 A.1 节所述的缓冲区溢出）
- en: Using uninitialized memory (e.g., uninitialized variables)^([[2](ch01s06.html#ftn.CHP-1-FN-2)])
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的内存（例如，未初始化的变量）^([[2](ch01s06.html#ftn.CHP-1-FN-2)])
- en: Using faulty heap-memory management (e.g., double frees)^([[3](ch01s06.html#ftn.CHP-1-FN-3)])
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有缺陷的堆内存管理（例如，双重释放）^([[3](ch01s06.html#ftn.CHP-1-FN-3)])
- en: Memory errors typically happen when powerful C/C++ features like explicit memory
    management or pointer arithmetic are used incorrectly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆错误通常发生在使用像显式内存管理或指针算术这样的强大 C/C++ 功能时使用不当。
- en: A subcategory of memory errors, called *memory corruption*, happens when a process,
    a thread, or the kernel modifies a memory location that it doesn’t own or when
    the modification corrupts the state of the memory location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一种被称为 *内存损坏* 的内存错误子类别发生在进程、线程或内核修改它不拥有的内存位置，或者当修改损坏了内存位置的状态时。
- en: If you’re not familiar with such memory errors, I suggest you have a look at
    Sections A.1, A.2, and A.3\. These sections describe the basics of the programming
    errors and vulnerabilities discussed in this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些内存错误不熟悉，我建议你查看 A.1、A.2 和 A.3 节。这些章节描述了本书中讨论的编程错误和漏洞的基本知识。
- en: In addition to exploitable memory errors, dozens of other vulnerability classes
    exist. These include logical errors and web-specific vulnerabilities like cross-site
    scripting, cross-site request forgery, and SQL injection, to name just a few.
    However, these other vulnerability classes are not the subject of this book. All
    the bugs discussed in this book were the result of exploitable memory errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可利用的内存错误之外，还存在数十种其他漏洞类别。这包括逻辑错误和特定于Web的漏洞，如跨站脚本、跨站请求伪造和SQL注入，仅举几例。然而，这些其他漏洞类别不是本书的主题。本书中讨论的所有漏洞都是可利用内存错误的结果。
- en: 1.4 Tools of the Trade
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 行业工具
- en: When searching for bugs, or building exploits to test them, I need a way to
    see inside the workings of applications. I most often use debuggers and disassemblers
    to gain that inside view.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找漏洞或构建用于测试它们的利用程序时，我需要一种方法来查看应用程序的工作原理。我通常使用调试器和反汇编器来获得这种内部视角。
- en: Debuggers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器
- en: A debugger normally provides methods to attach to user space processes or the
    kernel, write and read values to and from registers and memory, and to control
    program flow using features such as breakpoints or single-stepping. Each operating
    system typically ships with its own debugger, but several third-party debuggers
    are available as well. [Table 1-1](ch01s04.html#debuggers_used_in_this_book "Table 1-1. Debuggers
    Used in This Book") lists the different operating system platforms and the debuggers
    used in this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器通常提供方法来附加到用户空间进程或内核，读写寄存器和内存中的值，并使用诸如断点或单步执行等特性来控制程序流程。每个操作系统通常都附带自己的调试器，但还有几个第三方调试器可供选择。[表1-1](ch01s04.html#debuggers_used_in_this_book
    "表1-1. 本书中使用的调试器")列出了不同的操作系统平台和本书中使用的调试器。
- en: Table 1-1. Debuggers Used in This Book
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-1. 本书中使用的调试器
- en: '| Operating system | Debugger | Kernel debugging |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 操作系统 | 调试器 | 内核调试 |'
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Microsoft | WinDbg (the official debugger from Microsoft) | yes |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft | WinDbg (来自微软的官方调试器) | yes |'
- en: '| Windows | OllyDbg and its variant Immunity Debugger | no |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Windows | OllyDbg and its variant Immunity Debugger | no |'
- en: '| Linux | The GNU Debugger (gdb) | yes |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Linux | The GNU Debugger (gdb) | yes |'
- en: '| Solaris | The Modular Debugger (mdb) | yes |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Solaris | The Modular Debugger (mdb) | yes |'
- en: '| Mac OS X | The GNU Debugger (gdb) | yes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Mac OS X | The GNU Debugger (gdb) | yes |'
- en: '| Apple iOS | The GNU Debugger (gdb) | yes |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Apple iOS | The GNU Debugger (gdb) | yes |'
- en: These debuggers will be used to identify, analyze and exploit the vulnerabilities
    that I discovered. See also Sections B.1, B.2, and B.4 for some debugger command
    cheat sheets.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调试器将被用来识别、分析和利用我所发现的漏洞。有关一些调试器命令速查表，请参阅B.1、B.2和B.4节。
- en: Disassemblers
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反汇编器
- en: If you want to audit an application and don’t have access to the source code,
    you can analyze the program binaries by reading the application’s assembly code.
    Although debuggers have the ability to disassemble the code of a process or the
    kernel, they usually are not especially easy or intuitive to work with. A program
    that fills this gap is the Interactive Disassembler Professional, better known
    as IDA Pro.^([[4](ch01s06.html#ftn.CHP-1-FN-4)]) IDA Pro supports more than 50
    families of processors and provides full interactivity, extensibility, and code
    graphing. If you want to audit a program binary, IDA Pro is a must-have. For an
    exhaustive treatment of IDA Pro and all of its features, consult Chris Eagle’s
    *The IDA Pro Book*, 2nd edition (No Starch Press, 2011).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想审计一个应用程序但没有访问源代码，你可以通过读取应用程序的汇编代码来分析程序的二进制文件。尽管调试器具有反汇编进程或内核代码的能力，但它们通常并不特别容易或直观地使用。填补这一空白的程序是交互式反汇编器专业版，也称为IDA
    Pro.^([[4](ch01s06.html#ftn.CHP-1-FN-4)]) IDA Pro支持超过50种处理器系列，并提供完全交互性、可扩展性和代码图形化。如果你想审计程序二进制文件，IDA
    Pro是必备的。有关IDA Pro及其所有功能的详尽介绍，请参阅Chris Eagle的*IDA Pro书籍*，第2版（No Starch Press，2011年）。
- en: 1.5 EIP = 41414141
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 EIP = 41414141
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Instruction pointer/Program counter:*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令指针/程序计数器：*'
- en: '*EIP—32-bit instruction pointer (IA-32)*'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EIP—32位指令指针 (IA-32)*'
- en: '*RIP—64-bit instruction pointer (Intel 64)*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RIP—64位指令指针 (Intel 64)*'
- en: '*R15 or PC—ARM architecture as used on Apple’s iPhone*'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R15或PC—苹果iPhone上使用的ARM架构*'
- en: To illustrate the security implications of the bugs that I found, I will discuss
    the steps needed to gain control of the execution flow of the vulnerable program
    by controlling the instruction pointer (IP) of the CPU. The instruction pointer
    or program counter (PC) register contains the offset in the current code segment
    for the next instruction to be executed.^([[5](ch01s06.html#ftn.CHP-1-FN-5)])
    If you gain control of this register, you fully control the execution flow of
    the vulnerable process. To demonstrate instruction pointer control, I will modify
    the register to values like `0x41414141` (hexadecimal representation of ASCII
    “`AAAA`”), `0x41424344` (hexadecimal representation of ASCII “`ABCD`”), or something
    similar. So if you see `EIP = 41414141` in the following chapters, it means that
    I’ve gained control of the vulnerable process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我所发现的漏洞的安全影响，我将讨论通过控制CPU的指令指针（IP）来获取受漏洞程序执行流程控制所需的步骤。指令指针或程序计数器（PC）寄存器包含下一个要执行的指令在当前代码段中的偏移量.^([[5](ch01s06.html#ftn.CHP-1-FN-5)])
    如果你控制了这个寄存器，你就完全控制了受漏洞过程执行流程。为了演示指令指针控制，我将修改寄存器的值为`0x41414141`（ASCII字符“AAAA”的十六进制表示），`0x41424344`（ASCII字符“ABCD”的十六进制表示），或类似值。所以如果你在以下章节中看到`EIP
    = 41414141`，这意味着我已经控制了受漏洞程序。
- en: 'Once you achieve control over the instruction pointer, there are many ways
    to turn it into a fully working, weaponized exploit. For more information on the
    process of exploit development, you can refer to Jon Erickson’s *Hacking: The
    Art of Exploitation*, 2nd edition (No Starch Press, 2008), or you can type *exploit
    writing* into Google and browse through the enormous amount of material available
    online.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了指令指针的控制权，就有许多方法可以将它转变为一个完全工作、武器化的漏洞利用。有关漏洞开发过程的信息，你可以参考乔恩·埃里克森的《黑客：漏洞利用的艺术》，第2版（No
    Starch Press，2008年），或者你可以在Google中输入“exploit writing”并浏览在线上可用的大量材料。
- en: 1.6 Final Note
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 最后的注意事项
- en: We’ve covered a lot of ground in this chapter, and you might be left with a
    lot of questions. Don’t worry—that’s a fine place to be. The following seven diary
    chapters delve into more detail on the topics introduced here and will answer
    many of your questions. You can also read through the appendixes for background
    information on various topics discussed throughout this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了大量的内容，你可能会有很多疑问。不用担心——这是一个很好的位置。接下来的七个日记章节将更深入地探讨这里介绍的主题，并回答你许多问题。你还可以阅读附录，以获取本书中讨论的各种主题的背景信息。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The diary chapters are not in chronological order. They’re arranged according
    to the subject matter so that the concepts build on one another.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 日记章节并非按时间顺序排列。它们是根据主题内容进行编排的，以便概念相互关联。
- en: Notes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备注
- en: ^([[1](#ftn.CHP-1-FN-1)])
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#ftn.CHP-1-FN-1)])
- en: ^([[2](#ftn.CHP-1-FN-2)])
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#ftn.CHP-1-FN-2)])
- en: ^([[3](#ftn.CHP-1-FN-3)])
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#ftn.CHP-1-FN-3)])
- en: ^([[4](#ftn.CHP-1-FN-4)])
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#ftn.CHP-1-FN-4)])
- en: ^([[5](#ftn.CHP-1-FN-5)])
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#ftn.CHP-1-FN-5)])
- en: '* * *'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[1](#CHP-1-FN-1)]) See Pedram Amini, “Mostrame la guita! Adventures in Buying
    Vulnerabilities,” 2009, [http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr](http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr);
    Charlie Miller, “The Legitimate Vulnerability Market: Inside the Secretive World
    of 0-day Exploit Sales,” 2007, [http://weis2007.econinfosec.org/papers/29.pdf](http://weis2007.econinfosec.org/papers/29.pdf);
    iDefense Labs Vulnerability Contribution Program, [https://labs.idefense.com/vcpportal/login.html](https://labs.idefense.com/vcpportal/login.html);
    TippingPoint’s Zero Day Initiative, [http://www.zerodayinitiative.com/](http://www.zerodayinitiative.com/).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[1](#CHP-1-FN-1)]) 请参阅佩德拉姆·阿米尼的“Mostrame la guita! Adventures in Buying
    Vulnerabilities，”2009年，[http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr](http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr)；查理·米勒的“The
    Legitimate Vulnerability Market: Inside the Secretive World of 0-day Exploit Sales，”2007年，[http://weis2007.econinfosec.org/papers/29.pdf](http://weis2007.econinfosec.org/papers/29.pdf)；iDefense
    Labs Vulnerability Contribution Program，[https://labs.idefense.com/vcpportal/login.html](https://labs.idefense.com/vcpportal/login.html)；TippingPoint的Zero
    Day Initiative，[http://www.zerodayinitiative.com/](http://www.zerodayinitiative.com/).'
- en: '^([[2](#CHP-1-FN-2)]) See Daniel Hodson, “Uninitialized Variables: Finding,
    Exploiting, Automating” (presentation, Ruxcon, 2008), [http://felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf](http://felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-1-FN-2)]) 请参阅丹尼尔·霍德森的“未初始化变量：查找、利用、自动化”（演示文稿，Ruxcon，2008），[http://felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf](http://felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf).
- en: '^([[3](#CHP-1-FN-3)]) See Common Weakness Enumeration, CWE List, CWE - Individual
    Dictionary Definition (2.0), CWE-415: Double Free at [http://cwe.mitre.org/data/definitions/415.html](http://cwe.mitre.org/data/definitions/415.html).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[3](#CHP-1-FN-3)]) 请参阅通用弱点枚举，CWE 列表，CWE - 单个字典定义（2.0），CWE-415: Double Free，网址为
    [http://cwe.mitre.org/data/definitions/415.html](http://cwe.mitre.org/data/definitions/415.html).'
- en: ^([[4](#CHP-1-FN-4)]) See [http://www.hex-rays.com/idapro/](http://www.hex-rays.com/idapro/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-1-FN-4)]) 请参阅 [http://www.hex-rays.com/idapro/](http://www.hex-rays.com/idapro/).
- en: '^([[5](#CHP-1-FN-5)]) See *Intel® 64 and IA-32 Architectures Software Developer’s
    Manual, Volume 1: Basic Architecture* at [http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-1-FN-5)]) 请参阅 *Intel® 64 和 IA-32 架构软件开发者手册，第一卷：基本架构*，网址为 [http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/).
