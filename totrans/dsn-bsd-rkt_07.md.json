["```\n#include <fcntl.h>\n#include <kvm.h>\n#include <limits.h>\n#include <nlist.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/sysent.h>\n\nvoid usage();\n\nint\nmain(int argc, char *argv[])\n{\n        char errbuf[_POSIX2_LINE_MAX];\n        kvm_t *kd;\n        struct nlist nl[] = { { NULL }, { NULL }, { NULL }, };\n\n        unsigned long addr;\n        int callnum;\n        struct sysent call;\n\n        /* Check arguments. */\n        if (argc < 3) {\n                usage();\n                exit(-1);\n        }\n\n        nl[0].n_name = \"sysent\";\n        nl[1].n_name = argv[1];\n        callnum = (int)strtol(argv[2], (char **)NULL, 10);\n\n        printf(\"Checking system call %d: %s\\n\\n\", callnum, argv[1]);\n\n        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);\n        if (!kd) {\n                fprintf(stderr, \"ERROR: %s\\n\", errbuf);\n                exit(-1);\n        }\n\n        /* Find the address of sysent[] and argv[1]. */\n        if (❶kvm_nlist(kd, nl) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        if (nl[0].n_value)\n                printf(\"%s[] is 0x%x at 0x%lx\\n\", nl[0].n_name, nl[0].n_type,\n                    nl[0].n_value);\n        else {\n                fprintf(stderr, \"ERROR: %s not found (very weird...)\\n\",\n                    nl[0].n_name);\n                exit(-1);\n        }\n\n        if (!nl[1].n_value) {\n                fprintf(stderr, \"ERROR: %s not found\\n\", nl[1].n_name);\n                exit(-1);\n        }\n\n        /* Determine the address of sysent[callnum]. */\n        addr = nl[0].n_value + callnum * sizeof(struct sysent);\n\n        /* Copy sysent[callnum]. */\n        if (❷kvm_read(kd, addr, &call, sizeof(struct sysent)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Where does sysent[callnum].sy_call point to? */\n        printf(\"sysent[%d] is at 0x%lx and its sy_call member points to \"\n            \"%p\\n\", callnum, addr, call.sy_call);\n\n        /* Check if that's correct. */\n        ❸if ((uintptr_t)call.sy_call != nl[1].n_value) {\n                printf(\"ALERT! It should point to 0x%lx instead\\n\",\n                    nl[1].n_value);\n\n                /* Should this be fixed? */\n                if (argv[3] && strncmp(argv[3], \"fix\", 3) == 0) {\n                        printf(\"Fixing it... \");\n\n                        ❹call.sy_call =(sy_call_t *)(uintptr_t)nl[1].n_value;\n                        if (kvm_write(kd, addr, &call, sizeof(struct sysent))\n                            < 0) {\n\n                                fprintf(stderr,\"ERROR: %s\\n\",kvm_geterr(kd));\n                                exit(-1);\n                        }\n\n                        printf(\"Done.\\n\");\n                }\n        }\n\n        if (kvm_close(kd) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        exit(0);\n}\n\nvoid\nusage()\n{\n        fprintf(stderr,\"Usage:\\ncheckcall [system call function] \"\n            \"[call number] <fix>\\n\\n\");\n        fprintf(stderr, \"For a list of system call numbers see \"\n            \"/sys/sys/syscall.h\\n\");\n}\n\n```", "```\n$ `sudo kldload ./mkdir_hook.ko`\n$ `mkdir 1`\nThe directory \"1\" will be created with the following permissions: 777\n$ `sudo ./checkcall mkdir 136 fix`\nChecking system call 136: mkdir\n\nsysent[] is 0x4 at 0xc08bdf60\nsysent[136] is at 0xc08be5c0 and its sy_call member points to 0xc1eb8470\nALERT! It should point to 0xc0696354 instead\nFixing it... Done.\n$ `mkdir 2`\n$ `ls -l`\n. . .\ndrwxr-xr-x  2 ghost  ghost   512 Mar 23 14:12 1\ndrwxr-xr-x  2 ghost  ghost   512 Mar 23 14:15 2\n\n```", "```\n$ `nm /boot/kernel/kernel | grep mi_switch`\nc063e7dc T mi_switch\n$ `objdump -d --start-address=0xc063e7dc /boot/kernel/kernel`\n/boot/kernel/kernel:     file format elf32-i386-freebsd\n\nDisassembly of section .text:\n\nc063e7dc <mi_switch>:\nc063e7dc:       55                      push   %ebp\nc063e7dd:       89 e5                   mov    %esp,%ebp\nc063e7df:       57                      push   %edi\nc063e7e0:       56                      push   %esi\nc063e7e1:       53                      push   %ebx\nc063e7e2:       83 ec 30                sub    $0x30,%esp\nc063e7e5:       64 a1 00 00 00 00       mov    ❶%fs:0x0,%eax\nc063e7eb:       89 45 d0                mov    %eax,0xffffffd0(%ebp)\nc063e7ee:       8b 38                   mov    (%eax),%edi\n. . .\n\n```"]