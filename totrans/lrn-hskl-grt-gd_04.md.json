["```\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"maximum of empty list!\"\nmaximum' [x] = x\nmaximum' (x:xs) = max x (maximum' xs)\n```", "```\nreplicate' :: Int -> a -> [a]\nreplicate' n x\n    | n <= 0    = []\n    | otherwise = x : replicate' (n-1) x\n```", "```\ntake' :: (Num i, Ord i) => i -> [a] -> [a]\ntake' n _\n    | n <= 0   = []\ntake' _ []     = []\ntake' n (x:xs) = x : take' (n-1) xs\n```", "```\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n```", "```\nrepeat' :: a -> [a]\nrepeat' x = x:repeat' x\n```", "```\nzip' :: [a] -> [b] -> [(a,b)]\nzip' _ [] = []\nzip' [] _ = []\nzip' (x:xs) (y:ys) = (x,y):zip' xs ys\n```", "```\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs)\n    | a == x    = True\n    | otherwise = a `elem'` xs\n```", "```\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n    let smallerOrEqual = [a | a <- xs, a <= x]\n        larger = [a | a <- xs, a > x]\n    in  quicksort smallerOrEqual ++ [x] ++ quicksort larger\n```", "```\nghci> quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]\n[1,2,2,3,3,4,4,5,6,7,8,9,10]\nghci> quicksort \"the quick brown fox jumps over the lazy dog\"\n\"        abcdeeefghhijklmnoooopqrrsttuuvwxyz\"\n```"]