<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Storage Drivers"><div class="titlepage"><div><div><h1 class="title"><a id="storage_drivers"/>Chapter 13. Storage Drivers</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id13"/><div class="mediaobject"><a id="I_mediaobject13_d1e22709"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>In FreeBSD, <span class="emphasis"><em>storage drivers</em></span> provide access to devices that transfer randomly accessible data in blocks (such as disk drives, flash memory, and so on). A <span class="emphasis"><em>block</em></span> is a fixed-size chunk of data (Corbet et al., 2005). In this chapter I’ll discuss how to manage devices that employ block-centric I/O. To that end, some familiarity with disk and bio structures is needed, so that is where we’ll start.<a class="indexterm" id="IDX-CHP-13-0001"/></p><div class="sect1" title="disk Structures"><div class="titlepage"><div><div><h1 class="title"><a id="disk_structures"/>disk Structures</h1></div></div></div><p>A <code class="literal">disk</code> structure is the kernel’s representation of an individual disk-like storage device. It is defined in the <code class="literal">&lt;geom/geom_disk.h&gt;</code> header as follows:</p><a id="I_programlisting13_d1e22736"/><pre class="programlisting">struct disk {
        /* GEOM Private Data */
        struct g_geom          *d_geom;
        struct devstat         *d_devstat;
        int                     d_destroyed;

        /* Shared Objects */
        struct bio_queue_head  *d_queue;
        struct mtx             *d_lock;

        /* Descriptive Fields */
        const char             *d_name;
        u_int                   d_unit;
        u_int                   d_flags;

        /* Storage Device Methods */
        disk_open_t            *d_open;
        disk_close_t           *d_close;
        disk_strategy_t        *d_strategy;
        disk_ioctl_t           *d_ioctl;
        dumper_t               *d_dump;

        /* Mandatory Media Properties */
        u_int                   d_sectorsize;
        off_t                   d_mediasize;
        u_int                   d_maxsize;

        /* Optional Media Properties */
        u_int                   d_fwsectors;
        u_int                   d_fwheads;
        u_int                   d_stripesize;
        u_int                   d_stripeoffset;
        char                    d_ident[DISK_IDENT_SIZE];

        /* Driver Private Data */
        void                   *d_drv1;
};</pre><p>Many of the fields in <code class="literal">struct disk</code> must be initialized by a storage driver. These fields are described in the following sections.<a class="indexterm" id="IDX-CHP-13-0002"/><a class="indexterm" id="IDX-CHP-13-0003"/><a class="indexterm" id="IDX-CHP-13-0004"/><a class="indexterm" id="IDX-CHP-13-0005"/><a class="indexterm" id="IDX-CHP-13-0006"/><a class="indexterm" id="IDX-CHP-13-0007"/><a class="indexterm" id="IDX-CHP-13-0008"/><a class="indexterm" id="IDX-CHP-13-0009"/><a class="indexterm" id="IDX-CHP-13-0010"/></p><div class="sect2" title="Descriptive Fields"><div class="titlepage"><div><div><h2 class="title"><a id="descriptive_fields"/>Descriptive Fields</h2></div></div></div><p>The <code class="literal">d_name</code> and <code class="literal">d_unit</code> fields specify the storage device’s name and unit number, respectively. These fields must be defined in every <code class="literal">disk</code> structure.</p><p>The <code class="literal">d_flags</code> field further qualifies the storage device’s characteristics. Valid values for this field are shown in <a class="xref" href="ch13.html#disk_structure_symbolic_constants" title="Table 13-1. disk Structure Symbolic Constants">Table 13-1</a>.</p><div class="table"><a id="disk_structure_symbolic_constants"/><p class="title">Table 13-1. disk Structure Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="disk Structure Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">DISKFLAG_NEEDSGIANT</code></p></td><td style="text-align: left" valign="top"><p>Indicates that the storage device needs to be protected by <code class="literal">Giant</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DISKFLAG_CANDELETE</code></p></td><td style="text-align: left" valign="top"><p>Indicates that the storage device wants to be notified when a block is no longer required so that it can perform some special handling (for example, drivers for solid-state drives that support the <code class="literal">TRIM</code> command employ this flag)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DISKFLAG_CANFLUSHCACHE</code></p></td><td style="text-align: left" valign="top"><p>Indicates that the storage device can flush its local write cache</p></td></tr></tbody></table></div></div><p>The <code class="literal">d_flags</code> field is optional and may be undefined.<a class="indexterm" id="IDX-CHP-13-0011"/><a class="indexterm" id="IDX-CHP-13-0012"/><a class="indexterm" id="IDX-CHP-13-0013"/><a class="indexterm" id="IDX-CHP-13-0014"/><a class="indexterm" id="IDX-CHP-13-0015"/><a class="indexterm" id="IDX-CHP-13-0016"/><a class="indexterm" id="IDX-CHP-13-0017"/><a class="indexterm" id="IDX-CHP-13-0018"/><a class="indexterm" id="IDX-CHP-13-0019"/><a class="indexterm" id="IDX-CHP-13-0020"/><a class="indexterm" id="IDX-CHP-13-0021"/><a class="indexterm" id="IDX-CHP-13-0022"/><a class="indexterm" id="IDX-CHP-13-0023"/><a class="indexterm" id="IDX-CHP-13-0024"/><a class="indexterm" id="IDX-CHP-13-0025"/><a class="indexterm" id="IDX-CHP-13-0026"/><a class="indexterm" id="IDX-CHP-13-0027"/><a class="indexterm" id="IDX-CHP-13-0028"/><a class="indexterm" id="IDX-CHP-13-0029"/><a class="indexterm" id="IDX-CHP-13-0030"/><a class="indexterm" id="IDX-CHP-13-0031"/><a class="indexterm" id="IDX-CHP-13-0032"/><a class="indexterm" id="IDX-CHP-13-0033"/><a class="indexterm" id="IDX-CHP-13-0034"/></p></div><div class="sect2" title="Storage Device Methods"><div class="titlepage"><div><div><h2 class="title"><a id="storage_device_methods"/>Storage Device Methods</h2></div></div></div><p>The <code class="literal">d_open</code> field identifies the storage device’s open routine. If no function is provided, open will always succeed.</p><p>The <code class="literal">d_close</code> field identifies the storage device’s close routine. If no function is provided, close will always succeed. The <code class="literal">d_close</code> routine should always terminate anything set up by the <code class="literal">d_open</code> routine.</p><p>The <code class="literal">d_strategy</code> field identifies the storage device’s strategy routine. <span class="emphasis"><em>Strategy routines</em></span> are called to process block-centric reads, writes, and other I/O operations. Accordingly, <code class="literal">d_strategy</code> must be defined in every <code class="literal">disk</code> structure. I’ll discuss block-centric I/O and strategy routines in greater detail later.<a class="indexterm" id="IDX-CHP-13-0035"/></p><p>The <code class="literal">d_ioctl</code> field identifies the storage device’s ioctl routine. This field is optional and may be undefined.</p><p>The <code class="literal">d_dump</code> field identifies the storage device’s dump routine. <span class="emphasis"><em>Dump routines</em></span> are called after a kernel panic to record the contents of physical memory to a storage device. Note that <code class="literal">d_dump</code> is optional and may be undefined.<a class="indexterm" id="IDX-CHP-13-0036"/></p></div><div class="sect2" title="Mandatory Media Properties"><div class="titlepage"><div><div><h2 class="title"><a id="mandatory_media_properties"/>Mandatory Media Properties</h2></div></div></div><p>The <code class="literal">d_sectorsize</code> and <code class="literal">d_mediasize</code> fields specify the storage device’s sector and media size in bytes, respectively. These fields must be defined in every <code class="literal">disk</code> structure.</p><p>The <code class="literal">d_maxsize</code> field denotes the maximum size in bytes that an I/O operation, for the storage device, can be. This field must be defined in every <code class="literal">disk</code> structure.</p><p>Note that you can safely modify the values for <code class="literal">d_sectorsize</code>, <code class="literal">d_mediasize</code>, and <code class="literal">d_maxsize</code> in the <code class="literal">d_open</code> routine.</p></div><div class="sect2" title="Optional Media Properties"><div class="titlepage"><div><div><h2 class="title"><a id="optional_media_properties"/>Optional Media Properties</h2></div></div></div><p>The <code class="literal">d_fwsectors</code> and <code class="literal">d_fwheads</code> fields identify the number of sectors and heads on the storage device. These fields are optional and may be undefined; however, certain platforms require these fields for disk partitioning.</p><p>The <code class="literal">d_stripesize</code> field specifies the width of any natural request boundaries for the storage device (for example, the size of a stripe on a RAID-5 unit), and the <code class="literal">d_stripeoffset</code> field represents the location or offset to the first stripe. These fields are optional and may be undefined. For more on <code class="literal">d_stripesize</code> and <code class="literal">d_stripeoffset</code>, see <span class="emphasis"><em>/sys/geom/notes</em></span>.</p><p>The <code class="literal">d_ident</code> field denotes the storage device’s serial number. This field is optional and may be undefined, but it’s good practice to define it.</p><p>Note that you can safely modify the abovementioned fields in the <code class="literal">d_open</code> routine.</p></div><div class="sect2" title="Driver Private Data"><div class="titlepage"><div><div><h2 class="title"><a id="driver_private_data"/>Driver Private Data</h2></div></div></div><p>The <code class="literal">d_drv1</code> field may be used by the storage driver to house data. Typically, <code class="literal">d_drv1</code> will contain a pointer to the storage driver’s <code class="literal">softc</code> structure.<a class="indexterm" id="IDX-CHP-13-0037"/><a class="indexterm" id="IDX-CHP-13-0038"/><a class="indexterm" id="IDX-CHP-13-0039"/><a class="indexterm" id="IDX-CHP-13-0040"/><a class="indexterm" id="IDX-CHP-13-0041"/><a class="indexterm" id="IDX-CHP-13-0042"/><a class="indexterm" id="IDX-CHP-13-0043"/><a class="indexterm" id="IDX-CHP-13-0044"/><a class="indexterm" id="IDX-CHP-13-0045"/><a class="indexterm" id="IDX-CHP-13-0046"/></p></div></div></div>
<div class="sect1" title="disk Structure Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="disk_structure_management_routines"/>disk Structure Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following functions for working with <code class="literal">disk</code> structures:</p><a id="I_programlisting13_d1e23143"/><pre class="programlisting">#include &lt;geom/geom_disk.h&gt;

struct disk *
disk_alloc(void);

void
disk_create(struct disk *disk, int version);

void
disk_destroy(struct disk *disk);</pre><p>A <code class="literal">disk</code> structure is a dynamically allocated structure that’s owned by the kernel. That is, you cannot allocate a <code class="literal">struct disk</code> on your own. Instead, you must call <code class="literal">disk_alloc</code>.</p><p>Allocating a <code class="literal">disk</code> structure does not make the storage device available to the system. To do that, you must initialize the structure (by defining the necessary fields) and then call <code class="literal">disk_create</code>. The <code class="literal">version</code> argument must always be <code class="literal">DISK_VERSION</code>.</p><p>Note that as soon as <code class="literal">disk_create</code> returns, the device is “live” and its routines can be called at any time. Therefore, you should call <code class="literal">disk_create</code> only when your driver is completely ready to handle any operation.</p><p>When a <code class="literal">disk</code> structure is no longer needed, it should be freed with <code class="literal">disk_destroy</code>. You can destroy an opened <code class="literal">disk</code> structure. Of course, you’ll need to free any resources that were allocated during <code class="literal">d_open</code> afterward, as <code class="literal">d_close</code> can no longer be called.</p></div>
<div class="sect1" title="Block I/O Structures"><div class="titlepage"><div><div><h1 class="title"><a id="block_i_solidus_o_structures"/>Block I/O Structures</h1></div></div></div><p>A <code class="literal">bio</code> structure represents a block-centric I/O request. Loosely speaking, when the kernel needs to transfer some data to or from a storage device, it puts together a <code class="literal">bio</code> structure to describe that operation; then it passes that structure to the appropriate driver.</p><p><code class="literal">struct bio</code> is defined in the <code class="literal">&lt;sys/bio.h&gt;</code> header as follows:</p><a id="I_programlisting13_d1e23213"/><pre class="programlisting">struct bio {
        uint8_t bio_cmd;                /* I/O operation.               */
        uint8_t bio_flags;              /* General flags.               */
        uint8_t bio_cflags;             /* Private use by the consumer. */
        uint8_t bio_pflags;             /* Private use by the provider. */

        struct cdev *bio_dev;           /* Device to perform I/O on.    */
        struct disk *bio_disk;          /* Disk structure.              */
        off_t   bio_offset;             /* Requested position in file.  */
        long    bio_bcount;             /* Number of (valid) bytes.     */
        caddr_t bio_data;               /* Data.                        */
        int     bio_error;              /* Error number for BIO_ERROR.  */
        long    bio_resid;              /* Remaining I/O (in bytes).    */
        void (*bio_done)(struct bio *); /* biodone() handler function.  */

        void    *bio_driver1;           /* Private use by the provider. */
        void    *bio_driver2;           /* Private use by the provider. */
        void    *bio_caller1;           /* Private use by the consumer. */
        void    *bio_caller2;           /* Private use by the consumer. */

        TAILQ_ENTRY(bio) bio_queue;     /* bioq linkage.                */
        const char *bio_attribute;      /* For BIO_[GS]ETATTR.          */
        struct g_consumer *bio_from;    /* GEOM linkage.                */
        struct g_provider *bio_to;      /* GEOM linkage.                */

        off_t   bio_length;             /* Like bio_bcount.             */
        off_t   bio_completed;          /* Opposite of bio_resid.       */
        u_int   bio_children;           /* Number of spawned bios.      */
        u_int   bio_inbed;              /* Number of children home.     */
        struct bio *bio_parent;         /* Parent pointer.              */
        struct bintime bio_t0;          /* Time I/O request started.    */

        bio_task_t *bio_task;   /* bio_taskqueue() handler function.    */
        void    *bio_task_arg;          /* bio_task's argument.         */
        void    *bio_classifier1;       /* Classifier tag.              */
        void    *bio_classifier2;       /* Classifier tag.              */

        daddr_t bio_pblkno;             /* Physical block number.       */
};

/* Bits for bio_cmd.    */
#define BIO_READ        0x01
#define BIO_WRITE       0x02
#define BIO_DELETE      0x04
#define BIO_GETATTR     0x08
#define BIO_FLUSH       0x10
#define BIO_CMD0        0x20            /* For local hacks.             */
#define BIO_CMD1        0x40            /* For local hacks.             */
#define BIO_CMD2        0x80            /* For local hacks.             */

/* Bits for bio_flags.  */
#define BIO_ERROR       0x01
#define BIO_DONE        0x02
#define BIO_ONQUEUE     0x04</pre><p>We’ll examine <code class="literal">struct bio</code> in greater detail later. In the interim, you just need to remember that strategy routines are called to process newly received <code class="literal">bio</code> structures.</p></div>
<div class="sect1" title="Block I/O Queues"><div class="titlepage"><div><div><h1 class="title"><a id="block_i_solidus_o_queues"/>Block I/O Queues</h1></div></div></div><p>All storage drivers maintain a <span class="emphasis"><em>block I/O queue</em></span> to house any pending block-centric I/O requests. Generally speaking, these requests are stored in increasing or decreasing device-offset order so that when they are processed, the disk head will move in a single direction (instead of bouncing around) to maximize performance.<a class="indexterm" id="IDX-CHP-13-0047"/><a class="indexterm" id="IDX-CHP-13-0048"/><a class="indexterm" id="IDX-CHP-13-0049"/></p><p>The FreeBSD kernel provides the following functions for working with block I/O queues:<a class="indexterm" id="IDX-CHP-13-0050"/><a class="indexterm" id="IDX-CHP-13-0051"/></p><a id="I_programlisting13_d1e23250"/><pre class="programlisting">#include &lt;sys/bio.h&gt;

void
bioq_init(struct bio_queue_head *head);

void
bioq_disksort(struct bio_queue_head *head, struct bio *bp);

struct bio *
bioq_first(struct bio_queue_head *head);

struct bio *
bioq_takefirst(struct bio_queue_head *head);

void
bioq_insert_head(struct bio_queue_head *head, struct bio *bp);

void
bioq_insert_tail(struct bio_queue_head *head, struct bio *bp);

void
bioq_remove(struct bio_queue_head *head, struct bio *bp);

void
bioq_flush(struct bio_queue_head *head, struct devstat *stp, int error);</pre><p>A block I/O queue is a statically allocated structure that’s owned by the driver. To initialize a block I/O queue, you must call <code class="literal">bioq_init</code>.</p><p>To perform an ordered insertion, call <code class="literal">bioq_disksort</code>. To return the head of the queue (that is, the next request to process), use <code class="literal">bioq_first</code>. Lastly, to return and remove the head of the queue, call <code class="literal">bioq_takefirst</code>.</p><p>The abovementioned functions are the main methods for managing a block I/O queue. If a queue is manipulated using only these functions, it will contain at most one inversion point (that is, two sorted sequences).</p><p>The <code class="literal">bioq_insert_head</code> function inserts a request at the head of the queue. Additionally, it creates a “barrier” so that all subsequent insertions performed using <code class="literal">bioq_disksort</code> will end up after this request.</p><p>The <code class="literal">bioq_insert_tail</code> function is similar to <code class="literal">bioq_insert_head</code>, but it inserts the request at the end of the queue. Note that <code class="literal">bioq_insert_tail</code> also creates a barrier.</p><p>Generally speaking, you’d utilize a barrier to ensure that all preceding requests are serviced before continuing.<a class="indexterm" id="IDX-CHP-13-0052"/><a class="indexterm" id="IDX-CHP-13-0053"/></p><p>The <code class="literal">bioq_remove</code> function removes a request from the queue. If <code class="literal">bioq_remove</code> is invoked on the head of the queue, its effect is identical to <code class="literal">bioq_takefirst</code>.</p><p>If a block I/O queue is manipulated using <code class="literal">bioq_insert_head</code>, <code class="literal">bioq_insert_tail</code>, or <code class="literal">bioq_remove</code>, it may contain multiple inversion points.</p><p>The <code class="literal">bioq_flush</code> function expunges all of the queued requests and causes them to return the error code <code class="literal">error</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>For storage devices that incorporate request scheduling (such as SATA Native Command Queuing, SCSI Tagged Command Queuing, and so on), <code class="literal">bioq_disksort</code> is essentially pointless, as the devices will (re)sort the requests internally. In those cases, a straightforward FIFO block I/O queue that uses <code class="literal">bioq_insert_tail</code> will suffice.</p></div></div>
<div class="sect1" title="Tying Everything Together"><div class="titlepage"><div><div><h1 class="title"><a id="tying_everything_together-id3"/>Tying Everything Together</h1></div></div></div><p>Now that you’ve gained some familiarity with <code class="literal">disk</code> and <code class="literal">bio</code> structures, let’s dissect a real-world storage driver.</p><p><a class="xref" href="ch13s05.html#at45d.c" title="Example 13-1. at45d.c">Example 13-1</a> is the storage driver for Atmel’s AT45D series of DataFlash chips. DataFlash is Atmel’s serial interface for flash memory, employed on the Serial Peripheral Interface (SPI) bus. In short, <a class="xref" href="ch13s05.html#at45d.c" title="Example 13-1. at45d.c">Example 13-1</a> is a storage driver for flash memory on the SPI bus.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Take a quick look at this code and try to discern some of its structure. If you don’t understand all of it, don’t worry; an explanation follows.</p></div><div class="example"><a id="at45d.c"/><p class="title">Example 13-1. at45d.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/bus.h&gt;
  #include &lt;sys/conf.h&gt;
  #include &lt;sys/bio.h&gt;
  #include &lt;sys/kthread.h&gt;
  #include &lt;sys/lock.h&gt;
  #include &lt;sys/mutex.h&gt;
  #include &lt;geom/geom_disk.h&gt;

  #include &lt;dev/spibus/spi.h&gt;
  #include "spibus_if.h"

  #define MANUFACTURER_ID                 0x9f
  #define STATUS_REGISTER_READ            0xd7
  #define CONTINUOUS_ARRAY_READ_HF        0x0b
  #define PROGRAM_THROUGH_BUFFER          0x82

  struct at45d_softc {
          device_t                        at45d_dev;
          struct mtx                      at45d_mtx;
          struct intr_config_hook         at45d_ich;
          struct disk                    *at45d_disk;
          struct bio_queue_head           at45d_bioq;
          struct proc                    *at45d_proc;
  };

  static devclass_t at45d_devclass;

  static void                             at45d_delayed_attach(void *);
  static void                             at45d_task(void *);
  static void                             at45d_strategy(struct bio *);

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> at45d_probe(device_t dev)
  {
          device_set_desc(dev, "AT45 flash family");
          return (BUS_PROBE_SPECIFIC);
  }

  static int
  at45d_attach(device_t dev)
  {
          struct at45d_softc *sc = device_get_softc(dev);
          int error;

          sc-&gt;at45d_dev = dev;
          mtx_init(&amp;sc-&gt;at45d_mtx, device_get_nameunit(dev), "at45d", MTX_DEF);

          sc-&gt;at45d_ich.ich_func = at45d_delayed_attach;
          sc-&gt;at45d_ich.ich_arg = sc;
          error = config_intrhook_establish(&amp;sc-&gt;at45d_ich);
          if (error)
                  device_printf(dev, "config_intrhook_establish() failed!\n");

          return (0);
  }

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/> at45d_detach(device_t dev)
  {
          return (EIO);
  }

  static int
  at45d_get_info(device_t dev, uint8_t *r)
  {
          struct spi_command cmd;
          uint8_t tx_buf[8], rx_buf[8];
          int error;

          memset(&amp;cmd, 0, sizeof(cmd));
          memset(tx_buf, 0, sizeof(tx_buf));
          memset(rx_buf, 0, sizeof(rx_buf));

          tx_buf[0] = MANUFACTURER_ID;
          cmd.tx_cmd = &amp;tx_buf[0];
          cmd.rx_cmd = &amp;rx_buf[0];
          cmd.tx_cmd_sz = 5;
          cmd.rx_cmd_sz = 5;
          error = SPIBUS_TRANSFER(device_get_parent(dev), dev, &amp;cmd);
          if (error)
                  return (error);

          memcpy(r, &amp;rx_buf[1], 4);
          return (0);
  }

  static uint8_t
  at45d_get_status(device_t dev)
  {
          struct spi_command cmd;
          uint8_t tx_buf[8], rx_buf[8];

          memset(&amp;cmd, 0, sizeof(cmd));
          memset(tx_buf, 0, sizeof(tx_buf));
          memset(rx_buf, 0, sizeof(rx_buf));

          tx_buf[0] = STATUS_REGISTER_READ;
          cmd.tx_cmd = &amp;tx_buf[0];
          cmd.rx_cmd = &amp;rx_buf[0];
          cmd.tx_cmd_sz = 2;
          cmd.rx_cmd_sz = 2;
          SPIBUS_TRANSFER(device_get_parent(dev), dev, &amp;cmd);

          return (rx_buf[1]);
  }

  static void
  at45d_wait_for_device_ready(device_t dev)
  {
          while ((at45d_get_status(dev) &amp; 0x80) == 0)
                  continue;
  }

  static void
  at45d_delayed_attach(void *arg)
  {
          struct at45d_softc *sc = arg;
          uint8_t buf[4];

          at45d_get_info(sc-&gt;at45d_dev, buf);
          at45d_wait_for_device_ready(sc-&gt;at45d_dev);

          sc-&gt;at45d_disk = disk_alloc();
          sc-&gt;at45d_disk-&gt;d_name = "at45d";
          sc-&gt;at45d_disk-&gt;d_unit = device_get_unit(sc-&gt;at45d_dev);
          sc-&gt;at45d_disk-&gt;d_strategy = at45d_strategy;
          sc-&gt;at45d_disk-&gt;d_sectorsize = 1056;
          sc-&gt;at45d_disk-&gt;d_mediasize = 8192 * 1056;
          sc-&gt;at45d_disk-&gt;d_maxsize = DFLTPHYS;
          sc-&gt;at45d_disk-&gt;d_drv1 = sc;

          bioq_init(&amp;sc-&gt;at45d_bioq);
          kproc_create(&amp;at45d_task, sc, &amp;sc-&gt;at45d_proc, 0, 0, "at45d");

          disk_create(sc-&gt;at45d_disk, DISK_VERSION);
          config_intrhook_disestablish(&amp;sc-&gt;at45d_ich);
  }

  static void
  at45d_strategy(struct bio *bp)
  {
          struct at45d_softc *sc = bp-&gt;bio_disk-&gt;d_drv1;

          mtx_lock(&amp;sc-&gt;at45d_mtx);
          bioq_disksort(&amp;sc-&gt;at45d_bioq, bp);
          wakeup(sc);
          mtx_unlock(&amp;sc-&gt;at45d_mtx);
  }

  static void
  at45d_task(void *arg)
  {
          struct at45d_softc *sc = arg;
          struct bio *bp;
          struct spi_command cmd;
          uint8_t tx_buf[8], rx_buf[8];
          int ss = sc-&gt;at45d_disk-&gt;d_sectorsize;
          daddr_t block, end;
          char *vaddr;

          for (;;) {
                  mtx_lock(&amp;sc-&gt;at45d_mtx);
                  do {
                          bp = bioq_first(&amp;sc-&gt;at45d_bioq);
                          if (bp == NULL)
                                  mtx_sleep(sc, &amp;sc-&gt;at45d_mtx, PRIBIO,
                                      "at45d", 0);
                  } while (bp == NULL);
                  bioq_remove(&amp;sc-&gt;at45d_bioq, bp);
                  mtx_unlock(&amp;sc-&gt;at45d_mtx);

                  end = bp-&gt;bio_pblkno + (bp-&gt;bio_bcount / ss);
                  for (block = bp-&gt;bio_pblkno; block &lt; end; block++) {
                          vaddr = bp-&gt;bio_data + (block - bp-&gt;bio_pblkno) * ss;
                          if (bp-&gt;bio_cmd == BIO_READ) {
                                  tx_buf[0] = CONTINUOUS_ARRAY_READ_HF;
                                  cmd.tx_cmd_sz = 5;
                                  cmd.rx_cmd_sz = 5;
                          } else {
                                  tx_buf[0] = PROGRAM_THROUGH_BUFFER;
                                  cmd.tx_cmd_sz = 4;
                                  cmd.rx_cmd_sz = 4;
                          }

                          /* FIXME: This works only on certain devices. */
                          tx_buf[1] = ((block &gt;&gt; 5) &amp; 0xff);
                          tx_buf[2] = ((block &lt;&lt; 3) &amp; 0xf8);
                          tx_buf[3] = 0;
                          tx_buf[4] = 0;
                          cmd.tx_cmd = &amp;tx_buf[0];
                          cmd.rx_cmd = &amp;rx_buf[0];
                          cmd.tx_data = vaddr;
                          cmd.rx_data = vaddr;
                          cmd.tx_data_sz = ss;
                          cmd.rx_data_sz = ss;
                          SPIBUS_TRANSFER(device_get_parent(sc-&gt;at45d_dev),
                              sc-&gt;at45d_dev, &amp;cmd);
                  }
                  biodone(bp);
          }
  }

  static device_method_t at45d_methods[] = {
          /* Device interface. */
          DEVMETHOD(device_probe,         at45d_probe),
          DEVMETHOD(device_attach,        at45d_attach),
          DEVMETHOD(device_detach,        at45d_detach),
          { 0, 0 }
  };

  static driver_t at45d_driver = {
          "at45d",
          at45d_methods,
          sizeof(struct at45d_softc)
  };

  DRIVER_MODULE(at45d, spibus, at45d_driver, at45d_devclass, 0, 0);</pre></div></div><p>The following sections describe the functions defined in <a class="xref" href="ch13s05.html#at45d.c" title="Example 13-1. at45d.c">Example 13-1</a> roughly in the order they would execute.<a class="indexterm" id="IDX-CHP-13-0054"/><a class="indexterm" id="IDX-CHP-13-0055"/><a class="indexterm" id="IDX-CHP-13-0056"/><a class="indexterm" id="IDX-CHP-13-0057"/><a class="indexterm" id="IDX-CHP-13-0058"/></p><p>Incidentally, because <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23402"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">at45d_probe</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23411"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">at45d_detach</code> are extremely rudimentary and because you’ve seen similar code elsewhere, I’ll omit discussing them.</p><div class="sect2" title="at45d_attach Function"><div class="titlepage"><div><div><h2 class="title"><a id="at45d_underscore_attach_function"/>at45d_attach Function</h2></div></div></div><p>The <code class="literal">at45d_attach</code> function is the <code class="literal">device_attach</code> implementation for this storage driver. Here is its function definition (again):</p><a id="I_programlisting13_d1e23431"/><pre class="programlisting">static int
at45d_attach(device_t dev)
{
        struct at45d_softc *sc = device_get_softc(dev);
        int error;

        sc-&gt;at45d_dev = dev;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>mtx_init(&amp;sc-&gt;at45d_mtx, device_get_nameunit(dev), "at45d",
            MTX_DEF);

        sc-&gt;at45d_ich.ich_func = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>at45d_delayed_attach;
        sc-&gt;at45d_ich.ich_arg = sc;
        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>config_intrhook_establish(&amp;sc-&gt;at45d_ich);
        if (error)
                device_printf(dev, "config_intrhook_establish() failed!\n");

        return (0);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23453"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> initializes the mutex <code class="literal">at45d_mtx</code>, which will protect <code class="literal">at45d</code>’s block I/O queue. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23465"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> schedules <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23471"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">at45d_delayed_attach</code> to execute when interrupts are enabled.<a class="indexterm" id="IDX-CHP-13-0059"/><a class="indexterm" id="IDX-CHP-13-0060"/><a class="indexterm" id="IDX-CHP-13-0061"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>During the initial autoconfiguration phase (that is, right after the system boots), interrupts are disabled. However, some drivers (such as <code class="literal">at45d</code>) require interrupts for device initialization. In those cases, you’d use <code class="literal">config_intrhook_establish</code>, which schedules a function to execute as soon as interrupts are enabled but before root is mounted; if the system has already passed this point, the function is called immediately.</p></div></div><div class="sect2" title="at45d_delayed_attach Function"><div class="titlepage"><div><div><h2 class="title"><a id="at45d_underscore_delayed_underscore_atta"/>at45d_delayed_attach Function</h2></div></div></div><p>The <code class="literal">at45d_delayed_attach</code> function is, loosely speaking, the second half of <code class="literal">at45d_attach</code>. That is, it completes the device’s initialization. Here is its function definition (again):</p><a id="I_programlisting13_d1e23516"/><pre class="programlisting">static void
at45d_delayed_attach(void *arg)
{
        struct at45d_softc *sc = arg;
        uint8_t buf[4];

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>at45d_get_info(sc-&gt;at45d_dev, buf);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>at45d_wait_for_device_ready(sc-&gt;at45d_dev);

        sc-&gt;at45d_disk = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>disk_alloc();
        sc-&gt;at45d_disk-&gt;d_name = "at45d";
        sc-&gt;at45d_disk-&gt;d_unit = device_get_unit(sc-&gt;at45d_dev);
        sc-&gt;at45d_disk-&gt;d_strategy = at45d_strategy;
        sc-&gt;at45d_disk-&gt;d_sectorsize = 1056;
        sc-&gt;at45d_disk-&gt;d_mediasize = 8192 * 1056;
        sc-&gt;at45d_disk-&gt;d_maxsize = DFLTPHYS;
        sc-&gt;at45d_disk-&gt;d_drv1 = sc;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>bioq_init(&amp;sc-&gt;at45d_bioq);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>kproc_create(<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>&amp;at45d_task, sc, &amp;sc-&gt;at45d_proc, 0, 0, "at45d");

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>disk_create(sc-&gt;at45d_disk, DISK_VERSION);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>config_intrhook_disestablish(&amp;sc-&gt;at45d_ich);
}</pre><p>This function can be split into multiple parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23569"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> gets the device’s manufacturer ID. Then <code class="literal">at45d_delayed_attach</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23578"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> hangs until the device is ready. These two actions require interrupts to be enabled.<a class="indexterm" id="IDX-CHP-13-0062"/><a class="indexterm" id="IDX-CHP-13-0063"/><a class="indexterm" id="IDX-CHP-13-0064"/></p><p>The second part <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23601"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> allocates and defines <code class="literal">at45d</code>’s <code class="literal">disk</code> structure, <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23613"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> initializes <code class="literal">at45d</code>’s block I/O queue, and <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23623"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> creates a new kernel process (to execute the <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23629"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">at45d_task</code> function).</p><p>Finally, <code class="literal">at45d</code>’s device node is <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23643"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> created, and <code class="literal">at45d_delayed_attach</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23652"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> torn down.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>During the boot process—before root is mounted—the system stalls until every function scheduled via <code class="literal">config_intrhook_establish</code> completes and tears itself down. In other words, if <code class="literal">at45d_delayed_attach</code> didn’t call <code class="literal">config_intrhook_disestablish</code>, the system would hang.</p></div></div><div class="sect2" title="at45d_get_info Function"><div class="titlepage"><div><div><h2 class="title"><a id="at45d_underscore_get_underscore_info_fun"/>at45d_get_info Function</h2></div></div></div><p>The <code class="literal">at45d_get_info</code> function gets the storage device’s manufacturer ID. Here is its function definition (again):</p><a id="I_programlisting13_d1e23678"/><pre class="programlisting">static int
at45d_get_info(device_t dev, uint8_t *r)
{
        struct spi_command cmd;
        uint8_t tx_buf[8], rx_buf[8];
        int error;

        memset(&amp;cmd, 0, sizeof(cmd));
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>memset(tx_buf, 0, sizeof(tx_buf));
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>memset(rx_buf, 0, sizeof(rx_buf));

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>tx_buf[0] = MANUFACTURER_ID;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>cmd.tx_cmd = &amp;tx_buf[0];
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>cmd.rx_cmd = &amp;rx_buf[0];
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>cmd.tx_cmd_sz = 5;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>cmd.rx_cmd_sz = 5;
        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>SPIBUS_TRANSFER(device_get_parent(dev), dev, &amp;cmd);
        if (error)
                return (error);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>memcpy(r, &amp;rx_buf[1], 4);
        return (0);
}</pre><p>This function begins by zeroing its <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23737"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> transmit and <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23743"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> receive buffers.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Every SPI data transfer is a full-duplex data transmission. That is, it always requires a transmit and receive buffer, because the master and slave both transmit data—even if the data to be sent is meaningless or garbage, it’s still transferred.<a class="indexterm" id="IDX-CHP-13-0065"/><a class="indexterm" id="IDX-CHP-13-0066"/><a class="indexterm" id="IDX-CHP-13-0067"/><a class="indexterm" id="IDX-CHP-13-0068"/></p></div><p>The remainder of this function <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23772"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> places <code class="literal">MANUFACTURER_ID</code> in the transmit buffer, sets up the <code class="literal">spi_command</code> structure (which denotes the <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23784"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> transmit and <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23790"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> receive buffers and their <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23797"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23803"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> data lengths), <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23809"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> initiates the data transfer, and finally <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23815"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> returns the manufacturer ID to the caller.</p></div><div class="sect2" title="at45d_wait_for_device_ready Function"><div class="titlepage"><div><div><h2 class="title"><a id="at45d_underscore_wait_underscore_for_und"/>at45d_wait_for_device_ready Function</h2></div></div></div><p>The <code class="literal">at45d_wait_for_device_ready</code> function “spins” until the storage device is ready. Here is its function definition (again):</p><a id="I_programlisting13_d1e23829"/><pre class="programlisting">static void
at45d_wait_for_device_ready(device_t dev)
{
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>while ((at45d_get_status(dev) &amp; 0x80) == 0)
                continue;
}</pre><p>This function continually calls <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23839"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">at45d_get_status</code> until <code class="literal">0x80</code>, which designates that the device is not busy and is ready to accept the next command, is returned.</p></div><div class="sect2" title="at45d_get_status Function"><div class="titlepage"><div><div><h2 class="title"><a id="at45d_underscore_get_underscore_status_f"/>at45d_get_status Function</h2></div></div></div><p>The <code class="literal">at45d_get_status</code> function gets the storage device’s status. Here is its function definition (again):</p><a id="I_programlisting13_d1e23860"/><pre class="programlisting">static uint8_t
at45d_get_status(device_t dev)
{
        struct spi_command cmd;
        uint8_t tx_buf[8], rx_buf[8];

        memset(&amp;cmd, 0, sizeof(cmd));
        memset(tx_buf, 0, sizeof(tx_buf));
        memset(rx_buf, 0, sizeof(rx_buf));

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>tx_buf[0] = STATUS_REGISTER_READ;
        cmd.tx_cmd = &amp;tx_buf[0];
        cmd.rx_cmd = &amp;rx_buf[0];
        cmd.tx_cmd_sz = 2;
        cmd.rx_cmd_sz = 2;
        SPIBUS_TRANSFER(device_get_parent(dev), dev, &amp;cmd);

        return (rx_buf[1]);
}</pre><p>As you can see, this function is nearly identical to the <code class="literal">at45d_get_info</code> function, except that it <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23873"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> employs a different command. As such, I’ll omit walking through it.<a class="indexterm" id="IDX-CHP-13-0069"/><a class="indexterm" id="IDX-CHP-13-0070"/><a class="indexterm" id="IDX-CHP-13-0071"/><a class="indexterm" id="IDX-CHP-13-0072"/><a class="indexterm" id="IDX-CHP-13-0073"/><a class="indexterm" id="IDX-CHP-13-0074"/></p></div><div class="sect2" title="at45d_strategy Function"><div class="titlepage"><div><div><h2 class="title"><a id="at45d_underscore_strategy_function"/>at45d_strategy Function</h2></div></div></div><p>The <code class="literal">at45d_strategy</code> function is defined in <code class="literal">at45d_delayed_attach</code> as the <code class="literal">d_strategy</code> routine; it is executed anytime <code class="literal">at45d</code> receives a <code class="literal">bio</code> structure. Here is its function definition (again):</p><a id="I_programlisting13_d1e23929"/><pre class="programlisting">static void
at45d_strategy(<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct bio *bp)
{
        struct at45d_softc *sc = bp-&gt;bio_disk-&gt;d_drv1;

        mtx_lock(&amp;sc-&gt;at45d_mtx);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>bioq_disksort(&amp;sc-&gt;at45d_bioq, bp);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>wakeup(sc);
        mtx_unlock(&amp;sc-&gt;at45d_mtx);
}</pre><p>This function simply takes a <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23951"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">bio</code> structure and <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23960"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> adds it to <code class="literal">at45d</code>’s block I/O queue. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e23969"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> gets <code class="literal">at45d_task</code> to actually process the <code class="literal">bio</code> structure(s).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Most strategy routines do something similar. That is to say, they don’t actually process the <code class="literal">bio</code> structures; they only place them on the block I/O queue, and another function or thread sees to them.</p></div></div><div class="sect2" title="at45d_task Function"><div class="titlepage"><div><div><h2 class="title"><a id="at45d_underscore_task_function"/>at45d_task Function</h2></div></div></div><p>As mentioned in the previous section, the <code class="literal">at45d_task</code> function processes the <code class="literal">bio</code> structures on <code class="literal">at45d</code>’s block I/O queue. Here is its function definition (again):</p><a id="I_programlisting13_d1e24002"/><pre class="programlisting">static void
at45d_task(void *arg)
{
        struct at45d_softc *sc = arg;
        struct bio *bp;
        struct spi_command cmd;
        uint8_t tx_buf[8], rx_buf[8];
        int ss = sc-&gt;at45d_disk-&gt;d_sectorsize;
        daddr_t block, end;
        char *vaddr;

        for (;;) {
                mtx_lock(&amp;sc-&gt;at45d_mtx);
                do {
                        bp = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>bioq_first(&amp;sc-&gt;at45d_bioq);
                        if (bp == NULL)
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>mtx_sleep(sc, &amp;sc-&gt;at45d_mtx, PRIBIO,
                                    "at45d", 0);
                } while (bp == NULL);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>bioq_remove(&amp;sc-&gt;at45d_bioq, bp);
                mtx_unlock(&amp;sc-&gt;at45d_mtx);

                end = bp-&gt;bio_pblkno + (bp-&gt;bio_bcount / ss);
                for (block = bp-&gt;bio_pblkno; block &lt; end; block++) {
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>vaddr = bp-&gt;bio_data +
                            (block - bp-&gt;bio_pblkno) * ss;
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>if (bp-&gt;bio_cmd == BIO_READ) {
                                tx_buf[0] = CONTINUOUS_ARRAY_READ_HF;
                                cmd.tx_cmd_sz = 5;
                                cmd.rx_cmd_sz = 5;
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>} else {
                                tx_buf[0] = PROGRAM_THROUGH_BUFFER;
                                cmd.tx_cmd_sz = 4;
                                cmd.rx_cmd_sz = 4;
                        }

                        /* FIXME: This works only on certain devices. */
                        tx_buf[1] = ((block &gt;&gt; 5) &amp; 0xff);
                        tx_buf[2] = ((block &lt;&lt; 3) &amp; 0xf8);
                        tx_buf[3] = 0;
                        tx_buf[4] = 0;
                        cmd.tx_cmd = &amp;tx_buf[0];
                        cmd.rx_cmd = &amp;rx_buf[0];
                        cmd.tx_data = vaddr;
                        cmd.rx_data = vaddr;
                        cmd.tx_data_sz = ss;
                        cmd.rx_data_sz = ss;
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>SPIBUS_TRANSFER(device_get_parent(sc-&gt;at45d_dev),
                            sc-&gt;at45d_dev, &amp;cmd);
                }
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>biodone(bp);
        }
}</pre><p>This function can be split into four parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24055"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> determines whether <code class="literal">at45d</code>’s block I/O queue is empty. If so, <code class="literal">at45d_task</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24067"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> sleeps; otherwise, it <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24073"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> acquires (and removes) the head of the queue. The second part determines whether the block-centric I/O request is a <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24080"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> read or a <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24086"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> write.<a class="indexterm" id="IDX-CHP-13-0075"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Block-centric I/O requests are seen from the driver’s point of view. So, <code class="literal">BIO_READ</code> means reading <span class="emphasis"><em>from</em></span> the device.<a class="indexterm" id="IDX-CHP-13-0076"/></p></div><p>The second part also <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24109"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> calculates the offset in <code class="literal">bio_data</code> (that is, the location in main memory) to read from or write to. This is crucial because each I/O operation transmits 1 block of data, not 1 byte (that is, the abovementioned offset is a multiple of 1 block).</p><p>In case you have trouble following the offset calculation, here is a brief description of each variable involved: The <code class="literal">ss</code> variable is the device’s sector size. The <code class="literal">bio_pblkno</code> variable is the first block of device memory to read from or write to, <code class="literal">end</code> is the last block, and <code class="literal">block</code> is the current block <code class="literal">at45d_task</code> is working with.</p><p>The third part sets up the <code class="literal">spi_command</code> structure and <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24140"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> initiates the data transfer. Finally, the fourth part <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e24146"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> tells the kernel that the block-centric I/O request <code class="literal">bp</code> has been serviced.<a class="indexterm" id="IDX-CHP-13-0077"/><a class="indexterm" id="IDX-CHP-13-0078"/><a class="indexterm" id="IDX-CHP-13-0079"/><a class="indexterm" id="IDX-CHP-13-0080"/></p></div></div>
<div class="sect1" title="Block I/O Completion Routines"><div class="titlepage"><div><div><h1 class="title"><a id="block_i_solidus_o_completion_routines"/>Block I/O Completion Routines</h1></div></div></div><p>As seen in the previous section, after processing a block-centric I/O request, you must inform the kernel with:</p><a id="I_programlisting13_d1e24173"/><pre class="programlisting">#include &lt;sys/bio.h&gt;

void
biodone(struct bio *bp);

void
biofinish(struct bio *bp, struct devstat *stat, int error);</pre><p>The <code class="literal">biodone</code> function tells the kernel that the block-centric I/O request <code class="literal">bp</code> has been serviced successfully.</p><p>The <code class="literal">biofinish</code> function is identical to <code class="literal">biodone</code>, except that it sets <code class="literal">bp</code> to return the error code <code class="literal">error</code> (that is to say, <code class="literal">biofinish</code> can tell the kernel that <code class="literal">bp</code> was invalid, successful, or unsuccessful).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Typically, the <code class="literal">stat</code> argument is set to <code class="literal">NULL</code>. For more on <code class="literal">struct devstat</code>, see the <code class="literal">devstat(9)</code> manual page (though it’s somewhat antiquated).</p></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id12"/>Conclusion</h1></div></div></div><p>This chapter focused on implementing and understanding storage drivers. You learned how to manage both <code class="literal">disk</code> and <code class="literal">bio</code> structures and studied a real-world storage driver.</p></div></body></html>