<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Input and Output"><div class="titlepage"><div><div><h1 class="title"><a id="input_and_output"/>Chapter 8. Input and Output</h1></div></div></div><p>In this chapter, you’re going to learn how to receive input from the keyboard and print stuff to the screen.<a id="IDX-CHP-8-0001" class="indexterm"/><a id="IDX-CHP-8-0002" class="indexterm"/><a id="IDX-CHP-8-0003" class="indexterm"/><a id="IDX-CHP-8-0004" class="indexterm"/></p><p>But first, we’ll cover the basics of input and output (I/O):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>What are I/O actions?</p></li><li class="listitem"><p>How do I/O actions enable us to do I/O?</p></li><li class="listitem"><p>When are I/O actions actually performed?</p></li></ul></div><p>Dealing with I/O brings up the issue of constraints on how Haskell functions can work, so we’ll look at how we get around that first.</p><div class="sect1" title="Separating the Pure from the Impure"><div class="titlepage"><div><div><h1 class="title"><a id="separating_the_pure_from_the_impure"/>Separating the Pure from the Impure</h1></div></div></div><p>By now, you’re used to the fact that Haskell is a purely functional language. Instead of giving the computer a series of steps to execute, you give it definitions of what certain things are. In addition, a function isn’t allowed to have <span class="emphasis"><em>side effects</em></span>. A function can give us back only some result based on the parameters we supplied to it. If a function is called two times with the same parameters, it must return the same result.</p><p>While this may seem a bit limiting at first, it’s actually really cool. In an imperative language, you have no guarantee that a simple function that should just crunch some numbers won’t burn down your house or kidnap your dog while crunching those numbers. For instance, when we were making a binary search tree in the previous chapter, we didn’t insert an element into a tree by modifying the tree itself; instead, our function actually returned a <span class="emphasis"><em>new</em></span> tree with the new element inserted into that.<a id="IDX-CHP-8-0005" class="indexterm"/><a id="IDX-CHP-8-0006" class="indexterm"/><a id="IDX-CHP-8-0007" class="indexterm"/><a id="IDX-CHP-8-0008" class="indexterm"/><a id="IDX-CHP-8-0009" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e13747"/><img src="httpatomoreillycomsourcenostarchimages802614.png.jpg" alt="image with no caption"/></div></div><p>The fact that functions cannot change state—like updating global variables, for example—is good, because it helps us reason about our programs. However, there’s one problem with this: If a function can’t change anything in the world, how is it supposed to tell us what it calculated? To do that, it must change the state of an output device (usually the state of the screen), which then emits photons that travel to our brain, which changes the state of our mind, man.</p><p>But don’t despair, all is not lost. Haskell has a really clever system for dealing with functions that have side effects. It neatly separates the part of our program that is pure and the part of our program that is impure, which does all the dirty work like talking to the keyboard and the screen. With those two parts separated, we can still reason about our pure program and take advantage of all the things that purity offers—like laziness, robustness, and composability—while easily communicating with the outside world. You’ll see this at work in this chapter.</p></div></div>
<div class="sect1" title="Hello, World!"><div class="titlepage"><div><div><h1 class="title"><a id="hello_comma_world_exclamation"/>Hello, World!</h1></div></div></div><p>Until now, we’ve always loaded our functions into GHCi to test them. We’ve also explored the standard library functions in that way. Now we’re finally going to write our first real Haskell program! Yay! And sure enough, we’re going to do the good old Hello, world! schtick.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e13762"/><img src="httpatomoreillycomsourcenostarchimages802616.png.jpg" alt="image with no caption"/></div></div><p>For starters, punch the following into your favorite text editor:</p><a id="I_programlisting8_d1e13769"/><pre class="programlisting">main = putStrLn "hello, world"</pre><p>We just defined <code class="literal">main</code>, and in it we call a function called <code class="literal">putStrLn</code> with the parameter <code class="literal">"hello, world"</code>. Save that file as <span class="emphasis"><em>helloworld.hs</em></span>.</p><p>We’re going to do something we’ve never done before: compile our program, so that we get an executable file that we can run! Open your terminal, navigate to the directory where <span class="emphasis"><em>helloworld.hs</em></span> is located, and enter the following:<a id="IDX-CHP-8-0010" class="indexterm"/><a id="IDX-CHP-8-0011" class="indexterm"/><a id="IDX-CHP-8-0012" class="indexterm"/><a id="IDX-CHP-8-0013" class="indexterm"/><a id="IDX-CHP-8-0014" class="indexterm"/><a id="IDX-CHP-8-0015" class="indexterm"/></p><a id="I_programlisting8_d1e13816"/><pre class="programlisting">$ ghc --make helloworld</pre><p>This invokes the GHC compiler and tells it to compile our program. It should report something like this:</p><a id="I_programlisting8_d1e13820"/><pre class="programlisting">[1 of 1] Compiling Main ( helloworld.hs, helloworld.o )
Linking helloworld ...</pre><p>Now you can run your program by entering the following at the terminal:</p><a id="I_programlisting8_d1e13825"/><pre class="programlisting">$ ./helloworld</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>If you’re using Windows, instead of doing <code class="literal">./helloworld</code>, just type in <strong class="userinput"><code>helloworld.exe</code></strong> to run your program.</p></div><p>Our program prints out the following:</p><a id="I_programlisting8_d1e13838"/><pre class="programlisting">hello, world</pre><p>And there you go—our first compiled program that prints something to the terminal. How extraordinarily boring!</p><p>Let’s examine what we wrote. First, let’s look at the type of the function <code class="literal">putStrLn</code>:</p><a id="I_programlisting8_d1e13847"/><pre class="programlisting">ghci&gt; :t putStrLn
putStrLn :: String -&gt; IO ()
ghci&gt; :t putStrLn "hello, world"
putStrLn "hello, world" :: IO ()</pre><p>We can read the type of <code class="literal">putStrLn</code> like this: <code class="literal">putStrLn</code> takes a string and returns an <span class="emphasis"><em>I/O action</em></span> that has a result type of <code class="literal">()</code> (that is, the empty tuple, also known as <span class="emphasis"><em>unit</em></span>).</p><p>An I/O action is something that, when performed, will carry out an action with a side effect (such as reading input or printing stuff to the screen or a file) and will also present some result. We say that an I/O action <span class="emphasis"><em>yields</em></span> this result. Printing a string to the terminal doesn’t really have any kind of meaningful return value, so a dummy value of <code class="literal">()</code> is used.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The empty tuple is the value (), and it also has a type of ().</p></div><p>So when will an I/O action be performed? Well, this is where <code class="literal">main</code> comes in. An I/O action will be performed when we give it a name of <code class="literal">main</code> and then run our program.</p></div>
<div class="sect1" title="Gluing I/O Actions Together"><div class="titlepage"><div><div><h1 class="title"><a id="gluing_i_solidus_o_actions_together"/>Gluing I/O Actions Together</h1></div></div></div><p>Having your whole program be just one I/O action seems kind of limiting. That’s why we can use <code class="literal">do</code> syntax to glue together several I/O actions into one. Take a look at the following example:<a id="IDX-CHP-8-0016" class="indexterm"/><a id="IDX-CHP-8-0017" class="indexterm"/><a id="IDX-CHP-8-0018" class="indexterm"/><a id="IDX-CHP-8-0019" class="indexterm"/></p><a id="I_programlisting8_d1e13913"/><pre class="programlisting">main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")</pre><p>Ah, interesting—new syntax! And this reads pretty much like an imperative program. If you compile and run it, it will behave just as you expect.</p><p>Notice that we said <code class="literal">do</code> and then we laid out a series of steps, as we would in an imperative program. Each of these steps is an I/O action. By putting them together with <code class="literal">do</code> syntax, we glued them into one I/O action. The action that we got has a type of <code class="literal">IO ()</code>, as that’s the type of the last I/O action inside. Because of that, <code class="literal">main</code> always has a type signature of <code class="literal">main :: IO</code> <em class="replaceable"><code>something</code></em>, where <em class="replaceable"><code>something</code></em> is some concrete type. We don’t usually specify a type declaration for <code class="literal">main</code>.</p><p>How about that third line, which states <code class="literal">name &lt;- getLine</code>? It looks like it reads a line from the input and stores it into a variable called <code class="literal">name</code>. Does it really? Well, let’s examine the type of <code class="literal">getLine</code>.</p><a id="I_programlisting8_d1e13955"/><pre class="programlisting">ghci&gt; :t getLine
getLine :: IO String</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e13958"/><img src="httpatomoreillycomsourcenostarchimages802618.png.jpg" alt="image with no caption"/></div></div><p>We see that <code class="literal">getLine</code> is an I/O action that yields a <code class="literal">String</code>. That makes sense, because it will wait for the user to input something at the terminal, and then that something will be represented as a string.</p><p>So what’s up with <code class="literal">name &lt;- getLine</code> then? You can read that piece of code like this: perform the I/O action <code class="literal">getLine</code>, and then bind its result value to <code class="literal">name</code>. <code class="literal">getLine</code> has a type of <code class="literal">IO String</code>, so <code class="literal">name</code> will have a type of <code class="literal">String</code>.</p><p>You can think of an I/O action as a box with little feet that will go out into the real world and do something there (like write some graffiti on a wall) and maybe bring back some data. Once it has fetched that data for you, the only way to open the box and get the data inside it is to use the <code class="literal">&lt;-</code> construct. And if we’re taking data out of an I/O action, we can take it out only when we’re inside another I/O action. This is how Haskell manages to neatly separate the pure and impure parts of our code. <code class="literal">getLine</code> is impure, because its result value is not guaranteed to be the same when performed twice.</p><p>When we do <code class="literal">name &lt;- getLine</code>, <code class="literal">name</code> is just a normal string, because it represents what’s inside the box. For example, we can have a really complicated function that takes your name (a normal string) as a parameter and tells you your fortune based on your name, like this:<a id="IDX-CHP-8-0020" class="indexterm"/><a id="IDX-CHP-8-0021" class="indexterm"/><a id="IDX-CHP-8-0022" class="indexterm"/><a id="IDX-CHP-8-0023" class="indexterm"/></p><a id="I_programlisting8_d1e14032"/><pre class="programlisting">main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn $ "Zis is your future: " ++ tellFortune name</pre><p>The <code class="literal">tellFortune</code> function (or any of the functions it passes <code class="literal">name</code> to) does not need to know anything about I/O—it’s just a normal <code class="literal">String -&gt; String</code> function!</p><p>To see how normal values differ from I/O actions, consider the following line. Is it valid?</p><a id="I_programlisting8_d1e14047"/><pre class="programlisting">nameTag = "Hello, my name is " ++ getLine</pre><p>If you said no, go eat a cookie. If you said yes, drink a bowl of molten lava. (Just kidding—don’t!) This doesn’t work because <code class="literal">++</code> requires both its parameters to be lists over the same type. The left parameter has a type of <code class="literal">String</code> (or <code class="literal">[Char]</code>, if you will), while <code class="literal">getLine</code> has a type of <code class="literal">IO String</code>. Remember that you can’t concatenate a string and an I/O action. First, you need to get the result out of the I/O action to get a value of type <code class="literal">String</code>, and the only way to do that is to do something like <code class="literal">name &lt;- getLine</code> inside some other I/O action.</p><p>If we want to deal with impure data, we must do it in an impure environment. The taint of impurity spreads around much like the undead scourge, and it’s in our best interest to keep the I/O parts of our code as small as possible.</p><p>Every I/O action that is performed yields a result. That’s why our previous example could also have been written like this:</p><a id="I_programlisting8_d1e14077"/><pre class="programlisting">main = do
    foo &lt;- putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")</pre><p>However, <code class="literal">foo</code> would just have a value of <code class="literal">()</code>, so doing that would be kind of moot. Notice that we didn’t bind the last <code class="literal">putStrLn</code> to anything. That’s because in a <code class="literal">do</code> block, the last action cannot be bound to a name as the first two were. You’ll see exactly why that is so when we venture off into the world of monads, starting in <a class="xref" href="ch13.html" title="Chapter 13. A Fistful of Monads">Chapter 13</a>. For now, the important point is that the <code class="literal">do</code> block automatically extracts the value from the last action and yields that as its own result.</p><p>Except for the last line, every line in a <code class="literal">do</code> block that doesn’t bind can also be written with a bind. So <code class="literal">putStrLn "BLAH"</code> can be written as <code class="literal">_ &lt;- putStrLn "BLAH"</code>. But that’s useless, so we leave out the <code class="literal">&lt;-</code> for I/O actions that don’t yield an important result, like <code class="literal">putStrLn</code>.<a id="IDX-CHP-8-0024" class="indexterm"/><a id="IDX-CHP-8-0025" class="indexterm"/></p><p>What do you think will happen when we do something like the following?</p><a id="I_programlisting8_d1e14130"/><pre class="programlisting">myLine = getLine</pre><p>Do you think it will read from the input and then bind the value of that to <code class="literal">name</code>? Well, it won’t. All this does is give the <code class="literal">getLine</code> I/O action a different name called <code class="literal">myLine</code>. Remember that to get the value out of an I/O action, you must perform it inside another I/O action by binding it to a name with <code class="literal">&lt;-</code>.</p><p>I/O actions will be performed when they are given a name of <code class="literal">main</code> or when they’re inside a bigger I/O action that we composed with a <code class="literal">do</code> block. We can also use a <code class="literal">do</code> block to glue together a few I/O actions, and then we can use that I/O action in another <code class="literal">do</code> block, and so on. They will be performed if they eventually fall into <code class="literal">main</code>.</p><p>There’s also one more case when I/O actions will be performed: when we type out an I/O action in GHCi and press <span class="keycap">enter</span>.</p><a id="I_programlisting8_d1e14168"/><pre class="programlisting">ghci&gt; putStrLn "HEEY"
HEEY</pre><p>Even when we just punch in a number or call a function in GHCi and press <span class="keycap">enter</span>, GHCi will apply <code class="literal">show</code> to the resulting value, and then it will print it to the terminal by using <code class="literal">putStrLn</code>.</p><div class="sect2" title="Using let Inside I/O Actions"><div class="titlepage"><div><div><h2 class="title"><a id="using_let_inside_i_solidus_o_actions"/>Using let Inside I/O Actions</h2></div></div></div><p>When using <code class="literal">do</code> syntax to glue together I/O actions, we can use <code class="literal">let</code> syntax to bind pure values to names. Whereas <code class="literal">&lt;-</code> is used to perform I/O actions and bind their results to names, <code class="literal">let</code> is used when we just want to give names to normal values inside I/O actions. It’s similar to the <code class="literal">let</code> syntax in list comprehensions.</p><p>Let’s take a look at an I/O action that uses both <code class="literal">&lt;-</code> and <code class="literal">let</code> to bind names.</p><a id="I_programlisting8_d1e14209"/><pre class="programlisting">import Data.Char

main = do
    putStrLn "What's your first name?"
    firstName &lt;- getLine
    putStrLn "What's your last name?"
    lastName &lt;- getLine
    let bigFirstName = map toUpper firstName
        bigLastName = map toUpper lastName
    putStrLn $ "hey " ++ bigFirstName ++ " "
                      ++ bigLastName
                      ++ ", how are you?"</pre><p>See how the I/O actions in the <code class="literal">do</code> block are lined up? Also notice how the <code class="literal">let</code> is lined up with the I/O actions, and the names of the <code class="literal">let</code> are lined up with each other? That’s good practice, because indentation is important in Haskell.<a id="IDX-CHP-8-0026" class="indexterm"/><a id="IDX-CHP-8-0027" class="indexterm"/><a id="IDX-CHP-8-0028" class="indexterm"/></p><p>We wrote <code class="literal">map toUpper firstName</code>, which turns something like <code class="literal">"John"</code> into a much cooler string like <code class="literal">"JOHN"</code>. We bound that uppercased string to a name and then used it in a string that we printed to the terminal.</p><p>You may be wondering when to use <code class="literal">&lt;-</code> and when to use <code class="literal">let</code> bindings. <code class="literal">&lt;-</code> is for performing I/O actions and binding their results to names. <code class="literal">map toUpper firstName</code>, however, isn’t an I/O action—it’s a pure expression in Haskell. So you can use <code class="literal">&lt;-</code> when you want to bind the results of I/O actions to names, and you can use <code class="literal">let</code> bindings to bind pure expressions to names. Had we done something like <code class="literal">let firstName = getLine</code>, we would have just called the <code class="literal">getLine</code> I/O action a different name, and we would still need to run it through a <code class="literal">&lt;-</code> to perform it and bind its result.</p></div><div class="sect2" title="Putting It in Reverse"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_in_reverse"/>Putting It in Reverse</h2></div></div></div><p>To get a better feel for doing I/O in Haskell, let’s make a simple program that continuously reads a line and prints out the same line with the words reversed. The program’s execution will stop when we input a blank line. This is the program:</p><a id="I_programlisting8_d1e14281"/><pre class="programlisting">main = do
    line &lt;- getLine
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main

reverseWords :: String -&gt; String
reverseWords = unwords . map reverse . words</pre><p>To get a feel for what it does, save it as <span class="emphasis"><em>reverse.hs</em></span>, and then compile and run it:</p><a id="I_programlisting8_d1e14288"/><pre class="programlisting">$ ghc --make reverse.hs
[1 of 1] Compiling Main             ( reverse.hs, reverse.o )
Linking reverse ...
$ ./reverse
clean up on aisle number nine
naelc pu no elsia rebmun enin
the goat of error shines a light upon your life
eht taog fo rorre senihs a thgil nopu ruoy efil
it was all a dream
ti saw lla a maerd</pre><p>Our <code class="literal">reverseWords</code> function is just a normal function. It takes a string like <code class="literal">"hey there man"</code> and applies <code class="literal">words</code> to it to produce a list of words like <code class="literal">["hey","there","man"]</code>. We map <code class="literal">reverse</code> over the list, getting <code class="literal">["yeh","ereht","nam"]</code>, and then we put that back into one string by using <code class="literal">unwords</code>. The final result is <code class="literal">"yeh ereht nam"</code>.<a id="IDX-CHP-8-0029" class="indexterm"/><a id="IDX-CHP-8-0030" class="indexterm"/></p><p>What about <code class="literal">main</code>? First, we get a line from the terminal by performing <code class="literal">getLine</code> and call that line <code class="literal">line</code>. Next we have a conditional expression. Remember that in Haskell, every <code class="literal">if</code> must have a corresponding <code class="literal">else</code>, because every expression must have some sort of value. Our <code class="literal">if</code> says that when a condition is true (in our case, the line that we entered is blank), we perform one I/O action; when it isn’t true, the I/O action under the <code class="literal">else</code> is performed.</p><p>Because we need to have exactly one I/O action after the <code class="literal">else</code>, we use a <code class="literal">do</code> block to glue together two I/O actions into one. We could also write that part as follows:</p><a id="I_programlisting8_d1e14359"/><pre class="programlisting">else (do
    putStrLn $ reverseWords line
    main)</pre><p>This makes it clearer that the <code class="literal">do</code> block can be viewed as one I/O action, but it’s uglier.</p><p>Inside the <code class="literal">do</code> block, we apply <code class="literal">reverseWords</code> to the line that we got from <code class="literal">getLine</code> and then print that to the terminal. After that, we just perform <code class="literal">main</code>. It’s performed recursively, and that’s okay, because <code class="literal">main</code> is itself an I/O action. So in a sense, we go back to the start of the program.</p><p>If <code class="literal">null line</code> is <code class="literal">True</code>, the code after the <code class="literal">then</code> is executed: <code class="literal">return ()</code>. You might have used a <code class="literal">return</code> keyword in other languages to return from a subroutine or function. But <code class="literal">return</code> in Haskell is nothing like the <code class="literal">return</code> in most other languages.</p><p>In Haskell (and in I/O actions specifically), <code class="literal">return</code> makes an I/O action out of a pure value. Returning to the box analogy for I/O actions, <code class="literal">return</code> takes a value and wraps it up in a box. The resulting I/O action doesn’t actually do anything; it just yields that value as its result. So in an I/O context, <code class="literal">return "haha"</code> will have a type of <code class="literal">IO String</code>.</p><p>What’s the point of just transforming a pure value into an I/O action that doesn’t do anything? Well, we needed some I/O action to carry out in the case of an empty input line. That’s why we made a bogus I/O action that doesn’t do anything by writing <code class="literal">return ()</code>.</p><p>Unlike in other languages, using <code class="literal">return</code> doesn’t cause the I/O <code class="literal">do</code> block to end in execution. For instance, this program will quite happily continue all the way to the last line:</p><a id="I_programlisting8_d1e14435"/><pre class="programlisting">main = do
    return ()
    return "HAHAHA"
    line &lt;- getLine
    return "BLAH BLAH BLAH"
    return 4
    putStrLn line</pre><p>Again, all these uses of <code class="literal">return</code> do is make I/O actions that yield a result, which is then thrown away because it isn’t bound to a name.<a id="IDX-CHP-8-0031" class="indexterm"/></p><p>We can use <code class="literal">return</code> in combination with <code class="literal">&lt;-</code> to bind stuff to names:</p><a id="I_programlisting8_d1e14453"/><pre class="programlisting">main = do
    a &lt;- return "hell"
    b &lt;- return "yeah!"
    putStrLn $ a ++ " " ++ b</pre><p>So you see, <code class="literal">return</code> is sort of the opposite of <code class="literal">&lt;-</code>. While <code class="literal">return</code> takes a value and wraps it up in a box, <code class="literal">&lt;-</code> takes a box (and performs it) and takes the value out of it, binding it to a name. But doing this is kind of redundant, especially since you can use <code class="literal">let</code> in <code class="literal">do</code> blocks to bind to names, like so:</p><a id="I_programlisting8_d1e14476"/><pre class="programlisting">main = do
    let a = "hell"
        b = "yeah"
    putStrLn $ a ++ " " ++ b</pre><p>When dealing with I/O <code class="literal">do</code> blocks, we mostly use <code class="literal">return</code> either because we need to create an I/O action that doesn’t do anything or because we don’t want the I/O action that’s made up from a <code class="literal">do</code> block to have the result value of its last action. When we want it to have a different result value, we use <code class="literal">return</code> to make an I/O action that always yields our desired result, and we put it at the end.</p></div></div>
<div class="sect1" title="Some Useful I/O Functions"><div class="titlepage"><div><div><h1 class="title"><a id="some_useful_i_solidus_o_functions"/>Some Useful I/O Functions</h1></div></div></div><p>Haskell comes with a bunch of useful functions and I/O actions. Let’s take a look at some of them to see how they’re used.</p><div class="sect2" title="putStr"><div class="titlepage"><div><div><h2 class="title"><a id="putstr"/>putStr</h2></div></div></div><p><code class="literal">putStr</code> is much like <code class="literal">putStrLn</code>, in that it takes a string as a parameter and returns an I/O action that will print that string to the terminal. However, <code class="literal">putStr</code> doesn’t jump into a new line after printing out the string, whereas <code class="literal">putStrLn</code> does. For example, look at this code:<a id="IDX-CHP-8-0032" class="indexterm"/></p><a id="I_programlisting8_d1e14518"/><pre class="programlisting">main = do
    putStr "Hey, "
    putStr "I'm "
    putStrLn "Andy!"</pre><p>If we compile and run this, we get the following output:<a id="IDX-CHP-8-0033" class="indexterm"/><a id="IDX-CHP-8-0034" class="indexterm"/></p><a id="I_programlisting8_d1e14528"/><pre class="programlisting">Hey, I'm Andy!</pre></div><div class="sect2" title="putChar"><div class="titlepage"><div><div><h2 class="title"><a id="putchar"/>putChar</h2></div></div></div><p>The <code class="literal">putChar</code> function takes a character and returns an I/O action that will print it to the terminal:<a id="IDX-CHP-8-0035" class="indexterm"/><a id="IDX-CHP-8-0036" class="indexterm"/></p><a id="I_programlisting8_d1e14548"/><pre class="programlisting">main = do
    putChar 't'
    putChar 'e'
    putChar 'h'</pre><p><code class="literal">putStr</code> can be defined recursively with the help of <code class="literal">putChar</code>. The base case of <code class="literal">putStr</code> is the empty string, so if we’re printing an empty string, we just return an I/O action that does nothing by using <code class="literal">return ()</code>. If it’s not empty, then we print the first character of the string by doing <code class="literal">putChar</code> and then print the rest of them recursively:</p><a id="I_programlisting8_d1e14566"/><pre class="programlisting">putStr :: String -&gt; IO ()
putStr [] = return ()
putStr (x:xs) = do
    putChar x
    putStr xs</pre><p>Notice how we can use recursion in I/O, just as we can use it in pure code. We define the base case and then think what the result actually is. In this case, it’s an action that first outputs the first character and then outputs the rest of the string.</p></div><div class="sect2" title="print"><div class="titlepage"><div><div><h2 class="title"><a id="print"/>print</h2></div></div></div><p><code class="literal">print</code> takes a value of any type that’s an instance of <code class="literal">Show</code> (meaning that we know how to represent it as a string), applies <code class="literal">show</code> to that value to “stringify” it, and then outputs that string to the terminal. Basically, it’s just <code class="literal">putStrLn . show</code>. It first runs <code class="literal">show</code> on a value, and then feeds that to <code class="literal">putStrLn</code>, which returns an I/O action that will print out our value.</p><a id="I_programlisting8_d1e14592"/><pre class="programlisting">main = do
    print True
    print 2
    print "haha"
    print 3.2
    print [3,4,3]</pre><p>Compiling this and running it, we get the following output:<a id="IDX-CHP-8-0037" class="indexterm"/></p><a id="I_programlisting8_d1e14599"/><pre class="programlisting">True
2
"haha"
3.2
[3,4,3]</pre><p>As you can see, it’s a very handy function. Remember how we talked about how I/O actions are performed only when they fall into <code class="literal">main</code> or when we try to evaluate them at the GHCi prompt? When we type out a value (like <code class="literal">3</code> or <code class="literal">[1,2,3]</code>) and press <span class="keycap">enter</span>, GHCi actually uses <code class="literal">print</code> on that value to display it on the terminal!<a id="IDX-CHP-8-0038" class="indexterm"/></p><a id="I_programlisting8_d1e14624"/><pre class="programlisting">ghci&gt; 3
3
ghci&gt; print 3
3
ghci&gt; map (++"!") ["hey","ho","woo"]
["hey!","ho!","woo!"]
ghci&gt; print $ map (++"!") ["hey","ho","woo"]
["hey!","ho!","woo!"]</pre><p>When we want to print out strings, we usually use <code class="literal">putStrLn</code> because we don’t want the quotes around them. However, for printing out values of other types to the terminal, <code class="literal">print</code> is used the most often.</p></div><div class="sect2" title="when"><div class="titlepage"><div><div><h2 class="title"><a id="when"/>when</h2></div></div></div><p>The <code class="literal">when</code> function is found in <code class="literal">Control.Monad</code> (to access it, use <code class="literal">import Control.Monad</code>). It’s interesting because in a <code class="literal">do</code> block, it looks like a flow-control statement, but it’s actually a normal function.</p><p><code class="literal">when</code> takes a <code class="literal">Bool</code> and an I/O action, and if that <code class="literal">Bool</code> value is <code class="literal">True</code>, it returns the same I/O action that we supplied to it. However, if it’s <code class="literal">False</code>, it returns the <code class="literal">return ()</code> action, which doesn’t do anything.</p><p>Here’s a small program that asks for some input and prints it back to the terminal, but only if that input is <code class="literal">SWORDFISH</code>:</p><a id="I_programlisting8_d1e14675"/><pre class="programlisting">import Control.Monad

main = do
    input &lt;- getLine
    when (input == "SWORDFISH") $ do
        putStrLn input</pre><p>Without <code class="literal">when</code>, we would need to write the program like this:<a id="IDX-CHP-8-0039" class="indexterm"/></p><a id="I_programlisting8_d1e14685"/><pre class="programlisting">main = do
    input &lt;- getLine
    if (input == "SWORDFISH")
        then putStrLn input
        else return ()</pre><p>As you can see, the <code class="literal">when</code> function is useful when we want to perform some I/O actions when a condition is met, but do nothing otherwise.</p></div><div class="sect2" title="sequence"><div class="titlepage"><div><div><h2 class="title"><a id="sequence"/>sequence</h2></div></div></div><p>The <code class="literal">sequence</code> function takes a list of I/O actions and returns an I/O action that will perform those actions one after the other. The result that this I/O action yields will be a list of the results of all the I/O actions that were performed. For instance, we could do this:<a id="IDX-CHP-8-0040" class="indexterm"/></p><a id="I_programlisting8_d1e14705"/><pre class="programlisting">main = do
    a &lt;- getLine
    b &lt;- getLine
    c &lt;- getLine
    print [a,b,c]</pre><p>Or we could do this:</p><a id="I_programlisting8_d1e14709"/><pre class="programlisting">main = do
    rs &lt;- sequence [getLine, getLine, getLine]
    print rs</pre><p>The results of both these versions are exactly the same. <code class="literal">sequence [getLine, getLine, getLine]</code> makes an I/O action that will perform <code class="literal">getLine</code> three times. If we bind that action to a name, the result is a list of all the results. So in this case, the result would be a list of three things that the user entered at the prompt.</p><p>A common pattern with <code class="literal">sequence</code> is when we map functions like <code class="literal">print</code> or <code class="literal">putStrLn</code> over lists. Executing <code class="literal">map print [1,2,3,4]</code> won’t create an I/O action, but instead will create a list of I/O actions. Effectively, this is the same as writing this:</p><a id="I_programlisting8_d1e14733"/><pre class="programlisting">[print 1, print 2, print 3, print 4]</pre><p>If we want to transform that list of I/O actions into an I/O action, we must sequence it:</p><a id="I_programlisting8_d1e14737"/><pre class="programlisting">ghci&gt; sequence $ map print [1,2,3,4,5]
1
2
3
4
5
[(),(),(),(),()]</pre><p>But what’s with the <code class="literal">[(),(),(),(),()]</code> at the end of the output? Well, when we evaluate an I/O action in GHCi, that action is performed, and then its result is printed out, unless that result is <code class="literal">()</code>. That’s why evaluating <code class="literal">putStrLn "hehe"</code> in GHCi just prints out <code class="literal">hehe</code>—<code class="literal">putStrLn "hehe"</code> yields <code class="literal">()</code>. But when we enter <code class="literal">getLine</code> in GHCi, the result of that I/O action is printed out, because <code class="literal">getLine</code> has a type of <code class="literal">IO String</code>.<a id="IDX-CHP-8-0041" class="indexterm"/><a id="IDX-CHP-8-0042" class="indexterm"/><a id="IDX-CHP-8-0043" class="indexterm"/><a id="IDX-CHP-8-0044" class="indexterm"/></p></div><div class="sect2" title="mapM"><div class="titlepage"><div><div><h2 class="title"><a id="mapm"/>mapM</h2></div></div></div><p>Because mapping a function that returns an I/O action over a list and then sequencing it is so common, the utility functions <code class="literal">mapM</code> and <code class="literal">mapM_</code> were introduced. <code class="literal">mapM</code> takes a function and a list, maps the function over the list, and then sequences it. <code class="literal">mapM_</code> does the same thing, but it throws away the result later. We usually use <code class="literal">mapM_</code> when we don’t care what result our sequenced I/O actions have. Here’s an example of <code class="literal">mapM</code>:<a id="IDX-CHP-8-0045" class="indexterm"/></p><a id="I_programlisting8_d1e14813"/><pre class="programlisting">ghci&gt; mapM print [1,2,3]
1
2
3
[(),(),()]</pre><p>But we don’t care about the list of three units at the end, so it’s better to use this form:</p><a id="I_programlisting8_d1e14817"/><pre class="programlisting">ghci&gt; mapM_ print [1,2,3]
1
2
3</pre></div><div class="sect2" title="forever"><div class="titlepage"><div><div><h2 class="title"><a id="forever"/>forever</h2></div></div></div><p>The <code class="literal">forever</code> function takes an I/O action and returns an I/O action that just repeats the I/O action it got forever. It’s located in <code class="literal">Control.Monad</code>. The following little program will indefinitely ask the user for some input and spit it back in all uppercase characters:</p><a id="I_programlisting8_d1e14830"/><pre class="programlisting">import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l &lt;- getLine
    putStrLn $ map toUpper l</pre></div><div class="sect2" title="forM"><div class="titlepage"><div><div><h2 class="title"><a id="form"/>forM</h2></div></div></div><p><code class="literal">forM</code> (located in <code class="literal">Control.Monad</code>) is like <code class="literal">mapM</code>, but its parameters are switched around. The first parameter is the list, and the second is the function to map over that list, which is then sequenced. Why is that useful? Well, with some creative use of lambdas and <code class="literal">do</code> notation, we can do stuff like this:<a id="IDX-CHP-8-0046" class="indexterm"/><a id="IDX-CHP-8-0047" class="indexterm"/></p><a id="I_programlisting8_d1e14856"/><pre class="programlisting">import Control.Monad

main = do
    colors &lt;- forM [1,2,3,4] (\a -&gt; do
        putStrLn $ "Which color do you associate with the number "
                   ++ show a ++ "?"
        color &lt;- getLine
        return color)
    putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "
    mapM putStrLn colors</pre><p>Here’s what we get when we try this out:</p><a id="I_programlisting8_d1e14860"/><pre class="programlisting">Which color do you associate with the number 1?
white
Which color do you associate with the number 2?
blue
Which color do you associate with the number 3?
red
Which color do you associate with the number 4?
orange
The colors that you associate with 1, 2, 3 and 4 are:
white
blue
red
orange</pre><p>The <code class="literal">(\a -&gt; do ... )</code> lambda is a function that takes a number and returns an I/O action. Notice that we call <code class="literal">return color</code> in the inside <code class="literal">do</code> block. We do that so that the I/O action that the <code class="literal">do</code> block defines yields the string that represents our color of choice. We actually did not have to do that though, since <code class="literal">getLine</code> already yields our chosen color, and it’s the last line in the <code class="literal">do</code> block. Doing <code class="literal">color &lt;- getLine</code> and then <code class="literal">return color</code> is just unpacking the result from <code class="literal">getLine</code> and then repacking it—it’s the same as just calling <code class="literal">getLine</code>.</p><p>The <code class="literal">forM</code> function (called with its two parameters) produces an I/O action, whose result we bind to <code class="literal">colors</code>. <code class="literal">colors</code> is just a normal list that holds strings. At the end, we print out all those colors by calling <code class="literal">mapM putStrLn colors</code>.</p><p>You can think of <code class="literal">forM</code> as saying, “Make an I/O action for every element in this list. What each I/O action will do can depend on the element that was used to make the action. Finally, perform those actions and bind their results to something.” (Although we don’t need to bind it; we could also just throw it away.)</p><p>We could have actually achieve the same result without <code class="literal">forM</code>, but using <code class="literal">forM</code> makes the code more readable. Normally, we use <code class="literal">forM</code> when we want to map and sequence some actions that we define on the spot using <code class="literal">do</code> notation.</p></div></div>
<div class="sect1" title="I/O Action Review"><div class="titlepage"><div><div><h1 class="title"><a id="i_solidus_o_action_review"/>I/O Action Review</h1></div></div></div><p>Let’s run through a quick review of the I/O basics. I/O actions are values much like any other value in Haskell. We can pass them as parameters to functions, and functions can return I/O actions as results.<a id="IDX-CHP-8-0048" class="indexterm"/></p><p>What’s special about I/O actions is that if they fall into the <code class="literal">main</code> function (or are the result in a GHCi line), they are performed. And that’s when they get to write stuff on your screen or play “Yakety Sax” through your speakers. Each I/O action can also yield a result to tell you what it got from the real world.</p></div></body></html>