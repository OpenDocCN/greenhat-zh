<html><head></head><body><div class="appendix" title="Appendix&#xA0;A.&#xA0;How Does Ruby Compare to Other Languages?"><div class="titlepage"><div><div><h1 class="title"><a id="how_does_ruby_compare_to_other_languages"/>Appendix A. How Does Ruby Compare to Other Languages?</h1></div></div></div><p>One of the best ways to describe something is to talk about what it isn’t. This appendix describes similarities and differences between Ruby and some <a class="indexterm" id="idx-CHP-A-1304"/>other popular languages.</p><div class="sect1" title="C"><div class="titlepage"><div><div><h1 class="title"><a id="c"/>C</h1></div></div></div><p>Even though it isn’t the oldest language around, <span class="emphasis"><em>C</em></span> is the granddaddy of languages in many programmers’ minds. For the purposes of this discussion, we’ll be focusing more on the differences between Ruby and C than the similarities. C is <span class="emphasis"><em>procedural</em></span>, meaning that its programs are intended to be thought of as sets of instructions that proceed stepwise through time: <span class="emphasis"><em>Do this, then do this, then do that</em></span>. C is neither object oriented nor functional, although the closely related languages C++ and Objective C are object oriented. C undeniably has <span class="emphasis"><em>functions</em></span>, bits of reusable code that accept various inputs and return various outputs, but they are generally not <span class="emphasis"><em>purely functional</em></span> functions. C functions often depend on information other than the strict inputs to the function, and they have side effects that mean the second call to a given function will not necessarily produce the same result as the first call. C functions often return values indicating their success, relying on side effects to accomplish their main purpose.<a class="indexterm" id="idx-CHP-A-1305"/><a class="indexterm" id="idx-CHP-A-1306"/></p><p><a class="indexterm" id="idx-CHP-A-1307"/>C’s advantages over Ruby include execution speed, greater familiarity to more people, more widespread deployment, and the additional benefits that come from its code being <a class="indexterm" id="idx-CHP-A-1308"/>compiled, rather than interpreted. (Note that compiled versus interpreted is its own holy war.) When a C program compiles, you know it has passed at least one specific benchmark of reliability.</p><p>Ruby’s advantages over C include a faster development cycle, flexibility, conceptual elegance, and configurability. If you are interested in combining the strengths of both Ruby and C, you can start by exploring the <a class="indexterm" id="idx-CHP-A-1309"/>RubyInline project, available as the <code class="literal">rubyinline</code> gem or at <a class="ulink" href="http://www.zenspider.com/ZSS/Products/RubyInline">http://www.zenspider.com/ZSS/Products/RubyInline</a>.<sup>[<a class="footnote" href="#ftn.APP-A-FNOTE-1" id="APP-A-FNOTE-1">38</a>]</sup></p><p>C also has what is called <span class="emphasis"><em>strong, static typing</em></span>. This means that variables in C are defined to be a certain type of data (the integer 42, for example), and they will always remain that type of data. That’s the static part. If you wanted to express the integer 42 as a floating-point number, such as 42.0, you would need to pass it through a casting conversion function. Ruby is also strongly typed (requiring programmers to convert integers to floating-point numbers before using them that way), although it is <span class="emphasis"><em>dynamic</em></span>, meaning that variables can change type. C also lacks anything similar to Ruby’s irb.<a class="indexterm" id="idx-CHP-A-1310"/><a class="indexterm" id="idx-CHP-A-1311"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-A-FNOTE-1" id="ftn.APP-A-FNOTE-1">38</a>] </sup>I was lucky enough to see a demonstration of RubyInline by its author, Ryan Davis, at the 2005 RubyConf. It’s a very impressive piece of code, and I highly recommend it to anyone interested in combining Ruby and C.</p></div></div></div>
<div class="sect1" title="Haskell"><div class="titlepage"><div><div><h1 class="title"><a id="haskell"/>Haskell</h1></div></div></div><p>The fact that Haskell is included in this listing of <a class="indexterm" id="idx-CHP-A-1312"/>languages indicates how important the functional paradigm is to this book. <span class="emphasis"><em>Haskell</em></span> is a purely functional language designed by committee and released in 1998. It has several fascinating features, most notably <span class="emphasis"><em>lazy evaluation</em></span>, whereby the value of a given piece of data does not need to be known (or even meaningful) until it needs to be used. This allows a programmer to define things in terms of infinite series, such as the set of all integers.<a class="indexterm" id="idx-CHP-A-1313"/><a class="indexterm" id="idx-CHP-A-1314"/></p><p>Haskell is the language used for <span class="emphasis"><em>Pugs</em></span>, an implementation of the new Perl 6 language, which some people think is drawing more attention to Haskell than to Perl itself. Haskell has an interactive environment similar to Ruby’s irb, but it doesn’t allow function definitions except in external files that are imported, whereas irb allows full definitions for classes, methods, and functions. Like C, Haskell has both strong and static typing. Haskell is an excellent language that’s very suitable for teaching purely functional techniques, as well as general-purpose programming. You can read more about it at <a class="ulink" href="http://haskell.org">http://haskell.org</a>.<a class="indexterm" id="idx-CHP-A-1315"/><a class="indexterm" id="I_indexterm_d1e23118"/></p></div>
<div class="sect1" title="Java"><div class="titlepage"><div><div><h1 class="title"><a id="java"/>Java</h1></div></div></div><p>For the purposes of this discussion, Sun Microsystems’ <span class="emphasis"><em>Java</em></span> is a moderately complex, object-oriented language similar to C. Java has both strong and static typing. In one way, Java is more object oriented than Ruby is: A programmer coding in Java must use an object-oriented paradigm for his own programs. On the <a class="indexterm" id="idx-CHP-A-1316"/>other hand, <a class="indexterm" id="idx-CHP-A-1317"/>Java is less object oriented than Ruby is in the way that it implements its own built-in features. For example, to get the absolute value of the integer 100 in Java, you would do this:<a class="indexterm" id="idx-CHP-A-1318"/></p><a id="I_programlisting_d1e23142"/><pre class="programlisting">Math.abs(100)</pre><p>This means that the programmer wants to use a method called <code class="literal">abs</code>, which is associated with Math, to perform that method’s action on the integer 100. The equivalent operation in Ruby would be performed as follows:</p><a id="I_programlisting_d1e23149"/><pre class="programlisting">100.abs</pre><p>Using Ruby’s methodology, the programmer simply asks the number 100 to report its own absolute value. This approach is common in Ruby, and it assumes that every piece of data knows the best way to deal with operations on itself. An advantage of this is that the same symbol can be used for different (but conceptually related) operations. The <code class="literal">+</code> sign signifies simple addition for numbers, for example, while signifying concatenation for strings, as discussed in <a class="xref" href="ch01.html" title="Chapter 1. Interactive Ruby and the Ruby Environment">Chapter 1</a>.</p><p>Java is also compiled, rather than interpreted, generally using a special type of compilation called <span class="emphasis"><em>bytecode</em></span>, which is the same method that projects like Parrot, Python, and Ruby 2.0 use.<sup>[<a class="footnote" href="#ftn.APP-A-FNOTE-2" id="APP-A-FNOTE-2">39</a>]</sup> There is also an interesting project called <a class="indexterm" id="idx-CHP-A-1320"/>JRuby (<a class="ulink" href="http://jruby.codehaus.org">http://jruby.codehaus.org</a>), which is an implementation of Ruby written in Java. Java is described in greater detail at <a class="ulink" href="http://java.sun.com">http://java.sun.com</a>. The Java specification was written by Guy <a class="indexterm" id="idx-CHP-A-1321"/>Steele, although he didn’t create the language itself (fellow Lisper James Gosling did). When he wrote the Java specification, Steele already had the distinction of being the co-creator of Scheme, arguably the most conceptually pure version of <a class="indexterm" id="idx-CHP-A-1322"/>Lisp.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-A-FNOTE-2" id="ftn.APP-A-FNOTE-2">39</a>] </sup>You can read more about Parrot at <a class="ulink" href="http://www.parrotcode.org">http://www.parrotcode.org</a>; I’ll cover Python later in this appendix.<a class="indexterm" id="idx-CHP-A-1319"/></p></div></div></div>
<div class="sect1" title="Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="lisp"/>Lisp</h1></div></div></div><p>As one of Ruby’s most prominent ancestors, <span class="emphasis"><em>Lisp</em></span> deserves some space in this section. Lisp has been called “the most intelligent way to misuse a computer.”<sup>[<a class="footnote" href="#ftn.APP-A-FNOTE-3" id="APP-A-FNOTE-3">40</a>]</sup> It is properly understood as a family of languages or a language specification, rather than a single language. It is also diverse enough to resist many classification attempts, but for our purposes, the Lisps can be thought of mainly as functional languages with weak, dynamic typing. Renowned Lisper Paul Graham describes “What Made Lisp Different” at <a class="ulink" href="http://paulgraham.com/diff.html">http://paulgraham.com/diff.html</a>, and it’s interesting to note that Ruby shares all of these features except for Lisp’s peculiar syntax.</p><p>Lisp’s syntax (or lack thereof) is probably its most noteworthy feature, at first glance. Lisp code consists of bits of data bound by opening and closing parentheses. These bits are called <span class="emphasis"><em>lists</em></span>, and they give Lisp its name (which comes from <span class="emphasis"><em>LISt Processing</em></span>).<sup>[<a class="footnote" href="#ftn.APP-A-FNOTE-4" id="APP-A-FNOTE-4">41</a>]</sup> Having a syntax that is representable as a data structure within the language itself is Lisp’s most defining characteristic. Arguably, another language that implemented this same feature would not be a distinct language per se, but rather another dialect of Lisp.<sup>[<a class="footnote" href="#ftn.APP-A-FNOTE-5" id="APP-A-FNOTE-5">42</a>]</sup> A good argument can be made that Ruby tries to take concepts from Lisp and present them within a more user-friendly framework that also takes advantage of good ideas from object orientation, as well as good text manipulation. Matz has said, “Some may say Ruby is a bad rip-off of Lisp or Smalltalk, and I admit that. But it is nicer to ordinary people.”<sup>[<a class="footnote" href="#ftn.APP-A-FNOTE-6" id="APP-A-FNOTE-6">43</a>]</sup> Ruby owes much to Lisp, and along with many <a class="indexterm" id="idx-CHP-A-1329"/>other languages, it owes much of its powerful text manipulation to this next language, <a class="indexterm" id="idx-CHP-A-1330"/>Perl.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#APP-A-FNOTE-3" id="ftn.APP-A-FNOTE-3">40</a>] </sup>Dutch computer science Edsger <a class="indexterm" id="idx-CHP-A-1323"/>Dijkstra said this; you can find this and other interesting quotes compiled by Paul <a class="indexterm" id="idx-CHP-A-1324"/>Graham at <a class="ulink" href="http://www.paulgraham.com/quo.html">http://www.paulgraham.com/quo.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-A-FNOTE-4" id="ftn.APP-A-FNOTE-4">41</a>] </sup>Critics contend that this feature makes <a class="indexterm" id="idx-CHP-A-1325"/>Lisp a more appropriate acronym for <span class="emphasis"><em>Lots of Irritating Superfluous Parentheses</em></span>. Larry <a class="indexterm" id="idx-CHP-A-1326"/>Wall, the creator of <a class="indexterm" id="idx-CHP-A-1327"/>Perl, suggested that Lisp code has all the aesthetic appeal of “oatmeal with toenail clippings.” Clearly, Lisp has some public relations problems.</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-A-FNOTE-5" id="ftn.APP-A-FNOTE-5">42</a>] </sup>Relatedly, Philip <a class="indexterm" id="idx-CHP-A-1328"/>Greenspun’s tenth Rule of Programming at <a class="ulink" href="http://philip.greenspun.com/">http://philip.greenspun.com/</a> research is “Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp.”</p></div><div class="footnote"><p><sup>[<a class="para" href="#APP-A-FNOTE-6" id="ftn.APP-A-FNOTE-6">43</a>] </sup>This quote also comes from Paul Graham’s website, <a class="ulink" href="http://www.paulgraham.com/quotes.html">http://www.paulgraham.com/quotes.html</a>.</p></div></div></div>
<div class="sect1" title="Perl"><div class="titlepage"><div><div><h1 class="title"><a id="perl"/>Perl</h1></div></div></div><p><span class="emphasis"><em>Perl</em></span> is known by its mantra TMTOWTDI, and it is an extremely flexible and utilitarian language—one that has certainly had an impact on both Ruby and programming, in general. <span class="emphasis"><em>TMTOWTDI</em></span> stands for <span class="emphasis"><em>There’s More Than One Way To Do It</em></span>, which is a design philosophy that Perl certainly exemplifies. Its role in stressing the importance of regular expressions is enough to earn it a place in history. Perl was invented in 1987 by Larry Wall, and it was primarily intended to perform a role similar to that of Unix-centric languages like shell, awk, and sed. Perl focuses on ease of use for tasks like Unix system administration, and it is heavily used for web applications, as well. Perl’s initial design was procedural, but in recent years it has moved in an increasingly functional direction. It can also be used for object-oriented programming, a task for which it was never intended and for which it is not ideally suited—but the fact that this is even possible in Perl is a testament to its flexibility.</p><p>A new version of Perl is in the works (see the discussion of Pugs under Haskell), and it reminds me a great deal of Ruby. Coming from me, that is a compliment. Perl has weak dynamic typing, and like Ruby, it is interpreted. It has been called the <span class="emphasis"><em>swiss army chainsaw</em></span> and the <span class="emphasis"><em>Jeep</em></span> of programming languages, and it can be found at <a class="ulink" href="http://perl.com">http://perl.com</a>.<a class="indexterm" id="I_indexterm_d1e23292"/></p></div>
<div class="sect1" title="PHP"><div class="titlepage"><div><div><h1 class="title"><a id="php"/>PHP</h1></div></div></div><p><span class="emphasis"><em>PHP</em></span> is another interpreted language using weak dynamic typing that is very popular for web applications. In fact, some people erroneously believe that PHP is only usable for web applications. It is technically a complete, general-purpose programming language, although it has several features that make it more popular for web work. Many of the languages discussed here can be used in embedded code within web pages, provided that the code is marked off from the rest of the page with the appropriate tags. <a class="indexterm" id="idx-CHP-A-1331"/>PHP is unusual in that it must always be demarcated with such tags, even when it is used for command-line tasks that will never come near a webserver. It has weak, dynamic typing and is interpreted.<a class="indexterm" id="idx-CHP-A-1332"/></p><p>PHP and Ruby share the characteristic of having a relatively large number of built-in functions. Despite PHP’s general applicability, its primary focus is undoubtedly on making it easy for relatively inexperienced programmers to generate dynamic web content quickly. PHP’s web integration is such an important part of its most frequent use (if not its design) that it is often best compared to <a class="indexterm" id="idx-CHP-A-1333"/>other programming languages when combined with their own web integration systems, such Perl and Mason, or Ruby and eRuby or Rails. PHP’s creator Rasmus <a class="indexterm" id="idx-CHP-A-1334"/>Lerdorf began work on the project that would eventually become PHP in 1995. You can find out more about it at <a class="ulink" href="http://php.net">http://php.net</a>.</p></div>
<div class="sect1" title="Python"><div class="titlepage"><div><div><h1 class="title"><a id="python"/>Python</h1></div></div></div><p><span class="emphasis"><em>Python</em></span> is a language very similar to Ruby. Its creator, the “Benevolent Dictator For Life” Guido <a class="indexterm" id="idx-CHP-A-1335"/>van Rossum, named it after the British comedy troupe Monty Python when he invented it in the early 1990s. It has strong, dynamic typing very similar to Ruby’s and a similarly clean syntax, which is aided by its use of semantically significant whitespace. In Python, neither functions, blocks of code, nor statements need to have an explicit end-of-line mark (often a semicolon). Ruby’s use of ending markers is also quite minimal, although not to the same degree as Python’s is.<a class="indexterm" id="idx-CHP-A-1336"/></p><p>One area where Python and Ruby differ significantly is in flexibility. Python explicitly embraces the idea of <span class="emphasis"><em>There should be one—and preferably only one—obvious way to do it</em></span>, reporting this along with other ideas at Python’s interactive prompt when given the command <code class="literal">import this</code>.</p><p>Python and Ruby have an interesting relationship. Python has added several new features recently that borrow heavily from Ruby and Lisp, and at the time of this writing book sales for Ruby-related books also generally surpass those of Python-related books. Obviously, I hope those trends continue in relation to <span class="emphasis"><em>this</em></span> book. Python and Ruby seem like contentious siblings who will hopefully continue to challenge and inspire each other to excel. The Pythonistas live at <a class="ulink" href="http://python.org">http://python.org</a>.</p></div>
<div class="sect1" title="Smalltalk"><div class="titlepage"><div><div><h1 class="title"><a id="smalltalk"/>Smalltalk</h1></div></div></div><p><span class="emphasis"><em>Smalltalk</em></span> is a fully object-oriented programming language invented at Xerox PARC by a team led by Alan <a class="indexterm" id="idx-CHP-A-1337"/>Kay. While <a class="indexterm" id="idx-CHP-A-1338"/>Simula is generally recognized as the first object-oriented language, Smalltalk was instrumental in popularizing object orientation. Ruby borrows very extensively from Smalltalk in two major areas: the notion that everything is an object, and the concept of methods as messages that are passed to objects.<a class="indexterm" id="idx-CHP-A-1339"/></p><p>What does it mean to say that everything is an object? We’ve touched on this briefly in the Java discussion. In many languages, real “object” status is reserved for larger or more complicated things, while basic parts of the language are not considered objects. That’s why coders must invoke the <code class="literal">abs</code> method from within the Math namespace to get the absolute value of the integer 100 in Java. The <span class="emphasis"><em>Everything is an object</em></span> idea that Ruby inherited from Smalltalk is what allows the more consistent approach of asking the integer 100 to report its own absolute value. We explored the benefits of methods being implemented as messages also in the <code class="literal">to_lang.rb</code> script in <a class="xref" href="ch10.html" title="Chapter 10. More Complex Utilities and Tricks, Part II">Chapter 10</a>.</p><p>Check out Smalltalk at <a class="ulink" href="http://smalltalk.org">http://smalltalk.org</a> and <a class="ulink" href="http://squeak.org">http://squeak.org</a>.</p></div>
<div class="sect1" title="Summary of Ruby vs. Other Languages"><div class="titlepage"><div><div><h1 class="title"><a id="summary_of_ruby_vs_other_languages"/>Summary of Ruby vs. Other Languages</h1></div></div></div><p>To sum up, Ruby is interpreted, not compiled, making it fast to develop in and slow to run. It is object oriented and functional, not procedural. It has strong, dynamic typing, instead of either weak or static typing, and it only automatically casts type for Boolean tests. It has built-in regular expression support and a clean, readable syntax. It is a general-purpose programming language both in theory and in practice. It has a very large collection of built-in methods, and it allows you to add to, alter, and extend those methods easily. Like its ancestor Lisp, Ruby has a real, usable <code class="literal">nil</code> value, and it treats all values except for <code class="literal">nil</code> and <code class="literal">false</code> as <code class="literal">true</code>. Ruby is also very fun to program in, and it stays out of your way.<a class="indexterm" id="I_indexterm_d1e23406"/></p></div></body></html>