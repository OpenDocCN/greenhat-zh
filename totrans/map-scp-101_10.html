<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;MASHUP PROJECTS"><div class="titlepage"><div><div><h1 class="title"><a id="mashup_projects"/>Chapter 10. MASHUP PROJECTS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject10_d1e12229"/><img src="httpatomoreillycomsourcenostarchimages671943.png.jpg" alt="image with no caption"/></div></div><p>Throughout this book, I've demonstrated how to perform some common tasks with web maps and geographic data. Now I'll put many of these lessons together in example projects. The mashups in this chapter show how to retrieve, convert, and utilize external data sources.<a id="IDX-CHP-10-0001" class="indexterm"/></p><p>We'll also create interfaces that go beyond just showing a few locations on a map. Using events to capture clicks and mouse movements, we'll add some interactivity to the maps.</p><div class="sect1" title="What Is a Mashup?"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_mashup_question"/>What Is a Mashup?</h1></div></div></div><p>The Web is much more than a collection of interconnected documents. Millions of applications are creating, collecting, and consuming data all the time. When these applications talk to each other, sharing this data with application programming interfaces (APIs), the resulting feature is called a <span class="emphasis"><em>mashup</em></span>.</p><p>The name comes from music. Musically, a mashup is created when a DJ layers two or more songs together to make something new. This analogy describes what programmers and designers are creating with web mashups. They combine APIs to create something new, often an enlightening way of envisioning the underlying data.<a id="IDX-CHP-10-0002" class="indexterm"/><a id="IDX-CHP-10-0003" class="indexterm"/><a id="IDX-CHP-10-0004" class="indexterm"/><a id="IDX-CHP-10-0005" class="indexterm"/><a id="IDX-CHP-10-0006" class="indexterm"/><a id="IDX-CHP-10-0007" class="indexterm"/><a id="IDX-CHP-10-0008" class="indexterm"/><a id="IDX-CHP-10-0009" class="indexterm"/><a id="IDX-CHP-10-0010" class="indexterm"/><a id="IDX-CHP-10-0011" class="indexterm"/></p><p>We've been using a different type of API throughout this book. Maps, in addition to graphing and charting APIs, are used for visualizing data, either from your own or other APIs. Most APIs, however, are used to make data available to developers. Those that I'll use in this chapter provide publicly available location data.</p><div class="sect2" title="The Projects"><div class="titlepage"><div><div><h2 class="title"><a id="the_projects"/>The Projects</h2></div></div></div><p>The five projects in this chapter will get you started creating mashups. They were chosen for their conceptual diversity, so you can learn a number of techniques in this single chapter. Here's a brief overview of the projects:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Weather</strong></span></span></dt><dd><p>Just like your daily newspaper, this map shows weather conditions across the United States—only this weather map is interactive and updated each time the page loads. See <a class="ulink" href="http://mapscripting.com/weather">http://mapscripting.com/weather</a>.</p></dd><dt><span class="term"><span class="strong"><strong>Earthquakes</strong></span></span></dt><dd><p>You'll get geological and create a map showing last week's earthquakes plotted across the globe. Using the Richter scale measure of a quake's intensity, you can see where the big ones were and zoom in on the world's seismic hotspots. See <a class="ulink" href="http://mapscripting.com/earthquakes">http://mapscripting.com/earthquakes</a>.</p></dd><dt><span class="term"><span class="strong"><strong>Concerts</strong></span></span></dt><dd><p>Turn this mashup to 11! We'll create a tool to search a city or surrounding area for concerts. We'll even let users be frugal and declare their budget before searching. We'll filter only the results that match their criteria. See <a class="ulink" href="http://mapscripting.com/concerts">http://mapscripting.com/concerts</a>.</p></dd><dt><span class="term"><span class="strong"><strong>Twitter</strong></span></span></dt><dd><p>Help users find tweets near their location, or anywhere they search. Optionally, users can add a keyword to the search to zero in on both the <span class="emphasis"><em>what</em></span> and <span class="emphasis"><em>where</em></span> stored in Twitter status messages. See <a class="ulink" href="http://mapscripting.com/twitter">http://mapscripting.com/twitter</a>.</p></dd><dt><span class="term"><span class="strong"><strong>Midpoint search</strong></span></span></dt><dd><p>Meet in the middle! Just searching for coffee isn't enough. The final mashup shows you how to first find the midpoint of a route and then search for coffee near that midpoint. That way, you don't have to be the one to drive across town when you find a place to meet in the middle. See <a class="ulink" href="http://mapscripting.com/middle">http://mapscripting.com/middle</a>.</p></dd></dl></div><p>These five projects use many of the concepts you've learned earlier in this book. Complete them and you will definitely be on your way to map mashup mastery. Let the mashing begin!<a id="IDX-CHP-10-0012" class="indexterm"/><a id="IDX-CHP-10-0013" class="indexterm"/><a id="IDX-CHP-10-0014" class="indexterm"/></p></div></div></div>
<div class="sect1" title="#69: Create a Weather Map"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_69_colon_create_a_weather"/>#69: Create a Weather Map</h1></div></div></div><p>A big map with current conditions isn't just for your local meteorologist. Using the Yahoo! Weather API, you can make a visual forecast of a region, a country, or the whole world. In this example, I'll show how I created a US weather map with icons of current conditions marked for major regional cities.<a id="IDX-CHP-10-0015" class="indexterm"/></p><p>As you'll see, most of the effort to create the weather map involves manipulating data. Once the data is in a format that JavaScript can easily access, all we need is a basic map with some custom markers. Things get a little tricky when we zoom in on a city and show its forecast in an overlay, but even that should be a cinch for a map master like you. By the end of this project, your map will look like <a class="xref" href="ch10s02.html#complete_us_weather_map" title="Figure 10-1. Complete US weather map">Figure 10-1</a>.</p><div class="figure"><a id="complete_us_weather_map"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e12380"/><img src="httpatomoreillycomsourcenostarchimages672111.png.jpg" alt="Complete US weather map"/></div></div><p class="title">Figure 10-1. Complete US weather map</p></div><div class="sect2" title="Prepare a Basic US Map"><div class="titlepage"><div><div><h2 class="title"><a id="prepare_a_basic_us_map"/>Prepare a Basic US Map</h2></div></div></div><p>What are the essential elements of a web map? A center point and a zoom level. Okay, so you also need the HTML with a <code class="literal">div</code> for your map and some basic styles. Plus, you'll need to load some JavaScript files. Once that foundation is in place, however, you just need to <code class="literal">setCenterAndZoom</code>.</p><p>I decided early on that I only wanted to show the continental United States. Sorry Alaska and Hawaii—I'll make it up in the earthquake example later in this chapter. I arrived at the center and the zoom level with a little guess and check. Drag the map to where you want it and set the zoom to the perfect level. Then, call <code class="literal">getCenter</code> and <code class="literal">getZoom</code> (or do this automatically whenever the map is dragged).<a id="IDX-CHP-10-0016" class="indexterm"/></p><p>The center I arrived at has a latitude of 38 and a longitude of −98. Although not the exact center of the United States, it looked best. I chose a zoom level of four, which is enough to see major cities and highways. Here is the code to create the basic map that we'll build on in upcoming sections:</p><a id="I_programlisting10_d1e12411"/><pre class="programlisting">&lt;html &gt;
    &lt;head&gt;
      &lt;title&gt;Weather Map Mashup&lt;/title&gt;
      &lt;style&gt;
        div#mymap {
          width: 800px;
          height: 450px;
        }

      &lt;/style&gt;
❶     &lt;script src="http://ajax.googleapis.com/ajax/libs/
jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
      &lt;script type="text/javascript" src="http://maps.google.com/
maps/api/js?sensor=false"&gt;&lt;/script&gt;
      &lt;script src="mxn.js?(googlev3)"&gt;&lt;/script&gt;
      &lt;script type="text/javascript"&gt;
        var mapstraction;
❷       var center = new mxn.LatLonPoint(38,-98);
❸       var zoom = 4;

        function create_map() {
          mapstraction = new mxn.Mapstraction('mymap', 'googlev3');
          mapstraction.setCenterAndZoom(center, zoom);
          mapstraction.addControls({"zoom":"large"});

        }
      &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="create_map()"&gt;
      &lt;div id="mymap"&gt;&lt;/div&gt;

    &lt;/body&gt;
    &lt;/html&gt;t</pre><p>Most of this code likely looks familiar from other simple maps. We'll add to it soon but you can already spot signs that this code is looking ahead: I included <span class="emphasis"><em>jQuery</em></span> ❶, a JavaScript framework that makes applying effects and using Ajax to retrieve data easy. I also set <code class="literal">center</code> ❷ and <code class="literal">zoom</code> ❸ variables globally, so we'll be able to return users to the original view after zooming in.</p><p>The basic map, as seen in <a class="xref" href="ch10s02.html#basic_us_weather_map" title="Figure 10-2. Basic US weather map">Figure 10-2</a>, is now ready for markers. Before we can plot the weather conditions on the map, however, we'll need some data in an accessible format.</p><div class="figure"><a id="basic_us_weather_map"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e12431"/><img src="httpatomoreillycomsourcenostarchimages672113.png.jpg" alt="Basic US weather map"/></div></div><p class="title">Figure 10-2. Basic US weather map</p></div></div><div class="sect2" title="Convert Weather Results to JSON"><div class="titlepage"><div><div><h2 class="title"><a id="convert_weather_results_to_json"/>Convert Weather Results to JSON</h2></div></div></div><p>To make our map a mashup, we need some data, specifically current weather condition data. Yahoo! has an easy-to-use weather API that accepts a postal code or a proprietary location identifier. The result comes as GeoRSS, which is a plaintext XML file.<a id="IDX-CHP-10-0017" class="indexterm"/><a id="IDX-CHP-10-0018" class="indexterm"/><a id="IDX-CHP-10-0019" class="indexterm"/><a id="IDX-CHP-10-0020" class="indexterm"/><a id="IDX-CHP-10-0021" class="indexterm"/><a id="IDX-CHP-10-0022" class="indexterm"/></p><p>Let's look at an example call to the Yahoo! Weather API. To get the current conditions and forecast for Minneapolis, Minnesota, we fetch this URL: <a class="ulink" href="http://weather.yahooapis.com/forecastrss?p=USMN0503">http://weather.yahooapis.com/forecastrss?p=USMN0503</a>.</p><p>The bold portion of the URL is the location ID. The API will also accept a postal code, but in this example, we'll use the ID. When we plot the conditions on the map, I'll explain where to get the location IDs.</p><p>If you visit this URL, the result will look similar to this abbreviated version of the XML that is returned:</p><a id="I_programlisting10_d1e12475"/><pre class="programlisting">&lt;rss version="2.0" xmlns:yweather="http://xml.weather
.yahoo.com/ns/rss/1.0" &gt;
&lt;channel&gt;
...
&lt;item&gt;
&lt;title&gt;&lt;/title&gt;
&lt;geo:lat&gt;&lt;/geo:lat&gt;
&lt;geo:long&gt;&lt;/geo:long&gt;

&lt;/item&gt;&lt;/channel&gt;&lt;/rss&gt;</pre><p>Not to be too picky about the format of free data, but parsing XML with JavaScript can be troublesome, as I discussed in <a class="xref" href="ch08.html#number_symble_52_colon_use_xml" title="#52: Use XML">#52: Use XML</a> in <a class="xref" href="ch08.html#number_symble_52_colon_use_xml" title="#52: Use XML">#52: Use XML</a>. Many APIs now offer JavaScript Object Notation (JSON), a format that can be immediately plugged into JavaScript. Yahoo! Weather only provides XML, but another Yahoo! product can convert the data for us.</p><p>Yahoo! Pipes can perform many complex operations to merge, filter, and sort data. In this example, we won't be pushing the boundaries. All we want to do is read in XML from the API and output JSON. This is easy using Pipes. You could also use Yahoo! Query Language or run the XML through a process on your server. I'll show the second method in a project later in this chapter.<a id="IDX-CHP-10-0023" class="indexterm"/><a id="IDX-CHP-10-0024" class="indexterm"/></p><div class="sect3" title="Create a New Pipe"><div class="titlepage"><div><div><h3 class="title"><a id="create_a_new_pipe"/>Create a New Pipe</h3></div></div></div><p>Because all we have to do is convert from XML to JSON, we'll be creating about as simple a pipe as we can make. You can see a more in-depth version of this example in <a class="xref" href="ch08s06.html" title="#57: Convert from XML to JSON">#57: Convert from XML to JSON</a> in <a class="xref" href="ch08s06.html" title="#57: Convert from XML to JSON">#57: Convert from XML to JSON</a>, where you'll also find more advanced uses for Pipes.</p><p>From the Pipes home page at <a class="ulink" href="http://pipes.yahoo.com/">http://pipes.yahoo.com/</a>, click <span class="strong"><strong>Create a Pipe</strong></span> to get a brand new, empty pipe. On the left, you'll see pieces of "plumbing" that you can use. Drag a <span class="strong"><strong>Fetch Feed Source</strong></span> to the workspace. This point is where the data will flow in.</p><p>What is the feed's URL? We'll be making several calls to the Weather API, one for each city we want to look up. The calls will be routed through Pipes, which means the feed URL cannot be static. To accept input to the pipe, drag a <span class="strong"><strong>Text Input</strong></span> to the workspace. Name the input <span class="strong"><strong>location</strong></span>, and set the prompt to something like, <span class="strong"><strong>Enter a location</strong></span>. For default and debug values, use your postal code or city name. You could also use a location ID, such as the one for Minneapolis, <span class="strong"><strong>USMN0503</strong></span>. This helps you confirm the pipe is working.</p><p>Now that you've set up the text input to provide a location value, you're ready to create the URL. To merge the static and dynamic portions of the URL, we'll use one final piece of piping. Drag a <span class="strong"><strong>String Builder</strong></span> to the workspace. For a first value, add the beginning of the Weather API URL: <a class="ulink" href="http://weather.yahooapis.com/forecastrss?p=">http://weather.yahooapis.com/forecastrss?p=</a>.</p><p>Drag the output of the <span class="strong"><strong>Text Input</strong></span> to the second value of the <span class="strong"><strong>String Builder</strong></span>. This action will append the location ID to the end of the call to the Weather API. Now you have a complete feed URL. Drag the output of the <span class="strong"><strong>String Builder</strong></span> to the <span class="strong"><strong>Fetch Feed URL</strong></span> line. Finally, drag the <span class="strong"><strong>Fetch Feed</strong></span> output to the <span class="strong"><strong>Pipe Output</strong></span> at the bottom of the workspace.</p><p>You've just created a Yahoo! Pipe! The final product should look something like <a class="xref" href="ch10s02.html#complete_yahoo_exclamation_pipe_to_retri" title="Figure 10-3. Complete Yahoo! Pipe to retrieve weather data">Figure 10-3</a>. At the bottom of the screen in the Debug Output section, you should see some sample results based on the location you entered as the debug value for the Text Input.</p><p>To use your pipe, you need to save it. Once you've saved it, you can run it to retrieve more example results by entering different locations. From the sample results screen, click <span class="strong"><strong>Get as JSON</strong></span>. You may need to right-click (<span class="keycap">ctrl</span>-click on Mac) and copy the link. The Pipes URL will look something like this: <a class="ulink" href="http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&amp;_render=json&amp;location=USMN0503">http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&amp;_render=json&amp;location=USMN0503</a>.</p><div class="figure"><a id="complete_yahoo_exclamation_pipe_to_retri"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e12571"/><img src="httpatomoreillycomsourcenostarchimages672115.png.jpg" alt="Complete Yahoo! Pipe to retrieve weather data"/></div></div><p class="title">Figure 10-3. Complete Yahoo! Pipe to retrieve weather data</p></div><p>This URL will retrieve the weather conditions for Minneapolis in JSON format. Here is an abbreviated version of what it returns:<a id="IDX-CHP-10-0025" class="indexterm"/><a id="IDX-CHP-10-0026" class="indexterm"/><a id="IDX-CHP-10-0027" class="indexterm"/><a id="IDX-CHP-10-0028" class="indexterm"/></p><a id="I_programlisting10_d1e12596"/><pre class="programlisting">{"count":1,"value":{"items":[{"geo:long":"-93.26","geo:lat":"44.98",
"description":"&lt;img src=\"http:\/\/l.yimg.com\/a\/i\/us\/we\/52\/26.gif\"\/&gt;
&lt;br \/&gt;\n&lt;b&gt;Current Conditions:&lt;\/b&gt;&lt;br \/&gt;\nCloudy...","yweather:condition":
{"temp":"50","text":"Cloudy",...,"code":"26"}}]}</pre><p>That URL is what we'll use to get weather conditions for several cities, replacing the Minneapolis-specific location ID. In fact, that's what we're ready to do now that we've converted the XML results to JSON.</p></div></div><div class="sect2" title="Plot Conditions on the Map"><div class="titlepage"><div><div><h2 class="title"><a id="plot_conditions_on_the_map"/>Plot Conditions on the Map</h2></div></div></div><p>With our JSON feed ready to go, let's dive into the JavaScript to retrieve the weather conditions and plot them on our US map. First, you need to decide which cities to plot. I chose 11 prominent places, focusing on geographic diversity.</p><p>To gather the location IDs for my cities, I went to <a class="ulink" href="http://weather.yahoo.com/">http://weather.yahoo.com/</a> and typed each city name into the search box. The result forwards to a URL like this: <a class="ulink" href="http://weather.yahoo.com/forecast/USMN0503.html">http://weather.yahoo.com/forecast/USMN0503.html</a>.<a id="IDX-CHP-10-0029" class="indexterm"/></p><p>The part of the filename without the extension, the bold portion, is the location ID. Once I had the IDs for all of my cities, I created a variable at the top of my JavaScript to hold the values:</p><a id="I_programlisting10_d1e12617"/><pre class="programlisting">var weatherids = [
      "USIL0225", // Chicago
      "USTX0327", // Dallas
      "USCO0105", // Denver
      "USFL0316", // Miami
      "USMN0503", // Minneapolis
      "USTN0357", // Nashville
      "USNY0996", // New York City
      "USAZ0166", // Phoenix
      "USMO0787", // Saint Louis
      "USCA0987", // San Francisco
      "USWA0395" // Seattle
    ];</pre><p>The <code class="literal">weatherids</code> variable is an array, which holds a list of values. I spread the variable declaration over several lines to improve readability and make adding or removing cities easy. The city names are comments, so you can easily tell which location ID corresponds to which city.<a id="IDX-CHP-10-0030" class="indexterm"/><a id="IDX-CHP-10-0031" class="indexterm"/></p><p>When the map loads, we want to cycle through each city and look it up in our piped version of the Yahoo! Weather API. Add this loop code to the <code class="literal">create_map</code> function:</p><a id="I_programlisting10_d1e12637"/><pre class="programlisting">var pipeid = "Sbcb8u8J3hGNdOcopgt1Yg";for (var i=0; i &lt; weatherids.length; i++) {
  var pipeurl = "http://pipes.yahoo.com/pipes/pipe.run?_id=" + pipeid;
  pipeurl += "&amp;_render=json&amp;location=" + weatherids[i] + "&amp;_callback=?";
  jQuery.getJSON(pipeurl, add_weather);}</pre><p>The variable <code class="literal">i</code> holds the index of the array, which begins at zero and counts up to 10 (Nashville, the 11th item in the array). Each time through the loop, we create a URL to call our pipe using the location ID value of the current weather station.</p><p>To fetch the JSON from our pipe, we use jQuery, a small JavaScript framework. When we set up the basic map previously, we included a reference to the jQuery file, so we're all set; most of the work of creating the Ajax call is done for us by jQuery's <code class="literal">getJSON</code> function with the URL we just created.</p><p>In addition to the <code class="literal">location</code> parameter, we add a new argument to the URL, <code class="literal">_callback=?</code>. This security feature lets us get JSON from a site other than our own. Yahoo! Pipes will wrap the results so only our callback function has access to the data. The question mark is a holding place for the function, which we pass along as the second parameter for <code class="literal">getJSON</code>.</p><p>When jQuery gets results from the Weather API, those results are passed to our <code class="literal">add_weather</code> function, which we now need to write:</p><a id="I_programlisting10_d1e12666"/><pre class="programlisting">function add_weather(data) {
  jQuery.each(data.value.items, function(i, item) {
    var lat = item["geo:lat"];
    var lon = item["geo:long"];
    var code = item["yweather:condition"].code;
    var imgsrc = "http://l.yimg.com/a/i/us/we/52/" + code + ".gif;

    <strong class="userinput"><code>add_marker</code></strong>({"lat":lat, "lon":lon, "code":code, "imgsrc":imgsrc});
}</pre><p>The JSON data is automatically passed as a parameter to our callback function. In this case, I've used a variable called <code class="literal">data</code> to hold the response from the pipe. The weather conditions we want to get at are inside the first result of an array called <code class="literal">items</code>, which is itself inside an object named <code class="literal">value</code>. Sure, we've got some unnecessary overhead, but these are XML remnants.<a id="IDX-CHP-10-0032" class="indexterm"/><a id="IDX-CHP-10-0033" class="indexterm"/></p><p>The main data we need is latitude, longitude, and description. Wherever possible, I use JavaScript dot notation like <code class="literal">item.description</code>. Several field names in this feed contain a colon, which would be interpreted incorrectly with dot notation. In this case, I use the bracket notation to retrieve the properties from <code class="literal">item</code> instead.</p><p>Every weather condition has a numbered code that matches a particular description. The number allows machines to interpret a forecast easily without needing to parse text. The code is also used by Yahoo! Weather to call up the image designated for each condition. For example, a code of 30 means the sky is partly cloudy. The corresponding graphic is stored at <a class="ulink" href="http://l.yimg.com/a/i/us/we/52/30.gif">http://l.yimg.com/a/i/us/we/52/30.gif</a>. I piece together this image URL into the <code class="literal">imgsrc</code> variable.</p><p>Once we have the data we need, we wrap it inside an object with curly braces and pass it off to the <code class="literal">add_marker</code> function to do the work of plotting this marker on the map:</p><a id="I_programlisting10_d1e12710"/><pre class="programlisting">function add_marker(options) {
  var marker = new mxn.Marker(new mxn.LatLonPoint(options["lat"], options["lon"]));
  marker.setIcon(options["imgsrc"], [52,52]);
  marker.setShadowIcon('❶blankshadow.png', [0,0]);
  mapstraction.addMarker(marker);
}</pre><p>Why did I pass the data as a JavaScript object (the <code class="literal">options</code> variable) instead of individual parameters? You could use parameters, but four parameters would be a lot to pass along to a function. Every time we called it, we would need to double-check the order. Is description third or fourth? Also, JavaScript objects are commonly used to share data between JavaScript functions, so using them is good practice.</p><p>The rest of the <code class="literal">add_marker</code> function creates a straight-forward custom marker. The only line that might look strange is the shadow icon ❶, which I want to be empty. Because a shadowless marker is not an option, I used one transparent pixel for the shadow icon.</p><p>Now we have all the pieces to plot the conditions for our list of cities. Put them together and you have a complete weather map, with a little graphical representation of the current weather hovering above each city. Here's a brief recap of everything that happens as the mashup loads:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The HTML page is loaded, the <code class="literal">create_map</code> function is called, which sets up the basic map and calls the <code class="literal">get_weather</code> function for each location ID in the <code class="literal">weatherids</code> array.</p></li><li class="listitem"><p>The JSON is retrieved from the Yahoo! Pipe, the data gets passed to the <code class="literal">add_weather</code> function.</p></li><li class="listitem"><p>The important bits get extracted from the JSON into a JavaScript object, which is itself passed to the <code class="literal">add_marker</code> function.<a id="IDX-CHP-10-0034" class="indexterm"/><a id="IDX-CHP-10-0035" class="indexterm"/><a id="IDX-CHP-10-0036" class="indexterm"/></p></li><li class="listitem"><p>Custom markers are created and placed on the map.</p></li></ol></div><p>Now let's make this mashup a little more interactive. When the user clicks a marker, the map will zoom in on the forecast details for that location.</p></div><div class="sect2" title="Add a Forecast Details Pane"><div class="titlepage"><div><div><h2 class="title"><a id="add_a_forecast_details_pane"/>Add a Forecast Details Pane</h2></div></div></div><p>A visual representation of current conditions is great, but we cannot show much content from the Weather API. In this section, we'll add a Forecast Details pane. For added interactivity, we'll make the pane appear when the user clicks a marker, as shown in <a class="xref" href="ch10s02.html#forecast_pane_for_our_weather_map" title="Figure 10-4. Forecast pane for our weather map">Figure 10-4</a>.</p><div class="figure"><a id="forecast_pane_for_our_weather_map"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e12780"/><img src="httpatomoreillycomsourcenostarchimages672117.png.jpg" alt="Forecast pane for our weather map"/></div></div><p class="title">Figure 10-4. Forecast pane for our weather map</p></div><p>To start, we need to add the HTML shell for the new content. Right below the map <code class="literal">div</code>, add this line:</p><a id="I_programlisting10_d1e12790"/><pre class="programlisting">&lt;div id="forecast"&gt;&lt;/div&gt;</pre><p>Like the map, the shell is empty. We'll use JavaScript to load it with content. Because we want to overlay the forecast details on the map itself, we'll use CSS to position the new <code class="literal">div</code>. In the <code class="literal">&lt;style&gt;</code> section of the header, add these lines:<a id="IDX-CHP-10-0037" class="indexterm"/></p><a id="I_programlisting10_d1e12805"/><pre class="programlisting">div#forecast {
  position: relative;
  width: 200px;
  height: 400px;
  background-color: #fff;
  top: −435px;
  left: 550px;
  padding: 10px;
}</pre><p>This CSS creates a thin, tall, white box to the right side of the map. In fact, save your file, load it in a browser, and from Michigan east will be obscured with the box. That's certainly not what we want. We want the forecast pane only to show up when a city is selected. By default, we'll need to hide it.<a id="IDX-CHP-10-0038" class="indexterm"/></p><p>We can do that by adding this one line of jQuery to the <code class="literal">create_map</code> function:</p><a id="I_programlisting10_d1e12817"/><pre class="programlisting">$('#forecast').hide();</pre><p>Here we call the jQuery <code class="literal">hide</code> function on the forecast <code class="literal">div</code>. When the map is first loaded, the pane will be hidden, waiting for a user to click.</p><p>Now we can use Mapstraction to fill the Forecast Details pane with content. Rather than creating infoBubbles when a marker is clicked, we'll instead call <code class="literal">setInfoDiv</code> with the forecast data from the API.<a id="IDX-CHP-10-0039" class="indexterm"/></p><p>First, we actually need to get at that data. An entire description of the current conditions plus a forecast is passed from the Weather API in the description field. We need a fifth variable in the <code class="literal">add_weather</code> function. After the <code class="literal">imgsrc</code> line, add this:</p><a id="I_programlisting10_d1e12846"/><pre class="programlisting">var desc = item.description;</pre><p>Now you'll alter the call to <code class="literal">add_marker</code> by adding another option to the passed object:</p><a id="I_programlisting10_d1e12853"/><pre class="programlisting">add_marker({"lat":lat, "lon":lon, "code":code, "desc":desc, "imgsrc":imgsrc});</pre><p>Then you'll use the new value inside the <code class="literal">add_marker</code> function. Add this line before the call to <code class="literal">addMarker</code>:</p><a id="I_programlisting10_d1e12863"/><pre class="programlisting">marker.setInfoDiv(❶options["desc"] + "&lt;p&gt;&lt;a href=\"javascript:return_center()\"&gt;"
    + ❷"&lt;img src=\"usmap.png\" border=\"0\" alt=\"Return to full map\" /&gt;"
    + "&lt;/a&gt;&lt;/p&gt;", ❸"forecast");</pre><p>Here we set the Forecast Details pane to contain the description ❶ from the API, plus a clickable US map image ❷ that calls a new JavaScript function to return the map to the center and clear the Forecast Details pane. How does Mapstraction know which <code class="literal">div</code> to use? We pass its <code class="literal">id</code> as the second variable ❸.</p><p>To see the Forecast Details pane in action, we need to write code to show the hidden <code class="literal">div</code> when a marker is clicked. Add this line after the call to <code class="literal">addMarker</code>, as we'll be working with the marker object we've just created:</p><a id="I_programlisting10_d1e12881"/><pre class="programlisting">marker.click.addHandler(marker_clicked);</pre><p>Now we are listening for a click event on a marker and then responding with a function reference. Let's write the <code class="literal">marker_clicked</code> function, which will be called whenever any of our markers is clicked:<a id="IDX-CHP-10-0040" class="indexterm"/><a id="IDX-CHP-10-0041" class="indexterm"/></p><a id="I_programlisting10_d1e12895"/><pre class="programlisting">function marker_clicked(event_name, event_source, event_args) {
❹   mapstraction.setCenterAndZoom(event_source.location, 6);
    var bounds = mapstraction.getBounds();
    var diff = ((bounds.ne.lon − bounds.sw.lon)/4);
❺   mapstraction.setCenter(
      new mxn.LatLonPoint(mapstraction.getCenter().lat, bounds.ne.lon − diff));
❻   $('#forecast').show();
  });</pre><p>When any marker is clicked, we set it to the center of the map and zoom in ❹. We use the clicked marker's location as the center, which comes to the function via the <code class="literal">event_source</code> argument. Then, to account for the Forecast Details pane on the right side of the map, we shift the map center to the west ❺, so the marker will appear centered in the visible portion of the map. Finally, we make sure the Forecast Details pane is visible ❻.</p><p>Save your file and load it in a browser. Now you should be able to click a marker and zoom in to see the forecast. The only piece that isn't connected is the ability to zoom back out and see the whole contiguous United States again. To do this, we'll need to write the <code class="literal">return_center</code> function called whenever you click the US map.</p><p>Add this function to the JavaScript section:</p><a id="I_programlisting10_d1e12909"/><pre class="programlisting">function return_center() {
  mapstraction.setCenterAndZoom(center, zoom);
  $('#forecast').hide();
}</pre><p>This housekeeping function returns the map to its original center and zoom level and then hides the Forecast Details pane. Now we can see the whole US map again.</p><p>With the house cleaned, the mashup is complete. You pulled in data from Yahoo! Weather using Yahoo! Pipes to convert to JSON. Then you displayed the conditions for several cities, along with a descriptive graphic, on a map. Finally, upon clicking the marker, you zoomed the map into the city and displayed the forecast in its own overlaid info pane.</p><p>The best part, of course, is that you no longer need to read the weather page in the newspaper. You have an online, always-updating replacement.</p></div></div>
<div class="sect1" title="#70: Display Recent Earthquakes Worldwide"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_70_colon_display_recent"/>#70: Display Recent Earthquakes Worldwide</h1></div></div></div><p>Are you an aspiring geologist? Or maybe you're just looking for a quick way to see what's shaking in the world? In this mashup, I'll show you how to use a public data source to make sense of the world around you. We'll plot a week's worth of earthquakes, as tallied by the United States Geological Survey (USGS).<a id="IDX-CHP-10-0042" class="indexterm"/><a id="IDX-CHP-10-0043" class="indexterm"/></p><p>Lucky for us, the USGS logs earthquake data not just for the United States, but for the whole world. Even luckier for us, they're hip to the latest data formats. The organization publishes an XML feed that is geographically encoded as GeoRSS. It covers earthquakes that register 2.5 or greater on the Richter scale. That should still give us plenty of earthquakes to reveal some interesting trends on our map, as shown in <a class="xref" href="ch10s03.html#map_showing_recent_earthquakes_by_magnit" title="Figure 10-5. Map showing recent earthquakes by magnitude">Figure 10-5</a>.<a id="IDX-CHP-10-0044" class="indexterm"/></p><div class="figure"><a id="map_showing_recent_earthquakes_by_magnit"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e12942"/><img src="httpatomoreillycomsourcenostarchimages672119.png.jpg" alt="Map showing recent earthquakes by magnitude"/></div></div><p class="title">Figure 10-5. Map showing recent earthquakes by magnitude</p></div><p>You can load the feed into a web browser to view the content directly: <a class="ulink" href="http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml">http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml</a>.</p><p>Many browsers will display a "pretty" version by default. View its source to get a glimpse at all the data it sends along with it. Here is an abbreviated version of the XML file from the USGS:<a id="IDX-CHP-10-0045" class="indexterm"/><a id="IDX-CHP-10-0046" class="indexterm"/></p><a id="I_programlisting10_d1e12963"/><pre class="programlisting">&lt;feed xml:base="http://earthquake.usgs.gov/" 
      &gt;
&lt;title&gt;USGS M2.5+ Earthquakes&lt;/title&gt;
&lt;subtitle&gt;Real-time, worldwide earthquake list for the past 7 days&lt;/subtitle&gt;
&lt;entry&gt;
  &lt;id&gt;...&lt;/id&gt;
  &lt;title&gt;M 2.6, Washington&lt;/title&gt;
  &lt;updated&gt;YYYY-MM-DDTHH:MM:SSZ&lt;/updated&gt;
  &lt;link rel="alternate" type="text/html" href="/eqcenter/recenteqsww/Quakes/..."/&gt;
  &lt;summary type="html"&gt;...&lt;/summary&gt;
  &lt;georss:point&gt;46.4078 −119.2521&lt;/georss:point&gt;
&lt;/entry&gt;
&lt;entry&gt;
...
&lt;/entry&gt;
...
&lt;/feed&gt;</pre><p>That's some good stuff. Let's start using that data on our maps. First, we'll automatically parse GeoRSS, a feature that Mapstraction makes look easy. Then, if that basic visualization isn't enough, we'll create a completely custom solution.</p><div class="sect2" title="Show Earthquakes with GeoRSS"><div class="titlepage"><div><div><h2 class="title"><a id="show_earthquakes_with_georss"/>Show Earthquakes with GeoRSS</h2></div></div></div><p>Okay, you've chosen the quick version. You simply want to see these earthquakes get tossed up on a map. And you want to see this done using the fewest lines of code possible.</p><p>Add these very few lines to a new HTML file:</p><a id="I_programlisting10_d1e12974"/><pre class="programlisting">&lt;html &gt;
  &lt;head&gt;
    &lt;title&gt;Earthquake GeoRSS Map&lt;/title&gt;
    &lt;script src="http://maps.google.com/maps?file=api&amp;amp;v=2&amp;amp;key=
<em class="replaceable"><code>YOURKEY</code></em>" type="text/javascript"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="mxn.js?(google)"&gt;&lt;/script&gt;
    &lt;style type="text/css"&gt;
    div#mymap {
      width: 550px;
      height: 450px;
    }
    &lt;/style&gt;
    &lt;script type="text/javascript"&gt;
    var mapstraction;
    function create_map() {
      mapstraction = new mxn.Mapstraction('mymap', 'google');
      mapstraction.setCenterAndZoom(❶ new mxn.LatLonPoint(0, 0), 0);
      mapstraction.addControls({zoom: 'large'});
      <strong class="userinput"><code>mapstraction.addOverlay(</code></strong>
        <strong class="userinput"><code>"http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml");</code></strong>
      mapstraction.autoCenterAndZoom();
    }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="create_map()"&gt;
    &lt;div id="mymap"&gt;&lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre><p>As always, remember to use your own API key. Otherwise, the code is ready to go. Save and load it in a browser to see something similar to <a class="xref" href="ch10s03.html#earthquakes_shown_with_direct_georss_ove" title="Figure 10-6. Earthquakes shown with direct GeoRSS overlay">Figure 10-6</a>. The actual location of the markers will differ based on the past week's geological activity.<a id="IDX-CHP-10-0047" class="indexterm"/></p><div class="figure"><a id="earthquakes_shown_with_direct_georss_ove"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e12995"/><img src="httpatomoreillycomsourcenostarchimages672121.png.jpg" alt="Earthquakes shown with direct GeoRSS overlay"/></div></div><p class="title">Figure 10-6. Earthquakes shown with direct GeoRSS overlay</p></div><p>Did you catch all those zeroes on the line where we set the center and zoom ❶? Those aren't typos. A latitude of zero is the equator. A longitude of zero is roughly the international dateline, running through London. Finally, a zoom level of zero shows the whole world.</p><p>The money line, which loads the earthquake data, is shown in bold. Mapstraction's <code class="literal">addOverlay</code> function does most of the work. It creates dozens of markers and even adds infoBubble content to them. Unfortunately, the fun stops here. Once we outsource all that work to a single function, we've handcuffed our ability to make exactly what we want.<a id="IDX-CHP-10-0048" class="indexterm"/></p><p>To give this earthquake map our personal touches, we need to get deeper into the code. We need to go custom.</p></div><div class="sect2" title="Create a Custom Earthquake Map"><div class="titlepage"><div><div><h2 class="title"><a id="create_a_custom_earthquake_map"/>Create a Custom Earthquake Map</h2></div></div></div><p>If all you want to do is visualize where earthquakes are, using Mapstraction's built-in GeoRSS support gets the job done easily. On the other hand, if you want to prefilter content or show different icons based on quake intensity, you'll need a more custom solution.</p><p>In this section, I'll show you how to convert the GeoRSS to JSON using Yahoo! Query Language. Then you'll choose a marker icon based on the earthquake's Richter value. Finally, you'll get extra clever and zoom in on zones that usually have considerable earthquake activity.</p><p>To start, you need a basic view of the world on the map.</p><div class="sect3" title="Prepare Basic World Map"><div class="titlepage"><div><div><h3 class="title"><a id="prepare_basic_world_map"/>Prepare Basic World Map</h3></div></div></div><p>The basic map of the world doesn't need to be much different from the map in the GeoRSS version of the earthquake mapper. We need to load the map and then set a center and zoom level.</p><p>Add the following code to a new HTML file:</p><a id="I_programlisting10_d1e13030"/><pre class="programlisting">&lt;html &gt;
    &lt;head&gt;
      &lt;title&gt;Earthquake Map Mashup&lt;/title&gt;
      &lt;style type="text/css"&gt;
        div#mymap {
          width: 550px;
          height: 450px;
        }
      &lt;/style&gt;
❶     &lt;script type="text/javascript"
  src="http://ajax.googleapis.com/ajax/libs/jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
      &lt;script src="http://maps.google.com/maps?file=api&amp;amp;v=2&amp;amp;key=
<em class="replaceable"><code>YOURKEY</code></em>" type="text/javascript"&gt;&lt;/script&gt;
      &lt;script type="text/javascript" src="mxn.js?(google)"&gt;&lt;/script&gt;
      &lt;script type="text/javascript"&gt;
        var mapstraction;
❷       var defaultloc = {"point": new mxn.LatLonPoint(14.6048
47155053898, −177.1875),  "zoom": 1};

        function create_map() {
          mapstraction = new mxn.Mapstraction('mymap', 'google');
          mapstraction.setMapType(mxn.Mapstraction.HYBRID);
          mapstraction.addControls({"zoom":"large"});
          view_world();

        }
        function view_world() {
❸         mapstraction.setCenterAndZoom(defaultloc["point"], defaultloc["zoom"]);
        }
      &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="create_map()"&gt;
      &lt;div id="mymap"&gt;&lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;</pre><p>Save the file, load it into a browser, and you'll see a markerless map of the world, like <a class="xref" href="ch10s03.html#empty_map_of_the_world_comma_waiting_for" title="Figure 10-7. Empty map of the world, waiting for markers">Figure 10-7</a>. I've made a few changes to the code to look ahead as we customize the map. For one, I included jQuery ❶, the JavaScript framework that makes applying effects and using Ajax to retrieve data easy.</p><div class="figure"><a id="empty_map_of_the_world_comma_waiting_for"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e13042"/><img src="httpatomoreillycomsourcenostarchimages672123.png.jpg" alt="Empty map of the world, waiting for markers"/></div></div><p class="title">Figure 10-7. Empty map of the world, waiting for markers</p></div><p>I created an object variable to hold the default location and zoom level ❷, rather than individual variables. The values I chose were based on guessing and then checking to find a good location where the entire world would be visible and the location of the earthquakes would make the most sense. Because a world map is a two-dimensional view of a three-dimensional object, problems can crop up with where markers and polylines wrap. I chose the center of our basic map so our hotspot regions are completely within view globally.</p><p>Finally, I created an entire function ❸ to use the default center and zoom values. Later with this mashup, we'll zoom into those hotspot regions, but afterward we need a way to zoom back to the original center. We might as well reuse code where we can.<a id="IDX-CHP-10-0049" class="indexterm"/><a id="IDX-CHP-10-0050" class="indexterm"/><a id="IDX-CHP-10-0051" class="indexterm"/></p></div><div class="sect3" title="Convert Earthquake Data to JSON"><div class="titlepage"><div><div><h3 class="title"><a id="convert_earthquake_data_to_json"/>Convert Earthquake Data to JSON</h3></div></div></div><p>Now that the basic map is set up, we need to start thinking about data. The USGS provides an XML feed. JavaScript can parse XML, but we would need to download the XML to a server first for security reasons. If we can get the data as JSON, our job is so much easier.</p><p>We have a number of options for converting the earthquake data from XML to JSON. In the weather mashup, we used Yahoo! Pipes. In this case, we'll use another Yahoo! product, Yahoo! Query Language (YQL). Among many other uses of the technology YQL makes converting any GeoRSS feed to JSON easy.<a id="IDX-CHP-10-0052" class="indexterm"/></p><p>YQL's syntax is similar to SQL, the language used to query a database. You can try out commands in the YQL console at <a class="ulink" href="http://developer.yahoo.com/yql/console/">http://developer.yahoo.com/yql/console/</a>. Instead of querying a database table, we'll work against the USGS GeoRSS URL we used in the previous section. Here's the query to grab all the data from that feed:</p><a id="I_programlisting10_d1e13080"/><pre class="programlisting">select * from atom where
  url='http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml'</pre><p>Type that command in the YQL console, select the JSON output, and click the <span class="strong"><strong>Test</strong></span> button. As shown in <a class="xref" href="ch10s03.html#yql_console_showing_results_from_earthqu" title="Figure 10-8. YQL Console showing results from earthquake feed">Figure 10-8</a>, you'll see the results in the pane below. If you prefer to see a more structured view, click the <span class="strong"><strong>Tree View</strong></span> tab to peruse the data. From there, you can see the items we'll have available to us when we load the data into our map.</p><div class="figure"><a id="yql_console_showing_results_from_earthqu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e13095"/><img src="httpatomoreillycomsourcenostarchimages672125.png.jpg" alt="YQL Console showing results from earthquake feed"/></div></div><p class="title">Figure 10-8. YQL Console showing results from earthquake feed</p></div><p>Copy the long URL at the bottom of the console under The REST Query and store it somewhere. We'll use that URL in the next section.<a id="IDX-CHP-10-0053" class="indexterm"/><a id="IDX-CHP-10-0054" class="indexterm"/></p></div><div class="sect3" title="Plot Earthquakes on Map"><div class="titlepage"><div><div><h3 class="title"><a id="plot_earthquakes_on_map"/>Plot Earthquakes on Map</h3></div></div></div><p>As you've seen, simply plotting earthquakes on a map requires a single line call to a GeoRSS feed. That's too basic for us, however. The purpose of this mashup is to create something more customized. We want to provide a visual way to see the intensity of earthquakes at a glance by using bigger icons in places the Richter value is higher.<a id="IDX-CHP-10-0055" class="indexterm"/><a id="IDX-CHP-10-0056" class="indexterm"/></p><p>The following two JavaScript functions will load the data from the YQL JSON URL we found in the previous section, determine which icon to use, and plot the marker on the world map. Add this code to your basic map following the <code class="literal">create_map</code> function:</p><a id="I_programlisting10_d1e13128"/><pre class="programlisting">// Data and marker functions
  function get_quakes() {
❶   var jsonurl = "http://query.yahooapis.com/v1/public/yql"
    + "?q=select+*+from+atom+where+url%3D'http%3A%2F%2Fearthquake.usgs.gov"
    + "%2Feqcenter%2Fcatalogs%2F7day-M2.5.xml'"
    + "&amp;format=json&amp;diagnostics=true&amp;callback=?";
    jQuery.getJSON(jsonurl, function(data) {
❷     jQuery.each(data.query.results.entry, function(i, item) {
        // Get Lat/Lon point
        var lltxt = item.point;
❸       var llarr = lltxt.split(" ");
        // Get Richter value
        var richter = item.title;
❹       richter = richter.substr(2, 3);
        var majorrichter = richter.substring(0, 1);
        var iconvals = get_icon(majorrichter);
        // Find link
        var link;
        if (item.link[0]) {
          link = item.link[0].href;
        }
        else {
          link = item.link.href;
        }
        // Create marker
        var marker = new mxn.Marker(new mxn.LatLonPoint(llarr[0], llarr[1]));
        marker.setIcon(iconvals.name, iconvals.size);
❺       marker.setShadowIcon('blankshadow.png', [0,0]);
        var eqdate = item.updated.substr(0, 10);
❻       marker.setInfoBubble('&lt;strong&gt;' + item.title +
 '&lt;/strong&gt;&lt;p&gt;On ' + eqdate +  ' (&lt;a href="' + link + '"&gt;more info&lt;/a&gt;)&lt;/p&gt;');
        mapstraction.addMarker(marker);
      });
    });
  }
  function get_icon(majorrichter) {
    var identifier;
    var size;
    if (majorrichter &lt; 4) {
      identifier = "low";
      size = [10, 10];
    }
    else if (majorrichter == 4) {
      identifier = "med";
      size = [15, 15];
    }
    else {
      identifier = "high";
      size = [20, 20];
    }
    return {"name": "richter-" + identifier + ".png", "size": size};
  }</pre><p>The <code class="literal">get_quakes</code> function is actually a single line, but it's a really long line. It calls the <code class="literal">getJSON</code> function in jQuery. The JavaScript framework requires two variables to retrieve our JSON from YQL. The first is the URL to call. The second is a reference to a callback function. I used an anonymous, inline function. This callback function is what takes up most of the space in the <code class="literal">get_quakes</code> function.<a id="IDX-CHP-10-0057" class="indexterm"/><a id="IDX-CHP-10-0058" class="indexterm"/><a id="IDX-CHP-10-0059" class="indexterm"/><a id="IDX-CHP-10-0060" class="indexterm"/></p><p>The YQL URL ❶ is spread out over a few lines as a single, long string that is almost exactly the same as you copied from the YQL console. The only change is that the callback argument (the last part of the URL) is a question mark. By including a question mark, jQuery replaces it with the callback function for us.</p><p>Once we have a result, it is passed to the anonymous function as the <code class="literal">data</code> variable, which will be a JavaScript object. Within the object, <code class="literal">data.query.results.entry</code> refers to the array of all earthquake results. Using jQuery's <code class="literal">each</code> function ❷, we iterate through every result. Each earthquake is passed to yet another anonymous function.</p><p>For each earthquake, we first retrieve the geographic coordinates from the <code class="literal">point</code> value. As you may recall from the USGS XML, both the latitude and longitude are stored as a single value, with a space between. Our code splits them into two values ❸ and stores the result in an array. The first item in the array (with an index of zero) is the latitude; the second is the longitude.</p><p>Next, we need to find the Richter value. The <span class="emphasis"><em>Richter value</em></span> is the measurement of an earthquake's intensity and is usually given a decimal value less than 10. Unfortunately, the USGS does not directly pass this value, even though it's sitting right there in the title. For example, <code class="literal">M 2.6, Washington</code>. By sucking out a substring from the title, we can find the Richter value. In this case, we want 2.6 and nothing more.<a id="IDX-CHP-10-0061" class="indexterm"/></p><p>The Richter value begins at the third character in the string, which is referred to as <span class="emphasis"><em>slot two</em></span> because textual strings, like arrays, start counting at zero. Then the Richter value continues for three characters. So our call to <code class="literal">substr</code> ❹ begins at slot two and continues three characters. The value of the <code class="literal">richter</code> variable is now 2.6 in this example, just like we wanted.<a id="IDX-CHP-10-0062" class="indexterm"/><a id="IDX-CHP-10-0063" class="indexterm"/><a id="IDX-CHP-10-0064" class="indexterm"/><a id="IDX-CHP-10-0065" class="indexterm"/><a id="IDX-CHP-10-0066" class="indexterm"/></p><p>With the Richter value in hand, we can determine which icon to use by passing it to the <code class="literal">get_icon</code> function. I selected three levels and created a graphic for each of them. If an earthquake is relatively small, less than four, I assign it the smallest icon. If the earthquake is between four and five, it gets a medium-sized icon. Anything five and greater gets the largest icon. The icons are also colored differently among the levels, so the earthquake markers get bigger and redder with greater magnitude.</p><p>Using the latitude/longitude array that we split from the data, we create a marker for this earthquake. We give it a custom icon based on the Richter value, and then give it no shadow ❺. I used one transparent pixel for the shadow icon and set the width and height to be zero. As you'll see, our map will have so many earthquakes, we won't have room for shadows.</p><p>To finish, I added a very simple message inside the infoBubble ❻. The message shows the full title, the date, and a link to the page on the USGS site where the user can get more information about this earthquake.</p></div><div class="sect3" title="Create a Legend"><div class="titlepage"><div><div><h3 class="title"><a id="create_a_legend"/>Create a Legend</h3></div></div></div><p>In just a few lines, this map is easier to read than the one generated by the GeoRSS. The many earthquakes take up less space because of the smaller markers. We have shown that some earthquakes are more noteworthy than others by changing the size and color of the icons. Will the map make sense to someone who doesn't know the method to our Richter-based madness?</p><p>Let's create a legend, like the one shown in the finished map (<a class="xref" href="ch10s03.html#map_showing_recent_earthquakes_by_magnit" title="Figure 10-5. Map showing recent earthquakes by magnitude">Figure 10-5</a>), below the map to show what each icon means. Following the map <code class="literal">div</code>, add this ordered list, which describes the different icons:</p><a id="I_programlisting10_d1e13239"/><pre class="programlisting">&lt;ol id="legend"&gt;
  &lt;li&gt;&lt;img src="richter-low.png" /&gt; 2.5 − 3.9&lt;/li&gt;
  &lt;li&gt;&lt;img src="richter-med.png" /&gt; 4.0 − 4.9&lt;/li&gt;
  &lt;li&gt;&lt;img src="richter-high.png" /&gt; 5.0+&lt;/li&gt;
&lt;/ol&gt;</pre><p>We don't want the legend to look like an ordered list because that takes up too much space. Most of the time, something like this will be shown along one line. Enter a little CSS to make it look the way you want. Add this to your stylesheet:</p><a id="I_programlisting10_d1e13243"/><pre class="programlisting">ol#legend {
  list-style: none;
  margin: 0;
  padding: 0;
}
ol#legend li {
  display: inline;
  padding-right: 30px;
}</pre><p>Now the ordered list exists on a single line. Each list item is padded to the right, so which icon goes with which description is still obvious. Now that we've made it clear what the icons mean, let's add a little interactivity to this map.<a id="IDX-CHP-10-0067" class="indexterm"/><a id="IDX-CHP-10-0068" class="indexterm"/></p></div><div class="sect3" title="Zoom to Hotspot Regions"><div class="titlepage"><div><div><h3 class="title"><a id="zoom_to_hotspot_regions"/>Zoom to Hotspot Regions</h3></div></div></div><p>As you can tell from this mashup, some areas of the world are more seismically active than others. These spots are fairly predictable regions. Some, like California, may be more obvious than others. Due to the clustering of many markers in these areas, having a way to zoom in for a better view would be useful.</p><p>I identified four of these regions and created a system that makes adding others easy. In the variable section of your code, add these lines to create an object containing the regions' boundaries:</p><a id="I_programlisting10_d1e13262"/><pre class="programlisting">var regions = {
  "California": new mxn.BoundingBox(30, −136, 45, −101),
  "Alaska": new mxn.BoundingBox(48, 164, 68, −125),
  "Latin America": new mxn.BoundingBox(−47, −112, 24, −15),
  "Southeast Asia": new mxn.BoundingBox(−33, 52, 39, −167)
};</pre><p>At its most basic level, the <code class="literal">regions</code> variable holds text keys that correspond to Mapstraction <code class="literal">BoundingBox</code> objects. For our purposes, the key is a unique identifier for the region. The four numbers used to create the bounds are the minimum necessary to describe the region. The first pair describes the southwest corner of the box. The second describes the northeast corner. The other two corners of the box can be extrapolated from these values.</p><p>As the user mouses around the map, we want to determine when the cursor is hovering over one of these regions. If it is, we'll highlight the region by drawing a box around it. Then, if the user clicks, we'll zoom in to that region, like in <a class="xref" href="ch10s03.html#zoomed_into_an_earthquake_hotspot_region" title="Figure 10-9. Zoomed into an earthquake hotspot region">Figure 10-9</a>.</p><p>To achieve this, we need to listen for two events: mouse moving and clicking. Add these lines to your <code class="literal">create_map</code> function:</p><a id="I_programlisting10_d1e13281"/><pre class="programlisting">❶ google.maps.event.addListener(mapstraction.getMap(), 'mousemove', <strong class="userinput"><code>check_hover</code></strong>);
❷ mapstraction.click.addHandler(function() {
    if (highlighted) {
❸     <strong class="userinput"><code>set_region</code></strong>(highlighted);
    }
  });</pre><p>The first ❶ listens for mouse movement and highlights a region if the mouse is within its bounding box. We have to use Google's native <code class="literal">addListener</code> function, because the <code class="literal">mousemove</code> event is not supported by Mapstraction. An event object is passed along to the <code class="literal">check_hover</code> function.</p><div class="figure"><a id="zoomed_into_an_earthquake_hotspot_region"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e13303"/><img src="httpatomoreillycomsourcenostarchimages672127.png.jpg" alt="Zoomed into an earthquake hotspot region"/></div></div><p class="title">Figure 10-9. Zoomed into an earthquake hotspot region</p></div><p>Though we used a little Google-specific code, we are still able to use Mapstraction for everything else. The second ❷ event listens for a click somewhere on the map. If a region is already highlighted, it zooms in ❸ to give a closer look at the quakes.<a id="IDX-CHP-10-0069" class="indexterm"/><a id="IDX-CHP-10-0070" class="indexterm"/></p><p>Now let's write the two functions (in bold) that are called from our event code. First, we'll write the code to determine whether the mouse is hovering over any of our identified regions. Add this to your JavaScript:</p><a id="I_programlisting10_d1e13319"/><pre class="programlisting">// Region highlight functions
  var highlighted = "";
  function find_region(cpt) {
    for (var k in regions) {
      if (k != "World") {
❶       if (regions[k].contains(cpt)) {
          return k;
        }
      }
    }
    return "";
  }
  function check_hover(google_event) {
    // Google-specific code to convert event to Mapstraction LatLonPoint
    pt = new mxn.LatLonPoint(google_event.latLng.lat(), google_event.latLng.lng());
    // Mapstraction code to highlight appropriate region
    var regionin = find_region(pt);
    if (regionin) {
❷     if (highlighted != regionin) {
        highlighted = regionin;
        highlight_region(regionin);
      }
    }
❸   else if (highlighted) {
      highlighted = "";
❹     mapstraction.removeAllPolylines();
    }
  }</pre><p>In addition to the <code class="literal">check_hover</code> function, we also have a helper function. Together, this duo determines whether the user is hovering over a region and, if so, which region. The <code class="literal">find_region</code> function does most of this work. It loops through the region's array and compares the mouse's latitude/longitude to the four edges of the bounding box ❶ using the handy <code class="literal">contains</code> function.<a id="IDX-CHP-10-0071" class="indexterm"/></p><p>If the user is hovering over a region, the name of the region is returned to <code class="literal">check_hover</code>. Assuming we aren't already highlighting that region❷, we pass the name along to the <code class="literal">highlight_region</code> function, which draws the box. If the mouse is not over a region, but one was previously highlighted ❸, then we know the user moved the mouse outside of the region. Therefore, we can remove the box from the screen ❹.</p><p>We haven't created the function to add the box, so we'll do that now:</p><a id="I_programlisting10_d1e13345"/><pre class="programlisting">function highlight_region(name) {
    var bounds = regions[name];
    if (bounds) {
      mapstraction.removeAllPolylines();
❺     var pdata = {"color": "white"};
      var poly = BoundingBox_to_Polyline(bounds);
      mapstraction.addPolylineWithData(poly, pdata);
    }
  }
  function BoundingBox_to_Polyline(box) {
    var points = [box.sw, new mxn.LatLonPoint(box.ne.lat, box.sw. Lon),
                  box.ne, new mxn.LatLonPoint(box.sw.lat, box.ne.lon),
                  new mxn.LatLonPoint(box.sw.lat, box.sw.lon-.0001)];
    var poly = new mxn.Polyline(points);
    return poly;
  }</pre><p>The process of highlighting is fairly simple, though I have separated it into two functions. I have reprinted the second function, <code class="literal">BoundingBox_to_Polyline</code>, from <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a> in <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a>.</p><p>The box created in the <code class="literal">highlight_region</code> function uses a white polyline ❺. You may wish to change the polyline to another color. The rest is simply drawing the box on the map.</p><p>At this point, as a user moves the mouse around the map, regions will be highlighted. Now we need to make something happen when a user clicks while a region is highlighted. In other words, we need to set the current region and zoom in, fulfilling the second function called by the event listeners.<a id="IDX-CHP-10-0072" class="indexterm"/><a id="IDX-CHP-10-0073" class="indexterm"/></p><p>Add this to your JavaScript:</p><a id="I_programlisting10_d1e13371"/><pre class="programlisting">function set_region(name) {
  var bounds = regions[name];
  if (bounds) {
    mapstraction.setBounds(bounds);
  }
}</pre><p>Quite simply, if the region exists in our array, we set the map's boundaries to include only the selected region. The map zooms in and is centered to show the earthquakes in the region.</p><p>Now we need a way to get back to the world map. Very early on in this mashup, we created a <code class="literal">view_world</code> function. How do we call it? We'll use a graphic of the world and call the function whenever the image is clicked.</p><p>Adding this functionality is something that touches several sections of the mashup. So we need to include a few lines in a number of places. First, add the graphic to your HTML between the map and the legend:</p><a id="I_programlisting10_d1e13383"/><pre class="programlisting">&lt;a href="#" id="reset"&gt;&lt;img src="worldmap.png" /&gt;&lt;/a&gt;</pre><p>You can find this image, along with the marker icons I've used in this example at <a class="ulink" href="http://mapscripting.com/earthquake-mashup">http://mapscripting.com/earthquake-mashup</a>.</p><p>Next, we need to add some CSS so the graphic appears in the upper-right corner of our map:</p><a id="I_programlisting10_d1e13391"/><pre class="programlisting">#reset img {
  border: 5px solid white;
  position: relative;
  top: −435px;
  left: 430px;
}</pre><p>Let's use jQuery to respond to a user clicking the image. Add this code to the <code class="literal">create_map</code> function:</p><a id="I_programlisting10_d1e13398"/><pre class="programlisting">$("#reset").click(view_world);</pre><p>This retrieves the link element, which surrounds the image using CSS selector syntax and tells the browser to call the <code class="literal">view_world</code> function whenever that object is clicked.</p><p>If we weren't picky, we'd stop here. In a perfect world, the clickable graphic would only be visible when the map is zoomed in. Let's see if we can't make this world a little more perfect, again using some jQuery functions.<a id="IDX-CHP-10-0074" class="indexterm"/><a id="IDX-CHP-10-0075" class="indexterm"/><a id="IDX-CHP-10-0076" class="indexterm"/></p><p>Because we want the graphic to disappear whenever we're viewing the whole world, we'll need to add this line inside the <code class="literal">view_world</code> function:</p><a id="I_programlisting10_d1e13424"/><pre class="programlisting">$("#reset").hide();</pre><p>The image will now be invisible all the time. Of course, we want it to appear when we've zoomed in. Inside the <code class="literal">set_region</code> function, directly under the <code class="literal">setBounds</code> line, we add this line:</p><a id="I_programlisting10_d1e13434"/><pre class="programlisting">$("#reset").show();</pre><p>With that, we've incorporated a better interface into our interactive earthquake map. Zooming in by region is cool, as long as you can return to the map. We may not have made a perfect world, but this world map mashup is close to perfect.</p><p>We converted USGS data from XML to JSON. Then we read in every earthquake in the past week, determined its intensity, and gave it an appropriate icon. Finally, we implemented zooming into hotspot regions. The only thing left to do is monitor tectonic movements; at least now you have a tool to do that.</p></div></div></div>
<div class="sect1" title="#71: Search Music Events by Location"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_71_colon_search_music_even"/>#71: Search Music Events by Location</h1></div></div></div><p>Want to check out a concert tonight? Where shall we go and who's playing? This information is out there. Let's get our hands on it and plot it on a map.</p><p>For this mashup, we'll be using Yahoo!'s Upcoming API. Upcoming is an events calendar showing conferences, concerts, user group meetings, and more. We want to search only for music, an option made possible by using the API's tag-based search.</p><p>Unless we can count on users all being from the same city, we'll need to provide a way to search by location. Lucky us—that's also an option with Upcoming. Because some people are willing to drive farther than others, we also want users to be able to specify distance. Yep, that option is also supported.</p><p>Some people are more frugal than others. You may be willing to drop $75 to see an aging rocker, but I prefer to pay a small cover to see a local band at a bar. We'll need to plan for different price ranges. Alas, Upcoming does not directly support this option. We can query free concerts, but I'm not a total cheapskate; I'll pay five or ten bucks. Seeing as Upcoming does pass along ticket cost, however, we can handle price filtering ourselves.</p><p>This mashups requires a lot of features. You can see in <a class="xref" href="ch10s04.html#shows_within_25_miles_of_san_francisco" title="Figure 10-10. Shows within 25 miles of San Francisco">Figure 10-10</a> that they all come together nicely.</p><p>Now we have a game plan so let's jam! Before we get into the data itself, we'll get a feel for the interface we'll create for users.</p><div class="figure"><a id="shows_within_25_miles_of_san_francisco"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e13460"/><img src="httpatomoreillycomsourcenostarchimages672129.png.jpg" alt="Shows within 25 miles of San Francisco"/></div></div><p class="title">Figure 10-10. Shows within 25 miles of San Francisco</p></div><div class="sect2" title="Prepare HTML for Search Interface"><div class="titlepage"><div><div><h2 class="title"><a id="prepare_html_for_search_interface"/>Prepare HTML for Search Interface</h2></div></div></div><p>This being a map mashup, the map will be the center of our experience. The user will need to let us in on his or her whims regarding location and price. We'll need to put the search functions close to the map, so it's obvious that one controls the other.<a id="IDX-CHP-10-0077" class="indexterm"/></p><p>Open up a new file and add this code to create a basic map and form fields:</p><a id="I_programlisting10_d1e13477"/><pre class="programlisting">&lt;html &gt;
  &lt;head&gt;
    &lt;title&gt;Upcoming Music Map Mashup&lt;/title&gt;
❶   &lt;script type="text/javascript"
    src="http://ajax.googleapis.com/ajax/libs/jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="http://maps.google.com/maps?file=api&amp;amp;v=2&amp;amp;key=
<em class="replaceable"><code>YOURKEY</code></em>"  type="text/javascript"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="mxn.js?(google)"&gt;&lt;/script&gt;
    &lt;style type="text/css"&gt;
    div#mymap {
      width: 550px;
      height: 450px;
    }
    &lt;/style&gt;
    &lt;script type="text/javascript"&gt;
      var mapstraction;
      function create_map() {
        mapstraction = new mxn.Mapstraction('mymap', 'google');
        mapstraction.addControls({"zoom":"large"});
        mapstraction.setCenterAndZoom(new mxn.LatLonPoint(45.5, −122.5)❷, 10);
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="create_map();"&gt;
  &lt;p&gt;
  &lt;form onsubmit="<strong class="userinput"><code>search_upcoming()</code></strong>; return false;"&gt;
  Location: &lt;input type="text" name="location" value="Portland, OR"❸ size="20" /&gt;
  &lt;select name="radius" onchange="<strong class="userinput"><code>search_upcoming()</code></strong>;"&gt;
    &lt;option value="1"&gt;1 mile&lt;/option&gt;
    &lt;option value="5"❹&gt;5 miles&lt;/option&gt;
    &lt;option value="10"&gt;10 miles&lt;/option&gt;
    &lt;option value="25" selected="selected"&gt;25 miles&lt;/option&gt;
    &lt;option value="50"&gt;50 miles&lt;/option&gt;
  &lt;/select&gt;
  &lt;select name="cost" onchange="<strong class="userinput"><code>filter_select(this)</code></strong>;"&gt;
    &lt;option value="9999"❺&gt;Any price&lt;/option&gt;
    &lt;option value="25"&gt;$25 or less&lt;/option&gt;
    &lt;option value="10"&gt;$10 or less&lt;/option&gt;
  &lt;/select&gt;
  &lt;input type="submit" value="Search" /&gt;
  &lt;/form&gt;
  &lt;/p&gt;
  &lt;div id="mymap"&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;/html&gt;</pre><p>Much of this HTML will look familiar. As with most maps, I've loaded the Google Maps and Mapstraction JavaScript libraries. I also included jQuery ❶, which makes applying effects and using Ajax easy.<a id="IDX-CHP-10-0078" class="indexterm"/><a id="IDX-CHP-10-0079" class="indexterm"/><a id="IDX-CHP-10-0080" class="indexterm"/></p><p>The search location text defaults to Portland, Oregon, in this example. When the map first loads, it is centered on Portland. You can change the center to your city, but you'll need to edit multiple places. First, I used geographic coordinates ❷ to set the center. You've memorized these for your city now, right? Second, you need to change the value of the text field ❸. Of course, your user may edit the location, but starting with a logical default makes sense. For me, I used my hometown.</p><p>The radius and cost fields are drop-down boxes. The values hold the maximums. For example, if you choose a radius of five miles ❹, nothing even a foot farther than five miles will show in the results. The same goes for price values. For the option of showing results regardless of cost ❺, we're hoping no concert is charging more than $9,999.</p><p>Creating the basic interface for a mashup, as we have here, can help you figure out everything you need to do. Look back at the code listing and note the function names in bold. You need to write those—one to search and another to filter—at the very least to be able to convert this interface into a working mashup.<a id="IDX-CHP-10-0081" class="indexterm"/><a id="IDX-CHP-10-0082" class="indexterm"/></p><p>Before we start building the functions we need, let's look at the data we'll be using. To do that, we need to become familiar with the Upcoming API.</p></div><div class="sect2" title="Perform an Upcoming API Search"><div class="titlepage"><div><div><h2 class="title"><a id="perform_an_upcoming_api_search"/>Perform an Upcoming API Search</h2></div></div></div><p>Upcoming uses a REST API, which means we can play around with it in the browser before coding anything. As a first step, you need a Yahoo! account to sign into Upcoming. Then, you need to get an Upcoming API key. This key is different than ones you've used for any other Yahoo! service.<a id="IDX-CHP-10-0083" class="indexterm"/></p><p>While logged into Upcoming, request a key here: <a class="ulink" href="http://upcoming.yahoo.com/api/url">http://upcoming.yahoo.com/api/url</a>.</p><p>Now that you have an API key, try out this Upcoming search by copying this URL into your browser: <a class="ulink" href="http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&amp;method=event.search&amp;location=Portland,+OR">http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&amp;method=event.search&amp;location=Portland,+OR</a>.</p><p>Here is a sample of the results from this simple search:</p><a id="I_programlisting10_d1e13544"/><pre class="programlisting">&lt;rsp stat="ok" version="1.0" resultcount="12"&gt;
&lt;event id="1234567" name="Some Band Name" description="..."
start_date="2011-04-15" latitude="45.5409" longitude="-122.6637"
geocoding_precision="address" geocoding_ambiguous="0"
venue_name="Wonder Ballroom" venue_address="128 NE Russell St"
venue_city="Portland" venue_state_name="Oregon" venue_state_code="OR"
venue_zip="97212" ticket_url="..." ticket_price="$25-$40" ticket_free="0" /&gt;
&lt;event .... /&gt;
...
&lt;/rsp&gt;</pre><p>The search term has merely restricted to a location. We need to add more options to the search before it will find the data we seek. See <a class="xref" href="ch10s04.html#upcoming_api_event_search_option" title="Table 10-1. Upcoming API Event Search Option">Table 10-1</a> for a description of the arguments we'll use. Many more are listed in Upcoming's documentation.</p><div class="table"><a id="upcoming_api_event_search_option"/><p class="title">Table 10-1. Upcoming API Event Search Option</p><div class="table-contents"><table summary="Upcoming API Event Search Option" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Argument</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">api_key</code></p></td><td style="text-align: left" valign="top"><p>Your API key (required)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">location</code></p></td><td style="text-align: left" valign="top"><p>City and state to search for events</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">radius</code></p></td><td style="text-align: left" valign="top"><p>How far away from center of location to search</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">min_date</code></p></td><td style="text-align: left" valign="top"><p>What date to start searching for events</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">max_date</code></p></td><td style="text-align: left" valign="top"><p>What date to stop searching for events</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">tags</code></p></td><td style="text-align: left" valign="top"><p>The metadata keywords to filter results</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Retrieve Event Data Server-Side"><div class="titlepage"><div><div><h2 class="title"><a id="retrieve_event_data_server-side"/>Retrieve Event Data Server-Side</h2></div></div></div><p>Now that we know what to expect from the Upcoming API, we're ready to connect to it. Rather than use JavaScript to get directly at the data, we'll run the data through a server-side PHP script. If you're unsure about whether you have PHP or how to use it, go check out <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a>.<a id="IDX-CHP-10-0084" class="indexterm"/><a id="IDX-CHP-10-0085" class="indexterm"/><a id="IDX-CHP-10-0086" class="indexterm"/></p><p>We're using PHP to pass the results to JavaScript for two reasons: First, we have to take into account security issues with accessing outside APIs directly with JavaScript. In many cases, browsers won't allow it. Second, we can do some preprocessing to the data. We need to find the concert cost and put the price in a format that will make filtering results easier. Also, even though the API provides XML, we'll output as JSON with the server-side script. JSON can be read directly into a JavaScript object, which again will make our lives easier.<a id="IDX-CHP-10-0087" class="indexterm"/><a id="IDX-CHP-10-0088" class="indexterm"/></p><p>The PHP code we'll use to access the Upcoming API is about 60 lines long. Rather than display it all at once, I'll go through one section at a time. That way I can describe what's happening, and you'll understand each piece before moving on to the next.</p><p>To start, let's create a new PHP file on your server and retrieve arguments from the query string:</p><a id="I_programlisting10_d1e13647"/><pre class="programlisting">&lt;?php
  $apikey = "<em class="replaceable"><code>YOURKEY</code></em>";
  $dateformat = "Y-m-d";
  // Get arguments from querystring
  <strong class="userinput"><code>$location = $_GET["location"];</code></strong>
  <strong class="userinput"><code>$radius = $_GET["radius"];</code></strong>
  <strong class="userinput"><code>$timeframe = $_GET["timeframe"];</code></strong>
  <strong class="userinput"><code>$tags = $_GET["tags"];</code></strong>
  // Determine the timeframe as a timestamp, set max/min date variables
❶ $mindate = date($dateformat);
  $maxdate = "";
  switch($timeframe) {
    case "1d":
      $timestamp = ❷time();
      break;
    case "1m":
      $timestamp = strtotime("+1 month −1 day");
      break;
    case "1w":
    default:
      $timestamp = ❸strtotime("+1 week −1 day");
      break;
  }
❹ $maxdate = date($dateformat, $timestamp);</pre><p>Even though we're using someone else's API, writing a middleman PHP script like this is sort of like creating our own API. Most of our query string arguments (in bold) will be passed unchanged to Upcoming. The <code class="literal">timeframe</code> argument, however, is my own creation.</p><p>This argument specifies how far in the future to search. This simple version allows three options: one day (<code class="literal">1d</code>), one week (<code class="literal">1w</code>), and one month (<code class="literal">1m</code>). Because Upcoming does not have this option, we need to convert the timeframe to a maximum date by finding the timestamp that represents a day in the future.<a id="IDX-CHP-10-0089" class="indexterm"/><a id="IDX-CHP-10-0090" class="indexterm"/></p><p>We already set the minimum date to be today ❶. PHP's <code class="literal">date</code> function, if a second argument isn't included, assumes the current date. We can achieve the same result by passing <code class="literal">time()</code> as the second argument. In fact, with a timeframe of one day, we simply set the timestamp equal to <code class="literal">time()</code> ❷. That leaves the minimum date as today and the maximum date as today, just like we want.</p><p>In the case of a week or month, we need to do a little date math. PHP has a <code class="literal">strtotime</code> function that takes many different types of input. In this example ❸, the function starts at today and adds a week. Then it subtracts a day. Why? Because otherwise we'd have eight days, which is more than a week. The same is true of the month option.</p><p>Finally we convert our timeframe to a timestamp format the computer understands. Now all we need is to set the <code class="literal">$maxdate</code> variable by passing the <code class="literal">timeframe</code> to the <code class="literal">date</code> function ❹.</p><p>Now that we've figured out all the variables that we're sending to the Upcoming API, we're ready for the next bit of code. In this section, we actually retrieve data and preprocess it:</p><a id="I_programlisting10_d1e13716"/><pre class="programlisting">// Get XML results from Upcoming
❺ $url = "http://upcoming.yahooapis.com/services/rest/?api_key=$apikey";
  $url .= "&amp;method=event.search&amp;location=$location&amp;radius=$radius";
  $url .= "&amp;tags=$tags";
  $url .= "&amp;max_date=$maxdate&amp;min_date=$mindate";
❻ $xmlobj = get_xml($url);
  $outobj = array();
  // Loop through results
  foreach (❼$xmlobj-&gt;event as $event) {
❽   $attribs = $event-&gt;attributes();
    $id = (int) $attribs-&gt;id;
    $lat = (float) $attribs-&gt;latitude;
    $lon = (float) $attribs-&gt;longitude;
    $title = (string) $attribs-&gt;name;
    $date = (string) $attribs-&gt;start_date;
    $cost = "";
    // Convert ticket price range into number value we can use in JavaScript
❾   preg_match_all("(\\\$\d+)", (string) $attribs-&gt;ticket_price, $dollars);
    if (count($dollars) &gt; 0 &amp;&amp; count($dollars[0]) &gt; 0) {
      $cost = $dollars[0][count($dollars[0])-1];
    }
    $cost = str_replace("$", "", $cost);
    // Put all results into an array of associative arrays
    $eventobj = array(
      "id" =&gt; $id,
      "latitude" =&gt; $lat,
      "longitude" =&gt; $lon,
      "title" =&gt; $title,
      "date" =&gt; $date,
      "cost" =&gt; $cost
    );
❿   array_push($outobj, $eventobj);
  }</pre><p>Using the variables we created in the previous section, we piece together the URL to call Upcoming's API ❺. The content from the URL will come through as XML, which we convert into a <code class="literal">SimpleXML</code> object. In <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a> in <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a>, we wrote the <code class="literal">get_xml</code> function to perform this task. We might as well save ourselves some time and reuse that function here ❻.<a id="IDX-CHP-10-0091" class="indexterm"/><a id="IDX-CHP-10-0092" class="indexterm"/><a id="IDX-CHP-10-0093" class="indexterm"/></p><p>With the XML now easily accessible, let's loop through all the events that the Upcoming API returned. We'll grab each <code class="literal">&lt;event&gt;</code> tag ❼ one at a time. The data about the event is stored as the event tag's attributes. We can grab all the attributes at once ❽ and then pick and choose only the ones we want: the unique <code class="literal">id</code> assigned by Upcoming, latitude, longitude, the event's title, its date, and its cost. Most of these are straightforward, but we'll need to do a little voodoo to get the price of the event in the format we want.</p><p>Upcoming includes a dollar sign in front of the ticket price, and many events have a price range instead of a single amount. To filter by the cost in our JavaScript code, we need our PHP code to return a simple number.</p><p>Here, I used a regular expression to look for all instances of a dollar sign followed by one or more digits ❾. This way, we can take the last dollar amount, which should be at the highest end of the range if one exists. If tickets are just one price, the expression will find that, too. Finally, we remove the dollar sign, so we return only a number.</p><p>Now that we have the data from the event we need, we put it into an associative array, <code class="literal">$eventobj</code>. That new array then gets "pushed" onto the end of the results object ❿, which is a normal array. I've named the results object <code class="literal">$outobj</code> because we'll print it. In fact, with all the preprocessing complete, we can do that now:</p><a id="I_programlisting10_d1e13762"/><pre class="programlisting">// Output values as JSON
print header("Content-type: application/json");
print json_encode($outobj);
?&gt;</pre><p>We first print the header to declare that we're sending plain text. PHP defaults to HTML. Next, we print out the results object, but we make sure it is JSON-encoded. That way, we're giving our JavaScript code something easy to digest.</p><p>Remember when we used the <code class="literal">get_xml</code> function to retrieve the Upcoming URL and convert the XML content to a <code class="literal">SimpleXML</code> object? We never actually included the function in our code. Let's do that now:</p><a id="I_programlisting10_d1e13774"/><pre class="programlisting">&lt;?
//cUrl functions
function get_url($url) {
  $c = curl_init();
  curl_setopt($c, CURLOPT_URL, $url);
  curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);
  $content = trim(curl_exec($c));
  curl_close($c);
  return $content;
}
function get_xml($url) {
  $xml = get_url($url);
  return simplexml_load_string($xml);
}
?&gt;</pre><p>Hey! That's two functions!<a id="IDX-CHP-10-0094" class="indexterm"/><a id="IDX-CHP-10-0095" class="indexterm"/><a id="IDX-CHP-10-0096" class="indexterm"/><a id="IDX-CHP-10-0097" class="indexterm"/></p><p>You caught me. Because one calls the other, we need to include them both. If you find yourself using these functions often, adding them to their own file is probably worthwhile. Then you can make them part of your project as needed with the PHP <code class="literal">include</code> function.</p><p>And that's that. We've written some PHP to call the Upcoming API. From the XML returned by Upcoming, we take only the stuff we want and output it as JSON. I saved the PHP file as <span class="emphasis"><em>upcoming.php</em></span> in the same directory as the HTML search interface we created earlier. Now let's return to that HTML file, so we can use JavaScript to connect to our newly created PHP file.</p></div><div class="sect2" title="Plot Event Search Results on a Map"><div class="titlepage"><div><div><h2 class="title"><a id="plot_event_search_results_on_a_map"/>Plot Event Search Results on a Map</h2></div></div></div><p>Now that you know how to get data from Upcoming, let's put that data on our map. We'll connect to the PHP file we just created, sending it the information it needs.</p><p>You may recall from setting up the HTML that we need to create two functions. First, we write the <code class="literal">search_upcoming</code> function to perform the Ajax call to our PHP. Add these lines in the JavaScript below the <code class="literal">create_map</code> function:</p><a id="I_programlisting10_d1e13819"/><pre class="programlisting">function search_upcoming() {
❶   var tags = "music,concert";
    var timeframe = "1w";
❷   var data = {
      "location": f.location.value.replace(", ", ",").replace(" ", "_"),
      "radius": f.radius.value,
      "tags": tags,
      "timeframe": timeframe
    };
❸   $.get("upcoming.php", data, ❹plot_upcoming);
  }</pre><p>Before we can search Upcoming, we need to retrieve the user's values from the form. To do this, I used the <code class="literal">document.getElementById</code> function, doing a little data cleanup for the location.</p><p>I hard-coded some values that are options in our PHP file that we don't currently use as input from the user. For example, the tags ❶ that we look for can be changed to something else if you aren't looking for concerts. The timeframe defaults to one week, which seems the most useful for planning impromptu entertainment.<a id="IDX-CHP-10-0098" class="indexterm"/></p><p>The values that I hard-coded, plus a couple from the form, are put into a JavaScript object ❷. The jQuery <code class="literal">getJSON</code> function ❸ that calls our PHP file using the <code class="literal">data</code> variable to include values requires this format. The last parameter is a function reference to <code class="literal">plot_upcoming</code> ❹. That's one we need to write.</p><p>In this new function, we want to loop through all the results in the JavaScript object. As we find each event, we plot it on the map. Add this code to your JavaScript:</p><a id="I_programlisting10_d1e13844"/><pre class="programlisting">function plot_upcoming(jobj) {
    if (jobj.length &gt; 0) {
      mapstraction.removeAllMarkers();
❺     for (var i=0; i &lt; jobj.length; i++) {
        var ev = jobj[i];
❻       var url = "http://upcoming.yahoo.com/event/" + ev.id;
        var marker = new mxn.Marker(new mxn.LatLonPoint(ev.latitude, ev.longitude));
        var cost = ev.cost;
        if (cost != "") {
❼         marker.setAttribute('cost', parseInt(cost));
          cost = " ($" + cost + ")"; // Format cost for infoBubble
        }
        else {
          marker.setAttribute('cost', 9999); // Set a way too high value
        }
        var bubbletext = ev.date + " &lt;a href=\"" + url + "\"&gt;" + ev.title
                         + "&lt;/a&gt;" + cost;
        marker.setInfoBubble(bubbletext);
        mapstraction.addMarker(marker);
      }
❽     filter_select(document.forms[0].cost);
    }
    else {
      alert('no results for this search');
    }
  }</pre><p>This function unpacks the variables that are output by the PHP and uses them to add a marker for every Upcoming event the API returned. Remember, we used an array holding many associative arrays. The JavaScript object is also an array. We iterate through it with the <code class="literal">for</code> command ❺, putting each event result into the <code class="literal">ev</code> variable.</p><p>Using the <code class="literal">id</code> returned from Upcoming, we can piece together the URL ❻ where the user can find out more information about the event. Other data, like the latitude and longitude, we put directly into variables that we use to create the marker.</p><p>If the PHP was able to determine the cost of the event, we add an attribute to the marker with that information ❼. This information will be useful when we filter by ticket price. In fact, at the end of this function, once all the markers have been added to the map, we call that filter function ❽, which means we better go write it.<a id="IDX-CHP-10-0099" class="indexterm"/><a id="IDX-CHP-10-0100" class="indexterm"/><a id="IDX-CHP-10-0101" class="indexterm"/><a id="IDX-CHP-10-0102" class="indexterm"/><a id="IDX-CHP-10-0103" class="indexterm"/><a id="IDX-CHP-10-0104" class="indexterm"/><a id="IDX-CHP-10-0105" class="indexterm"/></p></div><div class="sect2" title="Filter Results by Ticket Price"><div class="titlepage"><div><div><h2 class="title"><a id="filter_results_by_ticket_price"/>Filter Results by Ticket Price</h2></div></div></div><p>When the results are returned, they contain all the music events in an area, not just the ones that match the user's budget. The Upcoming API has no way to query for events under a specific ticket price, though it does provide the price in the results, if available. The PHP we wrote takes the ticket price and produces a numeric cost that we can use as a filter.</p><p>In the previous section, we added a <code class="literal">cost</code> attribute for every marker containing the ticket price. Just having the attribute is not enough to remove overpriced concerts. We also need to apply the filter, which comes from a drop-down box in the HTML form.</p><p>The <code class="literal">filter_select</code> function is called when all the markers are added to the page, or whenever the value in the drop-down box changes. Add these functions to your JavaScript code:</p><a id="I_programlisting10_d1e13906"/><pre class="programlisting">function filter_select(selobj) {
❶   var cost = parseInt(selobj.options[selobj.selectedIndex].value);
    filter_cost(cost);
  }
  function filter_cost(amt) {
❷   mapstraction.removeAllFilters();
    mapstraction.addFilter('cost', ❸'le', amt);
    mapstraction.doFilter();
❹   mapstraction.visibleCenterAndZoom();
  }</pre><p>As with other examples, two functions perform this one task. The first retrieves the value from the drop-down box ❶ and then passes the cost to the second. The <code class="literal">filter_cost</code> function does the actual filtering work.</p><p>Before creating a new filter, we need to remove any previous filters ❷. Why? Mapstraction's filtering is additive, meaning a second filter does not replace the first, but instead is applied in addition to the first. In this case, we only want to use a single filtering method, we remove all filters before adding new ones.</p><p>To apply a filter requires three pieces of information: the attribute to be filtered by, the operator to use (in this case <code class="literal">le</code> for less than or equal to ❸), and finally the value to compare. Markers don't actually get filtered until Mapstraction's <code class="literal">doFilter</code> function is called.</p><p>Now with only the markers matching our filter being displayed, we can make sure they're all visible on the map. Mapstraction has a function specifically for situations like this ❹. We don't want to set the center and zoom based on all the markers; we simply want to use the visible markers.</p><p>These filtering functions are called from our mashup whenever the user searches for concerts. We also save a little bandwidth whenever the user changes the value in the ticket price drop-down box. Because we've stored concerts for all price ranges, we call these filtering functions to show only the ones that match, as shown in <a class="xref" href="ch10s04.html#filtered_results_show_only_concerts_that" title="Figure 10-11. Filtered results show only concerts that match the search">Figure 10-11</a>.<a id="IDX-CHP-10-0106" class="indexterm"/><a id="IDX-CHP-10-0107" class="indexterm"/></p><div class="figure"><a id="filtered_results_show_only_concerts_that"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e13940"/><img src="httpatomoreillycomsourcenostarchimages672131.png.jpg" alt="Filtered results show only concerts that match the search"/></div></div><p class="title">Figure 10-11. Filtered results show only concerts that match the search</p></div><p>If you look back to <a class="xref" href="ch10s04.html#shows_within_25_miles_of_san_francisco" title="Figure 10-10. Shows within 25 miles of San Francisco">Figure 10-10</a>, you can see all the results for concerts within 25 miles of San Francisco. Then, in <a class="xref" href="ch10s04.html#filtered_results_show_only_concerts_that" title="Figure 10-11. Filtered results show only concerts that match the search">Figure 10-11</a>, you see only the two concerts that are $10 or less. The map automatically zooms to show only the concerts that match our filter criteria. Pretty slick. Now which band are we going to hear?</p></div></div>
<div class="sect1" title="#72: Plot Twitter Geo-Tweets"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_72_colon_plot_twitter_geo"/>#72: Plot Twitter Geo-Tweets</h1></div></div></div><p>Twitter is a popular service for sharing short messages with friends. In 140 characters or less, people send rants, links, photos, or whatever else they feel like. Optionally, those messages (called <span class="emphasis"><em>tweets</em></span>) can be geo-tagged. When content is tied to a location, you can do some interesting things with that data.</p><p>In this mashup, we'll create a tool for users to search for geo-tagged tweets by city name, ZIP Code, or address. We'll also create an optional way to search by keyword. Do you want all the geo-tagged tweets nearby that mention <span class="emphasis"><em>lunch</em></span>? You can do that! Just take a look at <a class="xref" href="ch10s05.html#where_san_franciscans_like_to_tweet_abou" title="Figure 10-12. Where San Franciscans like to tweet about their lunch">Figure 10-12</a>.</p><div class="figure"><a id="where_san_franciscans_like_to_tweet_abou"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e13970"/><img src="httpatomoreillycomsourcenostarchimages672133.png.jpg" alt="Where San Franciscans like to tweet about their lunch"/></div></div><p class="title">Figure 10-12. Where San Franciscans like to tweet about their lunch</p></div><p>Along with searching tweets, we'll integrate a few other projects from earlier in the book. Because we need the user to enter a location, we'll need a geocoder to translate the name of a place to latitude and longitude coordinates. For that, we'll use <a class="xref" href="ch03s03.html" title="#12: Geocode with JavaScript">#12: Geocode with JavaScript</a> in <a class="xref" href="ch03s03.html" title="#12: Geocode with JavaScript">#12: Geocode with JavaScript</a>. And because we need to start somewhere, I've used <a class="xref" href="ch07s04.html" title="#50: Get Location by IP">#50: Get Location by IP</a> in <a class="xref" href="ch07s04.html" title="#50: Get Location by IP">#50: Get Location by IP</a> to guess where the user is.<a id="IDX-CHP-10-0108" class="indexterm"/><a id="IDX-CHP-10-0109" class="indexterm"/><a id="IDX-CHP-10-0110" class="indexterm"/></p><p>But first we need to create the HTML for the page where our map will reside. Let's get started.</p><div class="sect2" title="Prepare the Map with User Location"><div class="titlepage"><div><div><h2 class="title"><a id="prepare_the_map_with_user_location"/>Prepare the Map with User Location</h2></div></div></div><p>Most maps we've created start with a default location. That's the biggest difference between this map and the others. Here, we'll use Google's <code class="literal">ClientLocation</code> to guess the user's city. If that's not available, we'll instead show a map of the entire United States. In either case, the form below the map will be accessible to set a new location or other search term.</p><p>In an empty file, add the following code:</p><a id="I_programlisting10_d1e14011"/><pre class="programlisting">&lt;html &gt;
    &lt;head&gt;
      &lt;title&gt;Show Geocoded Tweets&lt;/title&gt;
      &lt;style&gt;
        div#mymap {
          width: 600px;
          height: 400px;
        }
      &lt;/style&gt;
❶     &lt;script type="text/javascript"  src="http://ajax.google
apis.com/ajax/libs/jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
❷     &lt;script type="text/javascript" src="http://www.google.com/
jsapi?key=<em class="replaceable"><code>YOURKEY</code></em>"&gt;&lt;/script&gt;
      &lt;script type="text/javascript" src="mxn.js?(google)"&gt;&lt;/script&gt;
❸     &lt;script type="text/javascript" src="mxn.google.geocoder.js"&gt;&lt;/script&gt;
      &lt;script type="text/javascript"&gt;
❹       google.load("maps", "2");

        var mapstraction;
        var radius_field, location_field, kw_field;
        function create_map() {
          mapstraction = new mxn.Mapstraction('mymap', 'google');
          mapstraction.addControls({"zoom":"large"});

          // Store form field objects
          radius_field = document.getElementById('radius');
          location_field = document.getElementById('loc');
          kw_field = document.getElementById('keyword');

          // Get position from ClientLocation
          var pos = google.loader.ClientLocation;
          if (pos) {
            var posloc = new mxn.LatLonPoint(pos.latitude, pos.longitude);
            var cityname = pos.address.city + ", " + pos.address.region;
            get_twitter_geo(posloc, 5);
            mapstraction.setCenterAndZoom(posloc, 11);

❺           location_field.value = cityname;
          }
          else {
❻           mapstraction.setCenterAndZoom(new mxn.LatLonPoint(40, −92), 3);
          }
        }
      &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="create_map()"&gt;
      &lt;div id="mymap"&gt;&lt;/div&gt;
      &lt;form onsubmit="geocode_form();return false;"&gt;
        &lt;input type="text" id="keyword" name="keyword" size="25" /&gt; within
        &lt;select name="radius" id="radius"&gt;
          &lt;option value="1"&gt;1 mi&lt;/option&gt;
          &lt;option value="5" selected&gt;5 mi&lt;/option&gt;
          &lt;option value="10"&gt;10 mi&lt;/option&gt;
          &lt;option value="25"&gt;25 mi&lt;/option&gt;
        &lt;/select&gt;
        of &lt;input type="text" id="loc" name="loc" size="25" /&gt;
        &lt;input type="submit" value="Go" /&gt;
      &lt;/form&gt;
    &lt;/body&gt;
  &lt;/html&gt;</pre><p>First, we include the jQuery library ❶, which we'll use to make the Ajax call to Twitter. Then we load the generic Google JavaScript API script ❷. This distinction from the normal way of loading the Google Maps API is important; we use this alternate method so we can retrieve the user's location. Because we will also be using the JavaScript geocoder, we need to include that, too ❸.<a id="IDX-CHP-10-0111" class="indexterm"/><a id="IDX-CHP-10-0112" class="indexterm"/><a id="IDX-CHP-10-0113" class="indexterm"/><a id="IDX-CHP-10-0114" class="indexterm"/><a id="IDX-CHP-10-0115" class="indexterm"/></p><p>At this point, we've loaded all our scripts the standard way. All we've included from Google, however, is a script that loads other scripts. The first thing we need to do in the JavaScript section is load Google Maps ❹.</p><p>When we create the map, we need to check whether we can determine the user's location. If we can, then we can set the center of the map based on the coordinates retrieved from <code class="literal">ClientLocation</code>. We'll also prepopulate the search form with the name of this location ❺ and call to the <code class="literal">get_twitter_geo</code> function, which retrieves search results from Twitter.</p><p>If we can't determine the user's location, we'll just zoom out so the entire United States is shown on the map ❻. And calling for search results from this view is futile, so we'll wait for the user to search manually. How does that happen? Read on.</p></div><div class="sect2" title="Geocode User Input"><div class="titlepage"><div><div><h2 class="title"><a id="geocode_user_input-id1"/>Geocode User Input</h2></div></div></div><p>Accepting user input is an important part of this mashup. Users want to interact with the map and the data, which requires the ability to look for any location. The form we created in the previous section has inputs for a keyword, radius, and place. Twitter can use all of these to find tweets, but first we need to convert the place into the latitude and longitude coordinates that Twitter expects.</p><p>When the user submits the form, the browser will call the <code class="literal">geocode_form</code> function, which is used to initiate a call to the JavaScript geocoder. Let's create this function by adding the following lines to your JavaScript section, outside any other functions:</p><a id="I_programlisting10_d1e14057"/><pre class="programlisting">function geocode_form() {
    var loctxt = location_field.value;
❶   if (loctxt == "") {
      call_twitter_geo({point: mapstraction.getCenter()});
    }
    else {
      geocoder = new MapstractionGeocoder(❷call_twitter_geo,
 'google'); var address = { address: loctxt };
❸     geocoder.geocode(address);
    }
  }</pre><p>If the user has left the location field empty ❶, we assume they want to search using the center of the current map. Otherwise, we create a geocoder and set the callback function ❷. Then, we perform geocoding ❸ using the location the user entered.<a id="IDX-CHP-10-0116" class="indexterm"/></p><p>In either case, the next function that will be called is <code class="literal">call_twitter_geo</code> (either directly or as a callback from the geocoder), which passes the point and other criteria to our <code class="literal">get_twitter_geo</code> function, which does the heavy lifting. Let's create the first and simpler of those two functions now. Add the following code within the JavaScript section, but not within another function:<a id="IDX-CHP-10-0117" class="indexterm"/></p><a id="I_programlisting10_d1e14079"/><pre class="programlisting">function call_twitter_geo(❹loc) {
    mapstraction.setCenterAndZoom(loc.point, 11);
    var kw = kw_field.value;
    var rad = radius_field.options[radius_field.selectedIndex].value;
❺ get_twitter_geo(loc.point, rad, kw, 1, 100);
  }</pre><p>The argument expected is a location object ❹, which is a <code class="literal">point</code> attribute containing a Mapstraction <code class="literal">LatLonPoint</code>. Even though we sometimes call this function directly, it is designed to accept the results of the JavaScript geocoder.</p><p>We gather the rest of the form fields (keyword, radius) and pass them off to be used to retrieve geo-tweets ❺.</p><p>With that, we're through with the overhead. Now we're ready to search tweets.</p></div><div class="sect2" title="Retrieve Geo-Tweets from Twitter"><div class="titlepage"><div><div><h2 class="title"><a id="retrieve_geo-tweets_from_twitter"/>Retrieve Geo-Tweets from Twitter</h2></div></div></div><p>So far we have only determined (in various ways) a point around which to search, but we haven't performed the actual search. That's what we'll do here: Send our requirements to Twitter, and receive tweets in return.</p><p>Twitter's search API does not require a key, so you can get started right away. The base URL is <span class="emphasis"><em>search.twitter.com/search.json</em></span>, and you can use a number of parameters to call it. The ones we'll use are listed in <a class="xref" href="ch10s05.html#some_twitter_search_parameters" title="Table 10-2. Some Twitter Search Parameters">Table 10-2</a>.<a id="IDX-CHP-10-0118" class="indexterm"/></p><div class="table"><a id="some_twitter_search_parameters"/><p class="title">Table 10-2. Some Twitter Search Parameters</p><div class="table-contents"><table summary="Some Twitter Search Parameters" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Argument</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">q</code></p></td><td style="text-align: left" valign="top"><p>Search query/keyword</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">geocode</code></p></td><td style="text-align: left" valign="top"><p>Coordinates in <code class="literal">lat,lon,radius</code> format</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">page</code></p></td><td style="text-align: left" valign="top"><p>Page of results to retrieve</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">rpp</code></p></td><td style="text-align: left" valign="top"><p>Results per page</p></td></tr></tbody></table></div></div><p>You can search in your browser by adjusting the URL. Here are some abbreviated example results:</p><a id="I_programlisting10_d1e14162"/><pre class="programlisting">{"results":[
  {"from_user":"mapscripting", "created_at":"Thu 15 Jul 2010 12:30:12",
   "text":"This is an example tweet, shown in the API",
   "geo":{"coordinates":[45.5228,-122.6485],"type":"Point"},
   ...},
  {"from_user":"adamd", ...
   "geo":null, ... },
   ...
], ... }</pre><p>You can see that the results contain the username, tweet text, and date. Also, the <code class="literal">geo</code> attribute contains information about geocoded tweets. Not every tweet will contain this data, however, even when we send the <code class="literal">geocode</code> argument in the search query. We'll need to watch for that as we create the function to plot geocoded tweets. In fact, because so many non-geocoded tweets are out there, we may need to go through many pages of results before we get enough tweets to plot on our map.<a id="IDX-CHP-10-0119" class="indexterm"/></p><p>Much more data than I have shown is sent along with the tweet, such as the client used to create the tweet and the profile image of the user who wrote it. You can find full documentation of the search API on Twitter's site at <a class="ulink" href="http://dev.twitter.com/doc/get/search">http://dev.twitter.com/doc/get/search</a>.</p><p>Now that you better understand the data you'll get from Twitter's API, let's write the <code class="literal">get_twitter_geo</code> function that we call from our mashup. Add the following code to your JavaScript, outside any other functions:</p><a id="I_programlisting10_d1e14184"/><pre class="programlisting">function get_twitter_geo(loc, rad, kw, pg, rpp) {
    // Set default values
    if (rpp == null) {
      rpp = 100;
    }
    if (rad == null) {
      rad = 5; // radius in miles
    }
    // Clear the map on first page
    if (pg == null || pg == 1) {
      pg = 1;
      mapstraction.removeAllMarkers();
      mapstraction.removeAllPolylines();
❶     polygon_circle(loc, rad);
    }
    mapstraction.autoCenterAndZoom();
    // Construct URL
    var url = "http://search.twitter.com/search.json?page=" + pg;
    if (kw != null &amp;&amp; kw != "") {
      url += "&amp;q=" + kw;
    }
    url += "&amp;geocode=" + loc.lat + "," + loc.lon + "," + rad + "mi" + "&amp;rpp=" + rpp;
❷   url += "&amp;callback=?";

    $.getJSON(url, function(jobj) {
      var resarray = jobj.results;
      for (var i=0; i&lt;resarray.length; i++) {
        var res = resarray[i];
❸       if (res.geo) {
          var coords = res.geo.coordinates;
          var mk = new mxn.Marker(new mxn.LatLonPoint(coords[0], coords[1]));
          mk.setInfoBubble(res.text);
          mapstraction.addMarker(mk);
        }
      }
❹     if ((pg * rpp) &lt; 1500 &amp;&amp; resarray.length == rpp) {
        get_twitter_geo(loc, rad, kw, ❺pg+1, rpp);
      }
    });
  }</pre><p>The function contains five parameters, but only one (the location) is required. The others—radius, keyword, page, and results per page—are set to defaults if need be.<a id="IDX-CHP-10-0120" class="indexterm"/><a id="IDX-CHP-10-0121" class="indexterm"/><a id="IDX-CHP-10-0122" class="indexterm"/><a id="IDX-CHP-10-0123" class="indexterm"/></p><p>Whenever the search is for the first page of results, we know that this is a new search, so we have to remove previous results from the map. Then, based on the center point, we draw a circle around the search area. I've used a polygon to approximate a circle, as described in <a class="xref" href="ch04s03.html" title="#18: Add Circles to Show Search Radius">#18: Add Circles to Show Search Radius</a> in <a class="xref" href="ch04s02.html#set_the_fill_color_and_opacity" title="Set the Fill Color and Opacity">Set the Fill Color and Opacity</a>. For convenience, the <code class="literal">polygon_circle</code> ❶ function is reprinted at the end of this section.</p><p>Using the function arguments (or the defaults), we then create the URL for a Twitter search. At the end, we include the <code class="literal">callback</code> parameter ❷ with a question mark that will be filled in by jQuery with a generated function name.</p><p>Once we get query results, we loop through until we find a tweet that is geocoded ❸. Then we grab its coordinates (an array, with latitude before longitude) and create a marker with them. I've given the marker a message box containing the text of the tweet. You could also include more data about the tweet if you want.</p><p>When we've looped through all the results, we aren't necessarily done. Because not every tweet is geocoded, we need to view many pages. Twitter will only return 1,500 tweets. The number of pages will depend on the results per page. As long as we're below the limit and still receiving a full set of tweets ❹, we want to keep searching. In some areas, especially without searching by keyword, your tweet map will get pretty full, like in <a class="xref" href="ch10s05.html#many_comma_many_tweets_near_downtown_por" title="Figure 10-13. Many, many tweets near downtown Portland">Figure 10-13</a>.</p><p>This <code class="literal">get_twitter_geo</code> function is what computer scientists call <span class="emphasis"><em>recursive</em></span>, meaning it calls itself. This can be dangerous, because if you aren't careful about the conditions when you make another call, you've got the potential for an infinite loop. Perhaps the most important part of the function is that we increase the page number ❺ with each call. Doing so will ensure that eventually we'll stop calling the function.<a id="IDX-CHP-10-0124" class="indexterm"/></p><p>That's it! Before your code will work, you'll need to include the code, which I am reprinting from <a class="xref" href="ch04.html" title="Chapter 4. LAYER IT ON">Chapter 4</a>:</p><a id="I_programlisting10_d1e14240"/><pre class="programlisting">function polygon_circle(center, radius) {
  var rad = new mxn.Radius(center, 10);
  var poly = rad.getPolyline(mxn.util.milesToKM(radius), '990066');
  mapstraction.addPolyline(poly);
}</pre><p>Now you've written a mashup that geocodes a location and searches Twitter for tweets near that place. You've tapped into the geographic hivemind. Now start using it to uncover some interesting data. Where in your city are people tweeting about lunch?<a id="IDX-CHP-10-0125" class="indexterm"/><a id="IDX-CHP-10-0126" class="indexterm"/></p><div class="figure"><a id="many_comma_many_tweets_near_downtown_por"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e14255"/><img src="httpatomoreillycomsourcenostarchimages672135.png.jpg" alt="Many, many tweets near downtown Portland"/></div></div><p class="title">Figure 10-13. Many, many tweets near downtown Portland</p></div></div></div>
<div class="sect1" title="#73: Find a Coffee Shop to Meet in the Middle"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_73_colon_find_a_coffee_sho"/>#73: Find a Coffee Shop to Meet in the Middle</h1></div></div></div><p>Meeting in the middle is the secret to a happy marriage and the key to passing kindergarten. And when it comes to physically finding a place to meet, meeting in the middle makes for a great map mashup. Whether you and a friend are just across town or many miles apart, we'll make a map that will find coffee shops as close to the midpoint between your two locations as possible, as shown in <a class="xref" href="ch10s06.html#a_search_for_coffee_shop_at_the_midpoint" title="Figure 10-14. A search for coffee shop at the midpoint of a route">Figure 10-14</a>.</p><p>The map we create will use several examples covered earlier in this book. First, we'll take input from the user and determine the route, as I showed in <a class="xref" href="ch06s02.html" title="#37: Find True Distance with Routing">#37: Find True Distance with Routing</a> in <a class="xref" href="ch06s02.html" title="#37: Find True Distance with Routing">#37: Find True Distance with Routing</a>. Then we'll go through each step of the driving directions to determine when we're about halfway. To find the exact midpoint, we'll use another method described in <a class="xref" href="ch06s05.html" title="#40: Find a Point Along a Line">#40: Find a Point Along a Line</a> in <a class="xref" href="ch06s05.html" title="#40: Find a Point Along a Line">#40: Find a Point Along a Line</a>. Finally, we'll use the midpoint to perform a local search using the review service Yelp's API.</p><p>Armed with this game plan, read on to get started.</p><div class="figure"><a id="a_search_for_coffee_shop_at_the_midpoint"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e14282"/><img src="httpatomoreillycomsourcenostarchimages672137.png.jpg" alt="A search for coffee shop at the midpoint of a route"/></div></div><p class="title">Figure 10-14. A search for coffee shop at the midpoint of a route</p></div><div class="sect2" title="Prepare the Map and Form"><div class="titlepage"><div><div><h2 class="title"><a id="prepare_the_map_and_form"/>Prepare the Map and Form</h2></div></div></div><p>Before we can incorporate the other examples from <a class="xref" href="ch06.html" title="Chapter 6. EXPLORE PROXIMITY">Chapter 6</a>, we need to think about the pieces to include on our web page. Obviously, we need to include a map. We also need a way to get two locations from the user.<a id="IDX-CHP-10-0127" class="indexterm"/></p><p>Open a new file, and add the following HTML to create a map with a view of the entire United States and the input fields we need to get user input:</p><a id="I_programlisting10_d1e14301"/><pre class="programlisting">&lt;html &gt;
    &lt;head&gt;
      &lt;title&gt;Coffee in the Middle&lt;/title&gt;
      &lt;style&gt;
        div#mymap {
          width: 600px;
          height: 450px;
        }
      &lt;/style&gt;
❶     &lt;script type="text/javascript"  src="http://ajax.google
apis.com/ajax/libs/jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
      &lt;script src="http://maps.google.com/maps?file=api&amp;amp;v=2&amp;amp;key=
<em class="replaceable"><code>YOURKEY</code></em>" type="text/javascript"&gt;&lt;/script&gt;
      &lt;script type="text/javascript" src="mxn.js?(google)"&gt;&lt;/script&gt;
      &lt;script type="text/javascript"&gt;
        var mapstraction;
❷       var gdir;

        function create_map() {
          mapstraction = new mxn.Mapstraction('mymap', 'google');
          mapstraction.addControls({"zoom":"large"});
          mapstraction.setCenterAndZoom(new mxn.LatLonPoint(40, −92), 3);

        }
      &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="create_map()"&gt;
      &lt;form id="myform" onSubmit="❸goDir();return false;"&gt;
        Your location: &lt;input type="text" id="start" /&gt;
        Friend's location: &lt;input type="text" id="end" /&gt;
        &lt;input type="submit" value="Go" /&gt;
      &lt;/form&gt;
      &lt;div id="mymap"&gt;&lt;/div&gt;
    &lt;/body&gt;
  &lt;/html&gt;</pre><p>I have included the jQuery JavaScript library ❶, which we'll use later to connect to Yelp. Looking ahead, I added the <code class="literal">gdir</code> variable ❷ to hold driving directions from Google. Save and load the file, and it will look like <a class="xref" href="ch10s06.html#the_foundation_of_the_mashup_colon_our_m" title="Figure 10-15. The foundation of the mashup: our map and form">Figure 10-15</a>.</p><div class="figure"><a id="the_foundation_of_the_mashup_colon_our_m"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e14316"/><img src="httpatomoreillycomsourcenostarchimages672139.png.jpg" alt="The foundation of the mashup: our map and form"/></div></div><p class="title">Figure 10-15. The foundation of the mashup: our map and form</p></div><p>Note that the form doesn't do anything right now. If you click the Submit button or press <span class="keycap">enter</span> within a text field, it will attempt to call the <code class="literal">goDir()</code> function, as instructed in the HTML ❸. The function does not exist yet, however, so the next step is to create it. We'll do that and retrieve driving directions from the user's input in the next section.<a id="IDX-CHP-10-0128" class="indexterm"/><a id="IDX-CHP-10-0129" class="indexterm"/><a id="IDX-CHP-10-0130" class="indexterm"/></p></div><div class="sect2" title="Retrieve Driving Directions"><div class="titlepage"><div><div><h2 class="title"><a id="retrieve_driving_directions"/>Retrieve Driving Directions</h2></div></div></div><p>This mashup <span class="emphasis"><em>could</em></span> have found the midpoint between two start and end points, but that would have only been the middle if you and your friends are crows. Or pilots. You are much more likely to drive than to fly, so we'll use Google's driving directions API.</p><p>As you may recall from <a class="xref" href="ch06.html" title="Chapter 6. EXPLORE PROXIMITY">Chapter 6</a>, to retrieve driving directions we first need to tell Google to load the appropriate code. In the <code class="literal">create_map</code> function, add the following lines to prepare for driving directions:</p><a id="I_programlisting10_d1e14355"/><pre class="programlisting">❶ // Google-specific code for driving directions
❷ gdir = new google.maps.DirectionsService();</pre><p>First, we've created a comment ❶ to note that we're writing provider-specific code; in this case, the code only works with Google. If you ever need to convert this mashup to use a different mapping provider, including this will be helpful.</p><p>In order to use driving directions, we must create a <code class="literal">DirectionsService</code> object ❷. Later, we can call functions on that object or pass it to other functions.</p><p>Now that we are ready to look up driving directions, let's write the <code class="literal">goDir</code> function. This function gets called when the user fills out the form. Add this code to the JavaScript section but outside the <code class="literal">create_map</code> function:</p><a id="I_programlisting10_d1e14372"/><pre class="programlisting">function goDir() {
    var start = document.getElementById('start').value;
    var end = document.getElementById('end').value;

    // Remove Markers and Polylines
    mapstraction.removeAllMarkers();
    mapstraction.removeAllPolylines();

    // Google-specific: load directions
❸   var diropt = {
        origin: start,
        destination: end,
        travelMode: google.maps.DirectionsTravelMode.DRIVING
     }
❹   gdirroute(diropt, addDir);
  }</pre><p>The purpose of the <code class="literal">goDir</code> function is to hand off the two locations to the driving directions service. We first store the text the user entered into variables. In case this is a subsequent search and the map already contains results, we need to clear the map of markers and polylines before calling for directions.<a id="IDX-CHP-10-0131" class="indexterm"/></p><p>Now we are ready to pass the locations to Google's directions. We include them in a special options object ❸. Then we can call the directions service using the options and also give Google a callback function ❹.</p><p>Before we find the midpoint, let's add the directions to the map. Here is the code for the callback function:</p><a id="I_programlisting10_d1e14387"/><pre class="programlisting">function addDir(response, status) {
    if (status == google.maps.DirectionsStatus.OK) {
❺     var gpts = response.routes[0].overview_path;
      var polypts = [];
      for (var i=0; i&lt;gpts.length; i++) {
❻       polypts.push(new mxn.LatLonPoint(gpts[i].lat(), gpts[i].lng()));
      }
      // Add polyline to map
      var poly = new mxn.Polyline(polypts);
      mapstraction.addPolyline(poly);
      mapstraction.autoCenterAndZoom();
      // Find distance
❼     var dist = response.routes[0].legs[0].distance.value / 1000;
      // Find midpoint
❽     findMidpoint(polypts, dist);
    }
  }</pre><p>This function is passed the results from the Google driving directions service. From the results, we can get the points ❺ that make up the route. Then, loop through those points, adding each to a new array of points ❻ after converting each into a Mapstraction <code class="literal">LatLonPoint</code>.</p><p>When we have all the points in the route, we can use them to create a new polyline. The line will serve as a visual of the entire route between the two locations, as shown in <a class="xref" href="ch10s06.html#the_full_directions_shown_while_we_find" title="Figure 10-16. The full directions shown while we find coffee shops">Figure 10-16</a>. We're almost ready to find the midpoint, but we need one more thing from the Google directions: the total route distance (in km) ❼. Then, we pass the new array of points and the distance to the <code class="literal">findMidpoint</code> function ❽.</p><p>In the next section, we'll create that function, which does most of the real work involved in this mashup.</p><div class="figure"><a id="the_full_directions_shown_while_we_find"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e14406"/><img src="httpatomoreillycomsourcenostarchimages672141.png.jpg" alt="The full directions shown while we find coffee shops"/></div></div><p class="title">Figure 10-16. The full directions shown while we find coffee shops</p></div></div><div class="sect2" title="Find the Route's Midpoint"><div class="titlepage"><div><div><h2 class="title"><a id="find_the_route_apostrophy_s_midpoint"/>Find the Route's Midpoint</h2></div></div></div><p>Now that we've set up the web page and retrieved the route from Google's directions service, we need to write the code to traverse the route data returned. As we go through each point in the directions, we'll add the total distance traveled so far, stopping when we've gone half the total distance.<a id="IDX-CHP-10-0132" class="indexterm"/><a id="IDX-CHP-10-0133" class="indexterm"/></p><p>The <code class="literal">findMidpoint</code> function receives two arguments, the route points and the total distance. Add the function to your JavaScript code but outside other functions:</p><a id="I_programlisting10_d1e14429"/><pre class="programlisting">function findMidpoint(allpts, totaldist) {
    var midicon = 'http://chart.apis.google.com/chart?chst=d_map_pin_icon
&amp;chld=star|00FF00';

    // Determine distance needed
    var halfdist = totaldist / 2;
    var distsofar = 0;

    // Loop through points, adding up distance so far
    for (var i=1; i &lt; allpts.length; i++) {
    var pt1 = allpts[i-1];
    var pt2 = allpts[i];
    var thisdist = pt1.distance(pt2);
❶   if ((distsofar + thisdist) &lt; halfdist) {
      distsofar += thisdist;
    }
    else {
❷     var distneeded = halfdist − distsofar;

      // Determine point that is "distneeded" along the line between pt1 and pt2
      var bearing = get_bearing(pt1, pt2);
      var midpt = get_destination(pt1, distneeded, bearing);
❸     var midmk = new mxn.Marker(midpt);
      midmk.setIcon(midicon);
      mapstraction.addMarker(midmk);

      // Determine search radius
      var radius = 1+ totaldist / 10;
      if (radius &gt; 25) {
        radius = 25;
      }
❹     loadYelp("coffee", midpt, radius);
      break; // stop the loop, we're halfway!
    }
   }
  }</pre><p>Each time through the loop, we look at two points—the previous point and the current one. Because we need two points, our loop begins at 1 (the second point) instead of 0. We calculate the distance between these two points. As long as the distance between all points so far is less than half the total distance ❶, we just add the distance between the two points to a running total and move on to the next point in the loop.</p><p>Once we have found a halfway point, the real work begins. Most likely the point we found is actually <span class="emphasis"><em>farther</em></span> than halfway. Because we are looking at each point in order, however, we know the two points that our midpoint is between. And we can calculate how far between the two points ❷ we need to go for the midpoint.</p><p>Now that we have two points and a distance from the first to the second, we have all the information needed to use the example from <a class="xref" href="ch06s05.html" title="#40: Find a Point Along a Line">#40: Find a Point Along a Line</a> in <a class="xref" href="ch06s05.html" title="#40: Find a Point Along a Line">#40: Find a Point Along a Line</a>. The two functions from that project, <code class="literal">get_bearing</code> and <code class="literal">get_destination</code>, are reprinted at the end of this section.</p><p>When we have the midpoint, we can use it to create a marker ❸, which we add to the map. Then we will also use that point to search Yelp. But first we need to determine what radius to send to search. Yelp will accept anything that is 25 miles or less. If our user is only searching a route across town, 25 miles is probably a longer search than the entire route. Yet, if we choose too small a radius, we run the risk of there not being any coffee nearby when the midpoint is in a more rural area.</p><p>I've chosen to make the search radius at least one mile, but then I add ten percent of the total distance. That way, small distances have proportionally small search radii. And, if my users are driving across the country, a radius of 25 miles is reasonable.<a id="IDX-CHP-10-0134" class="indexterm"/><a id="IDX-CHP-10-0135" class="indexterm"/><a id="IDX-CHP-10-0136" class="indexterm"/><a id="IDX-CHP-10-0137" class="indexterm"/></p><p>Finally, we send all this information to Yelp ❹. Before we get to that, here are the reprinted functions from <a class="xref" href="ch06.html" title="Chapter 6. EXPLORE PROXIMITY">Chapter 6</a>:</p><a id="I_programlisting10_d1e14470"/><pre class="programlisting">function get_bearing(pt1, pt2) {
  var lat1 = degrees_to_radians(pt1.lat);
  var lat2 = degrees_to_radians(pt2.lat);
  var lon_diff = degrees_to_radians(pt2.lon − pt1.lon);
  var y = Math.sin(lon_diff) * Math.cos(lat2);
  var x = Math.cos(lat1) * Math.sin(lat2)
          - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon_diff);
  var bearing = Math.atan2(y, x);
  return (radians_to_degrees(bearing)+360) % 360;
}
function get_destination(pt, dist, bearing) {
  var R = 6371; // radius of earth (km)
  var lat1 = degrees_to_radians(pt.lat);
  var lon1 = degrees_to_radians(pt.lon);
  bearing = degrees_to_radians(bearing);
  var cosLat1 = Math.cos(lat1);
  var sinLat1 = Math.sin(lat1);
  var distOverR = dist / R;
  var cosDistOverR = Math.cos(distOverR);
  var sinDistOverR = Math.sin(distOverR);
  var lat2 = Math.asin( sinLat1 * cosDistOverR
             + cosLat1 * sinDistOverR * Math.cos(bearing) );
  var lon2 = lon1 + Math.atan2( Math.sin(bearing) * sinDistOverR * cosLat1,
             cosDistOverR − sinLat1 * Math.sin(lat2) );
  lon2 = (lon2 + Math.PI) % (2 * Math.PI) − Math.PI;
  lat2 = radians_to_degrees(lat2);
  lon2 = radians_to_degrees(lon2);
  return new mxn.LatLonPoint(lat2, lon2);
}
function degrees_to_radians(deg) {
  return deg * Math.PI / 180;
}
function radians_to_degrees(rad) {
  return rad * 180 / Math.PI;
}</pre><p>Now the only thing missing from this mashup is the call to Yelp. We'll write that in the next section.</p></div><div class="sect2" title="Search for Coffee on Yelp"><div class="titlepage"><div><div><h2 class="title"><a id="search_for_coffee_on_yelp"/>Search for Coffee on Yelp</h2></div></div></div><p>This mashup isn't just about finding a midpoint; it's about finding a place to meet near that midpoint. As the title of the mashup suggests, we're searching for coffee shops, though you could have your mashup search for any keyword you want. To perform the search, we'll use Yelp, a site that catalogues local businesses.<a id="IDX-CHP-10-0138" class="indexterm"/><a id="IDX-CHP-10-0139" class="indexterm"/><a id="IDX-CHP-10-0140" class="indexterm"/><a id="IDX-CHP-10-0141" class="indexterm"/></p><p>Yelp has an API that makes searching based on a latitude and longitude point easy. Better yet, the response from Yelp is in JSON, a format that makes incorporating it into our mashup quick. Before you can use the API, you'll need to get an access key, just as you did for maps. Sign up as a Yelp developer at <a class="ulink" href="http://yelp.com/developers">http://yelp.com/developers</a>. Now you're ready to make your first call to the Yelp API. The base URL is <span class="emphasis"><em>api.yelp.com/business_review_search</em></span>, but we'll also include the parameters shown in <a class="xref" href="ch10s06.html#yelp_api_search_options" title="Table 10-3. Yelp API Search Options">Table 10-3</a>.</p><p>You can try out a few searches in your browser and see the text for the JSON results. For example, here's a snippet response:</p><a id="I_programlisting10_d1e14505"/><pre class="programlisting">{"message": {"text": "OK", "code": 0, "version": "1.1.1"},
 "businesses": [
   {"name": "Somewhere Coffee", "latitude": 12.3456, "longitude": 123.4567, ... },
   {"name": "Someplace Jo", "latitude": 12.3456, "longitude": 123.4567, ... },
   ...
 ]
}</pre><div class="table"><a id="yelp_api_search_options"/><p class="title">Table 10-3. Yelp API Search Options</p><div class="table-contents"><table summary="Yelp API Search Options" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Argument</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">ywsid</code></p></td><td style="text-align: left" valign="top"><p>Your API key (required)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">num_biz_requested</code></p></td><td style="text-align: left" valign="top"><p>Number of search results</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">term</code></p></td><td style="text-align: left" valign="top"><p>Keyword(s) to search</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">lat</code></p></td><td style="text-align: left" valign="top"><p>Latitude of search point</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">long</code></p></td><td style="text-align: left" valign="top"><p>Longitude of search point</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">radius</code></p></td><td style="text-align: left" valign="top"><p>Radius to search (in miles—25 or less)</p></td></tr></tbody></table></div></div><p>Let's dive in and create the <code class="literal">loadYelp</code> function that we've already called in earlier code. Add the following function to your JavaScript section, being careful to place it outside all other functions:</p><a id="I_programlisting10_d1e14575"/><pre class="programlisting">function loadYelp(kw, loc, rad) {
    var url = "http://api.yelp.com/business_review_search";
    url += "?ywsid=<em class="replaceable"><code>YOURKEY</code></em>&amp;num_biz_requested=10&amp;term=" + kw";
    url += "&amp;lat=" + loc.lat + "&amp;long=" + loc.lon + "&amp;radius=" + rad;
❶   url += "&amp;callback=?";
  $.getJSON(url, ❷function(x) {
    if (x.message.text == "OK") {
      if (x.businesses.length != 0) {
        var res = x.businesses;
        var allpts = [];
        for (var i = 0; i &lt; res.length; i++) {
❸         var place = res[i];
❹         var thisloc = new mxn.LatLonPoint(place.latitude, place.longitude);
          allpts.push(thisloc);
          var html = "&lt;strong&gt;" + place.name + "&lt;/strong&gt;&lt;br /&gt;" + place.address1;
          html += "&lt;br /&gt;" + place.city + ", " + place.state;
          // Create and add marker to the map
          var mk = new mxn.Marker(thisloc);
          mk.setInfoBubble(html);
          mapstraction.addMarker(mk);
        }
❺       mapstraction.centerAndZoomOnPoints(allpts);
      }
    }
  });
 }</pre><p>The <code class="literal">loadYelp</code> function requires three arguments: the keyword to search, the location to search (as a Mapstraction <code class="literal">LatLonPoint</code>), and the radius (in miles). The first thing the function does is use the arguments to create the URL for Yelp's API. We include the <code class="literal">callback</code> parameter ❶ with a question mark that will be filled in by jQuery with a generated function name.</p><p>To interpret the results from Yelp, we'll use an anonymous, inline function ❷ that accepts a single parameter, <code class="literal">x</code>, to hold the JSON object results. Once we've confirmed that we have usable data, we loop through all the results and grab each business listing ❸. From there, we can also find the business' location ❹ and other information.</p><p>In this example, I created a message box with some simple business information and basic styling. You could go wild here and include any HTML you want inside the message box. Yelp also provides some fun data in its response that I haven't included here. You can get the distance from the search point, average reviews, and even pictures of some locations.</p><p>When we're done looping through the results, we'll have a marker for each business. Then we center and zoom on just those markers ❺, passing an array of points we collected during the loop. This function is different than one shown in <a class="xref" href="ch02s08.html" title="#8: Determine the Correct Zoom Level to Use Based on Markers">#8: Determine the Correct Zoom Level to Use Based on Markers</a> in <a class="xref" href="ch02s07.html" title="#7: Loop Through All Markers">#7: Loop Through All Markers</a>. The <code class="literal">autoCenterAndZoom</code> function takes polylines into consideration, too, which shows the entire route.</p><p>You can see an example search in <a class="xref" href="ch10s06.html#meet_in_the_middle_results_show_coffee_s" title="Figure 10-17. Meet in the Middle results show coffee shops in Kansas between Boulder, Colorado, and Little Rock, Arkansas.">Figure 10-17</a>, where the mashup finds a few Kansas coffee shops between Boulder and Little Rock.</p><div class="figure"><a id="meet_in_the_middle_results_show_coffee_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject10_d1e14615"/><img src="httpatomoreillycomsourcenostarchimages672143.png.jpg" alt="Meet in the Middle results show coffee shops in Kansas between Boulder, Colorado, and Little Rock, Arkansas."/></div></div><p class="title">Figure 10-17. Meet in the Middle results show coffee shops in Kansas between Boulder, Colorado, and Little Rock, Arkansas.</p></div><p>The next time you want to meet a friend, either across town or across the country, neither of you has to drive the whole way. You can meet halfway, thanks to driving directions, a little math, Yelp, and this little mashup you've just created.</p></div></div></body></html>