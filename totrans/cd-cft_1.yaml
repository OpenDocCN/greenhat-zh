- en: Part II. THE SECRET LIFE OF CODE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section investigates the art and craft of developing code—the daily activities
    of programming life. Although these topics aren't closely guarded secrets, you
    rarely hear expert discussion or see much written about them. Even so, mastering
    each practice is crucial if you want to write good programs; the code craftsman
    has a thorough understanding of all of these subjects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. THE PROGRAMMER''S TOOLBOX")'
  prefs: []
  type: TYPE_NORMAL
- en: A survey of the tools of our trade and how you should use them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  prefs: []
  type: TYPE_NORMAL
- en: No code is complete until it has been proved fit for purpose; until it has been
    tested. Here we look at the techniques for doing so.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with the inevitable: How to find and remove bugs in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. THE CODE THAT JACK BUILT")'
  prefs: []
  type: TYPE_NORMAL
- en: '"Building" code: The process of converting source code into executable programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html "Chapter 11. THE NEED FOR SPEED")'
  prefs: []
  type: TYPE_NORMAL
- en: A look at the gory details of code optimization. What, why, when, and how.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  prefs: []
  type: TYPE_NORMAL
- en: The thorny topic of software security—how to protect your code from willful
    abuse and malicious attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are fundamental aspects of code construction. With the pressures and
    time constraints of the software factory, they are more than essential skills—they''re
    survival tactics. With experience, they become second nature, so you can spend
    your precious time focusing on more pressing concerns: the architecture of your
    next system, the customer''s changing requirements, and who''s going to fetch
    your next cup of espresso.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. THE PROGRAMMER'S TOOLBOX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using Tools to Construct Software*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perilous to us all are the devices of an art deeper than we possess ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: --J.R.R. Tolkien
  prefs: []
  type: TYPE_NORMAL
- en: To be a productive craftsman, you need a good set of tools. The contents of
    a plumber's toolbox will support him in whatever task he encounters, or else you
    wouldn't call him the next time your taps explode.
  prefs: []
  type: TYPE_NORMAL
- en: Not only the *existence* but also the *quality* of these tools is vital; a good
    craftsman can be let down by poor tools. If the compression valves are bad, there
    will be water everywhere, no matter how good your plumber is.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it's your *use* of these tools that sets you apart as a master craftsman.
    The tools, by themselves, will achieve nothing. Before power tools, carpenters
    were perfectly able to craft exquisite furniture. The tools were more basic, but
    their skill with them produced things of beauty.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true of programming. To do a good job, you need to be supported
    by an appropriate kit of tools; tools that you have confidence in, know how to
    use, and are fit for the jobs you'll encounter. It takes a skilled craftsman,
    good tools, *and* mastery of those tools to craft great code.
  prefs: []
  type: TYPE_NORMAL
- en: This is serious stuff. How you use your tools can set you apart as a truly productive
    programmer. In extreme cases, these tools could provide the shortcut that determines
    your project's success or failure. The relentless pace of the software factory
    means that you should cling tightly to anything that will help you produce better
    code and produce it more quickly and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Other chapters cover issues that relate to particular tools. Here we'll broach
    the subject of *software tools* as a whole. Programming is a discipline that simply
    can't do without tools. From day to day, we use tools without much of a thought,
    taking the compiler for granted in much the same way you'd take a can opener for
    granted—it's fine while it works, but as soon as it goes wrong (or you need to
    open an oddly shaped can) you're stuck, no matter how fancy the can opener is.
    A cheap, basic can opener that works is better than some pretentious contraption
    that doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Software Tool?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use a wide range of tools to construct software; they are *programs that
    build programs*—if that isn't too philosophical. Everything we use to create software
    is a tool of some form. Some tools help you write code. Some help you write *good*
    code. Some help sort out the mess of code you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'They come in all shapes and sizes and work in different ways. Obviously, the
    platform and environment they inhabit is a factor, but they also differ in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some tools are elaborate environments with many, many features and incredible
    configurability. Some are minuscule utilities for a single task. Each approach
    has its pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: A feature-rich tool is cool, when you've *finally* learned how to get it to
    make coffee and bring you doughnuts at the same time. If the many magical features
    make it hard to use, then it's less helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple tools are easier to learn; it's obvious what they do. You just end up
    with a lot of them, one for each task. But if you string them together, there
    are a lot of interface points, so they don't always work together seamlessly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different tools have different scopes, performing everything from very specific
    tasks (searching files for text strings) to entire projects (a collaborative project
    management environment).
  prefs: []
  type: TYPE_NORMAL
- en: '**Frequency of use**'
  prefs: []
  type: TYPE_NORMAL
- en: Some tools are used constantly; we can't live without them. Others are only
    dusted off once in a blue moon, but they're invaluable when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: Some tools have pretty *graphical user interfaces (GUIs)*. Some are more basic,
    driven by a *command-line interface (CLI)* and directing their output to a file.
    Which you prefer depends on how your brain is wired and what you're used to.
  prefs: []
  type: TYPE_NORMAL
- en: Windows utilities tend to be graphical with no command-line access. The standard
    Unix utilities are the opposite, which makes them easier to automate and integrate
    into larger tools using scripts. The interface alters the way you harness a tool's
    power.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration**'
  prefs: []
  type: TYPE_NORMAL
- en: Some tools fit into a larger toolchain, often subsumed in a graphical *integrated
    development environment (IDE)*. Stand-alone command-line utilities tend to generate
    plaintext output in a format suitable as input to other tools, acting primarily
    as data filters.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic GUI interfaces can be very comfortable to use, and the integration
    can make you incredibly productive. On the other hand, they take time to set up
    just as you'd like them, and they seldom offer the full power of more manual command-line
    tools. But although they are incredibly powerful, the discrete Unix tools all
    have different cryptic interfaces that make them hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost**'
  prefs: []
  type: TYPE_NORMAL
- en: There are many excellent free tools.^([[1](#ftn.CHP-7-FN-1)]) However, you often
    get what you pay for. Free tools tend to have have poorer documentation, less
    support, or a smaller feature set. This doesn't always hold true, though. Some
    free tools are far superior to their commercial counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: You can pay as much as you want for any type of tool, but a higher price tag
    doesn't guarantee a better product. I've worked with some fantastically expensive
    tools that were spectacularly poor. Which leads on to . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**Quality**'
  prefs: []
  type: TYPE_NORMAL
- en: Some tools are really good. Some tools are really bad. I have a couple of critical
    tools that I'd gladly never see again; they do the job, but only barely, and are
    permanently on the brink of a crash. But without them, I can't produce the code
    I get paid for. How often have I been tempted to rewrite them myself ? I can keep
    on dreaming.
  prefs: []
  type: TYPE_NORMAL
- en: You'll pick tools based on these characteristics, making appropriate compromises.
    Although it's important to get accustomed to your usual tool set, to learn it
    and to be productive with it, avoid the temptation to become religious about it.
    Most Windows users despise Unix-style development, while Unix hackers look down
    on Windows coders because they can't handle the command line. Get over it.
  prefs: []
  type: TYPE_NORMAL
- en: I challenge you to try working in a different environment on a reasonably large
    project. It will help you fully understand what makes a good toolchain and help
    you gain a real "world view" of software tools.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[1](#CHP-7-FN-1)]) *Free* has two meanings in the software world: free as
    in *beer* (the tool won''t cost you anything to obtain) and free as in *speech*
    (open source software whose code you can view and modify). Which *free* is more
    important depends on how much of an idealist you are. See "[LICENSES](ch18s06.html#licenses
    "LICENSES")" on page 361.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Worry About Tools?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's impossible to create programs without a core set of software tools; you'd
    be stuck without an editor or compiler. There are other tools that you *can* get
    by without, but that are still genuinely useful. In order to improve your productivity,
    code quality, and craftsmanship, it's good to pay a little attention to the tools
    you're currently using and find out what they can really do.
  prefs: []
  type: TYPE_NORMAL
- en: When you understand how your tools work and which tool to use for which job,
    you are better able to produce code that works properly—and produce it more quickly.
    Smarter tool use will make you a smarter programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Know your common tools inside out. A little time invested to become proficient
    with them will quickly pay off*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s be clear about why we actually use tools: Tools don''t do our work *for
    us*—they *enable* us to do our work. The quality of software is always determined
    by the competence of its programmer. Remind yourself of that the next time your
    compiler spits out pages of error messages. You wrote the code, dimwit!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers have wildly varying attitudes with regard to selecting and using
    tools. There''s probably some deep psychological reasoning behind it all—something
    to do with whether you''re an Evil Genius or not. On encountering a new lengthy
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers laboriously complete it by hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others write a tool in a scripting language to do the job automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others spend hours searching for a pre-written tool to do the job for them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given a tool that *might* solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers fiddle with it until they get something near enough to what
    they want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others carefully read the documentation to find out exactly what can be done
    and *then* start to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which the right approach? Well, it depends. Part of becoming a mature programmer
    is understanding how different situations require different solutions and applying
    the right tools for the right job. Everyone is different and everyone works differently—your
    colleagues may be most productive using different tools than the ones that are
    your favorites. But if you saw someone converting his C code into assembly by
    hand on a day-to-day basis, you'd question his sanity.
  prefs: []
  type: TYPE_NORMAL
- en: Invest your time and money in tools practically. Think about how you're going
    to use a tool. Search for or write a new tool only when the time it will take
    to do so *will* pay off. Don't spend a week writing a tool that will only save
    you one hour every month. Do spend a week writing a tool that will save you one
    hour every day.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adopt a pragmatic approach to software tools—use them only when they''ll make
    your life easier*.'
  prefs: []
  type: TYPE_NORMAL
- en: Power Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since programming and tools go hand in hand, in order to be a super-programmer,
    you need to be a super-tool user. What does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: First, it's important to have a good understanding of which tools are around.
    In the next section, we will run down a list of the common tools that every programmer
    should have on hand. You don't need to know every tool on the market; it makes
    for incredibly dull dinner party conversation, anyway. Just knowing the general
    categories of tools that exist, rather than specific products, is the important
    step forward. That will help you choose between finding a tool for a particular
    task, writing the tool yourself, or doing the task by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Take the time to get informed. Check out where you can obtain some of these
    tools—there are shops that specialize in selling software tools and plenty of
    download sites on the Internet. Maybe you already have some installed but never
    needed them, or you didn't appreciate how useful they were. Learn what you can
    expect tools to do for you; it will prepare you for good tool usage.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Know the sorts of tools that are available. Make sure you know where to get
    them, even if you don''t need them right now*.'
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared to try a new tool and to take time to learn it; this is a healthy
    attitude. You may be forced to find new tools if you start a new project, move
    to a new platform, encounter a new kind of problem, or find that your old tools
    have become deprecated. But don't wait to be pushed—make sure that right now,
    you're using the best tools you can get your hands on.
  prefs: []
  type: TYPE_NORMAL
- en: Devote a portion of your time to honing your tools skills—just as you'd spend
    time reading a techie book or magazine or taking a professional training course.
    This stuff is important, so invest in it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few simple steps to become a tool power user. For each weapon in
    your software construction arsenal . . .
  prefs: []
  type: TYPE_NORMAL
- en: Understand What It Can Do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find out the feature set—what it can *really* do, not what you think it *should
    be able* to do. Even if you don't know how to wring out every last drop of goodness
    (maybe you'd have to look up the more esoteric command-line parameters), knowing
    what it's capable of will be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Are there particular things the tool *can't* do? Perhaps it doesn't support
    some facilities provided by its counterparts. Understand these limitations, so
    you know when to shop around for something better.
  prefs: []
  type: TYPE_NORMAL
- en: Learn How to Drive it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just because you've run the tool without generating an error doesn't mean it
    has done *exactly* what you wanted it to do. You must know how to use it properly
    and be confident that you can make it do your bidding.
  prefs: []
  type: TYPE_NORMAL
- en: How does the tool fit into the whole toolchain? This will affect how you use
    it. For example, Unix tools can be used as sequential filters by *piping* them
    together—splicing small individual tools into a larger utility.^([[2](#ftn.CHP-7-FN-2)])
    Understanding how to harness the power of each tool and learning about how they
    inter-operate lifts your tool usage a notch.
  prefs: []
  type: TYPE_NORMAL
- en: Figure out the best way to use each tool—it might not be by calling it directly
    or by clicking somewhere in the GUI interface. Can it be triggered automatically?
    A compiler is often invoked through a build system, rather than manually.
  prefs: []
  type: TYPE_NORMAL
- en: Know What Tasks It's Good For
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Know how each tool fits in the context of the other available tools. For example,
    I can set up keystroke recording macros, which allow me to save time on repetitive
    actions, in my text editor. Some of these alterations could also be done using
    a magic sed invocation.^([[3](#ftn.CHP-7-FN-3)]) However, it's better to use the
    keystroke macros in this context—I'm already using the editor and so it's quicker
    to fire them off.
  prefs: []
  type: TYPE_NORMAL
- en: You might not know how to use yacc,^([[4](#ftn.CHP-7-FN-4)]) but if you ever
    need to write a parser, you'll save yourself loads of effort knowing it's there.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use the right tool for the right task. Don''t crack a walnut with a sledgehammer*.'
  prefs: []
  type: TYPE_NORMAL
- en: Check That It's Working
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everyone becomes the victim of bad tools at some point. Your code doesn't work,
    but no matter how long you search for the errant behavior, there's no explanation.
    In desperation, you'll test random things—checking that the wind is blowing in
    the right direction and the light fittings have been secured correctly. Several
    hours later, you'll find a flaky tool doing something peculiar.
  prefs: []
  type: TYPE_NORMAL
- en: Compilers can produce faulty code. Build systems can get dependencies wrong.
    Libraries harbor bugs. Learn how to check for obvious failures before you rip
    out too much of your own hair.
  prefs: []
  type: TYPE_NORMAL
- en: Having access to the source code for your tools can be instrumental in diagnosing
    any problems you encounter, allowing you to work out exactly what a tool is doing.
    This might be a deciding factor in your choice of tool set.
  prefs: []
  type: TYPE_NORMAL
- en: Have a Clear Route to Find Out More
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't have to know it all. The trick is to know someone who does!
  prefs: []
  type: TYPE_NORMAL
- en: Find out where the tool's documentation is. Who provides support? How do you
    get more information? Look for manuals, release notes, online resources, internal
    help files, and man pages. Know where they are and how to access them on demand.
    Do the online versions have useful search tools and good indexing?
  prefs: []
  type: TYPE_NORMAL
- en: Find Out When New Versions Appear
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tools seem to develop at an incredible rate—in this industry, technology changes
    fast. Some tools develop much faster than others. You've barely installed the
    latest widgetizer when the authors release a newer version with a longer red stripe
    down the side.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to stay informed about the tools you use so that you don't get
    out of date and end up with a potentially buggy and unsupported tool kit. But
    this should be done cautiously; don't blindly chase the latest version. The bleeding
    edge can be painful!
  prefs: []
  type: TYPE_NORMAL
- en: New versions may have new bugs and new higher prices. Adopt upgrades if they
    provide significant fixes and have been proven stable. Test first—sanity check
    the new tool on your old code to make sure that it behaves itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep up to date with the latest developments in your tools, but don''t upgrade
    carelessly*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-7-FN-2)]) If you don't know much about this, I urge you to read
    up on it. The Unix command `man bash` is a good place to start; search the man
    pages for *pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-7-FN-3)]) sed is a stream editor command-line utility, explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-7-FN-4)]) A parser generator. Don't worry—it's explained later too.
  prefs: []
  type: TYPE_NORMAL
- en: Which Tools?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a staggering array of software development tools. Over the years they
    have been developed to scratch particular itches, the needs that often crop up.
    When a task has been done many times, you can bet that someone has written a tool
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly what comprises your tool kit will depend on your line of work. The available
    tools for embedded platforms are rarely as rich as those for desktop applications.
    We'll consider the common components below. Some are really obvious; others are
    less so.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''ll look individually at each class of tool, don''t forget that modern
    IDEs collect these disparate programs into a single, streamlined interface. This
    is undoubtedly convenient, but it''s important to understand how each tool stands
    on its own, for these reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll know how to get the best from each feature that's available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll know what useful features your IDE lacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most IDEs are modular—you can substitute one component with a better alternative
    and plug in facilities that are not available right out of the box. Learn what
    tool varieties are around, and you'll improve your IDE experience.
  prefs: []
  type: TYPE_NORMAL
- en: Source Editing Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A potter's medium is clay; a sculptor's, stone; and a programmer's, code. This
    is the fundamental thing we work with, so it's important to pick excellent tools
    to help us write, edit, and investigate source code.
  prefs: []
  type: TYPE_NORMAL
- en: Source Code Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The editor is probably your most important tool, even more important than a
    compiler. The compiler faces the computer, whereas the editor faces *you*. And
    you're the one driving. This is where you'll spend most of your programming life,
    so pick a good editor and learn to use it *really* well. Being productive with
    your text editor will dramatically improve how you write code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Your choice of code editor is vital: It has a huge impact on how you write
    code*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The One True Source Editor is an age-old debate that doesn''t need to be stirred
    here, but you should select an editor that you are comfortable with and does what
    you require. Just because an editor is embedded in your visual IDE does not mean
    that it is the best editor for you. On the other hand, you may find that having
    it integrated is an incredible boon. For source code editing, I require at least
    the following from my editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive syntax coloring (with support for *many* languages—since I use
    many languages)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple syntax checking (e.g., highlighting mismatched brackets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good *incremental search* facilities (an interactive form of find that searches
    as you type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard macro recording
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works across every platform that I use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My requirements and choice of editor may not be the same as yours, but that
    seems like a fair list of the most important facilities. I don't mind spending
    a little time learning how to get the best out of all these features. It's worth
    it if it makes me productive.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of work you're doing, you may find other types of editors
    useful. There are binary file editors (usually displaying file contents in hexadecimal;
    they're commonly called *hex editors*) and editors devoted to specific file formats,
    for example XML file editors.
  prefs: []
  type: TYPE_NORMAL
- en: Vim and Emacs are the infamous Unix-land editors, available now on pretty much
    any platform (probably even your electric toaster). These contrast with the default
    editors bundled with IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Source Manipulation Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Unix philosophy is characterized by a large collection of small command-line
    tools. GUI environments have their counterparts for each tool, but they are rarely
    as powerful or easy to string together. The GUI versions are far simpler to learn,
    though.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Unix commands provide powerful mechanisms to investigate and
    modify source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`diff`**'
  prefs: []
  type: TYPE_NORMAL
- en: Compares two files and highlights the differences between them. Basic diff spits
    output to the console, but more sophisticated graphical versions exist. There
    are even editors that allow you to work on the diffed files, displaying them side
    by side and updating the differences as you type. Exotic diffs can compare three
    files at once.
  prefs: []
  type: TYPE_NORMAL
- en: '**`sed`**'
  prefs: []
  type: TYPE_NORMAL
- en: Stands for *stream editor*. Sed reads files a line at a time, applying a specified
    conversion rule. Sed can be used to reorder items, as a global search and replace
    tool, or to insert patterns into lines.
  prefs: []
  type: TYPE_NORMAL
- en: '**`awk`**'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine sed on steroids. Awk is another pattern-matching program that can process
    text files. It implements a full programming language for this task, so you can
    write quite advanced awk scripts to perform involved manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**`grep`**'
  prefs: []
  type: TYPE_NORMAL
- en: Searches for patterns of characters in a file. These patterns are described
    by *regular expressions*, a form of mini-language allowing wildcard characters
    and flexible match criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '**`find`**/**`locate`**'
  prefs: []
  type: TYPE_NORMAL
- en: These tools help to find files in the filesystem. They can hunt them down by
    name, date, or a number of other criteria.
  prefs: []
  type: TYPE_NORMAL
- en: These are only the tip of the iceberg, and there are many other tools. `wc`,
    for example, performs word/character counting. For more gems, look into `sort`,
    `paste`, `join`, and `cut`.
  prefs: []
  type: TYPE_NORMAL
- en: Source Navigation Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Really large projects have codebases like cities. Not even the town planners
    intimately know each and every back street. A few taxi drivers know the best routes
    around. Normal citizens know their own neighborhoods fairly well. Tourists get
    lost as soon as they step off a bus.
  prefs: []
  type: TYPE_NORMAL
- en: There is a breed of tool to help you delve into and understand code, map it
    out, and perform easy searches, navigation, and cross-referencing. Some tools
    produce call-graph trees so you can see how control flows around the system. They
    may produce a graphical map or integrate with your editor to provide auto-completion,
    function call help, and more. This can be invaluable on large codebases or when
    entering a project that is well established.
  prefs: []
  type: TYPE_NORMAL
- en: Good examples of freely available tools are LXR, Doxygen, and the venerable
    ctags.
  prefs: []
  type: TYPE_NORMAL
- en: Revision Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We won''t dwell on source control tools here, since we cover them in "[Source
    Control](ch18s02.html "Source Control")" on page 351\. Suffice to say: you *must*
    use one, or else have a limb forcibly amputated.'
  prefs: []
  type: TYPE_NORMAL
- en: Source Generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A number of tools automatically generate source code. Some are good; some frighten
    me.
  prefs: []
  type: TYPE_NORMAL
- en: One example is yacc, an LALR(1)^([[5](#ftn.CHP-7-FN-5)]) parser generator. You
    define the input grammar rules, then use it to generate programs that can parse
    well-formed input matching those rules. It spits out a C code parser with hooks
    for you to add functionality when items are parsed. Bison is a similar tool.
  prefs: []
  type: TYPE_NORMAL
- en: There is a class of code-generating tools that helps you to design user interfaces,
    spitting out the workhorse back-end code. These are especially used for complex
    GUI tool kits like MFC. If a library requires a tool to do *this much* legwork,
    then it implies that the library is too complex (or fundamentally broken) in the
    first place. Tread with caution!
  prefs: []
  type: TYPE_NORMAL
- en: Wizards that write reams of scaffolding code that you must later revise and
    modify should also be treated with caution. You must honestly understand the generated
    code before you begin to attack it, or you'll be bitten by your own ignorance.
    If you rerun the wizard after modifying any generated code, all your hand-edits
    will be silently overwriten. Ouch.
  prefs: []
  type: TYPE_NORMAL
- en: You can even write your own scripts to spit out repetitive sections of code.
    Sometimes this is an indicator that your code could have been designed better.
    Sometimes it *is* the right technical approach. In the past, I have written Perl
    scripts to generate code for me automatically. Having written the generator, I
    trusted the code it generated. Another programmer might look at it distrustfully,
    like any other code wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Source Beautifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These tools homogenize source code formatting, creating a uniform *lowest common
    denominator* layout. I honestly think they are more hassle than they're worth—they
    can destroy as much important and helpful formatting as they fix.
  prefs: []
  type: TYPE_NORMAL
- en: Code Construction Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don't want to stare at pretty source code all day. The fun bit is making
    it do something. We do this so often that we take the following tools for granted,
    assuming they all work, without thinking about what's going on behind the curtain.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides a source editor, this is the most used software tool. Compilers convert
    your source code into an executable so you can marvel at the ways your program
    fails to work. Since this tool is used so often, it's important that you can drive
    it properly. Do you really know all the options and facilities that it has? Many
    companies have a specific *buildmaster* who ensures that the build tools are used
    correctly, but this isn't an excuse to be ignorant of your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Do you understand what level of optimization to employ and how that might affect
    the generated code? It's important—among other things, it will determine how surprisingly
    the code runs in the debugger, and even which compiler bugs you enable!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you compile with all warnings switched on? There really is no excuse not
    to (perhaps only if you're maintaining legacy code that is already riddled with
    warnings). The warnings highlight potential errors, and their absence gives you
    extra confidence in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the compiler standards-compliant by default? The C++ ISO standard is, (ISO
    98) the 1999 C standard is, (ISO 99) the Java language is defined by, (Gosling
    et al. 00) and C# by the ISO standard. (ISO 05) Does the compiler have any nonstandard
    extensions; if so, do you know what they are and how to avoid them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it generating code for the correct CPU instruction set? You may be churning
    out 386-compatible code when you'll only ever run it on the latest Intel whiz-bang
    chip. Get your compiler to spit out the most appropriate code possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I NEED A TOOL . . .**'
  prefs: []
  type: TYPE_NORMAL
- en: You need to perform a task. It's a dull task. It's repetitive. It's the kind
    of thing that *must* be better for a computer to do; it would be less error prone,
    less tedious, and far quicker. That's what computers were invented for! How do
    you find out if there's something to do the job for you?
  prefs: []
  type: TYPE_NORMAL
- en: If it's mentioned in this list, you'll know already that a tool is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's not in the list, but you're sure that you're not the first person to
    have this kind of problem, there's probably a tool out there *somewhere* that
    will help. You'd be surprised at some of the random programs a quick web search
    brings up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your problem seems unique, you might have to write your own program for it.
    See "[ROLLING YOUR OWN](ch07s04.html#rolling_your_own "ROLLING YOUR OWN")" on
    page 126 for more on this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When looking for a tool, get as much advice as you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask others on your team if they have any experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search the web, and read appropriate newsgroups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to tools vendors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the selection of available tools, you'll need to make an informed choice
    based on the criteria we saw in the first section. To make this decision, you
    must establish your requirements. Is it important that the tool is free? Or is
    it more important that you can get it now? Should it be easy to use for everyone
    on the team? How often will you use it—will it justify the expense?
  prefs: []
  type: TYPE_NORMAL
- en: A *cross compiler* targets a different platform from the development machine.
    This is primarily used when writing embedded software (after all, it's hard to
    run Visual C++ on a dishwasher).
  prefs: []
  type: TYPE_NORMAL
- en: The compiler is a single part of a larger toolchain, including the linker, assembler,
    debugger, profiler, and other object-file manipulators.
  prefs: []
  type: TYPE_NORMAL
- en: Some popular compilers include gcc, Microsoft's Visual C++, and Borland's C++
    builder.
  prefs: []
  type: TYPE_NORMAL
- en: Linker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The linker is closely allied with the compiler. It takes all the intermediate
    *object files* that a compiler spits out and glues them together into a single
    executable lump of code. The C and C++ linkers are so closely bound to the compiler
    that sometimes the same executable does both tasks. For Java and C# the linker
    is tied to the run-time environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using your linker, make sure you know:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it *strip* the binary? That is, does it remove debugging symbols like the
    names of variables and functions? These can be used by a debugger to show useful
    diagnostic information, but they can also significantly bloat executables and
    make them slow to load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it eliminate replicated code sections?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you make it spit out library objects rather than executables? What control
    do you have over the library—can you make it *statically* or *dynamically* loaded?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The entire build environment is more than just a compiler and linker. The kind
    of build tools that we use are the Unix make program or the build portions of
    your IDE. They automate the compilation process. Many open source Unix projects
    use the autoconf and automake tools to simplify building.
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to get the most out of your integrated build environment, but not
    at the expense of knowing how to use each individual construction tool. We'll
    investigate these topics in more detail in [Chapter 10](ch10.html "Chapter 10. THE
    CODE THAT JACK BUILT").
  prefs: []
  type: TYPE_NORMAL
- en: Testing Toolchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is a code construction tool, *not* a debugging tool! Appropriate
    testing is vital to the production of reliable, high-quality software. It is often
    neglected—perhaps because it's seen as too much work, distracting attention away
    from the important task of writing code. This is one of the biggest threats to
    good software. You cannot construct a reliable piece code unless you can prove
    that it works correctly, and the only way to do this is to construct tests for
    it as you write.
  prefs: []
  type: TYPE_NORMAL
- en: There are tools that help automate unit testing, offering a skeleton into which
    you can place your test code. These tools can be easily integrated into your build
    system, so testing becomes a central part of the code construction process.
  prefs: []
  type: TYPE_NORMAL
- en: As well as automated unit testing, there are tools that generate test data and
    formulate test cases. There are also tools that simulate a target platform, perhaps
    with the ability to model particular error conditions (low memory, high load,
    etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and Investigative Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These tools characterize running code and help to track down problems—both things
    we have seen going wrong and potential disasters waiting to pounce. We'll look
    at them in greater detail in "[Wasp Spray, Slug Repellent, Fly Paper . . .](ch09s07.html
    "Wasp Spray, Slug Repellent, Fly Paper . . .")" on page 169.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a quality debugger and understanding how to use it can save you hours
    of development time chasing surprising behavior. It allows you to investigate
    paths of execution in your program, break into it, investigate variable values,
    set breakpoints, and generally dissect your running code. It's an order of magnitude
    more sophisticated than peppering programs with `printf` logging statements!
  prefs: []
  type: TYPE_NORMAL
- en: '`gdb` is GNU''s open source debugger; it has been ported to almost every conceivable
    platform. `ddd` is an accomplished graphical interface for it. Every IDE and toolchain
    has its own debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: Profiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This tool is used when your code runs unacceptably slowly. The profiler times
    sections of running code and identifies the bottlenecks. It is used to find targets
    for *sensible* optimization; armed with its results, you won't waste effort speeding
    up code that is rarely executed.
  prefs: []
  type: TYPE_NORMAL
- en: Code Validators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Code validators come in two varieties: *static* and *dynamic*. The former digest
    code in a similar way to a compiler, inspecting your source files to identify
    possible problem areas and flawed language use. `lint` is a well-known example;
    it performs static checks for a series of common coding errors in C. Much of its
    functionality is built into modern compilers, but there are still separate tools
    available for extra checking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic validators modify and instrument the code as it is compiled and then
    perform checking at run time. Memory allocation/bounds checkers are a good example—they
    ensure that all dynamically allocated memory is freed appropriately and that array
    accesses do not occur out of bounds.^([[6](#ftn.CHP-7-FN-6)]) These tools can
    save hours of legwork looking for obscure bugs. They are *much* more useful than
    a debugger in most situations, since they act like prevention mechanisms rather
    than cures: They''ll find faults before they have a chance to break your program.'
  prefs: []
  type: TYPE_NORMAL
- en: Metrics Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These tools perform code inspection and are usually a form of static analyzer
    (although dynamic metric tools do exist). They produce statistical assessments
    of the quality of your code. While statistics can easily mislead, these tools
    can powerfully highlight the most brittle areas. This information can help you
    pick specific targets for code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics are usually gathered on a per-function basis. The most basic metric
    is *number of lines of code*, followed by the ratio of *comments to code*. Neither
    really tell you anything particularly useful, but there are plenty of more interesting
    metrics. *Cyclomatic complexity* is a measure of the complexity of code, considering
    the number of decision points and potential flows of control. A high cyclomatic
    complexity implies unintelligible code, which is more likely to be brittle and
    harbor faults.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This peers into executables, allowing you to inspect the machine code. Debuggers
    do contain this kind of support, but advanced disassemblers can attempt to reconstruct
    code where no symbols exist, generating a high-level language reinterpretation
    of the binary program file.
  prefs: []
  type: TYPE_NORMAL
- en: Fault Tracking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good fault-tracking system provides a shared database that keeps track of
    the bugs found in your system. It allows colleagues to report faults, query, assign,
    or comment on them, and eventually mark faults as fixed. It's an essential tool
    to ensure the quality of a product—you need to manage faults systematically, or
    they'll slip through your fingers, and you'll release a flawed product. Capturing
    and storing this information is also useful when looking back over the project
    history.
  prefs: []
  type: TYPE_NORMAL
- en: Language Support Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write in a high-level language, you need a lot of support. The language implementation
    provides everything you need to make coding possible, making it easier than wallowing
    in a swamp of machine code.
  prefs: []
  type: TYPE_NORMAL
- en: The Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The language itself *is* a tool. Some languages provide facilities absent in
    others. These gaps may be filled by separate tools you can run over the program
    source. For example, C's much maligned preprocessor can be remarkably useful,
    and text-processing packages exist for other languages. Generic code facilities
    (like C++'s templates), and pre- and postcondition checking are other similarly
    useful language tools.
  prefs: []
  type: TYPE_NORMAL
- en: It's valuable to have a selection of languages under your belt. Understand how
    they differ, what tasks they lend themselves to, and what their weak points are.
    Then you can select the best language for any given task.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learn several languages; each will teach you different ways to approach problems.
    Consider them tools, and select the most appropriate language for each task*.'
  prefs: []
  type: TYPE_NORMAL
- en: Run Time and Interpreter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most languages can't be used without the requisite run-time support. Interpreted
    languages rely on their interpreter (or *virtual machine*), but directly compiled
    languages still lean on their support libraries. These libraries are often intimately
    entwined with the language itself, so the two can't be separated.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can pick a different compiler, you may be able to select a different
    language run time, with different characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Java's JVM (*The Java Virtual Machine*) is a common language interpreter. The
    C++ standard library supports the language, providing the default handlers for
    some core language features. Similarly, the C# language rests upon the run-time
    support of the .NET environment.
  prefs: []
  type: TYPE_NORMAL
- en: Components and Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yes, these are tools too! Reusing software components and finding libraries
    that do what you need avoids reinventing the wheel. A good library can increase
    productivity as much as any other software tool.
  prefs: []
  type: TYPE_NORMAL
- en: The scopes of these libraries vary—some are vast abstraction layers for an entire
    OS, while some do a very simple job, providing a humble *date* class. They look
    after their details and hide the complexity away so that you don't have to worry
    about it. You don't have to spend time writing, testing, and debugging your own
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: All languages these days come with some level of library support. The C++ STL
    is a wonderful example of a powerful extensible library. The Java language and
    .NET environment ship with more standard libraries than you can shake a stick
    at. Many, many third-party libraries exist, both commercial and free.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The story doesn't end here. You will come across plenty more tools. "[See Also](ch06s08.html
    "See Also")" on page 127 points out other places where we'll discuss software
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: The following are some other interesting tool varieties.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Good documentation is invaluable; it's a key part of well-engineered code. Various
    tools help you to write it, both in the source code itself and separately (I describe
    some in "[Practical Self-Documentation Methodologies](ch04s03.html "Practical
    Self-Documentation Methodologies")" on page 66). Never underestimate how important
    a good word processor is.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation needs to be read as well as written. Good online help systems
    (backed up by a quality bookshelf) are critical.
  prefs: []
  type: TYPE_NORMAL
- en: '**ROLLING YOUR OWN**'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you can't find a tool for a job and it'll take forever to
    do by hand? There's nothing wrong with "[ROLLING YOUR OWN](ch07s04.html#rolling_your_own
    "ROLLING YOUR OWN")" tools. Indeed, if this task is going to crop up repeatedly,
    a short tool development may save you hours in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Some tasks are naturally more tool-able than others. Make sure you're attempting
    something realistic, and check that the effort will be a cost-effective investment.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the common ways to create a tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Combine existing tools in a new ways, commonly using the Unix piping mechanism,
    perhaps writing a little connecting glue. You can put complex command-line incantations
    into a *shell script* (or *batch file* in Windows-land) so you don't have to type
    them in every time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a *scripting language*. Most small homegrown tools are written in some form
    of scripting language, often Perl. They're quick and easy to work with, yet powerful
    enough to provide the kind of support you need to write tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a full-blown program from scratch. You only really want to do this if
    it's a serious tool that you'll be using over and over again. Otherwise, the effort
    probably isn't justified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When writing the tool, consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The audience—how polished does the tool have to be? Are a few rough edges acceptable?
    If it's only you and one other techie using it, you can cope. If other, more delicate
    souls may one day need it, perhaps you should upholster it tastefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you extend an existing tool (wrap its command up, or perhaps create a plugin
    for it)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Management and work collaboration tools allow you to report and track work against
    a schedule, manage faults, and monitor team performance. Depending on the scope
    of the management tool, humble programmers may not need to go near it. But more
    exotic systems may become the central hub of project activity, drawing in all
    users.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-7-FN-5)]) A cryptic techie (and dull) way of saying *reasonably
    complex grammar*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-7-FN-6)]) More socially responsible languages, like Java, avoid
    this kind of problem in the language design.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Give us the tools and we will finish the job.
  prefs: []
  type: TYPE_NORMAL
- en: --Sir Winston Churchill
  prefs: []
  type: TYPE_NORMAL
- en: Tools make software development possible. Good tools make it much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Make a point of evaluating the set of tools you use. Do you really know how
    to use them all properly? Are there any missing tools you should have? Are you
    getting the most from the ones you do have?
  prefs: []
  type: TYPE_NORMAL
- en: A tool is only ever as good as its user. The proverb *A bad workman blames his
    tools* contains a lot of truth. Poor programmers create poor code, no matter how
    many tools they use. In fact, tools can help produce spectacularly worse code.
    Fostering a professional, responsible attitude toward your toolbox will make you
    a better programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Would rather learn *once* how to use an appropriate tool, rather than repeat
    a tedious job over *and over and over* again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand different toolchain models and are comfortable with each
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tools to make their lives easier but don't become slaves to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See everything they use as a tool, a replaceable utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are productive, because the use of their tools is second nature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Know how to use a few tools and look at every problem in terms of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are afraid of taking the time to learn new tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Started using one development environment and now use it religiously, never
    trying out or even investigating alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't add to their toolboxes when they come across a valuable new tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. THE CODE THAT JACK BUILT")'
  prefs: []
  type: TYPE_NORMAL
- en: The software build process is driven by tools. Just imagine compiling code by
    hand!
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  prefs: []
  type: TYPE_NORMAL
- en: Contains a section discussing specific *design tools*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  prefs: []
  type: TYPE_NORMAL
- en: A chapter devoted to the use of *revision control tools*.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207462.png)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 491.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is it more important for everyone in a development team to use the same IDE,
    or for each person to pick the one that suits him or her best? What are the implications
    of different people using different tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the minimum set of tools that any programmer should have at his or her
    disposal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which are more powerful: command-line or GUI-based tools?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there construction tools that aren't programs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's most important for a tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Flexibility
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Power
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ease of use and learning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are the common tools in your toolbox? Which do you use every day? Which
    do you use a few times a week? Which do you only call on occasionally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How well do you know how to use them?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Are you getting the most from every tool?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How did you learn to use them? Did you ever spend any time improving your skill
    with them?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Are these the *best* tools you could be using?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How up to date are your tools? Does it matter if they're not the latest cutting-edge
    versions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you favor an integrated tool set (like a visual development environment)
    or a discrete toolchain? What are the advantages of the *other* approach? How
    much experience do you have with *both* ways of working?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are you a *Default Dan* or a *Tweaker Tom*? Do you accept the default settings
    in your editor, or do you customize them to within an inch of their lives? Which
    is the "better" approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you determine your budget for software tools? How do you know whether
    a tool is worth its cost?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8. TESTING TIMES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Black Art of Testing Code*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test everything. Keep what is good.
  prefs: []
  type: TYPE_NORMAL
- en: --1 Thessalonians 5:21
  prefs: []
  type: TYPE_NORMAL
- en: 'Write as much code as you like—there''s one thing you can be sure of: It won''t
    work perfectly the first time. It doesn''t matter how long you took to carefully
    design it; software faults have a creepy ability to work their way into any program.
    The more code you write, the more faults you''ll introduce. The faster you write,
    the more you''ll introduce. I''ve yet to meet a really prolific programmer who
    created anything near bug-free code.'
  prefs: []
  type: TYPE_NORMAL
- en: What do we do about this? We *test* our code. We do this to find any problems
    that exist, and once we've fixed them, we use the tests to maintain confidence
    in the quality of the code as we continue to modify it. It's suicide to release
    untested software, no matter how good a programmer you think you are. Untested
    software is *bound* to fail; testing is an essential part of our craft. Too many
    software factories underestimate the importance of thorough testing or try to
    squeeze it into a last-minute dash before the software ships. It shows.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is not something relegated to the end of the development process, used
    to prove that your final program is okay. If that's all you ever try to do, you'll
    produce very poor code, indeed. Testing is a central construction technique. It's
    only by testing that you can prove that each bit of code works, which then tells
    you when you've finished it. How could you tell, otherwise? How do so many software
    factories think they can get away without decent testing?
  prefs: []
  type: TYPE_NORMAL
- en: '**TERMS AND CONDITIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *bug* is remarkably evocative and incredibly imprecise. It''s easy
    to throw words around without really understanding what they mean. Using more
    specific terminology helps us to define what we''re doing. These definitions are
    inspired by IEEE literature (IEEE 84):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *error* is something that *you* do wrong. It is a specific human action
    that results in software containing a *fault*. For example: Forgetting to check
    a condition in your code (like the size of a C array before indexing into it)
    is an error.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fault**'
  prefs: []
  type: TYPE_NORMAL
- en: A *fault* is the consequence of an error, embodied in the software. I made an
    error, and this resulted in a fault in the code. At first, this is a *latent*
    problem. If the code I've just written is never executed, then this fault will
    never have a chance to cause problems. If execution often passes through the faulty
    code, but never in the particular way that triggers the fault, we'll never notice
    that there is a fault at all.
  prefs: []
  type: TYPE_NORMAL
- en: This subtle point is what makes debugging notoriously difficult. A faulty line
    of code may seem fine for years, and then one day it causes the most bizarre system
    tantrum you've ever seen; you won't suspect the aged code since it's been reliable
    for so long.
  prefs: []
  type: TYPE_NORMAL
- en: You might discover a fault in a code review, but you can't identify a fault
    from a running program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Failure**'
  prefs: []
  type: TYPE_NORMAL
- en: When encountered, a fault may cause a *failure*. It may not. The failure, the
    manifestation of the fault, is what we really care about. It's probably the only
    thing we'll take notice of. A failure is the departure of your program's operation
    from its requirements, from its expected behavior. This is where we verge on philosophy.
    If a tree falls over in a forest, does it make a sound? If the running program
    doesn't exercise a bug, is the mistake still a fault? These definitions help to
    answer this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bug**'
  prefs: []
  type: TYPE_NORMAL
- en: The term *bug* is a colloquialism, often used as a synonym for fault. According
    to folklore, the first computer bug was an *actual* bug. It was discovered by
    Admiral Grace Hopper in 1947 at Harvard. A moth trapped between two electrical
    relays of the Mark II Aiken Relay Calculator caused the whole machine to shut
    down.
  prefs: []
  type: TYPE_NORMAL
- en: Reality Check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two simple questions *What is testing?* and *Why do you test?* seem painfully
    obvious. Yet all too often, adequate software testing is not performed—or it is
    not performed at the appropriate stage of production. Good testing is a skill.
    Actually *doing* some testing is more than many programmers achieve; the mere
    mention of testing is enough to make most of them break out in a cold sweat. "The
    single most important rule of testing is to do it." (Kernighan Pike 99)
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a distinct and separate activity from debugging, although their boundaries
    blur, and the two often get mixed up together. *Testing* is a methodical process
    of proving the existence, or lack thereof, of faults in your software. *Debugging*
    is the act of tracking down the cause of this faulty behavior. Testing leads to
    debugging, which leads to repair, which leads to more testing (we test again to
    prove that the fix worked).
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing is not debugging. Don''t get the two confused. They require different
    skills. Make sure you know when you''re testing and when you''re debugging*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're programming well, you'll do a *lot* more testing than debugging. That's
    why this chapter comes before the debugging chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the software development process, various things are tested:'
  prefs: []
  type: TYPE_NORMAL
- en: A large number of *documents* will go through a testing stage (more commonly
    known as a *review* process). Doing this ensures, for example, that the requirements
    specification correctly models the customer's needs, the functional specification
    implements the requirements specification, the various subsystem specifications
    are complete enough to fulfill the functional specification, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naturally, then, the implementation *code* is tested on the developer's machine.
    It is tested at several levels, ranging from line-by-line testing of each function
    as it's written, to the testing of individual modules, to integration tests when
    sections of code are glued together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the end *product* is tested. While this level of testing will (or *should*)
    indirectly test all the code components that have been developed, that is not
    the focus of these tests. Here we worry about whether or not the program, as a
    whole, is working as specified.^([[1](#ftn.CHP-8-FN-1)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product tests may be concerned with a number of things. Most importantly, they
    check that the system functions as intended. They also check that it installs
    correctly (if it's shrink-wrapped PC software) and that it's usable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the kind of testing performed by the QA department. It is this department's
    job to understand how the product should work and to ensure that it does, while
    also meeting any quality criteria that have been established for it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this chapter, we'll focus on the middle point—how we test our code as software
    developers. The other testing activities are large and separate topics, which
    are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**QUALITY ASSURANCE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'QA: *quality assurance*. Sounds painful, doesn''t it? But just *who* or *what*
    is it? This name is given both to a tribe of software factory inhabitants and
    a development practice. To understand QA properly, it''s important to separate
    colloquialisms and misconceptions from the real definiton.'
  prefs: []
  type: TYPE_NORMAL
- en: People mistakenly bundle QA with *testing*, but the two differ significantly.
    Testing aims to detect erroneous behavior, where software diverges from its specification;
    it is effectively *detection*. Real QA is *prevention*. It ensures that our processes
    and development practices will result in high-quality software. Testing is a small
    part of QA—software quality includes more than just a low bug count. It means
    software that is delivered on time, to budget, and meeting all requirements and
    expectations (these two are not necessarily the same). Sadly, there still isn't
    a lot of high-quality software coming out of today's software factories.
  prefs: []
  type: TYPE_NORMAL
- en: Who's responsible for software quality? An organization's test department (often
    known as the QA department) is the group of people dedicated to *product* testing.
    They have the final say as to whether your program is good enough to release.
    This is an important piece of the quality jigsaw, but not the whole picture. Everyone
    in the development process is involved in producing quality software—it's not
    something you can tack on once the code is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The responsibility for monitoring software quality often rests with the same
    group of people performing product testing. Otherwise, overall QA is the responsibility
    of project managers, while the testers are left to test.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-8-FN-1)]) Because, obviously, the correct behavior has been carefully
    specified beforehand, hasn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Who, What, When, and Why?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our software testing to be effective, we need to understand *why* we test,
    *who* does it, *what* it entails, and *when* it is done.
  prefs: []
  type: TYPE_NORMAL
- en: Why We Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As software developers, our testing procedure exists for a few reasons: to
    help us to find faults and fix them, and to ensure the same faults don''t reappear
    in later versions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that testing can never reveal the absence of faults, only their existence.
    If your tests don't find any bugs, it doesn't necessarily mean they aren't there;
    it just means you haven't found them yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing can only discover the* presence *of faults. It can''t prove the* absence
    *of faults. Don''t be led into a false sense of security by code that passes a
    suite of inadequate tests*.'
  prefs: []
  type: TYPE_NORMAL
- en: Software testing at the end of a development cycle may have another motivation.
    As well as *verifying* that a software component is correct and contains no faults,
    you may need to *validate* it—ensure that it fulfills the requirements originally
    established—to prove that it is good enough for release. Validation is one form
    of an acceptance test.
  prefs: []
  type: TYPE_NORMAL
- en: Who Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a *programmer's* responsibility to test the source code he or she writes.
    Tattoo that sentence backward across your forehead and stare in the mirror for
    10 minutes every morning.
  prefs: []
  type: TYPE_NORMAL
- en: Too many developers, disillusioned by the trials of the software factory, crank
    out code and release it thoughtlessly to QA without having tested it themselves.
    This is irresponsible and unprofessional. In the long run, it'll cost you *more*
    time and effort than testing properly. It's plain stupid to release untested code
    in a product and almost as bad to supply untested code to the QA department. Its
    job *is* testing, but testing the product, not your new lines of code. It is likely
    to find the silly coding errors that you left behind, probably manifesting themselves
    in obscure and seemingly unrelated ways; but its job is to look for more fundamental
    errors that couldn't have been caught any earlier, not mop up after sloppy programmers.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You must test every piece of code you write. Don''t expect anyone else to
    do it for you*.'
  prefs: []
  type: TYPE_NORMAL
- en: What Testing Involves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing software, we create individual functions, data structures, and
    classes and glue them together into a working system. Our main testing strategy
    is to exercise all this code and validate its behavior by writing more code—*test
    code*. This forms a harness around the test subject that prods, pokes, and drives
    it, provoking it to respond and checking that its response is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We write test code for each level of the system, testing each important class
    and function, through to the superstructures composed of these smaller parts.
    For each test, you must be clear about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exactly which piece of code you're testing. Clear modules with well-defined
    boundaries help here; the interfaces are your test points. Vague or complex interfaces
    make testing vague and complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method you're using to test (see "[The Types of Test](ch08s04.html "The
    Types of Test")" on page 138).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you will be finished. This is one of the hardest and most important questions
    to answer—you could go on forever. When can you say that you've run enough test
    cases?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another common testing strategy is to *inspect* the code in order to prove its
    correctness. Inasmuch as this is a human activity, it is prone to failure, and
    it also relies upon the requirements being well defined. *Code reviews* are a
    common inspection technique (see [Chapter 20](ch20.html "Chapter 20. A REVIEW
    TO A KILL")). Code inspection tools help, but they cannot magically perform all
    the tests for you. Too often, inspection is ad hoc and haphazard; it's so very
    easy to overlook faults. Prefer to use programmatic tests; they bring many benefits,
    which we'll see throughout this chapter. A combination of the two is most effective.
  prefs: []
  type: TYPE_NORMAL
- en: When We Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test your code *as it's written*, catching coding errors at the earliest possible
    opportunity. It's at this time when errors are easiest to fix, affect fewest people,
    and cause the least havoc. Testing early and thoroughly is the most effective
    way to ensure software quality.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of a bug escalates as it works through the development process,^([[2](#ftn.CHP-8-FN-2)])
    so it's essential to start testing code as soon as possible—during (or perhaps
    before) serious software development. The *test-driven development* approach,
    popularized by agile programmers, advocates testing as a central construction
    technique; you write test code *before* the code being tested!
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Effective code testing starts early, so you catch bugs when they''re least
    harmful. You* can *write tests before writing code!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an essential point, and it is vitally important to absorb into your
    programming routine. For each piece of code you write, *immediately* write a test.
    Or write the test first. Prove that your code works, so you know that it''s safe
    to move on. If you don''t write a test at this point, you''ll leave unproven,
    potentially buggy code behind. This destroys the stability of your codebase: When
    you hit a bug, you won''t know which bit of code (in the mass you''ve accumulated
    since you last wrote a test) is causing the problem. So you end up in the debugger,
    which is a massive waste of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test later means you will test from a distance—either too late,
    when you've forgotten what the code is supposed to do, or as a consequence of
    testing a separate code module. This will not be an effective test. You're also
    far more likely to forget to write the test at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This testing strategy has profound implications: When you start to think about
    writing some code, you must simultaneously think about testing it. This will shape
    the way you design that code, for the better; we''ll see why in "[Design for Test](ch08s06.html
    "Design for Test")" on page 144.'
  prefs: []
  type: TYPE_NORMAL
- en: Every time you find a fault that managed to slip past your existing tests, you
    must add a new test to your test suite (after scolding yourself for missing it
    in the first place). The new test will help to prove that your bug fix is correct.
    It will also catch any later reappearance of the same bug; bugs can rise unexpectedly
    from the dead—this often happens when your code is modified later.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write a test for every fault you find*.'
  prefs: []
  type: TYPE_NORMAL
- en: So we write tests as early as possible, but how often do we run them? As often
    as humanly possible, if not more often (using computer support). The more often
    we run the tests, the more likely we are to detect problems. This is embodied
    in a *continuous integration* strategy (see "[Automated Builds](ch10s05.html#automated_builds
    "Automated Builds")" on page 190), and begins to show why programatic tests (which
    are easy to run repeatedly) are so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Run your tests as often as you can*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-8-FN-2)]) See "[THE ECONOMICS OF FAILURE](ch09s02.html#the_economics_of_failure
    "THE ECONOMICS OF FAILURE")" on page 157 for more on the cost of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Isn't Hard . . .
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unless you do it badly, and then it''s *really* hard. It does take thoughtful
    effort, though. To test whether a particular piece of code works, you need a test
    harness that demonstrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: The correct output is generated for all valid inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appropriate failure behavior is generated for all invalid inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That sounds innocuous enough, yet for all but the simplest of functions, it
    is just not practical to exhaustively perform this testing. The set of valid inputs
    is usually very large, and it's impossible to test each input individually. You'll
    have to pick a smaller set of representative input values. The set of invalid
    inputs is almost always *much* larger than the set of valid inputs, so you have
    to pick a number of representative bad values, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, here are two examples. This first function is easy to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The set of valid inputs is of size two, and there are no invalid inputs. This
    means that the function''s test harness is simple. It might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The function doesn't do anything particularly exciting, though. Now consider
    the following function (let's not critique its elegance at the moment). How much
    harder is it to test?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s still a small snippet of code, but testing it is far more difficult for
    these reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Although there are only two parameters, the set of valid input is extremely
    large. You can't conceivably test every possible combination of values; it would
    take a *very* long time.^([[3](#ftn.CHP-8-FN-3)]) Adding more parameters to a
    function extends this problem exponentially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains a loop. Any form of branch (including a `for` loop) adds complexity
    and more potential for failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several conditional statements. You now have to arrange to exercise
    the code running through each combination of conditions to check that each side
    works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that's just for a single small function. There's *already* a fault in there,
    did you notice it? Can you find it? Ten points and a gold star if you can.^([[4](#ftn.CHP-8-FN-4)])
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It''s very easy to trust the code you read and to believe that it''s correct.
    When you''ve just written some code, you''ll read what you* intended *to write,
    not what you actually wrote. Learn to look twice—read* all *code cynically*.'
  prefs: []
  type: TYPE_NORMAL
- en: Those three problems aren't the only reasons software gets harder to test. There
    are plenty of other ways to increase test complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code size**'
  prefs: []
  type: TYPE_NORMAL
- en: The more code there is, the more room for potential faults, and the more individual
    paths of execution that must be traced through to check validity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependencies**'
  prefs: []
  type: TYPE_NORMAL
- en: Testing one small piece of code should be easy. But if the test harness has
    to attach the rest of the codebase before it will do anything, then it becomes
    too painful (and too time consuming) to write any tests. In this case, either
    testing doesn't happen, or the tests aren't comprehensive enough, since it's too
    hard to orchestrate all of the attached code components. This is an example of
    *untestable design*. We'll look at remedies for this later (in "[Design for Test](ch08s06.html
    "Design for Test")" on page 143).
  prefs: []
  type: TYPE_NORMAL
- en: The next two sections are also examples of kinds of inter-code dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '**External inputs**'
  prefs: []
  type: TYPE_NORMAL
- en: Any reliance on the state of an external part of the system is essentially another
    input. Unlike function parameters, it's not easy to arrange for these external
    inputs to take on certain test values. A shared global variable can't be set to
    an arbitrary value without compromising other parts of the running program.
  prefs: []
  type: TYPE_NORMAL
- en: '**External stimuli**'
  prefs: []
  type: TYPE_NORMAL
- en: The code may react to stimuli other than function calls. It's particularly troublesome
    when they may occur asynchronously (at any time), and with any frequency.
  prefs: []
  type: TYPE_NORMAL
- en: A class can act on callbacks from other parts of the system, which may crop
    up at any time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware interface code reacts to changes in physical device state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication with other systems may take any length of time. Physical connections
    are prone to interference, so they may degrade, and network connections can be
    unreliable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface code is driven by the user's mouse gestures. It's hard to physically
    automate a GUI in test conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These conditions are hard to simulate in an artificial test environment, and
    they may be particularly timing sensitive (for example, the speed of mouse double
    clicks or the frequency of hardware-generated interrupts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some outside influences are unplanned: memory may run low, disk space may become
    exhausted, and network connections may fail. You have to ensure that your code
    is robust in *all* prevailing environmental conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Threads**'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple threads of control make testing more complex, since the concurrent
    code may intertwine in any arbitrary sequence. The complex interplay of execution
    paths means that any given test run may never be repeatable. Thread faults leading
    to deadlock or starvation may be hard to trigger, but they cause serious problems
    when they do crop up.
  prefs: []
  type: TYPE_NORMAL
- en: The program's threaded behavior will be different on truly parallel multiprocessor
    systems to the behavior exhibited under simulated concurrency on single-processor
    time-slicing environments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Evolution**'
  prefs: []
  type: TYPE_NORMAL
- en: Software evolves. This evolution tends to break tests. If the requirements are
    not pinned down, your early tests will probably be invalid by the time you come
    to deliver because the APIs will have changed, the functionality will be completely
    different, and a full set of tests will not have been created because development
    never stood still long enough.
  prefs: []
  type: TYPE_NORMAL
- en: We require stable interfaces both in our own code and any external code we rely
    on. In the Real World, this is an impractical ideal—the code will never stand
    still—so we must craft small, malleable tests that can be easily modified alongside
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware faults**'
  prefs: []
  type: TYPE_NORMAL
- en: Faults exist in hardware as well as in software. Work in an embedded environment
    is generally more likely to run into hardware errors, because you're closer to
    the metal. Hardware faults can be an order of magnitude more difficult to diagnose
    and fix; they are seldom repeatable, and you'll naturally distrust your software
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nasty failure modes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code can fall over in a multitude of exciting and bizarre ways. Program faults
    don''t just lead to *incorrect output*—there''s more to contend with: infinite
    loops, deadlock, starvation, program crashes, OS lock-ups, and other potential
    failures raise their ugly heads to make testing a varied and exciting thing. A
    pathological software failure may even lead to physical damage to hardware!^([[5](#ftn.CHP-8-FN-5)])
    Write a test harness to check for *that*.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test harness is no small feat. When components get glued together
    and start relying on each other, the complexity of software expands exponentially.
    All of these problems gang up to make your life very complicated. This is when
    it becomes not just difficult, but technically infeasible to write harnesses that
    test the software *exhaustively*. The time and resources do not exist to generate
    all the test data necessary, and to run the software over all sets of inputs and
    stimuli. The brute-force method rapidly becomes impractical, and it seems more
    convenient to ignore testing and just hope that there aren't any bugs.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how hard you test, you still can't produce fault-free software—writing
    test code is as hard and requires as much skill as writing regular code. Some
    errors will invariably slip through even the most rigorous testing (studies show
    that the most carefully tested software still contains 0.5 to 3 errors per 1,000
    lines of code). (Myers 86) Testing in the Real World rarely proves that software
    is bulletproof—merely that it is *adequate*.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we need to focus on the key tests that are likely to capture
    the majority of software defects for the most effective testing. We'll see how
    to choose these later.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-8-FN-3)]) The higher your input values, the longer the `for` loop
    will take. Assuming an `int` is a 32-bit value (meaning there are 264 input combinations)
    and you have a nice, fast machine (let's say that every function call will take
    one millisecond—*that's one hell of a processor cache*), a brute-force test would
    take almost 600 million years! And that's without printing out any test results.
    . . .
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-8-FN-4)]) Look at the answer to this chapter's first "[Mull It Over](ch08s12.html#mull_it_over-id7
    "Mull It Over")" question (page 494) to find out what it is.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-8-FN-5)]) This is no joke. The 68000 processor had an undocumented
    *stop and catch fire* instruction—a bus test operation that rapidly cycled the
    address lines, causing the circuit board to overheat and catch on fire.
  prefs: []
  type: TYPE_NORMAL
- en: The Types of Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different kinds of software tests, and no one is better than
    any other. Each method approaches the code from a different direction and will
    catch a different class of faults. All are needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *unit test* is commonly used to mean testing a *module* of code (say
    a library, device driver, or protocol stack layer), but it really describes the
    testing of atomic units: each class or function.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is performed in strict isolation. Any untrusted external code with
    which the unit interfaces is replaced with a stub or simulator—this ensures that
    you only trap bugs in *this* unit, not bugs caused by outside influences.
  prefs: []
  type: TYPE_NORMAL
- en: '**Component testing**'
  prefs: []
  type: TYPE_NORMAL
- en: A step up from unit testing, this validates the combination of one or more units
    into a full component. Often this is what people mean by *unit test*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration testing**'
  prefs: []
  type: TYPE_NORMAL
- en: This tests the combination of components as they are brought together in the
    system, ensuring that they interconnect properly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Regression testing**'
  prefs: []
  type: TYPE_NORMAL
- en: This is retesting after fixes or modifications are made to the software or to
    its environment. You run regression tests to ensure that the software works as
    it did before and that your modification hasn't broken anything along the way.
    When you work with brittle software, a change in one place can cause strange faults
    to appear elsewhere. Regression testing helps to guard against this.
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to determine how much retesting is needed, especially near
    the end of the development cycle. Automated test tools are especially useful for
    this type of testing. I'll discuss this in detail in "[Look! No Hands!](ch08s07.html
    "Look! No Hands!")" on page 144.
  prefs: []
  type: TYPE_NORMAL
- en: '**Load testing**'
  prefs: []
  type: TYPE_NORMAL
- en: You perform load tests to ensure that your code can handle the expected volume
    of data being thrown at it. It's simple to write code that generates a good answer,
    but doing so in a timely manner is another thing. This can unearth problems related
    to the efficiency of a system, perhaps due to incorrect buffer sizes, bad memory
    usage, or inadequate database design. Load testing checks that the program "scales
    up" as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stress testing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stress testing throws a *huge* amount of data at the code within a short space
    of time to see what it does. It''s similar to load testing, often used for high-availability
    systems. Stress tests check the characteristics of the system: how tolerant it
    is to overloading. Load testing is performed to prove that the code can meet its
    *expected* demands; stress testing makes sure that it won''t just crumple in a
    heap if it receives a real battering. The code doesn''t have to keep working perfectly;
    it just has to fail gracefully and recover well.'
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing helps determine the capacity of the software—how hard you can
    push before it falls over. It is especially pertinent in threaded or real-time
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Soak testing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Soak testing is similar to stress testing. The focus is on running at a high
    load for a prolonged period of time—several days, weeks, or even months—to identify
    any performance problems that appear after a large number of operations have been
    executed. Soak testing reveals faults that might otherwise go undetected: small
    memory leaks that eventually crash the program or performance degradation as internal
    data structures slowly become fragmented.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Usability testing**'
  prefs: []
  type: TYPE_NORMAL
- en: Ensures that your software can be used easily by a shortsighted gerbil. There
    are various forms of end-user tests, often performed in *usability labs* under
    very controlled and scripted conditions. We also test software in *field trials*,
    putting it in a Real World setting to see what users think.
  prefs: []
  type: TYPE_NORMAL
- en: '**ALPHA, BETA, GAMMA . . .**'
  prefs: []
  type: TYPE_NORMAL
- en: What about *alpha* and *beta* testing? They are common terms, but not quite
    in the same league as the other tests we've looked at here. They are more focused
    on final *product* testing than on the implementation of particular bits of *code*.
    Nevertheless, they deserve some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Happily, the terms have no formal definition. Each company will have its own
    idea of what software in an *alpha* or *beta* state is. For all you know, alpha
    software might be made of lemon jelly and explode on exposure to light. Alpha
    or beta software is often released externally, as an advance customer preview—an
    early chance to elicit feedback and garner confidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are common interpretations of the terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alpha software**'
  prefs: []
  type: TYPE_NORMAL
- en: The first "code complete" stage. It may still have many, many bugs, and be completely
    unreliable. Alpha software provides a good representation of what the final product
    will be like, if you can look past the obvious flaws.
  prefs: []
  type: TYPE_NORMAL
- en: '**Beta software**'
  prefs: []
  type: TYPE_NORMAL
- en: Well past the alpha stage, beta software is *mostly* bug free; there are very
    few remaining problems. It's not too far from a final product. Beta testing (that
    is, testing *beta* software) is used in the run up to final release candidates
    to nail the remaining issues. Beta testing usually involves Real World field trials.
  prefs: []
  type: TYPE_NORMAL
- en: '**Release candidate**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the final stage before a formal software release. Candidate builds go
    through verification and *assurance testing* (validation) prior to the production
    release. Release candidates are internal builds, usually going to the test department
    only.
  prefs: []
  type: TYPE_NORMAL
- en: If alpha and beta releases venture to the outside world, they may have some
    form of crippling (time-limited operation, for example). The release candidates
    are "pure" builds, without any of these limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write unit and component tests, there are two main approaches to devising
    the test cases: *black box* and *white box* testing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Black box testing**'
  prefs: []
  type: TYPE_NORMAL
- en: This is also known as *functional testing*. Black box testing compares actual
    functionality against intended functionality. The internal workings of the code
    are not known by the tester; it is seen as a *black box*. The designer and tester
    can be independent of each other.^([[6](#ftn.CHP-8-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: Black box testing is not concerned that every line of code is tested, only that
    it meets the software's specification—that if you put the right things into one
    end of the box, the right things come out the other. Therefore, without clear
    specifications and documented APIs, it is very hard to devise black box tests.
  prefs: []
  type: TYPE_NORMAL
- en: Black box test cases can be designed as soon as the software specification is
    complete. They rely on the specification being correct in the first place and
    on it not being radically altered after the tests have been devised.
  prefs: []
  type: TYPE_NORMAL
- en: '**White box testing**'
  prefs: []
  type: TYPE_NORMAL
- en: This is also known as *structural testing*. It is a code-coverage-based approach.
    Each line of code is scrutinized systematically to ensure correctness. Where you
    couldn't see into the black box beforehand, you now can and do. For this reason,
    white box testing is sometimes called *glass box* testing. It is really only concerned
    with testing the lines of code produced, and it doesn't guarantee that they meet
    their specifications.
  prefs: []
  type: TYPE_NORMAL
- en: There are *static* and *dynamic* methods of white box testing. Static tests
    do not run the code; instead, it is inspected and walked through to ensure that
    it represents a valid solution. Dynamic tests run the code and are concerned with
    path and branch testing—trying to visit every line of code and execute every decision.
    This may require some modification of the code to force control down certain paths.
    Such modification can be easier than trying to engineer test cases for all behavioral
    combinations.^([[7](#ftn.CHP-8-FN-7)])
  prefs: []
  type: TYPE_NORMAL
- en: White box testing is laborious and much more expensive than black box; consequently,
    it is done a lot less. The completed code is needed before white box tests can
    even be planned. Black box testing is typically done before white box testing
    starts. The consequence of a failure at this stage is much more expensive. You'd
    have to code a fix, black box test again, then devise and run new white box tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tools exist to instrument your code and measure the test coverage. Without tool
    support, white box testing could make your head explode.
  prefs: []
  type: TYPE_NORMAL
- en: Black box testing is concerned with faults of *omission* (where the software
    misses out some of the specified behavior), while white box testing discovers
    faults of *commission* (where parts of the implementation are faulty). In order
    to fully test a software unit, both black and white box testing is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST TIME**'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these test methods is employed at different points in the development
    process. The following table illustrates this, showing which tests are most important
    at each point.
  prefs: []
  type: TYPE_NORMAL
- en: '| Stage of Development | Is Black or White Box Appropriate? | Common Testing
    Approaches at This Stage of Development | Who Performs the Test? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Requirements gathering | Black | Black box tests devised | Developers, QA
    |'
  prefs: []
  type: TYPE_TB
- en: '| Code design | Black | Black box tests devised | Developers, QA |'
  prefs: []
  type: TYPE_TB
- en: '| Code construction | Black, white | Unit, component, regression | Developers
    |'
  prefs: []
  type: TYPE_TB
- en: '| Code integration | Black, white | Component, integration, regression | Developers
    |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha status | Black, white | Regression, load, stress, soak, usability |
    Developers, QA |'
  prefs: []
  type: TYPE_TB
- en: '| Beta status | Black, white | Regression, load, stress, soak, usability |
    QA |'
  prefs: []
  type: TYPE_TB
- en: '| Release candidate | Black, white | Regression, load, stress, soak | QA |'
  prefs: []
  type: TYPE_TB
- en: '| Release | Black, white | It''s too late by now . . . | Users (good luck)
    |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-8-FN-6)]) However, this isn't necessarily a good idea—a programmer
    is usually the best person to write the unit test for the code he or she creates.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-8-FN-7)]) If you do modify the source code, then you're not actually
    testing the final executable, which is concerning.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Unit Test Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If testing is essential but exhaustive testing is impossible, you must judiciously
    choose the set of most effective tests. To do this, you need a thoughtful and
    methodical plan. You could take a *scattergun* approach—just prop the code up
    on a wall and then fire everything that comes to hand at it. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing Unit Test Cases](tagoreillycom20080909nostarchimages207464.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That way you *might* find some flaws. But without a sensible, staged testing
    approach, you'll never have the quality tests that will give you proper confidence
    in your code. Instead of the scattergun, you should pick up a rifle with an accurate
    sight and aim careful shots at the code, hitting well-judged marks, to see how
    well it stands up.
  prefs: []
  type: TYPE_NORMAL
- en: Where do you aim? How do you determine the volley of test data to launch? Since
    you can't try every possible value, you need to select a handful of pertinent
    inputs. You must pick the tests that are most likely to disclose the software's
    faults, rather than run tests that just show the same few problems repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write a comprehensive suite of tests, each one exercising a different aspect
    of the code. Fifteen tests that demonstrate the same fault over and over are less
    useful than fifteen tests that show fifteen different faults*.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you must understand the requirements for your piece of code. You
    can't write an accurate test case unless you know what it's supposed to do. It
    might be doing the wrong thing very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When black box testing, some test cases will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Some good input**'
  prefs: []
  type: TYPE_NORMAL
- en: Select a number of well-chosen *good* inputs to ensure that the software works
    properly in the normal cases.
  prefs: []
  type: TYPE_NORMAL
- en: Cover the whole range of valid input values; include some middle of the road
    values, some values from around the lower bounds of acceptable input, and some
    from the upper bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Some bad input**'
  prefs: []
  type: TYPE_NORMAL
- en: Just as important are a certain number of well-chosen *bad* inputs. This ensures
    that the software is robust and doesn't give misleading answers to invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must consider all sorts of bad data, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Values that are numerically far too large or far too small (handling negative
    values is often overlooked)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input that is too long or too short (string lengths are a classic example—try
    sending an empty string to see what happens, or try different-sized arrays and
    lists)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data values that are internally inconsistent (what this means will depend on
    the contract of the function; perhaps it expects values in a certain order)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boundary values**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test *all* the boundary cases—they are a rich source of error. Identify the
    highest and lowest inputs that are valid, or wherever the natural input boundaries
    are (perhaps where behavior changes). For each of these positions, test the code''s
    behavior at:'
  prefs: []
  type: TYPE_NORMAL
- en: The boundary value itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values just above it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values just below it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures that your software works correctly right into the corners, and
    that it then gives up exactly when expected.
  prefs: []
  type: TYPE_NORMAL
- en: Boundary tests catch the all-too-easy mistakes, like typing `>` instead of `>=`,
    or getting loop count bases wrong (did you start counting from zero or one?).
    All three boundary tests are needed to check for these kinds of mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Random data**'
  prefs: []
  type: TYPE_NORMAL
- en: Test randomly generated sets of input data to avoid guesswork. This is a surprisingly
    effective test strategy. If you can write an automated test harness that repeatedly
    generates and applies random data, you stand a good chance of picking up subtle
    errors that you would have never thought of otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero**'
  prefs: []
  type: TYPE_NORMAL
- en: If the input is numeric, always test for the zero case. For some reason, programmers
    fail to think properly about zero, a blind spot in their reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ pointers are often given a zero value to mean *unset* or *undefined*.
    Try throwing zero pointers at your code to see if it reacts correctly. In Java,
    you can send `null` object references for a similar effect.
  prefs: []
  type: TYPE_NORMAL
- en: Design for Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quality of unit test you can write is determined largely by the quality
    of the interface you have to test. Testing is easier when your code is written
    thoughtfully and specifically designed to accommodate inspection and verification.
    You achieve this by crafting clear APIs, reducing reliance on other bits of code,
    and breaking any hard-coded links to other components. This way, it's easy to
    place a component into its test environment and stimulate it. If, instead, it's
    grafted intimately into other sections of code, you have to drag all of that code
    into the test environment and arrange for it to interact with your unit appropriately.
    This is not always easy, and often impossible, limiting your scope for possible
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design your code for easy testing*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a helpful side effect of this rule: When you structure code for testability,
    you will be structuring it in a sensible, understandable, and maintainable way.
    You''ll reduce component coupling and increase cohesion. You''ll make it more
    flexible, easy to use, and easier to wire up in different configurations. Your
    code will be better.'
  prefs: []
  type: TYPE_NORMAL
- en: And since you've tested it well, the code is more likely to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must design for tests up front. You can''t easily return to an old component
    and bolt a "testable" interface onto it. If a lot of other code relies on the
    existing interface, then such modifications are hard. Remember: You''re most likely
    to design geniunely testable code if you write unit tests alongside the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few simple design rules lead to highly testable code:'
  prefs: []
  type: TYPE_NORMAL
- en: Make each section of code self-contained, without undocumented and tenuous dependencies
    on the outside world. Don't hard-code links to other parts of the system; rely
    on abstract interfaces that could be implemented by system components or by test
    simulators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't rely on global variables (or *singleton* objects, which are thin veneers
    for globals). Gather such states in a shared structure passed as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the complexity of your code; break it into small, comprehensible, bite-sized
    chunks that can be individually tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the code observable, so you can see what it's doing, query internal state,
    and ensure that it's operating as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look! No Hands!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can''t hang around all day turning the handle on your test machinery. Manually
    invoking test after test isn''t my idea of a great day''s programming. Repeated
    regression testing would rapidly get boring. It wouldn''t just be boring, but
    also slow, inefficient, and prone to human error. The golden testing rule is simple:
    *Automate*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Automate your code testing as much as possible. It''s quicker and easier than
    running tests by hand, and it''s far safer: The tests are more likely to be run
    regularly*.'
  prefs: []
  type: TYPE_NORMAL
- en: If the tests run without any intervention, they can be triggered as a validation
    phase of your build procedure. Before you play with some freshly built software,
    you'll know the unit tests have automatically run and passed; you're assured that
    there are no silly programming errors and that any new work hasn't broken old
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Run unit tests automatically as a part of your build process*.'
  prefs: []
  type: TYPE_NORMAL
- en: You can gather your individual pieces of test code together in an automated
    scaffold that marshals the test execution and gathers the results of the testing
    in a single place. This harness monitors which tests have been done; the more
    complex test harnesses maintain a history of test results over time. There are
    many such popular tools, like JUnit, a common Java unit test framework.
  prefs: []
  type: TYPE_NORMAL
- en: A high level of automation comes into its own during regression testing. If
    you make a modification to the code and want to ensure that you haven't accidentally
    broken anything, you can run the whole set of tests automatically; out of the
    end pops a *yes* or *no* answer. Of course, the regression test result is only
    ever as good as the tests put into the harness.
  prefs: []
  type: TYPE_NORMAL
- en: Automation really is a fundamental concept for solid code development. If you
    don't currently have an automated suite of unit tests, acting as a continual regression
    test of your codebase, then get one. Your work will quickly improve in quality.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, not all tests *can* be automated. Unit testing library functions is relatively
    easy; automatically testing user interfaces is very hard. How do you emulate mouse
    clicks, check the Urdu translation of a text string, or ensure that the correct
    sound clip is playing?
  prefs: []
  type: TYPE_NORMAL
- en: The Face of Failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Our greatest glory is not in never falling, but in rising every time we fall*.'
  prefs: []
  type: TYPE_NORMAL
- en: --Confucius
  prefs: []
  type: TYPE_NORMAL
- en: What do you do when your testing finds a program failure? Before you rush in
    headlong to debug it, step back and characterize the problem. This is especially
    important when you don't intend (or have no time) to repair it right away. Follow
    these steps to pin down the nature of the fault so that you, or any other developer,
    can come back later and attempt to sort it out.
  prefs: []
  type: TYPE_NORMAL
- en: Note what you were trying to do at the time and which actions triggered the
    failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it again. Discover whether the problem is repeatable, how frequently it
    crops up, and whether it coincides with any other activities going on at the same
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Describe the fault. Fully. Be very specific. Include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The context of problem
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest steps that can replicate it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about repeatability and frequency of occurrence
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of the software, exact build number, and hardware used
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else that might conceivably relate
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Record it. Don't lose it! Put this information in your fault-tracking system,
    even if it's a simple coding error that you intend to fix yourself (see "[Can
    You Manage It?](ch08s09.html "Can You Manage It?")" next).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the simplest test harness that will demonstrate the failure, and add it
    to the suite of automatic tests. This will ensure that the fault cannot be lost
    or ignored and, once it's eventually fixed, won't reoccur later in development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, testing is *not* debugging—and these steps are *not* debugging! You've
    not tried to unveil the cause of the failure, or peek into the code, just to establish
    enough information to describe the problem to another developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our favorite kind of fault is a repeatable fault. Really—we like code that
    falls over repeatedly: It''s easy to replicate the problem; therefore it''s easy
    to track down the fault and easy to prove that you''ve fixed it. Nasty failures
    are irregular, even random, and consequently hard to characterize. Failures that
    take an eon to manifest and depend upon the wind speed are a nightmare.'
  prefs: []
  type: TYPE_NORMAL
- en: Can You Manage It?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must be methodical and systematic in order to *find* faults. You must also
    be methodical and systematic in your management and handling of them. Before releasing
    code (or checking it into source control), you are the only person who''d be bitten
    by its gremlins. But as soon as it leaves your care, code takes on a life of its
    own. It''s no longer just *you* who is concerned with its faults. The rules change
    as more players join the game:'
  prefs: []
  type: TYPE_NORMAL
- en: A programmer will find problems at the codeface—in his own code and in other
    people's.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code integrator will find errors as components are glued together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QA department will find faults in the product as it tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With so many people finding so many problems while others are simultaneously
    trying to make fixes, there had better be a good procedure for managing it all.
    Otherwise, the result will be a mess, and development will come crashing down
    around everyone's heads.
  prefs: []
  type: TYPE_NORMAL
- en: Fault-Tracking System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our key weapon in managing faults is a *fault-tracking system*. This tool is
    a specialized database with interfaces visible to everyone who has a hand in the
    testing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As bugs are discovered and dealt with, this database is updated to reflect
    the status of the software. In doing so, the fault-tracking tool becomes an integral
    part of the project''s *fault-management procedure*. The general actions performed
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Report a failure**'
  prefs: []
  type: TYPE_NORMAL
- en: When you find a bug, make a new entry for it in the database by creating a *fault
    report*. It becomes a fully paid-up member of the fault club, with its own personal
    membership number. This reference number uniquely identifies it for future use.
    The bug now cannot be overlooked. It *must* be addressed before the software is
    shipped.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a report also alerts others in the team that this fault has been found;
    they don't need to enter the same information when they run into it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assign responsibility**'
  prefs: []
  type: TYPE_NORMAL
- en: This marks a fault report for a particular person's attention. It defines who
    is responsible for fixing (or making sure that someone fixes) each problem. Without
    this idea of ownership, every programmer will think that someone else is going
    to fix the fault, while the bug works its way through the cracks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prioritize reports**'
  prefs: []
  type: TYPE_NORMAL
- en: The fault-tracking system allows you to mark which faults are the most important.
    A repeatable startup crash is clearly more serious than a button that's occasionally
    shifted one pixel to the right.
  prefs: []
  type: TYPE_NORMAL
- en: By differentiating the show-stopping faults from little annoyances, developers
    can plan their work and choose which faults need to be fixed first. There may
    be various levels of severity supported by the tool—from critical faults, though
    medium-to-low priority issues, to feature requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mark as fixed**'
  prefs: []
  type: TYPE_NORMAL
- en: A developer will do this once a repair has been made. It doesn't close the fault
    report but places it on a pile ready for verification. The person who submits
    the report is responsible for testing that the fix is correct, although he can
    delegate this task. A fix certainly shouldn't be verified by the person who made
    it, for obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '**Close a report**'
  prefs: []
  type: TYPE_NORMAL
- en: Once verified, a report can be closed, becoming nothing more than a distant
    memory (and perhaps a project statistic).
  prefs: []
  type: TYPE_NORMAL
- en: There may be other scenarios leading to report closure—the issue may not have
    been a fault at all, perhaps just a characteristic of the system, or even perfectly
    valid behavior. Testers are fallible too.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of closing a report you don't intend to deal with, you can *defer* it,
    marking the fault to be fixed in a later software revision.
  prefs: []
  type: TYPE_NORMAL
- en: '**Query the database**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query the fault-tracking system for information:'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, you can produce a list of all the pending fault reports, ordering
    them by software version, assignee, priority, or whatever.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can discover which faults have been assigned to you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can produce a report on which faults have been fixed in each software version.
    This is helpful for preparing *release notes*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also view project statistics—how many faults have been reported during
    development, how many have been fixed, and the rate of closure versus generation.
    Presented graphically, this can give a good impression of how well the software
    is progressing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify an entry**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open a report and alter the information it contains. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments for any new information you've found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching log files, containing example output, to illustrate the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking a report as a duplicate of another fault, to prevent later confusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty of fault-tracking tools available, both commercial and freely
    available versions, like the popular Bugzilla system developed as a part of the
    Mozilla project.
  prefs: []
  type: TYPE_NORMAL
- en: Bug Reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Toward the end of product development, as release deadlines inch ever nearer,
    *bug review* meetings become a part of life, occurring about once a week. These
    reviews are scheduled once functionality is complete but before all the bugs are
    ironed out—the long home stretch of the development process. They provide an overview
    of the project's progress to all interested parties, help plan the remaining repair
    work, and shepherd the software toward release.
  prefs: []
  type: TYPE_NORMAL
- en: 'These meetings are attended by an eclectic bunch of people:'
  prefs: []
  type: TYPE_NORMAL
- en: The software developers responsible for the product. (They'll be doing the fixing,
    after all.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representatives from the test team, who will explain the context of faults and
    ensure the bug review is steering in the correct direction. (More often than not,
    it's their responsibility to convene the meeting.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product managers, who will gain an overview of the progress and will make *the
    buck stops here* decisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commercial and marketing team members, who are the people that will have to
    sell this bug-ridden product. (Their viewpoint on the importance of each fault
    helps to decide which ones to fix and which to sweep under the digital carpet.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of outstanding fault reports is generated from the fault tracking tool,
    and each fault is discussed in turn during the meeting. Test or development team
    members may present additional information, if required, and then commercial decisions
    on the importance of the problem are made. Nasty lingering faults are discussed,
    with a progress report of the repair. If work is struggling, a decision to apply
    additional resources might be made.
  prefs: []
  type: TYPE_NORMAL
- en: With such a large range of people, the meeting can rapidly get off track, and
    it takes a strong-willed chairman to keep discussion focused and to the point.
    The topic is fault reports and how to deal with them, not specific code fixes.
    Programmers love to talk technical and try to solve every issue in the meeting.
    This is not the place for it.^([[8](#ftn.CHP-8-FN-8)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#CHP-8-FN-8)]) Tactics for successful meetings are described in "[MEETING
    YOUR FATE](ch17s07.html#meeting_your_fate "MEETING YOUR FATE")" on page 340.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is critical to producing good software. In general, the more testing,
    the better—although the *quality* of the tests will be reflected in the quality
    of the final product. Poor tests will catch few faults, and the result will be
    a defective software release.
  prefs: []
  type: TYPE_NORMAL
- en: We test at various levels of development, from individual functions, through
    component integration, to the final assembled program. At each stage, you must
    adopt a methodical approach to finding and managing software faults.
  prefs: []
  type: TYPE_NORMAL
- en: It is each programmer's responsibility to test his or her code. The QA department
    has enough problems to deal with apart from your buggy code. You can't perform
    testing and then add in software quality at end of development—it must be designed
    in from the start, with tests being developed and run alongside the code.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Write tests for all their code (possibly even *before* they write the code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test at the *micro* level, so *macro*-level testing is not hindered by stupid
    coding mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Care about product quality and take responsibility for it, playing their parts
    in the total testing effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Don't consider testing to be an important and integral part of software development—*it's
    someone else's job*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release untested code to the QA department and look surprised when testing uncovers
    faulty behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make their lives more complicated by discovering problems too late—not testing
    early enough and then being hit by a slew of hard-to-locate faults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  prefs: []
  type: TYPE_NORMAL
- en: What to do when you find a fault—the process of locating and fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code reviews* are a testing technique—a manual form of static code analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207466.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 494.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a test harness for the `greatest_common_divisor` code example earlier
    in this chapter. Make it as exhaustive as you can. How many individual test cases
    have you included?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many of these passed?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How many failed?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using these tests, identify any faults and repair the code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How should the testing of a spreadsheet application and an automatic aircraft
    pilot differ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you test all of the *test code* that you write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a programmer's testing differ from a QA department member's testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it necessary to write a test harness for every single function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Test-driven development* encourages you to write tests first, before any code.
    What sort of tests should you write?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you write C/C++ tests to check for the handling of `NULL` (zero) pointer
    parameters? What's the value of such a test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your early code tests might not be on the final platform—you may not yet have
    access to it. Is it safest to defer testing until you *do* have a target test
    platform, or to steam ahead now?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code is intended to run in a different environment (perhaps on a high-capacity
    server, or some embedded device), how can you be sure that your tests are representative
    and adequate?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do you know when you've finished and can stop testing? How much is *enough*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For what percentage of your code do you write tests? Are you happy with this?
    Are your tests an automated part of the build process? What sort of testing do
    you give the remaining code? Is this adequate? What will you do about it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How good is your relationship with the people in your QA department? What personal
    reputation do you think you have with them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's your usual response to finding an error in your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you file a fault report for every code problem you uncover?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How much testing are the project engineers expected to do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9. FINDING FAULT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Debugging: What to Do When Things Go Wrong*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have not failed. I've just found 10,000 ways that won't work.
  prefs: []
  type: TYPE_NORMAL
- en: --Thomas Edison
  prefs: []
  type: TYPE_NORMAL
- en: Nobody's perfect. Well, except for me. All day, I have to sit down and work
    through tedious problems in other people's code. The test department discovers
    that our software falls over when it does *such-and-such*. So I trawl through
    the system to find what Programmer Fred did wrong three years ago, patch it up,
    and send it back for them to break again.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you wouldn't find *me* making those sorts of elementary mistakes—not
    a chance. My code is watertight. Faultless. Low fat and cholesterol free. I never
    write a line without meticulous planning, I won't complete a code statement without
    considering all the special cases that might occur, and I type so carefully that
    I've never once misplaced `=` for `==` in an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Totally fault free, me. Really.
  prefs: []
  type: TYPE_NORMAL
- en: Well, perhaps not quite.
  prefs: []
  type: TYPE_NORMAL
- en: The Facts of Life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I don't think anyone sits trainee programmers down and explains the facts of
    life to them. *It's like this, son. There are the birds and the bees. Oh, and
    the bugs*. Bugs are the inevitable dark side of constructing software, a simple
    fact of life. Sad, but true. Whole departments, and even industries, exist to
    manage them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re all aware of the proliferation of faults in released software. How do
    bugs appear with such frightening regularity and in such great magnitude? It all
    comes down to human nature. Programs are written by humans. Humans make mistakes.
    They make mistakes for a number of reasons (or excuses). They make mistakes because
    they don''t understand the system they''re working on well enough or because they
    don''t correctly understand what they are implementing, but more often than not,
    they make mistakes because they just don''t pay enough attention to what they''re
    doing. Most bugs are due to mindlessness. I once saw a wonderfully simple illustration
    of this; play along at home:'
  prefs: []
  type: TYPE_NORMAL
- en: The tree that grows from an acorn is called an . . .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The noise a frog makes is a . . .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vapor that rises from fire is called . . .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The white of an egg is called the . . .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *yolk*, right? Think about it. If you didn't fall for that one, then you
    were probably only paying attention because I'd just warned you. (Give yourself
    a brownie point anyway.) But tell me, who warns you every time you're about to
    write a potentially flawed line of code? If that person existed, he'd deserve
    a lifetime supply of brownie points.
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers, we''re all to blame for the bad state of software. We''re all
    guilty. Do we learn to live with the guilt, or do we do something about it? There
    are two types of responses. The first is the *It''s not a fault, it''s a feature*
    school: Just make up an excuse and ignore it. A fault turns up, and we respond
    in the words of the great philosopher Bart Simpson: "I didn''t do it. Nobody saw
    me do it. You can''t prove anything!" (Simpsons 91) We blame compiler quirks,
    OS flaws, random climate changes, and computers with minds of their own. Or as
    I alluded to in the opening paragraphs, we blame other people. A Teflon raincoat
    is a handy programming tool.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we should really subscribe to the second school, the school that concedes
    that software errors are *not* entirely inevitable. Many mindless mistakes can
    be picked up or even prevented, and as responsible programmers, we should be taking
    steps to do so. Defensive programming and sensible testing are our main weapons.
    In this chapter, we'll look at good debugging techniques to employ when bugs do
    slip through the net.
  prefs: []
  type: TYPE_NORMAL
- en: Nature of the Beast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contrary to popular belief, the term *bug* was in use before the advent of computers.
    In the 1870s, Thomas Edison talked about bugs in electrical circuits. The story
    of the Harvard University Mark II Aiken Relay Calculator tells of the first recorded
    computer bug. In 1945, the early days of computers when they took up whole rooms,
    a moth flew in and managed to lodge itself in some circuits, causing a system
    failure. They taped it into the logbook and wrote, *First actual case of bug being
    found*. For posterity's sake, it has been preserved in the Smithsonian Institute.
  prefs: []
  type: TYPE_NORMAL
- en: Bugs are bad news. But what are they, really? We outlined the correct nomenclature
    for these things in "[TERMS AND CONDITIONS](ch08.html#terms_and_conditions "TERMS
    AND CONDITIONS")" on page 130\. It's worth identifying the varieties of bugs we
    encounter and understanding how they are born, how they survive, and how they
    can be exterminated.
  prefs: []
  type: TYPE_NORMAL
- en: The View from 1,000 Feet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software bugs fall into a few broad categories, and understanding these will
    help us to reason about them. Some bugs are naturally harder to find than others,
    and this is related to their categories. Stepping back and squinting from a distance,
    these three classes of bugs emerge:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Failure to compile**'
  prefs: []
  type: TYPE_NORMAL
- en: It's really annoying when the code you've spent ages writing fails to compile.
    It means that you'll have to go back and fix a tedious little typo or a parameter
    type mismatch, and then wait for the compiler to run again before you can get
    to the real job of testing your handiwork. Surprisingly, this is the best type
    of error you can get. Why? Simply because it's the easiest to detect and fix.
    It's the most immediate and the most obvious.^([[1](#ftn.CHP-9-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: The longer it takes to detect faults, the more it will cost to fix them; this
    is demonstrated in "[THE ECONOMICS OF FAILURE](ch09s02.html#the_economics_of_failure
    "THE ECONOMICS OF FAILURE")" on page 157\. The sooner you catch and fix each fault,
    the sooner you can move on and the less fuss and cost they can incur. Compilation
    failures are very easy to notice (or rather, they are hard to ignore) and usually
    easy to fix. You can't run the program until you have taken care of them.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, a compilation failure will be a silly syntactic mistake or
    a simple oversight, like calling a function with the wrong number or type of parameters.
    The failure might be due to a fault in a makefile, it might be a link stage error
    (perhaps a missing function implementation), or even a build server running out
    of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: '**Run-time crash**'
  prefs: []
  type: TYPE_NORMAL
- en: After you fix the compilation errors, an executable pops out and you happily
    run it. Then it crashes. You'll probably swear and mutter something about random
    cosmic rays. After the 60th crash, you're threatening to throw your computer out
    the window. These kinds of errors are much harder to deal with than compilation
    errors, but they're still reasonably simple.
  prefs: []
  type: TYPE_NORMAL
- en: That's because, like compilation errors, they are blindingly obvious. You can't
    argue with a dead program. You can't pretend a crash is a "feature." When it has
    kicked the bucket and shuffled off its mortal coil, you can step back and begin
    to figure out where your program went wrong. You'll have some clues (which input
    sequence preceded the crash and what it did before crashing), and you can employ
    tools to discover more information (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: '**Unexpected behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the really nasty one—when your program isn't pushing up the daisies,
    just pining for the fjords. Suddenly it does the wrong thing. You expected a blue
    square, and out popped a yellow triangle. The code continues to meander on its
    happy way with total disregard for your frustration. What caused the yellow triangle
    to appear? Has the program been overthrown by a militant army of guerrilla COM
    objects? It will almost certainly be a minute logic problem in the bowels of the
    code that executed over half and hour ago. Good luck finding it.
  prefs: []
  type: TYPE_NORMAL
- en: A failure may manifest itself because of defective single line of code, or it
    may only show up when several interconnecting modules whose assumptions don't
    quite match up are finally glued together.
  prefs: []
  type: TYPE_NORMAL
- en: The View from the Ground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we move in a bit and take a closer look at run-time errors, more groupings
    of faults become clear. Here they are ranked in order of pain, from splinter to
    decapitation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntactic errors**'
  prefs: []
  type: TYPE_NORMAL
- en: 'While these *are* mostly caught by the compiler at build time, sometimes language
    grammar errors slip through undetected. They generate weird and unexpected behavior.
    In C-like languages, the syntax error will often be one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Mistaking `==` for `=` or `&&` for `&` in a conditional expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forgetting a semicolon or adding one in the wrong place (the classic location
    is after a `for` statement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forgetting to enclose a set of loop statements in braces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mismatching parentheses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest way to avoid being tripped up by these sorts of errors is to keep
    all compiler warnings switched on; modern compilers moan about of lot of these
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Build your code with all compiler warnings switched on. It will highlight
    potential problems before they can bite*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE ECONOMICS OF FAILURE**'
  prefs: []
  type: TYPE_NORMAL
- en: The art of debugging is intimately bound to the topic of the previous chapter—*testing*
    your code. Testing will expose faults that need to be debugged. I've covered these
    topics in two separate chapters because they *are* different disciplines. However,
    the two in tandem are fundamental to reliable software development.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE ECONOMICS OF FAILURE](tagoreillycom20080909nostarchimages207468.png)'
  prefs: []
  type: TYPE_IMG
- en: The frantic pace of the software factory demands code that's produced quickly
    and cheaply. This haste leads to software projects that are riddled with bugs
    and are consequently delivered incredibly late. Late software is a huge problem—it's
    not just embarrassing and inconvenient; it could spell disaster for any company.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the longer you ignore testing and allow bugs to remain, the worse it
    gets— this graph illustrates the escalating impact of bugs as they wriggle through
    the development process. It shows the average cost of finding and fixing an error
    relative to the phase of production in which it is discovered. (Boehm 81)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the cost rises dramatically with time (note that the cost axis
    is a logarithmic scale). To make matters worse, the nearer we get to a project
    deadline, the less time we have to perform thorough testing. The added pressure
    of impending deadlines makes debugging that much harder—with the pressure on,
    you're even more likely to introduce fresh faults with each repair.
  prefs: []
  type: TYPE_NORMAL
- en: To save your skin and prevent a lot of debugging stress, test your code early
    and thoroughly. Eradicate any bugs you find as soon as possible, before they have
    a chance to cause major grief. There are established methodologies for this—look
    at test-driven development, one of the components of agile software development.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build errors**'
  prefs: []
  type: TYPE_NORMAL
- en: While not a run-time fault *per se*, a build error may only manifest itself
    at run time. Be on the lookout and always distrust your build system, no matter
    how good you think it is. In these enlightened times, you're unlikely to come
    across a compiler bug. However, you may not always be running the code you thought
    you built.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve been hit by this several times: The build system failed to rebuild a
    program or shared library (perhaps because the makefiles didn''t contain adequate
    dependency information or the old executable had a bad timestamp). Every time
    I tested my modifications, I was still unknowingly running the old buggy code.
    There are a number of ways to confuse a build system, but the worst is when you
    don''t notice it failing—like a leprous limb.'
  prefs: []
  type: TYPE_NORMAL
- en: It can take quite some time to figure this out. For this reason, when you feel
    at all wary of what's going on, it's sensible to do a total cleanout of your project
    and rebuild it from scratch. This should flush out any potential build system
    problems.^([[2](#ftn.CHP-9-FN-2)])
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic semantic bugs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The majority of run-time faults are due to very simple errors causing incorrect
    behavior. Using uninitialized variables is a classic example and can be quite
    hard to track; the program''s behavior will depend on the garbage value previously
    in the memory location used by the variable. One time the program will work fine;
    another time it may fail. Other basic semantic faults are:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing floating-point variables for (in)equality^([[3](#ftn.CHP-9-FN-3)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing calculations that don't handle numerical overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rounding errors from implicit type conversions (losing the sign of a `char`
    is common)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring an `unsigned int foo`, later writing `if (foo < 0)`—oops!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type of semantic fault is often caught with static analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Semantic bugs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These insidious errors that won''t be caught by inspection tools are much harder
    to identify. A semantic bug might be a low-level error, like the wrong variable
    being used in the wrong place, not validating a function''s input parameters,
    or getting a loop wrong. It may be a higher-level piece of wrong-headedness: calling
    an API incorrectly or not keeping an object''s state internally consistent. Many
    memory-related errors fall into this category—they can be devilishly hard to find
    due to their ability to warp and corrupt your running code so that it behaves
    in totally unpredictable and unreasonable ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Programs often behave strangely. The only consolation is that they're doing
    exactly what we told them to.
  prefs: []
  type: TYPE_NORMAL
- en: The best kind of run-time failures are the repeatable ones. If they're reproducible,
    they are much easier to write tests for and track down the cause of. The failures
    that don't always occur tend to be memory corruptions.
  prefs: []
  type: TYPE_NORMAL
- en: The View from the Trenches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve arranged things into neat little boxes, let''s zoom right in
    and take a look at some of the common types of semantic faults:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Segmentation faults**'
  prefs: []
  type: TYPE_NORMAL
- en: Also known as *protection faults*, segmentation faults come from accessing memory
    locations that have not been allocated for the program's use. They result in the
    operating system aborting your application and producing some form of error message,
    usually with helpful diagnostic information.
  prefs: []
  type: TYPE_NORMAL
- en: This can be triggered far too easily by typing errors involving pointers or
    by poor pointer arithmetic. A common C typo causing a *segfault* is `scanf("%d",
    number);`. The missing `&` before `number` makes `scanf` try to write into the
    memory location referenced by the (garbage) contents of `number`, and *poof*—the
    program disappears in a wisp of smoke. If you're really unlucky, though, `number`
    happens to hold a value that equates to a valid memory address. Now your code
    will continue as if nothing is wrong, until the memory you just wrote over is
    used and your fate is in the lap of the gods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory overruns**'
  prefs: []
  type: TYPE_NORMAL
- en: These are caused by writing past memory that has been allocated for your data
    structure, be it an array, a vector, or some other custom construct. When writing
    values into the wide blue yonder, you'll probably clobber the data in some other
    part your program. If you're running on an unprotected operating system (more
    common in embedded environments), you may even tamper with data from another process
    or the OS itself. Ouch.
  prefs: []
  type: TYPE_NORMAL
- en: Memory overrun is a common problem and difficult to detect; usually the symptom
    is random unexpected behavior manifesting at a much later point than the overrun,
    possibly many thousands of instructions later. If you're lucky, the memory overrun
    hits an invalid memory address and you get a segfault, which is hard to ignore.
    Use safe data structures wherever possible to insulate yourself from the possibility
    of such disaster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory leaks**'
  prefs: []
  type: TYPE_NORMAL
- en: These are constant threats in languages that do not have garbage collection.^([[4](#ftn.CHP-9-FN-4)])
    When you want some memory, you have to ask the run time for it nicely (using `malloc`
    in C or `new` in C++). Then you have to be polite and give it back when you're
    done (using `free` and `delete`, respectively). If you rudely forget to release
    memory, your program slowly consumes more and more of the computer's scarce resources.
    You may not notice it at first, but your computer's response will gradually degrade
    as memory pages thrash to and from the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two other classes of error relate to this: freeing a memory block *too many*
    times, causing unpredictable environmental failures, and not managing other scarce
    resources carefully, such as file handles or network connections. (Remember: Anything
    you manually acquire must be manually released.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running out of memory**'
  prefs: []
  type: TYPE_NORMAL
- en: This is always a possibility, as is running out of file handles or any other
    managed resource. It might be rare (modern computers have so much memory, how
    could this possibly happen?), but that's no excuse to ignore the potential for
    failure. Only sloppy code fails to make appropriate checks, and it will consequently
    perform in a very brittle manner when run in constrained situations. For this
    reason, you should always validate the return status of a memory allocation or
    filesystem call.
  prefs: []
  type: TYPE_NORMAL
- en: Some operating systems *never* return failure from a memory allocation call—every
    allocation returns a pointer to a reserved but unallocated memory page. When the
    program eventually tries to access this page, an OS mechanism traps the access
    and then really allocates memory to the page, resuming normal program operation.
    This all works nicely until the available memory is finally exhausted. Your program
    will then be sent error signals—a long time after the relevant allocation occurred.^([[5](#ftn.CHP-9-FN-5)])
  prefs: []
  type: TYPE_NORMAL
- en: '**Math errors**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These errors come in a number of guises: floating-point exceptions, incorrect
    mathematical constructions, overflow/underflow, or expressions that may fail (for
    example, divide by zero). Even trying to output a `float` but passing an `int`
    through `printf("%f")` can cause your program to bomb with a maths error.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program hangs**'
  prefs: []
  type: TYPE_NORMAL
- en: These are usually caused by bad program logic; infinite loops with badly crafted
    terminal cases are the most common. We also see deadlock and race conditions in
    threaded code, and event-driven code waiting on events that will never occur.
    However, it is usually fairly easy to interrupt the running program, see where
    the code has stalled, and determine the cause of the hang.
  prefs: []
  type: TYPE_NORMAL
- en: Different OSes, languages, and environments report these errors in different
    ways, using different terminology. Some languages avoid whole classes of errors
    by not providing features you can shoot yourself in the foot with. Java, for example,
    has no pointers, and it automatically checks every memory access you make.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-9-FN-1)]) Provided you have a sane build environment that stops
    when it encounters an error and provides some reasonable diagnostic messages.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-9-FN-2)]) This presumes that you trust your `build clean` facility.
    To be really thorough, delete the entire project and check it back out again afresh.
    Alternatively, manually remove all intermediate object files, libraries, and executables.
    For large projects, both options are extremely tedious. *C'est la vie*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-9-FN-3)]) You can't do this meaningfully; floating point arithmetic
    is too approximate to offer an exact comparison that indicates anything.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-9-FN-4)]) It is also possible to leak memory in a language with
    garbage collection. Hand two object references to one another, and then let go
    of them both. Unless you have an advanced garbage collector, they will never be
    swept up.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-9-FN-5)]) This is certainly the case for Linux, at least until you
    exhaust the virtual memory address space. At this point, `malloc` may return 0,
    but the system would probably have keeled over before you got a chance to notice.
  prefs: []
  type: TYPE_NORMAL
- en: Pest Extermination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Weeding out bugs in your software is hard. You have to discover a bug, diagnose
    the problem, eradicate all traces of the unwanted behavior, make sure the bug
    hasn''t bred elsewhere, and try not to break the code while you''re doing all
    of it. The first step alone, finding a fault, is a major hassle: Humans make mistakes
    when writing, but they make just as many mistakes when reading. When looking over
    my prose or my code, I''ll naturally read what I *meant* to write and not what
    I *really* wrote. Faulty code isn''t obvious. The compiler isn''t much help; in
    fact it''s really quite pedantic. It can only produce *exactly* what you asked,
    not what you were hoping for.'
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers introduce far fewer faults than their peers (up to 60 percent
    less), can find and fix faults quicker (in as little as 35 percent of the time),
    and introduce fewer faults as they do so. (Gould 75) How do they do it? They are
    naturally able to pay more attention to the task and can focus on the microscopic
    level of the code they're writing, while still keeping the broader picture in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: This is the *art* of debugging; it's very much a skill to be learned. Experience
    teaches you how to become an effective debugger. And this is something that we
    *will* all get plenty of experience doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The single most important rule when debugging is this: *Use your brain*. Think.
    Consider what you''re doing. Don''t flail around, thoughtlessly hacking at bits
    of code until something appears to work.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Always follow the golden rule of debugging:Use your brain*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two paths to pest extermination: the quicky-and-dirty *low road*
    and the theologically correct *high road*. We must be aware of them both; sometimes
    the low road looks like a good shortcut but will actually be slower, and sometimes
    the high road takes more effort to follow than is genuinely required.'
  prefs: []
  type: TYPE_NORMAL
- en: The Low Road
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bug is really simple. The cause is obvious. You don't need to think too
    much about it, do you? Sometimes a quick tweak *will* achieve results; a few simple
    tests can pinpoint a problem quickly. So is it a justifiable thing to do? Perhaps,
    but don't fall into the trap of believing it will work every time. Too many programmers
    try to fix faults by tinkering, fiddling, poking, and prodding the code without
    any real thought about what they're doing. What happens is rarely anything useful—they
    just mask the original problem behind a myriad of other faults.
  prefs: []
  type: TYPE_NORMAL
- en: If you do make the conscious decision to do some quick-and-dirty stabbing around,
    set yourself a firm time limit to do it in. Don't spend an entire morning with
    the "just one more try" approach. After your time limit is up, follow the more
    methodical approach laid out here.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Set a reasonable time limit for "unstructured" debugging, and then resort
    to more methodical approaches if you don''t find success*.'
  prefs: []
  type: TYPE_NORMAL
- en: If your guesswork turns up trumps and you do find the fault, reengage your thinking
    gear. Look at "[How to Fix Faults](ch09s05.html "How to Fix Faults")" on page
    167, and make the change carefully and thoughtfully. Even if the fault was easy
    to find, the fix isn't necessarily as obvious.
  prefs: []
  type: TYPE_NORMAL
- en: The High Road
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A better debugging technique is more methodical and considered. It recognizes
    that there are two distinct facets to removing a bug: *finding* the fault that
    caused it and *fixing* that fault.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each presents its own challenges to overcome and problems to solve. It''s very
    easy to forget the latter part and to presume that once you''ve found a fault,
    it will be easy and obvious to fix. Don''t believe it. I''ll cover both aspects
    in depth in later sections, and I''ll outline a sensible approach to the task.
    But first, a few key principles govern the debugging game:'
  prefs: []
  type: TYPE_NORMAL
- en: How difficult a fault is to find depends on how well you know the code it's
    lurking in. It's hard to jump into some random source and make any kind of judgment
    about it without knowing the structure and how it's supposed to work. For this
    reason, if you have to debug some new code, take time to learn about it first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**key-concept**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Learn the code you're debugging—you can't expect to find errors in code you
    don't understand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ease of debugging is also dependent on the control you have over the execution
    environment—how much you can play around with the running program and inspect
    its state. In an embedded world, debugging can be much harder because the tool
    support is more sparse. You're also probably running in an environment that is
    providing a lot less insulation from your own stupidity; little mistakes can have
    much bigger consequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most potent weapons in our debugging arsenal is a distrust of anyone's
    code mixed with a healthy dose of cynicism. The cause of your errant behavior
    could be absolutely anything, and in the act of diagnosis, you should start by
    eliminating even the most unlikely of candidates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you look for a fault, suspect everything. Eliminate even the unlikeliest
    of causes first, rather than presume they have nothing to do with it. Assume nothing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Bug Hunting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you find bugs? If there was a simple three-step process, we'd all have
    learned it, and our programs would be perfect by now. As it is, there isn't, and
    they aren't. Let's try to distill the available bug-hunting wisdom.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-Time Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at these first, since they are comparatively easy to deal with. When
    your compiler comes across something unpleasant, it will not normally just complain
    once, but will take the opportunity to sound off about life in general, spitting
    out a barrage of subsequent error messages. It's been told to do this; upon encountering
    any error, the compiler tries to pick itself back up and carry on parsing away.
    It rarely manages very well, but with code like yours, who could blame it?
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is that the later compiler messages can be quite random and irrelevant.
    You only need to look at the very *first* error reported and sort out that problem.
    Have a glance farther down the list by all means; there may be some other useful
    errors there, but often there aren't.
  prefs: []
  type: TYPE_NORMAL
- en: '**CASE STUDY #1: PICTURE THIS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The program**'
  prefs: []
  type: TYPE_NORMAL
- en: A reasonably small utility with graphical interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**The problem**'
  prefs: []
  type: TYPE_NORMAL
- en: The program was redesigned with an updated "look and feel"—new icons and a new
    layout. The old interface was intended to remain available as a configurable option.
    During redevelopment, everything worked fine until just before release, when someone
    tried to use the legacy interface. The program crashed just as a window was appearing
    but before you had a chance to see it fully.
  prefs: []
  type: TYPE_NORMAL
- en: '**The story**'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, this was a nicely repeatable problem. The program was fired up in
    a debugger, and the point of failure was determined to be deep within the UI library
    in some image-rendering code.
  prefs: []
  type: TYPE_NORMAL
- en: On investigation, it seemed the failure was due to an invalid graphic being
    used. The program was trying to display an icon at memory location zero; a null
    pointer was causing the crash. We traced back up the call stack to see which graphic
    should have appeared. Armed with this information, a brief look at the legacy
    graphics directory showed that this particular icon was missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The icon load operation in the window''s constructor had obviously failed,
    returning a zero pointer value to signify "No icon loaded." This return value
    was never checked—the author assumed that the graphic would always be present.
    The fix would be twofold:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the return values of all icon load routines so they deal with any other
    missing graphics more gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place the missing graphic in the correct directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time to fix**'
  prefs: []
  type: TYPE_NORMAL
- en: A few hours to trace the problem, fix the fault, and verify the repair.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lessons learned**'
  prefs: []
  type: TYPE_NORMAL
- en: Check *all* function return codes, even the ones you don't think will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test all program functionality as soon as possible, especially the rare conditions
    that won't be used very often.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When your build fails, look at the* first *compiler error. Trust this far
    more than the subsequent messages*.'
  prefs: []
  type: TYPE_NORMAL
- en: Even this first compiler error may be cryptic or misleading, depending on the
    quality of the compiler (if you're really stumped by what an error means, try
    using another compiler). Hardcore C++ template code can provoke quite inspired
    errors from some compilers—listing reams and reams of mystical template incantations.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax error usually *is* on the line that the compiler reports, but sometimes
    it may actually be on the *preceding* line—a syntax error there causes the following
    line to be nonsensical; this is what the compiler notices and moans about.^([[6](#ftn.CHP-9-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: Linker errors, on the whole, are far less cryptic. The linker will tell you
    that it's missing a function or a library, so you'd better scurry off and find
    it (or write it). Sometimes the linker may complain about arcane v-table related
    C++ problems; this is usually a symptom of a missing destructor implementation
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Run-Time Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run-time errors require more of a game plan. If your program contains a bug,
    then it's likely that a condition somewhere in the code that you believed to be
    true isn't. Finding the bug is a process of confirming what you think is correct
    until you find the place where that condition doesn't hold. You have to develop
    a model of how the code really works and compare this with how you'd intended
    it to work. Doing this methodically is the only sensible way.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Debugging is a methodical activity, slowly closing in on the location of a
    fault. Don''t treat it like a simple guessing game*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *scientific method* is the process scientists use to develop an accurate
    representation of the world. That sounds akin to what we are trying to do, right?
    There are four steps to the scientific method:'
  prefs: []
  type: TYPE_NORMAL
- en: Observe a phenomenon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Form a hypothesis to explain it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this hypothesis to predict the results of further observations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform experiments to test these predications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although we're trying to *get rid of* the errant phenomenon rather than build
    a model of it, we need to understand a fault to truly fix it. The scientific method
    is a good debugging backbone, and you'll see it reflected in the steps below.
  prefs: []
  type: TYPE_NORMAL
- en: Identify a Failure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It all starts here, when you notice that the program doesn't do what it's supposed
    to do. It may crash or it may produce a yellow triangle instead of a blue square,
    but you know something's up, and you've got to fix it. The first thing to do is
    put a fault report into the fault database (see "[Fault-Tracking System](ch08s09.html#fault-tracking_system
    "Fault-Tracking System")" on page 147). This is particularly valuable if you're
    in the middle of tracking some other bug or don't have time to handle the fault
    right away. Making a record ensures that the fault won't get lost. Don't just
    make a mental note to come back to a problem later—you'll forget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you rush on and try to find a bug you''ve stumbled across, identify
    the nature of the errant behavior. Characterize the problem as completely as possible
    by answering questions like: Is it timing sensitive? and Does it depend on input,
    system load, or program state? If you don''t understand the bug before you try
    to fix it, you''ll just be changing code until the symptom disappears. You may
    only have masked a cause, so the same fault will crop up elsewhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Did the code work before? Skip back through your revision control system to
    find the last working version, and compare that working code with this faulty
    revision.
  prefs: []
  type: TYPE_NORMAL
- en: Reproduce It
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This goes alongside characterizing the failure. Work out the set of steps you
    must take to reliably trigger the problem. If there is more than one way, then
    document them all.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The first step to locating a fault is finding out how to reproduce it reliably*.'
  prefs: []
  type: TYPE_NORMAL
- en: You have a problem if the bug doesn't seem reproducible; the best you can do
    is set up mousetraps and see what information you can find out when it does occur.
    For these unreliable failures, keep careful notes of the information you collect;
    it may be a while until you see the problem crop up again.
  prefs: []
  type: TYPE_NORMAL
- en: Locate the Fault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the big one. You've got the scent; now you need to use what you've learned
    to track the beast and pinpoint its location. That is far more easily said than
    done. This is a process of eliminating all the things that don't contribute to
    the failure or can be shown to work correctly, Sherlock Holmes style. As you progress,
    you will find that you need to gather more and more information—the more answers
    you get, the more questions that arise. You may need to draft some new tests.
    You may need to poke around in the seedy underbelly of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze what you have learned about the failure. Without jumping to conclusions,
    draw up a list of code suspects. See if you can spot patterns of events that hint
    at causes. If possible, keep a record of the inputs and outputs that demonstrate
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good starting point for the investigation is where the error *manifests*
    itself—although this is rarely the actual habitat of the fault. Remember: Just
    because a failure exhibits itself in one module, it doesn''t necessarily mean
    *that* module is to blame. Determining this location is easy if the program crashed;
    a debugger will tell you the line of code that failed, the value of all variables
    at that point, and who called this function. In the absence of a crash, start
    from a point you know exhibits incorrect behavior. Work backward from there, following
    the flow of control, checking that the code is doing what you expect it to at
    each point.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Start from what you know—the point of a program crash, for example. Then work
    back from there to the cause of the failure*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few common bug-hunting strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: The worst thing to do is randomly change things to see if the failure goes away.
    This is an immature approach. (A professional will at least try to make it look
    scientific!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A far better strategy is to *divide and conquer*. Say you have the fault pinned
    down to a single function that consists of 20 steps. After the 10th step, print
    out the intermediate result, or set a breakpoint and investigate it in your debugger.
    If the value is good, then the fault lies in the instructions after this; otherwise,
    it's in the instructions before. Concentrate on those instructions and repeat
    until you've cornered the fault.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another technique is the *dry run* method. Rather than relying on intuition
    to locate the error, you play the role of the computer, tracing program execution
    through a trial run, calculating all intermediate values to get the final result.
    If your result and reality don't match, then you know a fault lies in the code—it's
    not doing what you expect it to. Although it is time consuming, this can be very
    effective because it highlights your bad assumptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you've found out where the fault is lurking, you've got to understand the
    *real* problem. If it's a simple syntactic error, such as using `=` instead of
    `==` (*d'oh!*), then the implications aren't too nasty. For more complex semantic
    problems, make sure you really know what the problem is and all the ways that
    it may manifest itself before you move on—you may have only found a part of the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often the fault is very subtle: The code will be doing exactly what it should
    do *and* what you thought it was supposed to do when you wrote it! The problem
    is a flawed assumption (remember how evil these are?). A function''s writer and
    caller can easily presume that different behavior is acceptable in particular
    strange cases. Trace back and understand exactly what the cause of the problem
    is and whether or not any other bits of code may contain the same mistake.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Once you think you''ve found the cause of a bug, investigate it thoroughly
    to prove that you are right. Don''t blindly accept your first hypothesis*.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a key principle in the fight against bugs. Otherwise, you'll join the
    ranks of the programmers who introduce *more* faults than they fix with every
    bit of repair work.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a test case to demonstrate the failure. You may have done this in the
    "Reproduce It" step if you were clever. If you didn't, then you really want to
    write one now. With your new understanding, make sure the test is rigorous.
  prefs: []
  type: TYPE_NORMAL
- en: Fix the Fault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'And now the easy part: You''ve just got to fix the darned thing! This *should*
    actually be the easy part—you understand exactly why the faliure occurs, and you''ve
    got a reproducible way to excerise it. Given that depth of information, the fix
    is usually child''s play. Most programmers find bug fixing hard because they skip
    the first two steps.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at fixing faults in more detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Prove You've Fixed It
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you know why you wrote a test case. Run it again, and prove the world is
    a better place. The test case can be added to your regression test suite to ensure
    that the fault is never reintroduced at a later point.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You haven''t finished debugging until you''ve proved that the problem''s been
    fixed and has gone away for good*.'
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Game over—mission accomplished. Well done. However . . .
  prefs: []
  type: TYPE_NORMAL
- en: If All Else Fails
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you try all of this but it just doesn't work; you're left wailing
    and gnashing your teeth, with a sore head from banging it against a brick wall
    for too long. When things get this bad, I always find it helps to explain the
    whole problem to someone else. Somewhere in the description, everything seems
    to slip into place and I see the one key piece of information I had been missing
    all along. Try it and see. This is one reason why *pair programming* is such a
    successful strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[6](#CHP-9-FN-6)]) C++ has a great party trick here: The preceeding line
    might be in a different file! If you forget the `;` at the end of your class declaration
    in a header file, the first line of the implementation file makes no sense. The
    compiler gives you a very crytpic error.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Fix Faults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll notice that this section is much smaller than the preceding one. Funny.
    Usually the whole problem is *finding* the darned fault. Once you've worked out
    where it is, then the fix is obvious.
  prefs: []
  type: TYPE_NORMAL
- en: But don't let that lure you into a false sense of security. Don't stop thinking
    once you've diagnosed the source of your errant behavior. It's very important
    not to break anything else as you make the fix—it's surprisingly easy to trample
    over something in the flower bed as you stroll over to pluck out a weed.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fix bugs with the utmost care. Don''t risk breaking anything else with your
    modification*.'
  prefs: []
  type: TYPE_NORMAL
- en: As you modify code, always ask yourself, *What are the consequences of this
    change?* Be aware of whether the fix is isolated to a single statement or if it
    affects other surrounding bits of code. Might the effect of your change ripple
    out to any code that calls this function; does it subtly alter the behavior of
    the function?
  prefs: []
  type: TYPE_NORMAL
- en: '**CASE STUDY #2: HUNG, DRAWN, AND QUARTERED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The program**'
  prefs: []
  type: TYPE_NORMAL
- en: Embedded software controlling a consumer electronics device.
  prefs: []
  type: TYPE_NORMAL
- en: '**The problem**'
  prefs: []
  type: TYPE_NORMAL
- en: A random lockup, occurring after about a week's continuous operation. It resulted
    in the total death of the device; there was no UI response, no network connectivity,
    not even an interrupt being handled—the processor was completely stalled. This
    was *particularly* nasty, leaving no easy way to find out the cause.
  prefs: []
  type: TYPE_NORMAL
- en: '**The story**'
  prefs: []
  type: TYPE_NORMAL
- en: The lockup happened so rarely that it was remarkably hard to track. In an attempt
    to pinpoint the cause, we tried a number of tests, leaving each to run for the
    weeklong gestation period. First we tried different usage patterns to see if we
    could make the fault happen sooner and thereby determine what was causing it.
    These tests made no difference whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of the lockup seemed to imply that it was a gnarly hardware problem.
    We tried running the software on different versions of the mainboard with different
    peripheral components and different CPU versions. Weeks of testing later, we were
    still no nearer to figuring out the problem, but we did have less hair (and what
    remained was graying). No matter what configuration we used, the software still
    ran for about a week and then locked up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we tried removing different sections of code from the system. After a
    lot of iterative testing, we tracked the problem down to a single component: Its
    presence in the build heralded a lockup; its absence prevented it. Finally, progress!'
  prefs: []
  type: TYPE_NORMAL
- en: Working out *why* this software component caused such problems wasn't straightforward.
    It was layered on top of a third-party library, which itself was built against
    a core OS library. We discovered that this core OS library had been upgraded to
    a more recent version, but the third-party library had not been rebuilt. We'd
    been continually linking against an inappropriate piece of code. While theoretically,
    this shouldn't have made a difference—the OS library change was supposedly *binary
    compatible*—a rebuild of the third-party library fixed the problem for good.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time to fix**'
  prefs: []
  type: TYPE_NORMAL
- en: The total process took about four months, elapsed time. It involved many people
    on and off over that period, consumed lots of test resources, tied up many bits
    of hardware, and caused more review meetings than you'd believe were possible.
    As bugs go, this one had a nasty sting, and caused the company a lot of pain (not
    to mention expense).
  prefs: []
  type: TYPE_NORMAL
- en: '**Lesson learned**'
  prefs: []
  type: TYPE_NORMAL
- en: Rebuild the *whole* software platform whenever *any* component changes to prevent
    subtle version mismatches.
  prefs: []
  type: TYPE_NORMAL
- en: Convince yourself that you have really found the root *cause* of the problem,
    and you're not just hiding another *symptom*. Then you can feel confident that
    you've put a fix in the right place. Consider whether similar mistakes may have
    been made elsewhere in any related modules; go and fix them if necessary.^([[7](#ftn.CHP-9-FN-7)])
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you fix a bug, check to see if the same mistake is lurking in related
    sections of code. Exterminate the bug once and for all: Fix all occurences of
    the fault now*.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try to learn from your mistake. We must learn, or else we will be doomed
    to repeat the same errors for all eternity. Is it a simple programming error you
    keep making or something more fundamental, like the incorrect application of an
    algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*With each fault you fix, learn the lessons. How could you have prevented it?
    How could you have discovered it more quickly?*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-9-FN-7)]) This is why copy and paste programming—duplicating code,
    perhaps with minor modifications—is bad. It's dangerous; you'll mindlessly duplicate
    bugs, and then you won't be able to fix them in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone will tell you that "an ounce of prevention is worth a pound of cure."
    The best way to manage the population of bugs is to not introduce them. Sadly
    I don't think that we'll ever completely reach this ideal. For as long as programming
    involves problem solving, it will always be difficult—not only do you have to
    solve the problem correctly, you have to understand the whole problem *fully*
    in the first place. Despite this, careful defensive programming can avoid many
    problems. Good programming is about discipline and attention to detail. Thorough
    testing will prevent faults from leaking out in your software releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section could be enormous, but all prevention advice boils down to that
    one simple statement: *Use your brain*. Enough said.'
  prefs: []
  type: TYPE_NORMAL
- en: Wasp Spray, Slug Repellent, Fly Paper . . .
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many useful debugging tools exist, and you'd be stupid not to take advantage
    of them. Some are *interactive*, allowing you to inspect the code while it is
    running. Others are *noninteractive*, often running as a code filter or parser
    spitting out information about the program following analysis. Learn how they
    work to immesurably reduce your debugging time.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the best known debugging tool; the name belies its purpose. A debugger
    is an interactive tool that allows you to view the internals of your running program
    and poke around with it. You can follow the flow of control, inspect the contents
    of variables, set *breakpoints* in the code for later interruption, and even run
    arbitrary sections of code at will.
  prefs: []
  type: TYPE_NORMAL
- en: Debuggers come in many shapes and sizes; some are command-line tools, and others
    are graphical applications. There will be at least one available for your particular
    development platform (although the ubiquitous gdb seems to be ported to every
    conceivable platform these days).
  prefs: []
  type: TYPE_NORMAL
- en: A debugger relies on *symbols* being left in your executable (these are elements
    of the compiler's internal information that are normally stripped out at the final
    link stage)—it uses these to provide you with information about function and variable
    names and the location of the source files.
  prefs: []
  type: TYPE_NORMAL
- en: Although debuggers are rich and powerful tools, I believe that they are often
    misused or overused, and can actually *inhibit* good debugging. Programmers easily
    become wrapped up chasing what the program is doing, getting sidetracked by observing
    the wrong variable values, stepping into the wrong functions, and they forget
    to step back and *think* about the problem they are trying to solve. A little
    more thought about a failure may pinpoint the specific fault far more quickly
    than it would take to hunt it down in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use debuggers sparingly, when you encounter behavior you can''t explain. Don''t
    reach for them routinely to use as an alternative to* understanding *how your
    code works*.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory Access Validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This interactive tool inspects your running program for memory leaks and overruns.
    It can be remarkably useful, revealing reams of memory release errors you never
    knew existed.
  prefs: []
  type: TYPE_NORMAL
- en: System Call Tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System call trace utilities, like Linux's strace, show all the system calls
    issued by an application. This is a good way to see how a program is interacting
    with its environment and is particularly useful when it appears to be stalled
    on some external activity that is not happening.
  prefs: []
  type: TYPE_NORMAL
- en: Core Dump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a Unix term for the OS-generated snapshot of a program that is produced
    when it exits abnormally. The term derives from archaic machines with *ferrite
    core* memory; the dump file is still called *core* today. It contains a copy of
    the program's memory when it died, the state of the CPU registers, and the function
    call stack. The core dump can be loaded into an analyzer (which is often the debugger)
    to reveal a great deal of useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging facilities allow you to programmatically generate information about
    your application as it runs. Rich logging systems allow you to assign priorities
    to the output (e.g., debug, warning, fatal) and then filter out a particular message
    level at run time. The program's log gives a history of activity that can help
    pinpoint the circumstances that triggered a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Even without a good logging facility (either as part of the operating environment
    or from a third-party library), you can achieve the same effect by peppering your
    code with basic print statements on an ad hoc basis. However, these printouts
    may interfere with normal program output, and they all must be carefully removed
    in the production code release.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes even lowly print instructions aren't available. Once, when bringing
    up a new piece of hardware, the only diagnostic output I had was a single eight-segment
    LED display and a scope attached to a spare system bus. It's impressive how much
    information you can shoehorn into a few lights when you try!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are downsides to logging: It can slow down program execution, bloat the
    executable size, and even introduce bugs of its own. Some logging systems, in
    which the crash destroys the buffer containing log messages, are useless for trapping
    a program crash. Be sure you know how well your logging mechanism behaves, and
    always send diagnostic print statements to an unbuffered output stream.'
  prefs: []
  type: TYPE_NORMAL
- en: Static Analyzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a noninteractive tool that inspects your source code for potential problems.
    Many compilers perform basic static analysis when set to their maximum warning
    level, but good analysis tools go far beyond this. Products exist to detect problem
    code and any usage of undefined behavior or non portable constructs, to identify
    dangerous programming practices, to provide code metrics, to enforce coding standards,
    and to create automatic test harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: Use of a static analysis tool can eradicate many errors before they have a chance
    to bite—a handy safety net. It's a pragmatic idea to use a static analyzer from
    a different company than your compiler manufacturer—two companies are less likely
    to have made the same set of assumptions or mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I can remember the exact instant when I realized that a large part of my life
    from then on was going to be spent in finding mistakes in my own programs.
  prefs: []
  type: TYPE_NORMAL
- en: --Maurice Wilkes
  prefs: []
  type: TYPE_NORMAL
- en: Like death and taxes, no matter how hard we try to avoid them, bugs happen.
    Sure, you might be able to mitigate the effects of the first two by using every
    sort of antiwrinkle cream available and manipulating your money in cunning ways,
    but if you don't know how to deal with faults when they stare you in the face,
    your code is doomed.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is a skill you develop. It doesn't rely on guesswork, but on methodical
    detection and thoughtful repair.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Don't cultivate bugs; they write code carefully to prevent introducing them
    in the first place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what their code does and write careful tests to ensure that it won't
    be broken easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hunt for bugs methodically and carefully, rather than rush in headfirst without
    a battle plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know their limitations and will ask others to help find a fault when they're
    stuck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change code carefully, even when making a "simple" repair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Don't debug; they flail around, sinking in a sea of bad code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spend most of their life in a debugger, figuring out what their code is doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encounter a failure and try to hide it—they actively avoid debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have unrealistic expectations of the quality of their code and of their ability
    to fix faults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Fix" bugs by masking symptoms rather than tracing the problem back to its
    real cause'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  prefs: []
  type: TYPE_NORMAL
- en: How to prevent bugs from ever gaining a foothold in your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  prefs: []
  type: TYPE_NORMAL
- en: You can't fix a fault until you know it exists. Thorough testing is a prevention
    mechanism that stops faults from leaking out into your software releases.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code reviews* help to pinpoint and eradicate bugs and can identify problem
    areas that would otherwise go undetected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207470.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 500.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is it best for faults to be fixed by the original programmer who wrote the code?
    Or is the programmer who discovered the problem better placed to make a fix?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell when to use a debugger and when to use your brain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should learn unfamiliar code before you start trying to find and fix faults
    in it. But the time pressures of the software factory often dictate that you can't
    spend any serious time studying and understanding the program you're repairing.
    What's the best way forward?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe good techniques to avoid memory-leak bugs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it justifiable to have a quick stab at finding and fixing a fault, rather
    than adopting a more methodical approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How many debugging techniques/tools do you routinely use? What others have you
    seen that you might find useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common problems and pitfalls in your language(s) of choice? How
    do you guard against these kinds of bugs in your own code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are most of the bugs that occur in your code sloppy programming errors, or are
    they more subtle issues?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do you know how to use a debugger on your platform? How routinely do you use
    it? Describe how to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Produce a backtrace
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect variable values
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect value of fields within a structure
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run an arbitrary function
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Swap thread contexts
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10. THE CODE THAT JACK BUILT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mechanisms to Turn Source Code into Executable Code*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What you spend years building may be destroyed overnight. Build anyway.
  prefs: []
  type: TYPE_NORMAL
- en: --Mother Teresa
  prefs: []
  type: TYPE_NORMAL
- en: The programmer (*Geekus maximus*) is usually found in its natural habitat, hunched
    in the ethereal glow of a monitor, entering profound combinations of punctuation
    characters into a text editor. Occasionally, this timid beast will leave the confines
    of its lair to forage for coffee or pizza. Quickly it returns to safety, continuing
    its ritual at the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: If typing language constructs was all there was to programming, then our job
    would be a great deal easier, although we'd risk being replaced by the proverbial
    infinite number of monkeys with their infinite number of text editors. Instead,
    we must run our source code through a compiler (or interpreter) to obtain something
    that might just function as we intend it to. Invariably, it doesn't. Rinse and
    repeat.
  prefs: []
  type: TYPE_NORMAL
- en: The task of converting carefully honed, high-level language into an executable
    that can be distributed is commonly referred to as *building* code (although you'll
    find that this term is used pretty interchangeably with *making* and *compiling*
    in most contexts).
  prefs: []
  type: TYPE_NORMAL
- en: This act of building is a fundamental part of what we do—we can't develop code
    without performing a build. It's important, then, to understand what's involved
    and how your project's build system works in order to have any confidence in the
    code that's generated. There are a lot of subtle issues at play here, especially
    when a codebase reaches a reasonable size. Interestingly, almost all programming
    textbooks will gloss over this kind of topic; they present single-file example
    programs that don't show any real build complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers rely on their IDE's build system, but this doesn't remove the
    burden of understanding how it works. It's very convenient to hit a button and
    have all your code generated, but if you don't know which options are being passed
    to the C compiler or which level of instrumentation is left in your object files,
    then you're not really in control. The same holds true if you type a single *build*
    instruction at a command prompt. You must understand what's going on under the
    hood to be able to repeatably perform reliable builds.
  prefs: []
  type: TYPE_NORMAL
- en: Language Barriers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several varieties of programming languages, each with its own mechanical
    process of constructing an executable program from source code. Some construction
    models are more complex than others, and each has its strong and weak points.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main mechanisms: *interpreted* languages, *compiled* languages,
    and *byte-compiled* languages. These are shown in [Figure 10-1](ch10.html#programing_language_build_and_execution_methods
    "Figure 10-1. Programing language build and execution methods").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Programing language build and execution methods](tagoreillycom20080909nostarchimages207472.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10-1. Programing language build and execution methods**'
  prefs: []
  type: TYPE_NORMAL
- en: '**DO WE REALLY *BUILD* SOFTWARE?**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Building* is often used as a metaphor for programming, equating what we do
    to the "traditional" building industry. There are many striking parallels, since
    both are construction processes. We have, in fact, seen some sort of overlap and
    collaboration between the two disciplines, as the software patterns movement (see
    "[DESIGN PATTERNS](ch13s05.html#design_patterns "DESIGN PATTERNS")" on page 255)
    learned from Christopher Alexander''s architectural work.(Alexander 79)'
  prefs: []
  type: TYPE_NORMAL
- en: It's valuable to understand how far this metaphor stretches and how useful it
    really is. No metaphor is perfect, after all. Although philosophical and a bit
    of an aside, it *does* matter because the comparison will inevitably prejudice
    our approach to development. The metaphor is helpful in places; elsewhere it's
    less than perfect (even potentially harmful).
  prefs: []
  type: TYPE_NORMAL
- en: '**The good**'
  prefs: []
  type: TYPE_NORMAL
- en: Like the physical construction process of a house, we start from nothing and
    buildby placing one layer of structure atop another. Before the construction begins,
    a process of gathering requirements and careful design and architecture should
    have been performed. While you can probably build a garden shed without much planning,
    you'd be crazy to hope an unplanned skyscraper had a chance of standing up; you
    need serious design and planning up front. This neatly parallels our software
    construction.
  prefs: []
  type: TYPE_NORMAL
- en: '**The bad**'
  prefs: []
  type: TYPE_NORMAL
- en: The metaphor stretches thin in other areas, though. We can modify the foundational
    layers of our software constructions more easily than the foundations of a house.
    It's far cheaper to tear down a software edifice than a physical one. This means
    that the software world offers the opportunity to prototype and explore more often
    than the physical world does.
  prefs: []
  type: TYPE_NORMAL
- en: Real World building mandates sound engineering principles; this is enshrined
    in statute and enforced by public liability. Many software firms wouldn't know
    an engineering principle if it slapped them in the face.
  prefs: []
  type: TYPE_NORMAL
- en: '**The ugly**'
  prefs: []
  type: TYPE_NORMAL
- en: Our entire development procedure *is* akin to a physical construction process,
    comprising system conception, design, implementation, and testing. But what we're
    actually thinking about in this chapter is subtly different—it revolves around
    *compilation* and the procedures involved in *this kind* of building task. The
    metaphor's a bit out of kilter here too. Each time you take a fresh copy of some
    source code, you "build" it, creating an executable program; *that* is what we're
    looking at here. Be clear about these two different uses of the term "build."
  prefs: []
  type: TYPE_NORMAL
- en: The software build process follows its own rules—if you modify a function, you
    must then perform a system rebuild. In contrast, you don't have to rebuild the
    walls in your house every time you paint the doors.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreted Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code written in interpreted languages does not need to go through a specific
    build phase. After writing some code, you need only tell the interpreter where
    it is; it parses and acts on the instructions in real time. Common interpreted
    languages are Perl, Python, and JavaScript. The majority of OO languages are interpreted,
    largely because they have been developed more recently as computers have become
    better able to run interpreters at reasonable speeds.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of interpreted languages is their speed of development; with
    no intermediate *compile* stage; you can test each change very quickly. You also
    gain platform independence—popular language interpreters run on many different
    platforms. Your program will work wherever the interpreter has been ported.
  prefs: []
  type: TYPE_NORMAL
- en: 'But interpreted programs have some disadvantages: They execute more slowly
    than a compiled equivalent since the language run time has to read, parse, interpret,
    and act on each individual code statement. That''s a lot of work. Modern machines
    are so fast that this is only a problem for the most computing-intensive applications.
    There are various interpreter technologies that improve code performance: Some
    languages precompile the source file before execution (slowing down startup time)
    or employ *Just-In-Time ( JIT)* compilation, compiling each function as it''s
    about to be run (slowing down each function''s first call). For most programs,
    this isn''t an appreciable overhead, and JIT-compiled performance is indistinguishable
    from native compiled code.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Scripting languages* are often interpreted. These languages support a very
    fast development cycle by being very forgiving to questionable code (with lax
    language rules and weak typing) and by avoiding complex features. Scripting languages
    are often used as glue to invoke other utilities in more convenient ways. Unix
    shell scripts, Windows batch files, and Tcl are examples of scripting languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiled Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compiled languages employ a build toolchain to convert your source code files
    into machine instructions that will execute natively on the target platform. The
    target execution platform is usually the same as the development platform, but
    embedded developers often build on a PC and target very different machines, using
    a *cross compiler*. Large projects are compiled in several stages; each individual
    source file is compiled into an intermediate *object file*, and then these objects
    are linked into a final executable. This build model is illustrated by the cake-baking
    metaphor, shown in [Figure 10-2](ch10.html#compilation_confectionary "Figure 10-2. Compilation
    confectionary"), where individual ingredients (source files) are mixed (compiled)
    and finally baked together (linked).
  prefs: []
  type: TYPE_NORMAL
- en: C and C++ are the most popular compiled languages, although most structured
    languages are compiled. By its very nature, a compiled application will run faster
    than its interpreted counterpart (at least, without JIT compilation), although
    in practice, you won't notice this—most applications are not computing-intensive;
    they spend most of their time stalled and waiting for user, disk, or network input.
  prefs: []
  type: TYPE_NORMAL
- en: The compiled language build procedure is more complex than an interpreter, so
    there are more possible points of failure. An application has to be recompiled
    for each target platform you want to run it on.^([[1](#ftn.CHP-10-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: '![Compilation confectionary](tagoreillycom20080909nostarchimages207474.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10-2. Compilation confectionary**'
  prefs: []
  type: TYPE_NORMAL
- en: Byte-Compiled Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Byte-compiled languages sit halfway between interpreted and compiled languages.
    They involve a compilation step but don't produce a native executable program.
    Instead, the product is a file of *byte code*; a pseudo machine language that
    can be executed by a *virtual machine*. Java and C# are common byte-compiled languages.
  prefs: []
  type: TYPE_NORMAL
- en: A common misconception is that executing byte code is *necessarily* slower than
    executing an equivalent compiled binary. This is not always so. A JIT optimizer
    can make intelligent decisions about the code that may make it particularly fast
    (for example, tailoring itself to the exact hardware the program is executing
    on).
  prefs: []
  type: TYPE_NORMAL
- en: As a compromise, byte compilers inherit some of the advantages and disadvantages
    of the previous approaches. Byte code can be executed on any platform the virtual
    machine has been ported to, so you gain portability (although some language run
    times are more widely ported than others).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-10-FN-1)]) Target platforms are distinguished by their processor
    types and the host operating systems. Other factors, like the available peripheral
    hardware, may be important.
  prefs: []
  type: TYPE_NORMAL
- en: Making Mountains out of Molehills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compiled (and byte-compiled) build models are the hardest to reason about,
    so let's investigate what compiling software entails. It's shocking how few newly
    trained programmers really understand this, so we'll start from first principles.
    If you already know this stuff, feel free to skip ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a good understanding, it''s best to think about each manual step rather
    than rely on your IDE to do all the rebuilding work for you. This five-part story
    of a simple program''s development will explain:'
  prefs: []
  type: TYPE_NORMAL
- en: You're starting a new project, coded in C. It will solve all the ills of the
    software development world and will usher in a new era of world peace. However
    all you have at first is a single file containing `main`. You've got to start
    somewhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's easy to build and run this single-file program—you just type `compiler
    main.c`,^([[2](#ftn.CHP-10-FN-2)]) and out pops an executable for you to run and
    test. Simple.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The program grows. To help organize the parts, you split it into multiple files,
    one per functional block. The build is still a simple process. Now you type `compiler
    main.c func1.c func2.c`. The same executable program pops out, leaving you to
    carry on testing as before. No sweat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Soon, you recognize that some sections of the code are really individual components
    with isolated concerns, almost like stand-alone libraries. It would be easier
    to reason about these sections of code by placing them in their own directories—grouping
    the similar sections of code together. Now the project is beginning to spread
    out. The simple way to build this new file structure is to compile each individual
    source file by hand, using a compiler call that doesn't build an executable, just
    intermediate object files. Afterward, `main.c` is compiled and linked with all
    the intermediate object files. To do this, you may also have to point the compiler
    at some other directories' include files. Now things are getting a little more
    complex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you change some code in one of the new directories, you have to fire
    off the compile command in *that* directory and then issue the final "link everything"
    command once more. Quite manual. Additionally, if you change a header file that
    other directories use, all of *those* directories have to be rebuilt too. If you
    forget, the linker will probably generate a slew of cryptic complaints.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To eliminate this huge command-line burden, you can write a *shell script* (or
    *batch file* in Windows) that walks around each directory and fires off the requisite
    build commands. Having hidden all that messy work and the tedious compiler parameters,
    you can get back to the serious business of code development with the peace of
    mind that you don't have to memorize unnecessary build fluff.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Later on, these subdirectories become real stand-alone libraries; they are also
    used in other projects. You tidy up the code so it's a little friendlier to use,
    add some good user-facing documentation, and then alter the build commands to
    generate *shared libraries* rather than object files. This requires some more
    changes to your build script, but it's a relatively hidden change and isn't too
    painful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Development carries on like this for some time. Code is added rapidly. Many
    new subdirectories and sub-subdirectories are created. Although the file structure
    seems pretty neat, build times become a problem—each time you fire up the build
    script, it recompiles every source file, even those that haven't changed. The
    temptation here is to track all changes yourself and to issue subdirectory builds
    by hand again (perhaps by creating individual directory build scripts as a halfway
    house). The project is now so large that it would be very easy to miss some dependencies.
    This would lead to hard to resolve build errors, or even subtler problems (e.g.,
    you may encounter flaws that don't stop the link from working, but that do make
    the program behave in incorrect ways).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now your development is on the brink. You can't trust the system being used
    to build the code. It's not safe. You can only really trust the executable if
    you've done a complete cleanout and rebuilt from scratch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter the tool for just this occasion. The classic solution is a command-line
    program imaginatively called make. (Feldman 78) It deals with all of the intermediate
    object files and compilation rules for you and, most importantly, tracks which
    files depend on which other files. You tell it what to do by writing makefiles
    that provide the necessary build rules. It looks at the source file timestamps
    to check what has changed since you last performed a make, and then it recompiles
    just those files, along with anything dependent on them. It's a more intelligent
    version of the scripts we wrote above, specifically tailored to the task of compiling
    and recompiling software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the years, many variants of the humble make have appeared, these days
    many with pretty GUI façades. GNU Make is one of the most widely used tools (it''s
    free and very flexible). If you haven''t been initiated into the Cult of Make,
    "[MAKE: A TOURIST''S GUIDE](ch10s03.html#make_colon_a_tourist_apos_s_guide "MAKE:
    A TOURIST''S GUIDE")" on page 183 explains its basic operation.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other build systems in common use. Look at SCons, Ant, Nant,
    and Jam for examples. They are each tailored to a specific kind of build environment
    (for example, Nant is used to build .NET projects) or for a particular quality
    (many aim to simplfy the syntax of make, which is quite baroque!).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-10-FN-2)]) Obviously, you would replace `compiler` with the command
    to prod your C compiler—this is a hypothetical example.
  prefs: []
  type: TYPE_NORMAL
- en: Building Builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In that sinking morass of software construction, we've seen some of the main
    issues of a build procedure. Essentially, any software build process takes one
    or more source files as input, and it spits some executable program out the other
    end. It may even produce an entire release distribution, including an executable,
    help files, an installer, and so on, all packaged neatly and ready to be burned
    onto CD.
  prefs: []
  type: TYPE_NORMAL
- en: '**TERMS AND CONDITIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These terms comprise the main software construction terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source code**'
  prefs: []
  type: TYPE_NORMAL
- en: Source code is physically contained in the files that you write, and it usually
    occursin a high-level language. These language constructs can be converted into
    a functioning program with the appropriate tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compilation**'
  prefs: []
  type: TYPE_NORMAL
- en: Source code is converted into an executable in one of two ways. One is to *compile*
    it into an executable program. The alternative is to *interpret* the source code
    in real time—a language run time parses and acts on the source code as the program
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a vague term, often used as a synonym for *compile*. Compilation is
    a single construction step, whereas a build describes the entire construction
    process. The term *make* is used in a similarly vague fashion; even worse, it
    is also the name of a common software build tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object code**'
  prefs: []
  type: TYPE_NORMAL
- en: Object code is held in an *object file*. It represents the compiled version
    of a file of source code. Object code is not directly executable; it relies on
    other files of code (most programs are made of more than one source file). An
    object file must be *linked* with other objects to create an *executable*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Library**'
  prefs: []
  type: TYPE_NORMAL
- en: A code *library* is akin to an object file—it is a collection of compiled code
    and not itself a whole program. A library contains a cohesive collection of useful
    functionality that can be incorporated into any program. A library can be *static*
    or *dynamic*. The former is linked like an object file, whereas the latter is
    dynamically loaded by the application when it is run.
  prefs: []
  type: TYPE_NORMAL
- en: '**Machine code**'
  prefs: []
  type: TYPE_NORMAL
- en: Some compilation steps produce *machine code* rather than object files. This
    is a form of source code that represents the exact CPU instructions for a program.
    Machine code is converted into real CPU instructions by an *assembler*, which
    is why it's also known as *assembly code*.
  prefs: []
  type: TYPE_NORMAL
- en: Some low-level OS libraries and embedded programs are written in assembly language,
    but we generally work in high-level languages and leave assembly to the internal
    workings of the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linking**'
  prefs: []
  type: TYPE_NORMAL
- en: The *linker* combines one or more *object files* (and perhaps libraries) into
    a final executable or into a partially linked code *library*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executable**'
  prefs: []
  type: TYPE_NORMAL
- en: The outcome of a compile or link step. This is a self-contained program that
    can be run directly on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Like the cumulative story from which I shamelessly pilfered this chapter's title,
    as our software develops and matures, the build process develops and matures with
    it. Maybe yours didn't start in as basic a state as the example above, but build
    scaffolding tends to start simple and grow alongside the code it builds. A large
    project often has a bewildering build process that requires (but doesn't necessarily
    always have) adequate documentation. We can see that the act of compiling a single
    source file is at the lowest level of the build food chain, and we will raise
    a tower of extra work upon this simple act.
  prefs: []
  type: TYPE_NORMAL
- en: A build process is not *just* about compiling source files. It may also involve
    preparing some text registration files from templates, creating internationalized
    strings for the UI, or converting graphics files from their source resolution
    to some destination format. Practically all such activities can hang off a build
    system and be run in the normal course of a build. This does presume that all
    the tools are scriptable—that they can be run by some other program (e.g., by
    make).
  prefs: []
  type: TYPE_NORMAL
- en: It's important to consider your build system a part of the entire source tree,
    not something separate. Makefiles are kept under revision control alongside other
    source files, are maintained alongside the source, and are as much a part of the
    program as any other source file. They're essential—you can't create the application
    without them.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Consider the build system a part of the source tree, and maintain the two
    together. They are intimately entwined*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKE: A TOURIST''S GUIDE**'
  prefs: []
  type: TYPE_NORMAL
- en: Make is one of the most widely used build systems in the programming world.
    Here is a whirlwind tour of what it is and what it can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make is driven by *makefiles*, which usually reside in directories beside the
    source code they build. These makefiles contain *rules* describing how to build
    the application. Each rule describes a *target* (that is, a program or intermediate
    library to build), details what it depends on, and how to create it. Comments
    in the file are prefixed by `#`. Here''s a short example (using the hypothetical
    `compiler` program to build source):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the general idea. If you save this with the magic filename `Makefile`
    and then issue the make `myapp` command, it will be loaded and parsed. Since `myapp`
    depends on some .`o` files, these will first be built from their respective .`c`
    files using the rule provided. Then the linker command will be run to create the
    application. There are many ways to neaten this up so that it''s more manageable.
    For example, makefiles can define variables; the `myapp` rule looks nicer like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A deeper description of the nuts and bolts of make usage is outside the scope
    of this book, but it's something every developer ought to know. There are many
    more useful features available. GUI build tools are essentially wrappers around
    this kind of functionality, hiding the detail of writing makefiles. They are generally
    easier to set up, but can be a hindrance when you want to do some advanced build
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: What Makes a Good Build System?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following are a few important qualities of a good build system.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The build system must be accessible to *all* programmers, not just the build
    gurus. Every developer must be able to perform a build, or he can''t get any work
    done. If a build system is too complicated, it''s practically useless. It must
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple to learn**'
  prefs: []
  type: TYPE_NORMAL
- en: That is, a new developer should be able to join the team and quickly understand
    how to build software. He won't be productive until he's mastered the build procedure.
    I've worked in companies where it was considered a *rite of passage* to figure
    out how the build works and to perform one. That is not just an unhelpful attitude,
    it is dangerous—what happens when everyone who really knows how to build the code
    leaves?
  prefs: []
  type: TYPE_NORMAL
- en: As software grows, it becomes larger and harder to understand. As the build
    system grows alongside it, it becomes larger and harder to understand. Builds
    tend to become more clever and more cryptic as new facilities are introduced.
    Resist complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple to set up**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up a build means:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking a clean PC (with just a fresh copy of the host OS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing all the necessary software (compilers, translators, source control,
    installers, plus patches/service packs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing all the necessary libraries (noting the correct versions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the correct environment to perform a build in (this may involve setting
    up directory structures, assigning environment variables, getting the correct
    tool licenses, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without clear instructions for setup, how can you be sure that your build is
    a repeatable procedure?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unsurprising**'
  prefs: []
  type: TYPE_NORMAL
- en: It's best to use common, well-known build tools. They are what people expect
    and know how to use, so the learning curve is less steep. Complex build tools
    that do things no one really understands are worrying.^([[3](#ftn.CHP-10-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: Uniformity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's essential that everyone uses the same build system. Otherwise they're not
    building the same software. Different build mechanisms may seem equivalent—*I
    use my IDE while he uses makefiles*—but you're increasing the maintenanc effort
    and the potential for error. Subtle differences can creep in—for example, compiler
    options may not be the same, resulting in a different executable.
  prefs: []
  type: TYPE_NORMAL
- en: This dovetails with the requirement to maintain the build system alongside the
    source tree. If the build system physically *is* a part of the code, then it can't
    be ignored or avoided.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Every programmer on a project must use the same build environment. Otherwise
    you''re not all building the same software*'
  prefs: []
  type: TYPE_NORMAL
- en: This may seem blindingly obvious, but it's incredibly easy to get wrong. Even
    if you *are* all happily sharing makefiles, other differences can slip past unnoticed—mismatched
    versions of libraries, tools, or the build scripts can all lead to a different
    program being built.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable and Reliable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Builds must be deterministic and reliable. You should be able to determine the
    set of input files easily before performing the build. Performing two separate
    builds on the same set of files should give you exactly the same executable both
    times—the build should be *repeatable*.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A good build system allows you to repeatedly create physically identical binary
    files*.'
  prefs: []
  type: TYPE_NORMAL
- en: You can then mark this set of source files in the revision control system as
    a particular version of the software (or archive the files to a backup store),
    and perform many identical builds at any time in the future.
  prefs: []
  type: TYPE_NORMAL
- en: This is crucial—an important customer may find a significant bug in an old revision
    of software, and if you can't get back to that version and generate the exact
    same program, you may never be able to reproduce the failure, let alone find the
    fault.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You must be able to pull out a source tree from three years ago and rebuild
    it correctly*.'
  prefs: []
  type: TYPE_NORMAL
- en: A build process that spits out an unreproducible binary is worrying. If what
    comes out of a build depends on the lunar cycle, the world becomes a hard place
    to reason about. This means that gratuitous use of C's `__DATE__` or other potentially
    changeable information should be kept to an absolute minimum in the source files.
  prefs: []
  type: TYPE_NORMAL
- en: The build must work perfectly all the time—it must be *reliable*. If it falls
    over every other day or occasionally produces a broken binary, then it is worse
    than useless—it's dangerous. How can you be sure that you're testing a good binary?
    How can you be sure that your company is releasing an acceptable product? Problems
    with the build system really hamper development.
  prefs: []
  type: TYPE_NORMAL
- en: The build should be almost invisible; the only thing you need to worry about
    is how to turn the handle, and you should be assured that the right things will
    come out at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ideal build system takes undoctored *virgin source* and compiles it all
    at once, with no human intervention. There should be no special steps you have
    to go through to perform the build. You should not have to fire up another application
    halfway through and prod a file. You shouldn't even need to run more than one
    command to perform the build. This ensures that no information is locked away
    in your head, just waiting to be lost. All the build magic is documented in a
    reliable place—the build script itself. The build is always repeatable. It's safe.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A good build is presented as a single step. You need only push a button or
    issue one command*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t reach this ideal (and it''s not *at all* unreasonable), then
    the less manual a build is, the better. All of the manual steps need full documentation.
    It is acceptable (in fact, it''s advisable) to break the procedure up into these
    separate parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the virgin source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the release distribution from this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See how the notion of *building* the code is separate from *obtaining* it—the
    same build instruction could potentially create any version of the software, depending
    on the version of source you start with. *Packaging* the program is also a separate
    step; for development work, you don't always want to waste time creating a full
    install package.
  prefs: []
  type: TYPE_NORMAL
- en: '**A WAR STORY**'
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable builds are essential; you must be able to regenerate any released
    version of your software. You'll get into trouble otherwise. I once worked for
    a company that struggled with this exact problem.
  prefs: []
  type: TYPE_NORMAL
- en: They had made a live change to the code on a customer's site and did not replicate
    the change in their master copy under version control. The customer was no longer
    running an "official" software release. Later on, when the customer found a critical
    bug, the programmers couldn't reproduce it. But of course no one could figure
    out why, because the on-site tweak had been long forgotten.
  prefs: []
  type: TYPE_NORMAL
- en: Why did they do this? Because it was much, much easier to make a quick-anddirty
    change than to do it properly (i.e., fix the bug in the main codebase, test it,
    make an official software release, ship it to the customer, and then get the appropriate
    approval and sign-off before installation). When your client's business depends
    on your software and its entire production line is waiting for you to fix a bug,
    the pressure for a dirty hack is enormous.
  prefs: []
  type: TYPE_NORMAL
- en: Coping with Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the end of development, when the dust settles over finished code, there will
    be *no* build errors. But during development you'll be breaking things all over
    the place. The build system has to cope with this and should lend a hand to deal
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Your build system should not continue after an error. It should stop and leave
    you with no doubt about what broke and where it can be fixed. If the build process
    continues, other problems will almost certainly result as a consequence of that
    first skipped error. These will be very hard to understand. For your own sanity,
    don't break this rule!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build system should remove any incomplete objects when a build step fails.
    Otherwise the next time you run a build, it will assume that file is actually
    intact and pick up after it. This will cause much pain later on; errors that magically
    hide themselves are great fun.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builds should not be *noisy*. This isn't determined so much by the build process
    as the source code that you've written.^([[4](#ftn.CHP-10-FN-4)]) If your code
    generates compiler warnings, then there is something in it that you should be
    looking into. Persuade the compiler to be quiet by writing better code. Copious
    silly warnings can cloak the more insidious messages that you *should* be reading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For maximum peace of mind, build with all compiler warnings enabled—switching
    them off does not fix the problem; it hides it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The only real way to follow this advice is from the very start: Think about
    the build process at the beginning of your project. Trying to add the flag that
    says *all warnings enabled* when you''ve already written a lot of code will result
    in an instant flood of warnings. The overwhelmingly likely response is to quickly
    turn the flag off again and pretend it never happened. Anything for an easy life.
    You really have to start as you mean to go on.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-10-FN-3)]) I have an built-in distrust of anything more clever than
    GNU Make, but that probably says more about me than the other clever make tools.
    GNU Make is *quite* clever enough, thank you!
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-10-FN-4)]) Actually, it could be—you can disable compiler warnings
    to remove the noise. This is the *wrong* way to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The Mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond those quality concerns are the practicalities of a build system. To discuss
    this in concrete terms, we'll talk about make, a specific build system, and makefiles
    a lot—don't worry too much; barring syntactic differences, other build systems
    follow similar conventions (even the pretty graphical ones).
  prefs: []
  type: TYPE_NORMAL
- en: Choice of Targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Makefiles define *rules* that describe how to build *targets*. (Remember: Other
    build systems work in a very similar manner, even if the terminology is subtly
    different.) The system is clever enough to infer all intermediate targets and
    build those along the way. A single makefile can contain multiple targets. This
    allows you to use one build system to generate several different outputs, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Distinct programs (commonly seen when two programs have some common code components
    and so live in the build source tree)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different target platforms to build your application for (say a Windows/Apple/Linux
    version, or a desktop/PDA release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product variants (the full *release build* or a *demo* version with save/print
    disabled)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development build (with debugging support enabled, logging switched on,
    and assertions made fatal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differing *levels* of build (build just the internal libraries, build the application,
    build an entire distribution)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might even require some combination of these targets, say a "demonstration
    PDA" build.^([[5](#ftn.CHP-10-FN-5)]) You can design your source tree so that
    each of these targets can be built from the same place. Rather than type just
    `make`, you might type `make desktop` or `make pda`, and an appropriate executable
    will come out the other end. (The name following `make` is the rule it should
    attempt to build.)
  prefs: []
  type: TYPE_NORMAL
- en: There is a huge benefit in doing this rather than having separate source trees
    for each target. Maintaining several source trees across which most of the code
    is identical would be an intense and error-prone task. You could easily forget
    to apply one of your modifications to all copies of the code.^([[6](#ftn.CHP-10-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do these target rules differ? The actual differences can boil down to
    a number of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Different files being built (e.g., `save_release.c` or `save_demo.c`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different macro definitions being passed through to the compiler (e.g., the
    compiler predefines a `DEMO_VERSION` macro to select appropriate `#ifdef`ed code
    in `save.c`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different compiler options being used (e.g., to enable debugging support)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different tool sets or environments being selected for building (e.g., using
    the correct compiler for the target platform)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you could have any number of targets for all sorts of minor differences,
    it opens the possibility of making your build system complex and unwieldy. Some
    selections can be moved to build configuration options. Some configuration can
    actually be done at code install time, or even at run time. This is preferable
    if it reduces the number of different builds that exist and require testing.
  prefs: []
  type: TYPE_NORMAL
- en: '**LIFE AFTER MAKE**'
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the issues we're investigating here are quite specific to the C-style
    development cycle, where a compiler generates object code and libraries from source
    files, and these are linked into a final executable. Some languages follow a different
    model. Java simplifies the build process greatly; the javac compiler takes over
    the role of make, performing dependency checks automatically. It locks you down
    more, enforcing a particular build tree structure, but makes your life easier
    by doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Java programs don't need an elaborate build system; one `javac` command
    can safely rebuild the world. However, a reasonably large Java project often *will*
    employ make. We've seen that there is more to a build than just compiling source.
    You need a mechanism to prepare supporting files, to run automated tests, and
    to create the final distribution. Make is a good framework for this to hang off
    of, so it isn't entirely redundant.
  prefs: []
  type: TYPE_NORMAL
- en: Housekeeping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For every target rule you define, there should be a corresponding *clean* rule
    that undoes all the build operations—removing the program executable, intermediate
    library, object files, and any other files created during the build. The source
    tree should revert to its original virgin state—it's relatively easy to verify
    that it does.^([[7](#ftn.CHP-10-FN-7)])
  prefs: []
  type: TYPE_NORMAL
- en: This implies that a build system that physically alters the source files is
    nasty—how can you easily revert from these changes? You should instead use the
    original files as templates, and send modifications to a different output file.
  prefs: []
  type: TYPE_NORMAL
- en: Clean rules are a good housekeeping convention. They allow you to easily sweep
    everything away and rebuild from scratch when you think that a build gremlin is
    catching up to you.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For every build rule, have a corresponding clean rule that undoes the action*.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does a build system know which files depend on which others? Short of ESP,
    it's a difficult task, and so we will elicit help from the people who do know.
  prefs: []
  type: TYPE_NORMAL
- en: '*You* provide dependency information in your makefile rules: a recipe in make''s
    preferred format. Make can build and follow the tree of dependencies, inspect
    each file''s timestamp, and work out which parts need to be rebuilt after any
    modification.'
  prefs: []
  type: TYPE_NORMAL
- en: This is simple enough for an executable build rule—you just need to specify
    which object files and libraries comprise it. You don't, however, want to laboriously
    specify dependency information for every single source file; no doubt there are
    many `#include`d files, which themselves `#include` many others. Quite a list.
    It would be really easy to type incorrectly at first and very likely to become
    out of date; you could easily add a new `#include` and forget to alter the makefile
    correspondingly.
  prefs: []
  type: TYPE_NORMAL
- en: Who *does* know about all this dependency information? The compiler does—it's
    the one component in the build system that actually traces all source file dependencies.
    Helpfully, all good compilers have an option that causes them to spit out dependency
    information. The trick is to write a make rule that gathers this dependency information,
    places it in an appropriately formatted file, and then includes *that* in the
    dependency tree.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your build procedure is atomic, a simple matter of firing off one command,
    you can easily set up overnight builds of the entire source tree.^([[8](#ftn.CHP-10-FN-8)])
    A regular overnight build takes the code that has been produced during the day
    and applies the full build procedure to it. This is a remarkably helpful practice
    with many benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Every morning there's a fresh copy of the state of the art. Developers often
    spend the day in their own little worlds, forgetting to synchronize their code
    with colleagues' check-ins. This technique provides a painless integration test,
    checking that everything knits together properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It identifies build problems early on, with no extra work on your part. When
    you sit down at your desk in the morning, coffee in hand, you can see whether
    the source tree is in a buildable state. You'll know immediately where to start
    fixing, rather than wait for your own build to complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add automated regression and stress tests to the overnight build. This
    is a good way to sanity-test code before anyone ever tries to use it. During the
    day, you may not have time to run the full test suite with every build—this ensures
    that it never gets overlooked. It's a potent validation mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overnight build can be used as a yardstick of project progress. Publish
    the overnight test results and, as more and more tests pass, the developers gain
    a sense of achievement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can make actual product releases from the overnight build. You'll trust
    this build to have not suffered from command-typing mistakes, misconfiguration,
    or other human errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It proves that you really know how to build the software and that the build
    procedure really *is* atomic. Without running automatic builds, how do you know
    that your build process doesn't rely on some other activity, like one of the developers
    cleaning away the old build tree first?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Establish an automatic build of your software. Use it to ensure that your
    codebase is in a consistent state*.'
  prefs: []
  type: TYPE_NORMAL
- en: Automated builds are especially good for big systems (where a build of *everything*
    may take hours and hours) or for systems with many people working alongside one
    another (where each developer may not have a copy of the absolute latest system
    source at any given point).
  prefs: []
  type: TYPE_NORMAL
- en: A good practice with nightly builds is to capture the *build log* (the output
    of the build procedure) and make it publicly accessible. Perhaps even email the
    results around when the build fails, to highlight the problem. It's important
    to know what happened each time a build ran, especially when something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overnight build becomes a central heartbeat of project development. The
    code is developing healthfully and happily if the builds are successful. A great
    rule enforced on many projects is: *Don''t break anything in the source tree*—checking
    in code that breaks during the nightly build is punishable by something extremely
    painful and unpleasant (preferably involving public humiliation). A second rule
    is this: *If the build breaks, it''s everyone''s problem*. If the overnight build
    fails, all developers must put down their down tools until it works again.'
  prefs: []
  type: TYPE_NORMAL
- en: You can take this automatic build procedure to the extreme, and use tools that
    perform a build whenever the source repository is altered. This is known as continuous
    integration and is a powerful way to check that your code is consistent and buildable
    at any point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Build Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good build system allows you to configure certain aspects on a per-build
    basis. This could be via options in your IDE, but makefiles usually achieve this
    by defining *variables*. Variables can be picked up from a number of places:'
  prefs: []
  type: TYPE_NORMAL
- en: Inherited from the calling environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set on make's command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined explicitly within a makefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration variables are commonly used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A `PROJECT_ROOT` variable is defined, pointing to the root of the build tree.
    This allows the build system to know where to look for other files—for example,
    to establish paths for header files. You really don't want to hard-code the location
    of the build tree on your development machine. If you did, you could never move
    it around, and you wouldn't be able to manage two build trees at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other variables may specify where to find each external library (so you can
    point the build at different versions for testing purposes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may specify the kind of build to produce (*development* or *release*, for
    example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command to invoke each build tool (compiler, linker, etc.) can be placed
    into a variable. This makes it easy to test a different set of command-line parameters,
    or to employ a different vendor's tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can put default values into the makefile. This serves two purposes: it
    documents all the available options and means you don''t *have* to provide values
    for every config option all the time.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Make
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source code naturally nests into directories. If all the files in a large project
    got dumped into one directory, things would rapidly become unmanageable. Since
    the source tree nests, the build system has to nest too. Far from making life
    more complex, accommodating this nesting can make the build system more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: A makefile in one directory can invoke the makefiles in subordinate directories
    by firing off another `make` command, just as it would invoke a compiler. This
    is a common technique known as *recursive make*; the build system that recurses
    into each subdirectory builds the components in there and returns to build the
    components in this directory. In this way, you can type `make` from the project
    root directory to build the whole codebase, or within a subcomponent's directory
    for a partial build. Whatever you want to be built is built.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive make helps to compartmentalize and manage build components, but introduces
    some problems of its own. It is slow (as it fires off many child processes to
    traverse into subdirectories), and since each child-make only sees its portion
    of the entire build tree, it can get dependency information incorrect. Be wary
    of recursive make if you see it—prefer to make non-recursive build systems. (For
    more on this, see the answer to this chapter's "[Mull It Over](ch09s10.html#mull_it_over-id8
    "Mull It Over")" question 7 on page 506.)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[5](#CHP-10-FN-5)]) In this case, the mechanism changes: You can only build
    one target at a time, so the "demo-ness" would become a build configuration rather
    than a target. A later section discusses configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-10-FN-6)]) Note how this dangerous approach is different from maintaining
    multiple *branches* of a project in a revision control system. Revision control
    systems provide a mechanism to *merge* changes across branches and to easily compare
    branches for differences.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-10-FN-7)]) Just do a build, do a clean, and then check the tree
    for differences from the start state.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#CHP-10-FN-8)]) Time-delayed commands can be set up in Unix using the
    cron utility or in Windows using the Scheduled Tasks facility.
  prefs: []
  type: TYPE_NORMAL
- en: Please Release Me
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some builds are particularly important and require more care in their preparation.
    These are *release builds*, builds that are made with a special purpose, rather
    than in the course of code development. A release could be one of a number of
    exciting events: a beta version, the first official product release, or a maintenance
    release. It may also be an internal development milestone or an interim release
    to the test department; these builds won''t leave the company but are held in
    as high regard as external releases, almost a fire drill for an official release.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the build system is carefully crafted, there shouldn''t be any extra preparation
    needed for a release build. However, these important builds must be handled thoughtfully,
    so we need to make sure that no build issues compromise the final executable.
    The key concerns with release builds are:'
  prefs: []
  type: TYPE_NORMAL
- en: Release builds should always come from a virgin source tree, not from someone's
    half-built development tree. Start from scratch. We need to know the exact state
    of the source files being built. Do not trust the files on Joe's computer to be
    in a "good enough" state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prior to the build itself, a specific step identifies which source code and
    which particular file versions to include in this release. It then marks them
    in some manner, usually by tagging or labeling them in the source control system.
    The release's file set is now retrievable at any later point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**THE (SOURCE) TREE OF KNOWLEDGE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All code lives in a *source tree*; a file structure housing directories and
    source files. The structure of this tree affects how easy the code is to work
    with. A messy glob of files is far harder to understand than a neatly arranged
    hierarchy. We can use the source file structure to our advantage, making development
    easier. This tree structure goes hand-in-hand with the build system, since the
    build system physically is a part of the source tree (hence the term *build tree*
    is used interchangeably with *source tree*). A modification to one requires meddling
    with the other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We divide code into separate modules, libraries, and applications. A good source
    tree reflects that structure. The code composition should map neatly into files,
    using directories as a logical grouping mechanism. This helps to manage development
    with multiple programmers—each person will probably be working in his own self-contained
    directory, removed from other people's work by a reasonably safe distance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Libraries**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Place each library in its own self-contained directory. Use the tree structure
    to differentiate the library *interface* (the public header files) from private
    *implementation* details. It is a good idea to place the public API within a directory
    on the compiler's lookup path and keep any private headers out of the way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Applications**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Structuring is easier; there are no public files as such, just a collection
    of source files that link to libraries. Even so, wrap each application in its
    own directory to make its bounds clear. If the application is large enough to
    have distinct constituent parts, they should be separated into subdirectories,
    or even libraries, and built separately. Make the build tree reflect the program
    structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Third-party code**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source tree should clearly mark *your own* code from third-party work. Projects
    increasingly rely on others' code; common libraries are brought in from outside
    (from commercial vendors, free software projects, or even other parts of the company).
    These external files should be kept separate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Other stuff**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Program documentation can live in the source tree. Put it in directories beside
    the code it refers to. The same holds for graphics and any other supporting files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each release build has a particular name you identify it by, sometimes a cool
    code name, sometimes just a build number. This should tally with the source control
    label the code was marked with. If you and I agree that we're talking about "build
    five" when investigating a fault, then we're working in harmony. If you are working
    with build five, but I found a fault in build six, how do we know we'll see the
    same issues?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Release builds are always made from virgin source. Ensure that these pristine
    sources can always be retrieved from source control or a backup archive in the
    future*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There may be some extra packaging stage after the code has been built, like
    preparing a CD, adding documentation, integrating licensing information, or whatever.
    This step should also be automated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each release should be archived and stored for future reference. Obviously you
    store a copy of the final built executable in whatever form it ships to the user
    (the exact shipped Zip file, self-extracting EXE, or whatever). You should also
    capture the final state of the build tree if possible, but often this will be
    enormous and impractical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the very least, the *build log*, the exact sequence of commands issued and
    the response generated, should be retained. These logs allow you to look back
    over old builds and see which compiler errors were overlooked or exactly what
    happened during the build. Sometimes this can give a clue into a fault reported
    in a years-old version of product that has long since been discontinued.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each release has a *release note* that describes what has changed. It may or
    may not be a customer-facing document, depending on exactly what you're building.
    These notes should also be archived. Usually the release note describes the changes
    since the last release and contains updates subsequent to the printing of the
    official documentation, any known issues, upgrade instructions, and so on. It
    is an important part of the release procedure and shouldn't be overlooked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing release builds, you must select the correct set of compiler
    switches—they might differ from those used in development builds. Debugging support
    gets switched off, for example. You also need to choose what level of code optimization
    is appropriate. Optimization may be disabled for development builds since the
    optimizer often takes a particularly long time to execute. This can become unbearable
    on very large build trees. However, ramping the optimizer up to warp speed nine
    may expose compiler bugs that break your code; you have to carefully choose (and
    test) a level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use different sets of compiler options for development and release builds,
    beware. You *must* test the release builds regularly, long before a deadline approaches.
    Aim to minimize the differences between release and development builds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ensure that you test the release configuration of your application, not just
    the development builds. Subtle differences may adversely affect the code''s behavior*.'
  prefs: []
  type: TYPE_NORMAL
- en: Since creating a release build is a relatively involved task and is so important
    to get right, responsibility is usually delegated to a nominated team member (perhaps
    one of the coders, perhaps someone in QA). That person produces all the release
    builds for the project to make sure that each build is of the same high quality.
    Release builds are as much about procedure as they are about the build system.
  prefs: []
  type: TYPE_NORMAL
- en: Jack-of-All-Trades, Buildmaster Of?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many organizations employ a specific person to fulfill a *build engineer* role,
    often known as the *buildmaster*. This person's job is to maintain the build system.
    The role may also involve planning and managing release schedules, or it may be
    purely technical. The buildmaster knows the build system intimately. He or she
    probably sets it up, adds new targets as required, maintains the overnight build
    scripts, and so on. The buildmaster also owns the build system documentation,
    and probably administers the source control system.
  prefs: []
  type: TYPE_NORMAL
- en: The buildmaster performs the release builds, and for this reason is often heavily
    involved with tracking component stability. He or she is charged with ensuring
    the reliability and safety of the release process.
  prefs: []
  type: TYPE_NORMAL
- en: The buildmaster is not always a specific full-time position; sometimes a programmer
    will double in this task.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is easier to pull down than to build up
  prefs: []
  type: TYPE_NORMAL
- en: --Latin proverb
  prefs: []
  type: TYPE_NORMAL
- en: On the face of it, building software is easy if you have the right tools. But
    you have to know how to use the tools properly. The quality of your build system
    is paramount; without a safe, reliable build process, you can't realistically
    develop solid code. Producing trustworthy release builds for production is an
    even more involved matter—it requires a thorough approach and a well-defined procedure.
    It is important to have an understanding of what's going on when you fire off
    a build, even if you don't have to alter the build system every day.
  prefs: []
  type: TYPE_NORMAL
- en: Performing good builds is not a straightforward task; our jobs are safe from
    the proverbial infinite number of monkeys. They're too busy arguing about which
    of their infinite number of text editors is the better one, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how their build system works, how to use it, and how to extend it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Craft simple, atomic build systems, and maintain them alongside the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate as many build activities as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use overnight builds to catch integration problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore build system mechanics, then get caught by silly build problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't care how unsafe and unreliable their build system is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expect newcomers to pick up their baroque build procedure in an almost adversarial
    manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create thrown-together release builds without following a defined release procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  prefs: []
  type: TYPE_NORMAL
- en: Describes how to deal with build errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  prefs: []
  type: TYPE_NORMAL
- en: The build tree is held in a source control system, and the two are intimately
    linked.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207476.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 502.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why should people with nice integrated development environments worry about
    using a command-line make utility, when they can just hit a single button to build
    their project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to treat the extraction of source code as a separate step
    from building it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where should the intermediate files from construction steps (e.g., object files)
    be put?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you add an automated test suite to the build system, should it run automatically
    after the software is built, or must you fire a separate command to invoke the
    tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should the overnight build be a *debug* or *release* build?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a make rule to automatically generate dependency information from your
    compiler. Show how to use this information in the makefile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursive make is a popular method of creating a modular build system spanning
    several directories. However, it is fundamentally flawed. Describe its problems
    and suggest alternatives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you know how to perform different types of compilation using your build system?
    How can you build a debug or release version of the application from the same
    sources, with the same makefiles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How good is your current project''s build process? Does it rate well against
    the characteristics in this chapter? How could you improve it? How easy is it
    to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new file to a library?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new directory of code?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Move or rename a file of code?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a different build configuration (say, a demo build)?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Build two configurations in one copy of the source tree without doing a clean
    in between?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Have you ever created a build system from scratch? What drove you to its particular
    design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everyone suffers from flaws in a build system from time to time. When programming
    a build script, you're as likely to introduce bugs as you are when programming
    real code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kinds of build errors have you been bitten by, and how could you fix, or
    even prevent, them?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chapter 11. THE NEED FOR SPEED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Optimizing Programs and Writing Efficient Code*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is more to life than increasing its speed.
  prefs: []
  type: TYPE_NORMAL
- en: --Mahatma Gandhi
  prefs: []
  type: TYPE_NORMAL
- en: We live in a fast food culture. Not only must our dinner arrive yesterday; our
    car should be fast and our entertainment instant. Our code should also run like
    lightning. I want my result. And I want it *now*.
  prefs: []
  type: TYPE_NORMAL
- en: Ironically, writing fast programs takes a long time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimization is a spectre hanging over software development, as renowned computer
    scientist W.A. Wulf observed: "More computing sins are committed in the name of
    efficiency (without necessarily achieving it) than for any other single reason—including
    blind stupidity." (Wulf 72)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimization is a well-worn subject, on which everyone has offered their two
    cents'' worth, and the same advice has been served time and time again. But despite
    this, a lot of code is *still* not developed sensibly. Optimization seems like
    a good idea, but programmers get it wrong all too often: They get sidetracked
    by the lure of efficiency, they write bad code in the name of performance, they
    optimize when it''s really not necessary, or they apply the wrong kind of optimizations.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll address this. We'll tread the familiar ground, but look
    out for some new views on the way. Don't worry—if the subject is optimization,
    it shouldn't take too long. . . .
  prefs: []
  type: TYPE_NORMAL
- en: What Is Optimization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The word *optimization* purely means to make something better, to improve it.
    In our world, it''s generally taken to mean "making code run faster," measuring
    a program''s performance against the clock. But this is only a part of the picture.
    Different programs have different requirements; what''s "better" for one may not
    be "better" for another. Software optimization may actually mean any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up program execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decreasing executable size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing output accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing startup time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing data throughput (*not necessarily* the same as execution speed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decreasing storage overhead (i.e., database size)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conventional optimization wisdom is summed up by M.A. Jackson''s infamous laws
    of optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't do it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*(For experts only)* Don''t do it yet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is, you should avoid optimization at all costs. Ignore it at first, and
    only consider it at the end of development when your code is not running fast
    enough. This is a simplistic viewpoint—accurate to a point, but potentially misleading
    and harmful. Performance is really a valid consideration right from the humble
    beginnings of development, before a single line of code has been written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code performance is determined by a number of factors, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The execution platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment or installation configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural software decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level module design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy artifacts (like the need to interoperate with older parts of the system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quality of each line of source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these are fundamental to the software system as a whole, and an efficiency
    problem there won't be easy to rectify once the program has been written. Notice
    how little impact individual lines of code have; there is so much more that affects
    performance. We must manage performance issues at every step of the development
    process and deal with any problems as they arise. In a sense, optimization (while
    not a specific scheduled activity) is an ongoing concern through all stages of
    development.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: Think about the performance of your program from the very start—do not ignore
    it, hoping to make quick fixes at the end of development.
  prefs: []
  type: TYPE_NORMAL
- en: But don't use this as an excuse to write tortured code based on your notion
    of what is fast or not. Programmers' gut feelings for where bottlenecks lie are
    seldom right, no matter how experienced they are. In the following sections, we'll
    see practical solutions to this code-writing dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, the golden rule. Before you consider a stint of code optimization,
    you must bear this advice in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Correct* code is far more important than *fast* code. There''s no point in
    arriving quickly at the wrong answer.'
  prefs: []
  type: TYPE_NORMAL
- en: You should spend more time and effort proving that your code is correct than
    making it fast. Any later optimization must not break this correctness.
  prefs: []
  type: TYPE_NORMAL
- en: '**A WAR STORY**'
  prefs: []
  type: TYPE_NORMAL
- en: I once discovered that a module I'd written was running unbelievably slowly.
    I profiled it and tracked the problem down to a single line of code. It was called
    frequently and appended a single element to a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon inspection, the buffer (which I was given and hadn''t written) was expanding
    itself by a *single element* each time it got full! In other words: Every single
    append was allocating, copying, and deallocating the entire buffer. Ouch. Needless
    to say, I was not expecting this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This helps to show how we get suboptimal programs: by growth. Few people willfully
    attempt to write an ambling program. As we glue software components into a larger
    system, we can easily make assumptions about the performance characteristics of
    the code and end up with a nasty shock.'
  prefs: []
  type: TYPE_NORMAL
- en: What Makes Code Suboptimal?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to improve our code, we have to know the things that will slow it down,
    bloat it, or degrade its performance. Later on, this will help us to determine
    some code optimization techniques. At this stage, it's helpful to appreciate what
    we're fighting against.
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary complexity is a killer. The more work there is to do, the more slowly
    the code will run. Reducing the amount of work or breaking it up into a different
    set of simpler, faster tasks can greatly enhance performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Indirection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is touted as the solution to all known programming problems, summarized
    by the infamous programmer maxim: *Every problem can be solved by an extra level
    of indirection*. But indirection is also blamed for a lot of slow code. This criticism
    is often leveled by old-school procedural programmers, aimed at modern OO designs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repetition**'
  prefs: []
  type: TYPE_NORMAL
- en: Repetition can often be avoided and will inevitably ruin code performance. Repetition
    can often be avoided and will inevitably ruin code performance. It comes in many
    guises—for example, failing to cache the results of expensive calculations or
    of remote procedure calls. Every time you recompute, you waste precious efficiency.
    Repeated code sections unnecessarily extend executable size.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad design**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s inevitable: Bad design will lead to bad code. For example, placing related
    units far away from each other (across module boundaries, for example) will make
    their interaction slow. Bad design can lead to the most fundamental, the most
    subtle, and the most difficult performance problems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**I/O**'
  prefs: []
  type: TYPE_NORMAL
- en: A program's communication with the outside world—its input and output—is a remarkably
    common bottleneck. A program whose execution is blocked waiting for input or output
    (to and from the user, the disk, or a network connection) is bound to perform
    badly.
  prefs: []
  type: TYPE_NORMAL
- en: This list is nowhere near exhaustive, but it gives us a good idea of what to
    think about as we investigate how to write optimal code.
  prefs: []
  type: TYPE_NORMAL
- en: Why Not Optimize?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, optimization was a crucial skill, since early computers ran very,
    very slowly. Getting a program to complete in anything like reasonable time required
    a lot of skill and the hand-honing of individual machine instructions. That skill
    is not so important these days; the personal computer revolution has changed the
    face of software development. We often have a surplus of computational power,
    quite the reverse of the days of yore. It might seem that optimization doesn't
    really matter anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Well, not quite. The software factory still throws us situations requiring high-performance
    code, and if you're not careful, you'll need a mad optimization dash at the last
    minute. But it is preferable to avoid optimizing code if at all possible. Optimization
    has a *lot* of downsides.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s always a price to pay for more speed. Optimizing code is the act of
    trading one desirable quality for another. Some aspect of the code will suffer.
    Done well, the (correctly identified) more desirable quality is enhanced. These
    trade-offs are the top reasons to avoid optimizing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loss of readability**'
  prefs: []
  type: TYPE_NORMAL
- en: It's rare for optimized code to read as clearly as its slower counterpart. By
    its very nature, the optimized version is not as direct an implementation of the
    logic or as straightforward. You sacrifice readability and neat code design for
    performance. Most "optimized" code is ugly and hard to follow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Increase in complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: A more clever implementation—perhaps exploiting special backdoors (thereby increasing
    module coupling) or taking advantage of platform-specific knowledge—will add complexity.
    Complexity is the enemy of good code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard to maintain/extend**'
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence of increased complexity and a lack of readability, the code
    will be harder to maintain. If an algorithm is not clearly presented, the code
    can hide bugs more easily. Optimization is a surefire way to add subtle new faults—these
    will be difficult to find because the code is more contrived and harder to follow.
    Optimization leads to dangerous code.
  prefs: []
  type: TYPE_NORMAL
- en: It also stunts the extensibility of your code. Optimizations often come from
    making more assumptions, limiting generality and future growth.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introducing conflicts**'
  prefs: []
  type: TYPE_NORMAL
- en: Often an optimization will be quite platform specific. It might make certain
    operations faster on one system, at the expense of another platform. Picking optimal
    data types for one processor type may lead to slower execution on others.
  prefs: []
  type: TYPE_NORMAL
- en: '**More effort**'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is another job that needs to be done. We have quite enough to do
    already, thank you. If the code is working adequately, then we should focus our
    attentions on more pressing concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing code takes a long time, and it's hard to target the real causes.
    If you optimized the wrong thing, you've wasted a lot of precious energy.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, optimization should be quite a way down on your list of concerns.
    Balance the need to optimize your code against the requirement to fix faults,
    to add new features, or to ship a product. Often optimization is not worthwhile
    or is uneconomical. If you take care to write efficient code in the first place,
    you're less likely to need to optimize anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often code optimization is performed when it''s not actually necessary. There
    are a number of alternative approaches that we can employ without altering our
    exisiting good-quality code. Consider these solutions *before* you get too focused
    on optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: Can you put up with this level of performance—is it really *that* disastrous?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the program on a faster machine. This seems laughably obvious, but if you
    have enough control over the execution platform, it might be more economical to
    specify a faster computer than spend time tinkering with code. Given the average
    project duration, you are guaranteed that by the time you reach completion, processors
    will be considerably faster. If they're not much faster, then they'll have double
    the number of CPU cores embedded in the same physical space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all problems can be fixed by a faster CPU, especially if the bottleneck
    is not execution speed—a slow storage system, for example. Sometimes a faster
    CPU can cause drastically *worse* performance; faster execution can exacerbate
    thread-locking problems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look for hardware solutions: Add a dedicated floating-point unit to speed up
    calculations; add a bigger processor cache, more memory, a better network connection,
    or a wider-bandwidth disk controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconfigure the target platform to reduce the CPU load on it. Disable background
    tasks or any unnecessary pieces of hardware. Avoid processes that consume huge
    amounts of memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run slow code asynchronously, in a background thread. Adding threads at the
    last minute is a road to disaster if you don't know what you're doing, but careful
    thread design can accommodate slow operations quite acceptably.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work on user interface elements that affect the user's perception of speed.
    Ensure that GUI buttons change immediately, even if their code takes over a second
    to execute. Implement a progress meter for slow tasks; a program that hangs during
    a long operation appears to have crashed. Visual feedback of an operation's progress
    conveys a better impression of the quality of performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design the system for unattended operation so that no one notices the speed
    of execution. Create a batch-processing program with a neat UI that allows you
    to queue work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try a newer compiler with a more aggressive optimizer, or target your code for
    the most specific processor variant (with all extra instructions and extensions
    enabled) to take advantage of all performance features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Look for alternatives to optimizing code—can you increase your program''s
    performance in any other way?*'
  prefs: []
  type: TYPE_NORMAL
- en: Why Optimize?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having seen the dangers of code optimization, should you now give up any foolish
    notion of ever optimizing your code? Well, no: You should still avoid optimization
    wherever possible, but there are plenty of situations where optimization is important.
    And contrary to popular belief, some areas are *guaranteed* to require optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: Games programming always needs well-honed code. Despite the huge advances in
    PC power, the market demands more realistic graphics and more impressive artificial
    intelligence algorithms. This can only be delivered by stretching the execution
    environment to its very limits. It's an incredibly challenging field of work;
    as each new piece of faster hardware is released, games programmers still have
    to wring every last drop of performance out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Digital signal processing (DSP)* programming is all about high performance.
    Digital signal processors are dedicated devices specifically optimized to perform
    fast digital filtering on large amounts of data. If speed didn''t matter, you
    wouldn''t be using them. DSP programming generally relies less on an optimizing
    compiler, since you want to have a high degree of control over what the processor
    is doing at all times. DSP programmers are skilled at driving these devices at
    their maximum performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource constrained environments, such as deeply embedded platforms, can struggle
    to achieve reasonable performance with the available hardware. You'll have to
    hone the code for acceptable quality of service or work hard to fit it into the
    device's tight memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Real-time* systems rely on timely execution, on being able to complete operations
    within well-specified quanta. Algorithms have to be carefully honed and proven
    to execute in fixed time limits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical programming—in the financial sector, or for scientific research—demands
    high performance. These huge systems are run on very large computers with dedicated
    numerical support, providing vector operations and parallel calculations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps optimization is not a serious consideration for general-purpose programming,
    but there are plenty of cases where optimization *is* a crucial skill. Performance
    is seldom specified in a requirements document, yet the customer will complain
    if your program runs unacceptably slowly. If there are no alternatives, and the
    code doesn't perform adequately, then you have to optimize it.
  prefs: []
  type: TYPE_NORMAL
- en: There is a shorter list of reasons to optimize than not to. Unless you have
    a specific need to optimize, you should avoid doing so. But if you do need to
    optimize, make sure you know how to do it well.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Understand when you* do *need to optimize code, but prefer to write efficient*
    high-quality *code in the first place*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Nuts and Bolts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So how do you optimize? Rather than learn a list of specific code optimizations,
    it's far more important to understand the correct *approach* to optimizing. Don't
    panic; we will see some programming techniques later, but they must be read in
    the context of this wider optimization process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The six steps for speeding up a program are:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine that it's too slow, and prove you do need to optimize.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the slowest code. Target this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the performance of the optimization target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimize the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test that the optimized code still works (very important).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the speed increase, and decide what to do next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This sounds like a lot of work, but without it you'll actually waste time and
    effort and end up with crippled code that runs no faster. If you're not trying
    to improve execution speed, adjust this process accordingly; for example, tackle
    memory consumption problems by identifying which data structures are consuming
    all the memory and target those.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to begin optimization with a clear goal in sight—the more optimization
    you perform, the less readable the code becomes. Know the level of performance
    you require, and stop when it's sufficiently fast. It's tempting to keep going,
    continually trying to squeeze out a little extra performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stand any chance of optimizing correctly, you must take great care to prevent
    external factors from changing the way your code works. When the world is changing
    under your feet, you can''t compare measurements realistically. There are two
    essential techniques that help here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimize your code separately from any other work, so the outcome of one task
    doesn''t cloud the other*.'
  prefs: []
  type: TYPE_NORMAL
- en: . . . and . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Optimize release builds of your program, not development builds*.'
  prefs: []
  type: TYPE_NORMAL
- en: The development builds may run very differently from release builds, due to
    the inclusion of debugging trace information, object file symbols, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll look at each of these optimization steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Prove You Need to Optimize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is make sure you really *do* need to optimize. If the
    code''s performance is acceptable, then there''s no point in tinkering with it.
    Knuth said (himself quoting C.A.R. Hoare): "We should forget about small efficiencies,
    say about 97 percent of the time: Premature optimization is the root of all evil."
    There are so many compelling reasons *not* to optimize that the quickest and safest
    optimization technique is to prove that you don''t need to do it.'
  prefs: []
  type: TYPE_NORMAL
- en: You make this decision based on program requirements or usability studies. With
    this information you can determine whether optimization takes priority over adding
    new features and fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the Slowest Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the part that most programmers get wrong. If you're going to spend time
    optimizing, you need to target the places where it will make a difference. Investigations
    show that the average program spends more than 80 percent of its time in less
    than 20 percent of the code. (Boehm 87) This is known as the *80/20 rule*.^([[1](#ftn.CHP-11-FN-1)])
    That's a relatively small target that is very easy to miss, which means you might
    waste effort optimizing code that's rarely run.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that a part of your program has some relatively easy optimizations,
    but if that part is seldom executed, then there's no point in optimizing—in this
    situation, clear code is better than faster code.
  prefs: []
  type: TYPE_NORMAL
- en: How do you figure out where to focus your attention? The most effective technique
    is to use a *profiler*. This tool times the flow of control around your program.
    It shows where that 80 percent of execution time is going, so you know where to
    concentrate your effort.
  prefs: []
  type: TYPE_NORMAL
- en: A profiler *doesn't* tell you which parts of the code are slowest; this is a
    common misconception. It actually tells you where the CPU spends most of its time.
    This is subtly different.^([[2](#ftn.CHP-11-FN-2)]) You have to interpret these
    results and use your brain. The program might spend most of its execution time
    in a few perfectly valid functions which cannot be improved at all. You can't
    always optimize; sometimes the laws of physics win.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of benchmarking programs around—many excellent commercial
    programs and a number of freely available tools. It''s worth spending money on
    a decent profiler: Optimization can easily eat into your time; this is also an
    expensive commodity. If you don''t have a profiler available, there are a few
    other timing techniques you can try:'
  prefs: []
  type: TYPE_NORMAL
- en: Put manual timing tests throughout your code. Make sure you use an accurate
    clock source and that the time taken to read the clock will not affect program
    performance too much.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count how often each function is called (some debug libraries provide support
    for this kind of activity).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit compiler-supplied hooks to insert your own accounting code when each
    function is entered or exited. Many compilers provide a means to do this; some
    profilers are implemented using such a mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample the program counter; interrupt your program periodically in a debugger
    to see where control is. This is harder in multithreaded programs and is a very
    slow, manual approach. If you have control over the execution environment, you
    can write scaffolding to automate this kind of test—effectively writing your own
    form of profiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test an individual function's impact on the total program execution time by
    making it slower. If you suspect that a particular function is causing a slowdown,
    try replacing its call with two calls in succession, and measure how it affects
    execution time.^([[3](#ftn.CHP-11-FN-3)]) If the program takes 10 percent longer
    to run, then the function consumes approximately 10 percent of execution time.
    Use this as a very basic timing test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When profiling, make sure that you use realistic input data, simulating Real
    World events. The way your code executes may be drastically affected by the kind
    of input you feed it or by the way it is driven, so make sure that you provide
    true representative input sets. If possible, capture a set of real input data
    from a live system.
  prefs: []
  type: TYPE_NORMAL
- en: Try profiling several different data sets, to see what difference this makes.
    Select a very basic set, a heavy use set, and a number of general use sets. This
    will prevent you from optimizing for the particular quirks of one input data set.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Select profiling test data carefully to represent Real World program use.
    Otherwise, you might optimize parts of the program that are not normally run*.'
  prefs: []
  type: TYPE_NORMAL
- en: While a profiler (or equivalent) is a good starting point to choose optimization
    targets, you can easily miss quite fundamental problems. The profiler only shows
    how the code in the current design executes—and encourages you to perform code-level
    improvement only. Look at larger design issues too. The lack of performance may
    not be due to a single function, but rather a more pervasive design flaw. If it
    is, then you'll have to work harder to remedy the problem. This shows how important
    it is to get the initial code design right, with knowledge of established performance
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don''t rely solely on a profiler to find the causes of program inefficiency;
    you might miss important problems*.'
  prefs: []
  type: TYPE_NORMAL
- en: Having completed this step, you've found the areas of your code where a performance
    improvement will have the most benefit. Now it's time to attack them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recognized three testing phases in the optimization procedure. For each piece
    of code targeted, we test its performance before optimization, confirm that the
    code still works correctly once optimized, and test its performance after optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers often forget the second check: that the optimized code still works
    correctly in *all* possible situations. It''s easy to check the normal mode of
    operation, but it''s not in our nature to test each and every rare case. This
    can be the cause of weird bugs late in the day, so be very rigorous about this.'
  prefs: []
  type: TYPE_NORMAL
- en: You *must* measure the code's performance before and after modification to make
    sure that you have made a real difference—and to make sure that it is a change
    for the better; sometimes an "optimization" can be an unwitting *pessimization*.
    You can perform these timing tests with your profiler or by inserting timing instrumentation
    by hand.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: Never *try to optimize code without performing some kind of before and after
    measurement*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some very important things to think about when running your timing
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Run both the before and after tests with exactly the same set of input data
    so that you're testing exactly the same thing. Otherwise, your tests are meaningless;
    you're not comparing apples to apples. An automated test suite is best (see "[Look!
    No Hands!](ch08s07.html "Look! No Hands!")" on page 144)—with the same kind of
    live representative data we used in the profiling step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run all tests under identical prevailing conditions, so that factors like the
    CPU load or amount of free memory don't affect your measurements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that your tests don't rely on user input. Humans can cause timings to
    fluctuate wildly. Automate every possible aspect of the test procedure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll investigate some specific optimization techniques later. Speed-ups vary
    from the simple refactoring of small sections of code to more serious design-level
    alterations. The trick is to optimize without totally destroying the code.
  prefs: []
  type: TYPE_NORMAL
- en: Determine how many different ways exist to optimize the identified code, and
    pick the best. Only perform one change at a time; it's less risky, and you'll
    have a better idea of what improved performance the most. Sometimes it's the least
    expected things that have the most significant optimization effects.
  prefs: []
  type: TYPE_NORMAL
- en: After Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don't forget to benchmark the optimized code to prove that you've made a successful
    modification. If an optimization is unsuccessful, remove it. Back out your changes.
    This is where a source control system is useful, helping you to revert to the
    previous code version.
  prefs: []
  type: TYPE_NORMAL
- en: Also remove the *slightly* successful optimizations. Prefer clear code to modest
    optimizations (unless you're absolutely desperate for an improvement, and there
    are no other avenues to explore).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-11-FN-1)]) Some go so far as to claim this should be the *90/10
    rule*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-11-FN-2)]) All code runs at a fixed rate, based on the speed of
    the CPU clock, the number of other processes being juggled by the OS, and the
    thread's priority.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-11-FN-3)]) This won't *necessarily* make the function run twice
    as slowly. Filesystem buffers or CPU memory caches can enhance the performance
    of repeated code sections. Treat this as a very rough guide—more qualitative than
    quantitative.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've avoided this for long enough; now it's time to look at the really gory
    details. Having followed the optimization procedure outlined above, you've proved
    that your program performs badly and have found the worst code culprit. Now you
    need to whip it into shape. What can you do?
  prefs: []
  type: TYPE_NORMAL
- en: There's a palette of optimizations to choose from. Which is the most appropriate
    will depend on the exact cause of the problem, what you're trying to achieve (e.g.,
    increased execution speed or reduced code size), and how much of an improvement
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'These optimizations fall into two broad categories: *design* changes and *code*
    changes. A change at the design level will usually have a more profound effect
    on performance than a code-level tweak. An inefficient design can strangle efficiency
    more than a few bad lines of source code, so a design fix—while more difficult—will
    have a bigger payoff.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most often, our goal is to increase execution speed. The speed-based optimization
    strategies are to:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed up slow things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do slow things less often
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defer slow things until you really need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other common optimization goals are to reduce memory consumption (mainly
    by changing the data representation, by tweaking the pattern of memory consumption,
    or by reducing the amount of data accessed at once), or to reduce executable size
    (by removing functionality or by exploiting commonality). As we''ll see, these
    goals often conflict: Most speed increases come at the expense of memory consumption,
    and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Design Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the *macro* optimizations, the fixes on a large scale that improve
    the internal design of your software. Bad design is hard to fix. The nearer a
    project is to a release deadline, the less likely you are to perform design changes;
    the risk is too great.^([[4](#ftn.CHP-11-FN-4)]) We end up plastering over the
    cracks by employing small, code-level fixes instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'When brave enough, the kinds of design optimization we can perform include:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding layers of caching or buffering to enhance slow data access or prevent
    lengthy recalculations. Precompute values that you know will be needed, and store
    them for immediate access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pool of resources to reduce the overhead of allocating objects. For
    example, preallocate memory, or hold a selection of files open rather than repeatedly
    opening and then closing them. This technique is often used to speed up memory
    allocation; older OS memory allocation routines were designed for simple non-threaded
    use. Their locks stall multithreaded applications, leading to horrible performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sacrificing accuracy for speed if you can get away with it. Dropping floating-point
    precision is the obvious example. Many devices have no *floating-point unit (FPU)*
    hardware and employ slower FPU emulation software instead. You can switch to fixed-point
    arithmetic libraries to bypass a slow emulator, at the expense of numeric resolution.
    This is particularly easy in C++ by taking advantage of its abstract data type
    facilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy is not solely due to your choice of data types; this tactic can run
    far deeper to your use of algorithms or the quality of your output. Perhaps you
    can let users make this decision—allow them to select *slow but accurate* or *fast
    but approximate* operation modes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Changing the data storage format or its on-disk representation to something
    more suited to high-speed operation. For example, speed up text file parsing by
    using a binary format. Transmit or store compressed files to reduce network bandwidth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting parallelization and using threading to prevent one action from being
    serialized after another. As advances in processor speeds tail off, CPU manufacturers
    are increasingly introducing multi-core, multi-pipeline processors. To use these
    effectively, your code *must* be designed with a threaded model at its heart.
    The front line of the optimization battle is rapidly moving in this direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Threading efficiently: Avoiding or removing excessive locking. It inhibits
    concurrency, generates overhead, and often leads to deadlock. Employ static checking
    to prove which locks are necessary and which aren''t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding overuse of exceptions. They can inhibit compiler optimizations^([[5](#ftn.CHP-11-FN-5)])
    and will hamper timely operation when used too frequently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forgoing certain language facilities if it will save code space. Some C++ compilers
    allow you to disable RTTI and exceptions, consequently reducing executable size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Removing functionality: The quickest code is code that doesn''t run at all.
    A function will be slow if it is doing too many things, some of which are unnecessary.
    Cut out the superfluous stuff. Move it elsewhere in the program. Defer all work
    until it''s really necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compromising design quality to gain speed. For example, reducing indirection
    and increasing coupling. You can do this by breaking encapsulation: leaking a
    class''s private implementation through its public interface. Knocking down module
    barriers will cause irreparable damage to the design. If possible, try a less
    disruptive optimization mechanism first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COMPLEXITY NOTATION**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Algorithmic complexity* is a measure of how well an algorithm scales—how long
    it takes in proportion to the size of input. It''s a *qualitative* mathematical
    model, allowing you to quickly compare the performance characteristics of different
    implementation approaches. It doesn''t measure exact execution time (this is highly
    dependent on CPU speed, OS configuration, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complexity is determined by the amount of work an algorithm must perform: the
    number of basic operations it executes. A basic operation is something like an
    arithmetic operation, an assignment, a test, or a data read/write. Algorithmic
    complexity doesn''t count the exact number of operations performed, just how this
    value relates to the problem size. We are usually interested in the worst case
    performance of an algorithm, the most work that will ever need to be done. A good
    comparison looks at the best case and average time complexity as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithmic complexity is expressed using *Big O* notation, invented by the
    German number theorist Edmund Landau. For a problem with input size *n*, it might
    have a complexity of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`O(1)`**: Order 1**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a *constant time* algorithm. No matter how large the input set, it always
    takes the same amount of time to complete the task. This is the best performance
    characteristic possible.
  prefs: []
  type: TYPE_NORMAL
- en: '`O(n)`**: Order n**'
  prefs: []
  type: TYPE_NORMAL
- en: A *linear time* algorithm's complexity rises in line with the input size. Searching
    a linked list will involve visiting more nodes as the list size grows; the number
    of operations is directly related to the size of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`O(n2)`**: Order n squared**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where performance really begins to get bad: Complexity is increasing
    faster than the rate of input growth. A *quadratic time* algorithm may seem fine
    when you give it a small set of data, but large data sets take a seriously long
    time. The bubblesort algorithm is `O(n2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, complexity may be of any order; the quicksort algorithm averages
    `O(n log n)`. This is worse than `O(n)`, but far better than `O(n2)`. A simple
    optimization route for a slow bubblesort algorithm is to replace it with a quicksort
    algorithm, especially since there are plenty of freely available quicksort implementations.
  prefs: []
  type: TYPE_NORMAL
- en: These Big O expressions don't include constants or low-order terms. You'll rarely
    see any talk about a complexity of `O(2n+6)`. When n gets large enough, these
    constants and low-order terms dwarf into insignificance.
  prefs: []
  type: TYPE_NORMAL
- en: The major design-level optimizations involve improvements in *algorithms* or
    *data structures*. Most speed degradation or memory consumption comes down to
    a bad choice of one or both, and a subsequent change will rectify this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms have a profound impact on the speed of execution. A function that
    works acceptably in a small local test may not scale up when Real World data gets
    thrown at it. If profiling shows that your code spends most of its time running
    a certain routine, you must make it run faster. One approach is at the code level,
    chipping small improvements from each instruction. A better approach is to replace
    the entire algorithm with a more efficient version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this realistic example: A particular algorithm runs a loop 1,000 times.
    Each iteration takes 5 milliseconds (ms) to execute. The operation therefore completes
    in around 5 seconds. By tweaking the code inside the loop, you can shave 1 ms
    from each iteration—that''s a saving of 1 second. Not bad. But instead, you can
    plug in a different algorithm, where an iteration takes 7 ms, although it only
    iterates 100 times. That''s a saving of almost 4 and a half seconds—significantly
    better.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, prefer to look at optimizations that change fundamental algorithms,
    not that tweak specific lines of code. There are many algorithms to chose from
    in the computer science world, and unless your code is particularly dire, you'll
    always gain the most significant performance improvements by selecting a better
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Prefer to replace a slow algorithm with a faster variant than to tinker with
    the algorithm''s implementation*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data structures**'
  prefs: []
  type: TYPE_NORMAL
- en: Data structures are intimately related to your choice of algorithms; some algorithms
    require certain data structures, and vice versa. If your program is consuming
    far too much memory, changing the data storage format may improve matters, although
    often at the expense of execution speed. If you need to quickly search a list
    of 1,000 items, don't store them in a linear array with `O(` *`n`*`)` search time;
    use a (larger) binary tree with `O(log` *`n`*`)` performance.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a different data structure seldom requires you to implement the new
    representation yourself. Most languages come with library support for all common
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Code Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And so now we creep anxiously on to the really disgusting stuff: the *micro*-level,
    small-scale, shortsighted, code-tweaking optimizations. There are many ways to
    molest source code for the sake of performance. You must experiment to see what
    works best in each situation: Some changes will work well; others will have little,
    or even negative effect. Some may prevent the compiler''s optimizer from performing
    its task, producing startlingly worse results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is easy: Turn on compiler optimization or increase the optimization
    level. It often gets disabled for development builds since the optimizer can take
    a very long time to run, increasing the build time of large projects by an order
    of magnitude.^([[6](#ftn.CHP-11-FN-6)]) Try configuring the optimizer, and test
    what affect this has. Many compilers allow you to bias optimization toward extra
    speed or reduced code size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few very low-level optimizations that you should know about but
    should generally avoid. These are the kind of changes that a compiler is able
    to perform for you. If you''ve switched the optimizer on, it''ll be looking in
    these areas already—enable optimization and make the most of its help. You will
    rarely need to apply these by hand, which is good: They butcher your code''s readability,
    since they warp its fundamental logic out of shape. Only consider using one of
    these optimizations if you can *prove* that it''s really required, that your optimizer
    hasn''t already done it, and that there are no better alternatives.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loop unrolling**'
  prefs: []
  type: TYPE_NORMAL
- en: For loops with very short bodies, the loop scaffolding may be more expensive
    than the looped operation itself. Remove this overhead by flattening it out—turn
    your 10-iteration loop into 10 consecutive individual statements.
  prefs: []
  type: TYPE_NORMAL
- en: Loop unrolling can be done partially; this makes more sense for large loops.
    You can insert four operations per iteration, and increment the loop counter by
    four each time. But this tactic gets nasty if the loop doesn't always iterate
    over a whole number of unrolls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code inlining**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For small operations, the overhead of calling a function might be prohibitive.
    Splitting code into functions brings significant benefits: clearer code, consistency
    through reuse, and the ability to isolate areas of change. However, this can be
    removed to increase performance, by merging the caller(s) and the callee.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to do this. With language support, you can request
    it in the source code (in C/C++ using the `inline` keyword); this method preserves
    a lot of the code's readability. Otherwise, you have to merge the code yourself,
    either by duplicating the function over and over again or using a preprocessor
    to do the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: It's hard to inline recursive function calls—how would you know when to stop
    inlining? Try to find alternative algorithms to replace recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Inlining often opens the way for further code-level optimizations (that were
    not previously possible across a function boundary) to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant folding**'
  prefs: []
  type: TYPE_NORMAL
- en: Calculations involving constant values can be computed at compile time to reduce
    the amount of work done at run time. The simple expression `return 6+4;` can be
    reduced to `return 10;`. Carefully ordering the terms of a large calculation might
    bring two constants together, enabling them to be reduced into a simpler subexpression.
  prefs: []
  type: TYPE_NORMAL
- en: It's unusual for a programmer to write something as obvious as `return 6+4;`.
    However, these sorts of expressions are common after macro expansion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Move to compile time**'
  prefs: []
  type: TYPE_NORMAL
- en: There is more you can do at compile time than just constant folding. Many conditional
    tests can be proved statically and removed from the code. Some kinds of tests
    can be avoided altogether; for example, remove tests for negative numbers by using
    unsigned data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strength reduction**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the act of replacing one operation with an equivalent that executes
    faster. This is most important on CPUs with poor arithmetic support. For example,
    replace integer multiplication and division with constant shifts or adds; `x/4`
    can be converted to `x>>2` if it's faster on your processor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Subexpressions**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Common subexpression elimination* avoids the recalculation of expressions
    whose values have not changed. In code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: the expression `(a * b)` is evaluated twice. Once is enough. You can factor
    out the common subexpression, and replace it with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Dead code elimination**'
  prefs: []
  type: TYPE_NORMAL
- en: Don't write needless code; prune anything that's not strictly necessary to the
    program. Static analysis will show you the functions that are never used or the
    sections of code that will never execute. Remove them.
  prefs: []
  type: TYPE_NORMAL
- en: While those are particularly distasteful code optimizations, the following ones
    are slightly more socially acceptable. They focus on increasing program execution
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you're repeatedly calling a slow function, then don't call
    it so often. Cache its result and reuse this value. This might lead to less clear
    code, but the program will run faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reimplement the function in another language. For example, rewrite a critical
    Java function in C using the Java Native Interface ( JNI) facility. Conventional
    compilers still beat JIT code interpreters for execution speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't naïvely assume that one language is faster than another—many programmers
    have been surprised by how little difference using JNI makes. It has been commonly
    claimed that OO languages are far slower than their procedural counterparts. This
    is a lie. Bad OO code *can* be slow, but so can bad procedural code. If you write
    OO-style code in C, it is likely to be *slower* than good C++; the C++ compiler
    will generate better-tuned method dispatch code than your attempts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reorder the code for improved performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defer work until it''s absolutely necessary**. Don''t open a file until you''re
    about to use it. Don''t calculate a value if you might not need it; wait until
    it''s wanted. Don''t call a function yet if the code will work without it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hoist checking further up the function to avoid needless work**. If a test
    leading to an early return can be placed at the top of a function or halfway though
    it, prefer to place it at the top. Make the check sooner to avoid delays.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Move invariant calculations out of a loop**. The most subtle source of this
    problem is a loop condition. If you write `for (int n = 0; n < tree.appleCount();
    ++n)`, but `appleCount()` manually counts 1,000 items on every call, you''ll have
    a very slow loop. Move the count operation before the loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, don''t forget to profile first to prove that the loop truly is a problem.
    This is a great example of how optimizations are local to a particular execution
    environment: In C#, the new version could well be *slower* because the unoptimized
    code is a pattern the JIT compiler understands and can optimize away itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use *lookup tables* for complex calculations, trading time for space. For example,
    rather than write a set of trigonometric functions that individually calculate
    their values, precalculate the return values and store them in an array. Map input
    values to the closest index into this array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit *short-circuit evaluation*. Make sure that the tests likely to fail
    are placed first to save time. If you write a conditional expression `if (condition_one
    && condition_two)`, make sure that `condition_one` is statistically more likely
    to fail than `condition_two` (unless, of course, `condition_one` acts as a guard
    for `condition_two`'s validity).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't reinvent the wheel—reuse standard routines that have already been performance
    tuned. Library writers will have already carefully honed their code. But be aware
    that a library may have been optimized for different goals than yours; perhaps
    an embedded product was profiled for memory consumption, not for speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size-focused, code-level optimizations include:'
  prefs: []
  type: TYPE_NORMAL
- en: Producing compressed executables that unpack their code before running. This
    doesn't necessarily affect the size of the running program, but it reduces the
    storage space required.^([[7](#ftn.CHP-11-FN-7)]) This might be important if your
    program is stored in limited flash memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factoring common code into a shared function to avoid duplication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving seldom-used functions out of the way. Put them into a dynamically loaded
    library or into a separate program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the ultimate hard-core optimization technique is to reimplement a
    section of code in assembly—the one environment where you have *full* control
    over the CPU and can do exactly what you want (including shooting yourself in
    the foot). This is always a last resort and is almost certainly unnecessary. These
    days, compilers produce perfectly acceptable code, and the lost time spent writing,
    debugging, and maintaining "optimized" sections of machine code far outweighs
    the advantages gained.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-11-FN-4)]) Sadly, it's often only near project deadlines that anyone
    notices that performance isn't good enough.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#CHP-11-FN-5)]) Like functions, `try/catch` blocks act as barriers to
    an optimizer. It's not possible to look through the barrier to perform optimization,
    so some potential speed-ups will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-11-FN-6)]) It has to do complex inspection of the parsed code to
    determine the set of possible speed-ups and select the most appropriate ones.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[7](#CHP-11-FN-7)]) This may have the pleasant side effect of decreasing
    program startup time: A compressed executable will load from disk much faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing Efficient Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the best approach is *not* to optimize, how can we avoid any need to improve
    code performance? The answer is to *design for performance*, planning to provide
    adequate quality of service from the outset, rather than trying to whittle it
    out at the last minute.
  prefs: []
  type: TYPE_NORMAL
- en: Some argue that this is a dangerous road to follow. Indeed, there are potential
    hazards for the unwary. If you try to optimize as you go along, then you'll write
    at a lower level than needed; you'll end up with nasty, hacky code full of low-level
    performance enhancements and back-door interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we reconcile these seemingly opposing views? It isn''t hard, because
    they''re not actually at odds. There are two complementary strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Write efficient code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize code later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you make a point of writing clear, good, efficient code *now*, you will not
    need to perform heavy optimizations later. Some claim that you don't know whether
    any optimization is necessary at first, so you should write everything *as simply
    as possible*, and only optimize when profiling proves that there is a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has obvious flaws. If you know that you need a data structure
    with good search performance (because your program must perform fast searches),
    pick a binary tree over an array.^([[8](#ftn.CHP-11-FN-8)]) If you're not aware
    of any such requirement, *then* go for the most appropriate thing that will work.
    This still might not be the simplest—a raw C array is a hard data structure to
    manage.
  prefs: []
  type: TYPE_NORMAL
- en: As you design each module, don't blindly chase performance—only spend the effort
    when necessary. Understand the mandated performance requirements and justify how
    your choices will meet these requirements at each stage. When you know what level
    of performance is required, it's easier to design for appropriate efficiency.
    It also helps you to write explicit tests that prove you do achieve these performance
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some simple design choices that will increase efficiency and aid later optimization
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing your reliance on functions that might be implemented on remote machines
    or that will access the network or a slow data storage system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the target deployment and how the program is expected to be run
    so you can design it to work well in these situations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing *modular* code so it's easy to speed up one section without having to
    rewrite other sections too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PESSIMIZATIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without careful measurement, you can easily end up writing optimizations that
    are not at all optimal. A perfectly good optimization for one situation might
    turn out to be a performance disaster in another. Here''s a case study. Exhibit
    A: The copy-onwrite string optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: This was a common optimization applied to C++ standard library implementations
    around 1990\. Programs that performed intensive string manipulation experienced
    a massive overhead when copying long strings, both in terms of execution speed
    and memory consumption. Copying large strings means duplicating and shoveling
    around large quantities of data. Many string copies are automatically generated,
    temporary objects that are created and then thrown away shortly after—they are
    never actually modified. The expensive copy operation is an unnecessary cost.
  prefs: []
  type: TYPE_NORMAL
- en: The copy-on-write (COW) optimization turns the `string` data type into a form
    of *smart pointer*; the actual string data is held in a (hidden) shared representation.
    The `string` copy operation now only has to perform an inexpensive smart pointer
    copy (attaching a new smart pointer to the shared representation), rather than
    duplicate the entire string contents. Only when you make a modification to a shared
    string is the internal representation copied and the smart pointer remapped. This
    optimization avoids a large number of unnecessary copy operations.
  prefs: []
  type: TYPE_NORMAL
- en: COW worked well in single-threaded programs; it was shown to greatly speed up
    performance. However, a problem became apparent when multithreaded programs used
    COW strings. (Indeed, this problem also manifests in single-threaded programs
    if the COW string class is built with multithreading support). The implementation
    requires very conservative thread locking around the copy operations— these locks
    become a *major* bottleneck. Suddenly, a lightning-fast program slowed down to
    a crawl. The COW optimization proved to be a serious pessimization.
  prefs: []
  type: TYPE_NORMAL
- en: Far better multithreaded performance was achieved by reverting to classic `string`
    implementations and writing more careful code that reduced automatic string copying.
    Thankfully, C++ library vendors now provide more intelligent versions of the `string`
    class, which are both thread safe and fast.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#CHP-11-FN-8)]) But, as always, it's not necessarily that simple. Arrays
    often provide better cache coherence (since binary tree nodes can easily become
    scattered across memory). An array that is kept sorted (you amortize time when
    inserting) would be a worthy consideration. Measure, measure, measure.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technological progress has merely provided us with more efficient means for
    going backwards.
  prefs: []
  type: TYPE_NORMAL
- en: --Aldous Huxley
  prefs: []
  type: TYPE_NORMAL
- en: High-performance code is not as important as some people think. Although you
    sometimes *do* have to roll your sleeves up and tinker with code, optimization
    is a task you should actively avoid. To do this, make sure that you know the software's
    performance requirements before you start working on it. At each level of design,
    ensure that you provide this quality of service. Then optimization will be unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: When you do optimize, be very methodical and measured in your approach. Have
    a clear goal, and prove that each step is getting you closer to it. Be guided
    by solid data, not your hunches. As you write code, ensure that your designs are
    efficient, but don't compromise on quality. Worry about code-level performance
    only when it proves to be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid optimizing unless it proves to be absolutely necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt optimization methodically, taking a considered and measured approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Look for alternatives and investigate design improvements before ever resorting
    to code-level optimizations*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer optimizations that won't destroy the code's quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Start optimizing before the code proves to be inadequate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dive in feet first, attacking the pieces of code they think are bottlenecks
    without measuring or investigating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Never consider the wider picture: what the full implications of their optimization
    are in other code areas and usage patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think speed is more important than code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations that remove "unnecessary" code often clash with any extra defensive
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  prefs: []
  type: TYPE_NORMAL
- en: The needs of optimized code are often at odds with self-documenting code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency must be *designed* into the codebase from the start of a project.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  prefs: []
  type: TYPE_NORMAL
- en: Performance requirements must be carefully specified before construction begins
    so you know how much optimization is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207478.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 510.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optimization is a process of making trade-offs—sacrificing one quality of code
    for another desirable quality. Describe the kinds of trade-offs that lead to a
    performance increase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at each of the optimization alternatives listed in "[Why Not Optimize?](ch11s03.html
    "Why Not Optimize?")" on page 202\. Describe what trade-offs are being made, if
    any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Explain these terms and their exact relationship:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiency
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimized
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the likely bottlenecks in a slow program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you avoid the need to optimize? What methods will prevent you from writing
    inefficient code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the presence of multiple threads affect optimization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why *don't* we write efficient code? What stops us from using high-performance
    algorithms in the first place?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `List` data type is implemented using an array. What is the worst case algorithmic
    complexity of each of the following `List` methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`append`—places a new item on the end of the list'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`insert`—slides a new item in between two existing list items, at a given position'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isEmpty`—returns `true` if the list contains no items'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`contains`—returns `true` if the list contains a specified item'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get`—returns the item with a given index'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How important (honestly) is code performance in your current project? What is
    the motivator for this performance requirement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your last optimization attempt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did you use a profiler?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, how much improvement did you measure?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If no, how did you know whether you made any kind of improvement?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Did you test that the code still worked after optimizing?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, how thoroughly did you test?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If no, why not? How could you be sure the code still worked properly for *all*
    cases?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've not yet attempted to optimize the code you're currently working on,
    take a guess at which parts are the slowest and which bits consume the most memory.
    Now run it through a profiler—how accurate were you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How well specified are your program's performance requirements? Do you have
    a concrete plan to test that you meet these criteria?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12. AN INSECURITY COMPLEX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing Secure Programs*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security is mostly a superstition. It does not exist in nature. . . . Life is
    either a daring adventure or nothing.
  prefs: []
  type: TYPE_NORMAL
- en: --Helen Keller
  prefs: []
  type: TYPE_NORMAL
- en: Not so long ago, computer access was a scarce commodity. The world contained
    only a handful of machines, owned by a few organizations and accessed by small
    teams of highly trained personnel. In those days, computer security meant wearing
    the right lab coat and pass card to get past the guard on the door.
  prefs: []
  type: TYPE_NORMAL
- en: Fast-forward to today. We carry more computational power in our pockets than
    those operators ever dreamed of. Computers are plentiful and, more pertinently,
    highly connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The volume of data carried by computer systems is growing at a fantastic rate.
    We write programs to store, manipulate, interpret, and transfer this data. Our
    software must guard against information going astray: into the hands of malicious
    attackers, past the eyes of accidental observers, or even disappearing into the
    ether. This is critical; a leak of top-secret company information could spell
    financial ruin. You don''t want sensitive personal information (your bank account
    or credit card details, for example) leaking out for anyone to use. Most software
    systems require some level of security.^([[1](#ftn.CHP-12-FN-1)])'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whose responsibility is it to build secure software? Here''s the bad news:
    It''s *our* headache. If we don''t consider the security of our handiwork carefully,
    we will inevitably write insecure, leaky programs and reap the rewards.'
  prefs: []
  type: TYPE_NORMAL
- en: Software security is a really big deal, but generally we're very bad at it.
    Nearly every day you'll hear of a new security vulnerability in a popular product
    or see the results of viruses compromising system integrity.
  prefs: []
  type: TYPE_NORMAL
- en: This is an enormous topic, far larger than we have scope to go into here. It's
    a highly specialized field, requiring much training and experience. However, even
    the basics are not adequately addressed by modern software engineering teaching.
    The aim of this chapter is to highlight security issues, explore the problems,
    and learn some basic techniques to protect our code.
  prefs: []
  type: TYPE_NORMAL
- en: The Risks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Better be despised for too anxious apprehensions, than ruined by too confident
    security.
  prefs: []
  type: TYPE_NORMAL
- en: --Edmund Burke
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would anyone bother to attack your system? It''s usually because you''ve
    got something that they want. This could be:'
  prefs: []
  type: TYPE_NORMAL
- en: Your processing power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your ability to send data (e.g., spam)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your privately stored information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your capabilities—perhaps the specific software you have installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your connection to more interesting remote systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People might even attack you for the sheer fun of it or because they dislike
    you and want to cause harm by disrupting your computer resources. While malicious
    people *are* lurking around looking for easy, insecure prey, a security vulnerability
    might also be caused by a program that accidentally releases information to the
    wrong audience. A lucky user might exploit the leak and cause you harm.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Know what important assets you possess. Do you have particularly sensitive
    information or specific capabilities that an attacker might want? Guard them*.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the kinds of attack you might suffer, it's important to differentiate
    protecting an entire computer *system* (comprising of several computers, a network,
    and a number of collaborating applications) from writing a single secure *program*.
    Both are important aspects of computer security; they blur together since both
    are necessary. The latter is a subset of the former. It takes just one insecure
    program to render an entire computer system (or network) insecure.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the common security risks and compromises of a live, running computer
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: A thief who acquires a laptop or PDA can read any unsecured sensitive data.
    The stolen device might be configured to automatically dial into a private network,
    allowing a simple route straight through all your company's defences. This is
    a serious security threat and one that you can't easily guard against in code!
    What we can do is write systems that aren't immediately accessible to computer
    thieves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flawed input routines can be exploited, leading to many types of compromise—even
    to the attacker gaining access to the whole machine (we'll see this in "[Buffer
    Overrun](ch12s04.html#buffer_overrun "Buffer Overrun")" on page 229).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break-ins through an unsecured public network interface are particularly worrying.
    While vulnerbilities in a GUI interface can only be exploited by people actually
    *using* that UI, an insecure system running on a public network could lead to
    the whole world trying to break down your door.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Privilege escalation* occurs when a user with limited access rights tricks
    the system to gain a higher security level. The attacker could be an authentic
    user or someone who has just broken into the system. His or her ultimate aim is
    to achieve *root* or *administrator* privilege, where the attacker has total control
    of the machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If communication is unencrypted and traverses an insecure medium (e.g., the
    Internet), then any computer en route can syphon off and read data, like a phone
    tap. A variant of this is known as a *man-in-the-middle attack*: An attacker''s
    machine pretends to be the other communicant and sits between both senders, snooping
    on their data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any system has a small set of trusted users. Malicious authorized users can
    wreak havoc by copying and sharing data they're not supposed to or entering bad
    data to compromise the quality of your computer system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's hard to guard against this. You have to trust that each user is responsible
    enough to handle the level of system access he or she has been designated. If
    the user isn't trustworthy, you can't write a program to fix it. This shows that
    security is as much about administration and policy as it is about writing code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Careless users (or careless administrators) can leave a system unnecessarily
    open and vulnerable. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People forget to log off; if there is no session timeout, anyone can pick up
    your program later and start using it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many attackers use dictionary-based password-cracking tools that fire off many
    login attempts until one works. Users choose easy-to-memorize passwords that are
    also easy to guess. Any system that allows weak, easy-to-guess passwords is vulnerable.
    More secure systems suspend a user's account after a few unsuccessful logins.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Social engineering*—the art of acquiring important information from people,
    items in an office, or even the outgoing trash—is usually a lot easier (and often
    quicker) than worming a way into your computer system. People are easier to con
    than computers, and attackers know this.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-date software installations permit many compromises. Many vendors issue
    security warnings (or *bulletins*) and software patches. An administrator can
    easily fall behind the cutting edge, leaving the system open to attack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting lax permissions will allow users access to sensitive parts of your system—for
    example, letting casual viewers read everyone's salary details. The cure could
    be as basic as setting correct access permissions on the database files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virus attacks (self-replicating malicious programs, commonly spread by email
    attachment), Trojans (hidden malicious payloads in seemingly benign software),
    and spyware (a form of Trojan that spies on what you are doing, the web pages
    you visit, etc.) infect machines and can cause all sorts of mayhem. They can capture
    even the most complex password with keystroke loggers, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data "in the clear" (unencrypted)—even in memory—is dangerous. Memory
    is not as safe as many programmers think; a virus or Trojan can scan computer
    memory and pull out a lot of interesting tidbits for an attacker to exploit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The risks increase as the number of routes into a system grows, with more input
    methods (web-access, command-line, or GUI interfaces), more individual inputs
    (different windows, prompts, web forms, or XML feeds), and more users (there is
    a better chance of someone discovering a password). With more outputs, there are
    more chances for bugs to manifest in the display code, leaking out the wrong information.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The more complicated a computer system is, the more likely it is to contain
    security vulnerabilities. Therefore, write the simplest software possible!*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-12-FN-1)]) As we'll see, this is true whether they handle sensitive
    data or not. If a noncritical component has a public interface, then it poses
    a security risk to the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The Opposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's probably difficult to believe that anyone would take the time and effort
    to hack your application. But these people exist. They're talented, motivated,
    and very, very patient. In the battle to write secure software, it's important
    to know who you're fighting against. Understand exactly what they're doing, how
    they do it, the tools they're using, and their objectives. Only then can you formulate
    a strategy to cope.
  prefs: []
  type: TYPE_NORMAL
- en: '**SECURE IN THE KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These important terms help us to reason about security problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flaw**'
  prefs: []
  type: TYPE_NORMAL
- en: A security flaw is an unintended problem in an application. It is a program
    fault (see "[TERMS AND CONDITIONS](ch10s03.html#terms_and_conditions-id1 "TERMS
    AND CONDITIONS")" on page 130). Not all flaws are security problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability**'
  prefs: []
  type: TYPE_NORMAL
- en: A vulnerability exists when a flaw opens the possibility for a program to be
    insecure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploit**'
  prefs: []
  type: TYPE_NORMAL
- en: This is an automated tool (or a manual method) that employs a program vulnerability
    to force unintended—and insecure—behavior. Not all vulnerabilities are found and
    exploited (that's called *luck*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Who**'
  prefs: []
  type: TYPE_NORMAL
- en: Your attacker might be a common crook, a talented cracker, a *script kiddie*
    (a derogatory name for crackers who run automated cracker scripts—they exploit
    well-known vulnerabilities with little skill themselves), a dishonest employee
    cheating the company, or a disgruntled ex-employee seeking revenge for unfair
    dismissal.
  prefs: []
  type: TYPE_NORMAL
- en: Crackers are well informed. There is a cracker subculture where knowledge is
    passed on and easy-to-use cracker tools are distributed. Not knowing about this
    doesn't make you innocent and pure, just naïve and open to the simplest attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where**'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to pervasive networking, attackers could be anywhere, on any continent,
    using any type of computer. When working over the Internet, attackers are very
    hard to locate; many are skilled at covering their tracks. Often they crack easy
    machines to use as covers for more audacious attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**When**'
  prefs: []
  type: TYPE_NORMAL
- en: They could attack at any time, day or night. Across continents, one person's
    day is another's night. You need to run secure programs around the clock, not
    just during business hours.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why**'
  prefs: []
  type: TYPE_NORMAL
- en: With such a large bunch of potential attackers, the motives for an attack are
    diverse. It might be malicious (a political activist wants to ruin your company
    or a thief wants to access your bank account), or it might be for fun (a college
    prankster wants to post a comical banner on your website). It might be inquisitive
    (a hacker just wants to see what your network infrastructure looks like or practice
    his cracking skills) or opportunist (a user stumbles over data he shouldn't see
    and works out how to use it to his advantage).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a networked world, you usually won''t know who your enemies actually are
    until after they have struck. You might not even find out who they are then; your
    forensic skills might not be able to work back from a smouldering pile of digital
    debris. But like any good boy scout: *Be prepared*. Don''t ignore vulnerabilities
    and assume no one is interested in attacking your systems—someone out there *is*
    interested.'
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don''t ignore vulnerabilities and pretend that you''re invincible. Someone,
    somewhere wants to exploit your code, guaranteed*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CRACKER VS. HACKER**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These two terms often get confused and used inappropriately. Their correct
    definitions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cracker**'
  prefs: []
  type: TYPE_NORMAL
- en: Someone who purposefully exploits vulnerabilities in computer systems to gain
    unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hacker**'
  prefs: []
  type: TYPE_NORMAL
- en: Often used incorrectly to mean *cracker*, a *hacker* is really someone who hacks
    at—works on—code. This is a 1970s term used with pride by a particular breed of
    programming geek. A hacker is a computer expert or enthusiast.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also see these two hacker terms in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**White hat**'
  prefs: []
  type: TYPE_NORMAL
- en: White hat hackers consider the consequences of their work, scorning the actions
    of crackers and unethical computer users. They believe that their work is for
    the good of society.
  prefs: []
  type: TYPE_NORMAL
- en: '**Black hat**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a programmer from the dark side who enjoys abusing computer systems.
    Black hats are crackers who actively seek to use systems dishonestly. They have
    no regard for other people's property or privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Excuses, Excuses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do attackers manage to break into code so often? They''re armed with weapons
    we don''t have or (due to lack of education) know nothing about. Tools, knowledge,
    skills: These all work in their favor. However, they have one key advantage that
    makes all the difference—time. In the heat of the software factory, programmers
    are pressed to deliver as much code as humanly possible (probably a little bit
    more) and to do so on time, or else. This code has to meet all requirements (for
    functionality, usability, reliability, etc.), leaving us precious little time
    to focus on other "peripheral" concerns, like security. Attackers don''t share
    this burden; they have plenty of time to learn the intricacies of your system,
    and they have learned to attack from many different angles.'
  prefs: []
  type: TYPE_NORMAL
- en: The game is stacked heavily in their favor. As software developers, we must
    defend all possible points of the system; an attacker can pick the weakest point
    and focus there. We can only defend against the known exploits; attackers can
    take their time to find any number of unknown vulnerabilities. We must be constantly
    on the lookout for attacks; attackers can strike at will. We have to write good,
    clean software that works nicely with the rest of the world; attackers can play
    as dirty as they like.
  prefs: []
  type: TYPE_NORMAL
- en: Software security presents a myriad of extra—but important—problems and challenges
    for the poor, overworked programmer. What does this tell us? Simply that we *must*
    do better. We must be better informed, better armed, more aware of our enemies,
    and more conscious of the way we write code. We must design in security from the
    outset and put it into our development processes and schedules.
  prefs: []
  type: TYPE_NORMAL
- en: Feeling Vulnerable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The programmer's role in this mess is to write secure code, so let's survey
    the weak points in our software to determine where we must focus our effort. These
    are specific types of code vulnerabilities, holes that can be compromised by an
    attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Insecure Design and Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most fundamental flaw, and consequently the hardest to fix. Failure
    to consider security at the architectural level will lead to committing security
    sins everywhere: sending unencrypted data over public networks, storing it on
    easily accessible media, and running software services that have known security
    flaws.'
  prefs: []
  type: TYPE_NORMAL
- en: Security should appear on the radar as soon as development starts. Every system
    component must be considered for security holes; a computer system is only as
    safe as its least secure part, which may not even be the code you're writing.
    For example, a Java program can be no more secure than the JVM executing it.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer Overrun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications are public facing, listening on an open network port or handling
    input from a web browser or GUI interface. These input routines are prime sites
    for security failure.
  prefs: []
  type: TYPE_NORMAL
- en: C code programs often use the standard library function `sscanf` to parse input.
    Although it's part of C's standard library and appears in C code regularly, `sscanf`
    unashamedly provides subtle ways to write insecure code.^([[2](#ftn.CHP-12-FN-2)])
  prefs: []
  type: TYPE_NORMAL
- en: 'You might see code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Can you see the glaring problem? An ill-formed `input` string—anything over
    100 characters—will overrun the `my_string` buffer and smear arbitrary data across
    invalid memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The results depend on what memory is trashed. Sometimes the program will carry
    on unaffected; you've been very, very lucky.^([[3](#ftn.CHP-12-FN-3)]) Sometimes
    the program continues, but its behavior is subtly altered—this can be hard to
    spot and confusing to debug. Sometimes the program will crash as a consequence,
    perhaps taking other critical system components down with it. But the worst case
    is when the spilt data gets written somewhere in the CPU's execution path. This
    isn't actually hard to do and allows an attacker to execute arbitrary code on
    your machine, potentially gaining complete access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Overrun is easiest to exploit when the buffer is located on the stack, as in
    the example above. Here it's possible to direct CPU behavior by overwriting the
    stack-stored return address of a function call. However, buffer overrun exploits
    can abuse heap-based buffers too.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Query Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This breed of attack can be used to crash programs, execute arbitrary code,
    or fish for unauthorized data. Like buffer overrun, it relies on a failure to
    parse input, but rather than burst buffer boundaries, these attacks exploit what
    the program subsequently does with the unfiltered input.
  prefs: []
  type: TYPE_NORMAL
- en: '*Format string attacks* are a classic example of this problem in C programs.
    A common culprit is the `printf` function (and its variants), used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A malicious user could provide an input string containing `printf` format tokens
    (like `%s` and `%x`) and coerce the program to print data from the stack or even
    from locations in memory, depending on the exact form of the `printf` call. An
    attacker can also write arbitrary data to memory locations using a similar ploy
    (exploiting the `%n` format token).
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to this problem aren't hard to find. Writing `printf("%s", input)`
    will avoid the problem by ensuring that `input` is not interpreted as a format
    string.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other situations where an embedded query can maliciously exploit
    a program. SQL statements can be surreptitiously fed into database applications
    to force them to perform arbitrary database lookups for an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another variant exhibited by lax web-based applications is known as a *cross-site
    scripting* exploit, due to the way the attack works across the system: from an
    attacker''s input, through the web application, finally manifesting on a victim''s
    browser. An attacker''s bogus comment on a web-based messaging system will be
    rendered by all browsers viewing the page. If the message contains hidden JavaScript
    code, the browsers will execute it without their users realizing it.'
  prefs: []
  type: TYPE_NORMAL
- en: Race Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to exploit systems that rely on the subtle ordering of events,
    to provoke unintended behavior or crash the code. This is generally exhibited
    in systems with complex threading models or that are comprised of many collaborating
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: A threaded program might share its memory pool between two worker threads. Without
    adequate guarding, one thread might read information in the buffer that the writer
    thread did not intend to release yet—part of a privileged transaction or a different
    user's information.
  prefs: []
  type: TYPE_NORMAL
- en: This problem isn't restricted to threaded applications, though. Consider the
    following fragment of Unix C code. It intends to dump some output to a file and
    then change file permissions on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is a race here that an attacker can exploit. By removing the file at point
    `A` and replacing it with a link to his own file, the attacker gains a specially
    privileged file. This can be used to further exploit the system.
  prefs: []
  type: TYPE_NORMAL
- en: Integer Overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Careless use of mathematical constructs can cause a program to cede control
    in unusual ways. Integer overflow will occur when a variable type is too small
    to represent the result of an arithmetic operation. The unsigned 8-bit data type
    (`uint8_t`) renders this C calculation erroneous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of `a` will be 0, not the 256 you''d expect; 8 bits can only count
    up to 255\. An attacker can supply very large numeric input values to provoke
    overflow and generate unintended program results. It''s not hard to see this causing
    significant problems; the following C code contains a heap overrun waiting to
    happen, thanks to integer overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's true that `uint8_t` is an unlikely candidate for the string length variable,
    but the exact same problem manifests itself with larger data types. It's less
    likely in normal operation, but just as exploitable.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of problem also occurs with subtraction operations (where it's called
    integer *underflow*), mixed signed and unsigned assignments, bad type casting,
    and multiplication or division.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-12-FN-2)]) This example is written in C and is common in C code,
    but remember that this exploit is far from a C-only problem.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-12-FN-3)]) Or, to look at it another way, you've been very unlucky.
    You didn't spot the flaw when testing; it will enter production code, just waiting
    for a cracker to exploit it.
  prefs: []
  type: TYPE_NORMAL
- en: Protection Racket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more you seek security, the less of it you have.
  prefs: []
  type: TYPE_NORMAL
- en: --Brian Tracy
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen how software construction is like building a house (see "[DO WE
    REALLY BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question "DO WE
    REALLY BUILD SOFTWARE?")" on page 177, and Chapter 14). We must learn to secure
    our programs just like we''d protect a house, locking all doors and windows, employing
    a sentry, and adding security mechanisms (like a burglar alarm, electronic pass
    cards, identity badges, etc.). But you must still be constantly vigilant: A door
    can be left ajar regardless of any fancy lock devices, and a burglar alarm can
    be left unset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our software security strategies apply at different levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The system** installation'
  prefs: []
  type: TYPE_NORMAL
- en: The exact OS configuration, network infrastructure, and version numbers of all
    running applications have important security implications.
  prefs: []
  type: TYPE_NORMAL
- en: '**The software system** design'
  prefs: []
  type: TYPE_NORMAL
- en: We need to address design issues like whether the user can remain logged in
    for indefinite periods, how each subsystem communicates, and which protocols are
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '**The program** implementation'
  prefs: []
  type: TYPE_NORMAL
- en: It must be flaw-free. Buggy code leads to security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**The system''s usage** procedure'
  prefs: []
  type: TYPE_NORMAL
- en: If it is routinely used incorrectly, any software system can be compromised.
    We should prevent this as much as possible with sound design, but users must be
    taught not to cause problems. How many people write down their username and password
    on paper beside their terminals?
  prefs: []
  type: TYPE_NORMAL
- en: Creating a secure system is never easy. It will always require a security/functionality
    compromise. The more secure a system is, the less useful it becomes. The safest
    system has no inputs and no outputs; there's nowhere for anyone to attack. It
    won't do much, though. The easiest system has no authentication and allows everyone
    full access to everything; it's just terribly insecure. We need to pick a balance.
    This depends on the nature of the application, its sensitivity, and the perceived
    threat of attack. To write appropriately secure code, we must be very clear about
    such *security requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you would take steps to secure a building, the following techniques
    will protect your software from malicious attackers.
  prefs: []
  type: TYPE_NORMAL
- en: System Installation Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No matter how good your application is, if the target system is insecure, your
    program is vulnerable. Even the most secure application must run in its operating
    environment: under a particular OS, on a specific piece of hardware, on a network,
    and with a certain set of users. An attacker is just as likely to compromise one
    of these as your actual code.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't run any untrusted, potentially insecure program on your computer system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This raises the question: What makes you trust a piece of software? You can
    audit open source software to prove that it''s correct (if you have the inclination).
    You can opt for the same software that everyone else uses, thinking that there''s
    safety in numbers. (However, if a vulnerability is found in that software, you,
    and many other people, must update.) Or you can pick a supplier based on their
    reputation, hoping that it''s a worthwhile indicator.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Only run trusted software on your computer system. Have a clear policy to
    decide who you trust*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Employ security technologies like firewalls and spam and virus filters. Don't
    let crackers in through a back door.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare for malicious authorized users by logging every operation, recording
    who did what and when. Back up all data stores periodically so that bogus modifications
    don't lose all of your good work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the access routes into the system, give each user a minimal set of
    permissions, and reduce the pool of users if you can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the system correctly. Certain OSes default to very lax security, practically
    inviting a cracker to walk straight in. If you're setting up such a system, then
    it's vital to learn how to protect it fully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install a *honeypot*: a decoy machine that attackers will find more easily
    than your real systems. If it looks plausible enough, then they''ll waste their
    energy breaking into it, while your critical machines continue unaffected. Hopefully
    you''ll notice a compromise of the honeypot and repel the attacker long before
    he gets near your valuable data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software Design Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the essential place to get your security story straight. You can try
    to shoehorn security into code at the end of a development cycle, and you'll fail.
    It must be a fundamental part of your system's architecture and design.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Security is an essential aspect of every software architecture. It''s a mistake
    to gloss over it during early development work*.'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest software design has the fewest points of attack and is consequently
    the easiest to secure. More complex designs naturally lead to more interactions
    between constituent parts, and so provide more places for a cracker to attack.
    If you're one of the 99.9 percent of programmers who can't run your program in
    a sealed box in an underground bunker in an undisclosed location in the middle
    of a desert, then you need to consider how to make your design as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you design the code, think about how to actively prevent anyone from abusing
    it. Here are the winning strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the number of inputs in your design, and route all communication through
    one portion of the system. This way, an attacker can't get all over your code—only
    through a single (secured) bottleneck. His influence is limited to a secluded
    corner, and you can focus your security efforts there.^([[4](#ftn.CHP-12-FN-4)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run every program at the most restrictive privilege level possible. Don't run
    a program as the system superuser unless it's absolutely necessary, and then take
    *even more* care than usual. This is especially important for Unix programs that
    run setuid—these can be run by any user but are given special system privileges
    when they start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid any features that you don't really need. It will not only save you development
    time, but also reduce the chance of bugs getting into the program—there's less
    software for them to inhabit. The less complicated your code, the less likely
    it is to be insecure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't rely on insecure libraries. An insecure library is anything you don't
    *know* to be secure. For example, most GUI libraries aren't designed for security,
    so don't use them in a program run as the superuser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Only rely on known, secure third-party components in your program design*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tailor your code to an execution environment that manages security issues. The
    .NET run time offers offers a *code access security* infrastructure that allows
    you to assert, for example, that the calling code has been signed by a trusted
    third party. This doesn't remove all potential problems (the company's private
    key could always go astray), and you must learn how to use it correctly, but it
    does help to manage security problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid storing sensitive data. If you must, encrypt it so that prying eyes can't
    easily read it. When you handle secrets, be very wary of where you put them; lock
    memory pages containing sensitive information so that your OS's virtual memory
    manager can't swap it onto the hard disk, leaving it available for an attacker
    to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain secrets from the user carefully. Don't display passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The least impressive security strategy is known as *security through obscurity*,
    yet this is really the most prevalent. It merely hides all software design and
    implementation behind a wall so that no one can see how the code works and figure
    out how to abuse it. Obscurity means that you don't advertise your critical computer
    systems in the hope that no attacker will find them.
  prefs: []
  type: TYPE_NORMAL
- en: It's a flawed plan. Your system *will* one day be found, and it *will* one day
    be attacked.
  prefs: []
  type: TYPE_NORMAL
- en: It's not always a conscious decision, and this technique works very conveniently
    when you forget to consider security in the system design at all—that is, it's
    convenient until someone *does* compromise your system. Then it's a different
    matter.
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Expect your software to be attacked, and design each part with this in mind*.'
  prefs: []
  type: TYPE_NORMAL
- en: Code Implementation Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a bulletproof system design, your software is unbreakable, right? Sadly,
    it is not. We've already seen how security exploits can capitalize on flaws in
    code to wreak their particular brand of chaos.
  prefs: []
  type: TYPE_NORMAL
- en: Our code is the front line, the most common route an attacker will try to enter
    through and the place our battles are fought. Without a good system design, even
    the best code is vulnerable to attack; but upon the foundation of a well-thought-out
    architecture, we must build strong walls of defense with secure code. Correct
    code is not necessarily secure code.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive programming is the main technique to achieve sound code. Its central
    tenet—*assume nothing*—is exactly what secure programming is about. Paranoia is
    a virtue, and you can never assume that users will employ your program as you
    expect or intend them to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple defensive rules like "check *every* input" (including user input, startup
    commands, and environment variables), and "validate *every* calculation" will
    remove countless security vulnerabilities from your code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Perform *security audits*. These are careful reviews of the source code by security
    experts. Normal testing won't find many security flaws; they are generally caused
    by bizarre combinations of use that ordinary testers wouldn't think of (for example,
    very long input sequences that provoke buffer overrun).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn child processes very carefully. If an attacker can redirect the sub-task,
    then he can gain control of arbitrary facilities. Don't use C's `system` function
    unless there's no other solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test and debug mercilessly. Squash bugs as rigorously as you can. Don't write
    code that can crash; its use could bring down a running system instantly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap all operations in atomic transactions so attackers can''t exploit race
    conditions to their advantage. You could fix the `chmod` example in "[Race Conditions](ch12s04.html#race_conditions
    "Race Conditions")" on page 231 by using `fchmod` on the open file handle, rather
    than `chmod`ing the file by name: It doesn''t matter if the attacker replaces
    the file, you know exactly which file is being altered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is largely a matter of training and education, although it helps to select
    users who aren't totally inept (if you have that luxury).
  prefs: []
  type: TYPE_NORMAL
- en: 'Users must be taught safe working practices: not to tell anyone their password,
    not to install random software on a critical PC, and to use their systems only
    as prescribed. However, even the most diligent people will make mistakes. We design
    to minimize the risk of these mistakes, and we hope that the consequences are
    never too severe.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-12-FN-4)]) Of course, it's never quite that simple. A buffer overrun
    could occur anywhere in your code, and you must be constantly vigilant. However,
    most security vulnerabilities exist at, or near, the sites of program input.
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a kind of death.
  prefs: []
  type: TYPE_NORMAL
- en: --Tennessee Williams
  prefs: []
  type: TYPE_NORMAL
- en: Programming is war.
  prefs: []
  type: TYPE_NORMAL
- en: Security is a real issue in modern software development; you can't stick your
    head in the sand and hide from it. Ostriches write poor code. We can prevent most
    security breaches by better design, better system architecture, and greater awareness
    of the problems. The benefits of a secure system are compelling, since the risks
    are so serious.
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the security requirements for each project they work on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instinctively write code that avoids common security vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design security into each system; they don't patch it in at the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a security test strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Dismiss security as an unimportant concern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider themselves security experts (very few people are security experts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only think about security flaws in their programs when vulnerabilities are discovered,
    or worse, when their code is compromised
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on security when writing code and ignore it at the design and architectural
    levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  prefs: []
  type: TYPE_NORMAL
- en: '*Defensive programing* is an important technique for writing secure code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  prefs: []
  type: TYPE_NORMAL
- en: We must rigorously test our software for security issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  prefs: []
  type: TYPE_NORMAL
- en: Security is similarly essential to the design of each section of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  prefs: []
  type: TYPE_NORMAL
- en: Security is one of the fundamental architectural concerns of a computer system.
    It must be designed in from the outset.
  prefs: []
  type: TYPE_NORMAL
- en: '![See Also](tagoreillycom20080909nostarchimages207480.png)'
  prefs: []
  type: TYPE_IMG
- en: Get Thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 515.
  prefs: []
  type: TYPE_NORMAL
- en: Mull It Over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a "secure" program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What input must be validated in a secure program? What sort of validation is
    required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you guard against attacks from the pool of trusted users?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can an exploitable buffer overrun occur? What functions are particularly
    prone to buffer overrun?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you avoid buffer overruns altogether?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you secure the memory in use by your application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are C and C++ inherently less secure than alternative languages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has the experience of C led to C++ being a better, more securely designed language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you know when your program has been compromised?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Personal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are the security requirements for your current project? How were these
    requirements established? Who knows about them? Where are they documented?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the worst security bug in one of your shipped applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many security bulletins have been posted against your application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have you ever run a *security audit*? What kinds of flaws did it reveal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of person is most likely to attack your current system? How is this
    influenced by
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your company
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of user
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of product
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The popularity of the product
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The competition
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The platform you run on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The connectedness and public visibility of the system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
