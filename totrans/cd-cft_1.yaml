- en: Part II. THE SECRET LIFE OF CODE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分. 代码的秘密生活
- en: This section investigates the art and craft of developing code—the daily activities
    of programming life. Although these topics aren't closely guarded secrets, you
    rarely hear expert discussion or see much written about them. Even so, mastering
    each practice is crucial if you want to write good programs; the code craftsman
    has a thorough understanding of all of these subjects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节探讨了开发代码的艺术和工艺——编程生活的日常活动。尽管这些话题并不是严格保密的秘密，但你很少听到专家的讨论或看到很多关于它们的写作。即便如此，掌握每一项实践对于编写好的程序至关重要；代码工匠对这些主题有全面的理解。
- en: 'We''ll look at:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨：
- en: '[Chapter 7](ch07.html "Chapter 7. THE PROGRAMMER''S TOOLBOX")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章. 程序员的工具箱")'
- en: A survey of the tools of our trade and how you should use them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们行业工具的调查以及如何使用它们。
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 测试时代")'
- en: No code is complete until it has been proved fit for purpose; until it has been
    tested. Here we look at the techniques for doing so.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何代码在未经证明适合其用途；未经测试之前都是不完整的。在这里，我们探讨如何进行测试的技术。
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章. 寻找错误")'
- en: 'Dealing with the inevitable: How to find and remove bugs in your code.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应对不可避免的事情：如何在你的代码中找到并移除错误。
- en: '[Chapter 10](ch10.html "Chapter 10. THE CODE THAT JACK BUILT")'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章. 杰克的代码")'
- en: '"Building" code: The process of converting source code into executable programs.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '"构建"代码：将源代码转换为可执行程序的过程。'
- en: '[Chapter 11](ch11.html "Chapter 11. THE NEED FOR SPEED")'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html "第11章. 对速度的需求")'
- en: A look at the gory details of code optimization. What, why, when, and how.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码优化的细节进行探讨。是什么、为什么、何时以及如何。
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章. 不安全感")'
- en: The thorny topic of software security—how to protect your code from willful
    abuse and malicious attack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全这个棘手的话题——如何保护你的代码免受恶意滥用和恶意攻击。
- en: 'These are fundamental aspects of code construction. With the pressures and
    time constraints of the software factory, they are more than essential skills—they''re
    survival tactics. With experience, they become second nature, so you can spend
    your precious time focusing on more pressing concerns: the architecture of your
    next system, the customer''s changing requirements, and who''s going to fetch
    your next cup of espresso.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是代码构建的基本方面。在软件工厂的压力和时间限制下，这些不仅仅是基本技能——它们是生存策略。随着经验的积累，它们变得习以为常，这样你就可以把宝贵的时间集中在更紧迫的问题上：你下一个系统的架构、客户不断变化的需求，以及谁会为你拿下一杯浓缩咖啡。
- en: Chapter 7. THE PROGRAMMER'S TOOLBOX
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 程序员的工具箱
- en: '*Using Tools to Construct Software*'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*使用工具构建软件*'
- en: Perilous to us all are the devices of an art deeper than we possess ourselves.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所有人来说，那些超越我们自身能力的艺术手段是危险的。
- en: --J.R.R. Tolkien
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: --J.R.R. 托尔金
- en: To be a productive craftsman, you need a good set of tools. The contents of
    a plumber's toolbox will support him in whatever task he encounters, or else you
    wouldn't call him the next time your taps explode.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一个高效的工匠，你需要一套好的工具。水管工工具箱的内容将支持他在遇到任何任务时，否则你下次水龙头爆裂时就不会再找他。
- en: Not only the *existence* but also the *quality* of these tools is vital; a good
    craftsman can be let down by poor tools. If the compression valves are bad, there
    will be water everywhere, no matter how good your plumber is.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的*存在*和*质量*同样至关重要；一个优秀的工匠可能会因为工具的糟糕而受挫。如果压缩阀坏了，无论你的水管工多么出色，到处都会漏水。
- en: Of course, it's your *use* of these tools that sets you apart as a master craftsman.
    The tools, by themselves, will achieve nothing. Before power tools, carpenters
    were perfectly able to craft exquisite furniture. The tools were more basic, but
    their skill with them produced things of beauty.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，是你对这些工具的使用让你区别于其他工匠。工具本身并不能完成任何事情。在动力工具出现之前，木匠完全能够制作出精美的家具。工具更为基础，但他们对工具的熟练使用产生了美丽的东西。
- en: The same is true of programming. To do a good job, you need to be supported
    by an appropriate kit of tools; tools that you have confidence in, know how to
    use, and are fit for the jobs you'll encounter. It takes a skilled craftsman,
    good tools, *and* mastery of those tools to craft great code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于编程。要做好工作，你需要一套合适的工具支持；你对其有信心、知道如何使用，并且适合你将要遇到的工作。这需要一位技艺高超的工匠、好工具，*以及*对这些工具的精通，才能编写出优秀的代码。
- en: This is serious stuff. How you use your tools can set you apart as a truly productive
    programmer. In extreme cases, these tools could provide the shortcut that determines
    your project's success or failure. The relentless pace of the software factory
    means that you should cling tightly to anything that will help you produce better
    code and produce it more quickly and reliably.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是严肃的事情。你如何使用你的工具可以让你成为一个真正高效的程序员。在极端情况下，这些工具可能提供决定项目成功或失败的捷径。软件工厂的持续节奏意味着你应该紧紧抓住任何能帮助你更快、更可靠地产生更好代码的东西。
- en: Other chapters cover issues that relate to particular tools. Here we'll broach
    the subject of *software tools* as a whole. Programming is a discipline that simply
    can't do without tools. From day to day, we use tools without much of a thought,
    taking the compiler for granted in much the same way you'd take a can opener for
    granted—it's fine while it works, but as soon as it goes wrong (or you need to
    open an oddly shaped can) you're stuck, no matter how fancy the can opener is.
    A cheap, basic can opener that works is better than some pretentious contraption
    that doesn't.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其他章节涵盖了与特定工具相关的问题。在这里，我们将探讨**软件工具**的整体问题。编程是一个无法没有工具的学科。从日常到日常，我们使用工具而不多加思考，就像你理所当然地使用罐头开启器一样——只要它工作就好，但一旦它出问题（或者你需要打开一个形状奇特的罐头）你就陷入了困境，不管罐头开启器多么花哨。
- en: What Is a Software Tool?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是软件工具？
- en: We use a wide range of tools to construct software; they are *programs that
    build programs*—if that isn't too philosophical. Everything we use to create software
    is a tool of some form. Some tools help you write code. Some help you write *good*
    code. Some help sort out the mess of code you just created.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用各种工具来构建软件；它们是**构建程序的程序**——如果这不算太哲学的话。我们用来创建软件的每一件事都是以某种形式存在的工具。有些工具帮助你编写代码。有些帮助你编写**好的**代码。有些帮助你整理你刚刚创建的代码混乱。
- en: 'They come in all shapes and sizes and work in different ways. Obviously, the
    platform and environment they inhabit is a factor, but they also differ in:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它们形状各异，大小不同，工作方式也不同。显然，它们所在的平台和环境是一个因素，但它们在以下方面也存在差异：
- en: '**Complexity**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂性**'
- en: 'Some tools are elaborate environments with many, many features and incredible
    configurability. Some are minuscule utilities for a single task. Each approach
    has its pros and cons:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具是功能丰富且可配置性极强的高级环境。有些则是针对单一任务的微小实用程序。每种方法都有其优缺点：
- en: A feature-rich tool is cool, when you've *finally* learned how to get it to
    make coffee and bring you doughnuts at the same time. If the many magical features
    make it hard to use, then it's less helpful.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你终于学会如何让它同时煮咖啡并给你带来甜甜圈时，一个功能丰富的工具很酷。但如果许多神奇的功能使其难以使用，那么它就变得不那么有帮助了。
- en: Simple tools are easier to learn; it's obvious what they do. You just end up
    with a lot of them, one for each task. But if you string them together, there
    are a lot of interface points, so they don't always work together seamlessly.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的工具更容易学习；它们做什么很明显。你最终会拥有很多这样的工具，每个任务一个。但如果你将它们串联起来，会有很多界面点，因此它们并不总是无缝协作。
- en: Different tools have different scopes, performing everything from very specific
    tasks (searching files for text strings) to entire projects (a collaborative project
    management environment).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工具有不同的范围，从非常具体的任务（搜索文件中的文本字符串）到整个项目（协作项目管理环境）。
- en: '**Frequency of use**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用频率**'
- en: Some tools are used constantly; we can't live without them. Others are only
    dusted off once in a blue moon, but they're invaluable when you need them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有些工具被不断使用；我们无法没有它们生活。而有些工具则很少被使用，但当你需要它们时却非常宝贵。
- en: '**Interface**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**界面**'
- en: Some tools have pretty *graphical user interfaces (GUIs)*. Some are more basic,
    driven by a *command-line interface (CLI)* and directing their output to a file.
    Which you prefer depends on how your brain is wired and what you're used to.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具拥有相当漂亮的**图形用户界面（GUI**）。有些则更为基础，由**命令行界面（CLI**）驱动，并将输出定向到文件。你更喜欢哪一种取决于你的大脑是如何连接的以及你习惯了什么。
- en: Windows utilities tend to be graphical with no command-line access. The standard
    Unix utilities are the opposite, which makes them easier to automate and integrate
    into larger tools using scripts. The interface alters the way you harness a tool's
    power.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Windows实用程序通常具有图形界面，没有命令行访问。标准的Unix实用程序则相反，这使得它们更容易通过脚本自动化并集成到更大的工具中。界面改变了你利用工具力量的方式。
- en: '**Integration**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成**'
- en: Some tools fit into a larger toolchain, often subsumed in a graphical *integrated
    development environment (IDE)*. Stand-alone command-line utilities tend to generate
    plaintext output in a format suitable as input to other tools, acting primarily
    as data filters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具可以集成到更大的工具链中，通常被包含在图形化的*集成开发环境（IDE）*中。独立的命令行实用程序倾向于生成适合作为其他工具输入的纯文本输出，主要作为数据过滤器。
- en: Monolithic GUI interfaces can be very comfortable to use, and the integration
    can make you incredibly productive. On the other hand, they take time to set up
    just as you'd like them, and they seldom offer the full power of more manual command-line
    tools. But although they are incredibly powerful, the discrete Unix tools all
    have different cryptic interfaces that make them hard to use.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的GUI界面可以非常舒适地使用，并且集成可以使你极其高效。另一方面，它们需要花费时间来设置，就像你希望的那样，而且它们很少提供比手动命令行工具更全面的功能。但尽管它们非常强大，离散的Unix工具都有不同的难以理解的界面，这使得它们难以使用。
- en: '**Cost**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**成本**'
- en: There are many excellent free tools.^([[1](#ftn.CHP-7-FN-1)]) However, you often
    get what you pay for. Free tools tend to have have poorer documentation, less
    support, or a smaller feature set. This doesn't always hold true, though. Some
    free tools are far superior to their commercial counterparts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的免费工具.^([[1](#ftn.CHP-7-FN-1)]) 然而，你得到的往往是你所付出的。免费工具通常具有较差的文档、较少的支持或较小的功能集。但这并不总是如此。一些免费工具远优于它们的商业版本。
- en: You can pay as much as you want for any type of tool, but a higher price tag
    doesn't guarantee a better product. I've worked with some fantastically expensive
    tools that were spectacularly poor. Which leads on to . . .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为任何类型的工具支付你想要的任何费用，但更高的价格标签并不保证更好的产品。我曾使用过一些极其昂贵的工具，它们的表现极其糟糕。这引出了……
- en: '**Quality**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量**'
- en: Some tools are really good. Some tools are really bad. I have a couple of critical
    tools that I'd gladly never see again; they do the job, but only barely, and are
    permanently on the brink of a crash. But without them, I can't produce the code
    I get paid for. How often have I been tempted to rewrite them myself ? I can keep
    on dreaming.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有些工具非常好。有些工具非常糟糕。我有几个关键的工具，我愿意永远不再看到它们；它们能完成工作，但只是勉强，并且永远处于崩溃的边缘。但如果没有它们，我就无法编写我需要付费的代码。我有多经常被诱惑自己重写它们？我可以继续做梦。
- en: You'll pick tools based on these characteristics, making appropriate compromises.
    Although it's important to get accustomed to your usual tool set, to learn it
    and to be productive with it, avoid the temptation to become religious about it.
    Most Windows users despise Unix-style development, while Unix hackers look down
    on Windows coders because they can't handle the command line. Get over it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你将根据这些特性选择工具，做出适当的妥协。虽然习惯于你常用的工具集、学习它并使用它提高生产力很重要，但避免对其产生宗教般的执着。大多数Windows用户讨厌Unix风格的开发，而Unix黑客看不起Windows程序员，因为他们无法处理命令行。克服它。
- en: I challenge you to try working in a different environment on a reasonably large
    project. It will help you fully understand what makes a good toolchain and help
    you gain a real "world view" of software tools.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我挑战你尝试在一个合理的大型项目中在一个不同的环境中工作。这将帮助你完全理解什么是好的工具链，并帮助你获得真正的“世界观”软件工具。
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[1](#CHP-7-FN-1)]) *Free* has two meanings in the software world: free as
    in *beer* (the tool won''t cost you anything to obtain) and free as in *speech*
    (open source software whose code you can view and modify). Which *free* is more
    important depends on how much of an idealist you are. See "[LICENSES](ch18s06.html#licenses
    "LICENSES")" on page 361.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-7-FN-1)]) 在软件世界中，“免费”有两个含义：免费就像*啤酒*（这个工具获取不会花费你任何费用）和免费就像*言论*（开源软件，你可以查看和修改其代码）。哪个“免费”更重要取决于你有多理想主义。参见第361页的“[LICENSES](ch18s06.html#licenses
    "LICENSES")”。
- en: Why Worry About Tools?
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为何要担心工具？
- en: It's impossible to create programs without a core set of software tools; you'd
    be stuck without an editor or compiler. There are other tools that you *can* get
    by without, but that are still genuinely useful. In order to improve your productivity,
    code quality, and craftsmanship, it's good to pay a little attention to the tools
    you're currently using and find out what they can really do.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 没有核心软件工具集就无法创建程序；你会被困在没有编辑器或编译器的情况下。还有一些工具你可以没有，但仍然非常有用。为了提高你的生产力、代码质量和工艺，关注你目前正在使用的工具，并了解它们真正能做什么是很好的。
- en: When you understand how your tools work and which tool to use for which job,
    you are better able to produce code that works properly—and produce it more quickly.
    Smarter tool use will make you a smarter programmer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你了解你的工具如何工作以及为哪种工作使用哪种工具时，你就能更好地产生正确工作的代码——并且更快地完成它。更聪明的工具使用会使你成为更聪明的程序员。
- en: '**KEY CONCEPT**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Know your common tools inside out. A little time invested to become proficient
    with them will quickly pay off*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*深入了解你常用的工具。花一点时间掌握它们，很快就能得到回报*。'
- en: 'Let''s be clear about why we actually use tools: Tools don''t do our work *for
    us*—they *enable* us to do our work. The quality of software is always determined
    by the competence of its programmer. Remind yourself of that the next time your
    compiler spits out pages of error messages. You wrote the code, dimwit!'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确我们为什么实际上使用工具：工具不是为我们做工作——它们*使我们能够*做工作。软件的质量始终由其程序员的技能决定。下次当你编译器吐出错误信息时，提醒自己这一点。是你写了代码，笨蛋！
- en: 'Programmers have wildly varying attitudes with regard to selecting and using
    tools. There''s probably some deep psychological reasoning behind it all—something
    to do with whether you''re an Evil Genius or not. On encountering a new lengthy
    task:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在选择和使用工具方面有着截然不同的态度。这背后可能有一些深层的心理原因——可能与你是否是邪恶天才有关。在遇到一个新的大任务时：
- en: Some programmers laboriously complete it by hand.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些程序员费力地手动完成它。
- en: Others write a tool in a scripting language to do the job automatically.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他程序员编写一个脚本语言工具来自动完成工作。
- en: Others spend hours searching for a pre-written tool to do the job for them.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他人在寻找一个预先编写的工具来做这项工作，花费数小时。
- en: 'Given a tool that *might* solve the problem:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个可能解决问题的工具：
- en: Some programmers fiddle with it until they get something near enough to what
    they want.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些程序员不断尝试，直到得到接近他们想要的结果。
- en: Others carefully read the documentation to find out exactly what can be done
    and *then* start to use it.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他程序员仔细阅读文档，找出确切可以做什么，然后才开始使用它。
- en: Which the right approach? Well, it depends. Part of becoming a mature programmer
    is understanding how different situations require different solutions and applying
    the right tools for the right job. Everyone is different and everyone works differently—your
    colleagues may be most productive using different tools than the ones that are
    your favorites. But if you saw someone converting his C code into assembly by
    hand on a day-to-day basis, you'd question his sanity.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法才是正确的？嗯，这取决于。成为一名成熟程序员的组成部分是理解不同情况需要不同的解决方案，并针对不同的工作应用正确的工具。每个人都是不同的，每个人工作方式也不同——你的同事可能使用你最喜欢的工具之外的工具来提高生产力。但如果你看到有人每天都在手动将C代码转换为汇编代码，你会质疑他的理智。
- en: Invest your time and money in tools practically. Think about how you're going
    to use a tool. Search for or write a new tool only when the time it will take
    to do so *will* pay off. Don't spend a week writing a tool that will only save
    you one hour every month. Do spend a week writing a tool that will save you one
    hour every day.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上投资你的时间和金钱在工具上。考虑你将如何使用一个工具。只有在这样做所需的时间会得到回报时，才去寻找或编写一个新工具。不要花一周时间编写一个每月只能为你节省一小时的工具。但确实花一周时间编写一个每天能为你节省一小时的工具。
- en: '**KEY CONCEPT**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Adopt a pragmatic approach to software tools—use them only when they''ll make
    your life easier*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*采取务实的软件工具方法——只有在它们能让你生活更轻松时才使用它们*。'
- en: Power Tools
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功率工具
- en: Since programming and tools go hand in hand, in order to be a super-programmer,
    you need to be a super-tool user. What does that mean?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程和工具密不可分，为了成为一名超级程序员，你需要成为一名超级工具用户。这意味着什么？
- en: First, it's important to have a good understanding of which tools are around.
    In the next section, we will run down a list of the common tools that every programmer
    should have on hand. You don't need to know every tool on the market; it makes
    for incredibly dull dinner party conversation, anyway. Just knowing the general
    categories of tools that exist, rather than specific products, is the important
    step forward. That will help you choose between finding a tool for a particular
    task, writing the tool yourself, or doing the task by hand.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解周围有哪些工具是很重要的。在下一节中，我们将列出每个程序员都应该随身携带的常见工具列表。你不需要了解市场上每个工具；毕竟，这会让晚宴上的谈话变得极其乏味。仅仅了解存在的工具的一般类别，而不是具体产品，是向前迈出的重要一步。这将帮助你选择是找到一个特定任务的工具，自己编写工具，还是手动完成这项任务。
- en: Take the time to get informed. Check out where you can obtain some of these
    tools—there are shops that specialize in selling software tools and plenty of
    download sites on the Internet. Maybe you already have some installed but never
    needed them, or you didn't appreciate how useful they were. Learn what you can
    expect tools to do for you; it will prepare you for good tool usage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 抽出时间来获取信息。查看你可以在哪里获得这些工具——有一些商店专门销售软件工具，互联网上也有大量的下载网站。也许你已经有了一些安装好的工具，但从未使用过，或者你没有意识到它们有多有用。了解工具能为你做什么；这将帮助你更好地使用工具。
- en: '**KEY CONCEPT**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Know the sorts of tools that are available. Make sure you know where to get
    them, even if you don''t need them right now*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解可用的工具种类。确保你知道在哪里可以获取它们，即使你现在不需要它们*。'
- en: Be prepared to try a new tool and to take time to learn it; this is a healthy
    attitude. You may be forced to find new tools if you start a new project, move
    to a new platform, encounter a new kind of problem, or find that your old tools
    have become deprecated. But don't wait to be pushed—make sure that right now,
    you're using the best tools you can get your hands on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 准备尝试新的工具，并花时间学习它；这是一种健康的态度。如果你开始一个新的项目，迁移到新的平台，遇到新的问题，或者发现你的旧工具已经过时，你可能被迫寻找新的工具。但不要等到被推动——确保现在，你正在使用你能得到的最好的工具。
- en: Devote a portion of your time to honing your tools skills—just as you'd spend
    time reading a techie book or magazine or taking a professional training course.
    This stuff is important, so invest in it accordingly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 投入一部分时间来磨练你的工具技能——就像你花时间阅读技术书籍或杂志，或者参加专业培训课程一样。这些东西很重要，所以相应地投资于它们。
- en: Here are a few simple steps to become a tool power user. For each weapon in
    your software construction arsenal . . .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的步骤，帮助你成为工具高手。对于你软件构建武器库中的每一件武器 . . .
- en: Understand What It Can Do
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解它能做什么
- en: Find out the feature set—what it can *really* do, not what you think it *should
    be able* to do. Even if you don't know how to wring out every last drop of goodness
    (maybe you'd have to look up the more esoteric command-line parameters), knowing
    what it's capable of will be helpful.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 了解功能集——它 *真正* 能做什么，而不是你认为它 *应该* 能做什么。即使你不知道如何榨取每一滴好处（可能你需要查找更神秘的命令行参数），了解它的能力将是有帮助的。
- en: Are there particular things the tool *can't* do? Perhaps it doesn't support
    some facilities provided by its counterparts. Understand these limitations, so
    you know when to shop around for something better.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 工具 *不能* 做的事情有哪些？也许它不支持其竞争对手提供的某些功能。了解这些限制，这样你就知道何时寻找更好的替代品。
- en: Learn How to Drive it
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习如何驾驭它
- en: Just because you've run the tool without generating an error doesn't mean it
    has done *exactly* what you wanted it to do. You must know how to use it properly
    and be confident that you can make it do your bidding.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在运行工具时没有产生错误，并不意味着它已经 *完全* 做了你想要它做的事情。你必须知道如何正确使用它，并自信地相信你可以让它按照你的意愿行事。
- en: How does the tool fit into the whole toolchain? This will affect how you use
    it. For example, Unix tools can be used as sequential filters by *piping* them
    together—splicing small individual tools into a larger utility.^([[2](#ftn.CHP-7-FN-2)])
    Understanding how to harness the power of each tool and learning about how they
    inter-operate lifts your tool usage a notch.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具如何融入整个工具链？这将影响你如何使用它。例如，Unix 工具可以通过 *管道* 连接在一起，作为顺序过滤器——将小型单个工具拼接成更大的实用工具.^([[2](#ftn.CHP-7-FN-2)])
    了解如何利用每个工具的力量，以及了解它们如何相互协作，可以提高你的工具使用水平。
- en: Figure out the best way to use each tool—it might not be by calling it directly
    or by clicking somewhere in the GUI interface. Can it be triggered automatically?
    A compiler is often invoked through a build system, rather than manually.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 确定使用每个工具的最佳方式——这不一定是通过直接调用它或在 GUI 界面中点击某个地方。它可以自动触发吗？编译器通常是通过构建系统调用的，而不是手动调用。
- en: Know What Tasks It's Good For
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解它适合哪些任务
- en: Know how each tool fits in the context of the other available tools. For example,
    I can set up keystroke recording macros, which allow me to save time on repetitive
    actions, in my text editor. Some of these alterations could also be done using
    a magic sed invocation.^([[3](#ftn.CHP-7-FN-3)]) However, it's better to use the
    keystroke macros in this context—I'm already using the editor and so it's quicker
    to fire them off.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: You might not know how to use yacc,^([[4](#ftn.CHP-7-FN-4)]) but if you ever
    need to write a parser, you'll save yourself loads of effort knowing it's there.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '*Use the right tool for the right task. Don''t crack a walnut with a sledgehammer*.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Check That It's Working
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everyone becomes the victim of bad tools at some point. Your code doesn't work,
    but no matter how long you search for the errant behavior, there's no explanation.
    In desperation, you'll test random things—checking that the wind is blowing in
    the right direction and the light fittings have been secured correctly. Several
    hours later, you'll find a flaky tool doing something peculiar.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Compilers can produce faulty code. Build systems can get dependencies wrong.
    Libraries harbor bugs. Learn how to check for obvious failures before you rip
    out too much of your own hair.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Having access to the source code for your tools can be instrumental in diagnosing
    any problems you encounter, allowing you to work out exactly what a tool is doing.
    This might be a deciding factor in your choice of tool set.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Have a Clear Route to Find Out More
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't have to know it all. The trick is to know someone who does!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Find out where the tool's documentation is. Who provides support? How do you
    get more information? Look for manuals, release notes, online resources, internal
    help files, and man pages. Know where they are and how to access them on demand.
    Do the online versions have useful search tools and good indexing?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Find Out When New Versions Appear
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tools seem to develop at an incredible rate—in this industry, technology changes
    fast. Some tools develop much faster than others. You've barely installed the
    latest widgetizer when the authors release a newer version with a longer red stripe
    down the side.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: It's important to stay informed about the tools you use so that you don't get
    out of date and end up with a potentially buggy and unsupported tool kit. But
    this should be done cautiously; don't blindly chase the latest version. The bleeding
    edge can be painful!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: New versions may have new bugs and new higher prices. Adopt upgrades if they
    provide significant fixes and have been proven stable. Test first—sanity check
    the new tool on your old code to make sure that it behaves itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep up to date with the latest developments in your tools, but don''t upgrade
    carelessly*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-7-FN-2)]) If you don't know much about this, I urge you to read
    up on it. The Unix command `man bash` is a good place to start; search the man
    pages for *pipelines*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: ^([[3](#CHP-7-FN-3)]) sed is a stream editor command-line utility, explained
    in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-7-FN-3)]) `sed` 是一个流编辑命令行实用程序，将在下一节中解释。
- en: ^([[4](#CHP-7-FN-4)]) A parser generator. Don't worry—it's explained later too.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-7-FN-4)]) 解析器生成器。不用担心——稍后也会解释。
- en: Which Tools?
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪些工具？
- en: There's a staggering array of software development tools. Over the years they
    have been developed to scratch particular itches, the needs that often crop up.
    When a task has been done many times, you can bet that someone has written a tool
    for it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发工具种类繁多。多年来，它们被开发出来以满足特定的需求，这些需求经常出现。当一项任务被多次执行时，你可以确信有人已经为它编写了一个工具。
- en: Exactly what comprises your tool kit will depend on your line of work. The available
    tools for embedded platforms are rarely as rich as those for desktop applications.
    We'll consider the common components below. Some are really obvious; others are
    less so.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工具包具体包含什么将取决于你的工作领域。嵌入式平台可用的工具通常不如桌面应用程序丰富。以下我们将考虑常见组件。有些非常明显；有些则不那么明显。
- en: 'While we''ll look individually at each class of tool, don''t forget that modern
    IDEs collect these disparate programs into a single, streamlined interface. This
    is undoubtedly convenient, but it''s important to understand how each tool stands
    on its own, for these reasons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将分别查看每种工具类别，但不要忘记现代IDE将这些不同的程序集成到一个单一、流畅的界面中。这无疑很方便，但了解每个工具独立存在的意义很重要，原因如下：
- en: You'll know how to get the best from each feature that's available.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将知道如何充分利用每个可用的功能。
- en: You'll know what useful features your IDE lacks.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将知道你的集成开发环境（IDE）缺少哪些有用的功能。
- en: Most IDEs are modular—you can substitute one component with a better alternative
    and plug in facilities that are not available right out of the box. Learn what
    tool varieties are around, and you'll improve your IDE experience.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IDE都是模块化的——你可以用更好的替代品替换一个组件，并插入那些出厂时不可用的功能。了解周围有哪些工具种类，你将提高你的IDE体验。
- en: Source Editing Tools
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码编辑工具
- en: A potter's medium is clay; a sculptor's, stone; and a programmer's, code. This
    is the fundamental thing we work with, so it's important to pick excellent tools
    to help us write, edit, and investigate source code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 陶艺家的媒介是粘土；雕塑家的，是石头；程序员的，是代码。这是我们工作的基本东西，因此选择优秀的工具来帮助我们编写、编辑和调查源代码非常重要。
- en: Source Code Editor
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码编辑器
- en: The editor is probably your most important tool, even more important than a
    compiler. The compiler faces the computer, whereas the editor faces *you*. And
    you're the one driving. This is where you'll spend most of your programming life,
    so pick a good editor and learn to use it *really* well. Being productive with
    your text editor will dramatically improve how you write code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器可能是你最重要的工具，甚至比编译器更重要。编译器面对的是计算机，而编辑器面对的是*你*。而你才是驾驶员。这就是你将在编程生活中花费大部分时间的地方，所以选择一个好的编辑器，并学会如何真正地使用它。使用文本编辑器提高生产力将极大地改善你的编码方式。
- en: '**KEY CONCEPT**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Your choice of code editor is vital: It has a huge impact on how you write
    code*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*你选择的代码编辑器至关重要：它对你的编码方式有着巨大的影响*。'
- en: 'The One True Source Editor is an age-old debate that doesn''t need to be stirred
    here, but you should select an editor that you are comfortable with and does what
    you require. Just because an editor is embedded in your visual IDE does not mean
    that it is the best editor for you. On the other hand, you may find that having
    it integrated is an incredible boon. For source code editing, I require at least
    the following from my editor:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “真正的源代码编辑器”是一个古老的争论，这里不需要再引起波澜，但你应该选择一个你感到舒适并且能满足你需求的编辑器。仅仅因为编辑器嵌入在你的可视化IDE中，并不意味着它就是最适合你的编辑器。另一方面，你可能会发现将其集成是一个巨大的好处。对于源代码编辑，我要求我的编辑器至少具备以下功能：
- en: Comprehensive syntax coloring (with support for *many* languages—since I use
    many languages)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合语法高亮显示（支持*许多*语言——因为我使用许多语言）
- en: Simple syntax checking (e.g., highlighting mismatched brackets)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的语法检查（例如，突出显示不匹配的大括号）
- en: Good *incremental search* facilities (an interactive form of find that searches
    as you type)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的*增量搜索*功能（一种在输入时搜索的交互式查找形式）
- en: Keyboard macro recording
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘宏录制
- en: Highly configurable
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可配置
- en: Works across every platform that I use
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我使用的每个平台上都能工作
- en: My requirements and choice of editor may not be the same as yours, but that
    seems like a fair list of the most important facilities. I don't mind spending
    a little time learning how to get the best out of all these features. It's worth
    it if it makes me productive.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我的要求和编辑器的选择可能与你不同，但这似乎是一个相当合理的最重要的功能列表。我不介意花点时间学习如何充分利用所有这些功能。如果它能让我更有效率，那就值得了。
- en: Depending on the type of work you're doing, you may find other types of editors
    useful. There are binary file editors (usually displaying file contents in hexadecimal;
    they're commonly called *hex editors*) and editors devoted to specific file formats,
    for example XML file editors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你正在进行的类型的工作，你可能会发现其他类型的编辑器很有用。有二进制文件编辑器（通常以十六进制显示文件内容；它们通常被称为*十六进制编辑器*）和针对特定文件格式的编辑器，例如XML文件编辑器。
- en: Vim and Emacs are the infamous Unix-land editors, available now on pretty much
    any platform (probably even your electric toaster). These contrast with the default
    editors bundled with IDEs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Vim和Emacs是臭名昭著的Unix编辑器，现在几乎可以在任何平台上找到（可能甚至包括你的电烤箱）。这些与IDE捆绑的默认编辑器形成对比。
- en: Source Manipulation Tools
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码操作工具
- en: The Unix philosophy is characterized by a large collection of small command-line
    tools. GUI environments have their counterparts for each tool, but they are rarely
    as powerful or easy to string together. The GUI versions are far simpler to learn,
    though.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Unix哲学的特点是拥有大量的小型命令行工具。每个工具都有对应的GUI环境，但它们通常没有这么强大或容易组合。GUI版本的学习要简单得多。
- en: 'The following Unix commands provide powerful mechanisms to investigate and
    modify source code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Unix命令提供了强大的机制来调查和修改源代码：
- en: '**`diff`**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**`diff`**'
- en: Compares two files and highlights the differences between them. Basic diff spits
    output to the console, but more sophisticated graphical versions exist. There
    are even editors that allow you to work on the diffed files, displaying them side
    by side and updating the differences as you type. Exotic diffs can compare three
    files at once.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个文件并突出显示它们之间的差异。基本的diff将输出到控制台，但更复杂的图形版本也存在。甚至还有编辑器允许你在比较的文件上工作，将它们并排显示，并随着你输入更新差异。奇特的diff可以一次性比较三个文件。
- en: '**`sed`**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**`sed`**'
- en: Stands for *stream editor*. Sed reads files a line at a time, applying a specified
    conversion rule. Sed can be used to reorder items, as a global search and replace
    tool, or to insert patterns into lines.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代表*流编辑器*。Sed逐行读取文件，应用指定的转换规则。Sed可以用作重新排序项目、全局搜索和替换工具，或者将模式插入到行中。
- en: '**`awk`**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**`awk`**'
- en: Imagine sed on steroids. Awk is another pattern-matching program that can process
    text files. It implements a full programming language for this task, so you can
    write quite advanced awk scripts to perform involved manipulation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下加强版的sed。Awk是另一个可以处理文本文件的匹配程序。它为此任务实现了一个完整的编程语言，因此你可以编写相当高级的awk脚本来执行复杂的操作。
- en: '**`grep`**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**`grep`**'
- en: Searches for patterns of characters in a file. These patterns are described
    by *regular expressions*, a form of mini-language allowing wildcard characters
    and flexible match criteria.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中搜索字符模式。这些模式由*正则表达式*描述，这是一种允许通配符字符和灵活匹配标准的迷你语言。
- en: '**`find`**/**`locate`**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**`find`**/**`locate`**'
- en: These tools help to find files in the filesystem. They can hunt them down by
    name, date, or a number of other criteria.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具有助于在文件系统中查找文件。它们可以通过名称、日期或其他许多标准来追踪它们。
- en: These are only the tip of the iceberg, and there are many other tools. `wc`,
    for example, performs word/character counting. For more gems, look into `sort`,
    `paste`, `join`, and `cut`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是冰山一角，还有许多其他工具。例如，`wc`执行单词/字符计数。对于更多宝石，请查看`sort`、`paste`、`join`和`cut`。
- en: Source Navigation Tools
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码导航工具
- en: Really large projects have codebases like cities. Not even the town planners
    intimately know each and every back street. A few taxi drivers know the best routes
    around. Normal citizens know their own neighborhoods fairly well. Tourists get
    lost as soon as they step off a bus.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的大型项目拥有像城市一样的代码库。甚至城镇规划者也不太了解每一条后街。少数出租车司机知道最佳路线。普通市民对自己的社区相当熟悉。游客一离开公交车就会迷路。
- en: There is a breed of tool to help you delve into and understand code, map it
    out, and perform easy searches, navigation, and cross-referencing. Some tools
    produce call-graph trees so you can see how control flows around the system. They
    may produce a graphical map or integrate with your editor to provide auto-completion,
    function call help, and more. This can be invaluable on large codebases or when
    entering a project that is well established.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种工具可以帮助你深入理解和映射代码，进行简单的搜索、导航和交叉引用。一些工具会生成调用图树，这样你可以看到控制流在系统中的流动。它们可能会生成图形映射或与你的编辑器集成，提供自动完成、函数调用帮助等。这对于大型代码库或进入一个已经建立的项目非常有价值。
- en: Good examples of freely available tools are LXR, Doxygen, and the venerable
    ctags.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一些免费可用的工具的好例子是LXR、Doxygen和备受尊敬的ctags。
- en: Revision Control
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制
- en: 'We won''t dwell on source control tools here, since we cover them in "[Source
    Control](ch18s02.html "Source Control")" on page 351\. Suffice to say: you *must*
    use one, or else have a limb forcibly amputated.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们不会过多地讨论源代码控制工具，因为我们在第351页的"[源代码控制](ch18s02.html "源代码控制")"中已经涉及了它们。简单来说：你*必须*使用一个，否则可能会被迫强行截肢。
- en: Source Generation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码生成
- en: A number of tools automatically generate source code. Some are good; some frighten
    me.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具会自动生成源代码。有些很好；有些让我感到害怕。
- en: One example is yacc, an LALR(1)^([[5](#ftn.CHP-7-FN-5)]) parser generator. You
    define the input grammar rules, then use it to generate programs that can parse
    well-formed input matching those rules. It spits out a C code parser with hooks
    for you to add functionality when items are parsed. Bison is a similar tool.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是yacc，一个LALR(1)^([[5](#ftn.CHP-7-FN-5)])解析器生成器。你定义输入语法规则，然后使用它来生成可以解析符合这些规则的正确输入的程序。它会生成一个C代码解析器，并提供钩子供你在解析项目时添加功能。Bison是一个类似工具。
- en: There is a class of code-generating tools that helps you to design user interfaces,
    spitting out the workhorse back-end code. These are especially used for complex
    GUI tool kits like MFC. If a library requires a tool to do *this much* legwork,
    then it implies that the library is too complex (or fundamentally broken) in the
    first place. Tread with caution!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种代码生成工具类别可以帮助你设计用户界面，生成工作后端代码。这些工具特别用于像MFC这样的复杂GUI工具包。如果一个库需要工具来做*这么多*基础工作，那么这表明该库本身可能过于复杂（或从根本上来说是损坏的）。小心行事！
- en: Wizards that write reams of scaffolding code that you must later revise and
    modify should also be treated with caution. You must honestly understand the generated
    code before you begin to attack it, or you'll be bitten by your own ignorance.
    If you rerun the wizard after modifying any generated code, all your hand-edits
    will be silently overwriten. Ouch.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 编写大量脚手架代码的向导应该也受到谨慎对待。在开始修改之前，你必须真诚地理解生成的代码，否则你可能会被自己的无知所咬。如果你在修改任何生成的代码后重新运行向导，所有的手动编辑都将被无声地覆盖。哎呀。
- en: You can even write your own scripts to spit out repetitive sections of code.
    Sometimes this is an indicator that your code could have been designed better.
    Sometimes it *is* the right technical approach. In the past, I have written Perl
    scripts to generate code for me automatically. Having written the generator, I
    trusted the code it generated. Another programmer might look at it distrustfully,
    like any other code wizard.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以编写自己的脚本来生成重复的代码段。有时这表明你的代码可能设计得更好。有时它*确实是*正确的技术方法。在过去，我编写了Perl脚本来自动生成代码。编写了生成器后，我信任它生成的代码。另一位程序员可能会怀疑地看着它，就像任何其他代码向导一样。
- en: Source Beautifiers
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码美化器
- en: These tools homogenize source code formatting, creating a uniform *lowest common
    denominator* layout. I honestly think they are more hassle than they're worth—they
    can destroy as much important and helpful formatting as they fix.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具使源代码格式统一，创建了一个统一的*最低公倍数*布局。我真诚地认为它们带来的麻烦比它们的价值大——它们可以破坏与它们修复的一样多的重要和有用的格式。
- en: Code Construction Tools
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码构建工具
- en: We don't want to stare at pretty source code all day. The fun bit is making
    it do something. We do this so often that we take the following tools for granted,
    assuming they all work, without thinking about what's going on behind the curtain.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想整天盯着漂亮的源代码。有趣的部分是让它做些事情。我们做这件事太频繁了，以至于我们理所当然地认为这些工具都会正常工作，而没有去思考幕后的情况。
- en: Compiler
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器
- en: Besides a source editor, this is the most used software tool. Compilers convert
    your source code into an executable so you can marvel at the ways your program
    fails to work. Since this tool is used so often, it's important that you can drive
    it properly. Do you really know all the options and facilities that it has? Many
    companies have a specific *buildmaster* who ensures that the build tools are used
    correctly, but this isn't an excuse to be ignorant of your compiler.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源代码编辑器之外，这是最常用的软件工具。编译器将你的源代码转换为可执行文件，这样你就可以惊叹于你的程序失败的方式。由于这个工具经常被使用，因此确保你能正确地使用它很重要。你真的了解它所有的选项和功能吗？许多公司都有一个专门的*buildmaster*，确保构建工具被正确使用，但这并不是不了解你的编译器的借口。
- en: Do you understand what level of optimization to employ and how that might affect
    the generated code? It's important—among other things, it will determine how surprisingly
    the code runs in the debugger, and even which compiler bugs you enable!
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否了解应该采用哪种级别的优化以及这可能会如何影响生成的代码？这很重要——在其他事情中，它将决定代码在调试器中的运行方式有多么令人惊讶，甚至可能激活哪些编译器错误！
- en: Do you compile with all warnings switched on? There really is no excuse not
    to (perhaps only if you're maintaining legacy code that is already riddled with
    warnings). The warnings highlight potential errors, and their absence gives you
    extra confidence in the code.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否在所有警告都开启的情况下编译？真的没有借口不这样做（也许只有当你维护的是已经充满警告的遗留代码时）。警告突出显示潜在的错误，它们的缺失让你对代码有额外的信心。
- en: Is the compiler standards-compliant by default? The C++ ISO standard is, (ISO
    98) the 1999 C standard is, (ISO 99) the Java language is defined by, (Gosling
    et al. 00) and C# by the ISO standard. (ISO 05) Does the compiler have any nonstandard
    extensions; if so, do you know what they are and how to avoid them?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器默认是符合标准的吗？C++ ISO标准是（ISO 98），1999年的C标准是（ISO 99），Java语言由（Gosling et al. 00）定义，C#由ISO标准定义。（ISO
    05）。编译器是否有任何非标准扩展；如果是，你知道它们是什么以及如何避免它们？
- en: Is it generating code for the correct CPU instruction set? You may be churning
    out 386-compatible code when you'll only ever run it on the latest Intel whiz-bang
    chip. Get your compiler to spit out the most appropriate code possible.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否为正确的CPU指令集生成代码？当你只会在最新的英特尔芯片上运行时，你可能会在生成386兼容的代码。让你的编译器输出尽可能合适的代码。
- en: '**I NEED A TOOL . . .**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**我需要工具……**'
- en: You need to perform a task. It's a dull task. It's repetitive. It's the kind
    of thing that *must* be better for a computer to do; it would be less error prone,
    less tedious, and far quicker. That's what computers were invented for! How do
    you find out if there's something to do the job for you?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要执行一项任务。这是一项枯燥的任务。它是重复的。这是那种计算机应该做得更好的事情；它将减少错误，减少乏味，并且更快。这正是计算机被发明出来的原因！你如何找出是否有东西可以为你完成这项工作？
- en: If it's mentioned in this list, you'll know already that a tool is available.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它在这个列表中提到，你已经知道有工具可用。
- en: If it's not in the list, but you're sure that you're not the first person to
    have this kind of problem, there's probably a tool out there *somewhere* that
    will help. You'd be surprised at some of the random programs a quick web search
    brings up.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它不在列表中，但你确信你不是第一个遇到这种问题的人，那么可能有一个工具“**某处**”可以帮到你。你可能会对快速网络搜索带来的随机程序感到惊讶。
- en: If your problem seems unique, you might have to write your own program for it.
    See "[ROLLING YOUR OWN](ch07s04.html#rolling_your_own "ROLLING YOUR OWN")" on
    page 126 for more on this.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的问题看起来很独特，你可能不得不为它编写自己的程序。参见第126页的“[自己动手做](ch07s04.html#rolling_your_own
    "自己动手做")”了解更多信息。
- en: 'When looking for a tool, get as much advice as you can:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找一个工具时，尽可能多地获取建议：
- en: Ask others on your team if they have any experience.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向团队中的其他人询问他们是否有任何经验。
- en: Search the web, and read appropriate newsgroups.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网上搜索，并阅读适当的新组。
- en: Go to tools vendors.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去工具供应商那里。
- en: Given the selection of available tools, you'll need to make an informed choice
    based on the criteria we saw in the first section. To make this decision, you
    must establish your requirements. Is it important that the tool is free? Or is
    it more important that you can get it now? Should it be easy to use for everyone
    on the team? How often will you use it—will it justify the expense?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用的工具选择中，你需要根据我们在第一部分看到的准则做出明智的选择。为了做出这个决定，你必须确立你的需求。工具是否免费重要吗？或者，现在能获取它更重要吗？它是否应该对团队中的每个人来说都易于使用？你将多久使用一次——它是否足以证明其费用合理？
- en: A *cross compiler* targets a different platform from the development machine.
    This is primarily used when writing embedded software (after all, it's hard to
    run Visual C++ on a dishwasher).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**交叉编译器**针对的是与开发机器不同的平台。这主要用于编写嵌入式软件（毕竟，在洗碗机上运行Visual C++是很困难的）。'
- en: The compiler is a single part of a larger toolchain, including the linker, assembler,
    debugger, profiler, and other object-file manipulators.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是更大工具链的一部分，包括链接器、汇编器、调试器、性能分析器和其他对象文件操作工具。
- en: Some popular compilers include gcc, Microsoft's Visual C++, and Borland's C++
    builder.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的编译器包括gcc、微软的Visual C++和博兰德的C++ builder。
- en: Linker
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接器
- en: The linker is closely allied with the compiler. It takes all the intermediate
    *object files* that a compiler spits out and glues them together into a single
    executable lump of code. The C and C++ linkers are so closely bound to the compiler
    that sometimes the same executable does both tasks. For Java and C# the linker
    is tied to the run-time environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器与编译器紧密相关。它将编译器输出的所有中间**对象文件**粘合在一起，形成一个单一的、可执行的代码块。C和C++链接器与编译器结合得如此紧密，有时同一个可执行文件会执行这两个任务。对于Java和C#，链接器与运行时环境相关联。
- en: 'When using your linker, make sure you know:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用你的链接器时，确保你知道：
- en: Does it *strip* the binary? That is, does it remove debugging symbols like the
    names of variables and functions? These can be used by a debugger to show useful
    diagnostic information, but they can also significantly bloat executables and
    make them slow to load.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否**剥离**了二进制文件？也就是说，它是否移除了调试符号，如变量和函数的名称？这些可以被调试器用来显示有用的诊断信息，但它们也可能显著增加可执行文件的大小，并使它们加载变慢。
- en: Does it eliminate replicated code sections?
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否消除了重复的代码部分？
- en: Can you make it spit out library objects rather than executables? What control
    do you have over the library—can you make it *statically* or *dynamically* loaded?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能让它输出库对象而不是可执行文件吗？你对库有什么控制权——你能让它**静态地**或**动态地**加载吗？
- en: Build Environment
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建环境
- en: The entire build environment is more than just a compiler and linker. The kind
    of build tools that we use are the Unix make program or the build portions of
    your IDE. They automate the compilation process. Many open source Unix projects
    use the autoconf and automake tools to simplify building.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 整个构建环境不仅仅是编译器和链接器。我们使用的构建工具是Unix的make程序或IDE的构建部分。它们自动化了编译过程。许多开源Unix项目使用autoconf和automake工具来简化构建。
- en: Learn how to get the most out of your integrated build environment, but not
    at the expense of knowing how to use each individual construction tool. We'll
    investigate these topics in more detail in [Chapter 10](ch10.html "Chapter 10. THE
    CODE THAT JACK BUILT").
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何充分利用你的集成构建环境，但不要以牺牲了解如何使用每个单独的构建工具为代价。我们将在第10章（[第10章：杰克建造的代码](ch10.html
    "第10章：杰克建造的代码"））中更详细地探讨这些主题。
- en: Testing Toolchain
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试工具链
- en: Note that this is a code construction tool, *not* a debugging tool! Appropriate
    testing is vital to the production of reliable, high-quality software. It is often
    neglected—perhaps because it's seen as too much work, distracting attention away
    from the important task of writing code. This is one of the biggest threats to
    good software. You cannot construct a reliable piece code unless you can prove
    that it works correctly, and the only way to do this is to construct tests for
    it as you write.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个代码构建工具，**不是**调试工具！适当的测试对于生产可靠、高质量的软件至关重要。这通常被忽视——也许是因为它被视为工作量过大，分散了人们对编写代码这一重要任务的注意力。这是对良好软件的最大威胁之一。除非你能证明代码正确运行，否则你无法构建可靠的代码。而唯一的方法是在编写代码的同时为它构建测试。
- en: There are tools that help automate unit testing, offering a skeleton into which
    you can place your test code. These tools can be easily integrated into your build
    system, so testing becomes a central part of the code construction process.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以帮助自动化单元测试，提供可以放置测试代码的框架。这些工具可以轻松集成到你的构建系统中，因此测试成为代码构建过程的核心部分。
- en: As well as automated unit testing, there are tools that generate test data and
    formulate test cases. There are also tools that simulate a target platform, perhaps
    with the ability to model particular error conditions (low memory, high load,
    etc.).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动单元测试之外，还有生成测试数据和制定测试用例的工具。还有模拟目标平台并可能具有模拟特定错误条件（如低内存、高负载等）能力的工具。
- en: Debugging and Investigative Tools
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试和调查工具
- en: These tools characterize running code and help to track down problems—both things
    we have seen going wrong and potential disasters waiting to pounce. We'll look
    at them in greater detail in "[Wasp Spray, Slug Repellent, Fly Paper . . .](ch09s07.html
    "Wasp Spray, Slug Repellent, Fly Paper . . .")" on page 169.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具描述运行中的代码并帮助追踪问题——包括我们已经看到出错的事情和即将发生的潜在灾难。我们将在第169页的"[Wasp Spray, Slug Repellent,
    Fly Paper . . .](ch09s07.html "Wasp Spray, Slug Repellent, Fly Paper . . .")"中更详细地探讨它们。
- en: Debugger
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试器
- en: Having a quality debugger and understanding how to use it can save you hours
    of development time chasing surprising behavior. It allows you to investigate
    paths of execution in your program, break into it, investigate variable values,
    set breakpoints, and generally dissect your running code. It's an order of magnitude
    more sophisticated than peppering programs with `printf` logging statements!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个高质量的调试器并理解如何使用它可以在追踪令人惊讶的行为上为你节省数小时的开发时间。它允许你调查程序中的执行路径，中断程序，调查变量值，设置断点，并通常剖析运行中的代码。这比在程序中散布`printf`日志语句要复杂一个数量级！
- en: '`gdb` is GNU''s open source debugger; it has been ported to almost every conceivable
    platform. `ddd` is an accomplished graphical interface for it. Every IDE and toolchain
    has its own debugger.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb`是GNU的开源调试器；它已被移植到几乎每个可想象的平台。`ddd`是它的一个成熟的图形界面。每个IDE和工具链都有自己的调试器。'
- en: Profiler
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能分析器
- en: This tool is used when your code runs unacceptably slowly. The profiler times
    sections of running code and identifies the bottlenecks. It is used to find targets
    for *sensible* optimization; armed with its results, you won't waste effort speeding
    up code that is rarely executed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码运行速度不令人满意时，使用此工具。性能分析器测量运行代码的各个部分并确定瓶颈。它用于找到*合理*优化的目标；有了它的结果，你不会浪费精力加速很少执行的代码。
- en: Code Validators
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码验证器
- en: 'Code validators come in two varieties: *static* and *dynamic*. The former digest
    code in a similar way to a compiler, inspecting your source files to identify
    possible problem areas and flawed language use. `lint` is a well-known example;
    it performs static checks for a series of common coding errors in C. Much of its
    functionality is built into modern compilers, but there are still separate tools
    available for extra checking.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代码验证器分为两种类型：*静态*和*动态*。前者以类似编译器的方式处理代码，检查你的源文件以识别可能的问题区域和语言使用上的缺陷。`lint`是一个著名的例子；它在C中执行一系列常见编码错误的静态检查。其大部分功能已集成到现代编译器中，但仍有一些独立的工具可用于额外的检查。
- en: 'Dynamic validators modify and instrument the code as it is compiled and then
    perform checking at run time. Memory allocation/bounds checkers are a good example—they
    ensure that all dynamically allocated memory is freed appropriately and that array
    accesses do not occur out of bounds.^([[6](#ftn.CHP-7-FN-6)]) These tools can
    save hours of legwork looking for obscure bugs. They are *much* more useful than
    a debugger in most situations, since they act like prevention mechanisms rather
    than cures: They''ll find faults before they have a chance to break your program.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 动态验证器在代码编译时对其进行修改和测量，然后在运行时执行检查。内存分配/边界检查器是一个很好的例子——它们确保所有动态分配的内存都得到适当的释放，并且数组访问不会超出范围。[^6](#ftn.CHP-7-FN-6)
    这些工具可以节省寻找难以捉摸的错误所需的大量时间。在大多数情况下，它们比调试器更有用，因为它们像预防机制而不是治疗手段：它们会在程序崩溃之前找到错误。
- en: Metrics Tools
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能工具
- en: These tools perform code inspection and are usually a form of static analyzer
    (although dynamic metric tools do exist). They produce statistical assessments
    of the quality of your code. While statistics can easily mislead, these tools
    can powerfully highlight the most brittle areas. This information can help you
    pick specific targets for code reviews.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具执行代码检查，通常是静态分析器的一种形式（尽管也存在动态度量工具）。它们对你的代码质量进行统计分析。虽然统计数据很容易误导，但这些工具可以有效地突出最脆弱的区域。这些信息可以帮助你选择代码审查的具体目标。
- en: Metrics are usually gathered on a per-function basis. The most basic metric
    is *number of lines of code*, followed by the ratio of *comments to code*. Neither
    really tell you anything particularly useful, but there are plenty of more interesting
    metrics. *Cyclomatic complexity* is a measure of the complexity of code, considering
    the number of decision points and potential flows of control. A high cyclomatic
    complexity implies unintelligible code, which is more likely to be brittle and
    harbor faults.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 指标通常按函数基础收集。最基本的指标是*代码行数*，其次是*注释与代码的比例*。这两者都不能真正告诉你什么特别有用的信息，但有许多更有趣的指标。*循环复杂度*是考虑决策点和潜在控制流数量的代码复杂度的度量。高循环复杂度意味着难以理解的代码，这更可能是不稳定且容易隐藏错误的。
- en: Disassembler
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反汇编器
- en: This peers into executables, allowing you to inspect the machine code. Debuggers
    do contain this kind of support, but advanced disassemblers can attempt to reconstruct
    code where no symbols exist, generating a high-level language reinterpretation
    of the binary program file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以深入到可执行文件中，让您检查机器代码。调试器确实包含这种支持，但高级反汇编器可以尝试在没有符号存在的地方重建代码，生成对二进制程序文件的高级语言重新解释。
- en: Fault Tracking
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障追踪
- en: A good fault-tracking system provides a shared database that keeps track of
    the bugs found in your system. It allows colleagues to report faults, query, assign,
    or comment on them, and eventually mark faults as fixed. It's an essential tool
    to ensure the quality of a product—you need to manage faults systematically, or
    they'll slip through your fingers, and you'll release a flawed product. Capturing
    and storing this information is also useful when looking back over the project
    history.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的故障追踪系统提供了一个共享数据库，用于跟踪系统中发现的错误。它允许同事报告故障、查询、分配或评论它们，并最终将故障标记为已修复。这是确保产品质量的必要工具——您需要系统地管理故障，否则它们会从您手中溜走，您会发布一个有缺陷的产品。在回顾项目历史时捕获和存储这些信息也是有用的。
- en: Language Support Tools
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言支持工具
- en: To write in a high-level language, you need a lot of support. The language implementation
    provides everything you need to make coding possible, making it easier than wallowing
    in a swamp of machine code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要用高级语言编写，您需要大量的支持。语言实现提供了使编码成为可能所需的一切，使其比在机器代码的沼泽中挣扎更容易。
- en: The Language
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言
- en: The language itself *is* a tool. Some languages provide facilities absent in
    others. These gaps may be filled by separate tools you can run over the program
    source. For example, C's much maligned preprocessor can be remarkably useful,
    and text-processing packages exist for other languages. Generic code facilities
    (like C++'s templates), and pre- and postcondition checking are other similarly
    useful language tools.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 语言本身*就是工具。一些语言提供了其他语言中不存在的功能。这些差距可以通过运行在程序源上的单独工具来填补。例如，C语言备受诟病的预处理器可以非常有用，其他语言也有文本处理包。通用的代码功能（如C++的模板）和前/后条件检查是其他类似有用的语言工具。
- en: It's valuable to have a selection of languages under your belt. Understand how
    they differ, what tasks they lend themselves to, and what their weak points are.
    Then you can select the best language for any given task.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一系列语言技能是非常有价值的。了解它们之间的差异，它们适合的任务以及它们的弱点。然后您可以选择任何给定任务的最佳语言。
- en: '**KEY CONCEPT**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Learn several languages; each will teach you different ways to approach problems.
    Consider them tools, and select the most appropriate language for each task*.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*学习几种语言；每种语言都会教会你不同的解决问题的方法。把它们当作工具，并为每个任务选择最合适的语言*。'
- en: Run Time and Interpreter
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时和解释器
- en: Most languages can't be used without the requisite run-time support. Interpreted
    languages rely on their interpreter (or *virtual machine*), but directly compiled
    languages still lean on their support libraries. These libraries are often intimately
    entwined with the language itself, so the two can't be separated.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言没有必要的运行时支持是无法使用的。解释型语言依赖于它们的解释器（或*虚拟机*），但直接编译的语言仍然依赖于它们的支持库。这些库通常与语言本身紧密相连，因此两者无法分离。
- en: Just as you can pick a different compiler, you may be able to select a different
    language run time, with different characteristics.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以选择不同的编译器一样，你可能能够选择具有不同特性的不同语言运行时。
- en: Java's JVM (*The Java Virtual Machine*) is a common language interpreter. The
    C++ standard library supports the language, providing the default handlers for
    some core language features. Similarly, the C# language rests upon the run-time
    support of the .NET environment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Java的JVM（*Java虚拟机*）是一种常见的语言解释器。C++标准库支持该语言，为一些核心语言特性提供默认处理程序。同样，C#语言依赖于.NET环境的运行时支持。
- en: Components and Libraries
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件和库
- en: Yes, these are tools too! Reusing software components and finding libraries
    that do what you need avoids reinventing the wheel. A good library can increase
    productivity as much as any other software tool.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这些也是工具！重用软件组件和寻找执行所需功能的库可以避免重新发明轮子。一个好的库可以提高生产力，就像任何其他软件工具一样。
- en: The scopes of these libraries vary—some are vast abstraction layers for an entire
    OS, while some do a very simple job, providing a humble *date* class. They look
    after their details and hide the complexity away so that you don't have to worry
    about it. You don't have to spend time writing, testing, and debugging your own
    versions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库的范围各不相同——有些是整个操作系统的庞大抽象层，而有些则只做非常简单的工作，提供一种谦逊的*日期*类。它们负责处理细节，隐藏复杂性，这样你就不必担心它。你不必花时间编写、测试和调试自己的版本。
- en: All languages these days come with some level of library support. The C++ STL
    is a wonderful example of a powerful extensible library. The Java language and
    .NET environment ship with more standard libraries than you can shake a stick
    at. Many, many third-party libraries exist, both commercial and free.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的所有语言都提供了一定程度的库支持。C++ STL是一个功能强大的可扩展库的绝佳例子。Java语言和.NET环境提供了比你能挥动的棍子还要多的标准库。许多第三方库存在，既有商业的也有免费的。
- en: Miscellaneous Tools
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项工具
- en: The story doesn't end here. You will come across plenty more tools. "[See Also](ch06s08.html
    "See Also")" on page 127 points out other places where we'll discuss software
    tools.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 故事还没有结束。你还会遇到更多工具。"见 Also"(ch06s08.html "See Also")在第127页指出，我们将在其他地方讨论软件工具。
- en: The following are some other interesting tool varieties.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他有趣的工具种类。
- en: Documentation Tools
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档工具
- en: Good documentation is invaluable; it's a key part of well-engineered code. Various
    tools help you to write it, both in the source code itself and separately (I describe
    some in "[Practical Self-Documentation Methodologies](ch04s03.html "Practical
    Self-Documentation Methodologies")" on page 66). Never underestimate how important
    a good word processor is.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的文档是无价的；它是精心设计的代码的关键部分。各种工具可以帮助你编写它，无论是在源代码本身还是在单独的文档中（我在第66页的"[实用自我文档方法](ch04s03.html
    "实用自我文档方法")"中描述了一些工具）。永远不要低估一个好的文字处理器的重要性。
- en: Documentation needs to be read as well as written. Good online help systems
    (backed up by a quality bookshelf) are critical.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 文档不仅需要阅读，还需要编写。良好的在线帮助系统（辅以高质量的书籍）至关重要。
- en: '**ROLLING YOUR OWN**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROLLING YOUR OWN**'
- en: What happens when you can't find a tool for a job and it'll take forever to
    do by hand? There's nothing wrong with "[ROLLING YOUR OWN](ch07s04.html#rolling_your_own
    "ROLLING YOUR OWN")" tools. Indeed, if this task is going to crop up repeatedly,
    a short tool development may save you hours in the long run.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你找不到适合工作的工具，而且手动完成将花费很长时间时，自己编写工具（"[ROLLING YOUR OWN](ch07s04.html#rolling_your_own
    "ROLLING YOUR OWN")"）并没有什么不妥。实际上，如果这项任务会反复出现，短期的工具开发可能会在长期内为你节省数小时。
- en: Some tasks are naturally more tool-able than others. Make sure you're attempting
    something realistic, and check that the effort will be a cost-effective investment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有些任务天生比其他任务更适合使用工具。确保你尝试的是现实可行的，并检查这种努力是否是成本效益的投资。
- en: 'These are the common ways to create a tool:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建工具的常见方法：
- en: Combine existing tools in a new ways, commonly using the Unix piping mechanism,
    perhaps writing a little connecting glue. You can put complex command-line incantations
    into a *shell script* (or *batch file* in Windows-land) so you don't have to type
    them in every time.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以新的方式组合现有工具，通常使用Unix管道机制，也许需要写一点连接胶水。你可以将复杂的命令行咒语放入*shell脚本*（或在Windows环境中是*批处理文件*），这样你就不必每次都输入它们。
- en: Use a *scripting language*. Most small homegrown tools are written in some form
    of scripting language, often Perl. They're quick and easy to work with, yet powerful
    enough to provide the kind of support you need to write tools.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*脚本语言*。大多数小型自建工具都是用某种形式的脚本语言编写的，通常是Perl。它们使用起来既快又简单，同时足够强大，可以提供编写工具所需的支撑。
- en: Create a full-blown program from scratch. You only really want to do this if
    it's a serious tool that you'll be using over and over again. Otherwise, the effort
    probably isn't justified.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始创建一个完整的程序。你只有在它是一个你将反复使用的严肃工具时才真正想这么做。否则，这种努力可能是不合理的。
- en: 'When writing the tool, consider:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写工具时考虑：
- en: The audience—how polished does the tool have to be? Are a few rough edges acceptable?
    If it's only you and one other techie using it, you can cope. If other, more delicate
    souls may one day need it, perhaps you should upholster it tastefully.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观众——工具需要多么精致？一些粗糙的边缘是否可以接受？如果只有你和另一个技术专家在使用它，你可以应对。如果其他更细腻的人可能有一天需要它，也许你应该优雅地给它加上装饰。
- en: Can you extend an existing tool (wrap its command up, or perhaps create a plugin
    for it)?
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否扩展现有的工具（将其命令包装起来，或者可能为它创建一个插件）？
- en: Project Management
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目管理
- en: Management and work collaboration tools allow you to report and track work against
    a schedule, manage faults, and monitor team performance. Depending on the scope
    of the management tool, humble programmers may not need to go near it. But more
    exotic systems may become the central hub of project activity, drawing in all
    users.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 管理和工作协作工具允许你根据时间表报告和跟踪工作，管理故障，并监控团队绩效。根据管理工具的范围，谦逊的程序员可能不需要接近它。但更异类的系统可能成为项目活动的中心枢纽，吸引所有用户。
- en: '* * *'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[5](#CHP-7-FN-5)]) A cryptic techie (and dull) way of saying *reasonably
    complex grammar*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-7-FN-5)]) 一种晦涩的技术专家（和无聊）的说法，指的是*相对复杂的语法*。
- en: ^([[6](#CHP-7-FN-6)]) More socially responsible languages, like Java, avoid
    this kind of problem in the language design.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-7-FN-6)]) 更具社会责任感的语言，如Java，在语言设计中避免了这类问题。
- en: In a Nutshell
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Give us the tools and we will finish the job.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们工具，我们将完成这项工作。
- en: --Sir Winston Churchill
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: --温斯顿·丘吉尔爵士
- en: Tools make software development possible. Good tools make it much easier.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 工具使软件开发成为可能。好的工具使它变得容易得多。
- en: Make a point of evaluating the set of tools you use. Do you really know how
    to use them all properly? Are there any missing tools you should have? Are you
    getting the most from the ones you do have?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要评估你使用的工具集。你真的知道如何正确使用它们吗？有没有你本应拥有的缺失工具？你是否从你所拥有的工具中获得了最大价值？
- en: A tool is only ever as good as its user. The proverb *A bad workman blames his
    tools* contains a lot of truth. Poor programmers create poor code, no matter how
    many tools they use. In fact, tools can help produce spectacularly worse code.
    Fostering a professional, responsible attitude toward your toolbox will make you
    a better programmer.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的价值永远取决于其用户。谚语“拙匠常怪工具不利”包含了很多真理。糟糕的程序员会编写糟糕的代码，无论他们使用多少工具。事实上，工具可以帮助产生极其糟糕的代码。培养对工具箱的专业、负责任的态度将使你成为一个更好的程序员。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 好程序员…… | 次程序员…… |'
- en: '| --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Would rather learn *once* how to use an appropriate tool, rather than repeat
    a tedious job over *and over and over* again
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更愿意学习一次如何使用合适的工具，而不是一次又一次地重复乏味的工作
- en: Understand different toolchain models and are comfortable with each
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同的工具链模型，并对每个都感到舒适
- en: Use tools to make their lives easier but don't become slaves to them
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具使他们的生活更轻松，但不要成为它们的奴隶
- en: See everything they use as a tool, a replaceable utility
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将他们使用的每件事都视为一个工具，一个可替换的实用工具
- en: Are productive, because the use of their tools is second nature
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们是高效的，因为使用他们的工具对他们来说就像第二本能一样
- en: '|'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Know how to use a few tools and look at every problem in terms of them
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用一些工具，并以它们为标准看待每个问题
- en: Are afraid of taking the time to learn new tools
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 害怕花时间去学习新工具
- en: Started using one development environment and now use it religiously, never
    trying out or even investigating alternatives
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用一个开发环境，现在虔诚地使用它，从未尝试过或调查过替代方案
- en: Don't add to their toolboxes when they come across a valuable new tool
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当他们遇到一个有价值的新工具时，不要将其添加到他们的工具箱中
- en: '|'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: '[Chapter 10](ch10.html "Chapter 10. THE CODE THAT JACK BUILT")'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。杰克建造的代码")'
- en: The software build process is driven by tools. Just imagine compiling code by
    hand!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 软件构建过程是由工具驱动的。想象一下手动编译代码！
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。宏伟设计")'
- en: Contains a section discussing specific *design tools*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个讨论特定**设计工具**的部分。
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章。实践安全源代码")'
- en: A chapter devoted to the use of *revision control tools*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一章专门讨论**版本控制工具**的使用。
- en: '![See Also](tagoreillycom20080909nostarchimages207462.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207462.png)'
- en: Get Thinking
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 491.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些问题的详细讨论可以在第491页的"[附录A](apa.html "附录A. 答案与讨论")"部分找到。
- en: Mull It Over
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: Is it more important for everyone in a development team to use the same IDE,
    or for each person to pick the one that suits him or her best? What are the implications
    of different people using different tools?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于开发团队中的每个人来说，使用相同的IDE是否更重要，还是每个人选择最适合他们的IDE更重要？不同的人使用不同的工具有什么影响？
- en: What is the minimum set of tools that any programmer should have at his or her
    disposal?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何程序员应该拥有的最小工具集是什么？
- en: 'Which are more powerful: command-line or GUI-based tools?'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行工具或基于GUI的工具哪个更强大？
- en: Are there construction tools that aren't programs?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有不是程序的构建工具？
- en: What's most important for a tool?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工具最重要的因素是什么？
- en: Interoperability
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 互操作性
- en: Flexibility
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 灵活性
- en: Customization
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定制化
- en: Power
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 权力
- en: Ease of use and learning
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 易用性和学习
- en: Getting Personal
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个性化
- en: What are the common tools in your toolbox? Which do you use every day? Which
    do you use a few times a week? Which do you only call on occasionally?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你工具箱中的常用工具是什么？你每天都用哪些？你每周用几次？你偶尔才用哪些？
- en: How well do you know how to use them?
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你对如何使用它们的了解程度如何？
- en: Are you getting the most from every tool?
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否从每个工具中获得了最大收益？
- en: How did you learn to use them? Did you ever spend any time improving your skill
    with them?
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是如何学会使用它们的？你是否花时间提高使用它们的技能？
- en: Are these the *best* tools you could be using?
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是你能使用的*最好*的工具吗？
- en: How up to date are your tools? Does it matter if they're not the latest cutting-edge
    versions?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的工具有多新？如果它们不是最新的尖端版本，这有关系吗？
- en: Do you favor an integrated tool set (like a visual development environment)
    or a discrete toolchain? What are the advantages of the *other* approach? How
    much experience do you have with *both* ways of working?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否更喜欢集成工具集（如可视化开发环境）还是离散的工具链？另一种方法的优点是什么？你对这两种工作方式有多少经验？
- en: Are you a *Default Dan* or a *Tweaker Tom*? Do you accept the default settings
    in your editor, or do you customize them to within an inch of their lives? Which
    is the "better" approach?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是“默认丹”还是“调整汤姆”？你接受编辑器的默认设置，还是将其调整到极致？哪种方法是“更好”的？
- en: How do you determine your budget for software tools? How do you know whether
    a tool is worth its cost?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是如何确定软件工具的预算的？你如何知道一个工具是否物有所值？
- en: Chapter 8. TESTING TIMES
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 测试时代
- en: '*The Black Art of Testing Code*'
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*测试代码的黑色艺术*'
- en: Test everything. Keep what is good.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一切。保留好的。
- en: --1 Thessalonians 5:21
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: --帖撒罗尼迦前书5:21
- en: 'Write as much code as you like—there''s one thing you can be sure of: It won''t
    work perfectly the first time. It doesn''t matter how long you took to carefully
    design it; software faults have a creepy ability to work their way into any program.
    The more code you write, the more faults you''ll introduce. The faster you write,
    the more you''ll introduce. I''ve yet to meet a really prolific programmer who
    created anything near bug-free code.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 随意编写尽可能多的代码——你可以确信的一件事是：它第一次肯定不会完美工作。无论你花了多少时间精心设计它；软件错误有一种令人毛骨悚然的能力，能够渗透到任何程序中。你编写的代码越多，引入的错误就越多。你写得越快，引入的错误就越多。我还没有遇到一个真正多产的程序员能够创造出几乎无错误的代码。
- en: What do we do about this? We *test* our code. We do this to find any problems
    that exist, and once we've fixed them, we use the tests to maintain confidence
    in the quality of the code as we continue to modify it. It's suicide to release
    untested software, no matter how good a programmer you think you are. Untested
    software is *bound* to fail; testing is an essential part of our craft. Too many
    software factories underestimate the importance of thorough testing or try to
    squeeze it into a last-minute dash before the software ships. It shows.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？我们*测试*我们的代码。我们这样做是为了找出任何存在的问题，一旦我们修复了它们，我们就使用测试来保持对代码质量的信心，因为我们继续对其进行修改。无论你认为你是一个多么好的程序员，发布未经测试的软件都是自杀。未经测试的软件*注定*会失败；测试是我们工艺的一个基本部分。太多的软件工厂低估了彻底测试的重要性，或者试图在软件发货前的最后一刻将其压缩进去。这是显而易见的。
- en: Testing is not something relegated to the end of the development process, used
    to prove that your final program is okay. If that's all you ever try to do, you'll
    produce very poor code, indeed. Testing is a central construction technique. It's
    only by testing that you can prove that each bit of code works, which then tells
    you when you've finished it. How could you tell, otherwise? How do so many software
    factories think they can get away without decent testing?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不是开发过程末尾的一项任务，用于证明你的最终程序是好的。如果你只是试图做这件事，你将产生非常糟糕的代码。测试是一种核心构建技术。只有通过测试，你才能证明每一块代码都能正常工作，这然后告诉你何时完成。否则你怎么能知道呢？为什么这么多软件工厂认为他们可以不进行适当的测试就逃脱呢？
- en: '**TERMS AND CONDITIONS**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**条款和条件**'
- en: 'The term *bug* is remarkably evocative and incredibly imprecise. It''s easy
    to throw words around without really understanding what they mean. Using more
    specific terminology helps us to define what we''re doing. These definitions are
    inspired by IEEE literature (IEEE 84):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *bug* 非常具有表现力，但非常不精确。很容易随意使用词汇而不真正理解它们的含义。使用更具体的术语有助于我们定义我们在做什么。这些定义受到了IEEE文献（IEEE
    84）的启发：
- en: '**Error**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误**'
- en: 'An *error* is something that *you* do wrong. It is a specific human action
    that results in software containing a *fault*. For example: Forgetting to check
    a condition in your code (like the size of a C array before indexing into it)
    is an error.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *错误* 是你做错的事情。它是一种特定的人类行为，导致软件中包含 *故障*。例如：忘记检查你的代码中的条件（比如在索引C数组之前检查数组的大小）是一个错误。
- en: '**Fault**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障**'
- en: A *fault* is the consequence of an error, embodied in the software. I made an
    error, and this resulted in a fault in the code. At first, this is a *latent*
    problem. If the code I've just written is never executed, then this fault will
    never have a chance to cause problems. If execution often passes through the faulty
    code, but never in the particular way that triggers the fault, we'll never notice
    that there is a fault at all.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *故障* 是一个错误的后果，体现在软件中。我犯了一个错误，这导致了代码中的故障。起初，这是一个 *潜在* 的问题。如果我所写的代码从未被执行，那么这个故障将永远不会有机会引起问题。如果执行经常通过有缺陷的代码，但从未以触发故障的特定方式执行，我们就永远不会注意到有故障。
- en: This subtle point is what makes debugging notoriously difficult. A faulty line
    of code may seem fine for years, and then one day it causes the most bizarre system
    tantrum you've ever seen; you won't suspect the aged code since it's been reliable
    for so long.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微妙之处使得调试变得极其困难。一条有缺陷的代码行可能看起来在多年内都很正常，然后有一天它会导致你见过的最奇怪的系统崩溃；你不会怀疑这个老代码，因为它已经可靠了这么久。
- en: You might discover a fault in a code review, but you can't identify a fault
    from a running program.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在代码审查中会发现一个故障，但你不能从运行中的程序中识别出一个故障。
- en: '**Failure**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障**'
- en: When encountered, a fault may cause a *failure*. It may not. The failure, the
    manifestation of the fault, is what we really care about. It's probably the only
    thing we'll take notice of. A failure is the departure of your program's operation
    from its requirements, from its expected behavior. This is where we verge on philosophy.
    If a tree falls over in a forest, does it make a sound? If the running program
    doesn't exercise a bug, is the mistake still a fault? These definitions help to
    answer this.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到时，一个故障可能会导致 *故障*。它可能不会。故障，故障的表现，是我们真正关心的。这可能是我们唯一会注意到的事情。故障是程序操作与其要求、预期行为之间的偏离。这就是我们接近哲学的地方。如果一棵树在森林中倒下，它会发出声音吗？如果运行中的程序没有执行bug，错误仍然是故障吗？这些定义有助于回答这些问题。
- en: '**Bug**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**bug**'
- en: The term *bug* is a colloquialism, often used as a synonym for fault. According
    to folklore, the first computer bug was an *actual* bug. It was discovered by
    Admiral Grace Hopper in 1947 at Harvard. A moth trapped between two electrical
    relays of the Mark II Aiken Relay Calculator caused the whole machine to shut
    down.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *bug* 是一种口语，通常用作 *故障* 的同义词。根据传说，第一个计算机 *bug* 是一个 *实际* 的虫子。它是由海军上将Grace Hopper在1947年于哈佛发现的。一只被困在Mark
    II Aiken Relay Calculator的两个电继电器之间的蛾导致整个机器关闭。
- en: Reality Check
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实检查
- en: The two simple questions *What is testing?* and *Why do you test?* seem painfully
    obvious. Yet all too often, adequate software testing is not performed—or it is
    not performed at the appropriate stage of production. Good testing is a skill.
    Actually *doing* some testing is more than many programmers achieve; the mere
    mention of testing is enough to make most of them break out in a cold sweat. "The
    single most important rule of testing is to do it." (Kernighan Pike 99)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 两个简单的问题*什么是测试？*和*你为什么要测试？*看起来很明显。然而，往往在生产的适当阶段没有进行足够的软件测试，或者没有进行测试。良好的测试是一种技能。实际上*进行*一些测试比许多程序员所达到的要多；仅仅提到测试就足以让大多数程序员大汗淋漓。“测试最重要的规则是去做。”（Kernighan
    Pike 99）
- en: Testing is a distinct and separate activity from debugging, although their boundaries
    blur, and the two often get mixed up together. *Testing* is a methodical process
    of proving the existence, or lack thereof, of faults in your software. *Debugging*
    is the act of tracking down the cause of this faulty behavior. Testing leads to
    debugging, which leads to repair, which leads to more testing (we test again to
    prove that the fix worked).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与调试是两个不同的独立活动，尽管它们的界限模糊，两者经常被混淆在一起。*测试*是证明软件中存在或不存在错误的方法论过程。*调试*是追踪这种错误行为原因的行为。测试导致调试，调试导致修复，修复导致更多测试（我们再次测试以证明修复有效）。
- en: '**KEY CONCEPT**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Testing is not debugging. Don''t get the two confused. They require different
    skills. Make sure you know when you''re testing and when you''re debugging*.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试不是调试。不要混淆这两个概念。它们需要不同的技能。确保你知道你在测试和调试的时候*。'
- en: If you're programming well, you'll do a *lot* more testing than debugging. That's
    why this chapter comes before the debugging chapter.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编程得好，你将进行*大量*的测试而不是调试。这就是为什么这一章在调试章节之前的原因。
- en: 'Throughout the software development process, various things are tested:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个软件开发过程中，各种事物都会被测试：
- en: A large number of *documents* will go through a testing stage (more commonly
    known as a *review* process). Doing this ensures, for example, that the requirements
    specification correctly models the customer's needs, the functional specification
    implements the requirements specification, the various subsystem specifications
    are complete enough to fulfill the functional specification, and so on.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量的*文档*将经过一个测试阶段（更常见的是称为*审查*过程）。这样做可以确保，例如，需求规范正确地模拟了客户的需求，功能规范实现了需求规范，各种子系统规范足够完整以实现功能规范，等等。
- en: Naturally, then, the implementation *code* is tested on the developer's machine.
    It is tested at several levels, ranging from line-by-line testing of each function
    as it's written, to the testing of individual modules, to integration tests when
    sections of code are glued together.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然地，实现*代码*在开发者的机器上被测试。它被测试在几个层面上，从逐行测试每个函数的编写，到测试单个模块，到集成测试，当代码部分被粘合在一起时。
- en: Finally, the end *product* is tested. While this level of testing will (or *should*)
    indirectly test all the code components that have been developed, that is not
    the focus of these tests. Here we worry about whether or not the program, as a
    whole, is working as specified.^([[1](#ftn.CHP-8-FN-1)])
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最终*产品*将被测试。虽然这一级别的测试将（或*应该*）间接测试所有已开发的代码组件，但这不是这些测试的重点。在这里，我们关心的是程序作为一个整体是否按指定的工作。
- en: Product tests may be concerned with a number of things. Most importantly, they
    check that the system functions as intended. They also check that it installs
    correctly (if it's shrink-wrapped PC software) and that it's usable.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 产品测试可能涉及许多事情。最重要的是，它们检查系统是否按预期工作。它们还检查它是否正确安装（如果它是包装好的PC软件）以及它是否可用。
- en: This is the kind of testing performed by the QA department. It is this department's
    job to understand how the product should work and to ensure that it does, while
    also meeting any quality criteria that have been established for it.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是QA部门执行的那种测试。这个部门的任务是理解产品应该如何工作，并确保它确实如此，同时满足为其设定的任何质量标准。
- en: In this chapter, we'll focus on the middle point—how we test our code as software
    developers. The other testing activities are large and separate topics, which
    are outside the scope of this book.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注中间点——作为软件开发者，我们如何测试我们的代码。其他测试活动是大型且独立的主题，超出了本书的范围。
- en: '**QUALITY ASSURANCE**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量保证**'
- en: 'QA: *quality assurance*. Sounds painful, doesn''t it? But just *who* or *what*
    is it? This name is given both to a tribe of software factory inhabitants and
    a development practice. To understand QA properly, it''s important to separate
    colloquialisms and misconceptions from the real definiton.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: QA：*质量保证*。听起来很痛苦，不是吗？但*谁*或*什么*是它？这个名字既给了一群软件工厂居民，也给了开发实践。为了正确理解QA，重要的是将俚语和误解与真实定义分开。
- en: People mistakenly bundle QA with *testing*, but the two differ significantly.
    Testing aims to detect erroneous behavior, where software diverges from its specification;
    it is effectively *detection*. Real QA is *prevention*. It ensures that our processes
    and development practices will result in high-quality software. Testing is a small
    part of QA—software quality includes more than just a low bug count. It means
    software that is delivered on time, to budget, and meeting all requirements and
    expectations (these two are not necessarily the same). Sadly, there still isn't
    a lot of high-quality software coming out of today's software factories.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 人们错误地将QA与*测试*捆绑在一起，但两者有显著区别。测试旨在检测错误行为，即软件与其规范不符；它实际上是*检测*。真正的QA是*预防*。它确保我们的流程和开发实践将产生高质量的软件。测试只是QA的一部分——软件质量不仅包括低错误率。这意味着软件按时、按预算交付，并满足所有要求和期望（这两个不一定相同）。遗憾的是，今天软件工厂中仍然没有很多高质量的软件。
- en: Who's responsible for software quality? An organization's test department (often
    known as the QA department) is the group of people dedicated to *product* testing.
    They have the final say as to whether your program is good enough to release.
    This is an important piece of the quality jigsaw, but not the whole picture. Everyone
    in the development process is involved in producing quality software—it's not
    something you can tack on once the code is complete.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 谁负责软件质量？一个组织的测试部门（通常称为QA部门）是一群致力于*产品*测试的人。他们有权决定你的程序是否足够好以发布。这是质量拼图中的重要一块，但不是全部。开发过程中的每个人都参与生产高质量的软件——这不是代码完成后可以附加的东西。
- en: The responsibility for monitoring software quality often rests with the same
    group of people performing product testing. Otherwise, overall QA is the responsibility
    of project managers, while the testers are left to test.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 监控软件质量的职责通常落在执行产品测试的同一组人身上。否则，整体质量保证（QA）是项目经理的责任，而测试人员则负责进行测试。
- en: '* * *'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-8-FN-1)]) Because, obviously, the correct behavior has been carefully
    specified beforehand, hasn't it?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-8-FN-1)]) 因为，显然，正确的行为已经事先仔细指定了，对吧？
- en: Who, What, When, and Why?
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁，什么，何时，为什么？
- en: For our software testing to be effective, we need to understand *why* we test,
    *who* does it, *what* it entails, and *when* it is done.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的软件测试有效，我们需要了解*为什么*我们要测试，*谁*来进行测试，*测试内容是什么*，以及*何时进行测试*。
- en: Why We Test
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么进行测试
- en: 'As software developers, our testing procedure exists for a few reasons: to
    help us to find faults and fix them, and to ensure the same faults don''t reappear
    in later versions.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发人员，我们的测试程序存在几个原因：帮助我们找到错误并修复它们，并确保相同的错误不会在后续版本中再次出现。
- en: Note that testing can never reveal the absence of faults, only their existence.
    If your tests don't find any bugs, it doesn't necessarily mean they aren't there;
    it just means you haven't found them yet.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试永远不会揭示错误的缺失，只会揭示其存在。如果你的测试没有发现任何错误，这并不意味着它们不存在；只是意味着你还没有找到它们。
- en: '**KEY CONCEPT**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Testing can only discover the* presence *of faults. It can''t prove the* absence
    *of faults. Don''t be led into a false sense of security by code that passes a
    suite of inadequate tests*.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试只能发现错误的*存在。它不能证明错误的*不存在*。不要被通过一系列不充分的测试的代码所误导，从而产生错误的安全感。'
- en: Software testing at the end of a development cycle may have another motivation.
    As well as *verifying* that a software component is correct and contains no faults,
    you may need to *validate* it—ensure that it fulfills the requirements originally
    established—to prove that it is good enough for release. Validation is one form
    of an acceptance test.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 开发周期末的软件测试可能还有另一个动机。除了*验证*软件组件是正确的且不包含错误之外，你可能还需要*验证*它——确保它满足最初设定的要求——以证明它足够好以发布。验证是验收测试的一种形式。
- en: Who Tests
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁进行测试
- en: It is a *programmer's* responsibility to test the source code he or she writes.
    Tattoo that sentence backward across your forehead and stare in the mirror for
    10 minutes every morning.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Too many developers, disillusioned by the trials of the software factory, crank
    out code and release it thoughtlessly to QA without having tested it themselves.
    This is irresponsible and unprofessional. In the long run, it'll cost you *more*
    time and effort than testing properly. It's plain stupid to release untested code
    in a product and almost as bad to supply untested code to the QA department. Its
    job *is* testing, but testing the product, not your new lines of code. It is likely
    to find the silly coding errors that you left behind, probably manifesting themselves
    in obscure and seemingly unrelated ways; but its job is to look for more fundamental
    errors that couldn't have been caught any earlier, not mop up after sloppy programmers.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '*You must test every piece of code you write. Don''t expect anyone else to
    do it for you*.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: What Testing Involves
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing software, we create individual functions, data structures, and
    classes and glue them together into a working system. Our main testing strategy
    is to exercise all this code and validate its behavior by writing more code—*test
    code*. This forms a harness around the test subject that prods, pokes, and drives
    it, provoking it to respond and checking that its response is correct.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'We write test code for each level of the system, testing each important class
    and function, through to the superstructures composed of these smaller parts.
    For each test, you must be clear about the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Exactly which piece of code you're testing. Clear modules with well-defined
    boundaries help here; the interfaces are your test points. Vague or complex interfaces
    make testing vague and complex.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method you're using to test (see "[The Types of Test](ch08s04.html "The
    Types of Test")" on page 138).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you will be finished. This is one of the hardest and most important questions
    to answer—you could go on forever. When can you say that you've run enough test
    cases?
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another common testing strategy is to *inspect* the code in order to prove its
    correctness. Inasmuch as this is a human activity, it is prone to failure, and
    it also relies upon the requirements being well defined. *Code reviews* are a
    common inspection technique (see [Chapter 20](ch20.html "Chapter 20. A REVIEW
    TO A KILL")). Code inspection tools help, but they cannot magically perform all
    the tests for you. Too often, inspection is ad hoc and haphazard; it's so very
    easy to overlook faults. Prefer to use programmatic tests; they bring many benefits,
    which we'll see throughout this chapter. A combination of the two is most effective.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: When We Test
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test your code *as it's written*, catching coding errors at the earliest possible
    opportunity. It's at this time when errors are easiest to fix, affect fewest people,
    and cause the least havoc. Testing early and thoroughly is the most effective
    way to ensure software quality.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码编写过程中测试你的代码，尽早捕捉到编码错误。这时错误最容易修复，影响的人最少，造成的混乱也最小。尽早和彻底地测试是最有效的确保软件质量的方法。
- en: The cost of a bug escalates as it works through the development process,^([[2](#ftn.CHP-8-FN-2)])
    so it's essential to start testing code as soon as possible—during (or perhaps
    before) serious software development. The *test-driven development* approach,
    popularized by agile programmers, advocates testing as a central construction
    technique; you write test code *before* the code being tested!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的成本随着它在开发过程中的工作而增加，^([[2](#ftn.CHP-8-FN-2)]) 因此，尽早开始测试代码至关重要——在（或可能在）严肃的软件开发期间。敏捷程序员普及的*测试驱动开发*方法主张将测试作为核心构建技术；你在编写被测试的代码之前编写测试代码！
- en: '**KEY CONCEPT**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Effective code testing starts early, so you catch bugs when they''re least
    harmful. You* can *write tests before writing code!*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*有效的代码测试应尽早开始，这样你就可以在错误最无害时捕捉到它们。你可以在编写代码之前*编写测试！*'
- en: 'This is an essential point, and it is vitally important to absorb into your
    programming routine. For each piece of code you write, *immediately* write a test.
    Or write the test first. Prove that your code works, so you know that it''s safe
    to move on. If you don''t write a test at this point, you''ll leave unproven,
    potentially buggy code behind. This destroys the stability of your codebase: When
    you hit a bug, you won''t know which bit of code (in the mass you''ve accumulated
    since you last wrote a test) is causing the problem. So you end up in the debugger,
    which is a massive waste of time.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键点，并且将这一点吸收到你的编程习惯中至关重要。对于你写的每一行代码，*立即*编写一个测试。或者先编写测试。证明你的代码是可行的，这样你就知道可以安全地继续前进。如果你在这个时候不编写测试，你将留下未经证明、可能存在错误的代码。这会破坏你的代码库的稳定性：当你遇到错误时，你不知道是哪一段代码（自从你上次编写测试以来积累的大量代码）导致了问题。所以你最终会陷入调试器，这是巨大的时间浪费。
- en: Writing the test later means you will test from a distance—either too late,
    when you've forgotten what the code is supposed to do, or as a consequence of
    testing a separate code module. This will not be an effective test. You're also
    far more likely to forget to write the test at all.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 事后编写测试意味着你将从一个距离测试——要么太晚，当你已经忘记了代码应该做什么，要么作为测试一个单独代码模块的结果。这不会是一个有效的测试。你也更有可能忘记编写测试。
- en: 'This testing strategy has profound implications: When you start to think about
    writing some code, you must simultaneously think about testing it. This will shape
    the way you design that code, for the better; we''ll see why in "[Design for Test](ch08s06.html
    "Design for Test")" on page 144.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试策略有深远的影响：当你开始思考编写一些代码时，你必须同时考虑测试它。这将塑造你设计代码的方式，使其变得更好；我们将在第144页的"[为测试而设计](ch08s06.html
    "为测试而设计")"中看到原因。
- en: Every time you find a fault that managed to slip past your existing tests, you
    must add a new test to your test suite (after scolding yourself for missing it
    in the first place). The new test will help to prove that your bug fix is correct.
    It will also catch any later reappearance of the same bug; bugs can rise unexpectedly
    from the dead—this often happens when your code is modified later.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现一个成功绕过现有测试的错误时，你必须在你测试套件中添加一个新的测试（在责备自己最初没有注意到它之后）。新的测试将有助于证明你的错误修复是正确的。它还将捕捉到任何后来再次出现的相同错误；错误可能会意外地复活——这通常发生在你的代码后来被修改时。
- en: '**KEY CONCEPT**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Write a test for every fault you find*.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*为每个发现的错误编写一个测试*。'
- en: So we write tests as early as possible, but how often do we run them? As often
    as humanly possible, if not more often (using computer support). The more often
    we run the tests, the more likely we are to detect problems. This is embodied
    in a *continuous integration* strategy (see "[Automated Builds](ch10s05.html#automated_builds
    "Automated Builds")" on page 190), and begins to show why programatic tests (which
    are easy to run repeatedly) are so powerful.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们尽早编写测试，但我们多久运行一次？尽可能频繁地运行，如果不是更频繁的话（使用计算机支持）。我们运行测试的次数越多，我们检测到问题的可能性就越大。这体现在一种*持续集成*策略中（参见第190页的"[自动构建](ch10s05.html#automated_builds
    "自动构建")"），并开始展示为什么程序性测试（易于重复运行）如此强大。
- en: '**KEY CONCEPT**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Run your tests as often as you can*.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能频繁地运行你的测试*。'
- en: '* * *'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-8-FN-2)]) See "[THE ECONOMICS OF FAILURE](ch09s02.html#the_economics_of_failure
    "THE ECONOMICS OF FAILURE")" on page 157 for more on the cost of bugs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-8-FN-2)]) 更多关于错误成本的信息，请参阅第157页的 "[失败的经济学](ch09s02.html#the_economics_of_failure
    "失败的经济学")"。
- en: Testing Isn't Hard . . .
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并不难……
- en: 'Unless you do it badly, and then it''s *really* hard. It does take thoughtful
    effort, though. To test whether a particular piece of code works, you need a test
    harness that demonstrates that:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你做得不好，否则这真的很困难。但这确实需要深思熟虑的努力。为了测试特定代码片段是否工作，你需要一个测试框架来演示：
- en: The correct output is generated for all valid inputs.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有有效的输入，都生成了正确的输出。
- en: The appropriate failure behavior is generated for all invalid inputs.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有无效输入，都生成了适当的失败行为。
- en: That sounds innocuous enough, yet for all but the simplest of functions, it
    is just not practical to exhaustively perform this testing. The set of valid inputs
    is usually very large, and it's impossible to test each input individually. You'll
    have to pick a smaller set of representative input values. The set of invalid
    inputs is almost always *much* larger than the set of valid inputs, so you have
    to pick a number of representative bad values, as well.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能并不严重，但对于除了最简单的函数之外的所有函数，全面进行这种测试实际上是不切实际的。有效的输入集通常非常大，不可能单独测试每个输入。您必须选择一组较小的代表性输入值。无效输入集几乎总是比有效输入集大得多，因此您必须选择一些代表性的错误值。
- en: 'To illustrate this, here are two examples. This first function is easy to test:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，这里有两个例子。第一个函数很容易测试：
- en: '[PRE0]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The set of valid inputs is of size two, and there are no invalid inputs. This
    means that the function''s test harness is simple. It might look like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有效输入集的大小为两个，没有无效输入。这意味着函数的测试框架很简单。它可能看起来像这样：
- en: '[PRE1]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The function doesn't do anything particularly exciting, though. Now consider
    the following function (let's not critique its elegance at the moment). How much
    harder is it to test?
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 函数并没有做什么特别令人兴奋的事情。现在考虑以下函数（让我们暂时不要评论它的优雅）。测试它有多难？
- en: '[PRE2]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s still a small snippet of code, but testing it is far more difficult for
    these reasons:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一小段代码，但由于以下原因，测试它要困难得多：
- en: Although there are only two parameters, the set of valid input is extremely
    large. You can't conceivably test every possible combination of values; it would
    take a *very* long time.^([[3](#ftn.CHP-8-FN-3)]) Adding more parameters to a
    function extends this problem exponentially.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管只有两个参数，但有效的输入集非常大。你不可能测试所有可能值的组合；这将花费很长时间.^([[3](#ftn.CHP-8-FN-3)]) 向函数添加更多参数会使这个问题呈指数级增长。
- en: It contains a loop. Any form of branch (including a `for` loop) adds complexity
    and more potential for failure.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个循环。任何形式的分支（包括`for`循环）都会增加复杂性和更多潜在的错误。
- en: There are several conditional statements. You now have to arrange to exercise
    the code running through each combination of conditions to check that each side
    works.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个条件语句。现在你必须安排运行代码，以检查每个条件组合的每一侧是否工作。
- en: And that's just for a single small function. There's *already* a fault in there,
    did you notice it? Can you find it? Ten points and a gold star if you can.^([[4](#ftn.CHP-8-FN-4)])
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个单一的小函数。你注意到那里的错误了吗？你能找到它吗？如果你能找到，就有10分和一颗金牌.^([[4](#ftn.CHP-8-FN-4)])
- en: '**KEY CONCEPT**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*It''s very easy to trust the code you read and to believe that it''s correct.
    When you''ve just written some code, you''ll read what you* intended *to write,
    not what you actually wrote. Learn to look twice—read* all *code cynically*.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*很容易相信你读到的代码，并相信它是正确的。当你刚刚编写了一些代码时，你会读你所*打算*写的，而不是你实际写的。学会多看一眼——带着怀疑的眼光读*所有*代码*。'
- en: Those three problems aren't the only reasons software gets harder to test. There
    are plenty of other ways to increase test complexity.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个问题并不是软件测试变得困难的唯一原因。还有许多其他方法可以增加测试的复杂性。
- en: '**Code size**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码大小**'
- en: The more code there is, the more room for potential faults, and the more individual
    paths of execution that must be traced through to check validity.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 代码越多，潜在的错误空间就越大，必须追踪的执行路径就越多，以检查其有效性。
- en: '**Dependencies**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖关系**'
- en: Testing one small piece of code should be easy. But if the test harness has
    to attach the rest of the codebase before it will do anything, then it becomes
    too painful (and too time consuming) to write any tests. In this case, either
    testing doesn't happen, or the tests aren't comprehensive enough, since it's too
    hard to orchestrate all of the attached code components. This is an example of
    *untestable design*. We'll look at remedies for this later (in "[Design for Test](ch08s06.html
    "Design for Test")" on page 143).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一小段代码应该是容易的。但如果测试工具在执行任何操作之前必须附加其余的代码库，那么编写任何测试都变得非常痛苦（并且耗时），因为很难协调所有附加的代码组件。这是一个**不可测试的设计**的例子。我们将在稍后（在“[为测试而设计](ch08s06.html
    "为测试而设计")”第143页）探讨解决方法。
- en: The next two sections are also examples of kinds of inter-code dependency.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个部分也是代码之间依赖关系的例子。
- en: '**External inputs**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部输入**'
- en: Any reliance on the state of an external part of the system is essentially another
    input. Unlike function parameters, it's not easy to arrange for these external
    inputs to take on certain test values. A shared global variable can't be set to
    an arbitrary value without compromising other parts of the running program.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对外部系统状态的依赖本质上都是另一个输入。与函数参数不同，很难安排这些外部输入采取某些测试值。共享的全局变量不能随意设置值，否则会损害运行程序的其他部分。
- en: '**External stimuli**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部刺激**'
- en: The code may react to stimuli other than function calls. It's particularly troublesome
    when they may occur asynchronously (at any time), and with any frequency.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能会对除了函数调用之外的其他刺激做出反应。当它们可能异步（在任何时间）发生，并且以任何频率发生时，这尤其麻烦。
- en: A class can act on callbacks from other parts of the system, which may crop
    up at any time.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以响应来自系统其他部分的回调，这些回调可能随时出现。
- en: Hardware interface code reacts to changes in physical device state.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件接口代码对物理设备状态的变化做出反应。
- en: Communication with other systems may take any length of time. Physical connections
    are prone to interference, so they may degrade, and network connections can be
    unreliable.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他系统的通信可能需要任何长度的时间。物理连接容易受到干扰，因此它们可能会退化，网络连接也可能不可靠。
- en: User interface code is driven by the user's mouse gestures. It's hard to physically
    automate a GUI in test conditions.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面代码由用户的鼠标手势驱动。在测试条件下，很难在物理上自动化GUI。
- en: These conditions are hard to simulate in an artificial test environment, and
    they may be particularly timing sensitive (for example, the speed of mouse double
    clicks or the frequency of hardware-generated interrupts).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件在人工测试环境中很难模拟，并且它们可能对时间非常敏感（例如，鼠标双击的速度或硬件生成的中断频率）。
- en: 'Some outside influences are unplanned: memory may run low, disk space may become
    exhausted, and network connections may fail. You have to ensure that your code
    is robust in *all* prevailing environmental conditions.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一些外部影响是未计划的：内存可能不足，磁盘空间可能耗尽，网络连接可能失败。你必须确保你的代码在所有**现有**的环境条件下都是健壮的。
- en: '**Threads**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**'
- en: Multiple threads of control make testing more complex, since the concurrent
    code may intertwine in any arbitrary sequence. The complex interplay of execution
    paths means that any given test run may never be repeatable. Thread faults leading
    to deadlock or starvation may be hard to trigger, but they cause serious problems
    when they do crop up.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 多个控制线程使得测试更加复杂，因为并发代码可能以任何任意的顺序交织在一起。执行路径的复杂交互意味着任何给定的测试运行可能永远无法重复。导致死锁或饥饿的线程故障可能难以触发，但一旦出现，它们会引发严重问题。
- en: The program's threaded behavior will be different on truly parallel multiprocessor
    systems to the behavior exhibited under simulated concurrency on single-processor
    time-slicing environments.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的线程行为在真正的并行多处理器系统上与在单处理器时间切片环境下的模拟并发行为不同。
- en: '**Evolution**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**进化**'
- en: Software evolves. This evolution tends to break tests. If the requirements are
    not pinned down, your early tests will probably be invalid by the time you come
    to deliver because the APIs will have changed, the functionality will be completely
    different, and a full set of tests will not have been created because development
    never stood still long enough.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 软件会进化。这种进化往往会导致测试失败。如果需求没有确定下来，你的早期测试在你交付时可能已经无效，因为API已经改变，功能完全不同，而且由于开发从未长时间停止，因此可能没有创建完整的测试套件。
- en: We require stable interfaces both in our own code and any external code we rely
    on. In the Real World, this is an impractical ideal—the code will never stand
    still—so we must craft small, malleable tests that can be easily modified alongside
    the code.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们自己的代码和任何我们依赖的外部代码中都有稳定的接口。在现实世界中，这是一个不切实际的理想——代码永远不会静止——因此我们必须编写小型、可塑的测试，这些测试可以很容易地与代码一起修改。
- en: '**Hardware faults**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件故障**'
- en: Faults exist in hardware as well as in software. Work in an embedded environment
    is generally more likely to run into hardware errors, because you're closer to
    the metal. Hardware faults can be an order of magnitude more difficult to diagnose
    and fix; they are seldom repeatable, and you'll naturally distrust your software
    first.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 故障存在于硬件和软件中。在嵌入式环境中工作通常更容易遇到硬件错误，因为你更接近底层。硬件故障可能比诊断和修复它们困难一个数量级；它们很少可重复，你自然会首先怀疑你的软件。
- en: '**Nasty failure modes**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕的故障模式**'
- en: 'Code can fall over in a multitude of exciting and bizarre ways. Program faults
    don''t just lead to *incorrect output*—there''s more to contend with: infinite
    loops, deadlock, starvation, program crashes, OS lock-ups, and other potential
    failures raise their ugly heads to make testing a varied and exciting thing. A
    pathological software failure may even lead to physical damage to hardware!^([[5](#ftn.CHP-8-FN-5)])
    Write a test harness to check for *that*.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能会以多种令人兴奋和奇特的方式崩溃。程序故障不仅会导致*不正确的输出*——还有更多需要应对的问题：无限循环、死锁、饥饿、程序崩溃、操作系统锁定，以及其他潜在故障会露出它们丑陋的脑袋，使测试变得多样化和令人兴奋。病态的软件故障甚至可能导致硬件损坏！^([[5](#ftn.CHP-8-FN-5)])
    编写一个测试框架来检查*那个*。
- en: Writing a test harness is no small feat. When components get glued together
    and start relying on each other, the complexity of software expands exponentially.
    All of these problems gang up to make your life very complicated. This is when
    it becomes not just difficult, but technically infeasible to write harnesses that
    test the software *exhaustively*. The time and resources do not exist to generate
    all the test data necessary, and to run the software over all sets of inputs and
    stimuli. The brute-force method rapidly becomes impractical, and it seems more
    convenient to ignore testing and just hope that there aren't any bugs.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试框架不是一件小事。当组件粘合在一起并开始相互依赖时，软件的复杂性会呈指数级增长。所有这些问题都会使你的生活变得非常复杂。这时，不仅困难，而且在技术上不可能编写出能够全面测试软件的框架。没有足够的时间和资源来生成所有必要的测试数据，以及运行软件对所有输入和刺激的集合。暴力方法迅速变得不切实际，似乎更方便忽略测试，只希望没有错误。
- en: No matter how hard you test, you still can't produce fault-free software—writing
    test code is as hard and requires as much skill as writing regular code. Some
    errors will invariably slip through even the most rigorous testing (studies show
    that the most carefully tested software still contains 0.5 to 3 errors per 1,000
    lines of code). (Myers 86) Testing in the Real World rarely proves that software
    is bulletproof—merely that it is *adequate*.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你测试得多仔细，你仍然无法生产出无故障的软件——编写测试代码与编写常规代码一样困难，并且需要同样的技能。一些错误不可避免地会从最严格的测试中漏出（研究表明，最仔细测试的软件每
    1000 行代码仍然包含 0.5 到 3 个错误）。（Myers 86）在现实世界中的测试很少能证明软件是坚不可摧的——仅仅证明它是*足够的*。
- en: With this in mind, we need to focus on the key tests that are likely to capture
    the majority of software defects for the most effective testing. We'll see how
    to choose these later.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们需要关注那些可能捕捉到大多数软件缺陷的关键测试，以实现最有效的测试。我们稍后会看到如何选择这些测试。
- en: '* * *'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-8-FN-3)]) The higher your input values, the longer the `for` loop
    will take. Assuming an `int` is a 32-bit value (meaning there are 264 input combinations)
    and you have a nice, fast machine (let's say that every function call will take
    one millisecond—*that's one hell of a processor cache*), a brute-force test would
    take almost 600 million years! And that's without printing out any test results.
    . . .
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-8-FN-3)]) 输入值越高，`for` 循环所需的时间就越长。假设一个 `int` 是一个 32 位值（意味着有 2^64
    种输入组合）并且你有一个性能良好的机器（让我们假设每个函数调用将花费一毫秒——*那可是一个相当不错的处理器缓存*），暴力测试将需要近 6 亿年！而且这还没有打印出任何测试结果……
- en: ^([[4](#CHP-8-FN-4)]) Look at the answer to this chapter's first "[Mull It Over](ch08s12.html#mull_it_over-id7
    "Mull It Over")" question (page 494) to find out what it is.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-8-FN-4)]) 查看本章第一个 "[Mull It Over](ch08s12.html#mull_it_over-id7
    "Mull It Over")" 问题的答案（第 494 页）以了解它是什么。
- en: ^([[5](#CHP-8-FN-5)]) This is no joke. The 68000 processor had an undocumented
    *stop and catch fire* instruction—a bus test operation that rapidly cycled the
    address lines, causing the circuit board to overheat and catch on fire.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-8-FN-5)]) 这不是玩笑。68000处理器有一个未记录的*停止并引发火灾*指令——一个快速循环地址线的总线测试操作，导致电路板过热并着火。
- en: The Types of Test
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: There are many different kinds of software tests, and no one is better than
    any other. Each method approaches the code from a different direction and will
    catch a different class of faults. All are needed.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试有很多不同的种类，没有一种是比其他更好的。每种方法都是从不同的方向接近代码，并且会捕捉到不同类别的错误。所有这些都是必需的。
- en: '**Unit testing**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: 'The term *unit test* is commonly used to mean testing a *module* of code (say
    a library, device driver, or protocol stack layer), but it really describes the
    testing of atomic units: each class or function.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*单元测试*通常用来表示测试代码的*模块*（比如库、设备驱动程序或协议栈层），但它实际上描述的是对原子单元的测试：每个类或函数。
- en: Unit testing is performed in strict isolation. Any untrusted external code with
    which the unit interfaces is replaced with a stub or simulator—this ensures that
    you only trap bugs in *this* unit, not bugs caused by outside influences.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是在严格隔离的情况下进行的。与单元接口的任何不受信任的外部代码都被替换为存根或模拟器——这确保你只捕获*这个*单元的缺陷，而不是由外部影响引起的缺陷。
- en: '**Component testing**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件测试**'
- en: A step up from unit testing, this validates the combination of one or more units
    into a full component. Often this is what people mean by *unit test*.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的进一步发展，这验证了一个或多个单元组合成一个完整的组件。通常这就是人们所说的*单元测试*。
- en: '**Integration testing**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**'
- en: This tests the combination of components as they are brought together in the
    system, ensuring that they interconnect properly.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这测试了组件在系统中组合在一起时的组合，确保它们能够正确互联。
- en: '**Regression testing**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**回归测试**'
- en: This is retesting after fixes or modifications are made to the software or to
    its environment. You run regression tests to ensure that the software works as
    it did before and that your modification hasn't broken anything along the way.
    When you work with brittle software, a change in one place can cause strange faults
    to appear elsewhere. Regression testing helps to guard against this.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对软件或其环境进行修复或修改后的重新测试。你运行回归测试以确保软件仍然像以前一样工作，并且你的修改没有在过程中破坏任何东西。当你与脆弱的软件一起工作时，一个地方的变化可能会在其他地方引起奇怪的故障。回归测试有助于防止这种情况发生。
- en: It can be difficult to determine how much retesting is needed, especially near
    the end of the development cycle. Automated test tools are especially useful for
    this type of testing. I'll discuss this in detail in "[Look! No Hands!](ch08s07.html
    "Look! No Hands!")" on page 144.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 确定需要多少重新测试可能很困难，尤其是在开发周期的后期。自动测试工具对于这种类型的测试特别有用。我将在第144页的"[看！没有手！](ch08s07.html
    "看！没有手！")"中详细讨论这一点。
- en: '**Load testing**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**负载测试**'
- en: You perform load tests to ensure that your code can handle the expected volume
    of data being thrown at it. It's simple to write code that generates a good answer,
    but doing so in a timely manner is another thing. This can unearth problems related
    to the efficiency of a system, perhaps due to incorrect buffer sizes, bad memory
    usage, or inadequate database design. Load testing checks that the program "scales
    up" as expected.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你执行负载测试以确保你的代码可以处理预期的数据量。编写生成良好答案的代码很简单，但及时这样做是另一回事。这可能会揭示与系统效率相关的问题，可能是由于缓冲区大小不正确、内存使用不当或数据库设计不足。负载测试检查程序是否“按预期扩展”。
- en: '**Stress testing**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**压力测试**'
- en: 'Stress testing throws a *huge* amount of data at the code within a short space
    of time to see what it does. It''s similar to load testing, often used for high-availability
    systems. Stress tests check the characteristics of the system: how tolerant it
    is to overloading. Load testing is performed to prove that the code can meet its
    *expected* demands; stress testing makes sure that it won''t just crumple in a
    heap if it receives a real battering. The code doesn''t have to keep working perfectly;
    it just has to fail gracefully and recover well.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试在短时间内向代码内投掷大量数据，以查看它会如何反应。它与负载测试类似，通常用于高可用性系统。压力测试检查系统的特性：它对过载的容忍度。负载测试是为了证明代码可以满足其*预期*的需求；压力测试确保它不会在受到真正的打击时只是堆叠在一起。代码不必一直完美工作；它只需要优雅地失败并很好地恢复。
- en: Stress testing helps determine the capacity of the software—how hard you can
    push before it falls over. It is especially pertinent in threaded or real-time
    systems.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试有助于确定软件的容量——在它崩溃之前你能施加多大的压力。这在线程或实时系统中尤为重要。
- en: '**Soak testing**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**Soak测试**'
- en: 'Soak testing is similar to stress testing. The focus is on running at a high
    load for a prolonged period of time—several days, weeks, or even months—to identify
    any performance problems that appear after a large number of operations have been
    executed. Soak testing reveals faults that might otherwise go undetected: small
    memory leaks that eventually crash the program or performance degradation as internal
    data structures slowly become fragmented.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Soak测试与压力测试类似。重点是长时间在高负载下运行——几天、几周甚至几个月，以识别在执行了大量操作后出现的任何性能问题。Soak测试揭示了可能被忽视的故障：可能导致程序崩溃的小内存泄漏或随着内部数据结构逐渐变得碎片化而导致的性能下降。
- en: '**Usability testing**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用性测试**'
- en: Ensures that your software can be used easily by a shortsighted gerbil. There
    are various forms of end-user tests, often performed in *usability labs* under
    very controlled and scripted conditions. We also test software in *field trials*,
    putting it in a Real World setting to see what users think.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的软件可以被短视的仓鼠轻松使用。有各种形式的最终用户测试，通常在*可用性实验室*中进行，条件非常受控和脚本化。我们还在*实地试验*中测试软件，将其置于真实世界环境中，看看用户有什么看法。
- en: '**ALPHA, BETA, GAMMA . . .**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**ALPHA, BETA, GAMMA . . .**'
- en: What about *alpha* and *beta* testing? They are common terms, but not quite
    in the same league as the other tests we've looked at here. They are more focused
    on final *product* testing than on the implementation of particular bits of *code*.
    Nevertheless, they deserve some explanation.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*alpha*和*beta*测试呢？它们是常见的术语，但并不完全等同于我们在这里讨论的其他测试。它们更侧重于最终*产品*测试，而不是特定代码片段的实现。尽管如此，它们仍然值得解释。
- en: Happily, the terms have no formal definition. Each company will have its own
    idea of what software in an *alpha* or *beta* state is. For all you know, alpha
    software might be made of lemon jelly and explode on exposure to light. Alpha
    or beta software is often released externally, as an advance customer preview—an
    early chance to elicit feedback and garner confidence.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些术语没有正式的定义。每家公司都会对其*alpha*或*beta*状态的软件有自己的看法。据你所知，alpha软件可能是由柠檬果冻制成的，在暴露于光线时会爆炸。Alpha或beta软件通常作为预览版对外发布，这是一个早期收集反馈和建立信心的机会。
- en: 'These are common interpretations of the terms:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是对这些术语的常见解释：
- en: '**Alpha software**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**Alpha软件**'
- en: The first "code complete" stage. It may still have many, many bugs, and be completely
    unreliable. Alpha software provides a good representation of what the final product
    will be like, if you can look past the obvious flaws.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个“代码完成”阶段。它可能仍然存在许多、许多错误，并且完全不可靠。Alpha软件提供了对最终产品将如何的很好展示，如果你能忽略明显的缺陷。
- en: '**Beta software**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**Beta软件**'
- en: Well past the alpha stage, beta software is *mostly* bug free; there are very
    few remaining problems. It's not too far from a final product. Beta testing (that
    is, testing *beta* software) is used in the run up to final release candidates
    to nail the remaining issues. Beta testing usually involves Real World field trials.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 超过alpha阶段，beta软件*基本上*没有错误；剩余的问题非常少。它离最终产品不远。Beta测试（即测试*beta*软件）用于最终发布候选版本，以解决剩余的问题。Beta测试通常涉及真实世界的实地试验。
- en: '**Release candidate**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布候选版本**'
- en: This is the final stage before a formal software release. Candidate builds go
    through verification and *assurance testing* (validation) prior to the production
    release. Release candidates are internal builds, usually going to the test department
    only.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正式软件发布前的最后阶段。候选版本在正式发布前会经过验证和*保证测试*（验证）。
- en: If alpha and beta releases venture to the outside world, they may have some
    form of crippling (time-limited operation, for example). The release candidates
    are "pure" builds, without any of these limitations.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果alpha和beta版本进入外部世界，它们可能有一些形式的限制（例如时间限制的操作）。发布候选版本是“纯”构建，没有任何这些限制。
- en: 'When we write unit and component tests, there are two main approaches to devising
    the test cases: *black box* and *white box* testing.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写单元和组件测试时，有两种主要方法来设计测试用例：*黑盒*和*白盒*测试。
- en: '**Black box testing**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑盒测试**'
- en: This is also known as *functional testing*. Black box testing compares actual
    functionality against intended functionality. The internal workings of the code
    are not known by the tester; it is seen as a *black box*. The designer and tester
    can be independent of each other.^([[6](#ftn.CHP-8-FN-6)])
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为**功能测试**。黑盒测试将实际功能与预期功能进行比较。测试者不知道代码的内部工作原理；它被视为一个**黑盒**。设计者和测试者可以是独立的。
- en: Black box testing is not concerned that every line of code is tested, only that
    it meets the software's specification—that if you put the right things into one
    end of the box, the right things come out the other. Therefore, without clear
    specifications and documented APIs, it is very hard to devise black box tests.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试不关心是否每行代码都被测试，只关心它是否符合软件的规格——即如果你把正确的东西放入盒子的一个端，正确的东西就会从另一个端出来。因此，如果没有明确的规格和文档化的API，设计黑盒测试是非常困难的。
- en: Black box test cases can be designed as soon as the software specification is
    complete. They rely on the specification being correct in the first place and
    on it not being radically altered after the tests have been devised.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试用例可以在软件规格完成后设计。它们依赖于规格首先正确，并且在测试设计之后没有发生根本性的改变。
- en: '**White box testing**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**白盒测试**'
- en: This is also known as *structural testing*. It is a code-coverage-based approach.
    Each line of code is scrutinized systematically to ensure correctness. Where you
    couldn't see into the black box beforehand, you now can and do. For this reason,
    white box testing is sometimes called *glass box* testing. It is really only concerned
    with testing the lines of code produced, and it doesn't guarantee that they meet
    their specifications.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为**结构测试**。它是一种基于代码覆盖的方法。每一行代码都会被系统地审查以确保正确性。在你之前无法看到黑盒内部的情况下，你现在可以并且确实可以看到。因此，白盒测试有时被称为**玻璃盒**测试。它实际上只关注测试生成的代码行，并且不能保证它们符合其规格。
- en: There are *static* and *dynamic* methods of white box testing. Static tests
    do not run the code; instead, it is inspected and walked through to ensure that
    it represents a valid solution. Dynamic tests run the code and are concerned with
    path and branch testing—trying to visit every line of code and execute every decision.
    This may require some modification of the code to force control down certain paths.
    Such modification can be easier than trying to engineer test cases for all behavioral
    combinations.^([[7](#ftn.CHP-8-FN-7)])
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试有**静态**和**动态**两种方法。静态测试不运行代码；相反，它被检查并逐步执行以确保它代表一个有效的解决方案。动态测试运行代码，并关注路径和分支测试——尝试访问每一行代码并执行每一个决策。这可能需要修改代码以强制控制流下某些路径。这种修改可能比为所有行为组合设计测试用例要容易。^([[7](#ftn.CHP-8-FN-7)])
- en: White box testing is laborious and much more expensive than black box; consequently,
    it is done a lot less. The completed code is needed before white box tests can
    even be planned. Black box testing is typically done before white box testing
    starts. The consequence of a failure at this stage is much more expensive. You'd
    have to code a fix, black box test again, then devise and run new white box tests.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试既费时又比黑盒测试昂贵得多；因此，它做得很少。在计划白盒测试之前，需要完成代码。黑盒测试通常在白盒测试开始之前进行。这个阶段的失败代价更大。你将不得不编写修复代码，再次进行黑盒测试，然后设计和运行新的白盒测试。
- en: Tools exist to instrument your code and measure the test coverage. Without tool
    support, white box testing could make your head explode.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 存在工具可以对代码进行仪器化并测量测试覆盖率。没有工具支持，白盒测试可能会让你的头爆炸。
- en: Black box testing is concerned with faults of *omission* (where the software
    misses out some of the specified behavior), while white box testing discovers
    faults of *commission* (where parts of the implementation are faulty). In order
    to fully test a software unit, both black and white box testing is required.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试关注的是**遗漏**（软件遗漏了部分指定的行为）的故障，而白盒测试发现的是**错误**（实现的部分有缺陷）。为了完全测试一个软件单元，需要同时进行黑盒和白盒测试。
- en: '**TEST TIME**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试时间**'
- en: Each of these test methods is employed at different points in the development
    process. The following table illustrates this, showing which tests are most important
    at each point.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试方法在不同的开发阶段被使用。以下表格说明了这一点，显示了在每个阶段哪些测试最重要。
- en: '| Stage of Development | Is Black or White Box Appropriate? | Common Testing
    Approaches at This Stage of Development | Who Performs the Test? |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
- en: '| Requirements gathering | Black | Black box tests devised | Developers, QA
    |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
- en: '| Code design | Black | Black box tests devised | Developers, QA |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
- en: '| Code construction | Black, white | Unit, component, regression | Developers
    |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
- en: '| Code integration | Black, white | Component, integration, regression | Developers
    |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
- en: '| Alpha status | Black, white | Regression, load, stress, soak, usability |
    Developers, QA |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
- en: '| Beta status | Black, white | Regression, load, stress, soak, usability |
    QA |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
- en: '| Release candidate | Black, white | Regression, load, stress, soak | QA |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
- en: '| Release | Black, white | It''s too late by now . . . | Users (good luck)
    |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
- en: '* * *'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-8-FN-6)]) However, this isn't necessarily a good idea—a programmer
    is usually the best person to write the unit test for the code he or she creates.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-8-FN-7)]) If you do modify the source code, then you're not actually
    testing the final executable, which is concerning.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Unit Test Cases
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If testing is essential but exhaustive testing is impossible, you must judiciously
    choose the set of most effective tests. To do this, you need a thoughtful and
    methodical plan. You could take a *scattergun* approach—just prop the code up
    on a wall and then fire everything that comes to hand at it. . . .
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing Unit Test Cases](tagoreillycom20080909nostarchimages207464.png.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
- en: That way you *might* find some flaws. But without a sensible, staged testing
    approach, you'll never have the quality tests that will give you proper confidence
    in your code. Instead of the scattergun, you should pick up a rifle with an accurate
    sight and aim careful shots at the code, hitting well-judged marks, to see how
    well it stands up.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Where do you aim? How do you determine the volley of test data to launch? Since
    you can't try every possible value, you need to select a handful of pertinent
    inputs. You must pick the tests that are most likely to disclose the software's
    faults, rather than run tests that just show the same few problems repeatedly.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '*Write a comprehensive suite of tests, each one exercising a different aspect
    of the code. Fifteen tests that demonstrate the same fault over and over are less
    useful than fifteen tests that show fifteen different faults*.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you must understand the requirements for your piece of code. You
    can't write an accurate test case unless you know what it's supposed to do. It
    might be doing the wrong thing very well.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'When black box testing, some test cases will be:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '**Some good input**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Select a number of well-chosen *good* inputs to ensure that the software works
    properly in the normal cases.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Cover the whole range of valid input values; include some middle of the road
    values, some values from around the lower bounds of acceptable input, and some
    from the upper bounds.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '**Some bad input**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Just as important are a certain number of well-chosen *bad* inputs. This ensures
    that the software is robust and doesn't give misleading answers to invalid input.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是一定数量的精心选择的*不良*输入。这确保了软件的鲁棒性，并且不会对无效输入给出误导性的答案。
- en: 'You must consider all sorts of bad data, including:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须考虑各种不良数据，包括：
- en: Values that are numerically far too large or far too small (handling negative
    values is often overlooked)
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值上过大或过小的值（处理负值常常被忽视）
- en: Input that is too long or too short (string lengths are a classic example—try
    sending an empty string to see what happens, or try different-sized arrays and
    lists)
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过长或过短的输入（字符串长度是一个经典例子——尝试发送一个空字符串看看会发生什么，或者尝试不同大小的数组和列表）
- en: Data values that are internally inconsistent (what this means will depend on
    the contract of the function; perhaps it expects values in a certain order)
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据值内部不一致（这具体意味着什么将取决于函数的合约；可能它期望值按照某种顺序）
- en: '**Boundary values**'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界值**'
- en: 'Test *all* the boundary cases—they are a rich source of error. Identify the
    highest and lowest inputs that are valid, or wherever the natural input boundaries
    are (perhaps where behavior changes). For each of these positions, test the code''s
    behavior at:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 测试所有边界情况——它们是错误来源的丰富资源。确定最高和最低的有效输入，或者自然输入边界在哪里（可能是在行为改变的地方）。对于这些位置中的每一个，测试代码在以下位置的行为：
- en: The boundary value itself
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界值本身
- en: The values just above it
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高于它的值
- en: The values just below it
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低于它的值
- en: This ensures that your software works correctly right into the corners, and
    that it then gives up exactly when expected.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了你的软件能够在边缘正确运行，并且当预期时能够准确放弃。
- en: Boundary tests catch the all-too-easy mistakes, like typing `>` instead of `>=`,
    or getting loop count bases wrong (did you start counting from zero or one?).
    All three boundary tests are needed to check for these kinds of mistakes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 边界测试可以捕捉到过于简单的错误，比如输入`>`而不是`>=`，或者循环计数基数错误（你是从零开始计数还是从一？）。所有三个边界测试都是必要的，以检查这些类型的错误。
- en: '**Random data**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机数据**'
- en: Test randomly generated sets of input data to avoid guesswork. This is a surprisingly
    effective test strategy. If you can write an automated test harness that repeatedly
    generates and applies random data, you stand a good chance of picking up subtle
    errors that you would have never thought of otherwise.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随机生成的输入数据集以避免猜测。这是一个出人意料有效的测试策略。如果你能编写一个自动测试框架，它可以重复生成并应用随机数据，你就有很大机会发现你从未考虑过的微妙错误。
- en: '**Zero**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**零**'
- en: If the input is numeric, always test for the zero case. For some reason, programmers
    fail to think properly about zero, a blind spot in their reasoning.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是数值型的，总是要测试零的情况。由于某种原因，程序员们往往没有正确考虑零，这是他们推理中的一个盲点。
- en: C/C++ pointers are often given a zero value to mean *unset* or *undefined*.
    Try throwing zero pointers at your code to see if it reacts correctly. In Java,
    you can send `null` object references for a similar effect.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++指针通常被赋予零值以表示*未设置*或*未定义*。尝试将零指针抛向你的代码，看看它是否正确反应。在Java中，你可以发送`null`对象引用以产生类似的效果。
- en: Design for Test
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试设计
- en: The quality of unit test you can write is determined largely by the quality
    of the interface you have to test. Testing is easier when your code is written
    thoughtfully and specifically designed to accommodate inspection and verification.
    You achieve this by crafting clear APIs, reducing reliance on other bits of code,
    and breaking any hard-coded links to other components. This way, it's easy to
    place a component into its test environment and stimulate it. If, instead, it's
    grafted intimately into other sections of code, you have to drag all of that code
    into the test environment and arrange for it to interact with your unit appropriately.
    This is not always easy, and often impossible, limiting your scope for possible
    tests.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 你能编写的单元测试质量很大程度上取决于你要测试的接口质量。当你的代码被深思熟虑地编写，并且专门设计以适应检查和验证时，测试会更简单。你通过构建清晰的API、减少对其他代码的依赖，并打破与其他组件的硬编码链接来实现这一点。这样，将组件放入测试环境并刺激它就变得容易了。相反，如果它与代码的其他部分紧密相连，你必须将所有这些代码拖入测试环境，并安排它们以适当的方式与你的单元交互。这并不总是容易，有时甚至不可能，这限制了可能测试的范围。
- en: '**KEY CONCEPT**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Design your code for easy testing*.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计你的代码以便于测试*。'
- en: 'There''s a helpful side effect of this rule: When you structure code for testability,
    you will be structuring it in a sensible, understandable, and maintainable way.
    You''ll reduce component coupling and increase cohesion. You''ll make it more
    flexible, easy to use, and easier to wire up in different configurations. Your
    code will be better.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个有用的副作用：当你为可测试性结构化代码时，你将按照合理、可理解和可维护的方式进行结构化。你会减少组件耦合并增加内聚性。你会使其更加灵活、易于使用，并更容易在不同配置中进行连接。你的代码会更好。
- en: And since you've tested it well, the code is more likely to be correct.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经很好地进行了测试，代码更有可能是正确的。
- en: 'You must design for tests up front. You can''t easily return to an old component
    and bolt a "testable" interface onto it. If a lot of other code relies on the
    existing interface, then such modifications are hard. Remember: You''re most likely
    to design geniunely testable code if you write unit tests alongside the code.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须从一开始就为测试而设计。你不可能轻易地返回到旧组件并在其上安装一个“可测试”的接口。如果大量其他代码依赖于现有的接口，那么这样的修改很困难。记住：如果你在编写代码的同时编写单元测试，你最有可能会设计出真正可测试的代码。
- en: 'A few simple design rules lead to highly testable code:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的设计规则可以导致高度可测试的代码：
- en: Make each section of code self-contained, without undocumented and tenuous dependencies
    on the outside world. Don't hard-code links to other parts of the system; rely
    on abstract interfaces that could be implemented by system components or by test
    simulators.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让每一部分代码都自成体系，不要对外部世界有未记录的、脆弱的依赖。不要将链接硬编码到系统的其他部分；依赖于可以被系统组件或测试模拟器实现的抽象接口。
- en: Don't rely on global variables (or *singleton* objects, which are thin veneers
    for globals). Gather such states in a shared structure passed as an argument.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要依赖于全局变量（或*单例*对象，它们是全球变量的薄薄外皮）。将这些状态收集在作为参数传递的共享结构中。
- en: Limit the complexity of your code; break it into small, comprehensible, bite-sized
    chunks that can be individually tested.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制代码的复杂性；将其分解成小、可理解、易于测试的块。
- en: Make the code observable, so you can see what it's doing, query internal state,
    and ensure that it's operating as expected.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码可观察，这样你就可以看到它在做什么，查询内部状态，并确保它按预期运行。
- en: Look! No Hands!
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看！不需要动手！
- en: 'You can''t hang around all day turning the handle on your test machinery. Manually
    invoking test after test isn''t my idea of a great day''s programming. Repeated
    regression testing would rapidly get boring. It wouldn''t just be boring, but
    also slow, inefficient, and prone to human error. The golden testing rule is simple:
    *Automate*.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你不可能整天都在你的测试机器上转动手柄。手动一个接一个地调用测试不是我认为的伟大的一天编程。重复回归测试会很快变得无聊。这不仅会无聊，而且会慢、低效，并容易出错。黄金测试规则很简单：*自动化*。
- en: '**KEY CONCEPT**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Automate your code testing as much as possible. It''s quicker and easier than
    running tests by hand, and it''s far safer: The tests are more likely to be run
    regularly*.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能自动化你的代码测试。这比手动运行测试更快、更简单，而且更安全：测试更有可能定期运行*。'
- en: If the tests run without any intervention, they can be triggered as a validation
    phase of your build procedure. Before you play with some freshly built software,
    you'll know the unit tests have automatically run and passed; you're assured that
    there are no silly programming errors and that any new work hasn't broken old
    code.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试在没有干预的情况下运行，它们可以作为构建过程的一部分触发验证阶段。在你玩一些新构建的软件之前，你会知道单元测试已经自动运行并通过；你确信没有愚蠢的编程错误，并且任何新的工作都没有破坏旧代码。
- en: '**KEY CONCEPT**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Run unit tests automatically as a part of your build process*.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*将单元测试自动作为构建过程的一部分运行*。'
- en: You can gather your individual pieces of test code together in an automated
    scaffold that marshals the test execution and gathers the results of the testing
    in a single place. This harness monitors which tests have been done; the more
    complex test harnesses maintain a history of test results over time. There are
    many such popular tools, like JUnit, a common Java unit test framework.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的单个测试代码片段组合在一个自动的脚手架中，该脚手架协调测试执行并在一个地方收集测试结果。这个工具包监控哪些测试已经完成；更复杂的测试工具包会维护随时间推移的测试结果历史。有许多这样的流行工具，如JUnit，这是一个常见的Java单元测试框架。
- en: A high level of automation comes into its own during regression testing. If
    you make a modification to the code and want to ensure that you haven't accidentally
    broken anything, you can run the whole set of tests automatically; out of the
    end pops a *yes* or *no* answer. Of course, the regression test result is only
    ever as good as the tests put into the harness.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在回归测试期间，高度自动化变得尤为重要。如果你对代码进行了修改，并想确保你没有意外破坏任何东西，你可以自动运行整个测试集；最终会弹出*是*或*否*的答案。当然，回归测试结果只与放入框架中的测试一样好。
- en: Automation really is a fundamental concept for solid code development. If you
    don't currently have an automated suite of unit tests, acting as a continual regression
    test of your codebase, then get one. Your work will quickly improve in quality.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化确实是稳健代码开发的基本概念。如果你目前还没有一套自动化的单元测试，作为代码库的持续回归测试，那么请获取一套。你的工作质量将迅速提高。
- en: Sadly, not all tests *can* be automated. Unit testing library functions is relatively
    easy; automatically testing user interfaces is very hard. How do you emulate mouse
    clicks, check the Urdu translation of a text string, or ensure that the correct
    sound clip is playing?
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，并非所有测试*都可以*自动化。单元测试库函数相对容易；自动测试用户界面非常困难。你如何模拟鼠标点击，检查文本字符串的乌尔都语翻译，或确保正确的声音剪辑正在播放？
- en: The Face of Failure
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 失败的面孔
- en: '*Our greatest glory is not in never falling, but in rising every time we fall*.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的最大荣耀不在于从未跌倒，而在于每次跌倒后都能重新站起来*。'
- en: --Confucius
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: ——孔子
- en: What do you do when your testing finds a program failure? Before you rush in
    headlong to debug it, step back and characterize the problem. This is especially
    important when you don't intend (or have no time) to repair it right away. Follow
    these steps to pin down the nature of the fault so that you, or any other developer,
    can come back later and attempt to sort it out.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的测试发现程序故障时，你会怎么做？在你匆忙调试之前，退后一步，描述问题。这在你不打算（或没有时间）立即修复它时尤为重要。遵循以下步骤，确定故障的性质，以便你或任何其他开发者稍后可以尝试解决它。
- en: Note what you were trying to do at the time and which actions triggered the
    failure.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意你当时试图做什么，以及哪些操作触发了故障。
- en: Try it again. Discover whether the problem is repeatable, how frequently it
    crops up, and whether it coincides with any other activities going on at the same
    time.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再试一次。发现问题是否可重复，它出现的频率，以及它是否与同时进行的任何其他活动相符。
- en: 'Describe the fault. Fully. Be very specific. Include the following:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 详细描述故障。要非常具体。包括以下内容：
- en: The context of problem
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题背景
- en: The simplest steps that can replicate it
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以复制它的最简单步骤
- en: Information about repeatability and frequency of occurrence
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于可重复性和发生频率的信息
- en: The version of the software, exact build number, and hardware used
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的版本、确切的构建号以及所使用的硬件
- en: Anything else that might conceivably relate
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能与之相关的任何其他信息
- en: Record it. Don't lose it! Put this information in your fault-tracking system,
    even if it's a simple coding error that you intend to fix yourself (see "[Can
    You Manage It?](ch08s09.html "Can You Manage It?")" next).
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录下来。不要丢失！即使是一个你打算自己修复的简单编码错误（参见“[你能管理它吗？](ch08s09.html "Can You Manage It?")”），也要将其信息放入故障跟踪系统中。
- en: Write the simplest test harness that will demonstrate the failure, and add it
    to the suite of automatic tests. This will ensure that the fault cannot be lost
    or ignored and, once it's eventually fixed, won't reoccur later in development.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最简单的测试框架来演示故障，并将其添加到自动测试套件中。这将确保故障不会被丢失或忽略，一旦最终修复，就不会在开发过程中再次出现。
- en: Remember, testing is *not* debugging—and these steps are *not* debugging! You've
    not tried to unveil the cause of the failure, or peek into the code, just to establish
    enough information to describe the problem to another developer.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，测试*不是*调试——这些步骤*不是*调试！你并没有试图揭示失败的原因，或窥视代码，只是为了收集足够的信息，向其他开发者描述问题。
- en: 'Our favorite kind of fault is a repeatable fault. Really—we like code that
    falls over repeatedly: It''s easy to replicate the problem; therefore it''s easy
    to track down the fault and easy to prove that you''ve fixed it. Nasty failures
    are irregular, even random, and consequently hard to characterize. Failures that
    take an eon to manifest and depend upon the wind speed are a nightmare.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最喜欢的故障类型是可重复的故障。真的——我们喜欢反复崩溃的代码：问题容易复制；因此，追踪故障和证明你已经修复它都很简单。糟糕的故障是不规则的，甚至是随机的，因此很难描述。需要很长时间才能显现并依赖于风速的故障是一场噩梦。
- en: Can You Manage It?
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能管理它吗？
- en: 'You must be methodical and systematic in order to *find* faults. You must also
    be methodical and systematic in your management and handling of them. Before releasing
    code (or checking it into source control), you are the only person who''d be bitten
    by its gremlins. But as soon as it leaves your care, code takes on a life of its
    own. It''s no longer just *you* who is concerned with its faults. The rules change
    as more players join the game:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 为了*发现*错误，你必须有系统性和条理性的方法。在管理和处理它们时，你也必须保持系统性和条理性。在发布代码（或将其检查到源代码控制中）之前，你将是唯一可能被其缺陷困扰的人。但是一旦它离开你的照顾，代码就获得了自己的生命。不再只有*你*会关心它的缺陷。随着更多玩家加入游戏，规则也会改变：
- en: A programmer will find problems at the codeface—in his own code and in other
    people's.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员会在代码层面发现问题——在自己的代码和其他人的代码中。
- en: The code integrator will find errors as components are glued together.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码集成器会在组件粘合在一起时发现错误。
- en: The QA department will find faults in the product as it tests.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量保证部门在测试产品时会发现错误。
- en: With so many people finding so many problems while others are simultaneously
    trying to make fixes, there had better be a good procedure for managing it all.
    Otherwise, the result will be a mess, and development will come crashing down
    around everyone's heads.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多人发现许多问题的同时，其他人正在尝试进行修复，因此必须有一个良好的管理程序。否则，结果将是一团糟，开发工作将崩溃在每个人的头上。
- en: Fault-Tracking System
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障跟踪系统
- en: Our key weapon in managing faults is a *fault-tracking system*. This tool is
    a specialized database with interfaces visible to everyone who has a hand in the
    testing process.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在管理故障中的关键武器是一个*故障跟踪系统*。这个工具是一个专门的数据库，对参与测试过程的每个人都是可见的。
- en: 'As bugs are discovered and dealt with, this database is updated to reflect
    the status of the software. In doing so, the fault-tracking tool becomes an integral
    part of the project''s *fault-management procedure*. The general actions performed
    are:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 随着错误的发现和处理，此数据库会更新以反映软件的状态。在此过程中，故障跟踪工具成为项目*故障管理流程*的一个组成部分。一般执行的操作包括：
- en: '**Report a failure**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告故障**'
- en: When you find a bug, make a new entry for it in the database by creating a *fault
    report*. It becomes a fully paid-up member of the fault club, with its own personal
    membership number. This reference number uniquely identifies it for future use.
    The bug now cannot be overlooked. It *must* be addressed before the software is
    shipped.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现一个错误时，通过创建一个*故障报告*在数据库中为它创建一个新条目。它现在成为故障俱乐部的正式成员，拥有自己的个人会员编号。这个参考编号在未来的使用中可以唯一地识别它。现在这个错误不能被忽视。在软件发货之前，它*必须*得到解决。
- en: Creating a report also alerts others in the team that this fault has been found;
    they don't need to enter the same information when they run into it.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 创建报告还会提醒团队中的其他人这个错误已被发现；当他们遇到它时，他们不需要输入相同的信息。
- en: '**Assign responsibility**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**分配责任**'
- en: This marks a fault report for a particular person's attention. It defines who
    is responsible for fixing (or making sure that someone fixes) each problem. Without
    this idea of ownership, every programmer will think that someone else is going
    to fix the fault, while the bug works its way through the cracks.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着为特定人员关注的故障报告。它定义了谁负责修复（或确保有人修复）每个问题。如果没有这种所有权的概念，每个程序员都会认为其他人会修复这个错误，而错误会通过缝隙蔓延。
- en: '**Prioritize reports**'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先处理报告**'
- en: The fault-tracking system allows you to mark which faults are the most important.
    A repeatable startup crash is clearly more serious than a button that's occasionally
    shifted one pixel to the right.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 故障跟踪系统允许你标记哪些故障是最重要的。一个可重复的启动崩溃显然比一个偶尔向右移动一个像素的按钮严重得多。
- en: By differentiating the show-stopping faults from little annoyances, developers
    can plan their work and choose which faults need to be fixed first. There may
    be various levels of severity supported by the tool—from critical faults, though
    medium-to-low priority issues, to feature requests.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通过区分阻止运行的故障和小的烦恼，开发者可以规划他们的工作并选择哪些故障需要首先修复。该工具可能支持各种严重程度级别——从关键故障到中等至低优先级问题，再到功能请求。
- en: '**Mark as fixed**'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**标记为已修复**'
- en: A developer will do this once a repair has been made. It doesn't close the fault
    report but places it on a pile ready for verification. The person who submits
    the report is responsible for testing that the fix is correct, although he can
    delegate this task. A fix certainly shouldn't be verified by the person who made
    it, for obvious reasons.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者会在修复完成后这样做。这并不会关闭故障报告，而是将其放在待验证的堆栈上。提交报告的人负责测试修复是否正确，尽管他可以委托这项任务。显然，修复不应该由制作它的人来验证。
- en: '**Close a report**'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**关闭报告**'
- en: Once verified, a report can be closed, becoming nothing more than a distant
    memory (and perhaps a project statistic).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证，报告可以关闭，变成一个遥远的记忆（也许是一个项目统计数字）。
- en: There may be other scenarios leading to report closure—the issue may not have
    been a fault at all, perhaps just a characteristic of the system, or even perfectly
    valid behavior. Testers are fallible too.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在其他导致报告关闭的场景——问题可能根本不是故障，可能是系统的特性，甚至可能是完全有效的行为。测试人员也会犯错误。
- en: Instead of closing a report you don't intend to deal with, you can *defer* it,
    marking the fault to be fixed in a later software revision.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择不关闭你不想处理的报告，而是将其*推迟*，将故障标记为在以后的软件版本中修复。
- en: '**Query the database**'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询数据库**'
- en: 'You can query the fault-tracking system for information:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查询故障跟踪系统以获取信息：
- en: Naturally, you can produce a list of all the pending fault reports, ordering
    them by software version, assignee, priority, or whatever.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然地，你可以生成一个所有待处理故障报告的列表，按软件版本、分配人、优先级或任何其他方式排序。
- en: You can discover which faults have been assigned to you.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以发现哪些故障已被分配给你。
- en: You can produce a report on which faults have been fixed in each software version.
    This is helpful for preparing *release notes*.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以生成一份报告，列出每个软件版本中已修复的故障。这有助于准备*发布说明*。
- en: You can also view project statistics—how many faults have been reported during
    development, how many have been fixed, and the rate of closure versus generation.
    Presented graphically, this can give a good impression of how well the software
    is progressing.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以查看项目统计信息——在开发过程中报告了多少个故障，修复了多少个，以及关闭率与生成率的比率。以图形方式呈现，这可以很好地展示软件的进展情况。
- en: '**Modify an entry**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改条目**'
- en: 'You can open a report and alter the information it contains. This includes:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开报告并更改其中包含的信息。这包括：
- en: Adding comments for any new information you've found
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加任何新发现信息的注释
- en: Attaching log files, containing example output, to illustrate the problem
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将包含示例输出的日志文件附加到说明问题
- en: Marking a report as a duplicate of another fault, to prevent later confusion
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将报告标记为另一个故障的重复项，以防止以后产生混淆
- en: There are plenty of fault-tracking tools available, both commercial and freely
    available versions, like the popular Bugzilla system developed as a part of the
    Mozilla project.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的故障跟踪工具有很多，包括商业版本和免费版本，如作为Mozilla项目一部分开发的流行Bugzilla系统。
- en: Bug Reviews
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺陷审查
- en: Toward the end of product development, as release deadlines inch ever nearer,
    *bug review* meetings become a part of life, occurring about once a week. These
    reviews are scheduled once functionality is complete but before all the bugs are
    ironed out—the long home stretch of the development process. They provide an overview
    of the project's progress to all interested parties, help plan the remaining repair
    work, and shepherd the software toward release.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品开发的后期，随着发布截止日期的日益临近，*缺陷审查*会议成为生活的一部分，大约每周举行一次。这些审查在功能完成但所有缺陷都得到解决之前进行——这是开发过程的漫长冲刺阶段。它们为所有感兴趣的相关方提供了项目进度的概述，帮助规划剩余的修复工作，并引导软件向发布迈进。
- en: 'These meetings are attended by an eclectic bunch of people:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这些会议由各种各样的人参加：
- en: The software developers responsible for the product. (They'll be doing the fixing,
    after all.)
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责该产品的软件开发者。（毕竟，他们将进行修复。）
- en: Representatives from the test team, who will explain the context of faults and
    ensure the bug review is steering in the correct direction. (More often than not,
    it's their responsibility to convene the meeting.)
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自测试团队的代表，他们将解释故障的背景并确保缺陷审查的方向正确。（通常情况下，他们的责任是召集会议。）
- en: Product managers, who will gain an overview of the progress and will make *the
    buck stops here* decisions.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品经理，他们将获得进度概述并做出*责任在此处停止*的决定。
- en: Commercial and marketing team members, who are the people that will have to
    sell this bug-ridden product. (Their viewpoint on the importance of each fault
    helps to decide which ones to fix and which to sweep under the digital carpet.)
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业和市场团队成员，他们是必须销售这个充满错误的产品的人。（他们对每个错误重要性的观点有助于决定哪些需要修复，哪些可以扫进数字地毯下。）
- en: A list of outstanding fault reports is generated from the fault tracking tool,
    and each fault is discussed in turn during the meeting. Test or development team
    members may present additional information, if required, and then commercial decisions
    on the importance of the problem are made. Nasty lingering faults are discussed,
    with a progress report of the repair. If work is struggling, a decision to apply
    additional resources might be made.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误跟踪工具生成一份未解决的错误报告清单，并在会议中依次讨论每个错误。如果需要，测试或开发团队成员可以提供额外信息，然后根据问题的商业重要性做出决定。讨论那些讨厌的持续存在的错误，并报告修复进度。如果工作进展缓慢，可能会做出增加额外资源的决定。
- en: With such a large range of people, the meeting can rapidly get off track, and
    it takes a strong-willed chairman to keep discussion focused and to the point.
    The topic is fault reports and how to deal with them, not specific code fixes.
    Programmers love to talk technical and try to solve every issue in the meeting.
    This is not the place for it.^([[8](#ftn.CHP-8-FN-8)])
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有这么多人，会议可能会迅速偏离轨道，需要一个意志坚定的主席来保持讨论的焦点和简洁。主题是错误报告以及如何处理它们，而不是具体的代码修复。程序员喜欢谈论技术并试图在会议中解决每个问题。这不是讨论技术的地方.^([[8](#ftn.CHP-8-FN-8)])
- en: '* * *'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[8](#CHP-8-FN-8)]) Tactics for successful meetings are described in "[MEETING
    YOUR FATE](ch17s07.html#meeting_your_fate "MEETING YOUR FATE")" on page 340.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-8-FN-8)]) 成功会议的策略在340页的"[MEETING YOUR FATE](ch17s07.html#meeting_your_fate
    "MEETING YOUR FATE")"中描述。
- en: In a Nutshell
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Testing is critical to producing good software. In general, the more testing,
    the better—although the *quality* of the tests will be reflected in the quality
    of the final product. Poor tests will catch few faults, and the result will be
    a defective software release.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于生产高质量的软件至关重要。一般来说，测试越多越好——尽管测试的质量将反映在最终产品的质量上。糟糕的测试将捕获很少的错误，结果将是一个有缺陷的软件发布。
- en: We test at various levels of development, from individual functions, through
    component integration, to the final assembled program. At each stage, you must
    adopt a methodical approach to finding and managing software faults.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开发的各个阶段进行测试，从单个函数，到组件集成，再到最终组装的程序。在每一个阶段，你必须采用一种系统的方法来寻找和管理软件错误。
- en: It is each programmer's responsibility to test his or her code. The QA department
    has enough problems to deal with apart from your buggy code. You can't perform
    testing and then add in software quality at end of development—it must be designed
    in from the start, with tests being developed and run alongside the code.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员都有责任测试自己的代码。QA部门已经有很多问题要处理，除了你的有缺陷的代码。你不能在开发结束时进行测试并添加软件质量——它必须从一开始就设计，测试与代码并行开发并运行。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| 优秀的程序员 . . . | 次要的程序员 . . . |'
- en: '| --- | --- |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Write tests for all their code (possibly even *before* they write the code)
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为他们所有的代码编写测试（甚至可能在编写代码之前）
- en: Test at the *micro* level, so *macro*-level testing is not hindered by stupid
    coding mistakes
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*微观*层面进行测试，这样*宏观*层面的测试就不会受到愚蠢的编码错误的阻碍
- en: Care about product quality and take responsibility for it, playing their parts
    in the total testing effort
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关心产品质量并对其负责，在总的测试工作中扮演自己的角色
- en: '|'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Don't consider testing to be an important and integral part of software development—*it's
    someone else's job*
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要认为测试是软件开发的重要和不可或缺的部分——*那是别人的工作*
- en: Release untested code to the QA department and look surprised when testing uncovers
    faulty behavior
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将未经测试的代码发布给QA部门，并在测试发现错误行为时感到惊讶
- en: Make their lives more complicated by discovering problems too late—not testing
    early enough and then being hit by a slew of hard-to-locate faults
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过太晚发现问题使他们的生活更加复杂——测试不够早，然后被一系列难以定位的错误所打击
- en: '|'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料列表
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。寻找错误")'
- en: What to do when you find a fault—the process of locating and fixing bugs.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现错误时该做什么——定位和修复错误的流程。
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[第20章](ch20.html "第20章。全面回顾")'
- en: '*Code reviews* are a testing technique—a manual form of static code analysis.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码审查*是一种测试技术——一种静态代码分析的手动形式。'
- en: '![See Also](tagoreillycom20080909nostarchimages207466.png.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207466.png.jpg)'
- en: Get Thinking
  id: totrans-615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 494.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些问题的详细讨论可以在第494页的“[附录A](apa.html "附录A. 答案和讨论")”部分找到。
- en: Mull It Over
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: Write a test harness for the `greatest_common_divisor` code example earlier
    in this chapter. Make it as exhaustive as you can. How many individual test cases
    have you included?
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为本章前面提到的`greatest_common_divisor`代码示例编写一个测试框架。尽可能使其详尽。你包含了多少个单独的测试用例？
- en: How many of these passed?
  id: totrans-619
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些中有多少通过了？
- en: How many failed?
  id: totrans-620
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少失败了？
- en: Using these tests, identify any faults and repair the code.
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些测试，识别任何故障并修复代码。
- en: How should the testing of a spreadsheet application and an automatic aircraft
    pilot differ?
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电子表格应用程序和自动飞机驾驶员的测试有何不同？
- en: Should you test all of the *test code* that you write?
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否应该测试你编写的所有*测试代码*？
- en: How does a programmer's testing differ from a QA department member's testing?
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员的测试与QA部门成员的测试有何不同？
- en: Is it necessary to write a test harness for every single function?
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有必要为每个函数编写测试框架？
- en: '*Test-driven development* encourages you to write tests first, before any code.
    What sort of tests should you write?'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*测试驱动开发*鼓励你在编写任何代码之前先编写测试。你应该编写什么样的测试？'
- en: Should you write C/C++ tests to check for the handling of `NULL` (zero) pointer
    parameters? What's the value of such a test?
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否应该编写C/C++测试来检查对`NULL`（零）指针参数的处理？这种测试的价值是什么？
- en: Your early code tests might not be on the final platform—you may not yet have
    access to it. Is it safest to defer testing until you *do* have a target test
    platform, or to steam ahead now?
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你早期的代码测试可能不在最终平台上——你可能还没有访问权限。现在推迟测试直到你*确实*有一个目标测试平台，还是现在就全力以赴？
- en: If the code is intended to run in a different environment (perhaps on a high-capacity
    server, or some embedded device), how can you be sure that your tests are representative
    and adequate?
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果代码打算在不同的环境中运行（可能在高容量服务器上，或者某些嵌入式设备上），你怎么能确保你的测试是具有代表性的和足够的？
- en: How do you know when you've finished and can stop testing? How much is *enough*?
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你怎么知道你已经完成测试可以停止了？多少是*足够的*？
- en: Getting Personal
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个性化
- en: For what percentage of your code do you write tests? Are you happy with this?
    Are your tests an automated part of the build process? What sort of testing do
    you give the remaining code? Is this adequate? What will you do about it?
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你为多少代码编写了测试？你对这个结果满意吗？你的测试是构建过程中的自动化部分吗？你对剩余的代码进行什么样的测试？这是否足够？你将如何处理这个问题？
- en: How good is your relationship with the people in your QA department? What personal
    reputation do you think you have with them?
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你与QA部门的人的关系有多好？你认为你在他们中的个人声誉如何？
- en: What's your usual response to finding an error in your code?
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在代码中发现错误时的通常反应是什么？
- en: Do you file a fault report for every code problem you uncover?
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否为每个发现的代码问题提交故障报告？
- en: How much testing are the project engineers expected to do?
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目工程师预计要进行多少测试？
- en: Chapter 9. FINDING FAULT
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章。寻找错误
- en: '*Debugging: What to Do When Things Go Wrong*'
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*调试：出错时该做什么*'
- en: I have not failed. I've just found 10,000 ways that won't work.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我并没有失败。我只是找到了一万种行不通的方法。
- en: --Thomas Edison
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: --托马斯·爱迪生
- en: Nobody's perfect. Well, except for me. All day, I have to sit down and work
    through tedious problems in other people's code. The test department discovers
    that our software falls over when it does *such-and-such*. So I trawl through
    the system to find what Programmer Fred did wrong three years ago, patch it up,
    and send it back for them to break again.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人是完美的。嗯，除了我。整天，我必须坐下来处理别人代码中的繁琐问题。测试部门发现我们的软件在*这样那样*的情况下会崩溃。所以我翻遍整个系统，找出程序员弗雷德三年前做错了什么，修补它，然后发回给他们再次破坏。
- en: Of course, you wouldn't find *me* making those sorts of elementary mistakes—not
    a chance. My code is watertight. Faultless. Low fat and cholesterol free. I never
    write a line without meticulous planning, I won't complete a code statement without
    considering all the special cases that might occur, and I type so carefully that
    I've never once misplaced `=` for `==` in an `if` statement.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Totally fault free, me. Really.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Well, perhaps not quite.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: The Facts of Life
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I don't think anyone sits trainee programmers down and explains the facts of
    life to them. *It's like this, son. There are the birds and the bees. Oh, and
    the bugs*. Bugs are the inevitable dark side of constructing software, a simple
    fact of life. Sad, but true. Whole departments, and even industries, exist to
    manage them.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re all aware of the proliferation of faults in released software. How do
    bugs appear with such frightening regularity and in such great magnitude? It all
    comes down to human nature. Programs are written by humans. Humans make mistakes.
    They make mistakes for a number of reasons (or excuses). They make mistakes because
    they don''t understand the system they''re working on well enough or because they
    don''t correctly understand what they are implementing, but more often than not,
    they make mistakes because they just don''t pay enough attention to what they''re
    doing. Most bugs are due to mindlessness. I once saw a wonderfully simple illustration
    of this; play along at home:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: The tree that grows from an acorn is called an . . .
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The noise a frog makes is a . . .
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vapor that rises from fire is called . . .
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The white of an egg is called the . . .
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *yolk*, right? Think about it. If you didn't fall for that one, then you
    were probably only paying attention because I'd just warned you. (Give yourself
    a brownie point anyway.) But tell me, who warns you every time you're about to
    write a potentially flawed line of code? If that person existed, he'd deserve
    a lifetime supply of brownie points.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers, we''re all to blame for the bad state of software. We''re all
    guilty. Do we learn to live with the guilt, or do we do something about it? There
    are two types of responses. The first is the *It''s not a fault, it''s a feature*
    school: Just make up an excuse and ignore it. A fault turns up, and we respond
    in the words of the great philosopher Bart Simpson: "I didn''t do it. Nobody saw
    me do it. You can''t prove anything!" (Simpsons 91) We blame compiler quirks,
    OS flaws, random climate changes, and computers with minds of their own. Or as
    I alluded to in the opening paragraphs, we blame other people. A Teflon raincoat
    is a handy programming tool.'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: However, we should really subscribe to the second school, the school that concedes
    that software errors are *not* entirely inevitable. Many mindless mistakes can
    be picked up or even prevented, and as responsible programmers, we should be taking
    steps to do so. Defensive programming and sensible testing are our main weapons.
    In this chapter, we'll look at good debugging techniques to employ when bugs do
    slip through the net.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们实际上应该遵循第二个学派，即承认软件错误并非完全不可避免的学派。许多无意的错误可以被捕捉甚至预防，作为负责任的程序员，我们应该采取措施这样做。防御性编程和合理的测试是我们的主要武器。在本章中，我们将探讨在错误意外通过时应该采用的良好调试技术。
- en: Nature of the Beast
  id: totrans-655
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶魔的本质
- en: Contrary to popular belief, the term *bug* was in use before the advent of computers.
    In the 1870s, Thomas Edison talked about bugs in electrical circuits. The story
    of the Harvard University Mark II Aiken Relay Calculator tells of the first recorded
    computer bug. In 1945, the early days of computers when they took up whole rooms,
    a moth flew in and managed to lodge itself in some circuits, causing a system
    failure. They taped it into the logbook and wrote, *First actual case of bug being
    found*. For posterity's sake, it has been preserved in the Smithsonian Institute.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 与流行观点相反，"bug"这个术语在计算机出现之前就已经在使用了。在19世纪70年代，托马斯·爱迪生谈论了电路中的虫子。哈佛大学马克II型艾肯继电器计算器的故事记录了第一个记录的计算机虫子。1945年，计算机的早期，当时它们占据了整个房间，一只蛾飞了进去，并设法卡在一些电路中，导致系统故障。他们将蛾贴在日志簿上，写道："首次发现虫子实际案例"。为了永存，它被保存在史密森尼博物院。
- en: Bugs are bad news. But what are they, really? We outlined the correct nomenclature
    for these things in "[TERMS AND CONDITIONS](ch08.html#terms_and_conditions "TERMS
    AND CONDITIONS")" on page 130\. It's worth identifying the varieties of bugs we
    encounter and understanding how they are born, how they survive, and how they
    can be exterminated.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是坏消息。但它们究竟是什么呢？我们在第130页的"[术语和条件](ch08.html#terms_and_conditions "术语和条件")"中概述了这些事物的正确命名法。识别我们遇到的错误种类，了解它们的产生、生存和灭绝方式是值得的。
- en: The View from 1,000 Feet
  id: totrans-658
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从1,000英尺的高度看
- en: 'Software bugs fall into a few broad categories, and understanding these will
    help us to reason about them. Some bugs are naturally harder to find than others,
    and this is related to their categories. Stepping back and squinting from a distance,
    these three classes of bugs emerge:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 软件错误可以分为几个广泛的类别，了解这些类别将帮助我们推理它们。有些错误比其他错误更难找到，这与它们的类别有关。退后一步，从远处眯着眼睛看，这三个类别的错误就会出现：
- en: '**Failure to compile**'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译失败**'
- en: It's really annoying when the code you've spent ages writing fails to compile.
    It means that you'll have to go back and fix a tedious little typo or a parameter
    type mismatch, and then wait for the compiler to run again before you can get
    to the real job of testing your handiwork. Surprisingly, this is the best type
    of error you can get. Why? Simply because it's the easiest to detect and fix.
    It's the most immediate and the most obvious.^([[1](#ftn.CHP-9-FN-1)])
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花费了很长时间编写的代码无法编译时，这真的很令人烦恼。这意味着你将不得不回去修复一个令人厌烦的小错误或参数类型不匹配，然后等待编译器再次运行，你才能开始真正的工作——测试你的作品。令人惊讶的是，这可能是你能得到的最好的错误类型。为什么？简单来说，因为它最容易检测和修复。这是最直接和最明显的。[^1](#ftn.CHP-9-FN-1)
- en: The longer it takes to detect faults, the more it will cost to fix them; this
    is demonstrated in "[THE ECONOMICS OF FAILURE](ch09s02.html#the_economics_of_failure
    "THE ECONOMICS OF FAILURE")" on page 157\. The sooner you catch and fix each fault,
    the sooner you can move on and the less fuss and cost they can incur. Compilation
    failures are very easy to notice (or rather, they are hard to ignore) and usually
    easy to fix. You can't run the program until you have taken care of them.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 检测错误所需的时间越长，修复它们的成本就越高；这在第157页的"[失败的经济学](ch09s02.html#the_economics_of_failure
    "失败的经济学")"中有演示。你越早发现并修复每个错误，你就能越快继续前进，它们造成的麻烦和成本就越少。编译失败很容易注意到（或者更确切地说，很难忽视），并且通常很容易修复。你必须处理完它们才能运行程序。
- en: Most of the time, a compilation failure will be a silly syntactic mistake or
    a simple oversight, like calling a function with the wrong number or type of parameters.
    The failure might be due to a fault in a makefile, it might be a link stage error
    (perhaps a missing function implementation), or even a build server running out
    of disk space.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，编译失败将是一个愚蠢的语法错误或简单的疏忽，比如调用函数时参数数量或类型错误。失败可能是由于makefile中的错误，可能是链接阶段错误（可能是缺少函数实现），甚至可能是构建服务器磁盘空间不足。
- en: '**Run-time crash**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时崩溃**'
- en: After you fix the compilation errors, an executable pops out and you happily
    run it. Then it crashes. You'll probably swear and mutter something about random
    cosmic rays. After the 60th crash, you're threatening to throw your computer out
    the window. These kinds of errors are much harder to deal with than compilation
    errors, but they're still reasonably simple.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复了编译错误之后，一个可执行文件就出现了，你高兴地运行它。然后它崩溃了。你可能会发誓并嘟囔着关于随机宇宙射线的事情。在经历了第 60 次崩溃之后，你可能会威胁要把电脑扔出窗外。这类错误比编译错误更难处理，但它们仍然相对简单。
- en: That's because, like compilation errors, they are blindingly obvious. You can't
    argue with a dead program. You can't pretend a crash is a "feature." When it has
    kicked the bucket and shuffled off its mortal coil, you can step back and begin
    to figure out where your program went wrong. You'll have some clues (which input
    sequence preceded the crash and what it did before crashing), and you can employ
    tools to discover more information (more on this later).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '这是因为，就像编译错误一样，它们是显而易见的。你不能与一个死去的程序争论。你不能假装崩溃是一个“特性”。当它踢开桶子，离开了它的肉身时，你可以退后一步，开始思考你的程序哪里出了问题。你会有一些线索（是什么输入序列导致了崩溃以及崩溃前它做了什么），并且你可以使用工具来发现更多信息（稍后会更详细地介绍）。 '
- en: '**Unexpected behavior**'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**意外行为**'
- en: This is the really nasty one—when your program isn't pushing up the daisies,
    just pining for the fjords. Suddenly it does the wrong thing. You expected a blue
    square, and out popped a yellow triangle. The code continues to meander on its
    happy way with total disregard for your frustration. What caused the yellow triangle
    to appear? Has the program been overthrown by a militant army of guerrilla COM
    objects? It will almost certainly be a minute logic problem in the bowels of the
    code that executed over half and hour ago. Good luck finding it.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真正棘手的一个——当你的程序不是在努力向上爬，而是在渴望 fjords。突然它做了错误的事情。你期望看到一个蓝色方块，却出现了一个黄色三角形。代码继续快乐地前进，完全不顾你的挫败感。是什么导致了黄色三角形的出现？程序是被一支激进的游击队
    COM 对象推翻了吗？这几乎肯定是在代码深处的一个逻辑问题，它执行了半小时。祝你好运找到它。
- en: A failure may manifest itself because of defective single line of code, or it
    may only show up when several interconnecting modules whose assumptions don't
    quite match up are finally glued together.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 一个失败可能是由有缺陷的单行代码引起的，或者它可能只有在几个相互连接的模块最终粘合在一起且假设不完全匹配时才会显现出来。
- en: The View from the Ground
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地面视角
- en: If we move in a bit and take a closer look at run-time errors, more groupings
    of faults become clear. Here they are ranked in order of pain, from splinter to
    decapitation.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微靠近一点，仔细观察运行时错误，更多的错误分组就会变得清晰。以下是按痛苦程度排序的列表，从刺痛到斩首。
- en: '**Syntactic errors**'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法错误**'
- en: 'While these *are* mostly caught by the compiler at build time, sometimes language
    grammar errors slip through undetected. They generate weird and unexpected behavior.
    In C-like languages, the syntax error will often be one of these:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些错误大多数在构建时会被编译器捕获，但有时语言语法错误会悄悄溜过而未被察觉。它们会产生奇怪和意外的行为。在类似 C 的语言中，语法错误通常会是以下之一：
- en: Mistaking `==` for `=` or `&&` for `&` in a conditional expression
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在条件表达式中将 `==` 错误地当作 `=` 或将 `&&` 错误地当作 `&`
- en: Forgetting a semicolon or adding one in the wrong place (the classic location
    is after a `for` statement)
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记分号或在错误的位置添加分号（经典位置是在 `for` 语句之后）
- en: Forgetting to enclose a set of loop statements in braces
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记用大括号括起一组循环语句
- en: Mismatching parentheses
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不匹配的括号
- en: The simplest way to avoid being tripped up by these sorts of errors is to keep
    all compiler warnings switched on; modern compilers moan about of lot of these
    problems.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 避免被这类错误绊倒的最简单方法就是保持所有编译器警告开启；现代编译器会对许多这类问题抱怨不已。
- en: '**KEY CONCEPT**'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Build your code with all compiler warnings switched on. It will highlight
    potential problems before they can bite*.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建代码时，请确保所有编译器警告都已开启。这样可以在问题发生之前将其突出显示出来*。'
- en: '**THE ECONOMICS OF FAILURE**'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '**失败的经济学**'
- en: The art of debugging is intimately bound to the topic of the previous chapter—*testing*
    your code. Testing will expose faults that need to be debugged. I've covered these
    topics in two separate chapters because they *are* different disciplines. However,
    the two in tandem are fundamental to reliable software development.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的艺术与上一章的主题——*测试*你的代码密切相关。测试会暴露出需要调试的错误。我已在两个单独的章节中涵盖了这些主题，因为它们是不同的学科。然而，这两个结合在一起对于可靠的软件开发是基本的。
- en: '![THE ECONOMICS OF FAILURE](tagoreillycom20080909nostarchimages207468.png)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![失败的经济学](tagoreillycom20080909nostarchimages207468.png)'
- en: The frantic pace of the software factory demands code that's produced quickly
    and cheaply. This haste leads to software projects that are riddled with bugs
    and are consequently delivered incredibly late. Late software is a huge problem—it's
    not just embarrassing and inconvenient; it could spell disaster for any company.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工厂的紧张节奏要求快速且低成本地产生代码。这种匆忙导致软件项目充满错误，并且因此交付得非常晚。晚交付的软件是一个大问题——它不仅令人尴尬和不便；它可能给任何公司带来灾难。
- en: In fact, the longer you ignore testing and allow bugs to remain, the worse it
    gets— this graph illustrates the escalating impact of bugs as they wriggle through
    the development process. It shows the average cost of finding and fixing an error
    relative to the phase of production in which it is discovered. (Boehm 81)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你忽略测试的时间越长，允许错误存在的时间越长，情况就越糟——这张图说明了错误在开发过程中逐渐升级的影响。它显示了发现和修复错误的平均成本相对于其在生产阶段被发现的阶段。
    (Boehm 81)
- en: As you can see, the cost rises dramatically with time (note that the cost axis
    is a logarithmic scale). To make matters worse, the nearer we get to a project
    deadline, the less time we have to perform thorough testing. The added pressure
    of impending deadlines makes debugging that much harder—with the pressure on,
    you're even more likely to introduce fresh faults with each repair.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，成本随着时间的推移而急剧上升（请注意，成本轴是对数刻度）。更糟糕的是，我们离项目截止日期越近，我们进行彻底测试的时间就越少。即将到来的截止日期的压力使得调试变得更加困难——在压力之下，你甚至更有可能在每次修复中引入新的错误。
- en: To save your skin and prevent a lot of debugging stress, test your code early
    and thoroughly. Eradicate any bugs you find as soon as possible, before they have
    a chance to cause major grief. There are established methodologies for this—look
    at test-driven development, one of the components of agile software development.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护自己并避免大量的调试压力，尽早彻底测试你的代码。尽快消除你发现的任何错误，在它们有机会造成重大麻烦之前。为此有既定的方法——看看测试驱动开发，它是敏捷软件开发的一个组成部分。
- en: '**Build errors**'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建错误**'
- en: While not a run-time fault *per se*, a build error may only manifest itself
    at run time. Be on the lookout and always distrust your build system, no matter
    how good you think it is. In these enlightened times, you're unlikely to come
    across a compiler bug. However, you may not always be running the code you thought
    you built.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个运行时错误本身，但构建错误可能只会在运行时显现出来。要保持警惕，并且无论你认为你的构建系统有多好，都要始终怀疑它。在当今这个开明的时代，你不太可能遇到编译器错误。然而，你并不总是运行你认为自己构建的代码。
- en: 'I''ve been hit by this several times: The build system failed to rebuild a
    program or shared library (perhaps because the makefiles didn''t contain adequate
    dependency information or the old executable had a bad timestamp). Every time
    I tested my modifications, I was still unknowingly running the old buggy code.
    There are a number of ways to confuse a build system, but the worst is when you
    don''t notice it failing—like a leprous limb.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经遭遇过几次这种情况：构建系统未能重新构建程序或共享库（可能是因为makefile没有包含足够的依赖信息，或者旧的执行文件有一个错误的最后修改时间戳）。每次我测试我的修改时，我仍然在不知不觉中运行着旧的错误代码。有几种方法可以混淆构建系统，但最糟糕的是当你没有注意到它失败——就像一个麻风病肢体。
- en: It can take quite some time to figure this out. For this reason, when you feel
    at all wary of what's going on, it's sensible to do a total cleanout of your project
    and rebuild it from scratch. This should flush out any potential build system
    problems.^([[2](#ftn.CHP-9-FN-2)])
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚这一点可能需要相当长的时间。因此，当你对正在发生的事情感到任何疑虑时，彻底清理你的项目并从头开始重建是明智的。这应该会清除任何潜在的构建系统问题.^([[2](#ftn.CHP-9-FN-2)])
- en: '**Basic semantic bugs**'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本语义错误**'
- en: 'The majority of run-time faults are due to very simple errors causing incorrect
    behavior. Using uninitialized variables is a classic example and can be quite
    hard to track; the program''s behavior will depend on the garbage value previously
    in the memory location used by the variable. One time the program will work fine;
    another time it may fail. Other basic semantic faults are:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运行时错误都是由于非常简单的错误导致的不正确行为。使用未初始化的变量是一个经典的例子，并且可能很难追踪；程序的行为将取决于变量使用的内存位置中之前存在的垃圾值。有时程序会正常运行；另一次它可能失败。其他基本语义错误包括：
- en: Comparing floating-point variables for (in)equality^([[3](#ftn.CHP-9-FN-3)])
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较浮点变量是否相等^([[3](#ftn.CHP-9-FN-3)])
- en: Writing calculations that don't handle numerical overflow
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写不处理数值溢出的计算
- en: Rounding errors from implicit type conversions (losing the sign of a `char`
    is common)
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类型转换的舍入误差（丢失`char`的符号是常见的）
- en: Declaring an `unsigned int foo`, later writing `if (foo < 0)`—oops!
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个`unsigned int foo`，后来写入`if (foo < 0)`——哎呀！
- en: This type of semantic fault is often caught with static analysis tools.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的语义错误通常可以通过静态分析工具捕获。
- en: '**Semantic bugs**'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义错误**'
- en: 'These insidious errors that won''t be caught by inspection tools are much harder
    to identify. A semantic bug might be a low-level error, like the wrong variable
    being used in the wrong place, not validating a function''s input parameters,
    or getting a loop wrong. It may be a higher-level piece of wrong-headedness: calling
    an API incorrectly or not keeping an object''s state internally consistent. Many
    memory-related errors fall into this category—they can be devilishly hard to find
    due to their ability to warp and corrupt your running code so that it behaves
    in totally unpredictable and unreasonable ways.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这些隐蔽的错误不会被检查工具捕获，因此很难识别。语义错误可能是一个低级错误，比如在错误的地方使用了错误的变量，没有验证函数的输入参数，或者循环出错。它也可能是一个更高层次的错误：调用API错误或不保持对象内部状态的一致性。许多与内存相关的错误都落在这个类别中——由于它们能够扭曲和破坏你的运行代码，使其以完全不可预测和不合理的方式运行，因此它们可能非常难以找到。
- en: Programs often behave strangely. The only consolation is that they're doing
    exactly what we told them to.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常会表现出奇怪的行为。唯一的安慰是它们正在做我们告诉它们做的事情。
- en: The best kind of run-time failures are the repeatable ones. If they're reproducible,
    they are much easier to write tests for and track down the cause of. The failures
    that don't always occur tend to be memory corruptions.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的运行时失败类型是可重复的。如果它们可以重复，那么编写测试和追踪原因就更容易了。那些不一定总是发生的失败往往是由内存损坏引起的。
- en: The View from the Trenches
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挖战壕的视角
- en: 'Now that we''ve arranged things into neat little boxes, let''s zoom right in
    and take a look at some of the common types of semantic faults:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把事情整理成整洁的小盒子，让我们直接深入看看一些常见的语义错误类型：
- en: '**Segmentation faults**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**段错误**'
- en: Also known as *protection faults*, segmentation faults come from accessing memory
    locations that have not been allocated for the program's use. They result in the
    operating system aborting your application and producing some form of error message,
    usually with helpful diagnostic information.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为*保护错误*，段错误是由于访问了未分配给程序使用的内存位置而引起的。这会导致操作系统终止你的应用程序并产生某种形式的错误消息，通常带有有用的诊断信息。
- en: This can be triggered far too easily by typing errors involving pointers or
    by poor pointer arithmetic. A common C typo causing a *segfault* is `scanf("%d",
    number);`. The missing `&` before `number` makes `scanf` try to write into the
    memory location referenced by the (garbage) contents of `number`, and *poof*—the
    program disappears in a wisp of smoke. If you're really unlucky, though, `number`
    happens to hold a value that equates to a valid memory address. Now your code
    will continue as if nothing is wrong, until the memory you just wrote over is
    used and your fate is in the lap of the gods.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过涉及指针的打字错误或糟糕的指针算术轻易触发。一个常见的导致*段错误*的C语言打字错误是`scanf("%d", number);`。在`number`之前缺少`&`使得`scanf`试图将数据写入由（垃圾）内容引用的内存位置，然后——噗——程序在一缕烟雾中消失。如果你真的很不幸，那么`number`恰好持有等于有效内存地址的值。现在你的代码将继续像什么都没发生一样运行，直到你刚刚覆盖的内存被使用，你的命运就掌握在上帝手中。
- en: '**Memory overruns**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存越界**'
- en: These are caused by writing past memory that has been allocated for your data
    structure, be it an array, a vector, or some other custom construct. When writing
    values into the wide blue yonder, you'll probably clobber the data in some other
    part your program. If you're running on an unprotected operating system (more
    common in embedded environments), you may even tamper with data from another process
    or the OS itself. Ouch.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误是由于写入了为你的数据结构分配的内存之外的区域，无论是数组、向量还是其他自定义结构。当你将值写入广阔的蓝色空间时，你可能会破坏程序其他部分的数据。如果你运行在一个未受保护的操作系统上（在嵌入式环境中更为常见），你甚至可能会篡改另一个进程或操作系统的数据。哎呀。
- en: Memory overrun is a common problem and difficult to detect; usually the symptom
    is random unexpected behavior manifesting at a much later point than the overrun,
    possibly many thousands of instructions later. If you're lucky, the memory overrun
    hits an invalid memory address and you get a segfault, which is hard to ignore.
    Use safe data structures wherever possible to insulate yourself from the possibility
    of such disaster.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 内存越界是一个常见问题，难以检测；通常的症状是在越界发生很久之后出现的随机意外行为，可能是在成千上万条指令之后。如果你很幸运，内存越界击中了无效的内存地址，你会得到一个段错误，这是很难忽视的。尽可能使用安全的数据结构来保护自己，避免这种灾难的可能性。
- en: '**Memory leaks**'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存泄漏**'
- en: These are constant threats in languages that do not have garbage collection.^([[4](#ftn.CHP-9-FN-4)])
    When you want some memory, you have to ask the run time for it nicely (using `malloc`
    in C or `new` in C++). Then you have to be polite and give it back when you're
    done (using `free` and `delete`, respectively). If you rudely forget to release
    memory, your program slowly consumes more and more of the computer's scarce resources.
    You may not notice it at first, but your computer's response will gradually degrade
    as memory pages thrash to and from the disk.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是那些没有垃圾回收机制的语言中的常见威胁。[^4](#ftn.CHP-9-FN-4) 当你需要内存时，你必须礼貌地向运行时请求（在C中使用`malloc`或在C++中使用`new`）。然后你必须有礼貌地在使用完毕后归还（分别使用`free`和`delete`）。如果你粗心大意地忘记了释放内存，你的程序会逐渐消耗越来越多的计算机稀缺资源。一开始你可能不会注意到，但随着内存页面在磁盘之间来回移动，你的计算机的响应速度会逐渐下降。
- en: 'Two other classes of error relate to this: freeing a memory block *too many*
    times, causing unpredictable environmental failures, and not managing other scarce
    resources carefully, such as file handles or network connections. (Remember: Anything
    you manually acquire must be manually released.)'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的其他两类错误：释放内存块**过多**次，导致不可预测的环境故障，以及未能仔细管理其他稀缺资源，例如文件句柄或网络连接。（记住：任何你手动获取的东西都必须手动释放。）
- en: '**Running out of memory**'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存耗尽**'
- en: This is always a possibility, as is running out of file handles or any other
    managed resource. It might be rare (modern computers have so much memory, how
    could this possibly happen?), but that's no excuse to ignore the potential for
    failure. Only sloppy code fails to make appropriate checks, and it will consequently
    perform in a very brittle manner when run in constrained situations. For this
    reason, you should always validate the return status of a memory allocation or
    filesystem call.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 这始终是一个可能性，就像耗尽文件句柄或任何其他受管理资源一样。这可能很少见（现代计算机有如此多的内存，这种情况怎么可能发生？），但这不能成为忽视失败可能性的借口。只有马虎的代码才会失败，并且当在受限情况下运行时，它将表现出非常脆弱的行为。因此，你应该始终验证内存分配或文件系统调用的返回状态。
- en: Some operating systems *never* return failure from a memory allocation call—every
    allocation returns a pointer to a reserved but unallocated memory page. When the
    program eventually tries to access this page, an OS mechanism traps the access
    and then really allocates memory to the page, resuming normal program operation.
    This all works nicely until the available memory is finally exhausted. Your program
    will then be sent error signals—a long time after the relevant allocation occurred.^([[5](#ftn.CHP-9-FN-5)])
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作系统**从不**从内存分配调用返回失败——每个分配都返回一个指向已保留但未分配的内存页面的指针。当程序最终尝试访问这个页面时，操作系统机制会拦截访问，然后真正为该页面分配内存，恢复正常的程序操作。这一切都进行得很好，直到可用的内存最终耗尽。然后你的程序将收到错误信号——在相关分配发生很长时间之后。[^5](#ftn.CHP-9-FN-5)
- en: '**Math errors**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学错误**'
- en: 'These errors come in a number of guises: floating-point exceptions, incorrect
    mathematical constructions, overflow/underflow, or expressions that may fail (for
    example, divide by zero). Even trying to output a `float` but passing an `int`
    through `printf("%f")` can cause your program to bomb with a maths error.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误以多种形式出现：浮点异常、不正确的数学构造、溢出/下溢，或者可能失败的表达式（例如，除以零）。甚至尝试输出一个`float`，但通过`printf("%f")`传递一个`int`，也可能导致你的程序因数学错误而崩溃。
- en: '**Program hangs**'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序挂起**'
- en: These are usually caused by bad program logic; infinite loops with badly crafted
    terminal cases are the most common. We also see deadlock and race conditions in
    threaded code, and event-driven code waiting on events that will never occur.
    However, it is usually fairly easy to interrupt the running program, see where
    the code has stalled, and determine the cause of the hang.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题通常是由不良的程序逻辑引起的；最常见的是设计不当的终端情况导致的无限循环。在多线程代码中，我们也会看到死锁和竞态条件，以及等待永远不会发生的事件的事件驱动代码。然而，通常很容易中断正在运行的程序，查看代码卡住的地方，并确定挂起的原因。
- en: Different OSes, languages, and environments report these errors in different
    ways, using different terminology. Some languages avoid whole classes of errors
    by not providing features you can shoot yourself in the foot with. Java, for example,
    has no pointers, and it automatically checks every memory access you make.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作系统、语言和环境以不同的方式报告这些错误，使用不同的术语。一些语言通过不提供可能导致自己受伤的功能来避免整个类别的错误。例如，Java没有指针，并且它会自动检查你进行的每一次内存访问。
- en: '* * *'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-9-FN-1)]) Provided you have a sane build environment that stops
    when it encounters an error and provides some reasonable diagnostic messages.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-9-FN-1)]) 假设你有一个合理的构建环境，当遇到错误时会停止，并提供一些合理的诊断信息。
- en: ^([[2](#CHP-9-FN-2)]) This presumes that you trust your `build clean` facility.
    To be really thorough, delete the entire project and check it back out again afresh.
    Alternatively, manually remove all intermediate object files, libraries, and executables.
    For large projects, both options are extremely tedious. *C'est la vie*.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-9-FN-2)]) 这假设你信任你的`build clean`功能。为了真正彻底，删除整个项目并重新检出。或者，手动删除所有中间对象文件、库和可执行文件。对于大型项目，这两种选择都非常繁琐。*这就是生活*。
- en: ^([[3](#CHP-9-FN-3)]) You can't do this meaningfully; floating point arithmetic
    is too approximate to offer an exact comparison that indicates anything.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-9-FN-3)]) 你无法有意义地做到这一点；浮点运算太近似，无法提供任何指示的精确比较。
- en: ^([[4](#CHP-9-FN-4)]) It is also possible to leak memory in a language with
    garbage collection. Hand two object references to one another, and then let go
    of them both. Unless you have an advanced garbage collector, they will never be
    swept up.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-9-FN-4)]) 在具有垃圾回收机制的语言中，也有可能发生内存泄漏。将两个对象引用相互传递，然后同时释放它们。除非你有一个高级的垃圾回收器，否则它们将永远不会被清理。
- en: ^([[5](#CHP-9-FN-5)]) This is certainly the case for Linux, at least until you
    exhaust the virtual memory address space. At this point, `malloc` may return 0,
    but the system would probably have keeled over before you got a chance to notice.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-9-FN-5)]) 至少在耗尽虚拟内存地址空间之前，这对于Linux来说肯定是正确的。在这种情况下，`malloc`可能会返回0，但系统在你有机会注意到之前可能已经崩溃了。
- en: Pest Extermination
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消灭害虫
- en: 'Weeding out bugs in your software is hard. You have to discover a bug, diagnose
    the problem, eradicate all traces of the unwanted behavior, make sure the bug
    hasn''t bred elsewhere, and try not to break the code while you''re doing all
    of it. The first step alone, finding a fault, is a major hassle: Humans make mistakes
    when writing, but they make just as many mistakes when reading. When looking over
    my prose or my code, I''ll naturally read what I *meant* to write and not what
    I *really* wrote. Faulty code isn''t obvious. The compiler isn''t much help; in
    fact it''s really quite pedantic. It can only produce *exactly* what you asked,
    not what you were hoping for.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的软件中清除错误是困难的。你必须发现一个错误，诊断问题，消除所有不希望的行为的痕迹，确保错误没有在其他地方繁殖，并且在执行所有这些操作时尽量不要破坏代码。仅第一步，找到错误，就是一个大麻烦：人类在写作时会犯错误，但在阅读时也会犯同样的错误。当检查我的散文或我的代码时，我会自然地阅读我*打算*写的，而不是我*真正*写的。有缺陷的代码并不明显。编译器并没有多大帮助；事实上，它非常挑剔。它只能产生*确切*你所要求的结果，而不是你所希望的结果。
- en: Some programmers introduce far fewer faults than their peers (up to 60 percent
    less), can find and fix faults quicker (in as little as 35 percent of the time),
    and introduce fewer faults as they do so. (Gould 75) How do they do it? They are
    naturally able to pay more attention to the task and can focus on the microscopic
    level of the code they're writing, while still keeping the broader picture in
    mind.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员引入的错误比他们的同行少得多（多达60%），可以更快地找到和修复错误（仅需35%的时间），并且在这样做时引入的错误也更少。（Gould 75）他们是如何做到这一点的呢？他们天生就能更加专注于任务，并且能够关注他们所编写的代码的微观层面，同时仍然保持对整体图景的关注。
- en: This is the *art* of debugging; it's very much a skill to be learned. Experience
    teaches you how to become an effective debugger. And this is something that we
    *will* all get plenty of experience doing.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是调试的艺术；它是一个非常需要学习的技能。经验教会你如何成为一个有效的调试者。而且，这是我们都会有很多经验去做的事情。
- en: 'The single most important rule when debugging is this: *Use your brain*. Think.
    Consider what you''re doing. Don''t flail around, thoughtlessly hacking at bits
    of code until something appears to work.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 调试时最重要的规则是：*用你的大脑*。思考。考虑你在做什么。不要盲目地乱砍代码，直到看起来有东西能工作。
- en: '**KEY CONCEPT**'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Always follow the golden rule of debugging:Use your brain*.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '*始终遵循调试的金科玉律：用你的大脑*。'
- en: 'There are two paths to pest extermination: the quicky-and-dirty *low road*
    and the theologically correct *high road*. We must be aware of them both; sometimes
    the low road looks like a good shortcut but will actually be slower, and sometimes
    the high road takes more effort to follow than is genuinely required.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 消灭害虫有两条路：一条是快速而粗糙的*低效之路*，另一条是神学上正确的*高效之路*。我们必须意识到它们两者；有时低效之路看起来像是一个很好的捷径，但实际上会更慢，有时高效之路需要更多的努力去遵循，而实际上并不需要那么多。
- en: The Low Road
  id: totrans-736
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低效之路
- en: The bug is really simple. The cause is obvious. You don't need to think too
    much about it, do you? Sometimes a quick tweak *will* achieve results; a few simple
    tests can pinpoint a problem quickly. So is it a justifiable thing to do? Perhaps,
    but don't fall into the trap of believing it will work every time. Too many programmers
    try to fix faults by tinkering, fiddling, poking, and prodding the code without
    any real thought about what they're doing. What happens is rarely anything useful—they
    just mask the original problem behind a myriad of other faults.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 错误实际上很简单。原因很明显。你不需要太多思考，对吧？有时快速调整*确实*能取得效果；几个简单的测试可以快速定位问题。所以这样做是合理的吗？也许吧，但不要陷入认为它每次都会奏效的陷阱。太多的程序员试图通过摆弄、调整、戳戳和捅捅代码来修复错误，而没有真正思考他们在做什么。结果很少是有用的——他们只是用无数的其他错误掩盖了原始问题。
- en: If you do make the conscious decision to do some quick-and-dirty stabbing around,
    set yourself a firm time limit to do it in. Don't spend an entire morning with
    the "just one more try" approach. After your time limit is up, follow the more
    methodical approach laid out here.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实决定做一些快速而粗糙的试探，为自己设定一个明确的时间限制。不要整个早上都花在“再试一次”的方法上。时间限制一到，就遵循这里提出的更系统的方法。
- en: '**KEY CONCEPT**'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Set a reasonable time limit for "unstructured" debugging, and then resort
    to more methodical approaches if you don''t find success*.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '*为“无结构”调试设定一个合理的时间限制，如果你没有成功，就转而采用更系统的方法*。'
- en: If your guesswork turns up trumps and you do find the fault, reengage your thinking
    gear. Look at "[How to Fix Faults](ch09s05.html "How to Fix Faults")" on page
    167, and make the change carefully and thoughtfully. Even if the fault was easy
    to find, the fix isn't necessarily as obvious.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的猜测奏效，并且你确实找到了错误，重新启动你的思考机制。查看第167页的“[如何修复错误](ch09s05.html "How to Fix Faults")”，并仔细、周到地进行更改。即使错误很容易找到，修复方法也不一定那么明显。
- en: The High Road
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效之路
- en: 'A better debugging technique is more methodical and considered. It recognizes
    that there are two distinct facets to removing a bug: *finding* the fault that
    caused it and *fixing* that fault.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的调试技术更加有系统和深思熟虑。它认识到消除错误有两个不同的方面：*找到*导致错误的原因和*修复*这个错误。
- en: 'Each presents its own challenges to overcome and problems to solve. It''s very
    easy to forget the latter part and to presume that once you''ve found a fault,
    it will be easy and obvious to fix. Don''t believe it. I''ll cover both aspects
    in depth in later sections, and I''ll outline a sensible approach to the task.
    But first, a few key principles govern the debugging game:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都提出了需要克服的挑战和需要解决的问题。很容易忘记后者，并假设一旦你找到了错误，修复它就会很容易且明显。不要相信这一点。我将在后面的章节中深入探讨这两个方面，并概述一个合理的任务方法。但首先，一些关键原则支配着调试游戏：
- en: How difficult a fault is to find depends on how well you know the code it's
    lurking in. It's hard to jump into some random source and make any kind of judgment
    about it without knowing the structure and how it's supposed to work. For this
    reason, if you have to debug some new code, take time to learn about it first.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的难度取决于你对隐藏在其中的代码了解多少。在不了解结构和它应该如何工作的情况下，跳入某个随机的源代码并对其做出任何判断是很困难的。因此，如果你必须调试一些新的代码，先花时间了解它。
- en: '**key-concept**'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: Learn the code you're debugging—you can't expect to find errors in code you
    don't understand.
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学习你正在调试的代码——你不能期望在你不理解的代码中找到错误。
- en: Ease of debugging is also dependent on the control you have over the execution
    environment—how much you can play around with the running program and inspect
    its state. In an embedded world, debugging can be much harder because the tool
    support is more sparse. You're also probably running in an environment that is
    providing a lot less insulation from your own stupidity; little mistakes can have
    much bigger consequences.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试的容易程度也取决于你对执行环境的控制——你可以对运行中的程序进行多少操作并检查其状态。在嵌入式世界中，调试可能更困难，因为工具支持更稀疏。你也在一个可能为你提供很少绝缘的环境下运行；小小的错误可能产生更大的后果。
- en: One of the most potent weapons in our debugging arsenal is a distrust of anyone's
    code mixed with a healthy dose of cynicism. The cause of your errant behavior
    could be absolutely anything, and in the act of diagnosis, you should start by
    eliminating even the most unlikely of candidates.
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调试工具中最有力的武器之一是对任何人的代码的不信任，加上适量的悲观主义。你错误行为的原因可能是绝对任何事情，在诊断过程中，你应该首先排除最不可能的候选者。
- en: '**KEY CONCEPT**'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*When you look for a fault, suspect everything. Eliminate even the unlikeliest
    of causes first, rather than presume they have nothing to do with it. Assume nothing*.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你寻找故障时，怀疑一切。首先排除最不可能的原因，而不是假设它们与此无关。不要假设任何事*。'
- en: Bug Hunting
  id: totrans-752
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕虫
- en: How do you find bugs? If there was a simple three-step process, we'd all have
    learned it, and our programs would be perfect by now. As it is, there isn't, and
    they aren't. Let's try to distill the available bug-hunting wisdom.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何找到错误？如果有一个简单的三步过程，我们都会学到它，我们的程序现在就会完美无缺。实际上，没有，它们也不是。让我们尝试提炼可用的捕虫智慧。
- en: Compile-Time Errors
  id: totrans-754
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时错误
- en: We'll look at these first, since they are comparatively easy to deal with. When
    your compiler comes across something unpleasant, it will not normally just complain
    once, but will take the opportunity to sound off about life in general, spitting
    out a barrage of subsequent error messages. It's been told to do this; upon encountering
    any error, the compiler tries to pick itself back up and carry on parsing away.
    It rarely manages very well, but with code like yours, who could blame it?
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看这些，因为它们相对容易处理。当你的编译器遇到不愉快的事情时，它通常不会只抱怨一次，而是会抓住机会对生活本身发表意见，吐出一连串后续的错误信息。它被告知这样做；在遇到任何错误时，编译器试图自己恢复并继续解析。它很少做得很好，但像你的代码这样的，谁能责怪它呢？
- en: The upshot is that the later compiler messages can be quite random and irrelevant.
    You only need to look at the very *first* error reported and sort out that problem.
    Have a glance farther down the list by all means; there may be some other useful
    errors there, but often there aren't.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，后来的编译器消息可能相当随机且不相关。你只需要查看报告的第一个错误并解决该问题。当然，你可以向下查看列表；那里可能还有一些其他有用的错误，但通常没有。
- en: '**CASE STUDY #1: PICTURE THIS**'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例研究 #1：想象一下**'
- en: '**The program**'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序**'
- en: A reasonably small utility with graphical interface.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有图形界面的合理小巧的实用程序。
- en: '**The problem**'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: The program was redesigned with an updated "look and feel"—new icons and a new
    layout. The old interface was intended to remain available as a configurable option.
    During redevelopment, everything worked fine until just before release, when someone
    tried to use the legacy interface. The program crashed just as a window was appearing
    but before you had a chance to see it fully.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 程序经过重新设计，采用了更新的“外观和感觉”——新的图标和布局。旧的界面旨在作为可配置选项保留。在重新开发过程中，一切工作正常，直到发布前，有人尝试使用旧版界面。程序在窗口出现之前崩溃，但你还没有机会完全看到它。
- en: '**The story**'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '**故事**'
- en: Thankfully, this was a nicely repeatable problem. The program was fired up in
    a debugger, and the point of failure was determined to be deep within the UI library
    in some image-rendering code.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是一个很好地可重复的问题。程序在调试器中运行，失败点被确定在UI库中的某些图像渲染代码深处。
- en: On investigation, it seemed the failure was due to an invalid graphic being
    used. The program was trying to display an icon at memory location zero; a null
    pointer was causing the crash. We traced back up the call stack to see which graphic
    should have appeared. Armed with this information, a brief look at the legacy
    graphics directory showed that this particular icon was missing.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 经过调查，似乎失败是由于使用了无效的图形。程序试图在内存位置零处显示一个图标；一个空指针导致了崩溃。我们沿着调用堆栈向上追踪，以查看应该出现哪个图形。有了这些信息，简要查看遗留图形目录就显示，这个特定的图标缺失。
- en: 'The icon load operation in the window''s constructor had obviously failed,
    returning a zero pointer value to signify "No icon loaded." This return value
    was never checked—the author assumed that the graphic would always be present.
    The fix would be twofold:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口构造函数中的图标加载操作显然失败了，返回一个零指针值表示“没有加载图标”。这个返回值从未被检查——作者假设图形始终存在。修复将包括两个方面：
- en: Check the return values of all icon load routines so they deal with any other
    missing graphics more gracefully.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有图标加载例程的返回值，以确保它们能够更优雅地处理任何其他缺失的图形。
- en: Place the missing graphic in the correct directory.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将缺失的图形放在正确的目录中。
- en: '**Time to fix**'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '**修复时间**'
- en: A few hours to trace the problem, fix the fault, and verify the repair.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 几个小时来追踪问题、修复故障并验证修复。
- en: '**Lessons learned**'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '**经验教训**'
- en: Check *all* function return codes, even the ones you don't think will fail.
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有函数返回代码，即使你认为它们不会失败。
- en: Test all program functionality as soon as possible, especially the rare conditions
    that won't be used very often.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快测试所有程序功能，特别是那些不太经常使用的罕见条件。
- en: '**KEY CONCEPT**'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*When your build fails, look at the* first *compiler error. Trust this far
    more than the subsequent messages*.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你的构建失败时，请查看第一个* 编译器错误。比后续的消息更信任这一点。'
- en: Even this first compiler error may be cryptic or misleading, depending on the
    quality of the compiler (if you're really stumped by what an error means, try
    using another compiler). Hardcore C++ template code can provoke quite inspired
    errors from some compilers—listing reams and reams of mystical template incantations.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是第一个编译器错误也可能很神秘或误导，这取决于编译器的质量（如果你对错误的意义感到困惑，尝试使用另一个编译器）。硬核C++模板代码可能会从某些编译器那里引发相当有启发的错误——列出大量神秘的模板咒语。
- en: The syntax error usually *is* on the line that the compiler reports, but sometimes
    it may actually be on the *preceding* line—a syntax error there causes the following
    line to be nonsensical; this is what the compiler notices and moans about.^([[6](#ftn.CHP-9-FN-6)])
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误通常*确实*在编译器报告的行上，但有时它实际上可能在*前面的*行上——那里的语法错误导致下一行变得无意义；这就是编译器注意到并抱怨的地方。[^6](#ftn.CHP-9-FN-6)
- en: Linker errors, on the whole, are far less cryptic. The linker will tell you
    that it's missing a function or a library, so you'd better scurry off and find
    it (or write it). Sometimes the linker may complain about arcane v-table related
    C++ problems; this is usually a symptom of a missing destructor implementation
    or something similar.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器错误总体上不太神秘。链接器会告诉你它缺少一个函数或库，所以你最好赶紧去找（或者编写它）。有时链接器可能会抱怨一些神秘的v-table相关的C++问题；这通常是一个缺少析构函数实现或类似问题的症状。
- en: Run-Time Errors
  id: totrans-778
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时错误
- en: Run-time errors require more of a game plan. If your program contains a bug,
    then it's likely that a condition somewhere in the code that you believed to be
    true isn't. Finding the bug is a process of confirming what you think is correct
    until you find the place where that condition doesn't hold. You have to develop
    a model of how the code really works and compare this with how you'd intended
    it to work. Doing this methodically is the only sensible way.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时错误需要更多的计划。如果你的程序中存在一个错误，那么很可能代码中某个你认为为真的条件实际上不是。找到错误是一个确认你认为正确的过程，直到你找到那个条件不成立的地方。你必须开发一个关于代码真正如何工作的模型，并将其与你的意图进行比较。有系统地这样做是唯一合理的办法。
- en: '**KEY CONCEPT**'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Debugging is a methodical activity, slowly closing in on the location of a
    fault. Don''t treat it like a simple guessing game*.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试是一种有系统的活动，缓慢地接近故障的位置。不要把它当作一个简单的猜测游戏*。'
- en: 'The *scientific method* is the process scientists use to develop an accurate
    representation of the world. That sounds akin to what we are trying to do, right?
    There are four steps to the scientific method:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '**科学方法**是科学家用来开发世界准确表示的过程。这听起来就像我们正在尝试做的事情，对吧？科学方法有四个步骤：'
- en: Observe a phenomenon.
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察一个现象。
- en: Form a hypothesis to explain it.
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 形成一个假设来解释它。
- en: Use this hypothesis to predict the results of further observations.
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个假设来预测进一步观察的结果。
- en: Perform experiments to test these predications.
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行实验以测试这些预测。
- en: Although we're trying to *get rid of* the errant phenomenon rather than build
    a model of it, we need to understand a fault to truly fix it. The scientific method
    is a good debugging backbone, and you'll see it reflected in the steps below.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们试图**消除**异常现象而不是建立其模型，但为了真正修复它，我们需要了解故障。科学方法是良好的调试基础，你将在下面的步骤中看到它的体现。
- en: Identify a Failure
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别故障
- en: It all starts here, when you notice that the program doesn't do what it's supposed
    to do. It may crash or it may produce a yellow triangle instead of a blue square,
    but you know something's up, and you've got to fix it. The first thing to do is
    put a fault report into the fault database (see "[Fault-Tracking System](ch08s09.html#fault-tracking_system
    "Fault-Tracking System")" on page 147). This is particularly valuable if you're
    in the middle of tracking some other bug or don't have time to handle the fault
    right away. Making a record ensures that the fault won't get lost. Don't just
    make a mental note to come back to a problem later—you'll forget.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都从这里开始，当你注意到程序没有做它应该做的事情时。它可能崩溃，或者它可能显示黄色三角形而不是蓝色正方形，但你知道有问题，你必须修复它。首先要做的事情是将故障报告放入故障数据库（参见第147页的"[故障跟踪系统](ch08s09.html#fault-tracking_system
    "Fault-Tracking System")"）。如果你正在跟踪其他错误或没有时间立即处理故障，这尤其有价值。记录确保故障不会丢失。不要只是心理上记下稍后回来处理问题——你会忘记。
- en: 'Before you rush on and try to find a bug you''ve stumbled across, identify
    the nature of the errant behavior. Characterize the problem as completely as possible
    by answering questions like: Is it timing sensitive? and Does it depend on input,
    system load, or program state? If you don''t understand the bug before you try
    to fix it, you''ll just be changing code until the symptom disappears. You may
    only have masked a cause, so the same fault will crop up elsewhere.'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在你急忙寻找你偶然发现的错误之前，确定异常行为的特点。通过回答诸如：它是否对时间敏感？以及它是否依赖于输入、系统负载或程序状态？等问题尽可能完整地描述问题。在你尝试修复错误之前，如果你不理解错误，你只会不断更改代码直到症状消失。你可能只是掩盖了原因，所以同样的故障会在其他地方再次出现。
- en: Did the code work before? Skip back through your revision control system to
    find the last working version, and compare that working code with this faulty
    revision.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 代码之前是否工作过？通过版本控制系统回溯到最后一个工作版本，并将该工作代码与这个有缺陷的修订版进行比较。
- en: Reproduce It
  id: totrans-792
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新复制它
- en: This goes alongside characterizing the failure. Work out the set of steps you
    must take to reliably trigger the problem. If there is more than one way, then
    document them all.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这与描述故障是一致的。制定出必须采取的一系列步骤来可靠地触发问题。如果有多种方式，则记录下来所有这些方式。
- en: '**KEY CONCEPT**'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*The first step to locating a fault is finding out how to reproduce it reliably*.'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '**定位故障的第一步是找出如何可靠地重新复制它**。'
- en: You have a problem if the bug doesn't seem reproducible; the best you can do
    is set up mousetraps and see what information you can find out when it does occur.
    For these unreliable failures, keep careful notes of the information you collect;
    it may be a while until you see the problem crop up again.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误似乎无法重现，你将遇到问题；你能做的最好的事情是设置陷阱并看看当它发生时你能找到什么信息。对于这些不可靠的故障，仔细记录你收集到的信息；可能要过一段时间问题才会再次出现。
- en: Locate the Fault
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位故障
- en: This is the big one. You've got the scent; now you need to use what you've learned
    to track the beast and pinpoint its location. That is far more easily said than
    done. This is a process of eliminating all the things that don't contribute to
    the failure or can be shown to work correctly, Sherlock Holmes style. As you progress,
    you will find that you need to gather more and more information—the more answers
    you get, the more questions that arise. You may need to draft some new tests.
    You may need to poke around in the seedy underbelly of the code.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键的一步。你已经找到了线索；现在你需要利用你所学的知识来追踪这个怪物并确定其位置。这比说起来容易做起来难。这是一个排除所有不导致故障或可以证明其正确性的东西的过程，就像福尔摩斯一样。随着你的进展，你会发现你需要收集越来越多的信息——你得到的答案越多，提出的问题就越多。你可能需要制定一些新的测试。你可能需要探索代码的阴暗面。
- en: Analyze what you have learned about the failure. Without jumping to conclusions,
    draw up a list of code suspects. See if you can spot patterns of events that hint
    at causes. If possible, keep a record of the inputs and outputs that demonstrate
    the problem.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 分析你关于失败所了解的内容。不要急于下结论，列出代码嫌疑名单。看看你是否能发现事件模式，这些模式暗示了原因。如果可能的话，记录下输入和输出，以证明问题。
- en: 'A good starting point for the investigation is where the error *manifests*
    itself—although this is rarely the actual habitat of the fault. Remember: Just
    because a failure exhibits itself in one module, it doesn''t necessarily mean
    *that* module is to blame. Determining this location is easy if the program crashed;
    a debugger will tell you the line of code that failed, the value of all variables
    at that point, and who called this function. In the absence of a crash, start
    from a point you know exhibits incorrect behavior. Work backward from there, following
    the flow of control, checking that the code is doing what you expect it to at
    each point.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 调查的起点是错误**表现**的地方——尽管这很少是故障的实际栖息地。记住：仅仅因为一个失败在一个模块中表现出来，并不意味着**那个**模块就是罪魁祸首。如果程序崩溃了，确定这个位置很容易；调试器会告诉你失败的代码行，那个点的所有变量的值，以及谁调用了这个函数。如果没有崩溃，从一个你知道表现出错误行为的地方开始。从那里回溯，遵循控制流，检查代码在每个点上是否做了你期望它做的事情。
- en: '**KEY CONCEPT**'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Start from what you know—the point of a program crash, for example. Then work
    back from there to the cause of the failure*.'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '*从你所知道的地方开始——比如程序崩溃的点。然后从那里回溯到失败的原因*。'
- en: 'There are a few common bug-hunting strategies:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种常见的错误查找策略：
- en: The worst thing to do is randomly change things to see if the failure goes away.
    This is an immature approach. (A professional will at least try to make it look
    scientific!)
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最糟糕的事情是随机更改东西，看看失败是否消失。这是一个不成熟的方法。（专业人士至少会尝试让它看起来科学！）
- en: A far better strategy is to *divide and conquer*. Say you have the fault pinned
    down to a single function that consists of 20 steps. After the 10th step, print
    out the intermediate result, or set a breakpoint and investigate it in your debugger.
    If the value is good, then the fault lies in the instructions after this; otherwise,
    it's in the instructions before. Concentrate on those instructions and repeat
    until you've cornered the fault.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更好的策略是**分而治之**。比如说，你把故障锁定在一个由20个步骤组成的单一函数中。在第10步之后，打印出中间结果，或者设置一个断点并在你的调试器中调查它。如果值是好的，那么故障就在这个指令之后；否则，就在之前的指令中。集中精力在这些指令上，重复操作，直到你找到了故障。
- en: Another technique is the *dry run* method. Rather than relying on intuition
    to locate the error, you play the role of the computer, tracing program execution
    through a trial run, calculating all intermediate values to get the final result.
    If your result and reality don't match, then you know a fault lies in the code—it's
    not doing what you expect it to. Although it is time consuming, this can be very
    effective because it highlights your bad assumptions.
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种技术是**干运行**方法。而不是依赖直觉来定位错误，你扮演计算机的角色，通过试运行跟踪程序执行，计算所有中间值以得到最终结果。如果你的结果和现实不符，那么你知道代码中存在故障——它没有做你期望它做的事情。虽然这很耗时，但这种方法可以非常有效，因为它突出了你的错误假设。
- en: Understand the Problem
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: Once you've found out where the fault is lurking, you've got to understand the
    *real* problem. If it's a simple syntactic error, such as using `=` instead of
    `==` (*d'oh!*), then the implications aren't too nasty. For more complex semantic
    problems, make sure you really know what the problem is and all the ways that
    it may manifest itself before you move on—you may have only found a part of the
    problem.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了故障潜伏的地方，你必须理解**真正的**问题。如果它是一个简单的语法错误，比如使用`=`而不是`==`（*哎呀!*），那么影响并不太严重。对于更复杂的语义问题，在你继续之前，确保你真正知道问题是什么以及它可能以何种方式表现出来——你可能只找到了问题的一部分。
- en: 'Often the fault is very subtle: The code will be doing exactly what it should
    do *and* what you thought it was supposed to do when you wrote it! The problem
    is a flawed assumption (remember how evil these are?). A function''s writer and
    caller can easily presume that different behavior is acceptable in particular
    strange cases. Trace back and understand exactly what the cause of the problem
    is and whether or not any other bits of code may contain the same mistake.'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 通常故障非常微妙：代码将做它应该做的事情 *并且* 当你编写它时你认为它应该做的事情！问题是存在一个有缺陷的假设（还记得这些有多邪恶吗？）。一个函数的编写者和调用者可以轻易地假设在特定奇怪的情况下不同的行为是可以接受的。回溯并确切了解问题的原因，以及是否有其他代码片段可能包含相同的错误。
- en: '**KEY CONCEPT**'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Once you think you''ve found the cause of a bug, investigate it thoroughly
    to prove that you are right. Don''t blindly accept your first hypothesis*.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦你认为你已经找到了一个错误的根源，就要彻底调查以证明你是正确的。不要盲目接受你的第一个假设*。'
- en: This is a key principle in the fight against bugs. Otherwise, you'll join the
    ranks of the programmers who introduce *more* faults than they fix with every
    bit of repair work.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与虫害作斗争的一个关键原则。否则，你将加入那些在每次修复工作中引入*更多*故障而不是修复故障的程序员行列。
- en: Create a Test
  id: totrans-813
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个测试
- en: Write a test case to demonstrate the failure. You may have done this in the
    "Reproduce It" step if you were clever. If you didn't, then you really want to
    write one now. With your new understanding, make sure the test is rigorous.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个测试用例来演示失败。如果你足够聪明，你可能在“重现它”步骤中已经做了这件事。如果没有，那么你现在真的需要写一个。利用你的新理解，确保测试是严格的。
- en: Fix the Fault
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复故障
- en: 'And now the easy part: You''ve just got to fix the darned thing! This *should*
    actually be the easy part—you understand exactly why the faliure occurs, and you''ve
    got a reproducible way to excerise it. Given that depth of information, the fix
    is usually child''s play. Most programmers find bug fixing hard because they skip
    the first two steps.'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是容易的部分了：你只需要修复这个该死的东西！这实际上应该是容易的部分——你完全理解为什么会出现故障，并且你有一个可复现的方式来练习它。鉴于这些信息，修复通常是小菜一碟。大多数程序员发现修复故障很难，因为他们跳过了前两个步骤。
- en: We'll look at fixing faults in more detail in the following section.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节更详细地探讨如何修复故障。
- en: Prove You've Fixed It
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 证明你已经修复了它
- en: Now you know why you wrote a test case. Run it again, and prove the world is
    a better place. The test case can be added to your regression test suite to ensure
    that the fault is never reintroduced at a later point.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道为什么你需要编写测试用例了。再次运行它，证明世界变得更美好。这个测试用例可以添加到你的回归测试套件中，以确保故障永远不会在以后的某个时刻再次引入。
- en: '**KEY CONCEPT**'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*You haven''t finished debugging until you''ve proved that the problem''s been
    fixed and has gone away for good*.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还没有完成调试，直到你已经证明问题已经被修复，并且永远消失了*。'
- en: That's it! Game over—mission accomplished. Well done. However . . .
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！游戏结束——任务完成。做得好。然而……
- en: If All Else Fails
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果所有其他方法都失败了
- en: Sometimes you try all of this but it just doesn't work; you're left wailing
    and gnashing your teeth, with a sore head from banging it against a brick wall
    for too long. When things get this bad, I always find it helps to explain the
    whole problem to someone else. Somewhere in the description, everything seems
    to slip into place and I see the one key piece of information I had been missing
    all along. Try it and see. This is one reason why *pair programming* is such a
    successful strategy.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你尝试了所有这些方法，但就是不起作用；你只能哭泣和咬牙切齿，因为你的头因为长时间撞击砖墙而疼痛。当事情变得如此糟糕时，我发现向别人解释整个问题总是有帮助的。在描述的某个地方，一切似乎都变得清晰起来，我看到了我一直以来一直缺少的关键信息。试试看。这就是为什么*结对编程*是一种如此成功的策略的原因之一。
- en: '* * *'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[6](#CHP-9-FN-6)]) C++ has a great party trick here: The preceeding line
    might be in a different file! If you forget the `;` at the end of your class declaration
    in a header file, the first line of the implementation file makes no sense. The
    compiler gives you a very crytpic error.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-9-FN-6)]) C++ 在这里有一个很棒的技巧：前面的行可能位于不同的文件中！如果你忘记在头文件中类声明的末尾添加 `;`，实现文件的第一行就没有意义了。编译器会给你一个非常隐晦的错误。
- en: How to Fix Faults
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何修复故障
- en: You'll notice that this section is much smaller than the preceding one. Funny.
    Usually the whole problem is *finding* the darned fault. Once you've worked out
    where it is, then the fix is obvious.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个部分比前面的部分小得多。有趣的是。通常整个问题在于*找到*这个该死的故障。一旦你找到了它，修复方法就显而易见了。
- en: But don't let that lure you into a false sense of security. Don't stop thinking
    once you've diagnosed the source of your errant behavior. It's very important
    not to break anything else as you make the fix—it's surprisingly easy to trample
    over something in the flower bed as you stroll over to pluck out a weed.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要让这让你产生错误的安心感。一旦你诊断出错误行为的原因，不要停止思考。在修复过程中，非常重要的一点是不要破坏其他任何东西——在去拔草的时候，意外踩到花坛上的东西是出乎意料的容易。
- en: '**KEY CONCEPT**'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Fix bugs with the utmost care. Don''t risk breaking anything else with your
    modification*.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '*修复错误时务必小心。不要因为你的修改而破坏其他任何东西*。'
- en: As you modify code, always ask yourself, *What are the consequences of this
    change?* Be aware of whether the fix is isolated to a single statement or if it
    affects other surrounding bits of code. Might the effect of your change ripple
    out to any code that calls this function; does it subtly alter the behavior of
    the function?
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改代码时，始终问自己，*这个变化的后果是什么？* 注意修复是否仅限于单个语句，或者它是否影响了周围的代码。你的变化是否会影响调用此函数的任何代码；它是否微妙地改变了函数的行为？
- en: '**CASE STUDY #2: HUNG, DRAWN, AND QUARTERED**'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例研究 #2：被吊死、被斩首、被四分五裂**'
- en: '**The program**'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序**'
- en: Embedded software controlling a consumer electronics device.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 控制消费电子设备的嵌入式软件。
- en: '**The problem**'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: A random lockup, occurring after about a week's continuous operation. It resulted
    in the total death of the device; there was no UI response, no network connectivity,
    not even an interrupt being handled—the processor was completely stalled. This
    was *particularly* nasty, leaving no easy way to find out the cause.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 随机锁定，发生在大约一周的连续运行之后。这导致了设备的完全死亡；没有任何用户界面响应，没有网络连接，甚至没有中断被处理——处理器完全停滞。这种情况特别令人讨厌，没有简单的方法可以找出原因。
- en: '**The story**'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**故事**'
- en: The lockup happened so rarely that it was remarkably hard to track. In an attempt
    to pinpoint the cause, we tried a number of tests, leaving each to run for the
    weeklong gestation period. First we tried different usage patterns to see if we
    could make the fault happen sooner and thereby determine what was causing it.
    These tests made no difference whatsoever.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定事件发生的频率如此之低，以至于追踪起来非常困难。为了确定原因，我们尝试了多种测试，让每个测试运行一周的时间。首先，我们尝试了不同的使用模式，看看是否可以更快地触发故障，从而确定原因。这些测试没有任何效果。
- en: The nature of the lockup seemed to imply that it was a gnarly hardware problem.
    We tried running the software on different versions of the mainboard with different
    peripheral components and different CPU versions. Weeks of testing later, we were
    still no nearer to figuring out the problem, but we did have less hair (and what
    remained was graying). No matter what configuration we used, the software still
    ran for about a week and then locked up.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定的性质似乎暗示这是一个棘手的硬件问题。我们尝试在不同的主板上运行不同版本的软件，使用不同的外围组件和不同的CPU版本。几周后，我们仍然没有接近解决问题，但我们确实少了一些头发（而且剩下的头发都变灰了）。无论我们使用什么配置，软件仍然可以运行大约一周然后锁定。
- en: 'Next we tried removing different sections of code from the system. After a
    lot of iterative testing, we tracked the problem down to a single component: Its
    presence in the build heralded a lockup; its absence prevented it. Finally, progress!'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试从系统中移除不同的代码部分。经过大量的迭代测试，我们将问题追踪到一个单一组件：它在构建中的存在预示着锁定；它的缺失阻止了锁定。最后，终于有了进展！
- en: Working out *why* this software component caused such problems wasn't straightforward.
    It was layered on top of a third-party library, which itself was built against
    a core OS library. We discovered that this core OS library had been upgraded to
    a more recent version, but the third-party library had not been rebuilt. We'd
    been continually linking against an inappropriate piece of code. While theoretically,
    this shouldn't have made a difference—the OS library change was supposedly *binary
    compatible*—a rebuild of the third-party library fixed the problem for good.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 确定为什么这个软件组件会导致这样的问题并不简单。它建立在第三方库之上，而这个第三方库本身又是基于核心操作系统库构建的。我们发现这个核心操作系统库已经被升级到更近的版本，但第三方库并没有被重新构建。我们一直在链接一个不合适的代码片段。虽然从理论上讲，这不应该有影响——操作系统库的变化据说应该是*二进制兼容的*——但重新构建第三方库永久地解决了问题。
- en: '**Time to fix**'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '**修复时间**'
- en: The total process took about four months, elapsed time. It involved many people
    on and off over that period, consumed lots of test resources, tied up many bits
    of hardware, and caused more review meetings than you'd believe were possible.
    As bugs go, this one had a nasty sting, and caused the company a lot of pain (not
    to mention expense).
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程大约花费了四个月的时间，这是流逝的时间。在这段时间里，涉及了许多人，消耗了大量的测试资源，占用了许多硬件部件，并且导致了比你能想象的还要多的审查会议。就错误而言，这个错误有一个令人讨厌的刺痛，给公司带来了很多痛苦（更不用说费用了）。
- en: '**Lesson learned**'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '**教训吸取**'
- en: Rebuild the *whole* software platform whenever *any* component changes to prevent
    subtle version mismatches.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 每当任何组件发生变化时，都要重新构建整个软件平台，以防止微妙的版本不匹配。
- en: Convince yourself that you have really found the root *cause* of the problem,
    and you're not just hiding another *symptom*. Then you can feel confident that
    you've put a fix in the right place. Consider whether similar mistakes may have
    been made elsewhere in any related modules; go and fix them if necessary.^([[7](#ftn.CHP-9-FN-7)])
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 让自己确信你已经真正找到了问题的根本*原因*，而不是仅仅隐藏了另一个*症状*。然后你可以自信地认为你已经把修复放在了正确的位置。考虑一下是否在其他任何相关模块中可能犯过类似的错误；如果需要，就去修复它们.^([[7](#ftn.CHP-9-FN-7)])
- en: '**KEY CONCEPT**'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*When you fix a bug, check to see if the same mistake is lurking in related
    sections of code. Exterminate the bug once and for all: Fix all occurences of
    the fault now*.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你修复一个错误时，检查是否有相同的错误潜伏在相关的代码部分。一次性彻底消灭这个错误：现在修复所有故障的实例*。'
- en: Finally, try to learn from your mistake. We must learn, or else we will be doomed
    to repeat the same errors for all eternity. Is it a simple programming error you
    keep making or something more fundamental, like the incorrect application of an
    algorithm?
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽量从你的错误中学习。我们必须学习，否则我们将注定要永远重复相同的错误。是简单的编程错误你一直在犯，还是更根本的问题，比如算法的错误应用？
- en: '**KEY CONCEPT**'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*With each fault you fix, learn the lessons. How could you have prevented it?
    How could you have discovered it more quickly?*'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '*随着你修复的每个错误，学习教训。你该如何预防它？你该如何更快地发现它？*'
- en: '* * *'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[7](#CHP-9-FN-7)]) This is why copy and paste programming—duplicating code,
    perhaps with minor modifications—is bad. It's dangerous; you'll mindlessly duplicate
    bugs, and then you won't be able to fix them in a single place.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-9-FN-7)]) 这就是为什么复制粘贴编程——复制代码，可能有一些小的修改——是糟糕的。它是危险的；你会无意识地复制错误，然后你将无法在一个地方修复它们。
- en: Prevention
  id: totrans-855
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防
- en: Anyone will tell you that "an ounce of prevention is worth a pound of cure."
    The best way to manage the population of bugs is to not introduce them. Sadly
    I don't think that we'll ever completely reach this ideal. For as long as programming
    involves problem solving, it will always be difficult—not only do you have to
    solve the problem correctly, you have to understand the whole problem *fully*
    in the first place. Despite this, careful defensive programming can avoid many
    problems. Good programming is about discipline and attention to detail. Thorough
    testing will prevent faults from leaking out in your software releases.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都会告诉你，“预防胜于治疗。”管理错误种群的最佳方式是不要引入它们。遗憾的是，我认为我们永远无法完全达到这个理想。只要编程涉及问题解决，它就会一直很难——不仅你必须正确解决问题，你首先必须完全理解整个问题。尽管如此，谨慎的防御性编程可以避免许多问题。良好的编程是关于纪律和对细节的关注。彻底的测试将防止错误在软件发布中泄露。
- en: 'This section could be enormous, but all prevention advice boils down to that
    one simple statement: *Use your brain*. Enough said.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节可能会非常庞大，但所有的预防建议都归结为那一个简单的声明：*使用你的大脑*。话已至此。
- en: Wasp Spray, Slug Repellent, Fly Paper . . .
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜜蜂喷雾剂，蜗牛驱赶剂，苍蝇纸……
- en: Many useful debugging tools exist, and you'd be stupid not to take advantage
    of them. Some are *interactive*, allowing you to inspect the code while it is
    running. Others are *noninteractive*, often running as a code filter or parser
    spitting out information about the program following analysis. Learn how they
    work to immesurably reduce your debugging time.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着许多有用的调试工具，你不利用它们真是太愚蠢了。其中一些是*交互式*的，允许你在程序运行时检查代码。其他的是*非交互式*的，通常作为代码过滤器或解析器运行，在分析后输出有关程序的信息。了解它们的工作原理，可以极大地减少你的调试时间。
- en: Debugger
  id: totrans-860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器
- en: This is the best known debugging tool; the name belies its purpose. A debugger
    is an interactive tool that allows you to view the internals of your running program
    and poke around with it. You can follow the flow of control, inspect the contents
    of variables, set *breakpoints* in the code for later interruption, and even run
    arbitrary sections of code at will.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 这是众所周知的调试工具；其名称掩盖了其目的。调试器是一个交互式工具，允许您查看运行程序的内部结构，并对其进行探索。您可以跟踪控制流，检查变量的内容，在代码中设置*断点*以供稍后中断，甚至可以随意运行代码的任意部分。
- en: Debuggers come in many shapes and sizes; some are command-line tools, and others
    are graphical applications. There will be at least one available for your particular
    development platform (although the ubiquitous gdb seems to be ported to every
    conceivable platform these days).
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器有多种形状和大小；有些是命令行工具，而另一些则是图形应用程序。您的特定开发平台至少会有一个可用的调试器（尽管无处不在的gdb现在似乎已经移植到每个可想象的平台上了）。
- en: A debugger relies on *symbols* being left in your executable (these are elements
    of the compiler's internal information that are normally stripped out at the final
    link stage)—it uses these to provide you with information about function and variable
    names and the location of the source files.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器依赖于在您的可执行文件中留下的*符号*（这些是编译器内部信息的元素，通常在最终链接阶段被移除）——它使用这些符号为您提供有关函数和变量名称以及源文件位置的信息。
- en: Although debuggers are rich and powerful tools, I believe that they are often
    misused or overused, and can actually *inhibit* good debugging. Programmers easily
    become wrapped up chasing what the program is doing, getting sidetracked by observing
    the wrong variable values, stepping into the wrong functions, and they forget
    to step back and *think* about the problem they are trying to solve. A little
    more thought about a failure may pinpoint the specific fault far more quickly
    than it would take to hunt it down in a debugger.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调试器是丰富且强大的工具，但我相信它们往往被误用或过度使用，实际上可能会*抑制*良好的调试。程序员很容易陷入追逐程序行为，被观察到的错误变量值、错误的函数调用所分心，而忘记了退后一步*思考*他们试图解决的问题。对失败进行一些思考可能会比在调试器中寻找更快地确定具体的故障。
- en: '**KEY CONCEPT**'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Use debuggers sparingly, when you encounter behavior you can''t explain. Don''t
    reach for them routinely to use as an alternative to* understanding *how your
    code works*.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '*在遇到无法解释的行为时，谨慎使用调试器。不要常规地伸手去使用它们作为理解*您的代码如何工作*的替代方案。'
- en: Memory Access Validator
  id: totrans-867
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存访问验证器
- en: This interactive tool inspects your running program for memory leaks and overruns.
    It can be remarkably useful, revealing reams of memory release errors you never
    knew existed.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个交互式工具，用于检查您的运行程序中的内存泄漏和越界。它可以非常有用，可以揭示大量您从未意识到的内存释放错误。
- en: System Call Tracing
  id: totrans-869
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用跟踪
- en: System call trace utilities, like Linux's strace, show all the system calls
    issued by an application. This is a good way to see how a program is interacting
    with its environment and is particularly useful when it appears to be stalled
    on some external activity that is not happening.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用跟踪实用程序，如Linux的strace，显示了应用程序发出的所有系统调用。这是一种查看程序如何与其环境交互的好方法，当程序似乎在某些外部活动上停滞不前时，尤其有用。
- en: Core Dump
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心转储
- en: This is a Unix term for the OS-generated snapshot of a program that is produced
    when it exits abnormally. The term derives from archaic machines with *ferrite
    core* memory; the dump file is still called *core* today. It contains a copy of
    the program's memory when it died, the state of the CPU registers, and the function
    call stack. The core dump can be loaded into an analyzer (which is often the debugger)
    to reveal a great deal of useful information.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Unix术语，指的是程序异常退出时操作系统生成的程序快照。这个术语来源于古老的具有*铁氧体磁芯*内存的机器；今天仍然将转储文件称为*核心*。它包含程序死亡时的内存副本、CPU寄存器的状态以及函数调用栈。核心转储可以被加载到分析器（通常是调试器）中，以揭示大量有用的信息。
- en: Logging
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: Logging facilities allow you to programmatically generate information about
    your application as it runs. Rich logging systems allow you to assign priorities
    to the output (e.g., debug, warning, fatal) and then filter out a particular message
    level at run time. The program's log gives a history of activity that can help
    pinpoint the circumstances that triggered a failure.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录功能允许你在程序运行时以编程方式生成有关应用程序的信息。丰富的日志系统允许你为输出分配优先级（例如，调试、警告、致命），然后在运行时过滤出特定的消息级别。程序的日志提供了活动的历史记录，有助于确定触发失败的环境。
- en: Even without a good logging facility (either as part of the operating environment
    or from a third-party library), you can achieve the same effect by peppering your
    code with basic print statements on an ad hoc basis. However, these printouts
    may interfere with normal program output, and they all must be carefully removed
    in the production code release.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有良好的日志记录功能（无论是作为操作系统的一部分还是来自第三方库），你也可以通过在代码中随意添加基本的打印语句来达到相同的效果。然而，这些打印输出可能会干扰正常的程序输出，并且在生产代码发布时都必须仔细删除。
- en: Sometimes even lowly print instructions aren't available. Once, when bringing
    up a new piece of hardware, the only diagnostic output I had was a single eight-segment
    LED display and a scope attached to a spare system bus. It's impressive how much
    information you can shoehorn into a few lights when you try!
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 有时甚至低级的打印指令也不可用。有一次，在启动新的硬件时，我唯一可用的诊断输出是一个单色的八段LED显示屏和一个连接到备用系统总线的示波器。当你尝试将大量信息塞入几个灯泡时，这真是令人印象深刻！
- en: 'There are downsides to logging: It can slow down program execution, bloat the
    executable size, and even introduce bugs of its own. Some logging systems, in
    which the crash destroys the buffer containing log messages, are useless for trapping
    a program crash. Be sure you know how well your logging mechanism behaves, and
    always send diagnostic print statements to an unbuffered output stream.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录有一些缺点：它可能会减慢程序执行速度，增加可执行文件的大小，甚至引入它自己的错误。一些日志系统，其中崩溃会破坏包含日志消息的缓冲区，对于捕获程序崩溃来说是无用的。确保你知道你的日志机制表现如何，并且始终将诊断打印语句发送到无缓冲的输出流。
- en: Static Analyzer
  id: totrans-878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析器
- en: This is a noninteractive tool that inspects your source code for potential problems.
    Many compilers perform basic static analysis when set to their maximum warning
    level, but good analysis tools go far beyond this. Products exist to detect problem
    code and any usage of undefined behavior or non portable constructs, to identify
    dangerous programming practices, to provide code metrics, to enforce coding standards,
    and to create automatic test harnesses.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非交互式工具，用于检查你的源代码中可能存在的问题。许多编译器在设置为最大警告级别时执行基本的静态分析，但好的分析工具远不止于此。存在一些产品可以检测问题代码和任何未定义行为或非可移植结构的用法，以识别危险的编程实践，提供代码度量，强制执行编码标准，并创建自动测试框架。
- en: Use of a static analysis tool can eradicate many errors before they have a chance
    to bite—a handy safety net. It's a pragmatic idea to use a static analyzer from
    a different company than your compiler manufacturer—two companies are less likely
    to have made the same set of assumptions or mistakes.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态分析工具可以在错误有机会造成影响之前消除许多错误——这是一个方便的安全网。使用与编译器制造商不同的公司的静态分析器是一个实用主义的思想——两家公司不太可能做出了相同的一组假设或错误。
- en: In a Nutshell
  id: totrans-881
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: I can remember the exact instant when I realized that a large part of my life
    from then on was going to be spent in finding mistakes in my own programs.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 我能记得我意识到从那时起我生命中很大一部分时间将花在寻找自己程序中的错误的那一刻。
- en: --Maurice Wilkes
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: --Maurice Wilkes
- en: Like death and taxes, no matter how hard we try to avoid them, bugs happen.
    Sure, you might be able to mitigate the effects of the first two by using every
    sort of antiwrinkle cream available and manipulating your money in cunning ways,
    but if you don't know how to deal with faults when they stare you in the face,
    your code is doomed.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 就像死亡和税收一样，无论我们多么努力地避免它们，错误总会发生。当然，你可能能够通过使用各种抗皱霜和巧妙地操纵金钱来减轻前两种错误的影响，但如果你不知道如何面对错误，你的代码就注定要失败。
- en: Debugging is a skill you develop. It doesn't rely on guesswork, but on methodical
    detection and thoughtful repair.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一种你培养的技能。它不依赖于猜测，而是依赖于有系统的检测和深思熟虑的修复。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
  zh: '| 好程序员…… | 差程序员…… |'
- en: '| --- | --- |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Don't cultivate bugs; they write code carefully to prevent introducing them
    in the first place
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要培养错误；要仔细编写代码，以防止一开始就引入它们
- en: Understand what their code does and write careful tests to ensure that it won't
    be broken easily
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解他们的代码做什么，并编写仔细的测试以确保它不会轻易被破坏
- en: Hunt for bugs methodically and carefully, rather than rush in headfirst without
    a battle plan
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有条不紊且仔细地寻找错误，而不是没有战斗计划就一头扎进去
- en: Know their limitations and will ask others to help find a fault when they're
    stuck
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解它们的局限性，并在遇到困难时请求他人帮助查找故障
- en: Change code carefully, even when making a "simple" repair
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行“简单”修复时也要小心地更改代码
- en: '|'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Don't debug; they flail around, sinking in a sea of bad code
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要调试；他们乱打一气，沉没在糟糕代码的海洋中
- en: Spend most of their life in a debugger, figuring out what their code is doing
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分时间都在调试器中，试图弄清楚他们的代码在做什么
- en: Encounter a failure and try to hide it—they actively avoid debugging
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到故障并试图隐藏它——他们积极避免调试
- en: Have unrealistic expectations of the quality of their code and of their ability
    to fix faults
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对他们代码的质量以及他们修复错误的能力有不切实际的期望
- en: '"Fix" bugs by masking symptoms rather than tracing the problem back to its
    real cause'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过掩盖症状而不是追踪问题到其真正原因来“修复”错误
- en: '|'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-901
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。防御")'
- en: How to prevent bugs from ever gaining a foothold in your code.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 如何防止错误在你的代码中扎根。
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。测试时间")'
- en: You can't fix a fault until you know it exists. Thorough testing is a prevention
    mechanism that stops faults from leaking out into your software releases.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 在你知道它存在之前，你不能修复一个故障。彻底测试是一种预防机制，可以阻止故障泄漏到你的软件发布中。
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '[第20章](ch20.html "第20章。致命的回顾")'
- en: '*Code reviews* help to pinpoint and eradicate bugs and can identify problem
    areas that would otherwise go undetected.'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码审查*有助于定位和根除错误，并可以识别出否则可能未被发现的潜在问题区域。'
- en: '![See Also](tagoreillycom20080909nostarchimages207470.png.jpg)'
  id: totrans-908
  prefs: []
  type: TYPE_IMG
  zh: '![另请参阅](tagoreillycom20080909nostarchimages207470.png.jpg)'
- en: Get Thinking
  id: totrans-909
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开动脑筋
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 500.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 在第500页的"[附录A](apa.html "附录A. 答案和讨论")"部分可以找到对这些问题的详细讨论。
- en: Mull It Over
  id: totrans-911
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: Is it best for faults to be fixed by the original programmer who wrote the code?
    Or is the programmer who discovered the problem better placed to make a fix?
  id: totrans-912
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是由编写代码的原始程序员修复故障最好，还是由发现问题的程序员更适合进行修复？
- en: How can you tell when to use a debugger and when to use your brain?
  id: totrans-913
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何判断何时使用调试器，何时使用你的大脑？
- en: You should learn unfamiliar code before you start trying to find and fix faults
    in it. But the time pressures of the software factory often dictate that you can't
    spend any serious time studying and understanding the program you're repairing.
    What's the best way forward?
  id: totrans-914
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始尝试查找和修复错误之前，你应该先学习不熟悉的代码。但软件工厂的时间压力通常意味着你无法花太多时间研究和理解你正在修复的程序。最好的前进方式是什么？
- en: Describe good techniques to avoid memory-leak bugs.
  id: totrans-915
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述避免内存泄漏错误的良好技术。
- en: When is it justifiable to have a quick stab at finding and fixing a fault, rather
    than adopting a more methodical approach?
  id: totrans-916
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下可以快速尝试查找和修复故障，而不是采用更系统的方法是合理的？
- en: Getting Personal
  id: totrans-917
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人感悟
- en: How many debugging techniques/tools do you routinely use? What others have you
    seen that you might find useful?
  id: totrans-918
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你通常使用多少调试技术/工具？你见过哪些可能对你有用的其他工具？
- en: What are the common problems and pitfalls in your language(s) of choice? How
    do you guard against these kinds of bugs in your own code?
  id: totrans-919
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的语言中，常见的错误和陷阱是什么？你如何在自己的代码中防范这些类型的错误？
- en: Are most of the bugs that occur in your code sloppy programming errors, or are
    they more subtle issues?
  id: totrans-920
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中发生的错误大多是粗心的编程错误，还是更微妙的问题？
- en: 'Do you know how to use a debugger on your platform? How routinely do you use
    it? Describe how to do the following:'
  id: totrans-921
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道如何在你的平台上使用调试器吗？你有多频繁地使用它？描述如何做以下事情：
- en: Produce a backtrace
  id: totrans-922
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成回溯
- en: Inspect variable values
  id: totrans-923
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查变量值
- en: Inspect value of fields within a structure
  id: totrans-924
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查结构中字段的值
- en: Run an arbitrary function
  id: totrans-925
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行任意函数
- en: Swap thread contexts
  id: totrans-926
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换线程上下文
- en: Chapter 10. THE CODE THAT JACK BUILT
  id: totrans-927
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。杰克建造的代码
- en: '*Mechanisms to Turn Source Code into Executable Code*'
  id: totrans-928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*将源代码转换为可执行代码的机制*'
- en: What you spend years building may be destroyed overnight. Build anyway.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 你花费多年建造的东西可能在一夜之间被摧毁。尽管如此，还是要继续建造。
- en: --Mother Teresa
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: --特蕾莎修女
- en: The programmer (*Geekus maximus*) is usually found in its natural habitat, hunched
    in the ethereal glow of a monitor, entering profound combinations of punctuation
    characters into a text editor. Occasionally, this timid beast will leave the confines
    of its lair to forage for coffee or pizza. Quickly it returns to safety, continuing
    its ritual at the keyboard.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员（*Geekus maximus*）通常在其自然栖息地被发现，弯曲在显示器那神秘的微光中，将深奥的标点符号组合输入到文本编辑器中。偶尔，这只胆怯的生物会离开其巢穴去寻找咖啡或披萨。它迅速返回安全的地方，继续在键盘上执行其仪式。
- en: If typing language constructs was all there was to programming, then our job
    would be a great deal easier, although we'd risk being replaced by the proverbial
    infinite number of monkeys with their infinite number of text editors. Instead,
    we must run our source code through a compiler (or interpreter) to obtain something
    that might just function as we intend it to. Invariably, it doesn't. Rinse and
    repeat.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程仅仅是输入语言结构，那么我们的工作将会容易得多，尽管我们可能会被传说中的无限数量的猴子及其无限数量的文本编辑器所取代。相反，我们必须运行我们的源代码通过编译器（或解释器）以获得可能正如我们意图那样工作的东西。不可避免的是，它并不总是这样。重复这个过程。
- en: The task of converting carefully honed, high-level language into an executable
    that can be distributed is commonly referred to as *building* code (although you'll
    find that this term is used pretty interchangeably with *making* and *compiling*
    in most contexts).
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 将精心打磨的高级语言转换为可分发可执行程序的任务通常被称为*构建*代码（尽管你会在大多数情况下发现这个术语与*制作*和*编译*几乎可以互换使用）。
- en: This act of building is a fundamental part of what we do—we can't develop code
    without performing a build. It's important, then, to understand what's involved
    and how your project's build system works in order to have any confidence in the
    code that's generated. There are a lot of subtle issues at play here, especially
    when a codebase reaches a reasonable size. Interestingly, almost all programming
    textbooks will gloss over this kind of topic; they present single-file example
    programs that don't show any real build complexity.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建行为是我们所做事情的基本部分——我们无法在不执行构建的情况下开发代码。因此，了解涉及的内容以及你的项目构建系统是如何工作的，对于对生成的代码有信心来说非常重要。这里有很多微妙的问题在发挥作用，尤其是在代码库达到合理规模时。有趣的是，几乎所有编程教科书都会略过这类话题；它们展示的是单文件示例程序，没有展示任何真正的构建复杂性。
- en: Many developers rely on their IDE's build system, but this doesn't remove the
    burden of understanding how it works. It's very convenient to hit a button and
    have all your code generated, but if you don't know which options are being passed
    to the C compiler or which level of instrumentation is left in your object files,
    then you're not really in control. The same holds true if you type a single *build*
    instruction at a command prompt. You must understand what's going on under the
    hood to be able to repeatably perform reliable builds.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者依赖于他们IDE的构建系统，但这并不能消除理解其工作原理的负担。一键生成所有代码非常方便，但如果你不知道哪些选项被传递给C编译器，或者你的目标文件中留下了哪个级别的仪器，那么你实际上并没有控制权。如果你在命令提示符中输入单个*构建*指令，也是如此。你必须了解底层发生了什么，才能能够重复执行可靠的构建。
- en: Language Barriers
  id: totrans-936
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言障碍
- en: There are several varieties of programming languages, each with its own mechanical
    process of constructing an executable program from source code. Some construction
    models are more complex than others, and each has its strong and weak points.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有多种类型，每种语言都有其从源代码构建可执行程序的独特机械过程。有些构建模型比其他模型更复杂，每种模型都有其优点和缺点。
- en: 'There are three main mechanisms: *interpreted* languages, *compiled* languages,
    and *byte-compiled* languages. These are shown in [Figure 10-1](ch10.html#programing_language_build_and_execution_methods
    "Figure 10-1. Programing language build and execution methods").'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有三种机制：*解释型*语言、*编译型*语言和*字节编译型*语言。这些在[图10-1](ch10.html#programing_language_build_and_execution_methods
    "图10-1. 编程语言构建和执行方法")中展示。
- en: '![Programing language build and execution methods](tagoreillycom20080909nostarchimages207472.png)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![编程语言构建和执行方法](tagoreillycom20080909nostarchimages207472.png)'
- en: '**Figure 10-1. Programing language build and execution methods**'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10-1. 编程语言构建和执行方法**'
- en: '**DO WE REALLY *BUILD* SOFTWARE?**'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们真的*构建*软件吗？**'
- en: '*Building* is often used as a metaphor for programming, equating what we do
    to the "traditional" building industry. There are many striking parallels, since
    both are construction processes. We have, in fact, seen some sort of overlap and
    collaboration between the two disciplines, as the software patterns movement (see
    "[DESIGN PATTERNS](ch13s05.html#design_patterns "DESIGN PATTERNS")" on page 255)
    learned from Christopher Alexander''s architectural work.(Alexander 79)'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建*经常被用作编程的隐喻，将我们所做的事情等同于“传统”的建筑行业。由于两者都是建筑过程，所以有很多显著的相似之处。实际上，我们已经看到了这两个学科之间的一些重叠和协作，正如软件模式运动（参见第255页的“[设计模式](ch13s05.html#design_patterns
    "设计模式")”）从克里斯托弗·亚历山大的建筑工作中汲取了灵感。（亚历山大 79）'
- en: It's valuable to understand how far this metaphor stretches and how useful it
    really is. No metaphor is perfect, after all. Although philosophical and a bit
    of an aside, it *does* matter because the comparison will inevitably prejudice
    our approach to development. The metaphor is helpful in places; elsewhere it's
    less than perfect (even potentially harmful).
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个隐喻可以延伸多远以及它实际上有多有用是有价值的。毕竟，没有哪个隐喻是完美的。虽然这是一个哲学性的话题，并且有点离题，但它*确实*很重要，因为这种比较不可避免地会偏颇我们的开发方法。隐喻在某些地方是有帮助的；在其他地方则不够完美（甚至可能是有害的）。
- en: '**The good**'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '**好的方面**'
- en: Like the physical construction process of a house, we start from nothing and
    buildby placing one layer of structure atop another. Before the construction begins,
    a process of gathering requirements and careful design and architecture should
    have been performed. While you can probably build a garden shed without much planning,
    you'd be crazy to hope an unplanned skyscraper had a chance of standing up; you
    need serious design and planning up front. This neatly parallels our software
    construction.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 就像房屋的物理建筑过程一样，我们从无到有，通过将一层结构置于另一层之上来构建。在施工开始之前，应该已经完成了需求收集和仔细的设计与架构。虽然你可能不需要太多计划就能建造一个花园小屋，但你如果希望一座没有计划的摩天大楼能站立起来，那就疯了；你需要前期进行严肃的设计和规划。这很巧妙地与我们软件构建相对应。
- en: '**The bad**'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '**不好的方面**'
- en: The metaphor stretches thin in other areas, though. We can modify the foundational
    layers of our software constructions more easily than the foundations of a house.
    It's far cheaper to tear down a software edifice than a physical one. This means
    that the software world offers the opportunity to prototype and explore more often
    than the physical world does.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐喻在其他领域也显得有些单薄。我们比修改房屋的基础更容易修改我们软件构建的基础层。拆除软件建筑比拆除物理建筑要便宜得多。这意味着软件世界提供了比物理世界更多的原型设计和探索的机会。
- en: Real World building mandates sound engineering principles; this is enshrined
    in statute and enforced by public liability. Many software firms wouldn't know
    an engineering principle if it slapped them in the face.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的建筑要求遵循良好的工程原则；这一点在法规中得到体现，并由公众责任来执行。许多软件公司即使工程原则打在脸上也未必能认出来。
- en: '**The ugly**'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**丑陋的方面**'
- en: Our entire development procedure *is* akin to a physical construction process,
    comprising system conception, design, implementation, and testing. But what we're
    actually thinking about in this chapter is subtly different—it revolves around
    *compilation* and the procedures involved in *this kind* of building task. The
    metaphor's a bit out of kilter here too. Each time you take a fresh copy of some
    source code, you "build" it, creating an executable program; *that* is what we're
    looking at here. Be clear about these two different uses of the term "build."
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个的开发流程*就是*类似于一个物理建筑过程，包括系统构思、设计、实施和测试。但我们在本章真正思考的却有所不同——它围绕着*编译*以及这种建筑任务所涉及的程序。这里的比喻也有点不协调。每次你获取一些源代码的新副本时，你“构建”它，创建一个可执行程序；*这就是*我们在这里关注的。要清楚这两个“构建”术语的不同用法。
- en: The software build process follows its own rules—if you modify a function, you
    must then perform a system rebuild. In contrast, you don't have to rebuild the
    walls in your house every time you paint the doors.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 软件构建过程遵循其自身的规则——如果你修改了一个函数，那么你必须执行系统重建。相比之下，你不需要每次粉刷门时都重建房屋的墙壁。
- en: Interpreted Languages
  id: totrans-952
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释性语言
- en: Code written in interpreted languages does not need to go through a specific
    build phase. After writing some code, you need only tell the interpreter where
    it is; it parses and acts on the instructions in real time. Common interpreted
    languages are Perl, Python, and JavaScript. The majority of OO languages are interpreted,
    largely because they have been developed more recently as computers have become
    better able to run interpreters at reasonable speeds.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解释型语言编写的代码不需要经过特定的构建阶段。编写一些代码后，你只需告诉解释器它的位置；它将实时解析并执行指令。常见的解释型语言有Perl、Python和JavaScript。大多数面向对象的编程语言都是解释型，这主要是因为随着计算机运行解释器速度的提高，这些语言是在最近几年发展起来的。
- en: The main advantage of interpreted languages is their speed of development; with
    no intermediate *compile* stage; you can test each change very quickly. You also
    gain platform independence—popular language interpreters run on many different
    platforms. Your program will work wherever the interpreter has been ported.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言的主要优势是它们的开发速度；没有中间的*编译*阶段，你可以非常快速地测试每个更改。你还获得了平台独立性——流行的语言解释器可以在许多不同的平台上运行。你的程序将在解释器被移植到的地方工作。
- en: 'But interpreted programs have some disadvantages: They execute more slowly
    than a compiled equivalent since the language run time has to read, parse, interpret,
    and act on each individual code statement. That''s a lot of work. Modern machines
    are so fast that this is only a problem for the most computing-intensive applications.
    There are various interpreter technologies that improve code performance: Some
    languages precompile the source file before execution (slowing down startup time)
    or employ *Just-In-Time ( JIT)* compilation, compiling each function as it''s
    about to be run (slowing down each function''s first call). For most programs,
    this isn''t an appreciable overhead, and JIT-compiled performance is indistinguishable
    from native compiled code.'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 但解释型程序有一些缺点：它们的执行速度比编译型程序慢，因为语言运行时必须读取、解析、解释并执行每个单独的代码语句。这是一项大量工作。现代机器如此之快，这仅是针对最计算密集型应用的问题。有各种解释器技术可以提高代码性能：一些语言在执行前预先编译源文件（减慢启动时间）或采用*即时编译（JIT）*，在函数即将运行时编译每个函数（减慢每个函数的第一次调用）。对于大多数程序来说，这并不是一个显著的开销，JIT编译的性能与本地编译代码无法区分。
- en: '*Scripting languages* are often interpreted. These languages support a very
    fast development cycle by being very forgiving to questionable code (with lax
    language rules and weak typing) and by avoiding complex features. Scripting languages
    are often used as glue to invoke other utilities in more convenient ways. Unix
    shell scripts, Windows batch files, and Tcl are examples of scripting languages.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '*脚本语言*通常被解释。这些语言通过非常宽容地对待可疑代码（宽松的语言规则和弱类型）以及避免复杂特性，支持非常快速的开发周期。脚本语言通常用作粘合剂，以更方便的方式调用其他实用程序。Unix
    shell脚本、Windows批处理文件和Tcl是脚本语言的例子。'
- en: Compiled Languages
  id: totrans-957
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译型语言
- en: Compiled languages employ a build toolchain to convert your source code files
    into machine instructions that will execute natively on the target platform. The
    target execution platform is usually the same as the development platform, but
    embedded developers often build on a PC and target very different machines, using
    a *cross compiler*. Large projects are compiled in several stages; each individual
    source file is compiled into an intermediate *object file*, and then these objects
    are linked into a final executable. This build model is illustrated by the cake-baking
    metaphor, shown in [Figure 10-2](ch10.html#compilation_confectionary "Figure 10-2. Compilation
    confectionary"), where individual ingredients (source files) are mixed (compiled)
    and finally baked together (linked).
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型语言使用构建工具链将你的源代码文件转换为在目标平台上本地执行的机器指令。目标执行平台通常与开发平台相同，但嵌入式开发者经常在PC上构建，并针对非常不同的机器，使用*交叉编译器*。大型项目通常在几个阶段编译；每个单独的源文件被编译成一个中间的*对象文件*，然后这些对象被链接成一个最终的可执行文件。这种构建模型可以用烘焙蛋糕的隐喻来表示，如图[图10-2](ch10.html#compilation_confectionary
    "图10-2. 编译甜点")所示，其中单个成分（源文件）被混合（编译），最后一起烘焙（链接）。
- en: C and C++ are the most popular compiled languages, although most structured
    languages are compiled. By its very nature, a compiled application will run faster
    than its interpreted counterpart (at least, without JIT compilation), although
    in practice, you won't notice this—most applications are not computing-intensive;
    they spend most of their time stalled and waiting for user, disk, or network input.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 是最受欢迎的编译型语言，尽管大多数结构化语言都是编译的。由于其本质，编译型应用程序将比其解释型对应物运行得更快（至少在没有 JIT 编译的情况下），尽管在实践中，你可能不会注意到这一点——大多数应用程序不是计算密集型的；它们大部分时间都在停滞，等待用户、磁盘或网络输入。
- en: The compiled language build procedure is more complex than an interpreter, so
    there are more possible points of failure. An application has to be recompiled
    for each target platform you want to run it on.^([[1](#ftn.CHP-10-FN-1)])
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型语言的构建过程比解释器更复杂，因此有更多的潜在故障点。应用程序必须为每个你想要运行它的目标平台重新编译.^([[1](#ftn.CHP-10-FN-1)])
- en: '![Compilation confectionary](tagoreillycom20080909nostarchimages207474.png)'
  id: totrans-961
  prefs: []
  type: TYPE_IMG
  zh: '![编译糖果屋](tagoreillycom20080909nostarchimages207474.png)'
- en: '**Figure 10-2. Compilation confectionary**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10-2. 编译糖果屋**'
- en: Byte-Compiled Languages
  id: totrans-963
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节编译语言
- en: Byte-compiled languages sit halfway between interpreted and compiled languages.
    They involve a compilation step but don't produce a native executable program.
    Instead, the product is a file of *byte code*; a pseudo machine language that
    can be executed by a *virtual machine*. Java and C# are common byte-compiled languages.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 字节编译语言位于解释型语言和编译型语言之间。它们涉及一个编译步骤，但不会生成原生可执行程序。相反，产品是一个包含 *字节码* 的文件；这是一种伪机器语言，可以被
    *虚拟机* 执行。Java 和 C# 是常见的字节编译语言。
- en: A common misconception is that executing byte code is *necessarily* slower than
    executing an equivalent compiled binary. This is not always so. A JIT optimizer
    can make intelligent decisions about the code that may make it particularly fast
    (for example, tailoring itself to the exact hardware the program is executing
    on).
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是执行字节码必然比执行等效的编译二进制文件慢。这并不总是如此。JIT 优化器可以对代码做出智能决策，这可能使其特别快（例如，根据程序正在执行的硬件进行定制）。
- en: As a compromise, byte compilers inherit some of the advantages and disadvantages
    of the previous approaches. Byte code can be executed on any platform the virtual
    machine has been ported to, so you gain portability (although some language run
    times are more widely ported than others).
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种折衷方案，字节编译器继承了先前方法的一些优点和缺点。字节码可以在虚拟机已移植到任何平台上执行，因此你获得了可移植性（尽管某些语言的运行时比其他语言的运行时更广泛地移植）。
- en: '* * *'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-10-FN-1)]) Target platforms are distinguished by their processor
    types and the host operating systems. Other factors, like the available peripheral
    hardware, may be important.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-10-FN-1)]) 目标平台通过其处理器类型和宿主操作系统来区分。其他因素，如可用的外围硬件，可能也很重要。
- en: Making Mountains out of Molehills
  id: totrans-969
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小题大做
- en: The compiled (and byte-compiled) build models are the hardest to reason about,
    so let's investigate what compiling software entails. It's shocking how few newly
    trained programmers really understand this, so we'll start from first principles.
    If you already know this stuff, feel free to skip ahead.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型（和字节编译型）的构建模型是最难推理的，因此让我们调查编译软件涉及的内容。令人震惊的是，真正理解这一点的新训练程序员如此之少，所以我们将从基本原则开始。如果你已经知道这些内容，请随意跳过。
- en: 'For a good understanding, it''s best to think about each manual step rather
    than rely on your IDE to do all the rebuilding work for you. This five-part story
    of a simple program''s development will explain:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，最好是将每个手动步骤都考虑进去，而不是依赖你的 IDE 为你完成所有重建工作。这个关于简单程序开发的五部分故事将解释：
- en: You're starting a new project, coded in C. It will solve all the ills of the
    software development world and will usher in a new era of world peace. However
    all you have at first is a single file containing `main`. You've got to start
    somewhere.
  id: totrans-972
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在启动一个新的项目，用 C 语言编写。它将解决软件开发世界的所有问题，并将迎来世界和平的新时代。然而，你最初只有包含 `main` 的单个文件。你必须从这里开始。
- en: It's easy to build and run this single-file program—you just type `compiler
    main.c`,^([[2](#ftn.CHP-10-FN-2)]) and out pops an executable for you to run and
    test. Simple.
  id: totrans-973
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建和运行这个单文件程序很容易——你只需输入 `compiler main.c`，^([[2](#ftn.CHP-10-FN-2)]) 然后就会为你生成一个可执行文件，你可以运行和测试它。很简单。
- en: The program grows. To help organize the parts, you split it into multiple files,
    one per functional block. The build is still a simple process. Now you type `compiler
    main.c func1.c func2.c`. The same executable program pops out, leaving you to
    carry on testing as before. No sweat.
  id: totrans-974
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序不断增长。为了帮助组织各个部分，你将其拆分为多个文件，每个功能块一个文件。构建过程仍然很简单。现在你输入`编译器 main.c func1.c func2.c`。同样的可执行程序就会生成，让你继续像以前一样进行测试。没问题。
- en: Soon, you recognize that some sections of the code are really individual components
    with isolated concerns, almost like stand-alone libraries. It would be easier
    to reason about these sections of code by placing them in their own directories—grouping
    the similar sections of code together. Now the project is beginning to spread
    out. The simple way to build this new file structure is to compile each individual
    source file by hand, using a compiler call that doesn't build an executable, just
    intermediate object files. Afterward, `main.c` is compiled and linked with all
    the intermediate object files. To do this, you may also have to point the compiler
    at some other directories' include files. Now things are getting a little more
    complex.
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很快，你就会意识到代码的一些部分实际上是具有独立关注点的独立组件，几乎就像独立的库。通过将这些代码部分放在它们自己的目录中——将相似的代码部分分组在一起——更容易对这些代码部分进行推理。现在项目开始扩展。构建这种新文件结构的简单方法是手动编译每个单独的源文件，使用一个不构建可执行文件，只生成中间目标文件的编译器调用。之后，`main.c`被编译并与所有中间目标文件链接。为此，你可能还需要将编译器指向其他目录的包含文件。现在事情变得稍微复杂一些。
- en: Whenever you change some code in one of the new directories, you have to fire
    off the compile command in *that* directory and then issue the final "link everything"
    command once more. Quite manual. Additionally, if you change a header file that
    other directories use, all of *those* directories have to be rebuilt too. If you
    forget, the linker will probably generate a slew of cryptic complaints.
  id: totrans-976
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当你在一个新目录中更改一些代码时，你必须在该目录中执行编译命令，然后再次发出最终的“链接所有内容”命令。相当手动。此外，如果你更改了其他目录使用的头文件，所有那些目录也必须重新构建。如果你忘记了，链接器可能会生成一系列神秘的抱怨。
- en: To eliminate this huge command-line burden, you can write a *shell script* (or
    *batch file* in Windows) that walks around each directory and fires off the requisite
    build commands. Having hidden all that messy work and the tedious compiler parameters,
    you can get back to the serious business of code development with the peace of
    mind that you don't have to memorize unnecessary build fluff.
  id: totrans-977
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了消除这个巨大的命令行负担，你可以编写一个*shell脚本*（或在Windows上的*批处理文件*），它会遍历每个目录并执行必要的构建命令。隐藏了所有那些杂乱的工作和繁琐的编译器参数后，你可以安心回到代码开发的正事上，不必记住不必要的构建细节。
- en: Later on, these subdirectories become real stand-alone libraries; they are also
    used in other projects. You tidy up the code so it's a little friendlier to use,
    add some good user-facing documentation, and then alter the build commands to
    generate *shared libraries* rather than object files. This requires some more
    changes to your build script, but it's a relatively hidden change and isn't too
    painful.
  id: totrans-978
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，这些子目录变成了真正的独立库；它们也被用于其他项目。你整理代码，使其使用起来更加友好，添加一些良好的用户文档，然后将构建命令更改为生成*共享库*而不是目标文件。这需要对你的构建脚本进行一些修改，但这是一个相对隐蔽的更改，并不太痛苦。
- en: Development carries on like this for some time. Code is added rapidly. Many
    new subdirectories and sub-subdirectories are created. Although the file structure
    seems pretty neat, build times become a problem—each time you fire up the build
    script, it recompiles every source file, even those that haven't changed. The
    temptation here is to track all changes yourself and to issue subdirectory builds
    by hand again (perhaps by creating individual directory build scripts as a halfway
    house). The project is now so large that it would be very easy to miss some dependencies.
    This would lead to hard to resolve build errors, or even subtler problems (e.g.,
    you may encounter flaws that don't stop the link from working, but that do make
    the program behave in incorrect ways).
  id: totrans-979
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发就这样持续了一段时间。代码被快速添加。创建了大量的新子目录和子子目录。尽管文件结构看起来相当整洁，但构建时间成为一个问题——每次你启动构建脚本时，它都会重新编译每个源文件，即使那些没有改变的文件。这里的诱惑是自行跟踪所有更改，并再次手动执行子目录构建（也许通过创建单个目录构建脚本作为折中方案）。项目现在如此庞大，很容易遗漏一些依赖项。这可能导致难以解决的构建错误，甚至更微妙的问题（例如，你可能会遇到不会阻止链接工作的缺陷，但会使程序以错误的方式运行）。
- en: Now your development is on the brink. You can't trust the system being used
    to build the code. It's not safe. You can only really trust the executable if
    you've done a complete cleanout and rebuilt from scratch.
  id: totrans-980
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在您的开发正处于边缘。您不能信任用于构建代码的系统。这并不安全。只有当您已经彻底清理并从头开始重建时，您才能真正信任可执行文件。
- en: Enter the tool for just this occasion. The classic solution is a command-line
    program imaginatively called make. (Feldman 78) It deals with all of the intermediate
    object files and compilation rules for you and, most importantly, tracks which
    files depend on which other files. You tell it what to do by writing makefiles
    that provide the necessary build rules. It looks at the source file timestamps
    to check what has changed since you last performed a make, and then it recompiles
    just those files, along with anything dependent on them. It's a more intelligent
    version of the scripts we wrote above, specifically tailored to the task of compiling
    and recompiling software.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种场合的工具。经典的解决方案是一个名为make的命令行程序。（Feldman 78）它为您处理所有中间对象文件和编译规则，最重要的是，跟踪哪些文件依赖于哪些其他文件。您通过编写makefiles来告诉它做什么，这些makefiles提供了必要的构建规则。它查看源文件的最后修改时间戳，以检查自上次执行make以来发生了什么变化，然后它只重新编译那些文件，以及依赖于它们的任何文件。这是一个比我们上面写的脚本更智能的版本，专门针对编译和重新编译软件的任务。
- en: 'Over the years, many variants of the humble make have appeared, these days
    many with pretty GUI façades. GNU Make is one of the most widely used tools (it''s
    free and very flexible). If you haven''t been initiated into the Cult of Make,
    "[MAKE: A TOURIST''S GUIDE](ch10s03.html#make_colon_a_tourist_apos_s_guide "MAKE:
    A TOURIST''S GUIDE")" on page 183 explains its basic operation.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '多年来，出现了许多谦逊的make的变体，如今许多都带有相当漂亮的GUI界面。GNU Make是最广泛使用的工具之一（它是免费的，并且非常灵活）。如果你还没有被引入Make的崇拜，请参阅第183页的"[MAKE:
    A TOURIST''S GUIDE](ch10s03.html#make_colon_a_tourist_apos_s_guide "MAKE: A TOURIST''S
    GUIDE")"，它解释了其基本操作。'
- en: There are many other build systems in common use. Look at SCons, Ant, Nant,
    and Jam for examples. They are each tailored to a specific kind of build environment
    (for example, Nant is used to build .NET projects) or for a particular quality
    (many aim to simplfy the syntax of make, which is quite baroque!).
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的构建系统还有很多。例如，看看SCons、Ant、Nant和Jam。它们各自针对特定的构建环境（例如，Nant用于构建.NET项目）或特定的质量（许多旨在简化make的语法，而make的语法相当复杂！）。
- en: '* * *'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-10-FN-2)]) Obviously, you would replace `compiler` with the command
    to prod your C compiler—this is a hypothetical example.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-10-FN-2)]) 显然，你会用命令来启动你的C编译器来替换`compiler`——这是一个假设的例子。
- en: Building Builds
  id: totrans-986
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建构建
- en: In that sinking morass of software construction, we've seen some of the main
    issues of a build procedure. Essentially, any software build process takes one
    or more source files as input, and it spits some executable program out the other
    end. It may even produce an entire release distribution, including an executable,
    help files, an installer, and so on, all packaged neatly and ready to be burned
    onto CD.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个软件构建的泥潭中，我们已经看到了构建过程的一些主要问题。本质上，任何软件构建过程都将以一个或多个源文件作为输入，并在另一端输出一些可执行程序。它甚至可以生成整个发布版本，包括可执行文件、帮助文件、安装程序等等，所有这些都被整齐地打包好，准备烧录到CD上。
- en: '**TERMS AND CONDITIONS**'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '**条款和条件**'
- en: 'These terms comprise the main software construction terminology:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语构成了主要的软件构建术语：
- en: '**Source code**'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码**'
- en: Source code is physically contained in the files that you write, and it usually
    occursin a high-level language. These language constructs can be converted into
    a functioning program with the appropriate tools.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码物理上包含在你所写的文件中，通常以高级语言的形式出现。这些语言结构可以通过适当的工具转换为功能程序。
- en: '**Compilation**'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译**'
- en: Source code is converted into an executable in one of two ways. One is to *compile*
    it into an executable program. The alternative is to *interpret* the source code
    in real time—a language run time parses and acts on the source code as the program
    is run.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以通过两种方式之一转换为可执行文件。一种是将它编译成可执行程序。另一种是在实时中解释源代码——语言运行时在程序运行时解析并作用于源代码。
- en: '**Build**'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建**'
- en: This is a vague term, often used as a synonym for *compile*. Compilation is
    a single construction step, whereas a build describes the entire construction
    process. The term *make* is used in a similarly vague fashion; even worse, it
    is also the name of a common software build tool.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模糊的术语，通常用作*编译*的同义词。编译是一个单独的构建步骤，而构建描述的是整个构建过程。术语*make*也以类似的方式使用；更糟糕的是，它也是一个常见的软件构建工具的名称。
- en: '**Object code**'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标代码**'
- en: Object code is held in an *object file*. It represents the compiled version
    of a file of source code. Object code is not directly executable; it relies on
    other files of code (most programs are made of more than one source file). An
    object file must be *linked* with other objects to create an *executable*.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 目标代码存储在*目标文件*中。它代表了源代码文件的编译版本。目标代码不能直接执行；它依赖于其他代码文件（大多数程序由多个源文件组成）。目标文件必须与其他对象*链接*以创建一个*可执行文件*。
- en: '**Library**'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**'
- en: A code *library* is akin to an object file—it is a collection of compiled code
    and not itself a whole program. A library contains a cohesive collection of useful
    functionality that can be incorporated into any program. A library can be *static*
    or *dynamic*. The former is linked like an object file, whereas the latter is
    dynamically loaded by the application when it is run.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 代码*库*类似于目标文件——它是一系列编译代码的集合，而不是一个完整的程序。库包含了一组有用的功能，可以集成到任何程序中。库可以是*静态的*或*动态的*。前者像目标文件一样链接，而后者在程序运行时由应用程序动态加载。
- en: '**Machine code**'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器代码**'
- en: Some compilation steps produce *machine code* rather than object files. This
    is a form of source code that represents the exact CPU instructions for a program.
    Machine code is converted into real CPU instructions by an *assembler*, which
    is why it's also known as *assembly code*.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译步骤产生的是*机器代码*而不是目标文件。这种源代码形式代表了程序的确切CPU指令。机器代码通过*汇编器*转换成实际的CPU指令，这也是为什么它也被称为*汇编代码*。
- en: Some low-level OS libraries and embedded programs are written in assembly language,
    but we generally work in high-level languages and leave assembly to the internal
    workings of the compiler.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 一些低级操作系统库和嵌入式程序是用汇编语言编写的，但我们通常使用高级语言，并将汇编留给编译器的内部工作。
- en: '**Linking**'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接**'
- en: The *linker* combines one or more *object files* (and perhaps libraries) into
    a final executable or into a partially linked code *library*.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '*链接器*将一个或多个*目标文件*（以及可能包含库）组合成一个最终的可执行文件或部分链接的代码*库*。'
- en: '**Executable**'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '**可执行文件**'
- en: The outcome of a compile or link step. This is a self-contained program that
    can be run directly on your computer.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 编译或链接步骤的结果。这是一个可以在您的计算机上直接运行的独立程序。
- en: Like the cumulative story from which I shamelessly pilfered this chapter's title,
    as our software develops and matures, the build process develops and matures with
    it. Maybe yours didn't start in as basic a state as the example above, but build
    scaffolding tends to start simple and grow alongside the code it builds. A large
    project often has a bewildering build process that requires (but doesn't necessarily
    always have) adequate documentation. We can see that the act of compiling a single
    source file is at the lowest level of the build food chain, and we will raise
    a tower of extra work upon this simple act.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我从其中毫不脸红地窃取了本章标题的累积故事一样，随着我们的软件发展和成熟，构建过程也随之发展和成熟。也许你的起点不像上面的例子那么基础，但构建脚手架往往从简单开始，并随着构建的代码一起增长。大型项目通常有一个令人困惑的构建过程，它需要（但不一定总是有）足够的文档。我们可以看到，编译单个源文件是构建食物链的最低级别，我们将在这一简单行为之上建立一座额外的塔楼。
- en: A build process is not *just* about compiling source files. It may also involve
    preparing some text registration files from templates, creating internationalized
    strings for the UI, or converting graphics files from their source resolution
    to some destination format. Practically all such activities can hang off a build
    system and be run in the normal course of a build. This does presume that all
    the tools are scriptable—that they can be run by some other program (e.g., by
    make).
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程不仅仅是编译源文件。它可能还涉及从模板中准备一些文本注册文件，为UI创建国际化字符串，或将图形文件从其源分辨率转换为某些目标格式。实际上，所有这些活动都可以挂载在构建系统上，并在构建的正常过程中运行。这确实假设所有工具都是可脚本化的——它们可以被其他程序（例如，make）运行。
- en: It's important to consider your build system a part of the entire source tree,
    not something separate. Makefiles are kept under revision control alongside other
    source files, are maintained alongside the source, and are as much a part of the
    program as any other source file. They're essential—you can't create the application
    without them.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要考虑你的构建系统是整个源树的一部分，而不是独立的东西。Makefiles与其他源文件一起存放在版本控制之下，与源代码一起维护，并且与任何其他源文件一样是程序的一部分。它们是必不可少的——没有它们，你无法创建应用程序。
- en: '**KEY CONCEPT**'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Consider the build system a part of the source tree, and maintain the two
    together. They are intimately entwined*.'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '*将构建系统视为源树的一部分，并一起维护它们。它们紧密相连*。'
- en: '**MAKE: A TOURIST''S GUIDE**'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '**MAKE：旅行者的指南**'
- en: Make is one of the most widely used build systems in the programming world.
    Here is a whirlwind tour of what it is and what it can do.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: Make是编程世界中应用最广泛的构建系统之一。这里简要介绍一下它是什么以及它能做什么。
- en: 'Make is driven by *makefiles*, which usually reside in directories beside the
    source code they build. These makefiles contain *rules* describing how to build
    the application. Each rule describes a *target* (that is, a program or intermediate
    library to build), details what it depends on, and how to create it. Comments
    in the file are prefixed by `#`. Here''s a short example (using the hypothetical
    `compiler` program to build source):'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: Make系统由*makefiles*驱动，这些文件通常位于构建源代码旁边的目录中。这些makefiles包含*规则*，描述了如何构建应用程序。每条规则描述一个*目标*（即要构建的程序或中间库），详细说明它所依赖的内容以及如何创建它。文件中的注释以前缀`#`开头。以下是一个简短的示例（使用假设的`compiler`程序来构建源代码）：
- en: '[PRE3]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s the general idea. If you save this with the magic filename `Makefile`
    and then issue the make `myapp` command, it will be loaded and parsed. Since `myapp`
    depends on some .`o` files, these will first be built from their respective .`c`
    files using the rule provided. Then the linker command will be run to create the
    application. There are many ways to neaten this up so that it''s more manageable.
    For example, makefiles can define variables; the `myapp` rule looks nicer like
    this:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一般思路。如果你将它们保存为具有魔法文件名`Makefile`，然后发出`make myapp`命令，它将被加载并解析。由于`myapp`依赖于一些`.o`文件，因此这些文件将首先使用提供的规则从各自的`.c`文件构建。然后运行链接器命令来创建应用程序。有许多方法可以使它更整洁，以便更容易管理。例如，makefiles可以定义变量；`myapp`规则看起来更简洁，如下所示：
- en: '[PRE4]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A deeper description of the nuts and bolts of make usage is outside the scope
    of this book, but it's something every developer ought to know. There are many
    more useful features available. GUI build tools are essentially wrappers around
    this kind of functionality, hiding the detail of writing makefiles. They are generally
    easier to set up, but can be a hindrance when you want to do some advanced build
    configuration.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 对make使用细节的更深入描述超出了本书的范围，但这是每个开发者都应该知道的事情。还有许多其他有用的功能。GUI构建工具本质上是对这种功能性的包装，隐藏了编写makefiles的细节。它们通常更容易设置，但在你想要进行一些高级构建配置时可能会成为障碍。
- en: What Makes a Good Build System?
  id: totrans-1019
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是一个好的构建系统？
- en: Following are a few important qualities of a good build system.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些好的构建系统的重要特性。
- en: Simplicity
  id: totrans-1021
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性
- en: 'The build system must be accessible to *all* programmers, not just the build
    gurus. Every developer must be able to perform a build, or he can''t get any work
    done. If a build system is too complicated, it''s practically useless. It must
    be:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统必须对所有程序员都可用，而不仅仅是构建专家。每个开发者都必须能够执行构建，否则他无法完成任何工作。如果构建系统过于复杂，实际上就没什么用了。它必须：
- en: '**Simple to learn**'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**易于学习**'
- en: That is, a new developer should be able to join the team and quickly understand
    how to build software. He won't be productive until he's mastered the build procedure.
    I've worked in companies where it was considered a *rite of passage* to figure
    out how the build works and to perform one. That is not just an unhelpful attitude,
    it is dangerous—what happens when everyone who really knows how to build the code
    leaves?
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，新开发者应该能够加入团队并快速了解如何构建软件。他必须掌握构建过程才能变得高效。我在一些公司工作过，在那里，弄清楚构建过程并执行它被认为是一种*成年礼*。这不仅是一种无益的态度，而且是非常危险的——当真正知道如何构建代码的人离开时会发生什么？
- en: As software grows, it becomes larger and harder to understand. As the build
    system grows alongside it, it becomes larger and harder to understand. Builds
    tend to become more clever and more cryptic as new facilities are introduced.
    Resist complexity.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件的增长，它变得更大，更难以理解。随着构建系统与软件一起增长，它也变得更大，更难以理解。随着新功能的引入，构建往往会变得更加复杂和晦涩。抵制复杂性。
- en: '**Simple to set up**'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单设置**'
- en: 'Setting up a build means:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 设置构建意味着：
- en: Taking a clean PC (with just a fresh copy of the host OS)
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个干净的PC（仅包含主机操作系统的最新副本）
- en: Installing all the necessary software (compilers, translators, source control,
    installers, plus patches/service packs)
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装所有必要的软件（编译器、翻译器、源代码控制、安装程序，以及补丁/服务包）
- en: Installing all the necessary libraries (noting the correct versions)
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装所有必要的库（注意正确的版本）
- en: Creating the correct environment to perform a build in (this may involve setting
    up directory structures, assigning environment variables, getting the correct
    tool licenses, and so on)
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建正确的环境以执行构建（这可能涉及设置目录结构、分配环境变量、获取正确的工具许可证等）
- en: Without clear instructions for setup, how can you be sure that your build is
    a repeatable procedure?
  id: totrans-1032
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有明确的设置说明，你怎么能确保你的构建是一个可重复的过程？
- en: '**Unsurprising**'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '**不出所料**'
- en: It's best to use common, well-known build tools. They are what people expect
    and know how to use, so the learning curve is less steep. Complex build tools
    that do things no one really understands are worrying.^([[3](#ftn.CHP-10-FN-3)])
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用常见且广为人知的构建工具。它们是人们期望并知道如何使用的工具，因此学习曲线不那么陡峭。那些做事情没有人真正理解的复杂构建工具令人担忧.^([[3](#ftn.CHP-10-FN-3)])
- en: Uniformity
  id: totrans-1035
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性
- en: It's essential that everyone uses the same build system. Otherwise they're not
    building the same software. Different build mechanisms may seem equivalent—*I
    use my IDE while he uses makefiles*—but you're increasing the maintenanc effort
    and the potential for error. Subtle differences can creep in—for example, compiler
    options may not be the same, resulting in a different executable.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人使用相同的构建系统是至关重要的。否则，他们不会构建相同的软件。不同的构建机制可能看起来等效——*我使用我的IDE，而他使用makefiles*——但你会增加维护工作量和出错的可能性。细微的差异可能会悄悄出现——例如，编译器选项可能不同，导致不同的可执行文件。
- en: This dovetails with the requirement to maintain the build system alongside the
    source tree. If the build system physically *is* a part of the code, then it can't
    be ignored or avoided.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 这与维护构建系统与源树并行的要求相吻合。如果构建系统在物理上*确实是*代码的一部分，那么它就不能被忽视或避免。
- en: '**KEY CONCEPT**'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Every programmer on a project must use the same build environment. Otherwise
    you''re not all building the same software*'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '*项目中的每个程序员都必须使用相同的构建环境。否则，你们不会构建相同的软件*'
- en: This may seem blindingly obvious, but it's incredibly easy to get wrong. Even
    if you *are* all happily sharing makefiles, other differences can slip past unnoticed—mismatched
    versions of libraries, tools, or the build scripts can all lead to a different
    program being built.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常明显，但很容易出错。即使你*确实*都在愉快地共享makefiles，其他差异也可能被忽视——库、工具或构建脚本的版本不匹配都可能导致构建不同的程序。
- en: Repeatable and Reliable
  id: totrans-1041
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重复且可靠
- en: Builds must be deterministic and reliable. You should be able to determine the
    set of input files easily before performing the build. Performing two separate
    builds on the same set of files should give you exactly the same executable both
    times—the build should be *repeatable*.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 构建必须是确定性和可靠的。在执行构建之前，你应该能够轻松地确定输入文件的集合。在相同的文件集上执行两次单独的构建应该每次都给出完全相同的可执行文件——构建应该是*可重复的*。
- en: '**KEY CONCEPT**'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*A good build system allows you to repeatedly create physically identical binary
    files*.'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个好的构建系统允许你反复创建物理上完全相同的二进制文件*。'
- en: You can then mark this set of source files in the revision control system as
    a particular version of the software (or archive the files to a backup store),
    and perform many identical builds at any time in the future.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在版本控制系统中标记这组源文件为软件的特定版本（或将文件存档到备份存储中），并在未来的任何时候进行许多相同的构建。
- en: This is crucial—an important customer may find a significant bug in an old revision
    of software, and if you can't get back to that version and generate the exact
    same program, you may never be able to reproduce the failure, let alone find the
    fault.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 这至关重要——一个重要的客户可能在软件的旧版本中发现一个显著的错误，如果你无法回到那个版本并生成完全相同的程序，你可能永远无法重现失败，更不用说找到故障了。
- en: '**KEY CONCEPT**'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*You must be able to pull out a source tree from three years ago and rebuild
    it correctly*.'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '*你必须能够从三年前提取源代码树并正确地重新构建它*。'
- en: A build process that spits out an unreproducible binary is worrying. If what
    comes out of a build depends on the lunar cycle, the world becomes a hard place
    to reason about. This means that gratuitous use of C's `__DATE__` or other potentially
    changeable information should be kept to an absolute minimum in the source files.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 产生不可重复二进制的构建过程令人担忧。如果构建输出的内容依赖于月相周期，那么世界就变成了一个难以推理的地方。这意味着在源文件中应该将C的`__DATE__`或其他可能改变的信息的使用限制在绝对最小范围内。
- en: The build must work perfectly all the time—it must be *reliable*. If it falls
    over every other day or occasionally produces a broken binary, then it is worse
    than useless—it's dangerous. How can you be sure that you're testing a good binary?
    How can you be sure that your company is releasing an acceptable product? Problems
    with the build system really hamper development.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 构建必须始终完美无缺——它必须是*可靠的*。如果它每隔一天就崩溃，或者偶尔产生损坏的二进制文件，那么它不仅无用，而且危险。你怎么能确定你在测试一个好的二进制文件？你怎么能确定你的公司正在发布一个可接受的产品？构建系统的问题真的阻碍了开发。
- en: The build should be almost invisible; the only thing you need to worry about
    is how to turn the handle, and you should be assured that the right things will
    come out at the end.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应该几乎是无形的；你需要担心的事情只是如何转动把手，你应该确信最终会得到正确的结果。
- en: Atomic
  id: totrans-1052
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子性
- en: The ideal build system takes undoctored *virgin source* and compiles it all
    at once, with no human intervention. There should be no special steps you have
    to go through to perform the build. You should not have to fire up another application
    halfway through and prod a file. You shouldn't even need to run more than one
    command to perform the build. This ensures that no information is locked away
    in your head, just waiting to be lost. All the build magic is documented in a
    reliable place—the build script itself. The build is always repeatable. It's safe.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的构建系统会从未经修改的*原始源代码*一次性编译，无需人工干预。不应该有特殊的步骤需要你执行构建。你不应该在构建过程中启动另一个应用程序并推动一个文件。你甚至不需要运行多个命令来执行构建。这确保了没有信息被锁在你的脑海中，只等着丢失。所有的构建魔法都记录在一个可靠的地方——构建脚本本身。构建总是可重复的。它是安全的。
- en: '**KEY CONCEPT**'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*A good build is presented as a single step. You need only push a button or
    issue one command*.'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '*良好的构建过程被描述为单一步骤。你只需按一个按钮或发出一个命令即可*。'
- en: 'If you can''t reach this ideal (and it''s not *at all* unreasonable), then
    the less manual a build is, the better. All of the manual steps need full documentation.
    It is acceptable (in fact, it''s advisable) to break the procedure up into these
    separate parts:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法达到这个理想（而且这并不*完全*不合理），那么构建越少手动越好。所有手动步骤都需要完整的文档。将程序拆分成这些单独的部分是可以接受的（事实上，这是建议的）：
- en: Obtain the virgin source.
  id: totrans-1057
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取原始源代码。
- en: Build it.
  id: totrans-1058
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建它。
- en: Create the release distribution from this.
  id: totrans-1059
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个版本创建发布分发。
- en: See how the notion of *building* the code is separate from *obtaining* it—the
    same build instruction could potentially create any version of the software, depending
    on the version of source you start with. *Packaging* the program is also a separate
    step; for development work, you don't always want to waste time creating a full
    install package.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 看看*构建*代码的概念是如何与*获取*它分开的——相同的构建指令可以根据你开始的源代码版本创建软件的任何版本。*打包*程序也是一个单独的步骤；对于开发工作，你并不总是想浪费时间创建完整的安装包。
- en: '**A WAR STORY**'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个战争故事**'
- en: Repeatable builds are essential; you must be able to regenerate any released
    version of your software. You'll get into trouble otherwise. I once worked for
    a company that struggled with this exact problem.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 可重复构建是必不可少的；你必须能够重新生成你软件的任何已发布版本。否则你会遇到麻烦。我曾经为一家公司工作，他们正面临着这个确切的问题。
- en: They had made a live change to the code on a customer's site and did not replicate
    the change in their master copy under version control. The customer was no longer
    running an "official" software release. Later on, when the customer found a critical
    bug, the programmers couldn't reproduce it. But of course no one could figure
    out why, because the on-site tweak had been long forgotten.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在一个客户的网站上对代码进行了实时更改，但没有在版本控制的主副本中复制这个更改。客户不再运行“官方”的软件版本。后来，当客户发现一个关键错误时，程序员无法重现它。但当然，没有人能弄清楚为什么，因为现场调整已经被遗忘了。
- en: Why did they do this? Because it was much, much easier to make a quick-anddirty
    change than to do it properly (i.e., fix the bug in the main codebase, test it,
    make an official software release, ship it to the customer, and then get the appropriate
    approval and sign-off before installation). When your client's business depends
    on your software and its entire production line is waiting for you to fix a bug,
    the pressure for a dirty hack is enormous.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 他们为什么要这样做？因为快速而粗糙的修改比正确地（即，修复主代码库中的错误、测试、发布官方软件版本、将其发送给客户，然后在安装前获得适当的批准和签字）要容易得多。当你的客户的业务依赖于你的软件，并且整个生产线都在等待你修复错误时，进行快速修复的压力是巨大的。
- en: Coping with Errors
  id: totrans-1065
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应对错误
- en: At the end of development, when the dust settles over finished code, there will
    be *no* build errors. But during development you'll be breaking things all over
    the place. The build system has to cope with this and should lend a hand to deal
    with it.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发结束时，当完成代码尘埃落定后，将**没有**构建错误。但在开发过程中，你会在各个地方破坏东西。构建系统必须应对这种情况，并应该提供帮助来处理它。
- en: Your build system should not continue after an error. It should stop and leave
    you with no doubt about what broke and where it can be fixed. If the build process
    continues, other problems will almost certainly result as a consequence of that
    first skipped error. These will be very hard to understand. For your own sanity,
    don't break this rule!
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的构建系统在出现错误后不应继续运行。它应该停止，并让你毫无疑问地知道什么出了问题以及在哪里可以修复。如果构建过程继续，几乎肯定会因为第一个跳过的错误而导致其他问题。这些问题将非常难以理解。为了你自己的精神健康，不要打破这条规则！
- en: The build system should remove any incomplete objects when a build step fails.
    Otherwise the next time you run a build, it will assume that file is actually
    intact and pick up after it. This will cause much pain later on; errors that magically
    hide themselves are great fun.
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建系统应在构建步骤失败时删除任何不完整的对象。否则，下次你运行构建时，它将假设该文件实际上完好无损，并从它那里继续。这将在以后造成很多痛苦；那些神奇地隐藏自己的错误很有趣。
- en: Builds should not be *noisy*. This isn't determined so much by the build process
    as the source code that you've written.^([[4](#ftn.CHP-10-FN-4)]) If your code
    generates compiler warnings, then there is something in it that you should be
    looking into. Persuade the compiler to be quiet by writing better code. Copious
    silly warnings can cloak the more insidious messages that you *should* be reading.
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过程不应**嘈杂**。这并不是由构建过程本身决定的，而是由你所编写的源代码决定的.^([[4](#ftn.CHP-10-FN-4)]) 如果你的代码生成了编译器警告，那么其中肯定有一些你应该检查的地方。通过编写更好的代码来说服编译器保持安静。大量的愚蠢警告可能会掩盖你**应该**阅读的更隐蔽的信息。
- en: For maximum peace of mind, build with all compiler warnings enabled—switching
    them off does not fix the problem; it hides it.
  id: totrans-1070
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了最大限度地放心，请启用所有编译器警告进行构建——关闭它们并不能解决问题；它只是隐藏了问题。
- en: 'The only real way to follow this advice is from the very start: Think about
    the build process at the beginning of your project. Trying to add the flag that
    says *all warnings enabled* when you''ve already written a lot of code will result
    in an instant flood of warnings. The overwhelmingly likely response is to quickly
    turn the flag off again and pretend it never happened. Anything for an easy life.
    You really have to start as you mean to go on.'
  id: totrans-1071
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遵循这条建议的唯一真正方法是从一开始就考虑：在你项目的开始阶段就考虑构建过程。当你已经编写了大量代码时，尝试添加表示**所有警告启用**的标志，会导致立即出现大量警告。最可能的反应是迅速关闭标志，假装它从未发生过。为了轻松的生活，什么都愿意做。你真的必须从你打算开始的地方开始。
- en: '* * *'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-10-FN-3)]) I have an built-in distrust of anything more clever than
    GNU Make, but that probably says more about me than the other clever make tools.
    GNU Make is *quite* clever enough, thank you!
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-10-FN-3)]) 我对任何比GNU Make更聪明的工具都持有内置的不信任，但这可能更多地反映了我自己，而不是其他聪明的make工具。感谢GNU
    Make，它**非常**聪明！
- en: ^([[4](#CHP-10-FN-4)]) Actually, it could be—you can disable compiler warnings
    to remove the noise. This is the *wrong* way to solve the problem.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-10-FN-4)]) 实际上，这可能是——你可以禁用编译器警告来消除噪音。这是**错误**的解决问题的方式。
- en: The Mechanics
  id: totrans-1075
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建机制
- en: Beyond those quality concerns are the practicalities of a build system. To discuss
    this in concrete terms, we'll talk about make, a specific build system, and makefiles
    a lot—don't worry too much; barring syntactic differences, other build systems
    follow similar conventions (even the pretty graphical ones).
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些质量担忧之外，还有构建系统的实用性。为了具体讨论这个问题，我们将讨论make，一个特定的构建系统，以及makefiles——不要过于担心；除了语法差异外，其他构建系统遵循类似的约定（甚至包括那些漂亮的图形界面）。
- en: Choice of Targets
  id: totrans-1077
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标选择
- en: 'Makefiles define *rules* that describe how to build *targets*. (Remember: Other
    build systems work in a very similar manner, even if the terminology is subtly
    different.) The system is clever enough to infer all intermediate targets and
    build those along the way. A single makefile can contain multiple targets. This
    allows you to use one build system to generate several different outputs, such
    as:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: Makefiles 定义 *规则*，描述如何构建 *目标*。（记住：其他构建系统以非常相似的方式工作，即使术语略有不同。）系统足够智能，可以推断所有中间目标并在构建过程中构建它们。一个
    Makefile 可以包含多个目标。这允许你使用一个构建系统生成多个不同的输出，例如：
- en: Distinct programs (commonly seen when two programs have some common code components
    and so live in the build source tree)
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的程序（常见于两个程序有一些共同的代码组件，因此它们位于构建源树中）
- en: Different target platforms to build your application for (say a Windows/Apple/Linux
    version, or a desktop/PDA release)
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为构建应用程序选择不同的目标平台（例如，Windows/Apple/Linux 版本，或桌面/PDA 发布）
- en: Product variants (the full *release build* or a *demo* version with save/print
    disabled)
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品变体（完整的 *发布构建* 或禁用保存/打印的 *演示版本*）
- en: The development build (with debugging support enabled, logging switched on,
    and assertions made fatal
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发构建（启用调试支持，开启日志记录，并使断言成为致命错误）
- en: Differing *levels* of build (build just the internal libraries, build the application,
    build an entire distribution)
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的 *构建级别*（仅构建内部库，构建应用程序，构建整个发行版）
- en: You might even require some combination of these targets, say a "demonstration
    PDA" build.^([[5](#ftn.CHP-10-FN-5)]) You can design your source tree so that
    each of these targets can be built from the same place. Rather than type just
    `make`, you might type `make desktop` or `make pda`, and an appropriate executable
    will come out the other end. (The name following `make` is the rule it should
    attempt to build.)
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可能需要这些目标的某些组合，例如一个“演示PDA”构建.^([[5](#ftn.CHP-10-FN-5)]) 你可以设计你的源树，使得每个这些目标都可以从同一个地方构建。你不必只输入
    `make`，你可以输入 `make desktop` 或 `make pda`，然后就会得到一个合适的可执行文件。（`make` 后面的名称是它应该尝试构建的规则。）
- en: There is a huge benefit in doing this rather than having separate source trees
    for each target. Maintaining several source trees across which most of the code
    is identical would be an intense and error-prone task. You could easily forget
    to apply one of your modifications to all copies of the code.^([[6](#ftn.CHP-10-FN-6)])
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 与为每个目标维护单独的源树相比，这样做有很大的好处。在大多数代码都相同的情况下维护多个源树将是一项艰巨且容易出错的任务。你可能会忘记将你的修改之一应用到代码的所有副本上.^([[6](#ftn.CHP-10-FN-6)])
- en: 'So how do these target rules differ? The actual differences can boil down to
    a number of things:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些目标规则有何不同？实际差异可以归结为许多事情：
- en: Different files being built (e.g., `save_release.c` or `save_demo.c`)
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在构建不同的文件（例如，`save_release.c` 或 `save_demo.c`）
- en: Different macro definitions being passed through to the compiler (e.g., the
    compiler predefines a `DEMO_VERSION` macro to select appropriate `#ifdef`ed code
    in `save.c`)
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给编译器的不同宏定义（例如，编译器预定义一个 `DEMO_VERSION` 宏，以选择 `save.c` 中适当的 `#ifdef`ed 代码）
- en: Different compiler options being used (e.g., to enable debugging support)
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的编译器选项（例如，启用调试支持）
- en: Different tool sets or environments being selected for building (e.g., using
    the correct compiler for the target platform)
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为构建选择不同的工具集或环境（例如，使用针对目标平台的正确编译器）
- en: While you could have any number of targets for all sorts of minor differences,
    it opens the possibility of making your build system complex and unwieldy. Some
    selections can be moved to build configuration options. Some configuration can
    actually be done at code install time, or even at run time. This is preferable
    if it reduces the number of different builds that exist and require testing.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以为所有各种细微差异设置任意数量的目标，但这可能会使你的构建系统变得复杂且难以控制。一些选择可以移动到构建配置选项。一些配置实际上可以在代码安装时完成，甚至可以在运行时完成。如果这减少了需要测试的不同构建的数量，那么这是更好的选择。
- en: '**LIFE AFTER MAKE**'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '**MAKE 之后的生活**'
- en: A lot of the issues we're investigating here are quite specific to the C-style
    development cycle, where a compiler generates object code and libraries from source
    files, and these are linked into a final executable. Some languages follow a different
    model. Java simplifies the build process greatly; the javac compiler takes over
    the role of make, performing dependency checks automatically. It locks you down
    more, enforcing a particular build tree structure, but makes your life easier
    by doing so.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里调查的许多问题都非常特定于C风格的开发生命周期，其中编译器从源文件生成目标代码和库，并将它们链接到最终的可执行文件。有些语言遵循不同的模型。Java极大地简化了构建过程；javac编译器接管了make的角色，自动执行依赖性检查。它使你更加受限，强制执行特定的构建树结构，但这样做也使你的生活更加轻松。
- en: Simple Java programs don't need an elaborate build system; one `javac` command
    can safely rebuild the world. However, a reasonably large Java project often *will*
    employ make. We've seen that there is more to a build than just compiling source.
    You need a mechanism to prepare supporting files, to run automated tests, and
    to create the final distribution. Make is a good framework for this to hang off
    of, so it isn't entirely redundant.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的Java程序不需要复杂的构建系统；一个`javac`命令就可以安全地重建整个世界。然而，一个相当大的Java项目通常*会*使用make。我们已经看到，构建不仅仅是编译源代码。你需要一个机制来准备支持文件，运行自动化测试，以及创建最终的发行版。Make是一个很好的框架，可以挂载这些功能，所以它并不是完全多余的。
- en: Housekeeping
  id: totrans-1095
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 家庭管理
- en: For every target rule you define, there should be a corresponding *clean* rule
    that undoes all the build operations—removing the program executable, intermediate
    library, object files, and any other files created during the build. The source
    tree should revert to its original virgin state—it's relatively easy to verify
    that it does.^([[7](#ftn.CHP-10-FN-7)])
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你定义的每个目标规则，都应该有一个相应的*清理*规则来撤销所有的构建操作——移除程序可执行文件、中间库、目标文件以及构建过程中创建的任何其他文件。源代码树应该恢复到其原始的原始状态——验证这一点相对容易。（^[[7](#ftn.CHP-10-FN-7)]）
- en: This implies that a build system that physically alters the source files is
    nasty—how can you easily revert from these changes? You should instead use the
    original files as templates, and send modifications to a different output file.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个物理修改源文件的构建系统是令人讨厌的——你怎么能轻松地回滚这些更改？你应该使用原始文件作为模板，并将修改发送到不同的输出文件。
- en: Clean rules are a good housekeeping convention. They allow you to easily sweep
    everything away and rebuild from scratch when you think that a build gremlin is
    catching up to you.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 清理规则是一种良好的家庭管理惯例。它们允许你在认为构建小鬼正在逼近时，轻松地将所有内容清除并从头开始重建。
- en: '**KEY CONCEPT**'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*For every build rule, have a corresponding clean rule that undoes the action*.'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于每个构建规则，都应该有一个相应的清理规则来撤销操作*。'
- en: Dependencies
  id: totrans-1101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖关系
- en: How does a build system know which files depend on which others? Short of ESP,
    it's a difficult task, and so we will elicit help from the people who do know.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统如何知道哪些文件依赖于哪些其他文件？在没有ESP的情况下，这是一个困难的任务，因此我们将寻求那些知道的人的帮助。
- en: '*You* provide dependency information in your makefile rules: a recipe in make''s
    preferred format. Make can build and follow the tree of dependencies, inspect
    each file''s timestamp, and work out which parts need to be rebuilt after any
    modification.'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '*你*在makefile规则中提供依赖信息：make首选格式的配方。Make可以构建并跟踪依赖树，检查每个文件的最后修改时间戳，并在任何修改后确定哪些部分需要重新构建。'
- en: This is simple enough for an executable build rule—you just need to specify
    which object files and libraries comprise it. You don't, however, want to laboriously
    specify dependency information for every single source file; no doubt there are
    many `#include`d files, which themselves `#include` many others. Quite a list.
    It would be really easy to type incorrectly at first and very likely to become
    out of date; you could easily add a new `#include` and forget to alter the makefile
    correspondingly.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可执行构建规则来说，这已经足够简单了——你只需要指定哪些目标文件和库构成了它。然而，你并不想费力地为每个单独的源文件指定依赖信息；毫无疑问，有许多被`#include`的文件，它们自己又`#include`了许多其他文件。这是一个相当长的列表。一开始很容易打错字，而且很可能变得过时；你可能会添加一个新的`#include`，却忘记相应地修改makefile。
- en: Who *does* know about all this dependency information? The compiler does—it's
    the one component in the build system that actually traces all source file dependencies.
    Helpfully, all good compilers have an option that causes them to spit out dependency
    information. The trick is to write a make rule that gathers this dependency information,
    places it in an appropriately formatted file, and then includes *that* in the
    dependency tree.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 谁**知道**所有这些依赖信息？编译器知道——它是构建系统中唯一一个实际追踪所有源文件依赖的组件。方便的是，所有好的编译器都有一个选项，可以让它们输出依赖信息。技巧是编写一个make规则，收集这些依赖信息，将其放置在适当格式的文件中，然后将其包含在依赖树中。
- en: Automated Builds
  id: totrans-1106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动构建
- en: 'If your build procedure is atomic, a simple matter of firing off one command,
    you can easily set up overnight builds of the entire source tree.^([[8](#ftn.CHP-10-FN-8)])
    A regular overnight build takes the code that has been produced during the day
    and applies the full build procedure to it. This is a remarkably helpful practice
    with many benefits:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的构建过程是原子的，只需发出一个命令，你就可以轻松地设置整个源树的夜间构建.^([[8](#ftn.CHP-10-FN-8)]) 定期的夜间构建将应用全天的代码，并对其执行完整的构建过程。这是一种非常有帮助的做法，具有许多好处：
- en: Every morning there's a fresh copy of the state of the art. Developers often
    spend the day in their own little worlds, forgetting to synchronize their code
    with colleagues' check-ins. This technique provides a painless integration test,
    checking that everything knits together properly.
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天早上都会有一份最新的技术状态。开发者们常常整天沉浸在自己的小世界里，忘记与同事的代码提交同步。这项技术提供了一种无痛苦的集成测试，确保一切都能正确地编织在一起。
- en: It identifies build problems early on, with no extra work on your part. When
    you sit down at your desk in the morning, coffee in hand, you can see whether
    the source tree is in a buildable state. You'll know immediately where to start
    fixing, rather than wait for your own build to complete.
  id: totrans-1109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在早期就识别出构建问题，而无需你做额外的工作。当你早上坐在办公桌前，手里拿着咖啡，你可以看到源树是否处于可构建状态。你将立即知道从哪里开始修复，而不是等待自己的构建完成。
- en: You can add automated regression and stress tests to the overnight build. This
    is a good way to sanity-test code before anyone ever tries to use it. During the
    day, you may not have time to run the full test suite with every build—this ensures
    that it never gets overlooked. It's a potent validation mechanism.
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将自动回归和压力测试添加到夜间构建中。这是一种在任何人尝试使用代码之前对代码进行合理性测试的好方法。在白天，你可能没有时间在每次构建时运行完整的测试套件——这确保了它永远不会被忽视。这是一个强大的验证机制。
- en: The overnight build can be used as a yardstick of project progress. Publish
    the overnight test results and, as more and more tests pass, the developers gain
    a sense of achievement.
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 夜间构建可以用作项目进度的衡量标准。发布夜间测试结果，随着越来越多的测试通过，开发者会获得成就感。
- en: You can make actual product releases from the overnight build. You'll trust
    this build to have not suffered from command-typing mistakes, misconfiguration,
    or other human errors.
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从夜间构建中制作实际的产品发布。你会信任这个构建没有受到命令输入错误、配置错误或其他人为错误的影响。
- en: It proves that you really know how to build the software and that the build
    procedure really *is* atomic. Without running automatic builds, how do you know
    that your build process doesn't rely on some other activity, like one of the developers
    cleaning away the old build tree first?
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它证明了你真的知道如何构建软件，并且构建过程确实是原子的。如果没有运行自动构建，你怎么知道你的构建过程不依赖于其他活动，比如开发者首先清理旧的构建树？
- en: '**KEY CONCEPT**'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Establish an automatic build of your software. Use it to ensure that your
    codebase is in a consistent state*.'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '*建立软件的自动构建。使用它来确保代码库处于一致状态*。'
- en: Automated builds are especially good for big systems (where a build of *everything*
    may take hours and hours) or for systems with many people working alongside one
    another (where each developer may not have a copy of the absolute latest system
    source at any given point).
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 自动构建对于大型系统（构建所有内容可能需要几个小时）或多人协作的系统（每个开发者可能在任何时候都没有最新的系统源代码副本）特别有用。
- en: A good practice with nightly builds is to capture the *build log* (the output
    of the build procedure) and make it publicly accessible. Perhaps even email the
    results around when the build fails, to highlight the problem. It's important
    to know what happened each time a build ran, especially when something goes wrong.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于夜间构建，一个好的做法是捕获*构建日志*（构建过程的输出）并使其公开可访问。也许甚至在构建失败时将结果发送电子邮件，以突出显示问题。了解每次构建发生的事情很重要，尤其是在出现问题的时候。
- en: 'The overnight build becomes a central heartbeat of project development. The
    code is developing healthfully and happily if the builds are successful. A great
    rule enforced on many projects is: *Don''t break anything in the source tree*—checking
    in code that breaks during the nightly build is punishable by something extremely
    painful and unpleasant (preferably involving public humiliation). A second rule
    is this: *If the build breaks, it''s everyone''s problem*. If the overnight build
    fails, all developers must put down their down tools until it works again.'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 夜间构建成为项目开发的核心心跳。如果构建成功，代码就会健康、快乐地发展。许多项目上强制执行的一个伟大规则是：*不要在源树中破坏任何东西*——在夜间构建期间破坏代码的行为会受到极其痛苦和令人不快的惩罚（最好是涉及公开羞辱）。第二个规则是：*如果构建失败，那是每个人的问题*。如果夜间构建失败，所有开发者都必须放下手中的工具，直到它再次工作。
- en: You can take this automatic build procedure to the extreme, and use tools that
    perform a build whenever the source repository is altered. This is known as continuous
    integration and is a powerful way to check that your code is consistent and buildable
    at any point in time.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个自动构建过程推向极致，并使用在源代码库更改时执行构建的工具。这被称为持续集成，并且是检查你的代码在任何时间点都是一致和可构建的强大方式。
- en: Build Configuration
  id: totrans-1120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建配置
- en: 'A good build system allows you to configure certain aspects on a per-build
    basis. This could be via options in your IDE, but makefiles usually achieve this
    by defining *variables*. Variables can be picked up from a number of places:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的构建系统允许你根据每个构建配置某些方面。这可以通过你的IDE中的选项实现，但makefile通常通过定义**变量**来实现。变量可以从多个地方获取：
- en: Inherited from the calling environment
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从调用环境中继承
- en: Set on make's command line
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在make命令行上设置
- en: Defined explicitly within a makefile
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在makefile中显式定义
- en: 'Configuration variables are commonly used in the following ways:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 配置变量通常按以下方式使用：
- en: A `PROJECT_ROOT` variable is defined, pointing to the root of the build tree.
    This allows the build system to know where to look for other files—for example,
    to establish paths for header files. You really don't want to hard-code the location
    of the build tree on your development machine. If you did, you could never move
    it around, and you wouldn't be able to manage two build trees at the same time.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个`PROJECT_ROOT`变量，指向构建树的根。这允许构建系统知道在哪里查找其他文件——例如，为头文件建立路径。你真的不希望在开发机器上硬编码构建树的位置。如果你这样做了，你就无法移动它，而且你将无法同时管理两个构建树。
- en: Other variables may specify where to find each external library (so you can
    point the build at different versions for testing purposes).
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他变量可能指定每个外部库的位置（这样你可以在测试目的下指向不同的版本）。
- en: They may specify the kind of build to produce (*development* or *release*, for
    example).
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能指定要生成的构建类型（例如，*开发*或*发布*）。
- en: The command to invoke each build tool (compiler, linker, etc.) can be placed
    into a variable. This makes it easy to test a different set of command-line parameters,
    or to employ a different vendor's tool.
  id: totrans-1129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用每个构建工具（编译器、链接器等）的命令可以放入一个变量中。这使得测试不同的命令行参数或使用不同供应商的工具变得容易。
- en: 'You can put default values into the makefile. This serves two purposes: it
    documents all the available options and means you don''t *have* to provide values
    for every config option all the time.'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在makefile中放入默认值。这有两个目的：它记录了所有可用的选项，意味着你不必总是为每个配置选项提供值。
- en: Recursive Make
  id: totrans-1131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归Make
- en: Source code naturally nests into directories. If all the files in a large project
    got dumped into one directory, things would rapidly become unmanageable. Since
    the source tree nests, the build system has to nest too. Far from making life
    more complex, accommodating this nesting can make the build system more flexible.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码自然地嵌套到目录中。如果一个大项目中的所有文件都放入一个目录中，事情会迅速变得难以管理。由于源树嵌套，构建系统也必须嵌套。远非使生活更加复杂，适应这种嵌套可以使构建系统更加灵活。
- en: A makefile in one directory can invoke the makefiles in subordinate directories
    by firing off another `make` command, just as it would invoke a compiler. This
    is a common technique known as *recursive make*; the build system that recurses
    into each subdirectory builds the components in there and returns to build the
    components in this directory. In this way, you can type `make` from the project
    root directory to build the whole codebase, or within a subcomponent's directory
    for a partial build. Whatever you want to be built is built.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: Recursive make helps to compartmentalize and manage build components, but introduces
    some problems of its own. It is slow (as it fires off many child processes to
    traverse into subdirectories), and since each child-make only sees its portion
    of the entire build tree, it can get dependency information incorrect. Be wary
    of recursive make if you see it—prefer to make non-recursive build systems. (For
    more on this, see the answer to this chapter's "[Mull It Over](ch09s10.html#mull_it_over-id8
    "Mull It Over")" question 7 on page 506.)
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: '^([[5](#CHP-10-FN-5)]) In this case, the mechanism changes: You can only build
    one target at a time, so the "demo-ness" would become a build configuration rather
    than a target. A later section discusses configurations.'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#CHP-10-FN-6)]) Note how this dangerous approach is different from maintaining
    multiple *branches* of a project in a revision control system. Revision control
    systems provide a mechanism to *merge* changes across branches and to easily compare
    branches for differences.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#CHP-10-FN-7)]) Just do a build, do a clean, and then check the tree
    for differences from the start state.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#CHP-10-FN-8)]) Time-delayed commands can be set up in Unix using the
    cron utility or in Windows using the Scheduled Tasks facility.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: Please Release Me
  id: totrans-1140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some builds are particularly important and require more care in their preparation.
    These are *release builds*, builds that are made with a special purpose, rather
    than in the course of code development. A release could be one of a number of
    exciting events: a beta version, the first official product release, or a maintenance
    release. It may also be an internal development milestone or an interim release
    to the test department; these builds won''t leave the company but are held in
    as high regard as external releases, almost a fire drill for an official release.'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: 'If the build system is carefully crafted, there shouldn''t be any extra preparation
    needed for a release build. However, these important builds must be handled thoughtfully,
    so we need to make sure that no build issues compromise the final executable.
    The key concerns with release builds are:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: Release builds should always come from a virgin source tree, not from someone's
    half-built development tree. Start from scratch. We need to know the exact state
    of the source files being built. Do not trust the files on Joe's computer to be
    in a "good enough" state.
  id: totrans-1143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prior to the build itself, a specific step identifies which source code and
    which particular file versions to include in this release. It then marks them
    in some manner, usually by tagging or labeling them in the source control system.
    The release's file set is now retrievable at any later point.
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建本身之前，一个特定的步骤会确定要包含在这个发布中的哪些源代码和特定文件版本。然后以某种方式标记它们，通常是通过在源控制系统中标记或标签它们。现在可以在任何后来的时间点检索发布文件集。
- en: '**THE (SOURCE) TREE OF KNOWLEDGE**'
  id: totrans-1145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**知识（源）树**'
- en: All code lives in a *source tree*; a file structure housing directories and
    source files. The structure of this tree affects how easy the code is to work
    with. A messy glob of files is far harder to understand than a neatly arranged
    hierarchy. We can use the source file structure to our advantage, making development
    easier. This tree structure goes hand-in-hand with the build system, since the
    build system physically is a part of the source tree (hence the term *build tree*
    is used interchangeably with *source tree*). A modification to one requires meddling
    with the other.
  id: totrans-1146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有代码都存在于一个*源树*中；这是一个包含目录和源文件的文件结构。这个树的结构会影响代码的可操作性。一团乱糟糟的文件远比一个整洁的层次结构难以理解。我们可以利用源文件结构来提高开发效率。这个树结构与构建系统紧密相连，因为构建系统实际上是源树的一部分（因此术语*构建树*与*源树*可以互换使用）。对其中一个的修改需要干预另一个。
- en: We divide code into separate modules, libraries, and applications. A good source
    tree reflects that structure. The code composition should map neatly into files,
    using directories as a logical grouping mechanism. This helps to manage development
    with multiple programmers—each person will probably be working in his own self-contained
    directory, removed from other people's work by a reasonably safe distance.
  id: totrans-1147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将代码划分为独立的模块、库和应用。一个好的源树反映了这种结构。代码组成应该整洁地映射到文件中，使用目录作为逻辑分组机制。这有助于管理多程序员开发——每个人可能都会在自己的自包含目录中工作，与其他人的工作保持合理的距离。
- en: '**Libraries**'
  id: totrans-1148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**库**'
- en: Place each library in its own self-contained directory. Use the tree structure
    to differentiate the library *interface* (the public header files) from private
    *implementation* details. It is a good idea to place the public API within a directory
    on the compiler's lookup path and keep any private headers out of the way.
  id: totrans-1149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将每个库放在一个独立的自包含目录中。使用树结构来区分库*接口*（公共头文件）和私有的*实现*细节。将公共API放在编译器查找路径上的目录中是一个好主意，并将任何私有头文件放在一边。
- en: '**Applications**'
  id: totrans-1150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**应用程序**'
- en: Structuring is easier; there are no public files as such, just a collection
    of source files that link to libraries. Even so, wrap each application in its
    own directory to make its bounds clear. If the application is large enough to
    have distinct constituent parts, they should be separated into subdirectories,
    or even libraries, and built separately. Make the build tree reflect the program
    structure.
  id: totrans-1151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结构化更容易；没有公共文件，只有一些链接到库的源文件集合。即便如此，每个应用程序都应该封装在自己的目录中，以明确其边界。如果应用程序足够大，有明显的组成部分，它们应该被分离到子目录中，甚至可以是库，并单独构建。使构建树反映程序结构。
- en: '**Third-party code**'
  id: totrans-1152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**第三方代码**'
- en: The source tree should clearly mark *your own* code from third-party work. Projects
    increasingly rely on others' code; common libraries are brought in from outside
    (from commercial vendors, free software projects, or even other parts of the company).
    These external files should be kept separate.
  id: totrans-1153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 源树应该清楚地标记出*你自己的*代码与第三方工作的区别。项目越来越多地依赖于他人的代码；常见的库是从外部引入的（来自商业供应商、免费软件项目，甚至是公司内的其他部分）。这些外部文件应该保持独立。
- en: '**Other stuff**'
  id: totrans-1154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**其他事项**'
- en: Program documentation can live in the source tree. Put it in directories beside
    the code it refers to. The same holds for graphics and any other supporting files.
  id: totrans-1155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序文档可以存放在源树中。将其放在与它相关的代码旁边的目录中。同样适用于图形和其他任何支持文件。
- en: Each release build has a particular name you identify it by, sometimes a cool
    code name, sometimes just a build number. This should tally with the source control
    label the code was marked with. If you and I agree that we're talking about "build
    five" when investigating a fault, then we're working in harmony. If you are working
    with build five, but I found a fault in build six, how do we know we'll see the
    same issues?
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个发布构建都有一个特定的名称，你可以通过它来识别，有时是一个酷炫的代号，有时只是一个构建号。这应该与代码标记的源控制标签相匹配。如果我们同意在调查故障时谈论“第五版”，那么我们就在一起工作。如果你正在使用第五版，但我发现第六版中有一个故障，我们如何知道我们会看到相同的问题？
- en: '**KEY CONCEPT**'
  id: totrans-1157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Release builds are always made from virgin source. Ensure that these pristine
    sources can always be retrieved from source control or a backup archive in the
    future*.'
  id: totrans-1158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*发布构建始终从原始源代码开始。确保这些原始源代码在将来可以从源代码控制或备份存档中检索到*。'
- en: There may be some extra packaging stage after the code has been built, like
    preparing a CD, adding documentation, integrating licensing information, or whatever.
    This step should also be automated.
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码构建完成后，可能会有一些额外的打包阶段，例如准备光盘、添加文档、集成许可信息，或者任何其他内容。这一步也应该自动化。
- en: Each release should be archived and stored for future reference. Obviously you
    store a copy of the final built executable in whatever form it ships to the user
    (the exact shipped Zip file, self-extracting EXE, or whatever). You should also
    capture the final state of the build tree if possible, but often this will be
    enormous and impractical.
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个版本都应该存档并存储以供将来参考。显然，你应该存储最终构建的可执行文件的副本，无论它以何种形式发送给用户（确切的发送Zip文件、自解压EXE，或任何其他形式）。如果可能的话，你也应该捕获构建树的最终状态，但通常这会非常大且不切实际。
- en: At the very least, the *build log*, the exact sequence of commands issued and
    the response generated, should be retained. These logs allow you to look back
    over old builds and see which compiler errors were overlooked or exactly what
    happened during the build. Sometimes this can give a clue into a fault reported
    in a years-old version of product that has long since been discontinued.
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少，应该保留*构建日志*，即发出的确切命令序列和生成的响应。这些日志允许你回顾旧构建，查看哪些编译器错误被忽略，或者在构建过程中确切发生了什么。有时这可以提供线索，了解在产品多年前的版本中报告的故障。
- en: Each release has a *release note* that describes what has changed. It may or
    may not be a customer-facing document, depending on exactly what you're building.
    These notes should also be archived. Usually the release note describes the changes
    since the last release and contains updates subsequent to the printing of the
    official documentation, any known issues, upgrade instructions, and so on. It
    is an important part of the release procedure and shouldn't be overlooked.
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个版本都有一个*发布说明*，描述了发生了什么变化。这可能是或可能不是面向客户的文档，具体取决于你正在构建的内容。这些说明也应该存档。通常，发布说明描述了自上次发布以来的变化，并包含官方文档打印后的更新、已知问题、升级说明等。它是发布流程的重要组成部分，不应被忽视。
- en: When performing release builds, you must select the correct set of compiler
    switches—they might differ from those used in development builds. Debugging support
    gets switched off, for example. You also need to choose what level of code optimization
    is appropriate. Optimization may be disabled for development builds since the
    optimizer often takes a particularly long time to execute. This can become unbearable
    on very large build trees. However, ramping the optimizer up to warp speed nine
    may expose compiler bugs that break your code; you have to carefully choose (and
    test) a level.
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行发布构建时，你必须选择正确的编译器开关——它们可能与开发构建中使用的不同。例如，调试支持会被关闭。你还需要选择适当的代码优化级别。对于开发构建，优化可能被禁用，因为优化器通常需要特别长的时间来执行。在非常大的构建树中，这可能会变得难以忍受。然而，将优化器加速到九倍速度可能会暴露编译器错误，这些错误会破坏你的代码；你必须仔细选择（并测试）一个级别。
- en: If you use different sets of compiler options for development and release builds,
    beware. You *must* test the release builds regularly, long before a deadline approaches.
    Aim to minimize the differences between release and development builds.
  id: totrans-1164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你为开发和发布构建使用不同的编译器选项集，要小心。你*必须*在截止日期临近之前定期测试发布构建。目标是尽量减少发布构建和开发构建之间的差异。
- en: '**KEY CONCEPT**'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Ensure that you test the release configuration of your application, not just
    the development builds. Subtle differences may adversely affect the code''s behavior*.'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保你测试的是应用程序的发布配置，而不仅仅是开发构建。细微的差异可能会对代码的行为产生不利影响*。'
- en: Since creating a release build is a relatively involved task and is so important
    to get right, responsibility is usually delegated to a nominated team member (perhaps
    one of the coders, perhaps someone in QA). That person produces all the release
    builds for the project to make sure that each build is of the same high quality.
    Release builds are as much about procedure as they are about the build system.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建发布构建是一个相对复杂的任务，而且非常重要，因此责任通常委托给指定的团队成员（可能是其中一位编码者，也可能是QA部门的人）。这个人负责为项目生成所有发布构建，以确保每个构建都具有相同的高质量。发布构建既关乎程序，也关乎构建系统。
- en: Jack-of-All-Trades, Buildmaster Of?
  id: totrans-1168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万能的构建大师？
- en: Many organizations employ a specific person to fulfill a *build engineer* role,
    often known as the *buildmaster*. This person's job is to maintain the build system.
    The role may also involve planning and managing release schedules, or it may be
    purely technical. The buildmaster knows the build system intimately. He or she
    probably sets it up, adds new targets as required, maintains the overnight build
    scripts, and so on. The buildmaster also owns the build system documentation,
    and probably administers the source control system.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织雇佣特定的人来担任*构建工程师*角色，通常被称为*构建大师*。这个人的工作是维护构建系统。这个角色可能还涉及规划和管理发布计划，或者它可能完全是技术性的。构建大师对构建系统了如指掌。他或她可能设置了它，根据需要添加新目标，维护夜间构建脚本，等等。构建大师还拥有构建系统文档，并可能管理源代码控制系统。
- en: The buildmaster performs the release builds, and for this reason is often heavily
    involved with tracking component stability. He or she is charged with ensuring
    the reliability and safety of the release process.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 构建大师执行发布构建，因此通常与跟踪组件稳定性密切相关。他或她负责确保发布过程的可靠性和安全性。
- en: The buildmaster is not always a specific full-time position; sometimes a programmer
    will double in this task.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 构建大师并不总是指一个特定的全职职位；有时程序员会兼职承担这项任务。
- en: In a Nutshell
  id: totrans-1172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: It is easier to pull down than to build up
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 拆卸比构建更容易
- en: --Latin proverb
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: --拉丁谚语
- en: On the face of it, building software is easy if you have the right tools. But
    you have to know how to use the tools properly. The quality of your build system
    is paramount; without a safe, reliable build process, you can't realistically
    develop solid code. Producing trustworthy release builds for production is an
    even more involved matter—it requires a thorough approach and a well-defined procedure.
    It is important to have an understanding of what's going on when you fire off
    a build, even if you don't have to alter the build system every day.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面上，如果你有合适的工具，构建软件很容易。但你必须知道如何正确使用这些工具。构建系统的质量至关重要；如果没有安全、可靠的构建过程，你无法现实地开发出坚实的代码。为生产环境生成可信赖的发布构建是一个更加复杂的任务——它需要一个彻底的方法和明确定义的程序。即使你不必每天更改构建系统，了解你启动构建时发生的事情也很重要。
- en: Performing good builds is not a straightforward task; our jobs are safe from
    the proverbial infinite number of monkeys. They're too busy arguing about which
    of their infinite number of text editors is the better one, anyway.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 执行良好的构建并非易事；我们的工作不会受到传说中的无穷无尽的猴子的影响。他们太忙于争论他们无穷无尽的文本编辑器中哪一个更好，无论如何。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-1177
  prefs: []
  type: TYPE_TB
  zh: '| 优秀的程序员 . . . | 次等的程序员 . . . |'
- en: '| --- | --- |'
  id: totrans-1178
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand how their build system works, how to use it, and how to extend it
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解他们的构建系统是如何工作的，如何使用它，以及如何扩展它
- en: Craft simple, atomic build systems, and maintain them alongside the source code
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计简单、原子化的构建系统，并与其源代码一起维护
- en: Automate as many build activities as possible
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能自动化许多构建活动
- en: Use overnight builds to catch integration problems
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用夜间构建来捕捉集成问题
- en: '|'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ignore build system mechanics, then get caught by silly build problems
  id: totrans-1185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略构建系统机制，然后被愚蠢的构建问题困扰
- en: Don't care how unsafe and unreliable their build system is
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不关心他们的构建系统有多么不安全和不可靠
- en: Expect newcomers to pick up their baroque build procedure in an almost adversarial
    manner
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期待新来者以一种几乎对抗的方式掌握他们复杂的构建流程
- en: Create thrown-together release builds without following a defined release procedure
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不遵循定义的发布流程就草率地创建发布构建
- en: '|'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-1190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章. 寻找错误")'
- en: Describes how to deal with build errors.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 描述如何处理构建错误。
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章. 实践安全源代码")'
- en: The build tree is held in a source control system, and the two are intimately
    linked.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 构建树存储在源代码控制系统中，两者紧密相连。
- en: '![See Also](tagoreillycom20080909nostarchimages207476.png.jpg)'
  id: totrans-1195
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207476.png.jpg)'
- en: Get Thinking
  id: totrans-1196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 502.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些问题的详细讨论可以在第502页的"[附录A](apa.html "附录A. 答案与讨论")"部分找到。
- en: Mull It Over
  id: totrans-1198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: Why should people with nice integrated development environments worry about
    using a command-line make utility, when they can just hit a single button to build
    their project?
  id: totrans-1199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么拥有良好的集成开发环境的人应该担心使用命令行make工具，当他们只需按一个按钮就可以构建他们的项目时？
- en: Why is it important to treat the extraction of source code as a separate step
    from building it?
  id: totrans-1200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么将源代码的提取视为与构建分开的步骤很重要？
- en: Where should the intermediate files from construction steps (e.g., object files)
    be put?
  id: totrans-1201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建步骤的中间文件（例如，目标文件）应该放在哪里？
- en: If you add an automated test suite to the build system, should it run automatically
    after the software is built, or must you fire a separate command to invoke the
    tests?
  id: totrans-1202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将自动测试套件添加到构建系统中，它应该在软件构建后自动运行，还是你必须发出一个单独的命令来调用测试？
- en: Should the overnight build be a *debug* or *release* build?
  id: totrans-1203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 夜间构建应该是*调试*还是*发布*版本？
- en: Write a make rule to automatically generate dependency information from your
    compiler. Show how to use this information in the makefile.
  id: totrans-1204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个make规则来自动从你的编译器生成依赖信息。展示如何在makefile中使用这些信息。
- en: Recursive make is a popular method of creating a modular build system spanning
    several directories. However, it is fundamentally flawed. Describe its problems
    and suggest alternatives.
  id: totrans-1205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归make是创建跨越多个目录的模块化构建系统的流行方法。然而，它存在根本性的缺陷。描述其问题并建议替代方案。
- en: Getting Personal
  id: totrans-1206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: Do you know how to perform different types of compilation using your build system?
    How can you build a debug or release version of the application from the same
    sources, with the same makefiles?
  id: totrans-1207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道如何使用你的构建系统执行不同类型的编译吗？你如何从相同的源代码、相同的makefile构建调试或发布版本的应用程序？
- en: 'How good is your current project''s build process? Does it rate well against
    the characteristics in this chapter? How could you improve it? How easy is it
    to:'
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你当前项目的构建过程有多好？它是否与本章中提到的特性相匹配？你该如何改进它？以下操作有多容易：
- en: Add a new file to a library?
  id: totrans-1209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向库中添加新文件？
- en: Add a new directory of code?
  id: totrans-1210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的代码目录？
- en: Move or rename a file of code?
  id: totrans-1211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动或重命名代码文件？
- en: Add a different build configuration (say, a demo build)?
  id: totrans-1212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加不同的构建配置（比如，演示构建）？
- en: Build two configurations in one copy of the source tree without doing a clean
    in between?
  id: totrans-1213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不进行清理的情况下，在一个源代码树的副本中构建两个配置？
- en: Have you ever created a build system from scratch? What drove you to its particular
    design?
  id: totrans-1214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否曾经从头开始创建一个构建系统？是什么驱使你选择了特定的设计？
- en: Everyone suffers from flaws in a build system from time to time. When programming
    a build script, you're as likely to introduce bugs as you are when programming
    real code.
  id: totrans-1215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个人有时都会在构建系统中遇到缺陷。当编写构建脚本时，你引入错误的可能性与编写真实代码时一样大。
- en: What kinds of build errors have you been bitten by, and how could you fix, or
    even prevent, them?
  id: totrans-1216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你遇到过哪些构建错误，你该如何修复，甚至预防它们？
- en: Chapter 11. THE NEED FOR SPEED
  id: totrans-1217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。速度的需求
- en: '*Optimizing Programs and Writing Efficient Code*'
  id: totrans-1218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*优化程序和编写高效代码*'
- en: There is more to life than increasing its speed.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 生活不仅仅是提高速度。
- en: --Mahatma Gandhi
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: --甘地
- en: We live in a fast food culture. Not only must our dinner arrive yesterday; our
    car should be fast and our entertainment instant. Our code should also run like
    lightning. I want my result. And I want it *now*.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个快餐文化中。不仅我们的晚餐应该昨天就到，我们的汽车应该快速，我们的娱乐应该即时。我们的代码也应该像闪电一样运行。我想要我的结果。而且我想要它*现在*。
- en: Ironically, writing fast programs takes a long time.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，编写快速程序需要很长时间。
- en: 'Optimization is a spectre hanging over software development, as renowned computer
    scientist W.A. Wulf observed: "More computing sins are committed in the name of
    efficiency (without necessarily achieving it) than for any other single reason—including
    blind stupidity." (Wulf 72)'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是软件开发的幽灵，正如著名计算机科学家W.A. Wulf所观察到的：“在效率的名义下犯下的计算错误（不一定实现了效率）比任何其他单一原因都要多——包括盲目的愚蠢。”（Wulf
    72）
- en: 'Optimization is a well-worn subject, on which everyone has offered their two
    cents'' worth, and the same advice has been served time and time again. But despite
    this, a lot of code is *still* not developed sensibly. Optimization seems like
    a good idea, but programmers get it wrong all too often: They get sidetracked
    by the lure of efficiency, they write bad code in the name of performance, they
    optimize when it''s really not necessary, or they apply the wrong kind of optimizations.'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一个老生常谈的话题，每个人都提出了自己的看法，同样的建议一次又一次地被提出。但尽管如此，许多代码仍然没有合理地开发。优化看起来是个好主意，但程序员经常出错：他们被效率的诱惑所分散，以性能的名义编写糟糕的代码，他们在不必要的时候进行优化，或者应用了错误的优化方式。
- en: In this chapter, we'll address this. We'll tread the familiar ground, but look
    out for some new views on the way. Don't worry—if the subject is optimization,
    it shouldn't take too long. . . .
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这个问题。我们将回顾熟悉的内容，但也要注意沿途的一些新观点。不用担心——如果主题是优化，它不应该花费太多时间……
- en: What Is Optimization?
  id: totrans-1226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化是什么？
- en: 'The word *optimization* purely means to make something better, to improve it.
    In our world, it''s generally taken to mean "making code run faster," measuring
    a program''s performance against the clock. But this is only a part of the picture.
    Different programs have different requirements; what''s "better" for one may not
    be "better" for another. Software optimization may actually mean any of the following:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 单纯的“优化”一词纯粹意味着使某物变得更好，改进它。在我们的世界中，它通常被理解为“使代码运行更快”，即测量程序的性能与时间的关系。但这只是其中的一部分。不同的程序有不同的要求；对某个程序“更好”的，对另一个程序可能就不是“更好”。软件优化实际上可能意味着以下任何一种：
- en: Speeding up program execution
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加快程序执行速度
- en: Decreasing executable size
  id: totrans-1229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少可执行文件大小
- en: Improving code quality
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高代码质量
- en: Increasing output accuracy
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高输出精度
- en: Minimizing startup time
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化启动时间
- en: Increasing data throughput (*not necessarily* the same as execution speed)
  id: totrans-1233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高数据吞吐量（不一定等同于执行速度）
- en: Decreasing storage overhead (i.e., database size)
  id: totrans-1234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少存储开销（即数据库大小）
- en: 'Conventional optimization wisdom is summed up by M.A. Jackson''s infamous laws
    of optimization:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 传统优化智慧可以总结为M.A. Jackson著名的优化法则：
- en: Don't do it.
  id: totrans-1236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要这样做。
- en: '*(For experts only)* Don''t do it yet.'
  id: totrans-1237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(仅限专家)* 还不要这样做。'
- en: That is, you should avoid optimization at all costs. Ignore it at first, and
    only consider it at the end of development when your code is not running fast
    enough. This is a simplistic viewpoint—accurate to a point, but potentially misleading
    and harmful. Performance is really a valid consideration right from the humble
    beginnings of development, before a single line of code has been written.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 即，你应该不惜一切代价避免优化。一开始忽略它，只有在代码运行不够快时，在开发结束时才考虑它。这是一个过于简化的观点——在某种程度上是准确的，但可能具有误导性和有害性。性能实际上是一个从开发初期就需要认真考虑的有效因素，甚至在写下一行代码之前。
- en: 'Code performance is determined by a number of factors, including:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 代码性能由多个因素决定，包括：
- en: The execution platform
  id: totrans-1240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行平台
- en: The deployment or installation configuration
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署或安装配置
- en: Architectural software decisions
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构决策
- en: Low-level module design
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低级模块设计
- en: Legacy artifacts (like the need to interoperate with older parts of the system)
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧式工件（如与系统旧部分的互操作性需求）
- en: The quality of each line of source code
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行源代码的质量
- en: Some of these are fundamental to the software system as a whole, and an efficiency
    problem there won't be easy to rectify once the program has been written. Notice
    how little impact individual lines of code have; there is so much more that affects
    performance. We must manage performance issues at every step of the development
    process and deal with any problems as they arise. In a sense, optimization (while
    not a specific scheduled activity) is an ongoing concern through all stages of
    development.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些是整个软件系统的基本要素，一旦程序编写完成，效率问题将不易纠正。注意单独的代码行对性能的影响有多小；还有更多其他因素会影响性能。我们必须在开发过程的每一步管理性能问题，并处理出现的任何问题。从某种意义上说，优化（虽然不是一个具体的计划活动）是贯穿整个开发阶段的一个持续关注点。
- en: '**KEY CONCEPT**'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: Think about the performance of your program from the very start—do not ignore
    it, hoping to make quick fixes at the end of development.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就考虑你程序的性能——不要忽视它，希望开发结束时能快速修复。
- en: But don't use this as an excuse to write tortured code based on your notion
    of what is fast or not. Programmers' gut feelings for where bottlenecks lie are
    seldom right, no matter how experienced they are. In the following sections, we'll
    see practical solutions to this code-writing dilemma.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要以此为借口编写基于你对快或慢的直觉的痛苦代码。无论程序员经验如何丰富，他们对瓶颈位置的直觉很少是正确的。在接下来的几节中，我们将看到解决这个代码编写困境的实际解决方案。
- en: 'But first, the golden rule. Before you consider a stint of code optimization,
    you must bear this advice in mind:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，黄金法则。在考虑进行代码优化之前，你必须牢记以下建议：
- en: '**KEY CONCEPT**'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Correct* code is far more important than *fast* code. There''s no point in
    arriving quickly at the wrong answer.'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: '*正确的*代码比*快的*代码更重要。快速得到错误答案是没有意义的。'
- en: You should spend more time and effort proving that your code is correct than
    making it fast. Any later optimization must not break this correctness.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该花更多的时间和精力证明你的代码是正确的，而不是让它运行得快。任何后续的优化都不能破坏这种正确性。
- en: '**A WAR STORY**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个战争故事**'
- en: I once discovered that a module I'd written was running unbelievably slowly.
    I profiled it and tracked the problem down to a single line of code. It was called
    frequently and appended a single element to a buffer.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经发现一个我编写的模块运行得不可思议地慢。我对其进行了性能分析，并追踪问题到一行代码。它被频繁调用，并向缓冲区追加一个单个元素。
- en: 'Upon inspection, the buffer (which I was given and hadn''t written) was expanding
    itself by a *single element* each time it got full! In other words: Every single
    append was allocating, copying, and deallocating the entire buffer. Ouch. Needless
    to say, I was not expecting this behavior.'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 检查后发现，缓冲区（我接手但没有编写）每次满了都会自己扩展一个*单个元素*！换句话说：每次单独的追加都会分配、复制和释放整个缓冲区。哎呀。不用说，我并没有期待这种行为。
- en: 'This helps to show how we get suboptimal programs: by growth. Few people willfully
    attempt to write an ambling program. As we glue software components into a larger
    system, we can easily make assumptions about the performance characteristics of
    the code and end up with a nasty shock.'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于展示我们如何得到次优程序：通过增长。很少有人故意尝试编写一个蹒跚的程序。当我们把软件组件粘合到一个更大的系统中时，我们很容易对代码的性能特征做出假设，最终得到一个令人不快的惊喜。
- en: What Makes Code Suboptimal?
  id: totrans-1258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么使代码次优？
- en: In order to improve our code, we have to know the things that will slow it down,
    bloat it, or degrade its performance. Later on, this will help us to determine
    some code optimization techniques. At this stage, it's helpful to appreciate what
    we're fighting against.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的代码，我们必须知道哪些东西会减慢它的速度、膨胀它或降低其性能。稍后，这将帮助我们确定一些代码优化技术。在这个阶段，理解我们正在对抗的是什么是有帮助的。
- en: '**Complexity**'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂性**'
- en: Unnecessary complexity is a killer. The more work there is to do, the more slowly
    the code will run. Reducing the amount of work or breaking it up into a different
    set of simpler, faster tasks can greatly enhance performance.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 不必要的复杂性是杀手。要完成的工作越多，代码运行得就越慢。减少工作量或将其分解为一系列更简单、更快的任务可以大大提高性能。
- en: '**Indirection**'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '**间接性**'
- en: 'This is touted as the solution to all known programming problems, summarized
    by the infamous programmer maxim: *Every problem can be solved by an extra level
    of indirection*. But indirection is also blamed for a lot of slow code. This criticism
    is often leveled by old-school procedural programmers, aimed at modern OO designs.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 这被吹捧为解决所有已知编程问题的方案，总结为臭名昭著的程序员格言：*每个问题都可以通过额外一层间接性来解决*。但间接性也被指责导致了大量慢速代码。这种批评通常由老派的程序设计员提出，针对现代面向对象设计。
- en: '**Repetition**'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复**'
- en: Repetition can often be avoided and will inevitably ruin code performance. Repetition
    can often be avoided and will inevitably ruin code performance. It comes in many
    guises—for example, failing to cache the results of expensive calculations or
    of remote procedure calls. Every time you recompute, you waste precious efficiency.
    Repeated code sections unnecessarily extend executable size.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 重复通常可以避免，并且不可避免地会破坏代码性能。重复通常可以避免，并且不可避免地会破坏代码性能。它以许多形式出现——例如，未能缓存昂贵计算或远程过程调用的结果。每次重新计算，你都会浪费宝贵的效率。不必要的重复代码段会无谓地扩展可执行文件的大小。
- en: '**Bad design**'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕的设计**'
- en: 'It''s inevitable: Bad design will lead to bad code. For example, placing related
    units far away from each other (across module boundaries, for example) will make
    their interaction slow. Bad design can lead to the most fundamental, the most
    subtle, and the most difficult performance problems.'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可避免的：糟糕的设计将导致糟糕的代码。例如，将相关的单元放置得非常远（例如跨越模块边界）将使它们的交互变得缓慢。糟糕的设计可能导致最基本、最微妙和最难以解决的性能问题。
- en: '**I/O**'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '**I/O**'
- en: A program's communication with the outside world—its input and output—is a remarkably
    common bottleneck. A program whose execution is blocked waiting for input or output
    (to and from the user, the disk, or a network connection) is bound to perform
    badly.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 程序与外部世界的通信——它的输入和输出——是一个非常常见的瓶颈。一个执行被阻塞等待输入或输出（来自用户、磁盘或网络连接）的程序肯定会表现不佳。
- en: This list is nowhere near exhaustive, but it gives us a good idea of what to
    think about as we investigate how to write optimal code.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表远非详尽无遗，但它为我们提供了在研究如何编写最优代码时需要考虑的一些思路。
- en: Why Not Optimize?
  id: totrans-1271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不优化？
- en: Historically, optimization was a crucial skill, since early computers ran very,
    very slowly. Getting a program to complete in anything like reasonable time required
    a lot of skill and the hand-honing of individual machine instructions. That skill
    is not so important these days; the personal computer revolution has changed the
    face of software development. We often have a surplus of computational power,
    quite the reverse of the days of yore. It might seem that optimization doesn't
    really matter anymore.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，优化是一个关键技能，因为早期的计算机运行速度非常慢。让程序在合理的时间内完成需要大量的技能和对手动机器指令的精细调整。这种技能在当今并不那么重要；个人电脑革命已经改变了软件开发的面貌。我们通常拥有过剩的计算能力，这与过去的时代正好相反。看起来优化可能已经不再那么重要了。
- en: Well, not quite. The software factory still throws us situations requiring high-performance
    code, and if you're not careful, you'll need a mad optimization dash at the last
    minute. But it is preferable to avoid optimizing code if at all possible. Optimization
    has a *lot* of downsides.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，并不完全是。软件工厂仍然会给我们带来需要高性能代码的情况，而且如果你不小心，你可能在最后一刻需要进行疯狂的性能优化。但尽可能地避免优化代码是更好的选择。优化有很多缺点。
- en: 'There''s always a price to pay for more speed. Optimizing code is the act of
    trading one desirable quality for another. Some aspect of the code will suffer.
    Done well, the (correctly identified) more desirable quality is enhanced. These
    trade-offs are the top reasons to avoid optimizing code:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更快的速度，总是需要付出代价。优化代码就是用一种期望的品质去交换另一种品质的行为。代码的某些方面将会受到影响。如果做得好，被正确识别的更期望的品质将会得到增强。这些权衡是避免优化代码的最主要原因：
- en: '**Loss of readability**'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '**可读性下降**'
- en: It's rare for optimized code to read as clearly as its slower counterpart. By
    its very nature, the optimized version is not as direct an implementation of the
    logic or as straightforward. You sacrifice readability and neat code design for
    performance. Most "optimized" code is ugly and hard to follow.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 优化后的代码通常不如其较慢的版本清晰易读。由于其本身的性质，优化版本并不是逻辑的直接实现，也不是那么直接。你为了性能牺牲了可读性和整洁的代码设计。大多数“优化”的代码都很丑陋且难以跟踪。
- en: '**Increase in complexity**'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂性增加**'
- en: A more clever implementation—perhaps exploiting special backdoors (thereby increasing
    module coupling) or taking advantage of platform-specific knowledge—will add complexity.
    Complexity is the enemy of good code.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 更聪明的实现——可能利用特殊的后门（从而增加模块耦合）或利用平台特定的知识——将增加复杂性。复杂性是优秀代码的敌人。
- en: '**Hard to maintain/extend**'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '**难以维护/扩展**'
- en: As a consequence of increased complexity and a lack of readability, the code
    will be harder to maintain. If an algorithm is not clearly presented, the code
    can hide bugs more easily. Optimization is a surefire way to add subtle new faults—these
    will be difficult to find because the code is more contrived and harder to follow.
    Optimization leads to dangerous code.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于复杂性的增加和可读性的缺乏，代码将更难维护。如果一个算法没有清晰地展示，代码更容易隐藏错误。优化是添加微妙新错误的一定方法——这些错误将很难找到，因为代码更加复杂且难以跟踪。优化导致危险的代码。
- en: It also stunts the extensibility of your code. Optimizations often come from
    making more assumptions, limiting generality and future growth.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会限制你代码的可扩展性。优化通常来自于做出更多的假设，限制通用性和未来的增长。
- en: '**Introducing conflicts**'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '**引入冲突**'
- en: Often an optimization will be quite platform specific. It might make certain
    operations faster on one system, at the expense of another platform. Picking optimal
    data types for one processor type may lead to slower execution on others.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，优化会非常依赖于特定平台。它可能在某个系统上使某些操作更快，但以牺牲另一个平台为代价。为一种处理器类型选择最佳数据类型可能会导致其他处理器上的执行速度变慢。
- en: '**More effort**'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多努力**'
- en: Optimization is another job that needs to be done. We have quite enough to do
    already, thank you. If the code is working adequately, then we should focus our
    attentions on more pressing concerns.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一项需要完成的任务。我们已经有足够多的事情要做，谢谢。如果代码已经足够工作，那么我们应该将注意力集中在更紧迫的问题上。
- en: Optimizing code takes a long time, and it's hard to target the real causes.
    If you optimized the wrong thing, you've wasted a lot of precious energy.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码需要很长时间，而且很难找到真正的根源。如果你优化了错误的东西，你就浪费了大量的宝贵精力。
- en: For these reasons, optimization should be quite a way down on your list of concerns.
    Balance the need to optimize your code against the requirement to fix faults,
    to add new features, or to ship a product. Often optimization is not worthwhile
    or is uneconomical. If you take care to write efficient code in the first place,
    you're less likely to need to optimize anyway.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，优化应该是在你关注列表中的最后一项。在优化代码的需求与修复错误、添加新功能或发布产品的要求之间取得平衡。通常，优化并不值得或是不经济的。如果你一开始就注意编写高效的代码，那么你就不太可能需要优化。
- en: Alternatives
  id: totrans-1288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'Often code optimization is performed when it''s not actually necessary. There
    are a number of alternative approaches that we can employ without altering our
    exisiting good-quality code. Consider these solutions *before* you get too focused
    on optimization:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码优化是在实际上并不需要的时候进行的。我们可以采用一些替代方法，而无需改变现有的高质量代码。在你过于专注于优化之前，考虑这些解决方案：
- en: Can you put up with this level of performance—is it really *that* disastrous?
  id: totrans-1290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能忍受这种性能水平吗——这难道真的**那么**灾难性吗？
- en: Run the program on a faster machine. This seems laughably obvious, but if you
    have enough control over the execution platform, it might be more economical to
    specify a faster computer than spend time tinkering with code. Given the average
    project duration, you are guaranteed that by the time you reach completion, processors
    will be considerably faster. If they're not much faster, then they'll have double
    the number of CPU cores embedded in the same physical space.
  id: totrans-1291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更快的机器上运行程序。这听起来显然荒谬，但如果你有足够的控制权来控制执行平台，指定一台更快的计算机可能比花时间修改代码更经济。考虑到平均项目周期，你保证在完成时，处理器将大大加快。如果它们没有快很多，那么它们将在相同的物理空间内嵌入双倍的CPU核心数量。
- en: Not all problems can be fixed by a faster CPU, especially if the bottleneck
    is not execution speed—a slow storage system, for example. Sometimes a faster
    CPU can cause drastically *worse* performance; faster execution can exacerbate
    thread-locking problems.
  id: totrans-1292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并非所有问题都能通过更快的CPU来解决，尤其是瓶颈不在于执行速度——例如，一个慢速的存储系统。有时，更快的CPU反而会导致性能**大幅下降**；更快的执行可能会加剧线程锁定问题。
- en: 'Look for hardware solutions: Add a dedicated floating-point unit to speed up
    calculations; add a bigger processor cache, more memory, a better network connection,
    or a wider-bandwidth disk controller.'
  id: totrans-1293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找硬件解决方案：添加一个专门的浮点单元以加快计算速度；添加更大的处理器缓存、更多内存、更好的网络连接或更宽频带的磁盘控制器。
- en: Reconfigure the target platform to reduce the CPU load on it. Disable background
    tasks or any unnecessary pieces of hardware. Avoid processes that consume huge
    amounts of memory.
  id: totrans-1294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新配置目标平台，以减少其上的CPU负载。禁用后台任务或任何不必要的硬件设备。避免消耗大量内存的进程。
- en: Run slow code asynchronously, in a background thread. Adding threads at the
    last minute is a road to disaster if you don't know what you're doing, but careful
    thread design can accommodate slow operations quite acceptably.
  id: totrans-1295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以异步方式运行慢速代码，在后台线程中。如果你不知道自己在做什么，在最后一刻添加线程是通往灾难的道路，但仔细的线程设计可以相当好地适应慢速操作。
- en: Work on user interface elements that affect the user's perception of speed.
    Ensure that GUI buttons change immediately, even if their code takes over a second
    to execute. Implement a progress meter for slow tasks; a program that hangs during
    a long operation appears to have crashed. Visual feedback of an operation's progress
    conveys a better impression of the quality of performance.
  id: totrans-1296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于影响用户对速度感知的用户界面元素。确保GUI按钮立即改变，即使它们的代码需要超过一秒钟才能执行。为耗时任务实现进度条；在长时间操作中挂起的程序看起来像是崩溃了。操作进度的视觉反馈传达了对性能质量的更好印象。
- en: Design the system for unattended operation so that no one notices the speed
    of execution. Create a batch-processing program with a neat UI that allows you
    to queue work.
  id: totrans-1297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计系统以实现无人值守操作，这样没有人会注意到执行速度。创建一个具有整洁用户界面的批处理程序，允许你排队工作。
- en: Try a newer compiler with a more aggressive optimizer, or target your code for
    the most specific processor variant (with all extra instructions and extensions
    enabled) to take advantage of all performance features.
  id: totrans-1298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用具有更激进优化器的较新编译器，或者针对最具体的处理器变体（启用所有额外指令和扩展）来利用所有性能特性。
- en: '**KEY CONCEPT**'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Look for alternatives to optimizing code—can you increase your program''s
    performance in any other way?*'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '*寻找优化代码的替代方案——你能否以其他方式提高程序的性能？*'
- en: Why Optimize?
  id: totrans-1301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要优化？
- en: 'Having seen the dangers of code optimization, should you now give up any foolish
    notion of ever optimizing your code? Well, no: You should still avoid optimization
    wherever possible, but there are plenty of situations where optimization is important.
    And contrary to popular belief, some areas are *guaranteed* to require optimization.'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 看过代码优化的危险后，你现在是否应该放弃任何优化代码的愚蠢想法？嗯，不：你应该尽可能避免优化，但确实有许多情况下优化是重要的。而且与普遍看法相反，某些领域*保证*需要优化。
- en: Games programming always needs well-honed code. Despite the huge advances in
    PC power, the market demands more realistic graphics and more impressive artificial
    intelligence algorithms. This can only be delivered by stretching the execution
    environment to its very limits. It's an incredibly challenging field of work;
    as each new piece of faster hardware is released, games programmers still have
    to wring every last drop of performance out.
  id: totrans-1303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏编程始终需要经过精心打磨的代码。尽管PC性能有了巨大的进步，但市场对更逼真的图形和更令人印象深刻的人工智能算法的需求更大。这只能通过将执行环境拉伸到极限来实现。这是一个极具挑战性的工作领域；随着每块新硬件的发布，游戏程序员仍然必须榨取每一滴性能。
- en: '*Digital signal processing (DSP)* programming is all about high performance.
    Digital signal processors are dedicated devices specifically optimized to perform
    fast digital filtering on large amounts of data. If speed didn''t matter, you
    wouldn''t be using them. DSP programming generally relies less on an optimizing
    compiler, since you want to have a high degree of control over what the processor
    is doing at all times. DSP programmers are skilled at driving these devices at
    their maximum performance.'
  id: totrans-1304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数字信号处理（DSP）*编程完全是关于高性能。数字信号处理器是专门优化以对大量数据进行快速数字滤波的专用设备。如果速度不重要，你就不会使用它们。DSP编程通常不太依赖于优化编译器，因为你希望始终对处理器正在执行的操作有高度的控制。DSP程序员擅长驱动这些设备以实现最大性能。'
- en: Resource constrained environments, such as deeply embedded platforms, can struggle
    to achieve reasonable performance with the available hardware. You'll have to
    hone the code for acceptable quality of service or work hard to fit it into the
    device's tight memory.
  id: totrans-1305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源受限的环境，如深度嵌入式平台，可能难以利用现有硬件实现合理的性能。你必须优化代码以实现可接受的服务质量，或者努力将其适应设备紧凑的内存。
- en: '*Real-time* systems rely on timely execution, on being able to complete operations
    within well-specified quanta. Algorithms have to be carefully honed and proven
    to execute in fixed time limits.'
  id: totrans-1306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实时*系统依赖于及时执行，能够在明确指定的量子内完成操作。算法必须经过精心打磨并证明能够在固定的时间限制内执行。'
- en: Numerical programming—in the financial sector, or for scientific research—demands
    high performance. These huge systems are run on very large computers with dedicated
    numerical support, providing vector operations and parallel calculations.
  id: totrans-1307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值编程——在金融领域或科学研究——需要高性能。这些大型系统在配备专用数值支持的大型计算机上运行，提供向量运算和并行计算。
- en: Perhaps optimization is not a serious consideration for general-purpose programming,
    but there are plenty of cases where optimization *is* a crucial skill. Performance
    is seldom specified in a requirements document, yet the customer will complain
    if your program runs unacceptably slowly. If there are no alternatives, and the
    code doesn't perform adequately, then you have to optimize it.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 也许优化对于通用编程来说并不是一个严肃的考虑因素，但有很多情况下优化*确实是*一项关键技能。性能很少在需求文档中指定，但如果你的程序运行速度不令人满意，客户会抱怨。如果没有替代方案，代码表现不佳，那么你就必须进行优化。
- en: There is a shorter list of reasons to optimize than not to. Unless you have
    a specific need to optimize, you should avoid doing so. But if you do need to
    optimize, make sure you know how to do it well.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 优化和不优化的理由比不优化的理由要短。除非你有特定的优化需求，否则你应该避免这样做。但如果你确实需要优化，确保你知道如何做得很好。
- en: '**KEY CONCEPT**'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Understand when you* do *need to optimize code, but prefer to write efficient*
    high-quality *code in the first place*.'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解何时需要优化代码，但首先优先考虑编写高效、高质量*的代码*。'
- en: The Nuts and Bolts
  id: totrans-1312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心内容
- en: So how do you optimize? Rather than learn a list of specific code optimizations,
    it's far more important to understand the correct *approach* to optimizing. Don't
    panic; we will see some programming techniques later, but they must be read in
    the context of this wider optimization process.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何进行优化？与其学习一系列特定的代码优化技巧，不如更重要的是理解正确的优化*方法*。不要慌张；我们稍后会看到一些编程技巧，但它们必须在这个更广泛的优化过程中进行阅读。
- en: 'The six steps for speeding up a program are:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 加速程序的速度的六个步骤是：
- en: Determine that it's too slow, and prove you do need to optimize.
  id: totrans-1315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定它太慢了，并证明你需要进行优化。
- en: Identify the slowest code. Target this point.
  id: totrans-1316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别最慢的代码。针对这一点。
- en: Test the performance of the optimization target.
  id: totrans-1317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试优化目标的性能。
- en: Optimize the code.
  id: totrans-1318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化代码。
- en: Test that the optimized code still works (very important).
  id: totrans-1319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试优化后的代码仍然可以工作（非常重要）。
- en: Test the speed increase, and decide what to do next.
  id: totrans-1320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试速度提升，并决定下一步做什么。
- en: This sounds like a lot of work, but without it you'll actually waste time and
    effort and end up with crippled code that runs no faster. If you're not trying
    to improve execution speed, adjust this process accordingly; for example, tackle
    memory consumption problems by identifying which data structures are consuming
    all the memory and target those.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一项大量工作，但如果没有这样做，你实际上会浪费时间和精力，最终得到的是运行速度没有提高的残缺代码。如果你不是试图提高执行速度，相应地调整这个过程；例如，通过识别哪些数据结构消耗了所有内存来处理内存消耗问题，并针对这些数据结构进行优化。
- en: It's important to begin optimization with a clear goal in sight—the more optimization
    you perform, the less readable the code becomes. Know the level of performance
    you require, and stop when it's sufficiently fast. It's tempting to keep going,
    continually trying to squeeze out a little extra performance.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是在明确的目标下开始优化——你进行的优化越多，代码的可读性就越低。了解你需要的性能水平，并在足够快时停止。继续进行，不断尝试挤出一点额外的性能是很诱人的。
- en: 'To stand any chance of optimizing correctly, you must take great care to prevent
    external factors from changing the way your code works. When the world is changing
    under your feet, you can''t compare measurements realistically. There are two
    essential techniques that help here:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地进行优化，你必须非常小心地防止外部因素改变你的代码的工作方式。当世界在你脚下变化时，你无法进行真实的比较。这里有两种基本技术可以帮助你：
- en: '**KEY CONCEPT**'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Optimize your code separately from any other work, so the outcome of one task
    doesn''t cloud the other*.'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '*将代码优化与其他工作分开，这样一项任务的成果就不会影响另一项*。'
- en: . . . and . . .
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: . . . 和 . . .
- en: '**KEY CONCEPT**'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Optimize release builds of your program, not development builds*.'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化你的程序的发布版本，而不是开发版本*。'
- en: The development builds may run very differently from release builds, due to
    the inclusion of debugging trace information, object file symbols, and so on.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 开发版本可能由于包含调试跟踪信息、对象文件符号等而与发布版本运行非常不同。
- en: Now we'll look at each of these optimization steps in more detail.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更详细地查看这些优化步骤中的每一个。
- en: Prove You Need to Optimize
  id: totrans-1331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证明你需要优化
- en: 'The first thing to do is make sure you really *do* need to optimize. If the
    code''s performance is acceptable, then there''s no point in tinkering with it.
    Knuth said (himself quoting C.A.R. Hoare): "We should forget about small efficiencies,
    say about 97 percent of the time: Premature optimization is the root of all evil."
    There are so many compelling reasons *not* to optimize that the quickest and safest
    optimization technique is to prove that you don''t need to do it.'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要确保你确实*需要*优化。如果代码的性能是可以接受的，那么就没有必要去修改它。Knuth说（他自己引用了C.A.R. Hoare的话）：“我们应该忘记那些小的效率，比如说97%的时间：过早的优化是所有邪恶的根源。”有很多令人信服的理由*不*要优化，所以最快的、最安全的优化技术是证明你不需要这样做。
- en: You make this decision based on program requirements or usability studies. With
    this information you can determine whether optimization takes priority over adding
    new features and fixing bugs.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 你根据程序需求或可用性研究做出这个决定。有了这些信息，你可以确定优化是否比添加新功能或修复错误有优先级。
- en: Identify the Slowest Code
  id: totrans-1334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别最慢的代码
- en: This is the part that most programmers get wrong. If you're going to spend time
    optimizing, you need to target the places where it will make a difference. Investigations
    show that the average program spends more than 80 percent of its time in less
    than 20 percent of the code. (Boehm 87) This is known as the *80/20 rule*.^([[1](#ftn.CHP-11-FN-1)])
    That's a relatively small target that is very easy to miss, which means you might
    waste effort optimizing code that's rarely run.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数程序员容易出错的地方。如果你打算花时间优化，你需要针对那些会产生影响的区域。调查表明，平均程序超过80%的时间都花在了不到20%的代码上。（Boehm
    87）这被称为*80/20法则*。^([[1](#ftn.CHP-11-FN-1)])这是一个相对较小的目标，很容易错过，这意味着你可能会浪费精力优化很少运行的代码。
- en: You might notice that a part of your program has some relatively easy optimizations,
    but if that part is seldom executed, then there's no point in optimizing—in this
    situation, clear code is better than faster code.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到你的程序中有一部分相对容易优化，但如果这部分很少被执行，那么优化就没有意义了——在这种情况下，清晰的代码比快速的代码更好。
- en: How do you figure out where to focus your attention? The most effective technique
    is to use a *profiler*. This tool times the flow of control around your program.
    It shows where that 80 percent of execution time is going, so you know where to
    concentrate your effort.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何确定应该集中注意力的地方？最有效的技术是使用*分析器*。这个工具会记录程序中控制流的耗时。它显示了执行时间的80%都花在了哪里，这样你就知道应该在哪里集中精力。
- en: A profiler *doesn't* tell you which parts of the code are slowest; this is a
    common misconception. It actually tells you where the CPU spends most of its time.
    This is subtly different.^([[2](#ftn.CHP-11-FN-2)]) You have to interpret these
    results and use your brain. The program might spend most of its execution time
    in a few perfectly valid functions which cannot be improved at all. You can't
    always optimize; sometimes the laws of physics win.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器*不会*告诉你代码中哪些部分是最慢的；这是一个常见的误解。它实际上告诉你CPU大部分时间都花在了哪里。这有一个细微的差别.^([[2](#ftn.CHP-11-FN-2)])你必须解释这些结果，并运用你的大脑。程序可能大部分执行时间都花在几个完全有效的函数上，这些函数根本无法改进。你并不总是可以优化；有时物理定律会获胜。
- en: 'There are plenty of benchmarking programs around—many excellent commercial
    programs and a number of freely available tools. It''s worth spending money on
    a decent profiler: Optimization can easily eat into your time; this is also an
    expensive commodity. If you don''t have a profiler available, there are a few
    other timing techniques you can try:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 周围有很多基准测试程序——许多优秀的商业程序和许多免费工具。投资一个好的分析器是值得的：优化很容易消耗你的时间；这也是一种昂贵的商品。如果你没有可用的分析器，还有一些其他的计时技术你可以尝试：
- en: Put manual timing tests throughout your code. Make sure you use an accurate
    clock source and that the time taken to read the clock will not affect program
    performance too much.
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中添加手动计时测试。确保你使用准确的时钟源，并且读取时钟的时间不会过多地影响程序性能。
- en: Count how often each function is called (some debug libraries provide support
    for this kind of activity).
  id: totrans-1341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个函数被调用的次数（一些调试库提供了对此类活动的支持）。
- en: Exploit compiler-supplied hooks to insert your own accounting code when each
    function is entered or exited. Many compilers provide a means to do this; some
    profilers are implemented using such a mechanism.
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用编译器提供的钩子，在每次函数进入或退出时插入你自己的会计代码。许多编译器都提供了这样做的方法；一些分析器就是使用这种机制实现的。
- en: Sample the program counter; interrupt your program periodically in a debugger
    to see where control is. This is harder in multithreaded programs and is a very
    slow, manual approach. If you have control over the execution environment, you
    can write scaffolding to automate this kind of test—effectively writing your own
    form of profiler.
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采样程序计数器；在调试器中定期中断程序以查看控制流。这在多线程程序中更困难，是一种非常缓慢且手动的方法。如果你控制执行环境，你可以编写脚本来自动化这种测试——实际上编写你自己的分析器形式。
- en: Test an individual function's impact on the total program execution time by
    making it slower. If you suspect that a particular function is causing a slowdown,
    try replacing its call with two calls in succession, and measure how it affects
    execution time.^([[3](#ftn.CHP-11-FN-3)]) If the program takes 10 percent longer
    to run, then the function consumes approximately 10 percent of execution time.
    Use this as a very basic timing test.
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使单个函数运行变慢来测试其对整个程序执行时间的影响。如果你怀疑某个特定函数导致了减速，尝试连续替换其调用两次，并测量它对执行时间的影响.^([[3](#ftn.CHP-11-FN-3)])
    如果程序运行时间延长了10%，那么该函数大约消耗了10%的执行时间。将此用作一个非常基本的计时测试。
- en: When profiling, make sure that you use realistic input data, simulating Real
    World events. The way your code executes may be drastically affected by the kind
    of input you feed it or by the way it is driven, so make sure that you provide
    true representative input sets. If possible, capture a set of real input data
    from a live system.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析时，确保你使用真实的数据输入，模拟现实世界的事件。你的代码执行方式可能会因你提供的输入类型或驱动方式而大幅改变，所以请确保你提供真正的代表性输入集。如果可能，从实际系统中捕获一组真实输入数据。
- en: Try profiling several different data sets, to see what difference this makes.
    Select a very basic set, a heavy use set, and a number of general use sets. This
    will prevent you from optimizing for the particular quirks of one input data set.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试分析几个不同的数据集，看看这会有什么不同。选择一个非常基本的集合，一个高使用率集合，以及几个通用使用集合。这将防止你针对特定输入数据集的特定怪癖进行优化。
- en: '**KEY CONCEPT**'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Select profiling test data carefully to represent Real World program use.
    Otherwise, you might optimize parts of the program that are not normally run*.'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '*仔细选择分析测试数据以代表现实世界程序的使用。否则，你可能会优化那些通常不会运行的程序部分*。'
- en: While a profiler (or equivalent) is a good starting point to choose optimization
    targets, you can easily miss quite fundamental problems. The profiler only shows
    how the code in the current design executes—and encourages you to perform code-level
    improvement only. Look at larger design issues too. The lack of performance may
    not be due to a single function, but rather a more pervasive design flaw. If it
    is, then you'll have to work harder to remedy the problem. This shows how important
    it is to get the initial code design right, with knowledge of established performance
    requirements.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然分析器（或等效工具）是选择优化目标的好起点，但你很容易错过相当基本的问题。分析器只显示当前设计中代码的执行情况——并鼓励你仅在代码级别进行改进。也要看看更大的设计问题。性能不佳可能不是由单个函数引起的，而是一个更普遍的设计缺陷。如果是这样，那么你需要更努力地解决问题。这表明正确获取初始代码设计并了解已建立的性能要求是多么重要。
- en: '**KEY CONCEPT**'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Don''t rely solely on a profiler to find the causes of program inefficiency;
    you might miss important problems*.'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要仅仅依赖分析器来查找程序效率低下的原因；你可能会错过重要的问题*。'
- en: Having completed this step, you've found the areas of your code where a performance
    improvement will have the most benefit. Now it's time to attack them.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，你已经找到了代码中性能改进将带来最大效益的区域。现在，是时候攻击它们了。
- en: Testing the Code
  id: totrans-1353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码测试
- en: We recognized three testing phases in the optimization procedure. For each piece
    of code targeted, we test its performance before optimization, confirm that the
    code still works correctly once optimized, and test its performance after optimization.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在优化过程中识别了三个测试阶段。对于每个要优化的代码片段，我们在优化前测试其性能，确认优化后代码仍然正确工作，并在优化后测试其性能。
- en: 'Programmers often forget the second check: that the optimized code still works
    correctly in *all* possible situations. It''s easy to check the normal mode of
    operation, but it''s not in our nature to test each and every rare case. This
    can be the cause of weird bugs late in the day, so be very rigorous about this.'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常忘记第二个检查：优化后的代码在所有可能的情况下仍然正确工作。检查正常操作模式很容易，但测试每一个罕见的案例并不符合我们的天性。这可能是晚上出现奇怪错误的原因，所以对此要非常严格。
- en: You *must* measure the code's performance before and after modification to make
    sure that you have made a real difference—and to make sure that it is a change
    for the better; sometimes an "optimization" can be an unwitting *pessimization*.
    You can perform these timing tests with your profiler or by inserting timing instrumentation
    by hand.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 你*必须*在修改前后测量代码的性能，以确保你确实做出了真正的改变——并确保这是一个向好的改变；有时所谓的“优化”可能是不知不觉的*劣化*。你可以使用你的分析器或手动插入计时工具来执行这些计时测试。
- en: '**KEY CONCEPT**'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: Never *try to optimize code without performing some kind of before and after
    measurement*.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要*在没有进行某种前后测量的情况下尝试优化代码*。
- en: 'These are some very important things to think about when running your timing
    tests:'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行你的计时测试时，以下是一些非常重要的事情需要考虑：
- en: Run both the before and after tests with exactly the same set of input data
    so that you're testing exactly the same thing. Otherwise, your tests are meaningless;
    you're not comparing apples to apples. An automated test suite is best (see "[Look!
    No Hands!](ch08s07.html "Look! No Hands!")" on page 144)—with the same kind of
    live representative data we used in the profiling step.
  id: totrans-1360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完全相同的输入数据集运行前后测试，以确保你测试的是完全相同的东西。否则，你的测试是没有意义的；你并没有在比较苹果和苹果。自动化的测试套件是最好的（参见第144页的"[Look!
    No Hands!](ch08s07.html "Look! No Hands!")"）——使用我们在分析步骤中使用的同种实时代表性数据。
- en: Run all tests under identical prevailing conditions, so that factors like the
    CPU load or amount of free memory don't affect your measurements.
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同的环境条件下运行所有测试，这样CPU负载或空闲内存的数量就不会影响你的测量结果。
- en: Ensure that your tests don't rely on user input. Humans can cause timings to
    fluctuate wildly. Automate every possible aspect of the test procedure.
  id: totrans-1362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的测试不依赖于用户输入。人类可能会使计时结果波动很大。自动化测试流程的每一个可能方面。
- en: Optimizing the Code
  id: totrans-1363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码优化
- en: We'll investigate some specific optimization techniques later. Speed-ups vary
    from the simple refactoring of small sections of code to more serious design-level
    alterations. The trick is to optimize without totally destroying the code.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后探讨一些具体的优化技术。速度提升可能从对代码小部分简单的重构到更严重的设计层面改动。关键是优化而不至于完全破坏代码。
- en: Determine how many different ways exist to optimize the identified code, and
    pick the best. Only perform one change at a time; it's less risky, and you'll
    have a better idea of what improved performance the most. Sometimes it's the least
    expected things that have the most significant optimization effects.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 确定优化已识别代码的不同方式有多少，并选择最佳方案。一次只进行一个更改；这样风险更低，你也会更清楚地知道哪个更改提高了性能。有时最意想不到的事情会产生最显著的优化效果。
- en: After Optimization
  id: totrans-1366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化后
- en: Don't forget to benchmark the optimized code to prove that you've made a successful
    modification. If an optimization is unsuccessful, remove it. Back out your changes.
    This is where a source control system is useful, helping you to revert to the
    previous code version.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记对优化后的代码进行基准测试，以证明你已经成功进行了修改。如果优化不成功，请移除它。撤销你的更改。这时源代码控制系统非常有用，它可以帮助你恢复到之前的代码版本。
- en: Also remove the *slightly* successful optimizations. Prefer clear code to modest
    optimizations (unless you're absolutely desperate for an improvement, and there
    are no other avenues to explore).
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 同时移除那些*稍微成功*的优化。优先选择清晰的代码而不是适度的优化（除非你绝对需要改进，而且没有其他途径可以探索）。
- en: '* * *'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-11-FN-1)]) Some go so far as to claim this should be the *90/10
    rule*.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-11-FN-1)]) 有些人甚至声称这应该是*90/10规则*。
- en: ^([[2](#CHP-11-FN-2)]) All code runs at a fixed rate, based on the speed of
    the CPU clock, the number of other processes being juggled by the OS, and the
    thread's priority.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-11-FN-2)]) 所有代码都以固定的速率运行，这取决于CPU时钟的速度、操作系统正在处理的其它进程数量以及线程的优先级。
- en: ^([[3](#CHP-11-FN-3)]) This won't *necessarily* make the function run twice
    as slowly. Filesystem buffers or CPU memory caches can enhance the performance
    of repeated code sections. Treat this as a very rough guide—more qualitative than
    quantitative.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-11-FN-3)]) 这并不一定会使函数运行速度减半。文件系统缓冲区或CPU内存缓存可以增强重复代码段的表现。把这当作一个非常粗略的指南——更多的是定性而非定量。
- en: Optimization Techniques
  id: totrans-1373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化技术
- en: We've avoided this for long enough; now it's time to look at the really gory
    details. Having followed the optimization procedure outlined above, you've proved
    that your program performs badly and have found the worst code culprit. Now you
    need to whip it into shape. What can you do?
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经避免这个问题很长时间了；现在是时候看看真正令人毛骨悚然的细节了。在遵循上述优化程序之后，你已经证明你的程序表现不佳，并找到了最糟糕的代码罪魁祸首。现在你需要把它整理好。你能做什么？
- en: There's a palette of optimizations to choose from. Which is the most appropriate
    will depend on the exact cause of the problem, what you're trying to achieve (e.g.,
    increased execution speed or reduced code size), and how much of an improvement
    is required.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优化可供选择。最合适的优化取决于问题的确切原因、你试图实现的目标（例如，提高执行速度或减少代码大小），以及所需的改进程度。
- en: 'These optimizations fall into two broad categories: *design* changes and *code*
    changes. A change at the design level will usually have a more profound effect
    on performance than a code-level tweak. An inefficient design can strangle efficiency
    more than a few bad lines of source code, so a design fix—while more difficult—will
    have a bigger payoff.'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优化可以分为两大类：**设计**变更和**代码**变更。在设计层面上的变更通常比代码级别的调整对性能有更深远的影响。一个低效的设计可能比几行糟糕的源代码更能扼杀效率，因此，虽然设计修复更困难，但回报更大。
- en: 'Most often, our goal is to increase execution speed. The speed-based optimization
    strategies are to:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的目标是提高执行速度。基于速度的优化策略包括：
- en: Speed up slow things
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加快缓慢的事情
- en: Do slow things less often
  id: totrans-1379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少执行缓慢的事情的频率
- en: Defer slow things until you really need them
  id: totrans-1380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将缓慢的事情推迟到真正需要它们的时候
- en: 'The other common optimization goals are to reduce memory consumption (mainly
    by changing the data representation, by tweaking the pattern of memory consumption,
    or by reducing the amount of data accessed at once), or to reduce executable size
    (by removing functionality or by exploiting commonality). As we''ll see, these
    goals often conflict: Most speed increases come at the expense of memory consumption,
    and vice versa.'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一些常见的优化目标是减少内存消耗（主要通过改变数据表示、调整内存消耗模式或减少一次性访问的数据量），或者减少可执行文件的大小（通过删除功能或利用共性）。正如我们将看到的，这些目标往往相互冲突：大多数速度提升都是以内存消耗为代价的，反之亦然。
- en: Design Changes
  id: totrans-1382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计变更
- en: These are the *macro* optimizations, the fixes on a large scale that improve
    the internal design of your software. Bad design is hard to fix. The nearer a
    project is to a release deadline, the less likely you are to perform design changes;
    the risk is too great.^([[4](#ftn.CHP-11-FN-4)]) We end up plastering over the
    cracks by employing small, code-level fixes instead.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是**宏观**优化，是在大范围内进行的修复，可以改善你软件的内部设计。糟糕的设计很难修复。项目离发布截止日期越近，你进行设计变更的可能性就越小；风险太大.^([[4](#ftn.CHP-11-FN-4)])
    我们最终通过采用小型、代码级别的修复来填补裂缝。
- en: 'When brave enough, the kinds of design optimization we can perform include:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有足够的勇气时，我们可以执行以下类型的设计优化：
- en: Adding layers of caching or buffering to enhance slow data access or prevent
    lengthy recalculations. Precompute values that you know will be needed, and store
    them for immediate access.
  id: totrans-1385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加缓存或缓冲层以增强缓慢的数据访问或防止长时间的重计算。预先计算你知道将需要的值，并将它们存储以供即时访问。
- en: Creating a pool of resources to reduce the overhead of allocating objects. For
    example, preallocate memory, or hold a selection of files open rather than repeatedly
    opening and then closing them. This technique is often used to speed up memory
    allocation; older OS memory allocation routines were designed for simple non-threaded
    use. Their locks stall multithreaded applications, leading to horrible performance.
  id: totrans-1386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建资源池以减少分配对象的开销。例如，预先分配内存，或者保持一组文件打开而不是反复打开和关闭它们。这种技术通常用于加快内存分配；较老的操作系统内存分配例程是为简单的非线程使用设计的。它们的锁会导致多线程应用程序停滞，从而产生糟糕的性能。
- en: Sacrificing accuracy for speed if you can get away with it. Dropping floating-point
    precision is the obvious example. Many devices have no *floating-point unit (FPU)*
    hardware and employ slower FPU emulation software instead. You can switch to fixed-point
    arithmetic libraries to bypass a slow emulator, at the expense of numeric resolution.
    This is particularly easy in C++ by taking advantage of its abstract data type
    facilities.
  id: totrans-1387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以的话，为了速度牺牲准确性。降低浮点精度是一个明显的例子。许多设备没有*浮点单元 (FPU)* 硬件，而是使用较慢的 FPU 模拟软件。你可以切换到定点算术库来绕过缓慢的模拟器，但这会牺牲数值分辨率。在
    C++ 中，通过利用其抽象数据类型功能，这尤其容易实现。
- en: Accuracy is not solely due to your choice of data types; this tactic can run
    far deeper to your use of algorithms or the quality of your output. Perhaps you
    can let users make this decision—allow them to select *slow but accurate* or *fast
    but approximate* operation modes.
  id: totrans-1388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准确性并不仅仅取决于你选择的数据类型；这种策略可以深入到你对算法的使用或输出质量。也许你可以让用户做出这个决定——允许他们选择*慢但准确*或*快但近似*的操作模式。
- en: Changing the data storage format or its on-disk representation to something
    more suited to high-speed operation. For example, speed up text file parsing by
    using a binary format. Transmit or store compressed files to reduce network bandwidth.
  id: totrans-1389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据存储格式或其磁盘表示形式更改为更适合高速操作的形式。例如，通过使用二进制格式来加速文本文件解析。传输或存储压缩文件以减少网络带宽。
- en: Exploiting parallelization and using threading to prevent one action from being
    serialized after another. As advances in processor speeds tail off, CPU manufacturers
    are increasingly introducing multi-core, multi-pipeline processors. To use these
    effectively, your code *must* be designed with a threaded model at its heart.
    The front line of the optimization battle is rapidly moving in this direction.
  id: totrans-1390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用并行化和使用线程来防止一个动作在另一个动作之后序列化。随着处理器速度的提升放缓，CPU 制造商越来越多地引入多核、多流水线处理器。为了有效地使用这些处理器，你的代码*必须*以线程模型为核心进行设计。优化战斗的前线正在迅速向这个方向发展。
- en: 'Threading efficiently: Avoiding or removing excessive locking. It inhibits
    concurrency, generates overhead, and often leads to deadlock. Employ static checking
    to prove which locks are necessary and which aren''t.'
  id: totrans-1391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地使用线程：避免或移除过多的锁定。这会抑制并发，产生开销，并经常导致死锁。使用静态检查来证明哪些锁是必要的，哪些不是。
- en: Avoiding overuse of exceptions. They can inhibit compiler optimizations^([[5](#ftn.CHP-11-FN-5)])
    and will hamper timely operation when used too frequently.
  id: totrans-1392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过度使用异常。它们可能会阻碍编译器的优化^([[5](#ftn.CHP-11-FN-5)])，并且当频繁使用时，会妨碍及时操作。
- en: Forgoing certain language facilities if it will save code space. Some C++ compilers
    allow you to disable RTTI and exceptions, consequently reducing executable size.
  id: totrans-1393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以节省代码空间，就放弃某些语言功能。一些 C++ 编译器允许你禁用 RTTI 和异常，从而减少可执行文件的大小。
- en: 'Removing functionality: The quickest code is code that doesn''t run at all.
    A function will be slow if it is doing too many things, some of which are unnecessary.
    Cut out the superfluous stuff. Move it elsewhere in the program. Defer all work
    until it''s really necessary.'
  id: totrans-1394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除功能：最快的代码是根本不运行的代码。如果一个函数做了太多事情，其中一些是不必要的，那么它就会变慢。删除多余的东西。将其移到程序的其他地方。推迟所有工作，直到真正需要时再进行。
- en: 'Compromising design quality to gain speed. For example, reducing indirection
    and increasing coupling. You can do this by breaking encapsulation: leaking a
    class''s private implementation through its public interface. Knocking down module
    barriers will cause irreparable damage to the design. If possible, try a less
    disruptive optimization mechanism first.'
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了速度牺牲设计质量。例如，减少间接引用并增加耦合。你可以通过破坏封装来实现这一点：通过公共接口泄露类的私有实现。打破模块障碍会对设计造成不可修复的损害。如果可能，首先尝试一个不那么破坏性的优化机制。
- en: '**COMPLEXITY NOTATION**'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂度表示法**'
- en: '*Algorithmic complexity* is a measure of how well an algorithm scales—how long
    it takes in proportion to the size of input. It''s a *qualitative* mathematical
    model, allowing you to quickly compare the performance characteristics of different
    implementation approaches. It doesn''t measure exact execution time (this is highly
    dependent on CPU speed, OS configuration, etc.).'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法复杂度*是衡量算法扩展性的指标——它相对于输入大小的长短。它是一个*定性的*数学模型，允许你快速比较不同实现方法的表现特性。它不测量确切的执行时间（这高度依赖于
    CPU 速度、操作系统配置等）。'
- en: 'Complexity is determined by the amount of work an algorithm must perform: the
    number of basic operations it executes. A basic operation is something like an
    arithmetic operation, an assignment, a test, or a data read/write. Algorithmic
    complexity doesn''t count the exact number of operations performed, just how this
    value relates to the problem size. We are usually interested in the worst case
    performance of an algorithm, the most work that will ever need to be done. A good
    comparison looks at the best case and average time complexity as well.'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度由算法必须执行的工作量决定：它执行的基本操作的数量。基本操作类似于算术运算、赋值、测试或数据读写。算法复杂度不计操作的确切数量，只计这个值与问题规模的关系。我们通常对算法的最坏情况性能感兴趣，即永远需要完成的最多的工作量。一个好的比较是查看最佳情况和平均时间复杂度。
- en: 'Algorithmic complexity is expressed using *Big O* notation, invented by the
    German number theorist Edmund Landau. For a problem with input size *n*, it might
    have a complexity of:'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 算法复杂度使用由德国数论学家埃德蒙·兰道发明的 *大O* 符号表示。对于输入大小为 *n* 的问题，它可能具有以下复杂度：
- en: '`O(1)`**: Order 1**'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(1)**：一阶**'
- en: This is a *constant time* algorithm. No matter how large the input set, it always
    takes the same amount of time to complete the task. This is the best performance
    characteristic possible.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常数时间算法。无论输入集有多大，完成任务的所需时间总是相同的。这是可能的最优性能特征。
- en: '`O(n)`**: Order n**'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(n)**：n阶**'
- en: A *linear time* algorithm's complexity rises in line with the input size. Searching
    a linked list will involve visiting more nodes as the list size grows; the number
    of operations is directly related to the size of the list.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 线性时间算法的复杂度与输入大小成正比。随着链表大小的增长，搜索链表将涉及访问更多的节点；操作的数量与列表的大小直接相关。
- en: '`O(n2)`**: Order n squared**'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(n^2)**：平方阶**'
- en: 'This is where performance really begins to get bad: Complexity is increasing
    faster than the rate of input growth. A *quadratic time* algorithm may seem fine
    when you give it a small set of data, but large data sets take a seriously long
    time. The bubblesort algorithm is `O(n2)`.'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是性能真正开始变差的地方：复杂度增长速度超过了输入增长速度。当给一个小数据集时，一个二次时间算法可能看起来还不错，但大数据集需要花费很长时间。冒泡排序算法的复杂度是
    `O(n^2)`。
- en: Of course, complexity may be of any order; the quicksort algorithm averages
    `O(n log n)`. This is worse than `O(n)`, but far better than `O(n2)`. A simple
    optimization route for a slow bubblesort algorithm is to replace it with a quicksort
    algorithm, especially since there are plenty of freely available quicksort implementations.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，复杂度可以是任何阶数；快速排序算法的平均复杂度为 `O(n log n)`。这比 `O(n)` 要差，但远比 `O(n^2)` 好得多。对于慢速冒泡排序算法的一个简单优化途径是将其替换为快速排序算法，尤其是考虑到有许多免费的快速排序实现。
- en: These Big O expressions don't include constants or low-order terms. You'll rarely
    see any talk about a complexity of `O(2n+6)`. When n gets large enough, these
    constants and low-order terms dwarf into insignificance.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大O表达式不包括常数或低阶项。你很少会看到关于 `O(2n+6)` 的复杂度讨论。当 n 足够大时，这些常数和低阶项变得微不足道。
- en: The major design-level optimizations involve improvements in *algorithms* or
    *data structures*. Most speed degradation or memory consumption comes down to
    a bad choice of one or both, and a subsequent change will rectify this.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的设计级优化涉及对算法或数据结构的改进。大多数速度下降或内存消耗归结于一个或两个选择不当，后续的更改将纠正这一点。
- en: '**Algorithms**'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法**'
- en: Algorithms have a profound impact on the speed of execution. A function that
    works acceptably in a small local test may not scale up when Real World data gets
    thrown at it. If profiling shows that your code spends most of its time running
    a certain routine, you must make it run faster. One approach is at the code level,
    chipping small improvements from each instruction. A better approach is to replace
    the entire algorithm with a more efficient version.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 算法对执行速度有深远的影响。一个在小范围本地测试中表现可接受的功能，当面对现实世界的数据时可能无法扩展。如果分析显示你的代码大部分时间都在运行某个特定的例程，你必须让它运行得更快。一种方法是在代码级别，从每条指令中提取小的改进。更好的方法是替换整个算法为更有效的版本。
- en: 'Consider this realistic example: A particular algorithm runs a loop 1,000 times.
    Each iteration takes 5 milliseconds (ms) to execute. The operation therefore completes
    in around 5 seconds. By tweaking the code inside the loop, you can shave 1 ms
    from each iteration—that''s a saving of 1 second. Not bad. But instead, you can
    plug in a different algorithm, where an iteration takes 7 ms, although it only
    iterates 100 times. That''s a saving of almost 4 and a half seconds—significantly
    better.'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个现实例子：一个特定的算法运行循环1,000次。每次迭代需要5毫秒（ms）来执行。因此，操作大约需要5秒钟完成。通过调整循环内的代码，你可以从每次迭代中节省1毫秒——这节省了1秒钟。不错。但相反，你可以插入一个不同的算法，其中每次迭代需要7毫秒，尽管它只迭代100次。这节省了近4.5秒——显著更好。
- en: For this reason, prefer to look at optimizations that change fundamental algorithms,
    not that tweak specific lines of code. There are many algorithms to chose from
    in the computer science world, and unless your code is particularly dire, you'll
    always gain the most significant performance improvements by selecting a better
    algorithm.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更倾向于查看改变基本算法的优化，而不是调整特定代码行。计算机科学领域有许多算法可供选择，除非你的代码特别糟糕，否则通过选择更好的算法，你总能获得最显著的性能提升。
- en: '**KEY CONCEPT**'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Prefer to replace a slow algorithm with a faster variant than to tinker with
    the algorithm''s implementation*.'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '*更倾向于用更快的变体替换慢速算法，而不是调整算法的实现*。'
- en: '**Data structures**'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构**'
- en: Data structures are intimately related to your choice of algorithms; some algorithms
    require certain data structures, and vice versa. If your program is consuming
    far too much memory, changing the data storage format may improve matters, although
    often at the expense of execution speed. If you need to quickly search a list
    of 1,000 items, don't store them in a linear array with `O(` *`n`*`)` search time;
    use a (larger) binary tree with `O(log` *`n`*`)` performance.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构与你的算法选择密切相关；某些算法需要特定的数据结构，反之亦然。如果你的程序消耗了过多的内存，改变数据存储格式可能会改善情况，尽管这通常是以执行速度为代价的。如果你需要快速搜索包含1,000个项目的列表，不要将它们存储在具有`O(`
    *`n`*`)`搜索时间的线性数组中；使用（更大的）二叉树，其性能为`O(log` *`n`*`)`。
- en: Selecting a different data structure seldom requires you to implement the new
    representation yourself. Most languages come with library support for all common
    data structures.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 选择不同的数据结构很少需要你自己实现新的表示形式。大多数语言都提供了对所有常见数据结构的库支持。
- en: Code Changes
  id: totrans-1418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码更改
- en: 'And so now we creep anxiously on to the really disgusting stuff: the *micro*-level,
    small-scale, shortsighted, code-tweaking optimizations. There are many ways to
    molest source code for the sake of performance. You must experiment to see what
    works best in each situation: Some changes will work well; others will have little,
    or even negative effect. Some may prevent the compiler''s optimizer from performing
    its task, producing startlingly worse results.'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在紧张不安地转向真正令人厌恶的东西：*微观*级别、小规模、短视的代码调整优化。有无数种方法可以为了性能而折磨源代码。你必须进行实验，以查看每种情况下什么最有效：一些更改会有效；其他更改可能效果很小，甚至产生负面影响。一些可能阻止编译器的优化器执行其任务，产生惊人的更差结果。
- en: 'The first task is easy: Turn on compiler optimization or increase the optimization
    level. It often gets disabled for development builds since the optimizer can take
    a very long time to run, increasing the build time of large projects by an order
    of magnitude.^([[6](#ftn.CHP-11-FN-6)]) Try configuring the optimizer, and test
    what affect this has. Many compilers allow you to bias optimization toward extra
    speed or reduced code size.'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务很简单：开启编译器优化或提高优化级别。由于优化器可能需要非常长的时间运行，这通常会导致大型项目的构建时间增加一个数量级。[6](#ftn.CHP-11-FN-6)
    尝试配置优化器，并测试这会产生什么影响。许多编译器允许你偏向于额外的速度或减少代码大小进行优化。
- en: 'There are a few very low-level optimizations that you should know about but
    should generally avoid. These are the kind of changes that a compiler is able
    to perform for you. If you''ve switched the optimizer on, it''ll be looking in
    these areas already—enable optimization and make the most of its help. You will
    rarely need to apply these by hand, which is good: They butcher your code''s readability,
    since they warp its fundamental logic out of shape. Only consider using one of
    these optimizations if you can *prove* that it''s really required, that your optimizer
    hasn''t already done it, and that there are no better alternatives.'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些非常底层的优化，你应该知道但通常应该避免。这些是编译器能够为你执行的改变。如果你已经开启了优化器，它已经在这些区域进行了检查——启用优化并充分利用其帮助。你很少需要手动应用这些优化，这是好事：它们会破坏代码的可读性，因为它们扭曲了其基本逻辑。只有在你能够**证明**这些优化确实是必需的，你的优化器还没有执行它们，并且没有更好的替代方案时，才考虑使用这些优化之一。
- en: '**Loop unrolling**'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环展开**'
- en: For loops with very short bodies, the loop scaffolding may be more expensive
    than the looped operation itself. Remove this overhead by flattening it out—turn
    your 10-iteration loop into 10 consecutive individual statements.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 对于体非常短的循环，循环框架可能比循环操作本身更昂贵。通过将其展开来移除这种开销——将你的10次迭代循环转换为10个连续的单独语句。
- en: Loop unrolling can be done partially; this makes more sense for large loops.
    You can insert four operations per iteration, and increment the loop counter by
    four each time. But this tactic gets nasty if the loop doesn't always iterate
    over a whole number of unrolls.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开可以部分进行；这对于大型循环更有意义。你可以每迭代插入四个操作，并且每次增加循环计数器四个。但是，如果循环不总是迭代整个展开数，这种策略就会变得很糟糕。
- en: '**Code inlining**'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码内联**'
- en: 'For small operations, the overhead of calling a function might be prohibitive.
    Splitting code into functions brings significant benefits: clearer code, consistency
    through reuse, and the ability to isolate areas of change. However, this can be
    removed to increase performance, by merging the caller(s) and the callee.'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型操作，调用函数的开销可能很大。将代码拆分为函数可以带来显著的好处：更清晰的代码，通过重用实现一致性，以及隔离变化区域的能力。然而，可以通过合并调用者和被调用者来移除这些好处以增加性能。
- en: There are a number of ways to do this. With language support, you can request
    it in the source code (in C/C++ using the `inline` keyword); this method preserves
    a lot of the code's readability. Otherwise, you have to merge the code yourself,
    either by duplicating the function over and over again or using a preprocessor
    to do the work for you.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现这一点。在有语言支持的情况下，你可以在源代码中请求它（在C/C++中使用`inline`关键字）；这种方法保留了代码的大部分可读性。否则，你必须自己合并代码，要么是通过重复复制函数，要么是使用预处理器为你完成工作。
- en: It's hard to inline recursive function calls—how would you know when to stop
    inlining? Try to find alternative algorithms to replace recursion.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 内联递归函数调用很难——你如何知道何时停止内联？尝试找到替代算法来替换递归。
- en: Inlining often opens the way for further code-level optimizations (that were
    not previously possible across a function boundary) to be performed.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 内联通常为在代码级别进行进一步的优化（之前在函数边界之外不可能进行）打开了道路。
- en: '**Constant folding**'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '**常量折叠**'
- en: Calculations involving constant values can be computed at compile time to reduce
    the amount of work done at run time. The simple expression `return 6+4;` can be
    reduced to `return 10;`. Carefully ordering the terms of a large calculation might
    bring two constants together, enabling them to be reduced into a simpler subexpression.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及常量值的计算可以在编译时进行，以减少运行时的工作量。简单的表达式`return 6+4;`可以简化为`return 10;`。仔细排序大量计算中的项可能会将两个常量放在一起，使它们能够被简化为一个更简单的子表达式。
- en: It's unusual for a programmer to write something as obvious as `return 6+4;`.
    However, these sorts of expressions are common after macro expansion.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员编写像`return 6+4;`这样明显的东西是不常见的。然而，这些类型的表达式在宏展开后很常见。
- en: '**Move to compile time**'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '**移至编译时**'
- en: There is more you can do at compile time than just constant folding. Many conditional
    tests can be proved statically and removed from the code. Some kinds of tests
    can be avoided altogether; for example, remove tests for negative numbers by using
    unsigned data types.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时你可以做的不仅仅是常量折叠。许多条件测试可以静态地证明并从代码中移除。某些类型的测试可以完全避免；例如，通过使用无符号数据类型来移除对负数的测试。
- en: '**Strength reduction**'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '**强度降低**'
- en: This is the act of replacing one operation with an equivalent that executes
    faster. This is most important on CPUs with poor arithmetic support. For example,
    replace integer multiplication and division with constant shifts or adds; `x/4`
    can be converted to `x>>2` if it's faster on your processor.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种用等效但执行速度更快的操作替换一个操作的行为。这在具有较差算术支持的 CPU 上尤为重要。例如，将整数乘法和除法替换为常数移位或加法；如果处理器上更快，`x/4`
    可以转换为 `x>>2`。
- en: '**Subexpressions**'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '**子表达式**'
- en: '*Common subexpression elimination* avoids the recalculation of expressions
    whose values have not changed. In code like this:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '*公共子表达式消除* 避免重新计算值未改变的表达式。在如下代码中：'
- en: '[PRE5]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: the expression `(a * b)` is evaluated twice. Once is enough. You can factor
    out the common subexpression, and replace it with
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `(a * b)` 被评估了两次。一次就足够了。你可以提取出公共子表达式，并用以下内容替换：
- en: '[PRE6]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Dead code elimination**'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除死代码**'
- en: Don't write needless code; prune anything that's not strictly necessary to the
    program. Static analysis will show you the functions that are never used or the
    sections of code that will never execute. Remove them.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 不要编写不必要的代码；修剪任何不是程序严格必要的部分。静态分析将显示从未使用过的函数或永远不会执行的代码部分。删除它们。
- en: While those are particularly distasteful code optimizations, the following ones
    are slightly more socially acceptable. They focus on increasing program execution
    speed.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些代码优化特别令人反感，但以下优化在社会上稍微更容易接受。它们侧重于提高程序执行速度。
- en: If you find that you're repeatedly calling a slow function, then don't call
    it so often. Cache its result and reuse this value. This might lead to less clear
    code, but the program will run faster.
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你发现你反复调用一个慢速函数，那么不要频繁调用它。缓存其结果并重用此值。这可能会导致代码不够清晰，但程序将运行得更快。
- en: Reimplement the function in another language. For example, rewrite a critical
    Java function in C using the Java Native Interface ( JNI) facility. Conventional
    compilers still beat JIT code interpreters for execution speed.
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一种语言中重新实现函数。例如，使用 Java 原生接口 (JNI) 功能将关键的 Java 函数重写为 C。传统的编译器在执行速度上仍然优于 JIT
    代码解释器。
- en: Don't naïvely assume that one language is faster than another—many programmers
    have been surprised by how little difference using JNI makes. It has been commonly
    claimed that OO languages are far slower than their procedural counterparts. This
    is a lie. Bad OO code *can* be slow, but so can bad procedural code. If you write
    OO-style code in C, it is likely to be *slower* than good C++; the C++ compiler
    will generate better-tuned method dispatch code than your attempts.
  id: totrans-1447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要天真地认为一种语言比另一种语言快——许多程序员对使用 JNI 产生的差异之小感到惊讶。普遍认为，面向对象的编程语言比过程式语言慢得多。这是谎言。糟糕的面向对象代码
    *可能* 会很慢，但糟糕的过程式代码也可能很慢。如果你用 C 编写面向对象风格的代码，它可能比好的 C++ 慢；C++ 编译器将生成比你的尝试更好的方法调度代码。
- en: Reorder the code for improved performance.
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排序代码以改善性能。
- en: '**Defer work until it''s absolutely necessary**. Don''t open a file until you''re
    about to use it. Don''t calculate a value if you might not need it; wait until
    it''s wanted. Don''t call a function yet if the code will work without it.'
  id: totrans-1449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**推迟工作直到绝对必要**。不要在你即将使用它之前打开文件。如果你可能不需要它，不要计算值；等待它被需要。如果代码可以不使用它而工作，那么不要调用函数。'
- en: '**Hoist checking further up the function to avoid needless work**. If a test
    leading to an early return can be placed at the top of a function or halfway though
    it, prefer to place it at the top. Make the check sooner to avoid delays.'
  id: totrans-1450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**将检查提升到函数的更高位置以避免不必要的操作**。如果可以将导致早期返回的测试放在函数的顶部或中间，则优先将其放在顶部。尽早进行检查以避免延迟。'
- en: '**Move invariant calculations out of a loop**. The most subtle source of this
    problem is a loop condition. If you write `for (int n = 0; n < tree.appleCount();
    ++n)`, but `appleCount()` manually counts 1,000 items on every call, you''ll have
    a very slow loop. Move the count operation before the loop:'
  id: totrans-1451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**将不变的运算移出循环**。这个问题的最微妙来源是循环条件。如果你写 `for (int n = 0; n < tree.appleCount();
    ++n)`，但 `appleCount()` 在每次调用时手动计算 1,000 个项目，那么你将有一个非常慢的循环。将计数操作移到循环之前：'
- en: '[PRE7]'
  id: totrans-1452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, don''t forget to profile first to prove that the loop truly is a problem.
    This is a great example of how optimizations are local to a particular execution
    environment: In C#, the new version could well be *slower* because the unoptimized
    code is a pattern the JIT compiler understands and can optimize away itself.'
  id: totrans-1453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，不要忘记首先进行性能分析，以证明循环确实是一个问题。这是一个很好的例子，说明了优化是如何局限于特定执行环境的：在C#中，新版本可能会更慢，因为未优化的代码是JIT编译器理解并可以优化的模式。
- en: Use *lookup tables* for complex calculations, trading time for space. For example,
    rather than write a set of trigonometric functions that individually calculate
    their values, precalculate the return values and store them in an array. Map input
    values to the closest index into this array.
  id: totrans-1454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *查找表* 进行复杂计算，以空间换取时间。例如，而不是编写一组单独计算其值的三角函数，预先计算返回值并将它们存储在数组中。将输入值映射到这个数组中最接近的索引。
- en: Exploit *short-circuit evaluation*. Make sure that the tests likely to fail
    are placed first to save time. If you write a conditional expression `if (condition_one
    && condition_two)`, make sure that `condition_one` is statistically more likely
    to fail than `condition_two` (unless, of course, `condition_one` acts as a guard
    for `condition_two`'s validity).
  id: totrans-1455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 *短路求值*。确保将可能失败的测试放在前面以节省时间。如果您编写了一个条件表达式 `if (condition_one && condition_two)`，请确保
    `condition_one` 在统计上比 `condition_two` 更有可能失败（除非，当然，`condition_one` 作为 `condition_two`
    有效性的保护者）。
- en: Don't reinvent the wheel—reuse standard routines that have already been performance
    tuned. Library writers will have already carefully honed their code. But be aware
    that a library may have been optimized for different goals than yours; perhaps
    an embedded product was profiled for memory consumption, not for speed.
  id: totrans-1456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重新发明轮子——重用已经过性能优化的标准例程。库的编写者已经仔细地优化了他们的代码。但请注意，库可能已经针对不同于您的目标进行了优化；可能一个嵌入式产品被针对内存消耗进行了分析，而不是针对速度。
- en: 'Size-focused, code-level optimizations include:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 以大小为导向，代码级别的优化包括：
- en: Producing compressed executables that unpack their code before running. This
    doesn't necessarily affect the size of the running program, but it reduces the
    storage space required.^([[7](#ftn.CHP-11-FN-7)]) This might be important if your
    program is stored in limited flash memory.
  id: totrans-1458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成在运行前解包其代码的压缩可执行文件。这不一定影响运行程序的大小，但减少了所需的存储空间.^([[7](#ftn.CHP-11-FN-7)]) 如果您的程序存储在有限的闪存中，这可能很重要。
- en: Factoring common code into a shared function to avoid duplication.
  id: totrans-1459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将常用代码因式分解到共享函数中，以避免重复。
- en: Moving seldom-used functions out of the way. Put them into a dynamically loaded
    library or into a separate program.
  id: totrans-1460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将很少使用的函数移到一边。将它们放入动态加载的库或单独的程序中。
- en: Of course, the ultimate hard-core optimization technique is to reimplement a
    section of code in assembly—the one environment where you have *full* control
    over the CPU and can do exactly what you want (including shooting yourself in
    the foot). This is always a last resort and is almost certainly unnecessary. These
    days, compilers produce perfectly acceptable code, and the lost time spent writing,
    debugging, and maintaining "optimized" sections of machine code far outweighs
    the advantages gained.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，终极的硬核优化技术是将代码的一部分重写为汇编语言——这是您对CPU拥有完全控制的环境，可以做到您想要的任何事情（包括自毁）。这始终是最后的手段，并且几乎肯定是不必要的。如今，编译器生成的代码已经足够好，编写、调试和维护“优化”的机器代码部分所花费的时间远远超过了所获得的优势。
- en: '* * *'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-11-FN-4)]) Sadly, it's often only near project deadlines that anyone
    notices that performance isn't good enough.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-11-FN-4)]) 可惜，通常只有在项目截止日期临近时，人们才会注意到性能不够好。
- en: ^([[5](#CHP-11-FN-5)]) Like functions, `try/catch` blocks act as barriers to
    an optimizer. It's not possible to look through the barrier to perform optimization,
    so some potential speed-ups will be lost.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-11-FN-5)]) 与函数一样，`try/catch` 块充当优化器的障碍。无法穿过障碍进行优化，因此可能会丢失一些潜在的速度提升。
- en: ^([[6](#CHP-11-FN-6)]) It has to do complex inspection of the parsed code to
    determine the set of possible speed-ups and select the most appropriate ones.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-11-FN-6)]) 它必须对解析后的代码进行复杂的检查，以确定可能的加速集并选择最合适的那些。
- en: '^([[7](#CHP-11-FN-7)]) This may have the pleasant side effect of decreasing
    program startup time: A compressed executable will load from disk much faster.'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-11-FN-7)]) 这可能有一个令人愉快的副作用，即减少程序启动时间：压缩的可执行文件将从磁盘加载得更快。
- en: Writing Efficient Code
  id: totrans-1467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高效代码
- en: If the best approach is *not* to optimize, how can we avoid any need to improve
    code performance? The answer is to *design for performance*, planning to provide
    adequate quality of service from the outset, rather than trying to whittle it
    out at the last minute.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最佳方案是*不*进行优化，我们如何避免任何改进代码性能的需求？答案是*为性能而设计*，从一开始就计划提供足够的服务质量，而不是试图在最后一刻削减它。
- en: Some argue that this is a dangerous road to follow. Indeed, there are potential
    hazards for the unwary. If you try to optimize as you go along, then you'll write
    at a lower level than needed; you'll end up with nasty, hacky code full of low-level
    performance enhancements and back-door interfaces.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为这是一条危险的道路。确实，对于不小心的人来说，存在潜在的风险。如果你在编写代码的同时尝试优化，那么你将低于所需的级别编写代码；你最终会得到充满低级性能增强和后门接口的糟糕、混乱的代码。
- en: 'How do we reconcile these seemingly opposing views? It isn''t hard, because
    they''re not actually at odds. There are two complementary strategies:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何调和这些看似对立的观点？这并不难，因为它们实际上并不矛盾。有两种互补的策略：
- en: Write efficient code.
  id: totrans-1471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写高效的代码。
- en: Optimize code later.
  id: totrans-1472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以后再优化代码。
- en: If you make a point of writing clear, good, efficient code *now*, you will not
    need to perform heavy optimizations later. Some claim that you don't know whether
    any optimization is necessary at first, so you should write everything *as simply
    as possible*, and only optimize when profiling proves that there is a bottleneck.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在就注重编写清晰、良好、高效的代码，你就不需要以后进行大量优化。有些人认为一开始你不知道是否需要进行优化，所以你应该尽可能简单地将一切写出来，只有在分析证明存在瓶颈时才进行优化。
- en: This approach has obvious flaws. If you know that you need a data structure
    with good search performance (because your program must perform fast searches),
    pick a binary tree over an array.^([[8](#ftn.CHP-11-FN-8)]) If you're not aware
    of any such requirement, *then* go for the most appropriate thing that will work.
    This still might not be the simplest—a raw C array is a hard data structure to
    manage.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有明显的缺陷。如果你知道你需要一个具有良好搜索性能的数据结构（因为你的程序必须进行快速搜索），那么选择二叉树而不是数组。^([[8](#ftn.CHP-11-FN-8)])
    如果你没有意识到任何这样的要求，*那么*选择最合适的东西，它仍然可能不是最简单的——原始C数组是一个难以管理的数据结构。
- en: As you design each module, don't blindly chase performance—only spend the effort
    when necessary. Understand the mandated performance requirements and justify how
    your choices will meet these requirements at each stage. When you know what level
    of performance is required, it's easier to design for appropriate efficiency.
    It also helps you to write explicit tests that prove you do achieve these performance
    goals.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计每个模块时，不要盲目追求性能——只有在必要时才付出努力。了解规定的性能要求，并证明你的选择在每个阶段如何满足这些要求。当你知道需要什么级别的性能时，设计适当的效率就更容易了。这也有助于你编写明确的测试，以证明你确实实现了这些性能目标。
- en: 'Some simple design choices that will increase efficiency and aid later optimization
    are:'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的设计选择可以增加效率并有助于后续优化，包括：
- en: Minimizing your reliance on functions that might be implemented on remote machines
    or that will access the network or a slow data storage system
  id: totrans-1477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化对可能在远程机器上实现或需要访问网络或慢速数据存储系统的函数的依赖
- en: Understanding the target deployment and how the program is expected to be run
    so you can design it to work well in these situations
  id: totrans-1478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解目标部署以及程序预期如何运行，以便你可以设计出在这些情况下表现良好的程序
- en: Writing *modular* code so it's easy to speed up one section without having to
    rewrite other sections too
  id: totrans-1479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写*模块化*代码，以便在不重写其他部分的情况下轻松加快某一部分的运行速度
- en: '**PESSIMIZATIONS**'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '**PESSIMIZATIONS**'
- en: 'Without careful measurement, you can easily end up writing optimizations that
    are not at all optimal. A perfectly good optimization for one situation might
    turn out to be a performance disaster in another. Here''s a case study. Exhibit
    A: The copy-onwrite string optimization.'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 没有仔细测量，你很容易写出并不优化的优化。一个在一种情况下可能很好的优化，在另一种情况下可能会变成性能灾难。这里有一个案例研究。案例A：写时复制字符串优化。
- en: This was a common optimization applied to C++ standard library implementations
    around 1990\. Programs that performed intensive string manipulation experienced
    a massive overhead when copying long strings, both in terms of execution speed
    and memory consumption. Copying large strings means duplicating and shoveling
    around large quantities of data. Many string copies are automatically generated,
    temporary objects that are created and then thrown away shortly after—they are
    never actually modified. The expensive copy operation is an unnecessary cost.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 1990 年左右应用于 C++ 标准库实现中的一种常见优化。执行大量字符串操作的程序在复制长字符串时，在执行速度和内存消耗方面都会产生巨大的开销。复制大型字符串意味着复制和移动大量数据。许多字符串复制是自动生成的临时对象，在创建后不久就被丢弃——它们实际上从未被修改过。昂贵的复制操作是不必要的成本。
- en: The copy-on-write (COW) optimization turns the `string` data type into a form
    of *smart pointer*; the actual string data is held in a (hidden) shared representation.
    The `string` copy operation now only has to perform an inexpensive smart pointer
    copy (attaching a new smart pointer to the shared representation), rather than
    duplicate the entire string contents. Only when you make a modification to a shared
    string is the internal representation copied and the smart pointer remapped. This
    optimization avoids a large number of unnecessary copy operations.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 写时复制（COW）优化将 `string` 数据类型转换成一种 *智能指针*；实际的字符串数据被保存在一个（隐藏的）共享表示中。现在的 `string`
    复制操作只需要执行一个低成本的智能指针复制（将一个新的智能指针附加到共享表示），而不是复制整个字符串内容。只有当你对一个共享字符串进行修改时，内部表示才会被复制，智能指针才会重新映射。这种优化避免了大量不必要的复制操作。
- en: COW worked well in single-threaded programs; it was shown to greatly speed up
    performance. However, a problem became apparent when multithreaded programs used
    COW strings. (Indeed, this problem also manifests in single-threaded programs
    if the COW string class is built with multithreading support). The implementation
    requires very conservative thread locking around the copy operations— these locks
    become a *major* bottleneck. Suddenly, a lightning-fast program slowed down to
    a crawl. The COW optimization proved to be a serious pessimization.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: COW 在单线程程序中表现良好；它被证明可以大大提高性能。然而，当多线程程序使用 COW 字符串时，问题变得明显。（实际上，如果 COW 字符串类是用多线程支持构建的，这个问题也会在单线程程序中显现）。实现需要非常保守的线程锁定来围绕复制操作——这些锁定成为了一个
    *主要* 的瓶颈。突然间，一个快速运行的程序速度慢了下来。COW 优化证明是一个严重的负优化。
- en: Far better multithreaded performance was achieved by reverting to classic `string`
    implementations and writing more careful code that reduced automatic string copying.
    Thankfully, C++ library vendors now provide more intelligent versions of the `string`
    class, which are both thread safe and fast.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回归经典的 `string` 实现并编写更仔细的代码来减少自动字符串复制，实现了更好的多线程性能。幸运的是，C++ 库供应商现在提供了更智能的 `string`
    类版本，它们既线程安全又快速。
- en: '* * *'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[8](#CHP-11-FN-8)]) But, as always, it's not necessarily that simple. Arrays
    often provide better cache coherence (since binary tree nodes can easily become
    scattered across memory). An array that is kept sorted (you amortize time when
    inserting) would be a worthy consideration. Measure, measure, measure.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-11-FN-8)]) 但是，像往常一样，事情并不一定那么简单。数组通常提供更好的缓存一致性（因为二叉树节点可以轻易地散布在内存中）。一个保持排序的数组（在插入时平均分配时间）值得考虑。测量，测量，再测量。
- en: In a Nutshell
  id: totrans-1488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Technological progress has merely provided us with more efficient means for
    going backwards.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 技术进步仅仅为我们提供了更有效的手段来走回头路。
- en: --Aldous Huxley
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: --奥尔德斯·赫胥黎
- en: High-performance code is not as important as some people think. Although you
    sometimes *do* have to roll your sleeves up and tinker with code, optimization
    is a task you should actively avoid. To do this, make sure that you know the software's
    performance requirements before you start working on it. At each level of design,
    ensure that you provide this quality of service. Then optimization will be unnecessary.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能代码并不像有些人认为的那么重要。虽然有时你确实需要卷起袖子修改代码，但优化是一个你应该积极避免的任务。为了做到这一点，确保在开始工作之前你了解软件的性能要求。在设计的每个级别上，确保你提供这种服务质量。然后优化将不再必要。
- en: When you do optimize, be very methodical and measured in your approach. Have
    a clear goal, and prove that each step is getting you closer to it. Be guided
    by solid data, not your hunches. As you write code, ensure that your designs are
    efficient, but don't compromise on quality. Worry about code-level performance
    only when it proves to be a problem.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行优化时，要非常有条理和谨慎。有一个明确的目标，并证明每一步都让你更接近目标。以可靠的数据为指导，而不是你的直觉。在编写代码时，确保你的设计是高效的，但不要在质量上妥协。只有在证明它是问题时，才担心代码级别的性能。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-1493
  prefs: []
  type: TYPE_TB
  zh: '| 精通编程的程序员 . . . | 不擅长编程的程序员 . . . |'
- en: '| --- | --- |'
  id: totrans-1494
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Avoid optimizing unless it proves to be absolutely necessary
  id: totrans-1496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非证明绝对必要，否则避免优化
- en: Attempt optimization methodically, taking a considered and measured approach
  id: totrans-1497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有条理地尝试优化方法，采取深思熟虑和谨慎的方法
- en: '*Look for alternatives and investigate design improvements before ever resorting
    to code-level optimizations*'
  id: totrans-1498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在求助于代码级别的优化之前，先寻找替代方案并调查设计改进*'
- en: Prefer optimizations that won't destroy the code's quality
  id: totrans-1499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾向于选择不会破坏代码质量的优化方法
- en: '|'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Start optimizing before the code proves to be inadequate
  id: totrans-1501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码证明不足之前就开始优化
- en: Dive in feet first, attacking the pieces of code they think are bottlenecks
    without measuring or investigating
  id: totrans-1502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接深入，攻击他们认为的瓶颈代码，而不进行测量或调查
- en: 'Never consider the wider picture: what the full implications of their optimization
    are in other code areas and usage patterns'
  id: totrans-1503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不考虑更广泛的视角：他们的优化在其他代码区域和使用模式中的全部影响
- en: Think speed is more important than code quality
  id: totrans-1504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑速度比代码质量更重要
- en: '|'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-1506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。防御性")'
- en: Optimizations that remove "unnecessary" code often clash with any extra defensive
    code.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 移除“不必要的”代码的优化通常与任何额外的防御性代码冲突。
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章。写作技巧")'
- en: The needs of optimized code are often at odds with self-documenting code.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码的需求通常与自文档化代码相矛盾。
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。宏伟设计")'
- en: Efficiency must be *designed* into the codebase from the start of a project.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 效率必须从项目开始时就设计到代码库中。
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章。具体化")'
- en: Performance requirements must be carefully specified before construction begins
    so you know how much optimization is necessary.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建之前，必须仔细指定性能要求，以便你知道需要多少优化。
- en: '![See Also](tagoreillycom20080909nostarchimages207478.png.jpg)'
  id: totrans-1515
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207478.png.jpg)'
- en: Get Thinking
  id: totrans-1516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 510.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的详细讨论可以在第510页的“[附录A](apa.html "附录A.答案和讨论)”部分找到。
- en: Mull It Over
  id: totrans-1518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思考
- en: Optimization is a process of making trade-offs—sacrificing one quality of code
    for another desirable quality. Describe the kinds of trade-offs that lead to a
    performance increase.
  id: totrans-1519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化是一个权衡的过程——为了另一个期望的质量牺牲代码的一个质量。描述导致性能提升的权衡类型。
- en: Look at each of the optimization alternatives listed in "[Why Not Optimize?](ch11s03.html
    "Why Not Optimize?")" on page 202\. Describe what trade-offs are being made, if
    any.
  id: totrans-1520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看202页上“[为什么不优化？](ch11s03.html "为什么不优化？)”中列出的每个优化替代方案。描述是否做出了任何权衡。
- en: 'Explain these terms and their exact relationship:'
  id: totrans-1521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释这些术语及其确切关系：
- en: Performance
  id: totrans-1522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Efficiency
  id: totrans-1523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: Optimized
  id: totrans-1524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: What are the likely bottlenecks in a slow program?
  id: totrans-1525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个慢速程序中，可能存在的瓶颈有哪些？
- en: How can you avoid the need to optimize? What methods will prevent you from writing
    inefficient code?
  id: totrans-1526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何避免需要优化的需求？哪些方法可以防止你编写低效的代码？
- en: How does the presence of multiple threads affect optimization?
  id: totrans-1527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线程的存在如何影响优化？
- en: Why *don't* we write efficient code? What stops us from using high-performance
    algorithms in the first place?
  id: totrans-1528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不编写高效的代码？是什么阻止我们首先使用高性能算法？
- en: A `List` data type is implemented using an array. What is the worst case algorithmic
    complexity of each of the following `List` methods?
  id: totrans-1529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List` 数据类型是通过数组实现的。以下每个 `List` 方法的最坏情况算法复杂度是什么？'
- en: The constructor
  id: totrans-1530
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数
- en: '`append`—places a new item on the end of the list'
  id: totrans-1531
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`append`—将新项目放置在列表的末尾'
- en: '`insert`—slides a new item in between two existing list items, at a given position'
  id: totrans-1532
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`insert`—在给定位置将新项目滑入两个现有列表项之间'
- en: '`isEmpty`—returns `true` if the list contains no items'
  id: totrans-1533
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isEmpty`—如果列表不包含任何项则返回 `true`'
- en: '`contains`—returns `true` if the list contains a specified item'
  id: totrans-1534
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`contains`—如果列表包含指定的项目则返回`true`'
- en: '`get`—returns the item with a given index'
  id: totrans-1535
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get`—返回给定索引的项目'
- en: Getting Personal
  id: totrans-1536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: How important (honestly) is code performance in your current project? What is
    the motivator for this performance requirement?
  id: totrans-1537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你当前的项目中，代码性能有多重要（老实说）？这种性能要求的动机是什么？
- en: 'In your last optimization attempt:'
  id: totrans-1538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你上一次的优化尝试中：
- en: Did you use a profiler?
  id: totrans-1539
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否使用了分析器？
- en: If yes, how much improvement did you measure?
  id: totrans-1540
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，你测量了多少改进？
- en: If no, how did you know whether you made any kind of improvement?
  id: totrans-1541
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，你怎么知道你是否做出了任何改进？
- en: Did you test that the code still worked after optimizing?
  id: totrans-1542
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你测试了优化后的代码是否仍然正常工作吗？
- en: If yes, how thoroughly did you test?
  id: totrans-1543
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，你测试得有多彻底？
- en: If no, why not? How could you be sure the code still worked properly for *all*
    cases?
  id: totrans-1544
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，为什么？你怎么能确保代码在*所有*情况下仍然正常工作？
- en: If you've not yet attempted to optimize the code you're currently working on,
    take a guess at which parts are the slowest and which bits consume the most memory.
    Now run it through a profiler—how accurate were you?
  id: totrans-1545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有尝试优化你目前正在工作的代码，猜测一下哪些部分是最慢的，哪些部分消耗了最多的内存。现在运行它通过一个分析器——你的猜测有多准确？
- en: How well specified are your program's performance requirements? Do you have
    a concrete plan to test that you meet these criteria?
  id: totrans-1546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的程序的性能要求有多明确？你是否有具体的计划来测试你是否满足这些标准？
- en: Chapter 12. AN INSECURITY COMPLEX
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。不安全复杂
- en: '*Writing Secure Programs*'
  id: totrans-1548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*编写安全的程序*'
- en: Security is mostly a superstition. It does not exist in nature. . . . Life is
    either a daring adventure or nothing.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性大部分是一种迷信。在自然界中并不存在。…生活要么是一场勇敢的冒险，要么什么都不是。
- en: --Helen Keller
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: --海伦·凯勒
- en: Not so long ago, computer access was a scarce commodity. The world contained
    only a handful of machines, owned by a few organizations and accessed by small
    teams of highly trained personnel. In those days, computer security meant wearing
    the right lab coat and pass card to get past the guard on the door.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，计算机访问是一种稀缺的商品。世界上只有少数几台机器，由少数组织拥有，并由一小队经过高度训练的人员访问。在那些日子里，计算机安全意味着穿上正确的实验室外套和通行证，才能通过门卫。
- en: Fast-forward to today. We carry more computational power in our pockets than
    those operators ever dreamed of. Computers are plentiful and, more pertinently,
    highly connected.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到今天。我们口袋里的计算能力比那些操作员梦寐以求的还要多。计算机很丰富，更重要的是，它们高度互联。
- en: 'The volume of data carried by computer systems is growing at a fantastic rate.
    We write programs to store, manipulate, interpret, and transfer this data. Our
    software must guard against information going astray: into the hands of malicious
    attackers, past the eyes of accidental observers, or even disappearing into the
    ether. This is critical; a leak of top-secret company information could spell
    financial ruin. You don''t want sensitive personal information (your bank account
    or credit card details, for example) leaking out for anyone to use. Most software
    systems require some level of security.^([[1](#ftn.CHP-12-FN-1)])'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统携带的数据量正以惊人的速度增长。我们编写程序来存储、操作、解释和传输这些数据。我们的软件必须防止信息走失：落入恶意攻击者的手中，经过意外观察者的眼睛，或者甚至消失在虚空中。这是关键的；机密公司信息的泄露可能导致财务灾难。你不想敏感的个人信息公开（比如你的银行账户或信用卡详情），供任何人使用。大多数软件系统都需要一定级别的安全。[1](#ftn.CHP-12-FN-1)
- en: 'Whose responsibility is it to build secure software? Here''s the bad news:
    It''s *our* headache. If we don''t consider the security of our handiwork carefully,
    we will inevitably write insecure, leaky programs and reap the rewards.'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 谁的责任是构建安全的软件？坏消息是：这是*我们的*头疼事。如果我们不仔细考虑我们作品的安保，我们不可避免地会写出不安全的、漏洞百出的程序，并收获这些回报。
- en: Software security is a really big deal, but generally we're very bad at it.
    Nearly every day you'll hear of a new security vulnerability in a popular product
    or see the results of viruses compromising system integrity.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全是一件非常重要的事情，但我们通常很糟糕。几乎每天你都会听到一个流行产品的新安全漏洞，或者看到病毒破坏系统完整性的结果。
- en: This is an enormous topic, far larger than we have scope to go into here. It's
    a highly specialized field, requiring much training and experience. However, even
    the basics are not adequately addressed by modern software engineering teaching.
    The aim of this chapter is to highlight security issues, explore the problems,
    and learn some basic techniques to protect our code.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巨大的话题，远远超出了我们在这里的范围。这是一个高度专业化的领域，需要大量的培训和经验。然而，即使是基础知识，现代软件工程教学也没有得到充分的解决。本章的目的是突出安全问题，探讨问题，并学习一些基本技术来保护我们的代码。
- en: The Risks
  id: totrans-1557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风险
- en: Better be despised for too anxious apprehensions, than ruined by too confident
    security.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 宁可因为过于焦虑的担忧而受到鄙视，也不要因为过于自信的安全措施而毁灭。
- en: --Edmund Burke
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: --埃德蒙·伯克
- en: 'Why would anyone bother to attack your system? It''s usually because you''ve
    got something that they want. This could be:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有人会费心攻击你的系统？通常是因为你拥有他们想要的东西。这可能是：
- en: Your processing power
  id: totrans-1561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的处理能力
- en: Your ability to send data (e.g., spam)
  id: totrans-1562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你发送数据的能力（例如，垃圾邮件）
- en: Your privately stored information
  id: totrans-1563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你私藏的信息
- en: Your capabilities—perhaps the specific software you have installed
  id: totrans-1564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的能力——可能是指你安装的特定软件
- en: Your connection to more interesting remote systems
  id: totrans-1565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你连接到更多有趣的远程系统
- en: People might even attack you for the sheer fun of it or because they dislike
    you and want to cause harm by disrupting your computer resources. While malicious
    people *are* lurking around looking for easy, insecure prey, a security vulnerability
    might also be caused by a program that accidentally releases information to the
    wrong audience. A lucky user might exploit the leak and cause you harm.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能会仅仅为了乐趣而攻击你，或者因为他们不喜欢你，想要通过破坏你的计算机资源来造成伤害。虽然恶意的人确实在寻找容易、不安全的猎物，但一个程序意外地向错误的目标泄露信息也可能导致安全漏洞。幸运的用户可能会利用这个漏洞对你造成伤害。
- en: '**KEY CONCEPT**'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Know what important assets you possess. Do you have particularly sensitive
    information or specific capabilities that an attacker might want? Guard them*.'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解你拥有的重要资产。你是否拥有特别敏感的信息或特定能力，攻击者可能想要？保护它们*。'
- en: To understand the kinds of attack you might suffer, it's important to differentiate
    protecting an entire computer *system* (comprising of several computers, a network,
    and a number of collaborating applications) from writing a single secure *program*.
    Both are important aspects of computer security; they blur together since both
    are necessary. The latter is a subset of the former. It takes just one insecure
    program to render an entire computer system (or network) insecure.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解你可能遭受的攻击类型，区分保护整个计算机*系统*（由多台计算机、一个网络和许多协作应用程序组成）与编写一个单一的、安全的*程序*是很重要的。这两个都是计算机安全的重要方面；由于两者都是必要的，它们相互交织。后者是前者的一部分。只需一个不安全的程序就可以使整个计算机系统（或网络）变得不安全。
- en: 'These are the common security risks and compromises of a live, running computer
    system:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是运行中的计算机系统的常见安全风险和妥协：
- en: A thief who acquires a laptop or PDA can read any unsecured sensitive data.
    The stolen device might be configured to automatically dial into a private network,
    allowing a simple route straight through all your company's defences. This is
    a serious security threat and one that you can't easily guard against in code!
    What we can do is write systems that aren't immediately accessible to computer
    thieves.
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个获得笔记本电脑或PDA的小偷可以读取任何未加密的敏感数据。被盗设备可能被配置为自动拨入私有网络，从而为直接穿过你公司所有防御的简单途径。这是一个严重的安全威胁，你很难在代码中防范！我们可以做的是编写不立即对计算机小偷开放的系统。
- en: Flawed input routines can be exploited, leading to many types of compromise—even
    to the attacker gaining access to the whole machine (we'll see this in "[Buffer
    Overrun](ch12s04.html#buffer_overrun "Buffer Overrun")" on page 229).
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有缺陷的输入例程可以被利用，导致许多类型的妥协——甚至使攻击者能够访问整个机器（我们将在第229页的"[缓冲区溢出](ch12s04.html#buffer_overrun
    "Buffer Overrun")"中看到这一点）。
- en: Break-ins through an unsecured public network interface are particularly worrying.
    While vulnerbilities in a GUI interface can only be exploited by people actually
    *using* that UI, an insecure system running on a public network could lead to
    the whole world trying to break down your door.
  id: totrans-1573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过未加密的公共网络接口的入侵尤其令人担忧。虽然GUI界面中的漏洞只能被实际*使用*该UI的人利用，但在公共网络上运行的不安全系统可能导致全世界都在试图打破你的大门。
- en: '*Privilege escalation* occurs when a user with limited access rights tricks
    the system to gain a higher security level. The attacker could be an authentic
    user or someone who has just broken into the system. His or her ultimate aim is
    to achieve *root* or *administrator* privilege, where the attacker has total control
    of the machine.'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*权限提升*发生在具有有限访问权限的用户通过欺骗系统获得更高的安全级别时。攻击者可能是一个合法用户或刚刚入侵系统的人。他们的最终目标是达到*root*或*管理员*权限，在那里攻击者对机器拥有完全控制权。'
- en: 'If communication is unencrypted and traverses an insecure medium (e.g., the
    Internet), then any computer en route can syphon off and read data, like a phone
    tap. A variant of this is known as a *man-in-the-middle attack*: An attacker''s
    machine pretends to be the other communicant and sits between both senders, snooping
    on their data.'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通信未加密且穿越不安全的中介（例如，互联网），那么任何途中的计算机都可以窃取并读取数据，就像电话窃听一样。这种攻击方式的一种变体被称为*中间人攻击*：攻击者的机器假装是另一通信方，坐在双方发送者之间，窃听他们的数据。
- en: Any system has a small set of trusted users. Malicious authorized users can
    wreak havoc by copying and sharing data they're not supposed to or entering bad
    data to compromise the quality of your computer system.
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何系统都有一小部分受信任的用户。恶意授权用户可以通过复制和共享他们不应该拥有的数据或输入错误数据来破坏计算机系统的质量。
- en: It's hard to guard against this. You have to trust that each user is responsible
    enough to handle the level of system access he or she has been designated. If
    the user isn't trustworthy, you can't write a program to fix it. This shows that
    security is as much about administration and policy as it is about writing code.
  id: totrans-1577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 防御这一点很困难。你必须相信每个用户都有足够的责任感来处理他们被指定的系统访问级别。如果用户不可信，你不能编写一个程序来解决这个问题。这表明，安全性与管理政策和编写代码一样重要。
- en: 'Careless users (or careless administrators) can leave a system unnecessarily
    open and vulnerable. For example:'
  id: totrans-1578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粗心的用户（或粗心的管理员）可能会使系统不必要地开放和脆弱。例如：
- en: People forget to log off; if there is no session timeout, anyone can pick up
    your program later and start using it.
  id: totrans-1579
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们忘记注销；如果没有会话超时，任何人都可以稍后拿起你的程序并开始使用它。
- en: Many attackers use dictionary-based password-cracking tools that fire off many
    login attempts until one works. Users choose easy-to-memorize passwords that are
    also easy to guess. Any system that allows weak, easy-to-guess passwords is vulnerable.
    More secure systems suspend a user's account after a few unsuccessful logins.
  id: totrans-1580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多攻击者使用基于字典的密码破解工具，不断尝试登录，直到成功为止。用户选择易于记忆但同时也容易被猜到的密码。任何允许弱密码和容易被猜到的密码的系统都是脆弱的。更安全的系统会在几次登录失败后暂停用户的账户。
- en: '*Social engineering*—the art of acquiring important information from people,
    items in an office, or even the outgoing trash—is usually a lot easier (and often
    quicker) than worming a way into your computer system. People are easier to con
    than computers, and attackers know this.'
  id: totrans-1581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*社会工程学*——从人们、办公室物品甚至外出的垃圾中获取重要信息的技术——通常比渗透到你的计算机系统要容易得多（并且通常更快）。人们比计算机更容易被骗，攻击者知道这一点。'
- en: Out-of-date software installations permit many compromises. Many vendors issue
    security warnings (or *bulletins*) and software patches. An administrator can
    easily fall behind the cutting edge, leaving the system open to attack.
  id: totrans-1582
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过时的软件安装允许许多妥协。许多供应商发布安全警告（或*公告*）和软件补丁。管理员可能很容易落后于前沿，使系统容易受到攻击。
- en: Setting lax permissions will allow users access to sensitive parts of your system—for
    example, letting casual viewers read everyone's salary details. The cure could
    be as basic as setting correct access permissions on the database files.
  id: totrans-1583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置宽松的权限将允许用户访问系统敏感部分——例如，让普通观众阅读每个人的薪资详情。解决办法可能只是简单地设置数据库文件的正确访问权限。
- en: Virus attacks (self-replicating malicious programs, commonly spread by email
    attachment), Trojans (hidden malicious payloads in seemingly benign software),
    and spyware (a form of Trojan that spies on what you are doing, the web pages
    you visit, etc.) infect machines and can cause all sorts of mayhem. They can capture
    even the most complex password with keystroke loggers, for example.
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 病毒攻击（自我复制的恶意程序，通常通过电子邮件附件传播）、特洛伊木马（看似良性的软件中的隐藏恶意负载）和间谍软件（一种特洛伊木马，它监视你的行为、你访问的网页等）会感染机器并可能造成各种混乱。例如，它们可以通过键盘记录器捕获甚至最复杂的密码。
- en: Storing data "in the clear" (unencrypted)—even in memory—is dangerous. Memory
    is not as safe as many programmers think; a virus or Trojan can scan computer
    memory and pull out a lot of interesting tidbits for an attacker to exploit.
  id: totrans-1585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据“明文”（未加密）——即使在内存中——是危险的。内存并不像许多程序员认为的那样安全；病毒或特洛伊木马可以扫描计算机内存，并为攻击者提取大量有趣的片段以供利用。
- en: The risks increase as the number of routes into a system grows, with more input
    methods (web-access, command-line, or GUI interfaces), more individual inputs
    (different windows, prompts, web forms, or XML feeds), and more users (there is
    a better chance of someone discovering a password). With more outputs, there are
    more chances for bugs to manifest in the display code, leaking out the wrong information.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 随着进入系统的路径数量的增加，风险也会增加，包括更多的输入方法（网络访问、命令行或GUI界面）、更多的单个输入（不同的窗口、提示、Web表单或XML馈送）以及更多的用户（有人发现密码的机会更大）。随着输出的增加，更多的机会会导致显示代码中的错误，泄露错误信息。
- en: '**KEY CONCEPT**'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*The more complicated a computer system is, the more likely it is to contain
    security vulnerabilities. Therefore, write the simplest software possible!*'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机系统越复杂，越有可能包含安全漏洞。因此，编写尽可能简单的软件！*'
- en: '* * *'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-12-FN-1)]) As we'll see, this is true whether they handle sensitive
    data or not. If a noncritical component has a public interface, then it poses
    a security risk to the system as a whole.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-12-FN-1)]) 正如我们将看到的，这无论他们是否处理敏感数据都是正确的。如果一个非关键组件有一个公开的接口，那么它对整个系统构成安全风险。
- en: The Opposition
  id: totrans-1591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**对手**'
- en: It's probably difficult to believe that anyone would take the time and effort
    to hack your application. But these people exist. They're talented, motivated,
    and very, very patient. In the battle to write secure software, it's important
    to know who you're fighting against. Understand exactly what they're doing, how
    they do it, the tools they're using, and their objectives. Only then can you formulate
    a strategy to cope.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能难以相信有人会花时间和精力来破解你的应用程序。但这些人确实存在。他们有才能、有动力，并且非常、非常耐心。在编写安全软件的战斗中，了解你是在与谁作战非常重要。确切了解他们在做什么，他们是如何做的，他们使用的工具以及他们的目标。只有这样，你才能制定出应对策略。
- en: '**SECURE IN THE KNOWLEDGE**'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '**有知的保障**'
- en: 'These important terms help us to reason about security problems:'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重要术语帮助我们推理安全问题：
- en: '**Flaw**'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误**'
- en: A security flaw is an unintended problem in an application. It is a program
    fault (see "[TERMS AND CONDITIONS](ch10s03.html#terms_and_conditions-id1 "TERMS
    AND CONDITIONS")" on page 130). Not all flaws are security problems.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 安全漏洞是应用程序中一个意外的错误。它是一个程序错误（参见第130页的“[术语和条件](ch10s03.html#terms_and_conditions-id1
    "术语和条件")”）。并非所有漏洞都是安全问题。
- en: '**Vulnerability**'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞**'
- en: A vulnerability exists when a flaw opens the possibility for a program to be
    insecure.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个漏洞使程序可能不安全时，就存在一个漏洞。
- en: '**Exploit**'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用**'
- en: This is an automated tool (or a manual method) that employs a program vulnerability
    to force unintended—and insecure—behavior. Not all vulnerabilities are found and
    exploited (that's called *luck*).
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自动化的工具（或手动方法），它利用程序漏洞强制执行非故意且不安全的操作。并非所有漏洞都被发现和利用（这被称为*运气*）。
- en: '**Who**'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁**'
- en: Your attacker might be a common crook, a talented cracker, a *script kiddie*
    (a derogatory name for crackers who run automated cracker scripts—they exploit
    well-known vulnerabilities with little skill themselves), a dishonest employee
    cheating the company, or a disgruntled ex-employee seeking revenge for unfair
    dismissal.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 你的攻击者可能是一个普通的骗子、一个有才华的破解者、一个*脚本小子*（破解者运行自动化破解脚本的贬义词——他们自己几乎不需要技能就能利用已知的漏洞），一个欺骗公司的
    dishonest employee，或者一个因不公平解雇而寻求报复的 disgruntled ex-employee。
- en: Crackers are well informed. There is a cracker subculture where knowledge is
    passed on and easy-to-use cracker tools are distributed. Not knowing about this
    doesn't make you innocent and pure, just naïve and open to the simplest attack.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 破解者消息灵通。存在一个破解者亚文化，其中知识得以传承，易于使用的破解工具得以分发。不了解这一点并不使你无罪和纯洁，只是天真且容易受到最简单攻击的威胁。
- en: '**Where**'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置**'
- en: Thanks to pervasive networking, attackers could be anywhere, on any continent,
    using any type of computer. When working over the Internet, attackers are very
    hard to locate; many are skilled at covering their tracks. Often they crack easy
    machines to use as covers for more audacious attacks.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了无处不在的网络，攻击者可能无处不在，在任何大陆，使用任何类型的计算机。当在互联网上工作时，攻击者很难定位；许多人擅长掩盖自己的踪迹。他们经常破解简单的机器作为更大胆攻击的掩护。
- en: '**When**'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时**'
- en: They could attack at any time, day or night. Across continents, one person's
    day is another's night. You need to run secure programs around the clock, not
    just during business hours.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以随时攻击，白天或夜晚。跨越大陆，一个人的白天是另一个人的夜晚。你需要全天候运行安全程序，而不仅仅是工作时间内。
- en: '**Why**'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么**'
- en: With such a large bunch of potential attackers, the motives for an attack are
    diverse. It might be malicious (a political activist wants to ruin your company
    or a thief wants to access your bank account), or it might be for fun (a college
    prankster wants to post a comical banner on your website). It might be inquisitive
    (a hacker just wants to see what your network infrastructure looks like or practice
    his cracking skills) or opportunist (a user stumbles over data he shouldn't see
    and works out how to use it to his advantage).
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此多的潜在攻击者中，攻击的动机是多样的。它可能是恶意的（一个政治活动家想要破坏你的公司，或者一个小偷想要访问你的银行账户），或者可能是为了乐趣（一个大学生恶作剧者想在你的网站上发布一个滑稽的横幅）。它可能是好奇的（一个黑客只是想看看你的网络基础设施是什么样子，或者练习他的破解技能），或者机会主义的（一个用户偶然发现了他不应该看到的数据，并设法利用它来获得自己的利益）。
- en: 'In a networked world, you usually won''t know who your enemies actually are
    until after they have struck. You might not even find out who they are then; your
    forensic skills might not be able to work back from a smouldering pile of digital
    debris. But like any good boy scout: *Be prepared*. Don''t ignore vulnerabilities
    and assume no one is interested in attacking your systems—someone out there *is*
    interested.'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个网络化的世界中，你通常在敌人攻击之后才会知道他们的真实身份。你可能甚至无法知道他们是谁；你的取证技能可能无法从一堆燃烧的数字碎片中回溯。但就像任何好的童子军一样：*做好准备*。不要忽视漏洞，并假设没有人对攻击你的系统感兴趣——外面有人
    *确实* 对此感兴趣。
- en: '**KEY CONCEPT**'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '**KEY CONCEPT**'
- en: '*Don''t ignore vulnerabilities and pretend that you''re invincible. Someone,
    somewhere wants to exploit your code, guaranteed*.'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要忽视漏洞，假装自己是不可战胜的。肯定有人，某个地方，想要利用你的代码*。'
- en: '**CRACKER VS. HACKER**'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRACKER VS. HACKER**'
- en: 'These two terms often get confused and used inappropriately. Their correct
    definitions are:'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个术语经常被混淆并错误地使用。它们的正确定义是：
- en: '**Cracker**'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cracker**'
- en: Someone who purposefully exploits vulnerabilities in computer systems to gain
    unauthorized access.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 某人故意利用计算机系统中的漏洞以获得未经授权的访问。
- en: '**Hacker**'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客**'
- en: Often used incorrectly to mean *cracker*, a *hacker* is really someone who hacks
    at—works on—code. This is a 1970s term used with pride by a particular breed of
    programming geek. A hacker is a computer expert or enthusiast.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 经常被错误地用来表示 *cracker*，一个 *hacker* 实际上是指那些在代码上工作——破解代码的人。这是一个 1970 年代的术语，被一种特定的编程极客群体自豪地使用。一个黑客是计算机专家或爱好者。
- en: 'You might also see these two hacker terms in use:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能看到这两个黑客术语被使用：
- en: '**White hat**'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '**白帽**'
- en: White hat hackers consider the consequences of their work, scorning the actions
    of crackers and unethical computer users. They believe that their work is for
    the good of society.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 白帽黑客会考虑他们工作的后果，蔑视 crackers 和不道德的电脑用户的行为。他们认为自己的工作是为了社会的利益。
- en: '**Black hat**'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑帽**'
- en: This is a programmer from the dark side who enjoys abusing computer systems.
    Black hats are crackers who actively seek to use systems dishonestly. They have
    no regard for other people's property or privacy.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个来自黑暗面的程序员，喜欢滥用计算机系统。黑帽是那些积极寻求不诚实地使用系统的 crackers。他们不关心他人的财产或隐私。
- en: Excuses, Excuses
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借口，借口
- en: 'How do attackers manage to break into code so often? They''re armed with weapons
    we don''t have or (due to lack of education) know nothing about. Tools, knowledge,
    skills: These all work in their favor. However, they have one key advantage that
    makes all the difference—time. In the heat of the software factory, programmers
    are pressed to deliver as much code as humanly possible (probably a little bit
    more) and to do so on time, or else. This code has to meet all requirements (for
    functionality, usability, reliability, etc.), leaving us precious little time
    to focus on other "peripheral" concerns, like security. Attackers don''t share
    this burden; they have plenty of time to learn the intricacies of your system,
    and they have learned to attack from many different angles.'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者是如何频繁地破解代码的？他们拥有我们没有的武器，或者（由于缺乏教育）对它们一无所知。工具、知识、技能：这些都在他们的优势之中。然而，他们有一个关键的优势，这决定了所有差异——时间。在软件工厂的热潮中，程序员们被迫尽可能多地交付代码（可能还有一点点多），并且按时完成，否则。这段代码必须满足所有要求（对于功能、可用性、可靠性等），这让我们几乎没有时间去关注其他“外围”问题，比如安全性。攻击者不承担这种负担；他们有足够的时间去了解你系统的复杂性，并且他们已经学会了从许多不同的角度进行攻击。
- en: The game is stacked heavily in their favor. As software developers, we must
    defend all possible points of the system; an attacker can pick the weakest point
    and focus there. We can only defend against the known exploits; attackers can
    take their time to find any number of unknown vulnerabilities. We must be constantly
    on the lookout for attacks; attackers can strike at will. We have to write good,
    clean software that works nicely with the rest of the world; attackers can play
    as dirty as they like.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏规则明显有利于他们。作为软件开发者，我们必须捍卫系统的所有可能点；攻击者可以选择最薄弱的点并集中攻击。我们只能防御已知的漏洞；攻击者可以花时间寻找任何数量的未知漏洞。我们必须时刻警惕攻击；攻击者可以随心所欲地发动攻击。我们必须编写出与世界其他部分良好协作的优质、干净的软件；攻击者可以随心所欲地玩弄伎俩。
- en: Software security presents a myriad of extra—but important—problems and challenges
    for the poor, overworked programmer. What does this tell us? Simply that we *must*
    do better. We must be better informed, better armed, more aware of our enemies,
    and more conscious of the way we write code. We must design in security from the
    outset and put it into our development processes and schedules.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全给辛苦工作的程序员带来了许多额外但重要的问题和挑战。这告诉我们什么？简单地说，我们*必须*做得更好。我们必须更加了解情况，装备更好，更加了解我们的敌人，并且更加意识到我们编写代码的方式。我们必须从一开始就设计安全性，并将其纳入我们的开发流程和计划中。
- en: Feeling Vulnerable
  id: totrans-1628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感觉到脆弱
- en: The programmer's role in this mess is to write secure code, so let's survey
    the weak points in our software to determine where we must focus our effort. These
    are specific types of code vulnerabilities, holes that can be compromised by an
    attacker.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个混乱中，程序员的职责是编写安全的代码，因此让我们调查我们软件中的弱点，以确定我们必须集中精力在哪里。这些都是特定的代码漏洞，攻击者可以从中攻破。
- en: Insecure Design and Architecture
  id: totrans-1630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不安全的设计和架构
- en: 'This is the most fundamental flaw, and consequently the hardest to fix. Failure
    to consider security at the architectural level will lead to committing security
    sins everywhere: sending unencrypted data over public networks, storing it on
    easily accessible media, and running software services that have known security
    flaws.'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本的缺陷，因此也是最难修复的。在架构层面没有考虑安全性会导致在各个地方犯下安全错误：在公共网络上发送未加密的数据，存储在易于访问的媒体上，以及运行具有已知安全漏洞的软件服务。
- en: Security should appear on the radar as soon as development starts. Every system
    component must be considered for security holes; a computer system is only as
    safe as its least secure part, which may not even be the code you're writing.
    For example, a Java program can be no more secure than the JVM executing it.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性应该在开发一开始就出现在雷达上。每个系统组件都必须考虑是否存在安全漏洞；计算机系统的安全性仅与其最不安全的部分相当，而这部分可能甚至不是你正在编写的代码。例如，Java程序的安全性不会超过执行它的JVM。
- en: Buffer Overrun
  id: totrans-1633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: Most applications are public facing, listening on an open network port or handling
    input from a web browser or GUI interface. These input routines are prime sites
    for security failure.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都是面向公众的，监听开放的网络安全端口或处理来自网页浏览器或GUI界面的输入。这些输入例程是安全失败的热点。
- en: C code programs often use the standard library function `sscanf` to parse input.
    Although it's part of C's standard library and appears in C code regularly, `sscanf`
    unashamedly provides subtle ways to write insecure code.^([[2](#ftn.CHP-12-FN-2)])
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: C代码程序通常使用标准库函数`sscanf`来解析输入。尽管它是C标准库的一部分，并且经常出现在C代码中，但`sscanf`却毫不掩饰地提供了编写不安全代码的微妙方式.^([[2](#ftn.CHP-12-FN-2)])
- en: 'You might see code like this:'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到这样的代码：
- en: '[PRE8]'
  id: totrans-1637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Can you see the glaring problem? An ill-formed `input` string—anything over
    100 characters—will overrun the `my_string` buffer and smear arbitrary data across
    invalid memory addresses.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出这个明显的问题吗？一个格式不正确的`input`字符串——任何超过100个字符的字符串——将会溢出`my_string`缓冲区，并将任意数据涂抹到无效的内存地址上。
- en: The results depend on what memory is trashed. Sometimes the program will carry
    on unaffected; you've been very, very lucky.^([[3](#ftn.CHP-12-FN-3)]) Sometimes
    the program continues, but its behavior is subtly altered—this can be hard to
    spot and confusing to debug. Sometimes the program will crash as a consequence,
    perhaps taking other critical system components down with it. But the worst case
    is when the spilt data gets written somewhere in the CPU's execution path. This
    isn't actually hard to do and allows an attacker to execute arbitrary code on
    your machine, potentially gaining complete access to it.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 结果取决于被丢弃的是哪种内存。有时程序会继续运行而不受影响；你非常、非常幸运。[^[[3](#ftn.CHP-12-FN-3)]] 有时程序会继续运行，但其行为会微妙地改变——这可能是难以察觉的，调试起来也很混乱。有时程序会因此崩溃，可能还会将其他关键系统组件拖垮。但最糟糕的情况是，溢出的数据被写入CPU执行路径中的某个地方。这实际上并不难做到，允许攻击者在你的机器上执行任意代码，可能获得对它的完全访问权限。
- en: Overrun is easiest to exploit when the buffer is located on the stack, as in
    the example above. Here it's possible to direct CPU behavior by overwriting the
    stack-stored return address of a function call. However, buffer overrun exploits
    can abuse heap-based buffers too.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓冲区位于堆栈上时，溢出最容易利用，如上面的例子所示。在这里，可以通过覆盖函数调用的堆栈存储的返回地址来指导CPU的行为。然而，缓冲区溢出漏洞也可以滥用基于堆的缓冲区。
- en: Embedded Query Strings
  id: totrans-1641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式查询字符串
- en: This breed of attack can be used to crash programs, execute arbitrary code,
    or fish for unauthorized data. Like buffer overrun, it relies on a failure to
    parse input, but rather than burst buffer boundaries, these attacks exploit what
    the program subsequently does with the unfiltered input.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击类型可以用来使程序崩溃、执行任意代码或窃取未经授权的数据。像缓冲区溢出一样，它依赖于解析输入的失败，但与突破缓冲区边界不同，这些攻击利用程序随后对未过滤输入的处理。
- en: '*Format string attacks* are a classic example of this problem in C programs.
    A common culprit is the `printf` function (and its variants), used as follows:'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '*格式字符串攻击*是C程序中此类问题的经典例子。一个常见的罪魁祸首是`printf`函数（及其变体），使用方式如下：'
- en: '[PRE9]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A malicious user could provide an input string containing `printf` format tokens
    (like `%s` and `%x`) and coerce the program to print data from the stack or even
    from locations in memory, depending on the exact form of the `printf` call. An
    attacker can also write arbitrary data to memory locations using a similar ploy
    (exploiting the `%n` format token).
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意用户可以提供一个包含`printf`格式标记（如`%s`和`%x`）的输入字符串，并迫使程序从堆栈或甚至从内存中的某个位置打印数据，具体取决于`printf`调用的确切形式。攻击者还可以使用类似的手段（利用`%n`格式标记）将任意数据写入内存位置。
- en: Solutions to this problem aren't hard to find. Writing `printf("%s", input)`
    will avoid the problem by ensuring that `input` is not interpreted as a format
    string.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法并不难找。通过写入`printf("%s", input)`可以确保`input`不会被解释为格式字符串。
- en: There are many other situations where an embedded query can maliciously exploit
    a program. SQL statements can be surreptitiously fed into database applications
    to force them to perform arbitrary database lookups for an attacker.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他情况下，嵌入的查询可以恶意利用程序。SQL语句可以秘密地输入到数据库应用程序中，迫使它们为攻击者执行任意的数据库查找。
- en: 'Another variant exhibited by lax web-based applications is known as a *cross-site
    scripting* exploit, due to the way the attack works across the system: from an
    attacker''s input, through the web application, finally manifesting on a victim''s
    browser. An attacker''s bogus comment on a web-based messaging system will be
    rendered by all browsers viewing the page. If the message contains hidden JavaScript
    code, the browsers will execute it without their users realizing it.'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 松散的基于Web的应用程序所表现出的另一种变体被称为*跨站脚本*攻击，因为攻击在系统中的工作方式：从攻击者的输入，通过Web应用程序，最终在受害者的浏览器上显现。攻击者在基于Web的消息系统上的虚假评论将被所有查看该页面的浏览器渲染。如果消息包含隐藏的JavaScript代码，浏览器将在用户未意识到的情况下执行它。
- en: Race Conditions
  id: totrans-1649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞态条件
- en: It is possible to exploit systems that rely on the subtle ordering of events,
    to provoke unintended behavior or crash the code. This is generally exhibited
    in systems with complex threading models or that are comprised of many collaborating
    processes.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 可以利用依赖于事件微妙顺序的系统，来引发意外的行为或使代码崩溃。这通常体现在具有复杂线程模型或由许多协作进程组成的系统中。
- en: A threaded program might share its memory pool between two worker threads. Without
    adequate guarding, one thread might read information in the buffer that the writer
    thread did not intend to release yet—part of a privileged transaction or a different
    user's information.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程化的程序可能在其两个工作线程之间共享其内存池。如果没有足够的保护，一个线程可能会读取写入线程尚未打算释放的信息——可能是特权交易的一部分或不同用户的信息。
- en: This problem isn't restricted to threaded applications, though. Consider the
    following fragment of Unix C code. It intends to dump some output to a file and
    then change file permissions on it.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个问题并不局限于线程化应用程序，但请考虑以下 Unix C 代码片段。它打算将一些输出写入文件，然后更改该文件的权限。
- en: '[PRE10]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is a race here that an attacker can exploit. By removing the file at point
    `A` and replacing it with a link to his own file, the attacker gains a specially
    privileged file. This can be used to further exploit the system.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个攻击者可以利用的竞争条件。通过在点 `A` 处删除文件并替换为其自己的文件链接，攻击者获得了一个具有特殊特权的文件。这可以用来进一步利用系统。
- en: Integer Overflow
  id: totrans-1655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数溢出
- en: 'Careless use of mathematical constructs can cause a program to cede control
    in unusual ways. Integer overflow will occur when a variable type is too small
    to represent the result of an arithmetic operation. The unsigned 8-bit data type
    (`uint8_t`) renders this C calculation erroneous:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 粗心使用数学结构可能导致程序以不寻常的方式放弃控制。当变量类型太小无法表示算术运算的结果时，会发生整数溢出。无符号 8 位数据类型 (`uint8_t`)
    使得以下 C 计算出错：
- en: '[PRE11]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The contents of `a` will be 0, not the 256 you''d expect; 8 bits can only count
    up to 255\. An attacker can supply very large numeric input values to provoke
    overflow and generate unintended program results. It''s not hard to see this causing
    significant problems; the following C code contains a heap overrun waiting to
    happen, thanks to integer overflow:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 的内容将是 0，而不是你预期的 256；8 位只能计数到 255。攻击者可以提供非常大的数值输入来引发溢出并生成意外的程序结果。不难看出这会导致重大问题；以下
    C 代码包含一个即将发生的堆溢出，这是由于整数溢出：'
- en: '[PRE12]'
  id: totrans-1659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's true that `uint8_t` is an unlikely candidate for the string length variable,
    but the exact same problem manifests itself with larger data types. It's less
    likely in normal operation, but just as exploitable.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `uint8_t` 很不可能成为字符串长度变量的候选者，但相同的问题也会在更大的数据类型中表现出来。在正常操作中，这种情况不太可能发生，但同样可被利用。
- en: This kind of problem also occurs with subtraction operations (where it's called
    integer *underflow*), mixed signed and unsigned assignments, bad type casting,
    and multiplication or division.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题也发生在减法操作（称为整数 *下溢*）、混合有符号和无符号赋值、类型转换错误以及乘法或除法中。
- en: '* * *'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-12-FN-2)]) This example is written in C and is common in C code,
    but remember that this exploit is far from a C-only problem.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-12-FN-2)]) 这个例子是用 C 编写的，在 C 代码中很常见，但请记住，这个问题远非 C 语言特有的问题。
- en: ^([[3](#CHP-12-FN-3)]) Or, to look at it another way, you've been very unlucky.
    You didn't spot the flaw when testing; it will enter production code, just waiting
    for a cracker to exploit it.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-12-FN-3)]) 或者，换一种说法，你非常不幸。你在测试时没有发现这个缺陷；它将进入生产代码，只等待黑客利用它。
- en: Protection Racket
  id: totrans-1665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护费
- en: The more you seek security, the less of it you have.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 你越寻求安全，你拥有的就越少。
- en: --Brian Tracy
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: --布赖恩·特雷西
- en: 'We''ve seen how software construction is like building a house (see "[DO WE
    REALLY BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question "DO WE
    REALLY BUILD SOFTWARE?")" on page 177, and Chapter 14). We must learn to secure
    our programs just like we''d protect a house, locking all doors and windows, employing
    a sentry, and adding security mechanisms (like a burglar alarm, electronic pass
    cards, identity badges, etc.). But you must still be constantly vigilant: A door
    can be left ajar regardless of any fancy lock devices, and a burglar alarm can
    be left unset.'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到软件构建就像建造一所房子（参见第 177 页的 "[我们真的在构建软件吗？](ch10.html#do_we_really_build_software_question
    "我们真的在构建软件吗？")" 和第 14 章）。我们必须学会像保护一所房子一样保护我们的程序，锁上所有的门窗，雇佣哨兵，并添加安全机制（如防盗报警器、电子通行证、身份卡等）。但你必须始终保持警惕：无论有多少复杂的锁，门都可能被留下一丝缝隙，防盗报警器也可能被忽略。
- en: 'Our software security strategies apply at different levels:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的软件安全策略适用于不同的层次：
- en: '**The system** installation'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统** 安装'
- en: The exact OS configuration, network infrastructure, and version numbers of all
    running applications have important security implications.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的操作系统配置、网络基础设施以及所有运行应用程序的版本号都具有重要的安全影响。
- en: '**The software system** design'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: We need to address design issues like whether the user can remain logged in
    for indefinite periods, how each subsystem communicates, and which protocols are
    used.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: '**The program** implementation'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: It must be flaw-free. Buggy code leads to security vulnerabilities.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: '**The system''s usage** procedure'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: If it is routinely used incorrectly, any software system can be compromised.
    We should prevent this as much as possible with sound design, but users must be
    taught not to cause problems. How many people write down their username and password
    on paper beside their terminals?
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: Creating a secure system is never easy. It will always require a security/functionality
    compromise. The more secure a system is, the less useful it becomes. The safest
    system has no inputs and no outputs; there's nowhere for anyone to attack. It
    won't do much, though. The easiest system has no authentication and allows everyone
    full access to everything; it's just terribly insecure. We need to pick a balance.
    This depends on the nature of the application, its sensitivity, and the perceived
    threat of attack. To write appropriately secure code, we must be very clear about
    such *security requirements*.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: Just as you would take steps to secure a building, the following techniques
    will protect your software from malicious attackers.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: System Installation Techniques
  id: totrans-1680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No matter how good your application is, if the target system is insecure, your
    program is vulnerable. Even the most secure application must run in its operating
    environment: under a particular OS, on a specific piece of hardware, on a network,
    and with a certain set of users. An attacker is just as likely to compromise one
    of these as your actual code.'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: Don't run any untrusted, potentially insecure program on your computer system.
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This raises the question: What makes you trust a piece of software? You can
    audit open source software to prove that it''s correct (if you have the inclination).
    You can opt for the same software that everyone else uses, thinking that there''s
    safety in numbers. (However, if a vulnerability is found in that software, you,
    and many other people, must update.) Or you can pick a supplier based on their
    reputation, hoping that it''s a worthwhile indicator.'
  id: totrans-1683
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**KEY CONCEPT**'
  id: totrans-1684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Only run trusted software on your computer system. Have a clear policy to
    decide who you trust*.'
  id: totrans-1685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Employ security technologies like firewalls and spam and virus filters. Don't
    let crackers in through a back door.
  id: totrans-1686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare for malicious authorized users by logging every operation, recording
    who did what and when. Back up all data stores periodically so that bogus modifications
    don't lose all of your good work.
  id: totrans-1687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the access routes into the system, give each user a minimal set of
    permissions, and reduce the pool of users if you can.
  id: totrans-1688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the system correctly. Certain OSes default to very lax security, practically
    inviting a cracker to walk straight in. If you're setting up such a system, then
    it's vital to learn how to protect it fully.
  id: totrans-1689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确设置系统。某些操作系统默认为非常宽松的安全设置，几乎是在邀请黑客直接进入。如果你正在设置这样的系统，那么学习如何完全保护它是至关重要的。
- en: 'Install a *honeypot*: a decoy machine that attackers will find more easily
    than your real systems. If it looks plausible enough, then they''ll waste their
    energy breaking into it, while your critical machines continue unaffected. Hopefully
    you''ll notice a compromise of the honeypot and repel the attacker long before
    he gets near your valuable data.'
  id: totrans-1690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个*诱饵系统*：一个比你的真实系统更容易被攻击者找到的诱饵机器。如果它看起来足够可信，那么他们会浪费精力试图入侵它，而你的关键机器将继续不受影响。希望你能及时发现诱饵系统的妥协并在此之前击退攻击者。
- en: Software Design Techniques
  id: totrans-1691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件设计技术
- en: This is the essential place to get your security story straight. You can try
    to shoehorn security into code at the end of a development cycle, and you'll fail.
    It must be a fundamental part of your system's architecture and design.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 这是确保你的安全故事清晰的基本地方。你可以在开发周期结束时试图将安全强加于代码，但你会失败。它必须是你的系统架构和设计的基本部分。
- en: '**KEY CONCEPT**'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Security is an essential aspect of every software architecture. It''s a mistake
    to gloss over it during early development work*.'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全性是每个软件架构的基本方面。在早期开发工作中忽略它是错误的*。'
- en: The simplest software design has the fewest points of attack and is consequently
    the easiest to secure. More complex designs naturally lead to more interactions
    between constituent parts, and so provide more places for a cracker to attack.
    If you're one of the 99.9 percent of programmers who can't run your program in
    a sealed box in an underground bunker in an undisclosed location in the middle
    of a desert, then you need to consider how to make your design as simple as possible.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的软件设计具有最少的攻击点，因此也最容易受到保护。更复杂的设计自然会导致组成部分之间的更多交互，因此为黑客提供了更多的攻击点。如果你是那99.9%的程序员之一，你不能在一个未公开的沙漠中的地下掩体中运行你的程序，那么你需要考虑如何使你的设计尽可能简单。
- en: 'As you design the code, think about how to actively prevent anyone from abusing
    it. Here are the winning strategies:'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计代码时，考虑如何积极防止任何人滥用它。以下是一些成功的策略：
- en: Limit the number of inputs in your design, and route all communication through
    one portion of the system. This way, an attacker can't get all over your code—only
    through a single (secured) bottleneck. His influence is limited to a secluded
    corner, and you can focus your security efforts there.^([[4](#ftn.CHP-12-FN-4)])
  id: totrans-1697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制你设计中的输入数量，并将所有通信通过系统的一个部分进行路由。这样，攻击者就不能在你的代码中四处游走——只能通过一个（受保护的）瓶颈。他们的影响力被限制在一个隐蔽的角落，你可以在那里集中你的安全努力。[^[[4](#ftn.CHP-12-FN-4)]]
- en: Run every program at the most restrictive privilege level possible. Don't run
    a program as the system superuser unless it's absolutely necessary, and then take
    *even more* care than usual. This is especially important for Unix programs that
    run setuid—these can be run by any user but are given special system privileges
    when they start.
  id: totrans-1698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能以最严格的权限级别运行每个程序。除非绝对必要，否则不要以系统超级用户身份运行程序，并且在这种情况下要更加小心。这对于运行setuid的Unix程序尤为重要——这些程序可以被任何用户运行，但在启动时被赋予特殊的系统权限。
- en: Avoid any features that you don't really need. It will not only save you development
    time, but also reduce the chance of bugs getting into the program—there's less
    software for them to inhabit. The less complicated your code, the less likely
    it is to be insecure.
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免任何你实际上不需要的功能。这不仅会节省你的开发时间，还会减少程序中出现错误的机会——可供它们栖息的软件更少。你的代码越简单，它就越不可能不安全。
- en: Don't rely on insecure libraries. An insecure library is anything you don't
    *know* to be secure. For example, most GUI libraries aren't designed for security,
    so don't use them in a program run as the superuser.
  id: totrans-1700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要依赖不安全的库。不安全的库是指你不知道其安全性如何的任何库。例如，大多数GUI库都不是为安全性设计的，因此不要在以超级用户身份运行的程序中使用它们。
- en: '**KEY CONCEPT**'
  id: totrans-1701
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Only rely on known, secure third-party components in your program design*.'
  id: totrans-1702
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*在设计程序时，只依赖已知且安全的第三方组件*。'
- en: Tailor your code to an execution environment that manages security issues. The
    .NET run time offers offers a *code access security* infrastructure that allows
    you to assert, for example, that the calling code has been signed by a trusted
    third party. This doesn't remove all potential problems (the company's private
    key could always go astray), and you must learn how to use it correctly, but it
    does help to manage security problems.
  id: totrans-1703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的代码调整到管理安全问题的执行环境中。.NET 运行时提供了一个 *代码访问安全* 基础设施，允许你断言，例如，调用代码已被受信任的第三方签名。这并不能消除所有潜在问题（公司的私钥可能会丢失），你必须学会正确使用它，但它确实有助于管理安全问题。
- en: Avoid storing sensitive data. If you must, encrypt it so that prying eyes can't
    easily read it. When you handle secrets, be very wary of where you put them; lock
    memory pages containing sensitive information so that your OS's virtual memory
    manager can't swap it onto the hard disk, leaving it available for an attacker
    to read.
  id: totrans-1704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免存储敏感数据。如果必须存储，请加密它，以便好奇的眼睛难以轻易阅读。当你处理机密信息时，要非常小心地将它们放在哪里；锁定包含敏感信息的内存页面，这样你的操作系统的虚拟内存管理器就不能将其交换到硬盘上，使其可供攻击者读取。
- en: Obtain secrets from the user carefully. Don't display passwords.
  id: totrans-1705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎地从用户那里获取机密信息。不要显示密码。
- en: The least impressive security strategy is known as *security through obscurity*,
    yet this is really the most prevalent. It merely hides all software design and
    implementation behind a wall so that no one can see how the code works and figure
    out how to abuse it. Obscurity means that you don't advertise your critical computer
    systems in the hope that no attacker will find them.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 最不令人印象深刻的策略被称为 *通过隐蔽性来提高安全性*，但实际上这是最普遍的。它只是将所有软件设计和实现隐藏在墙后，这样就没有人能看到代码是如何工作的，也无法找出如何滥用它。隐蔽性意味着你不宣传你的关键计算机系统，希望没有攻击者能找到它们。
- en: It's a flawed plan. Your system *will* one day be found, and it *will* one day
    be attacked.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有缺陷的计划。你的系统总有一天会被发现，总有一天会被攻击。
- en: It's not always a conscious decision, and this technique works very conveniently
    when you forget to consider security in the system design at all—that is, it's
    convenient until someone *does* compromise your system. Then it's a different
    matter.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是有意识的决策，而且当你忘记在系统设计中考虑安全性时，这种技术非常方便——也就是说，直到有人真的破坏了你的系统，那时就完全是另一回事了。
- en: '**KEY CONCEPT**'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Expect your software to be attacked, and design each part with this in mind*.'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '*预期你的软件会受到攻击，并且要以此为出发点来设计每个部分*。'
- en: Code Implementation Techniques
  id: totrans-1711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码实现技术
- en: With a bulletproof system design, your software is unbreakable, right? Sadly,
    it is not. We've already seen how security exploits can capitalize on flaws in
    code to wreak their particular brand of chaos.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 有了坚不可摧的系统设计，你的软件就是坚不可摧的，对吧？遗憾的是，并非如此。我们已经看到安全漏洞如何利用代码中的缺陷来造成他们特有的混乱。
- en: Our code is the front line, the most common route an attacker will try to enter
    through and the place our battles are fought. Without a good system design, even
    the best code is vulnerable to attack; but upon the foundation of a well-thought-out
    architecture, we must build strong walls of defense with secure code. Correct
    code is not necessarily secure code.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码是前线，是攻击者最常尝试进入的地方，也是我们战斗的地方。没有良好的系统设计，即使是最好的代码也容易受到攻击；但在深思熟虑的架构基础上，我们必须用安全的代码构建坚固的防御墙。正确的代码不一定是安全的代码。
- en: Defensive programming is the main technique to achieve sound code. Its central
    tenet—*assume nothing*—is exactly what secure programming is about. Paranoia is
    a virtue, and you can never assume that users will employ your program as you
    expect or intend them to.
  id: totrans-1714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御性编程是实现稳健代码的主要技术。其核心原则——*假设一切都不对*——正是安全编程的精髓。偏执是一种美德，你永远不能假设用户会像你期望或意图的那样使用你的程序。
- en: Simple defensive rules like "check *every* input" (including user input, startup
    commands, and environment variables), and "validate *every* calculation" will
    remove countless security vulnerabilities from your code.
  id: totrans-1715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单的防御规则，如“检查*每一个*输入”（包括用户输入、启动命令和环境变量），以及“验证*每一个*计算”，将消除你代码中的无数安全漏洞。
- en: Perform *security audits*. These are careful reviews of the source code by security
    experts. Normal testing won't find many security flaws; they are generally caused
    by bizarre combinations of use that ordinary testers wouldn't think of (for example,
    very long input sequences that provoke buffer overrun).
  id: totrans-1716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn child processes very carefully. If an attacker can redirect the sub-task,
    then he can gain control of arbitrary facilities. Don't use C's `system` function
    unless there's no other solution.
  id: totrans-1717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test and debug mercilessly. Squash bugs as rigorously as you can. Don't write
    code that can crash; its use could bring down a running system instantly.
  id: totrans-1718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap all operations in atomic transactions so attackers can''t exploit race
    conditions to their advantage. You could fix the `chmod` example in "[Race Conditions](ch12s04.html#race_conditions
    "Race Conditions")" on page 231 by using `fchmod` on the open file handle, rather
    than `chmod`ing the file by name: It doesn''t matter if the attacker replaces
    the file, you know exactly which file is being altered.'
  id: totrans-1719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural Techniques
  id: totrans-1720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is largely a matter of training and education, although it helps to select
    users who aren't totally inept (if you have that luxury).
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: 'Users must be taught safe working practices: not to tell anyone their password,
    not to install random software on a critical PC, and to use their systems only
    as prescribed. However, even the most diligent people will make mistakes. We design
    to minimize the risk of these mistakes, and we hope that the consequences are
    never too severe.'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#CHP-12-FN-4)]) Of course, it's never quite that simple. A buffer overrun
    could occur anywhere in your code, and you must be constantly vigilant. However,
    most security vulnerabilities exist at, or near, the sites of program input.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: In a Nutshell
  id: totrans-1725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a kind of death.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: --Tennessee Williams
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: Programming is war.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: Security is a real issue in modern software development; you can't stick your
    head in the sand and hide from it. Ostriches write poor code. We can prevent most
    security breaches by better design, better system architecture, and greater awareness
    of the problems. The benefits of a secure system are compelling, since the risks
    are so serious.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-1730
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1731
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: Understand the security requirements for each project they work on
  id: totrans-1733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instinctively write code that avoids common security vulnerabilities
  id: totrans-1734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design security into each system; they don't patch it in at the end
  id: totrans-1735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a security test strategy
  id: totrans-1736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: Dismiss security as an unimportant concern
  id: totrans-1738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider themselves security experts (very few people are security experts)
  id: totrans-1739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only think about security flaws in their programs when vulnerabilities are discovered,
    or worse, when their code is compromised
  id: totrans-1740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on security when writing code and ignore it at the design and architectural
    levels
  id: totrans-1741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-1743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: '*Defensive programing* is an important technique for writing secure code.'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '*防御性编程*是编写安全代码的重要技术。'
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。测试时代")'
- en: We must rigorously test our software for security issues.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须严格测试我们的软件以发现安全问题。
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。宏伟设计")'
- en: Security is similarly essential to the design of each section of code.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性同样对于代码每个部分的构建至关重要。
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。软件架构")'
- en: Security is one of the fundamental architectural concerns of a computer system.
    It must be designed in from the outset.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是计算机系统基本架构关注点之一。它必须从一开始就设计进去。
- en: '![See Also](tagoreillycom20080909nostarchimages207480.png)'
  id: totrans-1752
  prefs: []
  type: TYPE_IMG
  zh: '![参见](tagoreillycom20080909nostarchimages207480.png)'
- en: Get Thinking
  id: totrans-1753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考
- en: A detailed discussion of the following questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 515.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题的详细讨论可以在第515页的"[附录A](apa.html "附录A。答案与讨论")"部分找到。
- en: Mull It Over
  id: totrans-1755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思考
- en: What is a "secure" program?
  id: totrans-1756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是“安全”程序？
- en: What input must be validated in a secure program? What sort of validation is
    required?
  id: totrans-1757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安全程序中必须验证哪些输入？需要什么样的验证？
- en: How can you guard against attacks from the pool of trusted users?
  id: totrans-1758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何防御来自受信任用户池的攻击？
- en: Where can an exploitable buffer overrun occur? What functions are particularly
    prone to buffer overrun?
  id: totrans-1759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可利用的缓冲区溢出可能发生在哪里？哪些函数特别容易发生缓冲区溢出？
- en: Can you avoid buffer overruns altogether?
  id: totrans-1760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以完全避免缓冲区溢出吗？
- en: How can you secure the memory in use by your application?
  id: totrans-1761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何保护应用程序使用的内存？
- en: Are C and C++ inherently less secure than alternative languages?
  id: totrans-1762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C和C++是否天生比其他语言更不安全？
- en: Has the experience of C led to C++ being a better, more securely designed language?
  id: totrans-1763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C语言的经验是否导致C++成为更好、更安全设计的语言？
- en: How do you know when your program has been compromised?
  id: totrans-1764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何知道你的程序已被入侵？
- en: Getting Personal
  id: totrans-1765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: What are the security requirements for your current project? How were these
    requirements established? Who knows about them? Where are they documented?
  id: totrans-1766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你当前项目的安全需求是什么？这些需求是如何建立的？谁了解它们？它们在哪里被记录？
- en: What's the worst security bug in one of your shipped applications?
  id: totrans-1767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你发布的应用程序中最严重的安全漏洞是什么？
- en: How many security bulletins have been posted against your application?
  id: totrans-1768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对你的应用程序发布了多少安全公告？
- en: Have you ever run a *security audit*? What kinds of flaws did it reveal?
  id: totrans-1769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否运行过*安全审计*？它揭示了哪些类型的缺陷？
- en: What kind of person is most likely to attack your current system? How is this
    influenced by
  id: totrans-1770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最有可能攻击你当前系统的人是什么样的？这受什么影响？
- en: Your company
  id: totrans-1771
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的公司
- en: The type of user
  id: totrans-1772
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户类型
- en: The type of product
  id: totrans-1773
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品类型
- en: The popularity of the product
  id: totrans-1774
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品的普及度
- en: The competition
  id: totrans-1775
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争
- en: The platform you run on
  id: totrans-1776
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你运行的平台
- en: The connectedness and public visibility of the system
  id: totrans-1777
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的连通性和公开可见性
