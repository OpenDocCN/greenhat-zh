["```\n  #!/usr/bin/env ruby\n  # boolean_golf.rb\n\n  =begin rdoc\n  This is intended merely to add handy true? and false? methods to every\n  object. The most succinct way seemed to be declaring these particular\n  methods in this order. Note that to_b (to Boolean) is an alias to the\n  true?() method.\n  =end\n\n  class Object    *Superclasses*\n\n❶   def false?()\n      not self\n    end\n\n❷   def true?()\n      not false?\n    end\n\n❸   alias :to_b :true?    *Metaprogramming; Symbols*\n\n  end\n```", "```\n$ irb -r boolean_golf.rb\nirb(main):001:0> true.to_b\n=> true\nirb(main):002:0> false.to_b\n=> false\nirb(main):003:0> nil.to_b\n=> false\nirb(main):004:0> true.false?\n=> false\nirb(main):005:0> false.false?\n=> true\nirb(main):006:0> nil.false?\n=> true\n```", "```\nirb(main):007:0> class String\nirb(main):008:1> alias :make_me_into_an_integer :to_i\nirb(main):009:1> end\n=> nil\nirb(main):010:0> '5'.make_me_into_an_integer\n=> 5\n```", "```\n$ irb -r boolean_golf.rb\nirb(main):001:0> true.true?\n=> true\nirb(main):002:0> true.false?\n=> false\nirb(main):003:0> nil.false?\n=> true\n```", "```\nirb(main):001:0> a = [0, 1, 2]\n=> [0, 1, 2]\nirb(main):002:0> a.join(' ')    *The **`join`** Method*\n=> \"0 1 2\"\nirb(main):003:0> a.join(', ')\n=> \"0, 1, 2\"\nirb(main):004:0> a.join('')\n=> \"012\"\n```", "```\n  #!/usr/bin/env ruby\n  # array_join.rb\n\n  class Array\n\n❶   def my_join(separator1=', ', separator2=' and ')\n      modified_join(separator1, separator2)\n    end\n\n❷   protected    *Protected Methods*\n\n❸   def modified_join!(separator1, separator2)\n      last_one = self.pop()    *The **`pop`** Method*\n      join(separator1) + separator2 + last_one.to_s\n    end\n\n❹   def modified_join(separator1, separator2)\n      self.dup.modified_join!(separator1, separator2)    *The **`dup`** Method*\n    end\n\n  end\n```", "```\nirb(main):005:0> a\n=> [0, 1, 2]\nirb(main):006:0> a.pop\n=> 2\nirb(main):007:0> a\n=> [0, 1]\nirb(main):008:0> a.pop\n=> 1\nirb(main):009:0> a\n=> [0]\nirb(main):010:0> a.pop\n=> 0\nirb(main):011:0> a\n=> []\n```", "```\n$ irb -r array_join.rb\nirb(main):001:0> a = [0, 1, 2]\n=> [0, 1, 2]\nirb(main):002:0> a.join(', ')\n=> \"0, 1, 2\"\nirb(main):003:0> a.my_join(', ')\n=> \"0, 1 and 2\"\nirb(main):004:0>\n```", "```\n$ irb -r array_join.rb\nirb(main):001:0> a = [0, 1, 2]\n=> [0, 1, 2]\nirb(main):002:0> a.join(', ')\n=> \"0, 1, 2\"\nirb(main):003:0> a.my_join(', ')\nNoMethodError: private method 'modified_join!' called for [0, 1, 2]:Array\n        from ./array_join.rb:14:in 'modified_join'\n        from ./array_join.rb:7:in 'my_join'\n        from (irb):3\n        from :0\nirb(main):004:0>\n```", "```\n  #!/usr/bin/env ruby\n  # use_cli.rb\n\n  =begin rdoc\n  Please refer to the SimpleCLI Class for documentation.\n  =end\n\n❶ require 'simple_cli'    *Require*\n\n❷ cli = SimpleCLI.new()\n  cli.parse_opts(ARGV)\n```", "```\n  #!/usr/bin/env ruby\n  # simple_cli.rb\n\n  =begin rdoc\n  Parses command line options.\n  =end\n  class SimpleCLI\n\n❶   # CONSTANTS\n\n    OPTIONS = {    *Hashes*\n      :version => ['-v', '--version'],\n      :help    => ['-h', '--help'],\n      :reset   => ['-r', '--reset'],\n    }\n\n❷   USAGE =<<END_OF_USAGE    *Here Docs*\n\n  This program understands the following options:\n    -v, --version : displays the current version of the program\n    -h, --help    : displays a message with usage instructions\n    -r, --reset   : resets the program\n\n  With no command-line options, the program performs its default behavior.\n\n  END_OF_USAGE\n\n    VERSION = \"Some Project version 0.01 (Pre-Alpha)\\n\"\n\n    # METHODS\n\n❸   def parse_opts(args)\n      return option_by_args(args[0]) if understand_args?(args)\n      # options are not understandable, therefore display_usage\n      display(USAGE)\n    end\n\n❹   private\n\n❺   def display(content)\n      puts content\n    end\n\n    def do_default()\n      puts 'I am performing my default behavior'\n    end\n\n❻   def option_by_args(arg)\n      return display(VERSION) if OPTIONS[:version].include?(arg)\n      return display(USAGE)   if OPTIONS[:help].include?(arg)\n      return reset()          if OPTIONS[:reset].include?(arg)\n      do_default()\n    end\n\n    def reset()\n      puts 'I am resetting myself.'\n    end\n\n❼   def understand_args?(args)\n      # works in Ruby1.8\n      OPTIONS.keys.any? { |key| OPTIONS[key].include?(args[0]) }    *The **`any?`** Method*\n\n❽ =begin works in Ruby1.6\n      return true unless args\n      return true unless args[0]\n      return true if args[0].size.zero?\n      OPTIONS.keys.each do |key|\n        return true if OPTIONS[key].include?(args[0])    *The **`include?`** Method*\n      end\n      return false\n  =end\n    end\n\n  end\n```", "```\n$ irb -r simple_cli.rb\nirb(main):001:0> SimpleCLI::OPTIONS[:version]\n=> [\"-v\", \"--version\"]\nirb(main):002:0> SimpleCLI::OPTIONS[:help]\n=> [\"-h\", \"--help\"]\nirb(main):003:0> SimpleCLI::OPTIONS[:reset]\n=> [\"-r\", \"--reset\"]\n```", "```\nputs 'Some Project version 0.01 (Pre-Alpha)'\nprint \"Some Project version 0.01 (Pre-Alpha)\\n\"\n```", "```\n$ irb\nirb(main):001:0> a = [0, 1, 2]\n=> [0, 1, 2]\nirb(main):002:0> a.any? { |i| i > 1 }\n=> true\nirb(main):003:0> a.any? { |i| i > 2 }\n=> false\n```", "```\n$ ./uses_cli.rb -r\nI am resetting myself.\n$ ./uses_cli.rb -v\nSome Project version 0.01 (Pre-Alpha)\n$ ./uses_cli.rb -h\n\nThis program understands the following options:\n  -v, --version : displays the current version of the program\n  -h, --help    : displays a message with usage instructions\n  -r, --reset   : resets the program\n\nWith no command-line options, the program performs its default behavior.\n\n$ ./uses_cli.rb\nI am performing my default behavior\n$ ./uses_cli.rb --reset\nI am resetting myself.\n$ ./uses_cli.rb --version\nSome Project version 0.01 (Pre-Alpha)\n$ ./uses_cli.rb --help\n\nThis program understands the following options:\n  -v, --version : displays the current version of the program\n  -h, --help    : displays a message with usage instructions\n  -r, --reset   : resets the program\n\nWith no command-line options, the program performs its default behavior.\n```", "```\nclass String\n\n  def palindrome?()\n    (self == self.reverse)    *The **`reverse`** Method*\n  end\n\nend\n```", "```\n  #!/usr/bin/env ruby\n  # palindrome2.rb\n\n  =begin rdoc\n  Gives every <b>String</b> the ability to identify whether it is a\n  a palindrome. This version ignores all non-alphabetic characters,\n  making it suitable for longer text items.\n  =end\n\n  class String\n\n❶   DUAL_CASE_ALPHABET = ('a'..'z').to_a + ('A'..'Z').to_a\n\n  =begin rdoc\n  Contrast this with some other languages, involving iterating through each\n  string index and comparing with the same index from the opposite end.\n  Takes 1 optional Boolean, which indicates whether case matters.\n  Assumed to be true.\n  =end\n❷   def palindrome?(case_matters=true)\n      letters_only(case_matters) == letters_only(case_matters).reverse\n    end\n\n    private\n\n  =begin rdoc\n  Takes 1 optional Boolean, which indicates whether case matters.\n  Assumed to be false.\n\n  =end\n❸   def letters_only(case_matters=false)\n      just_letters = split('').find_all do |char|    *The **`find_all`** Method*\n        DUAL_CASE_ALPHABET.include?(char)\n      end.join('')\n      return just_letters if (case_matters)\n      return just_letters.downcase\n    end\n\n  end\n```", "```\n#!/usr/bin/env ruby\n# test_palindrome.rb\nputs \"Band\\tPal?\\tpal?\"\nbands = %w[abba Abba asia Asia]\nbands.each do |band|\n  puts \"#{band}\\t#{band.palindrome?}\\t#{band.palindrome?(false)}\"\nend\n```", "```\n$ ruby -r palindrome2.rb tests/test_palindrome.rb\nBand    Pal?    pal?\nabba    true    true\nAbba    false   true\nasia    false   false\nAsia    false   false\n```", "```\n$ irb -r palindrome2.rb\nirb(main):001:0> 'Ika Yaki'.palindrome?\n=> false\nirb(main):002:0> 'Ika Yaki'.palindrome?(false)\n=> true\nirb(main):003:0> 'ika yaki'.palindrome?\n=> true\n```"]