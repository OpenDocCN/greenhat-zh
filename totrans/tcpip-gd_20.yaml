- en: Part III-9. OTHER FILE AND MESSAGE TRANSFER APPLICATIONS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 85](ch85.html "Chapter 85. USENET (NETWORK NEWS) AND THE TCP/IP NETWORK
    NEWS TRANSFER PROTOCOL (NNTP)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 86](ch86.html "Chapter 86. GOPHER PROTOCOL (GOPHER)")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous three parts of this book have examined several of the most widely
    used TCP/IP file and message transfer protocols: the File Transfer Protocol (FTP),
    the Trivial File Transfer Protocol (TFTP), electronic mail (email), and the World
    Wide Web. Of course, hundreds of other applications are in use on the Internet
    today, and we couldn''t possibly examine them all here. However, there are a couple
    of other protocols that are considered part of the group of classic applications
    of TCP/IP like FTP, email, and the Web that I feel are worth discussing.'
  prefs: []
  type: TYPE_NORMAL
- en: This part contains two chapters that cover these other file and message transfer
    applications. The first chapter describes Usenet (network news), which is one
    of the original methods of group communication on the Internet. The second chapter
    describes the Gopher protocol, which while no longer widely used today is worth
    a brief discussion, especially due to its role as a historical precursor of the
    Web.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 85. USENET (NETWORK NEWS) AND THE TCP/IP NETWORK NEWS TRANSFER PROTOCOL
    (NNTP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Electronic mail (email) is one of the stalwarts of message transfer on the modern
    Internet, but it is really designed only for communication within a relatively
    small group of specific users. There are many situations in which email is not
    ideally suited, such as when information needs to be shared among a large number
    of participants, not all of whom may necessarily even know each other. One classic
    example of this is sharing *news*. In this case, the person providing news often
    wants to make it generally available to anyone who is interested, rather than
    specifying a particular set of recipients.
  prefs: []
  type: TYPE_NORMAL
- en: For distributing news and other types of general information over internetworks,
    a messaging system called both *Usenet* and *network news* was created. Like email,
    this application allows messages to be written and read by large numbers of users.
    However, it is designed using a very different model than email—one that is focused
    on public sharing and feedback. In Usenet, anyone can write a message that can
    be read by any number of recipients, and anyone can respond to messages written
    by others. Usenet was one of the first widely deployed internetwork-based group
    communication applications, and it has grown into one of the largest online communities
    in the world, used by millions of people for sharing information, asking questions,
    and discussing thousands of different topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I describe Usenet and network news in detail, discussing how
    they are used and how they work. I provide an overview and history of Usenet,
    a high-level look at its model of communication and how messages are created and
    manipulated, an explanation of Usenet newsgroups, and a description of the Usenet
    message format and headers. Then I provide a detailed description of the operation
    of the Network News Transfer Protocol (NNTP), the means used for transferring
    messages on modern Usenet. Starting as usual with an overview of the protocol,
    I then explain the two fundamentals ways that NNTP is used: for the propagation
    of news articles between servers and for client article posting and access. From
    there, I move on to the technical details of NNTP commands, command extensions,
    responses, and response codes.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *Several aspects of how Usenet works are closely
    related to the standards and techniques used for email. If you have not read [Part III-7](pt18.html
    "Part III-7. TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND PROTOCOLS"), which covers
    email, I suggest that you at least review the overview of the email system in
    [Chapter 74](ch74.html "Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND
    CONCEPTS") and the discussion of the email message format in [Chapter 76](ch76.html
    "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC
    822 AND MIME"), since Usenet messages are based on the RFC 822 email message standard.*'
  prefs: []
  type: TYPE_NORMAL
- en: Usenet Overview, History, and Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where email is the modern equivalent of the handwritten letter or the interoffice
    memo, *Usenet* is the updated version of the company newsletter, the cafeteria
    bulletin board, the coffee break chat, and the watercooler gossip session, all
    rolled into one. Spread worldwide over the Internet, Usenet newsgroup messages
    provide a means for people with common interests to form online communities to
    discuss happenings, solve problems, and provide support to each other, as well
    as to engage in plain old socializing and entertainment.
  prefs: []
  type: TYPE_NORMAL
- en: We are by nature both highly social and creative animals, and as a result, we
    are always finding new ways to communicate. It did not take long after computers
    were first connected together for it to be recognized that those interconnections
    provided the means to link together people as well. The desire to use computers
    to create an *online community* led to the creation of Usenet more than two decades
    ago.
  prefs: []
  type: TYPE_NORMAL
- en: History of Usenet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like almost everything associated with networking, Usenet had very humble beginnings.
    In 1979, Tom Truscott was a student at Duke University in North Carolina, and
    he spent the summer as an intern at Bell Laboratories, the place where the UNIX
    operating system was born. He enjoyed the experience so much that when he returned
    to school that autumn, he missed the intensive UNIX environment at Bell Labs.
    He used the *Unix-to-Unix Copy Protocol (UUCP)* to send information from his local
    machine to other machines and vice versa, including establishing electronic connectivity
    back to Bell Labs.
  prefs: []
  type: TYPE_NORMAL
- en: Building on this idea, Truscott and a fellow Duke student, Jim Ellis, teamed
    up with other UNIX enthusiasts at Duke and the nearby University of North Carolina
    (UNC) at Chapel Hill, to develop the idea of an online community. The goal was
    to create a system where students could use UNIX to write and read messages, to
    allow them to obtain both technical help and maintain social contacts. They designed
    the system based on an analogy to an online newsletter that was open to all users
    of a connected system. To share information, messages were posted to *newsgroups*,
    where any user could access the messages to read them and respond to them.
  prefs: []
  type: TYPE_NORMAL
- en: The early work at Duke and UNC resulted in the development of both the initial
    message format and the software for the earliest versions of this system, which
    became known both as *network news (net news)* and *Usenet* (a contraction of
    *User's network*). At first, the system had just two computers, sharing messages
    posted in a pair of different newsgroups. The value of the system was immediately
    recognized, however, and soon many new sites were added to the system. These sites
    were arranged in a structure to allow messages to be efficiently passed using
    direct UUCP connections. The software used for passing news articles also continued
    to evolve and become more capable, as did the software for reading and writing
    articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The newsgroups themselves also changed over time. Many new newsgroups were
    created, and a hierarchical structure was defined to help keep the newsgroups
    organized in a meaningful way. As more sites and users joined Usenet, more areas
    of interest were identified. Today, there are a staggering number of Usenet newsgroups:
    more than 100,000\. While many of these groups are not used, many thousands of
    active ones discuss nearly every topic imaginable—from space exploration, to cooking,
    to biochemistry, to PC troubleshooting, to raising horses. There are also regional
    newsgroups devoted to particular areas; for example, there is a set of newsgroups
    for discussing events in Canada and another for discussing happenings in the New
    York area, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Usenet Operation and Characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usenet begins with a user writing a message to be distributed. After the message
    is *posted* to say, the group on TCP/IP networking, it is stored on that user's
    local news server, and special software sends copies of it to other connected
    news servers. The message eventually propagates around the world, where anyone
    who chooses to read the TCP/IP networking newsgroup can see the message.
  prefs: []
  type: TYPE_NORMAL
- en: The real power of Usenet is that after reading a message, any user can respond
    to it on the same newsgroup. Like the original message, the reply will propagate
    to each connected system, including the one used by the author of the original
    message. This makes Usenet very useful for sharing information about recent happenings,
    for social discussions, and especially for receiving assistance with problems,
    such as resolving technical glitches or getting help with a diet program.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is particularly interesting about Usenet is that it is not a formalized
    system in any way, and it is not based on any formally defined standards. It is
    a classic example of the development of a system in an entirely ad hoc manner:
    The software was created, people started using it, the software was refined, and
    things just took off from there. Certain standards have been written to codify
    how Usenet works—such as RFC 1036, which describes the Usenet message format—but
    these serve more as historical documents than as prescriptive standards.'
  prefs: []
  type: TYPE_NORMAL
- en: There is likewise no central authority that is responsible for Usenet's operation,
    even though new users often think there is one. Unlike a dial-up bulletin board
    system or Web-based forum, Usenet works simply by virtue of cooperation between
    sites; there is no manager in charge. For this reason, Usenet is sometimes called
    an anarchy, but this is not accurate. It isn't the case that there are no rules.
    It is up to the managers of participating systems to make policy decisions such
    as which newsgroups to support. There are also certain dictatorial aspects of
    the system, in that only certain people (usually system administrators) can decide
    whether to create some kinds of new newsgroups. The system also has socialistic
    elements in that machine owners are expected to share messages with each other.
    So, the simplified political labels really don't apply to Usenet.
  prefs: []
  type: TYPE_NORMAL
- en: Every community has a *culture*, and the same is true of online communities,
    including Usenet. There is an overall culture that prescribes acceptable behavior
    on Usenet, and also thousands of newsgroup-specific cultures in Usenet, each of
    which has evolved through the writings of thousands of participants over the years.
    There are even newsgroups devoted to explaining how Usenet itself operates, where
    you can learn about *newbies* (new users), *netiquette* (rules of etiquette for
    posting messages), and related subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Usenet Transport Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I said earlier, Usenet messages were originally transported using UUCP, which
    was created to let UNIX systems communicate directly, usually using telephone
    lines. For many years, all Usenet messages were simply sent from machine to machine
    using computerized telephone calls (just as email once was). Each computer joining
    the network would connect to one already on Usenet and receive a *feed* of messages
    from it periodically. The owner of that computer had to agree to provide messages
    to other computers.
  prefs: []
  type: TYPE_NORMAL
- en: Once TCP/IP was developed in the 1980s and the Internet grew to a substantial
    size and scope, it made sense to start using it to carry Usenet messages rather
    than UUCP. The *Network News Transfer Protocol (NNTP)* was developed specifically
    to describe the mechanism for communicating Usenet messages over the Transmission
    Control Protocol (TCP). It was formally defined in RFC 977, published in 1986,
    with NNTP extensions described in RFC 2980, published in October 2000.
  prefs: []
  type: TYPE_NORMAL
- en: For many years, Usenet was carried using both NNTP and UUCP, but NNTP is now
    the mechanism used for the vast majority of Usenet traffic, and for this reason
    is the primary focus of my Usenet discussion. NNTP is employed not only to distribute
    Usenet articles to various servers, but also for other client actions, such as
    posting and reading messages. It is thus used for most of the steps in Usenet
    message communication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Many people often equate the Usenet system as a whole with the NNTP protocol
    that is used to carry Usenet messages on the Internet. They are not the same however;
    Usenet predates NNTP, which is simply a protocol for conveying Usenet messages.*'
  prefs: []
  type: TYPE_NORMAL
- en: It is because of the critical role of NNTP and the Internet in carrying messages
    in today's Usenet that the concepts are often confused. It's essential to remember,
    however, that Usenet does not refer to any type of physical network or internetworking
    technology; rather, it is a logical network of users. That logical network has
    evolved from UUCP data transfers to NNTP and TCP/IP, but Usenet itself is the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: Today, Usenet faces competition from many other group messaging applications
    and protocols, including Web-based bulletin board systems and chat rooms. After
    a quarter of a century, however, Usenet has established itself and is used by
    millions of people every day. While to some, the primarily text-based medium seems
    archaic, it is a mainstay of global group communication and likely to continue
    to be so for many years to come.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the very first online electronic communities was set
    up in 1979 by university students who wanted to keep in touch and share news and
    other information. Today, *Usenet (for User''s network)*, also called *network
    news*, has grown into a logical network that spans the globe. By posting messages
    to a Usenet newsgroup, people can share information on a variety of subjects of
    interest. Usenet was originally implemented in the form of direct connections
    established between participating hosts. Today, the Internet is the vehicle for
    message transport.'
  prefs: []
  type: TYPE_NORMAL
- en: Usenet Communication Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the students at Duke University decided to create their online community,
    email was already in wide use, and there were many mailing lists in operation
    as well. Email was usually transported using UUCP—the same method that Usenet
    was designed to employ—during these pre-Internet days. Then why not simply use
    email to communicate between sites?
  prefs: []
  type: TYPE_NORMAL
- en: The main reason is that email is not designed to facilitate the creation of
    an online community where information can be easily shared in a group. The main
    issue with email in this respect is that only the individuals who are specified
    as recipients of a message can read it. There is no facility whereby someone can
    write a message and put it in an open place where anyone who wants to can read
    it, analogous to posting a newsletter in a public place.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with email in large groups is related to efficiency. Consider
    that if you put 1,000 people on a mailing list, each message sent to that list
    must be duplicated and delivered 1,000 times. Early networks were limited in bandwidth
    and resources, so using email for wide-scale group communication was possible,
    but far from ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** While email can be used for group communications, it has two
    important limitations. First, a message must be specifically addressed to each
    recipient, making public messaging impossible. Second, each recipient requires
    delivery of a separate copy of the message, so sending a message to many recipients
    requires the use of a large number of resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Usenet's Public Distribution Orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid the problems of using email for group messaging, Usenet was designed
    using a rather different communication and message-handling model than email.
    The defining difference between the Usenet communication model and that used for
    email is that Usenet message handling is oriented around the concept of *public
    distribution*, rather than private delivery to an individual user. This affects
    every aspect of how Usenet communication works, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Addressing** Messages are not addressed from a sender to any particular recipient
    or set of recipients, but rather to a *group*, which is identified with a newsgroup
    name.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage** Messages are not stored in individual mailboxes, but rather in
    a central location on a server, where any user of the server can access them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delivery** Messages are not conveyed from the sender''s system to the recipient''s
    system, but rather are spread over the Internet to all connected systems so anyone
    can read them.'
  prefs: []
  type: TYPE_NORMAL
- en: Usenet Communication Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To help illustrate in more detail how Usenet communication works, let''s take
    a look at the steps involved in writing, transmitting, and reading a typical Usenet
    message (also called an *article*—the terms are used interchangeably). Let''s
    suppose the process begins with a user, Ellen, posting a request for help with
    a sick horse to the newsgroup misc.rural. Since she is posting the message, she
    would be known as the message *poster*. Simplified, the steps in the process (illustrated
    in [Figure 85-1](ch85s02.html#usenet_network_news_communication_model_ "Figure 85-1. Usenet
    (network news) communication model This figure illustrates the method by which
    messages are created, propagated, and read using NNTP on modern Usenet; it is
    similar in some respects to the email model diagram (Figure 74-1 in Chapter 74).
    In this example, a message is created by the poster, Ellen, and read by a reader,
    Jane. The process begins with Ellen creating a message in an editor and posting
    it. Her NNTP client sends it to her local NNTP server. It is then propagated from
    that local server to adjacent servers, usually including its upstream server,
    which is used to send the message around the Internet. Other NNTP servers receive
    the message, including the one upstream from Jane''s local server. It passes the
    message to Jane''s local server, and Jane accesses and reads the message using
    an NNTP client. Jane could respond to the message; in which case, the same process
    would repeat, but going in the opposite direction, back to Ellen (and also back
    to thousands of other readers, not shown here).")) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Article Composition** Ellen begins by creating a Usenet article, which is
    structured according to the special message format required by Usenet. This message
    is similar to an email message in that it has a *header* and a *body*. The body
    contains the actual message to be sent, while the header contains header lines
    that describe the message and control how it is delivered. For example, one important
    header line specifies for which newsgroup(s) the article is intended.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Article Posting and Local Storage** After completing her article, Ellen submits
    the article to Usenet, a process called *posting*. A client software program on
    Ellen''s computer transmits Ellen''s message to her local Usenet server. The message
    is stored in an appropriate file storage area on that server. It is now immediately
    available to all other users of that server who decide to read misc.rural.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Article Propagation** At this point, Ellen''s local server is the only one
    that has a copy of her message. The article must be sent to other sites, a process
    called *distribution*, or more commonly, *propagation*. Ellen''s message travels
    from her local Usenet server to other servers to which her server directly connects.
    It then propagates from those servers to others *they* connect to, and so on,
    until all Usenet servers that want it have a copy of the message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Article Access and Retrieval** Since Usenet articles are stored on central
    servers, in order to read them, they must be accessed on the server. This is done
    using a Usenet *newsreader* program. For example, some other reader of misc.rural
    named Jane might access that group and find Ellen''s message. If Jane were able
    to help Ellen, she could reply to Ellen by posting an article of her own. This
    would then propagate back to Ellen''s server, where she could read it and reply.
    All other readers of *misc.rural* could jump into the conversation at any time
    as well, which is what makes Usenet so useful for group communication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Usenet (network news) communication model This figure illustrates the method
    by which messages are created, propagated, and read using NNTP on modern Usenet;
    it is similar in some respects to the email model diagram ( in ). In this example,
    a message is created by the poster, Ellen, and read by a reader, Jane. The process
    begins with Ellen creating a message in an editor and posting it. Her NNTP client
    sends it to her local NNTP server. It is then propagated from that local server
    to adjacent servers, usually including its upstream server, which is used to send
    the message around the Internet. Other NNTP servers receive the message, including
    the one upstream from Jane''s local server. It passes the message to Jane''s local
    server, and Jane accesses and reads the message using an NNTP client. Jane could
    respond to the message; in which case, the same process would repeat, but going
    in the opposite direction, back to Ellen (and also back to thousands of other
    readers, not shown here).](httpatomoreillycomsourcenostarchimages288317.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 85-1. Usenet (network news) communication model This figure illustrates
    the method by which messages are created, propagated, and read using NNTP on modern
    Usenet; it is similar in some respects to the email model diagram ([Figure 74-1](ch74s03.html#email_communication_model_this_diagram_s
    "Figure 74-1. Email communication model This diagram shows the four devices that
    are involved in a typical email communication between two users. Each device consists
    of a number of different elements, which communicate as indicated by the black
    arrows. Note the inherent asymmetry, because the method used to send an email
    from a user is not the same as that used to retrieve it from the server. The large,
    shaded arrows show a typical transaction: the sender composes mail and it goes
    to her local email spool. It is sent to the sender''s local SMTP server using
    SMTP, and then to the recipient''s SMTP server, where it goes into that user''s
    inbox. It is then retrieved, usually using a protocol such as POP or IMAP.") in
    [Chapter 74](ch74.html "Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND
    CONCEPTS")). In this example, a message is created by the poster, Ellen, and read
    by a reader, Jane. The process begins with Ellen creating a message in an editor
    and posting it. Her NNTP client sends it to her local NNTP server. It is then
    propagated from that local server to adjacent servers, usually including its upstream
    server, which is used to send the message around the Internet. Other NNTP servers
    receive the message, including the one upstream from Jane''s local server. It
    passes the message to Jane''s local server, and Jane accesses and reads the message
    using an NNTP client. Jane could respond to the message; in which case, the same
    process would repeat, but going in the opposite direction, back to Ellen (and
    also back to thousands of other readers, not shown here).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Usenet communication consists of four basic steps. A message
    is first composed and then posted to the originator''s local server. The third
    step is propagation, where the message is transmitted from its original server
    to others on the Usenet system. The last step in the process is article retrieval,
    where other members of the newsgroup access and read the article. The Network
    News Transfer Protocol (NNTP) is the technology used for moving Usenet articles
    from one host to the next.'
  prefs: []
  type: TYPE_NORMAL
- en: Message Propagation and Server Organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Propagation is definitely the most complex part of the Usenet communication
    process. In the past, UUCP was used for propagation. Each Usenet server would
    be programmed to regularly dial up another server and give it all new articles
    it had received since the last connection. Articles would *flood* across Usenet
    from one server to another. This was time-consuming and inefficient, and it worked
    only because the volume of articles was relatively small.
  prefs: []
  type: TYPE_NORMAL
- en: As I noted in the previous section, in modern Usenet, NNTP is used for all stages
    of transporting messages between devices. Articles are posted using an NNTP connection
    between a client machine and a local server, which then uses the same protocol
    to propagate the articles to other adjacent NNTP servers. The client newsreader
    software also uses NNTP to retrieve messages from a server.
  prefs: []
  type: TYPE_NORMAL
- en: NNTP servers are usually arranged in a hierarchy of sorts, with the largest
    and fastest servers providing service to smaller servers downstream from them.
    Depending on how the connections are arranged, an NNTP server may establish a
    connection to immediately send a newly posted article to an upstream server for
    distribution to the rest of Usenet, or the server may passively wait for a connection
    from the upstream server to ask if there are any new articles to be sent. With
    the speed of the modern Internet, it typically takes only a few minutes (or seconds)
    for articles to propagate from one server to another, even across continents.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to restrict the propagation of a Usenet message, a technique
    often used for discussions that are of relevance only in certain regions or on
    certain systems. Discussing rural issues such as horses is of general interest,
    and Ellen might find help anywhere around the world, so global propagation of
    her message makes sense. However, if Ellen lived in the Boston area and was interested
    in knowing the location of a good local restaurant, posting a query to *ne.food*
    (New England food discussions) with only local distribution would make more sense.
    There are also companies that use Usenet to provide "in-house" newsgroups that
    are not propagated off the local server at all. However, because so many news
    providers are now national or international, limiting the distribution of messages
    has largely fallen out of practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usenet Addressing: Newsgroups'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key concept in Usenet communication is the *newsgroup*. Newsgroups are the
    addressing mechanism for Usenet, and sending a Usenet article to a newsgroup is
    equivalent to sending email to an email address. Newsgroups are analogous to other
    group communication venues such as mailing lists, chat rooms, Internet Relay Chat
    (IRC) channels, or bulletin board system (BBS) forums (though calling a newsgroup
    a *list*, *room*, *channel*, or *BBS* is likely to elicit a negative reaction
    from Usenet old-timers!).
  prefs: []
  type: TYPE_NORMAL
- en: Like any addressing mechanism, newsgroups must be uniquely identifiable. Each
    newsgroup has a *newsgroup name* that describes the topic of the newsgroup and
    differentiates it from other newsgroups. Since there are many thousands of different
    newsgroups, they are arranged into sets called *hierarchies*. Each hierarchy contains
    a tree structure of related newsgroups.
  prefs: []
  type: TYPE_NORMAL
- en: The Usenet Newsgroup Hierarchies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The total collection of newsgroup hierarchies is in many ways similar to the
    domain name tree structure used in the Domain Name System (DNS). Each Usenet hierarchy
    is like a collection of all the domain names within a DNS top-level domain. Just
    as a domain name like [www.pcguide.com](http://www.pcguide.com/) is formed by
    appending the label of the top-level domain *.com* to the second-level domain
    name *pcguide* and the subdomain *www*, newsgroup names are created in the same
    way. They are created from a top-level newsgroup hierarchy name, to which are
    attached a set of descriptive labels that describes the newsgroup's place in the
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: One difference between DNS and Usenet hierarchies is that while DNS names are
    created from right to left as you go down the tree, Usenet newsgroup names are
    formed in the more natural (for English speakers) left-to-right order. For example,
    one of the main Usenet hierarchies is the *comp* hierarchy, devoted to computer
    topics. Within comp is a subhierarchy on data communications called *dcom*, and
    within that is a group that discusses data cabling. This group is called comp.dcom.cabling.
    Almost all newsgroups are structured in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: The "Big Eight" Newsgroup Hierarchies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem with the decentralized nature of Usenet is ensuring coordination
    in certain areas where we want everyone to be on the same page, and one of these
    is newsgroup naming. If we let just anyone create a newsgroup, we might end up
    with many groups that all discuss the same topic. Imagine that someone had a question
    on data cabling and didn't realize that comp.dcom.cabling existed, so he created
    a new group called comp.datacomm.cabling. The two groups could coexist, but this
    would lead to both confusion and fragmenting of the pool of people interested
    in this topic.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid problems with newsgroup creation, administrators of large Usenet systems
    collaborated on a system for organizing many of the more commonly used Usenet
    groups into eight hierarchies, and devised a specific procedure for creating new
    newsgroups within them. Today, these are called the *Big Eight* Usenet hierarchies,
    which are summarized in [Table 85-1](ch85s02.html#usenet_big_eight_newsgroup_hierarchies
    "Table 85-1. Usenet Big Eight Newsgroup Hierarchies").
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-1. Usenet Big Eight Newsgroup Hierarchies
  prefs: []
  type: TYPE_NORMAL
- en: '| Hierarchy | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| comp.* | Newsgroups discussing computer-related topics, including hardware,
    software, operating systems, and techniques |'
  prefs: []
  type: TYPE_TB
- en: '| humanities.* | Newsgroups discussing the humanities, such as literature and
    art |'
  prefs: []
  type: TYPE_TB
- en: '| misc.* | Newsgroups discussing miscellaneous topics that don''t fit into
    other Big Eight hierarchies |'
  prefs: []
  type: TYPE_TB
- en: '| news.* | Newsgroups discussing Usenet itself and its administration |'
  prefs: []
  type: TYPE_TB
- en: '| rec.* | Newsgroups discussing recreation topics, such as games, sports, and
    activities |'
  prefs: []
  type: TYPE_TB
- en: '| sci.* | Science newsgroups, covering specific areas such as physics and chemistry,
    research topics, and so forth |'
  prefs: []
  type: TYPE_TB
- en: '| soc.* | Society and social discussions, including groups on specific cultures
    |'
  prefs: []
  type: TYPE_TB
- en: '| talk.* | Newsgroups primarily oriented around discussion and debate of current
    events and happenings |'
  prefs: []
  type: TYPE_TB
- en: These eight hierarchies contain many of the most widely used groups on Usenet
    today. For example, professional baseball is discussed in rec.sport.baseball,
    Intel computers in comp.sys.intel, and Middle East politics in talk.politics.mideast.
  prefs: []
  type: TYPE_NORMAL
- en: The Big Eight hierarchies are rather tightly controlled in terms of their structure
    and the newsgroups they contain. The process to create a new Big Eight newsgroup
    is democratic and open. Anyone can propose a new group, and if there is enough
    support, it will be created by the cooperating system administrators who agree
    to follow the Big Eight system. However, this creation process is rather complex
    and time-consuming. Some people find this unacceptable and even object to the
    entire concept of this restricted process. Others consider the system advantageous,
    as it keeps the Big Eight hierarchies relatively orderly by slowing the rate of
    change to existing newsgroups and the number of new groups added.
  prefs: []
  type: TYPE_NORMAL
- en: Alt and Other Newsgroup Hierarchies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those who prefer a more freewheeling environment and do not want to submit
    to the Big Eight procedures, there is an alternative Usenet hierarchy, which begins
    with the hierarchy name *alt*. This hierarchy includes many thousands of groups.
    Some are quite popular, but many are not used at all; this is a side effect of
    the relative ease with which an alt group can be created.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these nine hierarchies, there are dozens of additional, smaller
    hierarchies. Many of these are regional or even company-specific. For example,
    the *ne.* hierarchy contains a set of newsgroups discussing issues of relevance
    to New England; *fr.** covers France, and *de.** pertains to Germany. Microsoft
    has its own set of public newsgroups in the *microsoft.** hierarchy. [Figure 85-2](ch85s02.html#usenet_newsgroup_hierarchies_usenet_news
    "Figure 85-2. Usenet newsgroup hierarchies Usenet newsgroups are arranged into
    tree-like structures called hierarchies. Eight of these are centralized, widely
    used, general-purpose hierarchies, which are today called the Big Eight. The alternate
    (alt) hierarchy is a very loosely structured set of thousands of groups covering
    every topic imaginable. In addition to these, there are many hundreds of regional,
    private, and special-purpose hierarchies.") shows the Big Eight hierarchies and
    some of the other hierarchies that exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Usenet newsgroup hierarchies Usenet newsgroups are arranged into tree-like
    structures called hierarchies. Eight of these are centralized, widely used, general-purpose
    hierarchies, which are today called the Big Eight. The alternate (alt) hierarchy
    is a very loosely structured set of thousands of groups covering every topic imaginable.
    In addition to these, there are many hundreds of regional, private, and special-purpose
    hierarchies.](httpatomoreillycomsourcenostarchimages288319.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 85-2. Usenet newsgroup hierarchies Usenet newsgroups are arranged into
    tree-like structures called hierarchies. Eight of these are centralized, widely
    used, general-purpose hierarchies, which are today called the Big Eight. The alternate
    (alt) hierarchy is a very loosely structured set of thousands of groups covering
    every topic imaginable. In addition to these, there are many hundreds of regional,
    private, and special-purpose hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Usenet messages are not addressed to individual users; rather,
    they are posted to newsgroups. Each newsgroup represents a topic. Those with an
    interest in the subject of a group can read messages in it and reply to them as
    well. Usenet newsgroups are arranged into tree-like hierarchies that are similar
    in structure to DNS domains. Many of the most widely used newsgroups are found
    in a collection of general-interest hierarchies called the Big Eight. An alternate
    (alt) hierarchy offers an alternative to the Big Eight. There are also many regional
    and special-purpose hierarchies.'
  prefs: []
  type: TYPE_NORMAL
- en: Unmoderated and Moderated Newsgroups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most newsgroups are open to all to use and are called *unmoderated* because
    a message sent to them goes directly out to the whole Usenet server internetwork.
    In contrast, a small percentage of newsgroups is *moderated*, which means that
    all messages sent to the group are screened and only the ones that are approved
    by a moderator (or moderator team) are really posted.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of moderated groups is to ensure that discussions in a particular
    group remain on-topic. They are often created to handle topics that are controversial,
    to ensure that debates remain constructive and disruption is avoided. For example,
    rec.guns is moderated to ensure that discussions focus on the use of guns and
    not on endless political arguments related to gun control and the like (which
    has a place, in talk.politics.guns). Moderated groups are also sometimes used
    for specialty groups intended only for announcements, or for groups where the
    content is restricted. For example, rec.food.recipes is moderated so that it contains
    only recipes and recipe requests, which helps people find recipes easily without
    needing to wade through a lot of discussion. Finally, moderated versions of unmoderated
    groups are sometimes created when a few disruptive elements choose to post large
    volumes in the unmoderated groups, making normal discussion difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Posting to Multiple Newsgroups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible for a single article to be posted to multiple newsgroups. This
    process, called *cross-posting*, is used when a message pertains to two topics,
    or to allow a sender to reach a wider audience. For example, if you live in the
    Seattle area and have a problem with your house, you might legitimately cross-post
    to *seattle.general* and *misc.consumers.house*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-posting is more efficient than posting the same message to each group
    independently for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Only one copy of the message will be stored on each Usenet server rather than
    two.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usenet participants who happen to read both groups won't see the message twice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, cross-posting to very large numbers of newsgroups is usually considered
    disruptive and a breach of Usenet etiquette.
  prefs: []
  type: TYPE_NORMAL
- en: Usenet Message Format and Special Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usenet is designed to permit users to exchange information in the form of messages
    that are sent from one computer to another. As is necessary with any message-based
    networking application, all Usenet client software and server software agree to
    use a common *message format*. This ensures that all devices and programs are
    able to interpret all Usenet articles in a consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Usenet was created as an alternative to email, and there are obviously
    differences in how each treats messages, there are also many similarities. Both
    are text-oriented messaging systems with similar needs for communicating content
    and control information. The creators of Usenet realized that there would be many
    advantages to basing the Usenet message format on the one used for email, rather
    than creating a new format from scratch. The email message format was already
    widely used, and adopting it for Usenet would save implementation time and effort.
    It would also enhance compatibility between email and Usenet messages, allowing
    software designed to process or display email to also work with Usenet articles.
    For this reason, the Usenet message format was defined based on the RFC 822 standard
    for email messages (introduced in [Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC
    MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME")).'
  prefs: []
  type: TYPE_NORMAL
- en: RFC 822 messages begin with a set of *headers* that contain control and descriptive
    information about the message, followed by a blank line and then the message *body*,
    which contains the actual content.
  prefs: []
  type: TYPE_NORMAL
- en: One important attribute of the RFC 822 standard is the ability to define custom
    headers that add to the regular set of headers defined in the standard itself.
    Usenet articles require some types of information not needed by email, and these
    can be included in specially defined headers while still adhering to the basic
    RFC 822 format. At the same time, headers specific to email that are not needed
    for Usenet can be omitted. Thus, there is no structural difference at all between
    a Usenet article and an email message. They differ only in the kinds of headers
    they contain and the values for those headers. For example, a Usenet message will
    always contain a header specifying the newsgroup(s) to which the article is being
    posted, but will not carry a "To:" line as an email message would.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Usenet articles use the same RFC 822 message format as email
    messages. The only difference between a Usenet article and an email message is
    in the header types and values used in each.'
  prefs: []
  type: TYPE_NORMAL
- en: Usenet Header Categories and Common Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All Usenet headers are defined according to the standard header format specified
    in RFC 822: <*header name*>: <*header value*>. As with email messages, headers
    may extend onto multiple lines, following the indenting procedure described in
    the RFC 822 standard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current standard for Usenet messages, RFC 1036, describes the header types
    for Usenet messages. The headers are divided into two categories: *mandatory*
    headers (see [Table 85-2](ch85s03.html#usenet_mandatory_headers "Table 85-2. Usenet
    Mandatory Headers")) and *optional* headers (see [Table 85-3](ch85s03.html#usenet_optional_headers
    "Table 85-3. Usenet Optional Headers")). Some are the same as headers of the equivalent
    name used for email, some are similar to email headers but used in a slightly
    different way, and others are unique to Usenet.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-2. Usenet Mandatory Headers
  prefs: []
  type: TYPE_NORMAL
- en: '| Header Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| From: | The email address of the user sending the message, as for email.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Date: | The date and time that the message was originally posted to Usenet.
    This is usually the date/time that the user submitted the article to his or her
    local NNTP server. |'
  prefs: []
  type: TYPE_TB
- en: '| Newsgroups: | Indicates the newsgroup or set of newsgroups to which the message
    is being posted. Multiple newsgroups are specified by separating them with a comma;
    for example: Newsgroups: news.onegroup,rec.secondgroup. |'
  prefs: []
  type: TYPE_TB
- en: '| Subject: | Describes the subject or topic of the message. Note that this
    header is mandatory on Usenet despite being optional for email; it is important
    because it is used by readers to decide what messages to open. |'
  prefs: []
  type: TYPE_TB
- en: '| Message-ID: | Provides a unique code for identifying a message; normally
    generated when a message is sent. The message ID is very important in Usenet,
    arguably more so than in email. The reason is that delivery of email is performed
    based on recipient email addresses, while the propagation of Usenet messages is
    controlled using the message ID header. |'
  prefs: []
  type: TYPE_TB
- en: '| Path: | An informational field that shows the path of servers that a particular
    copy of a message followed to get to the server where it is being read. Each time
    a server forwards a Usenet article, it adds its own name to the list in the Path
    header. The entries are usually separated by exclamation points. For example,
    if a user on Usenet Server A posts a message, and it is transported from Server
    A to Server G, then Server X, then Server F, and finally to Server Q, where a
    second user reads it, the person on Server Q would see something like this in
    the Path header: "Q!F!X!G!A." |'
  prefs: []
  type: TYPE_TB
- en: Table 85-3. Usenet Optional Headers
  prefs: []
  type: TYPE_NORMAL
- en: '| Header Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Reply-To: | It is possible to reply back to a Usenet article author using
    email, which by default, goes to the address in the From: line. If this header
    is present, the address it contains is used instead of the default From: address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sender: | Indicates the email address of the user who is sending the message,
    if different from the message originator. This is functionally the same as the
    Sender: header in email messages, but is used in a slightly different way. Normally,
    when a Usenet message is posted, the sender''s email address is automatically
    filled in to the From: line. If the user manually specifies a different From:
    line, the address from which the message was actually sent is usually included
    in the Sender: line. This is used to track the true originating point of articles.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Followup-To: | A reply to a Usenet message is usually made back to Usenet
    itself and is called a follow-up. By default, a follow-up goes to the newsgroup(s)
    specified in the original message''s Newsgroups: header. However, if the Followup-To:
    header is included, follow-ups to that message go to the newsgroups specified
    in the Followup-To: header instead. This header is sometimes used to route replies
    to a message to a particular group. Note, however, that when a user replies to
    a message, this field controls only what appears in the new message''s Newsgroups:
    line by default. The user can override the Newsgroups: header manually. |'
  prefs: []
  type: TYPE_TB
- en: '| Expires: | All Usenet messages are maintained on each server for only a certain
    period of time, due to storage limitations. The expiration interval for each newsgroup
    is controlled by the administrator of each site. If present, this line requests
    a different expiration for a particular message; it is usually used only for special
    articles. For example, if a weekly announcement is posted every Monday morning,
    each article might be set to expire the following Monday morning, to make sure
    that people see the most current version. |'
  prefs: []
  type: TYPE_TB
- en: '| References: | Lists the message IDs of prior messages in a conversation.
    For example, if someone posts a question to a newsgroup with message ID AA207,
    and a reply to that message is made, the software will automatically insert the
    line "References: AA207" into the reply. This is used by software to group together
    articles into conversations (called *threads*) to make it easier to follow discussions
    on busy newsgroups. |'
  prefs: []
  type: TYPE_TB
- en: '| Control: | Indicates that the article is a control message and specifies
    a control action to be performed, such as creating a new newsgroup. |'
  prefs: []
  type: TYPE_TB
- en: '| Distribution: | By default, most messages are propagated on Usenet worldwide.
    If specified, this line restricts the distribution of a message to a smaller area,
    either geographical or organizational. |'
  prefs: []
  type: TYPE_TB
- en: '| Organization: | Describes the organization to which the article sender belongs.
    Often filled in automatically with the name of the user''s Internet service provider
    (ISP). |'
  prefs: []
  type: TYPE_TB
- en: '| Keywords: | Contains a list of comma-separated keywords that may be of use
    to the readers of the message. Keywords can be useful when searching for messages
    on a particular subject matter. This header is not often used. |'
  prefs: []
  type: TYPE_TB
- en: '| Summary: | A short summary of the message. This is rarely used in practice.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Approved: | Added by the moderator of a moderated newsgroup to tell the Usenet
    software that the message has been approved for posting. |'
  prefs: []
  type: TYPE_TB
- en: '| Lines: | A count of the number of lines in the message. |'
  prefs: []
  type: TYPE_TB
- en: '| Xref: | While Usenet articles are identified by message ID, they are also
    given a number by each Usenet server as they are received. These article numbers,
    which differ from one system to the next, are usually listed in this cross-reference
    header. This information is used when a message is cross-posted to multiple groups.
    In that case, as soon as a user reads the message in one group, it is marked as
    having been read in all the others where it was posted. This way, if the user
    later reads one of those other groups, that user will not see the message again.
    |'
  prefs: []
  type: TYPE_TB
- en: Additional Usenet Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usenet messages may also contain additional headers, just as is the case with
    email messages. Some of these are custom headers included by individual users
    to provide extra information about an article. Others are used in many current
    Usenet articles and have become almost de facto standard headers through common
    use. Many of these custom headers are preceded by *X-*, indicating that they are
    experimental or extra headers.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more frequently encountered additional Usenet headers are shown
    in [Table 85-4](ch85s03.html#common_additional_usenet_headers "Table 85-4. Common
    Additional Usenet Headers").
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-4. Common Additional Usenet Headers
  prefs: []
  type: TYPE_NORMAL
- en: '| Header Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NNTP-Posting-Host: | Specifies the IP address or the DNS domain name of the
    host used to originally post the message. This is usually either the address of
    the client that the author used for posting the message or the sender''s local
    NNTP server. |'
  prefs: []
  type: TYPE_TB
- en: '| User-Agent: (or) X-Newsreader: | The name and version number of the software
    used to post the message. |'
  prefs: []
  type: TYPE_TB
- en: '| X-Trace: | Provides additional information that can be used to trace the
    message. |'
  prefs: []
  type: TYPE_TB
- en: '| X-Complaints-To: | An email address to use to report abusive messages. This
    header is now included automatically by many ISPs. |'
  prefs: []
  type: TYPE_TB
- en: Usenet MIME Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Usenet follows the RFC 822 standard, Multipurpose Internet Mail Extensions
    (MIME) can be used to format Usenet messages. When this is done, you will see
    the usual MIME headers (such as MIME-Version, Content-Type, and so forth) in the
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the use of MIME in Usenet messages is somewhat controversial. Some
    newsreaders are not MIME-compliant and make a mess when trying to display some
    of these messages, and many Usenet veterans object to the use of anything but
    plain text in Usenet messages. Despite this, MIME messages are becoming more common,
    for better or worse.
  prefs: []
  type: TYPE_NORMAL
- en: NNTP Overview and General Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I explained earlier in this chapter, Usenet started out as an informal network
    of UNIX computers using dial-up UUCP connections to transmit messages between
    servers. This arrangement arose out of necessity, and it worked fairly well, though
    it had a number of problems. Once the Internet became widely used in the 1980s,
    it provided the ideal opportunity for a more efficient means of distributing Usenet
    articles. NNTP was developed as a special TCP/IP protocol for sending these messages.
    Now NNTP carries billions of copies of Usenet messages from computer to computer
    every day.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *NNTP is similar to the Simple Mail Transfer Protocol
    (SMTP) in many ways, including its basic operation and command set and reply format.
    You may find the information about NNTP easier to understand if you are familiar
    with SMTP, covered in [Chapter 77](ch77.html "Chapter 77. TCP/IP ELECTRONIC MAIL
    DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)").*'
  prefs: []
  type: TYPE_NORMAL
- en: Usenet began as a *logical* internetwork of cooperating hosts that contacted
    each other directly. In the early Usenet, a user would post a message to her local
    server, where it would stay until that server either contacted or was contacted
    by another server. The message would then be transferred to the new server, where
    it would stay until the second server contacted a third one, and so on. This transport
    mechanism was functional, but seriously flawed in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: Servers were not continually connected to each other; they could communicate
    only by making a telephone call using an analog modem. Thus, messages would often
    sit for hours before they could be propagated. Modems in those days were also
    very slow by today's standards—2400 bits per second or even less—so it took a
    long time to copy a message from one server to another. Worst of all, unless two
    sites were in the same city, these phone calls were long distance, making them
    quite expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Why was this system used despite all of these problems? The answer is simply
    because there was no alternative. In the late 1970s and early 1980s, there was
    no Internet as we know it, and no other physical infrastructure existed to link
    Usenet sites together. It was either use UUCP over telephone lines or nothing.
  prefs: []
  type: TYPE_NORMAL
- en: That all changed as the fledgling ARPAnet grew into the modern Internet. As
    the Internet expanded, more and more sites connected to it, including many sites
    that were participating in Usenet. Once both sites in an exchange were on the
    Internet, it was an easy decision to use the Internet to send Usenet articles,
    rather than relying on slow, expensive phone calls. Over time, more and more Usenet
    sites joined the Internet, and it became clear that just as email had moved from
    UUCP to the TCP/IP Internet, the future of Usenet was on the Internet as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shifting of Usenet from UUCP connections to TCP/IP internetworking meant
    that some rethinking was required as to how Usenet articles were moved from server
    to server. On the Internet, Usenet was just one of many applications, and the
    transfer of messages had to be structured using TCP or the User Datagram Protocol
    (UDP). Thus, like other applications, Usenet required an application-level protocol
    to describe how to carry Usenet traffic over TCP/IP. Just as Usenet had borrowed
    its message format from email''s RFC 822, it made sense to model its message delivery
    protocol on the one used by email: SMTP. The result was the creation of NNTP,
    published as RFC 977 in February 1986.'
  prefs: []
  type: TYPE_NORMAL
- en: The general operation of NNTP is indeed very similar to that of SMTP. NNTP uses
    TCP, with servers listening on well-known TCP port 119 for incoming connections,
    either from client hosts or other NNTP servers. As in SMTP, when two servers communicate
    using NNTP, the one that initiates the connection plays the role of client for
    that exchange.
  prefs: []
  type: TYPE_NORMAL
- en: After a connection is established, communication takes the form of commands
    sent by the client to the server and replies returned from the server to the client
    device. NNTP commands are sent as plain ASCII text, just like those used by SMTP,
    the File Transfer Protocol (FTP), the Hypertext Transfer Protocol (HTTP), and
    other protocols. NNTP responses take the form of three-digit reply codes as well
    as descriptive text, again just like SMTP (which, in turn, borrowed this concept
    from FTP).
  prefs: []
  type: TYPE_NORMAL
- en: NNTP was designed to be a comprehensive vehicle for transporting Usenet messages.
    It is most often considered as a delivery protocol for moving Usenet articles
    from one server to another, but it is also used for connections from client hosts
    to Usenet servers for posting and reading messages. Thus, the NNTP command set
    is quite extensive and includes commands to handle communications between servers
    and between clients and servers. For message propagation, a set of commands allows
    a server to request new articles from another server or to send new articles to
    another server. For message posting and access, commands allow a client to request
    lists of new newsgroups and messages, and to retrieve messages for display to
    a user.
  prefs: []
  type: TYPE_NORMAL
- en: The commands defined in RFC 977 were the only official ones for over a decade.
    However, even as early as the late 1980s, implementers of NNTP server and client
    software were adding new commands and features to make NNTP both more efficient
    and useful to users. These *NNTP extensions* were eventually documented in RFC
    2980, published in 2000\. I describe them in more detail later in this chapter,
    in the "NNTP Commands and Command Extensions" section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Network News Transfer Protocol (NNTP) is the protocol used
    to implement message communication in modern Usenet. It is used for two primary
    purposes: to propagate messages between NNTP servers and to permit NNTP clients
    to post and read articles. It is a stand-alone protocol, but shares many characteristics
    with email''s Simple Mail Transfer Protocol (SMTP).'
  prefs: []
  type: TYPE_NORMAL
- en: 'NNTP is used for all of the transfer steps in the modern Usenet communication
    process. However, NNTP is most often associated with the process of Usenet article
    *propagation*. This is arguably the most important function of NNTP: providing
    an efficient means of moving large volumes of Usenet articles from one server
    to another. It is thus a sensible place to start looking at the protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'NNTP Interserver Communication Process: News Article Propagation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how NNTP propagation works, we must begin with a look at the way
    that the modern Usenet network itself is organized. Usenet sites are now all on
    the Internet, and theoretically, any NNTP server can contact any other to send
    and receive Usenet articles. However, it would be ridiculous to have a new article
    submitted to a particular server need to be sent via separate NNTP connections
    to each and every other NNTP server. For this reason, the Usenet logical network
    continues to be very important, even in the Internet era.
  prefs: []
  type: TYPE_NORMAL
- en: The Usenet Server Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In theory, all that is required of the Usenet structure is that each site be
    connected to at least one other site in some form. The logical network could be
    amorphous and without any formal structure at all, as long as every site could
    form a path through some sequence of intermediate servers to each other one. However,
    the modern Usenet is very large, with thousands of servers and gigabytes of articles
    being posted every day. This calls for a more organized structure for distributing
    news.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the modern Usenet logical network is structured loosely in
    a hierarchy. A few large Internet service providers (ISPs) and big companies with
    high-speed Internet connections and large servers are considered to be at the
    top of the hierarchy, in what is sometimes called the Usenet *backbone*. Smaller
    organizations connect to the servers run by these large organizations; these organizations
    are considered to be *downstream* from the backbone groups. In turn, still smaller
    organizations may connect further downstream from the ones connected to the large
    organizations.
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchical structure means that most Usenet servers maintain a direct
    connection only to their upstream neighbor and to any downstream sites to which
    they provide service. A server is said to receive a *news feed* from its upstream
    connection, since that is the place from which it will receive most of its news
    articles. It then provides a news feed to all the servers downstream from it.
    I illustrated this structure earlier in [Figure 85-1](ch85s02.html#usenet_network_news_communication_model_
    "Figure 85-1. Usenet (network news) communication model This figure illustrates
    the method by which messages are created, propagated, and read using NNTP on modern
    Usenet; it is similar in some respects to the email model diagram (Figure 74-1
    in Chapter 74). In this example, a message is created by the poster, Ellen, and
    read by a reader, Jane. The process begins with Ellen creating a message in an
    editor and posting it. Her NNTP client sends it to her local NNTP server. It is
    then propagated from that local server to adjacent servers, usually including
    its upstream server, which is used to send the message around the Internet. Other
    NNTP servers receive the message, including the one upstream from Jane's local
    server. It passes the message to Jane's local server, and Jane accesses and reads
    the message using an NNTP client. Jane could respond to the message; in which
    case, the same process would repeat, but going in the opposite direction, back
    to Ellen (and also back to thousands of other readers, not shown here).").
  prefs: []
  type: TYPE_NORMAL
- en: As an example, suppose Company A runs a large Usenet server called Largenews
    that is connected to the backbone. Downstream from this server is the NNTP server
    Mediumnews. That server provides service to the server named Smallnews. If a user
    posts an article to Mediumnews, it will be placed on that server immediately.
    That server will send the article downstream, to Smallnews, so that it can be
    read by that server's users. Mediumnews will also, at some point, send the article
    to Largenews. From Largenews, the message will be distributed to other backbone
    sites, which will pass the message down to their own downstream sites. In this
    way, all sites eventually get a copy of the message, even though Mediumnews needs
    to connect directly to only two other servers.
  prefs: []
  type: TYPE_NORMAL
- en: The term used to describe how news is propagated with NNTP is *flooding*. This
    is because of the way that a message begins in one server and floods outward from
    it, eventually reaching the backbone sites, and then going down all the downstream
    "rivers" to reach every site on Usenet.
  prefs: []
  type: TYPE_NORMAL
- en: Even though I described the logical Usenet network as a hierarchy, it is not
    a strict hierarchy. For redundancy, many NNTP servers maintain connections to
    multiple other servers to ensure that news propagates quickly. The transmission
    of articles can be controlled by looking at message IDs to avoid duplication of
    messages that may be received simultaneously by one server from more than one
    neighbor.
  prefs: []
  type: TYPE_NORMAL
- en: Basic NNTP Propagation Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s look at how messages are actually propagated between servers using
    NNTP. There are two techniques by which this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *push model*, as soon as a server receives a new message, it immediately
    tells its upstream and downstream neighbors about the message and asks them if
    they want a copy of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *pull model*, servers do not offer new articles to their neighbors. The
    neighboring servers must ask for a list of new messages if they want to see what
    has arrived since the last connection was established, and then request that the
    new messages be sent to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both techniques have advantages and disadvantages, but pushing is the model
    most commonly used today.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One important role that NNTP plays is its propagation of articles
    between Usenet servers, which is what makes the entire system possible. Two models
    are used for article propagation: the push model, in which a server that receives
    a new message offers it to connected servers immediately, and the pull model,
    where servers that receive new messages hold them until they are requested by
    other servers. The push model is usually preferred since it allows for quicker
    communication of messages around the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Article Propagation Using the Push Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the push model, when the administrators of an NNTP server establish a
    service relationship with an upstream Usenet service provider, they furnish the
    provider with a list of newsgroups that the downstream server wants to carry.
    Whenever a new article arrives at the upstream server within that list of groups,
    it is automatically sent to the downstream site. This saves the downstream server
    from constantly having to ask whether anything has arrived.
  prefs: []
  type: TYPE_NORMAL
- en: In the classic NNTP protocol as defined in RFC 977, the exchange of articles
    is based on the push model and performed using the IHAVE command. Returning to
    the example in the previous section, suppose three new messages arrive at the
    Largenews server. It would establish an NNTP connection to the Mediumnews server
    and use IHAVE to provide the message IDs of each of the three new messages, one
    at a time. (NNTP commands are described later in this chapter.) The Mediumnews
    server would respond to each one, indicating whether or not it already had that
    message. If not, Largenews would send it the message. An example of an article
    transaction using the push model of propagation is illustrated in [Figure 85-3](ch85s05.html#nntp_article_propagation_using_the_push_
    "Figure 85-3. NNTP article propagation using the push model This example shows
    how Usenet articles are moved between servers using the conventional push model
    of propagation. Here, the device acting as an NNTP client (which may, in fact,
    be an NNTP server) has two messages available to offer to the server. It sends
    the IHAVE command specifying the message ID of the first message, but the server
    already has that message, so it sends a 435 (Do Not Send) reply. The client then
    issues an IHAVE with the second message ID. The server wants this one, so it sends
    a 335 reply. The client sends the Usenet message, ending with a single period
    on a line by itself. The server indicates that it received the message, and the
    client, finished with its transactions, quits the session.").
  prefs: []
  type: TYPE_NORMAL
- en: '![NNTP article propagation using the push model This example shows how Usenet
    articles are moved between servers using the conventional push model of propagation.
    Here, the device acting as an NNTP client (which may, in fact, be an NNTP server)
    has two messages available to offer to the server. It sends the IHAVE command
    specifying the message ID of the first message, but the server already has that
    message, so it sends a 435 (Do Not Send) reply. The client then issues an IHAVE
    with the second message ID. The server wants this one, so it sends a 335 reply.
    The client sends the Usenet message, ending with a single period on a line by
    itself. The server indicates that it received the message, and the client, finished
    with its transactions, quits the session.](httpatomoreillycomsourcenostarchimages288321.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 85-3. NNTP article propagation using the push model This example shows
    how Usenet articles are moved between servers using the conventional push model
    of propagation. Here, the device acting as an NNTP client (which may, in fact,
    be an NNTP server) has two messages available to offer to the server. It sends
    the IHAVE command specifying the message ID of the first message, but the server
    already has that message, so it sends a 435 (Do Not Send) reply. The client then
    issues an IHAVE with the second message ID. The server wants this one, so it sends
    a 335 reply. The client sends the Usenet message, ending with a single period
    on a line by itself. The server indicates that it received the message, and the
    client, finished with its transactions, quits the session.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this technique is that it ensures that a server is not
    sent a duplicate copy of a message that it already has. The problem with it in
    modern Usenet is that it is slow, because the server must respond to the IHAVE
    command before the message or the next command can be sent by the client.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Propagation Efficiency with Streaming Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the more important NNTP extensions is *streaming mode*, which changes
    how news pushing is done. (NNTP command extensions are described later in this
    chapter.) When this mode is enabled, the client machine uses the CHECK command
    instead of IHAVE to ask the server if it wants a particular message. The server
    responds to indicate if it wants the message; if it does, the client sends the
    message with the TAKETHIS command.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of CHECK/TAKETHIS is that the client does not need to wait for a
    reply to CHECK before sending the next command. While the client is waiting for
    a reply to the first CHECK command, it can do something else, like sending the
    next CHECK command, allowing commands to be streamed for greater efficiency. So,
    the client could send a CHECK command for the first new message, then a CHECK
    for the second, while waiting for a reply from the server to the first one. Many
    CHECK commands could be sent in a stream, and then TAKETHIS commands sent for
    each reply received to CHECK commands sent earlier indicating that the message
    was wanted by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Article Propagation Using the Pull Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pull model is implemented using the NEWNEWS and ARTICLE commands. The client
    connects to the server and sends the NEWNEWS command with a date specifying the
    date and time that it last checked for new messages. The server responds with
    a set of message IDs for new articles that have arrived since that date. The client
    then requests each new message using the ARTICLE command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the push and pull models can be combined in a single session. A client
    can connect to a server, use NEWNEWS to check for new messages on that server,
    and then IHAVE or CHECK inform the server about new messages the client wants
    to send. In practice, it is more common for only one or the other of the models
    to be used between a pair of servers for any given exchange.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to propagating new messages, NNTP is also used to allow servers
    to communicate information about new newsgroups that have been created. This is
    done using the NEWGROUPS command, which is specified with a date and time like
    NEWNEWS. In response, the server sends to the client a list of new newsgroups
    that have been created since the specified date and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'NNTP Client-Server Communication Process: News Posting and Access'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One critical area where NNTP differs from its progenitor, SMTP, is that NNTP
    is not just used for interserver communication. It is also used for the initial
    posting of Usenet messages, as well as reading the messages. In fact, the majority
    of NNTP commands deals with the interaction between user client machines and NNTP
    servers, not communication between servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'An NNTP client is any software program that knows the NNTP protocol and is
    designed to provide user access to Usenet. NNTP clients are usually called *newsreaders*,
    and they provide two main capabilities to a user: *posting* and *reading* Usenet
    messages. Usenet newsreaders exist for virtually all hardware and software platforms,
    and they range greatly in terms of capabilities, user interface, and other characteristics.
    Most people today use a Usenet newsreader on a client computer that must make
    NNTP connections to a separate NNTP server to read and post news. These programs
    are analogous to email clients, and, in fact, many email clients also function
    as NNTP clients.'
  prefs: []
  type: TYPE_NORMAL
- en: News Posting, Access, and Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Posting a Usenet message is the first step in the overall Usenet communication
    process (although many Usenet articles are actually replies to other articles,
    so it's a bit of a chicken-and-egg situation). Article posting is quite straightforward
    with NNTP. The client establishes a connection to the server and issues the POST
    command. If the server is willing to accept new articles, it replies with a prompt
    for the client to send it the article. The article is then transmitted by the
    client to the server. Some newsreaders may batch new articles, so they can be
    sent in a single NNTP session, rather than submitting them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Newsreaders also establish an NNTP connection to a server to read Usenet articles.
    NNTP provides a large number of commands to support a variety of different article
    access and retrieval actions that may be taken by a user. The first step in reading
    is sometimes to examine the list of available newsgroups. Using the LIST command,
    the client requests from the server a list of the newsgroups available for reading
    and posting. RFC 977 defines the basic LIST command, which returns a list of all
    groups to the client. RFC 2980 defines numerous extensions to the command to allow
    a client to retrieve only certain types of information about groups on the server.
    Since the number of Usenet newsgroups is so large today, this listing of newsgroups
    is usually skipped unless the user specifically requests it.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in Usenet message access is typically to select a newsgroup to
    read from the list of groups available. Again, since there are so many groups
    today, most newsreaders allow a user to search for a group name using a pattern
    or partial name string. The GROUP command is then sent to the server with the
    name of the selected group. The server returns the first and last current article
    numbers for the group to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages are identified in two ways: one absolute and the other site-specific.
    The article''s message ID is a fixed identifier that can be used to uniquely represent
    it across Usenet; this is what is used in interserver communication to determine
    whether each site has a copy of a given message. In contrast, *article numbers*
    are server-specific; they represent the numbers assigned to those articles as
    they arrived at that server and are used as a shorthand to more easily refer to
    articles in a newsgroup. Thus, the same message will have a different article
    number on each NNTP server. Article numbers are used for convenience, since they
    are much shorter than message IDs. During a session, the NNTP server also maintains
    a current article pointer, which can be used for stepping sequentially through
    a newsgroup.'
  prefs: []
  type: TYPE_NORMAL
- en: News Access Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several different ways that the newsreader can access messages in
    a group, depending on how it is programmed and what the user of the software wants.
    The news access methods include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full Newsgroup Retrieval** The brute-force technique is for the client to
    simply request that the server send it all the messages in the group. The client
    issues the ARTICLE command to select the first current message in the group, using
    the first article number returned by the GROUP command. This sets the server''s
    internal pointer for the session to point to the first article, so it can be retrieved.
    The NEXT command is then used to advance the pointer to the next message, and
    the ARTICLE command is used to retrieve it. This continues until the entire group
    has been read. [Figure 85-4](ch85s06.html#nntp_full_newsgroup_retrieval_process_th
    "Figure 85-4. NNTP full newsgroup retrieval process There are many ways that an
    NNTP client can access and read Usenet messages on a server. One common method
    is to retrieve the entire contents of a newsgroup. In this example, the client
    uses the GROUP command to select the newsgroup comp.protocols.tcp-ip for reading;
    the server responds with a 211 (Group Selected) reply, which includes important
    statistics about the group. The client uses the ARTICLE command with the number
    of the first article in the group, 177, to read it from the server. The server
    then sends the message line by line, ending it with a single period on a line.
    The client uses the NEXT command to tell the server to advance its internal article
    pointer to the next message, which often will not be the next consecutive number
    after the one just read; here it is 179\. The client can then read that message
    by sending the ARTICLE command by itself. Since no parameters are given, the server
    returns the current message (179).") illustrates the process. The retrieved messages
    are stored by the newsreader and available for instant access by the user. This
    method is most suitable for relatively small newsgroups and/or users with fast
    Internet connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newsgroup Header Retrieval** Since downloading an entire newsgroup is time-consuming,
    many newsreaders compromise by downloading the headers of all messages instead
    of the full message. The process is the same as for full newsgroup retrieval,
    but the HEAD command is used to retrieve just an article''s headers. This takes
    less time than retrieving each message in its entirety using the ARTICLE command.
    The XHDR command extension can also be used, if the server supports it, to more
    efficiently retrieve only a subset of the headers for the messages, such as the
    subject line and author.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Individual Article Retrieval** It is also possible to retrieve a single message
    from a group, using the ARTICLE command and specifying the article''s message
    identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** While NNTP is best known for its role in interserver propagation,
    it is also used by Usenet clients to write and read articles. Different commands
    provide flexibility in how articles can be read by a client device. A client can
    retrieve an entire newsgroup, only a set of newsgroup headers, or individual articles.
    Other commands also support various administrative functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Client/Server Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to reading and posting, NNTP includes commands to support other
    miscellaneous tasks that a Usenet user may wish to perform. The client can ask
    the server for help information by using the HELP command or get a list of new
    newsgroups by using the NEWGROUPS command.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern newsreaders include capabilities that go far beyond the basic posting
    and reading functions previously described. Most maintain their own sets of configuration
    files that allow a user to maintain a set of favorite subscribed newsgroups, rather
    than needing to choose a group to read from the master list each time Usenet is
    accessed. Newsreaders also keep track of which articles have been read by a user
    in each subscribed newsgroup, so users do not need to wade through a whole newsgroup
    to see new messages that have been posted.
  prefs: []
  type: TYPE_NORMAL
- en: '![NNTP full newsgroup retrieval process There are many ways that an NNTP client
    can access and read Usenet messages on a server. One common method is to retrieve
    the entire contents of a newsgroup. In this example, the client uses the GROUP
    command to select the newsgroup comp.protocols.tcp-ip for reading; the server
    responds with a 211 (Group Selected) reply, which includes important statistics
    about the group. The client uses the ARTICLE command with the number of the first
    article in the group, 177, to read it from the server. The server then sends the
    message line by line, ending it with a single period on a line. The client uses
    the NEXT command to tell the server to advance its internal article pointer to
    the next message, which often will not be the next consecutive number after the
    one just read; here it is 179\. The client can then read that message by sending
    the ARTICLE command by itself. Since no parameters are given, the server returns
    the current message (179).](httpatomoreillycomsourcenostarchimages288323.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 85-4. NNTP full newsgroup retrieval process There are many ways that
    an NNTP client can access and read Usenet messages on a server. One common method
    is to retrieve the entire contents of a newsgroup. In this example, the client
    uses the GROUP command to select the newsgroup comp.protocols.tcp-ip for reading;
    the server responds with a 211 (Group Selected) reply, which includes important
    statistics about the group. The client uses the ARTICLE command with the number
    of the first article in the group, 177, to read it from the server. The server
    then sends the message line by line, ending it with a single period on a line.
    The client uses the NEXT command to tell the server to advance its internal article
    pointer to the next message, which often will not be the next consecutive number
    after the one just read; here it is 179\. The client can then read that message
    by sending the ARTICLE command by itself. Since no parameters are given, the server
    returns the current message (179).
  prefs: []
  type: TYPE_NORMAL
- en: Article Threading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One particularly useful enhancement to basic Usenet article reading is *threading*.
    This feature allows a newsreader to display articles not strictly in either alphabetical
    or chronological order, but rather grouped into conversations using the information
    in the articles' References headers. Threading is especially useful in busy newsgroups,
    as it allows users to see all the articles in a particular discussion at once,
    rather than trying to juggle messages from many conversations simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: A problem with threading is that it takes a long time for a newsreader to sift
    through all those References lines and construct the article threads. To speed
    up this process, many servers now cache extra threading or overview information
    for newsgroups, which can be retrieved by the client to save time when a newsgroup
    is opened. This is done using the XTHREAD or XOVER NNTP command extensions.
  prefs: []
  type: TYPE_NORMAL
- en: NNTP Commands and Command Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great strengths of the open, cooperative process used to develop
    Internet standards is that new protocols are usually designed by building on older
    ones. This saves development time and effort, and promotes compatibility between
    technologies. As I explained earlier in the chapter, NNTP was based in many ways
    on principles from SMTP; SMTP, in turn, borrowed ideas from earlier protocols:
    Telnet and FTP. This legacy can be seen in the similarities between NNTP commands
    and those of these earlier protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Command Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in SMTP, all NNTP commands are ASCII text that are sent over the NNTP TCP
    connection to an NNTP server, from the device acting as the client (which may
    be a newsreader client or an NNTP server itself). These are standard text strings
    adhering to the Telnet Network Virtual Terminal (NVT) format, terminated by the
    two-character carriage return/line feed (CRLF) sequence. As is the case with SMTP
    and FTP, you can conduct an interactive session with an NNTP server by using Telnet
    to connect to it on port 119.
  prefs: []
  type: TYPE_NORMAL
- en: The basic syntax of an NNTP command is <*command-code*> <*parameters*>. Unlike
    SMTP, NNTP commands are not restricted to a length of four characters. The parameters
    that follow the command are separated by one or more space characters, and are
    used to provide necessary information to allow the server to execute the command.
    NNTP commands are not case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Base Command Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main NNTP specification, RFC 977, describes the base set of commands supported
    by NNTP clients and servers. They are not broken into categories, but rather listed
    alphabetically, as I have done in [Table 85-5](ch85s07.html#nntp_base_commands
    "Table 85-5. NNTP Base Commands"). (The details on how many of these commands
    are used for news article propagation and news posting/access were provided earlier
    in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-5. NNTP Base Commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Code | Command | Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ARTICLE | Retrieve Article | Message ID or server article number | Tells
    the server to send the client a particular Usenet article. The article to be retrieved
    may be specified using either its absolute, universal message ID or its locally
    assigned article number. When the command is issued with an article number, this
    causes the server''s internal message pointer to be set to the specified article.
    If the message pointer is already set to a particular article, the ARTICLE command
    can be issued without an article number, and the current message will be retrieved.
    |'
  prefs: []
  type: TYPE_TB
- en: '| HEAD | Retrieve Article Headers | Message ID or server article number | Same
    as the ARTICLE command, but retrieves only the article''s headers. |'
  prefs: []
  type: TYPE_TB
- en: '| BODY | Retrieve Article Body | Message ID or server article number | Same
    as the ARTICLE command, but returns only the body of the article. |'
  prefs: []
  type: TYPE_TB
- en: '| STAT | Retrieve Article Statistics | Server article number | Conceptually
    the same as the ARTICLE command, but does not return any message text, only the
    message ID of the article. This command is usually used for setting the server''s
    internal message pointer, so STAT is normally invoked only with an article number
    (and not a message ID). |'
  prefs: []
  type: TYPE_TB
- en: '| GROUP | Select Newsgroup | Newsgroup name | Tells the server the name of
    the newsgroup that the client wants to access. Assuming the group specified exists,
    the server returns to the client the numbers of the first and last articles currently
    in the group, along with an estimate of the number of messages in the group. The
    server''s internal article pointer is also set to the first message in the group.
    |'
  prefs: []
  type: TYPE_TB
- en: '| HELP | Get Help Information | None | Prompts the server to send the client
    help information, which usually takes the form of a list of valid commands that
    the server supports. |'
  prefs: []
  type: TYPE_TB
- en: '| IHAVE | Offer Article to Server | Message ID | Used by the client in an NNTP
    session to tell the server that it has a new article that the server may want.
    The server will check the message ID provided and respond to the client, indicating
    whether or not it wants the client to send the article. |'
  prefs: []
  type: TYPE_TB
- en: '| LAST | Go to Last Message | None | Tells the server to set its current article
    pointer to the last message in the newsgroup. |'
  prefs: []
  type: TYPE_TB
- en: '| LIST | List Newsgroups | None | Asks the server to send a list of the newsgroups
    that it supports, along with the first and last article number in each group.
    The command as described in RFC 977 is simple, supporting no parameters and causing
    the full list of newsgroups to be sent to the client. NNTP command extensions
    significantly expand the syntax of this command, as described in the following
    section of this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| NEWGROUPS | List New Newsgroups | Date and time, and optional distribution
    specification | Prompts the server to send a list of new newsgroups created since
    the date and time specified. The client may also restrict the command to return
    only new newsgroups within a particular regional distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| NEWNEWS | List New News Articles | Date and time, and optional distribution
    specification | Requests a list from the server of all new articles that have
    arrived since a particular date and time. Like the NEWGROUPS command, this may
    be restricted in distribution. The server responds with a list of message IDs
    of new articles. |'
  prefs: []
  type: TYPE_TB
- en: '| NEXT | Go to Next Message | None | Advances the server''s current article
    pointer to the next message in the newsgroup. |'
  prefs: []
  type: TYPE_TB
- en: '| POST | Post Article | None | Tells the server that the client would like
    to post a new article. The server responds with either a positive or negative
    acknowledgment. Assuming that posting is allowed, the client then sends the full
    text of the message to the server, which stores it and begins the process of propagating
    it to other servers. |'
  prefs: []
  type: TYPE_TB
- en: '| QUIT | End Session | None | Terminates the NNTP session. To be "polite,"
    the client should issue this command prior to closing the TCP connection. |'
  prefs: []
  type: TYPE_TB
- en: '| SLAVE | Set Slave Status | None | Intended for use in special configurations
    where one NNTP server acts as a subsidiary to others. It is not often used in
    practice. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The main NNTP standard defines a number of base NNTP commands
    that are used by the device initiating an NNTP connection to accomplish article
    propagation, posting, and reading functions. NNTP commands consist of a command
    code and, optionally, parameters that specify how the command is to be carried
    out.'
  prefs: []
  type: TYPE_NORMAL
- en: NNTP Command Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The base command set described in RFC 977 was sufficient to enable client-server
    and interserver functionality, but in many ways, it was quite basic and limited
    in efficiency and usefulness. As Usenet grew larger and more popular in the late
    1980s, NNTP needed changes to improve its usability. In 1991, work began on a
    formal revision to the NNTP standard, but was never completed. Despite this, many
    of the concepts from that effort were adopted informally in NNTP implementations
    in subsequent years. In addition, some Usenet software authors created their own
    nonstandard features to improve the protocol, and some of these features also
    became de facto standards through widespread adoption.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, by the late 1990s, most Usenet software actually implemented variations
    of NNTP with capabilities far exceeding what was documented in the standard. Naturally,
    not all NNTP software supported the same extra features, leading to potential
    compatibility difficulties between servers and clients. RFC 2980, "Common NNTP
    Extensions," was published in October 2000 to formalize many of these extensions
    to the base NNTP standard as defined in RFC 977.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NNTP extensions primarily consist of new NNTP commands that are added to
    the basic NNTP command set, as well as some minor changes to how other commands
    and functions of NNTP work. The extensions generally fall into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Extensions that improve the efficiency of NNTP message transport between servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions that make NNTP more effective for client message access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous extensions, which don't fall into either of the preceding groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NNTP Transport Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first group is called the NNTP *transport extensions* and consists of a
    small group of related commands that are designed to improve interserver message
    propagation. Most of these implement NNTP's *stream mode*, which provides a more
    effective way of moving large numbers of articles from one server to another,
    as described in the discussion of interserver communication earlier in this chapter.
    [Table 85-6](ch85s07.html#nntp_transport_extensions-id001 "Table 85-6. NNTP Transport
    Extensions") describes the new transport commands.
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-6. NNTP Transport Extensions
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Code | Command | Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MODE STREAM | Set Stream Mode | None | Used to tell the server that the client
    wants to operate in stream mode, using the CHECK and TAKETHIS commands. |'
  prefs: []
  type: TYPE_TB
- en: '| CHECK | Check If Article Exists | Message ID | Used in stream mode by a server
    acting as a client to ask another server if it has a copy of a particular article.
    The server responds back indicating whether or not it wishes to be sent a copy
    of the article. This command is similar to IHAVE, except that the client does
    not need to wait for a reply before sending the next command. |'
  prefs: []
  type: TYPE_TB
- en: '| TAKETHIS | Send Article to Server | Message ID | When a server responds to
    a CHECK command indicating that it wants a copy of a particular message, the client
    sends it using this command. |'
  prefs: []
  type: TYPE_TB
- en: '| XREPLIC | Replicate Articles | List of newsgroups and article numbers | Created
    for the special purpose of copying large numbers of articles from one server to
    another. It is not widely used. |'
  prefs: []
  type: TYPE_TB
- en: NNTP Newsreader Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second group of extensions defined by RFC 2980 consists of *newsreader
    extensions*, which focus primarily on commands used by newsreader clients in interactions
    with NNTP servers. These extensions consist of several new commands, as well as
    significant enhancements to one important command that was very limited in its
    functionality in RFC 977: LIST.'
  prefs: []
  type: TYPE_NORMAL
- en: The original LIST command has no parameters and only allows a client to retrieve
    the entire list of newsgroups a server carries. This may have been sufficient
    when there were only a few hundred Usenet newsgroups, but there are now tens of
    thousands. RFC 2980 defines a number of new variations of the LIST command to
    allow the client much more flexibility in the types of information the server
    returns. [Table 85-7](ch85s07.html#nntp_list_command_extensions "Table 85-7. NNTP
    LIST Command Extensions") shows the new LIST command variations.
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-7. NNTP LIST Command Extensions
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Code | Command | Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LIST ACTIVE | List Active Newsgroups | Newsgroup name or pattern | Provides
    a list of active newsgroups on the server. This is semantically the same as the
    original LIST command, but the client may provide a newsgroup name or a pattern
    to restrict the number of newsgroups returned. For example, the client can ask
    for a list of only the newsgroups that contain "football" in them. |'
  prefs: []
  type: TYPE_TB
- en: '| LIST ACTIVE.TIMES | List Active Newsgroup Creation Times | None | Prompts
    the server to send the client its *active.times* file, which contains information
    about when the newsgroups carried by the server were created. |'
  prefs: []
  type: TYPE_TB
- en: '| LIST DISTRIBUTIONS | List Distributions | None | Causes the server to sent
    the client the contents of the *distributions* file, which shows what regional
    distribution strings the server recognizes (for use in the Distribution header
    of a message). |'
  prefs: []
  type: TYPE_TB
- en: '| LIST DISTRIB.PATS | List Distribution Patterns | None | Asks the server for
    its *distribution.pats* file, which is like the distributions file but uses patterns
    to summarize distribution information for different newsgroups. |'
  prefs: []
  type: TYPE_TB
- en: '| LIST NEWSGROUPS | List Newsgroups | Newsgroup name or pattern | Provides
    a list of newsgroup names and descriptions. This differs from LIST ACTIVE in that
    only the newsgroup name and description are returned, not the article numbers
    for each newsgroup. It is functionally the same as XGTITLE (see [Table 85-8](ch85s07.html#nntp_newsreader_extensions-id001
    "Table 85-8. NNTP Newsreader Extensions")) and is usually employed by a user to
    locate a newsgroup to be added to his or her subscribed list. |'
  prefs: []
  type: TYPE_TB
- en: '| LIST OVERVIEW.FMT | Display Overview Format | None | Prompts the server to
    display information about the format of its *overview* file. See the XOVER command
    description in [Table 85-8](ch85s07.html#nntp_newsreader_extensions-id001 "Table 85-8. NNTP
    Newsreader Extensions") for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| LIST SUBSCRIPTIONS | Retrieve Default Subscription List | None | Asks the
    server to send the client a default list of subscribed newsgroups. This is used
    to set up a new user with a suggested list of newsgroups. For example, if an organization
    has an internal support newsgroup, it could put this group on the default subscription
    list so all new users learn about it immediately when they first start up their
    newsreader. |'
  prefs: []
  type: TYPE_TB
- en: In addition to these changes to the LIST command, many new newsreader-related
    command extensions are defined, which are described in [Table 85-8](ch85s07.html#nntp_newsreader_extensions-id001
    "Table 85-8. NNTP Newsreader Extensions").
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-8. NNTP Newsreader Extensions
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Code | Command | Parameters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LISTGROUP | List Article Numbers In Newsgroup | Newsgroup name | Causes the
    server to return a list of local article numbers for the current messages in the
    newsgroup. The server''s current article pointer is also set to the first message
    in the group. |'
  prefs: []
  type: TYPE_TB
- en: '| MODE READER | Set Newsreader Mode | None | Tells the server that the device
    acting as a client is a client newsreader and not another NNTP server. While technically
    not required—all commands can be sent by any device acting as client—some servers
    may be optimized to respond to newsreader-oriented commands if given this command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| XGTITLE | Retrieve Newsgroup Descriptions | Newsgroup name or pattern | Used
    to list the descriptions for a newsgroup or a set of newsgroups matching a particular
    text pattern. This command is functionally the same as the LIST NEWSGROUP command
    extension (see [Table 85-7](ch85s07.html#nntp_list_command_extensions "Table 85-7. NNTP
    LIST Command Extensions")). It is therefore recommended that XGTITLE no longer
    be used. |'
  prefs: []
  type: TYPE_TB
- en: '| XHDR | Retrieve Article Headers | Header name and optionally, either a message
    ID or a range of article numbers | Allows a client to ask for only a particular
    header from a set of messages. If only the header name is provided, the header
    is returned for all messages in the current group. Otherwise, the header is provided
    for the selected messages. This extension provides a newsreader client with a
    more efficient way of retrieving and displaying important headers in a newsgroup
    to a user. |'
  prefs: []
  type: TYPE_TB
- en: '| XINDEX | Retrieve Index Information | Newsgroup name | Retrieves an *index*
    file, used by the newsreader called *TIN* to improve the efficiency of newsgroup
    perusal. TIN now supports the more common overview format, so the XOVER command
    is preferred to this one. |'
  prefs: []
  type: TYPE_TB
- en: '| XOVER | Retrieve Overview Information | Article number or range of article
    numbers in a newsgroup | Retrieves the *overview* for an article or set of articles.
    Servers supporting this feature maintain a special database for their newsgroups
    that contains information about current articles in a format that can be used
    by a variety of newsreaders. Retrieving the overview information allows features
    like message threading to be performed more quickly than if the client had to
    retrieve the headers of each message and analyze them manually. |'
  prefs: []
  type: TYPE_TB
- en: '| XPAT | Retrieve Article Headers Matching a Pattern | Header name, pattern,
    and either a message ID or a range of article numbers | Similar to XHDR in that
    it allows a particular header to be retrieved for a set of messages. The difference
    is that the client can specify a pattern that must be matched for the header to
    be retrieved. This allows the client to have the server search for and return
    certain messages, such as those with a subject line indicating a particular type
    of discussion, rather than requiring the client to download all the headers and
    search through them. |'
  prefs: []
  type: TYPE_TB
- en: '| XPATH | Retrieve File Name Information | Message ID | Allows a client to
    ask for the name of the actual file in which a particular message is stored on
    the server. |'
  prefs: []
  type: TYPE_TB
- en: '| XROVER | Retrieve Overview Reference Information | Article number or range
    of article numbers in a newsgroup | Like the XOVER command, but specifically retrieves
    information in the References header for the indicated articles. This is the header
    containing the data needed to create threaded conversations. |'
  prefs: []
  type: TYPE_TB
- en: '| XTHREAD | Retrieve Threading Information | Optional DBINIT parameter | Similar
    to XINDEX, but retrieves a special threading information file in the format used
    by the newsreader named *TRN*. Like TIN, TRN now supports the common overview
    format, so XOVER is preferred to this command. The DBINIT parameter can be used
    to check for the existence of a thread database. |'
  prefs: []
  type: TYPE_TB
- en: Other NNTP Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last extension group contains the miscellaneous extensions not strictly
    related to either interserver or client-server NNTP interaction. There are two
    commands in this group: AUTHINFO and DATE. The latter is a simple command that
    causes the server to tell the client its current date and time. AUTHINFO is more
    interesting. It is used by a client to provide authentication data to a server.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that there are no commands related to security described
    in the RFC 977 protocol. That's because the original NNTP had no security features
    whatsoever. Like many protocols written before the modern Internet era, security
    was not considered a big issue back in the early 1980s. Most news servers were
    used only by people within the organization owning the server, and simple security
    measures were used, such as restricting access to servers by IP address or through
    the use of access lists.
  prefs: []
  type: TYPE_NORMAL
- en: One of the more important changes made by many NNTP software implementations
    as soon as Usenet grew in size was to require authentication. Modern clients will
    usually issue AUTHINFO as one of their first commands on establishing a connection
    to a server, because the server will refuse to accept most other commands before
    this is done. A special reply code is also added to NNTP for a server to use if
    it rejects a command due to improper authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The AUTHINFO command can be invoked in several different ways. The original
    version of the command required the client to issue an AUTHINFO USER command with
    a user name, followed by AUTHINFO PASS with a password. This is simple user/password
    login authentication. A variation of this is the AUTHINFO SIMPLE command, where
    the client needs to send just a password.
  prefs: []
  type: TYPE_NORMAL
- en: A client and server can also agree to use more sophisticated authentication
    methods by employing the AUTHINFO GENERIC command. The client provides to the
    server the name of the authentication method it wants to use, along with any arguments
    required for authentication. The client and server then exchange messages and
    authentication information as required by the particular authenticator they are
    using.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A number of limitations in its base command set led to a proliferation
    of nonstandard enhancements to NNTP during the 1980s and 1990s. These were eventually
    documented in a set of NNTP command extensions that formally supplement the original
    RFC 977 commands. The extensions are conceptually divided into three groups: transport
    extensions that refine how NNTP propagates messages, newsreader extensions that
    improve client article access, and miscellaneous extensions. The most important
    miscellaneous extension is AUTHINFO, which adds security to NNTP.'
  prefs: []
  type: TYPE_NORMAL
- en: NNTP Status Responses and Response Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time the device acting as a client in an NNTP connection sends a command,
    the server sends back a *response*. The response serves to acknowledge receipt
    of the command, to inform the client of the results of processing the command,
    and possibly to prompt for additional information. Since NNTP commands are structured
    and formatted in a way very similar to that of SMTP commands, I''m sure it will
    come as no great surprise that NNTP responses are very similar to those of SMTP
    (described in [Chapter 77](ch77.html "Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY
    PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)")). In turn, SMTP responses
    are based on the system designed for replies in FTP.'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of an NNTP response consists of a three-digit numerical *response
    code*, as well as a line of descriptive text that summarizes the response. These
    response codes are structured so that each digit has a particular significance,
    which allows the client to quickly determine the status of the command to which
    the reply was sent. After the initial response line, depending on the reply, a
    number of additional response lines may follow. For example, a successful LIST
    command results in a 215 response code, followed by a list of newsgroups.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *The discussion of FTP reply codes in [Chapter 72](ch72.html
    "Chapter 72. FILE TRANSFER PROTOCOL (FTP)") explains the reasons why numeric reply
    codes are used in addition to descriptive text*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with SMTP and FTP, NNTP reply codes can be considered to be of the form
    *xyz*, where *x* is the first digit, *y* the second, and *z* the third. The first
    reply code digit (*x*) indicates the success, failure, or progress of the command
    in general terms; whether a successful command is complete or incomplete; and
    the general reason why an unsuccessful command did not work. The values of this
    digit are defined slightly differently than they are in SMTP and FTP. In some
    cases, the terminology is just simplified; for example, the second category is
    Command OK, instead of the more cryptic Positive Completion Reply. [Table 85-9](ch85s08.html#nntp_reply_code_format_first_digit_inter
    "Table 85-9. NNTP Reply Code Format: First Digit Interpretation") shows the specific
    meaning of the possible values of this digit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 85-9. NNTP Reply Code Format: First Digit Interpretation'
  prefs: []
  type: TYPE_NORMAL
- en: '| Reply Code Format | Meaning | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1yz | Informative Message | General information; used for help information
    and debugging. |'
  prefs: []
  type: TYPE_TB
- en: '| 2yz | Command OK | The command was completed successfully. |'
  prefs: []
  type: TYPE_TB
- en: '| 3yz | Command OK So Far; Send the Rest | An intermediate reply, sent to prompt
    the client to send more information. Typically used for replies to commands such
    as IHAVE or POST, where the server acknowledges the command, and then requests
    that an article be transmitted by the client. |'
  prefs: []
  type: TYPE_TB
- en: '| 4yz | Command Was Correct, but Couldn''t Be Performed | The command was valid
    but could not be performed. This type of error usually occurs due to bad parameters,
    a transient problem with the server, a bad command sequence, or similar situations.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5yz | Command Unimplemented or Incorrect, or Serious Program Error | The
    command was invalid or a significant program error prevented it from being performed.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The second reply code digit (*y*) is used to categorize messages into functional
    groups. This digit is used in the same general way as in SMTP and FTP, but the
    functional groups are different, as described in [Table 85-10](ch85s08.html#nntp_reply_code_format_second_digit_inte
    "Table 85-10. NNTP Reply Code Format: Second Digit Interpretation").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 85-10. NNTP Reply Code Format: Second Digit Interpretation'
  prefs: []
  type: TYPE_NORMAL
- en: '| Reply Code Format | Meaning | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x0z | Connection, Setup, and Miscellaneous | Generic and miscellaneous replies.
    |'
  prefs: []
  type: TYPE_TB
- en: '| x1z | Newsgroup Selection | Messages related to commands used to select a
    newsgroup. |'
  prefs: []
  type: TYPE_TB
- en: '| x2z | Article Selection | Messages related to commands used to select an
    article. |'
  prefs: []
  type: TYPE_TB
- en: '| x3z | Distribution Functions | Messages related to the transfer of messages.
    |'
  prefs: []
  type: TYPE_TB
- en: '| x4z | Posting | Messages related to posting messages. |'
  prefs: []
  type: TYPE_TB
- en: '| x5z | Authentication | Messages related to authentication and the AUTHINFO
    command extension. (This category is not officially listed in the standard, but
    these responses have a middle digit of 5.) |'
  prefs: []
  type: TYPE_TB
- en: '| x8z | Nonstandard Extensions | Reserved for private, nonstandard implementation
    use. |'
  prefs: []
  type: TYPE_TB
- en: '| x9z | Debugging | Debugging output messages. |'
  prefs: []
  type: TYPE_TB
- en: The third reply code digit (*z*) indicates a specific type of message within
    each of the functional groups described by the second digit. The third digit allows
    each functional group to have ten different reply codes for each reply type given
    by the first code digit.
  prefs: []
  type: TYPE_NORMAL
- en: As in FTP and SMTP, these *x*, *y*, and *z* digit meanings are combined to make
    specific reply codes. For example, the reply code 435 is sent by the server if
    a client issues the IHAVE command but the server doesn't want the article being
    offered. The command was correct but the reply is negative, thus it starts with
    4, and the message is related to message distribution, so the middle digit is
    3.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 85-11](ch85s08.html#nntp_reply_codes "Table 85-11. NNTP Reply Codes")
    contains a list of some of the more common NNTP reply codes in numerical order,
    along with typical reply text from the standard and additional descriptive information.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 85-11. NNTP Reply Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Reply Code | Reply Text | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | help text follows | Precedes response to HELP command. |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | (date and time) | Response to DATE command extension. |'
  prefs: []
  type: TYPE_TB
- en: '| 199 | (debugging output) | Debugging information. |'
  prefs: []
  type: TYPE_TB
- en: '| 200 | server ready - posting allowed | Sent by the server on initiation of
    the session, if the client is allowed to post messages. |'
  prefs: []
  type: TYPE_TB
- en: '| 201 | server ready - no posting allowed | Sent by the server on initiation
    of the session, if the client is not allowed to post messages. |'
  prefs: []
  type: TYPE_TB
- en: '| 202 | slave status noted | Response to the SLAVE command. |'
  prefs: []
  type: TYPE_TB
- en: '| 203 | streaming is ok | Successful response to MODE STREAM command. |'
  prefs: []
  type: TYPE_TB
- en: '| 205 | closing connection - goodbye! | Goodbye message sent in response to
    a QUIT message. |'
  prefs: []
  type: TYPE_TB
- en: '| 211 | n f l s group selected | Successful response to the GROUP command,
    indicating the estimated number of messages in the group (*n*), first and last
    article numbers (*f* and *l*) and group name (*s*). |'
  prefs: []
  type: TYPE_TB
- en: '| 215 | list of newsgroups follows (OR) information follows | Successful response
    to LIST command. The second form is for variations of LIST defined as NNTP command
    extensions. |'
  prefs: []
  type: TYPE_TB
- en: '| 218 | tin-style index follows | Successful response to XINDEX command extension.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 220 | n <a> article retrieved - head and body follow | Successful response
    to the ARTICLE command, indicating the article number and message ID of the article.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 221 | n <a> article retrieved - head follows | Successful response to the
    HEAD command, indicating the article number and message ID of the article. |'
  prefs: []
  type: TYPE_TB
- en: '| 222 | n <a> article retrieved - body follows | Successful response to the
    BODY command, indicating the article number and message ID of the article. |'
  prefs: []
  type: TYPE_TB
- en: '| 223 | n <a> article retrieved - request text separately | Successful response
    to the STAT command, indicating the article number and message ID of the article.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 224 | overview information follows | Successful response to the XOVER command
    extension. |'
  prefs: []
  type: TYPE_TB
- en: '| 230 | list of new articles by message-id follows | Successful response to
    the NEWNEWS command. |'
  prefs: []
  type: TYPE_TB
- en: '| 235 | article transferred ok | Successful response to the IHAVE command,
    after the article has been sent. |'
  prefs: []
  type: TYPE_TB
- en: '| 239 | article transferred ok | Successful response to the TAKETHIS command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 240 | article posted ok | Successful response to the POST command, after
    the article has been posted. |'
  prefs: []
  type: TYPE_TB
- en: '| 250 or 281 | authentication accepted | Successful authentication using the
    AUTHINFO command extension. |'
  prefs: []
  type: TYPE_TB
- en: '| 282 | list of groups and descriptions follows | Positive response to the
    XGTITLE command extension. |'
  prefs: []
  type: TYPE_TB
- en: '| 288 | binary data to follow | Successful response to the XTHREAD command
    extension. |'
  prefs: []
  type: TYPE_TB
- en: '| 335 | send article to be transferred | Preliminary response to the IHAVE
    command. |'
  prefs: []
  type: TYPE_TB
- en: '| 340 | send article to be posted | Preliminary response to the POST command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 381 | more authentication information required | Preliminary response to
    the AUTHINFO command extension. |'
  prefs: []
  type: TYPE_TB
- en: '| 400 | service discontinued | Session is being terminated, perhaps due to
    user request. |'
  prefs: []
  type: TYPE_TB
- en: '| 411 | no such newsgroup | Invalid newsgroup name specified. |'
  prefs: []
  type: TYPE_TB
- en: '| 412 | no newsgroup has been selected | Attempt to issue a command that refers
    to the current newsgroup before one has been selected using GROUP. |'
  prefs: []
  type: TYPE_TB
- en: '| 420 | no current article has been selected | Attempt to issue a command that
    refers to the current article using the server''s current article pointer, before
    the pointer has been set through article selection. |'
  prefs: []
  type: TYPE_TB
- en: '| 421 | no next article in this group | Response to NEXT command when at the
    last article of a newsgroup. |'
  prefs: []
  type: TYPE_TB
- en: '| 422 | no previous article in this group | Possible response to LAST (I have
    no idea why the word "previous" is in there). |'
  prefs: []
  type: TYPE_TB
- en: '| 423 | no such article number in this group | Command with invalid article
    number. |'
  prefs: []
  type: TYPE_TB
- en: '| 430 | no such article found | Article not found; it may have been deleted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 435 | article not wanted - do not send it | Negative response to IHAVE if
    server doesn''t need the article. |'
  prefs: []
  type: TYPE_TB
- en: '| 436 | transfer failed - try again later | Temporary failure of article transfer;
    retry. |'
  prefs: []
  type: TYPE_TB
- en: '| 437 | article rejected - do not try again | Article refused for whatever
    reason. |'
  prefs: []
  type: TYPE_TB
- en: '| 438 | already have it, please don''t send it to me | Same as reply code 435,
    but for the CHECK command extension. |'
  prefs: []
  type: TYPE_TB
- en: '| 440 | posting not allowed | POST command issued when posting is not allowed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 441 | posting failed | POST command failed. |'
  prefs: []
  type: TYPE_TB
- en: '| 450 | authorization required for this command | Response sent when server
    requires authentication but client has not yet authenticated. |'
  prefs: []
  type: TYPE_TB
- en: '| 452 | authorization rejected | Failed authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| 480 | transfer permission denied | Response to CHECK if transfer is not allowed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 500 | command not recognized | Bad command. |'
  prefs: []
  type: TYPE_TB
- en: '| 501 | command syntax error | Bad syntax in command. |'
  prefs: []
  type: TYPE_TB
- en: '| 502 | access restriction or permission denied | Permission denied; sent if
    the client has not properly authentication but the server requires it. |'
  prefs: []
  type: TYPE_TB
- en: '| 503 | program fault - command not performed | General fatal error message.
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each command sent by the device acting as the client in an
    NNTP connection results in the server returning a reply. NNTP replies consist
    of a three-digit reply code and a string of descriptive text. These codes are
    modeled after those of SMTP, and in turn, FTP.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 86. GOPHER PROTOCOL (GOPHER)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s suppose that I told you I was going to describe a TCP/IP application
    layer protocol designed for the specific purpose of distributed document search
    and retrieval. This protocol uses a client/server model of operation, where servers
    provide links to related resources such as files or programs that users access
    with client software that displays options for the user to select. You might think
    that I was talking about the World Wide Web, and for good reason. However, in
    this case, I am actually talking about one of the Web''s predecessors: the *Gopher
    Protocol*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I briefly describe Gopher's history, operation, differences
    from the World Wide Web, and role in the modern Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Gopher Overview and General Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good place to start our discussion of this protocol is with its name, which
    is well chosen for a number of reasons. The Gopher Protocol was developed at the
    University of Minnesota, whose sports teams are called the Golden Gophers (Minnesota
    is known as the Gopher State). This is the direct origin of the name, but it is
    also appropriate because the rodent that shares it is known for burrowing, just
    as the protocol is designed to "burrow" through the Internet. And of course, the
    term *gopher* also applies to a person who performs errands, such as retrieving
    documents (they "go fer" this and "go fer" that).
  prefs: []
  type: TYPE_NORMAL
- en: The Gopher Protocol was developed in the late 1980s to provide a mechanism for
    organizing documents for easy access by students and faculty at the university.
    The core principle that guided the development of the system was *simplicity*.
    Gopher is designed on the basis of a small number of core principles, and it uses
    a very straightforward mechanism for passing information between client and server
    devices. It is described in RFC 1436, published in March 1993.
  prefs: []
  type: TYPE_NORMAL
- en: Information Storage on Gopher Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Information accessible by Gopher is stored as files on *Gopher servers*. It
    is organized in a hierarchical manner similar to the file system tree of a computer
    such as a Windows PC or UNIX workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Just as a file system consists of a top-level directory (or folder) that contains
    files and subdirectories (subfolders), Gopher servers present information as a
    top-level directory that contains resources such as files, and/or subdirectories
    containing additional resources. Resources on different servers can be linked
    together by having them mentioned in each others' resource hierarchies. It is
    also possible for virtual resources to be created that act as if they were files,
    such as programs that allow Gopher servers to be searched.
  prefs: []
  type: TYPE_NORMAL
- en: Gopher Client/Server Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typical use of Gopher begins with a user on a client machine creating a TCP
    connection to a Gopher server using well-known TCP port number 70\. After the
    connection is established, the server waits for the client to request a particular
    resource by sending the server a piece of text called a *selector string*. Often,
    when a user first accesses a server, he does not know what resource to request,
    so a null (empty) selector string is sent. This causes the server to send back
    to the client a list of the resources available at the top (root) directory of
    the server's file system tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'A directory list sent by the server consists of a set of lines, each of which
    describes one available resource in that directory. Each line contains the following
    elements, each separated by a tab character:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Character and Resource Name** The first character of the line tells
    the client software what sort of resource the line represents. The most common
    type characters are 0 (zero) for a file, 1 for a subdirectory, and 7 for a search
    service. The rest of the characters up to the first tab character contain the
    name of the resource to be presented to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selector String** The string of text to be sent to the server to retrieve
    this resource.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Name** The name of the server where the resource is located.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Port Number** The port number to be used for accessing this resource''s
    server; normally 70.'
  prefs: []
  type: TYPE_NORMAL
- en: Each line ends with a carriage return/line feed (CRLF) character sequence consistent
    with the Telnet Network Virtual Terminal (NVT) specification. Upon sending the
    directory listing (or any other response) the connection between the client and
    server is closed.
  prefs: []
  type: TYPE_NORMAL
- en: After receiving this sort of directory list, the Gopher client software will
    display a menu to the user containing all the resource names the server provided.
    The user then selects his desired item from the menu, and the client retrieves
    it by making a connection to the appropriate server and port number, and sending
    the selector string of that resource. If this itself represents a subdirectory,
    the server will send a new directory listing for that subdirectory; if it represents
    some other type of resource, it will be accessed according to the requirements
    of the resource type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose this line were sent from the server to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This would be presented to the user as the file called Gopher Introduction in
    a menu containing other options. If the user chose it, the client would initiate
    a connection to the Gopher server gopher.someserver.org at port 70, and then send
    the selector string intro to that server to retrieve the document.
  prefs: []
  type: TYPE_NORMAL
- en: Important Differences Between Gopher and the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I hinted at the start of this discussion, both Gopher and the Web are intended
    for the same basic purpose: providing access to repositories of information, with
    links between related documents and resources. However, they take a very different
    approach to how that information is accessed, especially in two key areas: user
    interface and resource linking.'
  prefs: []
  type: TYPE_NORMAL
- en: Gopher's presentation to the user is entirely oriented around its hierarchical
    file system. As a result, Gopher is inherently menu-based, and the user interface
    is usually based on a simple text presentation of those menus. In contrast, information
    on web servers can be organized in any manner and presented to the user in whatever
    form or fashion the owner of the server desires. The Web is much more free-form,
    and there is no need to use a directory structure unless that is advantageous
    in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Linking in the Web is done directly between documents, most often using Hypertext
    Markup Language (HTML) tags. When someone writing Document A mentions something
    relevant to Document B, she puts a link to Document B directly in Document A.
    Gopher, on the other hand, is not designed to use links in this way. Instead,
    linking is intended to be done using the directory tree I described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Gopher's Role in the Modern Internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some people who believe that Gopher is technically superior to the
    Web in a number of respects. They consider it cleaner to have servers do the linking,
    rather than having links embedded in documents. An argument can also be made that
    the text orientation of Gopher is efficient, better able to ensure compatibility
    between platforms, and also more suited to special needs situations such as low-bandwidth
    links and access by those with visual impairments. Some Gopher enthusiasts thus
    consider it to be a purer hypertext system than the Web.
  prefs: []
  type: TYPE_NORMAL
- en: However, history shows us that despite Gopher predating the Web, the Web overtook
    it in popularity in only a few short years. Today, the Web is the 900-pound gorilla
    of the Internet, while most people have never even heard of Gopher. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: I believe the main reason why Gopher lost out to the Web is that the Web is
    far more flexible. Gopher's use of text hyperlinks and server directory structures
    may be efficient, but it is limiting. In contrast, the Web allows information
    to be presented in a wide variety of ways. The open, unstructured nature of the
    Web makes it an ideal vehicle for the creativity of information providers and
    application developers. In the mid-1990s, the Web was also perfectly poised to
    support the transition of computing from text to graphics, and Gopher was not.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, you can do more with the Web than you can with Gopher, and most
    people care more about functionality and breadth of options than straight efficiency.
    Once the Web started to gain momentum, it very quickly snowballed. It took only
    a couple of years before Web use was well entrenched, and Gopher was unable to
    compete.
  prefs: []
  type: TYPE_NORMAL
- en: For its part, the University of Minnesota likely hastened Gopher's demise with
    its controversial decision to charge licensing fees to companies that wanted to
    use Gopher for commercial purposes. I do not believe there was anything nefarious
    about this. The university was on a limited budget and wanted companies that could
    afford it to pay a small fee to support development of Gopher software. However,
    computing history has shown time and time again that there is no faster way to
    kill a protocol or standard than to try to charge licensing or royalty fees for
    it, no matter what the reason.
  prefs: []
  type: TYPE_NORMAL
- en: By the late 1990s, Gopher was well on its way to obsolescence. As use of the
    protocol dwindled, many organizations could no longer justify the cost of continuing
    to run Gopher servers. Even the University of Minnesota itself eventually shut
    down its own Gopher servers due to low utilization. The final nail in the coffin
    for Gopher occurred in 2002, when a security vulnerability related to Gopher was
    discovered in Internet Explorer, and Microsoft chose to simply remove Gopher support
    from the product rather than fix the problem. Today, Gopher is still around, but
    it is a niche protocol used only by a relatively small group of enthusiasts and
    a handful of organizations that have a past history of using it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The Gopher Protocol is a distributed document search and retrieval
    protocol that was developed at the University of Minnesota in the late 1980s.
    Resources are stored on Gopher servers, which organize information using a hierarchical
    directory structure. Gopher clients access servers to retrieve directory listings
    of available resources, which are presented to the user as a menu from which an
    item may be selected for retrieval. Gopher''s chief advantage is simplicity and
    ease of use, but it lacks flexibility in presentation and the ability to effectively
    present graphics and multimedia. For this reason, despite Gopher predating the
    World Wide Web, the Web has almost entirely replaced it, and Gopher is now a niche
    protocol.'
  prefs: []
  type: TYPE_NORMAL
