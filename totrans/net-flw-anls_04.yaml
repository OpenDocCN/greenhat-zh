- en: Chapter 4. FILTERING FLOWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 流量过滤
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages651574.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages651574.png.jpg)'
- en: The good news is, you now have actual data about your network. The bad news
    is, you have far too much data about your network. An Internet T1 might generate
    millions of flow records in a single day, while a busy Ethernet core might generate
    billions or more. How can you possibly manage or evaluate that heap of data? You
    must filter your data to display only interesting flows. The `flow-nfilter` program
    lets you include or exclude flows as needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，您现在有了关于您网络的实际数据。坏消息是，您有关于您网络的大量数据。一个互联网T1可能在一天内生成数百万个流量记录，而一个繁忙的以太网核心可能生成数十亿或更多。您如何管理或评估这些数据？您必须过滤数据以仅显示有趣的流量。`flow-nfilter`程序允许您根据需要包含或排除流量。
- en: You can filter traffic in almost any way you can imagine. For example, if a
    particular server is behaving oddly, you can filter on its IP address. If you're
    interested in HTTP traffic, you can filter on TCP port 80\. You can reduce your
    data to include only interesting traffic, which will help you evaluate and diagnose
    issues. For example, if you have a large internal corporate network, you might
    want to view only the traffic exchanged with a particular branch office, filtering
    on all of its network addresses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以几乎任何您能想象的方式过滤流量。例如，如果某个服务器表现异常，您可以基于其IP地址进行过滤。如果您对HTTP流量感兴趣，可以基于TCP端口80进行过滤。您可以将数据减少到只包含有趣的流量，这将有助于您评估和诊断问题。例如，如果您有一个大型内部企业网络，您可能只想查看与特定分支机构交换的流量，基于其所有网络地址进行过滤。
- en: 'In [Chapter 3](ch03.html "Chapter 3. VIEWING FLOWS"), you viewed flow information
    by running `flow-cat` and feeding the resulting data stream to `flow-print`. Filtering
    takes place between these two processes: `flow-nfilter` accepts the data stream
    from `flow-cat` and examines each flow. Flows that match the filter pass on to
    `flow-print` (or other flow-processing programs); flows that do not match the
    filter drop from the data stream.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 观察流量")中，您通过运行`flow-cat`并将结果数据流传递给`flow-print`来查看流量信息。过滤发生在这两个过程之间：`flow-nfilter`接受来自`flow-cat`的数据流并检查每个流量。匹配过滤器的流量将传递到`flow-print`（或其他流量处理程序）；不匹配过滤器的流量将从数据流中掉落。
- en: Filter Fundamentals
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤基础
- en: In this chapter, you'll start by building a few simple filters. Once you understand
    the basics of filter construction, you'll examine the various filter types and
    functions in depth.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将首先构建几个简单的过滤器。一旦您了解了过滤器构建的基本知识，您将深入探讨各种过滤器类型和功能。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Define your filters in the file *filter.cfg*, which is probably in */usr/local/flow-tools/etc/cfg/filter.cfg*
    or */usr/local/etc/flow-tools/filter.cfg*, depending on your operating system
    and how you installed flow-tools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件*filter.cfg*中定义您的过滤器，该文件可能位于*/usr/local/flow-tools/etc/cfg/filter.cfg*或*/usr/local/etc/flow-tools/filter.cfg*，具体取决于您的操作系统和您安装flow-tools的方式。
- en: Common Primitives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见原始
- en: You'll build your filters out of *primitives*. A primitive is a simple traffic
    characteristic, such as "port 80," "TCP," or "IP address 192.0.2.1." For example,
    those three primitives could be combined to create one filter that passes all
    TCP traffic to the host 192.0.2.1 on port 80.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用*原始*构建您的过滤器。原始是一个简单的流量特征，例如“端口80”、“TCP”或“IP地址192.0.2.1”。例如，这三个原始可以组合成一个过滤器，该过滤器将所有TCP流量传递到端口80上的主机192.0.2.1。
- en: '`flow-nfilter` supports more than a dozen different primitives and can compare
    them with flows in more than two dozen different ways. A primitive looks much
    like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow-nfilter`支持十多种不同的原始，并且可以以二十多种不同的方式将它们与流量进行比较。原始看起来大致如下：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line defines a filtering primitive and assigns the primitive a name.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个过滤原始并将其分配给一个名称。
- en: The type at ❶ defines the characteristic you want to match on, such as an IP
    address, a port, or a time. (I'll cover the most commonly useful filter types.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ❶处的类型定义了您想要匹配的特征，例如IP地址、端口或时间。（我将介绍最常用的过滤器类型。）
- en: The permit statement at ❷ defines the values you're looking for. By default,
    a primitive denies everything, so you must explicitly state what your filter permits.
    Alternatively, you could use a `deny` statement to create a primitive that matches
    everything except what you're looking for and explicitly put a `default permit`
    statement at the end.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❷处的许可语句定义了您要查找的值。默认情况下，原始拒绝一切，因此您必须明确声明您的过滤器允许的内容。或者，您可以使用`deny`语句创建一个匹配除您要查找之外所有内容的原始，并在末尾明确放置一个`default
    permit`语句。
- en: 'For example, a complete primitive that matches the IP address 192.168.1.1 looks
    like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个匹配IP地址192.168.1.1的完整原语看起来像这样：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At ❶ I've named my primitive after the address it matches. You can use any one-word
    name that makes sense to you, such as "mailserver" or "firewall," if you prefer.
    The `ip-address` primitive at ❷ matches network addresses. Finally, at ❸ this
    primitive matches any IP address equal to 192.0.2.1\. If you include this primitive
    in a filter, it will pass traffic to or from this IP address only.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我根据它匹配的地址命名了我的原语。如果你愿意，可以使用任何有意义的单字名称，例如“mailserver”或“firewall”。❷处的`ip-address`原语匹配网络地址。最后，在❸处，这个原语匹配任何等于192.0.2.1的IP地址。如果你将这个原语包含在过滤器中，它只会将流量传递到或从这个IP地址。
- en: 'Similarly, the following primitive defines port 25:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下原语定义了端口25：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although I could have called this primitive `25`, at ❶ I used the name `port25`
    to make it absolutely clear that this primitive matches a port because the number
    25 by itself could be a number of seconds, a count of octets or packets per second,
    an autonomous system, a floor number, and so on. (An IP address is unmistakable,
    so using the address as a name probably won't confuse you.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我可以将这个原语命名为`25`，但在❶处我使用了名称`port25`，以使其绝对清楚这个原语匹配一个端口，因为数字25本身可能是一段时间、每秒的字节或数据包计数、自治系统、楼层号等等。（IP地址是独一无二的，所以使用地址作为名称可能不会让你混淆。）
- en: The `ip-port` primitive at ❷ is another commonly used filter component. Including
    this primitive in a filter means that the filter will pass traffic only on port
    25.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❷处的`ip-port`原语是另一个常用的过滤器组件。将此原语包含在过滤器中意味着该过滤器只会通过端口25的流量。
- en: 'The default *filter.cfg* includes a primitive for TCP traffic, as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`*filter.cfg*`包括一个用于TCP流量的原语，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You're unlikely to mistake the name TCP at ❶ for anything other than the protocol,
    but the `ip-protocol` primitive at ❷ lets you create a primitive for any TCP/IP
    protocol. Of course, if you have obscure network protocols, you'll probably need
    to create additional protocol primitives, and your permit statements at ❸ can
    use either the protocol number or the protocol name from */etc/protocols*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你不太可能将❶处的名称TCP误认为是除了协议以外的任何东西，但❷处的`ip-protocol`原语允许你为任何TCP/IP协议创建一个原语。当然，如果你有晦涩的网络协议，你可能需要创建额外的协议原语，并且你的许可语句❸可以使用来自`/etc/protocols`的协议号或协议名称。
- en: 'Each primitive can include only one type of match. For example, the following
    is invalid:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个原语只能包含一种匹配类型。例如，以下是不合法的：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This primitive tries to match on both a port number (❶) and an IP address (❷).
    A primitive cannot do this. To filter out connections to the IP address 192.0.2.1
    on port 25, you must assemble a filter from multiple primitives.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此原语尝试在端口号（❶）和IP地址（❷）上进行匹配。原语不能这样做。要过滤掉端口25上连接到IP地址192.0.2.1的连接，你必须从多个原语中组装一个过滤器。
- en: Now that you have a few primitives, you can create your first filter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一些原语了，你可以创建你的第一个过滤器。
- en: Creating a Simple Filter with Conditions and Primitives
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用条件和原语创建简单过滤器
- en: 'Combine primitives into filters with the `filter-definition` keyword, like
    so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter-definition`关键字将原语组合成过滤器，如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Every filter begins with `filter-definition` (❶) and a name. Filters can share
    a name with a primitive but not with other filter definitions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过滤器都以`filter-definition`（❶）和一个名称开始。过滤器可以与原语共享名称，但不能与其他过滤器定义共享名称。
- en: The filter contains a series of `match` keywords (❷), followed by conditions
    and primitives. The `match` keyword specifies the part of the flow this entry
    checks and the primitive to compare it to.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器包含一系列`match`关键字（❷），后面跟着条件和原语。`match`关键字指定了该条目检查的流量部分以及与之比较的原语。
- en: 'Conditions include things such as IP addresses, ports, protocols, types of
    service, and so on. All of the conditions listed must match for the filter to
    match a flow. For example, the following filter combines the `TCP` primitive and
    the `port25` primitive:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 条件包括诸如IP地址、端口、协议、服务类型等内容。所有列出的条件都必须匹配，才能使过滤器匹配一个流量。例如，以下过滤器结合了`TCP`原语和`port25`原语：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This filter passes all flows coming from TCP port 25\. Any flow that does not
    come from TCP port 25 will not pass through the filter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器允许所有来自TCP端口25的流量通过。任何不是来自TCP端口25的流量都不会通过过滤器。
- en: Although primitives and conditions look similar, their names can differ. For
    example, both filter conditions and filter primitives use the `ip-protocol` keyword
    (❶). When matching ports, however, primitives use the `ip-port` keyword (❷), but
    filter definitions use the `ip-source-port` and `ip-destination-port` keywords
    instead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本元素和条件看起来很相似，但它们的名称可能不同。例如，过滤条件和使用`ip-protocol`关键词（❶）的过滤基本元素都使用。然而，在匹配端口时，基本元素使用`ip-port`关键词（❷），但过滤定义使用`ip-source-port`和`ip-destination-port`关键词。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The most common cause of filtering errors is using incorrect keywords. Use filter
    keywords only in filters, and use primitive keywords only in primitives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤错误最常见的原因是使用不正确的关键词。仅在过滤器中使用过滤关键词，仅在基本元素中使用基本关键词。
- en: NAMING CONVENTIONS FOR FILTERS AND PRIMITIVES
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器和基本元素的命名约定
- en: Assign names to your filters and primitives carefully. If you initially choose
    ambiguous or confusing names, you'll trip over them when you have dozens or hundreds
    of filters! Make your names easy to recognize and unmistakable in purpose.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细为您的过滤器和基本元素命名。如果您最初选择了模糊或令人困惑的名称，当您有数十个或数百个过滤器时，您可能会遇到麻烦！使您的名称易于识别，并且目的明确无误。
- en: Primitives can share a name with a filter. For example, you can name a primitive
    TCP and a filter TCP, but you cannot name two primitives TCP or two filters UDP.
    Also, filter and primitive names are case insensitive. You cannot name one primitive
    `tcp` and another primitive TCP.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基本元素可以与过滤器共享名称。例如，你可以将一个基本元素命名为TCP和一个过滤器命名为TCP，但你不能将两个基本元素都命名为TCP或两个过滤器都命名为UDP。此外，过滤器和基本元素的名称不区分大小写。你不能将一个基本元素命名为`tcp`而另一个基本元素命名为TCP。
- en: Using Your Filter
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用您的过滤器
- en: 'Use `flow-nfilter`''s `-F` option and the filter name to pass only the traffic
    that matches your filters. For example, here I''m printing only the flows that
    match the `TCPport25` report:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flow-nfilter`的`-F`选项和过滤器名称来仅传递匹配您过滤器的流量。例如，在这里我正在打印仅匹配`TCPport25`报告的流量：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, you can see only the flows where the protocol is 6 (TCP) and
    the source port is 25\. This filter would be useful if you were investigating
    mail issues, for example. The filter shows that the mail server sent traffic from
    port 25, and hence the network level of the mail system is functioning.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您只能看到协议为6（TCP）且源端口为25的流量。如果您正在调查邮件问题，这个过滤器将非常有用。过滤器显示邮件服务器从端口25发送了流量，因此邮件系统的网络层正在运行。
- en: Useful Primitives
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的基本元素
- en: Now that you understand how primitives and filters work together, I'll discuss
    primitives in depth. `flow-nfilter` supports many different primitives, but I'll
    cover only the most commonly useful ones here. The `flow-nfilter` man page includes
    the complete primitive list, but this book contains every one that I have used
    during several years of flow analysis.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了基本元素和过滤器是如何一起工作的，我将深入讨论基本元素。`flow-nfilter`支持许多不同的基本元素，但在这里我将只介绍最常用的几个。`flow-nfilter`的手册页包括完整的元素列表，但本书包含了我在多年的流量分析中使用过的每一个。
- en: Protocol, Port, and Control Bit Primitives
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议、端口和控制位基本元素
- en: Filtering on network protocol and port information is one of the most common
    ways to strip a list of flow records down to only interesting traffic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络协议和端口信息上过滤是减少流量记录列表到仅包含有趣流量的一种最常见方式。
- en: IP Protocol Primitives
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP协议基本元素
- en: You saw a basic IP protocol primitive earlier, but you can check for protocols
    other than TCP. For example, if you use IPSec, OSPF, or other network protocols
    that run over IP but that are not over TCP or UDP, you'll eventually need to view
    them separately. Filtering by protocol is the only way to differentiate between
    network applications that share port numbers, such as syslog (UDP/514) and rsh
    (TCP/514).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前看到了一个基本的IP协议基本元素，但您可以检查除TCP之外的其他协议。例如，如果您使用IPSec、OSPF或其他在IP上运行但不在TCP或UDP上运行的网络协议，您最终需要单独查看它们。通过协议过滤是区分共享端口号的网络应用程序（如syslog（UDP/514）和rsh（TCP/514））的唯一方法。
- en: 'When defining a protocol filter, you can use either the protocol number or
    name from */etc/protocols*. I prefer to use the number so that */etc/protocols*
    changes won''t interfere with traffic analysis. For example, OSPF runs over protocol
    89, so here''s a filter to match it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义协议过滤器时，你可以使用来自*/etc/protocols*的协议号或名称。我更喜欢使用数字，这样*/etc/protocols*的变化就不会干扰流量分析。例如，OSPF在协议89上运行，所以这里有一个匹配它的过滤器：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, IPSec uses two different protocols: ESP (protocol 50) and AH (protocol
    51). The following primitive matches all IPSec traffic. (Separate multiple entries
    with commas.)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，IPSec 使用两种不同的协议：ESP（协议 50）和 AH（协议 51）。以下原语匹配所有 IPSec 流量。（用逗号分隔多个条目。）
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although the IPSec protocols don't have port numbers, `flow-nfilter` can show
    you how much bandwidth an IPSec VPN between any two points uses and where your
    VPN clients connect from.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IPSec协议没有端口号，但 `flow-nfilter` 可以显示任意两点之间的IPSec VPN使用的带宽以及VPN客户端的连接位置。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default *filter.cfg* includes primitives for TCP, UDP, and ICMP.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 *filter.cfg* 包含了 TCP、UDP 和 ICMP 的原语。
- en: Port Number Primitives
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口号原语
- en: Most network applications run on one or more ports. By filtering your output
    to include the port only for the network service you're interested in, you ease
    troubleshooting. To do so, use the `ip-port` primitive you saw earlier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序运行在一个或多个端口上。通过过滤你的输出，只包括你感兴趣的网络的端口，你可以简化故障排除。为此，使用你之前看到的 `ip-port`
    原语。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A single primitive can include multiple ports, separated with commas like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个原语可以包括多个端口，用逗号分隔，如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you have a long list of ports, you can give each its own line and add comments.
    This example includes services that run over TCP (telnet and POP3) as well as
    UDP (SMB).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一长串的端口列表，你可以为每个端口单独一行，并添加注释。此示例包括通过 TCP（telnet 和 POP3）以及 UDP（SMB）运行的服务。
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can also create primitives for ranges of ports.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为端口范围创建原语。
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: IP port primitives can use names from */etc/services*, but I recommend using
    numbers to insulate you from changes or errors in that file. `flow-print` and
    `flow-report` can perform number-to-name translations if necessary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: IP 端口号原语可以使用来自 */etc/services* 的名称，但我建议使用数字来保护你免受该文件中更改或错误的干扰。`flow-print` 和
    `flow-report` 在必要时可以执行数字到名称的转换。
- en: TCP Control Bit Primitives
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 控制位原语
- en: Filtering by TCP control bits identifies abnormal network flows. Use the `ip-tcp-flags`
    primitive to filter by control bits. (See [TCP Control Bits and Flow Records](ch03s03.html
    "TCP Control Bits and Flow Records") in [TCP Control Bits and Flow Records](ch03s03.html
    "TCP Control Bits and Flow Records").)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 TCP 控制位进行过滤可以识别异常网络流量。使用 `ip-tcp-flags` 原语通过控制位进行过滤。（参见 [TCP 控制位和流量记录](ch03s03.html
    "TCP 控制位和流量记录")。）
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This primitive matches flows with only a SYN control bit, also known as a *SYN-only
    flow*. Either the server never responded to the request, a firewall blocked the
    connection request, or no server exists at the destination address.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此原语匹配只包含 SYN 控制位的流，也称为 *只包含 SYN 的流*。服务器可能从未响应请求，防火墙阻止了连接请求，或者目标地址不存在服务器。
- en: These flows are fairly common on the naked Internet, where viruses and automated
    port scanners constantly probe every Internet address, but they should be comparatively
    uncommon on your internal network. Numerous SYN-only flows on an internal network
    usually indicate misconfigured software, a virus infection, or actual intruder
    probes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流量在裸露的互联网上相当常见，病毒和自动端口扫描器不断探测每个互联网地址，但在你的内部网络上应该相对不常见。内部网络上的大量只包含 SYN 的流通常表明软件配置错误、病毒感染或实际入侵者的探测。
- en: Similarly, you can filter on flows that contain only an RST. An RST-only flow
    indicates that a connection request was received and immediately rejected, generally
    because a host is requesting service on a TCP port that isn't open. For example,
    if you ask a host for a web page when that host doesn't run a web server, you'll
    probably get a TCP RST.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以过滤只包含 RST 的流。只包含 RST 的流表示收到了连接请求并被立即拒绝，通常是因为主机请求在未打开的 TCP 端口上提供服务。例如，如果你在主机不运行
    Web 服务器时请求该主机的网页，你可能会收到 TCP RST。
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although a certain level of this activity is normal, identifying the peak senders
    of SYN-only and RST-only flows can narrow down performance problems and unnecessary
    network congestion.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种活动的一定程度是正常的，但确定只包含 SYN 和 RST 流的峰值发送者可以缩小性能问题和不必要的网络拥塞的范围。
- en: To identify flows with multiple control bits set, add the control bits together.
    For example, flows that contain only the SYN and RST control bits indicate system
    problems. To identify these flows, write a filter that matches SYN+RST packets.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别设置了多个控制位的流，请将控制位相加。例如，只包含 SYN 和 RST 控制位的流表明系统存在问题。要识别这些流，请编写一个匹配 SYN+RST
    数据包的过滤器。
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once you start examining TCP control bits on even a small network, you'll find
    all sorts of problems and quickly ruin your blissful ignorance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始在小型网络上检查 TCP 控制位，你会发现各种问题，并迅速破坏你快乐的无知。
- en: ICMP Type and Code Primitives
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ICMP 类型码原始数据类型
- en: Different ICMP type and code messages can illuminate network activity. Although
    you can filter flows based on ICMP type and code, it's not exactly easy to do
    so.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 ICMP 类型码消息可以阐明网络活动。虽然你可以根据 ICMP 类型码和代码过滤流量，但这并不容易做到。
- en: Flows encode the ICMP type and code as the destination port. A primitive that
    matches a particular type and code uses the `ip-port` primitive. ICMP type and
    code are usually expressed as hexadecimal, but `ip-port` takes decimal values.
    (Use [Table 3-4](ch03s04.html#common_icmp_types_and_associated_codes_i "Table 3-4. Common
    ICMP Types and Associated Codes in Decimal and Hexadecimal") in [Types and Codes
    in ICMP](ch03s04.html#types_and_codes_in_icmp "Types and Codes in ICMP") to identify
    the appropriate decimal values.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 流将 ICMP 类型码编码为目标端口。匹配特定类型和代码的原始数据类型使用 `ip-port` 原始数据类型。ICMP 类型码通常以十六进制表示，但 `ip-port`
    接受十进制值。（使用 [Table 3-4](ch03s04.html#common_icmp_types_and_associated_codes_i "Table 3-4. Common
    ICMP Types and Associated Codes in Decimal and Hexadecimal") 中的 [Types and Codes
    in ICMP](ch03s04.html#types_and_codes_in_icmp "Types and Codes in ICMP") 识别适当的十进制值。）
- en: 'For example, suppose you''re looking for hosts that send ICMP redirects. Redirects
    are ICMP type 5 and come in two codes, 0 (redirect subnet) and 1 (redirect host).
    In hexadecimal, these would be 500 and 501\. [Table 3-4](ch03s04.html#common_icmp_types_and_associated_codes_i
    "Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal")
    shows their decimal values as 1280 and 1281, so write a primitive like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在寻找发送 ICMP 重定向的宿主机。重定向是 ICMP 类型 5，有两种代码，0（重定向子网）和 1（重定向宿主机）。以十六进制表示，这些是
    500 和 501。表 3-4 [Table 3-4](ch03s04.html#common_icmp_types_and_associated_codes_i
    "Table 3-4. Common ICMP Types and Associated Codes in Decimal and Hexadecimal")
    显示它们的十进制值为 1280 和 1281，因此可以编写如下原始数据类型：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Used in a filter by itself, this primitive would pass ICMP, TCP, and UDP flows.
    When you create the actual filter, use both this primitive and the ICMP primitive
    to see only ICMP redirects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用此原始数据类型进行过滤时，它会通过 ICMP、TCP 和 UDP 流。当你创建实际过滤器时，使用此原始数据类型和 ICMP 原始数据类型以仅查看
    ICMP 重定向。
- en: IP Address and Subnet Primitives
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP 地址和子网原始数据类型
- en: Filtering flows by addresses and subnets lets you narrow down data to hosts
    and networks of interest.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过地址和子网过滤流量可以让你缩小数据到感兴趣的宿主机和网络。
- en: IP Addresses
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP 地址
- en: Primitives for IP addresses use the `ip-address` type. It's reasonable to name
    primitives after the IP address they match, because IP addresses are difficult
    to confuse with other types of filter primitives.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址的原始数据类型使用 `ip-address` 类型。将原始数据类型命名为它们匹配的 IP 地址是合理的，因为 IP 地址与其他类型的过滤原始数据类型难以混淆。
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One primitive can include any number of addresses.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个原始数据类型可以包含任意数量的地址。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A primitive such as this `MailServers` example lets you match multiple hosts
    that serve a particular function, such as "all web servers," "all file servers,"
    and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于这个 `MailServers` 示例的原始数据类型让你可以匹配执行特定功能的多台宿主机，例如“所有 Web 服务器”、“所有文件服务器”等等。
- en: Subnet Primitives
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子网原始数据类型
- en: Primitives can also match subnets using the `ip-address-mask` and `ip-address-prefix`
    primitives. Flow-tools provides two different formats for subnets, `ip-address-mask`
    and `ip-address-prefix`, to match the two common notations for expressing subnets.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型也可以使用 `ip-address-mask` 和 `ip-address-prefix` 原始数据类型匹配子网。Flow-tools 提供了两种不同的子网格式，`ip-address-mask`
    和 `ip-address-prefix`，以匹配两种常见的表示子网的记法。
- en: 'The `ip-address-mask` primitive expects a full IP network address with the
    netmask in decimal form, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip-address-mask` 原始数据类型期望一个完整的 IP 网络地址，其中子网掩码以十进制形式表示，如下所示：'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This primitive matches all hosts with an IP between 192.0.2.0 and 192.0.2.255.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此原始数据类型匹配 IP 地址在 192.0.2.0 和 192.0.2.255 之间的所有宿主机。
- en: The `ip-address-prefix` primitive uses prefix (slash) notation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip-address-prefix` 原始数据类型使用前缀（斜杠）记法。'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can include multiple subnets, each on its own line, in the subnet primitive,
    and the subnet masks or prefixes do not have to be equal in all the entries. For
    example, the following is a perfectly valid primitive:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在子网原始数据类型中包含多个子网，每个子网占一行，并且子网掩码或前缀不必在所有条目中相等。例如，以下是一个完全有效的原始数据类型：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This primitive matches any IP address between 192.168.0.0 and 192.168.2.255.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此原始数据类型匹配介于 192.168.0.0 和 192.168.2.255 之间的任何 IP 地址。
- en: Time, Counter, and Double Primitives
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间、计数器和双原始数据类型
- en: You can filter flows by times during the day or by arbitrary counter values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据一天中的时间或任意的计数器值过滤流量。
- en: Comparison Operators in Primitives
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原语中的比较运算符
- en: Time and counter primitives use logical comparison operators, as shown in [Table 4-1](ch04s02.html#time_and_counter_comparison_operators
    "Table 4-1. Time and Counter Comparison Operators").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 时间和计数器原语使用逻辑比较运算符，如[表4-1](ch04s02.html#time_and_counter_comparison_operators
    "表4-1. 时间和计数器比较运算符")所示。
- en: Table 4-1. Time and Counter Comparison Operators
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1. 时间和计数器比较运算符
- en: '| Operator | Comparison | Time |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 比较 | 时间 |'
- en: '| --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `gt` | Greater than | Later than |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `gt` | 大于 | 晚于 |'
- en: '| `ge` | Greater than or equal to | This time or later |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `ge` | 大于或等于 | 这个时间或之后 |'
- en: '| `lt` | Less than | Earlier than |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `lt` | 小于 | 早于 |'
- en: '| `le` | Less than or equal to | Earlier than or equal to |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `le` | 小于或等于 | 早于或等于 |'
- en: '| `eq` | Equal | Exactly this time |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `eq` | 等于 | 正好是这个时间 |'
- en: Use these comparison operators *only* in time and counter primitives, not in
    filter definitions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较运算符 *仅* 用于时间和计数器原语，而不是在过滤器定义中使用。
- en: Time Primitives
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间原语
- en: To filter according to when flows began or stopped, use a `time` primitive.
    For example, here, you're looking for flows that stop or start some time during
    the minute of 8:03 **am**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据流量开始或停止的时间进行过滤，请使用 `time` 原语。例如，这里，你正在寻找在早上8:03 **am** 的分钟内停止或开始的流量。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, flow records use a 24-hour clock, so 8:03 **pm** is filtered as 20:03.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，流量记录使用24小时制时钟，所以晚上8:03 **pm** 被过滤为20:03。
- en: You can narrow down a time period even further. For example, if you know that
    the traffic you're interested in started and stopped during the second of 8:03:30
    **am**, you can write a primitive for that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以进一步缩小时间范围。例如，如果你知道你感兴趣的流量在早上8:03:30 **am** 的第二秒开始和结束，你可以为这个时间编写一个原语。
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You cannot filter on millisecond time intervals. Sensors and collectors are
    rarely accurate to milliseconds, however.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能根据毫秒时间间隔进行过滤。然而，传感器和收集器很少能精确到毫秒。
- en: 'To define a time interval, use other comparison operators. For example, suppose
    you know that something happened on your network between 7:58 **am** and 8:03
    **am**. To filter traffic during this time period, define a time window from 7:58
    to 8:03, inclusive, with the `ge` and `lt` operators, like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个时间间隔，请使用其他比较运算符。例如，假设你知道某件事发生在你的网络上的7:58 **am** 到8:03 **am** 之间。要过滤这段时间内的流量，定义一个从7:58到8:03的时间窗口，包括8:03，使用`ge`和`lt`运算符，如下所示：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although you can control the data you report on by selecting which flow files
    to analyze, using times helps narrow your searches even further. This is invaluable
    when examining large files, and it demonstrates the need for accurate time on
    your network.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以通过选择要分析的流量文件来控制你报告的数据，但使用时间可以帮助进一步缩小搜索范围。这在检查大文件时非常有价值，并且证明了在网络上准确时间的需求。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`flow-nfilter` also supports the `time-date` primitive for a specific date
    and time, such as January 20, 2011, at 8:03 **am**. If you''re interested in a
    specific date, however, you''re better off analyzing the flow files for that date.
    Flow files are named for the year, month, day, and time of their creation for
    a reason.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow-nfilter` 还支持用于特定日期和时间的 `time-date` 原语，例如2011年1月20日早上8:03 **am**。然而，如果你对特定日期感兴趣，分析该日期的流量文件会更好。流量文件以它们的创建年份、月份、日期和时间命名是有原因的。'
- en: Counter Primitives
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器原语
- en: 'The `counter` primitive lets you create filters like "more than 100 octets"
    or "between 500 and 700 packets." When creating filters of this sort, use one
    or more comparison operators with integers to define counters, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter` 原语允许你创建如“超过100字节”或“在500到700个数据包之间”的过滤器。在创建此类过滤器时，使用一个或多个整数比较运算符定义计数器，如下所示：'
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This particular filter would pass anything that has more than 10,000 of what
    you''re trying to measure. As another example, suppose you want to look at flows
    that last only 1,000 milliseconds (1 second) or longer. Here''s how you could
    do that:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的过滤器会通过任何超过你试图测量的10,000个内容的流量。作为另一个例子，假设你只想查看持续1,000毫秒（1秒）或更长的流量。以下是你可以这样做的方法：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Or, perhaps you want only flows of 1KB or larger.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许你只想过滤1KB或更大的流量。
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use multiple comparisons in a counter. For example, here, I''m permitting
    everything greater than 1,000 and less than 2,000:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在计数器中使用多个比较。例如，这里，我允许大于1,000且小于2,000的所有内容：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `counter` primitive, keep in mind that counters work only when
    filtering based on octets, packets, and/or duration. Counters will not match TCP
    ports or IP addresses.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`counter`原语时，请记住，计数器仅在基于字节、数据包和/或持续时间进行过滤时才起作用。计数器不会匹配TCP端口或IP地址。
- en: Double Primitives
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双重原语
- en: No, a `double` primitive isn't twice as primitive as the rest of flow-tools.
    A `double` primitive is a `counter` with a decimal point. It matches either packets
    per second or bits per second.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不，`double`原语并不比flow-tools中的其他原语简单两倍。`double`原语是一个带有小数点的`counter`。它可以匹配每秒数据包数或每秒比特数。
- en: For example, suppose you want to ignore all connections that send 100 or more
    packets per second. You need a primitive to define the 100 part of that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想忽略每秒发送100个或更多数据包的所有连接。你需要一个原语来定义其中的100部分。
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You'll see how to tie this to the number of packets per second in a filter definition,
    but this primitive defines the "less than 100" part of the filter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如何在过滤器定义中将它与每秒数据包数联系起来，但这个原语定义了过滤器的“小于100”部分。
- en: Like the `counter` primitive, the `double` cannot match arbitrary data. It can
    match only octets, packets, and duration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与`counter`原语一样，`double`不能匹配任意数据。它只能匹配字节、数据包和持续时间。
- en: Interface and BGP Primitives
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和BGP原语
- en: Flow records exported from a router include routing information, but most of
    this information is useful only if you're using dynamic routing such as Border
    Gateway Protocol (BGP). If you are not using BGP or other dynamic routing protocols,
    you can skip this section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从路由器导出的流量记录包括路由信息，但其中大部分信息仅在你使用动态路由，如边界网关协议（BGP）时才有用。如果你不使用BGP或其他动态路由协议，你可以跳过这一部分。
- en: Identifying Interface Numbers Using SNMP
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SNMP识别接口数字
- en: Most router configuration interfaces (such as Cisco's command line) give each
    router interface a human-friendly name such as FastEthernet0 or Serial1/0\. Internally,
    the router knows each interface by a number. The router uses the interface number
    in flow records, rather than the human-friendly name.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数路由器配置接口（如Cisco的命令行）给每个路由器接口一个人类友好的名称，例如FastEthernet0或Serial1/0。内部，路由器通过数字识别每个接口。路由器在流量记录中使用接口数字，而不是人类友好的名称。
- en: The simplest way to get the list of interface names and their corresponding
    numbers is through Simple Network Management Protocol (SNMP). If you're using
    multiple Internet providers, you almost certainly have some sort of SNMP capability.
    Most Unix-like systems include the net-snmp software suite, so I'll use that as
    an example. Other SNMP browsers should present similar results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 获取接口名称及其对应数字的最简单方式是通过简单网络管理协议（SNMP）。如果你使用多个互联网服务提供商，你几乎肯定拥有某种SNMP功能。大多数类Unix系统都包括net-snmp软件包，所以我会以它为例。其他SNMP浏览器应该会呈现类似的结果。
- en: Remember, SNMP presents information as a hierarchical tree. To get a list of
    network interfaces, check the `RFC1213-MIB::ifDescr` branch of the SNMP tree.
    To see interface names and numbers, use `snmpwalk` to query the router's `RFC1213-MIB::ifDescr`
    values. If your MIB browser doesn't support human-friendly names, `RFC1213-MIB::ifDescr`
    is equivalent to `.1.3.6.1.2.1.2.2.1.2`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，SNMP以层次树的形式呈现信息。要获取网络接口列表，请检查SNMP树中的`RFC1213-MIB::ifDescr`分支。要查看接口名称和数字，请使用`snmpwalk`查询路由器的`RFC1213-MIB::ifDescr`值。如果你的MIB浏览器不支持人类友好的名称，`RFC1213-MIB::ifDescr`等同于`.1.3.6.1.2.1.2.2.1.2`。
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous example, at ❶ you query a router with SNMP version 2, using
    its community name (❷) and the router's hostname or IP address (❸). In response,
    you get a list of router interface names.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在❶处，你使用SNMP版本2查询路由器，使用其社区名称（❷）和路由器的主机名或IP地址（❸）。作为回应，你得到一个路由器接口名称列表。
- en: The SNMP index is the router's internal number for the interface. For example,
    at ❹ interface 1 is named *FastEthernet0/0* (❺). Interface 7 is named *Serial0/0/0:0*,
    and so on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP索引是路由器接口的内部编号。例如，在❹处，接口1被命名为*FastEthernet0/0*（❺）。接口7被命名为*Serial0/0/0:0*，依此类推。
- en: Network engineers should notice that of the eight interfaces listed, interface
    4 (null0) is a logical interface and should never see any traffic. Similarly,
    interfaces 5 and 6 are not real interfaces; they are interface cards supporting
    interfaces 7 and 8\. Only five of the eight interfaces should ever pass traffic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师应该注意，在列出的八个接口中，接口4（null0）是一个逻辑接口，永远不会看到任何流量。同样，接口5和6不是真实接口；它们是支持接口7和8的接口卡。只有五个接口中的八个会传递流量。
- en: By default, Cisco routers can change their interface numbering on a reboot,
    which prevents gaps in interface numbering when interfaces are added or removed.
    Interface numbers that change arbitrarily really confuse long-term reporting,
    however. I recommend making your router maintain consistent interface numbering
    across reboots. It's true that this leaves gaps in the interface list; note the
    absence of interface 3 on the example router. On the other hand, interface 7 is
    always Serial 0/0/0:0, even years later. Tell a Cisco device to leave interface
    numbering unchanged with the configuration option `snmp-server ifindex persist`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Cisco路由器可以在重启时更改其接口编号，这防止了在添加或删除接口时接口编号出现空缺。然而，接口编号任意更改会真正混淆长期报告。我建议您的路由器在重启之间保持一致的接口编号。诚然，这会在接口列表中留下空缺；请注意示例路由器上接口3的缺失。另一方面，接口7始终是Serial
    0/0/0:0，即使多年以后也是如此。通过配置选项`snmp-server ifindex persist`告诉Cisco设备保持接口编号不变。
- en: Also, note that if you have multiple routers exporting data to a single collector,
    you must separate the data to get meaningful interface information. For example,
    interface 8 on router A might be a local Ethernet interface, while interface 8
    on router B might be an upstream T1 interface. You can filter data by exporter
    IP address, but this creates the need for an extra layer of filtering.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，如果您有多个路由器向单个收集器导出数据，您必须分离数据以获取有意义的接口信息。例如，路由器A上的接口8可能是一个本地以太网接口，而路由器B上的接口8可能是一个上游T1接口。您可以通过导出器IP地址过滤数据，但这会创建一个额外的过滤层需求。
- en: I'll use the previous interface list in the upcoming examples. Interfaces 1
    and 2 are local Ethernet ports, interfaces 7 and 8 are T1 circuits to two different
    Internet service providers, and interface 9 is a VPN tunnel. The other interfaces
    should never see traffic.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的示例中使用之前的接口列表。接口1和2是本地以太网端口，接口7和8是连接到两个不同互联网服务提供商的T1电路，而接口9是一个VPN隧道。其他接口不应该看到流量。
- en: Interface Number Primitive
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口编号原语
- en: Filtering by interface passes only the traffic that traversed that interface.
    Use the `ifindex` primitive for this purpose.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接口进行过滤只传递通过该接口的流量。为此，请使用`ifindex`原语。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Interface 9 is the VPN interface. Filtering on it shows you only traffic that
    goes over the VPN.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接口9是VPN接口。对其过滤只会显示通过VPN的流量。
- en: (You can list multiple interfaces on one line.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: （您可以在一行上列出多个接口。）
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Filtering by interface lets you focus on how traffic flows between particular
    network segments.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接口进行过滤让您能够关注特定网络段之间的流量流动。
- en: Autonomous System Primitives
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自治系统原语
- en: 'The Autonomous System (AS) is the core of BGP routing, and routers with BGP
    peers include AS number information in their flow exports. You can pull out traffic
    from particular AS numbers with the `as` primitive as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 自治系统（AS）是BGP路由的核心，具有BGP对等体的路由器在其流量导出中包含AS编号信息。您可以使用`as`原语提取特定AS编号的流量，如下所示：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can list multiple AS numbers separated by commas on a single line, or you
    can even list a range of AS numbers. Of course, you can also add multiple AS numbers
    on separate lines. (ARIN, RIPE, and other AS registrars frequently issue AS numbers
    to large organizations in blocks, so you might need to create such a filter.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一行上列出多个AS编号，用逗号分隔，或者甚至可以列出AS编号的范围。当然，您也可以在单独的行上添加多个AS编号。（ARIN、RIPE和其他AS注册机构经常以块的形式向大型组织颁发AS编号，因此您可能需要创建这样的过滤器。）
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can also write filters for route announcement prefix length using the `ip-address-prefix-len`
    primitive. I haven't found a use for a filter that says "Show me all the routes
    we're getting that are /25 or longer," but carriers and transit providers might
    find it useful to identify clients that are trying to announce tiny networks.^([[5](#ftn.CHP-4-FN-1)])
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`ip-address-prefix-len`原语编写用于路由公告前缀长度的过滤器。我没有找到一种过滤器，它说“显示我们正在获取的所有/25或更长的路由”，但运营商和转接提供商可能发现识别试图宣布小型网络的客户端很有用.^([[5](#ftn.CHP-4-FN-1)])
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[5](#CHP-4-FN-1)]) If you''re not a transit provider but are trying to announce
    tiny networks, the lesson you should learn here is this: Tiny route announcements
    won''t work, and if they do, they can find you.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-4-FN-1)]) 如果你不是转接提供商，但正在尝试宣布小型网络，你应该从中学到的教训是：小型路由公告不会起作用，如果它们确实起作用，它们可以找到你。
- en: Filter Match Statements
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤匹配语句
- en: To assemble primitives into filters, use `match` statements. `flow-nfilter`
    compares each flow against every `match` statement in a filter, and if a flow
    fits every `match` statement, the flow passes through. If the flow does not fit
    every `match` statement, the flow is removed from the data stream.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要将原语组装成过滤器，请使用`match`语句。`flow-nfilter`会将每个数据流与过滤器中的每个`match`语句进行比较，如果数据流符合每个`match`语句，则数据流通过。如果数据流不符合每个`match`语句，则数据流将从数据流中移除。
- en: Many match types have names that are similar to their associated primitives.
    For example, the `ip-protocol` primitive has a corresponding `ip-protocol` match.
    Other primitives have no single matching condition. For example, the `ip-port`
    primitive can match either the `ip-source-port` primitive or the `ip-destination-port`
    primitive. If you use an incorrect `match` statement in your configuration, `flow-nfilter`
    exits with an error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 许多匹配类型的名称与其相关原语相似。例如，`ip-protocol`原语有一个相应的`ip-protocol`匹配。其他原语没有单一的匹配条件。例如，`ip-port`原语可以匹配`ip-source-port`原语或`ip-destination-port`原语。如果您在配置中使用了错误的`match`语句，`flow-nfilter`将带错误退出。
- en: Filter definitions support many different types of match condition. The `flow-nfilter`
    manual page has the complete list, but the ones I find useful are described here.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器定义支持许多不同类型的匹配条件。`flow-nfilter`的手册页有完整的列表，但这里描述了我认为有用的那些。
- en: Protocols, Ports, and Control Bits
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议、端口和控制位
- en: Matching protocols and ports is very common. Control bits and ICMP type and
    code are less common but powerful in a different way.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配协议和端口是非常常见的。控制位和ICMP类型和代码则不太常见，但以不同的方式强大。
- en: Network Protocol Filters
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络协议过滤器
- en: Use the `ip-protocol` match type to check each flow against an `ip-protocol`
    primitive.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ip-protocol`匹配类型来检查每个数据流是否与`ip-protocol`原语匹配。
- en: 'I previously defined a primitive for OSPF. Here I''m using that primitive to
    pass only OSPF traffic:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前定义了一个OSPF原语。现在，我正在使用这个原语来仅允许OSPF流量通过：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Listing multiple protocol primitives in a filter will cause no packets to match.
    After all, very few single flows are both TCP and UDP.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤器中列出多个协议原语将导致没有数据包匹配。毕竟，非常少的数据流既是TCP又是UDP。
- en: Source or Destination Port Filters
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源或目的端口过滤器
- en: '`flow-nfilter` has separate matches for source ports (`ip-source-port`) and
    destination ports (`ip-destination-port`). These match against the `ip-port` primitive.
    Here I''m using the `port80` primitive defined earlier to filter traffic to a
    web server:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow-nfilter`对源端口（`ip-source-port`）和目的端口（`ip-destination-port`）有单独的匹配。这些匹配与`ip-port`原语。在这里，我正在使用之前定义的`port80`原语来过滤发送到Web服务器的流量：'
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To match multiple ports for one service, define a primitive that includes all
    the ports for that service. For example, earlier I defined a `webTraffic` primitive
    for ports 80 and 443.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一个服务的多个端口，定义一个包含该服务所有端口的原语。例如，之前我定义了一个`webTraffic`原语，用于端口80和443。
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Use the `ip-source-port` similarly. For example, to capture traffic leaving
    your web server, filter the flows leaving ports 80 and 443\. (You'll see how to
    write reports that match both arriving and departing traffic in [Logical Operators
    in Filter Definitions](ch04s05.html "Logical Operators in Filter Definitions")
    in [Logical Operators in Filter Definitions](ch04s05.html "Logical Operators in
    Filter Definitions").)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地使用`ip-source-port`。例如，为了捕获离开您的Web服务器的流量，过滤掉80和443端口的流量。（您将在[过滤器定义中的逻辑运算符](ch04s05.html
    "过滤器定义中的逻辑运算符")中看到如何编写匹配到达和离开流量的报告。[逻辑运算符在过滤器定义](ch04s05.html "逻辑运算符在过滤器定义")。）
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: TCP Control Bit Filters
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP控制位过滤器
- en: Use the `ip-tcp-flags` keyword to match TCP control bit primitives. For example,
    I previously defined a `rst-only` primitive that matched flows that contained
    TCP resets only.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ip-tcp-flags`关键字来匹配TCP控制位原语。例如，我之前定义了一个`rst-only`原语，它匹配只包含TCP重置的数据流。
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This filter displays only the flows that match the `rst-only` primitive. You
    don't need to specify a protocol, because flow records contain control bits only
    for TCP flows. You could use very similar filters for the other TCP control bit
    primitives.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器仅显示匹配`rst-only`原语的流量。您不需要指定协议，因为流量记录仅包含TCP流量的控制位。您可以使用非常相似的过滤器来匹配其他TCP控制位原语。
- en: ICMP Type and Code Filters
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ICMP类型和代码过滤器
- en: 'Remember that flows record the ICMP type and code in the destination port field
    of ICMP flows. However, unlike TCP control bits, which appear only in the records
    of TCP flows, destination ports appear in TCP, UDP, and ICMP flows. To specifically
    match ICMP type and code, your filter must include the destination port and the
    protocol as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，流记录了ICMP类型和代码在ICMP流的目标端口字段中。然而，与仅在TCP流记录中出现的TCP控制位不同，目标端口出现在TCP、UDP和ICMP流中。为了特定地匹配ICMP类型和代码，你的过滤器必须包括目标端口和协议，如下所示：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I previously defined a `redirects` primitive at ❶ that matched both codes within
    the ICMP redirect type. Here, I'm adding a match (❷) for the `ICMP` protocol primitive
    as well. This filter passes only the flows that contain ICMP redirects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前在❶处定义了一个`redirects`原始过滤器，它匹配ICMP重定向类型中的所有代码。在这里，我添加了一个匹配（❷）用于`ICMP`协议原始过滤器。此过滤器仅传递包含ICMP重定向的流。
- en: Addresses and Subnets
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址和子网
- en: '`flow-nfilter` supports two match types for IP addresses: source (`ip-source-address`)
    or destination address (`ip-destination-address`). These match types can work
    on any of the three IP address primitives: `ip-address`, `ip-address-mask`, or
    `ip-address-prefix`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow-nfilter`支持两种IP地址匹配类型：源地址（`ip-source-address`）或目标地址（`ip-destination-address`）。这些匹配类型可以在三个IP地址原始过滤器中的任何一个上工作：`ip-address`、`ip-address-mask`或`ip-address-prefix`。'
- en: 'You can match the source address on one line and the destination address on
    another line. For example, suppose you have an `ip-address-prefix` primitive for
    your client''s network and another for your web servers. The following definition
    passes traffic from your client to your web server:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一行上匹配源地址，在另一行上匹配目标地址。例如，假设你有一个用于你的客户端网络的`ip-address-prefix`原始过滤器，另一个用于你的Web服务器。以下定义传递来自你的客户端到你的Web服务器的流量：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You cannot list multiple matches of the same type in a single filter because
    a single flow cannot have multiple source or destination addresses! To pass traffic
    from several source or destination addresses, use a primitive that contains all
    the desired addresses.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在单个过滤器中列出同一类型的多个匹配项，因为单个流不能有多个源或目标地址！要从多个源或目标地址传递流量，请使用包含所有所需地址的原始过滤器。
- en: The next filter captures data coming into the server from web clients. You need
    a corresponding report to catch traffic from your web servers to the client network
    (or a slightly more complicated filter to capture traffic moving in both directions,
    as you'll see in [Logical Operators in Filter Definitions](ch04s05.html "Logical
    Operators in Filter Definitions") in [Logical Operators in Filter Definitions](ch04s05.html
    "Logical Operators in Filter Definitions")). Because you want to see only web
    traffic, you also filter with primitives for web traffic and TCP.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个过滤器捕获来自Web客户端的服务器数据。你需要一个相应的报告来捕获来自你的Web服务器到客户端网络的流量（或者一个稍微复杂一些的过滤器来捕获双向移动的流量，正如你将在[过滤器定义中的逻辑运算符](ch04s05.html
    "过滤器定义中的逻辑运算符")中看到的）。因为你只想看到Web流量，所以你也使用Web流量和TCP的原始过滤器进行过滤。
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You'll see other ways to achieve this same effect in [Using Multiple Filters](ch04s04.html
    "Using Multiple Filters") in [Next-Hop Address Filters](ch04s03.html#next-hop_address_filters
    "Next-Hop Address Filters").
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[使用多个过滤器](ch04s04.html "使用多个过滤器")中看到其他实现相同效果的方法，在[下一跳地址过滤器](ch04s03.html#next-hop_address_filters
    "下一跳地址过滤器")。
- en: Filtering by Sensor or Exporter
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过传感器或导出器进行过滤
- en: 'Multiple flow sensors can export to a single collector, but at times you''ll
    want to see only the flows that came from a particular sensor. You can use the
    `ip-exporter-address` match with any IP address primitive to create a filter that
    passes flows from a particular sensor, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 多个流量传感器可以导出到单个收集器，但有时你只想看到来自特定传感器的流。你可以使用`ip-exporter-address`匹配与任何IP地址原始过滤器一起创建一个过滤器，该过滤器仅传递来自特定传感器的流，如下所示：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This particular filter passes only the flows exported from the router at 192.0.2.1.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此特定过滤器仅传递从192.0.2.1路由器导出的流。
- en: Time Filters
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间过滤器
- en: 'The `start-time` and `end-time` match types let you filter on when flows begin
    and end, using the `time` primitive. For example, the following sample captures
    all flows that take place entirely within a particular minute, using the `0803`
    time primitive defined earlier:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`start-time`和`end-time`匹配类型允许你使用`time`原始过滤器根据流的开始和结束时间进行过滤。例如，以下示例使用之前定义的`0803`时间原始过滤器捕获所有在特定分钟内发生的流：'
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can define a filter to match flows starting or ending at any time that you
    can express with a primitive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个过滤器，以匹配任何可以用原语表达的时间开始或结束的流量。
- en: 'In most cases, you won''t have accurate time information about problems. Human
    beings have a notoriously fuzzy time sense: "A few minutes ago" might be anything
    from 30 seconds to an hour, and after a few days even that is unreliable. Remember
    that each flow file covers a five-minute period. Most of the time you''re better
    off searching entire flow files for issues rather than trying to filter on times.
    I find that filtering on times is useful only on very large flow files and then
    only when you have precise timing information from the flow files themselves.
    A human saying that the website broke at 8:15 **am** is not reliable. If your
    flow records say that you had unusual traffic at 8:15 **am**, however, you might
    want to see what else happened during that minute. Filtering on times can be useful
    in that instance.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不会有关于问题的准确时间信息。人类的时间感非常模糊：“几分钟前”可能从30秒到一小时不等，几天后甚至那个时间也不可靠。记住，每个流量文件覆盖了五分钟的时间段。大多数时候，你最好在整个流量文件中搜索问题，而不是尝试根据时间进行过滤。我发现，只有在非常大的流量文件上，并且只有当你从流量文件本身获得精确的时间信息时，根据时间进行过滤才有用。一个人说网站在早上8:15
    **am** 崩溃是不可靠的。然而，如果你的流量记录显示你在早上8:15 **am** 有异常流量，你可能想看看那一分钟内还发生了什么。在这种情况下，根据时间进行过滤可能会有用。
- en: Clipping Levels
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪裁级别
- en: A *clipping level* is the point at which you start ignoring data. For example,
    you might not care about flows that contain tiny amounts of data, or perhaps you
    want to see only tiny flows. To clip data, you can set clipping levels on the
    amount of traffic transmitted, the connection speed, and the duration of connections.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*剪裁级别* 是你开始忽略数据的那一点。例如，你可能不关心包含极小数据量的流量，或者你可能只想看到极小的流量。为了剪裁数据，你可以在传输流量量、连接速度和连接持续时间上设置剪裁级别。'
- en: Octets, Packets, and Duration Filters
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字节、数据包和持续时间过滤器
- en: Use `counter` primitives to filter based on the number of octets per flow, the
    packets per flow, or the duration of flows. For example, earlier I defined a primitive
    for 1KB or larger. Let's use that primitive now to remove the tiny connections
    from the flow data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `counter` 原语根据每个流中的字节数、每个流中的数据包数或流的持续时间进行过滤。例如，我之前定义了一个1KB或更大的原语。现在让我们使用这个原语来从流量数据中移除微小的连接。
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Similarly, you created a primitive for anything that totaled 1,000 or more,
    called `1second`. You can write a filter that uses this primitive to allow only
    flows of 1,000 milliseconds (1 second) or longer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你为总计1000个或更多的情况创建了一个原语，称为 `1second`。你可以编写一个使用此原语的过滤器，以允许只有1000毫秒（1秒）或更长的流量。
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Counters are arbitrary numbers and can apply to octets, packets, or duration.
    For example, if you want a filter that includes only flows with 1,024 or more
    packets, you could easily reuse the `1kB` primitive for that.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器是任意数字，可以应用于字节数、数据包数或持续时间。例如，如果你想有一个只包含1,024个或更多数据包的流量过滤器，你可以很容易地重复使用 `1kB`
    原语。
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Even though you can, I try not to reuse primitives in this way. You never hear
    of a kilobyte of packets! Such filters confuse me. Being confused while trying
    to identify network problems is not good.^([[6](#ftn.CHP-4-FN-2)])
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以这样做，但我尽量避免以这种方式重复使用原语。你从未听说过千字节的数据包！这样的过滤器让我感到困惑。在尝试识别网络问题时感到困惑并不是好事。[^6](#ftn.CHP-4-FN-2)]
- en: Packets or Bits per Second Filters
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每秒数据包或比特过滤器
- en: Perhaps you're interested in how quickly connections move or you're interested
    only in the really fast or really slow connections. If so, you can use `double`
    primitives to filter based on packets per second or bits per second.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你对连接移动的速度感兴趣，或者你只对非常快或非常慢的连接感兴趣。如果是这样，你可以使用 `double` 原语根据每秒的数据包数或比特数进行过滤。
- en: For example, earlier you defined a `double` primitive for less than 100\. You
    can use this for either packets per second or bits per second.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你之前定义了一个小于100的 `double` 原语。你可以用它来过滤每秒的数据包数或比特数。
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this particular case, I don't mind reusing the `lessThan100` primitive, because
    the name isn't so closely tied to a particular data type.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，我不介意重复使用 `lessThan100` 原语，因为这个名字并没有与特定数据类型紧密相关。
- en: BGP and Routing Filters
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BGP和路由过滤器
- en: You can filter flows based on the routing information included in the flow records.
    (If you are not using BGP, you can skip this section.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据流量记录中包含的路由信息来过滤流量。（如果你没有使用BGP，可以跳过这一节。）
- en: Autonomous System Number Filters
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自治系统编号过滤器
- en: 'The `source-as` and `destination-as` match types let you match based on AS
    numbers. For example, this filter lets you see what traffic you''re receiving
    (from what was the UUnet network) using the `uunet` AS primitive defined earlier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`source-as`和`destination-as`匹配类型允许你基于AS号码进行匹配。例如，这个过滤器允许你查看你接收到的流量（来自之前是UUnet网络的流量）使用之前定义的`uunet`
    AS原始指令：'
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You could also turn this around to create a filter to permit the traffic you're
    sending to UUnet systems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以反过来创建一个过滤器，允许发送到UUnet系统的流量。
- en: Next-Hop Address Filters
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下一跳地址过滤器
- en: The *next hop* is the IP address where a router sends a flow. This is usually
    the IP address on the remote end of an ISP circuit (for outgoing flows) or the
    external address of your firewall (for inbound flows). Routers include the next
    hop in flow records. However, software flow sensors like `softflowd` know nothing
    of interfaces on remote hosts or how packets are routed, so flows exported from
    software flow sensors do not contain next-hop addresses.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*下一跳*是路由器发送流量的IP地址。这通常是ISP电路远程端的IP地址（对于出站流量）或你的防火墙的外部地址（对于入站流量）。路由器在流量记录中包含下一跳地址。然而，像`softflowd`这样的软件流量传感器对远程主机的接口或数据包的路由方式一无所知，因此从软件流量传感器导出的流量不包含下一跳地址。'
- en: 'Now suppose that the next-hop IP address for one of your Internet providers
    is 61.118.12.45\. To filter all traffic leaving your network via that ISP, you
    could use a primitive and a definition like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你其中一个互联网服务提供商的下一步IP地址是61.118.12.45。为了过滤通过该ISP离开你网络的全部流量，你可以使用一个原始的定义，如下所示：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `ip-nexthop-address` match type works with the primitives `ip-address`,
    `ip-address-mask`, and `ip-address-prefix`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip-nexthop-address`匹配类型与`ip-address`、`ip-address-mask`和`ip-address-prefix`原始指令一起工作。'
- en: Interface Filters
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口过滤器
- en: Another way to filter by provider or network segment is to filter by the router
    interface. The match types `input-interface` and `output-interface` let you filter
    by traffic arriving or leaving your router.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种按提供商或网络段过滤的方法是通过路由器接口进行过滤。匹配类型`input-interface`和`output-interface`允许你根据到达或离开你的路由器的流量进行过滤。
- en: 'You defined a primitive for router interface 9 earlier. Here I''m using it
    in a filter:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前为路由器接口9定义了一个原始指令。这里我在一个过滤器中使用它：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This shows traffic entering the router on this interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了进入此接口的路由器上的流量。
- en: '* * *'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#CHP-4-FN-2)]) I don't need to waste my time calling myself an idiot
    because I gave a filter an ambiguous name. Many other people are delighted to
    call me an idiot for all sorts of reasons.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-4-FN-2)]) 我不需要浪费时间称自己为傻瓜，因为我给一个过滤器起了一个模糊的名字。很多人因为各种原因都乐于称我为傻瓜。
- en: Using Multiple Filters
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个过滤器
- en: Suppose you want to identify all traffic between two machines. You could define
    primitives for those two hosts and then write a filter that specifically defines
    those hosts. However, this common situation will keep you very busy writing new
    filters. Instead, I find it much easier to define smaller filters and tie them
    together on the command line.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想识别两台机器之间的所有流量。你可以为这两个主机定义原始指令，然后编写一个特别定义这些主机的过滤器。然而，这种常见情况会让你非常忙碌地编写新的过滤器。相反，我发现定义较小的过滤器并在命令行上连接它们要容易得多。
- en: You can invoke `flow-nfilter` repeatedly in a single command. Find the flow
    files for the times you're interested in, filter them for the first host, and
    then filter them a second time for the second host.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个命令中重复调用`flow-nfilter`。找到你感兴趣的时段的流量文件，对第一个主机进行过滤，然后对第二个主机进行第二次过滤。
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first `flow-nfilter` invocation at ❶ passes only flows that include traffic
    from `host1`. The second at ❷ passes only flows that include traffic from `host2`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`flow-nfilter`调用❶只允许包含来自`host1`的流量的流量。第二个❷只允许包含来自`host2`的流量的流量。
- en: Similarly, you can write separate filters for certain protocols, like all web
    traffic. You previously created a filter for all HTTP and HTTPS traffic, called
    `webTraffic`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以为某些协议编写单独的过滤器，比如所有Web流量。你之前创建了一个名为`webTraffic`的过滤器，用于所有HTTP和HTTPS流量。
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first filter at ❶ passes only traffic for the interesting host, and the
    second (❷) passes only HTTP and HTTPS traffic.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个过滤器❶只允许对感兴趣的主机的流量，第二个（❷）只允许HTTP和HTTPS流量。
- en: You can create simple filters for important hosts and subnets on your network.
    For example, if you have a customer who reports problems reaching your website,
    you could write one flow filter for your site and one for the customer's addresses
    and use them both to see what traffic passed between your networks. You could
    then look for SYN-only or RST-only flows that would indicate problems. Or you
    might find that traffic from the customer's network never reaches you at all.
    In any case, these two filters will tell you exactly what traffic appeared on
    your network and how it behaved.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你网络中的重要主机和子网创建简单的过滤器。例如，如果你有一个报告无法访问你网站的客户的案例，你可以为你的网站编写一个流量过滤器，并为客户的地址编写一个，然后使用这两个过滤器来查看你网络之间传递的流量。然后你可以查找表示问题的SYN-only或RST-only流量。或者，你可能发现来自客户网络的流量根本无法到达你。在任何情况下，这两个过滤器都会告诉你网络上出现了什么流量以及它的行为方式。
- en: By combining filters on the command line, you will write fewer filters and get
    more use out of the filters you create.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行上组合过滤器，你会编写更少的过滤器，并更充分地利用你创建的过滤器。
- en: Logical Operators in Filter Definitions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器定义中的逻辑运算符
- en: When you put multiple match conditions in a filter definition, `flow-nfilter`
    places a logical "and" between them. For example, the following filter shows all
    traffic that runs over TCP and has a source port of 25\. This passes an email
    server's responses to a connection.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在过滤器定义中放入多个匹配条件时，`flow-nfilter`会在它们之间放置一个逻辑“与”。例如，以下过滤器显示所有运行在TCP上且源端口为25的流量。这通过连接传递电子邮件服务器的响应。
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can use other logical operators to build very complicated filters.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其他逻辑运算符来构建非常复杂的过滤器。
- en: Logical "or"
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑“或”
- en: 'When I try to analyze a connection problem, I usually want to see both sides
    of the conversation. I want a filter that will show connections to port 25 as
    well as from port 25\. For this, use the `or` operator as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试分析一个连接问题时，我通常想看到对话的双方。我需要一个可以显示到端口25的连接以及从端口25的连接的过滤器。为此，使用以下`or`运算符：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After the `or` statement at ❶, a whole new filter definition begins. Although
    I listed `TCP` in the first filter, if you''re interested in TCP in the second
    filter, you must repeat the match on TCP at ❷, after which you can add the new
    `match` statement at ❸ to catch flows that end on port 25\. Now, if you apply
    this filter to your flow data, you''ll see something like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处的`or`语句之后，开始了一个全新的过滤器定义。尽管我在第一个过滤器中列出了`TCP`，如果你对第二个过滤器中的TCP感兴趣，你必须重复在❷处的TCP匹配，然后你可以添加❸处的新的`match`语句来捕获结束于端口25的流量。现在，如果你将此过滤器应用于你的流量数据，你会看到如下内容：
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first flow at ❶ is from a remote IP to the address of the local email server,
    with a destination port of 25\. This is an incoming mail transmission. The second
    flow at ❷ is from the mail server to the same remote IP address; it's coming from
    port 25\. This is the response to the first flow.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶处的第一个流量是从远程IP地址到本地电子邮件服务器的地址，目标端口为25。这是一个传入的邮件传输。❷处的第二个流量是从邮件服务器到相同的远程IP地址；它来自端口25。这是对第一个流量的响应。
- en: I could use more sophisticated `flow-print` formats to view this in more detail,
    run `flow-report` on this data to check for errors, or add another filter to specifically
    point out TCP errors in the email stream. This simple check shows me that the
    mail server is exchanging substantial amounts of traffic on TCP port 25, however.
    I would tell my mail administrator to check the logs for errors or provide more
    information.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用更复杂的`flow-print`格式来更详细地查看这些信息，运行`flow-report`来检查错误，或者添加另一个过滤器来特别指出电子邮件流中的TCP错误。这个简单的检查显示邮件服务器在TCP端口25上交换了大量的流量。我会告诉我的邮件管理员检查日志以查找错误或提供更多信息。
- en: Filter Inversion
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器反转
- en: Sometimes it's easier to write a filter for the traffic you're *not* interested
    in. For example, suppose you want to see all the traffic to or from your email
    servers that isn't email. Although you could write primitives that included all
    port numbers except those for email, that's annoying and tedious.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候编写一个过滤掉你**不感兴趣**的流量会更容易。例如，假设你想查看所有不是电子邮件的到或从你的电子邮件服务器的流量。虽然你可以编写包含所有端口号除了电子邮件端口的原始代码，但这很烦人且繁琐。
- en: 'Instead, use the `invert` keyword to reverse the meaning of a filter, like
    so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用`invert`关键字来反转过滤器的含义，如下所示：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: By adding `invert` to the report at ❶, you pass everything that doesn't match
    the defined filters. In this example, I'm passing every network transaction that
    doesn't involve TCP port 25.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在❶的报告中添加`invert`，你可以传递所有不匹配定义的过滤器的内容。在这个例子中，我正在传递所有不涉及TCP端口25的网络事务。
- en: 'But there''s a problem with this filter: It will match all nonemail traffic
    on all the hosts for which you''re capturing data. You, however, need to view
    only traffic for your email hosts.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个过滤器有一个问题：它会匹配你捕获数据的所有主机上的所有非电子邮件流量。然而，你只需要查看你的电子邮件主机的流量。
- en: To solve this problem, you could add your email servers into the `not-email`
    filter, but the email servers both send and receive email. You would need a definition
    section for remote servers connecting to your mail servers, a section for your
    servers' response to those remote servers, a third section for your mail servers
    connecting to remote mail servers, and a fourth for the remote servers' responses
    to your servers' requests. That's pretty ugly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以将你的电子邮件服务器添加到`not-email`过滤器中，但电子邮件服务器既发送也接收电子邮件。你需要为连接到你的邮件服务器的远程服务器定义一个部分，为你的服务器对那些远程服务器的响应定义一个部分，为你的邮件服务器连接到远程邮件服务器定义一个第三部分，以及为远程服务器对你的服务器请求的响应定义一个第四部分。这看起来相当糟糕。
- en: 'It''s much simpler to define a separate filter that strips the flow data down
    to just the email servers and then to concatenate the two, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个单独的过滤器，将流量数据简化到仅包含电子邮件服务器，然后将这两个过滤器连接起来，会更简单，如下所示：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `emailServers` primitive at ❶ includes the IP addresses of all the mail
    servers. Next, at ❷ I create a filter definition to match all traffic leaving
    or going to those servers. Then, to see all nonemail traffic to or from my email
    servers, I do this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`emailServers` 原语在❶中包含了所有邮件服务器的IP地址。接下来，在❷我创建了一个过滤器定义来匹配所有离开或前往这些服务器的流量。然后，为了查看所有非电子邮件流量到或来自我的电子邮件服务器，我这样做：'
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `emailServers` filter at ❶ passes only the flows that involve my email servers.
    The `not-email` filter at ❷ passes only flows that are not SMTP. By combining
    these two filters, I see only interesting traffic. I'll probably need to adjust
    the filter further to remove other uninteresting traffic, such as DNS queries
    to the DNS server, but I'm almost there.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶的`emailServers`过滤器中，只传递涉及我的电子邮件服务器的流量。在❷的`not-email`过滤器中，只传递不是SMTP的流量。通过结合这两个过滤器，我只看到有趣的流量。我可能需要进一步调整过滤器以删除其他不感兴趣的流量，例如到DNS服务器的DNS查询，但我几乎做到了。
- en: Of course, after reviewing the filtered traffic, I can go ask my email administrator
    why he's running his own DNS server on the mail server instead of using the corporate
    name servers and why he browses the Web from those machines instead of using the
    proxy server and its adult content filters.^([[7](#ftn.CHP-4-FN-3)])
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在审查过滤后的流量后，我可以去问我的电子邮件管理员为什么他在邮件服务器上运行自己的DNS服务器而不是使用公司名称服务器，以及为什么他从那些机器上浏览网页而不是使用代理服务器及其成人内容过滤器。[7](#ftn.CHP-4-FN-3)]
- en: '* * *'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[7](#CHP-4-FN-3)]) Yes, I could take this straight to human resources, but
    HR won't wash and wax my car.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-4-FN-3)]) 是的，我可以直接去人力资源部门，但人力资源部门不会洗车和打蜡。
- en: Filters and Variables
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器和变量
- en: Flow-tools also includes filters that can be configured on the command line,
    which can be useful for very simple filters, such as identifying traffic from
    a particular IP address. The default filters that use these are fairly limited,
    but they'll suffice for simple traffic analysis. It's also easy to write your
    own variable-driven reports.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Flow-tools还包括可以在命令行上配置的过滤器，这对于非常简单的过滤器很有用，例如识别来自特定IP地址的流量。使用这些过滤器的默认过滤器相当有限，但它们足以进行简单的流量分析。编写自己的变量驱动报告也很容易。
- en: Using Variable-Driven Filters
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变量驱动过滤器
- en: 'The filters that are configurable on the command line use three variables:
    `ADDR` (address), `PORT` (port), and `PROT` (protocol). These support five reports,
    letting you filter by protocol as well as by source and destination address and
    port: `ip-src-addr`, `ip-dst-addr`, `ip-src-port`, `ip-dest-port`, and `ip-prot`.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行上可配置的过滤器使用三个变量：`ADDR`（地址）、`PORT`（端口）和`PROT`（协议）。这些支持五个报告，让你可以根据协议以及源地址和端口进行过滤：`ip-src-addr`、`ip-dst-addr`、`ip-src-port`、`ip-dest-port`和`ip-prot`。
- en: 'Suppose your boss calls. She''s connecting from a random open wireless hotspot
    in some inconvenient city and can''t get into the corporate VPN concentrator.
    You get her IP address, either by asking her for it or by accessing system logs
    to see where she''s coming from. To see all the traffic coming to your network
    from her IP, without writing a custom filter, you could use a command-line variable
    on the flow files for that time window. For example, if she''s at the IP address
    192.0.2.8, you''d use a command like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的老板给你打电话。她正在某个不方便的城市的一个随机开放的无线热点连接，无法进入公司的VPN集中器。你可以通过询问她或者通过访问系统日志查看她的来源来获取她的IP地址。为了查看所有来自她IP地址的网络流量，而不需要编写自定义过滤器，你可以使用该时间窗口的流文件上的命令行变量。例如，如果她的IP地址是192.0.2.8，你会使用如下命令：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `-v` argument at ❶ tells `flow-nfilter` that you're assigning a value to
    a variable. In this example, I've assigned the value 192.0.2.8 to the variable
    `ADDR`. You'll see all traffic originating from that IP address.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`参数❶告诉`flow-nfilter`你正在为一个变量分配值。在这个例子中，我已将值192.0.2.8分配给变量`ADDR`。你将看到所有从这个IP地址起源的流量。'
- en: WHEN TO USE VARIABLE-DRIVEN FILTERS?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用变量驱动过滤器？
- en: For simple filters on individual hosts and ports, use variable-driven filters.
    If you must filter on multiple hosts or ranges of ports, define primitives and
    filters in *filter.cfg*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个主机和端口的简单过滤器，使用变量驱动过滤器。如果你必须过滤多个主机或端口的范围，请在*filter.cfg*中定义原语和过滤器。
- en: Defining Your Own Variable-Driven Filters
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义您自己的变量驱动过滤器
- en: Variable-driven filters take advantage of the primitives `VAR_ADDR` (address),
    `VAR_PORT` (port), and `VAR_PROT` (protocol), as defined in *filter.cfg*. For
    example, the following is a default variable-driven filter that uses the `ADDR`
    variable. This looks exactly like a standard report, except that it uses the variable
    name instead of a primitive.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 变量驱动过滤器利用了在*filter.cfg*中定义的原语`VAR_ADDR`（地址）、`VAR_PORT`（端口）和`VAR_PROT`（协议）。例如，以下是一个默认的变量驱动过滤器，它使用`ADDR`变量。这看起来就像一个标准的报告，除了它使用变量名而不是原语。
- en: '[PRE62]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Use these variables to define your own variable-driven filters. For example,
    I like to see all traffic to *and* from a host of interest. Writing a command-line
    version of this report is easy.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些变量来定义你自己的变量驱动过滤器。例如，我喜欢看到所有来自和到一个感兴趣的主机的流量。编写这个报告的命令行版本很容易。
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Similarly, I prefer to see all traffic to *and* from a port simultaneously.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我更喜欢同时查看到和来自端口的全部流量。
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With these reports, I can dynamically filter for any individual host or port
    on the fly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些报告，我可以动态地实时过滤任何单个主机或端口。
- en: Creating Your Own Variables
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您自己的变量
- en: '`VAR_ADDR`, `VAR_PORT`, and `VAR_PROT` are not magic variables hard-coded into
    `flow-nfilter`; they''re defined in *filter.cfg*. Here''s the definition of `VAR_PORT`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`VAR_ADDR`、`VAR_PORT`和`VAR_PROT`不是硬编码在`flow-nfilter`中的魔法变量；它们在*filter.cfg*中定义。以下是`VAR_PORT`的定义：'
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Most of this primitive looks like any other primitive for a port number, but
    the `permit` statement (❶) is very different. This example takes the variable
    `PORT` as defined on the command line and turns it into a number. The specifics
    of how this works aren't important, but you can use this sample as a model for
    your own primitives.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这个原语看起来像任何其他端口号的原语，但`permit`语句❶非常不同。这个例子将命令行上定义的变量`PORT`转换为一个数字。这个工作原理的具体细节并不重要，但你可以用这个样本作为你自己的原语的模型。
- en: Now here's another example. I frequently work with BGP, so I need an AS number
    primitive.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再举一个例子。我经常与BGP打交道，所以我需要一个AS号原语。
- en: '[PRE66]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: I've assigned this primitive the name `VAR_AS` at ❶ to correspond with the existing
    variable names, and I've assigned it the `as` type (❷). The `permit` statement
    at ❸ is copied from the `VAR_PORT` primitive, substituting the variable name `AS`
    for the port. Now I can create a filter using this variable.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将这个原语命名为`VAR_AS`❶，以与现有的变量名对应，并已将其分配为`as`类型❷。`permit`语句❸是从`VAR_PORT`原语复制的，用变量名`AS`代替了端口。现在我可以使用这个变量创建一个过滤器。
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This closely resembles the earlier custom variable-based filters in that you
    pass traffic going to ❶ and from the specified AS (❷). Now you can use this filter
    to get the traffic to a particular autonomous system.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前基于自定义变量的过滤器非常相似，因为你传递的是前往指定AS（❶）和来自该AS的流量。现在你可以使用这个过滤器来获取特定自治系统的流量。
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When you apply this filter, you'll see only the flows involving AS number 701.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用这个过滤器时，你将只看到涉及AS号701的流量。
- en: At this point, you should be able to filter traffic in any way you like. Now
    let's run analysis on that data.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够以任何你喜欢的任何方式过滤流量。现在让我们对那些数据进行分析。
