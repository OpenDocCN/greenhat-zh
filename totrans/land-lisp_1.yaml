- en: Part I. Lisp is Power
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分：Lisp 是力量
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703119.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages703119.png.jpg)'
- en: Chapter 1. Getting Started with Lisp
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：Lisp 入门
- en: This chapter begins with an introduction to the various dia lects of Lisp. Then
    we’ll talk a bit about ANSI Common Lisp, the dialect that we’ll be using in this
    book. Finally, you’ll get started by installing and testing CLISP, the implementation
    of ANSI Common Lisp that will let you run all the Lisp games you’re going to be
    creating!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从介绍 Lisp 的各种方言开始。然后我们将简要讨论 ANSI Common Lisp，这是我们将在本书中使用的方言。最后，你将开始安装和测试 CLISP，这是
    ANSI Common Lisp 的实现，它将允许你运行你将要创建的所有 Lisp 游戏！
- en: Lisp Dialects
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp 方言
- en: 'Any language that obeys the central principles of Lisp is considered a Lisp
    dialect. Since these principles are so simple, it’s not surprising that literally
    hundreds of dialects of Lisp have been created. In fact, since so many budding
    Lispers create their own Lisp dialect as an exercise, there may be *thousands*
    of partially completed Lisps slumbering in long-abandoned directories on hard
    drives across the planet. However, the vast majority of the Lisp community uses
    two Lisps: ANSI Common Lisp (often abbreviated CL) and Scheme.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何遵循 Lisp 核心原则的语言都被认为是 Lisp 方言。由于这些原则非常简单，所以毫不奇怪，实际上已经创建了数百种 Lisp 方言。实际上，由于许多初学者将创建自己的
    Lisp 方言作为练习，因此可能存在成千上万的未完成 Lisp 正在沉睡在地球上各个硬盘驱动器上被长期遗弃的目录中。然而，Lisp 社区的绝大多数人使用两种
    Lisp：ANSI Common Lisp（通常缩写为 CL）和 Scheme。
- en: In this book, we’ll be talking exclusively about the ANSI Common Lisp dialect,
    the slightly more popular of the two. Nevertheless, most of the knowledge you’ll
    gain from reading this book will also be relevant to Scheme (although the names
    of functions tend to differ somewhat between the dialects).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将专门讨论 ANSI Common Lisp 方言，这是两者中稍微更受欢迎的一个。尽管如此，你从阅读这本书中获得的大部分知识也将与 Scheme
    相关（尽管函数名称在方言之间可能略有不同）。
- en: A Tale of Two Lisps
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两种 Lisp 的故事
- en: Some deep philosophical differences exist between ANSI Common Lisp and Scheme,
    and they appeal to different programmer personalities. Once you learn more about
    Lisp languages, you can decide which dialect you prefer. There is no right or
    wrong choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI Common Lisp 和 Scheme 之间存在一些深层次的哲学差异，它们吸引了不同性格的程序员。一旦你更深入地了解 Lisp 语言，你就可以决定你更喜欢哪种方言。没有绝对的对错之分。
- en: 'To aid you in your decision, I have created the following personality test
    for you:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你做出决定，我为你创建了一个以下的人格测试：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703121.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages703121.png)'
- en: If you chose A, you like raw power in your language. You don’t mind if your
    language is a bit ugly, due to a lot of pragmatic compromises, as long as you
    can still write tight code. ANSI Common Lisp is the best language for you! ANSI
    Common Lisp traces its ancestry most directly from the ancient Lisp dialects,
    built on top of millions of programmer hours, giving it incredibly rich functionality.
    Sure, it has some baroque function names due to countless historical accidents,
    but this Lisp can really fly in the right hacker’s hands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了 A，你喜欢你语言中的原始力量。你并不介意你的语言因为许多实用主义的妥协而显得有些丑陋，只要你能写出紧凑的代码。ANSI Common Lisp
    是最适合你的语言！ANSI Common Lisp 的根源可以追溯到古老的 Lisp 方言，它建立在数百万程序员的辛勤工作之上，使其功能极其丰富。当然，由于无数历史事件，它有一些巴洛克式的函数名称，但这个
    Lisp 真正能在正确的黑客手中翱翔。
- en: If you chose B, you like languages that are clean and elegant. You are more
    interested in fundamental programming problems and are happy to while away on
    a beautiful meadow, contemplating the beauty of your code, occasionally writing
    a research paper on theoretical computing problems. Scheme is the language for
    you! It was created in the mid-1970s by Guy L. Steele and Gerald Jay Sussman and
    involved some soul-searching about the ideal Lisp. Code in Scheme tends to be
    slightly more verbose, since Schemers care more about mathematical purity in their
    code than creating the shortest programs possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了 B，你喜欢干净、优雅的语言。你对基本的编程问题更感兴趣，并且乐于在美丽的草地上消磨时光，思考你代码的美丽，偶尔写一篇关于理论计算问题的研究论文。Scheme
    是适合你的语言！它是在 1970 年代中期由 Guy L. Steele 和 Gerald Jay Sussman 创建的，涉及对理想 Lisp 的深入思考。Scheme
    中的代码通常稍微冗长一些，因为 Schemers 更关心他们代码中的数学纯粹性，而不是创建尽可能短的程序。
- en: 'If you chose C, you’re someone who wants it all: the power of ANSI CL and the
    mathematical beauty of Scheme. At this time, no Lisp dialect completely fits the
    bill, but that could change in the future. One language that might work for you
    (although it is sacrilege to make this claim in a Lisp book) is Haskell. It is
    not considered a Lisp dialect, but its followers obey paradigms popular among
    Lispers, such as keeping the syntax uniform, supporting native lists, and relying
    heavily on higher-order functions. More important, it has an extreme mathematical
    rigor (even more so than Scheme) that allows it to hide very powerful functionality
    under a squeaky clean surface. It’s essentially a wolf in sheep’s clothing. Like
    Lisp, Haskell is a language that any programmer would benefit from investigating
    further.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了C，你是一个想要拥有一切的人：ANSI CL的力量和Scheme的数学美。在这个时候，没有Lisp方言完全符合要求，但这种情况可能会在未来改变。一种可能适合你的语言（尽管在Lisp书中提出这种说法是亵渎的）是Haskell。它不被认为是Lisp方言，但它的追随者遵循Lisper中流行的范式，如保持语法统一，支持原生列表，并大量使用高阶函数。更重要的是，它具有极端的数学严谨性（甚至比Scheme还要严格），这使得它能够在干净利落的外表下隐藏非常强大的功能。它本质上是一只披着羊皮的狼。像Lisp一样，Haskell是一种任何程序员都应进一步调查的语言。
- en: Up-and-Coming Lisps
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新兴的Lisp
- en: As just mentioned, there really isn’t a true Lisp dialect available yet that
    possesses both the power and flexibility of ANSI Common Lisp and the elegance
    of Scheme. However, some new contenders on the horizon may attain the best-of-both-worlds
    crown in the near future.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才提到的，目前还没有一个真正的Lisp方言同时具备ANSI Common Lisp的强大功能和灵活性以及Scheme的优雅性。然而，一些新的竞争者可能在不久的将来获得两者的最佳结合。
- en: One new Lisp that is showing promise is Clojure, a dialect developed by Rich
    Hickey. Clojure is built on the Java platform, allowing it to leverage a lot of
    mature Java libraries right out of the box. Also, Clojure contains some clever
    and well-thought-out features to ease multithreaded programming, which makes it
    a useful tool for programming seemingly ubiquitous multicore CPUs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示出希望的新Lisp是Clojure，这是由Rich Hickey开发的方言。Clojure建立在Java平台之上，允许它直接利用许多成熟的Java库。此外，Clojure包含一些巧妙且经过深思熟虑的特性，以简化多线程编程，这使得它成为编程看似无处不在的多核CPU的有用工具。
- en: Another interesting challenger is Arc. It is a true Lisp language being principally
    developed by Paul Graham, a well-known Lisper. Arc is still in an early stage
    of development, and opinion varies widely on how much of an improvement it is
    over other Lisps. Also, its development has been progressing at a glacially slow
    pace. It will be a while before anyone can say if Arc might be a meaningful contender.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的挑战者是Arc。它是一种真正的Lisp语言，主要由知名的Lisper保罗·格雷厄姆开发。Arc仍处于早期开发阶段，对其相对于其他Lisp的改进程度意见分歧很大。此外，其开发进展缓慢，可能要过一段时间才能有人说出Arc是否可能成为一个有意义的竞争者。
- en: We’ll be dipping our toes in some Arc and Clojure in the epilogue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在结语中，我们将浅尝Arc和Clojure。
- en: Lisp Dialects Used for Scripting
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于脚本编写的Lisp方言
- en: 'Some Lisp dialects are used for scripting, including these:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Lisp方言被用于脚本编写，包括以下这些：
- en: Emacs Lisp is used for scripting inside the popular (and overall awesome) Emacs
    text editor.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emacs Lisp用于在流行的（并且总体上很棒）Emacs文本编辑器内部进行脚本编写。
- en: Guile Scheme is used as a scripting language in several open source applications.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guile Scheme在几个开源应用程序中用作脚本语言。
- en: Script-Fu Scheme is used with the GIMP image editor.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Script-Fu Scheme与GIMP图像编辑器一起使用。
- en: These dialects are forks from older versions of the main Lisp branches and are
    not typically used for creating stand-alone applications. However, they are still
    perfectly respectable dialects of Lisp.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方言是主要Lisp分支的较老版本的分支，通常不用于创建独立的应用程序。然而，它们仍然是完全值得尊重的Lisp方言。
- en: ANSI Common Lisp
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ANSI Common Lisp
- en: In 1981, in order to cope with the dizzying number of dialects of the language,
    members of the varying Lisp communities drafted a specification for a new dialect
    named Common Lisp. In 1986, this language, after further adjustments, was turned
    into the ANSI Common Lisp standard. Many of the developers of older versions of
    Lisp modified their interpreters and compilers to conform to this new standard,
    which became the most popular version of Lisp and remains so to this day.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 1981年，为了应对语言众多方言的令人眼花缭乱的数目，不同Lisp社区的成员起草了一个名为Common Lisp的新方言规范。1986年，经过进一步的调整，这种语言被转化为ANSI
    Common Lisp标准。许多较老版本的Lisp的开发者修改了他们的解释器和编译器以符合这个新标准，这成为了最流行的Lisp版本，并且至今仍然是。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, the term *Common Lisp* refers to the version of Common
    Lisp defined by the ANSI standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，术语**Common Lisp**指的是ANSI标准定义的Common Lisp版本。
- en: A key design goal with Common Lisp was to create a *multiparadigm language*,
    meaning it includes support for many different styles of programming. You’ve probably
    heard of *object-oriented programming*, which can be done quite nicely in Common
    Lisp. Other programming styles you may not have heard of before include *functional
    programming, generic programming*, and *domain-specific language programming*.
    These are all well supported within Common Lisp. You’ll be learning about each
    of these styles, along with others, as we progress through this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp的一个关键设计目标是创建一个**多范式语言**，这意味着它支持许多不同的编程风格。你可能听说过**面向对象编程**，这在Common
    Lisp中可以做得相当不错。其他你可能之前没有听说过的编程风格包括**函数式编程、泛型编程**和**领域特定语言编程**。这些在Common Lisp中都有很好的支持。随着我们继续阅读本书，你将学习到这些风格以及其他风格。
- en: Getting Started with CLISP
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLISP入门
- en: 'Many great Lisp compilers are available, but one in particular is easiest to
    get started with: CLISP, an open source Common Lisp. CLISP is simple to install
    and runs on any operating system.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的Lisp编译器可用，但其中一个特别容易入门：CLISP，一个开源的Common Lisp。CLISP易于安装，可在任何操作系统上运行。
- en: Other popular Lisps include Steel Bank Common Lisp (SBCL), a fast Common Lisp
    that’s considered a bit more heavy-duty than CLISP and also open source; Allegro
    Common Lisp, a powerful commercial Lisp by Franz, Inc; LispWorks; Clozure CL;
    and CMUCL. Mac users may want to consider LispWorks or Clozure CL, which will
    be easier to get running on their machines. However, for our purposes, CLISP is
    the best choice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的Lisp包括Steel Bank Common Lisp (SBCL)，这是一个比CLISP更强大的快速Common Lisp，也是开源的；Franz,
    Inc的强大商业Lisp Allegro Common Lisp；LispWorks；Clozure CL；和CMUCL。Mac用户可能想考虑LispWorks或Clozure
    CL，这些在他们的机器上运行起来会更容易。然而，就我们的目的而言，CLISP是最好的选择。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with [Chapter 12](ch13.html "Chapter 12. Working with Streams"), we’ll
    be using some CLISP-specific commands that are considered nonstandard. However,
    up until that point, any implementation of Common Lisp will work for running the
    examples in this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第12章](ch13.html "第12章。处理流")开始，我们将使用一些被认为是非标准的CLISP特定命令。然而，在此之前，任何Common Lisp的实现都可以用于运行本书中的示例。
- en: Installing CLISP
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装CLISP
- en: You can download a CLISP installer from [http://clisp.cons.org/](http://clisp.cons.org/).
    It will run on Windows PCs, Macs, and Linux variants. On a Windows PC, you simply
    run an install program. On a Mac, there are some additional steps, which are detailed
    on the website.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://clisp.cons.org/](http://clisp.cons.org/)下载CLISP安装程序。它可以在Windows
    PC、Mac和Linux变种上运行。在Windows PC上，你只需运行安装程序。在Mac上，有一些额外的步骤，这些步骤在网站上都有详细说明。
- en: On a Debian-based Linux machine, you should find that CLISP already exists in
    your standard sources. Just type **`apt-get install clisp`** at the command line,
    and you’ll have CLISP installed automatically.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Debian的Linux机器上，你应该会发现CLISP已经存在于你的标准源中。只需在命令行中输入**`apt-get install clisp`**，CLISP就会自动安装。
- en: For other Linux distributions (Fedora, SUSE, and so on), you can use standard
    packages listed under “Linux packages” on the CLISP website. And experienced Linux
    users can compile CLISP from source.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他Linux发行版（Fedora、SUSE等），你可以使用CLISP网站上列出的“Linux软件包”下的标准软件包。经验丰富的Linux用户可以从源代码编译CLISP。
- en: Starting Up CLISP
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动CLISP
- en: 'To run CLISP, type **`clisp`** from your command line. If all goes according
    to plan, you’ll see the following prompt:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行CLISP，从你的命令行输入**`clisp`**。如果一切顺利，你会看到以下提示：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Like all Common Lisp environments, CLISP will automatically place you into a
    *read-eval-print loop* (*REPL*) after you start it up. This means you can immediately
    start typing in Lisp code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有Common Lisp环境一样，CLISP启动后会自动将你放入一个**读取-评估-打印循环**（REPL）。这意味着你可以立即开始输入Lisp代码。
- en: 'Try it out by typing **`(+ 3 (* 2 4))`**. You’ll see the result printed below
    the expression:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入**`(+ 3 (* 2 4))`**来试一试。你会在表达式下方看到打印出的结果：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This shows how the REPL works. You type in an expression, and then the Lisp
    will immediately evaluate it and return the resulting value. When you want to
    shut down CLISP, just type **`(quit)`**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了REPL的工作方式。你输入一个表达式，然后Lisp会立即评估它并返回结果值。当你想要关闭CLISP时，只需输入**`(quit)`**。
- en: Now that you have CLISP working on your computer, you’re ready to write a Lisp
    game!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在电脑上安装了CLISP，你就可以开始编写Lisp游戏了！
- en: What You've Learned
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we discussed the different dialects of Lisp and installing
    CLISP. You learned the following along the way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了 Lisp 的不同方言和安装 CLISP。在过程中，你学习了以下内容：
- en: 'There are two main dialects of Lisp: Common Lisp and Scheme. Both have a lot
    to offer, but we’ll focus on Common Lisp in this book.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp 有两个主要的方言：Common Lisp 和 Scheme。两者都有很多优点，但在这本书中，我们将重点关注 Common Lisp。
- en: Common Lisp is a multiparadigm language, meaning that it supports many different
    programming styles.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Common Lisp 是一种多范式语言，这意味着它支持许多不同的编程风格。
- en: CLISP is a Common Lisp implementation that is easy to set up, making it a great
    choice for a Lisp novice.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLISP 是一个易于设置的 Common Lisp 实现，这使得它成为 Lisp 新手的绝佳选择。
- en: You can type in Lisp commands directly from the CLISP *REPL*.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以直接在 CLISP 的 *REPL* 中输入 Lisp 命令。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703123.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703123.png.jpg)'
- en: Chapter 2. Creating Your First Lisp Program
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 创建你的第一个 Lisp 程序
- en: Now that we’ve discussed some of the philosophy of Lisp and have a running CLISP
    environment, we’re ready to write some actual Lisp code in the form of a simple
    game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了一些 Lisp 的哲学思想，并且有一个运行的 CLISP 环境，我们就准备好编写一些实际的 Lisp 代码，形式为一个简单的游戏。
- en: The Guess-My-Number Game
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猜数字游戏
- en: This first game we’ll write is pretty much the simplest game imaginable. It’s
    the classic guess-my-number game.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第一个游戏几乎是想象中最简单的游戏。它是经典的猜数字游戏。
- en: In this game, you pick a number from 1 to 100, and the computer has to guess
    it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，你从 1 到 100 中选择一个数字，然后电脑必须猜出它。
- en: The following shows what game play might look like if you pick the number 23\.
    The computer starts by guessing 50, and with each successive guess, you enter
    `(smaller)` or `(bigger)` until the computer guesses your number.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了如果你选择数字 23，游戏玩法可能的样子。电脑首先猜测 50，然后每次连续猜测，你输入`(smaller)`或`(bigger)`，直到电脑猜出你的数字。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create this game, we need to write three functions: `guess-my-number`, `smaller`,
    and `bigger`. The player simply calls these functions from the REPL. As you saw
    in the previous chapter, when you start CLISP (or any other Lisp), you are presented
    with the REPL, from which the commands you type will be *read*, then *evaluated*,
    and finally *printed*. In this case, we’re running the commands `guess-my-number`,
    `smaller`, and `bigger`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个游戏，我们需要编写三个函数：`guess-my-number`、`smaller`和`bigger`。玩家只需从 REPL 中调用这些函数。正如你在上一章中看到的，当你启动
    CLISP（或任何其他 Lisp）时，你会看到一个 REPL，你输入的命令将在这里被*读取*，然后*评估*，最后*打印*。在这种情况下，我们正在运行`guess-my-number`、`smaller`和`bigger`这些命令。
- en: To call a function in Lisp, you put parentheses around it, along with any parameters
    you wish to give the function. Since these particular functions don’t require
    any parameters, we simply surround their names in parentheses when we enter them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lisp 中调用函数时，你需要在其周围加上括号，以及你希望传递给函数的任何参数。由于这些特定的函数不需要任何参数，我们在输入时只需将它们的名称用括号括起来即可。
- en: 'Let’s think about the strategy behind this simple game. After a little thought,
    we come up with the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考这个简单游戏背后的策略。经过一番思考，我们得出以下步骤：
- en: Determine the upper and lower (big and small) limit of the player’s number.
    Since the range is between 1 and 100, the smallest possible number would be 1
    and the biggest would be 100.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定玩家数字的上限和下限（大和小）。由于范围在 1 到 100 之间，最小的可能数字是 1，最大的数字是 100。
- en: Guess a number in between these two numbers.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两个数字之间猜一个数字。
- en: If the player says the number is smaller, lower the big limit.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家说数字更小，降低大限。
- en: If the player says the number is bigger, raise the small limit.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家说数字更大，提高小限。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703125.png.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703125.png.jpg)'
- en: By following these simple steps, cutting the range of possible numbers in half
    with every guess, the computer can quickly hone in on the player’s number.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些简单的步骤，每次猜测都将可能数字的范围减半，电脑可以快速缩小范围，找到玩家的数字。
- en: This type of search is called a *binary search*. As you may know, binary searches
    like this are used all the time in computer programming. You could follow these
    same steps, for instance, to efficiently find a specific number given a sorted
    table of values. In that case, you would simply track the smallest and largest
    row in that table, and then quickly hone in on the correct row in an analogous
    manner.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的搜索被称为**二分搜索**。正如你可能知道的，这种二分搜索在计算机编程中经常被使用。例如，你可以遵循这些相同的步骤，以高效地找到给定有序值表中的特定数字。在这种情况下，你只需跟踪表中最大和最小的行，然后以类似的方式快速定位到正确的行。
- en: Defining Global Variables in Lisp
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Lisp 中定义全局变量
- en: As the player calls the functions that make up our game, the program will need
    to track the small and big limits. In order to do this, we’ll need to create two
    global variables called `*small*` and `*big*`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家调用构成我们游戏的功能时，程序需要跟踪小和大限制。为了做到这一点，我们需要创建两个名为 `*small*` 和 `*big*` 的全局变量。
- en: Defining the small and big Variables
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义小变量和大变量
- en: 'A variable that is defined globally in Lisp is called a *top-level definition*.
    We can create new top-level definitions with the `defparameter` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lisp 中，全局定义的变量被称为**顶层定义**。我们可以使用 `defparameter` 函数来创建新的顶层定义：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function name `defparameter` is a bit confusing, since it doesn’t really
    have anything to do with parameters. What it does is let you define a *global
    variable*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名 `defparameter` 有点令人困惑，因为它实际上与参数没有什么关系。它所做的只是让你定义一个**全局变量**。
- en: The first argument we send to `defparameter` is the name of the new variable.
    The asterisks surrounding the names `*big*` and `*small*`—affectionately called
    *earmuffs*—are completely arbitrary and optional. Lisp sees the asterisks as part
    of the variable names and ignores them. Lispers like to mark all their global
    variables in this way as a convention, to make them easy to distinguish from local
    variables, which are discussed later in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送给 `defparameter` 的第一个参数是新变量的名称。围绕 `*big*` 和 `*small*` 名称的星号——亲切地称为**耳罩**——是完全任意和可选的。Lisp
    将星号视为变量名称的一部分，并忽略它们。Lispers 喜欢以这种方式标记所有全局变量，作为一种约定，以便于区分它们，这些将在本章后面讨论。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although earmuffs may be “optional” in a strictly technical sense, I suggest
    that you use them. I cannot vouch for your safety if you ever post any code to
    a Common Lisp newsgroup and your global variables are missing their earmuffs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在严格的技术意义上耳罩可能是“可选的”，但我建议你使用它们。如果你在 Common Lisp 新闻组中发布任何代码，并且你的全局变量缺少耳罩，我无法保证你的安全。
- en: An Alternative Global Variable Definition Function
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个全局变量定义函数的替代方案
- en: 'When you set the value of a global variable using `defparameter`, any value
    previously stored in the variable will be overwritten:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `defparameter` 设置全局变量的值时，任何先前存储在变量中的值都将被覆盖：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, when we redefine the variable `*foo*`, its value changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们重新定义变量 `*foo*` 时，其值会发生变化。
- en: 'Another command that you can use for declaring global variables, called `defvar`,
    won’t overwrite previous values of a global variable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另一个用于声明全局变量的命令，称为 `defvar`，它不会覆盖全局变量的先前值：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some Lispers prefer to use `defvar` instead of `defparameter` when defining
    global variables. In this book, however, we’ll be using `defparameter` exclusively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Lisp 程序员在定义全局变量时更喜欢使用 `defvar` 而不是 `defparameter`。然而，在这本书中，我们将仅使用 `defparameter`。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you read about Lisp in other places, you may also see programmers using
    the term *dynamic variable* or *special variable* when referring to a global variable
    in Common Lisp. This is because global variables in Common Lisp have some special
    abilities, which we’ll be discussing in future chapters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在其他地方阅读关于 Lisp 的内容时，你也可能会看到程序员在提到 Common Lisp 中的全局变量时使用术语**动态变量**或**特殊变量**。这是因为
    Common Lisp 中的全局变量有一些特殊的能力，我们将在未来的章节中讨论。
- en: Basic Lisp Etiquette
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本Lisp 礼仪
- en: 'The way commands are called and the way code is formatted in Lisp is somewhat
    strange compared with other languages. First of all, you need to surround the
    command (and its arguments) with parentheses, as with the `defparameter` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言相比，Lisp 中调用命令和代码格式化的方式有些奇怪。首先，你需要用括号包围命令（及其参数），就像 `defparameter` 函数一样：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Without the parentheses, a command will not be called.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有括号，命令将不会被调用。
- en: 'Also, spaces and line breaks are completely ignored when Lisp reads in your
    code. That means you could call this command in any crazy way, with the same result:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当Lisp读取你的代码时，会完全忽略空格和换行符。这意味着你可以以任何疯狂的方式调用这个命令，结果相同：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because Lisp code can be formatted in such flexible ways, Lispers have a lot
    of conventions for formatting commands, including when to use multiple lines and
    indentation. We’ll loosely follow some of the common indentation conventions in
    the code examples in this book. However, we’re more interested in writing games
    than in discussing source code indentation rules, so we’re not going to be spending
    too much time on code layout rules in this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lisp代码可以以如此灵活的方式格式化，Lispers有很多关于格式化命令的约定，包括何时使用多行和缩进。我们将松散地遵循本书中代码示例中的一些常见缩进约定。然而，我们更感兴趣的是编写游戏而不是讨论源代码缩进规则，所以我们不会在本书中花费太多时间在代码布局规则上。
- en: Defining Global Functions in Lisp
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Lisp中定义全局函数
- en: 'Our guess-my-number game has the computer respond to the player’s request to
    start the game, and then to requests for either smaller or bigger guesses. For
    these, we need to define three global functions: `guess-my-number`, `smaller`,
    and `bigger`. We’ll also define a function to start over with a different number,
    called `start-over`. In Common Lisp, functions are defined with `defun`, like
    this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`guess-my-number`游戏让计算机响应玩家请求开始游戏，以及请求更小或更大的猜测。为此，我们需要定义三个全局函数：`guess-my-number`、`smaller`和`bigger`。我们还将定义一个用于以不同数字重新开始游戏的函数，称为`start-over`。在Common
    Lisp中，函数使用`defun`定义，如下所示：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we specify the name and arguments for the function. Then we follow it
    up with the code that composes the function’s logic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定函数的名称和参数。然后我们跟上组成函数逻辑的代码。
- en: Defining the guess-my-number Function
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义`guess-my-number`函数
- en: 'The first function we’ll define is `guess-my-number`. This function uses the
    values of the `*big*` and `*small*` variables to generate a guess of the player’s
    number. The definition looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要定义的第一个函数是`guess-my-number`。这个函数使用`*big*`和`*small*`变量的值来生成玩家的数字猜测。定义看起来像这样：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The empty parentheses, `()`, after the function name `guess-my-number` indicate
    that this function doesn’t require any parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名`guess-my-number`后面的空括号`()`表示这个函数不需要任何参数。
- en: Although you don’t need to worry about indentation or line breaks when entering
    code snippets at the REPL, you must be sure to place parentheses correctly. If
    you forget a parenthesis or put one in the wrong place, you’ll most likely get
    an error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不需要在REPL中输入代码片段时担心缩进或换行符，但你必须确保正确放置括号。如果你忘记了一个括号或将其放在错误的位置，你很可能会得到一个错误。
- en: Whenever we run a piece of code like this in the REPL, the resulting value of
    the entered expression will be printed. Every command in Common Lisp generates
    a return value. The `defun` command, for instance, simply returns the name of
    the newly created function. This is why we see the name of the function parroted
    back to us in the REPL after we call `defun` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在这个REPL中运行这样的代码片段时，输入表达式的结果值将被打印出来。Common Lisp中的每个命令都会生成一个返回值。例如，`defun`命令只是返回新创建函数的名称。这就是为什么我们在调用`defun`后在REPL中看到函数名称被重复输出![图片链接](httpatomoreillycomsourcenostarchimages783562.png)。
- en: What does this function do? As discussed earlier, the computer’s best guess
    in this game will be a number in between the two limits. To accomplish this, we
    choose the average of the two limits. However, if the average number ends up being
    a fraction, we’ll want to use a near-average number, since we’re guessing only
    whole numbers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数做什么？如前所述，在这个游戏中，计算机的最佳猜测将是两个极限之间的一个数字。为了实现这一点，我们选择两个极限的平均值。然而，如果平均数最终变成一个分数，我们希望使用接近平均的数字，因为我们只猜测整数。
- en: We implement this in the `guess-my-number` function by first adding the numbers
    that represent the high and low limits, then using the arithmetic shift function,
    `ash`, to halve the sum of the limits and shorten the result. The code `(+ *small*
    *big*)` adds together those two variables. Because the addition happens within
    another function call, ![](httpatomoreillycomsourcenostarchimages783564.png),
    the resulting sum is then passed to the `ash` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`guess-my-number`函数中实现这一点，首先加上代表高限和低限的数字，然后使用算术移位函数`ash`将极限的总和减半并缩短结果。代码`(+
    *small* *big*)`将这两个变量相加。因为加法发生在另一个函数调用中，![图片链接](httpatomoreillycomsourcenostarchimages783564.png)，所以得到的总和随后传递给`ash`函数。
- en: The parentheses surrounding the `ash` function and the addition (`+`) function
    are mandatory in Lisp. These parentheses are what tell Lisp, “I want you to call
    this function.”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lisp中，包围`ash`函数和加法(`+`)函数的括号是强制性的。这些括号告诉Lisp，“我想调用这个函数。”
- en: 'The built-in Lisp function `ash` looks at a number in binary form, and then
    shifts its binary bits to the left or right, dropping any bits lost in the process.
    For example, the number 11 written in binary is 1011\. We can move the bits in
    this number to the left with `ash` by using `1` as the second argument:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Lisp函数`ash`查看一个以二进制形式表示的数字，然后将其二进制位向左或向右移动，丢弃在过程中丢失的任何位。例如，数字11以二进制形式表示为1011。我们可以使用`ash`将这个数字的位向左移动，通过将`1`作为第二个参数使用：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This produces 22, which is 10110 in binary. We can move the bits to the right
    (and lop off the bit on the end) by passing in `−1` as the second argument:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了22，这在二进制中是10110。我们可以通过将`-1`作为第二个参数传递来将位向右移动（并去掉末尾的位）：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This produces 5, which is 101 in binary.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了5，这在二进制中是101。
- en: By using the `ash` function in `guess-my-number`, we are continually halving
    our search space of possible numbers to quickly narrow down to the final correct
    number. As already mentioned, this halving process is called a *binary search*,
    a useful technique in computer programming. The ash function is commonly used
    for such binary searches in Lisp.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`guess-my-number`中使用`ash`函数，我们不断地将可能的数字搜索空间减半，以快速缩小到正确的最终数字。如前所述，这个过程称为*二分搜索*，是计算机编程中的一个有用技术。在Lisp中，ash函数通常用于此类二分搜索。
- en: 'Let’s see what happens when we call our new function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调用我们新函数时会发生什么：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since this is our first guess, the output we see when calling this function
    tells us that everything is working as planned: The program picked the number
    50, right in between 1 and 100.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次猜测，调用此函数时看到的输出告诉我们一切按计划进行：程序选择了数字50，正好位于1和100之间。
- en: 'When programming in Lisp, you’ll write many functions that won’t explicitly
    print values on the screen. Instead, they’ll simply return the value calculated
    in the body of the function. For instance, let’s say we wanted a function that
    just returns the number 5\. Here’s how we could write this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当用Lisp编程时，你会编写许多不会在屏幕上显式打印值的函数。相反，它们会简单地返回函数体中计算出的值。例如，假设我们想要一个只返回数字5的函数。我们可以这样编写这个函数：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because the value calculated in the body of the function ![](httpatomoreillycomsourcenostarchimages783564.png)
    evaluates to 5, calling `(return-five)` will just return 5.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数体中计算出的值![http://atomoreilly.com/source/nostarch/images/783564.png](http://atomoreilly.com/source/nostarch/images/783564.png)等于5，调用`(return-five)`将只返回5。
- en: This is how `guess-my-number` is designed. We see this calculated result on
    the screen (the number 50) not because the function causes the number to display,
    but because this is a feature of the REPL.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`guess-my-number`的设计方式。我们在屏幕上看到这个计算结果（数字50），并不是因为函数导致数字显示，而是因为这是REPL的一个特性。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ve used other programming languages before, you may remember having to
    write something like `return...` to cause a value to be returned. In Lisp, this
    is not necessary. The final value calculated in the body of the function is returned
    automatically.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过其他编程语言，你可能记得必须写一些像`return...`这样的东西来返回一个值。在Lisp中，这并不是必要的。函数体中计算出的最终值会自动返回。
- en: Defining the smaller and bigger Functions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义`smaller`和`bigger`函数
- en: 'Now we’ll write our `smaller` and `bigger` functions. Like `guess-my-number`,
    these are global functions defined with `defun`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写我们的`smaller`和`bigger`函数。像`guess-my-number`一样，这些是通过`defun`定义的全局函数：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we use `defun` to start the definition of a new global function `smaller.`
    Because this function takes no parameters, the parentheses are empty ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`defun`开始定义一个新的全局函数`smaller`。因为这个函数没有参数，所以括号是空的![http://atomoreilly.com/source/nostarch/images/783564.png]。
- en: 'Next, we use the `setf` function to change the value of our global variable
    `*big*` ![](httpatomoreillycomsourcenostarchimages783562.png). Since we know the
    number must be smaller than the last guess, the biggest it can now be is one less
    than that guess. The code `(1- (guess-my-number)`) calculates this: It first calls
    our `guess-my-number` function to get the most recent guess, and then it uses
    the function `1-`, which subtracts 1 from the result.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `setf` 函数来更改全局变量 `*big*` 的值 ![http://atomoreilly.com/source/nostarch/images/783562.png]。由于我们知道数字必须小于上一次猜测，它现在可能的最大值是比那次猜测少一个。代码
    `(1- (guess-my-number))` 计算这个值：它首先调用我们的 `guess-my-number` 函数以获取最新的猜测，然后使用 `1-`
    函数，该函数从结果中减去 1。
- en: Finally, we want our `smaller` function to show us a new guess. We do this by
    putting a call to `guess-my-number` as the final line in the function body ![](httpatomoreillycomsourcenostarchimages783560.png).
    This time, `guess-my-number` will use the updated value of `*big*`, causing it
    to calculate the next guess. The final value of our function will be returned
    automatically, causing our new guess (generated by `guess-my-number`) to be returned
    by the `smaller` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望 `smaller` 函数显示一个新的猜测。我们通过在函数体中将 `guess-my-number` 的调用作为最后一行来实现这一点 ![http://atomoreilly.com/source/nostarch/images/783560.png]。这次，`guess-my-number`
    将使用更新后的 `*big*` 值，导致它计算下一个猜测。函数的最终值将自动返回，导致由 `guess-my-number` 生成的新的猜测（`smaller`
    函数返回的）。
- en: The `bigger` function works in exactly the same manner, except that it raises
    the `*small*` value instead. After all, if you call the `bigger` function, you
    are saying your number is bigger than the previous guess, so the smallest it can
    now be (which is what the `*small*` variable represents) is *one more* than the
    previous guess. The function `1+` simply adds 1 to the value returned by `guess-my-number`
    ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`bigger` 函数的工作方式完全相同，只是它提高了 `*small*` 的值。毕竟，如果您调用 `bigger` 函数，您是在说您的数字比上一次猜测大，所以现在可能的最小值（即
    `*small*` 变量所代表的值）是比上一次猜测多一个。函数 `1+` 简单地将 1 加到 `guess-my-number` 返回的值上。'
- en: 'Here we see our functions in action, with the number 56 as our guess:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们的函数正在发挥作用，我们的猜测数字是 56：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Defining the start-over Function
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 `start-over` 函数
- en: 'To complete our game, we’ll add the function `start-over` to reset our global
    variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的游戏，我们将添加 `start-over` 函数来重置我们的全局变量：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the `start-over` function resets the values of `*small*` and
    `*big*` and then calls `guess-my-number` again to return a new starting guess.
    Whenever you want to start a brand-new game with a different number, you can call
    this function to reset the game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`start-over` 函数会重置 `*small*` 和 `*big*` 的值，然后再次调用 `guess-my-number` 函数以返回一个新的起始猜测。无论您想用不同的数字开始全新的游戏，都可以调用此函数来重置游戏。
- en: Defining Local Variables in Lisp
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Lisp 中定义局部变量
- en: For our simple game, we’ve defined global variables and functions. However,
    in most cases you’ll want to limit your definitions to a single function or a
    block of code. These are called *local* variables and functions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单游戏，我们已经定义了全局变量和函数。然而，在大多数情况下，您可能希望将定义限制在单个函数或代码块中。这些被称为 *局部* 变量和函数。
- en: 'To define a local variable, use the command `let`. A `let` command has the
    following structure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义局部变量，请使用 `let` 命令。一个 `let` 命令具有以下结构：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first thing inside the `let` command is a list of variable declarations
    ![](httpatomoreillycomsourcenostarchimages783564.png). This is where we can declare
    one or more local variables. Then, in the body of the command (and only within
    this body), we can use these variables ![](httpatomoreillycomsourcenostarchimages783562.png).
    Here is an example of the `let` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 命令中的第一件事是一系列变量声明 ![http://atomoreilly.com/source/nostarch/images/783564.png]。这是我们声明一个或多个局部变量的地方。然后，在命令的主体中（并且仅在此主体中），我们可以使用这些变量
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。以下是一个 `let` 命令的示例：'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we’ve declared the values `5` and `6` for the variables `a`
    ![](httpatomoreillycomsourcenostarchimages783564.png) and `b` ![](httpatomoreillycomsourcenostarchimages783562.png),
    respectively. These are our variable declarations. Then, in the body of the `let`
    command, we added them together ![](httpatomoreillycomsourcenostarchimages783560.png),
    resulting in the displayed value of `11`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们分别为变量 `a` ![http://atomoreilly.com/source/nostarch/images/783564.png]
    和 `b` ![http://atomoreilly.com/source/nostarch/images/783562.png] 声明了值 `5` 和 `6`。这些都是我们的变量声明。然后，在
    `let` 命令的主体中，我们将它们相加 ![http://atomoreilly.com/source/nostarch/images/783560.png]，得到显示的值
    `11`。
- en: When using a let expression, you must surround the entire list of declared variables
    with parentheses. Also, you must surround each pair of variable names and initial
    variables with another set of parentheses.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 let 表达式时，你必须用括号包围声明的变量列表。此外，你必须用另一组括号包围每一对变量名和初始变量。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the indentation and line breaks are completely arbitrary, because the
    names of the variables and their values in a `let` expression form a kind of simple
    table, common practice is to align the declared variables vertically. This is
    why the `b` is placed directly underneath the `a` in the preceding example.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管缩进和换行完全是任意的，因为 `let` 表达式中的变量及其值形成了一种简单的表格，常见的做法是将声明的变量垂直对齐。这就是为什么在先前的例子中 `b`
    直接位于 `a` 之下的原因。
- en: Defining Local Functions in Lisp
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Lisp 中定义局部函数
- en: 'We define local functions using the `flet` command. The `flet` command has
    the following structure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `flet` 命令来定义局部函数。`flet` 命令具有以下结构：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At the top of the `flet`, we declare a function (in the first two lines). This
    function will then be available to us in the body ![](httpatomoreillycomsourcenostarchimages783560.png).
    A function declaration consists of a function name, the arguments to that function
    ![](httpatomoreillycomsourcenostarchimages783564.png), and the function body ![](httpatomoreillycomsourcenostarchimages783562.png),
    where we put the function’s code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `flet` 的顶部，我们声明一个函数（在前两行）。然后这个函数将在主体中对我们可用 ![http://atomoreilly.com/source/nostarch/images/783560.png]。函数声明由函数名、该函数的参数
    ![http://atomoreilly.com/source/nostarch/images/783564.png]，以及函数体 ![http://atomoreilly.com/source/nostarch/images/783562.png]，我们在其中放置函数的代码。
- en: 'Here is an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we define a single function, `f`, which takes a single argument,
    `n` ![](httpatomoreillycomsourcenostarchimages783564.png). The function `f` then
    adds `10` to this variable `n` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which has been passed in it. Then we call this function with the number `5` as
    the argument, causing the value `15` to be returned ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个单独的函数 `f`，它接受一个参数 `n` ![http://atomoreilly.com/source/nostarch/images/783564.png]。函数
    `f` 然后将 `10` 添加到这个变量 `n` ![http://atomoreilly.com/source/nostarch/images/783562.png]，它已经传入。然后我们用数字
    `5` 作为参数调用这个函数，导致返回值 `15` ![http://atomoreilly.com/source/nostarch/images/783560.png]。
- en: As with `let`, you can define one or more functions within the scope of the
    `flet`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `let` 一样，你可以在 `flet` 的作用域内定义一个或多个函数。
- en: 'A single `flet` command can be used to declare multiple local functions at
    once. Simply add multiple function declarations in the first part of the command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 `flet` 命令可以一次声明多个局部函数。只需在命令的第一部分添加多个函数声明：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we have declared two functions: one named `f` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and one named `g` ![](httpatomoreillycomsourcenostarchimages783562.png). In the
    body of the `flet`, we can then refer to both functions. In this example, the
    body first calls `f` with `5` to yield 15, then calls `g` to subtract `3`, leading
    to `12` as a final result.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两个函数：一个名为 `f` ![http://atomoreilly.com/source/nostarch/images/783564.png]
    和一个名为 `g` ![http://atomoreilly.com/source/nostarch/images/783562.png]。在 `flet`
    的主体中，我们可以引用这两个函数。在这个例子中，主体首先用 `5` 调用 `f` 得到 15，然后调用 `g` 减去 `3`，最终结果为 `12`。
- en: 'To make function names available in defined functions, we can use the `labels`
    command. It’s identical in its basic structure to the `flet` command. Here’s an
    example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要使函数名在定义的函数中可用，我们可以使用 `labels` 命令。它在基本结构上与 `flet` 命令相同。以下是一个示例：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the local function `a` adds `5` to a number ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, the function `b` is declared ![](httpatomoreillycomsourcenostarchimages783562.png).
    It calls the function `a`, and then adds `6` to the result ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, the function `b` is called with the value `10` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Since 10 plus 6 plus 5 equals 21, the number 21 becomes the final value of the
    entire expression. The special step that requires us to use `labels` instead of
    `flet` is where the function `b` calls the function `a` ![](httpatomoreillycomsourcenostarchimages783560.png).
    If we had used `flet`, the function `b` would not have “known” about the function
    `a`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，局部函数 `a` 将 `5` 加到一个数字上 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。接下来，声明了函数
    `b` ![图片](httpatomoreillycomsourcenostarchimages783562.png)。它调用了函数 `a`，然后将其结果加上
    `6` ![图片](httpatomoreillycomsourcenostarchimages783560.png)。最后，使用值 `10` 调用了函数
    `b` ![图片](httpatomoreillycomsourcenostarchimages783554.png)。由于 10 加 6 加 5 等于 21，数字
    21 成为整个表达式的最终值。需要使用 `labels` 而不是 `flet` 的特殊步骤是函数 `b` 调用函数 `a` 的地方 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。如果我们使用了
    `flet`，函数 `b` 就不会“知道”函数 `a`。
- en: The `labels` command lets you call one local function from another, and it allows
    you to have a function call itself. This is commonly done in Lisp code and is
    called *recursion*. (You will see many examples of recursion in future chapters.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`labels` 命令允许你从一个局部函数调用另一个局部函数，并允许函数调用自身。这在 Lisp 代码中很常见，被称为 *递归*。（你将在未来的章节中看到许多递归的例子。）'
- en: What You've Learned
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你已经学到的内容
- en: 'In this chapter, we discussed the basic Common Lisp commands for defining variables
    and functions. Along the way, you learned the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了定义变量和函数的基本 Common Lisp 命令。在这个过程中，你学习了以下内容：
- en: To define a global variable, use the `defparameter` command.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定义一个全局变量，使用 `defparameter` 命令。
- en: To define a global function, use the `defun` command.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定义一个全局函数，使用 `defun` 命令。
- en: Use the `let` and `flet` commands to define local variables and functions, respectively.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `let` 和 `flet` 命令分别定义局部变量和函数。
- en: The function `labels` is like `flet`, but it lets functions call themselves.
    Functions that call themselves are called *recursive* functions.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 `labels` 类似于 `flet`，但它允许函数调用自身。调用自身的函数被称为 *递归函数*。
- en: Chapter 3. Exploring the Syntax of Lisp Code
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。探索 Lisp 代码的语法
- en: As you’ve learned so far, Lisp commands must be entered in a rather unorthodox
    way, with parentheses surrounding each command. In this chapter, we’ll explore
    why Lisp works this way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，Lisp 命令必须以一种相当不寻常的方式输入，每个命令周围都有括号。在本章中，我们将探讨 Lisp 为什么会这样工作。
- en: 'To understand why any language—whether it’s a programming language or a human
    language—looks a certain way, we need to begin with two concepts from the field
    of linguistics: syntax and semantics.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么任何语言——无论是编程语言还是人类语言——看起来都有一定的样子，我们需要从语言学领域的两个概念开始：语法和语义。
- en: Syntax and Semantics
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法和语义
- en: 'Here is a typical sentence in the English language:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是英语语言中的一个典型句子：
- en: '| My dog ate my homework. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 我的狗吃了我的作业。 |'
- en: 'This sentence has the correct syntax for a sentence in English. The *syntax*
    of a piece of text represents the basic rules that it needs to follow to be a
    valid sentence. Here are some of the rules of sentences in the English language
    that this text obeys:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个句子具有英语句子正确的语法。文本的 *语法* 代表了它需要遵循的基本规则，才能成为一个有效的句子。以下是一些遵循英语语言规则的句子规则，该文本遵守：
- en: The sentence ends in a punctuation mark.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子以标点符号结束。
- en: The sentence contains a subject and a verb.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子包含主语和谓语。
- en: The sentence is made up of letters in the English alphabet (as opposed to Egyptian
    hieroglyphics or Sumerian cuneiform).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子由英语字母表中的字母组成（与埃及象形文字或苏美尔楔形文字相反）。
- en: However, there is more to a sentence than just its syntax. We also care about
    what the sentence actually means. When we talk about the *semantics* of a sentence,
    we’re referring to its meaning.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，句子不仅仅有语法。我们还关心句子的实际意义。当我们谈论句子的 *语义* 时，我们指的是它的意义。
- en: 'For instance, here are some sentences that all roughly have identical semantics:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一些语义大致相同的句子：
- en: '| My dog ate my homework. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 我的狗吃了我的作业。 |'
- en: '| The canine, which I possess, has consumed my school assignment. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 我拥有的狗吃掉了我的学校作业。 |'
- en: '| Der Hund hat meine Hausarbeit gefressen. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| Der Hund hat meine Hausarbeit gefressen. |'
- en: The first two are just different ways of saying the same thing in English. The
    third sentence is in German, but it still has the same meaning and, hence, semantics
    as the first two.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前两句只是用英语表达相同内容的不同方式。第三句是德语，但它仍然与第一两句具有相同的意义和语义。
- en: 'The same distinction between these two ideas exists in programming languages.
    For instance, here is a valid line of code written in C++:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，这两种想法之间的区别同样存在。例如，这里是一行有效的 C++ 代码：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This line of code obeys the rules of C++ syntax. To make my point, I put in
    a lot of weird syntax that is unique to C++, which differentiates it from other
    languages. If you were to place this line of code in a program of another programming
    language with a different syntax, it would probably be invalid and cause an error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码遵循 C++ 语法的规则。为了说明我的观点，我在其中加入了很多独特的 C++ 语法，这使它与其他语言区分开来。如果你将这一行代码放入另一种具有不同语法的编程语言程序中，它可能无效并引发错误。
- en: Of course, this C++ programming code also means something. If we were to put
    this line of code in a C++ program (in the proper context), it would cause your
    computer to *do* something. The actions that a program performs are the *semantics*
    of the program. It is usually possible to write a program that has the same semantics
    in different programming languages; that is, the program will do the same thing
    in both languages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段 C++ 编程代码也有其意义。如果我们把这一行代码放入一个 C++ 程序中（在适当的环境中），它会使你的电脑 *执行* 一些操作。程序执行的操作是程序的
    *语义*。通常，可以编写在不同的编程语言中具有相同语义的程序；也就是说，程序在这两种语言中都会做同样的事情。
- en: What all this boils down to is that most programming languages have similar
    semantic powers. However, basic Lisp code is different from code in any other
    major programming language in that it has a far simpler syntax. *Having a simple
    syntax is a defining feature of the Lisp language*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些归结起来就是，大多数编程语言具有相似的语义能力。然而，基本的 Lisp 代码与任何其他主要编程语言的代码都不同，因为它具有远为简单的语法。*拥有简单的语法是
    Lisp 语言的一个定义性特征*。
- en: The Building Blocks of Lisp Syntax
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp 语法的基本构建块
- en: From the crazy line of C++ code in the previous section, you can get the idea
    that C++ has a lot of weird syntax—for indicating namespaces, dereferencing pointers,
    performing casts, referencing member functions, performing Boolean operations,
    and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中疯狂的一行 C++ 代码中，你可以得到这样的想法：C++ 有很多奇怪的语法——用于表示命名空间、解引用指针、执行类型转换、引用成员函数、执行布尔操作等等。
- en: If you were to write a C++ compiler, you would need to do a lot of hard work
    so that the compiler could read this code and obey the many C++ syntax rules,
    before you could make any sense of the code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写一个 C++ 编译器，你需要做很多艰苦的工作，以便编译器能够读取这段代码并遵守许多 C++ 语法规则，在你能够理解代码之前。
- en: 'Writing a Lisp compiler or interpreter is much easier. The part of a Lisp compiler
    or interpreter that reads in the code (which Lispers actually call the *reader*)
    is simpler than in C++ or any other major programming language. Take a random
    piece of Lisp code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Lisp 编译器或解释器要容易得多。Lisp 编译器或解释器中读取代码的部分（Lisper 实际上称之为 *reader*）比 C++ 或任何其他主要编程语言都要简单。拿一段随机的
    Lisp 代码：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function declaration, which creates a function that simply squares a number,
    consists of nothing more than parentheses and symbols. In fact, you can view it
    as just a bunch of nested lists, delimited by parentheses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数声明，它创建了一个简单的平方数字的函数，仅由括号和符号组成。实际上，你可以将其视为由括号分隔的一堆嵌套列表。
- en: 'Lisp only has one way of organizing bits of code: It uses parentheses to organize
    the code into *lists*.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 只有一种组织代码片段的方式：它使用括号将代码组织成 *列表*。
- en: 'All basic Lisp code uses this simple list-like syntax:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基本的 Lisp 代码都使用这种简单的类似列表的语法：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781268.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781268.png)'
- en: But what sorts of things can we put into these lists? Well, besides other lists,
    we can also put symbols, numbers, and strings into our code. Here, we’ll look
    at these basic building blocks, or datatypes, you’ll use in Lisp. (We’ll discuss
    many other Common Lisp datatypes in later chapters.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以将这些列表放入哪些类型的事物呢？嗯，除了其他列表，我们还可以将符号、数字和字符串放入我们的代码中。在这里，我们将探讨你在 Lisp 中将使用的这些基本构建块，或者说数据类型。（我们将在后面的章节中讨论许多其他
    Common Lisp 数据类型。）
- en: Symbols
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: '*Symbols* are a fundamental type of data in Lisp and are used extensively.
    A symbol in Lisp is a stand-alone word. Common Lisp symbols are typically made
    up of letters, numbers, and characters like `+ - / * = < > ? ! _`. Some examples
    of valid Lisp symbols are `foo`, `ice9`, `my-killer-app27`, and even `—<<==>>—`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号*是Lisp中的基本数据类型，被广泛使用。Lisp中的符号是一个独立的单词。Common Lisp符号通常由字母、数字和像`+ - / * =
    < > ? ! _`这样的字符组成。一些有效的Lisp符号示例有`foo`、`ice9`、`my-killer-app27`，甚至`—<<==>>—`。'
- en: 'Symbols in Common Lisp are *case-insensitive* (although most Lispers avoid
    using uppercase). To illustrate this, we’ll use a function called `eq`, which
    lets us see if two symbols are identical:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp中的符号是*不区分大小写*的（尽管大多数Lisper避免使用大写）。为了说明这一点，我们将使用一个名为`eq`的函数，它让我们看到两个符号是否相同：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, this function returned `T`, which tells us that Lisp considers
    these two symbols to be identical. (For now, ignore the quotation mark in front
    of the symbols. This will be explained shortly, when we discuss *data mode*.)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数返回了`T`，这告诉我们Lisp认为这两个符号是相同的。（现在忽略符号前面的引号。这将在我们讨论*数据模式*时解释。）
- en: Numbers
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: Lisp supports both floating-point numbers and integers. When you write a number,
    the presence of a decimal point determines whether your number is seen as a floating-point
    number or an integer. The numbers 1 and 1.0 are two different entities in Common
    Lisp.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp支持浮点数和整数。当你写一个数字时，是否存在小数点决定了你的数字被视为浮点数还是整数。在Common Lisp中，数字1和1.0是两个不同的实体。
- en: 'For instance, if you use most math functions with both an integer and a floating-point
    number, the integer will become “poisoned,” and a floating-point number will be
    returned. Here’s a case in point:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用大多数数学函数同时带有整数和浮点数，整数将会变成“中毒”，并返回一个浮点数。以下是一个具体的例子：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the decimal point in the returned number, `2.0`, indicates that it
    is a floating-point number.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，返回的数字`2.0`中的小数点表示它是一个浮点数。
- en: 'Lisp can perform some amazing feats with numbers, especially when compared
    with most other languages. For instance, here we’re using the function `expt`
    to calculate the fifty-third power of 53:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp可以用数字做一些惊人的事情，尤其是与其他大多数语言相比。例如，这里我们使用函数`expt`来计算53的53次方：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Isn’t that cool? Most languages would choke on a calculation involving such
    a large number.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这不酷吗？大多数语言在涉及如此大的数字的计算中都会崩溃。
- en: 'Finally, you should know that something weird could happen if you divide two
    integers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该知道，如果你除以两个整数，可能会发生一些奇怪的事情：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The division function is dividing the 4 by 6\. But instead of returning a fraction
    (0.66666...) as you might expect, it returns a *rational number*, represented
    as two integers with a division symbol between them. So the `2/3` result represents
    a single rational number, which is the mathematically ideal way to encode a fraction
    such as this.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除法函数正在将4除以6。但出乎意料的是，它并没有返回一个分数（0.66666...），而是返回了一个有理数，用两个整数之间的除号表示。所以`2/3`的结果代表了一个单一的有理数，这是在数学上编码这种分数的理想方式。
- en: 'Note that we get a different answer if there is a floating-point number in
    our calculation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们的计算中有浮点数，我们会得到不同的答案：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As in the previous example, the number with the decimal point (`4.0`) has poisoned
    our numbers to give us a fraction as a result.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，带有小数点的数字（`4.0`）使我们的数字“中毒”，给出了一个分数作为结果。
- en: If you’re not a math geek, this might not be of much use to you, but at least
    you now know what’s happening if you see this sort of thing while you’re coding.
    You can also rest assured that Lisp will do the right thing with this number when
    you use it later on in another calculation. Lisp is smart.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是数学爱好者，这可能对你没有太大帮助，但至少你现在知道，当你编码时看到这种事情时发生了什么。你也可以放心，当你稍后在另一个计算中使用这个数字时，Lisp会正确处理这个数字。Lisp很聪明。
- en: Strings
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: The last basic building block in Lisp is the *string*. Although strings aren’t
    really that fundamental to Lisp from a theoretical standpoint, any program that
    communicates with a human will usually need strings, because humans like to communicate
    with text.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp是最后一个基本构建块是字符串。虽然从理论角度来看，字符串并不是Lisp的基础，但任何与人类通信的程序通常都需要字符串，因为人类喜欢用文本进行交流。
- en: To indicate a string in Lisp, surround characters with double quotes. For example,
    `"Tutti Frutti"` is a valid string.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lisp中表示字符串时，用双引号包围字符。例如，`"Tutti Frutti"`是一个有效的字符串。
- en: 'We can display a string using a function called `princ`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个名为 `princ` 的函数来显示字符串：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that printing our text at the REPL^([[1](#ftn.CHP-3-FN-1)]) will cause
    the text to appear twice. First, we see the actual printing caused by the `princ`
    command ![](httpatomoreillycomsourcenostarchimages783564.png). However, since
    the REPL will always show the result of evaluating the entered expression, we
    see our string parroted back to us ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is because the `princ` function also returns a value, which happens to be
    the source string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 REPL 中打印我们的文本会导致文本出现两次。首先，我们看到由 `princ` 命令引起的实际打印![](httpatomoreillycomsourcenostarchimages783564.png)。然而，由于
    REPL 总是显示输入表达式的评估结果，所以我们看到我们的字符串被重复显示![](httpatomoreillycomsourcenostarchimages783562.png)。这是因为
    `princ` 函数也返回一个值，恰好是源字符串。
- en: 'A string can also contain so-called *escaped characters*. If you want a string
    to include double quotes or a backslash, you’ll need to prefix these characters
    with a backslash. For example, this string has two escaped quotes:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以包含所谓的*转义字符*。如果你想让字符串包含双引号或反斜杠，你需要在这些字符前加上反斜杠。例如，这个字符串包含两个转义引号：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the backslashes in front of the two quotes tell Lisp that these
    are literal quotation marks in the string, shown in the displayed string just
    like any other character.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两个引号前的反斜杠告诉 Lisp 这些是在字符串中的字面引号，就像显示的字符串中的任何其他字符一样。
- en: '* * *'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-3-FN-1)]) As discussed in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Lisp Program"), in a read-eval-print loop (or REPL), the functions
    we enter will be read, then evaluated, and finally printed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-3-FN-1)]) 如同在[第 2 章](ch02.html "第 2 章。创建您的第一个 Lisp 程序")中讨论的那样，在读取-评估-打印循环（或
    REPL）中，我们输入的函数将被读取，然后评估，最后打印出来。
- en: How Lisp Distinguishes Between Code and Data
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp 如何区分代码和数据
- en: When we write our Lisp program, how does Lisp decide which parts of our program
    consist of code (stuff to be executed) and which parts are just data? The syntax
    of Lisp has a special way of distinguishing between the two.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 Lisp 程序时，Lisp 是如何决定程序中的哪些部分是代码（要执行的内容）以及哪些部分只是数据？Lisp 的语法有一种特殊的方式来区分这两者。
- en: 'Common Lisp uses two modes when it reads your code: a *code mode* and a *data
    mode*. You can switch between these two modes when writing Lisp code.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 在读取你的代码时使用两种模式：*代码模式*和*数据模式*。你可以在编写 Lisp 代码时在这两种模式之间切换。
- en: Code Mode
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码模式
- en: Whenever you type something into the Lisp REPL, the compiler assumes that you’re
    entering a command you want to execute. In other words, Lisp always assumes that
    you’re writing code and defaults to code mode.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你将某些内容输入到 Lisp REPL 中时，编译器会假设你正在输入一个你想要执行的命令。换句话说，Lisp 总是假设你在编写代码，并默认为代码模式。
- en: 'As we’ve already discussed, Lisp will expect Lisp code to be entered as a list.
    However, the code should be in a special type of list: a *form*. So when you’re
    in code mode, as you are when you start typing into the REPL, the commands you
    enter need to be structured as forms:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，Lisp 预期 Lisp 代码将以列表的形式输入。然而，代码应该是一种特殊类型的列表：*形式*。因此，当你处于代码模式时，就像你在开始输入到
    REPL 时一样，你输入的命令需要以形式的结构来组织：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781095.png.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781095.png.jpg)'
- en: A form is simply a list with a special command at the beginning—typically the
    name of a function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 形式（form）简单来说是一个以特殊命令开头的列表——通常是函数的名称。
- en: 'When reading a form, Lisp sends all other items in the list to the function
    as parameters. For example, enter the following into your REPL:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取一个形式时，Lisp 将列表中的所有其他项发送到该函数作为参数。例如，将以下内容输入到你的 REPL 中：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This calculates 2^3 = 8\. It does this by calling `expt`, which computes an
    exponent. This command was entered in the standard way for Lisp: as a form with
    the function name at the beginning.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这计算了 2^3 = 8。它是通过调用 `expt` 来实现的，该命令计算指数。这个命令是以 Lisp 的标准方式输入的：作为一个以函数名称开头的形式。
- en: 'When Lisp reads the text for the parameters of such a command, it usually assumes
    that these parameters are *also* in code mode. Here’s an example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Lisp 读取此类命令的参数文本时，它通常假设这些参数也处于代码模式。以下是一个例子：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example has two nested forms. Lisp first looks at the entire expression
    in code mode. It determines that we’ve entered a form for the `expt` command.
    Then Lisp looks at the arguments to this command, also in code mode. One of these
    arguments `(+ 3 4)` is a form in its own right. This form is then executed, yielding
    `7`. Afterward, this result is passed to the outer `expt` form, which is then
    executed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有两个嵌套的表单。Lisp 首先以代码模式查看整个表达式。它确定我们进入了 `expt` 命令的表单。然后 Lisp 查看这个命令的参数，这些参数也在代码模式下。这些参数中的一个
    `(+ 3 4)` 是一个独立的表单。这个表单随后被执行，得到 `7`。之后，这个结果被传递给外部的 `expt` 表单，然后执行。
- en: Data Mode
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模式
- en: As you might imagine, any stuff written in data mode is treated as data. This
    means the computer will not try to “execute” it, which allows us to have information
    in our code that’s just plain old data.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，任何以数据模式编写的代码都被视为数据。这意味着计算机不会尝试“执行”它，这允许我们在代码中包含纯粹的数据信息。
- en: 'Let’s take a look at data mode in action. We’ll enter the same form that we
    entered in code mode in the previous example, with one difference:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据模式在实际中的应用。我们将输入与之前代码模式中相同的表单，只有一个区别：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This time, we put a single quote in front of the list. Instead of responding
    with the sum of the numbers 1 and 2, Lisp simply parrots our expression to us.
    The single quote tells Lisp to treat the subsequent form as a chunk of data—simply
    a list of items. Lisp then prints the result of evaluating what we entered, which
    is the list itself. It ignores any functions or variables in our list, treating
    everything as data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在列表前加了一个单引号。Lisp 并没有响应数字 1 和 2 的和，而是简单地重复我们的表达式。单引号告诉 Lisp 将随后的表单视为数据块——只是一个项目的列表。Lisp
    然后打印出评估我们所输入内容的结果，即列表本身。它忽略了列表中的任何函数或变量，将所有内容视为数据。
- en: Placing a quote in front of lists so that they won’t be evaluated as a command
    is called *quoting*. By using quoting, you can tell Lisp, “This next part isn’t
    a command. It’s just a chunk of data for my program.”
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表前放置一个引号，以便它们不会被评估为命令，这被称为 *引用*。通过使用引用，你可以告诉 Lisp，“接下来的这部分不是命令。它只是程序的数据块。”
- en: Lists in Lisp
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp 中的列表
- en: 'Lists are a crucial feature in Lisp. They are what hold all your Lisp code
    (as well as data) together. Take any basic piece of Lisp code, such as the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是 Lisp 中的一个关键特性。它们是所有 Lisp 代码（以及数据）的粘合剂。以任何基本的 Lisp 代码为例，如下所示：
- en: '[PRE35]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This piece of code contains a symbol (`expt`) and two numbers, all tied together
    as a list, indicated by the parentheses.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含一个符号（`expt`）和两个数字，它们作为一个列表绑定在一起，由括号表示。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783176.png.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783176.png.jpg)'
- en: You can think of a Lisp program as a house. If you were to build a house in
    Lisp, your walls would be made out of lists. The bricks would be made out of symbols,
    numbers, and strings. However, a wall needs mortar to hold it together. In the
    same way, lists in Lisp are held together by structures called *cons cells*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Lisp 程序想象成一栋房子。如果你在 Lisp 中构建一栋房子，你的墙壁将由列表组成。砖块由符号、数字和字符串组成。然而，墙壁需要灰浆来粘合。同样，Lisp
    中的列表由称为 *cons 单元* 的结构粘合在一起。
- en: Cons Cells
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cons 单元
- en: Lists in Lisp are held together with cons cells. Understanding the relationship
    between cons cells and lists will give you a better idea of how Lisp works.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 中的列表由 cons 单元组成。理解 cons 单元和列表之间的关系将帮助你更好地了解 Lisp 的工作原理。
- en: 'A cons cell looks like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: cons 单元看起来是这样的：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781418.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781418.png)'
- en: It’s made of two little connected boxes, both of which can point at other things.
    A cons cell can point to another cons cell or another type of Lisp data. By being
    able to point to two different things, it’s possible to link cons cells together
    into lists. In fact, lists in Lisp are just an abstract illusion—all of them are
    actually composed of cons cells.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它由两个小连接的盒子组成，这两个盒子都可以指向其他东西。一个 cons 单元可以指向另一个 cons 单元或另一种类型的 Lisp 数据。通过能够指向两个不同的事物，可以将
    cons 单元链接成列表。实际上，Lisp 中的列表只是一个抽象的幻象——它们实际上都是由 cons 单元组成的。
- en: 'For instance, suppose we create the list ''(1 2 3). Here’s how this list is
    represented in computer memory:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们创建了列表 `(1 2 3)`。以下是这个列表在计算机内存中的表示方式：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781207.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781207.png)'
- en: 'It’s created using three cons cells. Each cell points to a number, as well
    as the next cons cell for the list. The final cons cell then points at `nil`,
    to terminate the list. (If you’ve ever used a linked list in another programming
    language, this is the same basic idea.) You can think of this arrangement like
    a calling chain for your friends: “When I know about a party this weekend, I’ll
    call Bob, and then Bob will call Lisa, who will call . . .” Each person in a calling
    chain is responsible for only one phone call, which activates the next call in
    the list.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: List Functions
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Manipulating lists is extremely important in Lisp programming. There are three
    basic functions for manipulating cons cells (and hence lists) in Lisp: `cons`,
    `car`, and `cdr`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The cons Function
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to link any two pieces of data in your Lisp program (regardless
    of type), the usual way to do that is with the `cons` function. When you call
    `cons`, the Lisp compiler typically allocates a small chunk of memory, the cons
    cell, that can hold two references to the objects being linked. (Usually, the
    second of the two items being linked will be a list.) For example, let’s link
    the symbol `chicken` to the symbol `cat`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, `cons` returns a single object, the cons cell, represented by
    parentheses and a dot between the two connected items. Don’t confuse this with
    a regular list. The dot in the middle makes this a cons cell, just linking those
    two items together.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we prefix our two pieces of data with a single quote to make sure
    that Lisp sees them as just data and doesn’t try to evaluate them as code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead of another piece of data, we attach the symbol `nil` on the right
    side of the list, something special happens:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Unlike with our `cat`, the `nil` does not show in the output this time. There’s
    a simple reason for this: `nil` is a special symbol that is used to terminate
    a list in Lisp. That said, the Lisp REPL is taking a shortcut and just saying
    that we created a list with one item, our `chicken`. It could have displayed the
    result by explicitly showing our cons cell and printing `(CHICKEN . NIL)`. However,
    because this result is coincidentally also a list, it instead will show the list
    notation.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that Lisp will always go out of its way to “hide” the cons
    cells from you. When it can, it will show your results using lists. It will show
    a cons cell (with the dot between the objects) only if there isn’t a way to show
    your result using lists.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example can also be written like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The *empty list*, `()`, can be used interchangeably with the `nil` symbol in
    Common Lisp. Thinking of the terminator of a list as an empty list makes sense.
    What do you get when you add a chicken to an empty list? Just a list with a chicken
    in it. The `cons` function also can add a new item to the front of the list. For
    example, to add `pork` to the front of a list containing `(beef chicken)`, use
    `cons` like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When Lispers talk about using `cons`, they say they are *consing* something.
    In this example, we consed pork to a list containing beef and chicken.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Lisp 程序员谈论使用 `cons` 时，他们会说他们在 *连接* 东西。在这个例子中，我们将猪肉连接到一个包含牛肉和鸡肉的列表中。
- en: 'Since all lists are made of cons cells, our `(beef chicken)` list must have
    been created from its own two cons cells, perhaps like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有列表都是由 cons 单元组成的，我们的 `(beef chicken)` 列表必须是由它自己的两个 cons 单元创建的，可能像这样：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Combining the previous two examples, we can see what all the lists look like
    when viewed as conses. This is what is *really* happening:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 结合前两个例子，我们可以看到所有列表在作为 cons 单元查看时的样子。这就是 *真正* 发生的事情：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Basically, this is telling us that when we cons together a list of three items,
    we get a list of three items. No wholesale copying or deleting of data ever needs
    to take place.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这告诉我们当我们将三个元素的列表连接在一起时，我们得到一个包含三个元素的列表。数据永远不会被全部复制或删除。
- en: 'The REPL echoed back to us our entered items as a list, `(pork beef chicken)`,
    but it could just as easily (though a little less conveniently) have reported
    back the items exactly as we entered them: `(cons ''pork (cons ''beef (cons ''chicken
    ())))`. Either response would have been perfectly correct. *In Lisp, a chain of
    cons cells and a list are exactly the same thing*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将我们输入的项目作为列表回显给我们，`(pork beef chicken)`，但它也可以（尽管不太方便）将项目按我们输入的顺序回显：`(cons
    'pork (cons 'beef (cons 'chicken ())))`。任何一种回应都是完全正确的。*在 Lisp 中，一串 cons 单元和列表是同一回事*。
- en: The car and cdr Functions
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: car 和 cdr 函数
- en: Lists are just long chains of two-item cells.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表只是由两个元素的单元组成的长时间链。
- en: 'The `car` function is used for getting the thing out of the *first* slot of
    a cell:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`car` 函数用于从单元的 *第一个* 插槽中获取内容：'
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `cdr` function is used to grab the value out of the *second* slot, or the
    remainder of a list:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdr` 函数用于从 *第二个* 插槽中获取值，或列表的剩余部分：'
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can string together `car` and `cdr` into new functions like `cadr`, `cdar`,
    or `cadadr`. This lets you succinctly extract specific pieces of data out of complex
    lists. Entering `cadr` is the same as using `car` and `cdr` together—it returns
    the second item from a list. (The first slot of the second cons cell would contain
    that item.) Take a look at this example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `car` 和 `cdr` 组合成新的函数，如 `cadr`、`cdar` 或 `cadadr`。这让你可以简洁地从复杂列表中提取特定数据。输入
    `cadr` 与使用 `car` 和 `cdr` 相同——它从列表中返回第二个元素。（第二个 cons 单元的第一个插槽将包含该元素。）看看这个例子：
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We know that `cdr` will take away the first item in a list ![](httpatomoreillycomsourcenostarchimages783564.png).
    If we then take that shortened list and use `car`, we’ll get the first item in
    the new list ![](httpatomoreillycomsourcenostarchimages783562.png). Then, if we
    use these two commands together, we’ll get the second item in the original list
    ![](httpatomoreillycomsourcenostarchimages783560.png). Finally, if we use the
    `cadr` command, it gives us the same result as using `car` and `cdr` together
    ![](httpatomoreillycomsourcenostarchimages783554.png). Essentially, using the
    `cadr` command is the same as saying that you want the second item in the list.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `cdr` 会移除列表中的第一个元素 ![无标题图片](httpatomoreillycomsourcenostarchimages783564.png)。如果我们然后取这个缩短的列表并使用
    `car`，我们将得到新列表中的第一个元素 ![无标题图片](httpatomoreillycomsourcenostarchimages783562.png)。然后，如果我们同时使用这两个命令，我们将得到原始列表中的第二个元素
    ![无标题图片](httpatomoreillycomsourcenostarchimages783560.png)。最后，如果我们使用 `cadr` 命令，它给出的结果与同时使用
    `car` 和 `cdr` 相同 ![无标题图片](httpatomoreillycomsourcenostarchimages783554.png)。本质上，使用
    `cadr` 命令就是想要列表中的第二个元素。
- en: The list Function
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表函数
- en: 'For convenience, Common Lisp has many functions built on top of the basic three—`cons`,
    `car`, and `cdr`. A useful one is the `list` function, which does the dirty work
    of creating all the cons cells and builds our list all at once:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，Common Lisp 在基本的三种函数——`cons`、`car` 和 `cdr` 的基础上构建了许多函数。其中一个有用的函数是 `list`
    函数，它一次性完成创建所有 cons 单元的工作，并构建我们的列表：
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Remember that there is no difference between a list created with the `list`
    function, one created by specifying individual cons cells, or one created in data
    mode using the single quote. They’re all the same animal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用 `list` 函数创建的列表、通过指定单个 cons 单元创建的列表，或在数据模式下使用单引号创建的列表之间没有区别。它们都是同一类东西。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781830.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781830.png)'
- en: Nested Lists
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套列表
- en: 'Lists can contain other lists. Here’s an example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以包含其他列表。以下是一个例子：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a list containing three items. The second item of this list is `(duck
    bat)`, which is a list itself. This is an example of a *nested list*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三个项目的列表。该列表的第二个项目是`(duck bat)`，它本身也是一个列表。这是一个*嵌套列表*的例子。
- en: 'However, under the hood, these nested lists are still just made out of cons
    cells. Let’s look at an example where we pull items out of nested lists. Here,
    the first item is `(peas carrots tomatoes)` and the second item is `(pork beef
    chicken)`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在底层，这些嵌套列表仍然只是由cons单元格组成的。让我们看看一个例子，其中我们从嵌套列表中提取项目。这里，第一个项目是`(peas carrots
    tomatoes)`，第二个项目是`(pork beef chicken)`：
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `car` function gives us the first item in the list, which is a list in this
    case ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we use the cdr
    command to chop off the first item from this inner list, leaving us with (`CARROTS
    TOMATOES`) ![](httpatomoreillycomsourcenostarchimages783562.png). Using these
    commands together gives this same result ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, using `cdar` gives the same result as using `cdr` and `car` separately
    ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`car`函数给我们列表中的第一个项目，在这个例子中是一个列表！![图片](httpatomoreillycomsourcenostarchimages783564.png)。接下来，我们使用`cdr`命令从这个内部列表中移除第一个项目，留下(`CARROTS
    TOMATOES`)！![图片](httpatomoreillycomsourcenostarchimages783562.png)。使用这些命令一起给出相同的结果！![图片](httpatomoreillycomsourcenostarchimages783560.png)。最后，使用`cdar`给出与单独使用`cdr`和`car`相同的结果！![图片](httpatomoreillycomsourcenostarchimages783554.png)。'
- en: 'As demonstrated in this example, cons cells allow us to create complex structures,
    and we use them here to build a nested list. To prove that our nested list consists
    solely of cons cells, here is how we could create this nested list using only
    the `cons` command:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，cons单元格允许我们创建复杂结构，我们在这里使用它们来构建嵌套列表。为了证明我们的嵌套列表仅由cons单元格组成，以下是我们可以使用`cons`命令创建此嵌套列表的方法：
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here are some more examples of functions based on `car` and `cdr` that we could
    use on our data structure:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些基于`car`和`cdr`的函数的更多示例，我们可以在我们的数据结构上使用：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Common Lisp already defines all these functions for you. You can use any function
    with the name `c*r` right out of the box, up to four levels deep. In other words,
    `cadadr` will already exist for you to use, whereas `cadadar` (which is five levels
    deep) does not (you would need to write that function yourself). These functions
    make it easy to manipulate cons cells-based structures in Lisp, no matter how
    complicated they might be.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp已经为您定义了所有这些函数。您可以直接使用任何名为`c*r`的函数，最多可达四层深度。换句话说，`cadadr`已经为您准备好了使用，而`cadadar`（深度为五层）则没有（您需要自己编写该函数）。这些函数使得在Lisp中操作基于cons单元格的结构变得容易，无论它们可能多么复杂。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780154.png)![image
    with no caption](httpatomoreillycomsourcenostarchimages783324.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780154.png)![无标题图片](httpatomoreillycomsourcenostarchimages783324.png)'
- en: What You've Learned
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您学到了什么
- en: 'In this chapter, we discussed the basic Lisp syntax. Along the way, you learned
    the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了基本的Lisp语法。在这个过程中，您学习了以下内容：
- en: Parentheses in Lisp are there to keep the amount of syntax to a minimum.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp中的括号用于将语法量保持在最小。
- en: Lists are created from cons cells.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表是由cons单元格创建的。
- en: You can create lists by making cons cells with the `cons` command.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`cons`命令创建列表。
- en: You can inspect the pieces of a list with `car` and `cdr`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`car`和`cdr`检查列表的各个部分。
