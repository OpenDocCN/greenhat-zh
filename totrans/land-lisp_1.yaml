- en: Part I. Lisp is Power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703119.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1. Getting Started with Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter begins with an introduction to the various dia lects of Lisp. Then
    we’ll talk a bit about ANSI Common Lisp, the dialect that we’ll be using in this
    book. Finally, you’ll get started by installing and testing CLISP, the implementation
    of ANSI Common Lisp that will let you run all the Lisp games you’re going to be
    creating!
  prefs: []
  type: TYPE_NORMAL
- en: Lisp Dialects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any language that obeys the central principles of Lisp is considered a Lisp
    dialect. Since these principles are so simple, it’s not surprising that literally
    hundreds of dialects of Lisp have been created. In fact, since so many budding
    Lispers create their own Lisp dialect as an exercise, there may be *thousands*
    of partially completed Lisps slumbering in long-abandoned directories on hard
    drives across the planet. However, the vast majority of the Lisp community uses
    two Lisps: ANSI Common Lisp (often abbreviated CL) and Scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’ll be talking exclusively about the ANSI Common Lisp dialect,
    the slightly more popular of the two. Nevertheless, most of the knowledge you’ll
    gain from reading this book will also be relevant to Scheme (although the names
    of functions tend to differ somewhat between the dialects).
  prefs: []
  type: TYPE_NORMAL
- en: A Tale of Two Lisps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some deep philosophical differences exist between ANSI Common Lisp and Scheme,
    and they appeal to different programmer personalities. Once you learn more about
    Lisp languages, you can decide which dialect you prefer. There is no right or
    wrong choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To aid you in your decision, I have created the following personality test
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703121.png)'
  prefs: []
  type: TYPE_IMG
- en: If you chose A, you like raw power in your language. You don’t mind if your
    language is a bit ugly, due to a lot of pragmatic compromises, as long as you
    can still write tight code. ANSI Common Lisp is the best language for you! ANSI
    Common Lisp traces its ancestry most directly from the ancient Lisp dialects,
    built on top of millions of programmer hours, giving it incredibly rich functionality.
    Sure, it has some baroque function names due to countless historical accidents,
    but this Lisp can really fly in the right hacker’s hands.
  prefs: []
  type: TYPE_NORMAL
- en: If you chose B, you like languages that are clean and elegant. You are more
    interested in fundamental programming problems and are happy to while away on
    a beautiful meadow, contemplating the beauty of your code, occasionally writing
    a research paper on theoretical computing problems. Scheme is the language for
    you! It was created in the mid-1970s by Guy L. Steele and Gerald Jay Sussman and
    involved some soul-searching about the ideal Lisp. Code in Scheme tends to be
    slightly more verbose, since Schemers care more about mathematical purity in their
    code than creating the shortest programs possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you chose C, you’re someone who wants it all: the power of ANSI CL and the
    mathematical beauty of Scheme. At this time, no Lisp dialect completely fits the
    bill, but that could change in the future. One language that might work for you
    (although it is sacrilege to make this claim in a Lisp book) is Haskell. It is
    not considered a Lisp dialect, but its followers obey paradigms popular among
    Lispers, such as keeping the syntax uniform, supporting native lists, and relying
    heavily on higher-order functions. More important, it has an extreme mathematical
    rigor (even more so than Scheme) that allows it to hide very powerful functionality
    under a squeaky clean surface. It’s essentially a wolf in sheep’s clothing. Like
    Lisp, Haskell is a language that any programmer would benefit from investigating
    further.'
  prefs: []
  type: TYPE_NORMAL
- en: Up-and-Coming Lisps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As just mentioned, there really isn’t a true Lisp dialect available yet that
    possesses both the power and flexibility of ANSI Common Lisp and the elegance
    of Scheme. However, some new contenders on the horizon may attain the best-of-both-worlds
    crown in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: One new Lisp that is showing promise is Clojure, a dialect developed by Rich
    Hickey. Clojure is built on the Java platform, allowing it to leverage a lot of
    mature Java libraries right out of the box. Also, Clojure contains some clever
    and well-thought-out features to ease multithreaded programming, which makes it
    a useful tool for programming seemingly ubiquitous multicore CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting challenger is Arc. It is a true Lisp language being principally
    developed by Paul Graham, a well-known Lisper. Arc is still in an early stage
    of development, and opinion varies widely on how much of an improvement it is
    over other Lisps. Also, its development has been progressing at a glacially slow
    pace. It will be a while before anyone can say if Arc might be a meaningful contender.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be dipping our toes in some Arc and Clojure in the epilogue.
  prefs: []
  type: TYPE_NORMAL
- en: Lisp Dialects Used for Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some Lisp dialects are used for scripting, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: Emacs Lisp is used for scripting inside the popular (and overall awesome) Emacs
    text editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guile Scheme is used as a scripting language in several open source applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script-Fu Scheme is used with the GIMP image editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These dialects are forks from older versions of the main Lisp branches and are
    not typically used for creating stand-alone applications. However, they are still
    perfectly respectable dialects of Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: ANSI Common Lisp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1981, in order to cope with the dizzying number of dialects of the language,
    members of the varying Lisp communities drafted a specification for a new dialect
    named Common Lisp. In 1986, this language, after further adjustments, was turned
    into the ANSI Common Lisp standard. Many of the developers of older versions of
    Lisp modified their interpreters and compilers to conform to this new standard,
    which became the most popular version of Lisp and remains so to this day.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, the term *Common Lisp* refers to the version of Common
    Lisp defined by the ANSI standard.
  prefs: []
  type: TYPE_NORMAL
- en: A key design goal with Common Lisp was to create a *multiparadigm language*,
    meaning it includes support for many different styles of programming. You’ve probably
    heard of *object-oriented programming*, which can be done quite nicely in Common
    Lisp. Other programming styles you may not have heard of before include *functional
    programming, generic programming*, and *domain-specific language programming*.
    These are all well supported within Common Lisp. You’ll be learning about each
    of these styles, along with others, as we progress through this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with CLISP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many great Lisp compilers are available, but one in particular is easiest to
    get started with: CLISP, an open source Common Lisp. CLISP is simple to install
    and runs on any operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: Other popular Lisps include Steel Bank Common Lisp (SBCL), a fast Common Lisp
    that’s considered a bit more heavy-duty than CLISP and also open source; Allegro
    Common Lisp, a powerful commercial Lisp by Franz, Inc; LispWorks; Clozure CL;
    and CMUCL. Mac users may want to consider LispWorks or Clozure CL, which will
    be easier to get running on their machines. However, for our purposes, CLISP is
    the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with [Chapter 12](ch13.html "Chapter 12. Working with Streams"), we’ll
    be using some CLISP-specific commands that are considered nonstandard. However,
    up until that point, any implementation of Common Lisp will work for running the
    examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing CLISP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download a CLISP installer from [http://clisp.cons.org/](http://clisp.cons.org/).
    It will run on Windows PCs, Macs, and Linux variants. On a Windows PC, you simply
    run an install program. On a Mac, there are some additional steps, which are detailed
    on the website.
  prefs: []
  type: TYPE_NORMAL
- en: On a Debian-based Linux machine, you should find that CLISP already exists in
    your standard sources. Just type **`apt-get install clisp`** at the command line,
    and you’ll have CLISP installed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: For other Linux distributions (Fedora, SUSE, and so on), you can use standard
    packages listed under “Linux packages” on the CLISP website. And experienced Linux
    users can compile CLISP from source.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Up CLISP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run CLISP, type **`clisp`** from your command line. If all goes according
    to plan, you’ll see the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Like all Common Lisp environments, CLISP will automatically place you into a
    *read-eval-print loop* (*REPL*) after you start it up. This means you can immediately
    start typing in Lisp code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out by typing **`(+ 3 (* 2 4))`**. You’ll see the result printed below
    the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This shows how the REPL works. You type in an expression, and then the Lisp
    will immediately evaluate it and return the resulting value. When you want to
    shut down CLISP, just type **`(quit)`**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have CLISP working on your computer, you’re ready to write a Lisp
    game!
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the different dialects of Lisp and installing
    CLISP. You learned the following along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main dialects of Lisp: Common Lisp and Scheme. Both have a lot
    to offer, but we’ll focus on Common Lisp in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Lisp is a multiparadigm language, meaning that it supports many different
    programming styles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CLISP is a Common Lisp implementation that is easy to set up, making it a great
    choice for a Lisp novice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can type in Lisp commands directly from the CLISP *REPL*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703123.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 2. Creating Your First Lisp Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve discussed some of the philosophy of Lisp and have a running CLISP
    environment, we’re ready to write some actual Lisp code in the form of a simple
    game.
  prefs: []
  type: TYPE_NORMAL
- en: The Guess-My-Number Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This first game we’ll write is pretty much the simplest game imaginable. It’s
    the classic guess-my-number game.
  prefs: []
  type: TYPE_NORMAL
- en: In this game, you pick a number from 1 to 100, and the computer has to guess
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The following shows what game play might look like if you pick the number 23\.
    The computer starts by guessing 50, and with each successive guess, you enter
    `(smaller)` or `(bigger)` until the computer guesses your number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create this game, we need to write three functions: `guess-my-number`, `smaller`,
    and `bigger`. The player simply calls these functions from the REPL. As you saw
    in the previous chapter, when you start CLISP (or any other Lisp), you are presented
    with the REPL, from which the commands you type will be *read*, then *evaluated*,
    and finally *printed*. In this case, we’re running the commands `guess-my-number`,
    `smaller`, and `bigger`.'
  prefs: []
  type: TYPE_NORMAL
- en: To call a function in Lisp, you put parentheses around it, along with any parameters
    you wish to give the function. Since these particular functions don’t require
    any parameters, we simply surround their names in parentheses when we enter them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think about the strategy behind this simple game. After a little thought,
    we come up with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the upper and lower (big and small) limit of the player’s number.
    Since the range is between 1 and 100, the smallest possible number would be 1
    and the biggest would be 100.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Guess a number in between these two numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player says the number is smaller, lower the big limit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player says the number is bigger, raise the small limit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703125.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By following these simple steps, cutting the range of possible numbers in half
    with every guess, the computer can quickly hone in on the player’s number.
  prefs: []
  type: TYPE_NORMAL
- en: This type of search is called a *binary search*. As you may know, binary searches
    like this are used all the time in computer programming. You could follow these
    same steps, for instance, to efficiently find a specific number given a sorted
    table of values. In that case, you would simply track the smallest and largest
    row in that table, and then quickly hone in on the correct row in an analogous
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Global Variables in Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the player calls the functions that make up our game, the program will need
    to track the small and big limits. In order to do this, we’ll need to create two
    global variables called `*small*` and `*big*`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the small and big Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable that is defined globally in Lisp is called a *top-level definition*.
    We can create new top-level definitions with the `defparameter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function name `defparameter` is a bit confusing, since it doesn’t really
    have anything to do with parameters. What it does is let you define a *global
    variable*.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument we send to `defparameter` is the name of the new variable.
    The asterisks surrounding the names `*big*` and `*small*`—affectionately called
    *earmuffs*—are completely arbitrary and optional. Lisp sees the asterisks as part
    of the variable names and ignores them. Lispers like to mark all their global
    variables in this way as a convention, to make them easy to distinguish from local
    variables, which are discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although earmuffs may be “optional” in a strictly technical sense, I suggest
    that you use them. I cannot vouch for your safety if you ever post any code to
    a Common Lisp newsgroup and your global variables are missing their earmuffs.
  prefs: []
  type: TYPE_NORMAL
- en: An Alternative Global Variable Definition Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you set the value of a global variable using `defparameter`, any value
    previously stored in the variable will be overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we redefine the variable `*foo*`, its value changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another command that you can use for declaring global variables, called `defvar`,
    won’t overwrite previous values of a global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Some Lispers prefer to use `defvar` instead of `defparameter` when defining
    global variables. In this book, however, we’ll be using `defparameter` exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you read about Lisp in other places, you may also see programmers using
    the term *dynamic variable* or *special variable* when referring to a global variable
    in Common Lisp. This is because global variables in Common Lisp have some special
    abilities, which we’ll be discussing in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Lisp Etiquette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way commands are called and the way code is formatted in Lisp is somewhat
    strange compared with other languages. First of all, you need to surround the
    command (and its arguments) with parentheses, as with the `defparameter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Without the parentheses, a command will not be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, spaces and line breaks are completely ignored when Lisp reads in your
    code. That means you could call this command in any crazy way, with the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because Lisp code can be formatted in such flexible ways, Lispers have a lot
    of conventions for formatting commands, including when to use multiple lines and
    indentation. We’ll loosely follow some of the common indentation conventions in
    the code examples in this book. However, we’re more interested in writing games
    than in discussing source code indentation rules, so we’re not going to be spending
    too much time on code layout rules in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Global Functions in Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our guess-my-number game has the computer respond to the player’s request to
    start the game, and then to requests for either smaller or bigger guesses. For
    these, we need to define three global functions: `guess-my-number`, `smaller`,
    and `bigger`. We’ll also define a function to start over with a different number,
    called `start-over`. In Common Lisp, functions are defined with `defun`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we specify the name and arguments for the function. Then we follow it
    up with the code that composes the function’s logic.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the guess-my-number Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first function we’ll define is `guess-my-number`. This function uses the
    values of the `*big*` and `*small*` variables to generate a guess of the player’s
    number. The definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The empty parentheses, `()`, after the function name `guess-my-number` indicate
    that this function doesn’t require any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Although you don’t need to worry about indentation or line breaks when entering
    code snippets at the REPL, you must be sure to place parentheses correctly. If
    you forget a parenthesis or put one in the wrong place, you’ll most likely get
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we run a piece of code like this in the REPL, the resulting value of
    the entered expression will be printed. Every command in Common Lisp generates
    a return value. The `defun` command, for instance, simply returns the name of
    the newly created function. This is why we see the name of the function parroted
    back to us in the REPL after we call `defun` ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: What does this function do? As discussed earlier, the computer’s best guess
    in this game will be a number in between the two limits. To accomplish this, we
    choose the average of the two limits. However, if the average number ends up being
    a fraction, we’ll want to use a near-average number, since we’re guessing only
    whole numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We implement this in the `guess-my-number` function by first adding the numbers
    that represent the high and low limits, then using the arithmetic shift function,
    `ash`, to halve the sum of the limits and shorten the result. The code `(+ *small*
    *big*)` adds together those two variables. Because the addition happens within
    another function call, ![](httpatomoreillycomsourcenostarchimages783564.png),
    the resulting sum is then passed to the `ash` function.
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses surrounding the `ash` function and the addition (`+`) function
    are mandatory in Lisp. These parentheses are what tell Lisp, “I want you to call
    this function.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in Lisp function `ash` looks at a number in binary form, and then
    shifts its binary bits to the left or right, dropping any bits lost in the process.
    For example, the number 11 written in binary is 1011\. We can move the bits in
    this number to the left with `ash` by using `1` as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces 22, which is 10110 in binary. We can move the bits to the right
    (and lop off the bit on the end) by passing in `−1` as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This produces 5, which is 101 in binary.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `ash` function in `guess-my-number`, we are continually halving
    our search space of possible numbers to quickly narrow down to the final correct
    number. As already mentioned, this halving process is called a *binary search*,
    a useful technique in computer programming. The ash function is commonly used
    for such binary searches in Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens when we call our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is our first guess, the output we see when calling this function
    tells us that everything is working as planned: The program picked the number
    50, right in between 1 and 100.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When programming in Lisp, you’ll write many functions that won’t explicitly
    print values on the screen. Instead, they’ll simply return the value calculated
    in the body of the function. For instance, let’s say we wanted a function that
    just returns the number 5\. Here’s how we could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because the value calculated in the body of the function ![](httpatomoreillycomsourcenostarchimages783564.png)
    evaluates to 5, calling `(return-five)` will just return 5.
  prefs: []
  type: TYPE_NORMAL
- en: This is how `guess-my-number` is designed. We see this calculated result on
    the screen (the number 50) not because the function causes the number to display,
    but because this is a feature of the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve used other programming languages before, you may remember having to
    write something like `return...` to cause a value to be returned. In Lisp, this
    is not necessary. The final value calculated in the body of the function is returned
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the smaller and bigger Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’ll write our `smaller` and `bigger` functions. Like `guess-my-number`,
    these are global functions defined with `defun`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we use `defun` to start the definition of a new global function `smaller.`
    Because this function takes no parameters, the parentheses are empty ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `setf` function to change the value of our global variable
    `*big*` ![](httpatomoreillycomsourcenostarchimages783562.png). Since we know the
    number must be smaller than the last guess, the biggest it can now be is one less
    than that guess. The code `(1- (guess-my-number)`) calculates this: It first calls
    our `guess-my-number` function to get the most recent guess, and then it uses
    the function `1-`, which subtracts 1 from the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want our `smaller` function to show us a new guess. We do this by
    putting a call to `guess-my-number` as the final line in the function body ![](httpatomoreillycomsourcenostarchimages783560.png).
    This time, `guess-my-number` will use the updated value of `*big*`, causing it
    to calculate the next guess. The final value of our function will be returned
    automatically, causing our new guess (generated by `guess-my-number`) to be returned
    by the `smaller` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `bigger` function works in exactly the same manner, except that it raises
    the `*small*` value instead. After all, if you call the `bigger` function, you
    are saying your number is bigger than the previous guess, so the smallest it can
    now be (which is what the `*small*` variable represents) is *one more* than the
    previous guess. The function `1+` simply adds 1 to the value returned by `guess-my-number`
    ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we see our functions in action, with the number 56 as our guess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Defining the start-over Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete our game, we’ll add the function `start-over` to reset our global
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `start-over` function resets the values of `*small*` and
    `*big*` and then calls `guess-my-number` again to return a new starting guess.
    Whenever you want to start a brand-new game with a different number, you can call
    this function to reset the game.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Local Variables in Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our simple game, we’ve defined global variables and functions. However,
    in most cases you’ll want to limit your definitions to a single function or a
    block of code. These are called *local* variables and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a local variable, use the command `let`. A `let` command has the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing inside the `let` command is a list of variable declarations
    ![](httpatomoreillycomsourcenostarchimages783564.png). This is where we can declare
    one or more local variables. Then, in the body of the command (and only within
    this body), we can use these variables ![](httpatomoreillycomsourcenostarchimages783562.png).
    Here is an example of the `let` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve declared the values `5` and `6` for the variables `a`
    ![](httpatomoreillycomsourcenostarchimages783564.png) and `b` ![](httpatomoreillycomsourcenostarchimages783562.png),
    respectively. These are our variable declarations. Then, in the body of the `let`
    command, we added them together ![](httpatomoreillycomsourcenostarchimages783560.png),
    resulting in the displayed value of `11`.
  prefs: []
  type: TYPE_NORMAL
- en: When using a let expression, you must surround the entire list of declared variables
    with parentheses. Also, you must surround each pair of variable names and initial
    variables with another set of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the indentation and line breaks are completely arbitrary, because the
    names of the variables and their values in a `let` expression form a kind of simple
    table, common practice is to align the declared variables vertically. This is
    why the `b` is placed directly underneath the `a` in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Local Functions in Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define local functions using the `flet` command. The `flet` command has
    the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the `flet`, we declare a function (in the first two lines). This
    function will then be available to us in the body ![](httpatomoreillycomsourcenostarchimages783560.png).
    A function declaration consists of a function name, the arguments to that function
    ![](httpatomoreillycomsourcenostarchimages783564.png), and the function body ![](httpatomoreillycomsourcenostarchimages783562.png),
    where we put the function’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define a single function, `f`, which takes a single argument,
    `n` ![](httpatomoreillycomsourcenostarchimages783564.png). The function `f` then
    adds `10` to this variable `n` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which has been passed in it. Then we call this function with the number `5` as
    the argument, causing the value `15` to be returned ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: As with `let`, you can define one or more functions within the scope of the
    `flet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single `flet` command can be used to declare multiple local functions at
    once. Simply add multiple function declarations in the first part of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have declared two functions: one named `f` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and one named `g` ![](httpatomoreillycomsourcenostarchimages783562.png). In the
    body of the `flet`, we can then refer to both functions. In this example, the
    body first calls `f` with `5` to yield 15, then calls `g` to subtract `3`, leading
    to `12` as a final result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make function names available in defined functions, we can use the `labels`
    command. It’s identical in its basic structure to the `flet` command. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the local function `a` adds `5` to a number ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, the function `b` is declared ![](httpatomoreillycomsourcenostarchimages783562.png).
    It calls the function `a`, and then adds `6` to the result ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, the function `b` is called with the value `10` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Since 10 plus 6 plus 5 equals 21, the number 21 becomes the final value of the
    entire expression. The special step that requires us to use `labels` instead of
    `flet` is where the function `b` calls the function `a` ![](httpatomoreillycomsourcenostarchimages783560.png).
    If we had used `flet`, the function `b` would not have “known” about the function
    `a`.
  prefs: []
  type: TYPE_NORMAL
- en: The `labels` command lets you call one local function from another, and it allows
    you to have a function call itself. This is commonly done in Lisp code and is
    called *recursion*. (You will see many examples of recursion in future chapters.)
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the basic Common Lisp commands for defining variables
    and functions. Along the way, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To define a global variable, use the `defparameter` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To define a global function, use the `defun` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `let` and `flet` commands to define local variables and functions, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function `labels` is like `flet`, but it lets functions call themselves.
    Functions that call themselves are called *recursive* functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 3. Exploring the Syntax of Lisp Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve learned so far, Lisp commands must be entered in a rather unorthodox
    way, with parentheses surrounding each command. In this chapter, we’ll explore
    why Lisp works this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why any language—whether it’s a programming language or a human
    language—looks a certain way, we need to begin with two concepts from the field
    of linguistics: syntax and semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax and Semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a typical sentence in the English language:'
  prefs: []
  type: TYPE_NORMAL
- en: '| My dog ate my homework. |'
  prefs: []
  type: TYPE_TB
- en: 'This sentence has the correct syntax for a sentence in English. The *syntax*
    of a piece of text represents the basic rules that it needs to follow to be a
    valid sentence. Here are some of the rules of sentences in the English language
    that this text obeys:'
  prefs: []
  type: TYPE_NORMAL
- en: The sentence ends in a punctuation mark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sentence contains a subject and a verb.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sentence is made up of letters in the English alphabet (as opposed to Egyptian
    hieroglyphics or Sumerian cuneiform).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is more to a sentence than just its syntax. We also care about
    what the sentence actually means. When we talk about the *semantics* of a sentence,
    we’re referring to its meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, here are some sentences that all roughly have identical semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '| My dog ate my homework. |'
  prefs: []
  type: TYPE_TB
- en: '| The canine, which I possess, has consumed my school assignment. |'
  prefs: []
  type: TYPE_TB
- en: '| Der Hund hat meine Hausarbeit gefressen. |'
  prefs: []
  type: TYPE_TB
- en: The first two are just different ways of saying the same thing in English. The
    third sentence is in German, but it still has the same meaning and, hence, semantics
    as the first two.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same distinction between these two ideas exists in programming languages.
    For instance, here is a valid line of code written in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This line of code obeys the rules of C++ syntax. To make my point, I put in
    a lot of weird syntax that is unique to C++, which differentiates it from other
    languages. If you were to place this line of code in a program of another programming
    language with a different syntax, it would probably be invalid and cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this C++ programming code also means something. If we were to put
    this line of code in a C++ program (in the proper context), it would cause your
    computer to *do* something. The actions that a program performs are the *semantics*
    of the program. It is usually possible to write a program that has the same semantics
    in different programming languages; that is, the program will do the same thing
    in both languages.
  prefs: []
  type: TYPE_NORMAL
- en: What all this boils down to is that most programming languages have similar
    semantic powers. However, basic Lisp code is different from code in any other
    major programming language in that it has a far simpler syntax. *Having a simple
    syntax is a defining feature of the Lisp language*.
  prefs: []
  type: TYPE_NORMAL
- en: The Building Blocks of Lisp Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the crazy line of C++ code in the previous section, you can get the idea
    that C++ has a lot of weird syntax—for indicating namespaces, dereferencing pointers,
    performing casts, referencing member functions, performing Boolean operations,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to write a C++ compiler, you would need to do a lot of hard work
    so that the compiler could read this code and obey the many C++ syntax rules,
    before you could make any sense of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a Lisp compiler or interpreter is much easier. The part of a Lisp compiler
    or interpreter that reads in the code (which Lispers actually call the *reader*)
    is simpler than in C++ or any other major programming language. Take a random
    piece of Lisp code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function declaration, which creates a function that simply squares a number,
    consists of nothing more than parentheses and symbols. In fact, you can view it
    as just a bunch of nested lists, delimited by parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lisp only has one way of organizing bits of code: It uses parentheses to organize
    the code into *lists*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All basic Lisp code uses this simple list-like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781268.png)'
  prefs: []
  type: TYPE_IMG
- en: But what sorts of things can we put into these lists? Well, besides other lists,
    we can also put symbols, numbers, and strings into our code. Here, we’ll look
    at these basic building blocks, or datatypes, you’ll use in Lisp. (We’ll discuss
    many other Common Lisp datatypes in later chapters.)
  prefs: []
  type: TYPE_NORMAL
- en: Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Symbols* are a fundamental type of data in Lisp and are used extensively.
    A symbol in Lisp is a stand-alone word. Common Lisp symbols are typically made
    up of letters, numbers, and characters like `+ - / * = < > ? ! _`. Some examples
    of valid Lisp symbols are `foo`, `ice9`, `my-killer-app27`, and even `—<<==>>—`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbols in Common Lisp are *case-insensitive* (although most Lispers avoid
    using uppercase). To illustrate this, we’ll use a function called `eq`, which
    lets us see if two symbols are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function returned `T`, which tells us that Lisp considers
    these two symbols to be identical. (For now, ignore the quotation mark in front
    of the symbols. This will be explained shortly, when we discuss *data mode*.)
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lisp supports both floating-point numbers and integers. When you write a number,
    the presence of a decimal point determines whether your number is seen as a floating-point
    number or an integer. The numbers 1 and 1.0 are two different entities in Common
    Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you use most math functions with both an integer and a floating-point
    number, the integer will become “poisoned,” and a floating-point number will be
    returned. Here’s a case in point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that the decimal point in the returned number, `2.0`, indicates that it
    is a floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lisp can perform some amazing feats with numbers, especially when compared
    with most other languages. For instance, here we’re using the function `expt`
    to calculate the fifty-third power of 53:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Isn’t that cool? Most languages would choke on a calculation involving such
    a large number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you should know that something weird could happen if you divide two
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The division function is dividing the 4 by 6\. But instead of returning a fraction
    (0.66666...) as you might expect, it returns a *rational number*, represented
    as two integers with a division symbol between them. So the `2/3` result represents
    a single rational number, which is the mathematically ideal way to encode a fraction
    such as this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we get a different answer if there is a floating-point number in
    our calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous example, the number with the decimal point (`4.0`) has poisoned
    our numbers to give us a fraction as a result.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not a math geek, this might not be of much use to you, but at least
    you now know what’s happening if you see this sort of thing while you’re coding.
    You can also rest assured that Lisp will do the right thing with this number when
    you use it later on in another calculation. Lisp is smart.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last basic building block in Lisp is the *string*. Although strings aren’t
    really that fundamental to Lisp from a theoretical standpoint, any program that
    communicates with a human will usually need strings, because humans like to communicate
    with text.
  prefs: []
  type: TYPE_NORMAL
- en: To indicate a string in Lisp, surround characters with double quotes. For example,
    `"Tutti Frutti"` is a valid string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can display a string using a function called `princ`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that printing our text at the REPL^([[1](#ftn.CHP-3-FN-1)]) will cause
    the text to appear twice. First, we see the actual printing caused by the `princ`
    command ![](httpatomoreillycomsourcenostarchimages783564.png). However, since
    the REPL will always show the result of evaluating the entered expression, we
    see our string parroted back to us ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is because the `princ` function also returns a value, which happens to be
    the source string.
  prefs: []
  type: TYPE_NORMAL
- en: 'A string can also contain so-called *escaped characters*. If you want a string
    to include double quotes or a backslash, you’ll need to prefix these characters
    with a backslash. For example, this string has two escaped quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the backslashes in front of the two quotes tell Lisp that these
    are literal quotation marks in the string, shown in the displayed string just
    like any other character.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#CHP-3-FN-1)]) As discussed in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Lisp Program"), in a read-eval-print loop (or REPL), the functions
    we enter will be read, then evaluated, and finally printed.
  prefs: []
  type: TYPE_NORMAL
- en: How Lisp Distinguishes Between Code and Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write our Lisp program, how does Lisp decide which parts of our program
    consist of code (stuff to be executed) and which parts are just data? The syntax
    of Lisp has a special way of distinguishing between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common Lisp uses two modes when it reads your code: a *code mode* and a *data
    mode*. You can switch between these two modes when writing Lisp code.'
  prefs: []
  type: TYPE_NORMAL
- en: Code Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you type something into the Lisp REPL, the compiler assumes that you’re
    entering a command you want to execute. In other words, Lisp always assumes that
    you’re writing code and defaults to code mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve already discussed, Lisp will expect Lisp code to be entered as a list.
    However, the code should be in a special type of list: a *form*. So when you’re
    in code mode, as you are when you start typing into the REPL, the commands you
    enter need to be structured as forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781095.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A form is simply a list with a special command at the beginning—typically the
    name of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading a form, Lisp sends all other items in the list to the function
    as parameters. For example, enter the following into your REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This calculates 2^3 = 8\. It does this by calling `expt`, which computes an
    exponent. This command was entered in the standard way for Lisp: as a form with
    the function name at the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When Lisp reads the text for the parameters of such a command, it usually assumes
    that these parameters are *also* in code mode. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This example has two nested forms. Lisp first looks at the entire expression
    in code mode. It determines that we’ve entered a form for the `expt` command.
    Then Lisp looks at the arguments to this command, also in code mode. One of these
    arguments `(+ 3 4)` is a form in its own right. This form is then executed, yielding
    `7`. Afterward, this result is passed to the outer `expt` form, which is then
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: Data Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might imagine, any stuff written in data mode is treated as data. This
    means the computer will not try to “execute” it, which allows us to have information
    in our code that’s just plain old data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at data mode in action. We’ll enter the same form that we
    entered in code mode in the previous example, with one difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This time, we put a single quote in front of the list. Instead of responding
    with the sum of the numbers 1 and 2, Lisp simply parrots our expression to us.
    The single quote tells Lisp to treat the subsequent form as a chunk of data—simply
    a list of items. Lisp then prints the result of evaluating what we entered, which
    is the list itself. It ignores any functions or variables in our list, treating
    everything as data.
  prefs: []
  type: TYPE_NORMAL
- en: Placing a quote in front of lists so that they won’t be evaluated as a command
    is called *quoting*. By using quoting, you can tell Lisp, “This next part isn’t
    a command. It’s just a chunk of data for my program.”
  prefs: []
  type: TYPE_NORMAL
- en: Lists in Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lists are a crucial feature in Lisp. They are what hold all your Lisp code
    (as well as data) together. Take any basic piece of Lisp code, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code contains a symbol (`expt`) and two numbers, all tied together
    as a list, indicated by the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783176.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can think of a Lisp program as a house. If you were to build a house in
    Lisp, your walls would be made out of lists. The bricks would be made out of symbols,
    numbers, and strings. However, a wall needs mortar to hold it together. In the
    same way, lists in Lisp are held together by structures called *cons cells*.
  prefs: []
  type: TYPE_NORMAL
- en: Cons Cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists in Lisp are held together with cons cells. Understanding the relationship
    between cons cells and lists will give you a better idea of how Lisp works.
  prefs: []
  type: TYPE_NORMAL
- en: 'A cons cell looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781418.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s made of two little connected boxes, both of which can point at other things.
    A cons cell can point to another cons cell or another type of Lisp data. By being
    able to point to two different things, it’s possible to link cons cells together
    into lists. In fact, lists in Lisp are just an abstract illusion—all of them are
    actually composed of cons cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose we create the list ''(1 2 3). Here’s how this list is
    represented in computer memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781207.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It’s created using three cons cells. Each cell points to a number, as well
    as the next cons cell for the list. The final cons cell then points at `nil`,
    to terminate the list. (If you’ve ever used a linked list in another programming
    language, this is the same basic idea.) You can think of this arrangement like
    a calling chain for your friends: “When I know about a party this weekend, I’ll
    call Bob, and then Bob will call Lisa, who will call . . .” Each person in a calling
    chain is responsible for only one phone call, which activates the next call in
    the list.'
  prefs: []
  type: TYPE_NORMAL
- en: List Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Manipulating lists is extremely important in Lisp programming. There are three
    basic functions for manipulating cons cells (and hence lists) in Lisp: `cons`,
    `car`, and `cdr`.'
  prefs: []
  type: TYPE_NORMAL
- en: The cons Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to link any two pieces of data in your Lisp program (regardless
    of type), the usual way to do that is with the `cons` function. When you call
    `cons`, the Lisp compiler typically allocates a small chunk of memory, the cons
    cell, that can hold two references to the objects being linked. (Usually, the
    second of the two items being linked will be a list.) For example, let’s link
    the symbol `chicken` to the symbol `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `cons` returns a single object, the cons cell, represented by
    parentheses and a dot between the two connected items. Don’t confuse this with
    a regular list. The dot in the middle makes this a cons cell, just linking those
    two items together.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we prefix our two pieces of data with a single quote to make sure
    that Lisp sees them as just data and doesn’t try to evaluate them as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead of another piece of data, we attach the symbol `nil` on the right
    side of the list, something special happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with our `cat`, the `nil` does not show in the output this time. There’s
    a simple reason for this: `nil` is a special symbol that is used to terminate
    a list in Lisp. That said, the Lisp REPL is taking a shortcut and just saying
    that we created a list with one item, our `chicken`. It could have displayed the
    result by explicitly showing our cons cell and printing `(CHICKEN . NIL)`. However,
    because this result is coincidentally also a list, it instead will show the list
    notation.'
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that Lisp will always go out of its way to “hide” the cons
    cells from you. When it can, it will show your results using lists. It will show
    a cons cell (with the dot between the objects) only if there isn’t a way to show
    your result using lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example can also be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The *empty list*, `()`, can be used interchangeably with the `nil` symbol in
    Common Lisp. Thinking of the terminator of a list as an empty list makes sense.
    What do you get when you add a chicken to an empty list? Just a list with a chicken
    in it. The `cons` function also can add a new item to the front of the list. For
    example, to add `pork` to the front of a list containing `(beef chicken)`, use
    `cons` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When Lispers talk about using `cons`, they say they are *consing* something.
    In this example, we consed pork to a list containing beef and chicken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all lists are made of cons cells, our `(beef chicken)` list must have
    been created from its own two cons cells, perhaps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining the previous two examples, we can see what all the lists look like
    when viewed as conses. This is what is *really* happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this is telling us that when we cons together a list of three items,
    we get a list of three items. No wholesale copying or deleting of data ever needs
    to take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REPL echoed back to us our entered items as a list, `(pork beef chicken)`,
    but it could just as easily (though a little less conveniently) have reported
    back the items exactly as we entered them: `(cons ''pork (cons ''beef (cons ''chicken
    ())))`. Either response would have been perfectly correct. *In Lisp, a chain of
    cons cells and a list are exactly the same thing*.'
  prefs: []
  type: TYPE_NORMAL
- en: The car and cdr Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists are just long chains of two-item cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `car` function is used for getting the thing out of the *first* slot of
    a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cdr` function is used to grab the value out of the *second* slot, or the
    remainder of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can string together `car` and `cdr` into new functions like `cadr`, `cdar`,
    or `cadadr`. This lets you succinctly extract specific pieces of data out of complex
    lists. Entering `cadr` is the same as using `car` and `cdr` together—it returns
    the second item from a list. (The first slot of the second cons cell would contain
    that item.) Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We know that `cdr` will take away the first item in a list ![](httpatomoreillycomsourcenostarchimages783564.png).
    If we then take that shortened list and use `car`, we’ll get the first item in
    the new list ![](httpatomoreillycomsourcenostarchimages783562.png). Then, if we
    use these two commands together, we’ll get the second item in the original list
    ![](httpatomoreillycomsourcenostarchimages783560.png). Finally, if we use the
    `cadr` command, it gives us the same result as using `car` and `cdr` together
    ![](httpatomoreillycomsourcenostarchimages783554.png). Essentially, using the
    `cadr` command is the same as saying that you want the second item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The list Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For convenience, Common Lisp has many functions built on top of the basic three—`cons`,
    `car`, and `cdr`. A useful one is the `list` function, which does the dirty work
    of creating all the cons cells and builds our list all at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Remember that there is no difference between a list created with the `list`
    function, one created by specifying individual cons cells, or one created in data
    mode using the single quote. They’re all the same animal.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781830.png)'
  prefs: []
  type: TYPE_IMG
- en: Nested Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lists can contain other lists. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is a list containing three items. The second item of this list is `(duck
    bat)`, which is a list itself. This is an example of a *nested list*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, under the hood, these nested lists are still just made out of cons
    cells. Let’s look at an example where we pull items out of nested lists. Here,
    the first item is `(peas carrots tomatoes)` and the second item is `(pork beef
    chicken)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `car` function gives us the first item in the list, which is a list in this
    case ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we use the cdr
    command to chop off the first item from this inner list, leaving us with (`CARROTS
    TOMATOES`) ![](httpatomoreillycomsourcenostarchimages783562.png). Using these
    commands together gives this same result ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, using `cdar` gives the same result as using `cdr` and `car` separately
    ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'As demonstrated in this example, cons cells allow us to create complex structures,
    and we use them here to build a nested list. To prove that our nested list consists
    solely of cons cells, here is how we could create this nested list using only
    the `cons` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some more examples of functions based on `car` and `cdr` that we could
    use on our data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Common Lisp already defines all these functions for you. You can use any function
    with the name `c*r` right out of the box, up to four levels deep. In other words,
    `cadadr` will already exist for you to use, whereas `cadadar` (which is five levels
    deep) does not (you would need to write that function yourself). These functions
    make it easy to manipulate cons cells-based structures in Lisp, no matter how
    complicated they might be.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780154.png)![image
    with no caption](httpatomoreillycomsourcenostarchimages783324.png)'
  prefs: []
  type: TYPE_IMG
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the basic Lisp syntax. Along the way, you learned
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses in Lisp are there to keep the amount of syntax to a minimum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are created from cons cells.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create lists by making cons cells with the `cons` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can inspect the pieces of a list with `car` and `cdr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
