<html><head></head><body><section class="chapter" epub:type="chapter" id="overview_of_tcp_ip" title="Chapter&#xA0;11.&#xA0;Overview of TCP/IP"><div class="titlepage"><div><div><h2 class="title">Chapter 11. Overview of TCP/IP</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>IP version 6:</em></span><br/>
<span class="emphasis"><em>All the pain of version 4,</em></span><br/>
<span class="emphasis"><em>plus brand-new problems!</em></span></p></div></div><p><a class="indexterm" id="idx1074"/><a class="indexterm" id="idx2379"/><span class="inlinemediaobject"><a id="inline_id00012"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> Securing a computer is easy: Disconnect it from all networks, remove all input and output, and lock it in a bunker. Oh, wait—did you want the system to <span class="emphasis"><em>do</em></span> something? Then you’ll probably want to connect your system to the Internet.</p><p>Many system administrators have a vague familiarity with the basics of networking, but to be a truly competent sysadmin, you need a real understanding of how everything fits together. You don’t need to know when to use rapid spanning trees, how to choose between BGP and OSPF, or even what those acronyms represent. But you must know what an IP address is, how a netmask works, how port numbers differ from protocol numbers, and why you cannot use <code class="literal">telnet(1)</code> to test UDP connectivity. Without this basic knowledge, you’ll fumble. Read this chapter and understand it, and you’ll have an easier time convincing your network administrator to give you what you need.</p><p><a class="indexterm" id="idx1175"/><a class="indexterm" id="idx1488"/><a class="indexterm" id="idx1494"/><a class="indexterm" id="idx1576"/><a class="indexterm" id="idx1582"/><a class="indexterm" id="idx1641"/><a class="indexterm" id="idx1796"/><a class="indexterm" id="idx2386"/><a class="indexterm" id="idx2391"/>While this chapter offers an overview of TCP/IP, it doesn’t cover the innumerable details, caveats, annoyances, peccadilloes, and blatant outrages present in the protocol. If you find that you need to torture yourself with the finer points of TCP/IP, pick up one of the big, thick books on the subject. <span class="emphasis"><em>The TCP/IP Guide</em></span> by Charles M. Kozierok (No Starch Press, 2005) is an excellent place to start.</p><p>This chapter covers both TCP/IP version 4 (the Internet protocol widely used for the last 30-odd years) and the new version of the protocol, TCP/IP version 6. Despite the different version numbers, the two protocols are more similar than not.</p><p>We’ll start with the layers of the network and then delve into how the protocols work.</p><div class="sect1" title="Network Layers"><div class="titlepage"><div><div><h2 class="title" id="network_layers" style="clear: both">Network Layers</h2></div></div></div><p>The network protocol is divided into several layers. Each layer handles a specific task and interacts only with the layers immediately above and below it. At first, you might laugh at the idea that this layer model simplifies the network process, but it really does. The important thing to remember right now is that each layer communicates with only the layer directly above it and the layer directly beneath it (theoretically, anyway).</p><p>The classic Open Systems Interconnection (OSI) network protocol stack represents the network as seven layers. It’s an exhaustively complete model and covers almost any situation using any network protocol and any application. Because the Internet is a very specific type of network, and because this isn’t a book about networking or networked applications in general, I’ll limit my discussion of TCP/IP to four specific layers of the network: physical, datalink, network, and transport. Don’t worry—these four layers cover the Internet and (almost) all corporate networks.</p><div class="sect2" title="The Physical Layer"><div class="titlepage"><div><div><h3 class="title" id="the_physical_layer">The Physical Layer</h3></div></div></div><p>Whether it’s copper or fiber-optic cable, or even radio waves, physical wire is a layer of the network. Without some physical media to run over, a network cannot function. Everything from the CAT5 cable plugged into your desktop to the fiber-optic cable connecting you to Asia is part of the physical layer. If it can be tripped over, backhoed, or interfered with, it’s part of the physical layer. For simplicity’s sake, I’ll refer to the physical layer as the <span class="emphasis"><em>wire</em></span>, although it can take innumerable forms.</p><p>This is the easiest layer to understand. If your wire meets the requirements of the physical protocol, you’re in business. If not, your network won’t work. One of the functions of Internet routers is to connect one sort of physical layer to another—for example, converting local Ethernet into an OC3 fiber connection.</p><p>The physical layer has no decision-making abilities of its own; everything that runs over it is dictated by the datalink layer.</p></div><div class="sect2" title="The Datalink Layer"><div class="titlepage"><div><div><h3 class="title" id="the_datalink_layer">The Datalink Layer</h3></div></div></div><p><a class="indexterm" id="idx0027"/><a class="indexterm" id="idx0073"/><a class="indexterm" id="idx0367"/><a class="indexterm" id="idx0959"/><a class="indexterm" id="idx0967"/><a class="indexterm" id="idx1080"/><a class="indexterm" id="idx1085"/><a class="indexterm" id="idx1252"/><a class="indexterm" id="idx1341"/><a class="indexterm" id="idx1450"/><a class="indexterm" id="idx1456"/><a class="indexterm" id="idx1490"/><a class="indexterm" id="idx1492"/><a class="indexterm" id="idx1578"/><a class="indexterm" id="idx1580"/><a class="indexterm" id="idx1813"/><a class="indexterm" id="idx1856"/><a class="indexterm" id="idx2157"/><a class="indexterm" id="idx2285"/>The datalink layer is the protocol that runs over the physical wire. It transforms information into the actual signals that are sent over the physical layer, using the appropriate encoding for that physical media, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Both Ethernet and Switched Multimegabit Data Service (SMDS) use Media Access Control (MAC) addresses and the Address Resolution Protocol (ARP).</p></li><li class="listitem"><p>IPv6 over Ethernet uses Neighbor Discovery (ND).</p></li><li class="listitem"><p>Dial-up and wide area networks (WANs) use either the Point-to-Point Protocol (PPP) or High-Level Data Link Control (HDLC).</p></li></ul></div><p>OpenBSD supports other common datalink protocols, such as PPP over Ethernet (PPPoE). If you have unusual network requirements, check the OpenBSD website, mailing lists, or man pages to see if those requirements are supported.</p><p>Some datalink layers have been implemented over many different physical layers. Ethernet, for example, has been implemented over twinax, coax, CAT3, CAT5, CAT6, CAT7, optical fiber, and radio waves. And for true device independence, we have seen TCP/IP implemented with a biological transport layer: carrier pigeon.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id460204" id="id460204">27</a>]</sup></p><p>With minor changes to the device drivers, the datalink layer can address any sort of physical layer. This is one of the ways in which layers simplify the network.</p><p><a class="xref" href="ch12.html" title="Chapter 12. Connecting to the Network">Chapter 12</a> discusses Ethernet in detail, as it’s the most common network type for OpenBSD systems. Once you understand how Ethernet works, you’ll have no difficulty adding new datalink protocols as needed.</p><p>The datalink layer exchanges information with the physical layer and the network layer.</p></div><div class="sect2" title="The Network Layer"><div class="titlepage"><div><div><h3 class="title" id="the_network_layer">The Network Layer</h3></div></div></div><p>The network layer is the part that maps connectivity between network nodes, answering questions like “Where are other hosts?” and “Can I get there from here?” This logical protocol provides a consistent interface to programs that run over the network, no matter what the physical and datalink layers look like.</p><p>The network layer used on the Internet is the Internet Protocol, or IP. Both version 4 (IPv4) and version 6 (IPv6) provide each host with one or more unique <span class="emphasis"><em>IP addresses</em></span>, so that any other host on the network can find it. Okay, IPv4 network address translation munges the whole “unique address” rule, but your network still has a unique IP address somewhere.</p><p><a class="indexterm" id="idx0069"/><a class="indexterm" id="idx0701"/><a class="indexterm" id="idx1002"/><a class="indexterm" id="idx1075"/><a class="indexterm" id="idx1489"/><a class="indexterm" id="idx1496"/><a class="indexterm" id="idx1577"/><a class="indexterm" id="idx1584"/><a class="indexterm" id="idx2370"/><a class="indexterm" id="idx2389"/><a class="indexterm" id="idx2455"/><a class="indexterm" id="idx2456"/><a class="indexterm" id="idx2471"/><a class="indexterm" id="idx2531"/>The network layer talks to the datalink layer below it and the transport layer above it.</p></div><div class="sect2" title="The Transport Layer"><div class="titlepage"><div><div><h3 class="title" id="the_transport_layer">The Transport Layer</h3></div></div></div><p>The transport layer is where actual data flows. The three most common transport layer protocols are the Internet Control Message Protocol (ICMP), Transmission Control Protocol (TCP), and User Datagram Protocol (UDP).</p><p>ICMP passes basic connectivity messages between hosts with IP addresses. If IP provides a road and addresses, ICMP provides traffic lights and highway exit signs. Most of the time, ICMP runs silently in the background.</p><p>UDP and TCP are the protocols that carry actual data between hosts, and they are so prevalent that the suite of Internet protocols is usually called TCP/IP. UDP is a bare-bones transport protocol, offering the minimum services needed to transfer data over the network. Its minimalism means that if you want to customize exactly how data flows in your application, you can build it out of valid UDP. TCP provides more sophisticated features, such as integrity checking and congestion control, but many of its settings are hard-coded.</p><p>In addition to these three, many other protocols run at the transport layer. The file <span class="emphasis"><em>/etc/protocols</em></span> contains a fairly comprehensive list of transport protocols built atop IP. While it lists many more protocols than you will ever actually deal with out in the wild, it doesn’t include non-IP protocols like IPX/SPX or Digital Equipment Company’s DECnet.</p><p>As an example, let’s have a look at the first entry from <span class="emphasis"><em>/etc/protocols</em></span>:</p><a id="I_programlisting11_id457378"/><pre class="programlisting">ip      0       IP HOPOPT       # internet protocol, pseudo protocol number</pre><p>Each <span class="emphasis"><em>/etc/protocols</em></span> entry has three key fields: an official name, a protocol number, and any aliases. The IP protocol, protocol 0, is known as IP and (<span class="emphasis"><em>very</em></span> occasionally) as HOPOPT. Each protocol also has a comment giving it some context. Although some of the protocols in <span class="emphasis"><em>/etc/protocols</em></span> are long gone, some antediluvian devices out there might still speak them.</p><p>Note that ICMP, TCP, and UDP are slightly different when run over IPv4 versus IPv6. Each protocol has clearly defined fields in the IP packet header, leaving specific numbers of bits for things like checksums, destination addresses, and so on. You can’t run a transport protocol over an incompatible network protocol—TCPv6 over IPv4 just doesn’t work.</p><p>The transport layer speaks to the network layer below and to the applications layer above it.</p></div><div class="sect2" title="Applications"><div class="titlepage"><div><div><h3 class="title" id="applications">Applications</h3></div></div></div><p>Applications are definitely part of the network. Applications request network connectivity, send data over the network, receive data from the network, and process that data. Web browsers, email clients, JavaServer Pages (JSP) servers, and so on are examples of network-aware applications. Applications need to communicate with only the transport protocol and the user. The upper three layers of the OSI network model are inside applications.</p><p><a class="indexterm" id="idx0368"/><a class="indexterm" id="idx0885"/><a class="indexterm" id="idx1363"/><a class="indexterm" id="idx1491"/><a class="indexterm" id="idx1493"/><a class="indexterm" id="idx1495"/><a class="indexterm" id="idx1497"/><a class="indexterm" id="idx1499"/><a class="indexterm" id="idx1579"/><a class="indexterm" id="idx1581"/><a class="indexterm" id="idx1583"/><a class="indexterm" id="idx1585"/><a class="indexterm" id="idx1689"/><a class="indexterm" id="idx1797"/><a class="indexterm" id="idx2079"/><a class="indexterm" id="idx2387"/><a class="indexterm" id="idx2457"/>Problems with the user layer are beyond the scope of this book, but I find that many of these issues can be solved with proper application of a large chainsaw.</p></div></div><div class="sect1" title="The Life and Times of a Network Request"><div class="titlepage"><div><div><h2 class="title" id="the_life_and_times_of_a_network_request" style="clear: both">The Life and Times of a Network Request</h2></div></div></div><p>So how do all these layers fit together in the real world? Let’s have a look at a hypothetical network request, and walk through how data traverses the layers and the network.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note01"/>Note</h3><p>Some of this discussion touches on topics covered later this chapter, so you might want to reread this section after finishing the chapter. Purists will notice that I skip a lot of parts of the process, but I’m trying to relay the basics of how TCP/IP works in practice, not model every painful detail of a real network transaction.</p></div><p>Suppose a user connected to your network wants to look at a very important work-related website, such as Scott Meyer’s Basic Instructions (<span class="emphasis"><em><a class="ulink" href="http://www.basicinstructions.net/" target="_top">http://www.basicinstructions.net/</a></em></span>). The user opens his browser, enters the URL, and presses <span class="smallcaps">ENTER</span>. The browser application transforms the user’s request into the proper format and asks the transport layer for a TCP connection to a particular IP address on port 80.</p><p>The transport layer inside your computer examines the browser’s request and allocates the appropriate resources for it. The request is broken up into digestible chunks, called <span class="emphasis"><em>segments</em></span>, and handed down to the network layer.</p><p>The network layer doesn’t care about the contents of the request; it’s only concern is where that data is going. The network layer takes the TCP data and attaches the proper addressing information to it. The resulting chunk of data is called a <span class="emphasis"><em>packet</em></span>. The network layer checks the packet’s destination, chooses the interface closest to the gateway to that destination, and drops packets down into the datalink layer.</p><p>The datalink layer doesn’t care about the contents of the packet, and it certainly doesn’t care about IP addresses or routing. It has been given a lump of zeros and ones, and its job is to transmit those zeros and ones to another network node. The datalink layer adds the appropriate header and/or footer information to the packet, creating a <span class="emphasis"><em>frame</em></span> appropriate for the physical layer. The frame’s header and footer contain the addressing information for the physical layer. On most networks, the datalink layer prepares frames for the local Ethernet. Then the datalink layer hands off the frame to the physical layer for transmission.</p><p>The physical layer has no intelligence at all (think carrier pigeons). The datalink layer hands the physical layer a frame, and the physical layer transmits that frame to another physical device. For a web browsing client, this is usually the default router for the local Ethernet. The physical layer doesn’t care about the upper-level protocols. Its only job is to make sure the frame gets to the destination without errors.</p><p>When the client computer’s router receives the frame, it sends it up to the datalink layer. The datalink layer strips out the frame information and hands the resulting packet up to the network layer. The router’s network layer examines the packet, looks at its routing table, and decides which interface to send it out on. This might be another Ethernet interface, a T1, a DS3, an OC3, or whatever the router uses for upstream connectivity. Once the router chooses an interface, it hands the packet to the datalink layer for that interface.</p><p><a class="indexterm" id="idx0520"/><a class="indexterm" id="idx1106"/><a class="indexterm" id="idx1120"/><a class="indexterm" id="idx1507"/><a class="indexterm" id="idx2388"/>The local router’s upstream connection probably goes through a whole series of routers. Each router decides where to send the request based on its routing table. The request probably traverses a variety of datalink layers as it travels. Thanks to layering and abstraction, neither you nor your computer needs to know anything about any of them.</p><p>When the request reaches its destination, the computer at the other end of the transaction accepts the frame and sends it all the way back up the protocol stack. The frame is stripped down to packets, which are stripped down to segments, which are reassembled into a data stream. The data stream is then handed to the application (in this case, a web server). The application processes the request and returns an answer, which goes back down through the protocol stack and travels across the network, bouncing up and down through various datalink layers on the way as necessary.</p><p>This example shows why the layer model is important: Each layer knows only what it absolutely must about the layers above and below it, making it possible to swap out layers if necessary. When a new datalink protocol is created, the other layers don’t need to change. The network layer just hands a packet to the datalink layer and lets the datalink do its thing. When you install a new network card, you need only a driver that interfaces with the datalink layer and the physical layer; you don’t need to change anything higher in the network stack.</p></div><div class="sect1" title="Network Stacks"><div class="titlepage"><div><div><h2 class="title" id="network_stacks" style="clear: both">Network Stacks</h2></div></div></div><p>A network stack is the software that lets a host communicate with the network. A host can run with an IPv4-only network stack, an IPv6-only network stack, or a dual-stacked setup.</p><p>You’re already familiar with an IPv4-only stack—it’s what most hosts ran for much of the past 30 years. An IPv4-only stack can communicate only over IPv4. Today, an IPv4-only stack gets you access to the entire Internet, with a few deliberate exceptions. That will not be true in a few years.</p><p>Likewise, an IPv6-only stack can communicate with only IPv6 hosts. Because most Internet sites don’t yet support IPv6, running an IPv6-only stack isn’t practical at this point. It is, however, an excellent way to test your IPv6 infrastructure and connectivity.</p><p>The most common configuration these days is a dual-stack setup. Client hosts try to use both IPv4 and IPv6, preferring one over the other. I recommend configuring hosts with dual stacks, preferring the stack with better connectivity. (If you get IPv6 connectivity through a tunnel, it’s not as fast as your IPv4 connectivity.) If you have equal IPv4 and IPv6 connectivity, use whichever you prefer. IPv6 works well enough that I often don’t realize that I’m using it until I analyze my traffic.</p><p><a class="indexterm" id="idx1086"/><a class="indexterm" id="idx1470"/>You don’t need to do anything special to enable IPv6 on OpenBSD—an IPv6 address, a default router, and a DNS server, and away you go.</p></div><div class="sect1" title="IPv4 Addresses and Subnets"><div class="titlepage"><div><div><h2 class="title" id="ipv4_addresses_and_subnets" style="clear: both">IPv4 Addresses and Subnets</h2></div></div></div><p>An <span class="emphasis"><em>IP address</em></span> is a unique 32-bit number assigned to a specific network node. Some IP addresses are more or less permanent, such as those assigned to vital servers; others change as required, such as those used by desktop clients. Individual machines on a shared network use IP addresses from a range of addresses assigned to that network.</p><p>Rather than expressing that 32-bit address as a single number, an IP address is divided into four 8-bit numbers, usually expressed as decimals. While 192.0.2.1 and 11000000.00000000.00000010.00000001 represent the same address, the first option is easier for our feeble little brains to grasp.</p><p>Internet service providers (ISPs) issue IP addresses in blocks. These blocks are the smallest allocation that they can get away with giving you—say, 16 or 32 addresses. If your system is on a server farm, you might get only a few IP addresses out of a block of 256.</p><p>A <span class="emphasis"><em>netmask</em></span> indicates the size of the block of IP addresses assigned to your local network. The size of your IP block determines your netmask—or, your netmask determines how many IP addresses the network has.</p><p>ISPs issue IP addresses by prefix length, commonly called a <span class="emphasis"><em>slash</em></span>. You’ll see IP address blocks described in forms like 192.0.2.128/26. Everyone who has worked with networking has seen the netmask 255.255.255.0, and most know that it’s associated with a block of 256 IP addresses. That netmask is also called a /24. The number after the slash is the number of fixed bits in the netmask. Remember, an IPv4 address is a 32-bit number; on a /24 network, 24 of those bits will never change.</p><p>This isn’t a textbook on binary math, so I won’t quiz you on the conversions, but think of an IP address as a string of 32 binary digits. On your networks, you can change the bits on the far right, but not the bits on the far left. But where is the line that separates right from left?</p><p>Netmasks have traditionally been split on 8-bit boundaries, but there’s no hard rule that says they must be. A /25 network has 25 fixed bits—one more fixed bit than what used to be called a class C network—leaving you with 7 bits to play with. The netmask’s fixed bits are set to 1, and your network bits are set to 0, as in the following example of a /25 netmask:</p><a id="I_programlisting11_id457824"/><pre class="programlisting">11111111.11111111.11111111.10000000</pre><p>The first three blocks are set to the binary 11111111, which is 255 in decimal. The last block is set to 1000000, which is 128. Mash these together, and your resulting netmask is 255.255.255.128.</p><p><a class="indexterm" id="idx1105"/>If you reduce netmasks to binary, they’re simple to figure out. While you won’t need to work with this every day, if you don’t understand the underlying concepts, the decimal conversion looks like total gibberish. With a little practice, you’ll recognize certain decimal strings as legitimate netmasks.</p><p>So now that you know how netmasks work, what the heck does all this mean in the real world?</p><p>IP addresses are issued in multiples of 2. If you have 4 bits to play with, you have 16 addresses (2<sup>4</sup>=16). If you have 8 bits to play with, you have 256 addresses (2<sup>8</sup>=256). If someone says that you have exactly 17 IP addresses, you’re either sharing a network with other people or they’re wrong.</p><p>It’s common to see a host’s IP with the netmask attached, such as 192.0.2.130/26. This gives you everything you need to attach the host to the local network. (Finding the default gateway is a separate issue, but it’s usually the top or bottom address in the block.)</p><div class="sect2" title="Calculating a Decimal IPv4 Netmask"><div class="titlepage"><div><div><h3 class="title" id="calculating_a_decimal_ipv4_netmask">Calculating a Decimal IPv4 Netmask</h3></div></div></div><p>Converting from binary to decimal to binary is error-prone and mildly annoying. Here’s how to calculate your netmask while remaining in decimal land.</p><p>Find how many IP addresses you have on your network. This will be a multiple of 2, almost certainly smaller than 256. Subtract the number of IP addresses you have from 256. This is the last number of your netmask. You still need to recognize legitimate network sizes, however. If your IP address is 192.0.2.251/26, you’ll need to know that a /26 is 26 fixed bits, or 64 IP addresses. Your netmask is 255.255.255.192 (256–64=192).</p><p>And I should also mention that netmasks occasionally appear in hexadecimal.</p><p>Before you travel to my house to bludgeon me repeatedly with this book, <a class="xref" href="ch11.html#ipv4_netmasks_and_ip_address_conversions" title="Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions">Table 11-1</a> shows netmasks, IP information, and related information for /24 and smaller networks.</p><div class="table"><a id="ipv4_netmasks_and_ip_address_conversions"/><div class="table-title">Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/><col class="c4"/><col class="c5"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prefix</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Binary Mask End</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Decimal Mask</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hex Mask</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Available IPs</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/24</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>00000000</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.0</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xffffff00</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>256</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/25</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10000000</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.128</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xffffff80</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>128</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/26</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11000000</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.192</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xffffffc0</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>64</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/27</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11100000</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.224</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xffffffe0</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>32</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/28</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11110000</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.240</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xfffffff0</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>16</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/29</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111000</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.248</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xfffffff8</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>8</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>/30</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11111100</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>255.255.255.252</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0xfffffffc</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>4</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>/31</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>11111110</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>255.255.255.254</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>0xfffffffe</p></td><td style="vertical-align: top; "><p>2</p></td></tr></tbody></table></div></div><p><a class="indexterm" id="idx0197"/><a class="indexterm" id="idx1010"/><a class="indexterm" id="idx1100"/><a class="indexterm" id="idx1111"/><a class="indexterm" id="idx1112"/><a class="indexterm" id="idx1474"/><a class="indexterm" id="idx1799"/>When you don’t feel like doing the math, you can refer to <a class="xref" href="ch11.html#ipv4_netmasks_and_ip_address_conversions" title="Table 11-1. Table 11-1: IPv4 Netmasks and IP Address Conversions">Table 11-1</a> or install the <code class="literal">ipcalc</code> package for quick netmask calculations. Don’t say I never take pity on my readers.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id433870" id="id433870">28</a>]</sup></p></div><div class="sect2" title="Viewing IPv4 Addresses"><div class="titlepage"><div><div><h3 class="title" id="viewing_ipv4_addresses">Viewing IPv4 Addresses</h3></div></div></div><p>Display IP addresses with <code class="literal">ifconfig(8)</code>. If you run <code class="literal">ifconfig</code> without any arguments, it displays all interfaces on the machine.</p><a id="I_programlisting11_id458414"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig fxp0</strong></span>
…
        inet 192.0.2.226 netmask 0xfffffff0 broadcast 192.0.2.239
        inet 192.0.2.231 netmask 0xffffffff
…</pre><p>The lines starting with <code class="literal">inet</code> are IPv6 addresses. This interface has the primary IPv4 address of 192.0.2.226 and a secondary, or <span class="emphasis"><em>alias</em></span>, address of 192.0.2.231. You can also see the netmask of each of these addresses and the broadcast address for the subnet.</p></div><div class="sect2" title="Unusable IPv4 Addresses"><div class="titlepage"><div><div><h3 class="title" id="unusable_ipv4_addresses">Unusable IPv4 Addresses</h3></div></div></div><p>Every block of IPv4 addresses reserves the first and last IP addresses for use by the network:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The first IP address in a block is the <span class="emphasis"><em>network address</em></span>, used for separating networks (and on primordial BSD systems, the broadcast address). On a /24 network, this would be an address ending in .0.</p></li><li class="listitem"><p>The last IP address in the block is the <span class="emphasis"><em>broadcast address</em></span>. On a /24 network, the broadcast address ends in .255.</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="ch11note02"/>Note</h3><p>According to the IP specifications, every machine on a network is supposed to respond to a request to the broadcast address. Unfortunately, in the late 1990s, this feature was used as an attack technique: All you needed to do was ping the broadcast address on any given network, and you would have a list of all IP addresses currently in use. Consequently, this functionality is now disabled by default on most operating systems and network appliances.</p></div><p>You cannot assign the first or the last IP address in a network to a device without risking network problems. Some systems fail gracefully, others fail painfully, and a rare few make it work. Although OpenBSD won’t object if you use the top and bottom network addresses, prepare for mayhem the first time you plug in a commodity printer or other embedded device. It takes only one inflexible device to ruin your whole day.</p></div><div class="sect2" title="Special IPv4 Addresses"><div class="titlepage"><div><div><h3 class="title" id="special_ipv4_addresses">Special IPv4 Addresses</h3></div></div></div><p><a class="indexterm" id="idx1107"/><a class="indexterm" id="idx1109"/><a class="indexterm" id="idx1115"/><a class="indexterm" id="idx1209"/><a class="indexterm" id="idx1875"/><a class="indexterm" id="idx1959"/><a class="indexterm" id="idx1968"/>Quite a few blocks of IPv4 addresses are set aside for specific purposes. Although you don’t need to know all of them, there are two groups you’ll see pretty often. For a complete list of IPv4 subnets reserved for special purposes, read RFCs 5735 and 6598.</p><div class="sect3" title="Localhost"><div class="titlepage"><div><div><h4 class="title" id="localhost-id00001">Localhost</h4></div></div></div><p>The address range 127.0.0.1/8 is set aside for <span class="emphasis"><em>localhost</em></span>, a machine’s address for itself. Every Unix-like system—and most other operating systems—attaches 127.0.0.1/8 to a loopback interface. Everything knows that the localhost address is local to the specific machine. Packets to or from 127.0.0.0/8 should never cross the network; likewise, daemons bound only to 127.0.0.1 can be accessed on only the local machine.</p></div><div class="sect3" title="Private Networks"><div class="titlepage"><div><div><h4 class="title" id="private_networks">Private Networks</h4></div></div></div><p>Internet standard RFC 1918 sets aside three networks for use on private networks and behind network address translation (NAT) devices: 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16. While public IP addresses must be issued by an ISP, anyone can use addresses within these three blocks as long as those hosts are not directly exposed to the public Internet. If you have a network where hosts do not have access to the Internet, or if you provide Internet access through a proxy server or NAT, you can use an RFC 1918 network.</p></div></div><div class="sect2" title="IPv4 Addressing Pitfalls"><div class="titlepage"><div><div><h3 class="title" id="ipv4_addressing_pitfalls">IPv4 Addressing Pitfalls</h3></div></div></div><p>Common wisdom dictates that each computer on a network is assigned a single IP address for each of its network interfaces. One computer, one network card, one IP address—simple, right?</p><p>Not always. Some special-purpose interfaces (such as those dedicated to packet sniffing) function as intended without an IP address, and many operating systems will allow you to assign multiple IP addresses to a single network interface through a process called <span class="emphasis"><em>aliasing</em></span>. You can also bond multiple physical cards into a single network interface, giving the computer one large virtual interface. While you might not deal with these configurations every day, keep them in mind when troubleshooting.</p></div></div><div class="sect1" title="IPv6 Addresses and Subnets"><div class="titlepage"><div><div><h2 class="title" id="ipv6_addresses_and_subnets" style="clear: both">IPv6 Addresses and Subnets</h2></div></div></div><p>There’s a basic problem with IPv4: It provides only 4.29 billion addresses, and that’s just not enough. Without subnetting, that’s fewer than one address for every human being. Eventually, every person will have at least one IP-capable device.</p><p>Although IPv4 addresses haven’t run out yet, they’re becoming an increasingly scarce resource. Overly generous allocations in the early days, along with large chunks of address space reservations for special purposes, have accelerated exhaustion. The world is slowly grinding toward IPv4’s replacement: IPv6.</p><p>Some parts of the world already use IPv6 extensively. Even if your network doesn’t use IPv6 today, one day you’ll need it—probably without warning. Prepare yourself now, or one day you’ll discover that you needed it the week before.</p><div class="sect2" title="IPv6 Basics"><div class="titlepage"><div><div><h3 class="title" id="ipv6_basics">IPv6 Basics</h3></div></div></div><p>Like IPv4, IPv6 is a network layer protocol. IPv4 uses 32-bit addresses, usually expressed as four groups of decimal numbers from 0 to 255 (for example, 192.0.2.13). IPv6 uses 128-bit addresses, expressed as six groups of four hexadecimal characters separated by colons (for example, 2001:db8:0:bad:c0de:cafe). A 128-bit address space gives enough IPv6 addresses for every atom in the Earth to have more than 10 IP addresses. TCP, UDP, ICMP, and other protocols run atop it. IPv6 has its own layer 2 protocol, Neighbor Discovery, which replaces protocols such as Ethernet’s ARP.</p><p>The good news is that you don’t need to relearn the basics of networking. Hosts still need an IP address and a default gateway, routers still use a routing table, and you can almost—<span class="emphasis"><em>almost</em></span>—substitute an IPv6 address for an IPv4 address and watch everything work. A web server doesn’t care if it binds to port 80 on 192.0.2.13 or on 2001:db8:a12a:bad:c0de:café. The server just accepts requests sent to it and responds appropriately. That said, software does need to change slightly, because our web server must be able to log connections from both IPv4 and IPv6 addresses. These changes have wide-reaching repercussions, and we’ll be sorting out edge cases for the next decade. But, in general, once you understand the new rules for IPv6, all of your networking knowledge is applicable.</p></div><div class="sect2" title="Understanding IPv6 Addresses"><div class="titlepage"><div><div><h3 class="title" id="understanding_ipv6_addresses">Understanding IPv6 Addresses</h3></div></div></div><p>As noted, IPv6 addresses are 128 bits, expressed as six colon-delimited groups of four hexadecimal characters each. As with decimal IPv4 addresses, you don’t need to display leading zeros in each group. The address 2001:db8:0:bad:c0de:cafe could also be written as 2001:db8:0000:0bad:c0de:cafe, but just as we wouldn’t write 192.000.002.013, we strip out the leading zeros in an IPv6 address.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id369078" id="id369078">29</a>]</sup></p><p>IPv6 addresses often contain long strings of zeros. This had to do with subnetting, which I’ll describe later in this section. As of this writing, the IPv6 address of Sprint’s website is 2600:0:0:0:0:aaaa. When consecutive groups include only zeros, as in this address, they’re replaced with two colons (<code class="literal">::</code>). This IP address is usually displayed as 2600::aaaa. You can do this only once per address, however. You can’t, for example, have the address 2600::1::1, because it’s ambiguous. Does 2600::1::1 represent 2600:0:0:1:0:1 or does it represent 2600:0:1:0:0:1? I don’t know, and neither does your server.</p><p>You’ve probably seen a port number added to an IPv4 address, such as 192.0.2.13:80. Using a colon to glue a port number to an IPv6 address would be confusing. The IPv6 address 2001:db8::bad:c0de:cafe:80 isn’t ambiguous, but if you read it quickly, you might miss the double colon and think this is an IP address ending in 80. If you’re adding a port number to an IPv6 address, enclose the address in square brackets, as in [2001:db8::bad:c0de:cafe]:80.</p></div><div class="sect2" title="Viewing IPv6 Addresses"><div class="titlepage"><div><div><h3 class="title" id="viewing_ipv6_addresses">Viewing IPv6 Addresses</h3></div></div></div><p><a class="indexterm" id="idx1011"/><a class="indexterm" id="idx1121"/><a class="indexterm" id="idx1122"/><a class="indexterm" id="idx2261"/>Use <code class="literal">ifconfig(8)</code> to see all IPv6 addresses assigned on your machine. Here, I give <code class="literal">ifconfig</code> the name of my network card, <code class="literal">fxp0</code>.</p><a id="I_programlisting11_id458779"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig fxp0</strong></span>
…
       inet 192.0.2.13 netmask 0xfffffff0 broadcast 198.0.2.255
       inet6 fe80::bad:c0de:cafe%fxp0 prefixlen 64 scopeid 0x2
       inet6 2001:db8::bad:c0de:cafe prefixlen 64 autoconf pltime 604399 vltime 2591599
…</pre><p>The lines starting with <code class="literal">inet6</code> are my IPv6 addresses. This interface has been assigned two IPv6 addresses: <code class="literal">fe80::bad:c0de:cafe%fxp0</code> and <code class="literal">2001:db8::bad:c0de:cafe</code>. (Wait … where did that <code class="literal">%fxp0</code> come from? You’ll find out in <a class="xref" href="ch11.html#link_local_addresses" title="Link Local Addresses">Link Local Addresses</a>. For now, just nod and smile, and keep reading.)</p></div><div class="sect2" title="IPv6 Subnets"><div class="titlepage"><div><div><h3 class="title" id="ipv6_subnets">IPv6 Subnets</h3></div></div></div><p>Unlike IPv4, where you can subnet at any bit, IPv6 is usually subnetted at colon boundaries. Colons appear every 16 bits, so the natural IPv6 subnets are /16, /32, /48, and /64. Though IPv6 standards recommend using /64 as the smallest possible network, many carriers use /80, /96, and /112 networks for special purposes. (I’ve also seen people use subnets not divided at 16-bit boundaries. I won’t cover them, but don’t let your brain explode when you encounter a /51.) IPv6 subnets are always expressed as a slash, also known as a <span class="emphasis"><em>prefix length</em></span>, so you won’t see a netmask of ffff:ffff:ffff:ffff::, as you might in IPv4.</p><p>ISPs are usually issued a /32 or a /48 subnet and are expected to issue end-user networks, such as the typical home network, a /64 network. If ISPs do issue /64 subnets to their users, an end-user network will provide 264 IP addresses, or 18,446,744,073,709,551,616 IP addresses. (This will suffice for any number of televisions, phones, refrigerators, water faucets, vacuums, and network-enabled tacos.)</p><p>When you subnet at 16-bit boundaries, each network has 65,536 subnets of the next smaller size. A /32 contains 65,536 /48 networks, and a /48 contains 65,536 /64 networks.</p></div><div class="sect2" title="Special IPv6 Addresses"><div class="titlepage"><div><div><h3 class="title" id="special_ipv6_addresses">Special IPv6 Addresses</h3></div></div></div><p>Like its predecessor, IPv6 reserves several blocks of addresses for special purposes. You don’t need to memorize all of these reserved addresses, but some will appear in daily use.</p><div class="sect3" title="localhost"><div class="titlepage"><div><div><h4 class="title" id="localhost-id00002">localhost</h4></div></div></div><p><a class="indexterm" id="idx1116"/><a class="indexterm" id="idx1195"/><a class="indexterm" id="idx1210"/><a class="indexterm" id="idx2002"/>IPv6’s localhost address, ::1/128, works much like 127.0.0.1 in IPv4: It always refers to the local machine. In OpenBSD, ::1/128 is always assigned to the <code class="literal">lo0</code> interface.</p></div><div class="sect3" title="Link Local Addresses"><div class="titlepage"><div><div><h4 class="title" id="link_local_addresses">Link Local Addresses</h4></div></div></div><p>Addresses beginning with fe8<span class="emphasis"><em>x</em></span>: (where <span class="emphasis"><em>x</em></span> is variable) are local to their interface. Every link has such <span class="emphasis"><em>link local</em></span> addresses that are valid only on a specific local network. Even if an IPv6 network has no router, the hosts on the local, directly attached network can find each other and communicate using these local addresses. These networks are always /64 subnets. You’ll see identical IPv6 subnets on other interfaces and on networks completely disconnected from your network. That’s okay. These addresses are local to the link. For example, here’s a link local address on an OpenBSD machine:</p><a id="I_programlisting11_id458940"/><pre class="programlisting">inet6 fe80::bad:c0de:cafe<span class="strong"><strong>%fxp0</strong></span> prefixlen 64 scopeid 0x2</pre><p>The link local address of this interface is <code class="literal">fe80::bad:code:cafe</code>. The trailing <code class="literal">%fxp0</code> indicates that this address is local to the interface <code class="literal">fxp0</code> and isn’t usable on any other interface on the machine. If your machine has an interface <code class="literal">fxp1</code>, and a host on that network tries to reach the address fe80::bad:code:cafe, this machine will not respond. This particular address is valid only for the network attached to interface <code class="literal">fxp0</code>.</p><p>You might note that the link local address has a section in common with the public IPv6 address on this network. That’s because an autoconfigured IPv6 address is usually calculated from the interface’s physical address; it doesn’t matter whether that autoconfigured address is on a public address or a link local address.</p></div></div><div class="sect2" title="Assigning IPv6 Addresses"><div class="titlepage"><div><div><h3 class="title" id="assigning_ipv6_addresses">Assigning IPv6 Addresses</h3></div></div></div><p>IPv6 clients can usually use autoconfiguration through <span class="emphasis"><em>router discovery</em></span>, anIPv6 protocol where routers announce their presence on the network and the legitimate addresses to clients. Unfortunately, IPv6 autoconfiguration does not support common Dynamic Host Configuration Protocol (DHCP) options, such as assigning a Domain Name Service (DNS) server, let alone the options used for diskless configuration. If you have configured a DNS server—even IPv4 servers accessible on a dual-stacked host—autoconfiguration works just fine. If you run an IPv6-only network, you must either set up an IPv6 DHCP server to provide DNS server information to clients or configure DNS servers manually.</p><p>Servers should not use IPv6 autoconfiguration. A server usually needs a static IP address, even in IPv6. Similarly, routers cannot use autoconfiguration. If a host can forward packets, it requires a static IPv6 address.</p><p>You can assign multiple IPv6 addresses to a single interface by using aliases, just as with IPv4.</p><p>In IPv6, a client on a /64 network can use autoconfiguration.</p><p><a class="indexterm" id="idx1003"/><a class="indexterm" id="idx1076"/><a class="indexterm" id="idx1800"/><a class="indexterm" id="idx2380"/><a class="indexterm" id="idx2390"/><a class="indexterm" id="idx2451"/><a class="indexterm" id="idx2472"/>IPv6 autoconfiguration resembles a stripped-down DHCP service. The router broadcasts subnet and gateway information, and the hosts configure themselves to use it. Hosts on a network smaller than /64 must be manually configured.</p></div></div><div class="sect1" title="Remedial TCP/IP"><div class="titlepage"><div><div><h2 class="title" id="remedial_tcp_ip" style="clear: both">Remedial TCP/IP</h2></div></div></div><p>Now that you have a simplified overview of how the IP system works, let’s look at a real network protocol in some depth. The dominant transport protocol on the Internet is the Transmission Control Protocol over Internet Protocol, or TCP/IP. Although TCP is a transport protocol and IP is a network protocol, the two are so tightly intertwined that they’re generally referred to as a single entity.</p><p>We’ll start with ICMP, and proceed to UDP and TCP.</p><div class="sect2" title="ICMP"><div class="titlepage"><div><div><h3 class="title" id="icmp">ICMP</h3></div></div></div><p>ICMP is used to transmit routing and availability messages across the network. Tools such as <code class="literal">ping(8)</code> and <code class="literal">traceroute(8)</code> use ICMP. ICMP includes all sorts of different protocols and tools.</p><p>While some people claim that you need to block ICMP for security purposes, those people don’t understand that ICMP is just as diverse as the better-understood transport protocols TCP and UDP. Proper IPv4 network performance requires large chunks of ICMPv4. If you must block ICMPv4 for security reasons, do so selectively. For example, blocking source quench messages breaks path maximum transmission unit (MTU) discovery, which will steer you directly into a world of hurt. If you don’t understand that last sentence, don’t block ICMPv4.</p><p>IPv6 dies without ICMPv6, as IPv6 doesn’t support packet fragmentation, so never block ICMPv6. If you don’t know what packet fragmentation is, just trust me on this.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id453475" id="id453475">30</a>]</sup></p></div><div class="sect2" title="UDP"><div class="titlepage"><div><div><h3 class="title" id="udp">UDP</h3></div></div></div><p>UDP is the most bare-bones data-transfer protocol that runs over IP. It offers no error handling, minimal integrity verification, and no defense whatsoever against data loss. The transport protocol considers each packet of UDP completely self-contained; there are no data-coherence checks at the protocol layer. Despite these drawbacks, UDP can be a good choice for particular sorts of data transfer, and many vital Internet services rely on it.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note03"/>Note</h3><p>This discussion covers both UDPv4 and UDPv6. While each runs over only the corresponding network protocol, they behave identically otherwise.</p></div><p>UDP is also a datagram protocol, meaning that each network transmission is complete and self-contained, and received as a single integral unit. While the application might not consider a single UDP packet a complete request, the network does.</p><p><a class="indexterm" id="idx0287"/><a class="indexterm" id="idx2238"/><a class="indexterm" id="idx2240"/><a class="indexterm" id="idx2254"/><a class="indexterm" id="idx2371"/><a class="indexterm" id="idx2419"/>When a host transmits data via UDP, it has no way of knowing if the data ever reaches its destination. Programs that receive UDP data just listen to the network and accept whatever happens to arrive. When a program receives data via UDP, it cannot verify the source of that data. Although each UDP packet does include a source address, this address is easily faked. Each UDP packet includes a checksum for the packet, but there’s no integrity checking for the data stream as a whole. This is why UDP is called <span class="emphasis"><em>connectionless</em></span>, or <span class="emphasis"><em>stateless</em></span>.</p><p>No integrity checking, no guard against data loss, the potential for faked packets—all this sounds pretty unreliable. So why use UDP at all?</p><p>UDP-based applications often have their own error-correction methods or otherwise don’t mesh well with more reliable protocols, such as TCP. For example, simple client DNS queries must time out within just a few seconds or users will whine uncontrollably. TCP connections time out only after two minutes. DNS requires quick failures and only a single packet per transaction, which makes UDP a better choice than TCP for simple DNS queries. Real-time streaming services, such as video conferencing applications, also use UDP. (After all, if a few pixels go missing during a video conference, you don’t want those pixels a minute later.) Most other UDP-based applications use UDP for similar reasons.</p><p>Because the UDP protocol itself doesn’t return anything when you connect to a port, there’s no reliable way to remotely test if a UDP port is reachable (although tools such as <code class="literal">nmap</code> try to do so).</p><p>If you want a protocol that responds at the network layer, look at TCP.</p></div><div class="sect2" title="TCP"><div class="titlepage"><div><div><h3 class="title" id="tcp">TCP</h3></div></div></div><p>TCP includes nifty features, such as error correction and recovery. The receiver must acknowledge every packet it gets; otherwise, the sender retransmits any unacknowledged packets. Unlike UDP, applications that use TCP can expect reliable data transmission. This makes TCP a <span class="emphasis"><em>connected</em></span>, or <span class="emphasis"><em>stateful</em></span>, protocol.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note04"/>Note</h3><p>This discussion covers both TCPv6 and TCPv4. While they differ because of their underlying transport protocol, they behave in the same way.</p></div><p>TCP is also a <span class="emphasis"><em>streaming protocol</em></span>, which means that a single request can be split among several network packets. While the sender might transmit several chunks of data one after the other, that data might arrive out of order or fragmented. The recipient must track these chunks and assemble them properly to complete the network transaction.</p><p>For hosts to exchange TCP data, they must set up a channel for that data to flow across. One host requests a connection, the other host responds to the request, and then the first host starts transmitting. This setup process is known as the <span class="emphasis"><em>three-way handshake</em></span>. Similarly, once transmission is complete, the systems must do a certain amount of work to tear down the connections.</p><p><a class="indexterm" id="idx1225"/><a class="indexterm" id="idx1574"/><a class="indexterm" id="idx1829"/><a class="indexterm" id="idx2374"/>To test if a TCP port is open, you can use <code class="literal">telnet(1)</code> or <code class="literal">nc(1)</code> to connect to the port. Here, I see if I can connect to port 22 on the host <code class="literal">caddis</code>.</p><a id="I_programlisting11_id459338"/><pre class="programlisting">  $ <span class="strong"><strong>telnet caddis 22</strong></span>
  Trying 192.0.2.35…
  Connected to caddis.
  Escape character is '^]'.
  SSH-2.0-OpenSSH_6.0
<span class="strong"><strong>1</strong></span> <span class="strong"><strong>^]</strong></span>
<span class="strong"><strong>2</strong></span> telnet&gt; <span class="strong"><strong>c</strong></span>
  Connection closed.</pre><p>I connect to the remote port and see information displayed by the port, use the telnet escape character <span class="strong"><strong><code class="literal">^]</code></strong></span> (<span class="smallcaps">CTRL</span>-]) to disconnect <span class="strong"><strong>1</strong></span>, and enter <span class="strong"><strong><code class="literal">c</code></strong></span> <span class="strong"><strong>2</strong></span> to close telnet.</p><p>TCP is commonly used by applications most suited to its fairly generic set of timeouts and transmission features, such as email programs, FTP clients, and web browsers.</p></div><div class="sect2" title="How Protocols Fit Together"><div class="titlepage"><div><div><h3 class="title" id="how_protocols_fit_together">How Protocols Fit Together</h3></div></div></div><p>You can compare the network stack to sitting with your family at a holiday dinner. The datalink layer (ARP, in the case of Ethernet) lets you see everyone else at the table. IP gives every person at the table their own unique chair (except for the twins using piano bench NAT). ICMP provides basic, lower-layer information such as “The quickest way to the baked sweet potatoes is to get Uncle Mike to pass them”?<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id324463" id="id324463">31</a>]</sup> or “Aunt Liz can’t lift the ham platter.” TCP is where you hand someone the butter and the other person must say “thanks” before you let it go. UDP is like tossing a roll at Grandma Lucas; she might catch it or it might bounce off her forehead.</p></div><div class="sect2" title="Transport Protocol Ports"><div class="titlepage"><div><div><h3 class="title" id="transport_protocol_ports">Transport Protocol Ports</h3></div></div></div><p>Transport protocol ports permit one server to serve many different services over a single transport protocol, multiplexing connections between machines. When a network server starts, it attaches, or <span class="emphasis"><em>binds</em></span>, to one or more logical ports. A logical port is just an arbitrary number ranging from 0 to 65536, although nothing uses port 0. For example, Internet mail servers often bind to port 25.</p><p>Each TCP or UDP packet arriving at a system carries a field containing its desired destination port number. If an incoming packet asks for port 25, it is connected to the mail server running on that port. This means that other programs can run on other ports, clients can talk to those different ports, and no one gets confused except you.</p><p>Note that port assignments are not some sort of physical constant, but rather are mutually agreed upon. There’s no reason that email services should run on port 25 other than the fact that everyone agrees that they should. If someone tries to send you email, their mail server will automatically connect to port 25 on your server. If you run email on port 80 and have a web server on port 25, you’ll never get your email, and your web server won’t get much traffic.</p><p><a class="indexterm" id="idx0742"/><a class="indexterm" id="idx0990"/><a class="indexterm" id="idx1834"/><a class="indexterm" id="idx1961"/><a class="indexterm" id="idx2375"/>The file <span class="emphasis"><em>/etc/services</em></span> contains a list of port numbers and the associated services. The file has a very simple, five-column format, as shown in these two sample lines:</p><a id="I_programlisting11_id459520"/><pre class="programlisting">www             80/tcp          http    # WorldWideWeb
www             80/udp                  # HyperText Transfer Protocol</pre><p>The first field is the name of the service assigned to this port. This entry is for the service <code class="literal">www</code>. Port 80 is assigned to <code class="literal">www</code>, both TCP and UDP. Then there’s a list of any other names assigned to this port. Port 80 is also known as <code class="literal">http</code>. Finally, there’s a comment that gives more detail about the service.</p><p>The HTTP protocol used on the Web runs over TCP, so why is UDP port 80 also reserved for HTTP? The answer is pretty simple: Computer people are easily confused. Having two services share the same port number but run on different protocols confuses people—for example, the <code class="literal">syslog</code> service runs on port 514 via UDP, and the <code class="literal">lpr</code> printer protocol runs on port 514 over TCP.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id322914" id="id322914">32</a>]</sup></p><p>Some server programs read <span class="emphasis"><em>/etc/services</em></span> to learn which port to bind to on startup, and many client programs read <span class="emphasis"><em>/etc/services</em></span> to learn which port they should try to connect to. If you run servers on unusual ports, you might need to edit this file to get these programs to attach where needed.</p><p>As with all standards, there are times you will want to break the rules. The SSH daemon <code class="literal">sshd</code> normally binds to port 22/TCP, but I’ve run it on ports 23 (<code class="literal">telnet</code>), 80 (<code class="literal">www</code>), 443 (<code class="literal">https</code>), and others to evade naïve packet-filtering firewalls. You will find your own reasons to break the standards. That’s fine, as long as you understand what you’re doing and how it affects others.</p></div><div class="sect2" title="Reserved Ports"><div class="titlepage"><div><div><h3 class="title" id="reserved_ports">Reserved Ports</h3></div></div></div><p>Ports below 1024 in both TCP and UDP can be opened only by the root user. These ports are assigned (mostly) to core Internet infrastructure protocols, such as DNS, SSH, HTTP, LDAP, and so on—services that only a few select hosts on each network should offer. Only programs with root-level privileges can bind to reserved ports. For example, a user can run a game server on a high-numbered port if the system policy allows, but that’s different from setting up a web page visible to the whole world that claims the machine’s official purpose is a game server. The port assignment for these core protocols is generally permanent, and if you want to interoperate with other sites, you won’t change them.</p><p><a class="indexterm" id="idx1472"/><a class="indexterm" id="idx1830"/><a class="indexterm" id="idx1832"/><a class="indexterm" id="idx2373"/>OpenBSD software usually binds to a reserved port as root and then drops privileges, performing the rest of its functions as an unprivileged user. These unprivileged users, discussed in <a class="xref" href="ch06.html" title="Chapter 6. User Management">Chapter 6</a>, have even fewer privileges than a normal user account.</p><p>If you must run a service that binds to a reserved port, and it can run only as root, consider carefully whether you actually need it. Try to find an alternative server that does privilege separation. If you can’t, at least install that service on a dedicated machine to reduce its threat to other services on your network.</p></div><div class="sect2" title="Which Ports Are Open?"><div class="titlepage"><div><div><h3 class="title" id="which_ports_are_open">Which Ports Are Open?</h3></div></div></div><p>So, network services are made available via TCP or UDP ports. Programs bind to ports to offer network services. This brings up two obvious questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Which ports are open?</p></li><li class="listitem"><p>What programs are listening to each port?</p></li></ul></div><p>You can answer these questions with <code class="literal">netstat(1)</code> and <code class="literal">fstat(1)</code>.</p><div class="sect3" title="Using netstat"><div class="titlepage"><div><div><h4 class="title" id="using_netstat">Using netstat</h4></div></div></div><p>The <code class="literal">netstat(1)</code> program provides general visibility into the network stack. Use <code class="literal">netstat</code> to check your routing table, examine open sockets, see how many packets are traversing your interfaces, and so on. (I could write an entire book about <code class="literal">netstat</code>, but no one would buy it. Instead, I’ll sprinkle bits of <code class="literal">netstat</code> magic throughout this book.)</p><p>When looking at network information, I recommend turning off DNS lookups by using the <code class="literal">-n</code> flag. You can always rerun a check with DNS turned on, but adding DNS queries to the network sockets can sometimes skew the information you’re viewing, and almost always slows the command.</p><p>The <code class="literal">-f</code> argument lets you choose a protocol family to display. Use <code class="literal">-f inet</code> to see only IPv4 sockets, or <code class="literal">-f inet6</code> to see only IPv6. Read <code class="literal">netstat(1)</code> for the full protocol list.</p><p>Finally, <code class="literal">-a</code> tells <code class="literal">netstat</code> to show all sockets opened by any process, rather than just sockets owned by the user.</p><p>Let’s put all those options together and have a look at the output. Here, I show the open IPv4 sockets on my system:</p><a id="I_programlisting11_id459782"/><pre class="programlisting"> $ <span class="strong"><strong>netstat -na -f inet</strong></span>
 Active Internet connections (including servers)
 Proto   Recv-Q Send-Q    ?Local Address        Foreign Address     (state)
<span class="strong"><strong>1</strong></span>tcp        <span class="strong"><strong>2</strong></span>0      0  <span class="strong"><strong>3</strong></span>192.0.2.135.22      <span class="strong"><strong>4</strong></span>192.0.2.8.49997    <span class="strong"><strong>5</strong></span>ESTABLISHED
 tcp          0      0    127.0.0.1.587       <span class="strong"><strong>6</strong></span>*.*                <span class="strong"><strong>7</strong></span>LISTEN
 tcp          0      0    127.0.0.1.25         *.*                 LISTEN
 tcp          0      0  <span class="strong"><strong>8</strong></span>*.22                 *.*                 LISTEN
 Active Internet connections (including servers)
 Proto   Recv-Q Send-Q    Local Address        Foreign Address     (state)
<span class="strong"><strong>9</strong></span>udp          0      0    127.0.0.1.512        *.*
 udp          0      0    *.514                *.*</pre><p><a class="indexterm" id="idx2474"/>The list starts with open TCP ports <span class="strong"><strong>1</strong></span>. The <code class="literal">Recv-Q</code> and <code class="literal">Send-Q</code> columns <span class="strong"><strong>2</strong></span> show the number of bytes that the system is in the process of receiving or trying to send.</p><p>The <code class="literal">Local Address</code> column shows the IP address attached to the local machine where this socket is listening. It’s possible—common, even—for a service to bind to a port on only a single address on a machine. If the port is part of an actual connection, as the first example <span class="strong"><strong>3</strong></span> shows, the IP address is followed by the port number. This particular TCP connection is attached to port 22 at the address 192.0.2.135. Port 22 is reserved for SSH, so this is probably an SSH connection.</p><p>If the local address is an asterisk followed by a port number <span class="strong"><strong>8</strong></span>, this is a wildcard bind. A program has bound to this port, and has asked the kernel to figure out the IP address. It’s probably (but not necessarily) a listening socket.</p><p>The <code class="literal">Foreign Address</code> column <span class="strong"><strong>4</strong></span> shows the IP address and port of the remote host involved in a connection. If there’s a foreign address shown, it always includes the port. If this column shows two asterisks <span class="strong"><strong>6</strong></span>, that means the service is waiting for a connection on the local port.</p><p>The <code class="literal">(state)</code> column applies only to TCP connections. A live and working TCP connection is in the <code class="literal">ESTABLISHED</code> state <span class="strong"><strong>5</strong></span>. Other states (<code class="literal">SYN_RCVD</code>, <code class="literal">ACK</code>, and <code class="literal">SYN+ACK</code>) are all normal parts of connection creation, while <code class="literal">LAST_ACK</code>, <code class="literal">FIN_WAIT_1</code>, and <code class="literal">FIN_WAIT_2</code> mean that the connection is closing. A state of <code class="literal">LISTEN</code> <span class="strong"><strong>7</strong></span> means that this socket is waiting for an incoming connection.</p><p>UDP ports are given their own section <span class="strong"><strong>9</strong></span>. You might see remote hosts in the UDP section, especially for long-running protocols such as NFS and NTP, but remember that UDP is stateless, so you’ll never see state on a UDP connection.</p><p>If you’re interested in only TCP or UDP sockets, you can use the <code class="literal">-p</code> flag to show only a particular protocol. Here, I look at TCP sockets:</p><a id="I_programlisting11_id460006"/><pre class="programlisting">$ <span class="strong"><strong>netstat -na -p tcp</strong></span>
Active Internet connections (including servers)
Proto   Recv-Q Send-Q  Local Address          Foreign Address      (state)
tcp          0     52  192.0.2.135.22         192.0.2.8.49997      ESTABLISHED
tcp6         0      0  ::1.587                *.*                  LISTEN
tcp          0      0  127.0.0.1.587          *.*                  LISTEN
tcp6         0      0  ::1.25                 *.*                  LISTEN
tcp          0      0  127.0.0.1.25           *.*                  LISTEN
tcp          0      0  *.22                   *.*                  LISTEN
tcp6         0      0  *.22                   *.*                  LISTEN</pre><p>While this looks similar to the first output example, note that we see both IPv4 and IPv6 TCP connections and services. TCP runs over both IPv4 and IPv6, so choosing it shows both address families. It’s entirely possible to have a service running on one address family and not the other. Many of my systems listen for incoming SSH connections only on IPv6; doing so hides me from port scanners and worms (for now, anyway).</p><p><a class="indexterm" id="idx0895"/><a class="indexterm" id="idx1095"/><a class="indexterm" id="idx1831"/><a class="indexterm" id="idx2381"/>Rather than listing every service waiting for an incoming connection, you can show only live connections by dropping the <code class="literal">-a</code> flag:</p><a id="I_programlisting11_id460071"/><pre class="programlisting">$ <span class="strong"><strong>netstat -np tcp</strong></span>
Active Internet connections
Proto   Recv-Q Send-Q  Local Address       Foreign Address    (state)
tcp          0     52  192.0.2.135.22      192.0.2.8.49997    ESTABLISHED</pre></div><div class="sect3" title="Using fstat"><div class="titlepage"><div><div><h4 class="title" id="using_fstat">Using fstat</h4></div></div></div><p>Now that you know which TCP and UDP ports are open, how can you tell which programs are listening on them? OpenBSD includes <code class="literal">fstat(1)</code>, a program that displays all open files and sockets on the system. Network connections are open sockets. Running <code class="literal">fstat</code> on an idle system can generate hundreds of lines of output—one entry for each file opened by any process. While that’s educational and useful, it’s not what we’re looking for. Specifically, we want to see which programs are holding network sockets open. The string <code class="literal">internet</code> indicates network sockets.</p><a id="I_programlisting11_id460110"/><pre class="programlisting">$ <span class="strong"><strong>fstat | grep internet</strong></span>
mwlucas  sshd       21403    3* internet stream tcp 0xd5365994 192.0.2.235:22 &lt;-- 192.0.2.8:49997
root     sendmail   19063    4* internet stream tcp 0xd537e330 127.0.0.1:25
root     sendmail   19063    5* internet6 stream tcp 0xd537e4c8 [::1]:25
root     sendmail   19063    6* internet stream tcp 0xd537e660 127.0.0.1:587
root     sendmail   19063    7* internet6 stream tcp 0xd537e7f8 [::1]:587
root     sshd       29561    3* internet6 stream tcp 0xd537e000 *:22
root     sshd       29561    4* internet stream tcp 0xd537e198 *:22
_syslogd syslogd    12885    4* internet dgram udp *:514</pre><p>First, you see an <code class="literal">sshd</code> process owned by the user <code class="literal">mwlucas</code>. That’s an unprivileged process, tied to a particular SSH session. Further down the list, you see an SSH daemon owned by root listening to the network. When a connection request arrives, the root-owned SSH daemon will hand it off to an unprivileged child process. You can also see that we have a variety of <code class="literal">sendmail</code> processes listening to the network.</p><p>This system runs the expected SSH and email servers, and no one has bound anything to odd ports. My nasty paranoid suspicions were unfounded (this time, anyway).</p><p>Between <code class="literal">netstat</code> and <code class="literal">fstat</code>, you should be able to get a good idea of what your system is doing on your network at any given time.</p></div></div></div><div class="sect1" title="IP Routing"><div class="titlepage"><div><div><h2 class="title" id="ip_routing" style="clear: both">IP Routing</h2></div></div></div><p>Most sysadmins don’t need to understand much about IP routing, because most servers have only one network interface and one default gateway. The network administrator gives you an IPv4 address and a default route, you put them in the appropriate configuration files, and you’re routed. You don’t need even that for most IPv6 hosts, as autoconfiguration makes things magically work. Servers will need a static IPv6 address and a manual default route.</p><p><a class="indexterm" id="idx0121"/><a class="indexterm" id="idx0190"/><a class="indexterm" id="idx0390"/><a class="indexterm" id="idx1097"/><a class="indexterm" id="idx1575"/><a class="indexterm" id="idx1642"/><a class="indexterm" id="idx1971"/><a class="indexterm" id="idx2003"/><a class="indexterm" id="idx2004"/><a class="indexterm" id="idx2383"/>Some servers have multiple interfaces, such as one to their default gateway and another to a group of related application or backup servers. OpenBSD systems frequently wind up in the network infrastructure, however, or sit in demilitarized zones (DMZs) where the server must make routing decisions. If you want to use OpenBSD in such an environment, or as a firewall, you must understand the basics of routing.</p><p><span class="emphasis"><em>Routing</em></span> is simply deciding where to send packets. If your system is attached to a network, it doesn’t need to make any decisions; it just sends the packet to that network. Your system on 192.0.2.0/24 already knows how to reach any IP address beginning with 192.0.2—it can just send everything out to the local Ethernet. Where does it send those packets?</p><p>Most computers use a <span class="emphasis"><em>default route</em></span>, which is an IP address on the local network where they send all packets bound for nonlocal IP addresses. This is very common where one router or firewall provides all network access. This device probably also has a default route that points to your ISP, which makes all the complicated routing decisions for you.</p><p>In other cases, you might have a dynamic routing protocol running on your network. If you’re using Open Shortest Path First (OSPF), Border Gateway Protocol (BGP), or Routing Information Protocol (RIP), OpenBSD has daemons specifically for integrating these protocols. There’s an introductory middle ground between full dynamic routing and simple default routes, however, and you should understand it before attempting full dynamic routing.</p><p>We’ll cover a simple case here using an IPv4 example. (IPv6 routing is exactly like IPv4 routing, but with a lot more colons.)</p><div class="sect2" title="IPv4 Routed Network Example"><div class="titlepage"><div><div><h3 class="title" id="ipv4_routed_network_example">IPv4 Routed Network Example</h3></div></div></div><p>If a network has multiple gateways leading to different networks, hosts on the network must make routing decisions. Suppose your network has multiple routers attached to it, each going to a different network. Machines on your network decide where to send packets. Here’s an example of a common double-firewall situation:</p><div class="informalfigure"><a id="med_id00001"/><div class="mediaobject"><a id="I_mediaobject11_id460300"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1616080.png"/></div></div><p>In this network design, hosts must transit a DMZ before entering either the Internet or the internal network. (Other designs exist, such as the hub-and-spoke model, but I’ve specifically chosen a design where routing is needed.)</p><p><a class="indexterm" id="idx0503"/><a class="indexterm" id="idx0861"/><a class="indexterm" id="idx1099"/><a class="indexterm" id="idx1999"/><a class="indexterm" id="idx2005"/><a class="indexterm" id="idx2385"/>The external firewall provides one layer of protection. It permits only traffic specifically deemed necessary (we’ll go into the default deny stance in <a class="xref" href="ch21.html" title="Chapter 21. Packet Filtering">Chapter 21</a>). It does, however, permit incoming connections to hosts in your DMZ.</p><p>The hosts in the DMZ are to some extent vulnerable. They are not trusted enough to be on the internal network. Your intrusion-detection systems or your web servers might live here.</p><p>The internal firewall, like the external firewall, permits only traffic deemed necessary to organization purposes. It probably doesn’t allow any connections from the outside world, however, and it doesn’t trust the hosts on the DMZ.</p><p>Only highly trusted hosts are permitted on the internal network. This is where the organization keeps its most precious data, such as the financial records, customer databases, and movie collections.</p><p>Many of the hosts in this network need to make only very simple routing decisions. Anything on the internal network has just one way to reach anything, and any host on the Internet has only one way to reach the internal or DMZ networks.</p><p>The external firewall is directly attached to the DMZ network, so it can send packets to those hosts. It needs a default route pointing to the Internet so it can reach the rest of the world. To reach the hosts on the internal network, it must send packets to the internal firewall’s external interface. If you don’t configure this on the external firewall, data will never reach the internal firewall. Because the external firewall is responsible for the internal network’s Internet access, losing this route would disconnect the internal network from the Internet; internal systems could send packets, but would never receive any. The external firewall needs routing.</p><p>Similarly, you could configure routing on each host inside the DMZ. In that case, ICMP redirects from the firewalls would provide routing for these hosts, but trusting ICMP redirects on a vulnerable network is unwise and messy because it assumes that every host on the DMZ and every firewall accepts and sends ICMP redirects. If you’re using OpenBSD, you want your server to be secure, so configure routing on your DMZ systems.</p><p>In this example, I configure routing for the external firewall. Configuring routing for the DMZ hosts is nearly identical to this example.</p></div><div class="sect2" title="Managing Routing with route(8)"><div class="titlepage"><div><div><h3 class="title" id="managing_routing_with_route8">Managing Routing with route(8)</h3></div></div></div><p>The <code class="literal">route(8)</code> command manages all system routing. Like <code class="literal">netstat</code>, <code class="literal">route</code> has several subfunctions that allow you to view, edit, and monitor the system routing table. While the <code class="literal">route(8)</code> man page has complete details, the ability to view, add, and delete routes should be enough to get you started.</p><div class="sect3" title="Viewing Routes"><div class="titlepage"><div><div><h4 class="title" id="viewing_routes">Viewing Routes</h4></div></div></div><p>OpenBSD, like any other network device, keeps routes in a routing table. To view the IPv4 and IPv6 routes, enter <span class="strong"><strong><code class="literal">route show</code></strong></span>. Add <span class="strong"><strong><code class="literal">-n</code></strong></span> to remove IP-address-to-name translations.</p><p><a class="indexterm" id="idx0123"/><a class="indexterm" id="idx1643"/>Here’s the IPv4 routing table:</p><a id="I_programlisting11_id460502"/><pre class="programlisting">  $ <span class="strong"><strong>route -n show</strong></span>
  Routing tables
  Internet:
  Destination        Gateway            Flags   Refs      Use   Mtu  Prio Iface
<span class="strong"><strong>1</strong></span> default            192.0.2.1          UGS        4     6414     -     8 vic0
<span class="strong"><strong>2</strong></span> 127/8              127.0.0.1          UGRS       0        0 33196     8 lo0
<span class="strong"><strong>3</strong></span> 127.0.0.1          127.0.0.1          UH         1      170 33196     4 lo0
<span class="strong"><strong>4</strong></span> 192.0.2.32/24      link#1             UC         1        0     -     4 vic0
<span class="strong"><strong>5</strong></span> 192.0.2.1          00:0c:42:20:7f:42  UHLc       1        0     -     4 vic0
<span class="strong"><strong>6</strong></span> 224/4              127.0.0.1          URS        0        0 33196     8 lo0</pre><p>The table shows the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">Destination</code> field lists the range of IP addresses this route applies to—destination addresses. The <code class="literal">default</code> entry indicates the default gateway, which is where the system sends all packets that have no specific route.</p></li><li class="listitem"><p>The <code class="literal">Gateway</code> field tells where packets for this route should be sent. A gateway could be a hostname, an IP address, or a network interface.</p></li><li class="listitem"><p>The <code class="literal">Flags</code> field contains markers that indicate what sort of route this is and how it behaves. The next section covers the various route flags.</p></li><li class="listitem"><p>The <code class="literal">Refs</code> field shows the number of references to the route in the kernel (also known as the <span class="emphasis"><em>refcounter</em></span>). If the refcounter drops to zero, the route is removed. This has no practical use for system administration, because one reference is sufficient to keep the route in the routing table; additional references don’t change anything.</p></li><li class="listitem"><p>The <code class="literal">Use</code> counter increments each time a packet uses that route.</p></li><li class="listitem"><p>The <code class="literal">Mtu</code> is the MTU—the largest frame size that can travel over this route. If the field contains a hyphen (<code class="literal">-</code>), OpenBSD uses the MTU of the underlying physical interface. The loopback interface, <code class="literal">lo0</code>, isn’t a physical interface, so OpenBSD explicitly sets the MTU very high. You might see a route with a lower MTU if Path MTU Discovery has kicked in.</p></li><li class="listitem"><p>The <code class="literal">Prio</code> field gives the route priority. OpenBSD supports multiple routes to a single destination. Some routes are more desirable than others, and OpenBSD will use the route with the lowest priority number. Routes provided by dynamic routing protocols, such as BGP or OSPF, get higher priority numbers than static routes.</p></li><li class="listitem"><p>The <code class="literal">Iface</code> field shows which interface this route uses.</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="ch11note05"/>Note</h3><p>OpenBSD also includes dynamic routing daemons such as <code class="literal">ospfd(8)</code> and <code class="literal">bgpd(8)</code>. I don’t cover them here, because that topic would fill a book on its own.</p></div><p>Let’s see what’s interesting in the routes in this sample. The first entry at <span class="strong"><strong>1</strong></span> is the system default route. If there is no more specific route, packets will be sent to the IP address 192.0.2.1.</p><p><a class="indexterm" id="idx1098"/><a class="indexterm" id="idx1244"/><a class="indexterm" id="idx2384"/>To reach the network 127.0.0.0/8 at <span class="strong"><strong>2</strong></span>, packets should go to the IP address 127.0.0.1. 127.0.0.0/8 is the address range reserved for loopback addresses, and 127.0.0.1 is always the local machine. Notice the high MTU; this is a software interface, so there’s no physical limit on the size of frames sent through it.</p><p>To reach the IP address 127.0.0.1 at <span class="strong"><strong>3</strong></span>, send the packets to the IP address 127.0.0.1. This might seem a bit pedantic, but it’s a valid route and needs to be in the table. Remember that 127.0.0.1 is always the loopback address of the local machine.</p><p>To reach the IP address 192.0.2.0/24 at <span class="strong"><strong>4</strong></span>, use a gateway of <code class="literal">link#1</code>. This is a local physical interface—in this case, our Ethernet interface. The interface named <code class="literal">link#1</code> is actually the interface with index <code class="literal">#1</code>, which isn’t really exposed to the system administrator anywhere else. These addresses are local to the machine, and you must figure out which interface this is by the IP address attached to the machine. Addresses local to the machine don’t actually need to be in the routing table, but no one has bothered to remove this historical nit.</p><p>To reach a specific IP address on the local network at <span class="strong"><strong>5</strong></span>, you’ll get a route of the IP address and the physical media address. Because this host is connected via Ethernet, the gateway is a MAC address. Every local address that the system needs to find gets a route entry, and you should almost always show a specific route for the default gateway.</p><p>The last route at <span class="strong"><strong>6</strong></span> is for the multicast address range 224/8. If you’re not using multicast, it should go to the local host.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note06"/>Note</h3><p>Multicast is a complicated topic beyond the scope of this book (again). But if you’re interested, OpenBSD supports multicast just fine.</p></div></div><div class="sect3" title="Route Flags"><div class="titlepage"><div><div><h4 class="title" id="route_flags">Route Flags</h4></div></div></div><p>The <code class="literal">Flags</code> column of the routing table indicates how routes are generated or used. <code class="literal">netstat(1)</code> contains a complete list of route flags. <a class="xref" href="ch11.html#common_route_flags" title="Table 11-2. Table 11-2: Common Route Flags">Table 11-2</a> lists the common ones.</p><div class="table"><a id="common_route_flags"/><div class="table-title">Table 11-2. Table 11-2: Common Route Flags</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flag</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Description</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">C</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This route was cloned.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">c</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This is a protocol-specific route (such as to an Ethernet MAC address).</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">D</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This route is dynamic.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">G</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This route goes via a gateway.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">H</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This route is for a specific host.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">L</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This route is for the local link layer.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">M</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This route was modified.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>This is a reject route. Packets are dropped, and an error is sent.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">B</code></p></td><td style="vertical-align: top; "><p>This is a blackhole route. Packets are dropped silently.</p></td></tr></tbody></table></div></div><p><a class="indexterm" id="idx0391"/><a class="indexterm" id="idx0401"/><a class="indexterm" id="idx0618"/><a class="indexterm" id="idx1096"/><a class="indexterm" id="idx1997"/><a class="indexterm" id="idx1998"/><a class="indexterm" id="idx2382"/>These flags tell you where a route came from and how it’s used.</p></div><div class="sect3" title="Adding Routes"><div class="titlepage"><div><div><h4 class="title" id="adding_routes">Adding Routes</h4></div></div></div><p>Add routes with the <code class="literal">route add</code> command. You must know the destination network, its netmask, and the gateway.</p><a id="I_programlisting11_id461129"/><pre class="programlisting"># <span class="strong"><strong>route add</strong></span> <span class="emphasis"><em>address-block</em></span>/<span class="emphasis"><em>netmask netmask gateway</em></span></pre><p>In our example network, the outer firewall needs a route to reach the private network, 192.0.2.128/25. To route this network to the inner firewall at 192.0.2.2, run this command:</p><a id="I_programlisting11_id461150"/><pre class="programlisting"># <span class="strong"><strong>route add -net 192.0.2.128/25 192.0.2.2</strong></span>
add net 192.0.2.128: gateway 192.0.2.2</pre><p>Packets will use that route immediately. If you run <code class="literal">route show</code>, you’ll see that new route.</p><p>To add a default route, run <code class="literal">route add default</code> with the IP address of the default gateway, like this:</p><a id="I_programlisting11_id461176"/><pre class="programlisting"># <span class="strong"><strong>route add default 192.0.2.1</strong></span>
add net default: gateway 192.0.2.1</pre><p>To add routes automatically at boot, put the <code class="literal">route</code> statement in the <span class="emphasis"><em>/etc/hostname.if</em></span> file that leads to the destination network. These routes appear when the interface is brought up, before <span class="emphasis"><em>/etc/rc.securelevel</em></span> runs or any local daemons start. You’ll see examples of using <span class="emphasis"><em>hostname.if</em></span> for routes in the next chapter.</p><p>To add a default route automatically at boot, put the default router IP address in <span class="emphasis"><em>/etc/mygate</em></span>.</p></div><div class="sect3" title="Deleting Routes"><div class="titlepage"><div><div><h4 class="title" id="deleting_routes">Deleting Routes</h4></div></div></div><p>To delete a routing table entry, use <code class="literal">route delete</code> with the network address and netmask.</p><a id="I_programlisting11_id461229"/><pre class="programlisting"># <span class="strong"><strong>route delete</strong></span> <span class="emphasis"><em>address-block</em></span> <span class="strong"><strong>-netmask</strong></span> <span class="emphasis"><em>netmask</em></span></pre><p>To remove the route added in the previous example, run this command:</p><a id="I_programlisting11_id461254"/><pre class="programlisting"># <span class="strong"><strong>route delete -net 192.0.2.128 -netmask 255.255.255.128</strong></span>
delete net 192.0.2.128</pre><p>You should now have a decent idea of how routing works.</p><p>Now that you know how things are supposed to fit together, let’s see how to configure Ethernet networks.</p></div></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id460204"><p><sup>[<a class="para" href="#id460204">27</a>] </sup>You laugh, but the technical reviewer for this book was part of the first IP-over-carrier-pigeon implementation team that tackled the practical tests as specified in RFC 1149. That’s how I knew he had the time to review this book in excruciating detail. (If that’s how he spends his time, he couldn’t very well claim he was too busy, now could he?)</p></div><div class="footnote" epub:type="footnote" id="ftn.id433870"><p><sup>[<a class="para" href="#id433870">28</a>] </sup>I never do take pity on my readers; I just don’t want you to actually <span class="emphasis"><em>say</em></span> so.</p></div><div class="footnote" epub:type="footnote" id="ftn.id369078"><p><sup>[<a class="para" href="#id369078">29</a>] </sup>Some operating systems treat addresses containing numbers that begin with 0 as octal. Don’t actually use addresses like 192.000.002.013, or you might get a base-8 surprise.</p></div><div class="footnote" epub:type="footnote" id="ftn.id453475"><p><sup>[<a class="para" href="#id453475">30</a>] </sup>Or you can go look it up. Whatever—you not believing me won’t hurt my feelings.</p></div><div class="footnote" epub:type="footnote" id="ftn.id324463"><p><sup>[<a class="para" href="#id324463">31</a>] </sup>For the record, Uncle Mike’s security policy prevents him from passing baked sweet potatoes. If you want them, you’re going to have to take them by force.</p></div><div class="footnote" epub:type="footnote" id="ftn.id322914"><p><sup>[<a class="para" href="#id322914">32</a>] </sup>I used to count how many people confused 514/tcp and 514/udp, but the number got so high that I got depressed, so I stopped.</p></div></div></section></body></html>