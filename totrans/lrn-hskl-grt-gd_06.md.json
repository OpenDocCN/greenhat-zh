["```\nimport Data.List\n\nnumUniques :: (Eq a) => [a] -> Int\nnumUniques = length . nub\n```", "```\nghci> :m + Data.List\n```", "```\nghci> :m + Data.List Data.Map Data.Set\n```", "```\nimport Data.List (nub, sort)\n```", "```\nimport Data.List hiding (nub)\n```", "```\nimport qualified Data.Map\n```", "```\nimport qualified Data.Map as M\n```", "```\nghci> words \"hey these are the words in this sentence\"\n[\"hey\",\"these\",\"are\",\"the\",\"words\",\"in\",\"this\",\"sentence\"]\nghci> words \"hey these           are    the words in this sentence\"\n[\"hey\",\"these\",\"are\",\"the\",\"words\",\"in\",\"this\",\"sentence\"]\n```", "```\nghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]\n[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]\n```", "```\nghci> group [\"boom\",\"bip\",\"bip\",\"boom\",\"boom\"]\n[[\"boom\"],[\"bip\",\"bip\"],[\"boom\",\"boom\"]]\n```", "```\nghci> sort [5,4,3,7,2,1]\n[1,2,3,4,5,7]\nghci> sort [\"boom\",\"bip\",\"bip\",\"boom\",\"boom\"]\n[\"bip\",\"bip\",\"boom\",\"boom\",\"boom\"]\n```", "```\nimport Data.List\n\nwordNums :: String -> [(String,Int)]\nwordNums = map (\\ws -> (head ws, length ws)) . group . sort . words\n```", "```\nwordNums xs = map (\\ws -> (head ws,length ws)) (group (sort (words xs)))\n```", "```\nghci> tails \"party\"\n[\"party\",\"arty\",\"rty\",\"ty\",\"y\",\"\"]\nghci> tails [1,2,3]\n[[1,2,3],[2,3],[3],[]]\n```", "```\nghci> \"hawaii\" `isPrefixOf` \"hawaii joe\"\nTrue\nghci> \"haha\" `isPrefixOf` \"ha\"\nFalse\nghci> \"ha\" `isPrefixOf` \"ha\"\nTrue\n```", "```\nghci> any (> 4) [1,2,3]\nFalse\nghci> any (=='F') \"Frank Sobotka\"\nTrue\nghci> any (\\x -> x > 5 && x < 10) [1,4,11]\nFalse\n```", "```\nimport Data.List\n\nisIn :: (Eq a) => [a] -> [a] -> Bool\nneedle `isIn` haystack = any (needle `isPrefixOf`) (tails haystack)\n```", "```\nghci> \"art\" `isIn` \"party\"\nTrue\nghci> [1,2] `isIn` [1,3,5]\nFalse\n```", "```\nghci> ord 'a'\n97\nghci> chr 97\n'a'\nghci> map ord \"abcdefgh\"\n[97,98,99,100,101,102,103,104]\n```", "```\nimport Data.Char\n\nencode :: Int -> String -> String\nencode offset msg = map (\\c -> chr $ ord c + offset) msg\n```", "```\nghci> encode 3 \"hey mark\"\n\"kh|#pdun\"\nghci> encode 5 \"please instruct your men\"\n\"uqjfxj%nsxywzhy%~tzw%rjs\"\nghci> encode 1 \"to party hard\"\n\"up!qbsuz!ibse\"\n```", "```\ndecode :: Int -> String -> String\ndecode shift msg = encode (negate shift) msg\n```", "```\nghci> decode 3 \"kh|#pdun\"\n\"hey mark\"\nghci> decode 5 \"uqjfxj%nsxywzhy%~tzw%rjs\"\n\"please instruct your men\"\nghci> decode 1 \"up!qbsuz!ibse\"\n\"to party hard\"\n```", "```\nghci> foldl (+) 0 (replicate 100 1)\n100\n```", "```\nghci> foldl (+) 0 (replicate 1000000 1)\n*** Exception: stack overflow\n```", "```\nfoldl (+) 0 [1,2,3] =\nfoldl (+) (0 + 1) [2,3] =\nfoldl (+) ((0 + 1) + 2) [3] =\nfoldl (+) (((0 + 1) + 2) + 3) [] =\n((0 + 1) + 2) + 3 =\n(1 + 2) + 3 =\n3 + 3 =\n6\n```", "```\nfoldl' (+) 0 [1,2,3] =\nfoldl' (+) 1 [2,3] =\nfoldl' (+) 3 [3] =\nfoldl' (+) 6 [] =\n6\n```", "```\nghci> foldl' (+) 0 (replicate 1000000 1)\n1000000\n```", "```\nghci> digitToInt '2'\n2\nghci> digitToInt 'F'\n15\nghci> digitToInt 'z'\n*** Exception: Char.digitToInt: not a digit 'z'\n```", "```\nimport Data.Char\nimport Data.List\n\ndigitSum :: Int -> Int\ndigitSum = sum . map digitToInt . show\n```", "```\nghci> :t find\nfind :: (a -> Bool) -> [a] -> Maybe a\n```", "```\nghci> Nothing\nNothing\nghci> Just \"hey\"\nJust \"hey\"\nghci> Just 3\nJust 3\nghci> :t Just \"hey\"\nJust \"hey\" :: Maybe [Char]\nghci> :t Just True\nJust True :: Maybe Bool\n```", "```\nghci> find (> 4) [3,4,5,6,7]\nJust 5\nghci> find odd [2,4,6,8,9]\nJust 9\nghci> find (=='z') \"mjolnir\"\nNothing\n```", "```\nfirstTo40 :: Maybe Int\nfirstTo40 = find (\\x -> digitSum x == 40) [1..]\n```", "```\nghci> firstTo40\nJust 49999\n```", "```\nfirstTo :: Int -> Maybe Int\nfirstTo n = find (\\x -> digitSum x == n) [1..]\n```", "```\nghci> firstTo 27\nJust 999\nghci> firstTo 1\nJust 1\nghci> firstTo 13\nJust 49\n```", "```\nphoneBook =\n    [(\"betty\", \"555-2938\")\n    ,(\"bonnie\", \"452-2928\")\n    ,(\"patsy\", \"493-2928\")\n    ,(\"lucille\", \"205-2928\")\n    ,(\"wendy\", \"939-8282\")\n    ,(\"penny\", \"853-2492\")\n    ]\n```", "```\nfindKey :: (Eq k) => k -> [(k, v)] -> v\nfindKey key xs = snd . head . filter (\\(k, v) -> key == k) $ xs\n```", "```\nfindKey :: (Eq k) => k -> [(k, v)] -> Maybe v\nfindKey key [] = Nothing\nfindKey key ((k,v):xs)\n    | key == x  = Just v\n    | otherwise = findKey key xs\n```", "```\nfindKey :: (Eq k) => k -> [(k, v)] -> Maybe v\nfindKey key xs = foldr (\\(k, v) acc -> if key == k then Just v else acc) Nothing xs\n```", "```\nghci> findKey \"penny\" phoneBook\nJust \"853-2492\"\nghci> findKey \"betty\" phoneBook\nJust \"555-2938\"\nghci> findKey \"wilma\" phoneBook\nNothing\n```", "```\nimport qualified Data.Map as Map\n```", "```\nghci> Map.fromList [(3,\"shoes\"),(4,\"trees\"),(9,\"bees\")]\nfromList [(3,\"shoes\"),(4,\"trees\"),(9,\"bees\")]\nghci> Map.fromList [(\"kima\",\"greggs\"),(\"jimmy\",\"mcnulty\"),(\"jay\",\"landsman\")]\nfromList [(\"jay\",\"landsman\"),(\"jimmy\",\"mcnulty\"),(\"kima\",\"greggs\")]\n```", "```\nghci> Map.fromList [(\"MS\",1),(\"MS\",2),(\"MS\",3)]\nfromList [(\"MS\",3)]\n```", "```\nMap.fromList :: (Ord k) => [(k, v)] -> Map.Map k v\n```", "```\nimport qualified Data.Map as Map\n\nphoneBook :: Map.Map String String\nphoneBook = Map.fromList $\n    [(\"betty\", \"555-2938\")\n    ,(\"bonnie\", \"452-2928\")\n    ,(\"patsy\", \"493-2928\")\n    ,(\"lucille\", \"205-2928\")\n    ,(\"wendy\", \"939-8282\")\n    ,(\"penny\", \"853-2492\")\n    ]\n```", "```\nghci> :t Map.lookup\nMap.lookup :: (Ord k) => k -> Map.Map k a -> Maybe a\nghci> Map.lookup \"betty\" phoneBook\nJust \"555-2938\"\nghci> Map.lookup \"wendy\" phoneBook\nJust \"939-8282\"\nghci> Map.lookup \"grace\" phoneBook\nNothing\n```", "```\nghci> :t Map.insert\nMap.insert :: (Ord k) => k -> a -> Map.Map k a -> Map.Map k a\nghci> Map.lookup \"grace\" phoneBook\nNothing\nghci> let newBook = Map.insert \"grace\" \"341-9021\" phoneBook\nghci> Map.lookup \"grace\" newBook\nJust \"341-9021\"\n```", "```\nghci> :t Map.size\nMap.size :: Map.Map k a -> Int\nghci> Map.size phoneBook\n6\nghci> Map.size newBook\n7\n```", "```\nstring2digits :: String -> [Int]\nstring2digits = map digitToInt . filter isDigit\n```", "```\nghci> string2digits \"948-9282\"\n[9,4,8,9,2,8,2]\n```", "```\nghci> let intBook = Map.map string2digits phoneBook\nghci> :t intBook\nintBook :: Map.Map String [Int]\nghci> Map.lookup \"betty\" intBook\nJust [5,5,5,2,9,3,8]\n```", "```\nphoneBook =\n    [(\"betty\", \"555-2938\")\n    ,(\"betty\", \"342-2492\")\n    ,(\"bonnie\", \"452-2928\")\n    ,(\"patsy\", \"493-2928\")\n    ,(\"patsy\", \"943-2929\")\n    ,(\"patsy\", \"827-9162\")\n    ,(\"lucille\", \"205-2928\")\n    ,(\"wendy\", \"939-8282\")\n    ,(\"penny\", \"853-2492\")\n    ,(\"penny\", \"555-2111\")\n    ]\n```", "```\nphoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String\nphoneBookToMap xs = Map.fromListWith add xs\n    where add number1 number2 = number1 ++ \", \" ++ number2\n```", "```\nghci> Map.lookup \"patsy\" $ phoneBookToMap phoneBook\n\"827-9162, 943-2929, 493-2928\"\nghci> Map.lookup \"wendy\" $ phoneBookToMap phoneBook\n\"939-8282\"\nghci> Map.lookup \"betty\" $ phoneBookToMap phoneBook\n\"342-2492, 555-2938\"\n```", "```\nphoneBookToMap :: (Ord k) => [(k, a)] -> Map.Map k [a]\nphoneBookToMap xs = Map.fromListWith (++) $ map (\\(k, v) -> (k, [v])) xs\n```", "```\nghci> Map.lookup \"patsy\" $ phoneBookToMap phoneBook\n[\"827-9162\",\"943-2929\",\"493-2928\"]\n```", "```\nghci> Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]\nfromList [(2,100),(3,29),(4,22)]\n```", "```\nghci> Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]\nfromList [(2,108),(3,62),(4,37)]\n```", "```\nmodule Geometry\n( sphereVolume\n, sphereArea\n, cubeVolume\n, cubeArea\n, cuboidArea\n, cuboidVolume\n) where\n```", "```\nmodule Geometry\n( sphereVolume\n, sphereArea\n, cubeVolume\n, cubeArea\n, cuboidArea\n, cuboidVolume\n) where\n\nsphereVolume :: Float -> Float\nsphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)\n\nsphereArea :: Float -> Float\nsphereArea radius = 4 * pi * (radius ^ 2)\n\ncubeVolume :: Float -> Float\ncubeVolume side = cuboidVolume side side side\n\ncubeArea :: Float -> Float\ncubeArea side = cuboidArea side side side\n\ncuboidVolume :: Float -> Float -> Float -> Float\ncuboidVolume a b c = rectArea a b * c\n\ncuboidArea :: Float -> Float -> Float -> Float\ncuboidArea a b c = rectArea a b * 2 + rectArea a c * 2 +\nrectArea c b * 2\n\nrectArea :: Float -> Float -> Float\nrectArea a b = a * b\n```", "```\nimport Geometry\n```", "```\nmodule Geometry.Sphere\n( volume\n, area\n) where\n\nvolume :: Float -> Float\nvolume radius = (4.0 / 3.0) * pi * (radius ^ 3)\n\narea :: Float -> Float\narea radius = 4 * pi * (radius ^ 2)\n```", "```\nmodule Geometry.Cuboid\n( volume\n, area\n) where\n\nvolume :: Float -> Float -> Float -> Float\nvolume a b c = rectArea a b * c\n\narea :: Float -> Float -> Float -> Float\narea a b c = rectArea a b * 2 + rectArea a c * 2 + rectArea c b * 2\n\nrectArea :: Float -> Float -> Float\nrectArea a b = a * b\n```", "```\nmodule Geometry.Cube\n( volume\n, area\n) where\n\nimport qualified Geometry.Cuboid as Cuboid\n\nvolume :: Float -> Float\nvolume side = Cuboid.volume side side side\n\narea :: Float -> Float\narea side = Cuboid.area side side side\n```", "```\nimport Geometry.Sphere\n```", "```\nimport qualified Geometry.Sphere as Sphere\nimport qualified Geometry.Cuboid as Cuboid\nimport qualified Geometry.Cube as Cube\n```"]