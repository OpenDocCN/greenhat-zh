<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Direct Memory Access"><div class="titlepage"><div><div><h1 class="title"><a id="direct_memory_access"/>Chapter 12. Direct Memory Access</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id12"/><div class="mediaobject"><a id="I_mediaobject12_d1e20849"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p><span class="emphasis"><em>Direct Memory Access (DMA)</em></span> is a feature of modern processors that lets a device transfer data to and from main memory independently of the CPU. With DMA, the CPU merely initiates the data transfer (that is to say, it does not complete it), and then the device (or a separate DMA controller) actually moves the data. Because of this, DMA tends to provide higher system performance as the CPU is free to perform other tasks during the data transfer.<a class="indexterm" id="IDX-CHP-12-0001"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>There is some overhead in performing DMA. Accordingly, only devices that move large amounts of data (for example, storage devices) use DMA. You wouldn’t use DMA just to transfer one or two bytes of data.</p></div><div class="sect1" title="Implementing DMA"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_dma"/>Implementing DMA</h1></div></div></div><p>Unlike with previous topics, I’m going to take a holistic approach here. Namely, I’m going to show an example first, and then I’ll describe the DMA family of functions.</p><p>The following pseudocode is a <code class="literal">device_attach</code> routine for a fictitious device that uses DMA.<a class="indexterm" id="IDX-CHP-12-0002"/></p><a id="I_programlisting12_d1e20879"/><pre class="programlisting">static int
foo_attach(device_t dev)
{
        struct foo_softc *sc = device_get_softc(dev);
        int error;

        bzero(sc, sizeof(*sc));

        if (<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>bus_dma_tag_create(bus_get_dma_tag(dev),  /* parent       */
                               1,                       /* alignment    */
                               0,                       /* boundary     */
                               BUS_SPACE_MAXADDR,       /* lowaddr      */
                               BUS_SPACE_MAXADDR,       /* highaddr     */
                               NULL,                    /* filter       */
                               NULL,                    /* filterarg    */
                               BUS_SPACE_MAXSIZE_32BIT, /* maxsize      */
                               BUS_SPACE_UNRESTRICTED,  /* nsegments    */
                               BUS_SPACE_MAXSIZE_32BIT, /* maxsegsize   */
                               0,                       /* flags        */
                               NULL,                    /* lockfunc     */
                               NULL,                    /* lockfuncarg  */
                             <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>&amp;sc-&gt;foo_parent_dma_tag)) {
                device_printf(dev, "Cannot allocate parent DMA tag!\n");
                return (ENOMEM);
        }

        if (bus_dma_tag_create(<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sc-&gt;foo_parent_dma_tag,/* parent       */
                               1,                       /* alignment    */
                               0,                       /* boundary     */
                               BUS_SPACE_MAXADDR,       /* lowaddr      */
                               BUS_SPACE_MAXADDR,       /* highaddr     */
                               NULL,                    /* filter       */
                               NULL,                    /* filterarg    */
                               MAX_BAZ_SIZE,            /* maxsize      */
                               MAX_BAZ_SCATTER,         /* nsegments    */
                               BUS_SPACE_MAXSIZE_32BIT, /* maxsegsize   */
                               0,                       /* flags        */
                               NULL,                    /* lockfunc     */
                               NULL,                    /* lockfuncarg  */
                             <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>&amp;sc-&gt;foo_baz_dma_tag)) {
                device_printf(dev, "Cannot allocate baz DMA tag!\n");
                return (ENOMEM);
        }

        if (bus_dmamap_create(sc-&gt;foo_baz_dma_tag,      /* DMA tag      */
                              0,                        /* flags        */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>&amp;sc-&gt;foo_baz_dma_map)) {
                device_printf(dev, "Cannot allocate baz DMA map!\n");
                return (ENOMEM);
        }

        bzero(sc-&gt;foo_baz_buf, BAZ_BUF_SIZE);

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>bus_dmamap_load(sc-&gt;foo_baz_dma_tag,  /* DMA tag      */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>sc-&gt;foo_baz_dma_map,    /* DMA map      */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>sc-&gt;foo_baz_buf,        /* buffer       */
                                BAZ_BUF_SIZE,           /* buffersize   */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>foo_callback,           /* callback     */
                                &amp;sc-&gt;foo_baz_busaddr,   /* callbackarg  */
                                BUS_DMA_NOWAIT);        /* flags        */
        if (error || sc-&gt;foo_baz_busaddr == 0) {
                device_printf(dev, "Cannot map baz DMA memory!\n");
                return (ENOMEM);
        }

...
}</pre><p>This pseudocode begins by calling <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e20938"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">bus_dma_tag_create</code> to create a DMA tag named <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e20947"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">foo_parent_dma_tag</code>. At heart, <span class="emphasis"><em>DMA tags</em></span> describe the characteristics and restrictions of DMA transactions.<a class="indexterm" id="IDX-CHP-12-0003"/><a class="indexterm" id="IDX-CHP-12-0004"/><a class="indexterm" id="IDX-CHP-12-0005"/><a class="indexterm" id="IDX-CHP-12-0006"/></p><p>Next, <code class="literal">bus_dma_tag_create</code> is called again. Notice that <code class="literal">foo_parent_dma_tag</code> is this call’s <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e20980"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> first argument. See, DMA tags can inherit the characteristics and restrictions of other tags. Of course, child tags cannot loosen the restrictions set up by their parents. Consequently, the DMA tag <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e20986"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">foo_baz_dma_tag</code> is a “draconian” version of <code class="literal">foo_parent_dma_tag</code>.</p><p>The next statement, <code class="literal">bus_dmamap_create</code>, creates a DMA map named <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21004"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">foo_baz_dma_map</code>. Loosely speaking, <span class="emphasis"><em>DMA maps</em></span> represent memory areas that have been allocated according to the properties of a DMA tag and are within device visible address space.</p><p>Finally, <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21018"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">bus_dmamap_load</code> loads the buffer <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21027"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">foo_baz_buf</code> into the device visible address associated with the DMA map <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21036"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">foo_baz_dma_map</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Any arbitrary buffer can be used for DMA. However, buffers are inaccessible to devices until they’ve been loaded (or mapped) into a device visible address (that is, a DMA map).</p></div><p>Note that <code class="literal">bus_dmamap_load</code> requires a <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21054"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> callback function, which typically looks something like this:</p><a id="I_programlisting12_d1e21060"/><pre class="programlisting">static void
<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> foo_callback(void <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*arg, bus_dma_segment_t *segs, int nseg, int error)
{
        if (error)
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>return;

        *(bus_addr_t *)<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>arg = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>segs[0].ds_addr;
}</pre><p>Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21095"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> arg dereferences to the sixth argument passed to <code class="literal">bus_dmamap_load</code>, which was <code class="literal">foo_baz_busaddr</code>.<a class="indexterm" id="IDX-CHP-12-0007"/><a class="indexterm" id="IDX-CHP-12-0008"/><a class="indexterm" id="IDX-CHP-12-0009"/><a class="indexterm" id="IDX-CHP-12-0010"/><a class="indexterm" id="IDX-CHP-12-0011"/><a class="indexterm" id="IDX-CHP-12-0012"/></p><p>This callback function executes after the buffer-load operation completes. If successful, the <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21138"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> address where the buffer was loaded is returned in <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21144"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">arg</code>. If unsuccessful, <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21153"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">foo_callback</code> does <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21163"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> nothing.</p><div class="sect2" title="Initiating a DMA Data Transfer"><div class="titlepage"><div><div><h2 class="title"><a id="initiating_a_dma_data_transfer"/>Initiating a DMA Data Transfer</h2></div></div></div><p>Assuming the buffer-load operation completed successfully, one can initiate a DMA data transfer with something like this:</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Most devices just require the device visible address of a buffer to be written to a specific register to start a DMA data transfer.</p></div><a id="I_programlisting12_d1e21177"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>bus_write_4(sc-&gt;foo_io_resource, <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>FOO_BAZ, <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sc-&gt;foo_baz_busaddr);</pre><p>Here, the <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21198"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> device visible address of a buffer is <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21204"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> written to a <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21210"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> device register. Recall that the <code class="literal">foo_callback</code> function described in the previous section returns in <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21219"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">foo_baz_busaddr</code> the device visible address of <code class="literal">foo_baz_buf</code>.</p></div><div class="sect2" title="Dismantling DMA"><div class="titlepage"><div><div><h2 class="title"><a id="dismantling_dma"/>Dismantling DMA</h2></div></div></div><p>Now that you know how to implement DMA, I’ll demonstrate how to dismantle it.</p><a id="I_programlisting12_d1e21237"/><pre class="programlisting">static int
foo_detach(device_t dev)
{
        struct foo_softc *sc = device_get_softc(dev);

        if (sc-&gt;foo_baz_busaddr != 0)
                bus_dmamap_unload(sc-&gt;foo_baz_dma_tag, sc-&gt;foo_baz_dma_map);

        if (sc-&gt;foo_baz_dma_map != NULL)
                bus_dmamap_destroy(sc-&gt;foo_baz_dma_tag, sc-&gt;foo_baz_dma_map);

        if (sc-&gt;foo_baz_dma_tag != NULL)
                bus_dma_tag_destroy(sc-&gt;foo_baz_dma_tag);

        if (sc-&gt;foo_parent_dma_tag != NULL)
                bus_dma_tag_destroy(sc-&gt;foo_parent_dma_tag);

...
}</pre><p>As you can see, this pseudocode simply tears down everything in the opposite order that it was built up.</p><p>Now, let’s discuss in detail the different functions encountered here and in the previous two sections.</p></div></div></div>
<div class="sect1" title="Creating DMA Tags"><div class="titlepage"><div><div><h1 class="title"><a id="creating_dma_tags"/>Creating DMA Tags</h1></div></div></div><p>As mentioned earlier, DMA tags describe the characteristics and restrictions of DMA transactions and are created by using the <code class="literal">bus_dma_tag_create</code> function.<a class="indexterm" id="IDX-CHP-12-0013"/><a class="indexterm" id="IDX-CHP-12-0014"/><a class="indexterm" id="IDX-CHP-12-0015"/><a class="indexterm" id="IDX-CHP-12-0016"/><a class="indexterm" id="IDX-CHP-12-0017"/><a class="indexterm" id="IDX-CHP-12-0018"/><a class="indexterm" id="IDX-CHP-12-0019"/><a class="indexterm" id="IDX-CHP-12-0020"/><a class="indexterm" id="IDX-CHP-12-0021"/><a class="indexterm" id="IDX-CHP-12-0022"/><a class="indexterm" id="IDX-CHP-12-0023"/><a class="indexterm" id="IDX-CHP-12-0024"/><a class="indexterm" id="IDX-CHP-12-0025"/></p><a id="I_programlisting12_d1e21299"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment,
    bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr,
    bus_dma_filter_t *filtfunc, void *filtfuncarg, bus_size_t maxsize,
    int nsegments, bus_size_t maxsegsz, int flags,
    bus_dma_lock_t *lockfunc, void *lockfuncarg, bus_dma_tag_t *dmat);</pre><p>Here, the <code class="literal">parent</code> argument identifies the parent DMA tag. To create a top-level DMA tag, pass <code class="literal">bus_get_dma_tag(device_t dev)</code> as <code class="literal">parent</code>.</p><p>The <code class="literal">alignment</code> argument denotes the physical alignment, in bytes, of each DMA segment. Recall that DMA maps represent memory areas that have been allocated according to the properties of a DMA tag. These memory areas are known as <span class="emphasis"><em>DMA segments</em></span>. If you return to the <code class="literal">foo_callback</code> function described in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a> in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a>, you’ll see that <code class="literal">arg</code> is actually assigned the address of a DMA segment.</p><p>The <code class="literal">alignment</code> argument must be <code class="literal">1</code>, which denotes no specific alignment, or a power of two. As an example, drivers that require DMA buffers to begin on a multiple of 4KB would pass <code class="literal">4096</code> as <code class="literal">alignment</code>.</p><p>The <code class="literal">boundary</code> argument specifies the physical address boundaries that cannot be crossed by each DMA segment; that is, they cannot cross any multiple of <code class="literal">boundary</code>. This argument must be <code class="literal">0</code>, which indicates no boundary restrictions, or a power of two.</p><p>The <code class="literal">lowaddr</code> and <code class="literal">highaddr</code> arguments outline the address range that cannot be employed for DMA. For example, devices incapable of DMA above 4GB would have <code class="literal">0xFFFFFFFF</code> as <code class="literal">lowaddr</code> and <code class="literal">BUS_SPACE_MAXADDR</code> as <code class="literal">highaddr</code>.<a class="indexterm" id="IDX-CHP-12-0026"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">0xFFFFFFFF</code> equals 4GB, and the constant <code class="literal">BUS_SPACE_MAXADDR</code> signifies the maximum addressable memory for your architecture.</p></div><p>The <code class="literal">filtfunc</code> and <code class="literal">filtfuncarg</code> arguments denote an optional callback function and its first argument, respectively. This function is executed for every attempt to load (or map) a DMA buffer between <code class="literal">lowaddr</code> and <code class="literal">highaddr</code>. If there’s a device-accessible region between lowaddr and highaddr, filtfunc is supposed to tell the system. Here is the function prototype for <code class="literal">filtfunc</code>:</p><a id="I_programlisting12_d1e21405"/><pre class="programlisting">int filtfunc(void *filtfuncarg, bus_addr_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>addr)</pre><p>This function must return <code class="literal">0</code> if the address <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21419"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">addr</code> is device-accessible or a nonzero value if it’s inaccessible.</p><p>If <code class="literal">filtfunc</code> and <code class="literal">filtfuncarg</code> are <code class="literal">NULL</code>, the entire address range from <code class="literal">lowaddr</code> to <code class="literal">highaddr</code> is considered inaccessible.</p><p>The maxsize argument denotes the maximum amount of memory, in bytes, that may be allocated for a single DMA map.<a class="indexterm" id="IDX-CHP-12-0027"/><a class="indexterm" id="IDX-CHP-12-0028"/><a class="indexterm" id="IDX-CHP-12-0029"/><a class="indexterm" id="IDX-CHP-12-0030"/><a class="indexterm" id="IDX-CHP-12-0031"/><a class="indexterm" id="IDX-CHP-12-0032"/><a class="indexterm" id="IDX-CHP-12-0033"/><a class="indexterm" id="IDX-CHP-12-0034"/><a class="indexterm" id="IDX-CHP-12-0035"/><a class="indexterm" id="IDX-CHP-12-0036"/><a class="indexterm" id="IDX-CHP-12-0037"/><a class="indexterm" id="IDX-CHP-12-0038"/></p><p>The <code class="literal">nsegments</code> argument specifies the number of scatter/gather segments allowed in a single DMA map. A <span class="emphasis"><em>scatter/gather segment</em></span> is simply a memory page. The name comes from the fact that when you take a set of physically discontinuous pages and virtually assemble them into a single contiguous buffer, you must “scatter” your writes and “gather” your reads. Some devices require blocks of contiguous memory; however sometimes a large enough block is not available. So the kernel “tricks” the device by using a buffer composed of scatter/gather segments. Every DMA segment is a scatter/gather segment.<a class="indexterm" id="IDX-CHP-12-0039"/></p><p>The <code class="literal">nsegments</code> argument may be <code class="literal">BUS_SPACE_UNRESTRICTED</code>, which indicates no number restriction. DMA tags made with <code class="literal">BUS_SPACE_UNRESTRICTED</code> cannot create DMA maps; they can only be parent tags, because the system cannot support DMA maps composed of an unlimited number of scatter/gather segments.</p><p>The <code class="literal">maxsegsz</code> argument denotes the maximum size, in bytes, of an individual DMA segment within a single DMA map.</p><p>The <code class="literal">flags</code> argument modifies <code class="literal">bus_dma_tag_create</code>’s behavior. <a class="xref" href="ch12s02.html#bus_underscore_dma_underscore_tag_unders" title="Table 12-1. bus_dma_tag_create Symbolic Constants">Table 12-1</a> displays its only valid value.</p><div class="table"><a id="bus_underscore_dma_underscore_tag_unders"/><p class="title">Table 12-1. bus_dma_tag_create Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="bus_dma_tag_create Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_ALLOCNOW</code></p></td><td style="text-align: left" valign="top"><p>Preallocates enough resources to handle at least one buffer-load operation; if sufficient resources are unavailable, <code class="literal">ENOMEM</code> is returned.</p></td></tr></tbody></table></div></div><p>The <code class="literal">lockfunc</code> and <code class="literal">lockfuncarg</code> arguments denote an optional callback function and its first argument, respectively. Remember how <code class="literal">bus_dmamap_load</code> requires a callback function? Well, <code class="literal">lockfunc</code> executes right before and after that function to acquire and release any necessary synchronization primitives. Here is <code class="literal">lockfunc</code>’s function prototype:</p><a id="I_programlisting12_d1e21570"/><pre class="programlisting">void lockfunc(void *lockfuncarg, bus_dma_lock_op_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>op)</pre><p>When lockfunc executes, <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21580"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> op contains either <code class="literal">BUS_DMA_LOCK</code> or <code class="literal">BUS_DMA_UNLOCK</code>. That is, <code class="literal">op</code> dictates what lock operation to perform.</p><p>The <code class="literal">dmat</code> argument expects a pointer to <code class="literal">bus_dma_tag_t;</code> assuming <code class="literal">bus_dma_tag_create</code> is successful, this pointer will store the resulting DMA tag.</p></div>
<div class="sect1" title="Tearing Down DMA Tags"><div class="titlepage"><div><div><h1 class="title"><a id="tearing_down_dma_tags"/>Tearing Down DMA Tags</h1></div></div></div><p>DMA tags are torn down by the <code class="literal">bus_dma_tag_destroy</code> function.</p><a id="I_programlisting12_d1e21615"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dma_tag_destroy(bus_dma_tag_t dmat);</pre><p>This function returns <code class="literal">EBUSY</code> if there are any DMA maps still associated with <code class="literal">dmat</code>.<a class="indexterm" id="IDX-CHP-12-0040"/><a class="indexterm" id="IDX-CHP-12-0041"/><a class="indexterm" id="IDX-CHP-12-0042"/><a class="indexterm" id="IDX-CHP-12-0043"/><a class="indexterm" id="IDX-CHP-12-0044"/><a class="indexterm" id="IDX-CHP-12-0045"/><a class="indexterm" id="IDX-CHP-12-0046"/><a class="indexterm" id="IDX-CHP-12-0047"/><a class="indexterm" id="IDX-CHP-12-0048"/></p></div>
<div class="sect1" title="DMA Map Management Routines, Part 1"><div class="titlepage"><div><div><h1 class="title"><a id="dma_map_management_routines_comma_part_1"/>DMA Map Management Routines, Part 1</h1></div></div></div><p>As mentioned earlier, DMA maps represent memory areas (that is to say, DMA segments) that have been allocated according to the properties of a DMA tag and are within device visible address space.</p><p>DMA maps can be managed with the following functions:</p><a id="I_programlisting12_d1e21670"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp);

int
bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map);</pre><p>The <code class="literal">bus_dmamap_create</code> function creates a DMA map based on the DMA tag <code class="literal">dmat</code> and stores the result in <code class="literal">mapp</code>. The <code class="literal">flags</code> argument modifies <code class="literal">bus_dmamap_create</code>’s behavior. <a class="xref" href="ch12s04.html#bus_underscore_dmamap_underscore_create" title="Table 12-2. bus_dmamap_create Symbolic Constants">Table 12-2</a> displays its only valid value.</p><div class="table"><a id="bus_underscore_dmamap_underscore_create"/><p class="title">Table 12-2. bus_dmamap_create Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="bus_dmamap_create Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_COHERENT</code></p></td><td style="text-align: left" valign="top"><p>Causes cache synchronization operations to be as cheap as possible for your DMA buffers; this flag is implemented only on <span class="emphasis"><em>sparc64</em></span>.</p></td></tr></tbody></table></div></div><p>The <code class="literal">bus_dmamap_destroy</code> function tears down the DMA map <code class="literal">map</code>. The <code class="literal">dmat</code> argument is the DMA tag that <code class="literal">map</code> was based on.</p></div>
<div class="sect1" title="Loading (DMA) Buffers into DMA Maps"><div class="titlepage"><div><div><h1 class="title"><a id="loading_open_parenthesis_dma_close_paren"/>Loading (DMA) Buffers into DMA Maps</h1></div></div></div><p>The FreeBSD kernel provides four functions for loading a buffer into the device visible address associated with a DMA map:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">bus_dmamap_load</code></p></li><li class="listitem"><p><code class="literal">bus_dmamap_load_mbuf</code></p></li><li class="listitem"><p><code class="literal">bus_dmamap_load_mbuf_sg</code></p></li><li class="listitem"><p><code class="literal">bus_dmamap_load_uio</code></p></li></ul></div><p>Before I describe these functions, an explanation of <code class="literal">bus_dma_segment</code> structures is needed.</p><div class="sect2" title="bus_dma_segment Structures"><div class="titlepage"><div><div><h2 class="title"><a id="bus_underscore_dma_underscore_segment_st"/>bus_dma_segment Structures</h2></div></div></div><p>A <code class="literal">bus_dma_segment</code> structure describes a single DMA segment.</p><a id="I_programlisting12_d1e21767"/><pre class="programlisting">typedef struct bus_dma_segment {
        bus_addr_t     <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>ds_addr;
        bus_size_t     <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ds_len;
} bus_dma_segment_t;</pre><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21783"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">ds_addr</code> field contains its device visible address and <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21792"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">ds_len</code> contains its length.<a class="indexterm" id="IDX-CHP-12-0049"/><a class="indexterm" id="IDX-CHP-12-0050"/><a class="indexterm" id="IDX-CHP-12-0051"/><a class="indexterm" id="IDX-CHP-12-0052"/><a class="indexterm" id="IDX-CHP-12-0053"/><a class="indexterm" id="IDX-CHP-12-0054"/></p></div><div class="sect2" title="bus_dmamap_load Function"><div class="titlepage"><div><div><h2 class="title"><a id="bus_underscore_dmamap_underscore_load_fu"/>bus_dmamap_load Function</h2></div></div></div><p>We first discussed the <code class="literal">bus_dmamap_load</code> function in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a> in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a>.</p><a id="I_programlisting12_d1e21838"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf,
    bus_size_t buflen, bus_dmamap_callback_t *callback,
    void *callbackarg, int flags);</pre><p>This function loads the buffer buf into the device visible address associated with the DMA map map. The dmat argument is the DMA tag that map is based on. The buflen argument is the number of bytes from buf to load. <code class="literal">bus_dmamap_load</code> returns immediately and never blocks for any reason.<a class="indexterm" id="IDX-CHP-12-0055"/><a class="indexterm" id="IDX-CHP-12-0056"/></p><p>The <code class="literal">callback</code> and <code class="literal">callbackarg</code> arguments denote a callback function and its first argument, respectively. <code class="literal">callback</code> executes after the buffer-load operation completes. If resources are lacking, the buffer-load operation and <code class="literal">callback</code> will be deferred. If <code class="literal">bus_dmamap_load</code> returns <code class="literal">EINPROGRESS</code>, this has occurred. Here is <code class="literal">callback</code>’s function prototype:</p><a id="I_programlisting12_d1e21875"/><pre class="programlisting">void callback(void *callbackarg, bus_dma_segment_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*segs, int
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>nseg,              int <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>error)</pre><p>When callback executes, <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21897"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> error discloses the success (0) or failure (<code class="literal">EFBIG</code>) of the buffer-load operation (the error code <code class="literal">EFBIG</code> stands for <span class="emphasis"><em>error: file too large</em></span>). The <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21912"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">segs</code> argument is the array of DMA segments that <code class="literal">buf</code> has been loaded into; <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21925"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">nseg</code> is this array’s size.</p><p>The following pseudocode is an example <code class="literal">callback</code> function:</p><a id="I_programlisting12_d1e21939"/><pre class="programlisting">static void
foo_callback(void *callbackarg, bus_dma_segment_t *segs, int nseg, int error)
{
        struct foo_softc *sc = callbackarg;
        int i;

        if (error)
                return;

        sc-&gt;sg_num = nseg;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>for (i = 0; i &lt; nseg; i++)
                sc-&gt;sg_addr[i] = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>segs[i].ds_addr;
}</pre><p>This function <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21955"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> iterates through <code class="literal">segs</code> to return the <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e21964"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> device visible address of each DMA segment that <code class="literal">buf</code> has been loaded into.<a class="indexterm" id="IDX-CHP-12-0057"/><a class="indexterm" id="IDX-CHP-12-0058"/><a class="indexterm" id="IDX-CHP-12-0059"/><a class="indexterm" id="IDX-CHP-12-0060"/><a class="indexterm" id="IDX-CHP-12-0061"/><a class="indexterm" id="IDX-CHP-12-0062"/><a class="indexterm" id="IDX-CHP-12-0063"/><a class="indexterm" id="IDX-CHP-12-0064"/><a class="indexterm" id="IDX-CHP-12-0065"/><a class="indexterm" id="IDX-CHP-12-0066"/><a class="indexterm" id="IDX-CHP-12-0067"/><a class="indexterm" id="IDX-CHP-12-0068"/><a class="indexterm" id="IDX-CHP-12-0069"/><a class="indexterm" id="IDX-CHP-12-0070"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>If <code class="literal">buf</code> can fit into one DMA segment, the <code class="literal">foo_callback</code> function described in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a> in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a> may be used as <code class="literal">callback</code>.</p></div><p>The <code class="literal">flags</code> argument modifies <code class="literal">bus_dmamap_load</code>’s behavior. Valid values for this argument are shown in <a class="xref" href="ch12s05.html#bus_underscore_dmamap_underscore_load_sy" title="Table 12-3. bus_dmamap_load Symbolic Constants">Table 12-3</a>.</p><div class="table"><a id="bus_underscore_dmamap_underscore_load_sy"/><p class="title">Table 12-3. bus_dmamap_load Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="bus_dmamap_load Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_NOWAIT</code></p></td><td style="text-align: left" valign="top"><p>If memory resources are lacking, the buffer-load operation and <code class="literal">callback</code> will <span class="emphasis"><em>not</em></span> be deferred.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_NOCACHE</code></p></td><td style="text-align: left" valign="top"><p>Prevents caching the DMA buffer, thereby causing all DMA transactions to be executed without reordering; this flag is implemented only on <span class="emphasis"><em>sparc64</em></span>.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="bus_dmamap_load_mbuf Function"><div class="titlepage"><div><div><h2 class="title"><a id="bus_underscore_dmamap_underscore_load_un"/>bus_dmamap_load_mbuf Function</h2></div></div></div><p>The <code class="literal">bus_dmamap_load_mbuf</code> function is a variant of <code class="literal">bus_dmamap_load</code> that loads mbuf chains (you’ll learn about mbuf chains in <a class="xref" href="ch16.html" title="Chapter 16. Network Drivers, Part 1: Data Structures">Chapter 16</a>).</p><a id="I_programlisting12_d1e22111"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dmamap_load_mbuf(bus_dma_tag_t dmat, bus_dmamap_t map,
    struct mbuf *mbuf, bus_dmamap_callback2_t *callback2,
    void *callbackarg, int flags);</pre><p>Most of these arguments are identical to their <code class="literal">bus_dmamap_load</code> counterparts except for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">mbuf</code> argument, which expects an mbuf chain</p></li><li class="listitem"><p>The <code class="literal">callback2</code> argument, which requires a different callback function</p></li><li class="listitem"><p>The <code class="literal">flags</code> argument, which implicitly sets <code class="literal">BUS_DMA_NOWAIT</code></p></li></ul></div><p>Here is <code class="literal">callback2</code>’s function prototype:</p><a id="I_programlisting12_d1e22144"/><pre class="programlisting">void callback2(void *callbackarg, bus_dma_segment_t *segs, int nseg,
               bus_size_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>mapsize, int error)</pre><p><code class="literal">callback2</code> is like <code class="literal">callback</code>, but it returns the <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22159"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> amount of data loaded.</p></div><div class="sect2" title="bus_dmamap_load_mbuf_sg Function"><div class="titlepage"><div><div><h2 class="title"><a id="bus_underscore_dmamap_underscore_loa"/>bus_dmamap_load_mbuf_sg Function</h2></div></div></div><p>The <code class="literal">bus_dmamap_load_mbuf_sg</code> function is an alternative to <code class="literal">bus_dmamap_load_mbuf</code> that does not use <code class="literal">callback2</code>.</p><a id="I_programlisting12_d1e22179"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dmamap_load_mbuf_sg(bus_dma_tag_t dmat, bus_dmamap_t map,
    struct mbuf *mbuf, bus_dma_segment_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*segs, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*nseg, int flags);</pre><p>As you can see, this function directly and immediately returns <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22195"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">segs</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22204"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">nseg</code>.<a class="indexterm" id="IDX-CHP-12-0071"/><a class="indexterm" id="IDX-CHP-12-0072"/><a class="indexterm" id="IDX-CHP-12-0073"/><a class="indexterm" id="IDX-CHP-12-0074"/><a class="indexterm" id="IDX-CHP-12-0075"/><a class="indexterm" id="IDX-CHP-12-0076"/><a class="indexterm" id="IDX-CHP-12-0077"/><a class="indexterm" id="IDX-CHP-12-0078"/><a class="indexterm" id="IDX-CHP-12-0079"/></p></div><div class="sect2" title="bus_dmamap_load_uio Function"><div class="titlepage"><div><div><h2 class="title"><a id="bus_underscore_dmamap_underscore_lo"/>bus_dmamap_load_uio Function</h2></div></div></div><p>The <code class="literal">bus_dmamap_load_uio</code> function is identical to <code class="literal">bus_dmamap_load_mbuf</code> except that it loads the buffers from within a <code class="literal">uio</code> structure.</p><a id="I_programlisting12_d1e22269"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dmamap_load_uio(bus_dma_tag_t dmat, bus_dmamap_t map,
    struct uio *uio, bus_dmamap_callback2_t *callback2,
    void *callbackarg, int flags);</pre></div><div class="sect2" title="bus_dmamap_unload Function"><div class="titlepage"><div><div><h2 class="title"><a id="bus_underscore_dmamap_underscore_unload"/>bus_dmamap_unload Function</h2></div></div></div><p>The <code class="literal">bus_dmamap_unload</code> function unloads the buffers from a DMA map.</p><a id="I_programlisting12_d1e22279"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

void
bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map);</pre></div></div>
<div class="sect1" title="DMA Map Management Routines, Part 2"><div class="titlepage"><div><div><h1 class="title"><a id="dma_map_management_routines_comma_part_2"/>DMA Map Management Routines, Part 2</h1></div></div></div><p>This section describes an alternative set of functions used to manage DMA maps.<a class="indexterm" id="IDX-CHP-12-0080"/></p><a id="I_programlisting12_d1e22291"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

int
bus_dmamem_alloc(bus_dma_tag_t dmat, void **vaddr, int flags,
    bus_dmamap_t *mapp);

void
bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map);</pre><p>The <code class="literal">bus_dmamem_alloc</code> function creates a DMA map based on the DMA tag <code class="literal">dmat</code> and stores the result in <code class="literal">mapp</code>. This function also allocates <code class="literal">maxsize</code> bytes of contiguous memory (where <code class="literal">maxsize</code> is defined by <code class="literal">dmat</code>). The address of this memory is returned in <code class="literal">vaddr</code>. As you’ll soon see, this contiguous memory will eventually become your DMA buffer. The <code class="literal">flags</code> argument modifies <code class="literal">bus_dmamem_alloc</code>’s behavior. Valid values for this argument are shown in <a class="xref" href="ch12s06.html#bus_underscore_dmamem_underscore_alloc_s" title="Table 12-4. bus_dmamem_alloc Symbolic Constants">Table 12-4</a>.<a class="indexterm" id="IDX-CHP-12-0081"/><a class="indexterm" id="IDX-CHP-12-0082"/><a class="indexterm" id="IDX-CHP-12-0083"/><a class="indexterm" id="IDX-CHP-12-0084"/><a class="indexterm" id="IDX-CHP-12-0085"/><a class="indexterm" id="IDX-CHP-12-0086"/><a class="indexterm" id="IDX-CHP-12-0087"/></p><div class="table"><a id="bus_underscore_dmamem_underscore_alloc_s"/><p class="title">Table 12-4. bus_dmamem_alloc Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="bus_dmamem_alloc Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_ZERO</code></p></td><td style="text-align: left" valign="top"><p>Causes the allocated memory to be set to zero</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_NOWAIT</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">bus_dmamem_alloc</code> to return <code class="literal">ENOMEM</code> if the allocation cannot be immediately fulfilled due to resource shortage</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_WAITOK</code></p></td><td style="text-align: left" valign="top"><p>Indicates that it is okay to wait for resources; if the allocation cannot be immediately fulfilled, the current process is put to sleep to wait for resources to become available.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_COHERENT</code></p></td><td style="text-align: left" valign="top"><p>Causes cache synchronization operations to be as cheap as possible for your DMA buffer; this flag is implemented only on arm and sparc64.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMA_NOCACHE</code></p></td><td style="text-align: left" valign="top"><p>Prevents caching the DMA buffer, thereby causing all DMA transactions to be executed without reordering; this flag is implemented only on <span class="emphasis"><em>amd64</em></span> and <span class="emphasis"><em>i386</em></span>.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">bus_dmamem_alloc</code> is used when you require a physically contiguous DMA buffer.</p></div><p>The <code class="literal">bus_dmamem_free</code> function releases the memory at <code class="literal">vaddr</code> that was previously allocated by <code class="literal">bus_dmamem_alloc</code>. Then it tears down the DMA map <code class="literal">map</code>.</p></div>
<div class="sect1" title="A Straightforward Example"><div class="titlepage"><div><div><h1 class="title"><a id="a_straightforward_example-id1"/>A Straightforward Example</h1></div></div></div><p>The following pseudocode is a <code class="literal">device_attach</code> routine for a fictitious device that requires DMA. This pseudocode should demonstrate how to use <code class="literal">bus_dmamem_alloc</code>.</p><a id="I_programlisting12_d1e22446"/><pre class="programlisting">static int
foo_attach(device_t dev)
{
        struct foo_softc *sc = device_get_softc(dev);
        int size = BAZ_SIZE;
        int error;

        bzero(sc, sizeof(*sc));

        if (bus_dma_tag_create(bus_get_dma_tag(dev),    /* parent       */
                               1,                       /* alignment    */
                               0,                       /* boundary     */
                               BUS_SPACE_MAXADDR,       /* lowaddr      */
                               BUS_SPACE_MAXADDR,       /* highaddr     */
                               NULL,                    /* filter       */
                               NULL,                    /* filterarg    */
                               BUS_SPACE_MAXSIZE_32BIT, /* maxsize      */
                               BUS_SPACE_UNRESTRICTED,  /* nsegments    */
                               BUS_SPACE_MAXSIZE_32BIT, /* maxsegsize   */
                               0,                       /* flags        */
                               NULL,                    /* lockfunc     */
                               NULL,                    /* lockfuncarg  */
                               &amp;sc-&gt;foo_parent_dma_tag)) {
                device_printf(dev, "Cannot allocate parent DMA tag!\n");
                return (ENOMEM);
        }

        if (bus_dma_tag_create(sc-&gt;foo_parent_dma_tag,  /* parent       */
                               64,                      /* alignment    */
                               0,                       /* boundary     */
                               BUS_SPACE_MAXADDR_32BIT, /* lowaddr      */
                               BUS_SPACE_MAXADDR,       /* highaddr     */
                               NULL,                    /* filter       */
                               NULL,                    /* filterarg    */
                             <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>size,                    /* maxsize      */
                             <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>1,                       /* nsegments    */
                             <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>size,                    /* maxsegsize   */
                               0,                       /* flags        */
                               NULL,                    /* lockfunc     */
                               NULL,                    /* lockfuncarg  */
                               &amp;sc-&gt;foo_baz_dma_tag)) {
                device_printf(dev, "Cannot allocate baz DMA tag!\n");
                return (ENOMEM);
        }

        if (<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>bus_dmamem_alloc(sc-&gt;foo_baz_dma_tag,       /* DMA tag      */
                           <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>(void **)&amp;sc-&gt;foo_baz_buf,   /* vaddr        */
                             BUS_DMA_NOWAIT,              /* flags        */
                           <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>&amp;sc-&gt;foo_baz_dma_map)) {
                device_printf(dev, "Cannot allocate baz DMA memory!\n");
                return (ENOMEM);
        }

        bzero(sc-&gt;foo_baz_buf, size);

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>bus_dmamap_load(sc-&gt;foo_baz_dma_tag,  /* DMA tag      */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>sc-&gt;foo_baz_dma_map,    /* DMA map      */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>sc-&gt;foo_baz_buf,        /* buffer       */
                                size,                   /* buffersize   */
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>foo_callback,           /* callback     */
                                &amp;sc-&gt;foo_baz_busaddr,   /* callbackarg  */
                                BUS_DMA_NOWAIT);        /* flags        */
        if (error || sc-&gt;foo_baz_busaddr == 0) {
                device_printf(dev, "Cannot map baz DMA memory!\n");
                return (ENOMEM);
        }

...
}</pre><p>Although <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22511"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">bus_dmamem_alloc</code> allocates <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22520"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> memory and creates a <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22526"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> DMA map, <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22532"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> loading that <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22539"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> memory into the <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22545"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> DMA map still needs to occur.<a class="indexterm" id="IDX-CHP-12-0088"/><a class="indexterm" id="IDX-CHP-12-0089"/><a class="indexterm" id="IDX-CHP-12-0090"/><a class="indexterm" id="IDX-CHP-12-0091"/><a class="indexterm" id="IDX-CHP-12-0092"/><a class="indexterm" id="IDX-CHP-12-0093"/></p><p>Also, since <code class="literal">bus_dmamem_alloc</code> allocates contiguous memory, the <code class="literal">nsegments</code> argument must be <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22581"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">1</code>. Likewise, the <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22590"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">maxsize</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22600"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">maxsegsz</code> arguments must be identical.</p><p>Lastly, since <code class="literal">nsegments</code> is <code class="literal">1</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject12_d1e22617"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">callback</code> can be the <code class="literal">foo_callback</code> function shown in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a> in <a class="xref" href="ch12.html#implementing_dma" title="Implementing DMA">Implementing DMA</a>.</p></div>
<div class="sect1" title="Synchronizing DMA Buffers"><div class="titlepage"><div><div><h1 class="title"><a id="synchronizing_dma_buffers"/>Synchronizing DMA Buffers</h1></div></div></div><p>DMA buffers must be synchronized after each write completed by the CPU/driver or a device. The exact reason why is beyond the scope of this book. But it’s basically done to ensure that the CPU/driver and device have a consistent view of the DMA buffer.</p><p>DMA buffers are synchronized with the <code class="literal">bus_dmamap_sync</code> function.</p><a id="I_programlisting12_d1e22645"/><pre class="programlisting">#include &lt;machine/bus.h&gt;

void
bus_dmamap_sync(bus_dma_tag_t dmat, bus_dmamap_t map, bus_dmasync_op_t op);</pre><p>This function synchronizes the DMA buffer currently loaded in the DMA map <code class="literal">map</code>. The <code class="literal">dmat</code> argument is the DMA tag that <code class="literal">map</code> is based on. The <code class="literal">op</code> argument identifies the type of synchronization operation to perform. Valid values for this argument are shown in <a class="xref" href="ch12s08.html#bus_underscore_dmamap_underscore_sync_sy" title="Table 12-5. bus_dmamap_sync Symbolic Constant">Table 12-5</a>.</p><div class="table"><a id="bus_underscore_dmamap_underscore_sync_sy"/><p class="title">Table 12-5. bus_dmamap_sync Symbolic Constant</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="bus_dmamap_sync Symbolic Constant"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMASYNC_PREWRITE</code></p></td><td style="text-align: left" valign="top"><p>Used to synchronize after the CPU/driver writes to the DMA buffer</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_DMASYNC_POSTREAD</code></p></td><td style="text-align: left" valign="top"><p>Used to synchronize after a device writes to the DMA buffer</p></td></tr></tbody></table></div></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id11"/>Conclusion</h1></div></div></div><p>This chapter detailed FreeBSD’s DMA management routines. These routines are primarily used by storage and network drivers, which are discussed in <a class="xref" href="ch13.html" title="Chapter 13. Storage Drivers">Chapter 13</a>, <a class="xref" href="ch16.html" title="Chapter 16. Network Drivers, Part 1: Data Structures">Chapter 16</a>, and <a class="xref" href="ch17.html" title="Chapter 17. Network Drivers, Part 2: Packet Reception and Transmission">Chapter 17</a>.</p></div></body></html>