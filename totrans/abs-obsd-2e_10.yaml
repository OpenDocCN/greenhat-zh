- en: Chapter 10. Securing Your System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Hackers at the gates?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Puffy the Barbarian*'
  prefs: []
  type: TYPE_NORMAL
- en: '*defends against fiends.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Securing your system
    means ensuring that your computer’s resources are used only by authorized people
    and for authorized purposes. Even if a system has no important data, it still
    has valuable CPU time, memory, storage, and bandwidth. People who think that their
    systems are too unimportant for anyone to bother breaking into risk finding their
    equipment hosting pornography or relaying attacks against industrial or military
    sites. If you’re like me, you would rather not discover that your computers took
    down a government agency by having law enforcement agents kick in your door.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking over large numbers of remote computers gets easier all the time. Every
    year, more and more point-and-click toolkits for penetrating servers crop up.
    When one bright attacker posts an exploit, anyone can use it. Breaking into computers
    is big business, and if your computer is left unprotected, it *will* be penetrated.
    The only question is how.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, intruders don’t break into operating systems; they break
    into server programs running on the operating system. Even the most paranoiac,
    secure-by-default operating system cannot protect poorly written programs from
    themselves. OpenBSD features like W^X and address space layout randomization do
    a lot to protect the operating system from the side effects of buggy programs,
    but programs themselves still crash and burn. OpenBSD has undergone extensive
    auditing and testing to eliminate the most common security flaws, but there’s
    no guarantee that every security flaw has been eradicated. New features appear
    constantly, and can interact with older functions (and each other) in unexpected
    ways. For more details on the OpenBSD-specific features, check the papers and
    presentations collection at *[http://www.OpenBSD.org/papers/](http://www.OpenBSD.org/papers/)*.
  prefs: []
  type: TYPE_NORMAL
- en: No single tool can protect your server against all threats, and no single tool
    is applicable to all environments. Learning about OpenBSD’s security features
    helps you to understand not only what the tools do, but when they should be used
    and when they won’t help your particular situation. The best place to start is
    by understanding the threat.
  prefs: []
  type: TYPE_NORMAL
- en: Who Is the Enemy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Books dedicated to security break attackers down into smaller, more specific
    groups and include various edge cases, but that’s not what you’re here for. I
    lump potential attackers into four groups: script kiddies, botnets, disaffected
    users, and skilled attackers. These categories are easily understood and include
    99 percent of all the attackers you’re likely to encounter.'
  prefs: []
  type: TYPE_NORMAL
- en: Script Kiddies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common type of attackers, script kiddies, are not sysadmins. They are
    amateurs who download attack scripts and go looking for poorly defended, vulnerable
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Script kiddies are easy to defend against: Keep your software up-to-date and
    follow good computing practices. Like locusts, script kiddies are easy to squash,
    but there are just so darned *many* of the little buggers!'
  prefs: []
  type: TYPE_NORMAL
- en: Botnets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Botnets are composed of machines compromised by worms or viruses and are controlled
    from a central point. The botnet’s controllers might use the victim machines to
    search for more vulnerable hosts, to send spam, or to break into secure sites.
    Most botnets are composed of Windows or Linux machines, but there’s no reason
    why such a worm couldn’t target OpenBSD. The virus author would need to work hard,
    but it’s conceivable—if he finds a suitable security flaw.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, botnet defense is much like script kiddie defense. You shouldn’t
    have much to worry about if you keep your software patched, configure your server
    software securely, and follow good computing practices.
  prefs: []
  type: TYPE_NORMAL
- en: Disaffected Users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security pundits commonly claim that a system’s legitimate users cause the majority
    of security problems.^([[26](#ftn.id385498)]) Legitimate users are most likely
    to know where your security gaps are, to feel that the system rules don’t apply
    to them, and to have the necessary access and time to experiment with breaking
    your security. If you tell an employee that company policy forbids him access
    to a computer resource, and the employee feels that he *should* have access to
    it, he is likely to search for a way around the restriction. You can patch all
    of your servers and protect them with an outright hostile firewall, but if someone
    has physical access and knows the root password, your protections are useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deal with this problem on two levels. The first is technical: Keep your servers
    patched and up-to-date. The second is human: Don’t leave projects half finished
    or half documented. That unsecured modem you installed for emergency incoming
    access until the VPN is solid? Get rid of it, or put a password on it. Ditto for
    that telnet server running on a nonstandard port.'
  prefs: []
  type: TYPE_NORMAL
- en: Security by obscurity is feeble at best. When a privileged user leaves the company,
    immediately disable his account, change all administrative passwords, inform employees
    of the person’s departure, and remind them not to share confidential information
    with that person. Implement a computer security policy with real penalties for
    violations. If you have a Human Resources department, get the staff members to
    agree to the policy and insist they enforce it.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the best way to protect yourself against the disaffected user? Don’t
    be lazy.
  prefs: []
  type: TYPE_NORMAL
- en: Skilled Attackers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the most dangerous group, skilled attackers are competent system administrators,
    security researchers, penetration specialists, and criminals who want access to
    specific resources. Taking over computers is a lucrative business these days.
    Sending junk email or launching distributed denial-of-service attacks can bring
    in large sums of money. These intruders don’t care who they attack, as long as
    they secure the computing resources they need.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your company has valuable secrets, however, you might attract an entirely
    different type of intruder: someone who wants access to your network in particular.
    If your employer creates anything—from software to cast-iron tulips for front-wheel-drive
    vehicles—there’s likely a market for illicit copies of your product. Someone will
    find it worthwhile to probe every port on every IP address you expose to the Internet.
    It might take a long time, but that’s okay. Your data has a price tag, and the
    scan is cheap. This is often called the advanced persistent threat, or APT.'
  prefs: []
  type: TYPE_NORMAL
- en: Security measures that stop the other types of intruders affect the techniques
    used by skilled attackers. If you’ve ditched that unsecured inbound access method,
    the intruder can’t find it. If your servers and programs are up to date and correctly
    configured, the intruder will need to find a previously unknown exploit to break
    into your network. If a skilled intruder really wants *your* company’s data, he
    will need to change tactics. Maybe he will try dumpster diving for old sticky
    notes, or even show up dressed as a telco repairman and try to install a packet
    sniffer. If an intruder knows everything about your network and his easiest way
    to break in is *still* something out of a caper film, your security is pretty
    good.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The word hacker has different meanings depending on who is talking. In the technical
    world, a hacker is someone not only interested in the inner workings of technology
    but also capable of creating new technology. The media has transformed the word
    to mean “someone who breaks into computers.” I recommend completely avoiding the
    word “hacker,” and using terms like “intruder” or “gravy sucking pig-dog” instead.
    When to use each is up to you, of course.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD Security Announcements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your best line of defense against all types of intruders is keeping your computer
    software up to date. This means you need to know when to update your system and
    what to update. The OpenBSD Project maintains a low-traffic mailing list, *security-announce@OpenBSD.org*,
    specifically to broadcast new security alerts to users. Subscribe to this list.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t feel like subscribing to yet another mailing list, these security
    alerts are also posted on OpenBSD-specific sites such as *[http://www.undeadly.org](http://www.undeadly.org)*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this won’t get you security alerts for third-party software running
    on OpenBSD. You must get updates for those programs separately. Check the software’s
    website for details on how to get their security announcements. All the time you’ve
    spent securing your operating system will be wasted if someone hijacks the insecure
    web application you neglected to update.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD Memory Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common intrusion paths is to attack what’s in the computer’s
    memory. If intruders can access memory that they shouldn’t be able to access,
    or if they can make a program access memory it shouldn’t, they have any number
    of ways to get into the system.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes a whole bunch of security features for system memory that the
    sysadmin never actually sees. You don’t need to turn on the nonexecutable stack;
    it’s just there.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these features appear only in OpenBSD. Some appeared first in OpenBSD,
    and then spread elsewhere. Some came from research papers. Others build on hardware
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenBSD team takes a more proactive attitude about security features than
    many other projects. As an example, consider the ProPolice deployment several
    years ago. ProPolice is a compiler feature that prevents certain classes of buffer
    overflows. When you enabled ProPolice in the early days, a lot of software could
    not be built. Even more software could be built, but it crashed when used. These
    failures were not ProPolice problems. ProPolice simply exposed programming errors
    in the software. But many users and developers said that “enabling ProPolice breaks
    all kinds of stuff, so don’t turn it on.”
  prefs: []
  type: TYPE_NORMAL
- en: The OpenBSD team enabled ProPolice by default in a development snapshot. What
    happened? Stuff—a lot of stuff—broke. Many third-party applications needed by
    OpenBSD users either could not build or would not run. Third-party application
    vendors started receiving bug reports from OpenBSD users who were able to say
    exactly how the software was broken. Software vendors started fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: ProPolice didn’t cause these crashes; it merely exposed bugs. By enabling ProPolice
    by default, OpenBSD gave the free software world incentive to fix those bugs.
    Eventually, as the type of bugs revealed by ProPolice became less common, other
    operating systems also enabled ProPolice. OpenBSD’s willingness to take this step
    improved computer security as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: If you closely follow OpenBSD development, expect to see more of this behavior.
    The OpenBSD team does what it considers most correct, not what is most convenient
    or easiest.
  prefs: []
  type: TYPE_NORMAL
- en: The common memory security features you should know about include W^X, .rodata
    segments, guard pages, randomized memory allocations, ProPolice, and protecting
    `atexit` and `stdio`. We’ll cover each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: W^X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: W^X stands for Write Xor Execute. Once a program is loaded, that program’s pages
    in memory are either writable or executable, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: A common exploit technique is to trick a program into writing information to
    memory, and then executing that piece of memory. An attacker might convince a
    program to write to a chunk of memory, but the kernel will not allow that memory
    to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Some hardware platforms (such as amd64) have hardware support for W^X. If that
    support exists, OpenBSD uses it.
  prefs: []
  type: TYPE_NORMAL
- en: .rodata Segments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A segment of memory containing program code traditionally had two parts: actual
    code and read-only data, or *.rodata segments*. In the past, some operating systems
    allowed programs to modify read-only memory. OpenBSD prevents this by leveraging
    hardware features when available.'
  prefs: []
  type: TYPE_NORMAL
- en: Guard Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many pieces of software used to access memory beyond what they allocated. If
    a program writes to memory that doesn’t belong to it, it’s writing to memory that
    belongs to a different program. Intruders use this to exploit programs. A *guard
    page* is a single page of memory next to the memory allocated by a program. The
    program cannot write to this memory. If the program tries to write to the guard
    page, it probably will crash. By enforcing this limit, OpenBSD protects other
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Using guard pages everywhere would use a lot of memory, so OpenBSD enables guard
    pages only in carefully selected places.
  prefs: []
  type: TYPE_NORMAL
- en: Address Space Layout Randomization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally, computers allocate memory consecutively. This can give intruders
    certain advantages. If they know that program A usually loads after program B,
    and they know they can make program B write to memory space outside its allocation,
    they can guess that they can write to program A’s memory space and make program
    A fail in a predictable manner. Doing so requires a certain degree of skill, but
    once one person figures out this exploit, innumerable people can use it.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD randomizes where it allocates memory. Two programs started one after
    the other don’t get consecutive memory blocks. The randomization is done intelligently,
    to avoid wasting memory. Intruders cannot use one program against another in this
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: ProPolice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ProPolice protects code against attacks that manipulate the memory stack. When
    code is compiled, ProPolice adds additional code to keep a program within its
    own area of memory. If ProPolice determines that specific areas of memory (called
    *canaries*) have been changed, it immediately aborts the program. Where other
    memory protection techniques prevent writing to executable memory, ProPolice terminates
    a process when writable memory that *can* be written to, but specifically *should
    not*, is changed.
  prefs: []
  type: TYPE_NORMAL
- en: And More!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenBSD includes a whole bunch of small memory guards scattered throughout.
    Here’s a small sampling:'
  prefs: []
  type: TYPE_NORMAL
- en: The `malloc()` and `atexit()` system calls mark memory nonwritable after updating
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File descriptor handling has been carefully audited throughout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snprintf` is async-signal-safe when no floats are involved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the list continues.
  prefs: []
  type: TYPE_NORMAL
- en: Could any of these be exploited in the real world? Some of them have, and some
    are just theoretical. But I would rather be protected against theoretical threats
    than assume no one can break something that has never been broken before.
  prefs: []
  type: TYPE_NORMAL
- en: File Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Unix-like operating systems share a common permissions scheme, but OpenBSD
    (and most BSD-based operating systems) extends the permissions scheme with *file
    flags*. File flags work with permissions to change file security. Flags can make
    a file unchangeable, make it so that existing data cannot be removed and users
    can only add to the file, and produce several other effects. Some flags have functions
    unrelated to security, but we’ll pay special attention to the security flags.
    File flags are listed and documented in `chflags(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: File Flag Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many file flags have different effects depending on the system securelevel,
    which we’ll cover in the next section. Understanding how securelevels work requires
    an understanding of file flags, while file flags rely on securelevels. For the
    moment, just nod and smile when I mention securelevels while discussing file flags.
    All will become clear, trust me.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenBSD’s UFS and UFS2 filesystems support the following file flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`sappnd`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Files with the system-level append-only flag can be added to but cannot be removed
    or otherwise edited. The `sappnd` flag is particularly useful for log files. For
    example, a common intruder tactic is to remove *.history* or symlink it to */dev/null*
    so that the administrator cannot see what happened. Setting `sappnd` on a user’s
    *.history* file can be interesting if the account is compromised. Using the `sappnd`
    flag ensures that intruders cannot cover their tracks in this manner. Only root
    can set or remove the `sappnd` flag, and it cannot be removed when the system
    is running at securelevel 1 or higher.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`uappnd`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The user-level append-only flag can be set only by the file owner or root. As
    with `sappnd`, a file with the `uappnd` flag can be added to but not otherwise
    edited or removed. This is most useful for personal logs and files; it primarily
    adds an extra layer of protection against users accidentally deleting their own
    files. The owner or root can set or remove this flag.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`schg`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Files with the system-level immutable flag cannot be changed in any way. They
    cannot be edited, moved, replaced, or overwritten. Basically, the filesystem itself
    prevents all attempts to alter this file. Only root can set or remove this flag,
    and it cannot be removed when the system is running at securelevel 1 or higher.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`uchg`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The user-level immutable flag prevents anyone from changing the file. It’s a
    user-level flag, so root can override it. This flag helps to prevent a file from
    being edited or removed by accident, but it’s not a way to secure the system.
    The owner or root can set or remove this flag at any securelevel.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`nodump`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The no dump flag tells `dump(8)` to not back up a file. Set this on files that
    don’t need to be backed up to tape. Check your backup program’s documentation
    to see if it honors this flag.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Setting, Viewing, and Removing File Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Set file flags with `chflags(1)`. For example, if you are really worried about
    someone changing your kernel file, you could mark */bsd* with the system-level
    immutable flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This would prevent anyone—including you—from changing the kernel, reconfiguring
    the kernel, or upgrading the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also recursively change the file flags on an entire directory tree
    with the `-R` flag. If you wanted to make the entirety of */bin* immutable, you
    would run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And poof, you can no longer upgrade your system.
  prefs: []
  type: TYPE_NORMAL
- en: To view the flags on a file, use `ls -lo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This file has no flags set on it. Let’s set the system-level append-only flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh, right—only root can set system-level flags. Let’s try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This file now has the `sappnd` flag. The system can add to it, but cannot otherwise
    edit or remove it.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD doesn’t flag any files out of the box, so you’ll need to add flags yourself
    if you want them. Before you go nuts, however, note that adding file flags increases
    the overhead for system maintenance. If upgrading a system is hard, the sysadmin
    won’t want to do it. Is it more secure to have all your programs in */bin* immutable,
    or is it more secure to simplify upgrades, updates, and application of security
    patches?
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a flag from a file, use `chflags` with a `no` before the flag name.
    For example, to unset the `sappnd` flag on the *vitallog* file, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Wait a minute! I’m running under `sudo(8)`, and I have root-level privileges.
    What’s going on?
  prefs: []
  type: TYPE_NORMAL
- en: By default, OpenBSD runs at securelevel 1\. When running at securelevel 1 or
    higher, you cannot unset system-level file flags, so an attempt to do so failed.
    You can remove these flags only at securelevel -1 or in single-user mode. Read
    on to learn about securelevels.
  prefs: []
  type: TYPE_NORMAL
- en: Securelevels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`securelevel(7)` is a kernel setting to restrict actions the system can perform.
    The kernel behaves slightly differently as you raise the securelevel. For example,
    at low securelevels, the file flags discussed in the previous section can be removed;
    a file might be marked immutable, but you can remove the marker, delete or edit
    the file, and restore the flag. When you increase the securelevel, however, you
    can no longer remove the flag. Similar changes take place in other parts of the
    system. Taken as a whole, these changes might frustrate or stop an intruder.'
  prefs: []
  type: TYPE_NORMAL
- en: Securelevel settings range from -1 to 2\. Though OpenBSD runs at securelevel
    1 by default, you can change this setting to fit your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Higher securelevels make system maintenance difficult. Many actions taken during
    normal upgrades and administration are also things that intruders might do to
    cover their tracks. It might make sense for you to run a highly secure, stable
    server at securelevel 2, and run your experimental machine at -1\. On the other
    hand, the OpenBSD folks don’t encourage changing from the default securelevel.
    Running your system at -1 may leave you open to attacks, while running at 2 complicates
    management and maintenance. Which securelevel you choose depends on your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the name, a securelevel is not an all-purpose general security dial.
    Arbitrarily increasing the securelevel will do nothing but annoy you and your
    users. While you can increase the securelevel at any time, you cannot reduce the
    securelevel without rebooting the system, so don’t experiment blindly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the System Securelevel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Set the boot-time securelevel in */etc/rc.securelevel*. In that file, you’ll
    find a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Change the `1` to your preferred securelevel. On your next reboot, the system
    will go to this securelevel when it enters multiuser mode. If you need to run
    a process before the boot process raises the securelevel, put the command to start
    the process in this file.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to raise the securelevel without rebooting, adjust the `kern.securelevel
    sysctl(3)` to the desired value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you cannot lower the securelevel of a running system. If a sysadmin
    could lower the securelevel, so could an intruder.
  prefs: []
  type: TYPE_NORMAL
- en: Securelevel Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenBSD has four securelevels: -1, 0, 1 and 2\. We’ll cover each in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: Securelevel -1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Securelevel -1 is also called permanently insecure mode. The system isn’t necessarily
    insecure—it’s just that none of the securelevel protections are in place. I use
    securelevel -1 only to remove file flags that I never should have used in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: Securelevel 0
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Securelevel 0 is used only when the system is first booting. It offers no special
    features. When the system reaches multiuser mode, however, the securelevel is
    automatically raised to 1\. Setting `securelevel=0` in */etc/rc.securelevel* is
    functionally equivalent to setting `securelevel=1`.
  prefs: []
  type: TYPE_NORMAL
- en: Securelevel 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At securelevel 1, OpenBSD’s default, things become interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The securelevel affects certain kernel configuration settings, called sysctls
    (covered in [Chapter 18](ch18.html "Chapter 18. Kernel Configuration")). Early
    in the boot process, OpenBSD uses the settings in */etc/sysctl.conf* to set sysctls.
    When I say that a particular sysctl cannot be changed, read that as “without altering
    the configuration and rebooting.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Securelevel 1 implements the following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: No one can write to the */dev/mem* and */dev/kmem* devices. Many security exploits
    work by writing to these devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The raw disk devices of all mounted file systems are read-only. (Writing to
    the raw devices of mounted filesystems would let you change files without regard
    to permissions.) Programs should access mounted filesystems only through the filesystem
    anyway, so this won’t change day-to-day operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system-level file flags `schg` and `sappnd` cannot be removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel modules cannot be loaded or unloaded. OpenBSD supports kernel modules,
    but the default kernel is monolithic. There’s no legitimate reason to load a kernel
    module on a running production system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sysctl `fs.posix.setuid` cannot be changed. By default, `chown(1)` clears
    the `setuid` and `setgid` bits on files when changing file permissions, as per
    the POSIX standard. You can override this by setting `fs.posix.setuid` to 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sysctl `hw.allowpowerdown` cannot be changed. This controls the power button’s
    interaction with the system. When it’s set to 1, briefly pressing the power button
    shuts down the system cleanly. When it’s set to 0, the power button does not shut
    down the system. (You can still shut down the system by holding down the power
    button for several seconds, but that’s not a clean shutdown.) Not all platforms
    support this kind of shutdown or power management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sysctl `net.inet.ip.sourceroute` cannot be changed. Source routing is a
    technique to permit the sender of a packet to control which route the packet takes
    across the network. It’s caused many security problems, and its use is generally
    discouraged. OpenBSD ignores source routing by default. Setting `net.inet.ip.sourceroute`
    to 1 forces OpenBSD to pay attention to source routing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sysctl `machdep.kbdreset` cannot be changed. When set to 1, `machdep.kbdreset`
    allows the system to be cleanly rebooted using CTRL-ALT-DELETE. When this sysctl
    is set to 0, the system ignores CTRL-ALT-DELETE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ddb.console` and `ddb.panic` sysctls may not be raised. Raising these sysctls
    enables certain kernel debugging options. Unauthorized users with physical access
    could gain unlimited system access through the debugger if they could raise these
    sysctls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sysctl `machdep.allowaperture` cannot be raised. If you want to use the
    X Window System (discussed in [Chapter 17](ch17.html "Chapter 17. Desktop OpenBSD")),
    you must allow X access to specific parts of kernel memory by enabling this sysctl
    early during the boot process. If you’re not running X, no one legitimately needs
    this access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General-purpose input/output (GPIO) controllers cannot be further configured.
    GPIO controllers support a wide variety of special-purpose hardware. See `gpio(4)`
    and `gpioctl(8)` for details on each.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These limitations have little effect on normal day-to-day operations, but they
    can interfere with debugging. If you’re trying to discover why your GPIO device
    isn’t working, you probably want to set your securelevel to -1.
  prefs: []
  type: TYPE_NORMAL
- en: Securelevel 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Securelevel 2 is the highest securelevel in OpenBSD, and it disables a variety
    of features that you might need during normal maintenance. Use securelevel 2 only
    on a stable machine that you don’t expect to change much. If you need to change
    anything restricted by securelevel 2, you must reboot the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Securelevel 2 includes everything from securelevel 1, plus the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raw disk devices are always read-only. You cannot format, fdisk, or disklabel
    disks, even if they’re not in use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system clock cannot be moved backward, nor close to the overflow point.
    Make sure your system time is correct before entering multiuser mode!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot alter packet-filtering rules (covered in [Chapter 21](ch21.html "Chapter 21. Packet
    Filtering") and [Chapter 22](ch22.html "Chapter 22. Advanced PF")). Packet filters,
    network address translation (NAT), traffic queues, and so on are immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel debugger sysctl values (those beginning with `ddb`) cannot be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, for example, you don’t want your firewall at securelevel 2 unless you understand
    that packet filtering rules can change only with a reboot.
  prefs: []
  type: TYPE_NORMAL
- en: What Securelevel Do You Need?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The securelevel appropriate for your environment depends entirely on your situation,
    but the overwhelming majority of the time, the default of securelevel 1 is most
    suitable.
  prefs: []
  type: TYPE_NORMAL
- en: If you are debugging and testing features and tools, you might find that you
    need to use securelevel -1 on a development machine. Once you’ve worked out how
    to configure your GPIO device or the correct debugger settings for your system,
    however, use securelevel 1 so that you mirror a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a very stable system, you could try securelevel 2\. In all my years
    of running OpenBSD, though, I’ve had only one system for which securelevel 2 was
    the right choice, and several cases where securelevel 2 created more trouble than
    it was worth.
  prefs: []
  type: TYPE_NORMAL
- en: Securelevel Weaknesses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What can’t securelevels do? Consider a case where someone compromises a web
    application on your server, uses that to bootstrap himself into a shell, and then
    uses the shell to bootstrap himself into root access. Securelevels don’t do anything
    to prevent this.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you’ve made copious use of the `schg` flag, the intruder can replace
    system binaries with ones that send your authentication credentials to a free
    email account registered in a bogus name. So you decide to run around applying
    the `schg` flag to the contents of critical directories like */bin* and */usr/lib*.
    That will stop the bugger! Well, that will work as long as you make every file
    immutable, including the system configuration files in */etc* —you know, the ones
    that you need to change in order to do your job. If you leave one file unprotected,
    the intruder could add a command like `chflags -R noschg /` to an early part of
    the system startup, and poof—the next time you reboot your system, you unlock
    all your files. How often do you exhaustively audit your */etc* files? And you’ll
    need to undo this tangled morass every time you patch or upgrade your system!
  prefs: []
  type: TYPE_NORMAL
- en: This is only one possible path. There are many ways for an intruder to lever
    himself into the system. Relying on securelevels to protect you is unwise. Use
    them and consider them a tool in your kit, but don’t think they are a panacea
    for every problem.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Secure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tools discussed in this chapter are not OpenBSD’s only security features.
    The OpenBSD team has put a lot of work into securing every part of the system.
    But this chapter covers some things that make OpenBSD special and gives you an
    idea of how those features work.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the best path to security? Keep your system updated and configure your
    server daemons securely. It’s boring, but it works.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[26](#id385498)]) I’ve seen too many botnet or script kiddie intrusions go
    undetected for months to be comfortable blaming legitimate users for the majority
    of security problems. I would agree that “insider intrusions” are the most commonly
    identified intrusions, but frequently, that’s because the guilty user can’t keep
    his mouth shut.
  prefs: []
  type: TYPE_NORMAL
