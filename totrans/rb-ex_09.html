<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;More Complex Utilities and Tricks, Part I"><div class="titlepage"><div><div><h1 class="title"><a id="more_complex_utilities_and_tricks_part_i"/>Chapter 9. More Complex Utilities and Tricks, Part I</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e14968"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages686190.png.jpg"/></div></div><p>This chapter is the first of two that explore more complex operations in Ruby. This one deals extensively with text manipulations and larger-scale searches, while the next details an important functional technique that expands your options for abstraction in a very powerful way. For now, let’s dive right in to learn some text processing techniques.</p><div class="sect1" title="#34 Finding Codes in the Bible or Moby-Dick (els_parser.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp34_finding_codes_in_the_bible_or_mo"/>#34 Finding Codes in the Bible or Moby-Dick (els_parser.rb)</h1></div></div></div><p>This script analyzes a phenomenon in large texts called <a class="indexterm" id="idx-CHP-9-0902"/>equidistant letter sequences (<a class="indexterm" id="idx-CHP-9-0903"/>ELSes). These sequences are popularly known as <span class="emphasis"><em>Bible Codes</em></span> or <a class="indexterm" id="idx-CHP-9-0904"/><span class="emphasis"><em>Torah Codes</em></span>, largely due to their description in Michael <a class="indexterm" id="idx-CHP-9-0905"/>Drosnin’s book <a class="indexterm" id="idx-CHP-9-0906"/><em class="citetitle">The Bible Code</em> (Simon &amp; Schuster, 1997), in which he examined the Hebrew Bible. An <span class="emphasis"><em>ELS</em></span> is a collection of letters (what Ruby would call a String) with a known starting point within the source text, a known length, and a known <span class="emphasis"><em>skip value</em></span>, which is the distance between the letters comprising that ELS. You could construct an ELS by saying, “Start with the 23rd letter in this newspaper article and add every 8th letter until you have 11 letters.” That String of 11 letters would be an ELS. Drosnin’s work suggests that <a class="indexterm" id="idx-CHP-9-0907"/>ELSes of particular significance (generally due to relevance to the text they’re drawn from or due to accurate prediction of future events, such as assassinations) appear at a rate greater than chance within certain religious texts.<a class="indexterm" id="idx-CHP-9-0908"/><a class="indexterm" id="idx-CHP-9-0909"/></p><p>My <code class="literal">els_parser.rb</code> script also uses the work of Professor Brendan <a class="indexterm" id="idx-CHP-9-0910"/>McKay of The <a class="indexterm" id="idx-CHP-9-0911"/>Australian National University. McKay has done his own research (available at <a class="ulink" href="http://cs.anu.edu.au/~bdm/dilugim/torah.html">http://cs.anu.edu.au/~bdm/dilugim/torah.html</a>) to find ELSes in texts like <em class="citetitle">War and Peace</em> and <em class="citetitle">Moby-Dick</em>, thus concluding that the ELSes that Drosnin refers to as the Bible Codes do not occur more often in the Hebrew Bible than can be expected due to chance. I can’t read Hebrew, so for this script I’ve chosen to analyze Herman Melville’s <em class="citetitle">Moby-Dick</em> in English instead of the Hebrew Bible. I downloaded the text from <a class="indexterm" id="idx-CHP-9-0912"/>Project Gutenberg (<a class="ulink" href="http://www.gutenberg.org">http://www.gutenberg.org</a>) into <code class="literal">extras/moby_dick.txt</code>. The <code class="literal">els_parser.rb</code> script allows you to choose a text and a set of input parameters that describe a potential set of ELSes; then <code class="literal">els_parser.rb</code> will report whether any ELSes that match the description exist within the source text.<a class="indexterm" id="idx-CHP-9-0913"/><a class="indexterm" id="idx-CHP-9-0914"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id033"/>The Code</h2></div></div></div><a id="I_programlisting9_d1e15078"/><pre class="programlisting">  #!/usr/bin/env ruby    <em class="lineannotation"><span class="lineannotation">ELS</span></em>
  # els_parser.rb

  require 'palindrome2.rb'
  # I want all Strings to have the private letters_only
  # method from this file.

  class String

  =begin rdoc
  This provides a public method to access the private letters_only
  method we required from palindrome2.rb.
  =end
    def just_letters(case_matters)
❶     letters_only(case_matters)
    end

  end

  =begin rdoc
  A text-processing parser that does ASCII-only
  Equidistant Letter Sequence analyses similar to that described
  at http://en.wikipedia.org/wiki/Equidistant_letter_sequencing

  For my example, I use Moby Dick taken from
  Project Gutenberg, http://www.gutenberg.org.
  =end
  class ELS_Parser

❷   DEFAULT_SEARCH_PARAMS = {
      :start_pt =&gt; 4500,
      :end_pt   =&gt; nil, # assumes the end of the String to search when nil
      :min_skip =&gt; 126995,
      :max_skip =&gt; 127005,
      :term     =&gt; 'ssirhan',
    }

    def initialize(filename, search_params=nil)
      @contents = prepare(filename)
      @filename = filename
      reset_params(search_params || DEFAULT_SEARCH_PARAMS)
    end

    def reset_params(search_params)
      @search_params            = search_params
      @search_params[:end_pt] ||= (@contents.size-1)
      # ||= for :end_pt allows nil for 'end of file'
      return self # return self so we can chain methods
    end

  =begin rdoc
  Performs an ELS analysis on the &lt;i&gt;filename&lt;/i&gt; argument, searching for
  the term argument, falling back to the default.
  =end
❸   def search(term=@search_params[:term])
      @search_params[:term] = term
      reversed_term = term.reverse
      warn "Starting search within #{@filename} " +    <em class="lineannotation"><span class="lineannotation"><strong class="userinput"><code>$DEBUG</code></strong></span></em>
        "using #{@search_params.inspect}" if ($DEBUG)
❹     final_start_pt = @search_params[:end_pt] - @search_params[:term].size
      @search_params[:start_pt].upto(final_start_pt) do |index|
        @search_params[:min_skip].upto(@search_params[:max_skip]) do |skip|
❺         candidate = construct_candidate(index, skip)

❻         if (candidate == @search_params[:term])
            return report_match(skip, index)
          end
       
          if (candidate == reversed_term)
            return report_match(skip, index, 'reversed ')
          end

        end
      end
❼     return report_match(false, false)
    end

    private

❽   def construct_candidate(index, skip)
      output = ''
      0.upto(@search_params[:term].size-1) do |char_index|
        new_index = (index + (char_index * (skip + 1)))
        return '' if (new_index &gt;= @contents.size)
        output += @contents[new_index].chr    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> chr</code></strong> Method</span></em>
      end
      return output
    end

  =begin rdoc
  Creates a 'letters only' version of the contents of a &lt;i&gt;filename&lt;/i&gt;
  argument in preparation for ELS analysis. Assumes case-insensitivity.
  =end
❾   def prepare(filename, case_matters=false)
      File.open(filename, 'r').readlines.to_s.just_letters(case_matters)
    end

  =begin
  Either report the variables at which a match was found, or report
  failure for this set of search params.
  =end
❿   def report_match(skip, index, reversed='')
      return "No match within #{@filename} using " +
        @search_params.inspect unless index
      return "Match for #{@search_params[:term]} " +
        "#{reversed}within #{@filename} " +
        "at index #{index}, using skip #{skip}"
    end

  end # <a class="indexterm" id="idx-CHP-9-0915"/>ELS_Parser</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id032"/>How It Works</h2></div></div></div><p>The <code class="literal">els_parser.rb</code> script only processes letters, ignoring whitespace and punctuation. We know that Strings can also have non-letter characters, such a whitespace, numbers, punctuation, and so on; therefore, we need a method that strips all non-letters out of a String. Fortunately, we already have such a method—<code class="literal">letters_only</code>, defined in <code class="literal">palindrome2.rb</code>. It is easy to take advantage of <code class="literal">letters_only</code> with a <code class="literal">require</code> at the top of <code class="literal">els_parser.rb</code>. However, <code class="literal">palindrome2.rb</code> defined <code class="literal">letters_only</code> as a <code class="literal">private</code> method, and (as will become clear), we want it available as a public method. What can we do? One approach, which is what <code class="literal">els_parser.rb</code> does at ❶, is to define a new public method, <code class="literal">just_letters</code>, that exists merely to call the pre-existing <code class="literal">private</code> method <code class="literal">letters_only</code>.<a class="indexterm" id="idx-CHP-9-0916"/><a class="indexterm" id="idx-CHP-9-0917"/></p><p>The <code class="literal">just_letters</code> method is for Strings, but we want a new class called <code class="literal">ELS_Parser</code> to do the overall management of the searching. <code class="literal">ELS_Parser</code> has a Hash Constant called <code class="literal">DEFAULT_SEARCH_PARAMS</code> at ❷. The values for the <code class="literal">:start_pt</code> and <code class="literal">:end_pt</code> Symbol keys represent the earliest and latest character index for the search, respectively. The value for <code class="literal">:term</code> is the text to be searched for. Finally, the values for <code class="literal">:min_skip</code> and <code class="literal">:max_skip</code> are the minimum and maximum number of letters to jump past (i.e., skip) during the search. Why these particular default values? They could have been any values, but I took a shortcut and started with values from McKay’s web page (<a class="ulink" href="http://cs.anu.edu.au/~bdm/dilugim/moby.html">http://cs.anu.edu.au/~bdm/dilugim/moby.html</a>) that are known to correspond to a particular match within the text of <em class="citetitle">Moby-Dick</em>.</p><p>Note some subtle differences—my values are 0-based (where a skip of 0 means <span class="emphasis"><em>Go to the next letter</em></span>), whereas McKay defines moving to the next letter as a skip of 1. There is a similar difference with regard to starting points. He also accomplishes searches for backward terms using a negative skip value, while <code class="literal">els_parser.rb</code> uses a positive skip <a class="indexterm" id="idx-CHP-9-0918"/>search on a reversed term.</p><p>For example, in the String <code class="literal">‘abcdefgh’</code>, which we’ll call <code class="literal">contents</code>, searching for an ELS with a <code class="literal">:start_pt</code> of <code class="literal">0</code>, a <code class="literal">:term</code> of <code class="literal">‘abc’</code>, and a <code class="literal">:min_skip</code> of <code class="literal">0</code> would find a match, because the String <code class="literal">‘abc’</code> exists within <code class="literal">contents</code> starting at 0 (right at the beginning) with a skip value of 0. Similarly, <code class="literal">‘ceg’</code> would be found within <code class="literal">contents</code> starting at 2 with a skip value of 1, and <code class="literal">‘heb’</code> would be found starting at 1 with a skip value of 2, but as a reversed String. If you expand these concepts greatly, use longer search terms, much larger <code class="literal">contents</code> (such as the Bible or <em class="citetitle">Moby-Dick</em>), and much larger starting, ending, and skip values, you will begin to understand the basics of ELS analysis.</p><p>After defining <code class="literal">DEFAULT_SEARCH_PARAMS</code>, our <a class="indexterm" id="idx-CHP-9-0919"/>ELS_Parser needs an <code class="literal">initialize</code> method, in which it will define the instance variables <code class="literal">@contents</code>, to hold the text being searched, and <code class="literal">@filename</code>, to store the name of the file it read <code class="literal">@contents</code> from.<a class="indexterm" id="idx-CHP-9-0920"/></p><p>The <code class="literal">@contents</code> variable is the result of calling the <code class="literal">prepare</code> method (defined at ❾) on the <code class="literal">filename</code>. The <code class="literal">prepare</code> method takes in a mandatory <code class="literal">filename</code> argument and an optional <code class="literal">case_matters</code> argument. All it does is open a new file, extract its <code class="literal">contents</code> into a String with <code class="literal">readlines.to_s</code>, and call <code class="literal">just_letters</code> on that String. This ensures that we strip out inappropriate characters from our String before storing it in <code class="literal">@contents</code>. Note that <code class="literal">just_letters</code> takes an optional argument for case sensitivity. If you’re curious about how this works, remember that <code class="literal">just_letters</code> just calls the <code class="literal">letters_only</code> method defined in <code class="literal">palindrome2.rb</code>, so you can refer to that script for further study.<a class="indexterm" id="idx-CHP-9-0921"/></p><p>The <code class="literal">initialize</code> method also calls the <code class="literal">reset_params</code> method, defined right below <code class="literal">initialize</code>, which simply sets the instance variable <code class="literal">@search_params</code> to the <code class="literal">search_params</code> argument passed into <code class="literal">initialize</code>, falling back to the <code class="literal">DEFAULT_SEARCH_PARAMS</code>. It also sets the <code class="literal">:end_pt</code> value to fall back to the last index of <code class="literal">@contents</code> if the <code class="literal">:end_pt</code> value would otherwise be <code class="literal">nil</code>. This gives <code class="literal">ELS_Parser</code> a handy shortcut: leaving out the <code class="literal">:end_pt</code> automatically means <span class="emphasis"><em>Search to the end of</em></span> <em class="replaceable"><code>@contents</code></em>.<a class="indexterm" id="idx-CHP-9-0922"/></p><p>Next is <code class="literal">search</code> at ❸. It allows an optional <code class="literal">term</code> argument, which automatically updates <code class="literal">@search_params[:term]</code> as needed. Since <code class="literal">search</code> is set up to find reversed <code class="literal">term</code>s as well as normal-order <code class="literal">term</code>s, we define <code class="literal">reversed_term</code> right away. We also report that the search is starting if <code class="literal">$DEBUG</code> is true using the method <code class="literal">warn</code>, which writes out to <span class="emphasis"><em>standard error</em></span>, instead of <span class="emphasis"><em>standard out</em></span>. <code class="literal">$DEBUG</code> is generally set as a command-line option to <code class="literal">ruby</code>, such that <code class="literal">$DEBUG</code> is true when you execute <code class="literal">ruby</code> with either the <code class="literal">-d</code> or <code class="literal">--debug</code> flag. You may remember standard error from <code class="literal">html_tidy.rb</code>. In that script, we sent standard error to <code class="literal">/dev/null</code>, meaning we didn’t care about it. Here, we have a special message designed specifically to go to standard error.<a class="indexterm" id="idx-CHP-9-0923"/><a class="indexterm" id="idx-CHP-9-0924"/></p><p>After the standard error warning, we define <code class="literal">final_start_pt</code> at ❹. To understand what <code class="literal">final_start_pt</code> is for, let’s go back to our <code class="literal">contents</code> = <code class="literal">‘abcdefgh’</code> search example. What if we search for <code class="literal">‘hiccup’</code> with a <code class="literal">:start_pt</code> of 100? There aren’t even 100 letters in our <code class="literal">contents</code>, so a search with that <code class="literal">:start_pt</code> value would automatically fail. Instead of letting that happen, we want to figure out the maximum starting index that could conceivably work, and make sure <code class="literal">:start_pt</code> is not larger than that value.</p><p>It’s even more complicated than that. Our search terms will always have letters, and those letters take up space. If we start too close to the end of <code class="literal">@contents</code>, we could run out of room even with relatively low skip values. We need to keep enough room for the term being searched for, which we store in <code class="literal">@search_params[:term]</code>, so we set <code class="literal">final_start_pt</code> accordingly.</p><p>After setting <code class="literal">final_start_pt</code>, we enter two nested loops—one on <code class="literal">index</code> from the lowest to highest starting points and one using <code class="literal">skip</code> to refer to each number from the lowest to highest skip values. The first thing we do within those loops is use <code class="literal">index</code> and <code class="literal">skip</code> at ❺ to assign the expression returned from <code class="literal">construct_candidate</code>, defined at ❽, into <code class="literal">candidate</code>. The <code class="literal">construct_candidate</code> method takes the existing <code class="literal">index</code> and <code class="literal">skip</code> values and makes a String of the same length as the term being searched for. For a <code class="literal">@contents</code> of <code class="literal">‘abcdefgh’, construct_candidate(2, 1)</code> produces <code class="literal">‘ceg’</code> where <code class="literal">@search_params[:term]</code> has three characters in it. The <code class="literal">construct_candidate</code> method returns the empty String if the <code class="literal">new_index</code> being asked for ever goes beyond the <code class="literal">@contents</code> String. Our <code class="literal">final_start_pt</code> limits should prevent this from ever being needed, but it’s an additional safety check.<a class="indexterm" id="idx-CHP-9-0925"/></p><div class="note" title="Note"><h3 class="title"><a id="note-53"/>Note</h3><p><span class="emphasis"><em>The <em class="replaceable"><code>construct_candidate</code></em> method also uses the <em class="replaceable"><code>chr</code></em> method, because extracting a single character out of a String gives you that character’s ASCII value</em></span>.</p></div><p>You can test this in irb:</p><a id="I_programlisting9_d1e15562"/><pre class="programlisting">irb(main):001:0&gt; s = 'abcde'
=&gt; "abcde"
irb(main):002:0&gt; s[0]
=&gt; 97
irb(main):003:0&gt; s[0].chr
=&gt; "a"</pre><p>After establishing our <code class="literal">candidate</code>, we want to see if it is a successful match, which we start to do at ❻. If it does match, we <code class="literal">return</code> the result of calling <code class="literal">report_match</code> with <code class="literal">skip</code> and <code class="literal">index</code> as arguments. However, we also want to know whether our <code class="literal">candidate</code> matches the <code class="literal">reversed_term</code> instead of the term in regular order, so we call <code class="literal">report_match</code>, again with <code class="literal">skip</code> and <code class="literal">index</code> as arguments, but we also add the String <code class="literal">‘reversed ’</code>. Finally, at ❼ we return the result of calling <code class="literal">report_match</code> with two explicit <code class="literal">false</code> arguments if we’ve looped through all of the appropriate <code class="literal">skip</code> and <code class="literal">index</code> loops without already returning something. This just means that we never found a match, either forward or reversed.</p><p>We need to know how <code class="literal">report_match</code> works. It’s defined at ❿, and it takes arguments for <code class="literal">skip, index</code>, and an optional <code class="literal">reversed</code> String, as already shown. If <code class="literal">index</code> is <code class="literal">false, report_match</code> returns a String informing the user that there was no match found. Otherwise, It returns the details of the successful match. Note that <code class="literal">reversed</code> adds the String <code class="literal">‘reversed ’</code> (including the trailing space) as needed.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id025"/>Running the Script</h2></div></div></div><p>We can test this with another script called <code class="literal">demo_els_parser.rb</code>. Here is its code:<a class="indexterm" id="idx-CHP-9-0926"/></p><a id="I_programlisting9_d1e15648"/><pre class="programlisting">#!/usr/bin/env ruby
# <a class="indexterm" id="idx-CHP-9-0927"/>demo_<a class="indexterm" id="idx-CHP-9-0928"/>els_parser.rb

require 'els_parser.rb'

moby_dick = ELS_Parser.new('extras/moby_dick.txt')
puts moby_dick.search() # assumes 'ssirhan'
puts moby_dick.reset_params( {
  :start_pt =&gt; 93060,
  :end_pt   =&gt; nil, # assumes 'to the end'
  :min_skip =&gt; 13790,
  :max_skip =&gt; 13800,
  :term     =&gt; 'kennedy'
} ).search()
puts moby_dick.reset_params( {
  :start_pt =&gt; 327400,
  :end_pt   =&gt; nil, # 'to the end' again
  :min_skip =&gt; 0,
  :max_skip =&gt; 5,
  :term     =&gt; 'rabin'
} ).search()
puts moby_dick.reset_params( {
  :start_pt =&gt; 104620,
  :end_pt   =&gt; 200000, # not to the end
  :min_skip =&gt; 26020,
  :max_skip =&gt; 26030,
  :term     =&gt; 'mlking'
} ).search()</pre></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id030"/>The Results</h2></div></div></div><p>Here is the result of calling this script:</p><a id="I_programlisting9_d1e15667"/><pre class="programlisting">ruby -w --debug demo_els_parser.rb
Starting search within extras/moby_dick.txt using {:end_pt=&gt;924955,
:min_skip=&gt;126995, :max_skip=&gt;127005, :term=&gt;"ssirhan", :start_pt=&gt;4500}
Match for ssirhan within extras/moby_dick.txt at index 4546, using skip 126999
Starting search within extras/moby_dick.txt using {:end_pt=&gt;924955,
:min_skip=&gt;13790, :max_skip=&gt;13800, :term=&gt;"kennedy", :start_pt=&gt;93060}
Match for kennedy within extras/moby_dick.txt at index 93062, using skip 13797
Starting search within extras/moby_dick.txt using {:end_pt=&gt;924955,
:min_skip=&gt;0, :max_skip=&gt;5, :term=&gt;"rabin", :start_pt=&gt;327400}
Match for rabin reversed within extras/moby_dick.txt at index 327500, using
skip 3
Starting search within extras/moby_dick.txt using {:end_pt=&gt;200000,
:min_skip=&gt;26020, :max_skip=&gt;26030, :term=&gt;"mlking", :start_pt=&gt;104620}
Match for mlking reversed within extras/moby_dick.txt at index 104629, using
skip 26025</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id022"/>Hacking the Script</h2></div></div></div><p>We could significantly increase the speed of <code class="literal">construct_candidate</code> by checking against the search terms as we go and returning the empty string whenever it fails to match—an application of the return guard notion within the construction of the candidate. Where we define <code class="literal">final_start_pt</code>, we could also either limit <code class="literal">:max_skip</code> in a similar way or report an error if impossible search parameters were asked for.<a class="indexterm" id="idx-CHP-9-0929"/></p><div class="note" title="Note"><h3 class="title"><a id="note-54"/>Note</h3><p><span class="emphasis"><em>There’s also a better way to include the <em class="replaceable"><code>letters_only</code></em> method than the way I’ve done it here, using a concept called a mixin. Jump ahead to the <em class="replaceable"><code>to_lang.rb</code></em> script in <a class="xref" href="ch10.html" title="Chapter 10. More Complex Utilities and Tricks, Part II">Chapter 10</a> to see mixins in action</em></span>.<a class="indexterm" id="idx-CHP-9-0930"/></p></div></div></div></div>
<div class="sect1" title="#35 Mutating Strings into Weasels (methinks.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp35_mutating_strings_into_weasels_me"/>#35 Mutating Strings into Weasels (methinks.rb)</h1></div></div></div><p>This script is based on a program from Richard <a class="indexterm" id="idx-CHP-9-0931"/>Dawkins’ <a class="indexterm" id="idx-CHP-9-0932"/><em class="citetitle">The Blind Watchmaker</em> (W.W. Norton, 1996).The program demonstrates a simplified model of asexual <a class="indexterm" id="idx-CHP-9-0933"/>natural selection, starting with a String consisting of <a class="indexterm" id="idx-CHP-9-0934"/>random characters and successively <a class="indexterm" id="idx-CHP-9-0935"/>mutating it to produce “children” that differ from the parent. The program then selects the “best” child String (meaning the one that most closely matches the target String <code class="literal">methinksitislikeaweasel</code>, a reference from <em class="citetitle">Hamlet</em>) to be the next generation’s parent. This process continues until the parent String matches the target String.<a class="indexterm" id="idx-CHP-9-0936"/><a class="indexterm" id="idx-CHP-9-0937"/></p><p>Let’s implement Dawkins’ process in Ruby.</p><div class="note" title="Note"><h3 class="title"><a id="note-55"/>Note</h3><p><span class="emphasis"><em>Dawkins wrote his program to demonstrate a version of cumulative selection over time that was intentionally simpler than real-world neo-Darwinian natural selection. Critics contend that the program is a suboptimal model, with the most prominent criticisms being that it is overly simplified, it is unable to fail, and it has a preset target, making it a better model of artificial selection than natural selection. See <a class="xref" href="ch09s02.html#hacking_the_script-id023" title="Hacking the Script">Hacking the Script</a> on page 175 for general suggestions for modifying this version of the program to be a better model of real-world Darwinian selection</em></span>.<a class="indexterm" id="idx-CHP-9-0938"/></p></div><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id034"/>The Code</h2></div></div></div><a id="I_programlisting9_d1e15759"/><pre class="programlisting">  #!/usr/bin/env ruby
  # methinks.rb

  =begin rdoc
  Recreate Richard Dawkins' Blind Watchmaker program, in which a purely
  random string is mutated and filtered until it matches the target string.
  =end

❶ class Children &lt; Array    <em class="lineannotation"><span class="lineannotation">Inheritance</span></em>

    def select_fittest(target)
      inject(self[0]) do |fittest,child|
        child.fitter_than?(fittest, target) ? child : fittest
      end
    end

  end

❷ class String

    ALPHABET = ('a'..'z').to_a

    LETTER_OFFSET = 'a'[0]

    PARAMS = {
      :generation_size =&gt; 20,
      :mutation_rate   =&gt; 10,
      :display_filter  =&gt; 5,
      :mutation_amp    =&gt; 6
    }

    TARGET = 'methinksitislikeaweasel'
 
    @mutation_attempts ||= 0

❸   def deviance_from(target)    <em class="lineannotation"><span class="lineannotation">Differences between <a class="indexterm" id="idx-CHP-9-0939"/>Strings</span></em>
      deviance = 0
      split('').each_index do |index|
        deviance += (self[index] - target[index]).abs
      end
      return deviance
    end

    def fitter_than?(other, target)
      deviance_from(target) &lt; other.deviance_from(target)
    end

❹   def mutate(params)
      split('').map do |char|
        mutate_char(char, params)
      end.join('')
    end

❺   def mutate_until_matches!(target=TARGET, params=PARAMS)
      return report_success if (self == target)
      report_progress(params)
      @mutation_attempts += 1
      children = propagate(params)
      fittest  = children.select_fittest(target)
      replace(fittest)
      mutate_until_matches!(target, params)
    end

❻   def propagate(params)
      children = Children.new()
      children &lt;&lt; self
      params[:generation_size].times do |generation|
        children &lt;&lt; self.mutate(params)
      end
      return children
    end

❼   def report_progress(params)
      return unless (@mutation_attempts % params[:display_filter] == 0)
      puts "string ##{@mutation_attempts} = #{self}"
    end

    def report_success()
      puts &lt;&lt;END_OF_HERE_DOC
  I match after #{@mutation_attempts} mutations
  END_OF_HERE_DOC
      return @mutation_attempts
    end

  =begin rdoc
  Replace self with a &lt;b&gt;String&lt;/b&gt; the same length as the
  &lt;i&gt;target&lt;/i&gt; argument, consisting entirely of lowercase
  letters.
  =end
❽   def scramble!(target=TARGET)
      @mutation_attempts = 0
      replace( scramble(target) )
    end

    def scramble(target=TARGET)
      target.split('').map do |char|
        ALPHABET[rand(ALPHABET.size)]
      end.join('')
    end

    private

  =begin rdoc
  Limit 'out of bounds' indices at end points of the ALPHABET.
  =end
❾   def limit_index(alphabet_index)
      alphabet_index = [ALPHABET.size-1,  alphabet_index].min
      alphabet_index = [alphabet_index, 0].max
      return alphabet_index
    end

❿   def mutate_char(original_char, params)
      return original_char if rand(100) &gt; params[:mutation_rate]
      variance = rand(params[:mutation_amp]) - (params[:mutation_amp] / 2)
      # variance with amp of 6 now ranges from -3 to 2,
      variance += 1 if variance.zero? # therefore move (0..2) up to (1..3)
      alphabet_index = (original_char[0] + variance - LETTER_OFFSET)
      alphabet_index = limit_index(alphabet_index)
      mutated_char = ALPHABET[alphabet_index]
      return mutated_char
    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id033"/>How It Works</h2></div></div></div><p>We start by defining a new class called <a class="indexterm" id="idx-CHP-9-0940"/>Children at ❶. You’ll notice the peculiar <code class="literal">Children &lt; Array</code> within the class definition, which suggests a relationship between Children and Arrays. That relationship is <span class="emphasis"><em>inheritance</em></span>. Children inherits from Array, meaning that it behaves as an Array in every way, while also adding whatever new characteristics we give it. In our case, the only new characteristic is a new method called <code class="literal">select_fittest</code>, which uses <code class="literal">inject</code> to find the fittest child within Children, defined by the <code class="literal">fitter_than?</code> method.<a class="indexterm" id="idx-CHP-9-0941"/><a class="indexterm" id="idx-CHP-9-0942"/><a class="indexterm" id="idx-CHP-9-0943"/><a class="indexterm" id="idx-CHP-9-0944"/></p><div class="sidebar"><a id="children_dont_lie"/><p class="title">CHILDREN DON’T LIE</p><p>There’s one other way in which a child class (or subclass) differs from its parent, and that’s the expression returned by the class method. It returns the name of the subclass when called on an instance of the subclass:</p><a id="I_programlisting9_d1e15815"/><pre class="programlisting">$ irb -r <a class="indexterm" id="idx-CHP-9-0945"/>methinks.rb
irb(main):001:0&gt; a = Array.new
=&gt; []
irb(main):002:0&gt; c = Children.new
=&gt; []
irb(main):003:0&gt; a.class
=&gt; Array
irb(main):004:0&gt; c.class
=&gt; Children</pre><p>Some people may think that’s obvious, but it’s worth noting.</p></div><p>After defining Children, we open the String class at ❷. We add several Constants, including an Array of letters that we’ll call the <code class="literal">ALPHABET</code>, and <code class="literal">LETTER_OFFSET</code>. The <code class="literal">LETTER_OFFSET</code> Constant requires some explanation. It represents characters as <a class="indexterm" id="idx-CHP-9-0946"/>ASCII values to determine how closely certain <a class="indexterm" id="idx-CHP-9-0947"/>Strings match each other. Converting letters to numerical value is convenient, as it allows us to use basic mathematical operations to find the “most fit” child string. Ruby converts characters to numerical values by treating a String as an Array and reading values out with indices. Let’s demonstrate in irb (the <code class="literal">chr</code> method converts from ASCII values back to a String):</p><a id="I_programlisting9_d1e15846"/><pre class="programlisting">irb(main):001:0&gt; s = 'abcde'
=&gt; "abcde"
irb(main):002:0&gt; s[0]
=&gt; 97
irb(main):003:0&gt; s[0].chr
=&gt; "a"
irb(main):004:0&gt; 'a'[0]
=&gt; 97
irb(main):005:0&gt; s[1]
=&gt; 98</pre><p>You can see that the <a class="indexterm" id="idx-CHP-9-0948"/>ASCII value for the String <code class="literal">‘a’</code> (the <a class="indexterm" id="idx-CHP-9-0949"/>character at index <code class="literal">0</code> in String <code class="literal">s</code>) is <code class="literal">97</code>, that the <code class="literal">chr</code> method converts that ASCII value back to <code class="literal">‘a’</code>, and that the ASCII value for <code class="literal">‘b’</code> is <code class="literal">98</code>. The number <code class="literal">97</code> is our <code class="literal">LETTER_OFFSET</code>. Astute readers will notice that <code class="literal">LETTER_OFFSET</code> is the index at which <code class="literal">‘a’</code> appears in our <code class="literal">ALPHABET</code>, as well. Observe the following in irb:</p><a id="I_programlisting9_d1e15899"/><pre class="programlisting">irb(main):001:0&gt; letters = ('a'..'z').to_a
=&gt; ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o",
"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
irb(main):002:0&gt; 's'[0]
=&gt; 115
irb(main):003:0&gt; 's'[0] - 'a'[0]
=&gt; 18
irb(main):004:0&gt; letters[18]
=&gt; "s"</pre><p>Calling <code class="literal">[0]</code> on a character and subtracting <code class="literal">LETTER_OFFSET</code> (<code class="literal">‘a’[0]</code>, or <code class="literal">97</code>) gives us the index of that character within our <code class="literal">ALPHABET</code> Array. This will be very handy in the <code class="literal">mutate_char</code> method at ❿, which we’ll discuss when we get there.</p><p>Our next two Constants are <code class="literal">PARAMS</code> and <code class="literal">TARGET</code>. Both of these establish defaults for items that might be overridden by optional arguments. <code class="literal">PARAMS</code> is a now-familiar Hash with Symbol keys, each value of which determines the specific behavior of our mutations. The value for <code class="literal">:generation_size</code> is the number of children, <code class="literal">:mutation_rate</code>’s is the percentage chance that a mutation will occur at all, <code class="literal">:display_filter</code> just sets how often our program will give updates while it’s running, and <code class="literal">:mutation_amp</code> determines how strong or divergent a given mutation can be—basically a numeric measure of how different children can be from their parents.</p><p><code class="literal">TARGET</code> is our default final goal: <code class="literal">methinksitislikeaweasel</code>. Finally, after the Constants, we have a single class variable called <code class="literal">@mutation_attempts</code>, which is just a counter that increments every time we mutate. We’re ready to start defining some methods.</p><p>Our first new method to add to String is <code class="literal">deviance_from</code> (❸). It takes a mandatory target argument (the default fallback to the <code class="literal">TARGET</code> Constant occurs in <code class="literal">mutate_until_matches!</code> at ❺, which is later in the code but is called earlier). The <code class="literal">deviance_from</code> method returns an Integer (<code class="literal">deviance</code>) which is a numeric measure of how different two <a class="indexterm" id="idx-CHP-9-0950"/>Strings are. Each character of difference at each point within the String increments <code class="literal">deviance</code> by one. Here are some irb examples:<a class="indexterm" id="I_indexterm9_d1e15981"/></p><a id="I_programlisting9_d1e15985"/><pre class="programlisting">irb -r <a class="indexterm" id="idx-CHP-9-0951"/>methinks.rb
irb(main):001:0&gt; 'aaa'.deviance_from('aaa')
=&gt; 0
irb(main):002:0&gt; 'aaa'.deviance_from('aab')
=&gt; 1
irb(main):003:0&gt; 'aaa'.deviance_from('aac')
=&gt; 2
irb(main):004:0&gt; 'aaa'.deviance_from('bac')
=&gt; 3
irb(main):005:0&gt; 'aaa'.deviance_from('baq')
=&gt; 17</pre><p>This method is useful for our <a class="indexterm" id="idx-CHP-9-0952"/>script, because if we are trying to model the survival of the fittest, we need to be able to measure <a class="indexterm" id="idx-CHP-9-0953"/>fitness. A low <code class="literal">deviance_from</code> the <code class="literal">target</code> represents fitness. Just below <code class="literal">deviance_from</code> is <code class="literal">fitter_than?</code>, a simple predicate that compares the <code class="literal">deviance_from</code> value for <code class="literal">self</code> and the <code class="literal">deviance_from</code> value for the <code class="literal">other</code> String, both relative to the same <code class="literal">target</code>. It only returns <code class="literal">true</code> when <code class="literal">self</code>’s <code class="literal">deviance_from</code> value is lower, making <code class="literal">self</code> fitter. Take a look at <a class="xref" href="ch09s02.html#hacking_the_script-id023" title="Hacking the Script">Hacking the Script</a> on page 175 for a way to eliminate this method entirely.</p><p>Next up is <code class="literal">mutate</code> (❹). It takes a mandatory <code class="literal">params</code> argument, which falls back to the default <code class="literal">PARAMS</code> Constant in <code class="literal">mutate_until_matches!</code> (❺) earlier within the script’s operation, if necessary. The <code class="literal">mutate</code> method is remarkably lazy, in that it <code class="literal">split</code>s its calling object into individual characters, and calls <code class="literal">mutate_char</code> (❿) on each of those characters via <code class="literal">map</code>.<a class="indexterm" id="idx-CHP-9-0954"/><a class="indexterm" id="idx-CHP-9-0955"/><a class="indexterm" id="idx-CHP-9-0956"/></p><p>The <code class="literal">mutate_char</code> method is a bit more complicated. It takes mandatory arguments for the <code class="literal">original_char</code> and <code class="literal">params</code>, and it exits immediately if <code class="literal">params</code> says that it should not mutate, which is determined by a <a class="indexterm" id="idx-CHP-9-0957"/>random percentage being higher than <code class="literal">params[:mutation_rate]</code>. Assuming it passed <code class="literal">params</code>’ test, <code class="literal">mutate_char</code> will mutate the character. First, it declares a <code class="literal">variance</code>, which is just the amount and direction of change based on the <code class="literal">:mutation_amp</code>. The values for <code class="literal">variance</code> range from <code class="literal">+(:mutation_amp / 2)</code> to <code class="literal">-(:mutation_amp / 2)</code>, excluding zero. They initially vary from <code class="literal">-(:mutation_amp / 2)</code> to one less than <code class="literal">+(:mutation_amp / 2)</code>, including zero, but the line that executes <code class="literal">variance +=1 if variance.zero?</code> ensures that values of zero or higher are bumped up by one.</p><p>It then creates an <code class="literal">alphabet_index</code> variable, which uses <code class="literal">LETTER_OFFSET</code> as previously discussed to find that index within <code class="literal">ALPHABET</code> for our <code class="literal">original_char</code>, plus any appropriate <code class="literal">variance</code>. It then limits <code class="literal">alphabet_index</code> with the <code class="literal">limit_index</code> method (❾), which clips or truncates <code class="literal">alphabet_index</code> to a maximum of the last index within <code class="literal">ALPHABET</code> and minimum of <code class="literal">0</code>, which is the first index within <code class="literal">ALPHABET</code>. Since it then has a dependable index to read from <code class="literal">ALPHABET</code>, it does so, placing that value within a variable called <code class="literal">mutated_char</code>, which it then <code class="literal">return</code>s.</p><p>Following <code class="literal">mutate</code> is <code class="literal">mutate_until_matches!</code> (❺), which is the public-facing workhorse of the script. It takes optional arguments for <code class="literal">target</code> and <code class="literal">params</code>, falling back to String’s <code class="literal">TARGET</code> and <code class="literal">PARAMS</code> Constants, as mentioned in earlier discussions of other methods. If <code class="literal">self</code> matches the <code class="literal">target</code> exactly, we want to <code class="literal">report_success</code>. Failing that, we want to <code class="literal">report_progress</code>. We can look at both of those methods, which start at ❼. The <code class="literal">report_success</code> method uses <code class="literal">puts</code> to show that it matches exactly after a certain number of attempts, and it returns <code class="literal">@mutation_attempts</code> without incrementing it. (There’s no need to increment it, since no new mutation occurred.) The <code class="literal">report_progress</code> method returns with no value unless <code class="literal">@mutation_attempts</code> is a multiple of (i.e., has a modulus of 0 relative to) <code class="literal">params[:display_filter]</code>. If we set a lower display filter, we have a chattier mutation process. Assuming that it should output, it uses <code class="literal">puts</code> to show what <code class="literal">self</code> is after however many <code class="literal">@mutation_attempts</code>.<a class="indexterm" id="idx-CHP-9-0958"/><a class="indexterm" id="idx-CHP-9-0959"/></p><p>After reporting its progress, <code class="literal">mutate_until_matches!</code> should then actually do some <a class="indexterm" id="idx-CHP-9-0960"/>mutating. It increments <code class="literal">@mutation_attempts</code> and then creates a new variable called <code class="literal">children</code>, which is the output of <code class="literal">propagate</code> (❻). The <code class="literal">propagate</code> method takes some <code class="literal">params</code> and instantiates a new instance of Children (❶), meaning that it has access to <code class="literal">select_fittest</code>, which is not available to Arrays. It appends it <code class="literal">self</code> onto <code class="literal">children</code>, the effect of which is that if the parent (<code class="literal">self</code>) is fitter than all of the <code class="literal">children</code>, the parent will again be the source of the generation of <code class="literal">children</code> after this one. The <code class="literal">propagate</code> method then appends a child (a mutated version of it <code class="literal">self</code>) onto <code class="literal">children</code>, doing so a number of times equal to <code class="literal">params[:generation_size]</code>. Finally, it returns the <code class="literal">children</code>, who will then try to make their way in the cruel world.<a class="indexterm" id="idx-CHP-9-0961"/></p><p>The effect of the cruel world is accomplished via Children’s <code class="literal">select_fittest</code> method. The world is cruel indeed, because only one child survives, as discussed already. We call the fittest child <code class="literal">fittest</code>, appropriately, and <code class="literal">replace</code> the parent with this fittest child. Then <code class="literal">mutate_until_matches!</code> recursively calls itself, <a class="indexterm" id="idx-CHP-9-0962"/>mutating until it finally matches the <code class="literal">target</code>.</p><p>Two methods remain undescribed: <code class="literal">scramble</code> and <code class="literal">scramble!</code> (❽). Both of these methods take an optional <code class="literal">target</code> argument that defaults to <code class="literal">TARGET</code>. Since <code class="literal">scramble!</code> is destructive, it sets <code class="literal">self</code>’s <code class="literal">@mutation_attempts</code> to <code class="literal">0</code> and <code class="literal">replace</code>s it <code class="literal">self</code> with the value returned by the non-destructive <code class="literal">scramble</code>. The <code class="literal">scramble</code> method <code class="literal">split</code>s the <code class="literal">target</code> at each <code class="literal">char</code> and creates a new Array via <code class="literal">map</code>; each member of the new Array is a <a class="indexterm" id="idx-CHP-9-0963"/>random element from <code class="literal">ALPHABET</code>. Note that we don’t even make any use of <code class="literal">char</code>—we just use <code class="literal">map</code> to make sure that the scrambled String is the same <code class="literal">size</code> as the <code class="literal">target</code>. The <code class="literal">scramble</code> method then <code class="literal">join</code>s that Array of random characters with the empty String and returns the resulting String: a String of the same length as the target, consisting entirely of random letters.<a class="indexterm" id="idx-CHP-9-0964"/><a class="indexterm" id="idx-CHP-9-0965"/></p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id026"/>Running the Script</h2></div></div></div><p>Let’s try it out in irb.</p><a id="I_programlisting9_d1e16422"/><pre class="programlisting">irb -r <a class="indexterm" id="idx-CHP-9-0966"/>methinks.rb
irb(main):001:0&gt; candidate = String.new.scramble!()
=&gt; "rnvrtdldcgaxlsleyrmzych"
irb(main):002:0&gt; candidate.mutate_until_matches!()</pre></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id031"/>The Results</h2></div></div></div><a id="I_programlisting9_d1e16431"/><pre class="programlisting">string #0 = rnvrtdldcgaxlsleyrmzych
string #5 = okvpqekfcicsnsleysmzsci
string #10 = pkvnnekhdkdslrjeztmvseh
string #15 = pkvjnekjfmgslrjeytjrsei
string #20 = plvflekjhmislljettjosel
string #25 = oisfmejkimisllkeqtjlsel
string #30 = mfsgmgjnimislkkeotgjsel
string #35 = mfsglgjqimislkkeivfhsel
string #40 = mesgigkqiriskhleivffsel
string #45 = mesgikkqirislhleivfasel
string #50 = mesgikkqirislhkegvfasel
string #55 = metiilksitislhkegvfasem
string #60 = metiilksitislhkefvfasem
string #65 = meshinlsitislhkeaweasel
string #70 = methinlsitislhkeaweasel
string #75 = methinlsitislhkeaweasel
string #80 = methinlsitislikeaweasel
string #85 = methinlsitislikeaweasel
string #90 = methinlsitislikeaweasel
string #95 = methinlsitislikeaweasel
string #100 = methinlsitislikeaweasel
string #105 = methinlsitislikeaweasel
string #110 = methinlsitislikeaweasel
string #115 = methinlsitislikeaweasel
string #120 = methinlsitislikeaweasel
string #125 = methinlsitislikeaweasel
string #130 = methinlsitislikeaweasel
string #135 = methinlsitislikeaweasel
string #140 = methinlsitislikeaweasel
string #145 = methinlsitislikeaweasel
string #150 = methinlsitislikeaweasel
I match after 152 mutations
=&gt; 152</pre><p>Try it on your own machine, and notice that the results are <a class="indexterm" id="idx-CHP-9-0967"/>random—sometimes the <a class="indexterm" id="idx-CHP-9-0968"/>script takes more generations, sometimes fewer. If you pass in different values, you can get dramatically different results:</p><a id="I_programlisting9_d1e16443"/><pre class="programlisting">irb(main):005:0&gt; candidate = String.new.scramble!('hello')
=&gt; "wnwdi"
irb(main):006:0&gt; candidate.<a class="indexterm" id="idx-CHP-9-0969"/>mutate_until_matches!('hello')
string #0 = wnwdi
string #5 = onsdj
string #10 = lnpgj
string #15 = ijlkj
string #20 = hemlj
string #25 = hemll
string #30 = hemlo
I match after 34 mutations
=&gt; 34</pre><p>We’ll explore this program further in our next script, <code class="literal">methinks_meta.rb</code>.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id023"/>Hacking the Script</h2></div></div></div><p>The <code class="literal">select_fittest</code> method could be expressed as follows in terms of <code class="literal">sort_by</code>, rather than <code class="literal">inject</code>. The returned value is exactly the same, whether it’s the memoization within <code class="literal">inject</code> or the member of the sorted <code class="literal">Children</code> at the zeroth index. Using <code class="literal">sort_by</code> would also allow us to eliminate the <code class="literal">fitter_than?</code> method entirely.<a class="indexterm" id="idx-CHP-9-0970"/></p><a id="I_programlisting9_d1e16484"/><pre class="programlisting">return sort_by do |child|
  child.deviance_from(target)
end[0]</pre><p>The <code class="literal">replace</code> in <code class="literal">mutate_until_matches!</code> is what makes it destructive, making it appropriate for its name to end with a bang. The <code class="literal">mutate_until_matches!</code> method could easily have been purely functional by replacing the last two lines of the method with <code class="literal">return fittest.mutate_until_matches(target, params)</code>, although the name would then have been misleading, even without the bang—perhaps simply <code class="literal">get_match</code> would be a better name in this case. In addition, the <code class="literal">@mutation_attempts</code> variable would not be retained from mutation to mutation. We would have to alter <code class="literal">mutate_until_matches!</code> (or <code class="literal">get_match</code>, or whatever other new name it would have) to accept <code class="literal">mutation_attempts</code> as an optional argument, defaulting to zero for the first call. Its treatment would be very similar to how <code class="literal">els_parser.rb</code> updates <code class="literal">@search_params[:term]</code> with the optional <code class="literal">term</code> argument.</p><p>What would stop us from implementing the <code class="literal">propagate</code> method (❻) with something like the following code?</p><a id="I_programlisting9_d1e16531"/><pre class="programlisting">return [self] +
  (1..params[:generation_size]).to_a.map do |gen|
    self.mutate(params)
  end</pre><p>The main problem is that the returned value from <code class="literal">propagate</code> would be an <code class="literal">Array</code>, not a <code class="literal">Children</code>, meaning that it would not have access to the <code class="literal">select_fittest</code> method that we added to <code class="literal">Children</code>, our subclass of <code class="literal">Array</code>. We could use our new definition of <code class="literal">propagate</code> by eliminating the subclassing of <code class="literal">Children &lt; Array</code> (❶) and simply adding the <code class="literal">select_fittest</code> method to all <code class="literal">Array</code>s.</p><p>You could also modify this program to be a more accurate model of a more complex type of cumulative selection, such as real-world <a class="indexterm" id="idx-CHP-9-0971"/>Darwinian selection. Such a program would have multiple competing “species” of Strings, something to represent food supplies (which would be in finite supply and be consumed by the reproduction process), multiple potentially-successful targets not preset by the programmer, and so on. The changes would allow some Strings’ descendants to be unable to produce competitive children (and thus become extinct), while other Strings’ descendants would flourish, just like organisms in the real world.</p></div></div>
<div class="sect1" title="#36 Mutating the Mutation of Strings into Weasels (methinks_meta.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp36_mutating_the_mutation_of_strings"/>#36 Mutating the Mutation of Strings into Weasels (methinks_meta.rb)</h1></div></div></div><p>This script uses the previous one, <code class="literal">methinks.rb</code>, so make sure you understand how that one works before trying this one, <code class="literal">methinks_meta.rb</code>. This script uses techniques similar to those used in <code class="literal">methinks.rb</code> to find the “best” input parameters for <code class="literal">methinks.rb</code>.<a class="indexterm" id="idx-CHP-9-0972"/><a class="indexterm" id="idx-CHP-9-0973"/><a class="indexterm" id="idx-CHP-9-0974"/><a class="indexterm" id="I_indexterm9_d1e16599"/></p><p>The previous script’s performance (the number of generations it takes to match the target) can vary greatly from one run to the next. Two major factors affect that variation in our results: The first factor is the set of arbitrary starting parameters. We saw that a target of <code class="literal">hello</code> was much easier to reach quickly than a target of <code class="literal">methinksitislikeaweasel</code>. Using other values for <code class="literal">:mutation_rate</code> or the other parameters also has an impact. The second factor is the unpredictable nature of the <a class="indexterm" id="idx-CHP-9-0975"/>random <a class="indexterm" id="idx-CHP-9-0976"/>variations while the program runs. Over time, after many runs, the laws of probability will cause this second factor to be less and less important—and in any case, randomness is part of the given problem. Our arbitrary starting parameters are crucial. How do we decide what they should be?</p><div class="note" title="Note"><h3 class="title"><a id="note-56"/>Note</h3><p><span class="emphasis"><em>Varying the <em class="replaceable"><code>:display_filter</code></em> has no impact on how many generations it takes to reach the target, only how often the program reports on its own progress. Also, genuine random number generation is possible with computers—often by measuring the decay of radioactive elements or listening to noise from a microphone—but our “random” number generation is actually only pseudo-random. Pseudo-random numbers come from a process that has a pattern, making them unsuitable for use in heavy-duty applications like stress testing or cryptography. They’re random enough for our script’s purposes, though. This pseudo-random caveat applies to all random numbers in this book</em></span>.<a class="indexterm" id="idx-CHP-9-0977"/><a class="indexterm" id="idx-CHP-9-0978"/></p></div><p>The arbitrary set of <a class="indexterm" id="idx-CHP-9-0979"/>input parameters is the major problem facing the efficiency of our string’s mutations. Luckily, we’d recognize an ideal set of parameters if we saw them, and we can easily rate parameter sets as better or worse in relation to each other, because we have an easy way to measure success: A low number of generations needed to reach the target String. We already have a way to process candidates repeatedly to reach a given target—it’s called <code class="literal">methinks.rb</code>.</p><p>Just as we can create a Proc that returns another Proc (as shown in <a class="xref" href="ch06s05.html" title="#24 Nesting lambdas">#24 Nesting lambdas</a> on page 111), we can create a mutator that operates at a higher level of mutation—<a class="indexterm" id="idx-CHP-9-0980"/>mutating not just Strings, but the mutation of those Strings. We can define fitter as <span class="emphasis"><em>requiring a lower number of generations to reach the target</em></span>, plug in some parameters, and go. Our new script, <code class="literal">methinks_meta.rb</code>, will (pseudo-)randomly vary arbitrary input parameters and filter them by this fitness criterion to find ever-better input parameters for us. Let’s see the code.<a class="indexterm" id="idx-CHP-9-0981"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id035"/>The Code</h2></div></div></div><a id="I_programlisting9_d1e16664"/><pre class="programlisting">  #!/usr/bin/env ruby
  # methinks_meta.rb

❶ require 'methinks'

  class Hash

❷   def get_child()
      new_hash = {}
      each_pair do |k,v|
        new_hash[k] = (rand(v) + (v/2))
      end
      new_hash[:display_filter] = 5
      return new_hash
    end

  end # Hash

  ###

❸ class Meta_Mutator

    NEW_TARGET   = 'ruby'
    MAX_ATTEMPTS = 2
    TARGET = NEW_TARGET || String::TARGET

    def initialize()
      @params_by_number_of_mutations = {}
    end

❹   def mutate_mutations!(params, did_no_better_count=0)
      return if did_no_better_count &gt; MAX_ATTEMPTS

      num = update_params_by_number_of_mutations!(params)

      return mutate_mutations!(
        @params_by_number_of_mutations[best_num],
        get_no_better_count(num, did_no_better_count)
      )

    end

❺   def report()
      @params_by_number_of_mutations.sort.each do |pair|
        num, params = pair
        puts sprintf("%0#{digits_needed}d", num) +
          " generations with #{params.inspect}"
      end
    end

    private

❻   def best_num()
      @params_by_number_of_mutations.keys.sort[0] || nil
    end

❼   def digits_needed()
      @params_by_number_of_mutations.keys.max.to_s.size
    end

❽   def get_children(params, number_of_children = 10)
      (0..number_of_children).to_a.map do |i|
        params.get_child()
      end
    end

❾   def get_no_better_count(num, did_no_better_count)
      return did_no_better_count if (num == best_num)
      did_no_better_count + 1
    end

❿   def update_params_by_number_of_mutations!(params)
      children = get_children(params)
      number_of_mutations = nil
      children.each do |params|
        candidate = String.new.scramble!(TARGET)
        number_of_mutations = candidate.mutate_until_matches!(TARGET, params)
        @params_by_number_of_mutations[number_of_mutations] = params.dup
      end
      return number_of_mutations
    end

  end # Meta_Mutator

  ###

  params = {
    :generation_size =&gt; 200,
    :mutation_rate   =&gt; 30,
    :display_filter  =&gt; 5,
    :mutation_amp    =&gt; 7
  }

  mm = Meta_Mutator.new()
  mm.mutate_mutations!(params)
  mm.report()</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id034"/>How It Works</h2></div></div></div><p>Since we’re performing operations that use <code class="literal">methinks.rb</code>, we <code class="literal">require</code> that file at ❶. We then immediately open the Hash class, adding a new method called <code class="literal">get_child</code> at ❷. The <code class="literal">get_child</code> method, which could also have been named mutate or reproduce, performs <a class="indexterm" id="idx-CHP-9-0982"/>random variations on all of the values for the given Hash. It assumes that those values are Integers, and can thereby be varied with the <code class="literal">rand</code> method—in this case, from half the given value to 1.5 times the given value. Since the <code class="literal">:display_filter</code> value has no impact on fitness, we just forcibly set that to <code class="literal">5</code>. We accomplish the mutation through the construction of a <code class="literal">new_hash</code> by iterating over <code class="literal">self</code> with the <code class="literal">each_pair</code> method and making the necessary changes before writing to <code class="literal">new_hash</code>, which we then <code class="literal">return</code>.<a class="indexterm" id="idx-CHP-9-0983"/></p><div class="note" title="Note"><h3 class="title"><a id="note-57"/>Note</h3><p><span class="emphasis"><em>We already noted how <em class="replaceable"><code>get_child</code></em> makes the assumption that all of its Hash’s values are Integers. It also assumes that the Hash has a key called <em class="replaceable"><code>:display_filter</code></em>. This assumption works fine for our script, but if the <em class="replaceable"><code>get_child</code></em> method were to become part of a commonly-used library, we would have to make it play nicely with other programs. A programmer can avoid this method for inappropriate Hashes, but a better solution would be for the programmer to take responsibility for making new methods more robust when he or she opens an existing class and adds a new method. A production-ready version of <em class="replaceable"><code>get_child</code></em> would check that the Hash’s values can implement numeric addition and also check for the presence of a <em class="replaceable"><code>:display_filter</code></em> key before performing the operations laid out in our example</em></span>.<a class="indexterm" id="idx-CHP-9-0984"/><a class="indexterm" id="idx-CHP-9-0985"/></p></div><p>Next, we create our <code class="literal">Meta_Mutator</code> class at ❸. It has several Constants. The <code class="literal">NEW_TARGET</code> Constant defines a different target String. This was mainly for the convenience of having a shorter target, so that runs of the program would take a shorter time. The <code class="literal">MAX_ATTEMPTS</code> Constant defines the maximum number of attempts we should make to beat our previously fittest mutation attempt before giving up and trying a new set of parameters. <code class="literal">TARGET</code> is either our <code class="literal">NEW_TARGET</code> or the familiar <code class="literal">String::TARGET</code> from <code class="literal">methinks.rb</code>. This definition allows us to override the <code class="literal">TARGET</code> easily while still having a default value, and not having to constantly change code later when we want different targets—we just always use <code class="literal">TARGET</code>. The <code class="literal">Meta_Mutator</code> class also has the expected <code class="literal">initialize</code> <a class="indexterm" id="idx-CHP-9-0986"/>method, which takes no arguments and defines an empty Hash for <code class="literal">@params_by_number_of_mutations</code>. We’ll see this instance variable in action later.<a class="indexterm" id="idx-CHP-9-0987"/></p><p>Next comes the public method <code class="literal">mutate_mutations!</code> at ❹. Note that it is destructive, and it takes two arguments: a required <code class="literal">params</code> Hash, and an optional Integer for the <code class="literal">did_no_better_count</code>, assumed to be zero, which makes sense for an initial run. It has a return guard, which allows it to exit early if the <code class="literal">did_no_better_count</code> is greater than the <code class="literal">MAX_ATTEMPTS</code> allowed. Assuming it should continue, it calls <code class="literal">update_params_by_number_of_mutations!</code> (defined at ❿), passes in the <code class="literal">params</code> argument, and places its returned value into the local <code class="literal">num</code> variable.<a class="indexterm" id="idx-CHP-9-0988"/><a class="indexterm" id="idx-CHP-9-0989"/></p><p>Let’s jump down to ❿ to see what <code class="literal">update_params_by_number_of_mutations!</code> does. It creates some children, using <code class="literal">get_children</code>, defined at ❽. Then <code class="literal">get_children</code> creates an Array to be returned by <code class="literal">map</code> ping the operation of calling <code class="literal">get_child</code> on the <code class="literal">params</code> Hash onto an Array with as many members as the requested <code class="literal">number_of_children</code> (assumed to be <code class="literal">10</code>). The <code class="literal">update_params_by_number_of_mutations!</code> method then loops through <code class="literal">each</code> of those <code class="literal">children</code>, calling each one <code class="literal">params</code>. It constructs a new <code class="literal">candidate</code> and determines the <code class="literal">number_of_mutations</code> needed to reach the <code class="literal">TARGET</code> by calling <code class="literal">mutate_until_matches!</code> (from <code class="literal">methinks.rb</code>) on that <code class="literal">candidate</code>. We now have our measure of fitness and the <code class="literal">params</code> used to achieve that level of fitness. We update <code class="literal">@params_by_number_of_mutations</code>, setting the value at the <code class="literal">number_of_mutations</code> key to be <code class="literal">params</code>, as the name <code class="literal">@params_by_number_of_mutations</code> suggests. It then returns the <code class="literal">number_of_mutations</code> required by this pass through <code class="literal">mutate_until_matches!</code>.<a class="indexterm" id="idx-CHP-9-0990"/></p><p>Back in <code class="literal">mutate_mutations!</code> (❹), we recursively call <code class="literal">mutate_mutations!</code> again, this time with the “fittest” result in <code class="literal">@params_by_number_of_mutations</code> as the first argument and the result of calling <code class="literal">get_no_better_count(num, did_no_better_count)</code> as the second argument.<a class="indexterm" id="idx-CHP-9-0991"/></p><p>The <code class="literal">best_num</code> method is defined at ❻, and it is straightforward. The keys of <code class="literal">@params_by_number_of_mutations</code> are the number of mutations needed to reach the target. Since they’re Integers, the lowest (and therefore “fittest”) value will be the first element of the resulting Array when we <code class="literal">sort</code> them. We can get that easily with <code class="literal">[0]</code>. The <code class="literal">get_no_better_count</code> method is defined at ❾; it takes the existing <code class="literal">num</code> and <code class="literal">did_no_better_count</code> as its only arguments. It returns <code class="literal">0</code> if this pass’ <code class="literal">num</code> is the <code class="literal">best_num</code>, resetting the <code class="literal">did_no_better_count</code>. Otherwise, it returns <code class="literal">did_no_better_count + 1</code>.<a class="indexterm" id="idx-CHP-9-0992"/></p><p>That’s it for <code class="literal">mutate_mutations!</code>. There’s one other public method, <code class="literal">report</code>, defined at ❺. It sorts through each pair within <code class="literal">@params_by_number_of_mutations</code>, outputting results via <code class="literal">puts, inspect</code>, String interpolation, and the <code class="literal">digits_needed</code> method, defined at ❼. It simply takes all the keys of <code class="literal">@params_by_number_of_mutations</code>, finds the <code class="literal">max</code>, and converts that highest Integer to a String with <code class="literal">to_s</code>. That String’s <code class="literal">size</code> method returns the number of characters, which is our desired number of <code class="literal">digits_needed</code> for display purposes.<a class="indexterm" id="idx-CHP-9-0993"/></p><p>We can compute values as well as report them. We establish default <code class="literal">params</code> near the bottom of <code class="literal">methinks_meta.rb</code>, instantiate a <code class="literal">Meta_Mutator</code>, and call its <code class="literal">mutate_mutations!</code> and <code class="literal">report</code> methods. Let’s see the results.<a class="indexterm" id="idx-CHP-9-0994"/></p><div class="note" title="Note"><h3 class="title"><a id="note-58"/>Note</h3><p><span class="emphasis"><em>This script is not meant to demonstrate proper statistical analysis. Your results could be highly variable based on initial conditions. To accurately measure the improvement (or lack thereof) between variations, you should perform multiple runs of each version and verify that the differences you’re seeing are statistically significant. That’s beyond the scope of this book though. If this program inspires you to write programs that manipulate other programs, it’s done its job</em></span>.</p></div></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id027"/>Running the Script</h2></div></div></div><a id="I_programlisting9_d1e17039"/><pre class="programlisting">$ ruby -w methinks_meta.rb</pre></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id032"/>The Results</h2></div></div></div><a id="I_programlisting9_d1e17044"/><pre class="programlisting">string #0 = onfi
string #5 = ppbm
string #10 = rtbq
string #15 = rubv
I match after 18 mutations
string #0 = tfjc
string #5 = uuar
I match after 9 mutations
string #0 = qmsi
string #5 = rqln
string #10 = rugv
I match after 13 mutations
string #0 = yuqa
string #5 = uupf
... (several lines removed)...
string #0 = umsv
string #5 = rupy
I match after 10 mutations
string #0 = vclv
string #5 = rlay
I match after 8 mutations
04 generations with {:generation_size=&gt;243, :mutation_rate=&gt;25,
:mutation_amp=&gt;11, :display_filter=&gt;5}
08 generations with {:generation_size=&gt;251, :mutation_rate=&gt;28,
:mutation_amp=&gt;7, :display_filter=&gt;5}
09 generations with {:generation_size=&gt;234, :mutation_rate=&gt;31,
:mutation_amp=&gt;10, :display_filter=&gt;5}
10 generations with {:generation_size=&gt;112, :mutation_rate=&gt;15,
:mutation_amp=&gt;7, :display_filter=&gt;5}
11 generations with {:generation_size=&gt;162, :mutation_rate=&gt;26,
:mutation_amp=&gt;7, :display_filter=&gt;5}
12 generations with {:generation_size=&gt;118, :mutation_rate=&gt;30,
:mutation_amp=&gt;5, :display_filter=&gt;5}
13 generations with {:generation_size=&gt;100, :mutation_rate=&gt;24,
:mutation_amp=&gt;3, :display_filter=&gt;5}
14 generations with {:generation_size=&gt;191, :mutation_rate=&gt;29,
:mutation_amp=&gt;5, :display_filter=&gt;5}
15 generations with {:generation_size=&gt;146, :mutation_rate=&gt;22,
:mutation_amp=&gt;8, :display_filter=&gt;5}
17 generations with {:generation_size=&gt;161, :mutation_rate=&gt;14,
:mutation_amp=&gt;7, :display_filter=&gt;5}
18 generations with {:generation_size=&gt;112, :mutation_rate=&gt;18,
:mutation_amp=&gt;3, :display_filter=&gt;5}
22 generations with {:generation_size=&gt;277, :mutation_rate=&gt;40,
:mutation_amp=&gt;4, :display_filter=&gt;5}
24 generations with {:generation_size=&gt;112, :mutation_rate=&gt;41,
:mutation_amp=&gt;4, :display_filter=&gt;5}
27 generations with {:generation_size=&gt;120, :mutation_rate=&gt;24,
:mutation_amp=&gt;3, :display_filter=&gt;5}
36 generations with {:generation_size=&gt;140, :mutation_rate=&gt;17,
:mutation_amp=&gt;4, :display_filter=&gt;5}</pre><p>Our winner is <code class="literal">{:generation_size=&gt;243, :mutation_rate=&gt;25, :mutation_amp=&gt;11, :display_filter=&gt;5}</code>, with a match after only four generations. Again, the <code class="literal">:display_filter</code> doesn’t matter, it’s the other three parameters that really make a difference. You can rerun <code class="literal">methinks_meta.rb</code> as many times as you like, seeing if your winning values seem to hover around a given range of values for each important parameter. You can then reset the default <code class="literal">params</code> at the bottom of <code class="literal">methinks_meta.rb</code> and keep going as long as you want.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id024"/>Hacking the Script</h2></div></div></div><p>If we want the results to always show the <code class="literal">params</code> keys in alphabetical <a class="indexterm" id="idx-CHP-9-0995"/>order, we could override the built-in <code class="literal">inspect</code> method of all Hashes with the following code:<a class="indexterm" id="I_indexterm9_d1e17080"/><a class="indexterm" id="I_indexterm9_d1e17083"/><a class="indexterm" id="I_indexterm9_d1e17086"/></p><a id="I_programlisting9_d1e17091"/><pre class="programlisting">def inspect()
  '{' + keys.sort_by do |k|
    k.inspect
  end.map do |k|
    "#{k.inspect} =&gt; #{self[k].inspect}"
  end.join(', ') + '}'
end</pre></div></div>
<div class="sect1" title="Chapter Recap"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_recap-id007"/>Chapter Recap</h1></div></div></div><p>This chapter’s mandate was to use techniques you’ve already learned at some broader levels. However, there were still a few new concepts or approaches.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Equidistant Letter Sequences and larger-scale text searches</p></li><li class="listitem"><p>Extracting single characters from Strings</p></li><li class="listitem"><p>The <code class="literal">chr</code> method</p></li><li class="listitem"><p>Modeling natural selection with <code class="literal">methinks.rb</code></p></li><li class="listitem"><p>Subclassing (<code class="literal">Children &lt; Array</code>) and inheritance</p></li><li class="listitem"><p>Calculating differences between Strings</p></li><li class="listitem"><p><code class="literal">select_fittest</code> : <code class="literal">inject</code> versus <code class="literal">sort_by</code></p></li><li class="listitem"><p>Genuine random versus pseudo-random</p></li><li class="listitem"><p>Meta-mutation with <code class="literal">methinks_meta.rb</code></p></li><li class="listitem"><p>Alphabetizing <code class="literal">inspect</code> through overriding</p></li></ul></div><p>Our next chapter is the second of two chapters that consider more complex programs. While this chapter mainly expanded upon concepts we’ve already learned, the next one uses an exciting new type of abstraction, known as a <span class="emphasis"><em>callback</em></span>. Let’s get to it.</p></div></body></html>