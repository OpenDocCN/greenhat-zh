<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;AD HOC FLOW VISUALIZATION"><div class="titlepage"><div><div><h1 class="title"><a id="ad_hoc_flow_visualization"/>Chapter 8. AD HOC FLOW VISUALIZATION</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e13840"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages651574.png.jpg"/></div></div><p>Although viewing the content of flows and running reports helps track down problems, some issues can be properly assessed through visualization only. The average human brain simply cannot assemble 6,000 lines of plain-text data into a coherent understanding of the situation. Transforming large quantities of data into visual form eases comprehension.</p><p>Perhaps the most common way to convert data to graphical form is through an office suite, such as Microsoft Office or OpenOffice.org. Office suites are not suited to automation, however. Once you have designed your graphs, regenerating them with new data should be trivial or even instantaneous. Tools such as CUFlow (<a class="xref" href="ch06.html" title="Chapter 6. PERL, FLOWSCAN, AND CFLOW.PM">Chapter 6</a>) and FlowGrapher (<a class="xref" href="ch07.html" title="Chapter 7. FLOWVIEWER">Chapter 7</a>) provide basic graphing, but they lack true ad hoc flexibility, such as the ability to choose the style of graph or whether to overlay one graph atop another. To provide truly unlimited flexibility in a manner that you can automate or quickly reproduce, you need <code class="literal">gnuplot</code>.</p><div class="sect1" title="gnuplot 101"><div class="titlepage"><div><div><h1 class="title"><a id="gnuplot_101"/>gnuplot 101</h1></div></div></div><p><code class="literal">gnuplot</code> (<a class="ulink" href="http://www.gnuplot.info/">http://www.gnuplot.info/</a>) has a notoriously steep learning curve and a reputation for complexity. The notoriety and reputation are not completely unwarranted. <code class="literal">gnuplot</code>'s power and efficiency more than make up for its challenges, however. Although mastering <code class="literal">gnuplot</code> can take years, you can quickly learn enough to create impressive graphs of your network data. Almost every Unix-like operating system includes current <code class="literal">gnuplot</code> packages, and you can also find packages for Windows, DOS, VMS, and almost every other operating system used in the past 20 years.<a class="indexterm" id="IDX-CHP-8-0001"/><a class="indexterm" id="IDX-CHP-8-0002"/><a class="indexterm" id="IDX-CHP-8-0003"/><a class="indexterm" id="IDX-CHP-8-0004"/><a class="indexterm" id="IDX-CHP-8-0005"/></p><p>Using <code class="literal">gnuplot</code> on the reporting server simplifies reporting and the development of graphs. To use <code class="literal">gnuplot</code> on your reporting server, you'll need an X server on your workstation. If you use a Unix workstation, you're all set. If not, you can find any number of X Windows servers for Microsoft Windows. Be sure to choose one that can forward X over SSH, rather than speaking raw X over the network. (On Windows, I use the PuTTY SSH client and Xming X server.)</p><p>If you don't want to use an X terminal on your desktop, install <code class="literal">gnuplot</code> on your workstation, and then run reports on the server and transfer them to your workstation. Develop your graphs on your workstation, save their configurations, and copy those configurations to your server to automatically create more graphs.</p><div class="sidebar"><a id="other_graphing_programs"/><p class="title">OTHER GRAPHING PROGRAMS</p><p>gnuplot's main advantage is that it's easily automated. To create graphs on the fly without worrying about reproducing them later, consider Grace (<a class="ulink" href="http://plasma-gate.weizmann.ac.il/Grace/">http://plasma-gate.weizmann.ac.il/Grace/</a>).<a class="indexterm" id="IDX-CHP-8-0006"/></p></div><div class="sect2" title="Starting gnuplot"><div class="titlepage"><div><div><h2 class="title"><a id="starting_gnuplot"/>Starting gnuplot</h2></div></div></div><p>The best way to learn <code class="literal">gnuplot</code> is to use it. When <code class="literal">gnuplot</code> starts, it displays a message and offers its own command prompt.</p><a id="I_programlisting8_d1e13934"/><pre class="programlisting"># <strong class="userinput"><code>gnuplot</code></strong>
...
Terminal type set to 'x11'
gnuplot&gt;</pre><p>To leave <code class="literal">gnuplot</code>, enter either <strong class="userinput"><code>exit</code></strong> or <strong class="userinput"><code>quit</code></strong>.</p><p>Most <code class="literal">gnuplot</code> commands either alter a drawing's appearance or create a new drawing. For a taste for how <code class="literal">gnuplot</code> works, graph a sine wave. (For some reason, the sine plot is traditional in <code class="literal">gnuplot</code> tutorials.) On the <code class="literal">gnuplot</code> command line, enter the following:</p><a id="I_programlisting8_d1e13964"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot sin(x)</code></strong></pre><p>You should see another window appear, displaying the classic sine wave, as shown in <a class="xref" href="ch08.html#sine_wave" title="Figure 8-1. Sine wave">Figure 8-1</a>.<a class="indexterm" id="IDX-CHP-8-0007"/><a class="indexterm" id="IDX-CHP-8-0008"/><a class="indexterm" id="IDX-CHP-8-0009"/><a class="indexterm" id="IDX-CHP-8-0010"/></p><div class="figure"><a id="sine_wave"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e13989"/><img alt="Sine wave" src="httpatomoreillycomsourcenostarchimages651604.png.jpg"/></div></div><p class="title">Figure 8-1. Sine wave</p></div><p>To modify your graphs, use the <code class="literal">set</code> command. You can set countless values, from the title of a graph to the labels on the x- and y-axes, colors used, and so on. Here I'm giving the graph the title of <span class="emphasis"><em>test graph</em></span>:</p><a id="I_programlisting8_d1e14002"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>set title "test graph"</code></strong></pre><p>The displayed graph doesn't change until you tell <code class="literal">gnuplot</code> to replot the data, like so:</p><a id="I_programlisting8_d1e14012"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot sin(x)</code></strong></pre><p>Now your graph should have a title.</p></div><div class="sect2" title="gnuplot Configuration Files"><div class="titlepage"><div><div><h2 class="title"><a id="gnuplot_configuration_files"/>gnuplot Configuration Files</h2></div></div></div><p>The test graph you created here took very little effort. You didn't read in any data or enter complicated formulas. Flow data is much more complicated than a sine wave, however, and in this chapter you'll work through several iterations of your graph to make it look "just right." You can save all the settings from a <code class="literal">gnuplot</code> session so that you can call up those same settings and use them to plot new data. Just tell <code class="literal">gnuplot</code> the name of the file you want to save your configuration in.</p><a id="I_programlisting8_d1e14029"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>save "test.plt"</code></strong></pre><p>You'll find a <code class="literal">gnuplot</code> configuration file named <span class="emphasis"><em>test.plt</em></span> in your current directory. This file contains all the <code class="literal">gnuplot</code> commands you entered, including the title and the <code class="literal">plot sin(x)</code> instruction. Exit <code class="literal">gnuplot</code>, and restart it. Then load this configuration file:<a class="indexterm" id="IDX-CHP-8-0011"/><a class="indexterm" id="IDX-CHP-8-0012"/><a class="indexterm" id="IDX-CHP-8-0013"/><a class="indexterm" id="IDX-CHP-8-0014"/><a class="indexterm" id="IDX-CHP-8-0015"/><a class="indexterm" id="IDX-CHP-8-0016"/><a class="indexterm" id="IDX-CHP-8-0017"/><a class="indexterm" id="IDX-CHP-8-0018"/><a class="indexterm" id="IDX-CHP-8-0019"/><a class="indexterm" id="IDX-CHP-8-0020"/><a class="indexterm" id="IDX-CHP-8-0021"/><a class="indexterm" id="IDX-CHP-8-0022"/></p><a id="I_programlisting8_d1e14104"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>load "test.plt"</code></strong></pre><p>Your graph will reappear, with all the changes you specified.</p><p>Retyping two commands to re-create your graph wouldn't be difficult, but graphs based on flow reports might include dozens of instructions, some of them long and tedious. Being able to save your <code class="literal">gnuplot</code> configuration and reuse it to graph new data will save time and effort and reduce errors.</p><p>Now let's get some real data to graph.</p></div></div></div>
<div class="sect1" title="Time-Series Example: Bandwidth"><div class="titlepage"><div><div><h1 class="title"><a id="time-series_example_colon_bandwidth"/>Time-Series Example: Bandwidth</h1></div></div></div><p>One common question network engineers get is "How much bandwidth does this application use?" I've worked in more than one global operation where management was concerned about how much internal bandwidth email consumed or where the Active Directory team needed to know how much bandwidth the interdomain controller communications used.</p><p>Flow reports can answer this question in many different ways. An average of bandwidth use through the day is useful but won't reveal intermittent performance bottlenecks. A connection that's completely idle most of the time but that has a massive throughput spike during each day's peak hours might have an average throughput of about 50Kbps. The one-day average is simultaneously accurate and useless. The best way to answer this question is with a graph.</p><p>You'll start by investigating how much bandwidth you use between your desktop DHCP range and the Active Directory domain controllers at remote sites on your internal network during a particular 24-hour period. This is a very specific example of a question network engineers get all the time, and you can use this technique to answer any bandwidth-related question. You'll begin with a look at the total inbound and outbound traffic in a total bandwidth report.</p><div class="sect2" title="Total Bandwidth Report"><div class="titlepage"><div><div><h2 class="title"><a id="total_bandwidth_report"/>Total Bandwidth Report</h2></div></div></div><p>Any time you want to create a graph of bandwidth, packets, or flows over time, the best way to get the data is with the <code class="literal">linear-interpolated-flows-octets-packets</code> report (discussed in <a class="xref" href="ch05.html" title="Chapter 5. REPORTING AND FOLLOW-UP ANALYSIS">Chapter 5</a>). This report produces a good estimate of the number of octets, flows, and packets per second in a selection of flow data. You're specifically interested in bandwidth (octets) per second, so you can produce this information with this <span class="emphasis"><em>stat.cfg</em></span> configuration:</p><a id="I_programlisting8_d1e14139"/><pre class="programlisting">stat-report octets
     type linear-interpolated-flows-octets-packets
     output
❶    fields -packets,-flows
     path |/usr/local/bin/flow-rptfmt
     sort -key

 stat-definition octets
     report octets</pre><p>Because you're interested in the number of bytes transmitted, you remove at ❶ the packet and flow counts from this report. The other settings are <code class="literal">flow-report</code>'s defaults. Next, you need to decide what data to feed into the report.<a class="indexterm" id="IDX-CHP-8-0023"/><a class="indexterm" id="IDX-CHP-8-0024"/><a class="indexterm" id="IDX-CHP-8-0025"/></p><div class="sect3" title="Filtering Flows for Total Traffic"><div class="titlepage"><div><div><h3 class="title"><a id="filtering_flows_for_total_traffic"/>Filtering Flows for Total Traffic</h3></div></div></div><p>Say you want to graph the bandwidth usage between your desktop DHCP range and several remote hosts. To filter these hosts out of your flow data, you'll use primitives for these hosts.</p><a id="I_programlisting8_d1e14168"/><pre class="programlisting">filter-primitive localDesktops
    type ip-address-prefix
    permit 172.17.3/24
    permit 172.17.4/23

filter-primitive remoteDC
    type ip-address
    permit 172.18.0.10
    permit 172.18.0.11
...</pre><p>You need one filter for the remote domain controllers and one for the desktops. (You could write a single filter that captured traffic from the desktops to the domain controllers and back, but two separate filters are generally more reusable.)</p><a id="I_programlisting8_d1e14172"/><pre class="programlisting">filter-definition desktops
    match src-ip-addr desktops
    or
    match dst-ip-addr desktops

filter-definition remoteDCs
    match src-ip-addr remoteDC
    or
    match dst-ip-addr remoteDC</pre><p>Now run the flows for the day you've chosen through these filters and through your interpolated octets <code class="literal">flow-report</code>. You're reporting on all the flows for January 14, 2011.</p><a id="I_programlisting8_d1e14179"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-01-14.* | flow-nfilter -F desktops | flow-nfilter -F</code></strong>
<strong class="userinput"><code>remoteDCs | flow-report -S octets &gt; desktop-DC-traffic.txt</code></strong></pre><p>The top of the file should look something like this:<a class="indexterm" id="IDX-CHP-8-0026"/><a class="indexterm" id="IDX-CHP-8-0027"/><a class="indexterm" id="IDX-CHP-8-0028"/><a class="indexterm" id="IDX-CHP-8-0029"/></p><a id="I_programlisting8_d1e14202"/><pre class="programlisting">#  ['/usr/local/bin/flow-rptfmt']
unix-secs  octets
1294981479 168.000000
1294981610 30.000000
...
1295066753 15.000000
1295066757 367.000000</pre><p>The numbers on the left side are Unix epochal seconds. To double-check the report times, convert the first and last ones one with the <code class="literal">date</code> program.<a class="indexterm" id="IDX-CHP-8-0030"/></p><a id="I_programlisting8_d1e14212"/><pre class="programlisting"># <strong class="userinput"><code>date -r 1294981479</code></strong>
Fri Jan 14 00:04:39 EST 2011
# <strong class="userinput"><code>date -r 1295066757</code></strong>
Fri Jan 14 23:45:57 EST 2011</pre><p>The first matching flow began at four minutes after midnight, and the last one ended at almost 11:46 <span class="keycap"><strong>pm</strong></span>, both on January 14. The report covers the time you're interested in.</p><p><code class="literal">gnuplot</code> will have problems with the column names of this file because <code class="literal">unix-secs</code> and <code class="literal">octets</code> are not graphable numbers. The simplest way to deal with this is to delete the first two lines either by hand or with <code class="literal">sed</code>. (Although editing the file by hand might be easier when creating graphs by hand, <code class="literal">sed</code> can be automated.)</p><a id="I_programlisting8_d1e14242"/><pre class="programlisting"># <strong class="userinput"><code>sed '1,2d' desktop-DC-traffic.txt &gt; octets.txt</code></strong></pre></div><div class="sect3" title="The Target Graph"><div class="titlepage"><div><div><h3 class="title"><a id="the_target_graph"/>The Target Graph</h3></div></div></div><p>What do you want a graph to look like? It should clearly show how much bandwidth is used. The axes should be labeled with times and the unit of bandwidth measurement, and the graph itself should have a label. If you want real human beings to care about your graphs, times should be local clock time, not in epochal seconds or Greenwich mean time (GMT). If the graph has different lines for different types of traffic, it should have an interpretation key. And this should all be automatically generated. Oh, and while you're at it, you'll make the data accurate and meaningful.</p></div><div class="sect3" title="The First Graph: Missing the Target"><div class="titlepage"><div><div><h3 class="title"><a id="the_first_graph_colon_missing_the_target"/>The First Graph: Missing the Target</h3></div></div></div><p>Begin by creating a default <code class="literal">gnuplot</code> graph of your data and comparing this to your desired result.</p><a id="I_programlisting8_d1e14259"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot "octets.txt"</code></strong></pre><p>The bandwidth at any given time is represented by a point, as shown in <a class="xref" href="ch08s02.html#raw_throughput_graph" title="Figure 8-2. Raw throughput graph">Figure 8-2</a>. Bandwidth utilization on a second-by-second basis is too irregular for nice curving lines, but you'll learn how to make graphs using markers other than points later.</p><div class="figure"><a id="raw_throughput_graph"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14270"/><img alt="Raw throughput graph" src="httpatomoreillycomsourcenostarchimages651606.png.jpg"/></div></div><p class="title">Figure 8-2. Raw throughput graph</p></div><p>Neither axis has a label; the default graph could represent apples vs. pomegranates for all you can tell. In addition, the times along the bottom appear as epochal seconds, such as 1.2319E+08, rather than useful times. Epochal seconds are accurate, strictly speaking, but not exactly what you want to hand to your co-workers. You'll iteratively improve the graph, first by setting labels on the two axes and then by telling <code class="literal">gnuplot</code> how to format the time.<a class="indexterm" id="IDX-CHP-8-0031"/><a class="indexterm" id="IDX-CHP-8-0032"/><a class="indexterm" id="IDX-CHP-8-0033"/><a class="indexterm" id="IDX-CHP-8-0034"/><a class="indexterm" id="IDX-CHP-8-0035"/><a class="indexterm" id="IDX-CHP-8-0036"/><a class="indexterm" id="IDX-CHP-8-0037"/><a class="indexterm" id="IDX-CHP-8-0038"/></p><a id="I_programlisting8_d1e14310"/><pre class="programlisting">❶ gnuplot&gt; <strong class="userinput"><code>set xdata time</code></strong>
❷ gnuplot&gt; <strong class="userinput"><code>set timefmt x "%s"</code></strong>
❸ gnuplot&gt; <strong class="userinput"><code>set format x "%H"</code></strong>
❹ gnuplot&gt; <strong class="userinput"><code>set xlabel "time"</code></strong>
❺ gnuplot&gt; <strong class="userinput"><code>set ylabel "bytes"</code></strong>
❻ gnuplot&gt; <strong class="userinput"><code>plot "octets.txt" using ($1):($2)</code></strong></pre><p>You first tell <code class="literal">gnuplot</code> at ❶ that the data along the x-axis represents time. Then at ❷ you tell <code class="literal">gnuplot</code> the format of the time data along the x-axis. The <code class="literal">%s</code> character is a <code class="literal">gnuplot</code> time format that represents epoch seconds, and it gives <code class="literal">gnuplot</code> the information it needs to convert epoch seconds to human-friendly times. <code class="literal">gnuplot</code> can print measures of time in the same <code class="literal">strftime</code> format used by <code class="literal">flow-rptfmt</code> (see <a class="xref" href="ch05.html" title="Chapter 5. REPORTING AND FOLLOW-UP ANALYSIS">Chapter 5</a>). For a graph that covers 24 hours, printing the hour is a sensible choice, and you set that format at ❸. You then label the x- and y-axes at ❹ and ❺.</p><p>Now that you've started getting fancy, you tell <code class="literal">gnuplot</code> at ❻ exactly how to plot the data in your file. The dollar sign followed by a number indicates a column of data. <code class="literal">($1)</code> means "column 1," and <code class="literal">($2)</code> means "column 2." The statement <code class="literal">plot "octets.txt" using ($1):($2)</code> tells <code class="literal">gnuplot</code> to read <code class="literal">octets.txt</code> and plot the first column against the second column. The result looks like <a class="xref" href="ch08s02.html#flow_diagram_with_basic_labels" title="Figure 8-3. Flow diagram with basic labels">Figure 8-3</a>.<a class="indexterm" id="IDX-CHP-8-0039"/></p><div class="figure"><a id="flow_diagram_with_basic_labels"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14388"/><img alt="Flow diagram with basic labels" src="httpatomoreillycomsourcenostarchimages651608.png.jpg"/></div></div><p class="title">Figure 8-3. Flow diagram with basic labels</p></div><p>This graph is closer to the target graph described earlier. The x-axis is labeled in bytes, and the y-axis is labeled in human-readable times. Notice that the times along the bottom don't match the data in the report, however. The flow data started just after midnight and ended just before midnight, but this graph starts at about 5 <span class="keycap"><strong>am</strong></span> and ends 24 hours later. This is a time zone problem. I'm in Eastern standard time (EST), and <code class="literal">gnuplot</code> produced a graph in Coordinated Universal Time (UTC). This graph needs to display the local time. Also, I buy bandwidth in kilobits rather than kilobytes. Although the kilobytes label is accurate, I want the graph to show kilobits.</p><p>To convert UTC to EST, you subtract five hours, shifting each value by (5 × 60 × 60 =) 18,000 seconds. You need to reduce all times listed in the data by 18,000 seconds to have the graph display an accurate clock time. To convert bytes to kilobits, you divide by 125. (One byte has 8 bits, and one kilobit has 1,000 bits: 1000 / 8 = 125.) You can set both of these conversions as constants in <code class="literal">gnuplot</code> in order to transform the data as you graph it. (Don't forget to change the label on the y-axis when you change the measurement.)</p><a id="I_programlisting8_d1e14407"/><pre class="programlisting">❶ gnuplot&gt; <strong class="userinput"><code>edt = −18000</code></strong>
❷ gnuplot&gt; <strong class="userinput"><code>kb = 125</code></strong>
❸ gnuplot&gt; <strong class="userinput"><code>set ylabel "kb"</code></strong>
  gnuplot&gt; <strong class="userinput"><code>plot "octets.txt" using ($1+edt)</code></strong> ❹ <strong class="userinput"><code>:($2/kb)</code></strong> ❺</pre><p>First, you define a constant for the number of seconds between EST and UTC (❶) and another for the number of octets per kilobit (❷).<a class="indexterm" id="IDX-CHP-8-0040"/><a class="indexterm" id="IDX-CHP-8-0041"/></p><p>Next, because you're changing the measurement on the y-axis from bytes to kilobits, you also change the y-axis label, as shown at ❸.</p><p>The tricky part is where you tell <code class="literal">gnuplot</code> to change the data as you're graphing it. Previously, you graphed the first column against the second. You're transforming the first column by adding the time zone offset to every value in that column (❹). You transform the second column by dividing every entry by the constant <code class="literal">kb</code> (❺). You don't change the numbers in the <span class="emphasis"><em>octets.txt</em></span> file; you transform them on their way to the graph.</p><p>While you're here, you can make some other changes, such as assigning a title and giving the graph a grid.</p><a id="I_programlisting8_d1e14449"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>set title "Traffic between desktops and remote DCs, 14 Jan"</code></strong>
gnuplot&gt; <strong class="userinput"><code>set grid</code></strong>
gnuplot&gt; <strong class="userinput"><code>replot</code></strong></pre><p>You'll get the graph shown in <a class="xref" href="ch08s02.html#network_utilization_with_better_times_co" title="Figure 8-4. Network utilization with better times, bandwidth units, grid, and title">Figure 8-4</a>, which at first glance is similar to the graph in <a class="xref" href="ch08s02.html#raw_throughput_graph" title="Figure 8-2. Raw throughput graph">Figure 8-2</a> but with more appropriate times and more useful bandwidth measurements, which make it more suitable for sharing with co-workers.</p><div class="figure"><a id="network_utilization_with_better_times_co"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14468"/><img alt="Network utilization with better times, bandwidth units, grid, and title" src="httpatomoreillycomsourcenostarchimages651610.png.jpg"/></div></div><p class="title">Figure 8-4. Network utilization with better times, bandwidth units, grid, and title</p></div></div><div class="sect3" title="Changing How the Graph Is Drawn"><div class="titlepage"><div><div><h3 class="title"><a id="changing_how_the_graph_is_drawn"/>Changing How the Graph Is Drawn</h3></div></div></div><p>Although I like graphs composed of individual points, many people prefer a different style of graph. <code class="literal">gnuplot</code> supports a nearly limitless number of graph styles. One popular style of bandwidth graph is one that uses a solid line, called an <span class="emphasis"><em>impulse</em></span>, to represent the bandwidth used at any given time. Here, I'm creating exactly the same graph as before but using impulses:<a class="indexterm" id="IDX-CHP-8-0042"/><a class="indexterm" id="IDX-CHP-8-0043"/><a class="indexterm" id="IDX-CHP-8-0044"/><a class="indexterm" id="IDX-CHP-8-0045"/></p><a id="I_programlisting8_d1e14500"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot "octets.txt" using ($1+edt):($2/kb) with impulses</code></strong></pre><p>Other than specifying impulses, this is exactly the same command.</p><p>You'll get a graph like <a class="xref" href="ch08s02.html#network_utilization_with_impulses" title="Figure 8-5. Network utilization with impulses">Figure 8-5</a>. Some people will find this style of graph easier to understand. Just use whatever format your brain is wired to accept.</p><div class="figure"><a id="network_utilization_with_impulses"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14513"/><img alt="Network utilization with impulses" src="httpatomoreillycomsourcenostarchimages651612.png.jpg"/></div></div><p class="title">Figure 8-5. Network utilization with impulses</p></div></div><div class="sect3" title="Clipping Levels"><div class="titlepage"><div><div><h3 class="title"><a id="clipping_levels-id1"/>Clipping Levels</h3></div></div></div><p>You've probably noticed in <a class="xref" href="ch08s02.html#network_utilization_with_impulses" title="Figure 8-5. Network utilization with impulses">Figure 8-5</a> that a few data points vary greatly from the averages. If you examine the original data, you'll find that several connections are only three or four packets. Passing four octets in one millisecond is not the same as passing 4,000 octets in 1,000 milliseconds (or one second), but that's what a simple "average octets per second" calculation produces on a mostly idle network.</p><p>To eliminate these outliers, you can establish a sensible clipping level to create a more realistic graph. To do this, you'll use <code class="literal">gnuplot</code>'s built-in logical operators, in the format shown here. (Perl and C aficionados should be familiar with this syntax.)<a class="indexterm" id="IDX-CHP-8-0046"/></p><a id="I_programlisting8_d1e14533"/><pre class="programlisting">(a ? b : c )</pre><p>This translates to "Is <code class="literal">a</code> true? If true, use <code class="literal">b</code>. If untrue, use <code class="literal">c</code>."</p><p>After assessing your first graph and the data underlying those peaks, you might decide that you want your graph to have a maximum value of, say, 300Kbps, and that if a value exceeds 300Kbps, it should be treated as 300. Translated into the previous syntax, you have the following:</p><a id="I_programlisting8_d1e14548"/><pre class="programlisting">( $2/kb&gt;300 ? 300 : $2/kb)</pre><p><code class="literal">$2/kb</code> is the bandwidth in kilobits. With <code class="literal">&gt;300 ?</code>, you check to see whether the bandwidth exceeds 300. If it does, you use the value <code class="literal">300</code>. If not, you use the actual value of <code class="literal">$2/kb</code>.</p><p>To have <code class="literal">gnuplot</code> perform this check for you, enter it in the <code class="literal">plot</code> statement.</p><a id="I_programlisting8_d1e14571"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot "octets.txt" using ($1+edt):($2/kb&gt;300 ? 300 : $2/kb ) with impulses</code></strong></pre><p>You'll get a result like the graph shown in <a class="xref" href="ch08s02.html#network_utilization_with_clipping_levels" title="Figure 8-6. Network utilization with clipping levels">Figure 8-6</a>.</p><div class="figure"><a id="network_utilization_with_clipping_levels"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14583"/><img alt="Network utilization with clipping levels" src="httpatomoreillycomsourcenostarchimages651614.png.jpg"/></div></div><p class="title">Figure 8-6. Network utilization with clipping levels</p></div><p>By setting a clipping level, you get a graph that offers a more realistic image of your actual bandwidth usage.</p><div class="sidebar"><a id="clipping_levels_and_multiple_graphs"/><p class="title">CLIPPING LEVELS AND MULTIPLE GRAPHS</p><p>When creating graphs for comparison, use the same clipping levels in all the graphs. Varying clipping levels will confuse the results.</p></div></div><div class="sect3" title="Printing Graphs to Files"><div class="titlepage"><div><div><h3 class="title"><a id="printing_graphs_to_files"/>Printing Graphs to Files</h3></div></div></div><p><code class="literal">gnuplot</code> supports a wide variety of graphics formats. To view the complete list your version supports, enter <strong class="userinput"><code>set terminal</code></strong> at the <code class="literal">gnuplot&gt;</code> prompt. The three most commonly used formats for websites are GIF, JPEG, and PNG.<a class="indexterm" id="IDX-CHP-8-0047"/><a class="indexterm" id="IDX-CHP-8-0048"/><a class="indexterm" id="IDX-CHP-8-0049"/><a class="indexterm" id="IDX-CHP-8-0050"/><a class="indexterm" id="IDX-CHP-8-0051"/><a class="indexterm" id="IDX-CHP-8-0052"/><a class="indexterm" id="IDX-CHP-8-0053"/><a class="indexterm" id="IDX-CHP-8-0054"/><a class="indexterm" id="IDX-CHP-8-0055"/><a class="indexterm" id="IDX-CHP-8-0056"/><a class="indexterm" id="IDX-CHP-8-0057"/><a class="indexterm" id="IDX-CHP-8-0058"/></p><p>To have <code class="literal">gnuplot</code> print graphs to a file instead of to your screen, tell <code class="literal">gnuplot</code> the file type and name. Here, you save the graph to a JPEG file:</p><a id="I_programlisting8_d1e14673"/><pre class="programlisting">❶ gnuplot&gt; <strong class="userinput"><code>set terminal jpeg</code></strong>
  Terminal type set to 'jpeg'
  Options are 'nocrop medium '
❷ gnuplot&gt; <strong class="userinput"><code>set output "bandwidth.jpeg"</code></strong>
❸ gnuplot&gt; <strong class="userinput"><code>replot</code></strong>
❹ gnuplot&gt; <strong class="userinput"><code>set terminal x11</code></strong></pre><p>The <code class="literal">set output</code> statement at ❶ tells <code class="literal">gnuplot</code> the type of output to produce, and the one at ❷ says where to put any output. To actually create the file, you have <code class="literal">gnuplot</code> redraw the graph at ❸. Finally, at ❹ you set the terminal to display its output to the screen again.</p></div><div class="sect3" title="Save Your Work!"><div class="titlepage"><div><div><h3 class="title"><a id="save_your_work_exclamation"/>Save Your Work!</h3></div></div></div><p>You can use this configuration to easily generate very similar graphs. Save it as a basis for future reports.</p><a id="I_programlisting8_d1e14702"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>save "totalBW.plt"</code></strong></pre></div></div><div class="sect2" title="Unidirectional Bandwidth Reports"><div class="titlepage"><div><div><h2 class="title"><a id="unidirectional_bandwidth_reports"/>Unidirectional Bandwidth Reports</h2></div></div></div><p>The graph in <a class="xref" href="ch08s02.html#network_utilization_with_clipping_levels" title="Figure 8-6. Network utilization with clipping levels">Figure 8-6</a> showed the total amount of bandwidth used for communication between the desktops and the domain controllers at remote sites. What if you want a report on the bandwidth used in one direction only, such as from servers to desktops or from desktops to servers?</p><p>The report you'd generate isn't very different from the total bandwidth report you generated in the previous section. To create the report, you'd use the <code class="literal">flow-nfilter</code> configuration to extract the data of interest, feed that to your octet's <code class="literal">flow-report</code>, and then feed that to a very similar <code class="literal">gnuplot</code> configuration.</p><div class="sect3" title="Filtering Flows for Unidirectional Traffic"><div class="titlepage"><div><div><h3 class="title"><a id="filtering_flows_for_unidirectional_traff"/>Filtering Flows for Unidirectional Traffic</h3></div></div></div><p>The filter configuration uses the same <code class="literal">desktops</code> and <code class="literal">remoteDCs</code> primitives you used for the total bandwidth report. As shown here, you create two new filters, one for each direction:</p><a id="I_programlisting8_d1e14735"/><pre class="programlisting">filter-definition DCtoDesktops
    match src-ip-addr remoteDC
    match dst-ip-addr desktops

filter-definition DesktopsToDC
    match src-ip-addr desktops
    match dst-ip-addr remoteDC</pre><p>The first filter shows only the traffic the domain controllers send to the desktops; the second filter shows the traffic desktops send to the domain controllers. Now you run one of these new filters against the same flow files, beginning with the traffic from the domain controllers to the desktops.</p><a id="I_programlisting8_d1e14739"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-01-14.* | flow-nfilter</code></strong>
 <strong class="userinput"><code>-F DCtoDesktops | flow-report -S octets &gt; DCtoDesktop.txt</code></strong>
# <strong class="userinput"><code>sed '1,2d' DCtoDesktop.txt &gt; octets.txt</code></strong></pre><p>You use the same <code class="literal">sed</code> command to remove the two extra lines at the top of the file. Finally, verify that the contents of the data file resembles that of your previous report: two columns containing epoch dates and bandwidth amounts.</p></div><div class="sect3" title="Creating a Unidirectional Graph"><div class="titlepage"><div><div><h3 class="title"><a id="creating_a_unidirectional_graph"/>Creating a Unidirectional Graph</h3></div></div></div><p>The unidirectional traffic graph should look a lot like the total bandwidth graph. In fact, to produce the final graph, you can simply modify the existing <code class="literal">gnuplot</code> configuration and change the title.</p><a id="I_programlisting8_d1e14762"/><pre class="programlisting">❶ gnuplot&gt; <strong class="userinput"><code>load "totalBW.plt"</code></strong>
❷ gnuplot&gt; <strong class="userinput"><code>set title "DC to Desktop Traffic, 14 Jan 11"</code></strong>
❸ gnuplot&gt; <strong class="userinput"><code>replot</code></strong></pre><p>You begin by loading at ❶ the configuration you used for the total bandwidth graph. This configuration gives you correct times, bits instead of octets, and so on. Next, at ❷ you change the title, and at ❸ you create a new plot with your new data. The result would look like <a class="xref" href="ch08s02.html#unidirectional_bandwidth_usage" title="Figure 8-7. Unidirectional bandwidth usage">Figure 8-7</a>.</p><div class="figure"><a id="unidirectional_bandwidth_usage"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14779"/><img alt="Unidirectional bandwidth usage" src="httpatomoreillycomsourcenostarchimages651616.png.jpg"/></div></div><p class="title">Figure 8-7. Unidirectional bandwidth usage</p></div><p>As you can see, reusing <code class="literal">gnuplot</code> configurations with different data is a very quick way to produce graphs with a consistent appearance but different data.<a class="indexterm" id="IDX-CHP-8-0059"/><a class="indexterm" id="IDX-CHP-8-0060"/><a class="indexterm" id="IDX-CHP-8-0061"/><a class="indexterm" id="IDX-CHP-8-0062"/><a class="indexterm" id="IDX-CHP-8-0063"/><a class="indexterm" id="IDX-CHP-8-0064"/></p><p>To create a graph for traffic going in the opposite direction, you would do almost the same thing; simply change the graph title and the flow filter.</p></div></div><div class="sect2" title="Combined Inbound/Outbound Traffic"><div class="titlepage"><div><div><h2 class="title"><a id="combined_inbound_solidus_outbound_traffi"/>Combined Inbound/Outbound Traffic</h2></div></div></div><p>A graph showing both inbound and outbound traffic simultaneously is likely to be more useful than a graph showing traffic in one direction only. You already have the data; to produce a graph showing traffic in both directions, you just need a slightly different <code class="literal">gnuplot</code> configuration.</p><div class="sect3" title="Preparing the Data Files"><div class="titlepage"><div><div><h3 class="title"><a id="preparing_the_data_files"/>Preparing the Data Files</h3></div></div></div><p>If you were to create two unidirectional graphs, you would already have the data files you need, and that's essentially what you'll do. You can't call both data files <span class="emphasis"><em>octets.txt</em></span>; however, you need to give each a distinct name. Since you're measuring traffic between local and remote hosts, let's call one of them <span class="emphasis"><em>inbound.txt</em></span> and the other <span class="emphasis"><em>outbound.txt</em></span>. Trim the headers off the raw data files with <code class="literal">sed</code>, but otherwise leave the data unchanged.</p><a id="I_programlisting8_d1e14844"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-01-14.* | flow-nfilter</code></strong>
 <strong class="userinput"><code>-F DCtoDesktops | flow-report -S octets &gt; DCtoDesktop.txt</code></strong>
# <strong class="userinput"><code>flow-cat ft-v05.2011-01-14.* | flow-nfilter -F DesktopsToDC</code></strong>
 <strong class="userinput"><code>| flow-report -S octets &gt; DesktopToDC.txt</code></strong>
# <strong class="userinput"><code>sed '1,2d' DCtoDesktop.txt &gt; inbound.txt</code></strong>
# <strong class="userinput"><code>sed '1,2d' DesktopToDC.txt &gt; outbound.txt</code></strong></pre></div><div class="sect3" title="Displaying Two Graphs Simultaneously"><div class="titlepage"><div><div><h3 class="title"><a id="displaying_two_graphs_simultaneously"/>Displaying Two Graphs Simultaneously</h3></div></div></div><p>To display two graphs simultaneously, begin with your unidirectional graph configuration. You'll change the name of the files being plotted, but all the other configuration information such as time zone, kilobits instead of bytes, and so on, will work just as well for this new graph.</p><p>To plot two different data sets drawn from two different files on one graph, separate each with a comma in a single <code class="literal">plot</code> statement, as shown here:</p><a id="I_programlisting8_d1e14874"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot "inbound.txt" using ($1+edt):($2/kb&gt;300 ? 300 : $2/kb)</code></strong> ❶ <strong class="userinput"><code>\</code></strong>
       &gt; ❷ <strong class="userinput"><code>title "inbound"</code></strong> ❸<strong class="userinput"><code>, \</code></strong>
       &gt; <strong class="userinput"><code>"outbound.txt" using ($1+edt):($2/kb&gt;300 ? 300 : $2/kb) title "outbound"</code></strong></pre><p>This listing displays several new features here. The backslash (<code class="literal">\</code>) at ❶ tells <code class="literal">gnuplot</code> that a command continues on the next line. If you need to use a backslash to show a continued line, enter the backslash, and then just press <span class="keycap"><strong>enter</strong></span>. You'll be taken to the next line.</p><p>The <code class="literal">title</code> at ❷ within the <code class="literal">plot</code> statement labels the data. In this case, you have two types of data, labeled <code class="literal">inbound</code> and <code class="literal">outbound</code>. The comma (,) at ❸ separates the two data sources. The resulting graph looks something like <a class="xref" href="ch08s02.html#graph_of_inbound_and_outbound_traffic" title="Figure 8-8. Graph of inbound and outbound traffic">Figure 8-8</a>.</p><div class="figure"><a id="graph_of_inbound_and_outbound_traffic"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14920"/><img alt="Graph of inbound and outbound traffic" src="httpatomoreillycomsourcenostarchimages651618.png.jpg"/></div></div><p class="title">Figure 8-8. Graph of inbound and outbound traffic</p></div><p>According to the key, the data points of the inbound traffic are plus signs (<code class="literal">+</code>). The outbound traffic data points appear as <code class="literal">x</code> characters. <code class="literal">gnuplot</code> will also use different colors for the data points. (<a class="xref" href="ch08s02.html#graph_of_inbound_and_outbound_traffic" title="Figure 8-8. Graph of inbound and outbound traffic">Figure 8-8</a> is a bit easier to understand in color, but this book is in black and white because I want it to be affordable.) Having two different data point characters helps, but not much. It's better to show both types of traffic simultaneously, but not intermingled.</p><p>To make this graph easier to understand at a glance, graph outbound traffic as negative numbers, like so:</p><a id="I_programlisting8_d1e14940"/><pre class="programlisting">gnuplot &gt; <strong class="userinput"><code>plot "inbound.txt" using ($1+edt):($2/kb&gt;300 ? 300 : $2/kb) \</code></strong>
        &gt; <strong class="userinput"><code>title "inbound", \</code></strong>
        &gt; <strong class="userinput"><code>"outbound.txt" using ($1+edt):($2/kb&gt;300 ?</code></strong> ❶ <strong class="userinput"><code>−300 :</code></strong> ❷
 <strong class="userinput"><code>-$2/kb) title "outbound"</code></strong></pre><p>You've made only two minor changes here, placing minus signs in your outbound graph's plot statement at ❶ and ❷. <a class="xref" href="ch08s02.html#utilization_diagram_with_outbound_traffi" title="Figure 8-9. Utilization diagram with outbound traffic as negative numbers">Figure 8-9</a> shows the resulting graph.</p><div class="figure"><a id="utilization_diagram_with_outbound_traffi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e14964"/><img alt="Utilization diagram with outbound traffic as negative numbers" src="httpatomoreillycomsourcenostarchimages651620.png.jpg"/></div></div><p class="title">Figure 8-9. Utilization diagram with outbound traffic as negative numbers</p></div><p>As you can see in this graph, it's clear that you're receiving much more traffic than you send, and you receive it much more frequently. The inbound and outbound clipping levels are unchanged, but the outbound traffic never approaches the clipping level. You can also see that you have a big utilization spike just after 9 <span class="keycap"><strong>am</strong></span> EST.</p><p>To get another look at this data, you could graph it with impulses like so:</p><a id="I_programlisting8_d1e14976"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot "inbound.txt" using ($1+edt):($2/kb&gt;300 ? 300 : $2/kb) \</code></strong>
       &gt; <strong class="userinput"><code>title "inbound" with impulses, \</code></strong>
       &gt; <strong class="userinput"><code>"outbound.txt" using ($1+edt):($2/kb&gt;300 ? −300 : -$2/kb) \</code></strong>
       &gt; <strong class="userinput"><code>title "outbound" with impulses</code></strong></pre><p>The result resembles <a class="xref" href="ch08s02.html#impulse_utilization_diagram_with_outboun" title="Figure 8-10. Impulse utilization diagram with outbound traffic as negative numbers">Figure 8-10</a>.</p><p>With proper graphs, anyone—even your manager—can understand network utilization. <a class="xref" href="ch08s02.html#impulse_utilization_diagram_with_outboun" title="Figure 8-10. Impulse utilization diagram with outbound traffic as negative numbers">Figure 8-10</a> makes it clear that desktops are exchanging traffic with remote domain controllers, even though Microsoft insisted that clients should contact their local domain controller only. You can now resolve the problem with documented facts rather than guesses and intermittent packet sniffer snapshots.</p><div class="figure"><a id="impulse_utilization_diagram_with_outboun"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e15000"/><img alt="Impulse utilization diagram with outbound traffic as negative numbers" src="httpatomoreillycomsourcenostarchimages651622.png.jpg"/></div></div><p class="title">Figure 8-10. Impulse utilization diagram with outbound traffic as negative numbers</p></div></div></div></div>
<div class="sect1" title="Automating Graph Production"><div class="titlepage"><div><div><h1 class="title"><a id="automating_graph_production"/>Automating Graph Production</h1></div></div></div><p>Although you'll always need to have some ad hoc reporting ability, you'll find that you need certain graphs over and over again. You should make producing these graphs so easy that one of your flunkies can do it, or you can even schedule graph production with <code class="literal">cron</code>. The best way to manage this is through scripting and automation. <code class="literal">gnuplot</code> is very scripting-friendly, and the following script processes yesterday's flow files to generate a bidirectional traffic graph.<a class="indexterm" id="IDX-CHP-8-0065"/><a class="indexterm" id="IDX-CHP-8-0066"/><a class="indexterm" id="IDX-CHP-8-0067"/><a class="indexterm" id="IDX-CHP-8-0068"/><a class="indexterm" id="IDX-CHP-8-0069"/><a class="indexterm" id="IDX-CHP-8-0070"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>This script is not optimized. In a real environment, you'd send email via Perl, but I don't want to waste a page on that example when you probably already have a standard way to send mail on your systems. Too, this script uses insecure temp files, and you shouldn't use such files on a shared system. In short, do not use this script as is; rather, use it as a guide for writing a script that fits your own needs in the best Perl you can maintain. Who told you to listen to me, anyway?</p></div><a id="I_programlisting8_d1e15043"/><pre class="programlisting">#!/usr/bin/perl

#where are our flow files?
$logdir="/var/log/flows/";
#flow file version
$version=5;

#get yesterday's date
@T=localtime(time-86400);
$year=$T[5]+1900;
$month=$T[4]+1;
unless ($month&gt;9) {
    $month = '0'.$month;
}
$day=$T[3];

$filePrefix="ft-v0$version.$year-$month-$day";

#generate the reports and prepare them for graphing

system ("flow-cat $logdir$filePrefix* | flow-nfilter -F DCtoDesktops
 | flow-report -S octets &gt; /tmp/DCtoDesktop.txt");

system ("flow-cat $logdir$filePrefix* | flow-nfilter -F DesktopsToDC
 | flow-report -S octets &gt; /tmp/DesktopToDC.txt");

system ("sed '1,2d' /tmp/DesktopToDC.txt &gt; /tmp/outbound.txt");
system ("sed '1,2d' /tmp/DCtoDesktop.txt &gt; /tmp/inbound.txt");

#<strong class="userinput"><code>run gnuplot</code></strong>
open GNUPLOT, "| gnuplot";
print GNUPLOT &lt;&lt;gnuplot_settings;
set terminal jpeg
set output "/tmp/desktop-DC.jpeg"
set xdata time
set timefmt x "%s"
set format x "%H"
set xlabel "time"
set ylabel "kb"
set title "Desktop/DC Traffic, $day $month $year"
edt = −18000
kb=125
set grid
plot "/tmp/inbound.txt" using (\$1+edt):(\$2/kb&gt;300 ? 300 : \$2/kb) \\
    title "inbound" with impulses, \\
    "/tmp/outbound.txt" using (\$1+edt):(\$2/kb&gt;300 ? −300 : -\$2/kb) \\
    title "outbound" with impulses
gnuplot_settings
close GNUPLOT;

#<strong class="userinput"><code>send mail</code></strong>
system ("mutt -s \"Traffic for $day $month $year\" -a /tmp/desktop
-DC.jpeg mwlucas@localhost &lt; /dev/null");</pre><p>Admittedly, some of the commands here are a little long, but there's no interface to run flow reports directly from within Perl. You replace <code class="literal">sed</code> with textbook Perl routines, but you're already using <code class="literal">system()</code> calls all over the place.</p><p>Beginning with <code class="literal">run gnuplot</code>, you configure <code class="literal">gnuplot</code> entirely within this script. You could also load most of your <code class="literal">gnuplot</code> configuration from a file.</p><p>And as for sending mail (at the end of the script), you probably already have a preferred way to send mail from your servers. If you don't, I recommend Perl's MIME::Lite module. Otherwise, look at programs such as <code class="literal">mutt</code> or <code class="literal">metamail</code>.</p></div>
<div class="sect1" title="Comparison Graphs"><div class="titlepage"><div><div><h1 class="title"><a id="comparison_graphs"/>Comparison Graphs</h1></div></div></div><p>The easiest way to compare traffic from multiple time periods is to overlay one graph atop another; doing so helps you evaluate the impact of system changes on the network. You can use the same type of linear interpolation for this as well, with some needed changes to the graph techniques and the time values.<a class="indexterm" id="IDX-CHP-8-0071"/><a class="indexterm" id="IDX-CHP-8-0072"/><a class="indexterm" id="IDX-CHP-8-0073"/><a class="indexterm" id="IDX-CHP-8-0074"/><a class="indexterm" id="IDX-CHP-8-0075"/><a class="indexterm" id="IDX-CHP-8-0076"/></p><p>In the following report, you'll compare inbound and outbound Internet traffic from two different 24-hour periods, A and B. The data is in two files: <span class="emphasis"><em>inboundA.txt</em></span> and <span class="emphasis"><em>inboundB.txt</em></span>. I've already removed the column names from the top of these files.</p><div class="sect2" title="Data Normalizing"><div class="titlepage"><div><div><h2 class="title"><a id="data_normalizing"/>Data Normalizing</h2></div></div></div><p>To make the graphs overlay each other, you need to adjust the data times. Bandwidth values are largely unchanged, but the time values are problematic. The simplest way to do this is to subtract a value from each set of data so that each graph starts at time zero.</p><p>When you use <code class="literal">sort -key</code> in the output section of your linear-interpolated report, the earliest time in your file appears at the top. For example, look at the top of <span class="emphasis"><em>inboundA.txt</em></span>.</p><a id="I_programlisting8_d1e15126"/><pre class="programlisting">#  ['/usr/local/bin/flow-rptfmt']
  unix-secs  octets
❶ 1229488610 1033.430171
  1229488611 1033.430171
  1229488612 1033.430171
  ...</pre><p><span class="emphasis"><em>InboundA.txt</em></span> begins in epochal second 1229488610 (❶). You subtract 1,229,488,610 from every time value to turn it into an offset from zero. Similarly, <span class="emphasis"><em>inboundB.txt</em></span> begins in epochal second 1230179749. You store these values in <code class="literal">gnuplot</code>, and while you're defining constants, you'll also define the number of octets in a kilobyte.</p><a id="I_programlisting8_d1e15138"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>inboundA=1229488610</code></strong>
gnuplot&gt; <strong class="userinput"><code>inboundB=1230179749</code></strong>
gnuplot&gt; <strong class="userinput"><code>kb=125</code></strong></pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Those of you who check these dates will notice that they start about a minute apart. A difference of one minute in a small graph of a day's traffic is negligible. If you were graphing traffic within a single minute or creating a wide graph for a single hour you'd have to correct for this difference, but at this scale we don't care.</p></div></div><div class="sect2" title="Time Scale"><div class="titlepage"><div><div><h2 class="title"><a id="time_scale"/>Time Scale</h2></div></div></div><p>You want to label the x-axis by time using "hours into the samples," but as things stand, the x-axis will be numbered in seconds. You can convert seconds into hours by configuring <code class="literal">gnuplot</code>'s <span class="emphasis"><em>tics</em></span>. A tic is a divider along an axis; major tics are labeled, and minor tics are not. The previous graphs had a labeled tic every two hours and one minor tic halfway between each hour. Let's keep that value: Two hours is 7,200 seconds.</p><a id="I_programlisting8_d1e15162"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>set xtics 7200</code></strong>
gnuplot&gt; <strong class="userinput"><code>set mxtics 2</code></strong></pre><p>With these basic labels, you can now plot your data.</p><a id="I_programlisting8_d1e15171"/><pre class="programlisting">gnuplot&gt; <strong class="userinput"><code>plot "inboundA.txt" using ($1-inboundA)</code></strong>
<strong class="userinput"><code>:($2/kb) with lines title "day 1 traffic", "inboundB.txt"</code></strong>
 <strong class="userinput"><code>using ($1-inboundB):($2/kb) with lines title "day 2 traffic"</code></strong></pre><p>The result should look something like <a class="xref" href="ch08s04.html#comparisons_of_traffic_on_two_different" title="Figure 8-11. Comparisons of traffic on two different days">Figure 8-11</a>, except in color.</p><div class="figure"><a id="comparisons_of_traffic_on_two_different"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e15188"/><img alt="Comparisons of traffic on two different days" src="httpatomoreillycomsourcenostarchimages651624.png.jpg"/></div></div><p class="title">Figure 8-11. Comparisons of traffic on two different days</p></div><p>You can combine this sort of comparison graph with the graph that shows inbound and outbound traffic simultaneously and get an easy-to-understand comparison of traffic from two different time windows. Or you can make one day's traffic negative to make it easier to see. You can build graphs that show how much of your Internet traffic is web browsing from Monday through Friday, 9 <span class="keycap"><strong>am</strong></span> to 5 <span class="keycap"><strong>pm</strong></span>, to show the impact of users on the network. Or you can compare your current network usage to the usage when your new Internet circuit was installed last year. <code class="literal">gnuplot</code> lets you visualize any data you have. If you want more sophisticated examples of using <code class="literal">gnuplot</code> with flow data, look for the CAIDA tools or the FloCon (<a class="ulink" href="http://www.cert.org/flocon/">http://www.cert.org/flocon/</a>) proceedings.</p></div></div></body></html>