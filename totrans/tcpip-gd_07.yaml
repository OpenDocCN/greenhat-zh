- en: Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 24](ch24.html "Chapter 24. IPV6 OVERVIEW, CHANGES, AND TRANSITION")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 26](ch26.html "Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY,
    AND ROUTING")'
  prefs: []
  type: TYPE_NORMAL
- en: Since 1981, TCP/IP has been built on version 4 of the Internet Protocol (IPv4),
    discussed at length in the preceding part. IPv4 was created when the giant, worldwide
    Internet we take for granted today was just a small, experimental network. Considering
    how much the Internet has grown and changed over the course of two decades, IPv4
    has done its job admirably. At the same time, it has been apparent for many years
    that certain limitations in this venerable protocol would hold back the future
    growth of the Internet if they were not addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the key role that IP plays, changing it is no simple feat. It means a
    substantial modification to the way that nearly everything in TCP/IP operates.
    However, even though we find change difficult, most of us know that it is necessary.
    For the past several years, development of a new version of IP has been under
    way, officially called *Internet Protocol version 6 (IPv6)* and also sometimes
    referred to as *IP Next Generation* or *IPng*. IPv6 is poised to take over for
    IPv4, and it will be the basis for the Internet of the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, I provide a detailed description of IPv6\. Since IPv6 is still
    IP, just like IPv4, it performs the same functions: addressing, encapsulation,
    fragmentation and reassembly, and datagram delivery and routing. For this reason,
    this discussion of IPv6 is patterned after the discussion of IPv4\. There are
    four chapters: The first covers IPv6 concepts and issues; the second discusses
    IPv6 addressing; the third discusses IPv6 encapsulation and formatting; and the
    fourth discusses IPv6 datagram fragmentation, reassembly, and routing.'
  prefs: []
  type: TYPE_NORMAL
- en: Since IPv6 represents the evolution of IP, many of its concepts of operation
    are built on those introduced in IPv4\. To avoid unnecessary duplication in this
    part, I've assumed you are familiar with the operation of IPv4, especially addressing
    and how datagrams are packaged and delivered. If you have not read [Part II-3](pt06.html
    "Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)"), reviewing it first would
    be wise, because the description of IPv6 focuses on how it differs from the current
    IP version.
  prefs: []
  type: TYPE_NORMAL
- en: You may also wish to refer to the [Part II-6](pt09.html "Part II-6. IP SUPPORT
    PROTOCOLS"), which covers the Internet Control Message Protocol (ICMP), part of
    which is ICMP version 6—ICMP for IPv6, and the IPv6 Neighbor Discovery (ND) protocol,
    since these are companions to IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 24. IPV6 OVERVIEW, CHANGES, AND TRANSITION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Internet Protocol version 6 (IPv6) is destined to be the future of IP, and due
    to IP's critical importance, it will form the basis for the future of TCP/IP and
    the Internet as well. In fact, it's been under development since the middle of
    the last decade, and a real IPv6 internetwork has been used for testing for a
    number of years as well. Despite this, many people don't know much about IPv6,
    other than the fact that it's a newer version of IP. Some have never even heard
    of it at all! I'm going to rectify that, of course—but before I delve into the
    important changes made in IPv6 addressing, packaging, fragmentation, and other
    functions, let's start with a bird's-eye view of IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide a brief higher-level overview of IPv6, including
    a look at how it differs from IP version 4 (IPv4) in general terms. I begin with
    a brief overview of IPv6 and why it was created. I list the major changes made
    in IPv6 and the new additions to the protocol. I also explain some of the difficulties
    associated with transitioning the enormous global Internet from IPv4 to IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Motivation and Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"If it ain''t broke, don''t fix it." This is one of my favorite pieces of folk
    wisdom. I generally like to stick with what works, as do most people. And IPv4
    works pretty darned well. It''s been around for decades now and has survived the
    growth of the Internet from a small research network into a globe-spanning powerhouse.
    So, like a trusty older car that you''ve operated successfully for years, why
    should you replace it if it still gets the job done?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like that older car, you could continue to use IPv4 for the foreseeable future.
    The question is: at what cost? An older car can be kept in good working order
    if you are willing to devote the time and money it takes to maintain and service
    it. However, it will still be limited in some of its capabilities. Its reliability
    may be suspect. It won''t have the latest features. With the exception of those
    who like to work on cars as a hobby, it eventually stops making sense to keep
    fixing up an older vehicle.'
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, this isn't that great of an analogy. Our highways aren't all that
    much different than they were in the 1970s, and most other issues related to driving
    a car haven't changed all that much in the past 25 years either. The choice of
    updating a vehicle or not is based on practical considerations more than necessity.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, look at what has happened to the computer and networking worlds
    in the last 25 years! Today's handheld PCs can do more than the most powerful
    servers could back then. Networking technologies are 100 or even 1,000 times as
    fast. The number of people connecting to the global Internet has increased by
    an even larger factor. And the ways that computers communicate have, in many cases,
    changed dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 could be considered in some ways like an older car that has been meticulously
    maintained and repaired over time. It gets the job done, but its age is starting
    to show. The main problem with IPv4 is its relatively small address space, a legacy
    of the decision to use only 32 bits for the IP address. Under the original classful
    addressing allocation scheme, we would have probably already run out of IPv4 addresses
    by now. Moving to classless addressing has helped postpone this, as have technologies
    like IP Network Address Translation (NAT), which allows privately addressed hosts
    to access the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, however, these represent patch jobs and imperfect repairs applied
    to keep the aging IPv4 automobile on the road. The core problem, the 32-bit address
    space that is too small for the current and future size of the Internet, can be
    solved only by moving to a larger address space. This was the primary motivating
    factor in creating the next version of IP, *IPv6*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The reason why the successor to IPv4 is version 6 and not version 5 is because
    version number 5 was used to refer to an experimental protocol called the Internet
    Stream Protocol, which was never widely deployed. See [Chapter 15](ch15.html "Chapter 15. INTERNET
    PROTOCOL VERSIONS, CONCEPTS, AND OVERVIEW") for a full discussion of IP history
    and versions*.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IPv6 represents the first major change to IP since IPv4 was formalized in 1981\.
    For many years, its core operation was defined in a series of RFCs published in
    1998: RFCs 2460 through 2467\. The most notable of these are the main IPv6 standard,
    RFC 2460, "Internet Protocol, Version 6 (IPv6) Specification," and documents describing
    the two helper protocols for IPv6: RFC 2461, which describes the IPv6 Neighbor
    Discovery Protocol (ND), and RFC 2463, which describes Internet Control Message
    Protocol version 6 (ICMPv6) for IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these, two documents were also written in 1998\. They discuss
    more about IP addressing: RFC 2373, "IP Version 6 Addressing Architecture," and
    RFC 2374, "An IPv6 Aggregatable Global Unicast Address Format." Due to changes
    in how IPv6 addressing was to be implemented, these were updated in 2003 by RFC
    3513, "Internet Protocol Version 6 (IPv6) Addressing Architecture," and RFC 3587,
    "IPv6 Global Unicast Address Format."'
  prefs: []
  type: TYPE_NORMAL
- en: Many other RFCs define more specifics of how IPv6 works, and many also describe
    IPv6-compatible versions of other TCP/IP protocols like the Domain Name System
    (DNS; see [Chapter 52](ch52.html "Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW,
    FUNCTIONS, AND CHARACTERISTICS")) and Dynamic Host Control Protocol (DHCP; see
    [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS")).
    IPv6 is still very much a work in progress, with new standards being proposed
    and adopted on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because IPv6 is the version of IP that''s designed for the next generation
    of the Internet, it is also sometimes called *IP Next Generation* or *IPng*. Personally,
    I don''t care for this name; it reminds me too much of *Star Trek: The Next Generation*.
    Regardless of its name, IPv6 or IPng was designed to take TCP/IP and the Internet
    "where none have gone before." (Sorry, I *had* to!)'
  prefs: []
  type: TYPE_NORMAL
- en: Design Goals of IPv6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem of addressing was the main motivation for creating IPv6\. Unfortunately,
    this has caused many people to think that the address space expansion is the *only*
    change made in IP, which is definitely not the case. Since making a change to
    IP is such a big deal, it's something done rarely. It made sense to correct not
    just the addressing issue, but also to update the protocol in a number of other
    respects in order to ensure its viability. In fact, even the addressing changes
    in IPv6 go far beyond just adding more bits to IP address fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most important goals in designing IPv6 include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Larger Address Space** IPv6 needed to provide more addresses for the growing
    Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better Management of Address Space** Developers wanted IPv6 to include not
    only more addresses, but also a more capable way of dividing the address space
    and using the bits in each address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elimination of Addressing Kludges** Technologies like NAT are effectively
    kludges that make up for the lack of address space in IPv4\. IPv6 eliminates the
    need for NAT and similar work-arounds, allowing every TCP/IP device to have a
    public address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier TCP/IP Administration** The designers of IPv6 hoped to resolve some
    of the current labor-intensive requirements of IPv4, such as the need to configure
    IP addresses. Even though tools like DHCP eliminate the need to manually configure
    many hosts, it only partially solves the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modern Design for Routing** In contrast to IPv4, which was designed before
    anyone had an idea what the modern Internet would be like, IPv6 was created specifically
    for efficient routing in the current Internet, and with the flexibility for the
    future.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better Support for Multicasting** Multicasting was an option in IPv4 from
    the start, but support for it has been slow in coming.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better Support for Security** IPv4 was designed at a time when security wasn''t
    much of an issue because there were a relatively small number of networks on the
    Internet, and those networks'' administrators often knew each other. Today, security
    on the public Internet is a big issue, and the future success of the Internet
    requires that security concerns be resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better Support for Mobility** When IPv4 was created, there really was no
    concept of mobile IP devices. The problems associated with computers that move
    between networks led to the need for Mobile IP. IPv6 builds on Mobile IP and provides
    mobility support within IP itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The new version of the IP is *Internet Protocol version 6 (IPv6)*.
    It was created to correct some of the significant problems of IPv4, especially
    the looming deficiency of the IPv4 address space, to improve the operation of
    the protocol as a whole, and to take TCP/IP into the future.'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time that IPv6 was intended to address these and many other issues
    with traditional IP, its changes are nevertheless *evolutionary*, not *revolutionary*.
    During the many discussions in the Internet Engineering Task Force (IETF) in the
    1990s, there were some who said that while we were updating IP, perhaps we should
    make a complete, radical change to a new type of internetworking protocol completely.
    The end decision was not to do this, but to define a more capable version of the
    IP that we've been using all along.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is simple: IP, like our trusted older car, *works*. IPv6
    represents an update that strives to add to the best characteristics of IPv4,
    rather than making everyone start over from scratch with something new and unproven.
    This design ensures that whatever pain may result from the change from IPv4 to
    IPv6 can be managed, and hopefully, minimized.'
  prefs: []
  type: TYPE_NORMAL
- en: Major Changes and Additions in IPv6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding overview, I explained that the primary motivation for creating
    a new version of IP was to fix the problems with addressing under IPv4\. But as
    you also saw, numerous other design goals existed for the new protocol as well.
    Once the decision was made to take the significant step of creating a new version
    of a protocol as important as IP, it made sense to use the opportunity to make
    as many improvements as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there is still the problem of the pain of change to worry about,
    so each potential change or addition in IPv6 needed to have benefits that would
    outweigh its costs. The resulting design does a good job of providing useful advantages
    while maintaining most of the core of the original IP. The following are some
    of the most important changes between IPv4 and IPv6, and they demonstrate some
    of the ways that the IPv6 team met the design goals for the new protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Larger Address Space** IPv6 addresses are 128 bits long instead of 32 bits.
    This expands the address space from around 4 billion addresses to, well, an astronomical
    number (over 300 trillion trillion trillion addresses).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical Address Space** One reason why the IPv6 address size was expanded
    so much was to allow it to be hierarchically divided to provide a large number
    of many classes of addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical Assignment of Unicast Addresses** A special global unicast address
    format was created to allow addresses to be easily allocated across the entire
    Internet. It allows for multiple levels of network and subnetwork hierarchies
    at both the Internet service provider (ISP) and the organizational level. It also
    permits the generation of IP addresses based on underlying hardware interface
    device IDs such as Ethernet MAC addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better Support for Nonunicast Addressing** Support for multicasting is improved,
    and support for a new type of addressing, *anycast* addressing, has been added.
    This new kind of addressing basically says, "Deliver this message to the easiest-to-reach
    member of this group," and potentially enables new types of messaging functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autoconfiguration and Renumbering** A provision is included to allow easier
    autoconfiguration of hosts and renumbering of the IP addresses in networks and
    subnetworks as needed. A technique also exists for renumbering router addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Datagram Format** The IP datagram format has been redefined and given
    new capabilities. The main header of each IP datagram has been streamlined, and
    support has been added for the ability to easily extend the header for datagrams
    that require more control information.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Support for Quality of Service (QoS)** IPv6 datagrams include QoS features
    that allow for better support for multimedia and other applications that require
    QoS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Support** Security support is designed into IPv6 using the authentication
    and encryption extension headers and other features.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updated Fragmentation and Reassembly Procedures** The way that the fragmentation
    and reassembly of datagrams works has been changed in IPv6\. The improved routing
    efficiency better reflects the realities of today''s networks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modernized Routing Support** IPv6 is designed to support modern routing systems
    and allow for expansion as the Internet grows.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transition Capabilities** Since it was recognized from the start that going
    from IPv4 to IPv6 is a big move, support for the IPv4/IPv6 transition has been
    provided in numerous areas. This includes a plan for interoperating IPv4 and IPv6
    networks, for mapping between IPv4 and IPv6 addresses, and other transition support.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changes to Other Protocols** With the introduction of IPv6, several other
    TCP/IP protocols that deal intimately with IP have also had to be updated. One
    of these is ICMP, the most important support protocol for IPv4, which has been
    revised through the creation of ICMPv6 for IPv6\. An addition to TCP/IP is the
    ND protocol, which performs several functions for IPv6 that were done by the Address
    Resolution Protocol (ARP) and ICMP in version 4.'
  prefs: []
  type: TYPE_NORMAL
- en: The following chapters on IPv6 provide much more detail on these changes and
    additions to IP. You'll notice that the majority of these are related to addressing,
    because that is where the greatest number of important changes were made in IPv6\.
    Of course, routing and addressing are closely related, and the changes to addressing
    have had a big impact on routing as well.
  prefs: []
  type: TYPE_NORMAL
- en: Transition from IPv4 to IPv6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IP is the foundation of the TCP/IP protocol suite and the Internet, and thus
    it's somewhat comparable to the foundation of a house in terms of its structural
    importance. Given this, changing IP is somewhat analogous to making a substantial
    modification to the foundation of your house. Since IP is used to connect together
    many devices, it is like changing not just your house, but every house in the
    world!
  prefs: []
  type: TYPE_NORMAL
- en: How do you change the foundation of a house? Very carefully. The same caution
    is required with the implementation of IPv6\. While most people think IPv6 is
    something new, the reality is that the planning and development of IPv6 has been
    underway for nearly a full decade, and if we were starting from scratch, the protocol
    would have been ready for action years ago. However, there is a truly enormous
    installed base of IPv4 hardware and software. This means the folks who develop
    TCP/IP could not just flip a switch and have everyone move over to using IPv6\.
    Instead, a *transition* from IPv4 to IPv6 had to be planned.
  prefs: []
  type: TYPE_NORMAL
- en: The transition is already under way, though most people don't know about it.
    As I said, development of IPv6 itself is pretty much complete, though work continues
    on refining the protocol and also on the development of IPv6-compatible versions
    of other protocols. The implementation of IPv6 began with the creation of development
    networks to test IPv6's operation. These were connected together to form an experimental
    IPv6 internetwork called the *6BONE* (which is a contraction of the phrase *IPv6
    backbone*). This internetwork has been in operation for several years.
  prefs: []
  type: TYPE_NORMAL
- en: 'IPv4 to IPv6 Transition: Differences of Opinion'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Experimental networks are well and good, but the big issue is transitioning
    the Internet to IPv6, and here, opinion diverges rather quickly. In one camp are
    the corporations, organizations, and individuals. All of these groups are quite
    eager to transition to IPv6 quickly in order to gain the many benefits it promises
    in the areas of addressing, routing, and security. Others are taking a much more
    cautious approach, noting that the dire predictions in the mid-1990s of IPv4's
    imminent doom have not come to pass, and arguing that we should take our time
    to make sure IPv6 is going to work on a large scale.
  prefs: []
  type: TYPE_NORMAL
- en: These two groups will continue to play tug-of-war for the next few years, but
    it seems that the tide is now turning toward those who want to speed up the now-years-long
    transition. The move toward adoption of IPv6 as a *production* protocol is being
    spearheaded by a number of groups and organizations. IPv6 has a lot of support
    in areas outside the United States, many of which are running short of IPv4 addresses
    due to small allocations relative to their size. One such area is Asia, a region
    with billions of people, rapidly growing Internet use, and a shortage of IPv4
    addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Within the United States, which has the lion's share of IPv4 addresses (because
    the Internet was developed here), there seems to be a bit less enthusiasm for
    rapid IPv6 deployment. Even here, however, IPv6 got a major shot in the arm in
    July 2003 when the United States Department of Defense (DoD) announced that starting
    in October of that year, it would purchase only networking products that included
    compatibility with IPv6\. The DoD (which was responsible for the development of
    the Internet in the first place) hopes to be fully transitioned to IPv6 by 2008\.
    This will likely have a big impact on the plans of other governmental and private
    organizations in the United States.
  prefs: []
  type: TYPE_NORMAL
- en: The creators of IPv6 knew from the start that transition was going to be an
    important issue with the new protocol. IPv6 is not compatible with IPv4 because
    the addressing system and datagram format are different. Yet the IPv6 designers
    knew that since the transition would take many years, it was necessary that they
    provide a way for IPv4 and IPv6 hosts to interoperate. Consider that in any transition
    there are always stragglers. Like the old Windows 3.11 PC in the corner that you
    still need to use once in a while, some devices will remain on IPv4, even when
    most of the Internet is IPv6, because they were never upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Due to the many differences between IPv4 and IPv6, and the
    fundamental importance of IP to TCP/IP, an orderly transition has been planned
    from IPv4 to IPv6 over a period of many years.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 to IPv6 Transition Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The IETF has been working on specific provisions to allow a smooth transition
    from IPv4 to IPv6, and hardware and software interoperability solutions to let
    newer IPv6 devices access IPv4 hosts. A technique was included in IPv6 to allow
    administrators to embed IPv4 addresses within IPv6 addresses. Special methods
    are defined to handle interoperability, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dual-Stack Devices** Routers and some other devices may be programmed with
    both IPv4 and IPv6 implementations to allow them to communicate with both types
    of hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IPv4/IPv6 Translation** Dual-stack devices may be designed to accept requests
    from IPv6 hosts, convert them to IPv4 datagrams, send the datagrams to the IPv4
    destination, and then process the return datagrams similarly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IPv4 Tunneling of IPv6** IPv6 devices that don''t have a path between them
    consisting entirely of IPv6-capable routers may be able to communicate by encapsulating
    IPv6 datagrams within IPv4\. In essence, they would be using IPv6 on top of IPv4;
    that is, two network layers. The encapsulated IPv4 datagrams would travel across
    conventional IPv4 routers.'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that these solutions generally address only backward compatibility
    to allow IPv6 devices to talk to IPv4 hardware. Forward compatibility between
    IPv4 and IPv6 is not possible because IPv4 hosts cannot communicate with IPv6
    hosts; they lack the knowledge of how IPv6 works. It is possible that certain
    special adaptations might be created to allow IPv4 hosts to access IPv6 hosts.
    But eventually, all IPv4 devices of any importance will want to migrate to IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: The IETF has done such a good job in the past with introducing new technologies,
    and so much effort has been put into the IPv6 transition, that I am quite confident
    that the transition to IPv6 will come off with few, if any, problems. One good
    thing about the transition is that IPv4 is, at the present time, still getting
    the job done, so there is no big hurry to make the move to IPv6\. While technologies
    such as CIDR and NAT are like Band-Aids on IPv4, they have been very successful
    ones in extending the useful life of the aging protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 25. IPV6 ADDRESSING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The primary motivation for creating Internet Protocol version 6 (IPv6) was to
    rectify the addressing problems in version 4 (IPv4). Along with acquiring more
    addresses, the IPv6 designers desired a way of interpreting, assigning, and using
    addresses in a way that was more consonant with modern internetworking. So, it's
    no surprise that many of the changes in IPv6 are associated with IP addressing.
    The IPv6 addressing scheme is similar in concept to IPv4 addressing, but has been
    completely overhauled to create an addressing system that's capable of supporting
    continued Internet expansion and new applications for the foreseeable future.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the concepts and methods associated with addressing under
    IPv6\. I begin with a look at some addressing generalities in IPv6, including
    the addressing model, address types' size, and address space. I discuss the unique
    and sometimes confusing representations and notations used for IPv6 addresses
    and prefixes. Then I look at how addresses are arranged and allocated into types,
    beginning with an overall look at address space composition and then at the global
    unicast address format. I describe the new methods used for mapping IP addresses
    to underlying physical network addresses. I then describe special IPv6 addressing
    issues, including reserved and private addresses, IPv4 address embedding, anycast
    and multicast addresses, and autoconfiguration and renumbering of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Addressing under IPv6 is outlined in the main IPv6 RFC, RFC 2460, "Internet
    Protocol, Version 6 (IPv6) Specification." However, most of the details of IPv6
    addressing are contained in two other standards: RFC 3513, "Internet Protocol
    Version 6 (IPv6) Addressing Architecture," and RFC 3587, "IPv6 Global Unicast
    Address Format." These replaced the 1998 standards RFC 2373, "IP Version 6 Addressing
    Architecture," and RFC 2374, "An IPv6 Aggregatable Global Unicast Address Format."'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *As with the other IPv6 chapters in this book, my
    look at addressing is based somewhat on a contrast to how addressing is done in
    IPv4\. I strongly recommend a thorough understanding of IPv4 addressing, including
    classless addressing using Classless Inter-Domain Routing (CIDR), as presented
    in Chapters [Chapter 16](ch16.html "Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES")
    through [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING"), before
    proceeding here. As with the IPv4 addressing sections, familiarity with how binary
    numbers work, and conversion between binary and decimal numbers is also a good
    idea. [Chapter 4](ch04.html "Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE
    MATHEMATICS OF COMPUTING"), which provides some background on data representation
    and the mathematics of computing, may be of assistance in that respect*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'IPv6 Addressing Overview: Addressing Model, Address Types, and Address Size'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, IPv6 represents a significant update to
    IP, but its modifications and additions are made without changing the core nature
    of how IP works. Addressing is the place where most of the differences between
    IPv4 and IPv6 are seen, but the changes are mostly in how addresses are implemented
    and used. The overall model used for IP addressing in IPv6 is pretty much the
    same as it was in IPv4; some aspects have not changed at all, while others have
    changed only slightly.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Addressing Model Characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the general characteristics of the IPv6 addressing model that
    are basically the same as in IPv4:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core Functions of Addressing** The two main functions of addressing are still
    network interface identification and routing. Routing is facilitated through the
    structure of addresses on the internetwork.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Layer Addressing** IPv6 addresses are still the ones associated with
    the network layer in TCP/IP networks and are distinct from data link layer (also
    sometimes called *physical*) addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of IP Addresses per Device** Addresses are still assigned to network
    interfaces, so a regular host like a PC will usually have one (unicast) address,
    and routers will have more than one for each of the physical networks to which
    it connects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Interpretation and Prefix Representation** IPv6 addresses are like
    classless IPv4 addresses in that they are interpreted as having a network identifier
    part and a host identifier part (a network ID and a host ID), but that the delineation
    is not encoded into the address itself. A prefix-length number, using CIDR-like
    notation, is used to indicate the length of the network ID (prefix length).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private and Public Addresses** Both types of addresses exist in IPv6, though
    they are defined and used somewhat differently.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Supported Address Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One important change in the addressing model of IPv6 is the *address types*
    supported. IPv4 supported three address types: unicast, multicast, and broadcast.
    Of these, the vast majority of actual traffic was unicast. IP multicast support
    was not widely deployed until many years after the Internet was established and
    it continues to be hampered by various issues. Use of broadcast in IP had to be
    severely restricted for performance reasons (we don''t want any device to be able
    to broadcast across the entire Internet!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'IPv6 also supports three address types, but with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicast Addresses** These are standard unicast addresses as in IPv4, one
    per host interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast Addresses** These are addresses that represent various groups of
    IP devices. A message sent to a multicast address goes to all devices in the group.
    IPv6 includes much better multicast features and many more multicast addresses
    than IPv4\. Since multicast under IPv4 was hampered in large part due to lack
    of support of the feature by many hardware devices, support for multicasting is
    a required, not optional, part of IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anycast Addresses** Anycast addressing is used when a message must be sent
    to any member of a group, but does not need to be sent to all of them. Usually
    the member of the group that is easiest to reach will be sent the message. One
    common example of how anycast addressing could be used is in load sharing among
    a group of routers in an organization.'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast addressing as a distinct addressing method is gone in IPv6\. Broadcast
    functionality is implemented using multicast addressing to groups of devices.
    A multicast group to which all nodes belong can be used for broadcasting in a
    network, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** IPv6 has unicast and multicast addresses like IPv4\. There
    is, however, no distinct concept of a broadcast address in IPv6\. A new type of
    address, *the anycast* address, has been added to allow a message to be sent to
    any one member of a group of devices.'
  prefs: []
  type: TYPE_NORMAL
- en: An important implication of the creation of anycast addressing is removal of
    the strict uniqueness requirement for IP addresses. Anycast is accomplished by
    assigning the same IP address to more than one device. The devices must also be
    specifically told that they are sharing an anycast address, but the addresses
    themselves are structurally the same as unicast addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the remainder of this chapter focuses on unicast addressing, since
    it is by far the most important type. Multicast and anycast addressing are given
    special attention in a separate section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Address Size and Address Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of all the changes introduced in IPv6, easily the most celebrated is the increase
    in the size of IP addresses, which resulted in a corresponding massive increase
    in the size of the address space as well. It's not surprising that these sizes
    were increased compared to IPv4—everyone has known for years that the IPv4 address
    space was too small to support the future of the Internet. What's remarkable is
    the level of increase and the implications for how Internet addresses are used.
  prefs: []
  type: TYPE_NORMAL
- en: In IPv4, IP addresses are 32 bits long; these are usually grouped into 4 octets
    of 8 bits each. The theoretical IPv4 address space is 2^(32), or 4,294,967,296
    addresses. To increase this address space, we simply increase the size of addresses;
    each extra bit we give to the address size doubles the address space. Based on
    this, some folks expected the IPv6 address size to increase from 32 to 48 bits,
    or perhaps 64 bits. Either of these numbers would have given a rather large number
    of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: However, IPv6 addressing doesn't use either of these figures. Instead, the IP
    address size jumps all the way to 128 bits, or 16 8-bit octets/bytes. The size
    of the IPv6 address space is, quite literally, astronomical. Like the numbers
    that describe the number of stars in a galaxy or the distance to the furthest
    pulsars, the number of addresses that can be supported in IPv6 is mind-boggling.
    See [Figure 25-1](ch25.html#a_poor_representation_of_relative_ipv4_a "Figure 25-1. A
    (poor) representation of relative IPv4 and IPv6 address space sizes I wanted to
    make a cool graphic to show the relative sizes of the IPv4 and IPv6 address spaces.
    You know, where I would show the IPv6 address space as a big box and the IPv4
    address space as a tiny one. The problem is that the IPv6 address space is so
    much larger than the IPv4 space that there is no way to show it to scale! To make
    this diagram to scale, imagine the IPv4 address space is the 1.6-inch square above.
    In that case, the IPv6 address space would be represented by a square the size
    of the solar system!") for an idea of what I mean by *astronomical*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since IPv6 addresses are 128 bits long, the theoretical address space, if all
    addresses were used, is 2^(128) addresses. This number, when expanded out, is
    340,282,366,920,938,463,463,374,607,431,768,211,456, which is normally expressed
    in scientific notation as about 3.4*10^(38) addresses. Whoa! That''s about 340
    trillion, *trillion*, *trillion* addresses. As I said, it''s pretty hard to grasp
    just how large this number is. Consider these comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: It's enough addresses for many trillions of addresses to be assigned to every
    human being on the planet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Earth is about 4.5 billion years old. If you had been assigning IPv6 addresses
    at a rate of 1 billion per second since the Earth was formed, you would have by
    now used up less than one trillionth of the address space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Earth's surface area is about 510 trillion square meters. If a typical computer
    has a footprint of about one-tenth of a square meter, you would have to stack
    computers 10 billion high—blanketing the entire surface of the Earth—to use up
    that same trillionth of the address space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK, I think you get the idea. It's clear that one goal of the decision to go
    to 128-bit addresses is to make sure that we will never run out of address space
    again, and it seems quite likely that this will be the case.
  prefs: []
  type: TYPE_NORMAL
- en: '![A (poor) representation of relative IPv4 and IPv6 address space sizes I wanted
    to make a cool graphic to show the relative sizes of the IPv4 and IPv6 address
    spaces. You know, where I would show the IPv6 address space as a big box and the
    IPv4 address space as a tiny one. The problem is that the IPv6 address space is
    so much larger than the IPv4 space that there is no way to show it to scale! To
    make this diagram to scale, imagine the IPv4 address space is the 1.6-inch square
    above. In that case, the IPv6 address space would be represented by a square the
    size of the solar system!](httpatomoreillycomsourcenostarchimages287869.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-1. A (poor) representation of relative IPv4 and IPv6 address space
    sizes I wanted to make a cool graphic to show the relative sizes of the IPv4 and
    IPv6 address spaces. You know, where I would show the IPv6 address space as a
    big box and the IPv4 address space as a tiny one. The problem is that the IPv6
    address space is so much larger than the IPv4 space that there is no way to show
    it to scale! To make this diagram to scale, imagine the IPv4 address space is
    the 1.6-inch square above. In that case, the IPv6 address space would be represented
    by a square the size of the solar system!
  prefs: []
  type: TYPE_NORMAL
- en: There are drawbacks to having such a huge address space, too. Consider that
    even with a 64-bit address, we would have a very large address space; 2^(64) equals
    18,446,744,073,709,551,616, or about 18 million trillion. These are still probably
    more addresses than the Internet will ever need. However, by going to 128 bits
    instead, this has made dealing with IP addresses unruly (as you'll see in the
    next section). This has also increased overhead, since every datagram header or
    other place where IP addresses are referenced must use 16 bytes for each address
    instead of the 4 bytes that were needed in IPv4, or the 8 bytes that might have
    been required with a 64-bit address.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The IPv6 address space is really, *really* big!'
  prefs: []
  type: TYPE_NORMAL
- en: So why the overkill of going to 128 bits? The main reason is *flexibility*.
    Even though you can have a couple zillion addresses if we allocate them one at
    a time, this makes assignment difficult. The developers got rid of class-oriented
    addressing in IPv4 because it wasted address space. The reality, though, is that
    being able to waste address space is a useful luxury.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having 128 bits allows us to divide the address space and assign various purposes
    to different bit ranges, while still not having to worry about running out of
    space. Later in this chapter, in the section describing the IPv6 global unicast
    address format, you''ll see one way that those 128 bits are put to good use: They
    allow you to create a hierarchy of networks while still saving 64 bits for host
    IDs. This hierarchy has its own advantages.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Address and Address Notation and Prefix Representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Increasing the size of IP addresses from 32 bits to 128 bits expands the address
    space to a gargantuan size, thereby ensuring that we will never again run out
    of IP addresses, and thereby allowing flexibility in how they are assigned and
    used. Unfortunately, there are some drawbacks to this method, and one of them
    is that 128-bit numbers are very large. The size makes them awkward and difficult
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computers work in binary, and they have no problem dealing with long strings
    of ones and zeros, but humans find them confusing. Even the 32-bit addresses of
    IPv4 are cumbersome for us to deal with, which is why we use dotted decimal notation
    for them unless we need to work in binary (as with subnetting). However, IPv6
    addresses are so much larger than IPv4 addresses that it becomes problematic to
    use dotted decimal notation. To use this notation, we would split the 128 bits
    into 16 octets and represent each with a decimal number from 0 to 255\. However,
    we would end up not with 4 of these numbers, but *16*. A typical IPv6 address
    in this notation would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 128.91.45.157.220.40.0.0.0.0.252.87.212.200.31.255 |'
  prefs: []
  type: TYPE_TB
- en: The binary and dotted decimal representations of this address are shown near
    the top of [Figure 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses."). In either case, the
    word *elegant* doesn't exactly spring to mind.
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary, decimal, and hexadecimal representations of IPv6 addresses The top
    two rows show binary and dotted decimal representations of an IPv6 address; neither
    is commonly used (other than by computers themselves!). The top row of the lower
    table shows the full hexadecimal representation, while the next two rows illustrate
    zero suppression and compression. The last row shows mixed notation, with the
    final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses.](httpatomoreillycomsourcenostarchimages287871.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Address Hexadecimal Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make addresses shorter, the decision was made in IPv6 to change the primary
    method of expressing addresses to use hexadecimal instead of decimal. The advantage
    of this is that it requires fewer characters to represent an address, and converting
    from hexadecimal to binary and back again is much easier than converting from
    binary to decimal or vice versa. The disadvantage is that many people find hexadecimal
    difficult to comprehend and work with, especially because the notion of 16 values
    in each digit is a bit strange.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hexadecimal notation used for IPv6 addresses is similar to the same method
    used for IEEE 802 MAC addresses, and for technologies like Ethernet. With these
    MAC addresses, 48 bits are represented by 6 octets, each octet being a hexadecimal
    number from 0 to FF, separated by a dash or colon, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0A-A7-94-07-CB-D0 |'
  prefs: []
  type: TYPE_TB
- en: 'Since IPv6 addresses are larger, they are instead grouped into eight 16-bit
    *words*, separated by colons, to create what is sometimes called *colon hexadecimal
    notation*, as shown in [Figure 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses."). So, the IPv6 address
    given in the previous example would be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 805B:2D9D:DC28:0000:0000:FC57:D4C8:1FFF |'
  prefs: []
  type: TYPE_TB
- en: 'To keep the address size down, leading zeros can be suppressed in the notation
    so you can immediately reduce this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 805B:2D9D:DC28:0:0:FC57:D4C8:1FFF |'
  prefs: []
  type: TYPE_TB
- en: 'Well, it''s definitely shorter than dotted decimal, but still pretty long.
    When you are dealing with numbers this big, there''s only so much you can do.
    This is part of why the use of Domain Name System (DNS) names for hosts becomes
    much more important under IPv6 than it is in IPv4: Who could remember a hex address
    that long?'
  prefs: []
  type: TYPE_NORMAL
- en: Zero Compression in IPv6 Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fortunately, there is a shortcut that can be applied to shorten some addresses
    even further. This technique is sometimes called *zero compression*. The method
    allows a single string of contiguous zeros in an IPv6 address to be replaced by
    double colons. So, for example, the previous address could be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 805B:2D9D:DC28::FC57:D4C8:1FFF |'
  prefs: []
  type: TYPE_TB
- en: 'You know how many zeros are replaced by the two colons (::) because you can
    see how many fully expressed (uncompressed) hexadecimal words are in the address.
    In this case, there are six, so the :: represents two zero words. To prevent ambiguity,
    the double colons can appear only once in any IP address, because if it appeared
    more than once, you could not tell how many zeros were replaced in each instance.
    So, if the example address were 805B:2D9D:DC28:0:0:FC57:0:0, you could replace
    either the first pair of zeros or the second, but not both.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero compression doesn''t make the example much shorter, but due to how IPv6
    addresses are structured, long strings of zeros are common. For example, consider
    this address:'
  prefs: []
  type: TYPE_NORMAL
- en: '| FF00:4501:0:0:0:0:0:32 |'
  prefs: []
  type: TYPE_TB
- en: 'With compression, this could be shortened as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| FF00:4501::32 |'
  prefs: []
  type: TYPE_TB
- en: 'The technique works even better on special addresses. The full IPv6 loopback
    address is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0:0:0:0:0:0:0:1 |'
  prefs: []
  type: TYPE_TB
- en: 'With compression, the loopback address looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ::1 |'
  prefs: []
  type: TYPE_TB
- en: 'For even more fun, consider the especially odd IPv6 unspecified address, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0:0:0:0:0:0:0:0 |'
  prefs: []
  type: TYPE_TB
- en: Apply zero compression to an address that is all zeros, and what do you get?
  prefs: []
  type: TYPE_NORMAL
- en: '| :: |'
  prefs: []
  type: TYPE_TB
- en: 'No numbers at all! Of course, thinking of :: as an address *does* take some
    getting used to.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** For brevity, IPv6 addresses are represented using eight sets
    of four hexadecimal digits, a form called *colon hexadecimal notation*. Additional
    techniques, called *zero suppression* and *zero compression*, are used to reduce
    the size of displayed addresses further by removing unnecessary zeros from the
    presentation of the address.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Mixed Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is also an alternative notation used in some cases, especially for expressing
    IPv6 addresses that embed IPv4 addresses (discussed later in this chapter). For
    these, it is useful to show the IPv4 portion of the address in the older dotted
    decimal notation, since that''s what you use for IPv4\. Since embedding uses the
    last 32 bits for the IPv4 address, the notation has the first 96 bits in colon
    hexadecimal notation and the last 32 bits in dotted decimal. So, to take the earlier
    example again, in *mixed notation* it would be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 805B:2D9D:DC28::FC57:**212.200.31.255** |'
  prefs: []
  type: TYPE_TB
- en: 'This isn''t really a great example of mixed notation, because embedding usually
    involves long strings of zeros followed by the IPv4 address. Thus, zero compression
    comes in very handy here. Instead of seeing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0:0:0:0:0:0:212.200.31.255 |'
  prefs: []
  type: TYPE_TB
- en: 'You will typically see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ::212.200.31.255 |'
  prefs: []
  type: TYPE_TB
- en: At first glance, this appears to be an IPv4 address. You must keep a close eye
    on those colons in IPv6!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A special mixed notation is defined for IPv6 addresses whose
    last 32 bits contain an embedded IPv4 address. In this notation, the first 96
    bits are displayed in regular colon hexadecimal notation, and the last 32 bits
    are displayed in IPv4-style dotted decimal.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Address Prefix Length Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like IPv4 classless addresses, IPv6 addresses are fundamentally divided into
    a number of network ID bits followed by a number of host ID bits. The network
    identifier is called the *prefix*, and the number of bits used is the *prefix
    length*. This prefix is represented by adding a slash after the address and then
    putting the prefix length after the slash. This is the same method used for classless
    IPv4 addressing with CIDR. For example, if the first 48 bits of the sample address
    were the network ID (prefix), then we would express this as 805B:2D9D:DC28::FC57:D4C8:1FFF/48.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In IPv6, the size of an address''s prefix is indicated by the
    prefix length that follows the address, separated with a slash, just as it is
    done in IPv4 classless addressing.'
  prefs: []
  type: TYPE_NORMAL
- en: As in IPv4, specifiers for whole networks will typically end in long strings
    of zeros. These can be replaced by double colons (::) using zero compression.
    For example, the 48-bit network ID for the previous example is 805B:2D9D:DC28:0:0:0:0:0/48,
    or 805B:2D9D:DC28::/48\. You *must* include the "::" if replacing the trailing
    zeros.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Address Space Allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After dealing for so many years with the very small IPv4 address space, the
    enormous number of addresses in IPv6 must have made the Internet Engineering Task
    Force (IETF) engineers feel like kids in a candy shop. They were good kids, however,
    and didn't run wild, grabbing all the candy they could find and gobbling it up.
    They very carefully considered how to divide the address space for various uses.
    Of course, when you have this much candy, sharing becomes pretty easy.
  prefs: []
  type: TYPE_NORMAL
- en: As was the case with IPv4, the two primary concerns in deciding how to divide
    the IPv6 address space were address assignment and routing. The designers of IPv6
    wanted to structure the address space to make allocation of addresses to Internet
    service providers (ISPs), organizations, and individuals as easy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: At first, perhaps ironically, this led the creators of IPv6 back full circle
    to the use of specific bit sequences to identify different types of addresses,
    just like the old classful addressing scheme. The address type was indicated by
    a set of bits at the start of the address, called the format prefix (FP). The
    format prefix was conceptually identical to the one to four bits used in IPv4
    classful addressing to denote address classes, but was variable in length, ranging
    from three to ten bits. Format prefixes were described in RFC 2373.
  prefs: []
  type: TYPE_NORMAL
- en: In the years following the publication of RFC 2373, the gurus who run the Internet
    had a change of heart regarding how address blocks should be considered. They
    still wanted to divide the IPv6 address space into variably sized blocks for different
    purposes. However, they realized that many people were starting to consider the
    use of format prefixes to be equivalent to the old class-oriented IPv4 system.
    Their main concern was that implementers might program into IPv6 hardware logic
    to make routing decisions based only on the first few bits of the address. This
    was specifically *not* how IPv6 is supposed to work; for one thing, the allocations
    are subject to change.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, one of the modifications made in RFC 3513 was to change the language regarding
    IPv6 address allocations, and specifically, to remove the term *format prefix*
    from the standard. The allocation of different parts of the address space is still
    done based on particular patterns of the first three to ten bits of the address
    to allow certain categories to have more addresses than others. The elimination
    of the specific term denoting this is intended to convey that these bits should
    not be given special attention.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 25-1](ch25s03.html#ipv_address_space_allocations "Table 25-1. IPv6 Address
    Space Allocations") shows the allocations of the IPv6 address space and what fraction
    of the total address space each represents.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-1. IPv6 Address Space Allocations
  prefs: []
  type: TYPE_NORMAL
- en: '| Leading Bits | Fraction of Total IPv6 Address Space | Allocation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 0000 | 1/256 | Unassigned (Includes special addresses such as the unspecified
    and loopback addresses) |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 0001 | 1/256 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 001 | 1/128 | Reserved for NSAP address allocation |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 01 | 1/64 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 1 | 1/32 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 0001 | 1/16 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 1/8 | Global unicast addresses |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | 1/8 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | 1/8 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 1/8 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 1/8 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 1/8 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 1110 | 1/16 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 0 | 1/32 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 10 | 1/64 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 110 | 1/128 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 1110 0 | 1/512 | Unassigned |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 1110 10 | 1/1024 | Link-local unicast addresses |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 1110 11 | 1/1024 | Site-local unicast addresses |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 1111 | 1/256 | Multicast addresses |'
  prefs: []
  type: TYPE_TB
- en: This is more complicated than the IPv4 classful scheme because there are so
    many more categories and they range greatly in size, even if most of them are
    currently unassigned.
  prefs: []
  type: TYPE_NORMAL
- en: An easier way to make sense of this table is to consider the division of the
    IPv6 address space into *eighths*. Of these eight groups, one (001) has been reserved
    for unicast addresses; a second (000) has been used to carve out smaller reserved
    blocks, and a third (111) has been used for sub-blocks for local and multicast
    addresses. Five are completely unassigned.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the IPv6 designers have taken great care to allocate only the
    portion of these "eighths" of the address space that they felt was needed for
    each type of address. For example, only a small portion of the part of the address
    space beginning 111 was used, with most of it left aside. In total, only 71/512ths
    of the address space is assigned right now, or about 14 percent. The other 86
    percent is unassigned and kept aside for future use. (Bear in mind that even 1/1024th
    of the IPv6 address space is gargantuan—it represents trillions of trillions of
    addresses.)
  prefs: []
  type: TYPE_NORMAL
- en: Later sections in this chapter provide more information on several of these
    address blocks. Note that the 0000 0000 reserved block is used for several special
    address types, including the loopback address, the unspecified address, and IPv4
    address embedding. The 1111 1111 format prefix identifies multicast addresses;
    this string is FF in hexadecimal, so any address beginning with FF is a multicast
    address in IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Global Unicast Address Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is anticipated that unicast addressing will be used for the vast majority
    of Internet traffic under IPv6, as is the case for IPv4\. It is for this reason
    that the largest of the assigned blocks of the IPv6 address space is dedicated
    to unicast addressing. A full one-eighth slice of the enormous IPv6 address "pie"
    is assigned to unicast addresses, which are indicated by a 001 in the first three
    bits of the address. The question is: How do we use the remaining 125 bits in
    the spacious IP addresses?'
  prefs: []
  type: TYPE_NORMAL
- en: Rationale for a Structured Unicast Address Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When IPv4 was first created, the Internet was rather small, and the model for
    allocating address blocks was based on a central coordinator: the Internet Assigned
    Numbers Authority (IANA). Everyone who wanted address blocks would go straight
    to the central authority. As the Internet grew, this model became impractical.
    Today, IPv4''s classless addressing scheme allows variable-length network IDs
    and hierarchical assignment of address blocks. Big ISPs get large blocks from
    the central authority, and then subdivide them and allocate them to their customers,
    and so on. This is managed by today''s ISPs, but there is nothing in the address
    space that helps manage the allocation process. In turn, each organization has
    the ability to further subdivide its address allocation to suit its internal requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The designers of IPv6 had the benefit of this experience and realized there
    would be tremendous advantages to designing the unicast address structure to reflect
    the overall topology of the Internet. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier allocation of address blocks at various levels of the Internet topological
    hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP network addresses that automatically reflect the hierarchy by which routers
    move information across the Internet, thereby allowing routes to be easily aggregated
    for more efficient routing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility for organizations like ISPs to subdivide their address blocks for
    customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility for end-user organizations to subdivide their address blocks to
    match internal networks, much as subnetting did in IPv4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater meaning to IP addresses. Instead of just being a string of 128 bits
    with no structure, it would become possible to look at an address and know certain
    things about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic Division of the Unicast Address Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most generic way of dividing up the 128 bits of the unicast address space
    is into three sections, as shown in [Table 25-2](ch25s04.html#generic_ipv_global_unicast_address_forma
    "Table 25-2. Generic IPv6 Global Unicast Address Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-2. Generic IPv6 Global Unicast Address Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bits) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Prefix | *n* | Global Routing Prefix: The network ID or prefix of the address,
    used for routing. |'
  prefs: []
  type: TYPE_TB
- en: '| Subnet ID | *m* | Subnet Identifier: A number that identifies a subnet within
    the site. |'
  prefs: []
  type: TYPE_TB
- en: '| Interface ID | 128-*n-m* | Interface Identifier: The unique identifier for
    a particular interface (host or other device). It is unique within the specific
    prefix and subnet. |'
  prefs: []
  type: TYPE_TB
- en: 'The *global routing prefix* and *subnet identifier* represent the two basic
    levels at which addresses need to be hierarchically constructed: that is, global
    and site-specific. The routing prefix consists of a number of bits that can be
    further subdivided according to the needs of Internet registries and ISPs. This
    subdivision reflects the topography of the Internet as a whole. The subnet ID
    gives a number of bits to site administrators for creating an internal network
    structure suiting each administrator''s needs.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Implementation of the Unicast Address Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In theory, any size for *n* and *m* (see [Table 25-2](ch25s04.html#generic_ipv_global_unicast_address_forma
    "Table 25-2. Generic IPv6 Global Unicast Address Format")) could be used. The
    implementation chosen for IPv6, however, assigns 48 bits to the routing prefix
    and 16 bits to the subnet identifier. This means 64 bits are available for interface
    identifiers, which are constructed based on the IEEE EUI-64 format, as described
    in the next section. Thus, the overall IPv6 unicast address format is constructed
    as shown in [Table 25-3](ch25s04.html#ipv_global_unicast_address_format "Table 25-3. IPv6
    Global Unicast Address Format") and illustrated in [Figure 25-3](ch25s04.html#ipv6_global_unicast_address_format-id001
    "Figure 25-3. IPv6 global unicast address format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-3. IPv6 Global Unicast Address Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bits) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Prefix | 48 | Global Routing Prefix: The network ID or prefix of the address
    that''s used for routing. The first three bits are 001 to indicate a unicast address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Subnet ID | 16 | Subnet Identifier: A number that identifies a subnet within
    the site. |'
  prefs: []
  type: TYPE_TB
- en: '| Interface ID | 64 | Interface ID: The unique identifier for a particular
    interface (host or other device). It is unique within the specific prefix and
    subnet. |'
  prefs: []
  type: TYPE_TB
- en: '![IPv6 global unicast address format](httpatomoreillycomsourcenostarchimages287873.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-3. IPv6 global unicast address format
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The part of the IPv6 address space set aside for unicast addresses
    is structured into an address format that uses the first 48 bits for the *routing
    prefix* (like a network ID), the next 16 bits for a *subnet ID*, and the final
    64 bits for an *interface ID* (like a host ID).'
  prefs: []
  type: TYPE_NORMAL
- en: Due to this structure, most end sites (regular companies and organizations,
    as opposed to ISPs) will be assigned IPv6 networks with a 48-bit prefix. In common
    parlance, these network identifiers have now come to be called *48s* or */48s*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 16 bits of subnet ID allow each site considerable flexibility in creating
    subnets that reflect the site''s network structure. Here are some example uses
    of the 16 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: A smaller organization can just set all the bits in the subnet ID to zero and
    have a flat internal structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A medium-sized organization could use all the bits in the subnet ID to perform
    the equivalent of straight subnetting under IPv4, thereby assigning a different
    subnet ID to each subnet. There are 16 bits here, and this allows a whopping 65,536
    subnets!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A larger organization can use the bits to create a multiple-level hierarchy
    of subnets, exactly like IPv4's Variable Length Subnet Masking (VLSM). For example,
    the company could use two bits to create four subnets. It could then take the
    next three bits to create eight sub-subnets in some or all of the four subnets.
    There would still be 11 more bits to create sub-sub-subnets, and so forth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Original Division of the Global Routing Prefix: Aggregators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The global routing prefix is similarly divided into a hierarchy, but one that
    has been designed for the use of the entire Internet, like CIDR. There are 45
    bits available here (48 bits minus the first three that are fixed at 001). That
    is a lot. When the unicast address structure was first detailed in RFC 2374, that
    document described a specific division of the 45 bits based on a two-level hierarchical
    topology of Internet registries and providers. These organizations were described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-Level Aggregators (TLAs)** These refer to the largest Internet organizations,
    which were to be assigned large blocks of IPv6 addresses from registration authorities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next-Level Aggregators (NLAs)** These organizations would get blocks of addresses
    from TLAs and divide them for end-user organizations (sites).'
  prefs: []
  type: TYPE_NORMAL
- en: The 45 bits were split between these two uses, with a few bits reserved in the
    middle to allow expansion of either field if needed. Thus, the RFC 2374 structure
    for the 45 bits appeared as listed in [Table 25-4](ch25s04.html#historical_ipv_unicast_routing_prefix_st
    "Table 25-4. Historical IPv6 Unicast Routing Prefix Structure").
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-4. Historical IPv6 Unicast Routing Prefix Structure
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bits) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| TLA ID | 13 | Top-Level Aggregation (TLA) Identifier: A globally unique identifier
    for the top-level aggregator. There are 13 bits, so there were a maximum of 8,192
    TLAs allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| RES | 8 | Reserved: These 8 bits were reserved for future use and set to
    zero. By leaving these 8 bits between the TLA ID and NLA ID unused, they could
    later be used to expand either the TLA ID or NLA ID fields as needed. |'
  prefs: []
  type: TYPE_TB
- en: '| NLA ID | 24 | Next-Level Aggregation (NLA) Identifier: Each TLA was given
    this 24-bit field to generate blocks of addresses for allocation to its customers.
    The NLA ID is unique for each TLA ID. The use of the 24 bits was left up to the
    TLA organization. |'
  prefs: []
  type: TYPE_TB
- en: You'll notice my use of the past tense in the description of the TLA/NLA structure,
    and that table heading is a pretty big giveaway, too. In August 2003, RFC 3587
    was published, which in a nutshell says, "Uh, never mind about all that TLA/NLA
    stuff." The decision was made that having this structure hardwired into an Internet
    standard was inflexible, and it made more sense to let the regional Internet registries
    (APNIC, ARIN, LACNIC, and RIPE) decide for themselves how to use the 45 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The obsoleting of the TLA/NLA structure occurred after many years of people
    getting used to it, so for some time to come, you will still routinely see those
    terms mentioned in IPv6 descriptions. (This is why I included discussion of them
    here.)*'
  prefs: []
  type: TYPE_NORMAL
- en: A Sample Division of the Global Routing Prefix into Levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no single structure for determining how the 48-bit routing prefix is
    divided in the global unicast hierarchy. As one example, it might be possible
    to divide it into three levels, as shown in [Table 25-5](ch25s04.html#example_ipv_unicast_routing_prefix_struc
    "Table 25-5. Example IPv6 Unicast Routing Prefix Structure") and illustrated in
    [Figure 25-4](ch25s04.html#example_of_ipv6_unicast_routing_prefix_s "Figure 25-4. Example
    of IPv6 unicast routing prefix structure The top row shows the global IPv6 unicast
    address format. The second shows one way to divide the global routing prefix into
    three levels using 10, 12, and 23 bits, respectively. The third row shows how
    the first 10 bits are used to create 210, or 1,024, different level 1 blocks.
    The next row illustrates that for each of these 13-bit prefixes, you could have
    212, or 4,096, level 2 blocks. Then, within each 25-bit level 2 ID, you have 23
    bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or /48 would be assigned
    to an individual organization.").
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-5. Example IPv6 Unicast Routing Prefix Structure
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bits) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (Unicast Indicator) | 3 | Each unicast address starts with 001; there is
    no official name for this (it used to be called the *format prefix*). |'
  prefs: []
  type: TYPE_TB
- en: '| Level1 ID | 10 | Level 1 Identifier: The identifier of the highest level
    in the hierarchy. This would be used for assigning the largest blocks of addresses
    in the global hierarchy to the biggest Internet organizations. The number of level
    1 organizations would be 210, or 1,024. |'
  prefs: []
  type: TYPE_TB
- en: '| Level2 ID | 12 | Level 2 Identifier: Each block assigned to a level 1 organization
    would use 12 bits to create 4,096 address blocks to divide among the lower-level
    organizations it serves. |'
  prefs: []
  type: TYPE_TB
- en: '| Level3 ID | 23 | Level 3 Identifier: Each level 2 organization has 23 bits
    to use to divide its level 2 address block. Thus, it could create over 8 million
    individual /48 address blocks to assign to end-user sites. Alternatively, the
    23 bits could be divided further into still lower levels to reflect the structure
    of the level 2 organization''s customers. |'
  prefs: []
  type: TYPE_TB
- en: '![Example of IPv6 unicast routing prefix structure The top row shows the global
    IPv6 unicast address format. The second shows one way to divide the global routing
    prefix into three levels using 10, 12, and 23 bits, respectively. The third row
    shows how the first 10 bits are used to create 210, or 1,024, different level
    1 blocks. The next row illustrates that for each of these 13-bit prefixes, you
    could have 212, or 4,096, level 2 blocks. Then, within each 25-bit level 2 ID,
    you have 23 bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or /48
    would be assigned to an individual organization.](httpatomoreillycomsourcenostarchimages287875.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-4. Example of IPv6 unicast routing prefix structure The top row shows
    the global IPv6 unicast address format. The second shows one way to divide the
    global routing prefix into three levels using 10, 12, and 23 bits, respectively.
    The third row shows how the first 10 bits are used to create 210, or 1,024, different
    level 1 blocks. The next row illustrates that for each of these 13-bit prefixes,
    you could have 212, or 4,096, level 2 blocks. Then, within each 25-bit level 2
    ID, you have 23 bits, or 8,388,608, level 3 blocks. At the bottom, a level 3 or
    /48 would be assigned to an individual organization.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one possible theoretical way that the bits in a /48 network address
    could be assigned. As you can see, with so many bits, there is a lot of flexibility.
    In the previous scheme, you can have over four million level 2 organizations,
    each of which can assign eight million /48 addresses. And each of those is equivalent
    in size to an IPv4 Class B address (over 65,000 hosts)!
  prefs: []
  type: TYPE_NORMAL
- en: The removal of RFC 2374's fixed structure for the global routing prefix is consistent
    with the IPv6 development team's efforts to emphasize that bit fields and structures
    are used only for allocating addresses and not for routing purposes. The addresses
    themselves, once created, are not interpreted by hardware on an internetwork based
    on this format. To routers, the only structure that matters is the division between
    the network ID and host ID, given by the prefix length that trails the IP address,
    and this division can occur at any bit boundary. These hardware devices just see
    128 bits of an IP address and use it without any knowledge of hierarchical address
    divisions or levels.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the key to obtaining the allocation benefits of the aggregatable
    unicast address format is the abundance of bits available to us under IPv6\. The
    ability to have these hierarchical levels while still allowing 64 bits for the
    interface identifier is one of the main reasons why IPv6 designers went all the
    way from 32 bits to 128 bits for address size. By creating this structure, we
    maintain flexibility, while avoiding the potential chaos of trying to allocate
    many different network sizes within the 128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Note that anycast addresses are structured in the same way as unicast addresses,
    so they are allocated according to this same model. (Multicast addresses are not.)
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Interface Identifiers and Physical Address Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In IPv4, IP addresses have no relationship to the addresses used for underlying
    data link layer network technologies. A host that connects to a TCP/IP network
    using an Ethernet network interface card (NIC) has an Ethernet MAC address and
    an IP address, but the two numbers are distinct and unrelated in any way. IP addresses
    are assigned manually by administrators without any regard for the underlying
    physical address.
  prefs: []
  type: TYPE_NORMAL
- en: With the overhaul of addressing in IPv6, an opportunity presented itself to
    create a better way of mapping IP unicast addresses and physical network addresses.
    Implementing this superior mapping technique was one of the reasons why IPv6 addresses
    were made so large. With 128 total bits, even with a full 45 bits reserved for
    the network prefix and 16 bits for the site subnet, we are still left with 64
    bits to use for the *interface identifier (interface ID)*, which is analogous
    to the host ID under IPv4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having so many bits at our disposal gives us great flexibility. Instead of
    using arbitrary, made-up identifiers for hosts, we can base the interface ID on
    the underlying data link layer hardware address, as long as that address is no
    greater than 64 bits in length. Since virtually all devices use layer 2 addresses
    of 64 bits or fewer, there is no problem in using those addresses for the interface
    ID in IP addresses. This provides an immediate benefit: It makes networks easier
    to administer, since we don''t need to record two arbitrary numbers for each host.
    The IP address can be derived from the MAC address and the network ID. It also
    means that we can tell the IP address from the MAC address and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: The actual mapping from data link layer addresses to IP interface IDs depends
    on the particular technology. It is essential that all devices on the same network
    use the same mapping technique, of course. By far, the most common type of layer
    2 addresses in networking are IEEE 802 MAC addresses, which are used by Ethernet
    and other IEEE 802 Project networking technologies. These addresses have 48 bits,
    arranged into two blocks of 24\. The upper 24 bits are arranged into a block called
    the *organizationally unique identifier (OUI)*, with different values assigned
    to individual organizations. The lower 24 bits are then used for an identifier
    for each specific device.
  prefs: []
  type: TYPE_NORMAL
- en: The IEEE has also defined a format called the *64-bit extended unique identifier*,
    which is abbreviated *EUI-64*. It is similar to the 48-bit MAC format, except
    that while the OUI remains at 24 bits, the device identifier becomes 40 bits instead
    of 24\. This gives each manufacturer 65,536 times as many device addresses within
    its OUI.
  prefs: []
  type: TYPE_NORMAL
- en: A form of this format, called *modified EUI-64*, has been adopted for IPv6 interface
    IDs. To get the modified EUI-64 interface ID for a device, you simply take the
    EUI-64 address and change the seventh bit from the left (the universal/local,
    or U/L, bit) from a 0 to a 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, most devices still use the older 48-bit MAC address format. These
    can be converted to EUI-64 and then modified to EUI-64 form for creating an IPv6
    interface ID. The process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the 24-bit OUI portion, the leftmost 24 bits of the Ethernet address, and
    put them into the leftmost 24 bits of the interface ID. Take the 24-bit local
    portion (the rightmost 24 bits of the Ethernet address) and put it into the rightmost
    24 bits of the interface ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the remaining 16 bits in the middle of the interface ID, put the value 11111111
    11111110, FFFE in hexadecimal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address is now in EUI-64 form. Change the universal/local bit (bit 7 from
    the left, shown in bold in [Figure 25-5](ch25s06.html#converting_ieee_802_mac_addresses_to_ipv
    "Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers"))
    from a 0 to a 1\. This gives the modified EUI-64 interface ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The last 64 bits of IPv6 unicast addresses are used for interface
    IDs, which are created in a special format called *modified EUI-64*. A simple
    process can be used to determine the interface ID from the 48-bit MAC address
    of a device like an Ethernet network interface card. This can then be combined
    with a network prefix (routing prefix and subnet ID) to determine a corresponding
    IPv6 address for the device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take as an example the Ethernet address of 39-A7-94-07-CB-D0\. Here
    are the steps for conversion (illustrated in [Figure 25-5](ch25s06.html#converting_ieee_802_mac_addresses_to_ipv
    "Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers")):'
  prefs: []
  type: TYPE_NORMAL
- en: Take 39-A7-94, the first 24 bits of the identifier, and put it into the first
    (leftmost) 24 bits of the address. The local portion of 07-CB-D0 becomes the last
    24 bits of the identifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The middle 16 bits are given the value FF-FE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the seventh bit from 0 to 1, which changes the first octet from 39 to
    3B.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The identifier thus becomes 3B-A7-94-FF-FE-07-CB-D0, or in IPv6 colon hexadecimal
    notation, 3BA7:94FF:FE07:CBD0\. The first 64 bits of the device's address are
    supplied using the global unicast address format.
  prefs: []
  type: TYPE_NORMAL
- en: The only drawback of this technique is that if the physical hardware changes,
    so does the IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: 'IPv6 Special Addresses: Reserved, Private, Unspecified, and Loopback'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as certain IPv4 address ranges are designated for reserved, private, and
    other unusual addresses, a small part of the monstrous IPv6 address space has
    been set aside for special addresses. The purpose of these addresses and address
    blocks is to provide addresses for special requirements and private use in IPv6
    networks. Since even relatively small pieces of IPv6 are still enormous, setting
    aside 0.1 percent of the address space for a particular use still generally yields
    more addresses than anyone will ever need.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers](httpatomoreillycomsourcenostarchimages287877.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-5. Converting IEEE 802 MAC addresses to IPv6 modified EUI-64 identifiers
  prefs: []
  type: TYPE_NORMAL
- en: Special Address Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four basic types of special IPv6 addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reserved Addresses** A portion of the address space is set aside as reserved
    for various uses by the IETF, both present and future. Unlike IPv4, which has
    many small reserved blocks in various locations in the address space, the reserved
    block in IPv6 is at the "top" of the address space, beginning with 0000 0000 (or
    00 for the first hexadecimal octet). This represents 1/256th of the total address
    space. Some of the special addresses you''ll see shortly come from this block.
    IPv4 address embedding is also done within this reserved address area.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Reserved addresses are not the same as unassigned addresses. The latter term
    just refers to blocks whose use has not yet been determined*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private/Unregistered/Nonroutable Addresses** A block of addresses is set
    aside for private addresses, just as in IPv4, except that like everything in IPv6
    the private address block in IPv6 is much larger. These private addresses are
    local only to a particular link or site and, therefore, are never routed outside
    a particular company''s network. Private addresses are indicated by the address
    having "1111 1110 1" for the first nine bits. Thus, private addresses have a first
    octet value of FE in hexadecimal, with the next hexadecimal digit being from 8
    to F. These addresses are further divided into two types based on their scope:
    site-local and link-local, as discussed shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loopback Address** Like IPv4, a provision has been made for a special loopback
    address for testing; datagrams sent to this address "loop back" to the sending
    device. However, in IPv6, there is just one address for this function, not a whole
    block (which was never needed in the first place). The loopback address is 0:0:0:0:0:0:0:1,
    which is normally expressed using zero compression as ::1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unspecified Address** In IPv4, an IP address of all zeros has a special meaning:
    It refers to the host itself and is used when a device doesn''t know its own address.
    In IPv6, this concept has been formalized, and the all-zeros address (0:0:0:0:0:0:0:0)
    is named the *unspecified address*. It is typically used in the source field of
    a datagram sent by a device seeking to have its IP address configured. Zero compression
    can be applied to this address; since it is all zeros, the address becomes just
    ::. (I consider this confusing, myself. I think something like 0::0 is a lot clearer
    and short enough.)'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In IPv6, a special *loopback address*, 0:0:0:0:0:0:0:1 (::1
    in compressed form) is set aside for testing purposes. The *unspecified address*,
    0:0:0:0:0:0:0:0 (:: in compressed form) is used to indicate an unknown address.
    A block of *private* or *local* addresses is defined. This block is the set of
    all addresses beginning with 1111 1110 1 as the first nine bits.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Private Addresses Type Scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's take a closer look at private addresses. In IPv6, these are called
    *local-use* addresses, with the name conveying clearly what they are for. They
    are also sometimes called *link-layer* addresses. You'll recall that IPv4 private
    addresses were commonly used when public addresses could not be obtained for all
    devices, sometimes in combination with technologies like Network Address Translation
    (NAT). In IPv6, trickery like NAT isn't required. Instead, local-use addresses
    are intended for communication that is inherently designed to be sent to local
    devices only. For example, neighbor discovery functions using the IPv6 Neighbor
    Discovery (ND) protocol employ local-use addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *scope* of local addresses is obviously a local network, not the global
    scope of public Internet addresses. Local addresses in IPv6 are further divided
    into two types, reflecting a division of local scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Site-Local Addresses** These addresses have the scope of an entire site or
    organization. They allow addressing within an organization without having to use
    a public prefix. Routers will forward datagrams using site-local addresses within
    the site, but not addresses outside it to the public Internet. Site-local addresses
    are differentiated from link-local addresses by having a tenth bit of 1 following
    the nine starting address bits that are common to all private IPv6 addresses.
    Thus, they begin with 1111 1110 11\. In hexadecimal, site-local addresses begin
    with FE, and then C to F for the third digit. So, these addresses start with FEC,
    FED, FEE, or FEF.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link-Local Addresses** These addresses have a smaller scope than site-local
    addresses; they refer only to a particular physical link (physical network). Routers
    will not forward datagrams using link-local addresses at all—not even within the
    organization. These addresses are only for local communication on a particular
    physical network segment. They can be used for address configuration or for ND
    functions such as address resolution and ND. Link-local addresses are differentiated
    from site-local addresses by having a tenth bit of 0 following the nine initial
    address bits common to all private IPv6 addresses: 1111 1110 1\. Thus, site-local
    addresses begin with FE, and then 8 to B for the third hexadecimal digit. So,
    these addresses start with FE8, FE9, FEA, or FEB.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** IPv6 site-local addresses allow data to be sent only to the
    devices within a site or organization. They begin with FEC, FED, FEE, or FEF in
    hexadecimal. IPv6 link-loca laddresses are used only on a particular local link
    (physical network), typically for special purposes such as address resolution
    or Neighbor Discovery (ND). They start with FE8, FE9, FEA, or FEB.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that site-local IPv6 addresses are the equivalent of IPv4 private addresses,
    since they are routed throughout the organization. The concept of link-local scope
    is new to IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6/IPv4 Address Embedding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the importance of IP and the significance of the changes made in IPv6,
    deployment of the newer version of the protocol will not occur all at once. A
    *transition* from IPv4 to IPv6 will be required. This transition requires careful
    planning. It is anticipated that the migration from IPv4 to IPv6 will take many
    years, as I mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 is backward-compatible with IPv4 provided that you use special techniques.
    For example, to enable communication between islands of IPv6 devices connected
    by IPv4 networks, you may need to employ tunneling. To support IPv4/IPv6 compatibility,
    a scheme was developed to allow IPv4 addresses to be *embedded* within the IPv6
    address structure. This method takes regular IPv4 addresses and puts them in a
    special IPv6 format, so that they are recognized as being IPv4 addresses by certain
    IPv6 devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the IPv6 address space is so much bigger than the one in IPv4, embedding
    the latter within the former is easy—it''s like tucking a compact sedan into the
    hold of a cargo ship! The embedding address space is part of the reserved address
    block whose addresses begin with eight 0 bits, but it''s only a relatively small
    part. Two different embedding formats are used to indicate the capabilities of
    the device that''s using the embedded address:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IPv4-Compatible IPv6 Addresses** These are special addresses assigned to
    IPv6-capable devices, such as *dual-stack* devices that use both IPv4 and IPv6\.
    They have all zeros for the middle 16 bits; thus, they start off with a string
    of 96 zeros, followed by the IPv4 address. An example of such an address would
    be 0:0:0:0:0:0:101.45.75.219 in mixed notation, or more succinctly, ::101.45.75.219\.
    [Figure 25-6](ch25s07.html#ipv4-compatible_embedded_ipv6_address_re "Figure 25-6. IPv4-compatible
    embedded IPv6 address representation") illustrates IPv4-compatible IPv6 representation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IPv4-Mapped IPv6 Addresses** These are regular IPv4 addresses that have been
    mapped into the IPv6 address space. They are used for devices that are IPv4-capable
    only. They have a set of 16 ones after the initial string of 80 zeros and then
    the IPv4 address. So if an IPv4 device has the address 222.1.41.90, such as the
    one shown in [Figure 25-7](ch25s07.html#ipv4-mapped_embedded_ipv6_address_repres
    "Figure 25-7. IPv4-mapped embedded IPv6 address representation"), it would be
    represented as 0:0:0:0:0:FFFF:222.1.41.90, or ::FFFF:222.1.41.90.'
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv4-compatible embedded IPv6 address representation](httpatomoreillycomsourcenostarchimages287879.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-6. IPv4-compatible embedded IPv6 address representation
  prefs: []
  type: TYPE_NORMAL
- en: The difference between these two is subtle but important. Both have zeros for
    the first 80 bits of the address and put the embedded IPv4 address into the last
    32 bits of the IPv6 address format. They differ in the value of the 16 remaining
    bits in between (bits 81 to 96, counting from the left). IPv4-compatible IPv6
    addresses are used only for devices that are actually IPv6-aware; the IPv4-compatible
    address is in addition to its conventional IPv6 address. In contrast, if the FFFF
    is seen for the 16 bits after the initial 80, this designates a conventional IPv4
    devices whose IPv4 address has been mapped into the IPv6 format. It is not an
    IPv6-capable device.
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv4-mapped embedded IPv6 address representation](httpatomoreillycomsourcenostarchimages287881.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-7. IPv4-mapped embedded IPv6 address representation
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *IPv4 address embedding* is used to create a relationship between
    an IPv4 address and an IPv6 address to help you transition from IPv4 to IPv6\.
    One type, the *IPv4-compatible IPv6 address*, is used for devices that are compatible
    with both IPv4 and IPv6; it begins with 96 zero bits. The other, the *IPv4-mapped
    address*, is used for mapping IPv4 devices that are not compatible with IPv6 into
    the IPv6 address space; it begins with 80 zeros followed by 16 ones.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Multicast and Anycast Addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most significant modifications in the general addressing model in
    IPv6 was a change to the basic types of addresses and how they were used. Unicast
    addresses are still the choice for the vast majority of communications as in IPv4,
    but the "bulk" addressing methods are different in IPv6\. Broadcast as a specific
    addressing type has been eliminated. Instead, support for multicast addressing
    has been expanded and made a required part of the protocol, and a new type of
    addressing called *anycast* has been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Multicast Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by looking at multicast under IPv6\. Multicasting is used to allow
    a single device to send a datagram to a group of recipients. IPv4 supported multicast
    addressing using the Class D address block in the classful addressing scheme (see
    [Chapter 17](ch17.html "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING")). Under
    IPv6, multicast addresses are allocated from the multicast block. This is 1/256th
    of the address space, and it consists of all addresses that begin with 1111 1111\.
    Thus, any address starting with FF in colon hexadecimal notation is an IPv6 multicast
    address.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining 120 bits of address space are enough to allow the definition of,
    well, a gazillion or three multicast addresses. (OK, it's officially about 1.3
    trillion trillion trillion addresses.) The allocation of unicast addresses was
    organized by using a special format to divide these many bits, and the same thing
    was done for multicast addresses. The format for multicast addresses is explained
    in [Table 25-6](ch25s08.html#ipv_multicast_address_format "Table 25-6. IPv6 Multicast
    Address Format") and illustrated in [Figure 25-8](ch25s08.html#ipv6_multicast_address_format
    "Figure 25-8. IPv6 multicast address format").
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv6 multicast address format](httpatomoreillycomsourcenostarchimages287883.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-8. IPv6 multicast address format
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-6. IPv6 Multicast Address Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bits) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (Indicator) | 8 | The first eight bits are always 1111 1111, which indicates
    a multicast address. This used to be called the *format prefix* before the term
    was dropped (as explained in the section about IPv6 address space allocation earlier
    in this chapter). The field now has no name. |'
  prefs: []
  type: TYPE_TB
- en: '| Flags | 4 | Four bits are reserved for flags that can be used to indicate
    the nature of certain multicast addresses. Currently, the first three of these
    are unused and set to zero. The fourth is the T (Transient) flag. If left as zero,
    this marks the multicast address as a permanently assigned, well-known multicast
    address, as you will see shortly. If set to one, this means this is a *transient*
    multicast address, meaning that it is not permanently assigned. |'
  prefs: []
  type: TYPE_TB
- en: '| Scope ID | 4 | These four bits are used to define the scope of the multicast
    address; 16 different values from 0 to 15 are possible. This field allows creation
    of multicast addresses that are global to the entire Internet, or restricted to
    smaller spheres of influence such as a specific organization, site, or link. The
    currently defined values (in decimal) are as follows:0 = Reserved1 = Node-Local
    Scope 2 = Link-Local Scope5 = Site-Local Scope8 = Organization-Local Scope14 =
    Global Scope15 = Reserved |'
  prefs: []
  type: TYPE_TB
- en: '| Group ID | 112 | Defines a particular group within each scope level. |'
  prefs: []
  type: TYPE_TB
- en: Multicast Scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The notion of explicitly scoping multicast addresses is important. Globally
    scoped multicast addresses must be unique across the entire Internet, but locally
    scoped addresses are unique only within the organization. This provides tremendous
    flexibility, as every type of multicast address actually comes in several versions:
    one that multicasts only within a node, one that multicasts on the local link
    (local network), one that multicasts on the local site, and so on. The scope also
    allows routers to immediately determine how broadly they should propagate multicast
    datagrams in order to improve efficiency and eliminate problems with traffic being
    sent outside the are a for which it is intended. [Figure 25-9](ch25s08.html#ipv6_multicast_scope_this_diagram_shows_
    "Figure 25-9. IPv6 multicast scope This diagram shows how the notion of scope
    allows IPv6 multicasts to be limited to specific spheres of influence. The tightest
    scope is node-local scope, with a scope ID value of 1\. As the scope ID value
    increases, the scope expands to cover the local network, site, organization, and
    finally, entire Internet.") illustrates the notion of multicast scope graphically.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Multicast addresses are used to send data to a number of devices
    on an internetwork simultaneously. In IPv6, each multicast address can be specified
    for a variety of different scopes, thereby allowing a transmission to be targeted
    to either a wide or a narrow audience of recipient devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv6 multicast scope This diagram shows how the notion of scope allows IPv6
    multicasts to be limited to specific spheres of influence. The tightest scope
    is node-local scope, with a scope ID value of 1\. As the scope ID value increases,
    the scope expands to cover the local network, site, organization, and finally,
    entire Internet.](httpatomoreillycomsourcenostarchimages287885.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-9. IPv6 multicast scope This diagram shows how the notion of scope
    allows IPv6 multicasts to be limited to specific spheres of influence. The tightest
    scope is node-local scope, with a scope ID value of 1\. As the scope ID value
    increases, the scope expands to cover the local network, site, organization, and
    finally, entire Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Well-Known Multicast Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Transient flag allows for the explicit determination of which multicast
    addresses are available for normal use compared to which ones are set aside as
    well known. Several well-known multicast addresses are defined by setting aside
    certain group IDs that are used for a number of different scope ID values. [Table 25-7](ch25s08.html#important_ipv_well-known_multicast_addre
    "Table 25-7. Important IPv6 Well-Known Multicast Addresses") shows these values;
    the *x* in the multicast address pattern is the hexadecimal digit corresponding
    to the four-bit scope ID field.
  prefs: []
  type: TYPE_NORMAL
- en: The all-nodes and all-routers multicast addresses enable the equivalent function
    of what broadcast used to perform in IPv4\. Again, the concept of scope is important
    in a multicast of this type, because we don't want to try to send a message to
    all nodes on the global Internet, for example. So when the all-routers address
    is used with a scope value of 2, it means "all routers on the local link." If
    it is used with a value of 5, it means "all routers in this site."
  prefs: []
  type: TYPE_NORMAL
- en: Solicited-Node Multicast Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the regular multicast addresses, each unicast address has a special
    multicast address called its *solicited-node address*. This address is created
    through a special mapping from the device's unicast address. Solicited-node addresses
    are used by the IPv6 ND protocol (see [Chapter 36](ch36.html "Chapter 36. IPV6
    NEIGHBOR DISCOVERY (ND) PROTOCOL")) to provide more efficient address resolution
    than the Address Resolution Protocol (ARP; see [Chapter 13](ch13.html "Chapter 13. ADDRESS
    RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")) technique used
    in IPv4.
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-7. Important IPv6 Well-Known Multicast Addresses
  prefs: []
  type: TYPE_NORMAL
- en: '| Multicast Address Pattern | Valid Scope Values (Decimal) | Designation |
    Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| FF0x:0:0:0:0:0:0 | 0 to 15 | Reserved | All multicast addresses where the
    112-bit group ID is zero are reserved. |'
  prefs: []
  type: TYPE_TB
- en: '| FF0x:0:0:0:0:0:1 | 1, 2 | All Nodes | When the group ID is equal to exactly
    1, this is a multicast to all nodes. Both node-local (FF01:0:0:0:0:0:1) and link-local
    (FF02:0:0:0:0:0:1) all-nodes multicast addresses are possible. |'
  prefs: []
  type: TYPE_TB
- en: '| FF0x:0:0:0:0:0:2 | 1, 2, 5 | All Routers | When the group ID is equal to
    exactly 2, this designates all routers within a specific scope as the recipients.
    Valid scope values are node-local, link-local, and site-local. |'
  prefs: []
  type: TYPE_TB
- en: 'All solicited-node addresses have their T flag set to zero and a scope ID of
    2, so they start with FF02\. The 112-bit group ID is broken down as follows (see
    [Figure 25-10](ch25s08.html#ipv6_solicited-node_address_calculation_ "Figure 25-10. IPv6
    solicited-node address calculation The solicited-node multicast address is calculated
    from a unicast address by taking the last 24 bits of the address and prepending
    them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows the example address
    from Figure 25-2 converted to its solicited-node address, FF02::1:FFC8:1FFF.")):'
  prefs: []
  type: TYPE_NORMAL
- en: Eighty bits consisting of 79 zeros followed by a single one. This means that
    the next five hexadecimal values are 0000:0000:0000:0000:0001 in colon hexadecimal
    notation, or more succinctly, 0:0:0:0:1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eight ones: FF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twenty-four bits taken from the bottom 24 bits of its unicast address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, these addresses start with FF02:0:0:0:0:1:FF, followed by the bottom 24
    bits of the unicast address. Thus, the node with IP address 805B:2D9D:DC28:0:0:FC57:D4C8:1FFF
    would have a solicited-node address of FF02:0:0:0:0:1:FFC8:1FFF (or FF02::1:FFC8:1FFF).
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv6 solicited-node address calculation The solicited-node multicast address
    is calculated from a unicast address by taking the last 24 bits of the address
    and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This shows
    the example address from converted to its solicited-node address, FF02::1:FFC8:1FFF.](httpatomoreillycomsourcenostarchimages287887.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-10. IPv6 solicited-node address calculation The solicited-node multicast
    address is calculated from a unicast address by taking the last 24 bits of the
    address and prepending them with the IPv6 partial address FF02:0:0:0:0:1:FF. This
    shows the example address from [Figure 25-2](ch25s02.html#binary_decimal_and_hexadecimal_represent
    "Figure 25-2. Binary, decimal, and hexadecimal representations of IPv6 addresses
    The top two rows show binary and dotted decimal representations of an IPv6 address;
    neither is commonly used (other than by computers themselves!). The top row of
    the lower table shows the full hexadecimal representation, while the next two
    rows illustrate zero suppression and compression. The last row shows mixed notation,
    with the final 32 bits of an IPv6 address shown in dotted decimal notation (212.200.31.255).
    This is most commonly used for embedded IPv4 addresses.") converted to its solicited-node
    address, FF02::1:FFC8:1FFF.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each unicast address has an equivalent *solicited-node multicast
    address* that is created from the unicast address and used when other devices
    need to reach it on the local network.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Anycast Addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anycast addresses are a unique type of address that is new to IP in IPv6\. The
    IPv6 implementation is based on the material in RFC 1546, "Host Anycasting Service."
    Anycast addresses can be considered a conceptual cross between unicast and multicast
    addressing. Where unicast says, "Send this to one address," and multicast says,
    "Send this to every member of this group," anycast says, "Send this to any one
    member of this group." Naturally, in choosing which member to send to, we would,
    for efficiency, normally send to the closest one—that is, the closest in routing
    terms. So, we can normally also consider *anycast* to mean, "Send this to the
    closest member of this group."
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind anycast is to enable functionality that was previously difficult
    to implement in TCP/IP. Anycast was specifically intended to provide flexibility
    in situations where we need a service that is provided by a number of different
    servers or routers but don't really care which one provides it. In routing, anycast
    allows datagrams to be sent to whichever router in a group of equivalent routers
    is closest, and to allow load sharing among routers and dynamic flexibility if
    certain routers go out of service. Datagrams sent to the anycast address will
    automatically be delivered to the device that is easiest to reach.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps surprisingly, there is no special anycast-addressing scheme. Anycast
    addresses are the same as unicast addresses. An anycast address is created automatically
    when a unicast address is assigned to more than one interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Anycast addresses are new in IPv6 and can be used to set up
    a group of devices, any one of which can respond to a request sent to a single
    IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: Like multicast, anycast creates more work for routers, because it is more complicated
    than unicast addressing. In particular, the further apart the devices that share
    the anycast address are, the more complexity. Anycasting across the global Internet
    would be potentially difficult to implement, and IPv6 anycasting was designed
    for devices that are proximate to each other, generally within the same network.
    Also, at present, due to the Internet community's relative inexperience with anycast,
    only routers, not individual hosts, use anycast addresses.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Autoconfiguration and Renumbering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting and potentially valuable addressing features implemented
    in IPv6 is a facility that allows devices on an IPv6 network to actually configure
    themselves independently. In IPv4, hosts were originally configured manually.
    Later, host configuration protocols like the Dynamic Host Configuration Protocol
    (DHCP; see [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION
    CONCEPTS")) enabled servers to allocate IP addresses to hosts that joined the
    network. IPv6 takes this a step further by defining a method for some devices
    to automatically configure their IP address and other parameters without the need
    for a server. It also defines a method whereby the IP addresses on a network can
    be renumbered (changed en masse). These are the sorts of features that make TCP/IP
    network administrators drool.
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 autoconfiguration and renumbering feature is defined in RFC 2462, "IPv6
    Stateless Address Autoconfiguration." The word *stateless* contrasts this method
    to the server-based method using something like DHCPv6, which is called *stateful*.
    (This word, like *classful*, makes me cringe.) This method is called stateless
    because it begins with no information (or *state*) at all for the host to work
    with. It has no need for a DHCP server.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Stateless Autoconfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stateless autoconfiguration exploits several other new features in IPv6, including
    link-local addresses, multicasting, the ND protocol, and the ability to generate
    the interface ID of an address from the underlying data link layer address. The
    general idea is to have a device generate a temporary address until it can determine
    the characteristics of the network it is on, and then create a permanent address
    it can use based on that information. In the case of multihomed devices, autoconfiguration
    is performed for each interface separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a summary of the steps a device takes when using stateless
    autoconfiguration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link-Local Address Generation** The device generates a link-local address.
    You''ll recall that this is one of the two types of local-use IPv6 addresses.
    Link-local addresses have 1111 1110 10 for the first 10 bits. The generated address
    uses those 10 bits, followed by 54 zeros and then the 64-bit interface ID. Typically,
    this will be derived from the data link layer (MAC) address as explained in the
    "IPv6 Interface Identifiers and Physical Address Mapping" section earlier in this
    chapter, or it may be a "token" generated in some other manner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link-Local Address Uniqueness Test** The node tests to ensure that the address
    it generated isn''t already in use on the local network. (This is very unlikely
    to be an issue if the link-local address came from a MAC address; it is more likely
    that the address is already in use if it was based on a generated token.) It sends
    a Neighbor Solicitation message using the ND protocol. In response, it listens
    for a Neighbor Advertisement, which indicates that another device is already using
    its link-local address. If so, either a new address must be generated or autoconfiguration
    fails, and another method must be employed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Link-Local Address Assignment** Assuming the uniqueness test passes, the
    device assigns the link-local address to its IP interface. This address can be
    used for communication on the local network, but not on the wider Internet (since
    link-local addresses are not routed).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Router Contact** The node next attempts to contact a local router for more
    information on continuing the configuration. This is done either by listening
    for Router Advertisement messages sent periodically by routers or by sending a
    specific Router Solicitation message to ask a router for information on what to
    do next. This process is described in the section on the IPv6 ND protocol, in
    [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL").'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Router Direction** The router provides direction to the node about how to
    proceed with the autoconfiguration. It may tell the node that on this network
    stateful autoconfiguration is in use, and it may give it the address of a DHCP
    server to use. Alternatively, it will tell the host how to determine its global
    Internet address.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Global Address Configuration** Assuming that stateless autoconfiguration
    is in use on the network, the host will configure itself with its globally unique
    Internet address. This address is generally formed from a network prefix provided
    to the host by the router. The prefix is combined with the device''s identifier,
    as generated in step 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clearly, this method has numerous advantages over both manual and server-based
    configuration. It is particularly helpful in supporting the mobility of IP devices,
    because they can move to new networks and get a valid address without any knowledge
    of local servers or network prefixes. At the same time, it still allows for the
    management of IP addresses using the (IPv6-compatible) version of DHCP, if that
    is desired. Routers on the local network will typically tell hosts which type
    of autoconfiguration is supported using special flags in Internet Control Message
    Protocol version 6 (ICMPv6) Router Advertisement messages (see [Chapter 35](ch35.html
    "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS")).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** IPv6 includes an interesting feature called *stateless address
    autoconfiguration*, which allows a host to actually determine its own IPv6 address
    from its layer 2 address by following a special procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Device Renumbering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The renumbering of devices is a method related to autoconfiguration. Like host
    configuration, it can be implemented using protocols like DHCP through the use
    of IP address leases that expire after a period of time. Under IPv6, networks
    can be renumbered by having routers specify an expiration interval for network
    prefixes when autoconfiguration is done. Later, they can send a new prefix to
    tell devices to regenerate their IP addresses. Devices can actually maintain the
    old deprecated address for a while, and then move over to the new address.
  prefs: []
  type: TYPE_NORMAL
- en: RFC 2894 defined a similar technique for renumbering router addresses. It uses
    special ICMPv6 messages and is described in [Chapter 35](ch35.html "Chapter 35. ICMPV6
    INFORMATIONAL MESSAGE TYPES AND FORMATS").
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delivery of data over Internet Protocol version 6 (IPv6) internetworks is accomplished
    by encapsulating higher-layer data into IPv6 datagrams. These serve the same general
    purpose for IPv6 as IPv4 datagrams do in the older version of the protocol. However,
    they have been redesigned as part of the overall changes represented by IPv6\.
    IPv6 datagrams have a flexible structure, and their format better matches the
    needs of current IP networks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I take a look at the format used for IPv6 datagrams. I begin
    with an overview of the general structure of IPv6 datagrams, describe the major
    changes, and show how main and extension headers are arranged in the datagram.
    I then describe the format of the main header, and define and describe the various
    extension header types. I conclude with a brief explanation of IPv6 options and
    how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *This chapter assumes basic understanding of IPv6
    addressing concepts (see the previous chapter) and general familiarity with the
    IPv4 datagram format (described in [Chapter 21](ch21.html "Chapter 21. INTERNET
    PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING"))*.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Datagram Overview and General Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method by which IPv6 encapsulates data received from higher-layer protocols
    for transmission across the internetwork is basically the same as the one used
    by IPv4\. The data received from the transport or higher layers is made the payload
    of an IPv6 datagram, which has one or more headers that control the delivery of
    the message. These headers provide information to routers in order to enable them
    to move the datagram across the network. They also provide information to hosts
    so they can tell which datagrams they are intended to receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the basic use of datagrams hasn''t changed since IPv4, many modifications
    were made to their structure and format when IPv6 was created. This was done partly
    out of necessity: IPv6 addresses are different from IPv4 addresses, and IP addresses
    go in the datagram header. The increase in the size of IP addresses from 32 bits
    to 128 bits adds a whopping extra 192 bits, or 24 bytes, of information to the
    header. This led to an effort to remove fields that weren''t strictly necessary
    in order to compensate for the necessary increase in size. However, changes were
    also made to IPv6 datagrams to add features to them and to make them better suit
    the needs of modern internetworking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the most significant overall changes to datagrams
    in IPv6:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple-Header Structure** Rather than a single header that contains all
    fields for the datagram (possibly including options), the IPv6 datagram supports
    a main header and then extension headers for additional information when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Streamlined Header Format** Several fields have been removed from the main
    header to reduce its size and increase efficiency. Only the fields that are truly
    required for pretty much *all* datagrams remain in the main header; others are
    put into extension headers and used as needed. Some were removed because they
    were no longer needed, such as the Internet Header Length field. The IPv6 header
    is of fixed length. I''ll examine this more thoroughly in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Renamed Fields** Some fields have been renamed to better reflect their actual
    use in modern networks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Greater Flexibility** The extension headers allow for a great deal of extra
    information that will accompany datagrams when needed. Options are also supported
    in IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elimination of Checksum Calculation** In IPv6, a checksum is no longer computed
    on the header. This saves both the calculation time spent by every device that
    packages IP datagrams (hosts and routers) and the space the checksum field took
    up in the IPv4 header.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved Quality of Service Support** A new field, the Flow Label, is defined
    to help support the prioritization of traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** IPv6 datagrams use a general structure that begins with a mandatory
    main header that''s 40 bytes in length, followed by optional extension headers,
    and then a variable-length Data area. This structure was created to allow the
    main header to be streamlined, while allowing devices to add extra information
    to datagrams when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, IPv6 datagrams now include a main header format (which
    has no official name in the standards; it's just "the header") and zero or more
    extension headers. The overall structure of an IPv6 datagram is shown in [Table 26-1](ch26.html#ipv_general_datagram_structure
    "Table 26-1. IPv6 General Datagram Structure") and illustrated in [Figure 26-1](ch26.html#ipv6_general_datagram_structure
    "Figure 26-1. IPv6 general datagram structure").
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-1. IPv6 General Datagram Structure
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Number of Components per Datagram | Size (Bytes) | Description
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Main Header | 1 | 40 | Contains the source and destination addresses, and
    important information that''s required for every datagram. |'
  prefs: []
  type: TYPE_TB
- en: '| Extension Headers | 0 or more | Variable | Each contains one type of extra
    information that supports various features, including fragmentation, source routing,
    security, and options. |'
  prefs: []
  type: TYPE_TB
- en: '| Data | 1 | Variable | The payload from the upper layer that will be transmitted
    in the datagram. |'
  prefs: []
  type: TYPE_TB
- en: '![IPv6 general datagram structure](httpatomoreillycomsourcenostarchimages287889.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-1. IPv6 general datagram structure
  prefs: []
  type: TYPE_NORMAL
- en: Note that as with IPv4, large payloads may be fragmented prior to encapsulation
    in order to ensure that the total size of the datagram doesn't exceed the maximum
    size permitted on an underlying network. However, the details of fragmentation
    in IPv6 are different than in IPv4, as explained in [Chapter 27](ch27.html "Chapter 27. IPV6
    DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING").
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Datagram Main Header Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IPv6 datagrams use a structure that includes a regular header and, optionally,
    one or more extension headers. This regular header is like the header of IPv4
    datagrams, though it has a different format, as you will see shortly. The standards
    don't give this header a name; it is just "*the* IPv6 header." To differentiate
    it from IPv6 extension headers, I call it the *main header*.
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 main header is required for every datagram. It contains addressing
    and control information that are used to manage the processing and routing of
    the datagram. The main header format of IPv6 datagrams is described in [Table 26-2](ch26s02.html#ipv_main_header_format
    "Table 26-2. IPv6 Main Header Format") and illustrated in [Figure 26-2](ch26s02.html#ipv6_main_header_format
    "Figure 26-2. IPv6 main header format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-2. IPv6 Main Header Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1/2 (4 bits) | This identifies the version of IP that''s used to
    generate the datagram. This field is used the same way as in IPv4, except that
    it carries the value 6 (0110 binary). |'
  prefs: []
  type: TYPE_TB
- en: '| Traffic Class | 1 | This field replaces the Type of Service (TOS) field in
    the IPv4 header. It is used not in the original way that the TOS field was defined
    (with Precedence, D, T, and R bits), but rather, using the new Differentiated
    Services (DS) method defined in RFC 2474\. That RFC actually specifies quality-of-service
    (QoS) techniques for both IPv4 and IPv6; see the IPv4 format description ([Chapter 21](ch21.html
    "Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING")) for a
    bit more information. |'
  prefs: []
  type: TYPE_TB
- en: '| Flow Label | 2 1/2 (20 bits) | This large field was created to provide additional
    support for real-time datagram delivery and QoS features. The concept of a flow
    is defined in RFC 2460 as a sequence of datagrams sent from a source device to
    one or more destination devices. A unique flow label is used to identify all the
    datagrams in a particular flow, so that routers between the source and destination
    all handle them the same way. This helps to ensure uniformity in how the datagrams
    in the flow are delivered. For example, if a video stream is being sent across
    an IP internetwork, the datagrams containing the stream could be identified with
    a flow label to ensure that they are delivered with minimal latency. Not all devices
    and routers may support flow label handling, and the use of the field by a source
    device is entirely optional. Also, the field is still somewhat experimental and
    may be refined over time. |'
  prefs: []
  type: TYPE_TB
- en: '| Payload Length | 2 | This field replaces the Total Length field from the
    IPv4 header, but it is used differently. Rather than measuring the length of the
    whole datagram, it contains only the number of bytes of the payload. However,
    if extension headers are included, their length is counted here as well. In simpler
    terms, this field measures the length of the datagram less the 40 bytes of the
    main header itself. |'
  prefs: []
  type: TYPE_TB
- en: '| Next Header | 1 | This field replaces the Protocol field and has two uses.
    When a datagram has extension headers, this field specifies the identity of the
    first extension header, which is the next header in the datagram. When a datagram
    has just this "main" header and no extension headers, it serves the same purpose
    as the old IPv4 Protocol field and has the same values, though new numbers are
    used for the IPv6 versions of common protocols. In this case the "next header"
    is the header of the upper layer message the IPv6 datagram is carrying. I''ll
    discuss this in more detail a bit later in this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| Hop Limit | 1 | This replaces the Time to Live (TTL) field in the IPv4 header;
    its name better reflects the way that TTL is used in modern networks (because
    TTL is really used to count hops, not time). |'
  prefs: []
  type: TYPE_TB
- en: '| Source Address | 16 | The 128-bit IP address of the originator of the datagram.
    As with IPv4, this is always the device that originally sent the datagram. |'
  prefs: []
  type: TYPE_TB
- en: '| Destination Address | 16 | The 128-bit IP address of the intended recipient
    of the datagram: unicast, anycast, or multicast. Again, even though devices such
    as routers may be the intermediate targets of the datagram, this field is always
    for the ultimate destination. |'
  prefs: []
  type: TYPE_TB
- en: '![IPv6 main header format](httpatomoreillycomsourcenostarchimages287891.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-2. IPv6 main header format
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Next Header Field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Next Header field is one of the most important additions to the IPv6 datagram
    format. When an IPv6 datagram uses extension headers, this field contains an identifier
    for the first extension header, which, in turn, uses its own Next Header field
    to point to the next header, and so on. The last extension header then references
    the encapsulated higher-layer protocol. Because the higher-layer protocol's header
    appears at the start of the IPv6 Data field, it is like the "next header" to the
    device receiving the datagram. For some folks, this is a bit tough to see conceptually;
    you can find more detail on how the field works (including a useful illustration,
    [Figure 26-3](ch26s03.html#ipv6_extension_header_linking_using_the_ "Figure 26-3. IPv6
    extension header linking using the Next Header field The Next Header field allows
    a device to more easily process the headers in a received IPv6 datagram. When
    a datagram has no extension headers, the "next header" is actually the header
    at the start of the IP Data field, which, in this case, is a TCP header with a
    value of 6\. This is the same way the Protocol field is used in IPv4\. When extension
    headers do appear, the Next Header value of each header contains a number indicating
    the type of the following header in the datagram, so they logically chain together
    the headers.")) in the "IPv6 Header Chaining Using the Next Header Field" section
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most common values for the Next Header field in IPv6 are shown in
    [Table 26-3](ch26s02.html#common_ipv_next_header_values "Table 26-3. Common IPv6
    Next Header Values").
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-3. Common IPv6 Next Header Values
  prefs: []
  type: TYPE_NORMAL
- en: '| Value (Hexadecimal) | Value (Decimal) | Protocol/Extension Header |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00 | 0 | Hop-By-Hop Options Extension Header (Note that this value was "Reserved"
    in IPv4) |'
  prefs: []
  type: TYPE_TB
- en: '| 01 | 1 | Internet Control Message Protocol version 4 (ICMPv4) |'
  prefs: []
  type: TYPE_TB
- en: '| 02 | 2 | Internet Group Management Protocol version 4 (IGMPv4) |'
  prefs: []
  type: TYPE_TB
- en: '| 04 | 4 | IP-in-IP Encapsulation |'
  prefs: []
  type: TYPE_TB
- en: '| 06 | 6 | Transmission Control Protocol (TCP) |'
  prefs: []
  type: TYPE_TB
- en: '| 08 | 8 | Exterior Gateway Protocol (EGP) |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 17 | User Datagram Protocol (UDP) |'
  prefs: []
  type: TYPE_TB
- en: '| 29 | 41 | IPv6 |'
  prefs: []
  type: TYPE_TB
- en: '| 2B | 43 | Routing Extension Header |'
  prefs: []
  type: TYPE_TB
- en: '| 2C | 44 | Fragmentation Extension Header |'
  prefs: []
  type: TYPE_TB
- en: '| 2E | 46 | Resource Reservation Protocol (RSVP) |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | 50 | Encrypted Security Payload (ESP) Extension Header |'
  prefs: []
  type: TYPE_TB
- en: '| 33 | 51 | Authentication Header (AH) Extension Header |'
  prefs: []
  type: TYPE_TB
- en: '| 3A | 58 | ICMPv6 |'
  prefs: []
  type: TYPE_TB
- en: '| 3B | 59 | No Next Header |'
  prefs: []
  type: TYPE_TB
- en: '| 3C | 60 | Destination Options Extension Header |'
  prefs: []
  type: TYPE_TB
- en: The total length of the main IPv6 header format is 40 bytes. This is double
    the size of the IPv4 header without options, largely because of the extra 24 bytes
    needed for the monstrous IPv6 addresses. There are only 8 bytes of nonaddress
    header fields in the IPv6 main header, compared to 12 in the IPv4 header.
  prefs: []
  type: TYPE_NORMAL
- en: Key Changes to the Main Header Between IPv4 and IPv6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize, the IPv6 main header compares to the IPv4 header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unchanged Fields** Three fields are used the same way, and they retain the
    same name (though they have different content and/or size): Version, Source Address,
    and Destination Address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Renamed Fields** Two fields are used the same way, but they are renamed:
    Traffic Class and Hop Limit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified Fields** Two fields are used in a way similar way to their IPv4
    predecessors, but they are slightly different in meaning and also renamed: Payload
    Length and Next Header.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Added Field** There is one new field: Flow Label.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Removed Fields** To cut down on header length and unnecessary work, five
    IPv4 header fields are removed from the IPv6 header:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Internet Header Length* field is no longer needed, because the main IPv6
    header is fixed in length at 40 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Identification, Flags*, and *Fragment Offset* fields are used for fragmentation,
    which is done less in IPv6 than IPv4, so these fields are now found only when
    needed in the Fragmentation extension header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Header Checksum* field is no longer needed, because the decision was made
    to eliminate header checksum calculations in IPv6\. It was viewed as redundant
    with higher-layer error-checking and data link layer CRC calculations. This saves
    processing time for routers and 2 bytes in the datagram header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, while options were formerly considered part of the main header
    in IPv4, they are separate in IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Datagram Extension Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the mandatory main header in an IPv6 datagram, one or more extension headers
    may appear before the encapsulated payload. These headers were created in an attempt
    to provide both flexibility and efficiency in the creation of IPv6 datagrams.
    All the fields that are needed for only special purposes are put into extension
    headers and placed in the datagram when needed. This allows the size of the main
    datagram header to be made small and streamlined, containing only those fields
    that really must be present all the time.
  prefs: []
  type: TYPE_NORMAL
- en: There is often confusion regarding the role of extension headers, especially
    when compared to datagram options. The IPv4 datagram had only one header, but
    it included a provision for options, and IPv6 also has options, so why bother
    with extension headers?
  prefs: []
  type: TYPE_NORMAL
- en: It would have been possible to do everything using options. However, it was
    deemed a better design to employ extension headers for certain sets of information
    that are needed for common functions such as fragmenting. Options are indeed still
    supported in IPv6; they are used to supply even more flexibility by providing
    variable-length fields that can be used for any purpose. They are themselves defined
    using extension headers, as you will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: When extension headers are included in an IPv6 datagram, they appear one after
    the other following the main header. Each extension header type has its own internal
    structure of fields.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Header Chaining Using the Next Header Field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only field common to all extension header types is the Next Header field,
    which actually appears at the end of one header type, the ESP header. The 8-bit
    Next Header field is used to logically link all the headers in an IPv6 datagram,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Next Header field in the main header contains a reference number for the
    first extension header type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Next Header field in the first extension header contains the number of the
    second extension header type, if there is a second one. If there's a third, the
    second header's Next Header points to it, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Next Header field of the last extension header contains the protocol number
    of the encapsulated higher-layer protocol. In essence, this field points to the
    "next header" within the payload itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, suppose a datagram that encapsulates TCP has a Hop-By-Hop Options
    extension header and a Fragment extension header. Then, the Next Header fields
    of these headers would contain the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: The main header would have a Next Header value of 0, indicating the Hop-By-Hop
    Options header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hop-By-Hop Options header would have a Next Header value of 44 (decimal),
    which is the value for the Fragment extension header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Fragment header would have a Next Header value of 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is illustrated in [Figure 26-3](ch26s03.html#ipv6_extension_header_linking_using_the_
    "Figure 26-3. IPv6 extension header linking using the Next Header field The Next
    Header field allows a device to more easily process the headers in a received
    IPv6 datagram. When a datagram has no extension headers, the "next header" is
    actually the header at the start of the IP Data field, which, in this case, is
    a TCP header with a value of 6\. This is the same way the Protocol field is used
    in IPv4\. When extension headers do appear, the Next Header value of each header
    contains a number indicating the type of the following header in the datagram,
    so they logically chain together the headers.").
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv6 extension header linking using the Next Header field The Next Header
    field allows a device to more easily process the headers in a received IPv6 datagram.
    When a datagram has no extension headers, the "next header" is actually the header
    at the start of the IP Data field, which, in this case, is a TCP header with a
    value of 6\. This is the same way the Protocol field is used in IPv4\. When extension
    headers do appear, the Next Header value of each header contains a number indicating
    the type of the following header in the datagram, so they logically chain together
    the headers.](httpatomoreillycomsourcenostarchimages287893.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-3. IPv6 extension header linking using the Next Header field The Next
    Header field allows a device to more easily process the headers in a received
    IPv6 datagram. When a datagram has no extension headers, the "next header" is
    actually the header at the start of the IP Data field, which, in this case, is
    a TCP header with a value of 6\. This is the same way the Protocol field is used
    in IPv4\. When extension headers do appear, the Next Header value of each header
    contains a number indicating the type of the following header in the datagram,
    so they logically chain together the headers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The IPv6 Next Header field is used to chain together the headers
    in an IPv6 datagram. The Next Header field in the main header contains the number
    of the first extension header; its Next Header contains the number of the second,
    and so forth. The last header in the datagram contains the number of the encapsulated
    protocol that begins the Data field.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of IPv6 Extension Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 26-4](ch26s03.html#ipv_extension_headers "Table 26-4. IPv6 Extension
    Headers") lists the different extension headers, showing each one''s Next Header
    value, length, defining RFC, and a brief description of how it is used.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-4. IPv6 Extension Headers
  prefs: []
  type: TYPE_NORMAL
- en: '| Next Header Value (Decimal) | Extension Header Name | Length (Bytes) | Description
    | Defining RFC |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Hop-By-Hop Options | Variable | Defines an arbitrary set of options that
    are intended to be examined by all devices on the path from the source to destination
    device(s). This is one of two extension headers used to define variable-format
    options. | 2460 |'
  prefs: []
  type: TYPE_TB
- en: '| 43 | Routing | Variable | Defines a method for allowing a source device to
    specify the route for a datagram. This header type actually allows the definition
    of multiple routing types. The IPv6 standard defines the Type 0 Routing extension
    header, which is equivalent to the "loose" source routing option in IPv4\. It''s
    used in a similar way. See the "IPv6 Routing Extension Header" section in this
    chapter for the format of this extension header. | 2460 |'
  prefs: []
  type: TYPE_TB
- en: '| 44 | Fragment | 8 | When a datagram contains only a fragment of the original
    message, contains the Fragment Offset, Identification, and More Fragment fields
    that were removed from the main header. See the "IPv6 Fragment Extension Header"
    section in this chapter for the format of this extension header, and the topic
    on fragmentation and reassembly ([Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM
    SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING")) for details on how the fields
    are used. | 2460 |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | Encapsulating Security Payload (ESP) | Variable | Carries encrypted
    data for secure communications. This header is described in detail in [Chapter 29](ch29.html
    "Chapter 29. IP SECURITY (IPSEC) PROTOCOLS"), which covers IPsec. | 2406 |'
  prefs: []
  type: TYPE_TB
- en: '| 51 | Authentication Header (AH) | Variable | Contains information used to
    verify the authenticity of encrypted data. This header is described in detail
    in [Chapter 29](ch29.html "Chapter 29. IP SECURITY (IPSEC) PROTOCOLS"). | 2402
    |'
  prefs: []
  type: TYPE_TB
- en: '| 60 | Destination Options | Variable | Defines an arbitrary set of options
    that are intended to be examined only by the destination(s) of the datagram. This
    is one of two extension headers used to define variable-format options. | 2460
    |'
  prefs: []
  type: TYPE_TB
- en: Note that the Next Header value of the IPv6 main header is 41; that of an IPv4
    header is 4 (its protocol number). There is also a "dummy" extension header called
    No Next Header that has a value of 59\. This is a placeholder that, when found
    in the Next Header field, indicates that there is nothing after that extension
    header.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [Table 26-4](ch26s03.html#ipv_extension_headers "Table 26-4. IPv6
    Extension Headers"), the formats for several of the headers are provided in other
    areas of this book. I will describe two of them here, however: the Routing extension
    header and the Fragment extension header.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Routing Extension Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Routing extension header is used to perform source routing in IPv6\. It
    is described in [Table 26-5](ch26s03.html#ipv_routing_extension_header_format
    "Table 26-5. IPv6 Routing Extension Header Format") and illustrated in [Figure 26-4](ch26s03.html#ipv6_routing_extension_header_format
    "Figure 26-4. IPv6 Routing extension header format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-5. IPv6 Routing Extension Header Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Next Header | 1 | Contains the protocol number of the next header after the
    Routing header. Used to link headers together, as described earlier in this chapter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Hdr Ext Len | 1 | For Header Extension Length, specifies the length of the
    Routing header in 8-byte units, not including the first 8 bytes of the header.
    For a Routing Type field of 0, this value is thus two times the number addresses
    embedded in the header. |'
  prefs: []
  type: TYPE_TB
- en: '| Routing Type | 1 | Allows multiple routing types to be defined; at present,
    the only value used is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Segments Left | 1 | Specifies the number of explicitly named nodes remaining
    in the route until the destination. |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4 | Not used; set to zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| Address1…AddressN | Variable (Multiple of 16) | A set of IPv6 addresses that
    specify the route to be used. |'
  prefs: []
  type: TYPE_TB
- en: '![IPv6 Routing extension header format](httpatomoreillycomsourcenostarchimages287895.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-4. IPv6 Routing extension header format
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Fragment Extension Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fragment extension header is included in fragmented datagrams to provide
    the information that's necessary to allow the fragments to be reassembled. It
    is described in [Table 26-6](ch26s03.html#ipv_fragment_extension_header_format
    "Table 26-6. IPv6 Fragment Extension Header Format") and illustrated in [Figure 26-5](ch26s03.html#ipv6_fragment_extension_header_format
    "Figure 26-5. IPv6 Fragment extension header format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-6. IPv6 Fragment Extension Header Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Next Header | 1 | Contains the protocol number of the next header after the
    Fragment header. Used to link headers together, as described earlier in this chapter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 1 | Not used; set to zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| Fragment Offset | 13/8 (13 bits) | Specifies the offset, or position, in
    the overall message where the data in this fragment goes. It is specified in units
    of 8 bytes (64 bits) and used in a manner very similar to the field of the same
    name in the IPv4 header. |'
  prefs: []
  type: TYPE_TB
- en: '| Res | 1/4 (2 bits) | Not used; set to zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| M Flag | 1/8 (1 bit) | For More Fragments Flag, same as the flag of the same
    name in the IPv4 header. When set to 0, indicates the last fragment in a message;
    when set to 1, indicates that more fragments are yet to come in the fragmented
    message. |'
  prefs: []
  type: TYPE_TB
- en: '| Identification | 4 | Same as the field of the same name in the IPv4 header,
    but expanded to 32 bits. It contains a specific value that is common to each of
    the fragments belonging to a particular message. This ensures that pieces from
    different fragmented messages are not mixed together. |'
  prefs: []
  type: TYPE_TB
- en: '![IPv6 Fragment extension header format](httpatomoreillycomsourcenostarchimages287897.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-5. IPv6 Fragment extension header format
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Extension Header Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each extension header appears only once in any datagram (with one exception,
    as you'll see shortly). Also, only the final recipients of the datagram examine
    extension headers, not intermediate devices (again with one exception, which you
    will see momentarily).
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 2460 specifies that when multiple headers appear, they should be in the
    following order, after the main header and before the higher-layer encapsulated
    header in the IPv6 datagram payload:'
  prefs: []
  type: TYPE_NORMAL
- en: Hop-By-Hop Options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destination Options (for options to be processed by the destination as well
    as devices specified in a Routing header)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fragmentation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication Header
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulating Security Payload
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destination Options (for options processed only by the final destination)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's look at those exceptions. The only header that can appear twice is
    Destination Options. Normally, it appears as the last header. However, the datagram
    may also have a Destination Options header that contains options that must be
    examined by a list of devices specified in a source route, in addition to the
    destination. In this case, the Destination Options header for these options is
    placed before the Routing header. A second such header containing options for
    only the final destination may also appear.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each extension header may appear only once in an IPv6 datagram,
    and each one must appear in a fixed order. The exception is the Destination Options
    header, which may appear twice: near the start of the datagram for options to
    be processed by devices en route to the destination and at the end of the extension
    headers for options intended for only the final destination.'
  prefs: []
  type: TYPE_NORMAL
- en: The only header normally examined by all intermediate devices is the Hop-By-Hop
    Options extension header. It is used specifically to convey management information
    to all routers in a route. The Hop-By-Hop Options extension header must appear
    as the first extension header if present. Since it is the only one that every
    router must read (and this represents a performance drain on routers), it is given
    top billing to make it easier and faster to find and process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that all extension headers must be a multiple of eight bytes in
    length for alignment purposes. Also, remember that the Next Header value for a
    particular extension header appears in the Next Header field of the preceding
    header, not the header itself.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Datagram Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In IPv4, all extra information required for various purposes is placed into
    the datagram in the form of options that appear in the IPv4 header. In IPv6, the
    new concept of extension headers is introduced, as you just saw. These headers
    take the place of many of the predefined IPv4 options. However, the concept of
    options is still maintained in IPv6 for a slightly different purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Options allow the IPv6 datagram to be supplemented with arbitrary sets of information
    that aren't defined in the regular extension headers. They provide maximum flexibility,
    thereby allowing the basic IPv6 protocol to be extended in ways the designers
    never anticipated, with the goal of reducing the chance of the protocol becoming
    obsolete in the future.
  prefs: []
  type: TYPE_NORMAL
- en: I said that IPv6 options supplement extension headers; in fact, they are actually
    implemented as extension headers. There are two different ones used to encode
    options. These two headers differ only in terms of how devices will process the
    options they contain; otherwise, they are formatted the same and used in the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two extension header types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Destination Options** Contains options that are intended only for the ultimate
    destination of the datagram (and perhaps a set of routers in a Routing header,
    if present).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hop-By-Hop Options** Contains options that carry information for every device
    (router) between the source and destination.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these header types has a one-byte Next Header field, and a one-byte
    Header Extension Length field that indicates the header's overall length. The
    rest of the header has one or more option fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 26-6](ch26s04.html#ipv6_hop-by-hop_options_and_destination_ "Figure 26-6. IPv6
    Hop-By-Hop Options and Destination Options header formats Each of these extension
    headers begins with two fixed fields, Next Header and Header Extension Length.
    The rest of the header consists of a sequence of variable-length options. Each
    option has a structure that consists of a type/length/value triplet, shown in
    Table 26-7.") illustrates the overall format of these two headers. The format
    of each option is similar to that of IPv4 options, as shown in Tables [Table 26-7](ch26s04.html#ipv_option_format-id001
    "Table 26-7. IPv6 Option Format") and [Table 26-8](ch26s04.html#ipv_option_type_subfields
    "Table 26-8. IPv6 Option Type Subfields").'
  prefs: []
  type: TYPE_NORMAL
- en: '![IPv6 Hop-By-Hop Options and Destination Options header formats Each of these
    extension headers begins with two fixed fields, Next Header and Header Extension
    Length. The rest of the header consists of a sequence of variable-length options.
    Each option has a structure that consists of a type/length/value triplet, shown
    in .](httpatomoreillycomsourcenostarchimages287899.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-6. IPv6 Hop-By-Hop Options and Destination Options header formats
    Each of these extension headers begins with two fixed fields, Next Header and
    Header Extension Length. The rest of the header consists of a sequence of variable-length
    options. Each option has a structure that consists of a type/length/value triplet,
    shown in [Table 26-7](ch26s04.html#ipv_option_format-id001 "Table 26-7. IPv6 Option
    Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-7. IPv6 Option Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Option Type | 1 | This field indicates the type of option. The bits are interpreted
    according to the sub-subfield" structure, described in [Table 26-8](ch26s04.html#ipv_option_type_subfields
    "Table 26-8. IPv6 Option Type Subfields"). |'
  prefs: []
  type: TYPE_TB
- en: '| Opt Data Len | 1 | Specifies the length of the Option Data subfield. Note
    that this is a change in semantics from IPv4, where the Length field indicated
    the size of the entire option; in IPv6 the length of the Option Type and Option
    Data Length fields are not included. |'
  prefs: []
  type: TYPE_TB
- en: '| Option Data | Variable | The data to be sent as part of the option, which
    is specific to the option type. Also sometimes referred to as the Option Value.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 26-8. IPv6 Option Type Subfields
  prefs: []
  type: TYPE_NORMAL
- en: '| Sub-Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Unrecognized Option Action | 2/8 (2 bits) | The first two bits specify what
    action should be taken if the device processing the option doesn''t recognize
    the Option Type. The four values are as follows:00: Skip option; process rest
    of header.0: Discard datagram; do nothing else.10: Discard datagram and send an
    ICMP Parameter Problem message with code 2 back to the datagram source.11: Discard
    datagram and send the ICMP message as for value 10, only if destination was not
    a multicast address. |'
  prefs: []
  type: TYPE_TB
- en: '| Option Change Allowed Flag | 1/8 (1 bit) | Set to 1 if the Option Data can
    change while the datagram is en route, or left at 0 if it cannot. |'
  prefs: []
  type: TYPE_TB
- en: '| Remainder of Option Type | 5/8 (5 bits) | Five remaining bits that allow
    the specification of 32 different combinations for each combination of the three
    preceding bits. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Option Type subfield is a bit strange in terms of how it is interpreted.
    Even though it has a substructure with three sub-subfields (as shown in [Table 26-8](ch26s04.html#ipv_option_type_subfields
    "Table 26-8. IPv6 Option Type Subfields"), that structure is informal—the eight
    bits of this field are taken as a single entity. Despite the special meaning of
    the three highest-order bits, the entire field is called the Option Type, not
    just the last five bits, and the whole is used as a single value from 0 to 255\.
    In fact, the sub-subfield names aren''t even specified in the standard; I made
    them up*.'
  prefs: []
  type: TYPE_NORMAL
- en: Since each option has a subfield for type, length, and value (data), the options
    are sometimes said to be TLV-encoded. If there are multiple options, they are
    placed one after each other in the header. At the end of all the options, in a
    Hop-By-Hop Options or Destination Options extension header, a device may place
    padding to ensure that the header is a multiple of eight bytes in length.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Two IPv6 extension header types, Hop-By-Hop Options and Destination
    Options, are used to carry arbitrary optional information in IPv6 datagrams. Each
    consists of a set of variable-length options that are defined using three subfields
    that indicate the option''s type, length, and value.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Internet Protocol version 6 (IPv6) changes many of the operating details of
    IP, but most of the basics are the same. In particular, devices still need to
    deliver datagrams over an internetwork that may use different underlying network
    technologies. This means that we must be concerned here, as we were in IPv4, with
    the mechanics of datagram sizing, handling fragmentation and reassembly, and dealing
    with issues related to routing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I complete the discussion of IPv6 by examining these matters,
    with an eye toward contrasting how they work in IPv6\. This includes a look at
    IPv6 datagram sizing, changes to the maximum transmission unit (MTU), and fragmentation
    and reassembly. I also briefly discuss areas where IPv6 routing is performed in
    the same way as in IPv4, as well as where routing has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of IPv6 Datagram Sizing and Fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The job of IP is to convey messages across an internetwork of connected networks.
    When datagrams are sent between hosts on distant networks, they are carried along
    their journey by routers, one hop at a time, over many physical network links.
    On each step of this journey, the datagram is encoded in a data link layer frame
    for transmission.
  prefs: []
  type: TYPE_NORMAL
- en: In order for a datagram to be successfully carried along a route, its size must
    be small enough to fit within the lower-layer frame at each step of the way. The
    term *maximum transmission unit (MTU)* describes the size limit for any given
    physical network. If a datagram is too large for the MTU of a network, it must
    be broken into pieces—a process called *fragmentation*—and then the pieces are
    *reassembled* at the destination device. This has been a requirement since IPv4,
    and I explain the concepts and issues related to datagram size, MTUs, fragmentation,
    and reassembly in detail in the associated IPv4 discussion, in [Chapter 22](ch22.html
    "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY").
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these issues apply to sending datagrams in IPv6 as much as they did
    in IPv4\. However, as in other areas of the protocol, some important details of
    how fragmentation and reassembly are done have changed. These changes were made
    to improve the efficiency of the routing process and to reflect the realities
    of current networking technologies: Most can handle average IP datagrams without
    needing fragmentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important differences between IPv4 and IPv6 with respect to datagram
    size, MTU, and fragmentation and reassembly are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased Default MTU** In IPv4, the minimum MTU that routers and physical
    links were required to handle was 576 bytes. In IPv6, all links must handle a
    datagram size of at least 1280 bytes. This more than doubling in size improves
    efficiency by increasing the ratio of maximum payload to header length and reduces
    the frequency with which fragmentation is required.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elimination of en Route Fragmentation** In IPv4, datagrams may be fragmented
    by either the source device or by routers during delivery. In IPv6, only the source
    node can fragment; routers do not. The source must fragment to the size of the
    smallest MTU on the route before transmission. This has both advantages and disadvantages,
    as you will see. Reassembly is still done only by the destination, as in IPv4.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MTU Size Error Feedback** Since routers cannot fragment datagrams, they must
    drop them if they are forced to try to send a too-large datagram over a physical
    link. Using the Internet Control Message Protocol version 6 (ICMPv6; see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")), a feedback process has been
    defined that allows routers to tell source devices that they are using datagrams
    that are too large for the route.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Path MTU Discovery** Since source devices must decide on the correct size
    of fragments, it is helpful if they have a mechanism for determining what this
    should be. This capability is provided through a special technique called *Path
    MTU Discovery*, which was originally defined for IPv4 but has been refined for
    IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Movement of Fragmentation Header Fields** To reflect the decreased importance
    of fragmentation in IPv4, the permanent fields related to the process that were
    in the IPv4 header have been farmed out to a Fragment extension header and are
    included only when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Implications of IPv6's Source-Only Fragmentation Rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I find the changes in the fragmentation and reassembly process interesting.
    While many other changes in IPv6 represent a shift in responsibility for functions
    from host devices to routers, this one is the opposite. In IPv4, a source node
    can send a datagram of any size that its local link can handle, and let the routers
    take care of fragmenting it as needed. This seems like a sensible model; nodes
    communicate on a large, virtual network, and the details of splitting messages
    as needed for physical links are handled invisibly.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is that it represents a performance drag on routing. It
    is much faster for a router to forward a datagram intact than to spend time fragmenting
    it. In some cases, fragmentation would need to occur multiple times during the
    transmission of a datagram, and remember that this must happen for every datagram
    on a route. It is a lot more efficient for the source to just send datagrams that
    are the right size in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there''s a problem here: How does the source know what size to use?
    The source has no understanding of the physical networks used by the route datagrams
    will take to a destination; in fact, it doesn''t even know what the routes are!
    Thus, it has no idea of what MTU would be best. It has two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the Default MTU** The first option is simply to use the default MTU of
    1280 bytes, which all physical networks must be able to handle. This is a good
    choice, especially for short communications or for sending small amounts of data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Path MTU Discovery** The alternative is to make use of the Path MTU Discovery
    feature, as described later in the chapter. This feature, defined in RFC 1981,
    defines a method whereby a node sends messages over a route to determine what
    the overall minimum MTU for the path is. It''s a technique that''s very similar
    to the way it is done in IPv4, as discussed in [Chapter 22](ch22.html "Chapter 22. IP
    DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY").'
  prefs: []
  type: TYPE_NORMAL
- en: Since routers can't fragment in IPv6, if a datagram is sent by a source that
    is too large for a router, it must drop the datagram. It will then send back to
    the source feedback about this occurrence, in the form of an ICMPv6 Packet Too
    Big message. This tells the source that its datagram was dropped and that it must
    fragment (or reduce the size of its fragments).
  prefs: []
  type: TYPE_NORMAL
- en: This feedback mechanism is also used in discovering path MTUs. The source node
    sends a datagram that has the MTU of its local physical link, since that represents
    an upper bound on the MTU of the path. If this goes through without any errors,
    it knows it can use that value for future datagrams to that destination. If it
    gets back any Packet Too Big messages, it tries again using a smaller datagram
    size. The advantage of this over the 1280 default is that it may allow a large
    communication to proceed with a higher MTU, which improves performance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In IPv6, fragmentation is performed only by the device that''s
    sending a datagram, not by routers. If a router encounters a datagram too large
    to send over a physical network with a small MTU, the router sends an ICMPv6 *Packet
    Too Big* message back to the source of the datagram. This can be used as part
    of a process called *Path MTU Discovery* to determine the minimum MTU of an entire
    route.'
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of the decision to only fragment at the source is that it introduces
    the potential for problems if there is more than one route between devices or
    if routes change. In IPv4, fragmentation is dynamic and automatic; it happens
    on its own and adjusts as routes change. Path MTU Discovery is a good feature,
    but it is static. It requires that hosts keep track of MTUs for different routes
    and update them regularly. IPv6 does this by redoing Path MTU Discovery if a node
    receives a Packet Too Big message on a route for which it has previously performed
    Path MTU Discovery. However, this takes time.
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 Fragmentation Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The actual mechanics of fragmentation in IPv6 are similar to those in IPv4,
    with the added complication that extension headers must be handled carefully.
    For purposes of fragmentation, IPv6 datagrams are broken into the following two
    pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unfragmentable Part** This includes the main header of the original datagram,
    as well as any extension headers that need to be present in each fragment. This
    means the main header, and any of the following headers, if present: Hop-By-Hop
    Options, Destination Options (for those options to be processed by devices along
    a route), and Routing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fragmentable Part** This includes the data portion of the datagram, along
    with the other extension headers, if present—Authentication Header, Encapsulating
    Security Payload, and/or Destination Options (for options to be processed only
    by the final destination).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unfragmentable Part must be present in each fragment, while the Fragmentable
    Part is split up among the fragments. So to fragment a datagram, a device creates
    a set of fragment datagrams, each of which contains the following, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unfragmentable Part** The full Unfragmentable Part of the original datagram,
    with its Payload Length changed to the length of the fragment datagram.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fragment Header** A Fragment header with the Fragment Offset, Identification,
    and M flags set in the same way they are used in IPv4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fragment** A fragment of the Fragmentable Part of the original datagram.
    Note that each fragment must have a length that is a multiple of 8 bytes, because
    the value in the Fragment Offset field is specified in multiples of 8 bytes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Fragmentation is done in IPv6 in a manner similar to that of
    IPv4, except that extension headers must be handled specially. Certain extension
    headers are considered *unfragmentable* and appear in each fragment; others are
    fragmented along with the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an example to illustrate how IPv6 fragmentation works. Suppose you
    have an IPv6 datagram exactly 320 bytes wide, consisting of a 40-byte IP header,
    four 30-byte extension headers, and 160 bytes of data. Two of the extension headers
    are unfragmentable, while two are fragmentable. (In practice you would never need
    to fragment such a small datagram, but I am trying to keep the numbers simple.)
    Suppose you need to send this over a link with an MTU of only 230 bytes. You would
    actually require three fragments, not the two you might expect, because of the
    need to put the two 30-byte unfragmentable extension headers in each fragment,
    and the requirement that each fragment be a length that is a multiple of 8\. Here
    is how the fragments would be structured (see [Figure 27-1](ch27s03.html#ipv6_datagram_fragmentation_in_this_illu
    "Figure 27-1. IPv6 datagram fragmentation In this illustration, a 320-byte IPv6
    datagram, containing four 30-byte extension headers, is broken into three fragments.
    The sizes of the fields are shown to scale. The Unfragmentable Part, shown in
    lighter shading on the left, begins each fragment, followed by the Fragment header.
    Then, portions of the Fragmentable Part are placed into each fragment in sequence.
    The Authentication and Destination Options extension headers are part of the Fragmentable
    Part, so that they appear as part of the first fragment.")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**First Fragment** The first fragment would consist of the 100-byte Unfragmentable
    Part, followed by a 30-byte Fragment header and the first 96 bytes of the Fragmentable
    Part of the original datagram. This would contain the two fragmentable extension
    headers and the first 36 bytes of data. This leaves 124 bytes of data to send.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Second Fragment** This would also contain the 100-byte Unfragmentable Part,
    followed by a Fragment header, and 96 bytes of data (bytes 36 to 131). This would
    leave 28 bytes of data remaining.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Third Fragment** The last fragment would contain the 100-byte Unfragmentable
    Part, a Fragment header, and the final 28 bytes of data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![IPv6 datagram fragmentation In this illustration, a 320-byte IPv6 datagram,
    containing four 30-byte extension headers, is broken into three fragments. The
    sizes of the fields are shown to scale. The Unfragmentable Part, shown in lighter
    shading on the left, begins each fragment, followed by the Fragment header. Then,
    portions of the Fragmentable Part are placed into each fragment in sequence. The
    Authentication and Destination Options extension headers are part of the Fragmentable
    Part, so that they appear as part of the first fragment.](httpatomoreillycomsourcenostarchimages287901.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-1. IPv6 datagram fragmentation In this illustration, a 320-byte IPv6
    datagram, containing four 30-byte extension headers, is broken into three fragments.
    The sizes of the fields are shown to scale. The Unfragmentable Part, shown in
    lighter shading on the left, begins each fragment, followed by the Fragment header.
    Then, portions of the Fragmentable Part are placed into each fragment in sequence.
    The Authentication and Destination Options extension headers are part of the Fragmentable
    Part, so that they appear as part of the first fragment.
  prefs: []
  type: TYPE_NORMAL
- en: The M (More Fragments) flag would be set to 1 in the first two fragments and
    0 in the third, and the Fragment Offset values would be set appropriately. See
    [Chapter 22](ch22.html "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY"),
    which covers IPv4 fragmentation, for more on how these fields are used.
  prefs: []
  type: TYPE_NORMAL
- en: The receiving device reassembles by taking the Unfragmentable Part from the
    first fragment and then assembling the Fragment data from each fragment in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Datagram Delivery and Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IP functions such as addressing, datagram encapsulation, and, if necessary,
    fragmentation and reassembly, all lead up to the ultimate objective of the protocol:
    the actual delivery of datagrams from a source device to one or more destination
    devices. Most of the concepts related to how datagram delivery is accomplished
    in IPv6 are the same as in IPv4:'
  prefs: []
  type: TYPE_NORMAL
- en: Datagrams are delivered directly when the source and destination nodes are on
    the same network. When they are on different networks, delivery is indirect, using
    routing to the destination's network, and then direct to the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routers look at IP addresses and determine which portion is the network identifier
    (network ID) and which is the host identifier (host ID). IPv6 does this in the
    same basic way as in classless IPv4, despite the fact that IPv6 unicast addresses
    are assigned using a special hierarchical format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing is still done on a next-hop basis, with sources generally not knowing
    how datagrams get from point A to point B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing is performed by devices called *routers*, which maintain tables of routes
    that tell them where to forward datagrams to reach different destination networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing protocols are used to allow routers to exchange information about routes
    and networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the changes in routing in IPv6 are directly related to changes in other
    areas of the protocol, as discussed in the previous chapters. Some of the main
    issues of note related to routing and routers in IPv6 include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical Routing and Aggregation** One of the goals of the structure
    used for organizing unicast addresses was to improve routing. The unicast addressing
    format is designed to provide a better match between addresses and Internet topology
    and to facilitate route aggregation. Classless addressing using CIDR in IPv4 was
    an improvement but lacked any formal mechanism for creating a scalable hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scoped Local Addresses** Local-use addresses, including site-local and link-local
    addresses, are defined in IPv6, and routers must be able to recognize them. They
    must route them or *not* route them when appropriate. Multicast addresses also
    have various levels of scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast and Anycast Routing** Multicast is standard in IPv6, not optional
    as in IPv4, so routers must support it. Anycast addressing is a new type of addressing
    in IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Support Functions** Capabilities must be added to routers to support
    new features in IPv6\. For example, routers play a key role in implementing autoconfiguration
    without the help of a server and Path MTU Discovery in the new IPv6 fragmentation
    scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Routing Protocols** Routing protocols such as RIP must be updated to
    support IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transition Issues** Last, but certainly not least, routers play a major role
    in supporting the transition from IPv4 to IPv6\. They will be responsible for
    connecting together IPv6 "islands" and performing translation to allow IPv4 and
    IPv6 devices to communicate with each other during the multiyear migration to
    the new protocol.'
  prefs: []
  type: TYPE_NORMAL
